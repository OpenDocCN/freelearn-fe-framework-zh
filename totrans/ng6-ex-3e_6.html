<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Angular Directives in Depth</h1>
                
            
            <article>
                
<p class="calibre3"><strong class="calibre5">Directives</strong> are everywhere. They are the fundamental building blocks of Angular. Each extension to the application has resulted in us creating new <strong class="calibre5">component directives</strong>. These component directives have further consumed <strong class="calibre5">attribute directives</strong> (such as <kbd class="calibre13">NgClass</kbd> and <kbd class="calibre13">NgStyle</kbd>) and <strong class="calibre5">structural directives</strong> (such as <kbd class="calibre13">NgIf</kbd> and <kbd class="calibre13">NgFor</kbd>) to extend their behavior.</p>
<p class="calibre3">While we have built a number of component directives and a lone attribute directive, there are still some concepts of directive building that are worth exploring. This is especially true for attribute and structural directives, which we are yet to cover in detail.</p>
<p class="calibre3">The topics we will cover in this chapter include the following:</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Building directives</strong>: We build multiple directives and learn where directives are useful, how they differ from components, and how directives communicate with each other and/or their host component. We explore all directive types, including <em class="calibre2">component directives</em>, <em class="calibre2">attribute directives</em>, and <em class="calibre2">structural directives</em>.</li>
<li class="calibre12"><strong class="calibre1">Asynchronous validation</strong>: Angular makes it easy to validate rules that require server interaction and hence are async in nature. We will build our first async validator in this chapter.</li>
<li class="calibre12"><strong class="calibre1">Using renderer for view manipulation</strong>: Renderer allows view manipulation in a platform-agnostic way. We will utilize renderer for the busy indicator directive and learn about its API.</li>
<li class="calibre12"><strong class="calibre1">Host binding</strong>: Host binding allows directives to communicate with their <em class="calibre2">host element</em>. This chapter covers how to utilize such bindings for directives.</li>
<li class="calibre12"><strong class="calibre1">Directive injection</strong>: The Angular DI framework allows directive injection based on where in the HTML hierarchy the directives are declared. We will cover multiple scenarios pertaining to such injections.</li>
<li class="calibre12"><strong class="calibre1">Working with view children and content children</strong>: Components have the capability to include external view templates into their own view. How to work with the injected content is something we will cover here.</li>
</ul>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Understanding the NgIf platform directive</strong>: We will look under the hood of the <kbd class="calibre13">NgIf</kbd> platform directive and try to comprehend the working of <em class="calibre2">structural directives</em> such as <kbd class="calibre13">NgIf</kbd>.</li>
<li class="calibre12"><strong class="calibre1">View encapsulation of Angular components</strong>: We will learn how Angular uses concepts derived from <em class="calibre2">web components</em> to support view and style encapsulation.</li>
</ul>
<p class="calibre3">Let's start the chapter by reiterating the basic classification of directives.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Classifying directives</h1>
                
            
            <article>
                
<p class="calibre3">Angular directives integrate the HTML view with the application state. Directives help us manipulate views as application state changes and respond to view updates with little or no manual interaction with the actual DOM.</p>
<p class="calibre3">Depending upon how they affect the view, these directives are further classified into three types.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Components</h1>
                
            
            <article>
                
<p class="calibre3"><strong class="calibre5">Component directives</strong> or <strong class="calibre5">components</strong> are directives with an encapsulated view. In Angular, when we build UI widgets, we are building components. We have already built a lot of them, such as <kbd class="calibre13">WorkoutRunnerComponent</kbd>, <kbd class="calibre13">WorkoutAudioComponent</kbd>, <kbd class="calibre13">VideoPlayerComponent</kbd>, and many more!</p>
<p class="calibre3">An important point to realize here is that the view is bound to the component implementation and it can only work with properties and events defined on the backing component.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Attribute directives</h1>
                
            
            <article>
                
<p class="calibre3"><strong class="calibre5">Attribute directives</strong>, on the other hand, extend an existing component or HTML element. Consider them as behavioral extensions to these components/elements.</p>
<p class="calibre3">Since directives are behavioral extensions for predefined elements, every directive building exercise involves manipulating the state of the components/elements on which these directives are applied. The <kbd class="calibre13">MyAudioDirective</kbd> built in <span class="calibre6"><a href="" class="calibre10">Chapter 3</a></span>, <em class="calibre17">More Angular 2 – SPA, Routing, and Data Flows in Depth</em>, does the same. The directive wraps the HTML5 <em class="calibre17">audio</em> element (<kbd class="calibre13">HTMLAudioElement</kbd>) for easy usage. Platform directives such as <kbd class="calibre13">ngStyle</kbd> and <kbd class="calibre13">ngClass</kbd> also function in a similar manner.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Structural directives</h1>
                
            
            <article>
                
<p class="calibre3"><strong class="calibre5">Structural directives</strong>, such as attribute directives, do not define their own view. Instead, they work on the <em class="calibre17">view template</em> (HTML fragment) provided to them as part of their usage. More often than not, the purpose of a structural directive is to show/hide or clone the template view provided to it. Platform directives such as <kbd class="calibre13">NgFor</kbd>, <kbd class="calibre13">NgIf</kbd>, and <kbd class="calibre13">NgSwitch</kbd> are the prime examples in this category.</p>
<p class="calibre3">I hope this quick refresher on directives is enough to get us started. We'll begin our pursuit by extending the workout builder validations and build an async validator directive.</p>
<div class="packt_infobox">We are starting from where we left off in <span class="packt_screen"><a href="" class="calibre21">Chapter 5</a></span><span class="packt_screen">, </span><em class="calibre31">Supporting Server Data Persistence</em>. The Git branch <kbd class="calibre24">checkpoint5.4</kbd> can serve as the base for this chapter. The code is also available on GitHub (<a href="https://github.com/chandermani/angular6byexample" class="calibre21"><span class="packt_screen">https://github.com/chandermani/angular6byexample</span></a>) for everyone to download. Checkpoints are implemented as branches in GitHub. If you are not using Git, download the snapshot of <kbd class="calibre24">checkpoint5.4</kbd> (a ZIP file) from the GitHub location <a href="http://bit.ly/ng6be-checkpoint-5-4" class="calibre21">http://bit.ly/ng6be-checkpoint-5-4</a><span class="packt_screen"/>. Refer to the <kbd class="calibre24">README.md</kbd> file in the <kbd class="calibre24">trainer</kbd> folder when setting up the snapshot for the first time. Also, remember to update the API key in <kbd class="calibre24">services/workout-service.ts</kbd> with your own API key.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Building a remote validator directive</h1>
                
            
            <article>
                
<p class="calibre3">We ended <span class="calibre6"><a href="" class="calibre10">Chapter 5</a></span>, <em class="calibre17">Supporting Server Data Persistence</em>, with <em class="calibre17">Workout Runner</em> capable of managing workouts in the MongoDB store. Since each workout should have a unique name, we need to enforce the uniqueness constraint. Therefore, while creating/editing a workout, every time the user changes the workout name, we can query MongoDB to verify that the name already exists.</p>
<p class="calibre3">As is the case with any remote invocation, this check too is asynchronous, and hence it requires a <em class="calibre17">remote validator</em>. We are going to build this remote validator using Angular's <em class="calibre17">async validator support</em>.</p>
<p class="calibre3"><strong class="calibre5">Async validators</strong> are similar to standard custom validators, except that instead of returning a key-value object map or null, the return value of a validation check is a <strong class="calibre5">promise</strong>. This promise is eventually resolved with the validation state being set (if there is an error), or null otherwise (on validation success).</p>
<p class="calibre3">We are going to create a validation directive that does workout name checks. There are two possible implementation approaches for such a directive:</p>
<ul class="calibre11">
<li class="calibre12">We can create a directive specifically for unique name validation</li>
<li class="calibre12">We can create a generic directive that can perform any remote validation</li>
</ul>
<div class="packt_tip"><span class="packt_screen">Validation directives</span><br class="calibre27"/>
While we are building a validation directive here, we could have built a standard custom validator class. The advantage of creating a directive is that it allows us to incorporate the directive in a template-driven form approach, where the directive can be embedded in the view HTML. Or, if the form has been generated using a model (reactive approach), we can directly use the validator class while creating the <kbd class="calibre24">Control</kbd> objects.</div>
<p class="calibre3">At first, the requirement of checking duplicate names against a data source (the <em class="calibre17">mLab</em> database) seems to be too a specific requirement and cannot be handled by a generic validator. But with some sensible assumptions and design choices, we can still implement a validator that can handle all types of remote validation, including workout name validation.</p>
<p class="calibre3">The plan is to create a validator that externalizes the actual validation logic. The directive will take the validation function as input. This implies that the actual validation logic is not a part of the validator, but a part of the component that actually needs to validate input data. The job of the directive is just to call the function and return the appropriate error keys based on the function's return value.</p>
<p class="calibre3">Let's put this theory into practice and build our remote validation directive, aptly named <kbd class="calibre13">RemoteValidatorDirective</kbd>.</p>
<div class="packt_infobox">The companion code base for the following section is Git branch <kbd class="calibre24">checkpoint6.1</kbd>. You can work along with us or check out the implementation available in the aforementioned folder. Or if you are not using Git, download the snapshot of <kbd class="calibre24">checkpoint6.1</kbd> (a ZIP file) from GitHub location <span class="packt_screen"><a href="http://bit.ly/ng2be-checkpoint6-1" class="calibre21">http://bit.ly/ng2be-checkpoint6-1</a></span>. Refer to the <kbd class="calibre24">README.md</kbd> file in the <kbd class="calibre24">trainer</kbd> folder when setting up the snapshot for the first time.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Validating workout names using async validators</h1>
                
            
            <article>
                
<p class="calibre3">Like custom validators, async validators inherit from the same <kbd class="calibre13">Validator</kbd> class too; but this time, instead of returning an object map, async validators return a <kbd class="calibre13">Promise</kbd>.</p>
<p class="calibre3">Let's look at the definition of the validator. Copy the definition of the validator from the GitHub (<a href="http://bit.ly/ng6be-6-1-remote-validator-directive-ts" class="calibre10">http://bit.ly/ng6be-6-1-remote-validator-directive-ts</a>) folder and add it to the <kbd class="calibre13">shared</kbd> module folder. The validator definition looks as follows:</p>
<pre class="calibre19">import { Directive, Input } from '@angular/core';<br class="title-page-name"/>import { NG_ASYNC_VALIDATORS, FormControl } from '@angular/forms';<br class="title-page-name"/><br class="title-page-name"/>@Directive({<br class="title-page-name"/>  selector: '[abeRemoteValidator][ngModel]',<br class="title-page-name"/>  providers: [{ provide: NG_ASYNC_VALIDATORS, useExisting: RemoteValidatorDirective, multi: true }]<br class="title-page-name"/>})<br class="title-page-name"/>export class RemoteValidatorDirective {<br class="title-page-name"/><br class="title-page-name"/>  @Input() abeRemoteValidator: string;<br class="title-page-name"/>  @Input() validateFunction: (value: string) =&gt; Promise&lt;boolean&gt;;<br class="title-page-name"/><br class="title-page-name"/>  validate(control: FormControl): { [key: string]: any } {<br class="title-page-name"/>    const value: string = control.value;<br class="title-page-name"/>    return this.validateFunction(value).then((result: boolean) =&gt; {<br class="title-page-name"/>      if (result) {<br class="title-page-name"/>        return null;<br class="title-page-name"/>      }<br class="title-page-name"/>      else {<br class="title-page-name"/>        const error: any = {};<br class="title-page-name"/>        error[this.abeRemoteValidator] = true;<br class="title-page-name"/>        return error;<br class="title-page-name"/>      }<br class="title-page-name"/>    });<br class="title-page-name"/>  }<br class="title-page-name"/>} </pre>
<p class="calibre3">Do remember to export this directive from the shared module, allowing us to use it in the workout builder module.</p>
<p class="calibre3">Since we are registering the validator as a directive instead of registering using a <kbd class="calibre13">FormControl</kbd> instance (generally used when building forms with a <em class="calibre17">reactive approach</em>), we need the extra provider configuration setting (added in the preceding <kbd class="calibre13">@Directive</kbd> metadata) by using this syntax:</p>
<pre class="calibre19"> providers:[{ provide: NG_ASYNC_VALIDATORS, useExisting: RemoteValidatorDirective,  multi: true }] </pre>
<p class="calibre3">This statement registers the validator with the existing async validators.</p>
<div class="packt_infobox">The strange directive selector, <kbd class="calibre24">selector: `[abeRemoteValidator][ngModel]`</kbd>, used in the preceding code will be covered in the next section, where we will build a busy indicator directive.</div>
<p class="calibre3">Before we dig into the validator implementation, let's add it to the workout name input. This will help us correlate the behavior of the validator with its usage.</p>
<p class="calibre3">Update the workout name input (<kbd class="calibre13">workout.component.html</kbd>) with the validator declaration:</p>
<pre class="calibre19">&lt;input type="text" name="workoutName" ... 
<strong class="calibre1">  abeRemoteValidator="workoutname" </strong><strong class="calibre1">  [validateFunction]="validateWorkoutName"&gt;<br class="title-page-name"/></strong></pre>
<div class="packt_tip"><span class="packt_screen">Prefixing the directive selector</span><br class="calibre27"/>
Always prefix your directives with an identifier (<kbd class="calibre24">abe</kbd> as you just saw) that distinguishes them from framework directives and other third-party directives.</div>
<p class="calibre3"><strong class="calibre5">Note</strong>: If the <kbd class="calibre13">ngModelOptions</kbd>, <kbd class="calibre13">updateOn</kbd> is set to <kbd class="calibre13">submit,</kbd> change it to <kbd class="calibre13">blur</kbd>.</p>
<p class="calibre3">The directive implementation takes two inputs: the <em class="calibre17">validation key</em> through directive property <kbd class="calibre13">abeRemoveValidator,</kbd> used to set the <em class="calibre17">error key</em>, and the <em class="calibre17">validation function</em> (<kbd class="calibre13">validateFunction</kbd>), called to validate the value of the control. Both inputs are annotated with the <kbd class="calibre13">@Input</kbd> decorator.</p>
<div class="packt_infobox">The input parameter <kbd class="calibre24">@Input("validateFunction") validateFunction: (value: string) =&gt; Promise&lt;boolean&gt;;</kbd>, binds to a function, not a standard component property. We are allowed to treat the function as a property due to the nature of the underlying language, TypeScript (as well as JavaScript).</div>
<p class="calibre3">When the async validation fires (on a change of <kbd class="calibre13">input</kbd>), Angular invokes the function, passing in the underlying <kbd class="calibre13">control</kbd>. As the first step, we pull the current input value and then invoke the <kbd class="calibre13">validateFunction</kbd> function with this input. The <kbd class="calibre13">validateFunction</kbd> returns a promise, which should eventually resolve to <kbd class="calibre13">true</kbd> or <kbd class="calibre13">false</kbd>:</p>
<ul class="calibre11">
<li class="calibre12">If the promise resolves to <kbd class="calibre13">true</kbd>, the validation is successful, the promise callback function returns <kbd class="calibre13">null</kbd>.</li>
<li class="calibre12">If it is <kbd class="calibre13">false</kbd>, the validation has failed, and an error key-value map is returned. The <em class="calibre2">key</em> here is the string literal that we set when using the validator (<kbd class="calibre13">a2beRemoteValidator="workoutname"</kbd>).</li>
</ul>
<p class="calibre3">This <em class="calibre17">key</em> comes in handy when there are multiple validators declared on the input, allowing us to identify validations that have failed.</p>
<p class="calibre3">To the workout component next add a validation message for this failure too. Add this label declaration after the existing validation <kbd class="calibre13">label</kbd> for <em class="calibre17">workout name</em>:</p>
<pre class="calibre19">&lt;label *ngIf="name.control.hasError('workoutname')" class="alert alert-danger validation-message"&gt;A workout with this name already exists.&lt;/label&gt; </pre>
<p class="calibre3">And then wrap these two labels inside a <kbd class="calibre13">div</kbd>, as we do for <em class="calibre17">workout title</em> error labels.</p>
<p class="calibre3">The <kbd class="calibre13">hasError</kbd> function checks whether the <kbd class="calibre13">'workoutname'</kbd> validation key is present.</p>
<p class="calibre3">The last missing piece of this implementation is the actual validation function we assigned when applying the directive (<kbd class="calibre13">[validateFunction]="<strong class="calibre1">validateWorkoutName</strong>"</kbd>), but never implemented.</p>
<p class="calibre3">Add the <kbd class="calibre13">validateWorkoutName</kbd> function to <kbd class="calibre13">workout.component.ts</kbd>:</p>
<pre class="calibre19">validateWorkoutName = (name: string): Promise&lt;boolean&gt; =&gt; {<br class="title-page-name"/>    if (this.workoutName === name) { return Promise.resolve(true); }<br class="title-page-name"/>    return this.workoutService.getWorkout(name).toPromise()<br class="title-page-name"/>      .then((workout: WorkoutPlan) =&gt; {<br class="title-page-name"/>        return !workout;<br class="title-page-name"/>      }, error =&gt; {<br class="title-page-name"/>        return true;<br class="title-page-name"/>      });<br class="title-page-name"/>  }  </pre>
<p class="calibre3">Before we explore what the preceding function does, we need to do some more fixes on the <kbd class="calibre13">WorkoutComponent</kbd> class. The <kbd class="calibre13">validateWorkoutName</kbd> function is dependent on <kbd class="calibre13">WorkoutService</kbd> to get a workout with a specific name. Let's inject the service in the constructor and add the necessary import in the imports section:</p>
<pre class="calibre19">import { WorkoutService }  from "../../core/workout.service"; 
... 
constructor(... , private workoutService: WorkoutService) { </pre>
<p class="calibre3">Then declare variables <kbd class="calibre13">workoutName</kbd> and <kbd class="calibre13">queryParamsSub</kbd>:</p>
<pre class="calibre19">private workoutName: string;<br class="title-page-name"/>queryParamsSub: Subscription</pre>
<p class="calibre3">And add this statement to <kbd class="calibre13">ngOnInit</kbd>:</p>
<pre class="calibre19">this.queryParamsSub = this.route.params.subscribe(params =&gt; this.workoutName = params['id']); </pre>
<p class="calibre3">The preceding statement set the current workout name by watching (subscribing) over the observable <kbd class="calibre13">route.params</kbd> service. <kbd class="calibre13">workoutName</kbd> is used to skip workout name validation for an existing workout if the original workout name is used.</p>
<p class="calibre3">The subscription created previously needs to be clear to avoid memory leak, hence add this line to the <kbd class="calibre13">ngDestroy</kbd> function:</p>
<pre class="calibre19">this.queryParamsSub.unsubscribe();</pre>
<p class="calibre3">The reason for defining the <kbd class="calibre13">validateWorkoutName</kbd> function as an <em class="calibre17">instance function</em> (the use of the <em class="calibre17">arrow operator</em>) instead of defining it as a standard function (which declares the function on the <em class="calibre17">prototype</em>) is the <kbd class="calibre13">'this'</kbd> scoping issue.</p>
<p class="calibre3">Look at the validator function invocation inside <kbd class="calibre13">RemoteValidatorDirective</kbd> (declared using <kbd class="calibre13">@Input("validateFunction") validateFunction;</kbd>):</p>
<pre class="calibre19">return this.validationFunction(value).then((result: boolean) =&gt; { ... }); </pre>
<p class="calibre3">When the function (named <kbd class="calibre13">validateFunction</kbd>) is invoked, the <kbd class="calibre13">this</kbd> reference is bound to <kbd class="calibre13">RemoteValidatorDirective</kbd> instead of the <kbd class="calibre13">WorkoutComponent</kbd>. Since <kbd class="calibre13">execute</kbd> is referencing the <kbd class="calibre13">validateWorkoutName</kbd> function in the preceding setup, any access to <kbd class="calibre13">this</kbd> inside <kbd class="calibre13">validateWorkoutName</kbd> is problematic.</p>
<p class="calibre3">This causes the <kbd class="calibre13">if (this.workoutName === name)</kbd> statement inside <kbd class="calibre13">validateWorkoutName</kbd> to fail, as <kbd class="calibre13">RemoteValiatorDirective</kbd> does not have a <kbd class="calibre13">workoutName</kbd> instance member. By defining <kbd class="calibre13">validateWorkoutName</kbd> as an instance function, the <em class="calibre17">TypeScript</em> compiler <em class="calibre17">creates a closure</em> around the value of <kbd class="calibre13">this</kbd> when the function is defined.</p>
<p class="calibre3">With the new declaration, <kbd class="calibre13">this</kbd> inside <kbd class="calibre13">validateWorkoutName</kbd> always points to the <kbd class="calibre13">WorkoutComponent</kbd> irrespective of how the function gets invoked.</p>
<p class="calibre3">We can also look at the compiled JavaScript for <kbd class="calibre13">WorkoutComponent</kbd> to know how the closure works with respect to <kbd class="calibre13">validateWorkoutName</kbd>. The parts of the generated code that interest us are as follows:</p>
<pre class="calibre19">function WorkoutComponent(...) { 
<strong class="calibre1">  var _this = this;</strong> 
  ... 
  this.validateWorkoutName = function (name) { 
<strong class="calibre1">    if (_this.workoutName === name)</strong> 
      return Promise.resolve(true); </pre>
<p class="calibre3">If we look at the validation function implementation, we see that it involves querying <em class="calibre17">mLab</em> for a specific workout name. The <kbd class="calibre13">validateWorkoutName</kbd> function returns <kbd class="calibre13">true</kbd> when a workout with the same name is not found and <kbd class="calibre13">false</kbd> when a workout with the same name is found (actually a <em class="calibre17">promise</em> is returned).</p>
<div class="packt_infobox">The <kbd class="calibre24">getWorkout</kbd> function on <kbd class="calibre24">WorkoutService</kbd> returns an <em class="calibre31">observable,</em> but we convert it into a <em class="calibre31">promise</em> by calling the <kbd class="calibre24">toPromise</kbd> function on the observable.</div>
<p class="calibre3">The validation directive can now be tested. Create a new workout and enter an existing workout name such as <kbd class="calibre13">7minworkout</kbd>. See how the validation error message shows up eventually:</p>
<div class="packt_figure"><img src="../images/00059.jpeg" class="calibre63"/></div>
<p class="calibre3">Excellent! It looks great, but there is still something missing. The user is not informed that we are validating the workout name. We can improve this experience.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Building a busy indicator directive</h1>
                
            
            <article>
                
<p class="calibre3">While the workout name is being validated remotely, we want the user to be aware of the activity in the background. A visual clue around the input box while the remote validation happens should serve the purpose.</p>
<p class="calibre3">Think carefully; there is an input box with an asynchronous validator (which does remote validation) and we want to adorn the input box with a visual clue during validation. Seems like a common pattern to solve? Indeed it is, so let's create another directive!</p>
<p class="calibre3">But before we start the implementation, it is imperative to understand that we are not in it alone. The busy indicator directive requires the help of another directive, <kbd class="calibre13">NgModel</kbd>. We have already used the <kbd class="calibre13">NgModel</kbd> directive on <kbd class="calibre13">input</kbd> elements in <span class="calibre6"><a href="" class="calibre10">Chapter 4</a></span>, <em class="calibre17">Building Personal Trainer</em>. <kbd class="calibre13">NgModel</kbd> helps us track the input element state. The following example is taken from <span class="calibre6"><a href="" class="calibre10">Chapter 4</a></span>, <em class="calibre17">Building Personal Trainer</em>, and it highlights how <kbd class="calibre13">NgModel</kbd> helps us validate inputs:</p>
<pre class="calibre19">&lt;input type="text" name="workoutName" #name="ngModel"  class="form-control" id="workout-name" ... [(ngModel)]="workout.name" required&gt; 
... 
&lt;label *ngIf="name.control.hasError('required') &amp;&amp; (name.touched || submitted)" class="alert alert-danger"&gt;Name is required&lt;/label&gt;  </pre>
<p class="calibre3">Even the unique workout name validation done in the previous section employs the same technique of using <kbd class="calibre13">NgModel</kbd> to check the validation state.</p>
<p class="calibre3">Let's begin with defining the outline of the directive. Create a <kbd class="calibre13">busy-indicator.directive.ts</kbd> file using the CLI generator in the <kbd class="calibre13">src/app/shared</kbd> folder:</p>
<pre class="calibre19"><strong class="calibre1">ng generate directive busy-indicator</strong></pre>
<p class="calibre3">Also, export it by adding the directive to the <kbd class="calibre13">exports</kbd> array in the shared module file <kbd class="calibre13">shared.module.ts</kbd>.</p>
<p class="calibre3">Next, update the directive's constructor with <kbd class="calibre13">NgModel</kbd> injection and import the <kbd class="calibre13">NgModel</kbd> reference from <kbd class="calibre13">@angular/forms</kbd>:</p>
<pre class="calibre19">constructor(private model: NgModel) { }</pre>
<p class="calibre3">This instructs Angular to inject the <kbd class="calibre13">NgModel</kbd> instance of the element on which the directive is declared. Remember that the <kbd class="calibre13">NgModel</kbd> directive is already present on <kbd class="calibre13">input</kbd> (<kbd class="calibre13">workoutname</kbd>):</p>
<pre class="calibre19"><strong class="calibre1">&lt;input... name="workoutName" #name="ngModel" [(ngModel)]="workout.name" ...&gt;</strong></pre>
<p class="calibre3">This is enough to integrate our new directive in the workout view, so let's do it quickly.</p>
<p class="calibre3">Open <kbd class="calibre13">workout.component.html</kbd> from <kbd class="calibre13">workout-builder</kbd> and add the busy indicator directive to the workout name <kbd class="calibre13">input</kbd>:</p>
<pre class="calibre19">&lt;input type="text" name="workoutName" ... abeBusyIndicator&gt; </pre>
<p class="calibre3">Create a new workout or open an existing one to see whether the <kbd class="calibre13">BusyIndicatorDirective</kbd> is loaded and the <kbd class="calibre13">NgModel</kbd> injection worked fine. This can be easily verified by putting a breakpoint inside the <kbd class="calibre13">BusyIndicatorDirective</kbd> constructor.</p>
<p class="calibre3">Angular injects the same <kbd class="calibre13">NgModel</kbd> instance into <kbd class="calibre13">BusyIndicatorDirective</kbd> that it created when it encountered <kbd class="calibre13">ngModel</kbd> on the input HTML.</p>
<p class="calibre3">You may be wondering what happens if we apply this directive on an input element that does not have the <kbd class="calibre13">ngModel</kbd> attribute, or as a matter of fact on any HTML element/component, such as this:</p>
<pre class="calibre19">&lt;div abeBusyIndicator&gt;&lt;/div&gt; 
&lt;input type="text" abeBusyIndicator&gt; </pre>
<p class="calibre3">Will the injection work?</p>
<p class="calibre3">Of course not! We can try it in the create workout view. Open <kbd class="calibre13">workout.component.html</kbd> and add the following <kbd class="calibre13">input</kbd> above the workout name <kbd class="calibre13">input</kbd>. Refresh the app:</p>
<pre class="calibre19">&lt;input type="text" name="workoutName1" a2beBusyIndicator&gt; </pre>
<p class="calibre3">Angular throws an exception, as follows:</p>
<pre class="calibre19"> <strong class="calibre1">EXCEPTION: No provider for NgModel! (BusyIndicatorDirective -&gt; NgModel)</strong></pre>
<p class="calibre3">How to avoid this? Well, Angular's DI can rescue us here as it allows us to declare an optional dependency.</p>
<div class="packt_infobox"><br class="calibre27"/>
Remove the <kbd class="calibre24">input</kbd> control that you just added before proceeding further.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Injecting optional dependencies with the @Optional decorator</h1>
                
            
            <article>
                
<p class="calibre3">Angular has an <kbd class="calibre13">@Optional</kbd> decorator, which when applied to a constructor argument instructs the Angular <em class="calibre17">injector</em> to inject <kbd class="calibre13">null</kbd> if the dependency is not found.</p>
<p class="calibre3">Hence, the busy indicator constructor can be written as follows:</p>
<pre class="calibre19">constructor(@Optional() private model: NgModel) { } </pre>
<p class="calibre3">Problem solved? Not really; as stated previously, we require the <kbd class="calibre13">NgModel</kbd> directive for <kbd class="calibre13">BusyIndicatorDirective</kbd> to work. So, while we have learned something new, it is not very useful in the current scenario.</p>
<div class="packt_infobox">Before proceeding further, remember to revert the <kbd class="calibre24">workoutname</kbd><kbd class="calibre24">input</kbd> to its original state, with <kbd class="calibre24">abeBusyIndicator</kbd> applied.</div>
<p class="calibre3"><kbd class="calibre13">BusyIndicatorDirective</kbd> should only be applied if there is an <kbd class="calibre13">NgModel</kbd> directive already present on the element.</p>
<p class="calibre3">The <kbd class="calibre13">selector</kbd> directive is going to save our day this time. Update the <kbd class="calibre13">BusyIndicatorDirective</kbd> selector to this:</p>
<pre class="calibre19">selector: `[abeBusyIndicator][ngModel]` </pre>
<p class="calibre3">This selector creates the <kbd class="calibre13">BusyIndicatorDirective</kbd> only if the combination of <kbd class="calibre13">a2beBusyIndicator</kbd> with the <kbd class="calibre13">ngModel</kbd> attribute is present on the element. Problem solved!</p>
<p class="calibre3">It's now time to add the actual implementation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Implementation one – using renderer</h1>
                
            
            <article>
                
<p class="calibre3">For <kbd class="calibre13">BusyIndicatorDirective</kbd> to work, it needs to know when the async validation on the <kbd class="calibre13">input</kbd> fires and when it is over. This information is only available with the <kbd class="calibre13">NgModel</kbd> directive. <kbd class="calibre13">NgModel</kbd> has a property, <kbd class="calibre13">control</kbd>, which is an instance of the <kbd class="calibre13">Control</kbd> class. It is this <kbd class="calibre13">Control</kbd> class that tracks the current state of the input, including the following:</p>
<ul class="calibre11">
<li class="calibre12">Currently assigned validators (sync and async)</li>
<li class="calibre12">The current value</li>
<li class="calibre12">The input element state, such as <kbd class="calibre13">pristine</kbd>, <kbd class="calibre13">dirty</kbd>, and <kbd class="calibre13">touched</kbd></li>
<li class="calibre12">The input validation state, which could be any one of <kbd class="calibre13">valid</kbd>, <kbd class="calibre13">invalid</kbd>, or <kbd class="calibre13">pending</kbd> in the case of validation being performed asynchronously</li>
<li class="calibre12">Events that track when the value changes or the validation state changes</li>
</ul>
<p class="calibre3"><kbd class="calibre13">Control</kbd> seems to be a useful class, and it's the <kbd class="calibre13">pending</kbd> state that interests us!</p>
<p class="calibre3">Let's add our first implement for the <kbd class="calibre13">BusyIndicatorDirective</kbd> class. Update the class with this code:</p>
<pre class="calibre19">private subscriptions: Array&lt;any&gt; = []; <br class="title-page-name"/>ngAfterViewInit(): void {<br class="title-page-name"/>    this.subscriptions.push(<br class="title-page-name"/>      this.model.control.statusChanges.subscribe((status: any) =&gt; {<br class="title-page-name"/>        if (this.model.control.pending) {<br class="title-page-name"/>          this.renderer.setElementStyle(this.element.nativeElement, 'border-width', '3px');<br class="title-page-name"/>          this.renderer.setElementStyle(this.element.nativeElement, 'border-color', 'gray');<br class="title-page-name"/>        }<br class="title-page-name"/>        else {<br class="title-page-name"/>          this.renderer.setElementStyle(this.element.nativeElement, 'border-width', null);<br class="title-page-name"/>          this.renderer.setElementStyle(this.element.nativeElement, 'border-color', null);<br class="title-page-name"/>        }<br class="title-page-name"/>      }));<br class="title-page-name"/>  }  </pre>
<p class="calibre3">Two new dependencies need to be added to the constructor, as we use them in the <kbd class="calibre13">ngAfterViewInit</kbd> function. Update the <kbd class="calibre13">BusyIndicatorDirective</kbd> constructor to look as follows:</p>
<pre class="calibre19">constructor(private model: NgModel,  
<strong class="calibre1">    private element: ElementRef, </strong><strong class="calibre1">private renderer: Renderer) { }</strong></pre>
<p class="calibre3">And also add imports for <kbd class="calibre13">ElementRef</kbd> and <kbd class="calibre13">Renderer</kbd> in <kbd class="calibre13">'@angular/core'</kbd>.</p>
<p class="calibre3"><kbd class="calibre13">ElementRef</kbd> is a wrapper object over the underlying HTML element (<kbd class="calibre13">input</kbd> in this case). The <kbd class="calibre13">MyAudioDirective</kbd> directive built in <a href="" class="calibre10">Chapter 3</a>, <em class="calibre17">More Angular 2 – SPA, Routing, and Data Flows in Depth</em>, used <kbd class="calibre13">ElementRef</kbd> to get hold of the underlying <kbd class="calibre13">Audio</kbd> element.</p>
<p class="calibre3">The <kbd class="calibre13">Renderer</kbd> injection deserves a bit of attention. Calling <kbd class="calibre13">setElementStyle</kbd> is a dead giveaway that <kbd class="calibre13">Renderer</kbd> is responsible for managing the DOM. But before we delve more deeply into the role of <kbd class="calibre13">Renderer</kbd>, let's try to understand what the preceding code is doing.</p>
<p class="calibre3">In the preceding code, the <kbd class="calibre13">control</kbd> property on the model (the <kbd class="calibre13">NgModel</kbd> instance) defines an event (an <kbd class="calibre13">Observable</kbd>), <kbd class="calibre13">statusChanges</kbd>, which we can subscribe to in order to know when the control validation state changes. The available validation states are <kbd class="calibre13">valid</kbd>, <kbd class="calibre13">invalid</kbd>, and <kbd class="calibre13">pending</kbd>.</p>
<p class="calibre3">The subscription checks whether the control state is <kbd class="calibre13">pending</kbd> or not, and accordingly adorns the underlying element using the <kbd class="calibre13">Renderer</kbd> API function, <kbd class="calibre13">setElementStyle</kbd>. We set the <kbd class="calibre13">border-width</kbd> and <kbd class="calibre13">border-color</kbd> of the input.</p>
<p class="calibre3">The preceding implementation is added to the <kbd class="calibre13">ngAfterViewInit</kbd> directive lifecycle hook, which is called after the view has initialized.</p>
<p class="calibre3">Let's try it out. Open the create workout page or the existing <em class="calibre17">7 Minute Workout</em>. As soon as we leave workout name input, the <kbd class="calibre13">input</kbd> style changes and reverts once the remote validation of the workout name is complete. Nice!</p>
<div class="packt_figure"><img src="../images/00060.jpeg" class="calibre64"/></div>
<p class="calibre3">Before moving forward, also add the un-subscription code to the <kbd class="calibre13">BusyIndicatorDirective</kbd> to avoid a memory leak. Add this function (life  cycle hook) to <kbd class="calibre13">BusyIndicatorDirective</kbd>:</p>
<pre class="calibre19">ngOnDestroy() { 
    this.subscriptions.forEach((s) =&gt; s.unsubscribe()); 
} </pre>
<div class="packt_tip"><span class="packt_screen">Always unsubscribe from observables</span><br class="calibre27"/>
Always remember to unsubscribe from any <kbd class="calibre24">Observable</kbd>/<kbd class="calibre24">EventEmitter</kbd> subscription done in the code to avoid memory leaks.</div>
<p class="calibre3">The implementation looks good. The <kbd class="calibre13">Renderer</kbd> is doing its job. But there are some unanswered questions.</p>
<p class="calibre3">Why not just get hold of the underlying DOM object and use the standard DOM API to manipulate the input styles? Why do we need the <em class="calibre17">renderer</em>?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Angular renderer, the translation layer</h1>
                
            
            <article>
                
<p class="calibre3">One of the primary design goals of Angular 2 was to make it run across environments, frameworks, and devices. Angular enabled this by dividing the core framework implementation into an <strong class="calibre5">application layer</strong> and a <strong class="calibre5">rendering layer</strong>. The application layer has the API we interact with, whereas the rendering layer provides an abstraction that the application layer can use without worrying about how and where the actual view is being rendered.</p>
<p class="calibre3">By separating the rendering layer, Angular can theoretically run in various setups. These include (but are not limited to):</p>
<ul class="calibre11">
<li class="calibre12">Browser</li>
<li class="calibre12">Browser main thread and web worker thread, for obvious performance reasons</li>
<li class="calibre12">Server-side rendering</li>
<li class="calibre12">Native app frameworks; efforts are underway to integrate Angular with <kbd class="calibre13">NativeScript</kbd> with <kbd class="calibre13">ReactNative</kbd></li>
<li class="calibre12">Testing, allowing us to test the app UI outside the web browser</li>
</ul>
<div class="packt_infobox">The <kbd class="calibre24">Renderer</kbd> implementation that Angular uses inside our browser is <kbd class="calibre24">DOMRenderer</kbd>. It is responsible for translating our API calls into browser DOM updates. In fact, we can verify the renderer type by adding a breakpoint in the <kbd class="calibre24">BusyIndicatorDirective</kbd>'s constructor and seeing the value of <kbd class="calibre24">renderer</kbd>.</div>
<p class="calibre3">For this precise reason, we avoid direct manipulation of DOM elements inside <kbd class="calibre13">BusyIndicatorDirective</kbd>. You never know where the code will end up running. We could have easily done this:</p>
<pre class="calibre19">this.element.nativeElement.style.borderWidth="3px"; </pre>
<p class="calibre3">Instead, we used the <kbd class="calibre13">Renderer</kbd> to do the same in a platform-agnostic way.</p>
<p class="calibre3">Look at the <kbd class="calibre13">Renderer</kbd> API function, <kbd class="calibre13">setElementStyle</kbd>:</p>
<pre class="calibre19">this.renderer.setElementStyle( 
             this.element.nativeElement, "border-width", "3px"); </pre>
<p class="calibre3">It takes the element on which the style has to be set, the style property to update, and the value to set. The <kbd class="calibre13">element</kbd> references the <kbd class="calibre13">input</kbd> element injected into <kbd class="calibre13">BusyIndicatorDirective</kbd>.</p>
<div class="packt_tip"><span class="packt_screen">Resetting styles</span><br class="calibre27"/>
Styles set by calling <kbd class="calibre24">setElementStyle</kbd> can be reset by passing a <kbd class="calibre24">null</kbd> value in the third argument. Check out the <kbd class="calibre24">else</kbd> condition in the preceding code.</div>
<p class="calibre3">The <kbd class="calibre13">Renderer</kbd> API has a number of other methods that can be used to set attributes, set properties, listen to events, and even create new views. Whenever you build a new directive, remember to evaluate the <kbd class="calibre13">Renderer</kbd> API for DOM manipulation.</p>
<div class="packt_infobox">A more detailed explanation of <kbd class="calibre24">Renderer</kbd> and its application is available as part of Angular's design documents here: <span class="packt_screen"><a href="http://bit.ly/ng2-render" class="calibre21">http://bit.ly/ng2-render</a></span></div>
<p class="calibre3">We are not done yet! With Angular's awesomeness, we can improve the implementation. Angular allows us to do <em class="calibre17">host binding</em> in directive implementation, helping us avoid a lot of boilerplate code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Host binding in directives</h1>
                
            
            <article>
                
<p class="calibre3">In the Angular realm, the component/element that a directive gets attached to is termed the <strong class="calibre5">host element</strong>:<strong class="calibre5"> </strong>a container that hosts our directive/component. For the <kbd class="calibre13">BusyIndicatorDirective</kbd>, the <kbd class="calibre13">input</kbd> element is the <em class="calibre17">host</em>.</p>
<p class="calibre3">While we can use the <kbd class="calibre13">Renderer</kbd> to manipulate the host (and we did too), the Angular data binding infrastructure can reduce the code further. It provides a declarative way to manage directive-host interaction. Using the host binding concepts, we can manipulate an element's <em class="calibre17">properties</em> and <em class="calibre17">attributes</em> and subscribe to its <em class="calibre17">events</em>.</p>
<p class="calibre3">Let's understand each of the host binding capabilities, and at the end, we will fix our <kbd class="calibre13">BusyIndicatorDirective</kbd> implementation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Property binding using @HostBinding</h1>
                
            
            <article>
                
<p class="calibre3">Use <strong class="calibre5">host property binding</strong> to bind a <em class="calibre17">directive property</em> to a <em class="calibre17">host element property</em>. Any changes to the directive property will be synced with the linked host property during the change detection phase.</p>
<p class="calibre3">We just need to use the <kbd class="calibre13">@HostBinding</kbd> decorator on the directive property that we want to sync with. For example, consider this binding:</p>
<pre class="calibre19">@HostBinding("readOnly") get busy() {return this.isbusy}; </pre>
<p class="calibre3">When applied to <kbd class="calibre13">input</kbd>, it will set the <kbd class="calibre13">input</kbd><kbd class="calibre13">readOnly</kbd> property to <kbd class="calibre13">true</kbd> when the <kbd class="calibre13">isbusy</kbd> directive property is <kbd class="calibre13">true</kbd>.</p>
<div class="packt_infobox"><br class="calibre27"/>
Note that <kbd class="calibre24">readonly</kbd> is also an <em class="calibre31">attribute</em> on <kbd class="calibre24">input</kbd>. What we are referring to here is the input <em class="calibre31">property</em> <kbd class="calibre24">readOnly</kbd>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Attribute binding</h1>
                
            
            <article>
                
<p class="calibre3"><strong class="calibre5">Attribute binding</strong> binds a directive property to a host component attribute. For example, consider a directive with binding like the following:</p>
<pre class="calibre19">@HostBinding("attr.disabled") get canEdit(): string  
  { return !this.isAdmin ? "disabled" : null }; </pre>
<p class="calibre3">If applied to input, it will add the <kbd class="calibre13">disabled</kbd> attribute on <kbd class="calibre13">input</kbd> when the <kbd class="calibre13">isAdmin</kbd> flag is <kbd class="calibre13">false</kbd>, and clear it otherwise. We follow the same attribute binding notation used in the HTML template here too. The attribute name is prefixed with string literal <kbd class="calibre13">attr</kbd>.</p>
<p class="calibre3">We can do something similar with <em class="calibre17">class</em> and <em class="calibre17">style binding</em> too. Consider the following line:</p>
<pre class="calibre19">@HostBinding('class.valid')  
   get valid { return this.control.valid; } </pre>
<p class="calibre3">This line sets up a class binding, and the following line creates a style binding:</p>
<pre class="calibre19">@HostBinding("style.borderWidth")  
   get focus(): string { return this.focus?"3px": "1px"}; </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Event binding</h1>
                
            
            <article>
                
<p class="calibre3">Lastly, <strong class="calibre5">event binding</strong> is used to subscribe to the events raised by the host component/element. Consider this example:</p>
<pre class="calibre19">@Directive({ selector: 'button, div, span, input' }) 
class ClickTracker { 
  @HostListener('click', ['$event.target']) 
  onClick(element: any) { 
    console.log("button", element, "was clicked"); 
  } 
} </pre>
<p class="calibre3">This sets up a listener on the host event <kbd class="calibre13">click</kbd>. Angular will instantiate the preceding directive for every <em class="calibre17">button</em>, <em class="calibre17">div</em>, <em class="calibre17">span</em>, and <em class="calibre17">input</em> on the view and set up the host binding with the <kbd class="calibre13">onClick</kbd> function. The <kbd class="calibre13">$event</kbd> variable contains the event data for the event raised, and <kbd class="calibre13">target</kbd> refers to the element/component that was clicked on.</p>
<p class="calibre3">Event bindings work for components too. Consider the following example:</p>
<pre class="calibre19">@Directive({ selector: 'workout-runner' }) 
class WorkoutTracker { 
  @HostListener('workoutStarted', ['$event']) 
  onWorkoutStarted(workout: any) { 
    console.log("Workout has started!"); 
  } 
} </pre>
<p class="calibre3">With this directive, we track the <kbd class="calibre13">workoutStarted</kbd> event defined on the <kbd class="calibre13">WorkoutRunner</kbd> component. The <kbd class="calibre13">onWorkoutStarted</kbd> function is called when the workout starts, with the details of the started workout.</p>
<p class="calibre3">Now that we understand how these bindings work, we can improve our <kbd class="calibre13">BusyIndicatorDirective</kbd> implementation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Implementation two - BusyIndicatorDirective with host bindings</h1>
                
            
            <article>
                
<p class="calibre3">You may have already guessed it! We will use <em class="calibre17">host property binding</em> instead of <kbd class="calibre13">Renderer</kbd> to set styles. Want to give it a try? Go ahead! Clear the existing implementation and try to set up a host binding for the <kbd class="calibre13">borderWidth</kbd> and <kbd class="calibre13">borderColor</kbd> style attributes without looking at the following implementation.</p>
<p class="calibre3">This is how the directive will look after the host binding implementation:</p>
<pre class="calibre19">import {Directive, HostBinding} from '@angular/core'; 
import {NgModel} from '@angular/forms'; 
 
@Directive({ selector: `[abeBusyIndicator][ngModel]`}) 
export class BusyIndicatorDirective {<br class="title-page-name"/>  private get validating(): boolean {<br class="title-page-name"/>    return this.model.control != null &amp;&amp; this.model.control.pending;<br class="title-page-name"/>  }<br class="title-page-name"/>  @HostBinding('style.borderWidth') get controlBorderWidth():<br class="title-page-name"/>        string { return this.validating ? '3px' : null; }<br class="title-page-name"/>  @HostBinding('style.borderColor') get controlBorderColor():<br class="title-page-name"/>        string { return this.validating ? 'gray' : null; }<br class="title-page-name"/><br class="title-page-name"/>  constructor(private model: NgModel) { }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/></pre>
<p class="calibre3">We have moved the <kbd class="calibre13">pending</kbd> state check into a directive property called <kbd class="calibre13">validating</kbd> and then used the <kbd class="calibre13">controlBorderWidth</kbd> and <kbd class="calibre13">controlBorderColor</kbd> properties for style binding. This is definitely more succinct than our earlier approach! Go test it out.</p>
<p class="calibre3">And if we tell you that this can be done without the need for a custom directive, don't be surprised! This is how we do it, just by using style bindings on the workout name <kbd class="calibre13">input</kbd>:</p>
<pre class="calibre19">&lt;input type="text" name="workoutName" ... 
<strong class="calibre1">[style.borderColor]="name.control.pending ? 'gray' : null" </strong><strong class="calibre1">[style.borderWidth]="name.control.pending ? '3px' : null"&gt;</strong></pre>
<p class="calibre3">We get the same effect!</p>
<p class="calibre3">No, our effort did not go to waste. We did learn about <strong class="calibre5">renderer</strong> and <strong class="calibre5">host binding</strong>. These concepts will come in handy while building directives that provide complex behavior extension instead of just setting element styles.</p>
<div class="packt_infobox">If you are having a problem with running the code, look at the Git branch <kbd class="calibre24">checkpoint6.1</kbd> for a working version of what we have done thus far. Or if you are not using Git, download the snapshot of <kbd class="calibre24">checkpoint6.1</kbd> (a ZIP file) from <a href="http://bit.ly/ng6be-checkpoint-6-1" class="calibre21"><span class="packt_screen">http://bit.ly/ng6be-checkpoint-6-1</span></a>. Refer to the <kbd class="calibre24">README.md</kbd> file in the <kbd class="calibre24">trainer</kbd> folder when setting up the snapshot for the first time.</div>
<p class="calibre3">The next topic that we are going to take up is, <em class="calibre17">directive injection</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Directive injection</h1>
                
            
            <article>
                
<p class="calibre3">Go back a few pages and look at the <kbd class="calibre13">BusyIndicatorDirective</kbd> implementation that uses the <em class="calibre17">renderer,</em> specifically the constructor:</p>
<pre class="calibre19">constructor(<strong class="calibre1">private model: NgModel</strong> ...) { } </pre>
<p class="calibre3">Angular automatically locates the <kbd class="calibre13">NgModel</kbd> directive created for the directive element and injects it into <kbd class="calibre13">BusyIndicatorDirective</kbd>. This is possible because both directives are declared on the same <em class="calibre17">host element</em>.</p>
<p class="calibre3">The good news is that we can influence this behavior. Directives created on a parent HTML tree or child tree can also be injected. The next few sections talk about how to inject directives across the component tree, a very handy feature that allows cross-directive communication for directives that have a <em class="calibre17">common lineage</em> (in a view).</p>
<p class="calibre3">We will use StackBlitz (<a href="https://stackblitz.com/edit/angular-pzljm3" class="calibre10">https://stackblitz.com/edit/angular-pzljm3</a>) to demonstrate these concepts. SlackBlitz is an online IDE to run Angular applications!</p>
<p class="calibre3">To start with, look at the file <kbd class="calibre13">app.component.ts</kbd>. It has three directives: <kbd class="calibre13">Relation</kbd>,<strong class="calibre5"> </strong><kbd class="calibre13">Acquaintance</kbd>, and <kbd class="calibre13">Consumer</kbd> and this view hierarchy is defined:</p>
<pre class="calibre19">&lt;div relation="grand-parent" acquaintance="jack"&gt; 
    &lt;div relation="parent"&gt; 
<strong class="calibre1">      &lt;div relation="me" consumer&gt;</strong> 
        &lt;div relation="child-1"&gt; 
          &lt;div relation="grandchild-1"&gt;&lt;/div&gt; 
        &lt;/div&gt; 
        &lt;div relation="child-2"&gt;&lt;/div&gt; 
      &lt;/div&gt; 
    &lt;/div&gt; 
&lt;/div&gt; </pre>
<p class="calibre3">In the next few sections, we will describe the various ways in which we can inject the different <kbd class="calibre13">relation</kbd> and <kbd class="calibre13">Acquaintance</kbd> directives into the <kbd class="calibre13">consumer</kbd> directive. Check out the browser console for the injected dependencies that we log during the <kbd class="calibre13">ngAfterViewInit</kbd> life cycle hook.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Injecting directives defined on the same element</h1>
                
            
            <article>
                
<p class="calibre3">Constructor injection by default supports injecting directives defined on the same element. The constructor function just needs to declare the directive type variable that we want to inject:</p>
<pre class="calibre19">variable:DirectiveType </pre>
<p class="calibre3">The <kbd class="calibre13">NgModel</kbd> injection that we did in <kbd class="calibre13">BusyIndicatorDirective</kbd> falls under this category. If the directive is not found on the current element, the Angular DI will throw an error, unless we mark the dependency as <kbd class="calibre13">@Optional</kbd>.</p>
<div class="packt_tip"><span class="packt_screen">Optional dependency</span><br class="calibre27"/>
<span class="packt_screen">The </span><kbd class="calibre24">@Optional</kbd> decorator is not limited to directive injection. It's there to mark any type of dependency optional.</div>
<p class="calibre3">From the plunk example, the first injection (in <kbd class="calibre13">Consumer</kbd> directive implementation) injects the <kbd class="calibre13">Relation</kbd> directive with the <kbd class="calibre13">me</kbd> attribute (<kbd class="calibre13">relation="me"</kbd>) into the consumer directive:</p>
<pre class="calibre19">constructor(private me:Relation ... </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Injecting directive dependency from the parent</h1>
                
            
            <article>
                
<p class="calibre3">Prefixing a constructor argument with the <kbd class="calibre13">@Host</kbd> decorator instructs Angular to search for the dependency on the <em class="calibre17">current element</em>, <em class="calibre17">its parent</em>, or its <em class="calibre17">parents</em> until it reaches the component boundaries (a component with the directive present somewhere in its view hierarchy). Check the second <kbd class="calibre13">consumer</kbd> injection:</p>
<pre class="calibre19">constructor(..., @Host() private myAcquaintance:Acquaintance  </pre>
<p class="calibre3">This statement injects the <kbd class="calibre13">Acquaintance</kbd> directive instance declared two levels up the hierarchy.</p>
<div class="packt_infobox">Like the <kbd class="calibre24">@Option</kbd> decorator described previously, the usage of <kbd class="calibre24">@Host()</kbd> is not limited to directives too. Angular service injection also follows the same pattern. If a service is marked with <kbd class="calibre24">@Host</kbd>, the search stops at the host component. It does not continue further up the component tree.</div>
<p class="calibre3">The <kbd class="calibre13">@Skipself</kbd> decorator can be used to skip the current element for a directive search.</p>
<p class="calibre3">From the StackBlitz example, this injection injects the <kbd class="calibre13">Relation</kbd> directive with the <kbd class="calibre13">relation</kbd> attribute value <kbd class="calibre13">parent</kbd> (<kbd class="calibre13">relation="parent"</kbd>) into <kbd class="calibre13">consumer</kbd>:</p>
<pre class="calibre19">@SkipSelf() private myParent:Relation </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Injecting a child directive (or directives)</h1>
                
            
            <article>
                
<p class="calibre3">If there is a need to inject directive(s) defined on nested HTML into a parent directive/component, there are four decorators that can help us:</p>
<ul class="calibre11">
<li class="calibre12"><kbd class="calibre13">@ViewChild</kbd>/<kbd class="calibre13">@ViewChildren</kbd></li>
<li class="calibre12"><kbd class="calibre13">@ContentChild</kbd>/<kbd class="calibre13">@ContentChildren</kbd></li>
</ul>
<p class="calibre3">As these naming conventions suggest, there are decorators to inject a single child directive or multiple children directives:</p>
<p class="calibre3">To understand the significance of <kbd class="calibre13">@ViewChild/@ViewChildren</kbd> versus <kbd class="calibre13">@ContentChild/@ContentChildren</kbd>, we need to look at what view and content children are, a topic that we will take up soon. But for now, it's enough to understand that view children are part of a component's own view and content children are external HTML injected into the component's view.</p>
<p class="calibre3">Look how, in the StackBlitz example, the <kbd class="calibre13">ContentChildren</kbd> decorator is used to inject the child <kbd class="calibre13">Relation</kbd> directive into <kbd class="calibre13">Consumer</kbd>:</p>
<pre class="calibre19">@ContentChildren(Relation) private children:QueryList&lt;Relation&gt;; </pre>
<p class="calibre3">Surprisingly, the data type of the variable <kbd class="calibre13">children</kbd> is not an array, but a custom class-<kbd class="calibre13">QueryList</kbd>. The <kbd class="calibre13">QueryList</kbd> class is not a typical array, but a collection that is kept up to date by Angular whenever dependencies are added or removed. This can happen if the DOM tree is created/destroyed when using structural directives such as <kbd class="calibre13">NgIf</kbd> or <kbd class="calibre13">NgFor</kbd>. We will also talk more about <kbd class="calibre13">QueryList</kbd> in the coming sections.</p>
<p class="calibre3">You may have observed that the preceding injection is not a constructor injection as were the earlier two examples. This is for a reason. The injected directive(s) will not be available until the underlying component/element's content has initialized. For this precise reason, we have the <kbd class="calibre13">console.log</kbd> statements inside the <kbd class="calibre13">ngAfterViewInit</kbd> life cycle hook. We should only access the content children post this life cycle hook execution.</p>
<p class="calibre3">The preceding sample code injects in all three child <kbd class="calibre13">relation</kbd> objects into the <kbd class="calibre13">consumer</kbd> directive.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Injecting descendant directive(s)</h1>
                
            
            <article>
                
<p class="calibre3">The standard <kbd class="calibre13">@ContentChildren</kbd> decorator (or as a matter of fact <kbd class="calibre13">@ViewChildren</kbd> too) only injects the immediate children of a directive/component and not its descendants. To include all its descendants, we need to provide an argument to <kbd class="calibre13">Query</kbd>:</p>
<pre class="calibre19"><strong class="calibre1">@ContentChildren(Relation, {descendants: true}) private 
allDescendents:QueryList&lt;Relation&gt;; </strong></pre>
<p class="calibre3">Passing the <kbd class="calibre13">descendants: true</kbd> parameter will instruct Angular to search for all descendants.</p>
<p class="calibre3">If you look at the console log, the preceding statement injects in all four descendants.</p>
<p class="calibre3">The Angular DI, while it seems simple to use, packs a lot of functionality. It manages our services, components, and directives and provides us with the right stuff in the right place at the right time. Directive injection in components and other directives provides a mechanism for directives to communicate with each other. Such injections allow one directive to access the public API (public functions/properties) of another directive.</p>
<p class="calibre3">It's now time to explore something new. We are going to build an Ajax button component that allows us to inject an external view into the component, a process also known as <strong class="calibre5">content </strong><strong class="calibre5">transclusion</strong>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Building an Ajax button component</h1>
                
            
            <article>
                
<p class="calibre3">When we save/update an exercise or workout, there is always the possibility of duplicate submission (or duplicate <kbd class="calibre13">POST</kbd> requests). The current implementation does not provide any feedback as to when the save/update operation started and when it is  completed. The user of an app can knowingly or unknowingly click on the <span class="calibre6">Save</span> button multiple times due to the lack of visual clues.</p>
<p class="calibre3">Let's try to solve this problem by creating a specialized button—an <em class="calibre17">Ajax button</em> that gives some visual clues when clicked on and also stops duplicate Ajax submissions.</p>
<p class="calibre3">The button component will work on these lines. It takes a function as input. This input function (input parameter) should return a promise pertaining to the remote request. On clicking on the button, the button internally makes the remote call (using the input function), tracks the underlying promise, waits for it to complete, and shows some busy clues during this activity. Also, the button remains disabled until the remote invocation completes to avoid duplicate submission.</p>
<div class="packt_infobox">The companion code base for the following section is Git branch <kbd class="calibre24">checkpoint6.2</kbd>. You can work along with us, or check out the implementation available in the branch. Or if you are not using Git, download the snapshot of <kbd class="calibre24">checkpoint6.2</kbd> (a ZIP file) from the GitHub location <a href="http://bit.ly/ng6be-checkpoint-6-2" class="calibre21">http://bit.ly/ng6be-checkpoint-6-2</a>. Refer to the <kbd class="calibre24">README.md</kbd> file in the <kbd class="calibre24">trainer</kbd> folder when setting up the snapshot for the first time.</div>
<p class="calibre3">Let's create the component outline to make things clearer. Use the following command to create an <kbd class="calibre13">ajax-button</kbd> component under the application's shared module (<kbd class="calibre13">src/app/shared</kbd>) and <strong class="calibre5">then export the component</strong> from the <kbd class="calibre13">SharedModule</kbd>:</p>
<pre class="calibre19"><strong class="calibre1">ng generate component ajax-button -is</strong></pre>
<p class="calibre3">Update the component definition too and import them from <kbd class="calibre13">@angular/core</kbd>:</p>
<pre class="calibre19">export class AjaxButtonComponent implements OnInit { 
  busy: boolean = null; 
  @Input() execute: any; 
  @Input() parameter: any; 
} </pre>
<p class="calibre3">And add the following HTML template to <kbd class="calibre13">ajax-button.component.html</kbd>:</p>
<pre class="calibre19">&lt;button [attr.disabled]="busy" class="btn btn-primary"&gt; 
    &lt;span [hidden]="!busy"&gt;<br class="title-page-name"/>        &lt;div class="ion-md-cloud-upload spin"&gt;&lt;/div&gt;
    &lt;/span&gt;
    &lt;span&gt;Save&lt;/span&gt; 
&lt;/button&gt; </pre>
<p class="calibre3">The component (<kbd class="calibre13">AjaxButtonComponent</kbd>) takes two property bindings, <kbd class="calibre13">execute</kbd> and <kbd class="calibre13">parameter</kbd>. The <kbd class="calibre13">execute</kbd> property points to the function that is invoked on the Ajax button click. The <kbd class="calibre13">parameter</kbd> is the data that can be passed to this function.</p>
<p class="calibre3">Look at the usage of the <kbd class="calibre13">busy</kbd> flag in the view. We disable the button and show the spinner when the <kbd class="calibre13">busy</kbd> flag is set. Let's add the implementation that makes everything work. Add this code to the <kbd class="calibre13">AjaxButtonComponent</kbd> class:</p>
<pre class="calibre19">@HostListener('click', ['$event'])<br class="title-page-name"/>onClick(event: any) {<br class="title-page-name"/>    const result: any = this.execute(this.parameter);<br class="title-page-name"/>    if (result instanceof Promise) {<br class="title-page-name"/>      this.busy = true;<br class="title-page-name"/>      result.then(<br class="title-page-name"/>        () =&gt; { this.busy = null; },<br class="title-page-name"/>        (error: any) =&gt; { this.busy = null; });<br class="title-page-name"/>    }<br class="title-page-name"/>}</pre>
<p class="calibre3">We set up a <em class="calibre17">host event binding</em> to the click event on <kbd class="calibre13">AjaxButtonComponent</kbd>. Anytime the <kbd class="calibre13">AjaxButtonComponent</kbd> component is clicked on, the <kbd class="calibre13">onClick</kbd> function is invoked.</p>
<p class="calibre3">The <kbd class="calibre13">HostListener</kbd> import needs to be added to the <kbd class="calibre13">'@angular/core'</kbd> module.</p>
<p class="calibre3">The <kbd class="calibre13">onClick</kbd> implementation calls the input function with a lone parameter as <kbd class="calibre13">parameter</kbd>. The result of the invocation is stored in the <kbd class="calibre13">result</kbd> variable.</p>
<p class="calibre3">The <kbd class="calibre13">if</kbd> condition checks whether the <kbd class="calibre13">result</kbd> is a <kbd class="calibre13">Promise</kbd> object. If yes, the <kbd class="calibre13">busy</kbd> indicator is set to <kbd class="calibre13">true</kbd>. The button then waits for the promise to get resolved, using the <kbd class="calibre13">then</kbd> function. Irrespective of whether the promise is resolved with <em class="calibre17">success</em> or <em class="calibre17">error</em>, the busy flag is set to <kbd class="calibre13">null</kbd>.</p>
<div class="packt_infobox">The reason the busy flag is set to <kbd class="calibre24">null</kbd> and not <kbd class="calibre24">false</kbd> is due to this attribute binding <kbd class="calibre24">[attr.disabled]="busy"</kbd>. The <kbd class="calibre24">disabled</kbd> attribute will not be removed unless <kbd class="calibre24">busy</kbd> is <kbd class="calibre24">null</kbd>. Remember that in HTML, <kbd class="calibre24">disabled="false"</kbd> does not enable the button. The attribute needs to be removed before the button becomes clickable again.</div>
<p class="calibre3">If we are confused about this line:</p>
<pre class="calibre19">    const result: any = this.execute(this.parameter); </pre>
<p class="calibre3">Then you need to look at how the component is used. Open <kbd class="calibre13">workout.component.html</kbd> and replace the <kbd class="calibre13">Save</kbd> button HTML with the following:</p>
<pre class="calibre19">&lt;abe-ajax-button [execute]="save" [parameter]="f"&gt;&lt;/abe-ajax-button&gt; </pre>
<p class="calibre3">The <kbd class="calibre13">Workout.save</kbd> function binds to <kbd class="calibre13">execute</kbd>, and <kbd class="calibre13">parameter</kbd> takes the <kbd class="calibre13">FormControl</kbd> object <kbd class="calibre13">f</kbd>.</p>
<p class="calibre3">We need to change the <kbd class="calibre13">save</kbd> function in the <kbd class="calibre13">Workout</kbd> class to return a promise for <kbd class="calibre13">AjaxButtonComponent</kbd> to work. Change the <kbd class="calibre13">save</kbd> function implementation to the following:</p>
<pre class="calibre19">save = (formWorkout: any): Promise&lt;Object | WorkoutPlan&gt; =&gt; {<br class="title-page-name"/>    this.submitted = true;<br class="title-page-name"/>    if (!formWorkout.valid) { return; }<br class="title-page-name"/>    const savePromise = this.workoutBuilderService.save().toPromise();<br class="title-page-name"/><br class="title-page-name"/>    savePromise.then(<br class="title-page-name"/>      result =&gt; this.router.navigate(['/builder/workouts']),<br class="title-page-name"/>      err =&gt; console.error(err)<br class="title-page-name"/>    );<br class="title-page-name"/>    return savePromise;<br class="title-page-name"/>  } </pre>
<p class="calibre3">The <kbd class="calibre13">save</kbd> function now returns a <em class="calibre17">promise</em> that we build by calling the <kbd class="calibre13">toPromise</kbd> function on the <em class="calibre17">observable</em> returned from the call to <kbd class="calibre13">workoutBuilderService.save()</kbd>.</p>
<div class="packt_infobox">Make note of how we define the <kbd class="calibre24">save</kbd> function as an <em class="calibre31">instance function</em> (with the use of the arrow operator) to create a closure over <em class="calibre31">this</em>. It's something we did earlier while building the <em class="calibre31">remote validator directive</em>.</div>
<p class="calibre3">Time to test our implementation! Refresh the application and open the create/edit workout view. Click on the <span class="calibre6">Save</span> button and see the Ajax button in action:</p>
<div class="packt_figure"><img src="../images/00061.gif" class="calibre28"/></div>
<div class="packt_tip"><br class="calibre27"/>
The preceding animation may be short-lived as we navigate back to the workout list page post save. We can temporarily disable the navigation to see the new changes.</div>
<p class="calibre3">We started this section with the aim of highlighting how external elements/components can be transcluded into a component. Let's do it now!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Transcluding external components/elements into a component</h1>
                
            
            <article>
                
<p class="calibre3">From the very start, we need to understand what <strong class="calibre5">transclusion</strong> means. And the best way to understand this concept would be to look at an example.</p>
<p class="calibre3">No component that we have built thus far has borrowed content from outside. Not sure what this means?</p>
<p class="calibre3">Consider the preceding <kbd class="calibre13">AjaxButtonComponent</kbd> example in <kbd class="calibre13">workout.component.html</kbd>:</p>
<pre class="calibre19">&lt;ajax-button [execute]="save" [parameter]="f"&gt;&lt;/ajax-button&gt; </pre>
<p class="calibre3">What if we change the <kbd class="calibre13">ajax-button</kbd> usage to the following?</p>
<pre class="calibre19">&lt;ajax-button [execute]="save" [parameter]="f"&gt;<strong class="calibre1">Save Me!</strong>&lt;/ajax-button&gt; </pre>
<p class="calibre3">Will the <kbd class="calibre13">Save Me!</kbd> text show up on the button? It will not try it!</p>
<p class="calibre3">The <kbd class="calibre13">AjaxButtonComponent</kbd> component already has a template, and it rejects the content we provide in the preceding declaration. What if we can somehow make the content (<kbd class="calibre13">Save Me!</kbd> in the preceding example) load inside the <kbd class="calibre13">AjaxButtonComponent</kbd>? This act of injecting an external view fragment into the component's view is what we call <strong class="calibre5">transclusion</strong>, and the framework provides the necessary constructs to enable transclusions.</p>
<p class="calibre3">It's time to introduce two new concepts, <em class="calibre17">content children</em> and <em class="calibre17">view children</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Content children and view children</h1>
                
            
            <article>
                
<p class="calibre3">To define it succinctly, the HTML structure that a component defines internally (using <kbd class="calibre13">template or templateUrl</kbd>) is the <strong class="calibre5">view children</strong> of the component. However, the HTML view provided as part of the component usage added to the host element (such as <kbd class="calibre13">&lt;ajax-button&gt;<strong class="calibre1">Save Me!</strong>&lt;/ajax-button&gt;</kbd>), defines the <strong class="calibre5">content children</strong> of the component.</p>
<p class="calibre3">By default, Angular does not allow <em class="calibre17">content children</em> to be embedded as we saw before. The <kbd class="calibre13">Save Me!</kbd> text was never emitted. We need to explicitly tell Angular where to emit the <em class="calibre17">content children</em> inside the <em class="calibre17">component view template</em>. To understand this concept, let's fix the <kbd class="calibre13">AjaxButtonComponent</kbd> view. Open <kbd class="calibre13">ajax-button.component.ts</kbd> and update the view template definition to the following:</p>
<pre class="calibre19">&lt;button [attr.disabled]="busy" class="btn btn-primary"&gt; <br class="title-page-name"/>    &lt;span [hidden]="!busy"&gt; 
        <strong class="calibre1">&lt;ng-content select="[data-animator]"&gt;&lt;/ng-content&gt;</strong> 
   &lt;/span&gt; 
<strong class="calibre1">   &lt;ng-content select="[data-content]"&gt;&lt;/ng-content&gt;</strong> 
&lt;/button&gt;</pre>
<p class="calibre3">The two <kbd class="calibre13">ng-content</kbd> elements in the preceding view define the <em class="calibre17">content injection locations</em>, where the content children can be injected/transcluded. The <kbd class="calibre13">selector</kbd> property defines the <em class="calibre17">CSS selector</em> that should be used to locate the content children when injected into the main host.</p>
<p class="calibre3">It starts to make more sense as soon as we fix the <kbd class="calibre13">AjaxButtonComponent</kbd> usage in <kbd class="calibre13">workout.component.html</kbd>. Change it to the following:</p>
<pre class="calibre19">&lt;ajax-button [execute]="save" [parameter]="f"&gt;<br class="title-page-name"/>    <strong class="calibre1">&lt;div class="ion-md-cloud-upload spin" data-animator&gt;&lt;/div&gt;</strong><br class="title-page-name"/><strong class="calibre1">    &lt;span data-content&gt;Save&lt;/span&gt;</strong>
&lt;/ajax-button&gt; </pre>
<p class="calibre3">The <kbd class="calibre13">span</kbd> with <kbd class="calibre13">data-animator</kbd> is injected into the <kbd class="calibre13">ng-content</kbd> with the <kbd class="calibre13">select=[data-animator]</kbd> property and the other <kbd class="calibre13">span</kbd> (with the <kbd class="calibre13">data-content</kbd> attribute) is injected into the second <kbd class="calibre13">ng-content</kbd> declaration.</p>
<p class="calibre3">Refresh the application again and try to save a workout. While the end result is the same, the resultant view is a combination of multiple view fragments: one part for component definition (<em class="calibre17">view children</em>) and another part for component usage (<em class="calibre17">content children</em>).</p>
<p class="calibre3">The following diagram highlights this difference for the rendered <kbd class="calibre13">AjaxButtonComponent</kbd>:</p>
<div class="packt_figure"><img src="../images/00062.jpeg" class="calibre28"/></div>
<div class="packt_tip">The <kbd class="calibre24">ng-content</kbd> can be declared without the <kbd class="calibre24">selector</kbd> attribute. In such a scenario, the complete content defined inside the component tag is injected.</div>
<p class="calibre3"><em class="calibre17">Content injection</em> into an existing component view is a very powerful concept. It allows the component developer to provide extension points that the component consumer can readily consume and customize the behavior of the component, that too in a controlled manner.</p>
<p class="calibre3">The content injections that we defined for the <kbd class="calibre13">AjaxButtonComponent</kbd> allow the consumer to change the busy indicator animation and the button content, keeping the behavior of the button intact.</p>
<p class="calibre3">Angular's advantages do not end here. It has the capability to inject <em class="calibre17">content children</em> and <em class="calibre17">view children</em> into the <em class="calibre17">component code/implementation</em>. This allows the component to interact with its content/view children and control their behavior too.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Injecting view children using @ViewChild and @ViewChildren</h1>
                
            
            <article>
                
<p class="calibre3">In <span class="calibre6"><a href="" class="calibre10">Chapter 3</a></span>, <em class="calibre17">More Angular 2 – SPA, Routing, and Data Flows in Depth</em>, we made use of something similar, <em class="calibre17">view children injection</em>. To recall what we did, let's look at the relevant parts of the <kbd class="calibre13">WorkoutAudioComponent</kbd> implementation.</p>
<p class="calibre3">The view definition looked as follows:</p>
<pre class="calibre19">&lt;audio #ticks="MyAudio" loop src="/assets/audio/tick10s.mp3"&gt;&lt;/audio&gt;<br class="title-page-name"/>&lt;audio #nextUp="MyAudio" src="/assets/audio/nextup.mp3"&gt;&lt;/audio&gt;<br class="title-page-name"/>&lt;audio #nextUpExercise="MyAudio" [src]="'/assets/audio/' + nextupSound"&gt;&lt;/audio&gt;
// Some other audio elements </pre>
<p class="calibre3">And the injection looked as follows:</p>
<pre class="calibre19">@ViewChild('ticks') private _ticks: MyAudioDirective; 
@ViewChild('nextUp') private _nextUp: MyAudioDirective; 
@ViewChild('nextUpExercise') private _nextUpExercise: MyAudioDirective; </pre>
<p class="calibre3">The directive (<kbd class="calibre13">MyAudioDirective</kbd>) associated with the <kbd class="calibre13">audio</kbd> tag was injected into the <kbd class="calibre13">WorkoutAudio</kbd> implementation using the <kbd class="calibre13">@ViewChild</kbd> decorator. The parameters passed to <kbd class="calibre13">@ViewChild</kbd> are the <em class="calibre17">template variable</em> names (such as <kbd class="calibre13">tick</kbd>) used to locate the element in the view definition. The <kbd class="calibre13">WorkoutAudio</kbd> component then used these audio directives to control the audio playback for <em class="calibre17">7 Minute Workout</em>.</p>
<p class="calibre3">While the preceding implementation injects <kbd class="calibre13">MyAudioDirective</kbd>, even child components can be injected. For example, instead of using <kbd class="calibre13">MyAudioDirective</kbd>, suppose we build a <kbd class="calibre13">MyAudioComponent</kbd>, something like the following:</p>
<pre class="calibre19">@Component({ 
  selector: 'my-audio', 
  template: '&lt;audio ...&gt;&lt;/audio&gt;', 
}) 
export class MyAudioComponent { 
  ... 
} </pre>
<p class="calibre3">We can then use it instead of the <kbd class="calibre13">audio</kbd> tag:</p>
<pre class="calibre19">&lt;<strong class="calibre1">my-audio</strong> #ticks loop  
  src="/static/audio/tick10s.mp3"&gt;&lt;/<strong class="calibre1">my-audio</strong>&gt; </pre>
<p class="calibre3">The injection would still work.</p>
<p class="calibre3">What happens if there is more than one directive/component of the same type defined on the component view? Use the <kbd class="calibre13">@ViewChildren</kbd> decorator. It allows you to query injections of one type. The syntax for the use of <kbd class="calibre13">@ViewChildren</kbd> is as follows:</p>
<pre class="calibre19">@ViewChildren(directiveType) children: QueryList&lt;directiveType&gt;; </pre>
<p class="calibre3">This injects all the view children of type <kbd class="calibre13">directiveType</kbd>. For the <kbd class="calibre13">WorkoutAudio</kbd> component example stated previously, we can use the following statement to get hold of all <kbd class="calibre13">MyAudioDirective</kbd>:</p>
<pre class="calibre19">@ViewChildren(MyAudioDirectives) private all: QueryList&lt;MyAudioDirectives&gt;; </pre>
<p class="calibre3">The <kbd class="calibre13">ViewChildren</kbd> decorator can also take a list of comma-separated selectors (<em class="calibre17">template variable names</em>) instead of type. For example, to select multiple <kbd class="calibre13">MyAudioDirective </kbd>instances in the <kbd class="calibre13">WorkoutAudio</kbd> component, we can use the following:</p>
<pre class="calibre19"> @ViewChildren('ticks, nextUp, nextUpExercise, halfway, aboutToComplete') private all: QueryList&lt;MyAudioDirective&gt;; </pre>
<p class="calibre3">The <kbd class="calibre13">QueryList</kbd> class is a special class provided by Angular. We introduced <kbd class="calibre13">QueryList</kbd> in the <em class="calibre17">Injecting descendant directive(s)</em> section earlier in the chapter. Let's explore <kbd class="calibre13">QueryList</kbd> further.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Tracking injected dependencies with QueryList</h1>
                
            
            <article>
                
<p class="calibre3">For components that require multiple components/directives to be injected (using either <kbd class="calibre13">@ViewChildren</kbd> or <kbd class="calibre13">@ContentChildren</kbd>), the dependency injected is a <kbd class="calibre13">QueryList</kbd> object.</p>
<p class="calibre3">The <kbd class="calibre13">QueryList</kbd> class is a <em class="calibre17">read-only </em><em class="calibre17">collection</em> of injected components/directives. Angular keeps this collection in sync based on the current state of the user interface.</p>
<p class="calibre3">Consider, for example, the <kbd class="calibre13">WorkoutAudio</kbd> directive view. It has five instances of <kbd class="calibre13">MyAudioDirective</kbd>. Hence, for the following collection, we will have five elements:</p>
<pre class="calibre19">@ViewChildren(MyAudioDirective) private all: QueryList&lt;MyAudioDirective&gt;; </pre>
<p class="calibre3">While the preceding example does not highlight the syncing part, Angular can track components/directives being added or removed from the view. This happens when we use content generation directives such as <kbd class="calibre13">ngFor</kbd>.</p>
<p class="calibre3">Take this hypothetical template for example:</p>
<pre class="calibre19">&lt;div *ngFor="let audioData of allAudios"&gt; 
  &lt;audio [src]="audioData.url"&gt;&lt;/audio&gt; 
&lt;/div&gt; </pre>
<p class="calibre3">The number of <kbd class="calibre13">MyAudioDirective</kbd> directives injected here equals the size of the <kbd class="calibre13">allAudios</kbd> array. During the program's execution, if elements are added to or removed from the <kbd class="calibre13">allAudios</kbd> array, the directive collection is also kept in sync by the framework.</p>
<p class="calibre3">While the <kbd class="calibre13">QueryList</kbd> class is not an array, it can be iterated over (as it implements the <strong class="calibre5">ES6 iterable interface</strong>) using the <kbd class="calibre13">for (var item in queryListObject)</kbd> syntax. It also has some other useful properties, such as <kbd class="calibre13">length</kbd>, <kbd class="calibre13">first</kbd>, and <kbd class="calibre13">last</kbd>, which can come in handy. Check out the framework documentation (<span class="calibre6"><a href="http://bit.ly/ng2-querylist-class" class="calibre10">http://bit.ly/ng2-querylist-class</a></span>) for more details.</p>
<p class="calibre3">From the preceding discussion, we can conclude that <kbd class="calibre13">QueryList</kbd> saves the component developer a lot of boilerplate code that would be required if tracking had to be done manually.</p>
<div class="packt_tip"><span class="packt_screen">View children access timing</span><br class="calibre27"/>
View children injections are not available when the component/directive initializes. Angular makes sure that the view children injections are available to the component no later than the <kbd class="calibre24">ngAfterViewInit</kbd> life cycle event. Make sure you access the injected components/directives only when (or after) the <kbd class="calibre24">ngAfterViewInit</kbd> event has fired.</div>
<p class="calibre3">Let's now look at content children injection, which is almost similar, except for a few minor differences.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Injecting content children using @ContentChild and @ContentChildren</h1>
                
            
            <article>
                
<p class="calibre3">Angular allows us to inject <em class="calibre17">content children</em> too, using a parallel set of attributes: <kbd class="calibre13">@ContentChild</kbd> to inject a specific content child and <kbd class="calibre13">@ContentChildren</kbd> to inject content children of a specific type.</p>
<p class="calibre3">If we look back at the usage of <kbd class="calibre13">AjaxButtonComponent</kbd>, its content children spans can be injected into <kbd class="calibre13">AjaxButtonComponent</kbd> implementation by doing this:</p>
<pre class="calibre19">@ContentChild('spinner') spinner:ElementRef; 
@ContentChild('text') text:ElementRef; </pre>
<p class="calibre3">And adding template variables onto the corresponding spans in <kbd class="calibre13">workout.component.html</kbd>:</p>
<pre class="calibre19"><strong class="calibre1">&lt;div class="ion-md-cloud-upload spin" data-animator #spinner&gt;&lt;/div&gt;<br class="title-page-name"/>&lt;span data-content #text&gt;Save&lt;/span&gt;</strong></pre>
<p class="calibre3">While the preceding injection is <kbd class="calibre13">ElementRef</kbd>, it could have been a component too. Had we defined a component for spinner, such as:</p>
<pre class="calibre19">&lt;ajax-button&gt; 
    &lt;busy-spinner&gt;&lt;/busy-spinner&gt; 
    ... 
&lt;/ajax-button&gt; </pre>
<p class="calibre3">We could have injected it too using the following:</p>
<pre class="calibre19">@ContentChild(BusySpinner) spinner: BusySpinner; </pre>
<p class="calibre3">The same holds true for directives too. Any directive declared on <kbd class="calibre13">AjaxButtonComponent</kbd> can be injected into the <kbd class="calibre13">AjaxButtonComponent</kbd> implementation. For the preceding case, since the transcluded elements are standard HTML elements, we injected <kbd class="calibre13">ElementRef</kbd>, a wrapper that Angular creates for any HTML element.</p>
<div class="packt_tip">Like <em class="calibre31">view children</em>, Angular makes sure that the content children references are bound to the variables injected before the <kbd class="calibre24">ngAfterContentInit</kbd> life cycle event.</div>
<p class="calibre3">While we are on the subject of injecting dependencies, let's talk about some variations around <em class="calibre17">injecting services into </em><em class="calibre17">components</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Dependency injection using viewProvider</h1>
                
            
            <article>
                
<p class="calibre3">We are already familiar with the mechanism of DI registration in Angular, where we register a dependency at the global level by adding it to any module declaration.</p>
<p class="calibre3">Or we can do it at a component level using the <kbd class="calibre13">providers</kbd> property on the <kbd class="calibre13">@Component</kbd> decorator:</p>
<pre class="calibre19">providers:[WorkoutHistoryTracker, LocalStorage] </pre>
<div class="packt_infobox">Just to avoid confusion, we are now talking about injecting dependencies other than directive/component objects. Directives/components are registered in the <kbd class="calibre24">declarations</kbd> array of a module before they can be injected using decorator hints such as <kbd class="calibre24">@Query</kbd>, <kbd class="calibre24">@ViewChild</kbd>, <kbd class="calibre24">@ViewChildren</kbd>, and a few others.</div>
<p class="calibre3">Dependencies registered at the component level are available for its <em class="calibre17">view children</em> and <em class="calibre17">content children</em> and their descendants.</p>
<div class="packt_infobox"><br class="calibre27"/>
Before we proceed, we hope that the distinction between <em class="calibre31">view</em> and <em class="calibre31">content </em><em class="calibre31">children</em> is crystal clear to everyone. If in doubt, refer to the <em class="calibre31">Content children and view children</em> section again.</div>
<p class="calibre3">Let's take an example from <span class="calibre6"><a href="" class="calibre10">Chapter 4</a></span>, <em class="calibre17">Building Personal Trainer</em>. The <kbd class="calibre13">WorkoutBuilderService</kbd> service was registered at the app level in the workout builder module (<kbd class="calibre13">WorkoutBuilderModule</kbd>):</p>
<pre class="calibre19">providers: [ExerciseBuilderService, ...  
<strong class="calibre1">          WorkoutBuilderService]);</strong></pre>
<p class="calibre3">This allows us to inject <kbd class="calibre13">WorkoutBuilderService</kbd> across the app in order to build workouts and while running workouts. Instead, we could have registered the service at the <kbd class="calibre13">WorkoutBuilderComponent</kbd> level since it is the parent of all workout/exercise creation components, something like the following:</p>
<pre class="calibre19">@Component({ 
    template: `...` 
<strong class="calibre1">    providers:[ WorkoutBuilderService ]</strong> 
}) 
export class WorkoutBuilderComponent { </pre>
<p class="calibre3">This change would disallow injecting <kbd class="calibre13">WorkoutBuilderService</kbd> in <kbd class="calibre13">WorkoutRunner</kbd> or any component related to workout execution.</p>
<div class="packt_infobox">What if the <kbd class="calibre24">WorkoutBuilderService</kbd> service is registered at the app level as well as at the component level (as shown in the preceding example)? How does the injection happen? From our experience, we know that Angular will inject a different instance of the <kbd class="calibre24">WorkoutBuilderService</kbd> service into <kbd class="calibre24">WorkoutBuilderComponent</kbd> (and its descendants), while other parts of the application (<em class="calibre31">Workout runner</em>) will get the global dependency. Remember <strong class="calibre26">hierarchical injectors</strong>!</div>
<p class="calibre3">Angular does not stop here. It provides some further scoping of dependencies using the <kbd class="calibre13">viewProviders</kbd> property. The <kbd class="calibre13">viewProviders</kbd> property, available on the <kbd class="calibre13">@Component</kbd> decorator, allows the registering of dependencies that can be injected only in the view children.</p>
<p class="calibre3">Let's consider the <kbd class="calibre13">AjaxButtonComponent</kbd> example again, and a simple directive implementation called <kbd class="calibre13">MyDirective</kbd>, to elaborate on our discussion:</p>
<pre class="calibre19">@Directive({ 
  selector: '[myDirective]', 
}) 
export class MyDirective { 
  constructor(service:MyService) { } 
  ... 
} </pre>
<p class="calibre3">The <kbd class="calibre13">MyDirective</kbd> class depends upon a service, <kbd class="calibre13">MyService</kbd>.</p>
<p class="calibre3">To apply this directive to the <em class="calibre17">button element</em> in the <kbd class="calibre13">AjaxButtonComponent</kbd> template, we need to register the <kbd class="calibre13">MyService</kbd> dependency too (assuming that <kbd class="calibre13">MyService</kbd> has not been registered globally):</p>
<pre class="calibre19">@Component({ 
  selector: 'ajax-button', 
  template:` &lt;button [attr.disabled]="busy" ... 
<strong class="calibre1">                myDirective&gt;</strong> 
                ... 
             &lt;button&gt;` 
<strong class="calibre1">  providers:[MyService],</strong> 
... </pre>
<p class="calibre3">Since <kbd class="calibre13">MyService</kbd> is registered with <kbd class="calibre13">AjaxButtonComponent</kbd>, <kbd class="calibre13">MyDirective</kbd> can be added to its content children too. Hence the <kbd class="calibre13">myDirective</kbd> application on <em class="calibre17">spinner HTML</em> will also work (the code in <kbd class="calibre13">workout.component.html</kbd>):</p>
<pre class="calibre19">&lt;div class="ion-md-cloud-upload spin" data-animator myDirective&gt;&lt;/div&gt;</pre>
<p class="calibre3">But changing the <kbd class="calibre13">providers</kbd> property to <kbd class="calibre13">viewProviders</kbd>:</p>
<pre class="calibre19"><strong class="calibre1">viewProviders:[MyService]</strong></pre>
<p class="calibre3">Will fail the <kbd class="calibre13">MyService</kbd> injection for the <kbd class="calibre13">AjaxButtonComponent</kbd>'s content children (the <kbd class="calibre13">div</kbd> in the preceding code), with a DI error in the console.</p>
<div class="packt_infobox"><br class="calibre27"/>
Dependencies registered with <kbd class="calibre24">viewProviders</kbd> are invisible to its content children.</div>
<p class="calibre3">This dependency scoping for <em class="calibre17">the view</em> and <em class="calibre17">content children</em> may not seem useful at first sight, but it does have its benefits. Imagine we are building a reusable component that we want to package and deliver to developers for consumption. If the component has a service dependency that it prepackages too, we need to be extra cautious. If such a component allows <em class="calibre17">content injection</em> (content children), the dependent service is widely exposed if <em class="calibre17">provider-based</em> registration is used on the component. Any content children can get hold of the service dependency and use it, leading to undesirable consequences. By registering the dependency using <kbd class="calibre13">viewProvider</kbd>, only the component implementation and its child views have access to the dependency, providing the necessary layer of encapsulation.</p>
<p class="calibre3">Yet again, we are amazed by the flexibility and level of customization that the DI framework provides. While it may be intimidating for starters, once we start building more and more components/directives with Angular, we will always find areas where these concepts make our implementation simpler.</p>
<p class="calibre3">Let's shift our focus to the third classification of directives: <em class="calibre17">structural directives</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Understanding structural directives</h1>
                
            
            <article>
                
<p class="calibre3">While we will often be using structural directives, such as <kbd class="calibre13">NgIf</kbd> and <kbd class="calibre13">NgFor</kbd>, there is seldom a need to creating a structural directive. Think carefully. If we need a new view, we create a <em class="calibre17">component</em>. If we need to extend an existing element/component, we use a <em class="calibre17">directive</em>. Whereas the most common use of structural directives is to clone a piece of a view (also called a <em class="calibre17">template view</em>) and then, based on some conditions:</p>
<ul class="calibre11">
<li class="calibre12">Either inject/destroy these templates (<kbd class="calibre13">NgIf</kbd> and <kbd class="calibre13">NgSwitch</kbd>)</li>
<li class="calibre12">Or duplicate these templates (<kbd class="calibre13">NgFor</kbd>)</li>
</ul>
<p class="calibre3">Any behavior implemented using structure directives will inadvertently fall into either of these two categories.</p>
<p class="calibre3">Given this fact, instead of building our own structural directive, let's look at the source code of the <kbd class="calibre13">NgIf</kbd> implementation.</p>
<p class="calibre3">The following is an excerpt from the <kbd class="calibre13">NgIf</kbd> directive that is of interest to us. We have ignored the <kbd class="calibre13">ngIfElse</kbd> parts from the excerpt intentionally:</p>
<pre class="calibre19">@Directive({selector: '[ngIf]'})<br class="title-page-name"/>export class NgIf {<br class="title-page-name"/> constructor(private _viewContainer: ViewContainerRef, templateRef: TemplateRef&lt;NgIfContext&gt;) {<br class="title-page-name"/>    this._thenTemplateRef = templateRef;<br class="title-page-name"/> }<br class="title-page-name"/><br class="title-page-name"/> @Input()<br class="title-page-name"/>  set ngIf(condition: any) {<br class="title-page-name"/>    this._context.$implicit = this._context.ngIf = condition;<br class="title-page-name"/>    this._updateView();<br class="title-page-name"/> }<br class="title-page-name"/> private _updateView() {<br class="title-page-name"/>    if (this._context.$implicit) {<br class="title-page-name"/>      if (!this._thenViewRef) {<br class="title-page-name"/>        this._viewContainer.clear();<br class="title-page-name"/>        this._elseViewRef = null;<br class="title-page-name"/>        if (this._thenTemplateRef) {<br class="title-page-name"/>          this._thenViewRef =<br class="title-page-name"/>              this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context);<br class="title-page-name"/>        }<br class="title-page-name"/>      }<br class="title-page-name"/>    }<br class="title-page-name"/>    ...<br class="title-page-name"/>}</pre>
<p class="calibre3">No magic here, just a simple structural directive that checks a Boolean condition (<kbd class="calibre13">this._context.$implicit</kbd>) to create/destroy the view!</p>
<p class="calibre3">The first if condition above check, if the condition <kbd class="calibre13">this._context.$implicit</kbd> is <kbd class="calibre13">true.</kbd> The next condition makes sure that the view is already not rendered by checking the variable <kbd class="calibre13">_thenViewRef</kbd>. We only want to flip the view if <kbd class="calibre13">this._context.$implicit</kbd> translates from <kbd class="calibre13">false</kbd> to <kbd class="calibre13">true</kbd>. If both if's conditions are true the existing view is cleared (<kbd class="calibre13">this._viewContainer.clear()</kbd>) and the reference to the else view is cleared. The innermost if condition makes sure that the if's template reference is available. Finally, the code calls <kbd class="calibre13">_viewContainer.createEmbeddedView</kbd> to render (or re-render) the view.</p>
<p class="calibre3">It's not difficult to understand how the directive works. What needs to be detailed are the two new injections, <kbd class="calibre13">ViewContainerRef (_viewContainer)</kbd> and <kbd class="calibre13">TemplateRef (_templateRef)</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">TemplateRef</h1>
                
            
            <article>
                
<p class="calibre3">The <kbd class="calibre13">TemplateRef</kbd> class (<kbd class="calibre13">_templateRef</kbd>) stores the reference to the template that the structural directive is referring to. Remember the discussion on structural directives from <span class="calibre6"><a href="" class="calibre10">Chapter 2</a></span>, <em class="calibre17">Building Our First App - 7 Minute Workout</em>? All structural directives take a template HTML that they work on. When we use a directive such as <kbd class="calibre13">NgIf</kbd>:</p>
<pre class="calibre19">&lt;h3 *ngIf="currentExercise.exercise.name=='rest'"&gt; 
  ... 
&lt;/h3&gt; </pre>
<p class="calibre3">Angular internally translates this declaration to the following:</p>
<pre class="calibre19">&lt;ng-template [ngIf]="currentExercise.exercise.name=='rest'"&gt; 
  &lt;h3&gt; ... &lt;/h3&gt; 
&lt;/ng-template&gt; </pre>
<p class="calibre3">This is the template that structural directives work with, and <kbd class="calibre13">_templateRef</kbd> points to this template.</p>
<p class="calibre3">The other injection is <kbd class="calibre13">ViewContainerRef</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">ViewContainerRef</h1>
                
            
            <article>
                
<p class="calibre3">The <kbd class="calibre13">ViewContainerRef</kbd> class points to the container where templates are rendered. This class has a number of handy methods for managing views. The two functions that <kbd class="calibre13">NgIf</kbd> implementation uses, <kbd class="calibre13">createEmbeddedView</kbd> and <kbd class="calibre13">clear</kbd>, are there to add and remove the template HTML.</p>
<p class="calibre3">The <kbd class="calibre13">createEmbeddedView</kbd> function takes the template reference (again injected into the directive) and renders the view.</p>
<p class="calibre3">The <kbd class="calibre13">clear</kbd> function destroys the element/component already injected and clears the view container. Since every component and its children referenced inside the template (<kbd class="calibre13">TemplateRef</kbd>) are destroyed, all the associated bindings also cease to exist.</p>
<p class="calibre3">Structural directives have a very specific area of application. Still, we can do a lot of nifty tricks using the <kbd class="calibre13">TemplateRef</kbd> and <kbd class="calibre13">ViewContainerRef</kbd> classes.</p>
<p class="calibre3">We can implement a structural directive that, depending on the user role, shows/hides the view template.</p>
<p class="calibre3">Consider this example of a hypothetical structural directive, <kbd class="calibre13">forRoles</kbd>:</p>
<pre class="calibre19">&lt;button *forRoles="admin"&gt;Admin Save&lt;/button&gt; </pre>
<p class="calibre3">The <kbd class="calibre13">forRoles</kbd> directive will not render the button if the user does not belong to the <em class="calibre17">admin</em> role. The core logic would look something like the following:</p>
<pre class="calibre19">if(this.loggedInUser.roles.indexOf(this.forRole) &gt;=0){ 
      this.viewContainer.createEmbeddedView(this.templateRef); 
} 
else { 
      this.viewContainer.clear(); 
}  </pre>
<p class="calibre3">The directive implementation will need some sort of service that returns the logged-in user's details. We will leave the implementation for such a directive to the readers.</p>
<p class="calibre3">What the <kbd class="calibre13">forRoles</kbd> directive does can also be done using <kbd class="calibre13">NgIf</kbd>:</p>
<pre class="calibre19">&lt;button *ngIf="loggedInUser.roles.indexOf('admin')&gt;=0"&gt;Admin Save&lt;/button&gt; </pre>
<p class="calibre3">But the <kbd class="calibre13">forRoles</kbd> directive just adds to the template's readability with clear intentions.</p>
<p class="calibre3">A fun application of structural directives may involve creating a directive that just duplicates the template passed to it. It would be quite easy to build one; we just need to call <kbd class="calibre13">createEmbeddedView</kbd> twice:</p>
<pre class="calibre19">ngOnInit() {       
 this.viewContainer.createEmbeddedView(this._templateRef);        
 this.viewContainer.createEmbeddedView(this._templateRef); 
}  </pre>
<p class="calibre3">Another fun exercise!</p>
<p class="calibre3">The <kbd class="calibre13">ViewContainerRef</kbd> class also has some other functions that allow us to inject <em class="calibre17">components</em>, get the number of embedded views, reorder the view, and so on and so forth. Look at the framework documentation for <kbd class="calibre13">ViewContainerRef</kbd> (<span class="calibre6"><a href="http://bit.ly/view-container-ref" class="calibre10">http://bit.ly/view-container-ref</a></span>) for more details.</p>
<p class="calibre3">That completes our discussion on structural directives and it's time to start something new!</p>
<p class="calibre3">The components that we have built thus far derive their styles (CSS) from the common <em class="calibre17">bootstrap style sheet</em> and some custom styles defined in <kbd class="calibre13">app.css</kbd>. Angular has much more to offer in this area. A truly reusable component should be completely self-contained, in terms of both behavior and user interface.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Component styling and view encapsulation</h1>
                
            
            <article>
                
<p class="calibre3">A longstanding problem with web app development is the lack of encapsulation when it comes to DOM element behavior and styles. We cannot segregate one part of the application HTML from another through any mechanism.</p>
<p class="calibre3">In fact, we have too much power at our disposal. With libraries such as jQuery and powerful <em class="calibre17">CSS selectors</em>, we can get hold of any DOM element and change its behavior. There is no distinction between our code and any external library code in terms of what it can access. Every single piece of code can manipulate any part of the rendered DOM. Hence, the encapsulation layer is broken. A badly written library can cause some nasty issues that are hard to debug.</p>
<p class="calibre3">The same holds true for CSS styling too. Any UI library implementation can override global styles if the library implementation wants to do so.</p>
<p class="calibre3">These are genuine challenges that any library developer faces when building reusable libraries. Some emerging web standards have tried to address this issue by coming up with concepts such as <strong class="calibre5">web components</strong>.</p>
<p class="calibre3"><strong class="calibre5">Web components</strong>, in simple terms, are reusable user interface widgets that encapsulate their <em class="calibre17">state</em>, <em class="calibre17">style</em>, <em class="calibre17">user interface</em>, and <em class="calibre17">behavior</em>. Functionality is exposed through well-defined APIs, and the user interface parts are encapsulated too.</p>
<p class="calibre3">The <em class="calibre17">web component</em> concept is enabled by four standards:</p>
<ul class="calibre11">
<li class="calibre12">HTML templates</li>
<li class="calibre12">Shadow DOM</li>
<li class="calibre12">Custom elements</li>
<li class="calibre12">HTML imports</li>
</ul>
<p class="calibre3">For this discussion, the technology standard we are interested in is <strong class="calibre5">Shadow DOM.</strong></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Overview of Shadow DOM</h1>
                
            
            <article>
                
<p class="calibre3"><strong class="calibre5">Shadow DOM</strong> is like a parallel DOM tree hosted inside a component (<em class="calibre17">an HTML element, </em><em class="calibre17">not to be confused with Angular components</em>), hidden away from the main DOM tree. No part of the application has access to this shadow DOM other than the component itself.</p>
<p class="calibre3">It is the implementation of the Shadow DOM standard that allows view, style, and behavior encapsulation. The best way to understand Shadow DOM is to look at HTML5 <kbd class="calibre13">video</kbd> and <kbd class="calibre13">audio</kbd> tags.</p>
<p class="calibre3">Have you ever wondered how this <kbd class="calibre13">audio</kbd> declaration:</p>
<pre class="calibre19">&lt;audio src="/static/audio/nextup.mp3" controls&gt;&lt;/audio&gt; </pre>
<p class="calibre3">Produces the following?</p>
<div class="packt_figure"><img class="image-border16" src="../images/00063.gif"/></div>
<p class="calibre3">It is the browser that generates the underlying Shadow DOM to render the audio player. Surprisingly, we can even look at the generated DOM! Here is how we do it:</p>
<ul class="calibre11">
<li class="calibre12">Take the preceding HTML, create a dummy HTML page, and open it in Chrome.</li>
<li class="calibre12">Then open the <span><span>Developer tools</span> window</span> (<em class="calibre2"><span>F12</span></em>). Click on the <span>Setting</span> icon on the upper-left corner.</li>
<li class="calibre12">On the <span>General</span> settings, click on the checkbox, as highlighted in the following screenshot, to enable the inspection of Shadow DOM:</li>
</ul>
<div class="packt_figure"><img class="image-border17" src="../images/00064.jpeg"/></div>
<p class="calibre3">Refresh the page, and if we now inspect the generated <kbd class="calibre13">audio</kbd> HTML, the Shadow DOM shows up:</p>
<div class="packt_figure"><img class="calibre28" src="../images/00065.jpeg"/></div>
<p class="calibre3">Under <kbd class="calibre13">shadow-root</kbd>, there is a whole new world that the other part of the page and script do not have access to.</p>
<div class="packt_infobox">In the Shadow DOM realm, <strong class="calibre26">shadow-root</strong> (<kbd class="calibre24">#shadow-root</kbd> in the preceding code) is the root node for the generated DOM, hosted inside a <strong class="calibre26">shadow host</strong> (in this case the <kbd class="calibre24">audio</kbd> tag). When the browser renders this element/component, what gets rendered is the content from the <em class="calibre31">shadow root</em> and not the <em class="calibre31">shadow host</em>.</div>
<p class="calibre3">From this discussion, we can conclude that Shadow DOM is a parallel DOM created by the browser that encapsulates the <em class="calibre17">markup</em>, <em class="calibre17">style</em>, and <em class="calibre17">behavior</em> (DOM manipulation) of an HTML element.</p>
<div class="packt_infobox"><br class="calibre27"/>
This was a gentle introduction to Shadow DOM. To learn more about how Shadow DOM works, we recommend this series by Rob Dodson: <span class="packt_screen"><a href="http://bit.ly/shadow-dom-intro" class="calibre21">http://bit.ly/shadow-dom-intro</a></span></div>
<p class="calibre3">But what has all this got to do with Angular? As it turns out, Angular components support some sort of view encapsulation too! This allows us to isolate styles for Angular components too.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Shadow DOM and Angular components</h1>
                
            
            <article>
                
<p class="calibre3">To understand how Angular employs the concept of Shadow DOM, we will first have to learn about styling Angular components.</p>
<p class="calibre3">When it comes to styling the apps built as part of this book, we have taken a conservative approach. Be it <em class="calibre17">Workout Builder</em> or the <em class="calibre17">Workout Runner</em> (<em class="calibre17">7 Minute Workout</em>) app, all the components that we built derive their style from <em class="calibre17">bootstrap CSS</em> and from custom styles defined in <kbd class="calibre13">app.css</kbd>. No component has defined its own style.</p>
<p class="calibre3">While this adheres to the standard practices of web app development, sometimes we do need to deviate. This is especially true when we are building self-contained, packaged, and reusable components.</p>
<p class="calibre3">Angular allows us to define styles specific to a component by using the <kbd class="calibre13">style</kbd> (for inline style) and <kbd class="calibre13">styleUrl</kbd> (external style sheet) properties on the <kbd class="calibre13">@Component</kbd> decorator. Let's play around with the <kbd class="calibre13">style</kbd> property and see what Angular does.</p>
<p class="calibre3">We will use the <kbd class="calibre13">AjaxButtonComponent</kbd> implementation as our playground for the next exercise. But before doing that, let's look at the <kbd class="calibre13">AjaxButtonComponent</kbd> HTML as it stands now. The HTML tree for <kbd class="calibre13">AjaxButtonComponent</kbd> looks as follows:</p>
<div class="packt_figure"><img src="../images/00066.jpeg" class="calibre65"/></div>
<p class="calibre3">Let's override some styles using the <kbd class="calibre13">styles</kbd> property:</p>
<pre class="calibre19">@Component({ 
  ... 
  styles:[` 
    button { 
      background: green; 
    }`] 
}) </pre>
<p class="calibre3">The preceding <em class="calibre17">CSS selector</em> sets the <kbd class="calibre13">background</kbd> property to <kbd class="calibre13">green</kbd> for all HTML buttons. Save the preceding style and refresh the work builder page. The button style has been updated. No surprises here? Not true, there are some! Look at the generated <span class="calibre6">HTML</span>:</p>
<div class="packt_figure"><img src="../images/00067.jpeg" class="calibre66"/></div>
<p class="calibre3">There are some new attributes added to a number of HTML elements. And where have the recently defined styles landed? At the very top, inside the <kbd class="calibre13">head</kbd> tag:</p>
<div class="packt_figure"><img src="../images/00068.jpeg" class="calibre67"/></div>
<p class="calibre3">The style defined in the <kbd class="calibre13">head</kbd> section has an extra scope with the <kbd class="calibre13">_ngcontent-c1</kbd> attribute (the attribute name may differ in your case). This scoping allows us to style <kbd class="calibre13">AjaxButtonComponent</kbd> independently and it cannot override any global styles.</p>
<div class="packt_infobox">Angular does the same even if we use the <kbd class="calibre24">styleUrls</kbd> property. Suppose we had embedded the same CSS in an external CSS file and used this: <kbd class="calibre24">styleUrls:['static/css/ajax-button.css']</kbd> Angular would have still in-lined the styles into the <kbd class="calibre24">head</kbd> section, by fetching the CSS, parsing it, and then injecting it.</div>
<p class="calibre3">The styles that by definition, should have affected the appearance of all the buttons in the application, have had no effect. Angular has scoped these styles.</p>
<div class="packt_infobox">This scoping makes sure that the component styles do not mess with the already defined style, but the reverse is not true. Global styles will still affect the component unless overridden in the component itself.</div>
<p class="calibre3">This scoped style is the result of Angular trying to emulate the Shadow DOM paradigm. The styles defined on the component never leak into the global styles. All this awesomeness without any effort!</p>
<div class="packt_tip"><br class="calibre27"/>
If you are building components that define their own styles and want a degree of isolation, use the component's <kbd class="calibre24">style</kbd>/<kbd class="calibre24">styleUrl</kbd> property instead of using the old-school approach of having a common CSS file for all styles.</div>
<p class="calibre3">We can further control this behavior by using a <kbd class="calibre13">@Component</kbd> decorator property called <strong class="calibre5">encapsulation</strong>. The API documentation for this property mentions:</p>
<p class="calibre3"><strong class="calibre5">encapsulation:</strong> <kbd class="calibre13">ViewEncapsulation</kbd> Specify how the template and the styles should be encapsulated. The default is <kbd class="calibre13">ViewEncapsulation.Emulated</kbd> if the view has styles, otherwise <kbd class="calibre13">ViewEncapsulation.None</kbd>.</p>
<p class="calibre3">As we can see, as soon as we set the style on the component, the encapsulation effect is <kbd class="calibre13">Emulated</kbd>. Otherwise, it is <kbd class="calibre13">None</kbd>.</p>
<div class="packt_infobox">If we explicitly set <kbd class="calibre24">encapsulation</kbd> to <kbd class="calibre24">ViewEncapsulation.None</kbd>, the scoping attributes are removed and the styles are embedded in the head section as normal styles.</div>
<p class="calibre3">And then there is a third option, <kbd class="calibre13">ViewEncapsulation.Native</kbd>, in which Angular actually creates Shadow DOM for the components view. Set the <kbd class="calibre13">encapsulation</kbd> property on the <kbd class="calibre13">AjaxButtonComponent</kbd> implementation to <kbd class="calibre13">ViewEncapsulation.Native</kbd>, and now look at the rendered DOM:</p>
<div class="packt_figure"><img src="../images/00069.jpeg" class="calibre68"/></div>
<p class="calibre3"><kbd class="calibre13">AjaxButtonComponent</kbd> now has a shadow DOM! This also implies that the complete styling of the button is lost (style derived from bootstrap CSS) and the button needs to now define its own style.</p>
<p class="calibre3">Angular goes to great lengths to make sure that the components we develop can work independently and are reusable. Each component already has its own template and behavior. In addition to that, we can also encapsulate component styles, allowing us to create robust, standalone components.</p>
<p class="calibre3">This brings us to the end of the chapter, and it's time to wrap up the chapter with what we've learned.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre3">As we conclude this chapter, we now have a better understanding of how directives work and how to use them effectively.</p>
<p class="calibre3">We started the chapter by building a <kbd class="calibre13">RemoteValidatorDirective</kbd>, and learned a lot about Angular's support for <em class="calibre17">asynchronous validations</em>.</p>
<p class="calibre3">Next in line was <kbd class="calibre13">BusyIndicatorDirective</kbd>, again an excellent learning ground. We explored the <strong class="calibre5">renderer</strong> service, which allows component view manipulation in a platform-agnostic way. We also learned about <strong class="calibre5">host bindings</strong>, which let us bind to a host element's <em class="calibre17">events</em>, <em class="calibre17">attributes</em>, and <em class="calibre17">properties</em>.</p>
<p class="calibre3">Angular allows directives declared across the view lineage to be injected into the lineage. We dedicated a few sections to understanding this behavior.</p>
<p class="calibre3">The third directive (component) that we created was <kbd class="calibre13">AjaxButtonComponent</kbd>. It helped us understand the critical difference between <em class="calibre17">content children</em> and <em class="calibre17">view children</em> for a component.</p>
<p class="calibre3">We also touched upon structural directives, where we explored the <kbd class="calibre13">NgIf</kbd> platform directive.</p>
<p class="calibre3">Lastly, we looked at Angular's capabilities in terms of view encapsulation. We explored the basics of Shadow DOM and learned how the framework employs the Shadow DOM paradigm to provide view plus style encapsulation.</p>
<p class="calibre3">The next chapter is all about testing Angular apps, a critical piece in the complete framework offering. The Angular framework was built with testability in mind. The framework constructs and the tooling support make automated testing in Angular easy. More about this in the next chapter....</p>


            </article>

            
        </section>
    </body></html>