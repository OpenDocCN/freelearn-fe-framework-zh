- en: Chapter 8. Tooling and Development Experience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are already familiar with all the core concepts of Angular. We know how to
    develop a component-based user interface, taking advantage of all the building
    blocks that the framework provides – directives, components, dependency injections,
    pipes, forms, and the brand new router.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the final step, we''ll look at where to begin when we want to build a **single-page
    application** (**SPA**) from scratch. This chapter describes how to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Use Web Workers for performance-sensitive applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build SEO-friendly applications with server-side rendering.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bootstrap a project as quickly as possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhance our experience as developers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is **Ahead-of-Time** (**AoT**) compilation and how to use it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's begin!
  prefs: []
  type: TYPE_NORMAL
- en: Running an application in a Web Worker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When talking about performance in the context of frontend Web development, we
    can either mean network, computational, or rendering performance. In this section,
    we'll concentrate on rendering and computational performance, which are very tightly
    related.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's draw parallels between a Web application and a video file, and
    between a browser and a video player. The biggest difference between the Web application
    running in the browser and the video file playing in the video player is that
    the web page needs to be generated dynamically, in contrast to the video which
    has been recorded, encoded, and distributed. However, in both cases, the user
    of the application sees a sequence of frames; the core difference is in how these
    frames are generated. In the world of video processing, when we play a video,
    we have it already recorded; it is the responsibility of the video decoder to
    extract the individual frames based on the compression algorithm. In contrast
    to this, on the Web, JavaScript, HTML, and CSS are in charge of producing frames
    that are rendered later by the browser's rendering engine.
  prefs: []
  type: TYPE_NORMAL
- en: In the context of the browser, we can think of each frame as a snapshot of the
    web page at a given moment. The different frames are rendered fast, one after
    the other; so, in theory, the end user of the application should see them smoothly
    incorporated together, just like a video played in a video player.
  prefs: []
  type: TYPE_NORMAL
- en: On the Web, we try to reach 60 fps (frames per second), which means that each
    frame has about 16 milliseconds to be computed and rendered on the screen. This
    duration includes the time required by the browser to make all the necessary calculations
    for the layout and the rendering of the page (the browser's internal computations),
    and the time that our JavaScript needs to execute.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, we have less than 16 milliseconds (because of the browser's internal
    computations) for our JavaScript to finish its execution. If it doesn't fit in
    this duration, the frame rate will drop by half. Since JavaScript is a single-threaded
    language, all the calculations need to happen in the main UI thread, which can
    lead to a very poor user experience because of the frame drop.
  prefs: []
  type: TYPE_NORMAL
- en: HTML5 introduced an API called **Web Workers**, which allows the execution of
    client-side code into multiple threads. For the sake of simplicity, the standard
    doesn't allow shared memory between individual threads, but instead allows communication
    with message passing. The messages exchanged between Web Workers and the main
    UI thread must be strings, which often require the serialization and deserialization
    of JSON strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lack of shared memory between the individual workers, and the workers and
    the main UI thread brings a couple of limitations, some of which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Disabled access to the DOM by the worker threads.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Global variables cannot be shared among the individual computational units (that
    is, worker threads and main UI threads and vice versa).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web Workers and Angular
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On account of the platform agnostic design of Angular, the core team decided
    to take advantage of this API; during the summer of 2015, Google embedded Web
    Workers support into the framework. This feature allows most of the Angular applications
    to be run on a separate thread, making the main UI thread responsible only for
    rendering. This helps us achieve the goal of 60 fps much more easily than running
    the entire application in a single thread.
  prefs: []
  type: TYPE_NORMAL
- en: Web Workers support is not enabled by default. When enabling it, we need to
    keep something in mind-in a Web Worker-ready application, the components will
    not be run in the main UI thread, which does not allow us to directly manipulate
    the DOM. In this case, we need to use APIs on a higher-level of abstraction, provided
    by Angular, for establishing data binding or manipulating the elements' properties.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping an application running in a Web Worker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's make the to-do application that we developed in [Chapter 4](ch04.html
    "Chapter 4. Getting Started with Angular Components and Directives"), *Getting
    Started with Angular Components and Directives* work in a Web Worker. You can
    find the example that we'll explore at `ch8/ts/todo_webworkers/`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the Web Worker module is not finalized yet, so its API may change
    in future versions of Angular. On the other hand, the conceptual idea and the
    architecture are mature enough, so most likely there will not be any fundamental
    differences.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, let's discuss the changes that we will need to make. Take a look
    at `ch4/ts/inputs-outputs/app.ts`. Note that, inside `app.ts`, we include the
    `platformBrowserDynamic` function from the `@angular/platform-browser-dynamic`
    module. This is the first thing we need to modify. The bootstrap process of an
    application running in a background process is different.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before refactoring our code, let''s take a look at a diagram that illustrates
    the bootstrap process of a typical Angular application running in Web Workers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bootstrapping an application running in a Web Worker](img/web-workers.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1
  prefs: []
  type: TYPE_NORMAL
- en: 'This diagram has two parts: **UI** and **WebWorker**. **UI** shows the actions
    performed during initialization in the main UI thread; the **WebWorker** part
    of the diagram shows how the application is bootstrapped in the background thread.
    Now, let''s explain the bootstrap process step-by-step.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the user opens the `index.html` page, which triggers the download of
    the following two files:'
  prefs: []
  type: TYPE_NORMAL
- en: The UI bundle of Angular used for applications running in Web Worker.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `system.js` bundle (we talked about the global object `System` in [Chapter
    3](ch03.html "Chapter 3. TypeScript Crash Course"), *TypeScript Crash Course*.
    We can think of the `system.js` bundle as a polyfill for the module loader).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `system.js`, we download the script used for the initialization of the
    part of the application running in the main UI thread (`bootstrap.js`). This script
    starts `loader.js` in Web Worker. This is the first script that runs in a background
    thread. Once the worker is started, `loader.js` will download `system.js` and
    the bundle of Angular, which is meant to be run in the background thread. The
    first request will usually hit the cache because `system.js` is already requested
    by the main thread. Using the module loader, we download the script that is responsible
    for bootstrapping the background app `background_bootstrap.js`, which will finally
    start the functionality of our application, in Web Worker.
  prefs: []
  type: TYPE_NORMAL
- en: From now on, the entire application that we built will be run in Web Worker
    and will exchange messages with the main UI thread to respond to user events and
    render instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are aware of the basic flow of events during initialization when
    using workers, let's refactor our to-do application to take advantage of them.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating an application to Web Worker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's show how we can make an application compatible with Web Workers. This
    way, we can reduce the frame drop in computationally intensive apps, since we'll free
    the main UI thread and let it be responsible only for rendering.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `index.html`, we will need to add the following scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we've included references to `system.js`, `zone.js`,
    and `reflect-metadata`. `zone.js` is a polyfill for the zones that Angular exclusively
    uses, that we mentioned earlier in the book. `reflect-metadata` contains another
    polyfill for the Metadata Reflection API, which at the moment of writing is not
    yet available in browsers.
  prefs: []
  type: TYPE_NORMAL
- en: For the next step, we will explicitly import the `bootstrap.js` file, which
    contains the logic used to start the `loader.js` script in Web Worker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore `bootstrap.ts`, which is the original TypeScript version of
    the transpiled `bootstrap.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We pass `'loader.js'` to the invocation of `bootstrapWorkerUi`. This way, Angular
    knows that `loader.js` will run in a background thread. The script is located
    in the application's root.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can move to the right-hand side of the diagram shown in the *Bootstrapping
    an application running in a Web Worker* section. The logic in `loader.ts` (the
    original TypeScript version of `loader.js`) is quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As the first step, we import `SystemJS`, `ReflectMetadata` polyfils, `zone.js`,
    and the configuration for `SystemJS`. As this script is already run in Web Workers,
    we have the `importScripts` function, which allows us to load the listed files
    synchronously. As the last step, with `System`, we import the script that contains
    our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s explore how we bootstrap the application inside of the Web Worker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding process is quite similar to what we used to do when bootstrapping
    an Angular application running in the main UI thread. We import the `platformWorkerAppDynamic` function
    and invoke it with the root module of the application as its first argument.
  prefs: []
  type: TYPE_NORMAL
- en: Making an application compatible with Web Workers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we said, the code that runs in the context of Web Worker does not have access
    to the DOM. Let's see what changes we need to make in order to address this limitation.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the original implementation of the `InputBox` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note that, inside the template, we reference the input element with the identifier `todoInput`
    and use the reference within the expression set as the handler of the click event.
    This code will not be able to run in Web Worker, since we directly access a DOM
    element inside the template. In order to take care of this, we will need to refactor
    the snippet, so it uses Angular data binding instead of directly touching any
    element. We can either use inputs when a single direction binding makes sense
    or `NgModel` to achieve two-way data binding, which is a bit more computationally
    intensive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use `NgModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this version of the `InputBox` component, we create a two-way data binding
    between the input element and the `input` property of the `InputBox` component.
    Once the user clicks on the button, the `emitText` method will be invoked, which
    will trigger a new event emitted by `inputText` `EventEmitter`. In order to reset
    the value of the input element, we take advantage of the two-way data binding
    mechanism of Angular and set the value of the `input` property to the empty string;
    this will automatically update the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Moving the entire logic from the templates of the components to their controllers
    brings a lot of benefits, such as improved testability, maintainability, code
    reuse, and clarity.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code is compatible with the Web Worker environment, as the `NgModel`
    directive is based on an abstraction that does not manipulate the DOM directly. Instead,
    it delegates this responsibility to another abstraction called `Renderer`, which
    when running in a Web Worker exchanges messages asynchronously with the main UI
    thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'To recap, we can say that, while running applications in the context of Web
    Workers, we need to keep the following two things in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to use a different bootstrap process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We should not access the DOM directly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Typical scenarios that violate the second point are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Changing the DOM of the page by selecting an element and manipulating it directly
    with the browser's native APIs or with a third-party library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing native elements injected using `ElementRef`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a reference to an element in the template and passing it as an argument
    to methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directly manipulating an element referenced within the template.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In all these scenarios, we would need to use the higher-level APIs provided
    by Angular. If we build our applications according to this practice, we will benefit
    not only from being able to run them in Web Workers, but also from increasing
    the code reuse in case we want to use them across different platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping this in mind and following best practices will also allow us to take
    advantage of server-side rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Initial load of a SPA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will explore what a server-side rendering is, why we need
    it in our applications, and how we can use it with Angular.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our purpose, we''ll explain the typical flow of events when a user opens
    a SPA implemented in Angular. First, we''ll trace the events with the server-side
    rendering disabled, and after that, we''ll see how we can benefit from this feature
    by enabling it. Our example will be illustrated in the context of HTTP 1.1:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Initial load of a SPA](img/2-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2* shows the first request by the browser and the corresponding server''s
    response when loading a typical SPA. The result that the client will see initially
    is the content of the HTML page without any rendered components.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's suppose that we deploy the to-do application we built in [Chapter 4](ch04.html
    "Chapter 4. Getting Started with Angular Components and Directives"), *Getting
    Started with Angular Components and Directives*, to a web server that has the
    `example.com` domain associated with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the user navigates to `https://example.com/`, the browser will open a
    new HTTP GET request, fetching the root resource (`/`). When the server receives
    the request, it will respond with an HTML file that, in our case, will look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The browser will receive this content as the body of the response. When the
    markup is rendered onto the screen, all that the user will see is the **Loading...**
    label.
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, the browser will find all the references in the HTML file's
    external resources, such as styles and scripts, and start to download them. In
    our case, some of them are `bootstrap.css`, `es6-shim.min.js`, `Reflect.js`, `system.src.js`,
    and `angular-polyfills.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Once all the referenced resources are available, there still won't be any significant
    visual progress for the user (except if the styles from the downloaded CSS file
    are applied to the page). This won't change until the JavaScript virtual machine
    processes all the referenced scripts related to the application's implementation.
    At this point, Angular will know which component needs to be rendered based on
    the current URL and configuration.
  prefs: []
  type: TYPE_NORMAL
- en: If the component associated with the page is defined in a separate file outside
    of our main application bundle, the framework will need to download it together
    with its entire dependency graph.
  prefs: []
  type: TYPE_NORMAL
- en: If we're using JiT compilation, in case the template and the styles of the component
    are externalized, Angular will need to download them as well before it is able
    to render the requested page. Right after this, the framework will be able to
    compile the template associated with the target component and render the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this scenario, these are the two main pitfalls:'
  prefs: []
  type: TYPE_NORMAL
- en: In case of large applications and/or poor Internet connection, the user experience
    will be poor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search engines are not that good at indexing dynamic content generated by JavaScript;
    this means that the **SEO** (**Search Engine Optimization**) of our SPA will suffer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the past, we solved the SEO issue in the applications built with AngularJS
    with different workarounds, such as using a headless browser for rendering the
    requested page, caching it onto the disk, and later providing it to search engines.
    However, there's a more elegant solution.
  prefs: []
  type: TYPE_NORMAL
- en: Initial load of a SPA with server-side rendering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A couple of years ago, libraries such as *Rendr*, *Derby*, *Meteor*, and the
    others introduced the concept of **isomorphic** JavaScript applications, which
    were later renamed **universal**. In essence, universal applications could be
    run both on the client and on the server. Such portability is only possible in
    the case of low coupling between the SPA and the browser's APIs. The greatest
    benefit of this paradigm is that the application can be rendered on the server
    and sent to the client.
  prefs: []
  type: TYPE_NORMAL
- en: Universal applications are not framework specific; we can take advantage of
    them in any framework that can be run outside of the environment of the browser.
    Conceptually, the practice of server-side rendering is very similar across platforms
    and libraries; only its implementation details may differ. For instance, the Angular
    Universal module, which implements server-side rendering, supports node.js as
    well as ASP.NET.
  prefs: []
  type: TYPE_NORMAL
- en: '![Initial load of a SPA with server-side rendering](img/3-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3* shows the response by the server to the initial browser GET request.
    This time, in contrast to the typical scenario of loading a SPA, the browser will
    receive the HTML of the rendered page.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's trace the flow of the events in the same application with the server-side
    rendering feature enabled. In this case, once the server receives the HTTP GET
    request by the browser, it will run the SPA on the server in the environment of
    node.js. All the DOM calls will be redirected to a server-side DOM implementation
    and executed in the context of the used platform. Similarly, all the AJAX calls
    with the Angular HTTP module will be handled by the server-side implementation
    of the module. This way, the application will not make any difference, whether
    it is running in the context of the browser or the server.
  prefs: []
  type: TYPE_NORMAL
- en: Once the rendered version of the SPA is available, it can be serialized to HTML
    and sent to the browser. This time, during the application's initialization, instead
    of the **Loading...** label, the user will see the page they requested right away.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, at this point, the client will have the rendered version of the application,
    but all the referenced external resources, such as scripts and styles, still need
    to be available. This means that, initially, none of the CSS styles declared in
    the external files will be applied and the application will not be responsive
    to any user-related interactions, such as the mouse and keyboard events.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that in case the scripts are inlined on the server-side rendered page,
    the application will be responsive to user events. However, inlining big chunks
    of JavaScript is generally considered a bad practice, as it will increase the
    page's size dramatically and prevent the scripts from caching; both will influence
    the network performance.
  prefs: []
  type: TYPE_NORMAL
- en: When the JavaScript virtual machine processes the JavaScript associated with
    the page, our SPA will be ready to use.
  prefs: []
  type: TYPE_NORMAL
- en: Server-side rendering with Angular
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During the first half of 2015, Patrick Stapleton and Jeff Whelpley announced
    that they had started the development of the module, **Universal**. Universal
    is a library that allows us to build universal (also called isomorphic) JavaScript
    applications with Angular; in other words, it provides server-side rendering support.
  prefs: []
  type: TYPE_NORMAL
- en: Applications using Angular Universal and rendered on the server will not be
    responsive to user interaction until all the JavaScript belonging to the requested
    page has been processed. This is a drawback that we already mentioned, which is
    valid for all server-side rendered applications. To handle this problem, Patrick
    and Jeff introduced **preboot.js**, which is a lightweight library that will be
    inlined on the page rendered by the server and available after the initial client
    request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Preboot.js has several strategies for the management of the received client
    events before the application is completely initialized; they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Recording and playing back events.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Responding immediately to events.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintaining focus when a page is re-rendered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Buffering client-side re-rendering for smoother transition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Freezing a page until the bootstrap is complete if a user clicks on a button.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the time of writing this book, the Universal module was still being actively
    developed. You can give it a try using the Angular universal starter at [https://github.com/angular/universal-starter](https://github.com/angular/universal-starter)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing our development experience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our experience as developers can be enhanced in terms of productivity or by
    allowing us to have more fun while working on our projects. This can be achieved
    with all the tools, IDEs, text editors, and more, which we use on a daily basis.
    In this section, we'll take a brief look at popular IDEs and text editors that
    take advantage of the statically analyzable syntax that Angular provides. We'll
    also mention the language service that the Angular team developed.
  prefs: []
  type: TYPE_NORMAL
- en: Text editors and IDEs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we have already said at the beginning of the book, the core team put a lot
    of effort into enhancing the tooling support in Angular. First of all, the framework
    is built with TypeScript, which naturally allows us to use static typing during
    our development process. Some of the text editors and IDEs that have great TypeScript
    support are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**IntelliJ Idea**: A general-purpose IDE by JetBrains.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WebStorm**: An IDE specialized for Web development by JetBrains.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VSCode**: A cross-platform text editor written in TypeScript and developed
    by Microsoft.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sublime Text**: A cross-platform text editor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Atom**: A cross-platform text editor written in JavaScript, based on Electron.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recently, JetBrains announced advanced Angular support in IntelliJ Idea and
    WebStorm, which supports autocompletion for components and bindings.
  prefs: []
  type: TYPE_NORMAL
- en: Although not all the mentioned IDEs and text editors have Angular-specific features at
    the time of writing this book, the framework comes with tooling in mind. It allows
    us to perform advanced static code analysis on the application's code base for
    the development of sophisticated refactoring and productivity tools in the near
    future.
  prefs: []
  type: TYPE_NORMAL
- en: Angular language service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Taking advantage of the analyzable nature of Angular, Google developed a **language
    service** for the framework. We can think of this service as a server, which indexes
    our project and provides autocompletion suggestions, type checking in templates,
    based on requests from a client. This client can be a plugin of our text editor
    or IDE.
  prefs: []
  type: TYPE_NORMAL
- en: The language service can keep track of the context of the given component that
    is in focus in your text editor and provide context-specific suggestions. For
    instance, it can provide autocompletion suggestions for directive selectors based
    on the available set of directives at the given part of the component tree.
  prefs: []
  type: TYPE_NORMAL
- en: The best thing about the language service is that it is not coupled to any specific
    text editor or IDE, which means that, with a thin plugin, it can be reused in
    any development environment.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping a project with angular-cli
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During AngularConnect 2015, Brad Green and Igor Minar, part of the Angular team,
    announced `angular-cli`-a **CLI** (**command-line interface**) tool to ease starting
    and managing Angular applications. For those who have used Ruby on Rails, the
    idea behind the CLI tool might be familiar. The basic purpose of the tool is to
    allow the quick setup of new projects and scaffolding of new directives, components,
    pipes, and services.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, the tool is based on webpack and is in the early stages
    of development, so we'll demonstrate only its basic usage.
  prefs: []
  type: TYPE_NORMAL
- en: Using angular-cli
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to install the CLI tool, run the following command on your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Right after this, the `ng` command will appear as global executable in your
    system. For creating a new Angular project, use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding commands will perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Angular project and install all of its node.js dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enter your project's directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Start a development web server that will let you open the application you have
    just created in your web browser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For further reading, take a look at the project's repository, located at [https://github.com/angular/angular-cli](https://github.com/angular/angular-cli)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Angular quick starters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you prefer to not get coupled with the CLI tool, there are a lot of starter
    projects developed by the community that can provide a great starting point for
    your next Angular project.
  prefs: []
  type: TYPE_NORMAL
- en: Angular Seed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you enjoy static typing, you can give the **angular-seed** project a try.
    It is hosted on GitHub at  [https://github.com/mgechev/angular-seed](https://github.com/mgechev/angular-seed)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'The Angular Seed provides the following key features:'
  prefs: []
  type: TYPE_NORMAL
- en: Easy for extend, modular, and statically typed build systems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AoT compilation support.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supports multiple Angular applications with a shared code base in a single instance
    of the seed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Production and development builds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sample unit tests with Jasmine and Karma.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: End-to-end tests with Protractor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A development server with LiveReload.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses codelyzer for static code analysis, which verifies that your project follows
    the Angular style guide to some extent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Follows the best practices for your applications' and files' organization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manager for the TypeScript-related type definitions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides full Docker support for both development and production environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code distributed with the book is based on this seed project.
  prefs: []
  type: TYPE_NORMAL
- en: 'For `angular-seed`, you will need to have node.js, npm, and git installed and
    will need to run the following list of commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: After you have run the preceding commands, your browser will automatically open
    the home page of the seed. Upon the change of any of the files in your project,
    the application will be automatically rebuilt, and your browser will be refreshed.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the production build produces a single bundle that contains a minified
    version of the application and all the referenced libraries. Angular Seed also
    supports AoT compilation and extensible build systems.
  prefs: []
  type: TYPE_NORMAL
- en: Angular 2 Webpack starter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you prefer Webpack, you can use *angular2-webpack-starter*. It is a starter
    project developed by *AngularClass* and hosted on GitHub. You can find it at 
    [https://github.com/AngularClass/angular2-webpack-starter](https://github.com/AngularClass/angular2-webpack-starter)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'This starter provides the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: The best practices in file and application organization for Angular.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ready-to-go build system using Webpack for working with TypeScript.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing Angular code with Jasmine and Karma.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coverage with Istanbul and Karma.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: End-to-end Angular code using Protractor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type manager with Typings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to give it a try, you will need to have node.js, npm, and git installed
    and run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: AoT compilation in Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll briefly explain what AoT compilation is in the context
    of Angular and what implication it may have on our projects, without going into
    deep technical details.
  prefs: []
  type: TYPE_NORMAL
- en: The key focus in Angular is it's extremely fast change detection mechanism.
    After exploring different options for performing change detection, the Angular
    team discovered that the change detection mechanism used in AngularJS can be improved
    dramatically using **code generation**. It turns out that generating code, which
    performs change detection and rendering and on top of that is very well optimized
    for the JavaScript virtual machine, runs much faster compared to the traditional
    (also known as dynamic) change detection mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: How code generation works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Angular code generator is known as the Angular compiler. What it does is
    compile the templates of the Angular components to JavaScript or TypeScript (depending
    on the use case). When we compile the templates to TypeScript, we allow the TypeScript
    compiler to perform type checking, not only within the imperative logic of our
    components, directives, services and pipes, but also in the components' templates!
    Performing type checking in the templates helps us find even more potential issues
    in our application.
  prefs: []
  type: TYPE_NORMAL
- en: On top of code generation for templates, the Angular compiler also generates
    code for the injectors in our application. This improves the performance of the
    dependency injection mechanism even further.
  prefs: []
  type: TYPE_NORMAL
- en: Based on the static analysis of the bindings in the templates, the generated
    code for the templates performs the most efficient change detection and most optimal
    update of the DOM tree, depending on the changed values. On top of that, the produced
    code takes advantage of the inline caching mechanism of JavaScript virtual machines,
    which brings an additional performance boost.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For further reading about inline caching, take a look at the article *Explaining
    JavaScript VMs in JavaScript - Inline Caches* located at [http://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html](http://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html).
  prefs: []
  type: TYPE_NORMAL
- en: The code generation could be either performed at runtime, known as **Just-in-Time**
    (**JiT**) compilation or build time, known as **Ahead-of-Time** (**AoT**) compilation.
    Since the JiT compilation involves the evaluation of code at runtime, it is recommended
    that you use AoT in environments with strict **CSP** (**Content-Security-Policy**),
    where `eval` is not available.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing AoT compilation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From AoT, we get a couple of improvements. Firstly, if we compile our Angular
    application as part of the build process, we don't need to compile it at runtime.
    This has two implications. Firstly, we don't have the runtime performance hit
    that we get when using JiT. This way, AoT offers faster initial rendering of the
    application because Angular has to do less work during initialization.
  prefs: []
  type: TYPE_NORMAL
- en: On top of that, since we don't have to perform compilation at runtime anymore, we
    can drop the entire `@angular/compiler` module out of the final application bundle
    and decrease the bundle size.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can perform much more efficient dead code elimination in terms of
    **tree-shaking**. Tree-shaking means dropping unused exports, which is one of
    the great properties of the static nature of the ES2015 modules. When relaying
    on JiT compilation, we can reference different components by their selectors inside
    the templates. However, the templates are in HTML-like format, which the modern
    minifiers (such as uglifyjs, Google Closure Compiler, and so on) don't understand.
    This means that they cannot eliminate all the unused exports (for instance, unused
    components), since they are not sure what exactly is used within the templates.
    Once at build time, the Angular compiler translates the templates to TypeScript
    or JavaScript, with static ES2015 imports, bundlers can apply traditional dead-code
    elimination techniques, and so reduce the bundle size even further!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you're interested in further reading, you can take a look at the article
    *Ahead-of-Time Compilation in Angular* at [https://goo.gl/eXieJl](https://goo.gl/eXieJl).
  prefs: []
  type: TYPE_NORMAL
- en: Constraints of the AoT compilation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Keep in mind that the Angular compiler needs type metadata in order to perform
    the process of compilation. This means that you cannot perform AoT compilation
    if you're not using TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: AoT compilation is performed without any data collected at runtime. This means
    that, in some cases, your code may work with JiT but may not work in AoT in case
    you have dynamic constructs, which cannot be resolved at build time.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For further details, take a look at this repository at   [https://goo.gl/F7cV1s](https://goo.gl/F7cV1s).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the generated code for the templates is not part of the components'
    controllers themselves. This means that we cannot bind to non-public fields because,
    during compilation, TypeScript will throw an error.
  prefs: []
  type: TYPE_NORMAL
- en: How to use the AoT compilation of Angular
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Angular's AoT compilation is already supported in the most popular starters
    and the CLI.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, Angular CLI does not perform an AoT compilation by
    default. You can enable it using the `--aot` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Angular Seed introduced AoT compilation when Angular 2.0.0-rc.5 was released.
    With the seed, you can take advantage of all the benefits that come with it by
    performing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: By running the commands above, you'll get a well-optimized production build
    of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since web tooling changes quite frequently, we didn't go into details of how
    Angular Seed or Angular CLI produce the production build. If you're interested
    in further reading on what is going on under the hood, you can take a look at
    an article at [https://goo.gl/kAiJUJ](https://goo.gl/kAiJUJ).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started our journey by introducing the reasons behind the rewrite of Angular,
    which was followed by a conceptual overview that gave us a general idea about
    the building blocks that the framework provides. In the next step, we went through
    a TypeScript crash course that prepared us for [Chapter 4](ch04.html "Chapter 4. Getting
    Started with Angular Components and Directives"), *Getting Started with Angular
    Components and Directives*, where we went deep into Angular's directives, components,
    and change detection.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](ch05.html "Chapter 5. Dependency Injection in Angular"), *Dependency
    Injection in Angular*,we explained the dependency injection mechanism and saw
    how it's related to the component hierarchy. In the next chapters, we saw how
    we can build forms and pipes and take advantage of Angular's router.
  prefs: []
  type: TYPE_NORMAL
- en: By completing this chapter, we have finished our journey into the framework.
    At the time of writing, the design decisions and the ideas behind Angular's core
    are solid and finalized. Although the framework is still brand new, in the past
    couple of months, its ecosystem reached a level where we can develop production-ready,
    high-performance, SEO-friendly applications, and on top of this, have a great
    development experience with static typing and IDE support.
  prefs: []
  type: TYPE_NORMAL
