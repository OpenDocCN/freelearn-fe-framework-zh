- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MonoRepo Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we think about building apps, we usually talk about an app, a `git` repository,
    and a build output. However, this configuration of an application and a repository
    does not always reflect the real-world experience of developers. Often organizations
    will use a single repository with all the applications, components, and libraries
    that could be used in common development. These are called a monorepository or
    single repository, and they are starting to become very popular.
  prefs: []
  type: TYPE_NORMAL
- en: So, what makes a monorepository interesting for organizations? Why put all the
    code in one place? Why not have a single `git` repository where you have many
    small and separate repositories? If we keep all our code in one project.
  prefs: []
  type: TYPE_NORMAL
- en: By keeping all the code in one repository, you keep all dependencies up to date
    across the organization. This is probably the biggest benefit of a single repository.
    This way we will stop having to waste time updating all the dependencies of several
    different projects.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll be walking through how to create a monorepository with
    multiple packages using TypeScript, webpack, and NPM Workspaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of a monorepository and the problems it solves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a monorepository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing TypeScript in the monorepository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a `devtools` package to compile other packages with Webpack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a `utils` package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a multi-site system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js 19+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find the code for this chapter in the book’s GitHub repository: [https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter14](https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter14).'
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of a monorepository and the problems it solves
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some of the advantages of a **MonoRepo** (**monorepository**) are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sharing is made easy**: With all the code in one place, it becomes easier
    to utilize the same code or tools across multiple projects, saving valuable time
    and effort.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No mix-ups**: In a MonoRepo, every project utilizes the same version of shared
    components, eliminating concerns about compatibility issues between different
    versions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Change everything at once**: In a MonoRepo, making changes across all projects
    simultaneously becomes a straightforward task, as opposed to the complexity of
    managing individual projects in separate repositories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Grouped changes**: Modifying multiple projects simultaneously within a MonoRepo
    ensures that all related components stay synchronized, allowing for efficient
    and cohesive updates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Everyone can see everything**: With all the code centralized in one repository,
    all developers have access to it, fostering a better understanding of the entire
    system and facilitating effective collaboration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now let’s explore some of the real-life problems that a MonoRepo solves:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Faster updates**: With a MonoRepo, you can update all projects at once. Without
    it, you’d have to update each project separately, which can take a lot of time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No more confusion**: Without a MonoRepo, different projects might use different
    versions of the same thing, which can cause problems. With a MonoRepo, everything
    uses the same version, so there’s no confusion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Better teamwork**: With all the code in one place, developers can easily
    see and understand what others have done. This can help them work together better.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easier start for newbies**: For new team members, it’s easier to get started
    when all the code is in one place. They can quickly understand the whole system,
    rather than having to search through different places.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important to remember that MonoRepos may not always be the optimal choice.
    They can introduce their own challenges, such as potential performance issues
    and increased complexity when they become excessively large. Whether adopting
    a MonoRepo is a suitable approach depends on the specific needs of the team and
    the scale of their projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following image you can see how the structure of a **MonoRepo** is different
    from that of a **Multi Repo**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer screen  Description automatically generated with
    low confidence](img/B18414_14_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.1: MultiRepo vs MonoRepo'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve shed light on the concept of a monorepository and explored why
    it is becoming increasingly popular for organizations, we will delve into the
    practical implementation of a monorepository using NPM Workspaces.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a MonoRepo with NPM Workspaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**NPM Workspaces** was introduced in NPM 7 and is a generic term that refers
    to the set of features in the npm CLI that provides support for managing multiple
    packages from your local filesystem, from within a singular top-level root package.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you need to do in order to create a monorepository is to create
    a root `package.json` file, which should contain the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We will name our MonoRepo `web-creator`. We need to specify that `web-creator`
    will be private (only the root), and we need to specify the workspaces where our
    packages will live, which is on `"packages/*"`; the `*` means that we will include
    any directory that exists under the `packages` folder. After this, you need to
    create the packages directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create two directories inside our new `packages` folder: `"packages/api"`
    and `"packages/frontend"`. Now go to your `api` project and run `npm init -y`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you run that command it will create a `package.json` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the name of that package by default will be `"api"`, but in
    order to connect that package to our main monorepository, we need to call it with
    a special format; in this case, you need to rename it `"@<name_of_root_package>/api"`,
    which in our example will be `"@web-creator/api"`. Your `package.json` should
    be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you need to create a file (`packages/api/index.js`) inside your `api` directory
    (later we will change this to TypeScript) with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, you need to go to your `frontend` package (`packages/frontend`)
    and run the same `npm init -y` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, you will need to rename that package `@web-creator/frontend`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The monorepository now is ready to share packages. Let’s suppose you now want
    to consume your `api` package in your `frontend` package. To do this, you need
    to specify the `api` package as a dependency and put the same version we have
    in that `api` package; in this case, the version will be 1.0.0\. You need to be
    very careful and not change this version unless you really need to, and if you
    change it then you will need to update it on the `dependencies` node as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will be your `package.json` from `packages/frontend`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After you’ve specified the `api` package as a dependency, you need to run `npm
    install` inside the frontend project. One very interesting thing you will notice
    is that even if you run the `npm install` command inside the `frontend` package
    (`packages/frontend`), your `node_modules` folder will be created at the root
    level, and it will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18414_14_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.2: Monorepo structure'
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything worked as expected, you can consume your `api` package in your
    `frontend` package. For this, you need to create an `index.js` file inside `packages/frontend/index.js`
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can execute your index file with `node` and see the console message
    that comes from the `api` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18414_14_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.3: Running frontend'
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the biggest advantages of a monorepository is that if you update your
    API `index.js`, the change will be reflected right away without you having to
    compile anything or publish any package to the NPM registry. This is very helpful
    and saves a lot of time for developers when coding large projects. Let’s change
    our message now to `I''m the API package UPDATED` in the `packages/api/index.js`
    and run the `index.js` again with `node`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18414_14_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.4: Updating the API'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations, you have created your first MonoRepo successfully! In the next
    section, we will transform our MonoRepo to use TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing TypeScript in our MonoRepo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following sections, I will outline the steps to create a multi-site project.
    Due to the substantial amount of code involved, I’m unable to include it all in
    this book. However, I invite you to review the complete code in the repository
    available at [https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter14/web-creator](https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter14/web-creator).
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you need to do in order to add TypeScript to your project is
    to install the `typescript` package at the root level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, you need to create the `tsconfig.json` file at the root level as
    well with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we extend the `tsconfig.json` file to `tsconfig.common.json`,
    and this is because we don’t want to to repeat each package that we want to transform
    to TypeScript. The only `compilerOptions` we want to specify is the `baseUrl`
    on our `packages` directory, and in the paths we will specify the name of our
    MonoRepo to be able to do imports in the code. This is the `tsconfig.common.json`
    file that you need to create:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The architecture of our project will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chart, bubble chart  Description automatically generated](img/B18414_14_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.5: Web creator architecture'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have explored the project’s architecture, let’s dive into the first
    package that will manage our Webpack configurations. This package will be referred
    to as `devtools`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a devtools package to compile packages with Webpack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first package we need to create to be able to compile other packages is
    called `devtools` and should be created in `packages/devtools`. Let’s see how
    it should look in its `package.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'After you create the `package.json`, you need to create the `tsconfig.json`
    file for `devtools`. Each package will have its own `tsconfig.json` file. Basically
    we will extend our `tsconfig.common.json` from root and just specify the `outDir`
    and include the files inside the `src` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Creating a colorful log
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to create a log function that will help us highlight the Webpack configuration
    that we will implement, and for this we will use the `cli-color` package, which
    adds colors to the logs. You need to create the file under `packages/devtools/src/cli/log.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Webpack common configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have our log function ready, we will continue creating the Webpack
    configuration. We will break our Webpack configuration into three files: `webpack.common.ts`,
    `webpack.development.ts`, and `webpack.production.ts`. The common configuration
    will be merged with the development and production separately. However, before
    creating our common configuration, we need to create our Webpack types, and you
    need to add this file to `packages/devtools/src/webpack/webpack.types.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s create our `webpack.common.ts` file, starting with the packages we
    need to import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we need to create the `getWebpackCommonConfig` function, which will receive
    arguments from the terminal to compile each package via the NPM script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The blocks of code that you will see next from this chapter’s GitHub repository
    need to be added where the comment is located in the previous code: `// Here goes
    the next block of codes`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First let’s check if we are running a sandbox (this will be for our design-system
    package). If yes, we will use port `8080`, and if not, we will use the `port +
    1` (`3001`by default):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The first configuration option we need to create is `entry`, which will define
    the index file that we will use to compile our project, based on the `packageName`
    we specify in our script. We can create `entry` by running the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: When our `configType` is `"package"` (or different than `'web'`), we will specify
    the `index.ts` as `entry`, and for the web packages, we will use `index.tsx`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second configuration option we need to create is going to be the `resolve`
    node, which will include the extensions we want to support and the alias for each
    package (`~`). In Webpack 5, we must turn off some fallback packages that are
    not enabled by default anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The third configuration option is the `output`, which will specify where we
    will place the compiled project (the `dist` directory), which will be the dynamic
    filename (`[name].js`). If we want to compile a package, we will add the necessary
    options to be able to export that package (`libraryTarget`, `library`, `umdNamedDefine`,
    and `globalObject`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The fourth configuration option is the `plugins`, which will be applied based
    on some conditions, depending on if we want to analyze our bundle sizes (`BundleAnalyzerPlugin`)
    and add a template with `HtmlWebPackPlugin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The fifth configuration option is the `rules`, which we will define depending
    on the extension file we want to process. We will also use Webpack loaders like
    `ts-loader` to load TypeScript files or `svg-url-loader` and `@svgr/webpack` to
    load SVG files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we put all the options together in the `webpackConfig` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Webpack development configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After creating our Webpack common configuration file, we now need to create
    our `webpack.development.ts` file, which is way smaller than the common one and
    will extend that configuration (on `webpack.config.ts`), specifying the development
    mode for Webpack, adding the source map, and passing the `HMR` plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Webpack production configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last file we need to create is the `webpack.production.ts`, which will
    will use external libraries when we try to compile a package that uses shared
    libraries like **React**, **Apollo Server**, or **JSON Web Tokens**, put the `mode`
    as production, and disable the source map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s all for our `devtools` package. Now we only need to create the `index.ts`
    file in `packages/devtools/src/index.ts` to export all the Webpack configuration
    and be able to compile our `devtools` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this will be the base package that will compile other packages, first
    we need to build it, and for this, we will just use the `tsc` command to transform
    TypeScript into JavaScript files. For this, you just need to run the `build` command
    inside `packages/devtools`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything is correct, you should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B18414_14_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.6: npm run build'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to create the `webpack.config.ts` file at the root level where
    we will consume our brand-new `devtools` package and merge the configurations
    (development + common or production + common) using `webpack-merge`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Creating the utils package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After we’ve created the `devtools` package, it is time to add a basic `utils`
    package to test the Webpack compilation with `devtools`. For this, you will need
    to create a directory at `packages/utils`. For the example in the book, we will
    just add one `util` file to test our `devtools`, but in the actual repository
    you will find way more `util` files that have been added to the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'As always let’s start creating our `package.json` in the `utils` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'There are some important elements in this `package.json` that I want to mention:'
  prefs: []
  type: TYPE_NORMAL
- en: The first one is the name of the package, which is `@web-creator/utils`. As
    I mentioned before, this is the correct format to name packages inside our MonoRepo.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second node is `version`, which always will be `1.0.0` (unless you want
    to publish this package to the NPM registry; for now you don’t need to worry about
    that).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main` is to specify where our `utils` code will exist, which will always be
    in `dist/index.js`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `types` node is to be able to load our TypeScript types; if you don’t specify
    this, it won’t be possible to see the types you add to your `utils` package when
    you consume this package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally the `files` node is an array that will contain the `dist` directory
    that will contain the compiled package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, the scripts have some interesting things that you should know.
    Our `build` command will run multiple scripts using `npm-run-all`, which is a
    library that helps us run multiple scripts one after the other. In this case,
    we always execute the script `clean` first to remove our `dist` folder and start
    fresh. Then we `compile` the code with TypeScript (`tsc`), then we execute `webpack:production`.
    This will execute `webpack`, specifying the configuration file that exists at
    the root (two levels behind). We also use the `--env` flag to pass values as variables.
  prefs: []
  type: TYPE_NORMAL
- en: These variables are defined in our `webpack.config.ts` file. In this case, we’re
    passing `mode=production`, `type=package`, and `packageName=utils`.
  prefs: []
  type: TYPE_NORMAL
- en: If you notice, some scripts contain `npm run --prefix ../../`, and I’m pretty
    sure you are wondering what exactly the `--prefix` flag is in this command. It
    is essentially a way to tell NPM that we want to run a script from a different
    `package.json`. In this specific example, we are going back two levels to run
    the script `lint` that exists in our root `package.json`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s create our first `util` file, which is going to be called `is.ts`,
    and you must save it in `packages/utils/src/utils/is.ts` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'After you create this `util`, you need to create the `index.ts` file in `packages/utils/src/index.ts`,
    where you will export all your `utils`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you must add a script to your root `package.json` to be able to compile
    your brand-new `utils` package. Here is how your root `package.json` file should
    look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we need to add a `build:package_name`(in this case,`build:utils`)
    script for each package that we want to build, and then our build script will
    execute all of them using `npm-run-all build:*`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can build your `utils` package by running the `npm run build` script
    inside the `utils` directory; you should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B18414_14_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.7: Building utils'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following this, you should see the Webpack configuration log that we use to
    compile this package:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text, timeline  Description automatically generated](img/B18414_14_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.8: Webpack configuration'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then at the end, you will see the compiled files by Webpack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B18414_14_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.9: Compiled files by Webpack'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have created our first package, which is compiled with `devtools`,
    and understand the structure of a package, it’s time to start working on our API.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the API package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this package, we will implement a multi-service system that will help us
    have more than one service to connect to multiple databases. Let’s see how our
    `package.json` file should look for the `api` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we will use Sequelize (an ORM) and PostgreSQL for the database,
    but feel free to use MySQL or any other type of database supported by Sequelize.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we’ll guide you through each of these steps in detail.
    We’ll demonstrate how to integrate all the components and successfully operate
    your CRM service. If it appears complex, there’s no need to worry. We’ll proceed
    at a steady pace and provide explanations along the way.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a user-shared model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing we need to create is our shared model, which for now will be
    only the `User` model, to be able to create a shared authentication system for
    all our sites.
  prefs: []
  type: TYPE_NORMAL
- en: 'You must create the `User` model file in `packages/models/User.ts`, which will
    create a table with the following fields: `id` (`UUID`), `username` (`STRING)`,
    `password` (`STRING`), `Email` (`STRING`), `Role` (`STRING`), and `active` (`BOOLEAN`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Creating a user-shared GraphQL type and resolver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides the `User`-shared model, we need to create a shared GraphQL **type**
    and **resolver**, in order to handle the authentication using GraphQL on all our
    sites.
  prefs: []
  type: TYPE_NORMAL
- en: 'First we need to create another shared GraphQL type called `error`, which will
    help us handle errors on any of the queries or mutations we will create later.
    This file exists in `packages/api/src/graphql/types/Error.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Another shared type that we need to create is the scalar one, which will define
    scalar types like `UUID`, `Datetime`, and `JSON`. This file exists in `packages/api/src/graphql/types/Scalar.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to create our `User` type, which will include some queries
    to get a specific user via an access token (`at`), get all users, and get some
    mutations to create a new user and also to log in. This file should be placed
    in `packages/api/src/graphql/types/User.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'After you create the preceding types, you need to create the user resolver.
    For this we will use the `authentication` package (please check the code at [https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter14/web-creator/packages/authentication](https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter14/web-creator/packages/authentication)).
    Do you remember the authentication system we created in *Chapter 13*? It is the
    same code, but now it will have its own package. This resolver should be created
    in `packages/api/src/graphql/resolvers/user.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Creating custom services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now it is time to create our custom services; for this we will create one default
    service (just to have an empty service) and one for a **CRM** project (it will
    be called `crm`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is to create our service configuration, and for
    this we will create some types that will help us to be very strict in the options
    that our configuration will receive. This file needs to be created in `packages/api/src/types/config.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Our default configuration should be like this (`packages/api/src/services/default/config.ts`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'After that let’s create our CRM configuration (custom service). This should
    be placed in `packages/api/src/services/crm/config.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'I’m pretty sure you’re wondering where the other options of the database node
    (`engine`, `port`, `host`, `username`, and `password`) are. Those will be overwritten
    in the main config file that we will create later, but those values will be grabbed
    from our `.env` file (you must rename the `.env.example` file). Hence, let’s create
    that file in `packages/api/.env`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Building our service configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have our custom service (**CRM**) ready, let’s build our configuration.
    For this you need to create the config file in `packages/api/src/config.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Creating our custom models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once we’ve created the configuration correctly, we need to create our custom
    models for our CRM service, which are created specifically for that service, and
    they will not be shared with other services. In this case, we will add just one
    and call it `Guest`. This model needs to be saved in `packages/api/src/services/crm/models/Guest.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'After we create the `Guest` model, we need to connect to our database and join
    our global models (`User`) and our local models (`Guest`) in order to create our
    service tables. This file needs to be created in `packages/api/src/services/crm/models/index.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Creating model seeds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Seeds are the initial data for our models (tables). Most of the time we want
    to clear all the model values but keep some of them as default values, but in
    this case we will add some default data for our `User` model and our `Guest` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Creating our custom GraphQL types and resolvers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For our CRM, we will create a `Guest` type and resolver just to illustrate
    how we can use GraphQL in different services that we create; the first file you
    need to create is the `Guest` type, which must be saved in `packages/api/src/services/crm/graphql/types/Guest.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we define our `Guest` type with some personal fields such as
    `fullName`, `email`, `photo`, etc. Then we create a `GuestResponse` type that
    represents an array of guests `([Guest!]!`). The square brackets indicate that
    it’s an array, and the exclamation mark (`!`) denotes that it cannot contain `null`
    values. After that, we create a `union` type, which enables the `schema` field
    to return one of multiple object types. In this case, it can return `GuestResponse`
    when we have guests or the `Error` type if we don’t have guests or encounter any
    other issues. If something else occurs, we define the response of these types
    in our resolver.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you create this type file (or more), it is time to merge all your **Type
    Definitions** (**TypeDefs**). For this, we will create an `index.ts` file inside
    our `types` directory and import our global types (`Error`, `Scalar`, and `User`).
    We will also include our local type (`Guest`) and merge it with a function provided
    by `@graphql-tools/merge`. This file is placed in `packages/api/src/services/crm/types/index.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now once you have merged your types, you need to create the `Guest` resolver.
    This file should be placed in `packages/api/src/services/crm/graphql/resolvers/guest.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, when we find guests (or data), we return them and add the `__typename`
    property (which is a GraphQL property) with a value of `GuestResponse`. This property
    is necessary to resolve the query with the correct type, since we are using a
    union. Here is where we define what we will return, whether it’s the `GuestResponse`
    type or the `Error` type. On the other hand, if we don’t find any guests, we return
    an error object with a code and message, and the `__typename` is set to `'Error'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to do the same with the resolvers. We need to merge our resolvers,
    both the global ones and the local ones. To do this, create an `index.ts` file
    in the same `resolvers` directory and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We have done a similar thing with our resolvers as we did with the `TypeDef`.
    Now, we need to import the global user resolver and merge it with our guest resolver.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing our models and starting Apollo Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have created our custom `configs`, `models`, `seeds`, `types`,
    and `resolvers`, it’s time to put everything together, synchronize our models,
    and start our Apollo Server. This file should be placed in `packages/api/src/index.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'After importing all the packages we need, first we need to check if we received
    the `SERVICE` variable from the terminal; otherwise, we will choose our default
    service. We will also check if our service is valid (exists in our `Service` type):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we are sure that our service is valid, then we will dynamically import
    the `resolvers`, `types`, `models`, and `seeds`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we create our Express app and configure `cors`, `cookieParser`, and `bodyParser`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to create our GraphQL schema with `makeExecutableSchema` and use the
    `applyMiddleware`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we create our `ApolloServer` instance passing the schema and the plugins.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to sync our models. The `alter` option enables us to listen to
    changes in our models and modify them:'
  prefs: []
  type: TYPE_NORMAL
- en: If you change something, BE VERY CAREFUL with the `force` option. If it is `true`,
    it will truncate all your tables (meaning all your data will be deleted). Hence,
    only use it when totally necessary.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Testing our CRM service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you did everything correctly, you can run the command `SERVICE=crm npm run
    dev` inside your `api` package. and you should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B18414_14_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.10: SERVICE=crm npm run dev'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you check your database, you will see the two tables created from your models
    (`Guests` and `Users`), and you should be able to see the seeds you added as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application, email  Description automatically generated](img/B18414_14_11.a.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Graphical user interface, application, email  Description automatically generated](img/B18414_14_11.b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.11: Database query'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the `createdAt` and `updatedAt` fields are automatically created
    by Sequelize. After this, you can try to hit [http://localhost:4000/graphql](http://localhost:4000/graphql)
    to see if your Apollo Server works fine.
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application, website  Description automatically
    generated](img/B18414_14_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.12: GraphQL Explorer'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start testing our service queries like `getGuests`; let’s see what it
    returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text  Description automatically generated](img/B18414_14_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.13: getGuests query'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, you can test the `getUsers` query:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application, Teams  Description automatically generated](img/B18414_14_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.14: getUsers query'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you can also test the `login` mutation to make sure your global authentication
    system works fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application, Teams  Description automatically generated](img/B18414_14_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.15: The login mutation'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the frontend package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this package, we will implement a multi-site system that will help us have
    more than one site with the same code base.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how our `package.json` file should look for this package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Our `frontend` package works a little bit differently from our other packages
    because we use **Next.js**, which takes care of its own Webpack configuration.
    We do not compile it using our `devtools` like the other packages, and the TypeScript
    configuration differs slightly.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the `tsconfig.json` file for our `frontend` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we define the `~` path. This is handled by `devtools` in other
    packages but in our case, we need to modify the next Webpack configuration directly.
    For this, you need to create the file `next.config.js` (yes, `.js`, not `.ts`),
    and the code should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Another configuration we need to set up is to add `styled-components` plugins
    to our `.babelrc` file. We will also use the `next/babel` preset. This file exists
    in `packages/frontend/.babelrc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have completed this portion of the chapter, we will proceed to create
    a universal `User` model. This model will serve as a template that can be utilized
    across all our websites for anyone who signs up.
  prefs: []
  type: TYPE_NORMAL
- en: Next, our focus will shift toward developing a `Sites` system, which can be
    visualized as a master control room responsible for managing our websites. Just
    like changing TV channels, we will also build a **Page Switcher** that enables
    users to seamlessly switch between different pages on our websites.
  prefs: []
  type: TYPE_NORMAL
- en: Subsequently, we will construct a common `Login` system that ensures a consistent
    login experience across all our websites. To enhance customization and functionality,
    we will set up a `Sites` configuration, which acts as a rulebook or settings panel
    for each individual site, dictating its behavior and features.
  prefs: []
  type: TYPE_NORMAL
- en: To consolidate all these components, we will bundle them together in a single
    file named `server.ts`, which will function as the command center for our system.
  prefs: []
  type: TYPE_NORMAL
- en: Once the setup is complete, we will proceed to test our work by running the
    program and examining the outcomes using various examples. If any issues arise,
    our system will provide error messages to indicate and assist in troubleshooting.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming sections, you will witness all these steps in action, enabling
    you to comprehend how they integrate within our larger system. Rest assured, although
    it may sound intricate at the moment, we will break it down and guide you through
    each step, ensuring a clear understanding of the process.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our Sites system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Sites system is pretty much the same as the services system we created in
    our API packages, but in this case instead of managing databases, we manage websites.
    So, like we did before, the first thing we need to do is create the configuration
    of each site. In this scenario, we will also have a **default** site, which is
    called `'blank-page'`, just to avoid the system breaking when no site has been
    provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create the config file for this site in `packages/frontend/src/sites/blank-page/config.ts`,
    and this is the content of that file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: For this example, I’ll use two personal sites, `san-pancho` and `codejobs`,
    but feel free to add any site you want to the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'As part of the site, we need to create the `graphql` files, to consume our
    API queries and mutations, and the specific pages for this site. The only query
    we will add for now is the `getGuests` query that we previously created in the
    API package. This file should be in `packages/frontend/src/sites/san-pancho/graphql/guest/getGuests.query.ts`.
    If, at some point, you want to create a mutation, you may want to use the `myMutation.mutation.ts`
    format for the filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Creating our Page Switcher
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have used Next.js in the past, you’ll know how the **Next** page system
    works. Essentially, you have your `pages` directory, and the files or directories
    you add to that will represent the route of a page. For our example, we will need
    to create some Next pages that will “switch” or render a custom page from each
    site. I know it sounds a little bit complicated, but let’s break this down into
    parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to do is to create our `index.ts` page in `packages/frontend/src/pages/index.ts`
    (this is a Next page):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Another Next.js page that we must create is one that has a special name and
    needs to be created in `packages/frontend/src/pages/[page]/[…params].tsx`. The
    `[page]` will be a dynamic path. The `[...params].tsx` file will receive any additional
    parameters passed in the URL. If we have more than two nested routes, these additional
    routes will be added as an array to the `params` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: On each Next.js page, we will import a `SwitcherPage` component that exists
    on each site. We also import the `routerParams`, which will control the routing
    for each site as well, and we will receive the `siteTitle` via props. In other
    words, we just render the `SwitcherPage` component and pass the props.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how the `Switcher` component from our `san-pancho` site looks (`packages/frontend/src/sites/san-pancho/switcher.tsx`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The `next/dynamic` is a composite extension of `React.lazy` and `Suspense`.
    These components can delay hydration until the `Suspense` boundary is resolved.
    In our case, we are dynamically loading pages from this site, specifically the
    `index.index`, `login.index`, and `dashboard.index`. You’re probably wondering
    why we have a nested index page for each of them. This is because we can have
    nested pages; for example, `index.index` will refer to [http://localhost:3000/](http://localhost:3000/),
    `login.index` to [http://localhost:3000/login](http://localhost:3000/login), and
    `dashboard.index` to [http://localhost:3000/dashboard](http://localhost:3000/dashboard).
    However, suppose you want to add a page inside the dashboard like `guests`. You
    will then add `dashboard.guests`, which will point to [http://localhost:3000/dashboard/guests](http://localhost:3000/dashboard/guests).
  prefs: []
  type: TYPE_NORMAL
- en: 'Each `switcher.ts` file from the `sites` directories uses the `Switcher` component.
    Hence, let’s create it. This file is located in `packages/frontend/src/components/Switcher.tsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s now create the index page for our San Pancho site. This page serves a
    simple purpose: to display the site’s title, providing confirmation that we are
    currently on the San Pancho site. This file should exist in `packages/frontend/src/sites/san-pancho/pages/index.tsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, we can create our index page for our dashboard (`packages/frontend/src/sites/san-pancho/pages/dashboard/index.tsx`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to create our login page for `san-pancho`, which will share
    the `Login` component for all the sites (`packages/frontend/src/sites/san-pancho/pages/login.tsx`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Creating our Login system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All our sites will use the same login page because we share the authentication
    system. Let’s create our `Login` component and see how we can perform the login:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `login` function that is executed in the `handleSubmit`
    comes from our `UserContext`. This will execute the `login` mutation when the
    user needs to perform a login, and the `getUser` query to validate if a logged
    user is valid. Let’s create that `User Context` (Context API), which should be
    located in `packages/frontend/src/contexts/user.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s create our `login` mutation, which will receive two parameters (`$emailOrUsername`
    and `$password`). This file should be located in `packages/frontend/src/graphql/user/login.mutation.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we need to create the `getUser` query, which will take the `accessToken`
    (`at`) as a parameter and validate if the connected user is valid. This file exists
    in `packages/frontend/src/graphql/user/getUser.query.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two more things to do. The first thing is to add our `UserProvider`
    as a wrapper of our application; we need to do this on a special page called `"_app.tsx"`
    inside the `pages` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to create another special file called `"_document.tsx"` inside
    the `pages` directory. In this file, we will render the `ServerStyleSheet` from
    `styled-components` to be able to use `styled-components` in the server (Next.js):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Creating our sites configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we did in our API project, we need to create a configuration for our sites.
    Let’s start by creating our `SiteConfiguration` type, the file for which will
    be located in `packages/frontend/src/types/config.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The configuration we will do is for the `san-pancho` site, and you should add
    this file to `packages/frontend/src/sites/san-pancho/config.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, we must create our main `config.ts` file, which should be in `packages/frontend/src/config.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Putting everything together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last piece of the puzzle is our `server.ts` file, which will handle Next.js,
    our static directories, and routes. Let’s break down the file into parts and see
    each one in detail. This file should be in `packages/frontend/src/server.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is to import some dependencies and the site configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we need to check that the `SITE` being passed in the terminal is actually
    valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'If the site is valid, then we prepare our `Next` and `Express` applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to configure our `cookieParser` to be able to use cookies and
    set up our site’s static directories, so we can have a shared `public` folder
    and then specific `static` directories inside each site:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we’ll handle our custom routes next and add additional protection to
    specific routes, such as `/dashboard`. We want to ensure that only connected users
    can access this route. For this, we will use the `isConnected` middleware to validate
    whether a user is connected. If the user is not connected, we will redirect them
    to the login page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, all other traffic is going to be handled by Next.js; then we listen
    to port `3000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Demo time!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After all of those configurations, we are ready to run our project and see
    if it works. We will need to run it in a similar way to how we did on the API,
    but instead of the `SERVICE` variable, we will use the `SITE` variable. We also
    need to specify which site we want to run (`san-pancho` or `codejobs`). If you
    try to run some other site that does not exist, you will get an error. Let’s try
    that to test the validation of the sites:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B18414_14_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.16: getGuests query'
  prefs: []
  type: TYPE_NORMAL
- en: 'The validation works fine. Now, let’s run our `san-pancho` site with the `SITE=san-pancho
    npm run dev` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, chat or text message  Description
    automatically generated](img/B18414_14_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.17: San Pancho Index Page'
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything works fine, you should see the preceding. Next, let’s run our
    `codejobs` site with `SITE=codejobs npm run dev`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, chat or text message  Description
    automatically generated](img/B18414_14_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.18: Codejobs Index Page'
  prefs: []
  type: TYPE_NORMAL
- en: Nice, so both our sites work as expected!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it’s time to test our login page for each site. Let’s start with San Pancho:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, chat or text message  Description
    automatically generated](img/B18414_14_19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.19: San Pancho Sign In page'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then let’s test the Codejobs login page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application  Description automatically generated](img/B18414_14_20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.20: Codejobs Sign In page'
  prefs: []
  type: TYPE_NORMAL
- en: 'Everything seems good so far. Now let’s test the login with our default credentials,
    which are **username**: `admin` and **password**:`12345678`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B18414_14_21.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.21: Dashboard for San Pancho'
  prefs: []
  type: TYPE_NORMAL
- en: Nice! So now we are connected to San Pancho’s dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing I want to highlight here is the cookie name we used for the user
    session, which is `at-san-pancho`. However, even if you already performed a login
    in San Pancho, if you try to access the Codejobs dashboard, you will be required
    to log in again because each site session is independent of the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18414_14_22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.22: Site cookies'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s test hitting a URL that does not exist on our sites:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, website  Description automatically generated](img/B18414_14_23.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.23: 404 error page'
  prefs: []
  type: TYPE_NORMAL
- en: You should see a `404` page that will be shared across both sites.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations on making it this far! Without a doubt, this chapter has been
    complex, yet incredibly interesting. Now, you have the bare bones ready to begin
    working on your personal websites.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the course of this chapter, you acquired a comprehensive set of skills.
    You learned how to create `User` models and GraphQL types, understand error handling,
    and set up custom services like a CRM. You successfully navigated through the
    process of building a Sites system, enhanced user experience with a Page Switcher,
    and established a shared login system. Furthermore, you gained knowledge in managing
    configurations, working with “seeds” or default data for models, and consolidating
    components into a command file such as `server.ts`. As a result, you are now proficient
    in synchronizing models, starting up the Apollo Server, running tests, and effectively
    troubleshooting any issues that may arise. In essence, you have established a
    robust foundation in managing multi-site web systems, enhancing user experience,
    understanding GraphQL, and troubleshooting.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will have the opportunity to expand your skills further
    as you learn how to improve the performance of your React applications.
  prefs: []
  type: TYPE_NORMAL
