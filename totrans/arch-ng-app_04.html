<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Functional Reactive Programming</h1>
                </header>
            
            <article>
                
<p class="mce-root">According to Wikipedia, <strong>Functional Reactive Programming</strong> (<strong>FRP</strong>) is a programming paradigm for reactive programming, which uses the building blocks of functional programming. OK, that sounds fancy, but what does it mean? To understand the whole sentence we need to break it apart a bit. Let's try to define the following:</p>
<ul>
<li>A <strong>programming paradigm</strong> is an overarching theory, or way of working, centered around how a program should be organized and structured. Object-oriented programming and functional programming are examples of programming paradigms.</li>
<li><strong>Reactive programming</strong>, in short, is programming with asynchronous data streams. Asynchronous data streams are streams of data whose values can arrive at any point in time.</li>
<li><strong>Functional programming</strong> is a programming paradigm that takes a more mathematical approach, in that it sees a functional call as a mathematical computation and thereby avoids changing states or dealing with mutable data.</li>
</ul>
<p>So, in short, our Wikipedia definition means we have a functional programming approach to values that might arrive at any point in time. That doesn't really mean much, but hopefully things will have been cleared up a bit by the end of this chapter.</p>
<p>In this chapter, we will learn about:</p>
<ul>
<li>The differences between declarative and imperative programming</li>
<li>Asynchronous data streams</li>
<li>How these streams can be manipulated</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Functional programming versus imperative programming</h1>
                </header>
            
            <article>
                
<p>We will discuss and describe two different styles of programming, imperative programming and declarative programming. Functional programming is a subset of declarative programming. The easiest way to explain what declarative programming is to compare it to its opposite, imperative programming. Imperative programming focuses on <em>how</em> the program should achieve its result. Functional programming, on the other hand, is a declarative programming paradigm, which means its focus is on what the programming should accomplish, or the what. This is an important distinction. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Imperative programming versus declarative programming</h1>
                </header>
            
            <article>
                
<p>Imperative programming is made up of statements that help change the program's state. As mentioned before, it focuses on the <em>how</em> rather than the <em>what</em>. Let's have a look at what this can look like in code to make it more clear:</p>
<pre>let sum = 0;<br/><br/>function updateSum(records) {<br/>  for( let i = 0; i&lt; records.length; i++ ) {<br/>    sum += records[i]; <br/>  }<br/>}<br/><br/>updateSum([1,2,3,4]);</pre>
<p>The preceding code has the following effect: the variable <kbd>sum</kbd> is updated when we call <kbd>updateSum()</kbd>.  We can also see that the function is very explicit about <em>how</em> the summation should happen.</p>
<p>Declarative programming is more focused on <em>what</em> to achieve. It's easy to think of this as being more high-level, because you say <em>what</em> you want to achieve. Let's look at some SQL code. SQL is a declarative programming language:</p>
<pre>// content of table 'orderitem'<br/>-------------------<br/>id  price productId<br/>-------------------<br/>1     100   1<br/>1      50  11  <br/><br/>SELECT <br/>  SUM(price) as total <br/>FROM orderitem<br/><br/>// result of the query<br/>150</pre>
<p>Here, we are querying a table for a number of records while telling SQL what we want to summarize. We are clearly carrying out the same type of action, which is to summarize something. The difference is that with our declarative example we tell SQL what we want done; we trust SQL to know to summarize. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">First-class higher-order functions</h1>
                </header>
            
            <article>
                
<p>The term first class means that the language itself treats functions as values; they can be passed around as example arguments to other functions. A higher-order function is a function that takes other functions as parameters. Let's look at an example to make this clearer:</p>
<pre>function project(obj, fn) {<br/>  return fn(obj);<br/>}<br/><br/>project( { name : 'chris', age: 37 }, (obj) =&gt; obj['name'] ); // 'chris'<br/>project({ name : 'chris', age: 37 }, (obj) =&gt; obj['age'] ) // 37 </pre>
<p>Here we can see that the second argument in our <kbd>project()</kbd> function is a function. The function is being applied to the first argument. We can also see that, depending on what input argument we give the higher-order function as its second argument, the higher-order function will behave differently.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pure functions</h1>
                </header>
            
            <article>
                
<p>A pure function is a function that does not have a side-effect. Nothing the function does will ever affect a variable outside of it. This means that the input argument, when used in a computation, should not cause a side-effect, such as talking to the filesystem or opening a network connection, for example. Let's look at an example:</p>
<pre>function notAPureFunction(filePath) {<br/>  const fileContent = fs.readFileSync(filePath);<br/>  const rows = fileContent.split(',');<br/>  let sum = 0;<br/>  rows.forEach(row =&gt; { sum += row; });<br/>  return sum;<br/>}</pre>
<p>As we can see, our function opens up a file, loops through its rows, and calculates a sum of all the row contents. Unfortunately, the function talks to the filesystem, which is considered a side-effect. It may look a little bit contrived, but in a longer function it is not an impossibility to see both calculations—logging and talking to a database—take place, or so has been my experience. Such code is far from ideal, and suffers from separation of concerns and a whole lot of other issues. When it comes to pure functions though, it is a good idea to isolate the pure parts into their own functions, which would result in this:</p>
<pre>function calculateSum(rows) {  // now it's pure<br/>  let sum = 0;<br/>  rows.forEach(row =&gt; { sum += row; });<br/>  return sum;<br/>}<br/><br/>function getRows(filePath) {  // still not pure, but some things needs to perform side-effects<br/>  const fileContent = fs.readFileSync(filePath);<br/>  const rows = fileContent.split(',');<br/>}</pre>
<p>As you can see, we now have two functions. We managed to isolate the pure parts into a function called <kbd>calculateSum()</kbd> and we ended up creating the <kbd>getRows()</kbd> function, which performs side-effects. Most programs have side-effects in some form, but your job as a programmer is to keep those functions away from pure functions as much as possible.</p>
<p>In reality, we have described two things here:</p>
<ul>
<li><strong>Pure functions</strong>: They are more like mathematical computations that do not have side-effects.</li>
<li><strong>Single responsibility principle</strong> (<strong>SRP</strong>): Part of doing functional programming well is writing small and focused functions. Even though this is not a strict property of functional programming or pure functions, it is an important principle that will help you have the right mindset while adopting the functional programming lifestyle.</li>
</ul>
<p>One thing we didn't mention was why pure functions play an integral role in functional programming. They are predictable through their computational nature, which makes them easy to test. Building a system that mostly consists of many small predictable functions makes the whole system predictable.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Recursion</h1>
                </header>
            
            <article>
                
<div class="packt_quote">"To understand the word recursion see the word recursion."</div>
<p>This is a standing joke at most engineering schools and it explains what it is in a very short way. Recursion is a mathematical concept. Let's explain it a bit more. The official definition says the following:</p>
<div class="packt_quote"><span>Recursion is the process a procedure goes through when one of the steps of the procedure involves invoking the procedure itself. A procedure that goes through recursion is said to be 'recursive'.</span></div>
<p>Ok, what does that mean in human speak? It says that at some point in running our function, we will call ourselves. This means we have a function that looks something like this:</p>
<pre>function something() {<br/>  statement;<br/>  statement;<br/>  if(condition) {<br/>    something();<br/>  }<br/>  return someValue;<br/>}</pre>
<p>We can see that the function <kbd>something()</kbd> at some point in its body calls itself. A recursive function should abide to the following rules:</p>
<ul>
<li>Should call itself</li>
<li>Should eventually meet an exit condition</li>
</ul>
<p>If a recursive function doesn't have an exit condition, we will run out of memory as the function will call itself for all eternity. There are certain types of problems that are more suitable than others to apply recursive programming to. Examples of these are:</p>
<ul>
<li>Traversing trees</li>
<li>Compiling code</li>
<li>Writing algorithms for compression</li>
<li>Sort lists</li>
</ul>
<p>There are many more examples, but it's important to remember that, although it's a great tool, it shouldn't be used everywhere. Let's look at an example where recursion really shines. Our example is a linked list. A linked list consists of nodes that know about the node they are connected to. The code for the <kbd>Node</kbd> structure looks like this:</p>
<pre>class Node {<br/>  constructor(<br/>    public left, <br/>    public value<br/>  ) {}<br/>}</pre>
<p>Using such a structure as a <kbd>Node</kbd>, we can construct a linked list consisting of several linked nodes. We can connect a set of node instances in the following way:</p>
<pre>const head = new Node(null, 1);<br/>const firstNode = new Node(head, 2);<br/>const secondNode = new Node(firstNode, 3);</pre>
<p>A graphical representation of the preceding code would be the following diagram. Here, we can clearly see what our nodes consist of and how they are connected:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f74ea5ae-b028-4afc-af5d-66e95e2bb579.png" style=""/></div>
<p>Here, we have a linked list where we have three connected node instances. The head node is not connected to the node to the left. The second node however is connected to the first node and the first node is connected to the head node. The following type of operations on a list might be interesting to do:</p>
<ul>
<li>Find the head node, given any node in the list</li>
<li>Insert a node at a given point in the list</li>
<li>Remove a node from a given point in the list</li>
</ul>
<p>Let's have a look at how we can solve the first bullet point. Firstly, we will use an imperative approach and thereafter we will use a recursive approach to see how they differ. More importantly, let's discuss why the recursive approach might be preferred:</p>
<pre>// demo of how to find the head node, imperative style<br/><br/>const head = new Node(null, 1);<br/>const firstNode = new Node(head, 2);<br/>const secondNode = new Node(firstNode, 3); <br/><br/>function<span> findHeadImperative (startNode)  {</span><span><br/></span>  while<span> (startNode.left </span><span>!==</span><span> </span><span>null</span><span>) {<br/></span>    startNode <span>=</span><span> startNode.left;<br/></span>  }<br/>  return<span> startNode;<br/></span>}<br/><br/>const<span> foundImp </span><span>=</span><span> findHeadImperative(secondNode);<br/></span>console.log(<span>'found'</span><span>, foundImp);<br/></span>console.log(foundImp <span>===</span><span> head);</span><span><br/></span></pre>
<p>As we can see here, we are using a <kbd>while</kbd> loop to traverse through the list until we find the node instance whose <kbd>left</kbd> property is null. Now, let's show the recursive approach:</p>
<pre>// demo of how to find head node, declarative style using recursion<br/><br/>const head = new Node(null, 1);<br/>const firstNode = new Node(head, 2);<br/>const secondNode = new Node(firstNode, 3); <br/><br/>function<span> findHeadRecursive(startNode) {<br/></span>  if<span>(startNode.left </span><span>!==</span><span> </span><span>null</span><span>) {<br/></span>    return<span> findHeadRecursive(startNode.left);<br/></span>  } <span>else</span><span> {<br/></span>    return<span> startNode;<br/></span>  }<br/>}<br/><br/>const<span> found </span><span>=</span><span> findHeadRecursive(secondNode);<br/></span>console.log(<span>'found'</span><span>, found);<br/></span>console.log(found <span>===</span><span> head);</span><span><br/></span></pre>
<p>In the preceding code, we check whether <kbd>startNode.left</kbd> is null. If that is the case, we have reached our exit condition. If we haven't reached the exit condition yet, we keep on calling ourselves.</p>
<p>Ok, so we have an imperative approach and a recursive approach. Why is the latter so much better? Well, with the recursive approach, we start off with a long list and we make the list shorter every time we call ourselves: a bit of a <em>divide and conquer</em> approach. One thing that clearly stands out with the recursive approach is that we defer execution by saying, no, our exit condition isn't met yet, keep processing. Keep processing means we call ourselves as we do in our <kbd>if</kbd> clause. Is the point of recursive programming that we get fewer lines of code? Well, that could be the result, but more importantly: it changes our mindset toward how we go about solving problems. In imperative programming, we have a <em>let's solve the problem from top to bottom mindset</em>, whereas in recursive programming, our mindset is more, define when we are done and slice down the problem to make it easier to deal with. In the preceding case, we discarded the part of our linked list that wasn't interesting anymore. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">No more loops</h1>
                </header>
            
            <article>
                
<p>One of the more significant changes when starting to code in a more functional way is that we get rid of <kbd>for</kbd> loops. Now that we know about recursion, we can just use that instead. Let's have look at a simple imperative piece of code that prints an array:</p>
<pre>// demo of printing an array, imperative style<br/><br/>let array = [1, 2, 3, 4, 5];<br/><br/>function print(arr) {<br/>  for(var i = 0, i &lt; arr.length; i++) {<br/>    console.log(arr[i]); <br/>  }<br/>}<br/><br/>print(arr);</pre>
<p>The corresponding code using recursion looks like this:</p>
<pre>// print.js, printing an array using recursion<br/><br/>let<span> array </span><span>=</span><span> [</span><span>1</span><span>, </span><span>2</span><span>, </span><span>3</span><span>, </span><span>4</span><span>, </span><span>5</span><span>];<br/></span><br/>function<span> print(arr, pos, len) {<br/></span>  if<span> (pos </span><span>&lt;</span><span> len) {<br/></span>    console.log(arr[pos]);<br/>    print(arr, pos <span>+</span><span> </span><span>1</span><span>, len);<br/></span>  }<br/>  return<span>;<br/></span>}<br/><br/>print(array, <span>0</span><span>, array.length</span><span>);</span></pre>
<p>As we can see, our imperative code is still there in spirit. We still start at <kbd>0</kbd>. Moreover, we keep going until we come to the last position of our array. Once we hit our break condition, we exit the method.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reoccurring pattern</h1>
                </header>
            
            <article>
                
<p>We haven't really sold recursion as a concept at this point. We kind of get it, but are probably not convinced why good old <kbd>while</kbd> or <kbd>for</kbd> loops can't be used in its place. Recursion shines when it solves problems that look like a reoccurring pattern. An example of that is a tree. A tree has some similar concepts to it such as consisting of nodes. A node without children connected to it is called a leaf. A node with children but that has no connection to an upward node is called a root node. Let's illustrate this with a diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a027455b-81fd-4284-aebc-7615a806fde3.png" style=""/></div>
<p>There are a few interesting operations that we would want to carry out on a tree:</p>
<ul>
<li>Summarise the node values</li>
<li>Count the number of nodes</li>
<li>Calculate the width</li>
<li>Calculate the depth</li>
</ul>
<p>To attempt to solve that, we need to think about how to store a tree as a data structure. The most common way of modeling it is by creating a representation of a node as having a value, and a <kbd>left</kbd> property and a <kbd>right</kbd> property, then both those properties point to nodes in turn. Therefore, the code for said Node class might look like this:</p>
<pre>class<span> NodeClass {<br/></span>  constructor<span>(left, right, value) {<br/></span>    this<span>.left </span><span>=</span><span> left;<br/></span>    this<span>.right </span><span>=</span><span> right;<br/></span>    this<span>.value </span><span>=</span><span> value;<br/></span>  }<br/>}</pre>
<p>The next step is thinking how to create the tree itself. This code shows how we can create a tree with a root node and two children, and how to bind these together:</p>
<pre>// tree.js<br/><br/>class<span> NodeClass {<br/></span>  constructor<span>(left, right, value) {<br/></span>    this<span>.left </span><span>=</span><span> left;<br/></span>    this<span>.right </span><span>=</span><span> right;<br/></span>    this<span>.value </span><span>=</span><span> value;<br/></span>  }<br/>}<br/><br/>const<span> leftLeftLeftChild </span><span>=</span><span> </span><span>new</span><span> NodeClass(</span><span>null</span><span>, </span><span>null</span><span>, </span><span>7</span><span>);<br/></span>const<span> leftLeftChild </span><span>=</span><span> </span><span>new</span><span> NodeClass(leftLeftLeftChild, </span><span>null</span><span>, </span><span>1</span><span>);<br/></span>const<span> leftRightChild </span><span>=</span><span> </span><span>new</span><span> NodeClass(</span><span>null</span><span>, </span><span>null</span><span>, </span><span>2</span><span>);<br/></span>const<span> rightLeftChild </span><span>=</span><span> </span><span>new</span><span> NodeClass(</span><span>null</span><span>, </span><span>null</span><span>, </span><span>4</span><span>);<br/></span>const<span> rightRightChild </span><span>=</span><span> </span><span>new</span><span> NodeClass(</span><span>null</span><span>, </span><span>null</span><span>, </span><span>2</span><span>);<br/></span>const<span> left </span><span>=</span><span> </span><span>new</span><span> NodeClass(leftLeftChild, leftRightChild, </span><span>3</span><span>);<br/></span>const<span> right </span><span>=</span><span> </span><span>new</span><span> NodeClass(rightLeftChild, rightRightChild, </span><span>5</span><span>);<br/></span>const<span> root </span><span>=</span><span> </span><span>new</span><span> NodeClass(left, right, </span><span>2</span><span>);<br/><br/></span>module.exports <span>=</span><span> root;</span><span><br/></span></pre>
<p>Worth highlighting is how the instances <kbd>left</kbd> and <kbd>right</kbd> do not have children. We can see that because we set their values to <kbd>null</kbd> on creation. Our root node, on the other hand, has  the object instances <kbd>left</kbd> and <kbd>right</kbd> as children.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summarise</h1>
                </header>
            
            <article>
                
<p>Thereafter, we need to think about how to summarise the nodes. Just looking at it, it looks like we should summarise the top node and its two children. So, a code implementation would start off like this:</p>
<pre>// tree-sum.js<br/><br/>const root = require('./tree');<br/><br/>function summarise(node) {<br/>  return node.value + node.left.value + node.right.value;<br/>}<br/><br/>console.log(summarise(root)) // 10</pre>
<p>What happens if our tree grows and suddenly looks like this:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7b191666-4c04-4430-92cd-1ce1cffaf73a.png" style=""/></div>
<p>Let's add to the preceding code so it looks like this:</p>
<pre>// example of a non recursive code<br/><br/>function summarise(node) {<br/>  return node.value + <br/>    node.left.value + <br/>    node.right.value +<br/>    node.right.left.value +<br/>    node.right.right.value + <br/>    node.left.left.value + <br/>    node.left.right.value;<br/>}<br/><br/>console.log(summarise(root)) // 19</pre>
<p>This is technically working code, but it can be improved. What we should see at this point, looking at the tree, are reoccurring patterns in the tree. We have the following triangles:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/4987cb37-bffd-4ea5-ac9a-70ceadf7a6ce.png" style=""/></div>
<p>One triangle is made up of <strong>2,</strong> <strong>3</strong>, <strong>5</strong>, another one is made up of <strong>3</strong>, <strong>1</strong>, <strong>2</strong>, and the last one is made up of <strong>5</strong>, <strong>4</strong>, <strong>2</strong>. Every triangle computes its sum by taking the node itself, plus its left child and its right child. Recursion is all about this: discovering a reoccurring pattern and codifying it. We can now implement our <kbd>summarise()</kbd> function with recursion, like so:</p>
<pre>function summarise(node) {<br/>  if(node === null) {<br/>    return 0;<br/>  }<br/>  return node.value + summarise(node.left) + summarise(left.right);<br/>}</pre>
<p>What we are doing here is expressing our reoccurring pattern as <em>node + left node + right node</em>. When we call <kbd>summarise(node.left)</kbd> we simply run through <kbd>summarise()</kbd> again for that node. The preceding implementation is short and elegant, and is able to traverse the entire tree. Recursion is truly elegant once you find that your problem can be seen as a repeating pattern. The full code looks like this:</p>
<pre>// tree.js<br/><br/>class<span> NodeClass {<br/></span>  constructor<span>(left, right, value) {<br/></span>    this<span>.left </span><span>=</span><span> left;<br/></span>    this<span>.right </span><span>=</span><span> right;<br/></span>    this<span>.value </span><span>=</span><span> value;<br/></span>  }<br/>}<br/><br/>const<span> leftLeftLeftChild </span><span>=</span><span> </span><span>new</span><span> NodeClass(</span><span>null</span><span>, </span><span>null</span><span>, </span><span>7</span><span>);<br/></span>const<span> leftLeftChild </span><span>=</span><span> </span><span>new</span><span> NodeClass(leftLeftLeftChild, </span><span>null</span><span>, </span><span>1</span><span>);<br/></span>const<span> leftRightChild </span><span>=</span><span> </span><span>new</span><span> NodeClass(</span><span>null</span><span>, </span><span>null</span><span>, </span><span>2</span><span>);<br/></span>const<span> rightLeftChild </span><span>=</span><span> </span><span>new</span><span> NodeClass(</span><span>null</span><span>, </span><span>null</span><span>, </span><span>4</span><span>);<br/></span>const<span> rightRightChild </span><span>=</span><span> </span><span>new</span><span> NodeClass(</span><span>null</span><span>, </span><span>null</span><span>, </span><span>2</span><span>);<br/></span>const<span> left </span><span>=</span><span> </span><span>new</span><span> NodeClass(leftLeftChild, leftRightChild, </span><span>3</span><span>);<br/></span>const<span> right </span><span>=</span><span> </span><span>new</span><span> NodeClass(rightLeftChild, rightRightChild, </span><span>5</span><span>);<br/></span>const<span> root </span><span>=</span><span> </span><span>new</span><span> NodeClass(left, right, </span><span>2</span><span>);<br/><br/></span>module.exports <span>=</span><span> root;<br/></span><br/>// tree-sum.js<br/><br/>const<span> root </span><span>=</span><span> require(</span><span>"./tree"</span><span>);<br/><br/></span>function<span> sum(node) {<br/></span>  if<span> (node </span><span>===</span><span> </span><span>null</span><span>) {<br/></span>    return<span> </span><span>0</span><span>;<br/></span>  }<br/>  return<span> node.value </span><span>+</span><span> sum(node.left) </span><span>+</span><span> sum(node.right);<br/></span>}<br/><br/>console.log(<span>"sum"</span><span>, sum(root));</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Count</h1>
                </header>
            
            <article>
                
<p>Implementing a function that counts all the nodes in the trees is quite trivial now that we are beginning to grasp the nature of recursion. We can reuse our summary function from before and simply count every non-null node as <kbd>1</kbd> and null as <kbd>0</kbd>. So, we simply take the existing summary function and modify it to this:</p>
<pre>//tree-count.js<br/><br/>const<span> root </span><span>=</span><span> require(</span><span>"./tree"</span><span>);<br/></span><br/>function<span> count(node) {<br/></span>  if<span> (node </span><span>===</span><span> </span><span>null</span><span>) {<br/></span>    return<span> </span><span>0</span><span>;<br/></span>  } <span>else</span><span> {<br/></span>    return<span> </span><span>1</span><span> </span><span>+</span><span> count(node.left) </span><span>+</span><span> count(node.right);<br/></span>  }<br/>}<br/><br/>console.log(<span>"count"</span><span>, count(root));</span></pre>
<p>The preceding code ensures we traverse each and every node successfully. Our exit condition happens when we reach null. That is, we are trying to go from a node to one of its non-existing children.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Width</h1>
                </header>
            
            <article>
                
<p>To create a width function, we first need to define what we mean by width. Let's have a look at our tree again:</p>
<div class="CDPAlignCenter CDPAlign"> <img src="assets/26f8a6fa-05a3-44c1-8cd6-4266c283f05d.png" style=""/></div>
<p>This tree has a width of <strong>4</strong>. How is that? For every step down in the tree, our nodes expand one step to the left and one step to the right. This means that to calculate the width correctly, we need to traverse the edges of our tree. Every time we have to traverse a node to the left or to the right, we increment the width. What we are interested in doing from a calculation standpoint is to traverse the tree like this:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1c0353df-bcff-4eb2-a7de-28fa7acd39fa.png" style=""/></div>
<p>The code should therefore reflect this fact. We can implement this like this:</p>
<pre>// tree-width.js<br/><br/>const<span> root </span><span>=</span><span> require(</span><span>"./tree"</span><span>);<br/></span><br/>function<span> calc(node, direction) {<br/></span>  if<span> (node </span><span>===</span><span> </span><span>null</span><span>) {<br/></span>    return<span> </span><span>0</span><span>;<br/></span>  } <span>else</span><span> {<br/></span>    return<span> (<br/></span>      1<span> </span><span>+ </span>(direction <span>===</span><span> </span><span>"left" </span>?<span> <br/>      calc(node.left, direction) </span>:<span> <br/>      calc(node.right, direction))<br/></span>    );<br/>  }<br/>}<br/><br/>function<span> calcWidth(node) {<br/></span>  return<span> calc(node.left, </span><span>"left"</span><span>) </span><span>+</span><span> calc(node.right, </span><span>"right"</span><span>);<br/></span>}<br/><br/>console.log(<span>"width"</span><span>, calcWidth(root));</span></pre>
<p>Note especially how, in the <kbd>calcWidth()</kbd> function, we call <kbd>calc()</kbd> with <kbd>node.left</kbd> and <kbd>node.right</kbd>, respectively, as arguments. We also add a <kbd>left</kbd> and <kbd>right</kbd> argument which, in the method <kbd>calc()</kbd>, means that we will keep going in that direction. Our exit condition is when we eventually hit null. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Asynchronous data streams</h1>
                </header>
            
            <article>
                
<p>An asynchronous data stream is a stream of data where values are emitted, one after another, with a delay between them. The word asynchronous means that the data emitted can appear anywhere in time, after one second or even after two minutes, for example. A way to model asynchronous streams is to place the emitted values on a time axis, like so:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-234 image-border" src="assets/f0ae8d59-f244-4005-bddf-967f0d6b328b.png" style=""/></div>
<p>There are a lot of things that can be considered asynchronous. One such thing is fetching data through AJAX. When the data arrives depends on a number of factors, such as:</p>
<ul>
<li>The speed of your connection</li>
<li>The responsiveness of the backend API</li>
<li>The size of the data, and many more factors.</li>
</ul>
<p>The point is the data isn't arriving right at this very second.</p>
<p>Other things that can be considered asynchronous are user initiated events, such as scrolling or mouse clicks. These are events that can happen at any point in time, depending on the user's interaction. As such, we can consider these UI events as a continuous stream of data on a time axis. The following diagram depicts a stream of data representing a user clicking several times. Each click leads to a click event, <strong>c</strong>, which we place on a time axis:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-235 image-border" src="assets/f09aaa3a-001b-4a51-8eeb-e7232beed9fb.png" style=""/></div>
<p>At first glance, our diagram depicts four click events. Taking a closer look, we see that the click events seem grouped. The preceding diagram contains two pieces of information:</p>
<ul>
<li>That a number of click events have occurred</li>
<li>That the click events have occurred with a certain delay in between events</li>
</ul>
<p>Here, we can see that the two first clicks seem to happen very close together in time; when two events happen very close in time, this will be interpreted as a double-click. Therefore, our image above thus tells us about the events that occurred; it also tells us when and how often they occurred. Looking at the previous diagram, it is quite easy to distinguish between a single-click and a double-click.</p>
<p>We can assign different actions to each click behavior. A double-click might mean that we want to zoom-in, whereas a single-click might mean we want to select something; exactly what is up to the application you are writing. </p>
<p>A third example is that of input. What if we have a situation where the user is typing and stops typing after a while? After a certain amount of time has passed, the user expects the UI to react. This is the case with a search field. In that case, the user might enter something in a search field and press a search button when done. Another way to model that situation in a UI is to just provide a search field and wait for the user to stop typing as a sign of when to start searching for what the user wants. The final example is known as <strong>autocomplete</strong> behavior. It can be modeled in the following way:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-236 image-border" src="assets/9e367157-1c65-4371-aebe-77f6912e6bb7.png" style=""/></div>
<p>The first three characters entered seem to belong to the same search query, whereas the fourth <span>character </span>entered occurs a lot later and probably belongs to another query.</p>
<p>The point of this section has been to highlight that different things lend themselves to being modeled as streams, and that the time axis and the placement of the emitted values on it can come to mean something.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Comparing lists to async streams – preparing for RxJS</h1>
                </header>
            
            <article>
                
<p>We have discussed so far how we can model asynchronous events as a continuous stream of data on a time axis, or stream modeling. Events can be AJAX data, mouse clicks, or some other type of event. Modeling things this way makes for an interesting perspective on things but, looking at a double-click situation for example, doesn't mean much unless we are able to dig out the data. There might be another case where there is data that we need to filter out. What we are discussing here is how to manipulate streams. Without that ability, stream modeling itself has no practical value.</p>
<p>There are different ways to manipulate data: sometimes we want to change the data emitted to some other data and sometimes we might want to change how often the data is being emitted to a listener. Sometimes, we want our stream of data to become a totally different stream. We will try to model the following situations:</p>
<ul>
<li><strong>Projection</strong>: Changing the data of the value being emitted</li>
<li><strong>Filtering</strong>: Changing what gets emitted</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Combining the functional programming paradigm with streams</h1>
                </header>
            
            <article>
                
<p>This chapter has covered functional programming and asynchronous data streams. Working with RxJS doesn't require a deep understanding of functional programming, but you do need to understand what declarative means, in order to focus on the right things. Your focus should be on what you want done, not how you want it done. RxJS, as a library, will take care of the how. More on that in the upcoming chapter.</p>
<p>These might seem like two different topics. Combining the two, however, gives us the ability to manipulate streams. A stream can be seen as a list of data, where the data is available at a certain point in time. If we start treating our streams as lists, especially immutable lists, then there are operations that go with lists that manipulate lists by applying operators to them. The result of the manipulation is a new list, not a mutated list. So let's start applying our list philosophy and its operators to the following situations. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Projection</h1>
                </header>
            
            <article>
                
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-237 image-border" src="assets/822b07eb-50f1-455e-981a-1dfa7b7481e5.png" style=""/></div>
<p>Here, we can see that our stream is emitting the values <strong>1</strong>, <strong>2</strong>, <strong>3</strong>, and <strong>4</strong>, and then a manipulation happens that changes every value by incrementing it by one. This is quite a simple situation. If we consider this as a list, we can see that what we do here is simply a projection, which we would code like this:</p>
<pre>let newList = list.map(value =&gt; value + 1)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Filtering</h1>
                </header>
            
            <article>
                
<p>There might be some items in a list, as well as in a stream, that you do not want. What you do to fix that is to create a filter that filters out the unwanted data. Modeling our initial array, the manipulation, and the resulting array, we get the following: </p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8ffa7b44-4784-472e-befd-585c97e2da97.png" style=""/></div>
<p>In JavaScript, we can accomplish this by writing the following code:</p>
<pre>let array = [1,2,3];<br/>let filtered = array.filter(data =&gt; data % 2 === 0);</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Combining mindsets</h1>
                </header>
            
            <article>
                
<p>So, what are we trying to say with this section. Clearly, we have shown examples of how to manipulate lists. Well, what we have done is shown how we can display items on an axis. In that sense, we can see how it is easy to think of asynchronous events and lists of values in the same way, as we are graphically picturing them in the same way. The question is, why do we want to do that? The reason is that this is the mindset the RxJS library wants you to have when you start manipulating and crafting streams in the upcoming chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p><span>This chapter has established that we can model asynchronous events as values on a time axis. We introduced the idea of comparing these streams to lists and thereby applying functional methods to them that would not change the lists themselves but merely create a new list. The benefit of applying the functional paradigm is that we can focus on <em>what</em> to achieve rather than <em>how</em> to achieve it, thereby having a declarative approach. We realize it's not easy to combine async and lists and create readable code from it. Fortunately, this is what the RxJS library does for us. It is this realization that prepares us for the coming chapter, <a href="84bb33e0-d186-4abe-9b3f-10ba1ae911c8.xhtml">Chapter 5</a>, <em>RxJS Basics</em>, where we introduce RxJS as a library just that: create order in the async mess while modeling everything as a stream. With RxJS, we can truly focus on <em>what</em> rather than <em>how,</em> as it comes with a bunch of stream manipulation functions. After having read the next chapter, you will understand how RxJS works on a fundamental level, but also how it addresses the problems mentioned in this chapter.</span></p>


            </article>

            
        </section>
    </body></html>