<html><head></head><body>
<div id="_idContainer041">
<h1 class="chapter-number" id="_idParaDest-83"><a id="_idTextAnchor084"/><span class="koboSpan" id="kobo.1.1">7</span></h1>
<h1 id="_idParaDest-84"><a id="_idTextAnchor085"/><span class="koboSpan" id="kobo.2.1">Untangling Complex Flows in React Native Apps with XState</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapter, we took a look at </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">MobX</span></strong><span class="koboSpan" id="kobo.5.1">—the second most popular state management library in the </span><strong class="bold"><span class="koboSpan" id="kobo.6.1">React</span></strong><span class="koboSpan" id="kobo.7.1"> ecosystem. </span><span class="koboSpan" id="kobo.7.2">MobX introduced some new concepts, such as using state values derived by the state manager. </span><span class="koboSpan" id="kobo.7.3">Other high-level concepts were similar to </span><strong class="bold"><span class="koboSpan" id="kobo.8.1">Redux</span></strong><span class="koboSpan" id="kobo.9.1">—such as presenting state as plain </span><strong class="bold"><span class="koboSpan" id="kobo.10.1">JavaScript</span></strong><span class="koboSpan" id="kobo.11.1"> objects. </span><span class="koboSpan" id="kobo.11.2">We will now look at the first outlier on the React-state-management horizon: </span><strong class="bold"><span class="koboSpan" id="kobo.12.1">XState</span></strong><span class="koboSpan" id="kobo.13.1">. </span><span class="koboSpan" id="kobo.13.2">XState treats the state not as an object, but as a finite machine. </span><span class="koboSpan" id="kobo.13.3">Don’t worry if you haven’t heard that term yet, as we’ll go over the topic of finite machines in the first section of </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.15.1">We will start by looking at the theoretical side of XState’s basic idea: state machines. </span><span class="koboSpan" id="kobo.15.2">We will then talk about other high-level concepts of XState—state charts, actions, and the XState visualizer. </span><span class="koboSpan" id="kobo.15.3">When we’re comfortable with the theory, we’ll configure XState in the Funbook app, and then we will implement XState for managing liking images in </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">the app.</span></span></p>
<p><span class="koboSpan" id="kobo.17.1">Here’s a complete list of what is covered in </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.19.1">What are finite </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">state machines?</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">What is </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">XState—high-level concepts</span></span></li>
<li><span class="koboSpan" id="kobo.23.1">Configuring XState in the </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">Funbook app</span></span></li>
<li><span class="koboSpan" id="kobo.25.1">Using XState for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.26.1">FavoritedImages</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.27.1"> surface</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.28.1">By the end of this chapter, you will be able to understand and use XState as the state management solution for your projects. </span><span class="koboSpan" id="kobo.28.2">You will understand what a state machine is and how it differs from state objects used in other state management libraries. </span><span class="koboSpan" id="kobo.28.3">I hope that you will also start seeing which solutions you </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">prefer using.</span></span></p>
<h1 id="_idParaDest-85"><a id="_idTextAnchor086"/><span class="koboSpan" id="kobo.30.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.31.1">In order to follow along with this chapter, you will need some knowledge of JavaScript and </span><strong class="bold"><span class="koboSpan" id="kobo.32.1">ReactJS</span></strong><span class="koboSpan" id="kobo.33.1">. </span><span class="koboSpan" id="kobo.33.2">If you have followed at least </span><em class="italic"><span class="koboSpan" id="kobo.34.1">Chapters 1</span></em><span class="koboSpan" id="kobo.35.1"> through </span><em class="italic"><span class="koboSpan" id="kobo.36.1">4</span></em><span class="koboSpan" id="kobo.37.1"> of this book, you should be able to go forward without </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">any issues.</span></span></p>
<p><span class="koboSpan" id="kobo.39.1">Feel free to use an IDE of your choice, as React Native does not need any specific functionality. </span><span class="koboSpan" id="kobo.39.2">Currently, the most popular IDEs for frontend developers are Microsoft’s VS Code, Atom, Sublime Text, </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">and WebStorm.</span></span></p>
<p><span class="koboSpan" id="kobo.41.1">The code snippets provided in this chapter are here to illustrate what we should be doing with the code—they do not provide the whole picture. </span><span class="koboSpan" id="kobo.41.2">For a better experience of coding along, please open the GitHub repo in your IDE and look at the files in there. </span><span class="koboSpan" id="kobo.41.3">You can start with the files in either the folder named </span><strong class="source-inline"><span class="koboSpan" id="kobo.42.1">example-app-full</span></strong><span class="koboSpan" id="kobo.43.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.44.1">chapter-7</span></strong><span class="koboSpan" id="kobo.45.1">. </span><span class="koboSpan" id="kobo.45.2">If you start with </span><strong class="source-inline"><span class="koboSpan" id="kobo.46.1">example-app-full</span></strong><span class="koboSpan" id="kobo.47.1">, you will be responsible for implementing the solutions described in this chapter. </span><span class="koboSpan" id="kobo.47.2">If you choose to look at </span><strong class="source-inline"><span class="koboSpan" id="kobo.48.1">chapter-7</span></strong><span class="koboSpan" id="kobo.49.1"> you will see the entire solution implemented </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">by me.</span></span></p>
<p><span class="koboSpan" id="kobo.51.1">If you get stuck or lost, you can check the code in the </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">GitHub repo:</span></span></p>
<p><a href="https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-7"><span class="No-Break"><span class="koboSpan" id="kobo.53.1">https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-7</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.54.1">.</span></span></p>
<h1 id="_idParaDest-86"><a id="_idTextAnchor087"/><span class="koboSpan" id="kobo.55.1">What are finite state machines?</span></h1>
<p><span class="koboSpan" id="kobo.56.1">If I were to ask you, my dear reader, to guess</span><a id="_idIndexMarker301"/><span class="koboSpan" id="kobo.57.1"> what finite state machines are, you would probably say they are related to managing state in applications. </span><span class="koboSpan" id="kobo.57.2">After all, this whole book is on </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">that topic!</span></span></p>
<p><span class="koboSpan" id="kobo.59.1">Funny thing is, finite state machines have nothing to do with applications; they have nothing to do with React or even programming at all. </span><span class="koboSpan" id="kobo.59.2">A finite state machine is a mathematical model of computation. </span><span class="koboSpan" id="kobo.59.3">It’s an abstract concept that can be applied to real-life objects or problems, and it represents a machine that can be in exactly one of a finite number of states at any given time. </span><span class="koboSpan" id="kobo.59.4">The predefined states can be changed from one to another in response to some user input. </span><span class="koboSpan" id="kobo.59.5">Traffic lights are an example of a simple finite state machine: a traffic light can be green, red, or yellow at any time, and it should never display two colors at once. </span><span class="koboSpan" id="kobo.59.6">Another example of a simple state machine is an elevator. </span><span class="koboSpan" id="kobo.59.7">The default state of an elevator is to stand still with doors closed. </span><span class="koboSpan" id="kobo.59.8">When a user pushes the button summoning the elevator, the elevator transitions to a state of movement. </span><span class="koboSpan" id="kobo.59.9">When it reaches the right floor, it opens and closes the doors. </span><span class="koboSpan" id="kobo.59.10">The elevator then goes back to the default, idle state, waiting for the next </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">user input.</span></span></p>
<p><span class="koboSpan" id="kobo.61.1">If you wish to find out more</span><a id="_idIndexMarker302"/><span class="koboSpan" id="kobo.62.1"> about this theoretical concept, you will find a link to a very thorough </span><em class="italic"><span class="koboSpan" id="kobo.63.1">Wikipedia</span></em><span class="koboSpan" id="kobo.64.1"> page on finite state machines in the </span><em class="italic"><span class="koboSpan" id="kobo.65.1">Further reading</span></em><span class="koboSpan" id="kobo.66.1"> section. </span><span class="koboSpan" id="kobo.66.2">As for this book, it’s time to find out why we are talking about this concept at all. </span><span class="koboSpan" id="kobo.66.3">Can you guess? </span><span class="koboSpan" id="kobo.66.4">I bet you can! </span><span class="koboSpan" id="kobo.66.5">Finite state machines are the basic concept of the state management library we’re analyzing in this </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">chapter: XState.</span></span></p>
<h1 id="_idParaDest-87"><a id="_idTextAnchor088"/><span class="koboSpan" id="kobo.68.1">What is XState – high-level concepts</span></h1>
<p><span class="koboSpan" id="kobo.69.1">Now that we have a grasp</span><a id="_idIndexMarker303"/><span class="koboSpan" id="kobo.70.1"> on the theoretical concept of finite state machines, we can move on to talking about XState and its main concept: finite state machines! </span><span class="koboSpan" id="kobo.70.2">But this time, we’ll look at it in the world of programming global state </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">in applications.</span></span></p>
<p><span class="koboSpan" id="kobo.72.1">When using XState to manage global state in an application, we should think of our state as a finite state machine. </span><span class="koboSpan" id="kobo.72.2">This means abandoning the previous concept of representing state as a plain JavaScript object. </span><span class="koboSpan" id="kobo.72.3">With XState, a component—or a surface—is a machine that can be in one of multiple predefined states. </span><span class="koboSpan" id="kobo.72.4">Let’s consider the user login flow. </span><span class="koboSpan" id="kobo.72.5">Our entire app can be in one of two states: the user is logged in or the user is not logged in. </span><span class="koboSpan" id="kobo.72.6">We would also need a transition mechanism for the user to move from one of the states to the other. </span><span class="koboSpan" id="kobo.72.7">The same goes for images on the </span><strong class="bold"><span class="koboSpan" id="kobo.73.1">Home</span></strong><span class="koboSpan" id="kobo.74.1"> surface. </span><span class="koboSpan" id="kobo.74.2">Every image is either in the state of being “liked” or “not liked”. </span><span class="koboSpan" id="kobo.74.3">The user can change the current state of the image by clicking the heart icon below </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">the image.</span></span></p>
<p><span class="koboSpan" id="kobo.76.1">Besides finite state</span><a id="_idIndexMarker304"/><span class="koboSpan" id="kobo.77.1"> machines, there</span><a id="_idIndexMarker305"/><span class="koboSpan" id="kobo.78.1"> are two other important concepts used in XState: </span><strong class="bold"><span class="koboSpan" id="kobo.79.1">statecharts</span></strong><span class="koboSpan" id="kobo.80.1"> and the </span><strong class="bold"><span class="koboSpan" id="kobo.81.1">actor model</span></strong><span class="koboSpan" id="kobo.82.1">. </span><span class="koboSpan" id="kobo.82.2">Statecharts are basically drawings that can be used to represent state machines. </span><span class="koboSpan" id="kobo.82.3">Here’s an example of a statechart representing the state and transitions of a </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">light bulb:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer036">
<span class="koboSpan" id="kobo.84.1"><img alt="Figure 7.1 – Simple statechart drawing of a light switch " src="image/Figure_7.01_B18396.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.85.1">Figure 7.1 – Simple statechart drawing of a light switch</span></p>
<p><span class="koboSpan" id="kobo.86.1">The preceding diagram</span><a id="_idIndexMarker306"/><span class="koboSpan" id="kobo.87.1"> serves as a very simple state machine. </span><span class="koboSpan" id="kobo.87.2">When working on a mobile application, you may find yourself working on much more complicated state machines. </span><span class="koboSpan" id="kobo.87.3">Starting from something as trivial as a form, you can find yourself adding multiple states, such as enabled/disabled, valid/invalid, and clean/dirty, on multiple elements. </span><span class="koboSpan" id="kobo.87.4">Without statecharts, you would face a state explosion. </span><span class="koboSpan" id="kobo.87.5">As fun as it may sound, it’s not great to face in an app. </span><span class="koboSpan" id="kobo.87.6">Let’s take a look at the example of complex inputs drawn out with </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">state transitions:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer037">
<span class="koboSpan" id="kobo.89.1"><img alt="Figure 7.2 – Complex state chart " src="image/Figure_7.02_B18396.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.90.1">Figure 7.2 – Complex state chart</span></p>
<p><span class="koboSpan" id="kobo.91.1">The user clicks</span><a id="_idIndexMarker307"/><span class="koboSpan" id="kobo.92.1"> on a valid input and enters the </span><strong class="bold"><span class="koboSpan" id="kobo.93.1">Valid Enabled Unchanged</span></strong><span class="koboSpan" id="kobo.94.1"> state. </span><span class="koboSpan" id="kobo.94.2">The app transitions automatically into an </span><strong class="bold"><span class="koboSpan" id="kobo.95.1">Invalid Enabled Unchanged</span></strong><span class="koboSpan" id="kobo.96.1"> state. </span><span class="koboSpan" id="kobo.96.2">When the user provides some input, the app will be in an </span><strong class="bold"><span class="koboSpan" id="kobo.97.1">Invalid Enabled Changed</span></strong><span class="koboSpan" id="kobo.98.1"> state. </span><span class="koboSpan" id="kobo.98.2">If the input provided by the user is valid, we will land in a </span><strong class="bold"><span class="koboSpan" id="kobo.99.1">Valid Enabled Changed</span></strong><span class="koboSpan" id="kobo.100.1"> state; if not, we will return to </span><strong class="bold"><span class="koboSpan" id="kobo.101.1">Invalid Enabled Changed</span></strong><span class="koboSpan" id="kobo.102.1">. </span><span class="koboSpan" id="kobo.102.2">What if the user clicks something else in the form—let’s say, a radio box that disables the first input? </span><span class="koboSpan" id="kobo.102.3">We go into an </span><strong class="bold"><span class="koboSpan" id="kobo.103.1">Invalid</span></strong><span class="koboSpan" id="kobo.104.1"> (or </span><strong class="bold"><span class="koboSpan" id="kobo.105.1">Valid</span></strong><span class="koboSpan" id="kobo.106.1">) </span><strong class="bold"><span class="koboSpan" id="kobo.107.1">Disabled Changed</span></strong><span class="koboSpan" id="kobo.108.1"> state. </span><span class="koboSpan" id="kobo.108.2">It’s rather hard to reason about this chart. </span><span class="koboSpan" id="kobo.108.3">This is the moment when statechart features come into play. </span><span class="koboSpan" id="kobo.108.4">Statecharts offer an implementation of parallel states, hierarchies, and guards. </span><span class="koboSpan" id="kobo.108.5">You can read more on those concepts</span><a id="_idIndexMarker308"/><span class="koboSpan" id="kobo.109.1"> in this document recommended in the XState </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">documentation: </span></span><a href="https://statecharts.dev/state-machine-state-explosion.html"><span class="No-Break"><span class="koboSpan" id="kobo.111.1">https://statecharts.dev/state-machine-state-explosion.html</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.112.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.113.1">The last big idea behind XState is actor models. </span><span class="koboSpan" id="kobo.113.2">This is a mathematical model of computation, stating that everything is an “actor” and can do three things: receive messages, send messages, and do something with the </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">received messages.</span></span></p>
<p><span class="koboSpan" id="kobo.115.1">I was very lucky to be able to ask XState’s author, </span><em class="italic"><span class="koboSpan" id="kobo.116.1">David Khourshid</span></em><span class="koboSpan" id="kobo.117.1">, a few questions on the topic of his state management library. </span><span class="koboSpan" id="kobo.117.2">He told me he “</span><em class="italic"><span class="koboSpan" id="kobo.118.1">created XState for two reasons: to manage complex logic and to visualize complex logic. </span><span class="koboSpan" id="kobo.118.2">State machines and statecharts are visual formalisms that excel in representing even the most complex flows and logic in a visually clear way, and I wanted a simple way to use them in JavaScript applications."</span></em><span class="koboSpan" id="kobo.119.1"> He added that the high-level ideas</span><a id="_idIndexMarker309"/><span class="koboSpan" id="kobo.120.1"> of XState</span><a id="_idIndexMarker310"/><span class="koboSpan" id="kobo.121.1"> were heavily influenced by the </span><strong class="bold"><span class="koboSpan" id="kobo.122.1">World Wide Web Consortium</span></strong><span class="koboSpan" id="kobo.123.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.124.1">W3C</span></strong><span class="koboSpan" id="kobo.125.1">) </span><strong class="bold"><span class="koboSpan" id="kobo.126.1">State Chart XML</span></strong><span class="koboSpan" id="kobo.127.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.128.1">SCXML</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">) specification.</span></span></p>
<p><span class="koboSpan" id="kobo.130.1">Let’s take a quick detour to find out what SCXML is and what it means that it has a W3C specification. </span><span class="koboSpan" id="kobo.130.2">Depending on your experience</span><a id="_idIndexMarker311"/><span class="koboSpan" id="kobo.131.1"> in programming, you may have heard of the </span><strong class="bold"><span class="koboSpan" id="kobo.132.1">Extensible Markup Language</span></strong><span class="koboSpan" id="kobo.133.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.134.1">XML</span></strong><span class="koboSpan" id="kobo.135.1">) file format and markup language. </span><span class="koboSpan" id="kobo.135.2">XML is used to store, transmit, and reconstruct data. </span><span class="koboSpan" id="kobo.135.3">XML files are easy to read when properly indented and formatted, as they simply describe data. </span><span class="koboSpan" id="kobo.135.4">SCXML is a cousin of XML. </span><span class="koboSpan" id="kobo.135.5">It’s an XML-based markup language used for providing a state-machine-based environment. </span><span class="koboSpan" id="kobo.135.6">The fact that it has a W3C specification means that it can be used for various internet-related programs with great confidence. </span><span class="koboSpan" id="kobo.135.7">You can find a link to the entire W3C specification in the </span><em class="italic"><span class="koboSpan" id="kobo.136.1">Further </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.137.1">reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.138.1"> section.</span></span></p>
<p><span class="koboSpan" id="kobo.139.1">Going back to XState, not only has it been influenced by SCXML, but it is also fully compatible with it, which means you could write an SCXML document describing states, and it will work with an XState implementation in your React Native app. </span><span class="koboSpan" id="kobo.139.2">You can also write it in JavaScript. </span><span class="koboSpan" id="kobo.139.3">Whatever rocks </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">your boat!</span></span></p>
<p><span class="koboSpan" id="kobo.141.1">I asked David Khourshid about the future </span><a id="_idIndexMarker312"/><span class="koboSpan" id="kobo.142.1">of his library. </span><span class="koboSpan" id="kobo.142.2">XState is an open source project, as with all the other state management libraries we talk about in this book. </span><span class="koboSpan" id="kobo.142.3">David said maintaining XState and working on XState-related tools is his full-time job. </span><span class="koboSpan" id="kobo.142.4">He is working on new and powerful collaborative editing tools for the XState visualizer. </span><span class="koboSpan" id="kobo.142.5">He said: “</span><em class="italic"><span class="koboSpan" id="kobo.143.1">the next major version of XState (version 5) will have many more features, be more modular, and have “actors” as first-class citizens. </span><span class="koboSpan" id="kobo.143.2">Actors are entities that can send and receive messages, and state machines are just one of many behaviors that an actor can have. </span><span class="koboSpan" id="kobo.143.3">You can also represent actors as promises, observables, reducers, and more, which will allow developers to use XState’s API (and visual tools) for all of their logic, not just the </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.144.1">state-machine-specific logic."</span></em></span></p>
<p><span class="koboSpan" id="kobo.145.1">You may have noticed a mention of an XState visualizer in the previous paragraph. </span><span class="koboSpan" id="kobo.145.2">This tool is something that absolutely sets XState apart from other state management libraries. </span><span class="koboSpan" id="kobo.145.3">Thanks to this visualizer, you can see a graphical representation of states and transitions between states in your app. </span><span class="koboSpan" id="kobo.145.4">You can use it to plan a new app or debug an app that you</span><a id="_idIndexMarker313"/><span class="koboSpan" id="kobo.146.1"> are working on. </span><span class="koboSpan" id="kobo.146.2">You can find the visualizer at https://xstate.js.org/viz/. </span><span class="koboSpan" id="kobo.146.3">Here’s an example screenshot of what it </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">looks like:</span></span></p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<div>
<div class="IMG---Figure" id="_idContainer038">
<span class="koboSpan" id="kobo.148.1"><img alt="Figure 7.3 – Screenshot of the XState visualizer " src="image/Figure_7.03_B18396.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.149.1">Figure 7.3 – Screenshot of the XState visualizer</span></p>
<p><span class="koboSpan" id="kobo.150.1">David said that the visualizer is one of the hardest things he has worked on. </span><span class="koboSpan" id="kobo.150.2">It’s always a work in progress, and it has gone through many iterations. </span><span class="koboSpan" id="kobo.150.3">Currently, it’s an “</span><em class="italic"><span class="koboSpan" id="kobo.151.1">SVG-based 'canvas' with HTML inside."</span></em><span class="koboSpan" id="kobo.152.1"> Even though it’s somewhat interactive right now—you can click on transitions and observe how the state changes—David said that “</span><em class="italic"><span class="koboSpan" id="kobo.153.1">making it interactive is yet another layer of difficulty, especially for drag-and-drop interactions and modifying the statechart."</span></em><span class="koboSpan" id="kobo.154.1"> Personally, I’m very excited about the new versions of the visualizer. </span><span class="koboSpan" id="kobo.154.2">It has helped me many times to plan the best possible state machine for the apps I worked on (that </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">used XState).</span></span></p>
<p><span class="koboSpan" id="kobo.156.1">In this section, we have talked</span><a id="_idIndexMarker314"/><span class="koboSpan" id="kobo.157.1"> about the main ideas behind XState. </span><span class="koboSpan" id="kobo.157.2">They are different from all the previous approaches we analyzed. </span><span class="koboSpan" id="kobo.157.3">The entire library is based on the mathematical concept of finite state machines. </span><span class="koboSpan" id="kobo.157.4">It also uses the theories behind statecharts and actor models, to make sure managing state in a complex app can be done effectively. </span><span class="koboSpan" id="kobo.157.5">Now, it’s time to see this library in action. </span><span class="koboSpan" id="kobo.157.6">Let’s move on to implementing XState in the </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">Funbook app.</span></span></p>
<h1 id="_idParaDest-88"><a id="_idTextAnchor089"/><span class="koboSpan" id="kobo.159.1">Configuring XState in the Funbook app</span></h1>
<p><span class="koboSpan" id="kobo.160.1">Let’s see what it takes</span><a id="_idIndexMarker315"/><span class="koboSpan" id="kobo.161.1"> to use XState in a real</span><a id="_idIndexMarker316"/><span class="koboSpan" id="kobo.162.1"> app. </span><span class="koboSpan" id="kobo.162.2">If you would like to follow along on your own, you can copy the </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">example-app-full</span></strong><span class="koboSpan" id="kobo.164.1"> folder and use it as a starting point. </span><span class="koboSpan" id="kobo.164.2">If you prefer to look at the code related to this chapter, please look in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">chapter-7</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.166.1">folder: </span></span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-7</span></span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.169.1">First things first—we need to add XState to the project. </span><span class="koboSpan" id="kobo.169.2">You can do so by running one of the two </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">following commands:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.171.1">
npm install xstate@latest --save
// or
yarn add xstate@latest --save</span></pre>
<p><span class="koboSpan" id="kobo.172.1">XState itself is an unopinionated library, much like MobX. </span><span class="koboSpan" id="kobo.172.2">This means it is not ready out-of-the-box to work with React. </span><span class="koboSpan" id="kobo.172.3">The XState documentation has a section called </span><em class="italic"><span class="koboSpan" id="kobo.173.1">Recipes</span></em><span class="koboSpan" id="kobo.174.1"> where you can read more on the implementation with React or other UI libraries, such as Vue or Svelte. </span><span class="koboSpan" id="kobo.174.2">As for us, we need to add the React-related dependency, </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">xstate-react</span></strong><span class="koboSpan" id="kobo.176.1">. </span><span class="koboSpan" id="kobo.176.2">Let’s do this by running one of the two </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">following commands:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.178.1">
npm install xstate-react@latest –-save
// or
yarn add xstate-react@latest –-save</span></pre>
<p><span class="koboSpan" id="kobo.179.1">Now that we have the dependencies ready, let’s run the app to make sure everything is working as expected. </span><span class="koboSpan" id="kobo.179.2">If everything is OK, we can create our very first state machine. </span><span class="koboSpan" id="kobo.179.3">We will start with a simple example: user login flow. </span><span class="koboSpan" id="kobo.179.4">At a high level, there isn’t much logic involved in this flow. </span><span class="koboSpan" id="kobo.179.5">The user can be either logged in or out, and they transition from one state to the other </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">and back:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.181.1">
import { createMachine } from 'xstate';
export const userFlowMachine = createMachine({
  id: 'userFlow',
  initial: 'anonymous',
  states: {
    anonymous,
    authenticated,
  }
});</span></pre>
<p><span class="koboSpan" id="kobo.182.1">Reading through the code</span><a id="_idIndexMarker317"/><span class="koboSpan" id="kobo.183.1"> is rather logical. </span><span class="koboSpan" id="kobo.183.2">We start by importing a </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">createMachine</span></strong><span class="koboSpan" id="kobo.185.1"> function, which we call</span><a id="_idIndexMarker318"/><span class="koboSpan" id="kobo.186.1"> to create our </span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">userFlowMachine</span></strong><span class="koboSpan" id="kobo.188.1"> instance. </span><span class="koboSpan" id="kobo.188.2">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">userFlowMachine</span></strong><span class="koboSpan" id="kobo.190.1">, we start by defining the machine ID and the initial state. </span><span class="koboSpan" id="kobo.190.2">We then continue to define the two possible states of the app. </span><span class="koboSpan" id="kobo.190.3">The user in our app can be anonymous or authenticated. </span><span class="koboSpan" id="kobo.190.4">But how can the user transition from one state to the other? </span><span class="koboSpan" id="kobo.190.5">Let’s add this functionality to the </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">state machine:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.192.1">
import { createMachine } from 'xstate';
export const userFlowMachine = createMachine({
  id: 'userFlow',
  initial: 'anonymous',
  states: {
    anonymous: {
      on: {
        LOGIN: { target: 'authenticated' },
      }
    },
    authenticated: {
        on: {
            LOGOUT: { target: 'anonymous' },
          }
    },
  }
});</span></pre>
<p><span class="koboSpan" id="kobo.193.1">Great! </span><span class="koboSpan" id="kobo.193.2">Now, the user</span><a id="_idIndexMarker319"/><span class="koboSpan" id="kobo.194.1"> can be in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">anonymous</span></strong><span class="koboSpan" id="kobo.196.1"> state, from</span><a id="_idIndexMarker320"/><span class="koboSpan" id="kobo.197.1"> which they can transition using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">LOGIN</span></strong><span class="koboSpan" id="kobo.199.1"> transition. </span><span class="koboSpan" id="kobo.199.2">At this moment, they will be in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">authenticated</span></strong><span class="koboSpan" id="kobo.201.1"> state, from which they can transition using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">LOGOUT</span></strong><span class="koboSpan" id="kobo.203.1"> transition. </span><span class="koboSpan" id="kobo.203.2">You could continue improving this example by adding some implementation details to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">LOGIN</span></strong><span class="koboSpan" id="kobo.205.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">LOGOUT</span></strong><span class="koboSpan" id="kobo.207.1"> transitions, or maybe an error state. </span><span class="koboSpan" id="kobo.207.2">But I will stop talking about this particular state machine now and see how it should be used in a </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">React app.</span></span></p>
<p><span class="koboSpan" id="kobo.209.1">Unsurprisingly, the XState docs recommend using React Context to manage global state with XState. </span><span class="koboSpan" id="kobo.209.2">Luckily for us, we have a good handle on React Context by now, right? </span><span class="koboSpan" id="kobo.209.3">So, let’s look at an example of React Context in the </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">XState documentation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.211.1">
import React, { createContext } from 'react';
import { useInterpret } from '@xstate/react';
import { userFlowMachine } from './machines/userFlowMachine;
export const GlobalStateContext = createContext({});
export const GlobalStateProvider = (props) =&gt; {
  const userFlowService = useInterpret(userFlowMachine);
  return (
    &lt;GlobalStateContext.Provider value={{ userFlowService }}&gt;
      {props.children}
    &lt;/GlobalStateContext.Provider&gt;
  );
};</span></pre>
<p><span class="koboSpan" id="kobo.212.1">Hmm… what</span><a id="_idIndexMarker321"/><span class="koboSpan" id="kobo.213.1"> is this </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">useInterpret()</span></strong><span class="koboSpan" id="kobo.215.1"> function? </span><span class="koboSpan" id="kobo.215.2">It’s imported</span><a id="_idIndexMarker322"/><span class="koboSpan" id="kobo.216.1"> from </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">xstate-react</span></strong><span class="koboSpan" id="kobo.218.1">, and it’s a special tool to make sure we don’t cause too many re-renders when using React Context. </span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">useInterpret()</span></strong><span class="koboSpan" id="kobo.220.1"> returns a service, which is a reference to the state machine. </span><span class="koboSpan" id="kobo.220.2">As per the XState documentation: “</span><em class="italic"><span class="koboSpan" id="kobo.221.1">this value never changes, so we don’t need to worry about </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.222.1">wasted re-renders.</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">”</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.224.1">Knowing your tools</span></p>
<p class="callout"><span class="koboSpan" id="kobo.225.1">Every tool was created with an idea of how it should be used. </span><span class="koboSpan" id="kobo.225.2">You could take a hammer and use the wooden handle to hit a nail, but you have learned this is not how hammers work best. </span><span class="koboSpan" id="kobo.225.3">The same rule applies to JavaScript libraries. </span><span class="koboSpan" id="kobo.225.4">No one was born with the knowledge of JavaScript libraries and tooling. </span><span class="koboSpan" id="kobo.225.5">We all must read the documentation and learn our tools’ </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">best practices.</span></span></p>
<p><span class="koboSpan" id="kobo.227.1">We have a way to create context, so now, let’s go through XState’s instructions for using it. </span><span class="koboSpan" id="kobo.227.2">We will have to subscribe to the service of the global context we defined at the root of the app. </span><span class="koboSpan" id="kobo.227.3">Here’s what such a subscription would </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">look like:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.229.1">
import React, { useContext } from 'react';
import { GlobalStateContext } from './globalState';
import { useActor } from '@xstate/react';
export const SomeComponent = (props) =&gt; {
  const globalServices = useContext(GlobalStateContext);
  const [state] = useActor(globalServices. </span><span class="koboSpan" id="kobo.229.2">userFlowService);
    return state.matches('loggedIn') ? </span><span class="koboSpan" id="kobo.229.3">'Logged In' :      'Logged Out';
};</span></pre>
<p><span class="koboSpan" id="kobo.230.1">We have completed</span><a id="_idIndexMarker323"/><span class="koboSpan" id="kobo.231.1"> the basic setup for XState in a React Native</span><a id="_idIndexMarker324"/><span class="koboSpan" id="kobo.232.1"> app. </span><span class="koboSpan" id="kobo.232.2">There are many paths to be taken now: improving performance, dispatching events, or using state selectors. </span><span class="koboSpan" id="kobo.232.3">We will go over the necessary steps in the next section, where we will set up XState for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">LikedImages</span></strong><span class="koboSpan" id="kobo.234.1"> surface and the modal responsible for adding </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">liked images.</span></span></p>
<h1 id="_idParaDest-89"><a id="_idTextAnchor090"/><span class="koboSpan" id="kobo.236.1">Using XState for the FavoritedImages surface</span></h1>
<p><span class="koboSpan" id="kobo.237.1">In the previous section, we set up</span><a id="_idIndexMarker325"/><span class="koboSpan" id="kobo.238.1"> a basic machine</span><a id="_idIndexMarker326"/><span class="koboSpan" id="kobo.239.1"> that could be used to control the user flow in the app. </span><span class="koboSpan" id="kobo.239.2">Let’s add a new machine, for our real-world use case: liking images in a social media </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">clone app.</span></span></p>
<p><span class="koboSpan" id="kobo.241.1">We’ll start</span><a id="_idIndexMarker327"/><span class="koboSpan" id="kobo.242.1"> by creating a machine </span><strong class="bold"><span class="koboSpan" id="kobo.243.1">minimum viable </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.244.1">product</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.245.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.246.1">MVP</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.248.1">
// src/machines/likeImagesMachine.js
import { createMachine } from "xstate";
export const likeImagesMachine = createMachine({
  id: "likeImagesMachine",
  context: {
    likedImages: [
       { Example Image Object 1},
       { Example Image Object 2}
       …
       ],
  },
  initial: "loading",
  states: {
    loading: {},
    ready: {},
    error: {},
  },
});</span></pre>
<p><span class="koboSpan" id="kobo.249.1">Let’s analyze this code from the top: we start by importing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">createMachine</span></strong><span class="koboSpan" id="kobo.251.1"> function, which we use on the very first line of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">likeImagesMachine</span></strong><span class="koboSpan" id="kobo.253.1"> function. </span><span class="koboSpan" id="kobo.253.2">We set the ID of the machine and the context. </span><span class="koboSpan" id="kobo.253.3">Bear in mind that XState context is different from React context. </span><span class="koboSpan" id="kobo.253.4">We’ve talked a lot about ReactJS context; we know it can be used to share state between components. </span><span class="koboSpan" id="kobo.253.5">XState context is a container for quantitative data (such as strings, arrays, or objects), which can potentially be infinite. </span><span class="koboSpan" id="kobo.253.6">The array of liked images is a great example of this sort of data, and that’s why we’ll be keeping this array in our machine’s context. </span><span class="koboSpan" id="kobo.253.7">For testing purposes, we will add a couple of images to this default array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">likedImages</span></strong><span class="koboSpan" id="kobo.255.1"> in the context. </span><span class="koboSpan" id="kobo.255.2">All that’s left is defining states of our machine and setting the default </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">state. </span><span class="koboSpan" id="kobo.256.2">Easy-peasy!</span></span></p>
<p><span class="koboSpan" id="kobo.257.1">We will start by creating</span><a id="_idIndexMarker328"/><span class="koboSpan" id="kobo.258.1"> and configuring a wrapper</span><a id="_idIndexMarker329"/><span class="koboSpan" id="kobo.259.1"> for the state, with the help of React’s context. </span><span class="koboSpan" id="kobo.259.2">Once everything is set up correctly with mock data, we will fetch real data from our backend. </span><span class="koboSpan" id="kobo.259.3">Having fetched data, we will write the last piece of code: managing liked images </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">with XState.</span></span></p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor091"/><span class="koboSpan" id="kobo.261.1">Configuring context and components</span></h2>
<p><span class="koboSpan" id="kobo.262.1">Now is the time to talk about</span><a id="_idIndexMarker330"/><span class="koboSpan" id="kobo.263.1"> the first type of context: React context. </span><span class="koboSpan" id="kobo.263.2">We set</span><a id="_idIndexMarker331"/><span class="koboSpan" id="kobo.264.1"> up a nifty context with the user flow in the previous section. </span><span class="koboSpan" id="kobo.264.2">We will add the liked images machine to </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">this context:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.266.1">
// src/context.js
[…]
import { useInterpret } from "@xstate/react";
  import { likeImagesMachine } from "./machines/    likeImagesMachine ";
import { userFlow } from "./machines/userFlowMachine";
export const GlobalStateContext = createContext({});
export const useXStateContext = () =&gt; {
  const context = React.useContext(GlobalStateContext);
  if (context === undefined) {
    throw new Error(
        " useXStateContext must be used within a           GlobalStateContextProvider"
    );
  }
  return context;
};
export const GlobalStateProvider = (props) =&gt; {
  const likedImagesAppService = useInterpret(likeImagesMachine);
  const userFlowService = useInterpret(userFlow);
  const mergedServices = {
    likedImagesAppService,
    userFlowService,
  };
  return (
    &lt;GlobalStateContext.Provider value={mergedServices}&gt;
      {props.children}
    &lt;/GlobalStateContext.Provider&gt;
  );
};</span></pre>
<p><span class="koboSpan" id="kobo.267.1">This is a good moment</span><a id="_idIndexMarker332"/><span class="koboSpan" id="kobo.268.1"> to improve</span><a id="_idIndexMarker333"/><span class="koboSpan" id="kobo.269.1"> the basic context we set up in the previous, more theoretical part of this chapter. </span><span class="koboSpan" id="kobo.269.2">We will do so by adding a new custom hook called </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">useXStateContext</span></strong><span class="koboSpan" id="kobo.271.1">. </span><span class="koboSpan" id="kobo.271.2">Using custom hooks with React context is a best practice that we covered in previous chapters. </span><span class="koboSpan" id="kobo.271.3">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">GlobalStateProvider</span></strong><span class="koboSpan" id="kobo.273.1"> function, we added </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">likedImagesMachine</span></strong><span class="koboSpan" id="kobo.275.1"> through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">useInterpret</span></strong><span class="koboSpan" id="kobo.277.1"> custom hook provided by the good people at XState. </span><span class="koboSpan" id="kobo.277.2">We merge the interpreted machines and pass them as the context value. </span><span class="koboSpan" id="kobo.277.3">The last piece of the context value is wrapping the component in context. </span><span class="koboSpan" id="kobo.277.4">We will have to keep the global state at the very root of the app so that both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">FavoritedImages</span></strong><span class="koboSpan" id="kobo.279.1"> surface and </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">ImageDetailsModal</span></strong><span class="koboSpan" id="kobo.281.1"> can reach it. </span><span class="koboSpan" id="kobo.281.2">Here’s what your </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">App.js</span></strong><span class="koboSpan" id="kobo.283.1"> should roughly </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">look like:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.285.1">
// src/App.js
[…]
import {
  […]
    GlobalStateProvider
      } from "./src/context";
[…]
return (
    &lt;SafeAreaProvider&gt;
      &lt;GlobalStateProvider&gt;
        &lt;UserStateContext.Provider value={userLoggedIn}&gt;
[…]</span></pre>
<p><span class="koboSpan" id="kobo.286.1">Let’s use this brand-new machine, interpreted by React</span><a id="_idIndexMarker334"/><span class="koboSpan" id="kobo.287.1"> context and holding a few example images</span><a id="_idIndexMarker335"/><span class="koboSpan" id="kobo.288.1"> in its own context, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">FavoritedImages</span></strong><span class="koboSpan" id="kobo.290.1"> surface. </span><span class="koboSpan" id="kobo.290.2">The list of favorited images is rendered in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">ListOfFavorites</span></strong><span class="koboSpan" id="kobo.292.1"> component, and this is the component we will </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">be changing:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.294.1">
// src/components/ListOfFavorties.js
import { useXStateContext } from "../context";
import { useActor } from "@xstate/react";
export const ListOfFavorites = ({ navigation }) =&gt; {
  const globalServices = useXStateContext();
    const [state] = useActor(globalServices.      likedImagesAppService);
    const [imageData, updateImageData] = useState       (state.context.likedImages);
//…
  return (
    //…
      &lt;FlatList
        data={imageData}
//…</span></pre>
<p><span class="koboSpan" id="kobo.295.1">We start by importing the custom </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">useXStateContext</span></strong><span class="koboSpan" id="kobo.297.1"> hook we created to easily consume React context. </span><span class="koboSpan" id="kobo.297.2">The second thing</span><a id="_idIndexMarker336"/><span class="koboSpan" id="kobo.298.1"> we need to import is XState’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">useActor</span></strong><span class="koboSpan" id="kobo.300.1"> hook. </span><span class="koboSpan" id="kobo.300.2">This is a React</span><a id="_idIndexMarker337"/><span class="koboSpan" id="kobo.301.1"> hook that subscribes to emitted changes from a given interpreted state machine, named by the XState author “an actor." </span><span class="koboSpan" id="kobo.301.2">If you go to the XState documentation, you will find there are other implementations of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">useActor</span></strong><span class="koboSpan" id="kobo.303.1"> function, tailored for use with Svelte, Vue, and other libraries. </span><span class="koboSpan" id="kobo.303.2">This is because XState, much like MobX, is unopinionated when it comes to </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">UI libraries.</span></span></p>
<p><span class="koboSpan" id="kobo.305.1">Finally, we need to use all those imported items in our component. </span><span class="koboSpan" id="kobo.305.2">We pull in data from React context, and we subscribe to changes through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">useActor</span></strong><span class="koboSpan" id="kobo.307.1"> hook. </span><span class="koboSpan" id="kobo.307.2">We could use the state returned from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">useActor</span></strong><span class="koboSpan" id="kobo.309.1"> hook directly. </span><span class="koboSpan" id="kobo.309.2">However, React Native’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">FlatList</span></strong><span class="koboSpan" id="kobo.311.1"> needs to be informed of data changes very clearly to update. </span><span class="koboSpan" id="kobo.311.2">Therefore, I added a </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">useState</span></strong><span class="koboSpan" id="kobo.313.1"> hook, including the </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">updateImageData</span></strong><span class="koboSpan" id="kobo.315.1"> setter function, which will come in handy once we try to add images to this </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">array dynamically.</span></span></p>
<p><span class="koboSpan" id="kobo.317.1">Speaking of dynamically, it’s time to think about data fetching through XState. </span><span class="koboSpan" id="kobo.317.2">But before we go any further, make sure to run your app with the current changes and make sure you can see the example images from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">likeImagesMachine</span></strong><span class="koboSpan" id="kobo.319.1"> function on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">FavoritedImages</span></strong><span class="koboSpan" id="kobo.321.1"> surface. </span><span class="koboSpan" id="kobo.321.2">If you do encounter any errors, you can look at your terminal window, as many XState errors will be described there. </span><span class="koboSpan" id="kobo.321.3">They should also be visible on your phone simulator or physical device. </span><span class="koboSpan" id="kobo.321.4">Here’s an example error you may see in the console and in the simulator at the </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">same time:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer039">
<span class="koboSpan" id="kobo.323.1"><img alt="Figure 7.4 – XState errors in the console and phone simulator " src="image/Figure_7.04_B18396.jpg"/></span>
</div>
</div>
<div>
<div class="IMG---Figure" id="_idContainer040">
<span class="koboSpan" id="kobo.324.1"><img alt="Figure 7.4 – XState errors in the console and phone simulator " src="image/Figure_7.05_B18396.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.325.1">Figure 7.4 – XState errors in the console and phone simulator</span></p>
<h2 id="_idParaDest-91"><a id="_idTextAnchor092"/><span class="koboSpan" id="kobo.326.1">Fetching image data</span></h2>
<p><span class="koboSpan" id="kobo.327.1">Fetching data</span><a id="_idIndexMarker338"/><span class="koboSpan" id="kobo.328.1"> isn’t always the strong</span><a id="_idIndexMarker339"/><span class="koboSpan" id="kobo.329.1"> suit of state management libraries. </span><span class="koboSpan" id="kobo.329.2">After all, it’s not their basic responsibility. </span><span class="koboSpan" id="kobo.329.3">In the case of XState, however, fetching comes very naturally as every Promise can be modeled as a state machine. </span><span class="koboSpan" id="kobo.329.4">At a high level, we need to kick off a function that will be in a default “loading” state. </span><span class="koboSpan" id="kobo.329.5">We’ll wait for something to happen with it—either resolve or reject—and go to the appropriate “resolved” or “rejected” states. </span><span class="koboSpan" id="kobo.329.6">Here’s how our image-fetching machine is </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">shaping up:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.331.1">
// src/machines/fetchMachine.js
import { createMachine, assign } from "xstate";
export const fetchImagesMachine = createMachine({
  id: "fetchImages",
  initial: "loading",
  context: {
    retries: 0,
    images: [],
  },
  states: {
    loading: {
      on: {
        RESOLVE: "success",
        REJECT: "failure",
      },
    },
    success: {
      type: "final",
    },
    failure: {
      on: {
        RETRY: {
          target: "loading",
          actions: assign({
            retries: (context, event) =&gt; context.retries+1,
          }),
        },
      },
    },
  },
});</span></pre>
<p><span class="koboSpan" id="kobo.332.1">What you can see here</span><a id="_idIndexMarker340"/><span class="koboSpan" id="kobo.333.1"> is a very simple machine, prepared to describe the process</span><a id="_idIndexMarker341"/><span class="koboSpan" id="kobo.334.1"> of fetching data from an external source. </span><span class="koboSpan" id="kobo.334.2">We have three states: the initial state of </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">loading</span></strong><span class="koboSpan" id="kobo.336.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">success</span></strong><span class="koboSpan" id="kobo.338.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">failure</span></strong><span class="koboSpan" id="kobo.340.1"> states. </span><span class="koboSpan" id="kobo.340.2">You can see two actions in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">loading</span></strong><span class="koboSpan" id="kobo.342.1"> state, which could be used to manage the fetching mechanism. </span><span class="koboSpan" id="kobo.342.2">There’s also a </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">retry</span></strong><span class="koboSpan" id="kobo.344.1"> action in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">failure</span></strong><span class="koboSpan" id="kobo.346.1"> state. </span><span class="koboSpan" id="kobo.346.2">We could use it in the app to let the users manually try to fetch data when an error occurs. </span><span class="koboSpan" id="kobo.346.3">As far as the basic setup is concerned, this is all good, but we need to see how to call a real endpoint. </span><span class="koboSpan" id="kobo.346.4">In order to do so, we will change the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">loading</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.348.1"> state:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.349.1">
//…
states: {
    loading: {
      invoke: {
        id: 'fetchImagesFunction',
        src: async () =&gt; {
          const response = await fetch(
            requestBase + "/john_doe/likedImages.json"
          );
          const imageData = await response.json();
          return imageData;
        },
        onDone: {
          target: "success",
          actions: assign((context, event) =&gt; {
            return {
              images: event.data,
            };
          }),
        },
        onError: {
          target: "failure",
          actions: assign({
              error: (context, event) =&gt; "Oops!                Something went wrong",
          }),
        },
      },
    },</span></pre>
<p><span class="koboSpan" id="kobo.350.1">Instead of two actions</span><a id="_idIndexMarker342"/><span class="koboSpan" id="kobo.351.1"> that could be called manually, I added the </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">invoke</span></strong><span class="koboSpan" id="kobo.353.1"> property to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">loading</span></strong><span class="koboSpan" id="kobo.355.1"> state. </span><span class="koboSpan" id="kobo.355.2">This way, the images will be loaded automatically when</span><a id="_idIndexMarker343"/><span class="koboSpan" id="kobo.356.1"> the machine is spawned, without needing user interaction. </span><span class="koboSpan" id="kobo.356.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">invoke</span></strong><span class="koboSpan" id="kobo.358.1"> property’s value is an object that contains the </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">id</span></strong><span class="koboSpan" id="kobo.360.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">src</span></strong><span class="koboSpan" id="kobo.362.1"> properties of the function that is to be invoked. </span><span class="koboSpan" id="kobo.362.2">It is possible to invoke Promises, callbacks—which can send and receive events from the parent machine—observables—which can send events to the parent machine—and entire machines. </span><span class="koboSpan" id="kobo.362.3">We will stay on the simple side of things, and we will add an async </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">fetch</span></strong><span class="koboSpan" id="kobo.364.1"> function to the source. </span><span class="koboSpan" id="kobo.364.2">You may also create a named function anywhere outside of the machine and invoke it through </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">src</span></strong><span class="koboSpan" id="kobo.366.1">. </span><span class="koboSpan" id="kobo.366.2">We are also using two optional values from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">invoke</span></strong><span class="koboSpan" id="kobo.368.1"> property: </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">onDone</span></strong><span class="koboSpan" id="kobo.370.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">onError</span></strong><span class="koboSpan" id="kobo.372.1">. </span><span class="koboSpan" id="kobo.372.2">These two transitions come in handy when handling Promises. </span><span class="koboSpan" id="kobo.372.3">They act like any other XState transition—they include actions and the target state. </span><span class="koboSpan" id="kobo.372.4">Both actions include the </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">assign</span></strong><span class="koboSpan" id="kobo.374.1"> keyword. </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">assign</span></strong><span class="koboSpan" id="kobo.376.1"> is a function that updates the machine’s context. </span><span class="koboSpan" id="kobo.376.2">We use it here to pass the resulting fetched data to the context so that we can use it later in our app. </span><span class="koboSpan" id="kobo.376.3">Assigner functions have some caveats: they have to be pure, and they surrender to a strict order. </span><span class="koboSpan" id="kobo.376.4">If you want to read more about them, please check the links provided in the </span><em class="italic"><span class="koboSpan" id="kobo.377.1">Further </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.378.1">reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.379.1"> section.</span></span></p>
<p><span class="koboSpan" id="kobo.380.1">If everything works fine, you should</span><a id="_idIndexMarker344"/><span class="koboSpan" id="kobo.381.1"> be able to fetch images thanks to this function. </span><span class="koboSpan" id="kobo.381.2">But how</span><a id="_idIndexMarker345"/><span class="koboSpan" id="kobo.382.1"> do we use those images in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">likeImagesMachine</span></strong><span class="koboSpan" id="kobo.384.1"> function? </span><span class="koboSpan" id="kobo.384.2">Remember that </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">invoke</span></strong><span class="koboSpan" id="kobo.386.1"> property we just used for the Promise? </span><span class="koboSpan" id="kobo.386.2">We’ll use that same property on </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">likeImagesMachine</span></strong><span class="koboSpan" id="kobo.388.1"> in the loading state, to invoke this fetching machine and pass the fetched data thanks to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">onDone</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.390.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.391.1">
// src/machines/likeImagesMachine.js
import { fetchImagesMachine } from "./fetchImagesMachine";
export const likeImagesMachine  = createMachine({
  id: "likeImagesMachine ",
  context: {
    likedImages: [],
    currentImage: null,
  },
  initial: "loading",
  states: {
    loading: {
      invoke: {
        id: "fetchImagesMachine",
        src: fetchImagesMachine,
        onDone: {
          target: "ready",
          actions: assign({
            likedImages: (context, event) =&gt; {
              return event.data.images;
            },
          }),
        },
      },
    },
//…</span></pre>
<p><span class="koboSpan" id="kobo.392.1">In this code snippet, we’ve imported the </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">fetchImagesMachine</span></strong><span class="koboSpan" id="kobo.394.1"> function and we invoke</span><a id="_idIndexMarker346"/><span class="koboSpan" id="kobo.395.1"> it in the loading state</span><a id="_idIndexMarker347"/><span class="koboSpan" id="kobo.396.1"> of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">likeImagesMachine</span></strong><span class="koboSpan" id="kobo.398.1"> function. </span><span class="koboSpan" id="kobo.398.2">Let’s take a closer look at the assigner function we’re using to pass image data from </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">fetchImagesMachine</span></strong><span class="koboSpan" id="kobo.400.1"> to this parent machine. </span><span class="koboSpan" id="kobo.400.2">It has an </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">onDone</span></strong><span class="koboSpan" id="kobo.402.1"> function, which will be called when </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">fetchImagesMachine</span></strong><span class="koboSpan" id="kobo.404.1"> reaches its final state. </span><span class="koboSpan" id="kobo.404.2">This function assigns data returned from the invoked machine to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">context</span></strong><span class="koboSpan" id="kobo.406.1"> of </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">likeImagesMachine</span></strong><span class="koboSpan" id="kobo.408.1">, and the data is passed through </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">event</span></strong><span class="koboSpan" id="kobo.410.1">. </span><span class="koboSpan" id="kobo.410.2">You will notice we’re calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">event.data.images</span></strong><span class="koboSpan" id="kobo.412.1">. </span><span class="koboSpan" id="kobo.412.2">Where did that come from? </span><span class="koboSpan" id="kobo.412.3">This is something we need to add to </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">fetchImagesMachine</span></strong><span class="koboSpan" id="kobo.414.1">. </span><span class="koboSpan" id="kobo.414.2">So far, that machine only passed fetched data to its </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">context</span></strong><span class="koboSpan" id="kobo.416.1">, but we need to expose it so that the parent machine, </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">likeImagesMachine</span></strong><span class="koboSpan" id="kobo.418.1">, can access it. </span><span class="koboSpan" id="kobo.418.2">We already know the </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">onDone</span></strong><span class="koboSpan" id="kobo.420.1"> event in the parent (</span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">likeImagesMachine</span></strong><span class="koboSpan" id="kobo.422.1">) is called when the child (</span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">fetchImagesMachine</span></strong><span class="koboSpan" id="kobo.424.1">) reaches its final state. </span><span class="koboSpan" id="kobo.424.2">The final state in our case is </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">success</span></strong><span class="koboSpan" id="kobo.426.1">. </span><span class="koboSpan" id="kobo.426.2">This is where we can add the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">data</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.428.1"> property:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.429.1">
// src/machines/fetchImagesMachine.js
//…
success: {
      type: "final",
      data: {
        images: (context, event) =&gt; context.images,
      },
    },
//…</span></pre>
<p><span class="koboSpan" id="kobo.430.1">This block of code tells the </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">fetchImagesMachine</span></strong><span class="koboSpan" id="kobo.432.1"> function to add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">data</span></strong><span class="koboSpan" id="kobo.434.1"> object to its final state. </span><span class="koboSpan" id="kobo.434.2">This is the object that we access when we run </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">onDone</span></strong><span class="koboSpan" id="kobo.436.1"> in the parent (</span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">likeImagesMachine</span></strong><span class="koboSpan" id="kobo.438.1">). </span><span class="koboSpan" id="kobo.438.2">If everything</span><a id="_idIndexMarker348"/><span class="koboSpan" id="kobo.439.1"> went well, you should be able to see the entire array of fetched</span><a id="_idIndexMarker349"/><span class="koboSpan" id="kobo.440.1"> images in your app right now. </span><span class="koboSpan" id="kobo.440.2">This is a good moment to run the app on your device or emulator if you </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">haven’t already.</span></span></p>
<h2 id="_idParaDest-92"><a id="_idTextAnchor093"/><span class="koboSpan" id="kobo.442.1">Managing the image in the image modal</span></h2>
<p><span class="koboSpan" id="kobo.443.1">We have ourselves</span><a id="_idIndexMarker350"/><span class="koboSpan" id="kobo.444.1"> a nice setup—we’re fetching images and feeding</span><a id="_idIndexMarker351"/><span class="koboSpan" id="kobo.445.1"> them to the app. </span><span class="koboSpan" id="kobo.445.2">Our app is rather static, though. </span><span class="koboSpan" id="kobo.445.3">We need a way to add new images to the liked images array. </span><span class="koboSpan" id="kobo.445.4">We would also like to check whether an image is liked so that we can display the proper icon </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">ImageDetailsModal</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.449.1">If we want to know whether an image should be liked or unliked, we first need to know whether it’s liked. </span><span class="koboSpan" id="kobo.449.2">But even before we can know whether an image has been liked, we need to know all the data pertinent to that image. </span><span class="koboSpan" id="kobo.449.3">We will add a new item to the context of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">likeImagesMachine</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.451.1"> machine—</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">currentImage</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.454.1">
export const likeImagesMachine  = createMachine({
  id: "likeImagesMachine ",
  context: {
    likedImages: [],
    currentImage: null,
  },
//…</span></pre>
<p><span class="koboSpan" id="kobo.455.1">This is where we will store information on the currently viewed image. </span><span class="koboSpan" id="kobo.455.2">The context is initialized as </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">null</span></strong><span class="koboSpan" id="kobo.457.1">, and we need to add an action that will update this context value. </span><span class="koboSpan" id="kobo.457.2">We will add a new event called </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">MODAL_OPEN</span></strong><span class="koboSpan" id="kobo.459.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">ready</span></strong><span class="koboSpan" id="kobo.461.1"> state </span><span class="No-Break"><span class="koboSpan" id="kobo.462.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">likeImagesMachine</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.465.1">
// src/machines/likeImagesMachine
ready: {
      on: {
        MODAL_OPEN: {
          actions: assign((context, event) =&gt; {
            return {
              currentImage: event.payload,
            };
          }),
        },
        MODAL_CLOSE: {
          actions: assign((context, event) =&gt; {
            return {
              currentImage: null,
            };
          }),
        },
      },
//…</span></pre>
<p><span class="koboSpan" id="kobo.466.1">We will call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">MODAL_OPEN</span></strong><span class="koboSpan" id="kobo.468.1"> action</span><a id="_idIndexMarker352"/><span class="koboSpan" id="kobo.469.1"> when </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">ImageDetailsModal</span></strong><span class="koboSpan" id="kobo.471.1"> is opened, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">MODAL_CLOSE</span></strong><span class="koboSpan" id="kobo.473.1"> when the modal</span><a id="_idIndexMarker353"/><span class="koboSpan" id="kobo.474.1"> is closed—pretty straightforward! </span><span class="koboSpan" id="kobo.474.2">You can see the code in </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">action here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.476.1">
// src/surfaces/ImageDetailsModal.js
export const ImageDetailsModal = ({ navigation, route }) =&gt; {
  const globalServices = useXStateContext();
  const { send } = globalServices.likedImagesAppService;
  useEffect(() =&gt; {
    send({
      type: "MODAL_OPEN",
      payload: route.params.imageItem,
    });
    return () =&gt; {
      send("MODAL_CLOSE", {});
    };
  }, []);</span></pre>
<p><span class="koboSpan" id="kobo.477.1">We start by using a custom hook called </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">useXStateContext</span></strong><span class="koboSpan" id="kobo.479.1"> in order to consume context values that we set up previously. </span><span class="koboSpan" id="kobo.479.2">Then, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">send</span></strong><span class="koboSpan" id="kobo.481.1"> function from </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">likedImagesAppService</span></strong><span class="koboSpan" id="kobo.483.1">. </span><span class="koboSpan" id="kobo.483.2">Finally, I’ve added a </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">useEffect</span></strong><span class="koboSpan" id="kobo.485.1"> hook calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">MODAL_OPEN</span></strong><span class="koboSpan" id="kobo.487.1"> action when the modal is rendered and </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">MODAL_CLOSE</span></strong><span class="koboSpan" id="kobo.489.1"> as a </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">cleanup function.</span></span></p>
<p><span class="koboSpan" id="kobo.491.1">Now that we have the current</span><a id="_idIndexMarker354"/><span class="koboSpan" id="kobo.492.1"> image saved in the machine</span><a id="_idIndexMarker355"/><span class="koboSpan" id="kobo.493.1"> context, we can check whether it’s liked or not. </span><span class="koboSpan" id="kobo.493.2">To do that, we will use yet another utility from XState: a custom hook called </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">useSelector</span></strong><span class="koboSpan" id="kobo.495.1">. </span><strong class="bold"><span class="koboSpan" id="kobo.496.1">Selector</span></strong><span class="koboSpan" id="kobo.497.1"> is a name</span><a id="_idIndexMarker356"/><span class="koboSpan" id="kobo.498.1"> that may sound familiar to you. </span><span class="koboSpan" id="kobo.498.2">In JavaScript, there are query selectors, Redux promotes using selector functions, and there are also CSS selectors. </span><span class="koboSpan" id="kobo.498.3">XState selectors are the closest ideologically to the ones in Redux. </span><span class="koboSpan" id="kobo.498.4">They are special functions that receive the current state and can return a value based on some conditions. </span><span class="koboSpan" id="kobo.498.5">Our current state is the array of images and the current image, and the condition is if the current image is in the image array. </span><span class="koboSpan" id="kobo.498.6">The code is illustrated in the </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">following snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.500.1">
const isImageLikedSelector = (state) =&gt; {
  if (!state.context.currentImage) {
    return;
  }
  const checkIfInImagesArray = state.context.likedImages.find(
      (image) =&gt; image.itemId === state.context.currentImage.        itemId
  );
  return !!checkIfInImagesArray;
};</span></pre>
<p><span class="koboSpan" id="kobo.501.1">As mentioned previously, this selector will receive the current state as the first argument. </span><span class="koboSpan" id="kobo.501.2">We start by checking that the images array is not </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">null</span></strong><span class="koboSpan" id="kobo.503.1">. </span><span class="koboSpan" id="kobo.503.2">We are running a </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">find</span></strong><span class="koboSpan" id="kobo.505.1"> function on that array, and if it were </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">null</span></strong><span class="koboSpan" id="kobo.507.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">undefined</span></strong><span class="koboSpan" id="kobo.509.1">, this would cause the app to crash. </span><span class="koboSpan" id="kobo.509.2">Once we’re sure the images array exists, we can filter it by the current image. </span><span class="koboSpan" id="kobo.509.3">You can place this function anywhere you’d like (in the same file as the machine, in a file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">selectors</span></strong><span class="koboSpan" id="kobo.511.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">utilities</span></strong><span class="koboSpan" id="kobo.513.1">, and so on) and then import it </span><span class="No-Break"><span class="koboSpan" id="kobo.514.1">into </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">ImageDetailsModal</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.517.1">
// src/surfaces/ImageDetailsModal.js
export const ImageDetailsModal = ({ navigation, route }) =&gt; {
  const globalServices = useXStateContext();
  const { send } = globalServices.globalAppService;
  const isImageLiked = useSelector(
    globalServices.globalAppService,
    isImageLikedSelector
  );</span></pre>
<p><span class="koboSpan" id="kobo.518.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">isImageLiked</span></strong><span class="koboSpan" id="kobo.520.1"> constant can be used in the component</span><a id="_idIndexMarker357"/><span class="koboSpan" id="kobo.521.1"> to check which icon</span><a id="_idIndexMarker358"/><span class="koboSpan" id="kobo.522.1"> should be displayed and which action (liking or unliking) should </span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">be called.</span></span></p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor094"/><span class="koboSpan" id="kobo.524.1">Liking images</span></h2>
<p><span class="koboSpan" id="kobo.525.1">Our state machines are aware</span><a id="_idIndexMarker359"/><span class="koboSpan" id="kobo.526.1"> of the array of images we have fetched and that</span><a id="_idIndexMarker360"/><span class="koboSpan" id="kobo.527.1"> we display on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">FavoritedImages</span></strong><span class="koboSpan" id="kobo.529.1"> surface. </span><span class="koboSpan" id="kobo.529.2">They also become aware of the currently seen image through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">MODAL_OPEN</span></strong><span class="koboSpan" id="kobo.531.1"> action. </span><span class="koboSpan" id="kobo.531.2">Now, we need to tell them what to do if someone presses the “like” button. </span><span class="koboSpan" id="kobo.531.3">Let’s add a new action to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">likeImagesMachine</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.533.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.534.1">
// src/machines/likeImagesMachine.js
//…
ready: {
      on: {
        LIKE: {
          actions: assign((context, event) =&gt; {
            const updateImageArray = event.payload.concat(context.likedImages);
            return {
              likedImages: updateImageArray,
            };
          }),
        },
//…</span></pre>
<p><span class="koboSpan" id="kobo.535.1">We’re using the assigner function, which we’ve met before. </span><span class="koboSpan" id="kobo.535.2">Inside it, we’re concatenating the array containing only the current image to the full array of all images. </span><span class="koboSpan" id="kobo.535.3">This way, the newly added image will be at the top of the array and at the top of </span><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">FlatList</span></strong><span class="koboSpan" id="kobo.537.1">. </span><span class="koboSpan" id="kobo.537.2">Now that the action is ready, we can call it in the modal, </span><span class="No-Break"><span class="koboSpan" id="kobo.538.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.539.1">
// src/surfaces/ImageDetailsModal
//…
&lt;Pressable
          onPress={() =&gt; {
            if (!isImageLiked) {
                send({ type: "LIKE", payload:                  [route.params.imageItem] });
            }
//…</span></pre>
<p><span class="koboSpan" id="kobo.540.1">We’ve done quite</span><a id="_idIndexMarker361"/><span class="koboSpan" id="kobo.541.1"> a few changes—let’s test</span><a id="_idIndexMarker362"/><span class="koboSpan" id="kobo.542.1"> them in our app. </span><span class="koboSpan" id="kobo.542.2">If you followed along, you should be able to see that the fetched images load correctly on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">FavoritedImages</span></strong><span class="koboSpan" id="kobo.544.1"> surface. </span><span class="koboSpan" id="kobo.544.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">ImageDetails</span></strong><span class="koboSpan" id="kobo.546.1"> modal opens correctly as well, showing a full heart for images that are liked and an empty heart for images that are not liked (those on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">Feed</span></strong><span class="koboSpan" id="kobo.548.1"> surface). </span><span class="koboSpan" id="kobo.548.2">We can even press the empty heart and it changes to be filled! </span><span class="koboSpan" id="kobo.548.3">The like action and the selector work as </span><span class="No-Break"><span class="koboSpan" id="kobo.549.1">expected! </span><span class="koboSpan" id="kobo.549.2">Great!</span></span></p>
<p><span class="koboSpan" id="kobo.550.1">Unfortunately, </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">FlatList</span></strong><span class="koboSpan" id="kobo.552.1"> is a little more stubborn. </span><span class="koboSpan" id="kobo.552.2">As mentioned before, </span><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">FlatList</span></strong><span class="koboSpan" id="kobo.554.1"> needs explicit data changes in order to re-render, and we need it to re-render if we want to see the new images added. </span><span class="koboSpan" id="kobo.554.2">We will have to “twist its hand” a little bit, by adding this </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">useEffect</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.556.1"> hook:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.557.1">
// src/components/ListOfFavorites
export const ListOfFavorites = ({ navigation }) =&gt; {
  const globalServices = useXStateContext();
  const [state] = useActor(globalServices.globalAppService);
  const [imageData, updateImageData] = useState([]);
  useEffect(() =&gt; {
    updateImageData(state.context.likedImages);
  }, [state.context.likedImages]);
//…</span></pre>
<p><span class="koboSpan" id="kobo.558.1">And now, everything should work flawlessly! </span><span class="koboSpan" id="kobo.558.2">Time for a pat on the back! </span><span class="koboSpan" id="kobo.558.3">We’ve covered a lot of topics in this section. </span><span class="koboSpan" id="kobo.558.4">We have gone over a real-world implementation of setting up multiple state machines, invoking fetching functions, passing context values between machines, calling actions, and using selectors. </span><span class="koboSpan" id="kobo.558.5">With this</span><a id="_idIndexMarker363"/><span class="koboSpan" id="kobo.559.1"> knowledge, you should be able</span><a id="_idIndexMarker364"/><span class="koboSpan" id="kobo.560.1"> to configure any app to use XState as the state </span><span class="No-Break"><span class="koboSpan" id="kobo.561.1">management library.</span></span></p>
<h1 id="_idParaDest-94"><a id="_idTextAnchor095"/><span class="koboSpan" id="kobo.562.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.563.1">XState is the first state management library in this book to be fundamentally based on mathematical principles. </span><span class="koboSpan" id="kobo.563.2">We talked briefly about those principles, as understanding them is very useful for understanding XState. </span><span class="koboSpan" id="kobo.563.3">The most important concept is state machines. </span><span class="koboSpan" id="kobo.563.4">They are not new in the world of mathematics; they are quite novel, however, when it comes to how we think about global state in mobile apps. </span><span class="koboSpan" id="kobo.563.5">Once we had a grasp on the theory and we discovered the very useful XState visualizer, we were ready to do real work. </span><span class="koboSpan" id="kobo.563.6">We set up XState in the Funbook app, using best practices described in the XState documentation. </span><span class="koboSpan" id="kobo.563.7">We covered the topic of implementing XState as the global state solution for the use case of managing liked images. </span><span class="koboSpan" id="kobo.563.8">We looked at fetching data and changing data with XState. </span><span class="koboSpan" id="kobo.563.9">I hope you enjoyed it! </span><span class="koboSpan" id="kobo.563.10">Now, it’s time to continue our journey to the next outlier in the state management libraries </span><span class="No-Break"><span class="koboSpan" id="kobo.564.1">world: </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.565.1">Jotai</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">.</span></span></p>
<h1 id="_idParaDest-95"><a id="_idTextAnchor096"/><span class="koboSpan" id="kobo.567.1">Further reading</span></h1>
<ul>
<li><a href="https://brilliant.org/wiki/finite-state-machines/"><span class="koboSpan" id="kobo.568.1">https://brilliant.org/wiki/finite-state-machines/</span></a><span class="koboSpan" id="kobo.569.1">: Finite </span><span class="No-Break"><span class="koboSpan" id="kobo.570.1">state machines.</span></span></li>
<li><span class="koboSpan" id="kobo.571.1">https://www.w3.org/TR/scxml/: W3C </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">SCXML specification.</span></span></li>
<li><span class="koboSpan" id="kobo.573.1">https://xstate.js.org/docs/recipes/react.html#local-state: </span><span class="No-Break"><span class="koboSpan" id="kobo.574.1">XState recipes.</span></span></li>
<li><span class="koboSpan" id="kobo.575.1">https://xstate.js.org/docs/guides/context.html#assign-action: </span><span class="No-Break"><span class="koboSpan" id="kobo.576.1">Assigner action.</span></span></li>
</ul>
</div>
</body></html>