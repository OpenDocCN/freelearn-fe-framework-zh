<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Composing with Components" id="aid-QMFO1"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Composing with Components</h1></div></div></div><p>In this chapter, we will go one step further in structuring our application and working on the layout and architecture that serves as the base for our task management system. Besides introducing new components and creating larger compositions with the existing components, we'll also look at the way that we deal with data. So far, we've obtained task data synchronously from the <code class="literal">TaskListService</code> that we created in the previous chapter. However, in real-world scenarios, this would rarely be the case. In a real application, data is mostly retrieved in an asynchronous form. Usually, we acquire data through a RESTful web service, and we use <code class="literal">XMLHttpRequest</code> or the recently standardized fetch API. However, as we're trying to build a cutting-edge application, we will go one step further. In this chapter, we'll look at how we can restructure our application to deal with observable data structures using RxJS—a functional and reactive programming library that is used in Angular.</p><p>In this chapter, we will look at the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Restructuring our application to deal with observable data structures</li><li class="listitem">The basics of RxJS and its operators in order to build a reactive data model</li><li class="listitem">Using pure components in Angular</li><li class="listitem">Using <code class="literal">ChangeDetectionStrategy.OnPush</code> for pure components</li><li class="listitem">Using content projection points and <code class="literal">@ContentChildren</code> to create a <code class="literal">Tab</code> component</li><li class="listitem">Creating a simple navigation component</li><li class="listitem">Injecting parent components and establishing direct component communication</li><li class="listitem">Combining internal and external content to create a flexible component API</li></ul></div><div class="section" title="Data – Fake to real"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Data – Fake to real</h1></div></div></div><p>Starting with this chapter, we are switching to a document-based database to store our tasks and project data. As a data store, we use the PouchDB project, which is an in-browser database that is designed to run with IndexedDB and various fallback strategies. PouchDB is designed similarly to Apache CouchDB, and it can even be synchronized with it.</p><p>In order to provide a quality <a id="id135" class="indexterm"/>experience for you while you build your application, it's important that we work in real-life conditions. This means that we should use asynchronous data in our components and not rely on a simple JavaScript array of data. In order to make this as smooth as possible, the whole data layer is already set up for you, and you don't need to worry about the internals too much. Of course if you're still interested, I'm not holding you back from exploring the source code that is in the <code class="literal">data-access</code> folder.</p></div></div>
<div class="section" title="Reactive programming with observable data structures"><div class="titlepage" id="aid-RL0A2"><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Reactive programming with observable data structures</h1></div></div></div><p>So far, we <a id="id136" class="indexterm"/>used simple array data <a id="id137" class="indexterm"/>structures in the task list that we created. This is not really what we'll find in real-world scenarios. In real applications, we have to deal with asynchronous data and the changes of the data that needs to be synchronized between users. The requirements for modern applications sometimes even go further and also provide view updates on the changed data in real time. As we're building a modern task management system here, we should try to keep up with these requirements.</p><p>Both of these, handling asynchronous data and handling real-time data updates, require a major redesign of the data flow in our application. Using observable data structures, we enable our application to master the challenges of asynchronous data where we need to react to change.</p><p>Handling data in applications behaves very similarly to streams. You take input, transform it, combine it, merge it, and finally, write it into output. In systems such as this, it's also very likely that input is in a continuous form and sometimes even of infinite duration. Just take a live feed as an example; this type of data flows continuously, and the data also flows infinitely. Functional and reactive programming are paradigms to help us deal with this kind of data in a cleaner way.</p><div class="mediaobject"><img src="../Images/image00309.jpeg" alt="Reactive programming with observable data structures"/><div class="caption"><p>A simple observable subscription with value emission and a transformation</p></div></div><p style="clear:both; height: 1em;"> </p><p>Angular 2 is reactive at its very core and the whole of the change detection and bindings are built using a <a id="id138" class="indexterm"/>reactive architecture. The <a id="id139" class="indexterm"/>input and output of components, which we've learned about in the previous chapter, is nothing but a data flow that is established using a reactive event-driven approach. Angular uses RxJS, a functional and reactive programming library for JavaScript, to implement this data flow. In fact, the <code class="literal">EventEmitter</code>, which we've used to send custom events from within our components, is just a wrapper around an RxJS observable.</p><p>Reactive and functional programming is exactly what we are looking for to redesign our application in order to handle asynchronous data and data changes. As we already have RxJS at hand from the production dependency of Angular, let's use it to establish a continuous data flow from our data source into our application. The <code class="literal">DataProvider</code> service that is present in the <code class="literal">data-access</code> folder of our project provides a nice wrapper around our data store using RxJS. As we will use this service in our whole application, we can directly provide it to the bootstrap in the <code class="literal">bootstrap.js</code> file, as follows:</p><div class="informalexample"><pre class="programlisting">// Import Angular bootstrap function
import {bootstrap} from '@angular/platform-browser-dynamic';
<span class="strong"><strong>import {DataProvider} from '../data-access/data-provider';</strong></span>
// Import our main app component
import {App} from './app';

<span class="strong"><strong>bootstrap(App, [</strong></span>
<span class="strong"><strong>  DataProvider</strong></span>
<span class="strong"><strong>]);</strong></span>
</pre></div><p>As a second argument to the <code class="literal">bootstrap</code> function of Angular, we can provide application-level dependencies, which will be available for injection in all components and directives.</p><p>Let's now use the <code class="literal">DataProvider</code> service as an abstraction to obtain data from the PouchDB data store and create a new service responsible to provide project data.</p><p>We will create a new <code class="literal">ProjectService</code> class on the <code class="literal">lib/project/project-service/project-service.js</code> path, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>import {Injectable, Inject} from '@angular/core';</strong></span>
<span class="strong"><strong>import {ReplaySubject} from 'rxjs/Rx';</strong></span>
<span class="strong"><strong>import {DataProvider} from '../../../data-access/data-provider';</strong></span>

<span class="strong"><strong>@Injectable()</strong></span>
export class ProjectService {
  constructor(<span class="strong"><strong>@Inject(DataProvider) dataProvider</strong></span>) {
    …
  }
}</pre></div><p>Looking at the import section of our new module, you can see that we import the necessary dependencies from the Angular core module for dependency injection. Our service class uses the <code class="literal">@Injectable</code> decorator so that we can provide this to the injectors of components. We also inject the <code class="literal">DataProvider</code> service into the constructor of our newly-created service.</p><p>The <a id="id140" class="indexterm"/>
<code class="literal">ReplaySubject</code> class, which we import <a id="id141" class="indexterm"/>from the RxJS library, is used to make our service reactive. A subject in the RxJS world is both an observer as well as an observable. It can observe something for changes and then emit further on to all its subscribers. You can think of a subject like a proxy, where it sits in the middle between a source for changes and a group of observers. Whenever the source emits changes, the subject will notify all subscribers about these changes.</p><p>Now, the <code class="literal">ReplaySubject</code> class is a special kind of subject that allows you to replay a buffer of changes when new subscribers get added. This is especially useful if you always need to provide some initial data to subscribers. Imagine our data, which we'd like to get propagated into the UI. We want to immediately get the initial data when we subscribe to our service and then going forward, we also want to get notified about changes. Using a <code class="literal">ReplySubject</code> class, which is buffering just one change, suits this use-case perfectly.</p><p>Let's look at the following figure, which illustrates the behavior of <code class="literal">ReplaySubject</code>:</p><div class="mediaobject"><img src="../Images/image00310.jpeg" alt="Reactive programming with observable data structures"/><div class="caption"><p>A source connected to an observer using a ReplaySubject class, which buffers the most recent value and emits on subscription</p></div></div><p style="clear:both; height: 1em;"> </p><p>In the preceding figure, you can see that we're connecting a <code class="literal">ReplaySubject</code> class to a source that is emitting value changes over time. After two emissions, an observer subscribes to our <code class="literal">ReplaySubject</code> class. <code class="literal">ReplaySubject</code> will then replay all buffered changes to the new subscriber as if these events just occurred. In this example, we use a replay buffer length of one. On subsequent value emissions, these will be directly re-emitted to the subscribers of the <code class="literal">ReplaySubject</code> class.</p><p>Let's go <a id="id142" class="indexterm"/>back to our <code class="literal">ProjectService</code> <a id="id143" class="indexterm"/>class and add some logic to the <code class="literal">constructor</code> function in order to emit project data using a <code class="literal">ReplaySubject</code> class.</p><p>We will start off with some member field initialization, for which we're going to need to implement the logic:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>this.dataProvider = dataProvider;</strong></span>
this.projects = [];
// We're exposing a replay subject that will emit events whenever 
// the projects list change
<span class="strong"><strong>this.change = new ReplaySubject(1);</strong></span>
</pre></div><p>Note that we created a new <code class="literal">ReplaySubject</code> class with a buffer length of one, and assign it to the member filed with the name <code class="literal">change</code>.</p><p>We also assign the <code class="literal">DataProvider</code> service, which was previously injected in the constructor parameters, to the <code class="literal">dataProvider</code> member field.</p><p>Now, it's time to make use of the <code class="literal">DataProvider</code> service in order to subscribe for any changes <a id="id144" class="indexterm"/>within our data store. This <a id="id145" class="indexterm"/>establishes a reactive connection to our data that is stored in PouchDB:</p><div class="informalexample"><pre class="programlisting">// Setting up our functional reactive subscription to receive
// project changes from the database
<span class="strong"><strong>this.projectsSubscription = this.dataProvider.getLiveChanges()</strong></span>
  // First convert the change records to actual documents
<span class="strong"><strong>  .map((change) =&gt; change.doc)</strong></span>
  // Filter so that we only receive project documents
<span class="strong"><strong>  .filter((document) =&gt; document.type === 'project')</strong></span>
  // Finally we subscribe to the change observer and deal with 
  // project changes in the function parameter
<span class="strong"><strong>  .subscribe((changedProject) =&gt; {</strong></span>
    this.projects = this.projects.slice();
    // On every project change we need to update our projects list 
    const projectIndex = this.projects.findIndex(
      (project) =&gt; project._id === changedProject._id
    );
    if (projectIndex === -1) {
      this.projects.push(changedProject);
    } else {
      this.projects.splice(projectIndex, 1, changedProject);
    }
<span class="strong"><strong>    // Emit an event on our replay subject</strong></span>
<span class="strong"><strong>    this.change.next(this.projects);</strong></span>
  });</pre></div><p>The observable that is returned by the <code class="literal">getLiveChanges()</code> function emits data in our data store as changes. In addition to this, this will also emit any future changes that are applied to our store after we've received the initial data. You can imagine a persistent connection to the database, and whenever a document is updated in the database, our observer will receive this change as a value.</p><p>Observables provide a large amount of so-called operators that allow you to transform the data stream that originated at the observable. You might already know about some of these functional operators from the ECMAScript 5 array extra functions, such as <code class="literal">map</code> and <code class="literal">filter</code>. Using operators, you can model a whole transformation flow until you finally subscribe to the data.</p><p>As we receive changed objects from the data store, we first need to transform them into document objects. This is fairly easy because each change object contains a <code class="literal">doc</code> property that actually holds the whole data of the changed document for which we have received an update. Using the <code class="literal">map</code> function, we can transform the changed objects into project objects before we return them back into the data flow:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>.map((change) =&gt; change.doc)</strong></span>
</pre></div><p><code class="literal">DataProvider</code> will provide us with data for all the documents in the store. As we are only interested in project data at the moment, we also apply a filter that filters out all the documents that are not of the <code class="literal">project</code> type:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>.filter((document) =&gt; document.type === 'project')</strong></span>
</pre></div><p>Finally, we can <a id="id146" class="indexterm"/>subscribe to the <a id="id147" class="indexterm"/>transformed stream, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>.subscribe((changedProject) =&gt; {})</strong></span>
</pre></div><p>The <code class="literal">subscribe</code> operator is where we terminate our observation path. This is like an endpoint at which we sit and observe. Inside our <code class="literal">subscribe</code> function, we listen for project document updates and incorporate them into the <code class="literal">projects</code> member property of our <code class="literal">App</code> component. This includes not only adding the new projects that were added to the document store, but it also includes updating existing projects. Each project contains a unique identifier that can be accessed by the <code class="literal">_id</code> property. This allows us to find the right action easily.</p><p>After updating our actual view of the projects and storing the list of projects in the <code class="literal">projects</code> member field, we can emit the updated list using our <code class="literal">ReplaySubject</code> class:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>this.change.next(this.projects);</strong></span>
</pre></div><p>Our <code class="literal">ProjectService</code> class is now ready to be used, and applications components that need to obtain project data can subscribe to the exposed <code class="literal">ReplaySubject</code> class in order to react on these data changes.</p><p>Let's refactor our <code class="literal">App</code> component in <code class="literal">lib/app.js</code> and get rid of the fake <code class="literal">TaskListService</code> that we've used so far:</p><div class="informalexample"><pre class="programlisting">import {Component, ViewEncapsulation, Inject} from '@angular/core';
<span class="strong"><strong>import {ProjectService} from './project/project-service/project-service';</strong></span>
import template from './app.html!text';

@Component({
  selector: 'ngc-app',
  template,
  encapsulation: ViewEncapsulation.None,
  providers: [ProjectService]
})
export class App {
<span class="strong"><strong>  constructor(@Inject(ProjectService) projectService) {</strong></span>
<span class="strong"><strong>    this.projectService = projectService;</strong></span>
<span class="strong"><strong>    this.projects = [];</strong></span>

    // Setting up our functional reactive subscription to receive 
    // project changes
<span class="strong"><strong>    this.projectsSubscription = projectService.change</strong></span>
<span class="strong"><strong>      // We subscribe to the change observer of our service</strong></span>
<span class="strong"><strong>      .subscribe((projects) =&gt; {</strong></span>
<span class="strong"><strong>        this.projects = projects;</strong></span>
<span class="strong"><strong>      });</strong></span>
<span class="strong"><strong>  }</strong></span>

  // If this component gets destroyed, we need to remember to 
  // clean up the project subscription
<span class="strong"><strong>  ngOnDestroy() {</strong></span>
<span class="strong"><strong>    this.projectsSubscription.unsubscribe();</strong></span>
<span class="strong"><strong>  }</strong></span>
}</pre></div><p>In our <code class="literal">App</code> <a id="id148" class="indexterm"/>component, we now obtain a list <a id="id149" class="indexterm"/>of projects using the changed observable on our <code class="literal">ProjectService</code> class. Using a reactive subscription to <code class="literal">ReplaySubject</code> on the service, we make sure that our projects list that is stored in the <code class="literal">App</code> component will always be updated after any changes.</p><p>We use the <code class="literal">OnDestroy</code> lifecycle hook to unsubscribe from the <code class="literal">ProjectService</code> change observable. This is a necessary manual step if you like to do proper housekeeping in your application. Depending on the source, forgetting to unsubscribe could lead to memory leaks.</p><p>With the preceding code, we already established the base for a reactive data architecture. We observe our data store for changes and our user interface will react on them:</p><div class="mediaobject"><img src="../Images/image00311.jpeg" alt="Reactive programming with observable data structures"/><div class="caption"><p>This figure shows the reactive data flow end-to-end from our data-store into the view</p></div></div><p style="clear:both; height: 1em;"> </p></div>
<div class="section" title="Immutability" id="aid-SJGS1"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Immutability</h1></div></div></div><p>Immutable data <a id="id150" class="indexterm"/>was originally a core concept of functional programming. This topic will not cover immutable data in much depth, but it will explain the core concept so that we can talk about how to apply this concept to Angular components.</p><p>Immutable data structures force you to create a full copy of the data that you want to modify before you can do this. You'll never operate on the data directly but on a copy of this same data. This has many benefits over standard mutable data, the most obvious probably being the application state. When you always operate on new copies of data, there's no chance that you're messing up the data that you actually didn't want to modify.</p><p>Let's take this simple example, which illustrates the issues object references can cause:</p><div class="informalexample"><pre class="programlisting">const list = [1, 2, 3];
console.log(list === <span class="strong"><strong>list.reverse()</strong></span>); // true</pre></div><p>Although this seems odd at first, it actually makes sense that the output of this example is true. <code class="literal">Array.reverse()</code> is a mutable operation, and it will modify the innards of the array. The actual reference will stay the same because JavaScript will not create a copy of the array to reverse it. Although technically this makes a lot of sense, this is not what we expected in the first place when we look at this code.</p><p>We can easily change this example to an immutable procedure by creating a copy of the array before we reverse it:</p><div class="informalexample"><pre class="programlisting">const list = [1, 2, 3];
console.log(list === <span class="strong"><strong>list.slice().reverse()</strong></span>); // false</pre></div><p>The issue with references is that they can cause a lot of unexpected side-effects. Also, if we come back to our encapsulation topic from <a class="link" title="Chapter 1. Component-Based User Interfaces" href="part0014.xhtml#aid-DB7S1">Chapter 1</a>, <span class="emphasis"><em>Component-Based User Interfaces</em></span>, they are completely against the concept of encapsulation. Although we might think that it would be safe to pass complex data types into a capsule, it's actually not. As we're dealing with references here, the data can still be modified from the outside, and our capsule will not have the complete ownership. Consider the following example:</p><div class="informalexample"><pre class="programlisting">class Sum {
  constructor(data) {
<span class="strong"><strong>    this.data = data;</strong></span>
<span class="strong"><strong>    this.data.sum = data.a + data.b;</strong></span>
  }
  getSum() {
    return this.data.sum;
  }
}

<span class="strong"><strong>const data = {a: 5, b: 8};</strong></span>
var sum = new Sum(data);
console.log(sum.getSum()); // 13
console.log(data.sum); // 13</pre></div><p>Even if we only wanted to store the data internally in our <code class="literal">Sum</code> class, we would have created an unwanted <a id="id151" class="indexterm"/>side-effect of referencing and modifying the data object that's outside the instance. Multiple <code class="literal">sum</code> instances would also share the same data from outside and cause more side-effects. As a developer, you've learned to treat object references right, but they still can cause a lot of problems.</p><p>We don't have these problems with immutable data, which can be illustrated easily with primitive data types in JavaScript. Primitive data types don't use references, and they are immutable by design:</p><div class="informalexample"><pre class="programlisting">let originalString = 'Hello there!';
let modifiedString = originalString.replace(/e/g, 3);
console.log(originalString); // Hello there!
console.log(modifiedString); // H3llo th3r3!</pre></div><p>There's no way we can modify an instance of a string. Every modification that we perform on a string will generate a new string, and this prevents the unwanted side-effects.</p><p>So, why do we still have object references within programming languages, even though they cause so many issues? Why aren't we performing all these operations on immutable data, and why are we only dealing with values rather than object references?</p><p>Of course, imperative data structures also come with their benefits, and it always depends on the context if immutable data brings value.</p><p>One of the main reasons that is often used against immutable data is bad performance. Of course, it costs some performance if we need to create tons of copies of our data every time we want to modify it. However, there are great optimization techniques, which fully eliminate the performance issues that we would usually expect from immutable data structures. Using a tree data structure that allows internal structural sharing, copies of the data will be shared internally. This allows very efficient memory management, which in some situations, even outperforms mutable data structures. I can highly recommend the paper by Chris Okasaki about <span class="emphasis"><em>Purely Functional Data Structures</em></span> if you would like to read more about performance in immutable data structures.</p><div class="note" title="Note"><h3 class="title"><a id="tip09"/>Tip</h3><p>JavaScript does not support immutable data structures out of the box. However, you can use libraries, such as <code class="literal">Immutable.js</code> by Facebook, which provide you with an easy API to deal with immutable data. <code class="literal">Immutable.js</code> even implements structural sharing and makes it a perfect power tool if you decide to build on an immutable architecture in your application.</p></div><p>As with every paradigm, there are pros and cons, and depending on the context, one concept may fit better than another one. In our application, we won't use immutable data structures that are provided by third-party libraries, but we'll borrow some of the benefits that you get from immutable data by the following immutable idioms:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>It's much easier to reason about immutable data</strong></span>: You can always tell why your data is in a given state because you know the exact transformation path. This may sound irrelevant, but in practice, this is a huge benefit not only for humans to write code, but also for compilers and interpreters to optimize it.</li><li class="listitem"><span class="strong"><strong>Using immutable objects makes change detection much faster</strong></span>: If we rely on immutable patterns to <a id="id152" class="indexterm"/>treat our data, we can rely on object reference checks to detect change. We no longer need to perform complex data analysis and comparison for dirty checking, and can fully rely on checking references. We have the guarantee that object properties don't change without the object identity changing as well. This makes change detection as easy as <code class="literal">oldObject === newObject</code>.</li></ul></div></div>
<div class="section" title="Pure components"><div class="titlepage" id="aid-TI1E2"><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Pure components</h1></div></div></div><p>The idea of a "pure" component is that its whole state is represented by its inputs, where all inputs are <a id="id153" class="indexterm"/>immutable. This is effectively a stateless component, but additionally, all the inputs are immutable.</p><p>I like to call such components "pure" because their behavior can be compared to the concept of pure functions in functional programming. A pure function is a function which has the following properties:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">It does not rely on any state outside of the function scope</li><li class="listitem">It always behave the same if input parameters don't change</li><li class="listitem">It never changes any state outside the function scope (side-effect)</li></ul></div><p>With pure components, we have a simple guarantee. A pure component will never change without its input parameters being changed. We can ignore a component and its subcomponents in change detection until one of the component inputs changes. Sticking to this idea about components gives us several advantages.</p><p>It's very easy to reason about pure components and their behavior can be predicted very easily. Let's look at a simple illustration of a component tree where we use pure components:</p><div class="mediaobject"><img src="../Images/image00312.jpeg" alt="Pure components"/><div class="caption"><p>A component tree with immutable components</p></div></div><p style="clear:both; height: 1em;"> </p><p>If we have the guarantee that each component in our tree has a stable state until an immutable input property changes, we can safely ignore change detection that would usually be triggered by <a id="id154" class="indexterm"/>Angular. The only way that such a component could change is if an input of the component changes. Let's say that there's an event that causes the <span class="strong"><strong>A</strong></span> root component to change the input binding value of the <span class="strong"><strong>B</strong></span> component, which will change the value of a binding on the <span class="strong"><strong>E</strong></span> component. This event, and the resulting procedure, would mark a certain path in our component tree to be checked by change detection:</p><div class="mediaobject"><img src="../Images/image00313.jpeg" alt="Pure components"/><div class="caption"><p>Figure that shows a marked path for change detection (in black) with "pure" components.</p></div></div><p style="clear:both; height: 1em;"> </p><p>Although the state of the root component changed, which also changed input properties of the subcomponents on two levels, we only need to be concerned about a given path when thinking about possible changes in the system. Pure components give us the promise that they will not change if their inputs will not. Immutability plays a big role here. Imagine that you're binding a mutable object to the component, <span class="strong"><strong>B</strong></span>, and the <span class="strong"><strong>A</strong></span> component would change a property of this object. As we use object references and mutable objects, the property would also be changed for the <span class="strong"><strong>B</strong></span> component. However, there's no way for the <span class="strong"><strong>B</strong></span> <a id="id155" class="indexterm"/>component to notice this change, as we can't track who knows about our object within the component tree. Basically, we'd need to go back to regular dirty checking of the whole tree again.</p><p>By knowing that all our components are pure and that their inputs are immutable, we can tell Angular to disable change detection until an input property value changes. This makes our component tree very efficient, and Angular can optimize change detection effectively. When thinking about large component trees, this can make the difference between a stunningly-fast application and a slow one.</p><p>The change detection of Angular is very flexible, and each component gets its own change detector. We can configure the change detection of a component by specifying the <code class="literal">changeDetection</code> property of the component decorator.</p><p>Using <code class="literal">ChangeDetectionStrategy</code>, we can choose from a list of strategies that apply for the change detection of our component. In order to tell Angular that our component should only be checked if an immutable input was changed, we can use the <code class="literal">OnPush</code> strategy, which is designed exactly for this purpose.</p><p>Let's take a look at the different configuration possibilities of component change-detection strategies and <a id="id156" class="indexterm"/>some possible use cases:</p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><thead><tr><th valign="bottom">
<p>Change-detection strategy</p>
</th><th valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td valign="top">
<p><code class="literal">CheckAlways</code></p>
</td><td valign="top">
<p>This strategy tells Angular to check this component during every change-detection cycle, and this is obviously the most expensive strategy. This is the only strategy that guarantees that a component gets checked for changes on every possible application state change. If we're not working with stateless or immutable components, or we are using an inconsistent data flow within our application, this is still the most reliable change-detection method. Change detection will be executed on every browser event that runs within the zone of this component.</p>
</td></tr><tr><td valign="top">
<p><code class="literal">Detached</code></p>
</td><td valign="top">
<p>This strategy tells Angular to completely detach a component subtree from change detection. This strategy can be used to create a manual change-detection mechanism.</p>
</td></tr><tr><td valign="top">
<p><code class="literal">OnPush</code></p>
</td><td valign="top">
<p>This strategy tells Angular that a given component subtree will only change under one of the following conditions:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">One of the input properties changes where changes need to be immutable</li><li class="listitem">An event binding within the component subtree is receiving an event</li></ul></div>
</td></tr><tr><td valign="top">
<p><code class="literal">Default</code></p>
</td><td valign="top">
<p>This strategy simply evaluates to <code class="literal">CheckAlways</code></p>
</td></tr></tbody></table></div><div class="section" title="Purifying our task list"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec23"/>Purifying our task list</h2></div></div></div><p>In the previous <a id="id157" class="indexterm"/>topic, we changed our main application component to use RxJS Observables in order to get notified about the data changes in our data store.</p><p>We also looked into the basics of using immutable data structures and that Angular can be configured to assume component changes only occur when component input changes ("pure" components). As we'd like to get the performance benefits that result from this optimization, let's refactor our task list component to make use of this.</p><p>In the previous chapter, we built our <code class="literal">TaskList</code> component and directly placed the task data in the component. We then refactored our code so that we could place the task data into a service and use injection to obtain data.</p><p>Now, we're rebuilding our <code class="literal">TaskList</code> component to make it "pure" and only dependent on its input properties. As we'll make sure that the data flowing into the component is always immutable, we can use the <code class="literal">OnPush</code> change-detection strategy on our refactored component. This will certainly give our task list a performance boost.</p><p>Equally important as performance, are the structural benefits that we get from using pure components. A "pure" component does not change any data directly because it's not allowed to modify application state. Instead, it uses output properties to emit events on changed data. This allows our parent component to react to these events and perform the necessary steps to handle the changes. As a result of this, the parent component will possibly change the input properties of the pure component. This will trigger change detection and effectively change the state of the pure component.</p><p>What might sound a bit overcomplicated at first is actually an immense benefit to the structure of our application. This allows us to reason about our component with high confidence. The unidirectional data flow as well as stateless nature makes it easy to understand, examine, and test our components. Also, the loose nature of inputs and outputs makes our component extremely portable. We can decide on a parent component, what data we'd like to run into our component, and how we'd like to handle changes.</p><p>Let's take a look at our <code class="literal">TaskList</code> component and how we change it to conform to our concept of "pure" components:</p><div class="informalexample"><pre class="programlisting">import {Component, ViewEncapsulation, Input, Output, EventEmitter, <span class="strong"><strong>ChangeDetectionStrategy</strong></span>} from '@angular/core';
import template from './task-list.html!text';
import {Task} from './task/task';
import {EnterTask} from './enter-task/enter-task';
import {Toggle} from '../ui/toggle/toggle';

@Component({
  selector: 'ngc-task-list',
  host: {
    class: 'task-list'
  },
  template,
  encapsulation: ViewEncapsulation.None,
  directives: [Task, EnterTask, Toggle],
<span class="strong"><strong>  changeDetection: ChangeDetectionStrategy.OnPush</strong></span>
})
export class TaskList {
<span class="strong"><strong>  @Input() tasks;</strong></span>
<span class="strong"><strong>  // Event emitter for emitting an event once the task list has </strong></span>
<span class="strong"><strong>  // been changed</strong></span>
<span class="strong"><strong>  @Output() tasksUpdated = new EventEmitter();</strong></span>

  constructor() {
    this.taskFilterList = ['all', 'open', 'done'];
    this.selectedTaskFilter = 'all';
  }

  ngOnChanges(changes) {
    if (changes.tasks) {
      this.taskFilterChange(this.selectedTaskFilter);
    }
  }

  taskFilterChange(filter) {
    this.selectedTaskFilter = filter;
    this.filteredTasks = this.tasks ? this.tasks.filter((task) =&gt; {
        if (filter === 'all') {
          return true;
        } else if (filter === 'open') {
          return !task.done;
        } else {
          return task.done;
        }
      }) : [];
  }

  // Function to add a new task
  addTask(title) {
<span class="strong"><strong>    const tasks = this.tasks.slice();</strong></span>
<span class="strong"><strong>    tasks.push({ created: +new Date(), title, done: null });</strong></span>
<span class="strong"><strong>    this.tasksUpdated.next(tasks);</strong></span>
  }
}</pre></div><p>All the operations in our task list component are now immutable. We never directly modify our task's data that was passed in as input, but rather we create new task data arrays to perform mutable operations.</p><p>From what we've learned from <a id="id158" class="indexterm"/>the previous section, this effectively makes our component a "pure" component. This component itself is only relying on its input and makes our component very easy to reason about.</p><p>You've probably noticed that we've also configured the change-detection strategy of our component. As we have a "pure" component now, we can configure our change-detection strategy accordingly to save some performance:</p><div class="informalexample"><pre class="programlisting">@Component({
  selector: 'ngc-task-list',
  …
<span class="strong"><strong>  changeDetection: ChangeDetectionStrategy.OnPush</strong></span>
})</pre></div><p>As we're rendering a <code class="literal">Task</code> component for each data record in our task list, we should also check what we can change there in order to round this out.</p><p>Let's look at the changes in our <code class="literal">Task</code> component:</p><div class="informalexample"><pre class="programlisting">import {Component, Input, Output, EventEmitter, ViewEncapsulation, HostBinding, <span class="strong"><strong>ChangeDetectionStrategy</strong></span>} from '@angular/core';
import template from './task.html!text';
import {Checkbox} from '../../ui/checkbox/checkbox';

@Component({
  selector: 'ngc-task',
  host: {
    class: 'task'
  },
  template,
  encapsulation: ViewEncapsulation.None,
  directives: [Checkbox],
<span class="strong"><strong>  changeDetection: ChangeDetectionStrategy.OnPush</strong></span>
})
export class Task {
<span class="strong"><strong>  @Input() task;</strong></span>
<span class="strong"><strong>  // We are using an output to notify our parent about updates</strong></span>
<span class="strong"><strong>  @Output() taskUpdated = new EventEmitter();</strong></span>

  @HostBinding('class.task--done')
  get done() {
    return this.task &amp;&amp; this.task.done;
  }

<span class="strong"><strong>  // We use this function to update the checked state of our task</strong></span>
<span class="strong"><strong>  markDone(checked) {</strong></span>
<span class="strong"><strong>    this.taskUpdated.next({</strong></span>
<span class="strong"><strong>      title: this.task.title,</strong></span>
<span class="strong"><strong>      done: checked ? +new Date() : null</strong></span>
<span class="strong"><strong>    });</strong></span>
<span class="strong"><strong>  }</strong></span>
}</pre></div><p>We also use the <code class="literal">OnPush</code> strategy for our <code class="literal">Task</code> component, and we can do this because we also have a pure component here. This component only depends on its inputs. Both inputs expect native values (a <code class="literal">String</code> <a id="id159" class="indexterm"/>for title and a <code class="literal">Boolean</code> for done), which actually makes them immutable by nature. Changes on the task will be communicated using the <code class="literal">taskUpdated</code> output property.</p><p>Now, this is a good time to think about where to place our task list in the application. As we're writing a task management system that gives our users the ability to manage tasks within projects, we need to have a container that will encapsulate the concerns of projects. We create a new <code class="literal">Project</code> component, on the path <code class="literal">lib/project/project.js</code>, which will display project details and renders the <code class="literal">TaskList</code> component as a subcomponent:</p><div class="informalexample"><pre class="programlisting">import {Component, ViewEncapsulation, Input, Output, EventEmitter, <span class="strong"><strong>ChangeDetectionStrategy</strong></span>} from '@angular/core';
import template from './project.html!text';
<span class="strong"><strong>import {TaskList} from '../task-list/task-list';</strong></span>

@Component({
  selector: 'ngc-project',
  host: {
    class: 'project'
  },
  template,
  encapsulation: ViewEncapsulation.None,
<span class="strong"><strong>  directives: [TaskList],</strong></span>
<span class="strong"><strong>  changeDetection: ChangeDetectionStrategy.OnPush</strong></span>
})
export class Project {
<span class="strong"><strong>  @Input() title;</strong></span>
<span class="strong"><strong>  @Input() description;</strong></span>
<span class="strong"><strong>  @Input() tasks;</strong></span>
<span class="strong"><strong>  @Output() projectUpdated = new EventEmitter();</strong></span>

<span class="strong"><strong>  // This function should be called if the task list of the </strong></span>
<span class="strong"><strong>  // project was updated</strong></span>
<span class="strong"><strong>  updateTasks(tasks) {</strong></span>
<span class="strong"><strong>    this.projectUpdated.next({</strong></span>
<span class="strong"><strong>      title: this.title,</strong></span>
<span class="strong"><strong>      description: this.description,</strong></span>
<span class="strong"><strong>      tasks</strong></span>
<span class="strong"><strong>    });</strong></span>
  } 
}</pre></div><p>Again, we make the state of this component dependent only on its immutable inputs, and we use the <code class="literal">OnPush</code> strategy in order to get the positive performance implications of using a pure component. It's also important to note that the <code class="literal">updateTasks</code> function acts as some sort of a delegate from our <code class="literal">TaskList</code> component. When we update a task inside the <code class="literal">TaskList</code> component, we catch the event in the project template and call the <code class="literal">updateTasks</code> function with the new updated task list. From here, we're just emitting the updated project data with the new task list further up in the component tree.</p><p>Let's also take a look at the <a id="id160" class="indexterm"/>template of our <code class="literal">Project</code> component quickly to understand the wiring behind this component:</p><div class="informalexample"><pre class="programlisting">&lt;div class="project__l-header"&gt;
  &lt;h2 class="project__title"&gt;{{title}}&lt;/h2&gt;
  &lt;p&gt;{{description}}&lt;/p&gt;
&lt;/div&gt;
&lt;ngc-task-list <span class="strong"><strong>[tasks]="tasks"</strong></span>
<span class="strong"><strong>               (tasksUpdated)="updateTasks($event)"</strong></span>&gt;
&lt;/ngc-task-list&gt;</pre></div><p>The binding logic in the template tells us how the whole data flow with our purified components work. While the <code class="literal">Project</code> component itself receives the list of tasks as input, it directly forwards this data to the <code class="literal">tasks</code> input of the <code class="literal">TaskList</code> component. If the <code class="literal">TaskList</code> component fires a <code class="literal">tasksUpdated</code> event, we're calling the <code class="literal">updateTasks</code> method on the <code class="literal">Project</code> component, which in fact just emits a <code class="literal">projectUpdated</code> event again.</p></div><div class="section" title="Recap"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec24"/>Recap</h2></div></div></div><p>The refactoring of our task list is now completed, and we applied our knowledge about immutable components and observable data structures to gain some performance wins in this structure. There won't be unnecessary dirty checking on our <code class="literal">Task</code> component any more because we switched to the <code class="literal">OnPush</code> change-detection strategy.</p><p>We have also reduced the complexity of the <code class="literal">TaskList</code> and <code class="literal">Task</code> components a lot, and it's now far easier to reason about these components and their state.</p><p>A further benefit of this refactoring is the great encapsulation level that we achieved using immutable inputs. Our <code class="literal">TaskList</code> component is not relying on any task container as a project. We can also pass it <a id="id161" class="indexterm"/>a list of tasks across all the projects, and it can still work as expected.</p></div></div>
<div class="section" title="Composition using content projection" id="aid-UGI01"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Composition using content projection</h1></div></div></div><p>In this <a id="id162" class="indexterm"/>section, we will create a tabbed interface for <a id="id163" class="indexterm"/>our <code class="literal">Project</code> component that will help us further organize the structure of our application user interface. In order to create a <code class="literal">Tabs</code> component, we'll look at content projection and content child injection using observable query lists.</p><p>Input and output properties are great to establish encapsulation, and this is a main property of proper composition. However, sometimes the requirements are not to only pass data but to also pass content from the outside of a component into the component. In Shadow DOM, this is done using so-called slots. In Angular components, we can create content projection points using the <code class="literal">&lt;ng-content&gt;</code> element.</p><p>Let's look at a simple content projection example that helps us understand what this is good for:</p><div class="informalexample"><pre class="programlisting">@Component({
  selector: 'child',
  template: `
    &lt;article&gt;
      &lt;header&gt;
        &lt;h1&gt;<code class="literal">&lt;ng-content select="[data-header]"&gt;&lt;/ng-content&gt;</code>&lt;/h1&gt;
      &lt;/header&gt;
      <span class="strong"><strong>&lt;ng-content&gt;&lt;/ng-content&gt;</strong></span>
    &lt;/article&gt;
  `
})
export class Child {}

@Component({
  selector: 'app',
  template: `
<span class="strong"><strong>    &lt;child&gt;</strong></span>
<span class="strong"><strong>      &lt;header data-header&gt;Content projection is great&lt;/header&gt;</strong></span>
<span class="strong"><strong>      &lt;p&gt;Insert content in a controlled manner&lt;/p&gt;</strong></span>
<span class="strong"><strong>    &lt;/child&gt;</strong></span>
  `,
  directives: [Child]
})
export class App {}</pre></div><p>Looking at the <code class="literal">App</code> component in this example, we can see that we've put elements inside the actual <code class="literal">&lt;child&gt;</code> element. Usually, this content would be ignored and removed by Angular before it renders the <code class="literal">Child</code> component with its template.</p><p>However, when using content projection, the elements that are placed inside our component HTML element can be sucked into the <code class="literal">Child</code> component. This is what content projection is all about. Content projection is actually very similar to the concept of transclusion from Angular 1.</p><p>All that we need to do in order to enable content projection within a <code class="literal">Child</code> component is to place a <code class="literal">&lt;ng-content&gt;</code> element within its template. In this way, we specify at what locations in our component template we want to insert the content that is sucked in from the parent component.</p><p>Additionally, we <a id="id164" class="indexterm"/>can use the select attribute on the <code class="literal">&lt;ng-content&gt;</code> element to set a CSS-like selector. This selector will be used to only suck in <a id="id165" class="indexterm"/>specific elements, which match this selector. In this way, you can have multiple insertion points that cover different content requirements.</p><p>Elements from the component element can only be inserted once, and the content projection works by going through all the <code class="literal">&lt;ng-content&gt;</code> elements in sequential order by project matching elements. If you have multiple competing content projection points in your template that are interested in the same elements, the first one will actually win.</p></div>
<div class="section" title="Creating a tabbed interface component"><div class="titlepage" id="aid-VF2I2"><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Creating a tabbed interface component</h1></div></div></div><p>Let's introduce <a id="id166" class="indexterm"/>a new UI component in our <code class="literal">ui</code> folder in the project that will provide us with a tabbed interface that we can use for composition. We use what we learned about content projection in order to make this component reusable.</p><p>We'll actually create two components, one for <code class="literal">Tabs</code>, which itself holds individual <code class="literal">Tab</code> components.</p><p>First, let's create the component class within a new <code class="literal">tabs/tab</code> folder in a file called <code class="literal">tab.js</code>:</p><div class="informalexample"><pre class="programlisting">import {Component, Input, ViewEncapsulation, HostBinding} from '@angular/core';
import template from './tab.html!text';

@Component({
  selector: 'ngc-tab',
  host: {
    class: 'tabs__tab'
  },
  template,
  encapsulation: ViewEncapsulation.None
})
export class Tab {
<span class="strong"><strong>  @Input() name;</strong></span>
<span class="strong"><strong>  @HostBinding('class.tabs__tab--active') active = false;</strong></span>
}</pre></div><p>The only state that we store in our <code class="literal">Tab</code> component is whether the tab is active or not. The name that is displayed on the tab will be available through an input property.</p><p>We use a class property binding to make a tab visible, based on the active flag we set a class; without this, our tabs are hidden.</p><p>Let's take a look at the <code class="literal">tab.html</code> template file of this component:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&lt;ng-content&gt;&lt;/ng-content&gt;</strong></span>
</pre></div><p>This is it <a id="id167" class="indexterm"/>already? Actually, yes it is! The <code class="literal">Tab</code> component is only responsible for the storage of its name and active state, as well as the insertion of the host element content in the content projection point. There's no additional templating that is needed.</p><p>Now, we'll move one level up and create the <code class="literal">Tabs</code> component that will be responsible for grouping all the <code class="literal">Tab</code> components. As we won't include <code class="literal">Tab</code> components directly when we want to create a tabbed interface but use the <code class="literal">Tabs</code> component instead, this needs to forward content that we put into the <code class="literal">Tabs</code> host element. Let's look at how we can achieve this.</p><p>In the <code class="literal">tabs</code> folder, we will create a <code class="literal">tabs.js</code> file that contains our <code class="literal">Tabs</code> component code, as follows:</p><div class="informalexample"><pre class="programlisting">import {Component, ViewEncapsulation, ContentChildren} from '@angular/core';
import template from './tabs.html!text';
// We rely on the Tab component
<span class="strong"><strong>import {Tab} from './tab/tab';</strong></span>

@Component({
  selector: 'ngc-tabs',
  host: {
    class: 'tabs'
  },
  template,
  encapsulation: ViewEncapsulation.None,
<span class="strong"><strong>  directives: [Tab]</strong></span>
})
export class Tabs {
<span class="strong"><strong>  // This queries the content inside &lt;ng-content&gt; and stores a </strong></span>
<span class="strong"><strong>  // query list that will be updated if the content changes</strong></span>
<span class="strong"><strong>  @ContentChildren(Tab) tabs;</strong></span>

  // The ngAfterContentInit lifecycle hook will be called once the 
  // content inside &lt;ng-content&gt; was initialized
<span class="strong"><strong>  ngAfterContentInit() {</strong></span>
<span class="strong"><strong>    this.activateTab(this.tabs.first);</strong></span>
<span class="strong"><strong>  }</strong></span>

  activateTab(tab) {
    // To activate a tab we first convert the live list to an 
    // array and deactivate all tabs before we set the new 
    // tab active
<span class="strong"><strong>    this.tabs.toArray().forEach((t) =&gt; t.active = false);</strong></span>
<span class="strong"><strong>    tab.active = true;</strong></span>
  }
} </pre></div><p>Let's observe what's happening here. We used a new <code class="literal">@ContentChildren</code> annotation, in order to query our inserted content for directives that match the type that we pass to the decorator. The <a id="id168" class="indexterm"/>
<code class="literal">tabs</code> property will contain an object of the <code class="literal">QueryList</code> type, which is an observable list type that will be updated if the content projection changes. You need to remember that content projection is a dynamic process, as the content in the host element can actually change, for example, using the <code class="literal">NgFor</code> or <code class="literal">NgIf</code> directives.</p><p>We use the <code class="literal">AfterContentInit</code> lifecycle hook, which we've already briefly discussed in the <span class="emphasis"><em>Custom UI elements</em></span> section of <a class="link" title="Chapter 2. Ready, Set, Go!" href="part0020.xhtml#aid-J2B81">Chapter 2</a>, <span class="emphasis"><em>Ready, Set, Go!</em></span> This lifecycle hook is called after Angular has completed content projection on the component. Only then do we have the guarantee that our <code class="literal">QueryList</code> object will be initialized, and we can start working with child directives that were projected as content.</p><p>The <code class="literal">activateTab</code> function will set the <code class="literal">Tab</code> component's active flag, deactivating any previous active tab. As the observable <code class="literal">QueryList</code> object is not a native array, we first need to convert it using <code class="literal">toArray()</code> before we start working with it.</p><p>Let's now look at the template of the <code class="literal">Tabs</code> component that we created in a file called <code class="literal">tabs.html</code> in the <code class="literal">tabs</code> directory:</p><div class="informalexample"><pre class="programlisting">&lt;ul class="tabs__tab-list"&gt;
  &lt;li <span class="strong"><strong>*ngFor="let tab of tabs"</strong></span>&gt;
    &lt;button class="tabs__tab-button"
<span class="strong"><strong>            [class.tabs__tab-button--active]="tab.active"</strong></span>
<span class="strong"><strong>            (click)="activateTab(tab)"&gt;</strong></span>{{tab.name}}&lt;/button&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="tabs__l-container"&gt;
<span class="strong"><strong>  &lt;ng-content select="ngc-tab"&gt;&lt;/ng-content&gt;</strong></span>
&lt;/div&gt;</pre></div><p>The structure of our <code class="literal">Tabs</code> component is as follows.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">First we render all the <code class="literal">tab</code> buttons in an unordered list.</li><li class="listitem">After the unordered list, we have a <code class="literal">tabs</code> container that will contain all our <code class="literal">Tab</code> components that are inserted using content projection and the <code class="literal">&lt;ng-content&gt;</code> element. Note that the selector that we use is actually the selector we use for our <code class="literal">Tab</code> component.</li><li class="listitem">Tabs that are not active will not be visible because we control this using CSS on our <code class="literal">Tab</code> component class attribute binding (refer to the <code class="literal">Tab</code> component code).</li></ul></div><p>This is all that we <a id="id169" class="indexterm"/>need to create a flexible and well-encapsulated tabbed interface component. Now we can go ahead and use this component in our <code class="literal">Project</code> component to provide a segregation of our project detail information.</p><p>We will create three tabs for now, where the first one will embed our task list. We will address the content of the other two tabs in a later chapter.</p><p>Let's modify our <code class="literal">Project</code> component template in the <code class="literal">project.html</code> file as a first step.</p><p>Instead of including our <code class="literal">TaskList</code> component directly, we now use the <code class="literal">Tabs</code> and <code class="literal">Tab</code> components to nest the task list into our tabbed interface:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&lt;ngc-tabs&gt;</strong></span>
<span class="strong"><strong>  &lt;ngc-tab name="Tasks"&gt;</strong></span>
    &lt;ngc-task-list [tasks]="tasks"
                   (tasksUpdated)="updateTasks($event)"&gt;
    &lt;/ngc-task-list&gt;
<span class="strong"><strong>  &lt;/ngc-tab&gt;</strong></span>
<span class="strong"><strong>  &lt;ngc-tab name="Comments"&gt;&lt;/ngc-tab&gt;</strong></span>
<span class="strong"><strong>  &lt;ngc-tab name="Activities"&gt;&lt;/ngc-tab&gt;</strong></span>
<span class="strong"><strong>&lt;/ngc-tabs&gt;</strong></span>
</pre></div><p>You should have noticed by now that we are actually nesting two components within this template code using content projection, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">First, the <code class="literal">Tabs</code> component uses content projection to select all the <code class="literal">&lt;ngc-tab&gt;</code> elements. As these elements happen to be components too (our <code class="literal">Tab</code> component will attach to elements with this name), they will be recognized as such within the <code class="literal">Tabs</code> component once they are inserted.</li><li class="listitem">In the <code class="literal">&lt;ngc-tab&gt;</code> element, we then nest our <code class="literal">TaskList</code> component. If we go back to our <code class="literal">Task</code> component template, which will be attached to elements with the name <code class="literal">ngc-tab</code>, we will have a generic projection point that inserts any content that is present in the host element. Our task list will effectively be passed through the <code class="literal">Tabs</code> component into the <code class="literal">Tab</code> component.</li></ul></div><div class="section" title="Recap"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec25"/>Recap</h2></div></div></div><p>In this topic, we created a very handy tabbed interface component that we can use to segregate our user interface <a id="id170" class="indexterm"/>and provide a focused context for our users. We used content projection points using the <code class="literal">&lt;ng-content&gt;</code> elements. We also learned how to access inserted components using the <code class="literal">@ContentChildren</code> annotation and observable lists using the <code class="literal">QueryList</code> type.</p></div></div>
<div class="section" title="Mixing projected with generated content"><div class="titlepage" id="aid-10DJ42"><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Mixing projected with generated content</h1></div></div></div><p>Our task <a id="id171" class="indexterm"/>management application supports the listing of multiple projects where a user can manage tasks. We need to provide a navigation that enables a user to browse through the existing projects. As projects come from our data store, the navigation will need to be generated dynamically. However, we also would like to have the possibility of specifying some navigation items within our navigation, as static content with pure templating.</p><p>In this section, we will create a simple navigation component, which will use content projection, so that we can add static navigation items. At the same time, navigation items can be generated from data and mixed with the static content-based navigation items.</p><p>Let's first take a look at an illustration of the architectural design and composition that we're going to use to implement our navigation:</p><div class="mediaobject"><img src="../Images/image00314.jpeg" alt="Mixing projected with generated content"/><div class="caption"><p>An illustration of the navigation component tree and interactions</p></div></div><p style="clear:both; height: 1em;"> </p><p>We'll use an intermediate component between the <code class="literal">Navigation</code> and <code class="literal">NavigationItem</code> components. The <code class="literal">NavigationSection</code> component is responsible for the division of multiple items into a section. The navigation sections also have a title that will be displayed on top of the item list.</p><p>The illustration <a id="id172" class="indexterm"/>shows two <code class="literal">NavigationSection</code> components, where the left one uses pure content projection to create items, as we have learned in the previous section. The right <code class="literal">NavigationSection</code> component generates items using an input data structure, which is a list of navigation item models.</p><p>As we have intermediate components between the <code class="literal">Navigation</code> and <code class="literal">NavigationItems</code> components (we can only have one selected navigation), we also establish a direct communication path between them. We will achieve this using ancestor component injection.</p><div class="note" title="Note"><h3 class="title"><a id="note06"/>Note</h3><p>The architectural approach for this navigation is just one of many possible approaches. We choose this approach in order to show you how we can easily mix content projection and generated content. In this example, we don't use the Angular router to provide navigation state and route mapping. This will be part of a later chapter.</p></div><p>Let's start bottom up with the <code class="literal">NavigationItem</code> component and create a new <code class="literal">navigation-item.js</code> file in a newly-created <code class="literal">navigation/navigation-section/navigation-item</code> path:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>// We rely on the navigation component to know if we are active</strong></span>
<span class="strong"><strong>import {Navigation} from '../../navigation';</strong></span>

@Component({
  selector: 'ngc-navigation-item'
})
export class NavigationItem {
  @Input() title;
  @Input() link;

  constructor<span class="strong"><strong>(@Inject(Navigation) navigation</strong></span>) {
    this.navigation = navigation;
  }

  // Here, we are delegating to the navigation component to see if
  // we are active or not
  isActive() {
<span class="strong"><strong>    return this.navigation.isItemActive(this);</strong></span>
  }

  // If this link is activated we need to tell the navigation component
  onActivate() {
<span class="strong"><strong>    this.navigation.activateLink(this.link);</strong></span>
  }
}</pre></div><p>From the <code class="literal">NavigationItem</code> component code, we can see that we're directly communicating with the <code class="literal">Navigation</code> ancestor component. We can simply inject the <code class="literal">NavigationComponent</code>, as this is a child of the component. As the <code class="literal">Navigation</code> items will never exist without a <code class="literal">Navigation</code> component, we should be fine with this direct dependency.</p><p>Let's move <a id="id173" class="indexterm"/>on to the <code class="literal">NavigationSection</code> component that is the intermediate component between the <code class="literal">Navigation</code> component and the items and is responsible for the grouping of items together.</p><p>We will create a file called <code class="literal">navigation-section.js</code> in the <code class="literal">navigation/navigation-section</code> path:</p><div class="informalexample"><pre class="programlisting">@Component({
  selector: 'ngc-navigation-section',
  directives: [<span class="strong"><strong>NavigationItem</strong></span>]
})
export class NavigationSection {
  @Input() title;
<span class="strong"><strong>  @Input() items;</strong></span>
}</pre></div><p>Hold on! That's all that this needs? Didn't we say that we want our <code class="literal">NavigationSection</code> component to also be responsible for not only providing a way to insert content, but also accepting data in order to generate items? Well, this is true. However, this is actually pure templating logic, and it can be done solely within the template file of the component. All that we need is an optional input with item data that we will use to generate the <code class="literal">NavigationItem</code> components.</p><p>Let's create the view template for this component in a file named <code class="literal">navigation-section.html</code>:</p><div class="informalexample"><pre class="programlisting">&lt;h2 class="navigation-section__title"&gt;{{title}}&lt;/h2&gt;
&lt;ul class="navigation-section__list"&gt;
<span class="strong"><strong>  &lt;ng-content select="ngc-navigation-item"&gt;&lt;/ng-content&gt;</strong></span>
<span class="strong"><strong>  &lt;ngc-navigation-item *ngFor="let item of items"</strong></span>
<span class="strong"><strong>                       [title]="item.title"</strong></span>
<span class="strong"><strong>                       [link]="item.link"&gt;&lt;/ngc-navigation-item&gt;</strong></span>
&lt;/ul&gt;</pre></div><p>Well, this wasn't rocket science, was it? However, this shows the great flexibility that we have in Angular component templates:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Firstly, we create a content projection point that selects all the elements from the host element that match the name <code class="literal">ngc-navigation-item</code>. This means that the <code class="literal">NavigationItem</code> components can be placed outside the component in a very static fashion to create, for example, static links. As the model properties of navigation items are directly exposed as bindable attributes on the <code class="literal">NavigationItem</code> element, we can also place them statically into a pure HTML template with regular DOM attributes.</li><li class="listitem">Secondly, we can use the <code class="literal">NgFor</code> directive to generate the <code class="literal">NavigationItem</code> components inside the component. Here, we just iterate over the list of navigation <a id="id174" class="indexterm"/>item models that acts as an optional input to our component. We use bindings in the items model so that we can even propagate change into our navigation item components.</li></ul></div><p>As a final step, we create the <code class="literal">Navigation</code> component itself that uses content projection points so that we can manage the <code class="literal">NavigationSection</code> component from outside. We create a file called <code class="literal">navigation.js</code> to write the code of the <code class="literal">Navigation</code> component:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>import {NavigationSection} from './navigation-section/navigation-section';</strong></span>

@Component({
  selector: 'ngc-navigation',
  directives: [<span class="strong"><strong>NavigationSection</strong></span>]
})
export class Navigation {
<span class="strong"><strong>  @Input() activeLink;</strong></span>

  // Checks if a given navigation item is currently active by its 
  // link. This function will be called by navigation item child 
  // components.
<span class="strong"><strong>  isItemActive(item) {</strong></span>
<span class="strong"><strong>    return item.link === this.activeLink;</strong></span>
<span class="strong"><strong>  }</strong></span>

  // If a link wants to be activated within the navigation, this 
  // function needs to be called. This way child navigation item 
  // components can activate themselves.
<span class="strong"><strong>  activateLink(link) {</strong></span>
<span class="strong"><strong>    this.activeLink = link;</strong></span>
<span class="strong"><strong>    this.activeLinkChange.next(this.activeLink);</strong></span>
<span class="strong"><strong>  }</strong></span>
}</pre></div><p>In the <code class="literal">Navigation</code> component, we store the state of which navigation item is activated. This is also provided as input to the component so that we can set the activated link with an input binding from outside. The <code class="literal">isItemActive</code> and <code class="literal">activateLink</code> functions are there to monitor and change the state of the active item within the navigation. These functions are directly used within the <code class="literal">NavigationItem</code> components, which inject the navigation using ancestor component injection.</p><p>Now, the only <a id="id175" class="indexterm"/>bit that is missing is to include our navigation in the main application. For this, we will edit the <code class="literal">app.html</code> template of the component:</p><div class="informalexample"><pre class="programlisting">&lt;div class="app"&gt;
  &lt;div class="app__l-side"&gt;
<span class="strong"><strong>    &lt;ngc-navigation </strong></span>
<span class="strong"><strong>            [activeLink]="getSelectedProjectLink()"</strong></span>
<span class="strong"><strong>            (activeLinkChange)="selectProjectByLink($event)"&gt;</strong></span>
<span class="strong"><strong>      &lt;ngc-navigation-section </strong></span>
<span class="strong"><strong>                   title="Projects"</strong></span>
<span class="strong"><strong>                   [items]="getProjectNavigationItems()"&gt;</strong></span>
<span class="strong"><strong>      &lt;/ngc-navigation-section&gt;</strong></span>
<span class="strong"><strong>    &lt;/ngc-na</strong></span>
<span class="strong"><strong>vigation&gt;</strong></span>
  &lt;/div&gt;
  &lt;div class="app__l-main"&gt;
    …
  &lt;/div&gt;
&lt;/div&gt;</pre></div><p>Here, we only use the generative approach to write a <code class="literal">NavigationSection</code> component where we actually pass a list of navigation item models into the navigation component. This list is generated by the <code class="literal">getProjectNavigationItems</code> function on our main application component using the available projects from our observable data structure:</p><div class="mediaobject"><img src="../Images/image00315.jpeg" alt="Mixing projected with generated content"/><div class="caption"><p>A screenshot of the newly-created project navigation</p></div></div><p style="clear:both; height: 1em;"> </p></div>
<div class="section" title="Summary" id="aid-11C3M1"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec29"/>Summary</h1></div></div></div><p>In this chapter, we learned about how we can profit from concepts, such as reactive programming, observable data structures, and immutable objects, in order to make our application perform better, and most importantly, simple and easy to reason about.</p><p>We touched on the different change-detection strategies and learned how to use the <code class="literal">OnPush</code> strategy to gain better performance in combination with immutable data.</p><p>We built a tabbed user interface component that we can reuse wherever we need it, and we learned about the concept of content projection. We also created a simple navigation component tree that uses a mix of content projection and generation. The navigation items also directly communicate with their ancestor <code class="literal">Navigation</code> component, in order to manage their state using ancestor component injection.</p><p>As we switched to a reactive approach to manage data within our application, I want you to perform a little experiment. If you've downloaded the final chapter's code, go ahead and open two browser windows that point to the task management application. You will be amazed that we already have a working real-time synchronization in place that allows us to work in both browser windows and have both of them updated at the same time. This has all been made possible because of the reactive and functional way that we work with data in our components.</p></div></body></html>