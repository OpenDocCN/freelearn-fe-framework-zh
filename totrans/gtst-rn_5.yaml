- en: Chapter 5. Displaying and Saving Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how to style a React Native application, let's figure out how
    to actually make it do something. In this chapter, we'll start saving notes to
    the device, populate a list with the notes we've saved, and select notes from
    the list to view and edit.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a `ListView` to display rows of data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using props to pass data and callbacks into components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `AsyncStorage` to store data on both iOS and Android devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our strategy in this chapter is to first build the basic functionality using
    dummy data so we can learn some fundamental skills before we learn about saving
    and loading the data with the `AsyncStorage` API. By the end of the chapter, you
    will have a fully functional note-taking application!
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `HomeScreen` of our application is going to display a list of the notes
    that we have saved. To do this, we will introduce the `ListView` component. Let''s
    start by creating a new file in our `Components` directory called `NoteList` and
    add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `ListView` component is fairly simple to use. You must provide two pieces
    of information, the `dataSource` that will provide the data for all of the rows
    and the `renderRow` function, which is simply a function that takes each row's
    data (a single note) and returns a React component. In the preceding example,
    this function returns a `<Text/>` component that displays the title of the note.
  prefs: []
  type: TYPE_NORMAL
- en: We instantiate a `ListView`. The `DataSource` is in the constructor because
    we only want to create it once. The `DataSource` constructor takes a `params`
    object to configure the `DataSource`; however, the only required parameter is
    a `rowHasChanged` function. This function is used by the `DataSource` when it
    receives new data so that it can efficiently determine which rows need to be re-rendered.
    If `r1` and `r2` point to the same object, the row hasn't changed.
  prefs: []
  type: TYPE_NORMAL
- en: You'll also notice that we don't pass the `DataSource` reference directly to
    our `ListView`. Instead we use `cloneWithRows()`, passing it to the `rowData`
    we want to use. We're hardcoding the row data for now, but by the end of this
    chapter you will know how to update the `ListView` with new data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s add the `NoteList` component to the `HomeScreen` and learn how
    to respond to touch events on each row. Open the `HomeScreen` component and add
    the following line to import your new `NoteList` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, let''s drop the `NoteList` component into `HomeScreen''s` `render` method
    just inside the `View` component, before the `<Text/>` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we try out our `NoteList`, let''s modify our styles to make sure that
    the list content isn''t obscured by the `NavigationBar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when you reload the application you should see the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lists](img/B05162_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We still have the **You haven't created any notes!** Message at the bottom of
    the screen, but we'll learn how to take care of that later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a list of items, we''d like to be able to respond when the
    user touches one of the items. To do that, we''ll wrap the `<Text/>` component
    in our `renderRow` function with the `TouchableHighlight` component. First, let''s
    add `TouchableHighlight` to our list of imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then update the `renderRow` function in our `ListView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can reload the application and touch each row to see that the `rowData`
    has been logged to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our goal is to be able to touch a row, navigate to the `NoteScreen`, and populate
    the title and body with the data from the row. Let''s add an `_onPress` event
    handler to our `NoteList` component, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And we will call this function from our `TouchableHighlight`, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Before we try this out, take a look at the `_onPress` handler and notice that
    we are referring to `this.props.navigator`. This is the navigator that we've been
    using to go back and forth between the `HomeScreen` and the `NoteScreen`, but
    what's this props business?
  prefs: []
  type: TYPE_NORMAL
- en: Understanding props
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you take a look at the constructor function of the `NoteList`, you will
    notice that it takes an argument called **props**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Props is the mechanism we use to pass data to React components. In our case,
    we want to pass a navigator reference from the `HomeScreen` component to the `NoteList`,
    so let''s make a quick change to our `NoteList` declaration, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When you touch a row in the `NoteList`, you push the note data associated with
    that row to the navigator, which then triggers `renderScene` that passes the note
    to the `NoteScreen`. So how do we use this note inside the `NoteScreen`? We learned
    earlier that props are passed into the component''s constructor, but how do we
    actually get our `TextInput` components to display the note''s title and body?
    Let''s see what happens if we bind the value property of each of our inputs to
    the passed-in note, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when we reload the application and touch the first note in the list, we
    will see the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding props](img/B05162_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'But what happens when you try to edit the title or body? Nothing happens! Before
    we diagnose what is wrong, let''s tap the **Back** button and touch the second
    note in the `NoteList`. You will see it displayed, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding props](img/B05162_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Ok, so our `NoteScreen` does update, but only when we pass it new props from
    outside, not when we try to edit the `TextInputs`. Props can only be passed from
    the outside of a component. As tempting as it may seem, it's a bad idea to try
    to modify `this.props.note` from inside the `NoteScreen` when the value of each
    `TextInput` changes. What we need instead is some way to manage the changes made
    to the internal state of our `NoteScreen` when the user makes changes to the `TextInputs`.
    For that, each React component has something called **state**.
  prefs: []
  type: TYPE_NORMAL
- en: Using state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'React components have a built-in variable called `state` that you can use to
    keep track of the component''s `state`. In the preceding example, we know that
    we are passing in a note that we want to display, so the initial state of the
    component is represented by that note. Let''s do something totally crazy and modify
    the `NoteScreen` constructor, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: So, `this.state` is an object with title and body properties that are initially
    set to the title and body of the note we passed. Why the call to *super (props)?*
    The superclass of our `NoteScreen` is `React.Component`, which takes props as
    an argument and sets `this.props`. If we omit `super(props)` in `NoteScreen`,
    then `this.props` will be undefined.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have already guessed that we''re going to update the `TextInputs` to
    bind to `this.state.title` and `this.state.body` respectively, but we''re also
    going to listen for `onChangeText` events for each input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `arrow` function that we're using to handle the `onChangeText`
    event is calling `this.setState(...)` instead of directly setting `this.state.title`.
    This is an important thing to remember. Anytime you modify state you must use
    `this.setState()` so that React knows that your component needs to be re-rendered.
    For performance reasons, calling `setState()` doesn't immediately update `this.state`,
    so don't let that trip you up!
  prefs: []
  type: TYPE_NORMAL
- en: 'Reload the application, touch **Note 1** in the list and then change the title
    to **My note**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using state](img/B05162_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `TextInput` attribute now reflects the value of `this.state.title` on every
    call to `render()`, which happens after every call to `this.setState({title})`.
    So far so good, but what do you think we will see when we navigate back to the
    `HomeScreen`? Tap the **Back** button and take a look —the title of the first
    note is still **Note 1** instead of **My note**. Now, when you click on **Note
    1** to go back to the `NoteScreen` you'll see that your changes have disappeared.
    Let's fix this!
  prefs: []
  type: TYPE_NORMAL
- en: We've just identified the need to update our `ListView` when a note is changed.
    We know that the internal state of the `NoteScreen` changes when we type into
    the `TextInput` components, but how do we communicate these changes to the rest
    of the application?
  prefs: []
  type: TYPE_NORMAL
- en: Passing callbacks in props
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A common pattern in React is to pass a callback to a component via props. In
    our case, we want to pass a callback to our `NoteScreen` so that it can let us
    know when the note is changed. Let''s return to the `ReactNotes` component in
    our `index.ios.js` or `index.android.js` file and update our `renderScene` function,
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are defining a prop called `onChangeNote` and setting its value to
    an arrow function that will be called when we invoke `onChangeNote` inside our
    `NoteScreen` component. So, somewhere inside our `NoteScreen` code we''re going
    to add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s revisit the `NoteScreen` and a function to handle the updating of notes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In our title `TextInput`, update the `onChangeText` function, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'And in the body `TextInput`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s reload our application, touch **Note 1**, and start making changes.
    If you look at the console you should see each change being logged:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Passing callbacks in props](img/B05162_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Getting notified of the changes to a note only gets us halfway to our goal
    to update the `ListView`. Recall that our `NoteList` component''s `dataSource`
    is currently just a hardcoded array of notes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to be able to pass in the list of notes to the `NoteList` component
    instead of hardcoding them. Now that you''re familiar with props, you know that
    we can pass the list in from the `HomeScreen`, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then modify the `NoteList` component to use `this.props.notes` in the `dataSource`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take our refactoring one step further. We don''t really want the `HomeScreen`
    to be responsible for managing the state of our list of notes, that''s a job for
    our top-level component, `ReactNotes`. We can repeat the same trick we just used
    and replace the hardcoded array of notes in `HomeScreen` with `this.props.notes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `ReactNotes` component, we can pass the notes to the `HomeScreen` using
    props:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You may sense that we are getting tantalizingly close to our goal of being able
    to modify notes and see the changes in the `ListView`. The source of our notes
    is now in close proximity to the event handler that knows when the user has modified
    a note on the `NoteScreen`. What we're really talking about here is managing the
    state of our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ReactNotes` component is the top-level component that is responsible for
    managing the application state, which consists entirely of notes. So, let''s make
    it official and move the array of notes into the component''s initial state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Storing notes in an array makes it a little tricky to update a particular note;
    let''s do a quick refactor using an object instead of an array, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, `notes` is the object in which the keys correspond to the `ids` of the
    notes. Since the `NoteList` component is still expecting an array, let''s use
    `underscore.js` to do the conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `NoteList` should continue to function the way it did earlier; we are just
    keeping track of our notes a little differently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the changes that we need to make for the `onChangeNote` handler to
    actually update a note via state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Let's walk through the `updateNote` function to understand what's happening.
    First, we create a copy of `this.state.notes` using `Object.assign()`. Any time
    you work with nested data in your state object, we recommend making a copy like
    this to avoid unexpected behavior. React compares the two objects to determine
    if a component's state has changed and needs to be re-rendered; hence, using a
    copy like this ensures that the old state and the new state point to different
    objects. We then put our modified note into `newNotes` using `note.id` as the
    key. Lastly, we call `setState()` to replace the entire notes object with the
    new copy.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve got a few more refactorings to do before we can try out our handiwork.
    Now that we know how to pass callbacks to our components via props, we can eliminate
    the need to pass in a navigator to the `HomeScreen` and `NoteList` components,
    and instead pass in a callback so that the `NoteList` can tell us when the user
    has selected a note:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that we have to update our `HomeScreen` to pass the `onSelectNote`
    callback into the `NoteList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we''ll have to update `NoteList`. We no longer need the `_onPress` handler
    or a reference to the navigator, we can just invoke the provided callback with
    `rowData`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now be able to reload the application, touch a note, change the
    title, go back, and see the updated title appear in the `NoteList`, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Passing callbacks in props](img/B05162_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When you select a note and navigate to the `NoteScreen`, the title that appears
    in the `NavigationBar` is still **Create Note**. Let''s modify it, so that even
    if we select an existing note from the list, we use the note''s title instead
    of **Create Note**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'When you reload the application, the `NoteScreen` should reflect the title
    of the selected note:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Passing callbacks in props](img/B05162_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating new notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, we''ve been updating existing notes. How do we add new ones? Well,
    that''s actually very easy. We just need to update the **Create Note** button
    in the `NavigationBar`, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we're now passing an empty note with a generated id. (A better
    approach to generate ids will be to use a `uuid` generator, but we'll leave that
    as an exercise for the reader!)
  prefs: []
  type: TYPE_NORMAL
- en: That's it! We finally have a full, end-to-end note taking application! However,
    our notes only exist in memory. We need to be able to save notes to the device,
    so let's meet our new friend, `AsyncStorage`.
  prefs: []
  type: TYPE_NORMAL
- en: Using AsyncStorage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: React Native provides an abstraction over the native local storage mechanism
    so that you don't have to worry about the underlying differences between how iOS
    and Android save data to the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s really simple to use, so let''s update our `ReactNotes` component to
    use `AsyncStorage`. First, let''s add `AsyncStorage` to our list of imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s add a `saveNotes()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You may be wondering what the `async` and `await` keywords are doing in your
    JavaScript! These are new keywords in ES7 that simplify working with promises.
    The `AsyncStorage` methods are, well, asynchronous and they return promises. Without
    going into too much detail, the `async` keyword in front of a function allows
    us to use the await keyword within the function body. The await keyword will resolve
    the promise, and if there's a problem, it will throw an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify our `updateNote` function to call our new `saveNotes` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also need a function to `loadNotes` from `AsyncStorage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to load our saved notes from the device in our constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Reload your application, and save the changes made to a note or create a new
    note. Then reload the application again. Your changes have been saved! We just
    have one more job to do, deleting notes!
  prefs: []
  type: TYPE_NORMAL
- en: Deleting notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last thing we need to do before we have a fully functional note-taking
    application is to add a **Delete** button to our `NoteScreen`. To accomplish that,
    we''ll update our `NavigationBarRouteMapper` to add a `RightButton` when the route
    name is `createNote`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The first thing to notice is that I've added a condition to check if the note
    has already been saved (we will need to tweak our `updateNote` function to set
    this). This is to make sure that the **Delete** button doesn't show up for new
    notes. The `Create Note` `onPress` handler has been updated to set `isSaved =
    false` in the empty note that we pass to the `NoteScreen`, when that button is
    pressed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the `onPress` handler for the **Delete** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve seen `navigator.pop()` before, but we''re also invoking a new callback
    called `onDeleteNote`. We need to pass that callback in through props in our `ReactNotes`
    `render` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to modify our `updateNote` function to mark the notes that have
    been saved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Just below that, we''ll add the `deleteNote` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it! Reload the application and create a new note. Notice that there
    is no **Delete** button in the `NavigationBar`. Press the **Back** button to view
    the note in the list, then tap that item in the list to view it. You should be
    able to see the **Delete** button in the top right corner, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deleting notes](img/B05162_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Press the **Delete** button and you will be returned to the `HomeScreen` where
    the deleted note will disappear from the list!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have created a complete note-taking application. You have
    learned how to use the `ListView` to display data, pass data into components using
    props, keep track of a component's state, and save data to the device using AsyncStorage.
    Moreover, you have done did all of this without writing any `platform-specific`
    code!
  prefs: []
  type: TYPE_NORMAL
