<html><head></head><body>
		<div id="_idContainer060">
			<h1 id="_idParaDest-132"><em class="italic"><a id="_idTextAnchor131"/>Chapter 13</em>: Building an E-Commerce Website with Next.js and GraphCMS</h1>
			<p>During our journey exploring Next.js, we've learned a lot. We've explored different rendering methodologies, styling techniques, integrations, and even deployment strategies.</p>
			<p>Now it's time to start creating something worth going to production, taking advantage of everything we have learned so far.</p>
			<p>In this chapter, we will see how to adopt Next.js to build e-commerce storefronts from scratch.</p>
			<p>We will look at the following in detail:</p>
			<ul>
				<li>What GraphCMS is and how to adopt it</li>
				<li>How to integrate payment methods such as Stripe</li>
				<li>How to deploy an e-commerce website</li>
			</ul>
			<p>By the end of this chapter, you will be able to describe a Next.js e-commerce architecture, find the right SEO and performance tradeoff, and deploy your Next.js instance on the right cloud platform. </p>
			<h1 id="_idParaDest-133"><a id="_idTextAnchor132"/>Technical requirements</h1>
			<p>To run the code examples in this chapter, you need to have both Node.js and npm installed on your local machine.</p>
			<p>If you prefer, you can use an online IDE, such as <a href="https://repl.it">https://repl.it</a> or <a href="https://codesandbox.io">https://codesandbox.io</a>; they both support Next.js and you don't need to install any dependency on your computer. As with the other chapters, you can find the code base for this chapter on GitHub: https://github.com/PacktPublishing/Real-World-Next.js.</p>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor133"/>Creating e-commerce websites for the modern web</h1>
			<p>Since the <a id="_idIndexMarker668"/>internet started to spread at the end of the 90s, it<a id="_idIndexMarker669"/> opened a world of possibilities for online<a id="_idIndexMarker670"/> businesses. As a result, many companies began to develop <strong class="bold">software-as-a-service</strong> (<strong class="bold">SaaS</strong>) products to help people build their own online shopping platforms.</p>
			<p>Today, there are several significant players in this area: Shopify, Big Cartel, WordPress (using WooCommerce or other plugins), and Magento, just to name a few.</p>
			<p>There are also companies, such as PayPal and Stripe, that make it incredibly easy to integrate payment methods on any platform, paving the ground for custom e-commerce creation, where our imagination is the only limit.</p>
			<p>When talking about "limits" in e-commerce creation, I'm referring to the fact that certain SaaS platforms can make it hard for us developers to customize the UI, payment flow, and so on.</p>
			<p>Shopify, as an example, solved this problem by creating a new server-side-rendered React.js framework <a id="_idIndexMarker671"/>called <strong class="bold">Hydrogen</strong>, which ships with pre-built components and Hooks to communicate with its GraphQL APIs, allowing developers to create unique user experiences on the frontend with ease.</p>
			<p>Next.js, released Next.js Commerce, a highly customizable starter kit for effortlessly creating e-commerce experiences, being able to integrate with many different platforms.</p>
			<p>Next.js Commerce doesn't add anything new to the Next.js framework. Instead, it acts as a template for starting a new e-commerce website, knowing that we can customize every single part of it with extreme ease. We will not touch upon the customization capabilities in practice; however, we will still deploy an incredibly performant and optimized online shop.</p>
			<p>We can use Next.js commerce with any headless backend service. It doesn't matter whether we're using Shopify, BigCommerce, Saleor, or any other service, as long as they expose some APIs to communicate with the backend.</p>
			<p>Starting from the next section, we will be using one of the best headless CMS platforms out there, which can manage any aspect of a modern e-commerce platform, from product inventory to <a id="_idIndexMarker672"/>content translations, always<a id="_idIndexMarker673"/> keeping an API-first approach: GraphCMS.</p>
			<h1 id="_idParaDest-135"><a id="_idTextAnchor134"/>Setting up GraphCMS</h1>
			<p>There are many<a id="_idIndexMarker674"/> different competitors in the e-commerce world; all of them offer a great set of functionalities for building modern and performant solutions, but there's always a kind of tradeoff when it comes to analyzing back-office features, frontend customization capabilities, APIs, integrations, and so on.</p>
			<p>In this chapter, we will be using GraphCMS for a simple reason: it's easy to integrate, offers a generous free plan, and requires no setup for complex release pipelines, databases, or whatever. We just need to open an account and take advantage of the massive set of free features to build a fully working e-commerce website.</p>
			<p>It also provides an e-commerce starter template with pre-built (yet fully customizable) contents, which translates to a pre-built GraphQL schema ready to consume on the frontend to create product pages, catalogs, and so on.</p>
			<p>We can start by creating a new GraphCMS <a id="_idIndexMarker675"/>account by going to <a href="https://graphcms.com">https://graphcms.com</a>. Once we log into our dashboard, we will see that GraphCMS prompts us to create a new project, and we will choose among several pre-made templates. We can select the <strong class="bold">Commerce Shop</strong> template, which will generate some mock content for us.</p>
			<div>
				<div id="_idContainer053" class="IMG---Figure">
					<img src="image/Figure_13.1_B16985.jpg" alt="Figure 13.1 – The GraphCMS dashboard&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.1 – The GraphCMS dashboard</p>
			<p>Once we have created <a id="_idIndexMarker676"/>the project by selecting <strong class="bold">Commerce Shop</strong> as a template, we can browse the <strong class="bold">Content</strong> section in our GraphCMS dashboard and see what mock data we have.</p>
			<p>We will see many useful and prepopulated sections, such as products, product variants, categories, and reviews; we will use this data in our Next.js commerce application shortly.</p>
			<p>Now that we have our content, we need to create a Next.js application to display it on the frontend by using the powerful GraphCMS GraphQL APIs:</p>
			<p class="source-code">npx create-next-app with-graphcms</p>
			<p>Once we have created the app, we can start thinking about how we want the UI to be. In this case, we want to keep things easy, and we'll use Chakra UI for styling our components. Let's install it and set it up inside our Next.js application:</p>
			<p class="source-code">yarn add @chakra-ui/react @emotion/react@^11 @emotion/styled@^11 framer-motion@^4</p>
			<p>Let's open<a id="_idIndexMarker677"/> our <strong class="source-inline">_app.js</strong> file and add the Chakra provider:</p>
			<p class="source-code"><strong class="bold">import { ChakraProvider } from '@chakra-ui/react';</strong></p>
			<p class="source-code">function MyApp({ Component, pageProps }) {</p>
			<p class="source-code">  return (</p>
			<p class="source-code"><strong class="bold">    &lt;ChakraProvider&gt;</strong></p>
			<p class="source-code">      &lt;Component {...pageProps} /&gt;</p>
			<p class="source-code"><strong class="bold">    &lt;/ChakraProvider&gt;</strong></p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p class="source-code">export default MyApp;</p>
			<p>Now that we've set up an elementary Next.js application, we can start thinking about linking GraphCMS to it.</p>
			<p>As said before, GraphCMS exposes excellent GraphQL APIs, so we need to connect to it by using that protocol. We've already discussed how to connect to any GraphQL endpoint using Apollo in <a href="B16985_04_Final_SB_epub.xhtml#_idTextAnchor053"><em class="italic">Chapter 4</em></a>, <em class="italic">Organizing the Code base and Fetching Data in Next.js</em>. For the sake of simplicity, we'll now use a more straightforward library for connecting to GraphCMS: <strong class="source-inline">graphql-request</strong>.</p>
			<p>We can install it by using Yarn:</p>
			<p class="source-code">yarn add graphql-request graphql</p>
			<p>Now let's create a basic GraphQL interface to connect GraphCMS to our storefront. First, let's create a new file called <strong class="source-inline">lib/graphql/index.js</strong> and add the following content:</p>
			<p class="source-code">import { GraphQLClient } from 'graphql-request';</p>
			<p class="source-code">const { GRAPHCMS_ENDPOINT, GRAPHCMS_API_KEY = null } =       </p>
			<p class="source-code">  process.env;</p>
			<p class="source-code">const authorization = `Bearer ${GRAPHCMS_API_KEY}`;</p>
			<p class="source-code">export default new GraphQLClient(GRAPHCMS_ENDPOINT, {</p>
			<p class="source-code">  headers: {</p>
			<p class="source-code">    ...(GRAPHCMS_API_KEY &amp;&amp; { authorization} }),</p>
			<p class="source-code">  },</p>
			<p class="source-code">});</p>
			<p>What's happening <a id="_idIndexMarker678"/>here?</p>
			<p>As you can see, we will need to create a couple of environment variables: <strong class="source-inline">GRAPHCMS_ENDPOINT</strong> and <strong class="source-inline">GRAPHCMS_API_KEY</strong>. The first one contains the GraphCMS endpoint URL, and the second is an optional API key for accessing protected data.</p>
			<p>In fact, GraphCMS allows you to expose its data publicly, which can be handy in certain situations. In other cases, though, we want our data to be accessible to authorized clients only, so we need to use an API key.</p>
			<p>We can retrieve those environment variables values by going to <strong class="bold">Settings</strong> then <strong class="bold">API Access</strong> on our GraphCMS dashboard.</p>
			<div>
				<div id="_idContainer054" class="IMG---Figure">
					<img src="image/Figure_13.2_B16985.jpg" alt="Figure 13.2 – API access management in GraphCMS&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.2 – API access management in GraphCMS</p>
			<p>We can now <a id="_idIndexMarker679"/>take the <strong class="bold">Content API</strong> value and put it as a <strong class="source-inline">GRAPHCMS_ENDPOINT</strong> value inside the <strong class="source-inline">.env.local</strong> file in our codebase. Of course, if this file does not exist, we can create it from scratch:</p>
			<p class="source-code">GRAPHCMS_ENDPOINT=https://api-eu-central-1.graphcms.com/v2/ckvt6q8oe1h5d01xpfkub364l/master</p>
			<p>We now need to set the API key, which allows us to perform mutations on the CMS (for example, save an order once it's paid). We can use the default <strong class="bold">Mutation</strong> token created by GraphCMS for us under <strong class="bold">Permanent Auth Tokens</strong> in the <strong class="bold">API Access</strong> section. Once we retrieve it, we can simply add it as the <strong class="source-inline">GRAPHCMS_API_KEY</strong> value in our <strong class="source-inline">.env.local</strong> file.</p>
			<p>We're now ready to go! We have a connection with the CMS, so we can read, write, and even update or delete data via GraphQL APIs. In the next section, we will use them to create the<a id="_idIndexMarker680"/> storefront and the product detail page.</p>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor135"/>Creating the storefront, cart, and product detail pages</h1>
			<p>GraphCMS <a id="_idIndexMarker681"/>offers<a id="_idIndexMarker682"/> a well-made, rock-solid, open<a id="_idIndexMarker683"/> source template for creating e-commerce websites, which can be found at this URL: <a href="https://github.com/GraphCMS/graphcms-commerce-starter">https://github.com/GraphCMS/graphcms-commerce-starter</a>.</p>
			<p>We're not adopting this starter template because we want to fully understand the reasoning behind certain technical decisions and how to approach the problems that can appear during the development phase.</p>
			<p>That said, we can focus on developing the first essential components for our storefront.</p>
			<p>We will wrap our entire application in a Chakra UI box so that every page will have a similar layout. We can do that by opening the <strong class="source-inline">_app.js</strong> file and adding the following components:</p>
			<p class="source-code"><strong class="bold">import { Box, Flex, ChakraProvider } from '@chakra-ui/react';</strong></p>
			<p class="source-code">function MyApp({ Component, pageProps }) {</p>
			<p class="source-code">  return (</p>
			<p class="source-code">&lt;ChakraProvider&gt;</p>
			<p class="source-code"><strong class="bold">  &lt;Flex w="full" minH="100vh" bgColor="gray.100"&gt;</strong></p>
			<p class="source-code"><strong class="bold">    &lt;Box maxW="70vw" m="auto"&gt;</strong></p>
			<p class="source-code">      &lt;Component {...pageProps} /&gt;</p>
			<p class="source-code"><strong class="bold">    &lt;/Box&gt;</strong></p>
			<p class="source-code"><strong class="bold">  &lt;/Flex&gt;</strong></p>
			<p class="source-code">&lt;/ChakraProvider&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p class="source-code">export default MyApp;</p>
			<p>Now, we can <a id="_idIndexMarker684"/>start<a id="_idIndexMarker685"/> thinking about how we want to <a id="_idIndexMarker686"/>show our products on the home page. However, before doing that, we may want to check the data provided via GraphQL APIs by the CMS, and we can easily do that by going into the <strong class="bold">API Playground</strong> section of our dashboard. Here, we can write our GraphQL queries, taking advantage of the <strong class="bold">Explorer</strong> functionality to help us create highly customizable GraphQL queries with ease.</p>
			<div>
				<div id="_idContainer055" class="IMG---Figure">
					<img src="image/Figure_13.3_B16985.jpg" alt="Figure 13.3 – GraphCMS API Playground&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.3 – GraphCMS API Playground</p>
			<p>In the <a id="_idIndexMarker687"/>query<a id="_idIndexMarker688"/> shown in the preceding screenshot, we're<a id="_idIndexMarker689"/> retrieving all the publicly available products. We can use this exact query in our Next.js app, so let's create a new <strong class="source-inline">/lib/graphql/queries/getAllProducts.js</strong> file and add the following content:</p>
			<p class="source-code">import { gql } from 'graphql-request';</p>
			<p class="source-code">export default gql`</p>
			<p class="source-code">  query GetAllProducs {</p>
			<p class="source-code">    products {</p>
			<p class="source-code">      id</p>
			<p class="source-code">      name</p>
			<p class="source-code">      slug</p>
			<p class="source-code">      price</p>
			<p class="source-code">      images {</p>
			<p class="source-code">        id</p>
			<p class="source-code">        url</p>
			<p class="source-code">      }</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">`;</p>
			<p>We're now <a id="_idIndexMarker690"/>ready <a id="_idIndexMarker691"/>to fetch all the products to populate our <a id="_idIndexMarker692"/>home page. To generate a static page at build time, let's head to our <strong class="source-inline">pages/index.js</strong> page and retrieve the products inside the <strong class="source-inline">getStaticProps</strong> function:</p>
			<p class="source-code">import graphql from '../lib/graphql';</p>
			<p class="source-code">import getAllProducts from '../lib/graphql/queries/getAllProducts';</p>
			<p class="source-code">export const getStaticProps = async () =&gt; {</p>
			<p class="source-code">  const { products } = await graphql.request(getAllProducts)</p>
			<p class="source-code">  return {</p>
			<p class="source-code">    props: {</p>
			<p class="source-code">      products,</p>
			<p class="source-code">    },</p>
			<p class="source-code">  };</p>
			<p class="source-code">};</p>
			<p>At this point, we might be wondering how to handle cases where we create a new product and want to display it immediately on the home page. Here, we have two options:</p>
			<ul>
				<li>Use <strong class="source-inline">getServerSideProps</strong> instead of <strong class="source-inline">getStaticProps</strong>, which will dynamically generate the page on each request, but we already know its downsides, as seen in <a href="B16985_10_Final_SB_epub.xhtml#_idTextAnchor102"><em class="italic">Chapter 10</em></a>, <em class="italic">Working with SEO and Managing Performance</em>.</li>
				<li>Use incremental static regeneration so that after a given period, the page gets regenerated, including any new API changes.</li>
			</ul>
			<p>We'll<a id="_idIndexMarker693"/> proceed <a id="_idIndexMarker694"/>with the second option by adding the following <a id="_idIndexMarker695"/>property to our returning <strong class="source-inline">getStaticProps</strong> object:</p>
			<p class="source-code">import graphql from '../lib/graphql';</p>
			<p class="source-code">import getAllProducts from '../lib/graphql/queries/getAllProducts';</p>
			<p class="source-code">export const getStaticProps = async () =&gt; {</p>
			<p class="source-code">  const { products } = await graphql.request(getAllProducts)</p>
			<p class="source-code">  return {</p>
			<p class="source-code"><strong class="bold">    revalidate: 60, // 60 seconds</strong></p>
			<p class="source-code">    props: {</p>
			<p class="source-code">      products,</p>
			<p class="source-code">    },</p>
			<p class="source-code">  };</p>
			<p class="source-code">};</p>
			<p>We're now ready to display all the products on our home page. We'll do that by creating a new component<a id="_idIndexMarker696"/> under <strong class="source-inline">/components/ProductCard/index.js</strong>, exposing<a id="_idIndexMarker697"/> the following <a id="_idIndexMarker698"/>function:</p>
			<p class="source-code">import Link from 'next/link';</p>
			<p class="source-code">import { Box, Text, Image, Divider } from '@chakra-ui/react';</p>
			<p class="source-code">export default function ProductCard(props) {</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;Link href={`/product/${<strong class="bold">props.slug</strong>}`} passHref&gt;</p>
			<p class="source-code">      &lt;Box</p>
			<p class="source-code">        as="a"</p>
			<p class="source-code">        border="1px"</p>
			<p class="source-code">        borderColor="gray.200"</p>
			<p class="source-code">        px="10"</p>
			<p class="source-code">        py="5"</p>
			<p class="source-code">        rounded="lg"</p>
			<p class="source-code">        boxShadow="lg"</p>
			<p class="source-code">        bgColor="white"</p>
			<p class="source-code">        transition="ease 0.2s"</p>
			<p class="source-code">        _hover={{</p>
			<p class="source-code">        boxShadow: 'xl',</p>
			<p class="source-code">        transform: 'scale(1.02)',</p>
			<p class="source-code">        }}&gt;</p>
			<p class="source-code">    &lt;Image src={<strong class="bold">props.images[0]?.url</strong>} alt={<strong class="bold">props.name</strong>} /&gt;</p>
			<p class="source-code">    &lt;Divider my="3" /&gt;</p>
			<p class="source-code">    &lt;Box&gt;</p>
			<p class="source-code">      &lt;Text fontWeight="bold" textColor="purple"        </p>
			<p class="source-code">        fontSize="lg"&gt;{<strong class="bold">props.name</strong>}</p>
			<p class="source-code">      &lt;/Text&gt;</p>
			<p class="source-code">      &lt;Text textColor="gray.700"&gt;€{<strong class="bold">props.price</strong>/ 100}&lt;/Text&gt;</p>
			<p class="source-code">    &lt;/Box&gt;</p>
			<p class="source-code">  &lt;/Box&gt;</p>
			<p class="source-code">&lt;/Link&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p>As you can see, this is a straightforward component that displays a product card containing<a id="_idIndexMarker699"/> the <a id="_idIndexMarker700"/>product<a id="_idIndexMarker701"/> image, name, and price.</p>
			<p>If you look at the used props (highlighted in the preceding code snippet), you will notice a one-to-one correspondence with the data we're getting back from GraphCMS. That's another slight advantage of using GraphQL: it allows you to model your data while querying it, making it incredibly easy to build components, functions, and even algorithms around it.</p>
			<p>Now that we have our <strong class="source-inline">ProductCard</strong> component, we can import it into our home page and use it to display all the products fetched from the CMS:</p>
			<p class="source-code"><strong class="bold">import { Grid } from '@chakra-ui/layout';</strong></p>
			<p class="source-code">import graphql from '../lib/graphql';</p>
			<p class="source-code">import getAllProducts from '../lib/graphql/queries/getAllProducts';</p>
			<p class="source-code"><strong class="bold">import ProductCard from '../components/ProductCard';</strong></p>
			<p class="source-code">export async const getStaticProps = () =&gt; {</p>
			<p class="source-code">  // ...</p>
			<p class="source-code">}</p>
			<p class="source-code">export default function Home(<strong class="bold">props</strong>) {</p>
			<p class="source-code">  return (</p>
			<p class="source-code"><strong class="bold">&lt;Grid gridTemplateColumns="repeat(4, 1fr)" gap="5"&gt;</strong></p>
			<p class="source-code"><strong class="bold">  {props.products.map((product) =&gt; (</strong></p>
			<p class="source-code"><strong class="bold">  &lt;ProductCard key={product.id} {...product} /&gt;</strong></p>
			<p class="source-code"><strong class="bold">      ))}</strong></p>
			<p class="source-code"><strong class="bold">&lt;/Grid&gt;</strong></p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p>If we now<a id="_idIndexMarker702"/> launch<a id="_idIndexMarker703"/> our <a id="_idIndexMarker704"/>development server and head to <a href="http://localhost:3000">http://localhost:3000</a>, we will be able to see our storefront.</p>
			<div>
				<div id="_idContainer056" class="IMG---Figure">
					<img src="image/Figure_13.4_B16985.jpg" alt="Figure 13.4 – Our first Next.js-based storefront&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.4 – Our first Next.js-based storefront</p>
			<p>Now that we <a id="_idIndexMarker705"/>have <a id="_idIndexMarker706"/>a <a id="_idIndexMarker707"/>working storefront, we need to create a single product page.</p>
			<p>As for the home page, we will use SSG + ISR to build all the product pages, which will help us maintain great performance and improve SEO and user experience.</p>
			<p>We can do that by creating a new file under <strong class="source-inline">pages/product/[slug].js</strong>, where we can start writing the following function definitions:</p>
			<p class="source-code">export async function getStaticPaths() {}</p>
			<p class="source-code">export async function getStaticProps() {}</p>
			<p class="source-code">export default function ProductPage() {}</p>
			<p>As you may have guessed, we will need to generate a new page for each product, and we can do that by using Next.js' reserved <strong class="source-inline">getStaticPaths</strong> function.</p>
			<p>Inside that function, we will query for all the products in our CMS, then generate the dynamic URL paths for each one; that way, at build time, Next.js will generate all the pages we need in our website.</p>
			<p>The other two functions should already sound familiar, so we will implement them later.</p>
			<p>We now need to write a GraphQL query for getting all the products in GraphCMS. To keep it simple, we can reuse the query we wrote for the home page, which is already fetching all the products, including their slugs (which will be part of the product URL).</p>
			<p>Let's update <a id="_idIndexMarker708"/>our<a id="_idIndexMarker709"/> product page by making a request to<a id="_idIndexMarker710"/> GraphCMS for all the products in the inventory:</p>
			<p class="source-code"><strong class="bold">import graphql from '../../lib/graphql';</strong></p>
			<p class="source-code"><strong class="bold">import getAllProducts from '../../lib/graphql/queries/getAllProducts';</strong></p>
			<p class="source-code">export async function getStaticPaths() {</p>
			<p class="source-code"><strong class="bold">  const { products } = await     </strong></p>
			<p class="source-code"><strong class="bold">    graphql.request(getAllProducts);</strong></p>
			<p class="source-code"><strong class="bold">  const paths = products.map((product) =&gt; ({</strong></p>
			<p class="source-code"><strong class="bold">    params: {</strong></p>
			<p class="source-code"><strong class="bold">      slug: product.slug,</strong></p>
			<p class="source-code"><strong class="bold">    },</strong></p>
			<p class="source-code"><strong class="bold">  }));</strong></p>
			<p class="source-code"><strong class="bold">  return {</strong></p>
			<p class="source-code"><strong class="bold">    paths,</strong></p>
			<p class="source-code"><strong class="bold">    fallback: false,</strong></p>
			<p class="source-code"><strong class="bold">  };</strong></p>
			<p class="source-code">}</p>
			<p>With this edit, we're returning an object containing all the pages we need to generate at build time. In <a id="_idIndexMarker711"/>fact, the<a id="_idIndexMarker712"/> returning object <a id="_idIndexMarker713"/>will look like this:</p>
			<p class="source-code">{</p>
			<p class="source-code">  paths: [</p>
			<p class="source-code">   {</p>
			<p class="source-code">      params: {</p>
			<p class="source-code">        slug: "unisex-long-sleeve-tee"</p>
			<p class="source-code">      }</p>
			<p class="source-code">    },</p>
			<p class="source-code">    {</p>
			<p class="source-code">      params: {</p>
			<p class="source-code">        slug: "snapback"</p>
			<p class="source-code">      }</p>
			<p class="source-code">    },</p>
			<p class="source-code">    // ...</p>
			<p class="source-code">  ]</p>
			<p class="source-code">  fallback: false</p>
			<p class="source-code">}</p>
			<p>As you may guess, this will help Next.js to match a given <strong class="source-inline">/product/[slug]</strong> route with the correct product slug.</p>
			<p>At this point, we need to create a GraphQL query to get the single product details. We can create a new file under <strong class="source-inline">lib/graphql/queries/getProductDetail.js</strong> and add the following content:</p>
			<p class="source-code">import { gql } from 'graphql-request';</p>
			<p class="source-code">export default gql`</p>
			<p class="source-code">  query GetProductBySlug($slug: String!) {</p>
			<p class="source-code">  products(where: { slug: $slug }) {</p>
			<p class="source-code">    id</p>
			<p class="source-code">    images(first: 1) {</p>
			<p class="source-code">    id</p>
			<p class="source-code">    url</p>
			<p class="source-code">  }</p>
			<p class="source-code">    name</p>
			<p class="source-code">    price</p>
			<p class="source-code">    slug</p>
			<p class="source-code">    description</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">`;</p>
			<p>With this<a id="_idIndexMarker714"/> query, we<a id="_idIndexMarker715"/> will get all the products whose slug <a id="_idIndexMarker716"/>matches the <strong class="source-inline">$slug</strong> query variable. Given that the <strong class="source-inline">slug</strong> property is unique in GraphCMS, it will return an array with just one result if the requested products exist or an empty array if it doesn't.</p>
			<p>We're now ready to import this query and edit the <strong class="source-inline">getStaticProps</strong> function:</p>
			<p class="source-code">import graphql from '../../lib/graphql';</p>
			<p class="source-code">import getAllProducts from '../../lib/graphql/queries/getAllProducts';</p>
			<p class="source-code"><strong class="bold">import getProductDetail from '../../lib/graphql/queries/getProductDetail';</strong></p>
			<p class="source-code">export async function getStaticProps(<strong class="bold">{ params }</strong>) {</p>
			<p class="source-code"><strong class="bold">  const { products } = await </strong></p>
			<p class="source-code"><strong class="bold">    graphql.request(getProductDetail, {</strong></p>
			<p class="source-code"><strong class="bold">    slug: params.slug,</strong></p>
			<p class="source-code"><strong class="bold">  });</strong></p>
			<p class="source-code"><strong class="bold">  return {</strong></p>
			<p class="source-code"><strong class="bold">    props: {</strong></p>
			<p class="source-code"><strong class="bold">      product: products[0],</strong></p>
			<p class="source-code"><strong class="bold">    },</strong></p>
			<p class="source-code"><strong class="bold">  };</strong></p>
			<p class="source-code">}</p>
			<p>Now we only need<a id="_idIndexMarker717"/> to<a id="_idIndexMarker718"/> create the product page layout, containing <a id="_idIndexMarker719"/>an image of our product, a title, a brief description, the price, and a quantity selector. To do that, we can edit the <strong class="source-inline">ProductPage</strong> function in the following way:</p>
			<p class="source-code">import { Box, Flex, Grid, Text, Image, Divider, Button,  </p>
			<p class="source-code">  Select } from '@chakra-ui/react';</p>
			<p class="source-code">// ...</p>
			<p class="source-code">function SelectQuantity(props) {</p>
			<p class="source-code">  const quantity = [...Array.from({ length: 10 })];</p>
			<p class="source-code">  return (</p>
			<p class="source-code">  &lt;Select  placeholder="Quantity"</p>
			<p class="source-code">    onChange={(event) =&gt;props.onChange(event.target.value)}&gt;</p>
			<p class="source-code">      {quantity.map((_, i) =&gt; (</p>
			<p class="source-code">    &lt;option key={i + 1} value={i + 1}&gt;</p>
			<p class="source-code">      {i + 1}</p>
			<p class="source-code">    &lt;/option&gt;</p>
			<p class="source-code">    ))}</p>
			<p class="source-code">  &lt;/Select&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p class="source-code">export default function ProductPage({ product }) {</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;Flex rounded="xl" boxShadow="2xl" w="full" p="16"  </p>
			<p class="source-code">      bgColor="white"&gt;</p>
			<p class="source-code">    &lt;Image height="96" width="96" src={product.images[0].url}/&gt;</p>
			<p class="source-code">    &lt;Box ml="12" width="container.xs"&gt;</p>
			<p class="source-code">    &lt;Text as="h1" fontSize="4xl" fontWeight="bold"&gt;</p>
			<p class="source-code">      {product.name}</p>
			<p class="source-code">    &lt;/Text&gt;</p>
			<p class="source-code">    &lt;Text lineHeight="none" fontSize="xl" my="3"   </p>
			<p class="source-code">    fontWeight="bold" textColor="blue.500"&gt;</p>
			<p class="source-code">      €{product.price / 100}</p>
			<p class="source-code">    &lt;/Text&gt;</p>
			<p class="source-code">    &lt;Text maxW="96" textAlign="justify" fontSize="sm"&gt;</p>
			<p class="source-code">      {product.description}</p>
			<p class="source-code">    &lt;/Text&gt;</p>
			<p class="source-code">    &lt;Divider my="6" /&gt;</p>
			<p class="source-code">    &lt;Grid gridTemplateColumns="2fr 1fr" gap="5"    </p>
			<p class="source-code">      alignItems="center"&gt;</p>
			<p class="source-code">    &lt;SelectQuantityonChange={() =&gt; {}} /&gt;</p>
			<p class="source-code">    &lt;Button colorScheme="blue"&gt;</p>
			<p class="source-code">      Add to cart</p>
			<p class="source-code">    &lt;/Button&gt;</p>
			<p class="source-code">    &lt;/Grid&gt;</p>
			<p class="source-code">    &lt;/Box&gt;</p>
			<p class="source-code">    &lt;/Flex&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p>If we now<a id="_idIndexMarker720"/> launch <a id="_idIndexMarker721"/>the<a id="_idIndexMarker722"/> development server and open a single product page, we will see the following content:</p>
			<div>
				<div id="_idContainer057" class="IMG---Figure">
					<img src="image/Figure_13.5_B16985.jpg" alt="Figure 13.5 – The single product detail page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.5 – The single product detail page</p>
			<p>Now that we can <a id="_idIndexMarker723"/>navigate<a id="_idIndexMarker724"/> from the home page to a <a id="_idIndexMarker725"/>product page, we need to build a navigation bar that can allow us to go back to the storefront or go to the shopping cart to review the product we want to purchase and then make the payment.</p>
			<p>We can easily create a navigation bar by opening a new file under <strong class="source-inline">components/NavBar/index.js</strong> and adding the following content:</p>
			<p class="source-code">import Link from 'next/link';</p>
			<p class="source-code">import { Flex, Box, Button, Text } from '@chakra-ui/react';</p>
			<p class="source-code">import { MdShoppingCart } from 'react-icons/md';</p>
			<p class="source-code">export default function NavBar() {</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;Box position="fixed" top={0} left={0} w="full"   </p>
			<p class="source-code">    bgColor="white" boxShadow="md"&gt;</p>
			<p class="source-code">    &lt;Flex width="container.xl" m="auto" p="5"     </p>
			<p class="source-code">      justifyContent="space-between"&gt;</p>
			<p class="source-code">    &lt;Link href="/" passHref&gt;</p>
			<p class="source-code">    &lt;Text textColor="blue.800" fontWeight="bold"      </p>
			<p class="source-code">      fontSize="2xl" as="a"&gt;</p>
			<p class="source-code">        My e-commerce</p>
			<p class="source-code">    &lt;/Text&gt;</p>
			<p class="source-code">    &lt;/Link&gt;</p>
			<p class="source-code">    &lt;Box&gt;</p>
			<p class="source-code">    &lt;Link href="/cart" passHref&gt;</p>
			<p class="source-code">      &lt;Button as="a"&gt;</p>
			<p class="source-code">        &lt;MdShoppingCart /&gt;</p>
			<p class="source-code">      &lt;/Button&gt;</p>
			<p class="source-code">    &lt;/Link&gt;</p>
			<p class="source-code">    &lt;/Box&gt;</p>
			<p class="source-code">    &lt;/Flex&gt;</p>
			<p class="source-code">    &lt;/Box&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p>We will also <a id="_idIndexMarker726"/>need<a id="_idIndexMarker727"/> to<a id="_idIndexMarker728"/> install the <strong class="source-inline">react-icons</strong> library, which, as the name suggests, is an excellent package containing hundreds of well-made and useful icons for our React-based projects:</p>
			<p class="source-code">yarn add react-icons</p>
			<p>We now only need to update our <strong class="source-inline">_app.js</strong> file by including the newest <strong class="source-inline">NavBar</strong> component so that<a id="_idIndexMarker729"/> it <a id="_idIndexMarker730"/>will be rendered on all the application<a id="_idIndexMarker731"/> pages:</p>
			<p class="source-code">import { Box, Flex, ChakraProvider } from '@chakra-ui/react';</p>
			<p class="source-code"><strong class="bold">import NavBar from '../components/NavBar';</strong></p>
			<p class="source-code">function MyApp({ Component, pageProps }) {</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;ChakraProvider&gt;</p>
			<p class="source-code">    &lt;Flex w="full" minH="100vh" bgColor="gray.100"&gt;</p>
			<p class="source-code"><strong class="bold">    &lt;NavBar /&gt;</strong></p>
			<p class="source-code">    &lt;Box maxW="70vw" m="auto"&gt;</p>
			<p class="source-code">      &lt;Component {...pageProps} /&gt;</p>
			<p class="source-code">    &lt;/Box&gt;</p>
			<p class="source-code">    &lt;/Flex&gt;</p>
			<p class="source-code">    &lt;/ChakraProvider&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p class="source-code">export default MyApp;</p>
			<p>We can finally navigate from the storefront to the product page and back!</p>
			<p>Now that the website is taking shape, we want to add products to our shopping basket. We discussed a similar scenario in <a href="B16985_05_Final_SB_epub.xhtml#_idTextAnchor068"><em class="italic">Chapter 5</em></a>, <em class="italic">Managing Local and Global States in Next.js</em>.</p>
			<p>We will need to create a React context to hold the shopping list until the user pays.</p>
			<p>First, we will need to create a new file under <strong class="source-inline">lib/context/Cart/index.js</strong>. Here, we will write the following script:</p>
			<p class="source-code">import { createContext } from 'react';</p>
			<p class="source-code">const CartContext = createContext({</p>
			<p class="source-code">  items: {},</p>
			<p class="source-code">  setItems: () =&gt; {},</p>
			<p class="source-code">});</p>
			<p class="source-code">export default CartContext;</p>
			<p>We now need to<a id="_idIndexMarker732"/> wrap <a id="_idIndexMarker733"/>the entire app under this<a id="_idIndexMarker734"/> context, so we need to open the <strong class="source-inline">_app.js</strong> file and edit it as follows:</p>
			<p class="source-code"><strong class="bold">import { useState } from 'react';</strong></p>
			<p class="source-code">import { Box, Flex, ChakraProvider } from '@chakra-ui/react';</p>
			<p class="source-code">import NavBar from '../components/NavBar';</p>
			<p class="source-code"><strong class="bold">import CartContext from '../lib/context/Cart';</strong></p>
			<p class="source-code">function MyApp({ Component, pageProps }) {</p>
			<p class="source-code"><strong class="bold">  const [items, setItems] = useState({});</strong></p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;ChakraProvider&gt;</p>
			<p class="source-code"><strong class="bold">    &lt;CartContext.Provider value={{ items, setItems }}&gt;</strong></p>
			<p class="source-code">    &lt;Flex w="full" minH="100vh" bgColor="gray.100"&gt;</p>
			<p class="source-code">    &lt;NavBar /&gt;</p>
			<p class="source-code">      &lt;Box maxW="70vw" m="auto"&gt;</p>
			<p class="source-code">        &lt;Component {...pageProps} /&gt;</p>
			<p class="source-code">      &lt;/Box&gt;</p>
			<p class="source-code">    &lt;/Flex&gt;</p>
			<p class="source-code"><strong class="bold">    &lt;/CartContext.Provider&gt;</strong></p>
			<p class="source-code">    &lt;/ChakraProvider&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p class="source-code">export default MyApp;</p>
			<p>This is quite similar to the context we created in <a href="B16985_05_Final_SB_epub.xhtml#_idTextAnchor068"><em class="italic">Chapter 5</em></a>, <em class="italic">Managing Local and Global States in Next.js</em>, right?</p>
			<p>We now need <a id="_idIndexMarker735"/>to<a id="_idIndexMarker736"/> link <a id="_idIndexMarker737"/>the single product page to the context to add products to the shopping cart. Let's open the <strong class="source-inline">components/ProductCard/index.js</strong> file and link the context to the <strong class="bold">select quantity</strong> and <strong class="bold">add to cart</strong> actions:</p>
			<p class="source-code"><strong class="bold">import { useContext, useState } from 'react';</strong></p>
			<p class="source-code"><strong class="bold">import CartContext from '../../lib/context/Cart';</strong></p>
			<p class="source-code">// ...</p>
			<p class="source-code">export default function ProductPage({ product }) {</p>
			<p class="source-code"><strong class="bold">  const [quantity, setQuantity] = useState(0);</strong></p>
			<p class="source-code"><strong class="bold">  const { items, setItems } = useContext(CartContext);</strong></p>
			<p class="source-code"><strong class="bold">  const alreadyInCart = product.id in items;</strong></p>
			<p class="source-code"><strong class="bold">  function addToCart() {</strong></p>
			<p class="source-code"><strong class="bold">      setItems({</strong></p>
			<p class="source-code"><strong class="bold">      ...items,</strong></p>
			<p class="source-code"><strong class="bold">      [product.id]: quantity,</strong></p>
			<p class="source-code"><strong class="bold">    });</strong></p>
			<p class="source-code"><strong class="bold">  }</strong></p>
			<p class="source-code">  return (</p>
			<p class="source-code">   &lt;Flex rounded="xl" boxShadow="2xl" w="full" p="16"   </p>
			<p class="source-code">     bgColor="white"&gt;</p>
			<p class="source-code">   &lt;Image height="96" width="96" src={product.images[0].url} /&gt;</p>
			<p class="source-code">   &lt;Box ml="12" width="container.xs"&gt;</p>
			<p class="source-code">     &lt;Text as="h1" fontSize="4xl" fontWeight="bold"&gt;</p>
			<p class="source-code">       {product.name}</p>
			<p class="source-code">    &lt;/Text&gt;</p>
			<p class="source-code">    &lt;Text lineHeight="none" fontSize="xl" my="3"    </p>
			<p class="source-code">       fontWeight="bold" textColor="blue.500"&gt;</p>
			<p class="source-code">          €{product.price / 100}</p>
			<p class="source-code">    &lt;/Text&gt;</p>
			<p class="source-code">    &lt;Text maxW="96" textAlign="justify" fontSize="sm"&gt;</p>
			<p class="source-code">          {product.description}</p>
			<p class="source-code">    &lt;/Text&gt;</p>
			<p class="source-code">    &lt;Divider my="6" /&gt;</p>
			<p class="source-code">    &lt;Grid gridTemplateColumns="2fr 1fr" gap="5"       </p>
			<p class="source-code">      alignItems="center"&gt;</p>
			<p class="source-code">     &lt;SelectQuantity</p>
			<p class="source-code"><strong class="bold">       onChange={(quantity)=&gt;setQuantity </strong></p>
			<p class="source-code"><strong class="bold">         (parseInt(quantity</strong>))} </p>
			<p class="source-code">      /&gt;</p>
			<p class="source-code"><strong class="bold">      &lt;Button colorScheme="blue" onClick={addToCart}&gt;</strong></p>
			<p class="source-code"><strong class="bold">            {alreadyInCart ? 'Update' : 'Add to cart'}</strong></p>
			<p class="source-code"><strong class="bold">      &lt;/Button&gt;</strong></p>
			<p class="source-code">    &lt;/Grid&gt;</p>
			<p class="source-code">  &lt;/Box&gt;</p>
			<p class="source-code">&lt;/Flex&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p>We can also make things <a id="_idIndexMarker738"/>more<a id="_idIndexMarker739"/> exciting and dynamic by <a id="_idIndexMarker740"/>showing how many products we have in our shopping cart. We can do this by linking the <strong class="source-inline">NavBar</strong> component to the same <strong class="source-inline">CartContext</strong> by adding a few lines:</p>
			<p class="source-code"><strong class="bold">import { useContext } from 'react';</strong></p>
			<p class="source-code">import Link from 'next/link';</p>
			<p class="source-code">import { Flex, Box, Button, Text } from '@chakra-ui/react';</p>
			<p class="source-code">import { MdShoppingCart } from 'react-icons/md';</p>
			<p class="source-code"><strong class="bold">import CartContext from '../../lib/context/Cart';</strong></p>
			<p class="source-code">export default function NavBar() {</p>
			<p class="source-code"><strong class="bold">  const { items } = useContext(CartContext);</strong></p>
			<p class="source-code"><strong class="bold">  const itemsCount = Object</strong></p>
			<p class="source-code"><strong class="bold">    .values(items)</strong></p>
			<p class="source-code"><strong class="bold">    .reduce((x, y) =&gt; x + y, 0);</strong></p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;Box position="fixed" top={0} left={0} w="full"    </p>
			<p class="source-code">      bgColor="white" boxShadow="md"&gt;</p>
			<p class="source-code">    &lt;Flex width="container.xl" m="auto" p="5"</p>
			<p class="source-code">      justifyContent="space-between"&gt;</p>
			<p class="source-code">      &lt;Link href="/" passHref&gt;</p>
			<p class="source-code">      &lt;Text textColor="blue.800" fontWeight="bold"   </p>
			<p class="source-code">         fontSize="2xl" as="a"&gt;</p>
			<p class="source-code">            My e-commerce</p>
			<p class="source-code">      &lt;/Text&gt;</p>
			<p class="source-code">      &lt;/Link&gt;</p>
			<p class="source-code">&lt;Box&gt;</p>
			<p class="source-code">&lt;Link href="/cart" passHref&gt;</p>
			<p class="source-code">  &lt;Button as="a"&gt;</p>
			<p class="source-code">    &lt;MdShoppingCart /&gt;</p>
			<p class="source-code"><strong class="bold">&lt;Text ml="3"&gt;{itemsCount}&lt;/Text&gt;</strong></p>
			<p class="source-code">  &lt;/Button&gt;</p>
			<p class="source-code">&lt;/Link&gt;</p>
			<p class="source-code">&lt;/Box&gt;</p>
			<p class="source-code">&lt;/Flex&gt;</p>
			<p class="source-code">&lt;/Box&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p>Now that we have a way to add items to the shopping cart, we need to create the cart page itself. Let's <a id="_idIndexMarker741"/>create <a id="_idIndexMarker742"/>a new <strong class="source-inline">pages/cart.js,</strong> file where we<a id="_idIndexMarker743"/> will add the following component:</p>
			<p class="source-code">import { useContext, useEffect, useState } from 'react';</p>
			<p class="source-code">import { Box, Divider, Text } from '@chakra-ui/react';</p>
			<p class="source-code">export default function Cart() {</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;Box</p>
			<p class="source-code">      rounded="xl"</p>
			<p class="source-code">      boxShadow="2xl"</p>
			<p class="source-code">      w="container.lg"</p>
			<p class="source-code">      p="16"</p>
			<p class="source-code">      bgColor="white"</p>
			<p class="source-code">     &gt;</p>
			<p class="source-code">     &lt;Text as="h1" fontSize="2xl" fontWeight="bold"&gt;</p>
			<p class="source-code">        Cart</p>
			<p class="source-code">     &lt;/Text&gt;</p>
			<p class="source-code">     &lt;Divider my="10" /&gt;</p>
			<p class="source-code">     &lt;Box&gt;</p>
			<p class="source-code">       &lt;Text&gt;The cart is empty.&lt;/Text&gt;</p>
			<p class="source-code">     &lt;/Box&gt;</p>
			<p class="source-code">     &lt;/Box&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p>This will be the shopping cart's page default state. When a user puts any product into the basket, we need to display it here.</p>
			<p>To do that, we can <a id="_idIndexMarker744"/>easily <a id="_idIndexMarker745"/>use the cart context we just<a id="_idIndexMarker746"/> created, which will tell us the ID and quantity of each product:</p>
			<p class="source-code">import { useContext, useEffect, useState } from 'react';</p>
			<p class="source-code">import { Box, Divider, Text } from '@chakra-ui/react';</p>
			<p class="source-code"><strong class="bold">import cartContext from '../lib/context/Cart';</strong></p>
			<p class="source-code">export default function Cart() {</p>
			<p class="source-code"><strong class="bold">  const { items } = useContext(cartContext);</strong></p>
			<p class="source-code">  return (</p>
			<p class="source-code">    // ...</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p>We ended up having an object containing the IDs and the quantity for each product in the format <strong class="source-inline">{ [product_id]: quantity }</strong>.</p>
			<p>We will use the keys of this object to fetch all the required products from GraphCMS by using a new query, positioned under <strong class="source-inline">lib/graphql/queries/getProductsById.js</strong>:</p>
			<p class="source-code">import { gql } from 'graphql-request';</p>
			<p class="source-code">export default gql`</p>
			<p class="source-code">  query GetProductByID($ids: [ID!]) {</p>
			<p class="source-code">  products(where: { id_in: $ids }) {</p>
			<p class="source-code">    id</p>
			<p class="source-code">    name</p>
			<p class="source-code">    price</p>
			<p class="source-code">    slug</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">`;</p>
			<p>Once we finish writing the query, we can move back to our <strong class="source-inline">cart.js</strong> file and implement <a id="_idIndexMarker747"/>it <a id="_idIndexMarker748"/>using a <strong class="source-inline">useEffect</strong> React Hook, so <a id="_idIndexMarker749"/>that we fetch all the products as soon as the page loads:</p>
			<p class="source-code">import { useContext, useEffect, useState } from 'react';</p>
			<p class="source-code">import { Box, Divider, Text } from '@chakra-ui/react';</p>
			<p class="source-code">import graphql from '../lib/graphql';</p>
			<p class="source-code">import cartContext from '../lib/context/Cart';</p>
			<p class="source-code"><strong class="bold">import getProductsById from '../lib/graphql/queries/getProductsById';</strong></p>
			<p class="source-code">export default function Cart() {</p>
			<p class="source-code">  const { items } = useContext(cartContext);</p>
			<p class="source-code"><strong class="bold">  const [products, setProducts] = useState([]);</strong></p>
			<p class="source-code"><strong class="bold">  const hasProducts = Object.keys(items).length;</strong></p>
			<p class="source-code"><strong class="bold">  useEffect(() =&gt; {</strong></p>
			<p class="source-code"><strong class="bold">    // only fetch data if user has selected any product</strong></p>
			<p class="source-code"><strong class="bold">    if (!hasProducts) return;</strong></p>
			<p class="source-code"><strong class="bold">  graphql.request(getProductsById, {</strong></p>
			<p class="source-code"><strong class="bold">        ids: Object.keys(items),</strong></p>
			<p class="source-code"><strong class="bold">      })</strong></p>
			<p class="source-code"><strong class="bold">      .then((data) =&gt; {</strong></p>
			<p class="source-code"><strong class="bold">        setProducts(data.products);</strong></p>
			<p class="source-code"><strong class="bold">      })</strong></p>
			<p class="source-code"><strong class="bold">      .catch((err) =&gt;console.error(err));</strong></p>
			<p class="source-code"><strong class="bold">  }, [JSON.stringify(products)]);</strong></p>
			<p class="source-code">  return (</p>
			<p class="source-code">    // ...</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p>As soon as we<a id="_idIndexMarker750"/> try <a id="_idIndexMarker751"/>to<a id="_idIndexMarker752"/> add a couple of products to the shopping basket and then move to the cart page, we will see the following error:</p>
			<div>
				<div id="_idContainer058" class="IMG---Figure">
					<img src="image/Figure_13.6_B16985.jpg" alt="Figure 13.6 – The browser can't find the process variable&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.6 – The browser can't find the process variable</p>
			<p>Next.js is telling us that the <strong class="source-inline">process</strong> variable, containing all the environment variables, is not available on <a id="_idIndexMarker753"/>the<a id="_idIndexMarker754"/> browser. Thankfully, even<a id="_idIndexMarker755"/> if this variable is not officially supported by any browser, Next.js provides an excellent polyfill for us; we only need to make a couple of changes to make it effective.</p>
			<p>First of all, we will need to rename the <strong class="source-inline">GRAPHCMS_ENDPOINT</strong> variable to <strong class="source-inline">NEXT_PUBLIC_GRAPHCMS_ENDPOINT</strong>. By prepending <strong class="source-inline">NEXT_PUBLIC_</strong> to any environment variable, Next.js will add a <strong class="source-inline">process.env</strong> object, available on the browser, exposing only the public variables.</p>
			<p>Let's make the change in the <strong class="source-inline">.env.local</strong> file, then move back to the <strong class="source-inline">lib/graphql/index.js</strong> file and make a small change there too:</p>
			<p class="source-code">import { GraphQLClient } from 'graphql-request';</p>
			<p class="source-code"><strong class="bold">const GRAPHCMS_ENDPOINT = process.env.NEXT_PUBLIC_GRAPHCMS_ENDPOINT;</strong></p>
			<p class="source-code"><strong class="bold">const GRAPHCMS_API_KEY = process.env.GRAPHCMS_API_KEY;</strong></p>
			<p class="source-code">const authorization = `Bearer ${GRAPHCMS_API_KEY}`;</p>
			<p class="source-code">export default new GraphQLClient(GRAPHCMS_ENDPOINT, {</p>
			<p class="source-code">  headers: {</p>
			<p class="source-code">    ...(GRAPHCMS_API_KEY &amp;&amp; { authorization }),</p>
			<p class="source-code">  },</p>
			<p class="source-code">});</p>
			<p>Please note that we're not modifying the <strong class="source-inline">GRAPHCMS_API_KEY</strong> environment variable name, as it contains private data and should never be exposed.</p>
			<p>Now that we have fixed this little issue, we're finally ready to compose our cart page.</p>
			<p>First, we will <a id="_idIndexMarker756"/>need<a id="_idIndexMarker757"/> to write a function that calculates the <a id="_idIndexMarker758"/>final expense by summing the product prices multiplied by their quantity. We can do that by adding this function inside our component's body:</p>
			<p class="source-code">export default function Cart() {</p>
			<p class="source-code">  // ...</p>
			<p class="source-code">function getTotal() {</p>
			<p class="source-code">  if (!products.length) return 0;</p>
			<p class="source-code">  return Object.keys(items)</p>
			<p class="source-code">    .map(</p>
			<p class="source-code">      (id) =&gt;</p>
			<p class="source-code">        products.find((product) =&gt; product.id === id).price</p>
			<p class="source-code">        * (items[id] / 100) // Stripe requires the prices to be</p>
			<p class="source-code">                            // integers (i.e., €4.99 should be</p>
			<p class="source-code">                            // written as 499). That's why</p>
			<p class="source-code">                            // we need to divide by 100 the                                prices</p>
			<p class="source-code">                            // we get from GraphCMS, which are</p>
			<p class="source-code">                            // already in the correct</p>
			<p class="source-code">                            // Stripe format</p>
			<p class="source-code">      )</p>
			<p class="source-code">      .reduce((x, y) =&gt; x + y)</p>
			<p class="source-code">      .toFixed(2);</p>
			<p class="source-code">  }</p>
			<p class="source-code">// ...</p>
			<p class="source-code">}</p>
			<p>Now, we can update <a id="_idIndexMarker759"/>our<a id="_idIndexMarker760"/> component returning JSX by<a id="_idIndexMarker761"/> including the list of products that we added to the shopping cart:</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;Box</p>
			<p class="source-code">      rounded="xl"</p>
			<p class="source-code">      boxShadow="2xl"</p>
			<p class="source-code">      w="container.lg"</p>
			<p class="source-code">      p="16"</p>
			<p class="source-code">      bgColor="white"&gt;</p>
			<p class="source-code">    &lt;Text as="h1" fontSize="2xl" fontWeight="bold"&gt;</p>
			<p class="source-code">      Cart</p>
			<p class="source-code">    &lt;/Text&gt;</p>
			<p class="source-code">    &lt;Divider my="10" /&gt;</p>
			<p class="source-code">    &lt;Box&gt;</p>
			<p class="source-code">      {!hasProducts ? (</p>
			<p class="source-code">    &lt;Text&gt;The cart is empty.&lt;/Text&gt;</p>
			<p class="source-code">        ) : (</p>
			<p class="source-code">    &lt;&gt;</p>
			<p class="source-code">       {products.map((product) =&gt; (</p>
			<p class="source-code">    &lt;Flex</p>
			<p class="source-code">      key={product.id}</p>
			<p class="source-code">      justifyContent="space-between"</p>
			<p class="source-code">      mb="4"&gt;</p>
			<p class="source-code">    &lt;Box&gt;</p>
			<p class="source-code">    &lt;Link href={`/product/${product.slug}`} passHref&gt;</p>
			<p class="source-code">    &lt;Text</p>
			<p class="source-code">      as="a"</p>
			<p class="source-code">      fontWeight="bold"</p>
			<p class="source-code">      _hover={{</p>
			<p class="source-code">      textDecoration: 'underline',</p>
			<p class="source-code">      color: 'blue.500' }}&gt;</p>
			<p class="source-code">        {product.name}</p>
			<p class="source-code">      &lt;Text as="span" color="gray.500"&gt;</p>
			<p class="source-code">        {''}</p>
			<p class="source-code">        x{items[product.id]}</p>
			<p class="source-code">      &lt;/Text&gt;</p>
			<p class="source-code">      &lt;/Text&gt;</p>
			<p class="source-code">      &lt;/Link&gt;</p>
			<p class="source-code">      &lt;/Box&gt;</p>
			<p class="source-code">      &lt;Box&gt;</p>
			<p class="source-code">        €{(items[product.id] *</p>
			<p class="source-code">        (product.price / 100)).toFixed(2)}</p>
			<p class="source-code">      &lt;/Box&gt;</p>
			<p class="source-code">      &lt;/Flex&gt;</p>
			<p class="source-code">            ))}</p>
			<p class="source-code">      &lt;Divider my="10" /&gt;</p>
			<p class="source-code">      &lt;Flex</p>
			<p class="source-code">        alignItems="center"</p>
			<p class="source-code">        justifyContent="space-between"&gt;</p>
			<p class="source-code">        &lt;Text fontSize="xl" fontWeight="bold"&gt;</p>
			<p class="source-code">          Total: €{getTotal()}</p>
			<p class="source-code">        &lt;/Text&gt;</p>
			<p class="source-code">     &lt;Button colorScheme="blue"&gt; Pay now &lt;/Button&gt;</p>
			<p class="source-code">     &lt;/Flex&gt;</p>
			<p class="source-code">     &lt;/&gt;</p>
			<p class="source-code">        )}</p>
			<p class="source-code">&lt;/Box&gt;</p>
			<p class="source-code">&lt;/Box&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p>We're all set for managing the cart! We now need to process the payment by choosing a financial<a id="_idIndexMarker762"/> service, such<a id="_idIndexMarker763"/> as Stripe, PayPal, or <a id="_idIndexMarker764"/>Braintree.</p>
			<p>In the next section, we will see how to implement the payment feature using Stripe.</p>
			<h1 id="_idParaDest-137"><a id="_idTextAnchor136"/>Processing payments using Stripe</h1>
			<p>Stripe is one <a id="_idIndexMarker765"/>of the best financial services out there; it's <a id="_idIndexMarker766"/>straightforward to use and offers excellent documentation to understand how to integrate their APIs.</p>
			<p>Before continuing <a id="_idIndexMarker767"/>with this section, make sure to open an account at https://stripe.com.</p>
			<p>Once we have an account, we can log in and go to <a href="https://dashboard.stripe.com/apikeys">https://dashboard.stripe.com/apikeys</a>, where we'll retrieve the following information: the publishable key and secret key. We will need to store them inside of two environment variables, following this naming convention:</p>
			<p class="source-code">NEXT_PUBLIC_STRIPE_SHARABLE_KEY=</p>
			<p class="source-code">STRIPE_SECRET_KEY=</p>
			<p>Please double-check that you're not exposing the <strong class="source-inline">STRIPE_SECRET_KEY</strong> variable and that the <strong class="source-inline">.env.local</strong> file is not added to the Git history by including it in the <strong class="source-inline">.gitignore</strong> file.</p>
			<p>Now let's install the Stripe JavaScript SDK inside of our project:</p>
			<p class="source-code">yarn add @stripe/stripe-js stripe</p>
			<p>Once the two packages are installed, we can create a new file under <strong class="source-inline">lib/stripe/index.js</strong>, containing the following script:</p>
			<p class="source-code">import { loadStripe } from '@stripe/stripe-js';</p>
			<p class="source-code">const key = process.env.NEXT_PUBLIC_STRIPE_SHARABLE_KEY;</p>
			<p class="source-code">let stripePromise;</p>
			<p class="source-code">const getStripe = () =&gt; {</p>
			<p class="source-code">  if (!stripePromise) {</p>
			<p class="source-code">    stripePromise = loadStripe(key);</p>
			<p class="source-code">  }</p>
			<p class="source-code">  return stripePromise;</p>
			<p class="source-code">};</p>
			<p class="source-code">export default getStripe;</p>
			<p>This script will <a id="_idIndexMarker768"/>ensure <a id="_idIndexMarker769"/>that we load Stripe only once, even if we come back to the cart page multiple times.</p>
			<p>At this point, we will need to create an API page that creates a Stripe session. By doing that, Stripe will create a beautiful and secure checkout page to redirect our users to insert their payment and shipping details. Once the users place their orders, they will get redirected to a landing page of our choice, but we'll see that later on in this section.</p>
			<p>Let's create a new API route under <strong class="source-inline">/pages/api/checkout/index.js</strong>, where we will write a very basic Stripe checkout session request:</p>
			<p class="source-code">import Stripe from 'stripe';</p>
			<p class="source-code">const stripe = new Stripe(process.env.STRIPE_SECRET_KEY);</p>
			<p class="source-code">export default async function handler(req, res) {</p>
			<p class="source-code">}</p>
			<p>Once we have created this basic function, we need to understand what data Stripe requires to complete the session.</p>
			<p>We will need to pass the following data in a particular order:</p>
			<ul>
				<li>All the products to purchase, containing names, quantities, prices, and (optionally) images</li>
				<li>All the available payment methods (credit cards, Alipay, SEPA Debit, or other payment methods, such as Klarna)</li>
				<li>Shipping rates</li>
				<li>Success and cancel redirect URLs for either case</li>
			</ul>
			<p>We can start by considering the first point; we can easily pass the whole cart context object to <a id="_idIndexMarker770"/>this <a id="_idIndexMarker771"/>endpoint, including both product IDs to purchase and their quantity. We will need to then ask GraphCMS for product details, and we can do that by creating a new specific query under <strong class="source-inline">lib/graphql/queries/getProductDetailsById.js</strong>:</p>
			<p class="source-code">import { gql } from 'graphql-request';</p>
			<p class="source-code">export default gql`</p>
			<p class="source-code">  query GetProductDetailsByID($ids: [ID!]) {</p>
			<p class="source-code">    products(where: { id_in: $ids }) {</p>
			<p class="source-code">      id</p>
			<p class="source-code">      name</p>
			<p class="source-code">      price</p>
			<p class="source-code">      slug</p>
			<p class="source-code">      description</p>
			<p class="source-code">      images {</p>
			<p class="source-code">        id</p>
			<p class="source-code">         url</p>
			<p class="source-code">      }</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">`;</p>
			<p>Going back to our <strong class="source-inline">/pages/api/checkout/index.js</strong> API page, we can start by implementing<a id="_idIndexMarker772"/> the<a id="_idIndexMarker773"/> query to retrieve the product details:</p>
			<p class="source-code">import Stripe from 'stripe';</p>
			<p class="source-code">import graphql from '../../../lib/graphql';</p>
			<p class="source-code">import getProductsDetailsById from '../../../lib/graphql/queries/getProductDetailsById';</p>
			<p class="source-code">const stripe = new Stripe(process.env.STRIPE_SECRET_KEY);</p>
			<p class="source-code">export default async function handler(req, res) {</p>
			<p class="source-code">  const { items } = req.body;</p>
			<p class="source-code">  const { products } = await graphql</p>
			<p class="source-code">    .request(getProductsDetailsById, { ids: Object.keys(items) });</p>
			<p class="source-code">}</p>
			<p>Stripe requires a configuration object containing a property called <strong class="source-inline">line_items</strong>, which describes all the products ready for purchase. Now that we have all the product information, we can compose this property in the following way:</p>
			<p class="source-code">export default async function handler(req, res) {</p>
			<p class="source-code">  const { items } = req.body;</p>
			<p class="source-code">  const { products } = await graphql</p>
			<p class="source-code">    .request(getProductsDetailsById, { ids: Object.keys(items) });</p>
			<p class="source-code">  const line_items = products.map((product) =&gt; ({</p>
			<p class="source-code">    // user can change the quantity during checkout</p>
			<p class="source-code">    adjustable_quantity: {</p>
			<p class="source-code">      enabled: true,</p>
			<p class="source-code">      minimum: 1,</p>
			<p class="source-code">    },</p>
			<p class="source-code">  price_data: {</p>
			<p class="source-code">  // of course, it can be any currency of your choice</p>
			<p class="source-code">    currency: 'EUR',</p>
			<p class="source-code">    product_data: {</p>
			<p class="source-code">      name: product.name,</p>
			<p class="source-code">      images: product.images.map((img) =&gt; img.url),</p>
			<p class="source-code">      },</p>
			<p class="source-code">  // please note that GraphCMS already returns the price in the</p>
			<p class="source-code">  // format required by Strapi: €4.99, for instance, should be</p>
			<p class="source-code">  // passed to Stripe as 499.</p>
			<p class="source-code">    unit_amount: product.price,</p>
			<p class="source-code">    },</p>
			<p class="source-code">    quantity: items[product.id],</p>
			<p class="source-code">  }));</p>
			<p>As a reference, if a user buys a couple of backpacks from our store, the <strong class="source-inline">line_items</strong> array would <a id="_idIndexMarker774"/>look<a id="_idIndexMarker775"/> like this:</p>
			<p class="source-code">[</p>
			<p class="source-code">  {</p>
			<p class="source-code">    "adjustable_quantity": {</p>
			<p class="source-code">      "enabled": true,</p>
			<p class="source-code">      "minimum": 1</p>
			<p class="source-code">    },</p>
			<p class="source-code">    "price_data": {</p>
			<p class="source-code">      "currency": "EUR",</p>
			<p class="source-code">      "product_data": {</p>
			<p class="source-code">        "name": "Backpack",</p>
			<p class="source-code">        "images": [</p>
			<p class="source-code">          https://media.graphcms.com/U5y09n80TpuRKJU6Gue1</p>
			<p class="source-code">        ]</p>
			<p class="source-code">      },</p>
			<p class="source-code">      "unit_amount": 4999</p>
			<p class="source-code">    },</p>
			<p class="source-code">    "quantity": 2</p>
			<p class="source-code">  }</p>
			<p class="source-code">]</p>
			<p>We can now start writing the Stripe checkout session request by using the <strong class="source-inline">line_items</strong> array and a bit more information:</p>
			<p class="source-code">export default async function handle(req, res) {</p>
			<p class="source-code">  // ...</p>
			<p class="source-code">  const session = await stripe.checkout.sessions.create({</p>
			<p class="source-code">    mode: 'payment', // can also be "subscription" or "setup"</p>
			<p class="source-code">    line_items,</p>
			<p class="source-code">    payment_method_types: ['card', 'sepa_debit'],</p>
			<p class="source-code">    // the server doesn't know the current URL, so we need to     write</p>
			<p class="source-code">    // it into an environment variable depending on the current</p>
			<p class="source-code">    // environment. Locally, it should be URL=http://    localhost:3000</p>
			<p class="source-code">    success_url: `${process.env.URL}/success`,</p>
			<p class="source-code">    cancel_url: `${process.env.URL}/cancel`,</p>
			<p class="source-code">  });</p>
			<p class="source-code">    res.status(201).json({ session });</p>
			<p class="source-code">}</p>
			<p>We're almost there. Now, we <a id="_idIndexMarker776"/>only need to get the shipping information <a id="_idIndexMarker777"/>and store it in two different Stripe session properties: <strong class="source-inline">shipping_address_collection</strong> and <strong class="source-inline">shipping_options</strong>.</p>
			<p>We can create two new variables outside the <strong class="source-inline">handler</strong> function. Still, as you can imagine, this can be completely CMS-driven.</p>
			<p>To keep it simple, let's create the first <strong class="source-inline">shipping_address_collection</strong> variable:</p>
			<p class="source-code">export const shipping_address_collection = {</p>
			<p class="source-code">  allowed_countries: ['IT', 'US'],</p>
			<p class="source-code">};</p>
			<p>As you can see, we can restrict shipping by manually selecting the countries where we ship to. You can simply avoid passing the <strong class="source-inline">shipping_address_collection</strong> property to the Stripe session if you want to ship worldwide.</p>
			<p>The second variable is more complex but allows us to create different shipping methods with different rates. Let's say we offer free shipping, which takes 3 to 5 business days for delivery, and express next day shipping for €4.99. </p>
			<p>We can create<a id="_idIndexMarker778"/> the<a id="_idIndexMarker779"/> following array of shipping options:</p>
			<p class="source-code">export const shipping_options = [</p>
			<p class="source-code">  {</p>
			<p class="source-code">    shipping_rate_data: {</p>
			<p class="source-code">      type: 'fixed_amount',</p>
			<p class="source-code">      fixed_amount: {</p>
			<p class="source-code">        amount: 0,</p>
			<p class="source-code">        currency: 'EUR',</p>
			<p class="source-code">  },</p>
			<p class="source-code">    display_name: 'Free Shipping',</p>
			<p class="source-code">delivery_estimate: {</p>
			<p class="source-code">        minimum: {</p>
			<p class="source-code">          unit: 'business_day',</p>
			<p class="source-code">          value: 3,</p>
			<p class="source-code">        },</p>
			<p class="source-code">        maximum: {</p>
			<p class="source-code">          unit: 'business_day',</p>
			<p class="source-code">          value: 5,</p>
			<p class="source-code">        },</p>
			<p class="source-code">      },</p>
			<p class="source-code">    },</p>
			<p class="source-code">  },</p>
			<p class="source-code">  {</p>
			<p class="source-code">shipping_rate_data: {</p>
			<p class="source-code">      type: 'fixed_amount',</p>
			<p class="source-code">fixed_amount: {</p>
			<p class="source-code">        amount: 499,</p>
			<p class="source-code">        currency: 'EUR',</p>
			<p class="source-code">      },</p>
			<p class="source-code">display_name: 'Next day air',</p>
			<p class="source-code">delivery_estimate: {</p>
			<p class="source-code">        minimum: {</p>
			<p class="source-code">          unit: 'business_day',</p>
			<p class="source-code">          value: 1,</p>
			<p class="source-code">        },</p>
			<p class="source-code">        maximum: {</p>
			<p class="source-code">          unit: 'business_day',</p>
			<p class="source-code">          value: 1,</p>
			<p class="source-code">        },</p>
			<p class="source-code">      },</p>
			<p class="source-code">    },</p>
			<p class="source-code">  },</p>
			<p class="source-code">];</p>
			<p>The shipping objects are self-explanatory. We can finally add those two new properties to our Stripe <a id="_idIndexMarker780"/>checkout <a id="_idIndexMarker781"/>session:</p>
			<p class="source-code">export default async function handle(req, res) {</p>
			<p class="source-code">  // ...</p>
			<p class="source-code">  const session = await stripe.checkout.sessions.create({</p>
			<p class="source-code">    mode: 'payment', // can also be "subscription" or "setup"</p>
			<p class="source-code">    line_items,</p>
			<p class="source-code">    payment_method_types: ['card', 'sepa_debit'],</p>
			<p class="source-code">    // the server doesn't know the current URL, so we need to     write</p>
			<p class="source-code">    // it into an environment variable depending on the current</p>
			<p class="source-code">    // environment. Locally, it should be URL=http://    localhost:3000</p>
			<p class="source-code"><strong class="bold">    shipping_address_collection,</strong></p>
			<p class="source-code"><strong class="bold">    shipping_options,</strong></p>
			<p class="source-code">      success_url: `${process.env.URL}/success`,</p>
			<p class="source-code">      cancel_url: `${process.env.URL}/cancel`,</p>
			<p class="source-code">  });</p>
			<p class="source-code">      res.status(201).json({ session });</p>
			<p class="source-code">}</p>
			<p>And we're done! We're now replying with a session object that contains the redirect URL to be used on the frontend to redirect the user to the Stripe-hosted checkout page.</p>
			<p>We can do that<a id="_idIndexMarker782"/> by<a id="_idIndexMarker783"/> moving back to our <strong class="source-inline">pages/cart.js</strong> page and adding the following function:</p>
			<p class="source-code">import loadStripe from '../lib/stripe';</p>
			<p class="source-code">// ...</p>
			<p class="source-code">export default function Cart() {</p>
			<p class="source-code">  // ...</p>
			<p class="source-code">  async function handlePayment() {</p>
			<p class="source-code">    const stripe = await loadStripe();</p>
			<p class="source-code">    const res = await fetch('/api/checkout', {</p>
			<p class="source-code">      method: 'POST',</p>
			<p class="source-code">      headers: {</p>
			<p class="source-code">        'Content-Type': 'application/json',</p>
			<p class="source-code">      },</p>
			<p class="source-code">      body: JSON.stringify({</p>
			<p class="source-code">        items,</p>
			<p class="source-code">      }),</p>
			<p class="source-code">    });</p>
			<p class="source-code">    const { session } = await res.json();</p>
			<p class="source-code">    await stripe.redirectToCheckout({</p>
			<p class="source-code">      sessionId: session.id,</p>
			<p class="source-code">    });</p>
			<p class="source-code">  }</p>
			<p class="source-code">  // ...</p>
			<p class="source-code">}</p>
			<p>As a very last thing, we<a id="_idIndexMarker784"/> only need to link this function to the <strong class="bold">Pay now</strong> button<a id="_idIndexMarker785"/> in the returning JSX for the <strong class="source-inline">Cart</strong> function:</p>
			<p class="source-code">// ...</p>
			<p class="source-code">&lt;Button colorScheme="blue" <strong class="bold">onClick={handlePayment}&gt;</strong></p>
			<p class="source-code">    Pay now</p>
			<p class="source-code">&lt;/Button&gt;</p>
			<p class="source-code">// ...</p>
			<p>We're finally ready to test out our checkout flow! Let's boot the development server, add a couple of products to the shopping basket, then go to the <strong class="bold">Cart</strong> section and click on the <strong class="bold">Pay now</strong> button. We should end up on this beautiful, Stripe-powered checkout page, where we can insert our shipping information, choose the desired payment method, and modify the quantity for each product we put in the cart:</p>
			<div>
				<div id="_idContainer059" class="IMG---Figure">
					<img src="image/Figure_13.7_B16985.jpg" alt="Figure 13.7 – The Stripe checkout page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.7 – The Stripe checkout page</p>
			<p>In my case, you can <a id="_idIndexMarker786"/>see<a id="_idIndexMarker787"/> that I've been redirected to a <strong class="bold">Michele Riva</strong> store (upper-left corner), as I opened my Stripe account using my name, but if you did the same and want to customize the store name, you can edit it on your Stripe dashboard.</p>
			<p>By clicking on the store name in the upper-left corner, we will be redirected to the <strong class="source-inline">cancel_url</strong> we set in the <strong class="source-inline">pages/api/checkout/index.js</strong> page; if we successfully complete a purchase, we will get redirected to <strong class="source-inline">success_url</strong>. I'll leave you the task<a id="_idIndexMarker788"/> of <a id="_idIndexMarker789"/>creating those two pages as a little homework to complete before moving on to the next chapter.</p>
			<h1 id="_idParaDest-138"><a id="_idTextAnchor137"/>Summary</h1>
			<p>In the previous sections, we saw how to create a straightforward e-commerce website using GraphCMS and Stripe, two incredible products that can help build scalable, secure, and maintainable storefronts.</p>
			<p>Even though we've made some significant progress during this chapter, we're still missing some features that would deserve an entire book on them exclusively.</p>
			<p>For example, if we now want to navigate back from the Stripe checkout to the cart page, we will see that our shopping cart is empty, as the cart context is not persistent. And what if we want to allow our users to create an account and see the shipping progress, order history, and other helpful information?</p>
			<p>As you can imagine, these are complex topics, and there's no way we can manage them in one chapter exclusively. One thing's for sure: once we know how to handle users and authentication via Auth0, product inventory and order history on GraphCMS, and checkout on Stripe, we have all the elements we need to create rock-solid user experiences and development workflows.</p>
			<p>The Vercel team also announced Next.js Commerce in the latest releases, a template ready to be attached to Shopify, Saleor, BigCommerce, and a few more e-commerce platforms to create a custom UI instantly for your storefront. The reason why we're not digging into that template is simple: it is compelling, but it abstracts most of the work that is needed to connect different systems (such as Stripe and GraphCMS, or PayPal and WordPress), and we want to understand how to do it ourselves for the sake of learning more.</p>
			<p>In this chapter, we saw how to integrate a headless CMS into our Next.js frontend. But if you found it easy, that's mainly because GraphCMS has been wisely built with the developer experience in mind, allowing us to take advantage of well-written GraphQL APIs built for the modern web era.</p>
			<p>We can't say that the same applies to other CMSs, born when the web was still young and evolving, maintaining a full-stack approach, where we used the CMS itself to build both the backend and the frontend of our applications. But today, even those older CMS platforms are evolving thanks to an incredible community effort, aiming to provide a great developer experience by allowing us to adopt Next.js (or any other framework) as a frontend. For example, there's a fantastic WordPress plugin that generates excellent GraphQL APIs from an existing website; that way, we can use WordPress as a complete headless CMS, creating a robust, performant, custom Next.js frontend. You can learn more about this plugin at https://www.wpgraphql.com. The same applies to Drupal, another popular, open source CMS that can expose GraphQL APIs thanks to the GraphQL module: <a href="https://www.drupal.org/project/graphql">https://www.drupal.org/project/graphql</a>.</p>
			<p>In the followingchapter, we will briefly recap what we've seen so far and see some example projects that we can build to practice more with Next.js.</p>
		</div>
	</body></html>