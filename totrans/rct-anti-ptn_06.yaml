- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Exploring Common Refactoring Techniques
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索常见的重构技术
- en: Welcome to the fascinating world of refactoring! In this chapter, we’re going
    to explore the basics of this fundamental practice, essential to every developer
    in maintaining and improving a code base. We aim to introduce you to the most
    common refactoring techniques, providing a solid foundation for understanding
    and employing these valuable tools. Remember, our objective is not to provide
    an exhaustive guide, but rather to familiarize you with the essentials that you’ll
    use time and time again in your programming journey.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到重构的迷人世界！在本章中，我们将探讨这一基本实践的基础知识，这对于每个开发者在维护和改进代码库方面都是至关重要的。我们的目标是让你熟悉这些最常见重构技术，为你理解和运用这些宝贵工具打下坚实的基础。记住，我们的目标不是提供详尽的指南，而是让你熟悉你在编程旅程中会反复使用的要点。
- en: Refactoring doesn’t discriminate among languages or frameworks – it’s a universal
    concept applicable anywhere you write code. The techniques we’ll discuss include
    renaming variables, changing function declarations, extracting functions, moving
    fields, and more. These techniques might appear simple at first glance, but they
    are incredibly powerful tools for crafting clean, understandable, and maintainable
    code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 重构不分语言或框架——它是一个通用的概念，适用于你编写代码的任何地方。我们将讨论的技术包括重命名变量、更改函数声明、提取函数、移动字段等。这些技术乍一看可能很简单，但它们是构建干净、易于理解、易于维护的代码的强大工具。
- en: Also remember that refactoring is not a one-time task, but rather an ongoing
    process of small, iterative changes that gradually enhance the structure and quality
    of your code. It is these frequent, incremental improvements that keep a code
    base healthy, robust, and easier to work with. By introducing you to the basics,
    we hope to equip you with the essential tools and techniques that will be a stepping
    stone toward more advanced refactoring methods.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记住，重构不是一个一次性任务，而是一个持续的小型、迭代性更改的过程，这些更改逐渐提高你代码的结构和质量。正是这些频繁的增量改进使代码库保持健康、健壮，并且更容易工作。通过介绍基础知识，我们希望为你提供必要的工具和技术，这些将成为更高级重构方法的垫脚石。
- en: While we’ll delve into more complex refactoring techniques in later chapters,
    the practices you’ll learn here will serve as a valuable starting point. By the
    end of this chapter, you’ll have a toolkit of common refactoring practices and
    a newfound understanding of their importance in enhancing code quality. Ultimately,
    the refactoring skills you begin to develop here will empower you to write cleaner,
    more efficient code, and set you on the path to becoming a more proficient developer.
    Let’s dive in!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们将在后面的章节中深入探讨更复杂的重构技术，但你在这里学到的实践将作为一个宝贵的起点。到本章结束时，你将拥有一个常见的重构实践工具包，以及对这些实践在提高代码质量方面重要性的新认识。最终，你在这里开始培养的重构技能将使你能够编写更干净、更高效的代码，并使你走上成为更熟练的开发者的道路。让我们开始吧！
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding refactoring
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解重构
- en: Adding tests before refactoring
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在重构前添加测试
- en: Using Rename Variable
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用重命名变量
- en: Using Extract Variable
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用提取变量
- en: Using Replace Loop with Pipeline
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用管道中的替换循环
- en: Using Extract Function
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用提取函数
- en: Using Introduce Parameter Object
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用引入参数对象
- en: Using Decompose Conditional
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用分解条件
- en: Using Move Function
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用移动函数
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: A GitHub repository has been created to host all the code we discuss in the
    book. For this chapter, you can find the recommended structure at [https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch6](https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch6).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 已创建一个GitHub仓库来托管本书中讨论的所有代码。对于本章，你可以在[https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch6](https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch6)找到推荐的结构。
- en: Before we dive into the refactorings, let’s align with some tooling that would
    help us to make changes easily. When it comes to refactoring tools, there are
    many **integrated development environments** (**IDEs**) and source code editors
    available in the frontend world – WebStorm and Visual Studio Code (VS Code) are
    the most popular ones that offer an impressive range of features, including robust
    refactoring capabilities.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入重构之前，让我们与一些有助于我们轻松进行更改的工具保持一致。当谈到重构工具时，前端世界中有很多**集成开发环境**（**IDEs**）和源代码编辑器可用——WebStorm和Visual
    Studio Code（VS Code）是最受欢迎的，它们提供了令人印象深刻的特性，包括强大的重构功能。
- en: '**WebStorm**, developed by JetBrains, is a powerful and feature-rich IDE specifically
    designed for JavaScript and its related technologies such as TypeScript, HTML,
    and CSS. One of its most notable features is its advanced automated refactoring,
    but it also offers an extensive list of refactoring options such as rename, extract,
    inline, move, and copy, which can be applied to variables, classes, functions,
    and other elements. It also has a smart duplication detection feature, helping
    you to locate and resolve repetitive blocks of code.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**WebStorm**，由JetBrains开发，是一个专为JavaScript及其相关技术（如TypeScript、HTML和CSS）设计的强大且功能丰富的IDE。其最显著的特点是其高级自动重构功能，但它还提供了一系列的重构选项，如重命名、提取、内联、移动和复制，这些选项可以应用于变量、类、函数和其他元素。它还具有智能重复代码检测功能，帮助你定位和解决重复的代码块。'
- en: '![Figure 6.1: The WebStorm IDE](img/B31103_06_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1：WebStorm IDE](img/B31103_06_01.jpg)'
- en: 'Figure 6.1: The WebStorm IDE'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：WebStorm IDE
- en: WebStorm’s IntelliSense, auto-complete, and code navigation are quite robust,
    giving you a lot of help when writing and exploring the code. However, WebStorm
    is a commercial product, and while it does offer a trial period, you will need
    to purchase a license for continued use.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: WebStorm的智能感知、自动完成和代码导航功能相当强大，在编写和探索代码时为你提供了很多帮助。然而，WebStorm是一个商业产品，尽管它提供试用版，但你仍需要购买许可证才能继续使用。
- en: '**Visual Studio Code** (**VS Code**), on the other hand, is a free, open source
    IDE developed by Microsoft. It’s lightweight compared to WebStorm and is known
    for its speed and flexibility. VS Code also supports a wide range of languages
    beyond JavaScript, thanks to its extension marketplace. Refactoring capabilities
    in VS Code are strong as well, with support for common operations such as renaming,
    extracting functions or variables, and changing function signatures. VS Code’s
    refactoring capabilities can be further enhanced by installing extensions, and
    its customizability is one of its key strengths.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**Visual Studio Code**（**VS Code**），另一方面，是由微软开发的一个免费、开源的集成开发环境（IDE）。与WebStorm相比，它更轻量级，以其速度和灵活性而闻名。由于拥有扩展市场，VS
    Code支持广泛的编程语言，而不仅仅是JavaScript。VS Code的重构功能也很强大，支持常见的操作，如重命名、提取函数或变量以及更改函数签名。通过安装扩展，VS
    Code的重构功能可以进一步增强，其可定制性是其关键优势之一。'
- en: '![Figure 6.2: VS Code](img/B31103_06_02.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2：VS Code](img/B31103_06_02.jpg)'
- en: 'Figure 6.2: VS Code'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：VS Code
- en: While VS Code may not have as many automated refactoring features as WebStorm
    out of the box, it can be tailored to match and sometimes exceed WebStorm’s capabilities
    through these extensions.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然VS Code可能没有WebStorm那么多的内置自动重构功能，但通过这些扩展，它可以定制以匹配甚至超越WebStorm的功能。
- en: Choosing between the two often boils down to personal preference and the specific
    needs of your project. If you value a highly automated, feature-rich environment
    and don’t mind paying for it, WebStorm might be your best bet. However, if you
    prioritize speed, flexibility, and customization and are comfortable setting up
    your environment through extensions, VS Code could be the better choice.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在两者之间进行选择通常归结为个人偏好和项目具体需求。如果你重视高度自动化的、功能丰富的环境，并且不介意为此付费，WebStorm可能是你的最佳选择。然而，如果你更看重速度、灵活性和定制性，并且愿意通过扩展来设置你的环境，那么VS
    Code可能是更好的选择。
- en: I prefer WebStorm as my IDE at work – part of the reason is I am already very
    familiar with the keymaps, and I love the built-in auto-refactoring capability.
    However, I still use VS Code for casual projects.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢WebStorm作为我的工作IDE——部分原因是我已经非常熟悉快捷键，并且我喜欢内置的自动重构功能。然而，我仍然使用VS Code进行休闲项目。
- en: Understanding refactoring
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解重构
- en: '**Refactoring** is a disciplined, systematic process of improving the design
    of an existing code base without changing its external behavior. It’s a fundamental
    aspect of everyday coding, a practice integral to the iterative and incremental
    nature of software development. The concept is universally applicable, and not
    bound to any specific programming language, framework, or paradigm. Whether you’re
    writing in JavaScript, Python, or any other language, and whether you’re using
    React, Angular, or a homegrown framework, refactoring is crucial to maintaining
    a healthy code base.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**重构**是一种有纪律、系统的过程，旨在在不改变现有代码库外部行为的情况下改进其设计。它是日常编码的基本方面，是软件开发迭代和增量特性的一个组成部分。这个概念具有普遍适用性，不受任何特定编程语言、框架或范式的限制。无论你是在编写JavaScript、Python还是其他任何语言，无论你是在使用React、Angular还是自建框架，重构对于维护健康的代码库至关重要。'
- en: 'The term “refactoring” was first introduced by William Opdyke and Ralph Johnson
    in a 1990 paper titled *Refactoring: An Aid in Designing Application Frameworks
    and Evolving Object-Oriented Systems*; however, the concept and practice of refactoring
    have roots in earlier practices in software engineering. The art of refactoring
    gained significant prominence with Martin Fowler’s book *Refactoring: Improving
    the Design of Existing Code*, published in 1999\. In this book, Fowler describes
    refactoring as “a controlled technique for improving the design of an existing
    code base,” emphasizing its role in mitigating the buildup of technical debt,
    which makes the code easier to understand, maintain, and extend.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 术语“重构”最初由威廉·奥普迪克和拉尔夫·约翰逊在1990年发表的一篇题为《重构：设计应用程序框架和演进面向对象系统的辅助工具》的论文中提出；然而，重构的概念和实践源于软件工程早期的实践。重构的艺术随着马丁·福勒1999年出版的书籍《重构：现有代码的设计改进》而获得了显著的关注。在这本书中，福勒将重构描述为“一种控制现有代码库设计的技巧”，强调其在减轻技术债务积累方面的作用，这使得代码更容易理解、维护和扩展。
- en: Refactoring isn’t about making one grand, sweeping change to perfect the code
    base. Instead, it’s about making small, incremental improvements consistently
    over time. Each individual change might not dramatically alter the quality of
    the code, but collectively, over time, these small changes can significantly enhance
    the structure, readability, and maintainability of the code base.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 重构不是关于对代码库进行一次重大、全面的改变以使其完美。相反，它是在一段时间内持续不断地进行小的、渐进的改进。每个单独的改变可能不会显著改变代码的质量，但集体来看，随着时间的推移，这些小的改变可以显著提高代码库的结构、可读性和可维护性。
- en: Although refactoring doesn’t add new functionality, it directly influences the
    team’s ability to deliver new features more quickly, with fewer bugs, and to respond
    more flexibly to changing requirements. By continuously refactoring, we keep our
    code clean and easy to work with and set the stage for long-term, sustainable
    development.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管重构不添加新功能，但它直接影响了团队快速交付新功能的能力，减少错误，并更灵活地应对变化的需求。通过持续重构，我们保持代码的整洁和易于操作，并为长期、可持续的发展奠定基础。
- en: In conclusion, refactoring is a critical tool in a developer’s toolkit, irrespective
    of the technology stack or the size and scope of the project. It’s a long-term
    investment in the code base and the team, and ultimately, it’s an investment in
    the quality of the software that is delivered.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，重构是开发者工具箱中的关键工具，无论技术栈或项目的规模和范围如何。它是代码库和团队的长期投资，最终，它是对交付的软件质量的投资。
- en: The common mistakes of refactoring
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构的常见错误
- en: The biggest mistake people make in refactoring is that they restructure code
    rather than refactoring it. The terms “refactoring” and “restructuring” are often
    used interchangeably, but they have distinct meanings in software development.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 人们在重构中犯的最大错误是将代码重构而不是重构代码。术语“重构”和“重构”经常被互换使用，但在软件开发中它们有截然不同的含义。
- en: '*Refactoring* is a disciplined technique for improving the design of an existing
    code base, making it cleaner and easier to understand and work with. It involves
    changing the internal structure of the software without modifying its external
    behavior. This is generally done in small steps, and each refactoring step is
    expected to maintain the software’s functionality. It doesn’t add new features;
    instead, it makes the code more readable, maintainable, and prepared for future
    changes.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*重构*是一种提高现有代码库设计的纪律性技术，使其更干净、更容易理解和操作。它涉及在不修改软件外部行为的情况下改变软件的内部结构。这通常以小步骤进行，并且每个重构步骤都应保持软件的功能。它不添加新功能；相反，它使代码更易于阅读、维护，并为未来的变化做好准备。'
- en: For example, in a React application, refactoring could involve breaking down
    a large component into smaller, more manageable components, or replacing complex
    conditional logic with a strategy pattern.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在一个React应用程序中，重构可能包括将一个大型组件拆分成更小、更易于管理的组件，或者用策略模式替换复杂的条件逻辑。
- en: '*Restructuring*, on the other hand, can be seen as a broader and more drastic
    process. It often involves large-scale changes that not only impact the internal
    structure of the software but can also affect its external behavior. Restructuring
    can encompass changes to the software’s architecture, data models, interfaces,
    and more. It is often driven by the need to introduce major changes or additions
    to the software’s features or capabilities, to improve performance, or to address
    significant technical debt.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，重构可以被视为一个更广泛、更彻底的过程。它通常涉及大规模的变更，不仅影响软件的内部结构，还可以影响其外部行为。重构可以包括对软件架构、数据模型、接口等方面的变更。它通常是由引入软件功能或能力的主要变更或添加、提高性能或解决重大技术债务的需求所驱动的。
- en: In the context of a React application, restructuring might involve changing
    the state management solution (such as moving from Redux to the React Context
    API), updating the routing mechanism, or transitioning from a monolithic architecture
    to a microfrontend architecture.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React 应用的背景下，重构可能包括更改状态管理解决方案（例如从 Redux 移动到 React Context API），更新路由机制，或者从单体架构过渡到微前端架构。
- en: While both refactoring and restructuring aim to improve the quality of the code
    base, refactoring is typically smaller in scope, involves no change in functionality,
    and is part of the regular development process. In contrast, restructuring is
    generally larger in scope, can change functionality, and is often part of a larger
    project or initiative to address more significant challenges or changes in requirements.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然重构和重构都旨在提高代码库的质量，但重构通常范围较小，不涉及功能变更，并且是常规开发过程的一部分。相比之下，重构通常范围更广，可以改变功能，并且通常是解决更重大挑战或需求变化的更大项目或倡议的一部分。
- en: As well as a misunderstanding between refactoring and restructuring, another
    mistake people tend to make is that they don’t test as often – sometimes this
    is because they don’t have many tests, while at other times they think it’s safe
    to make these “small” changes without testing. Let’s look at testing in the next
    section.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 除了重构和重构之间的误解之外，人们还倾向于犯的另一个错误是他们测试的频率不够高——有时这是因为他们没有很多测试，而有时他们认为在没有测试的情况下进行这些“小”改动是安全的。让我们在下一节中看看测试。
- en: Adding tests before refactoring
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在重构之前添加测试
- en: Because we don’t want to make any observable behavior changes during refactoring,
    we need to inspect the code to make sure we have enough tests to cover the current
    behavior. It’s easy to mess up without the right tests in place, and that’s not
    only risky but also less efficient, as we need to check the changed code manually
    and repeatedly.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不希望在重构期间造成任何可观察的行为变化，我们需要检查代码以确保我们有足够的测试来覆盖当前的行为。如果没有适当的测试，很容易出错，这不仅风险高，而且效率低，因为我们需要手动和反复地检查更改后的代码。
- en: 'Let’s say we have some TypeScript code from an online shopping application
    – the code works fine, but there aren’t any tests associated with it. To improve
    the code so that it’s easier to understand and extend, we need to refactor it:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一些来自在线购物应用程序的 TypeScript 代码——代码运行正常，但没有与之相关的测试。为了改进代码，使其更容易理解和扩展，我们需要对其进行重构：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: So, this code defines a shopping cart model. Firstly, it defines an `Item` interface,
    which represents an item to be added to the cart. An `Item` component consists
    of an ID, a price, and a quantity. Then, it defines a `ShoppingCart` class with
    a `cartItems` property, which is an array of `Item` objects, initially empty.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这段代码定义了一个购物车模型。首先，它定义了一个 `Item` 接口，它代表要添加到购物车中的项目。一个 `Item` 组件由一个 ID、一个价格和一个数量组成。然后，它定义了一个具有
    `cartItems` 属性的 `ShoppingCart` 类，该属性是一个 `Item` 对象的数组，最初为空。
- en: 'The `ShoppingCart` class has two methods:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShoppingCart` 类有两个方法：'
- en: The `addItemToCart` method accepts an ID, price, and quantity, and then creates
    an item using these parameters. This item is then added to the `cartItems` array.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addItemToCart` 方法接受一个 ID、价格和数量，然后使用这些参数创建一个项目。然后，这个项目被添加到 `cartItems` 数组中。'
- en: The `calculateTotal` method calculates the total price of the items in the cart.
    For each item, it multiplies the item’s price by its quantity to get a subtotal.
    If the quantity of the item is more than 10, a 10% discount is applied to the
    subtotal. The subtotal of each item is then added together to get the total. The
    total is then returned by the method.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calculateTotal` 方法计算购物车中商品的总价。对于每个商品，它将商品的价格乘以其数量以得到小计。如果商品的数量超过10个，则对小计应用10%的折扣。然后将每个商品的子计价相加以得到总价。该方法随后返回总价。'
- en: 'There are two important calculations here: compute the total price (price by
    quantity) and apply the discount when eligible. We normally should pay more attention
    to the logic regarding these calculations.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个重要的计算：计算总价（价格乘以数量）以及在适用的情况下应用折扣。我们通常应该更加关注这些计算的逻辑。
- en: 'For example, we need to verify both sides of an `if-else` statement. As we
    have `if-else` inside the `for` loop, we will at least need to add two test cases
    before making changes. Let’s add the following Jest tests to describe both calculations
    – with and without a discount:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们需要验证`if-else`语句的两边。由于我们在`for`循环内部有`if-else`，我们至少需要在做出更改之前添加两个测试用例。让我们添加以下Jest测试来描述两种计算情况——有折扣和无折扣：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first test, `calculates item prices`, is verifying that the `calculateTotal`
    method works as expected when no discounts are applied. Here, a `ShoppingCart`
    object is instantiated, and two items (`apple` and `orange`) are added to the
    cart. The total price of these items is calculated and expected to be 7.5, as
    there are two apples at $2 each and one orange at $3.5.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试“计算商品价格”，是验证在没有应用折扣的情况下`calculateTotal`方法是否按预期工作。在这里，创建了一个`ShoppingCart`对象，并向购物车中添加了两个商品（`apple`和`orange`）。这些商品的总价计算出来应该是7.5，因为有两个苹果，每个2美元，还有一个橙子，3.5美元。
- en: The second test, `applies discount when applicable`, is checking that the `calculateTotal`
    method correctly applies a 10% discount when the quantity of an item is more than
    10\. In this case, a `ShoppingCart` object is instantiated, and one type of item
    (`apple`) is added to the cart with quantity 11\. The total price of this item
    should be $19.8 after applying the 10% discount on the subtotal of $22 (11 apples
    at $2 each). The calculated total price is then checked against this expected
    value.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个测试“在适用时应用折扣”，是检查当商品的数量超过10个时，`calculateTotal`方法是否正确地应用了10%的折扣。在这种情况下，创建了一个`ShoppingCart`对象，并向购物车中添加了一种商品（`apple`），数量为11。在应用了10%折扣后的子计价22美元（11个苹果，每个2美元）后，该商品的总价应该是19.8美元。然后，计算出的总价与这个预期值进行比较。
- en: Once we have test cases to cover the important logic, we can safely make changes.
    During refactoring, we’ll need to run these tests regularly.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有测试用例来覆盖重要的逻辑，我们就可以安全地进行更改。在重构过程中，我们需要定期运行这些测试。
- en: 'Refactorings are small steps that can improve the code. Let’s have a look at
    our very first and maybe the simplest refactoring technique: **Rename Variable**.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 重构是小的步骤，可以提高代码质量。让我们看看我们非常第一个，也许是最简单的重构技术：**重命名变量**。
- en: Using Rename Variable
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用重命名变量
- en: Let’s start with a simple refactoring technique called Rename Variable. Rename
    Variable is a very straightforward yet effective method to improve the readability
    and maintainability of the code. It involves changing the name of a variable to
    better reflect its purpose and the data it holds, or to follow a certain naming
    convention or standard.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一种简单的重构技术“重命名变量”开始。重命名变量是一种非常直接且有效的方法，可以提高代码的可读性和可维护性。它涉及更改变量的名称，以更好地反映其目的和所持有的数据，或遵循某种命名约定或标准。
- en: Sometimes, during the initial phases of coding, developers might choose names
    for variables that make sense at that time, but as the code evolves, the purpose
    of the variable might change or become clearer. The variable name, however, often
    remains the same. This can cause confusion and make the code harder to understand
    and maintain. Renaming variables to describe their purposes more accurately can
    reduce the cognitive load for future readers of the code, including the future
    self of the current coder.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在编码的初期阶段，开发者可能会为变量选择当时有意义的名称，但随着代码的发展，变量的目的可能会改变或变得更加清晰。然而，变量名往往保持不变。这可能会导致混淆，并使代码更难以理解和维护。将变量重命名为更准确地描述其目的可以减少未来读者（包括当前开发者的未来自我）的认知负担。
- en: 'Let’s return to our `ShoppingCart` example. The variable name `cartItems` inside
    the `ShoppingCart` class is a little redundant; however, we can rename it to simply
    `items` to be more concise and clean:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的 `ShoppingCart` 示例。`ShoppingCart` 类内部的变量名 `cartItems` 稍显冗余；然而，我们可以将其重命名为
    `items` 以使其更加简洁和清晰：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After the change, make sure to run the tests again to see whether we accidentally
    made any mistakes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在更改后，请确保再次运行测试，以查看我们是否意外地犯了错误。
- en: It’s important to establish a habit of running tests regularly after making
    some changes, and whenever the tests fail, we need to stop and examine what is
    wrong. Once all the tests are back to passing, we can then proceed.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行一些更改后，定期运行测试并建立习惯是很重要的，并且每当测试失败时，我们需要停下来检查哪里出了问题。一旦所有测试都恢复正常通过，我们就可以继续进行。
- en: Using Extract Variable
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用提取变量
- en: '**Extract Variable** is a common refactoring technique that is used to improve
    the readability and maintainability of code. The process involves taking a section
    of code that calculates a value, replacing it with a new variable, and assigning
    the result of the original expression to this new variable. There is a similar
    refactoring called **Extract Constant** that can be used to extract a value that
    doesn’t change at runtime.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**提取变量**是一种常见的重构技术，用于提高代码的可读性和可维护性。这个过程涉及取一段计算值的代码，用一个新的变量替换它，并将原始表达式的结果分配给这个新变量。还有一种类似的重构称为**提取常量**，可以用来提取在运行时不改变的值。'
- en: This refactoring technique is particularly useful when you have a complex expression
    or a duplicated calculation; by extracting parts of the expression to variables
    with meaningful names, the code becomes more understandable and easier to manage.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这种重构技术在处理复杂表达式或重复计算时特别有用；通过将表达式的部分提取到具有有意义名称的变量中，代码变得更加易于理解和维护。
- en: 'In the `ShoppingCart` example, the `0.9` discount rate deserves its own name;
    we can extract a variable and reference it at the point where the function is
    called. As the value of the variable isn’t going to change at runtime, we can
    call it **Extract Constant** in this case:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ShoppingCart` 示例中，`0.9` 折扣率值得有一个自己的名字；我们可以在函数调用点提取一个变量并引用它。由于变量的值在运行时不会改变，我们可以在这种情况下将其称为**提取常量**：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For the sake of clarity, portions of the code that aren’t relevant to this particular
    change have been left out of the discussion; however, the important thing to note
    is that in this instance, we’ve created a constant named `DISCOUNT_RATE` and used
    it in place of the previous hard-coded value of `0.9` where it’s utilized in the
    code. At times, we may wish to assign a name to an expression other than a hard-coded
    value, so we can create a variable to stand in for the expression and then refer
    to that variable.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，讨论中省略了与此次特定更改无关的代码部分；然而，需要注意的是，在这个例子中，我们创建了一个名为 `DISCOUNT_RATE` 的常量，并在代码中使用它来替代之前硬编码的
    `0.9` 值。有时，我们可能希望给一个表达式而不是硬编码的值命名，因此我们可以创建一个变量来代表这个表达式，然后引用这个变量。
- en: It’s a tiny step, but it improves the code slightly. If we need to change the
    discount rate in the future, the constant name is much easier to search and understand
    than the hard-coded value of `0.9`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个小小的步骤，但它略微改进了代码。如果我们将来需要更改折扣率，常量名称比硬编码的 `0.9` 值更容易搜索和理解。
- en: Now we can investigate another refactoring technique to make the `for` loop
    a bit simpler.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以调查另一种重构技术，使 `for` 循环变得更加简单。
- en: Using Replace Loop with Pipeline
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用替换循环与管道
- en: The `map`, `filter`, and `reduce` in functional programming languages such as
    JavaScript.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在像 JavaScript 这样的函数式编程语言中的 `map`、`filter` 和 `reduce`。
- en: In the case of JavaScript, the Array prototype has methods such as `map`, `filter`,
    and `reduce` that can be chained together to form a pipeline. Each of these methods
    receives a function as an argument and applies this function to each element in
    the array, effectively transforming the array in some manner.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 的情况下，数组原型有 `map`、`filter` 和 `reduce` 等方法，可以将它们链接起来形成一个管道。这些方法中的每一个都接收一个函数作为参数，并将此函数应用于数组中的每个元素，从而以某种方式有效地转换数组。
- en: However, keep in mind that while replacing loops with pipelines can make the
    code cleaner and more readable, it might not always be the most efficient option,
    especially when dealing with very large datasets. So, as with all refactorings,
    you need to balance readability and maintainability with performance requirements
    in cases when you need to iterate through a large dataset multiple times.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，虽然用管道替换循环可以使代码更简洁、更易读，但这可能并不总是最有效的方法，尤其是在处理非常大的数据集时。因此，就像所有重构一样，在需要多次遍历大型数据集的情况下，你需要平衡可读性和可维护性与性能要求。
- en: 'The `for` loop in the previous section can be replaced by the `reduce` function
    (and we don’t have to explicitly define an index variable or save the boilerplate
    code):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中的`for`循环可以用`reduce`函数（我们不需要显式定义索引变量或保存样板代码）来替换：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `calculateTotal()` method is using the `reduce()` function to calculate
    the total price of the items in the shopping cart. The `reduce()` function is
    a higher-order function that applies a function against an accumulator and each
    element in the array (from left to right) to reduce it to a single output value.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculateTotal()`方法正在使用`reduce()`函数来计算购物车中物品的总价。`reduce()`函数是一个高阶函数，它将一个函数应用于累加器和数组中的每个元素（从左到右），以将其减少到单个输出值。'
- en: The total starts at 0 and then for each item in the shopping cart, it adds the
    `subTotal` variable of that item to the total. The `subTotal` variable is calculated
    by multiplying the price and quantity of each item.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 总计从0开始，然后对于购物车中的每一项，都会将该项目的`subTotal`变量加到总计中。`subTotal`变量是通过乘以每个项目的价格和数量来计算的。
- en: Next, we need to re-run all the tests to check whether everything goes well.
    As our tests are still passing, let’s see how we can make the code even better
    by extracting lines into a smaller function.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要重新运行所有测试，以检查一切是否顺利。由于我们的测试仍然通过，让我们看看如何通过将行提取到更小的函数中来使代码更加完善。
- en: Using Extract Function
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用提取函数
- en: '**Extract Function** is a refactoring technique that helps to improve code
    readability and maintainability by breaking down a large or complex function into
    smaller, more manageable parts.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**提取函数**是一种重构技术，通过将大型或复杂的函数分解成更小、更易于管理的部分，有助于提高代码的可读性和可维护性。'
- en: Let’s say you come across a function that’s performing multiple tasks. Maybe
    it’s doing some data validation, then some computations, and finally logging the
    result or updating some state. The function is long and complex, making it hard
    to understand at a glance what it’s doing. Extract Function refactoring is all
    about identifying those distinct pieces of functionality, pulling them out into
    their own separate functions, and then calling those new functions from the original
    one.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你遇到一个执行多个任务的函数。也许它正在进行一些数据验证，然后进行一些计算，最后记录结果或更新某些状态。这个函数很长且复杂，使得一眼看去很难理解它在做什么。提取函数重构就是关于识别那些不同的功能部分，将它们拉出到它们自己的独立函数中，然后从原始函数中调用这些新函数。
- en: One key benefit is that it makes the code more self-documenting. If you extract
    a part of your function to a new function and give it a meaningful name, it can
    often make the code much easier to understand since the function name can describe
    what the code is doing. It also improves the reusability of the code, since these
    smaller functions can be reused elsewhere if needed.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一个关键的好处是它使代码更具自文档性。如果你将函数的一部分提取到新的函数中并给它一个有意义的名称，它通常可以使代码更容易理解，因为函数名可以描述代码正在做什么。它还提高了代码的可重用性，因为这些较小的函数如果需要可以在其他地方重用。
- en: 'The logic of how to calculate the `subTotal` variable can be extracted from
    `calculateTotal` as a separate unit:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 计算如何计算`subTotal`变量的逻辑可以从`calculateTotal`中提取为一个独立的单元：
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this code snippet, we see the result of an Extract Function refactoring.
    The logic to apply a discount if the item quantity is greater than 10 has been
    extracted into its own function named `applyDiscountIfEligible`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们看到提取函数重构的结果。如果项目数量大于10，应用折扣的逻辑已经被提取到名为`applyDiscountIfEligible`的独立函数中。
- en: In the `ShoppingCart` class, the `calculateTotal` method calculates the total
    price of the items in the cart using the `reduce` function. For each item, it
    computes the subtotal as the product of the item’s price and quantity, then adds
    this subtotal (after applying any eligible discount) to the total.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ShoppingCart` 类中，`calculateTotal` 方法使用 `reduce` 函数计算购物车中物品的总价。对于每个物品，它计算小计作为物品价格和数量的乘积，然后将这个小计（在应用任何符合条件的折扣后）加到总金额上。
- en: The `applyDiscountIfEligible` function takes an item and its quantity as arguments.
    If the quantity of the item is more than 10, it applies a discount rate (represented
    by `DISCOUNT_RATE`) to the argument `subTotal`; otherwise, it simply returns the
    argument `subTotal` as it is.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`applyDiscountIfEligible` 函数接受一个物品及其数量作为参数。如果物品的数量超过10，它将对参数 `subTotal` 应用折扣率（表示为
    `DISCOUNT_RATE`）；否则，它简单地返回参数 `subTotal` 而不改变。'
- en: This refactoring makes the `calculateTotal` method more concise and easier to
    read, by abstracting away the details of how discounts are applied into a separate,
    appropriately named function.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将如何应用折扣的细节抽象到单独的、适当命名的函数中，这种重构使 `calculateTotal` 方法更加简洁且易于阅读。
- en: Let’s look at another refactoring method that could make the passed-in parameter
    easy to modify.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一种重构方法，可以使传入的参数更容易修改。
- en: Using Introduce Parameter Object
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用引入参数对象
- en: '**Introduce Parameter Object** is a refactoring technique used when a function
    has a large number of parameters, or when multiple functions share the same parameters.
    In this technique, you group related parameters into a single object and pass
    that object to the function instead.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**引入参数对象** 是一种重构技术，用于函数有大量参数或多个函数共享相同参数时。在这种技术中，你将相关的参数组合成一个单一的对象，并将其传递给函数。'
- en: A large number of parameters in a function can be confusing and difficult to
    manage. Grouping related parameters together into an object can increase code
    readability and make it easier to understand what the function does. It also makes
    the function call simpler and cleaner. Furthermore, if the same group of parameters
    is used in multiple function calls, this technique reduces the chances of passing
    parameters in the wrong order.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 函数中有大量参数可能会令人困惑且难以管理。将相关的参数组合成一个对象可以增加代码的可读性，并使理解函数的功能更容易。这还使函数调用更简单、更清晰。此外，如果同一组参数在多个函数调用中使用，这种技术可以减少传递参数顺序错误的机会。
- en: 'For example, consider a `calculateTotalPrice(quantity, price, discount)` function.
    We could refactor this using the Introduce Parameter Object technique to become
    `calculateTotalPrice({ quantity, price, discount })`. Now, the `quantity`, `price`,
    and `discount` parameters are grouped together into an object (with type `Item`),
    like so:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个 `calculateTotalPrice(quantity, price, discount)` 函数。我们可以使用引入参数对象技术对其进行重构，变为
    `calculateTotalPrice({ quantity, price, discount })`。现在，`quantity`、`price` 和 `discount`
    参数被组合成一个对象（类型为 `Item`），如下所示：
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: On top of these benefits, Introduce Parameter Object refactoring can often reveal
    or inspire domain concepts that were previously hidden and implicit in your code.
    The parameter object might become a class of its own, with its own behavior and
    data manipulation methods. This can lead to more object-oriented and encapsulated
    code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些好处，引入参数对象重构通常可以揭示或激发之前在代码中隐藏和隐含的领域概念。参数对象可能成为一个具有自己行为和数据操作方法的类。这可能导致更面向对象和封装的代码。
- en: Next, let’s explore another refactoring technique designed to streamline your
    `if-else` statements and enhance code readability.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们探索另一种重构技术，旨在简化你的 `if-else` 语句并提高代码可读性。
- en: Using Decompose Conditional
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用分解条件
- en: '`if-else` or `switch`) is extracted into separate functions. This technique
    helps to improve the readability of the code, making it more understandable.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `if-else` 或 `switch`）提取到单独的函数中。这种技术有助于提高代码的可读性，使其更易于理解。
- en: The condition, `if` clause, and `else` clause (if it exists) all get their own
    function. These functions are then named according to what they do or what they
    are checking for. This refactoring is beneficial because it replaces code that
    might need comments to understand with well-named functions, making the code self-explanatory.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 条件、`if` 子句和 `else` 子句（如果存在）都各自有自己的函数。然后根据它们所做的工作或它们所检查的内容来命名这些函数。这种重构的好处是，它用有良好命名的函数替换了可能需要注释来理解的代码，使代码更具自解释性。
- en: 'For example, the logic in the `applyDiscountIfEligible` function can actually
    be simplified by this refactoring; we can extract a small function called `isDiscountEligible`
    to replace the `item.quantity > 10` check, like in the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this code snippet, the extraction of logic into a separate function might
    appear superfluous because it adds an additional function call. However, it enhances
    readability and reusability:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this code snippet, we’ve separated the logic that determines whether an item
    is eligible for a discount into a standalone `isDiscountEligible` function. This
    extraction makes our `applyDiscountIfEligible` function cleaner and its intention
    more evident. Additionally, it allows for the `isDiscountEligible` logic to be
    updated independently if needed in the future, improving maintainability.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: After extracting these smaller functions, they don’t have to reside in the current
    file. We can relocate them to a separate module and import them as needed; this
    not only shortens the length of the current module but also improves its readability.
    Let’s look at that next.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Using Move Function
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Move Function** is a refactoring method that involves changing the location
    of a function to a more suitable or appropriate place. This could be within the
    same class, to a different class, or even to a separate module. The objective
    of this method is to enhance the readability, maintainability, and structure of
    the code by ensuring that functions are placed where they logically fit best.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: This kind of refactoring becomes necessary when the responsibilities of your
    classes evolve over time. You might find that a function makes more sense in a
    different class, or perhaps you have a group of functions within a class that
    work together and would be better suited in their own class or module.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Move Function refactoring can help reduce the complexity of the class by moving
    functions to the places where their functionality is most relevant or required.
    This promotes the principle of cohesion where related code is kept together. It
    also aids in achieving loose coupling by minimizing unnecessary dependencies between
    different parts of the code.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `ShoppingCart` component, we can move the type definition into a new
    file called `types.ts`. We can also move `DISCOUNT_RATE`, `isDiscountEligible`,
    and `applyDiscountIfEligible` into a separate file called `utils.ts`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that in the code, only `applyDiscountIfEligible` is a public function and
    can be accessed outside of the file. This refactoring also improves the encapsulation
    of the code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'After Move Function is used, the `ShoppingCart` component is simplified significantly
    and only has the necessary parts:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As with all refactoring, care should be taken when moving functions to ensure
    that the overall behavior of the system is not altered. Tests should be in place
    to verify that the functionality remains the same after refactoring.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focused on a variety of code refactoring techniques that are essential
    to maintaining and improving the structure, readability, and maintainability of
    your code base.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍了各种代码重构技术，这些技术对于维护和改进代码库的结构、可读性和可维护性至关重要。
- en: The refactoring techniques introduced include Rename Variable, which enhances
    code clarity by using more descriptive variable names, Extract Variable, which
    simplifies complex expressions by breaking them into smaller, more manageable
    parts, and Replace Loop with Pipeline, which transforms traditional `for`/`while`
    loops into more concise, declarative higher-order functions such as `map`, `filter`,
    and `reduce`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍的重构技术包括：重命名变量，通过使用更具描述性的变量名来提高代码清晰度；提取变量，通过将复杂表达式分解成更小、更易于管理的部分来简化表达式；以及用管道替换循环，将传统的`for`/`while`循环转换为更简洁、声明式的更高阶函数，如`map`、`filter`和`reduce`。
- en: As well as this, Extract Function encourages code modularity and reusability
    by breaking down large functions into smaller ones, each with a single, well-defined
    responsibility, while Introduce Parameter Object groups related parameters into
    a single object, thereby reducing the complexity of function signatures. Plus,
    Decompose Conditional breaks down complex conditional logic into separate functions,
    enhancing readability, and Move Function ensures that functions are placed in
    the most logical and appropriate location in your code base, promoting high cohesion
    and loose coupling.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，提取函数通过将大函数分解成更小的函数，每个函数都有单一、明确的职责，来鼓励代码模块化和可重用性，而引入参数对象将相关参数组合成一个单一对象，从而简化函数签名。此外，分解条件将复杂的条件逻辑分解成单独的函数，提高可读性，移动函数确保函数被放置在代码库中最合理和适当的位置，促进高内聚和松耦合。
- en: Throughout all these techniques, we emphasized the importance of maintaining
    the same overall system behavior and relying on tests to ensure that functionality
    remains consistent despite refactoring. These methods, when properly applied,
    can lead to a more understandable, easier to maintain, and more robust code base.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些技术中，我们强调了保持相同整体系统行为和依赖测试来确保功能在重构后保持一致性的重要性。这些方法如果正确应用，可以导致代码库更加易于理解、易于维护和更健壮。
- en: In the next chapter, we will explore an exceptional approach to enhancing the
    quality of our code – the method known as test-driven development.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨一种提升代码质量卓越的方法——被称为测试驱动开发的方法。
