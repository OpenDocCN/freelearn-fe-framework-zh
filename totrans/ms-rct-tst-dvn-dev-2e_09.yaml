- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Form Validation
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单验证
- en: For many programmers, TDD makes sense when it involves *toy* programs that they
    learn in a training environment. But they find it hard to join the dots when they
    are faced with the complexity of *real-world* programs. The purpose of this part
    of this book is for you to apply the techniques you’ve learned to real-world applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多程序员来说，TDD在涉及他们在培训环境中学习的*玩具*程序时是有意义的。但当面对*现实世界*程序的复杂性时，他们发现很难将这些点连接起来。本书的这一部分的目的就是让你将学到的技术应用到现实世界的应用中。
- en: This chapter takes a somewhat self-indulgent journey into form validation. Normally,
    with React, you’d reach for a ready-made form library that handles validation
    for you. But in this chapter, we’ll hand-craft our own validation logic, as an
    example of how real-world complexity can be conquered with TDD.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将带我们进行一次关于表单验证的自我放纵之旅。通常，使用React，你会寻找一个现成的表单库来处理验证。但在这个章节中，我们将亲手制作自己的验证逻辑，作为一个例子，说明如何用TDD克服现实世界的复杂性。
- en: 'You will uncover an important architectural principle when dealing with frameworks
    such as React: take every opportunity to move logic out of framework-controlled
    components and into plain JavaScript objects.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理像React这样的框架时，你将发现一个重要的架构原则：抓住每一个机会将逻辑从框架控制的组件中移出，放入普通的JavaScript对象中。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Performing client-side validation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行客户端验证
- en: Handling server errors
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理服务器错误
- en: Indicating form submission status
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指示表单提交状态
- en: By the end of the chapter, you’ll have seen how tests can be used to introduce
    validation into your React forms.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将看到如何使用测试将验证引入你的React表单中。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code files for this chapter can be found here:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在这里找到：
- en: '[https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter09](https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter09)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter09](https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter09)'
- en: Performing client-side validation
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行客户端验证
- en: In this section, we’ll update the `CustomerForm` and `AppointmentForm` components
    so that they alert the user to any issues with the text they’ve entered. For example,
    if they enter non-digit characters into the phone number field, the application
    will display an error.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将更新`CustomerForm`和`AppointmentForm`组件，以便它们向用户提醒他们输入文本中可能存在的问题。例如，如果他们在电话号码字段中输入非数字字符，应用程序将显示错误。
- en: We’ll listen for the DOM’s `blur` event on each field to take the current field
    value and run our validation rules on it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将监听每个字段的DOM的`blur`事件，以获取当前字段值并对其运行验证规则。
- en: 'Any validation errors will be stored as strings, such as `First name is required`,
    within a `validationErrors` state variable. Each field has a key in this object.
    An undefined value (or absence of a value) represents no validation error, and
    a string value represents an error. Here’s an example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 任何验证错误都将存储为字符串，例如`First name is required`，在`validationErrors`状态变量中。每个字段在这个对象中都有一个键。未定义的值（或值的缺失）表示没有验证错误，而字符串值表示一个错误。以下是一个示例：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This error is rendered in the browser like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误在浏览器中显示如下：
- en: '![Figure 9.1 – Validation errors displayed to the user ](img/Figure_9.01_B18423.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – 显示给用户的验证错误](img/Figure_9.01_B18423.jpg)'
- en: Figure 9.1 – Validation errors displayed to the user
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 显示给用户的验证错误
- en: To support tests that manipulate the keyboard focus, we need a new function
    that simulates the `focus` and `blur` events being raised when the user completes
    a field value. We’ll call this function `withFocus`. It wraps a test-supplied
    action (such as changing the field value) with the `focus`/`blur` events.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持操作键盘焦点的测试，我们需要一个新函数来模拟当用户完成字段值时引发的`focus`和`blur`事件。我们将把这个函数命名为`withFocus`。它将测试提供的操作（例如更改字段值）与`focus`/`blur`事件包装起来。
- en: This section will start by checking that the `CustomerForm` first name field
    is supplied. Then, we’ll generalize that validation so that it works for all three
    fields in the form. After that, we’ll ensure validation also runs when the submit
    button is pressed. Finally, we’ll extract all the logic we’ve built into a separate
    module.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将首先检查`CustomerForm`的姓名字段是否提供。然后，我们将使这个验证通用化，使其适用于表单中的所有三个字段。之后，我们将确保在按下提交按钮时也运行验证。最后，我们将把构建的所有逻辑提取到一个单独的模块中。
- en: Validating a required field
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证必填字段
- en: Each of the three fields on our page – `firstName`, `lastName`, and `phoneNumber`
    – are required fields. If a value hasn’t been provided for any of the fields,
    the user should see a message telling them that. To do that, each of the fields
    will have an alert message area, implemented as a `span` with an ARIA role of
    `alert`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们页面上的三个字段——`firstName`、`lastName` 和 `phoneNumber`——都是必填字段。如果任何字段没有提供值，用户应该看到一个消息告诉他们这一点。为此，每个字段都将有一个警告消息区域，实现为一个具有
    ARIA 角色 `alert` 的 `span`：
- en: 'Let’s begin by adding that alert for the `firstName` field, and then making
    it operational by validating the field when the user removes focus:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先添加 `firstName` 字段的警告，然后通过在用户移除焦点时验证字段来使其生效：
- en: 'Add the following new test to the bottom of the `CustomerForm` test suite.
    It should be within a new nested `describe` block named `validation`. This test
    checks that an alert space has been rendered. Notice the CSS selector: it’s a
    bit of a hack. We’re primarily interested in finding an element that matches `[role=alert]`.
    However, we are also qualifying it with the `firstNameError` ID since we’ll eventually
    have multiple alert spaces – one for each field:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下新测试添加到 `CustomerForm` 测试套件的底部。它应该在一个名为 `validation` 的新嵌套 `describe` 块中。此测试检查是否已渲染一个警告空间。注意
    CSS 选择器：这有点像是一个技巧。我们主要感兴趣的是找到一个匹配 `[role=alert]` 的元素。然而，我们还在 `firstNameError`
    ID 上进行了限定，因为我们最终会有多个警告空间——每个字段一个：
- en: '[PRE1]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To make that pass, move to `src/CustomerForm.js` and add the following `span`
    definition, just below the `firstName` input field:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使那个通过，请转到 `src/CustomerForm.js` 并在 `firstName` 输入字段下方添加以下 `span` 定义：
- en: '[PRE2]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we want to check that the field has an `aria-describedby` field that
    points to the error alert. This helps screen readers understand the content of
    the page. Add the following new test at the bottom of the test suite:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们想要检查该字段是否有一个指向错误警告的 `aria-describedby` 字段。这有助于屏幕阅读器理解页面内容。在测试套件的底部添加以下新测试：
- en: '[PRE3]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To make that pass, add the `aria-describedby` attribute to the `firstName`
    field definition:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使这个通过，请将 `aria-describedby` 属性添加到 `firstName` 字段定义中：
- en: '[PRE4]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The next test we’ll write will use the blur DOM event to trigger validation.
    For this test, we’ll start by building a new test extension, `withFocus`, which
    calls the `focus` event to ensure the target element has focus, then runs an action
    – such as entering text into the focused field – and ends by invoking the `blur`
    event. In `test/reactTestExtensions.js`, add the following definition for the
    `withFocus` function:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将要编写的下一个测试将使用失焦 DOM 事件来触发验证。为此测试，我们将首先构建一个新的测试扩展，`withFocus`，它调用 `focus` 事件以确保目标元素有焦点，然后运行一个动作——例如在聚焦的字段中输入文本——最后调用
    `blur` 事件。在 `test/reactTestExtensions.js` 中，为 `withFocus` 函数添加以下定义：
- en: '[PRE5]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The focus and blur sequence
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 聚焦和失焦序列
- en: The initial call to `focus` is needed because if the element isn’t focused,
    JSDOM will think that `blur` has nothing to do.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 初始调用 `focus` 是必要的，因为如果元素没有聚焦，JSDOM 会认为 `blur` 没有关系。
- en: 'In `test/CustomerForm.test.js`, import the new `withFocus` function:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `test/CustomerForm.test.js` 中，导入新的 `withFocus` 函数：
- en: '[PRE6]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add the following new test at the bottom of the test suite (still inside the
    `validation` nested `describe` block). It checks that if the user enters a blank
    name value, they’ll see a message telling them that a value is required:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试套件的底部（仍然在 `validation` 嵌套 `describe` 块中）添加以下新测试。它检查如果用户输入一个空白名称值，他们会看到一个消息告诉他们需要一个值：
- en: '[PRE7]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To make this pass, we need to hardcode the message:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使这个通过，我们需要硬编码消息：
- en: '[PRE8]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let’s triangulate to replace the hardcoding. The following test asserts that
    the alert message is initially blank. Notice the use of `toEqual` rather than
    `not.toContainText`: this is forward planning. When we come to generalize this
    function in the next section, the alert text could be anything:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过替换硬编码来定位。以下测试断言警告消息最初是空的。注意使用 `toEqual` 而不是 `not.toContainText`：这是前瞻性规划。当我们来到下一节中泛化此函数时，警告文本可以是任何内容：
- en: '[PRE9]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A matcher for empty text content
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 空文本内容的匹配器
- en: Although not covered in this book, this would be a good opportunity to build
    a new matcher such as `toHaveNoText`, or maybe `not.toContainAnyText`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这本书没有涵盖，但这将是构建一个新的匹配器，如 `toHaveNoText` 或 `not.toContainAnyText` 的好机会。
- en: 'To make this test pass, we’ll add support for running validation rules within
    `CustomerForm`. Start by adding the following inline function definition at the
    top of `src/CustomerForm.js`, just below the imports but above the `CustomerForm`
    component definition. This is our first validation rule, `required`, which returns
    an error string if the supplied value is empty, and `undefined` otherwise:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使这个测试通过，我们将在 `CustomerForm` 中添加运行验证规则的支持。首先，在 `src/CustomerForm.js` 的顶部添加以下内联函数定义，位于导入语句下方但
    `CustomerForm` 组件定义上方。这是我们第一个验证规则，`required`，如果提供的值是空的，则返回一个错误字符串，否则返回 `undefined`：
- en: '[PRE10]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Within the `CustomerForm` component, define a `validationErrors` state variable,
    initially set to an empty object:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `CustomerForm` 组件中，定义一个 `validationErrors` 状态变量，初始设置为空对象：
- en: '[PRE11]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create a handler function inside `CustomerForm` that can be used when the user
    switches focus away from the first name field. It runs the `required` validation
    we defined in the first step, and then saves the response in the `validationErrors`
    state object:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `CustomerForm` 中创建一个处理函数，当用户从名字字段切换焦点时可以使用。它运行我们在第一步中定义的 `required` 验证，然后将响应保存到
    `validationErrors` 状态对象中：
- en: '[PRE12]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, define a function that the JSX will use to choose which message to display,
    named `hasFirstNameError`:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，定义一个函数，JSX 将使用它来选择要显示的消息，命名为 `hasFirstNameError`：
- en: '[PRE13]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'All that’s left is to modify our JSX so that it invokes the validation logic,
    and then displays the validation error. Use the following code to set the `onBlur`
    handler on the existing input field for `firstName` and to render the error text
    just after it. After this change, your test should be passing:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 剩下的只是修改我们的 JSX，使其调用验证逻辑，然后显示验证错误。使用以下代码设置现有输入字段 `firstName` 的 `onBlur` 处理程序，并在其后渲染错误文本。在此更改后，你的测试应该通过：
- en: '[PRE14]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You now have a completed, working system for validating the first name field.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完成了一个用于验证名字字段的完整、可工作的系统。
- en: Generalizing validation for multiple fields
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为多个字段泛化验证
- en: Next, we’ll add the required validation to the last name and phone number fields.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加对姓氏和电话号码字段的必要验证。
- en: Since we’re on green, we can refactor our existing code *before* we write the
    next test. We will update the JSX and the `hasFirstNameError` and `handleBlur`
    functions so that they work for all the fields on the form.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在处于绿色状态，我们可以在编写下一个测试之前重构现有的代码。我们将更新 JSX 以及 `hasFirstNameError` 和 `handleBlur`
    函数，以便它们适用于表单上的所有字段。
- en: 'This will be an exercise in systematic refactoring: breaking the refactoring
    down into small steps. After each step, we’re aiming for our tests to still be
    green:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个系统重构的练习：将重构分解成小步骤。在每个步骤之后，我们都在努力使测试保持绿色：
- en: 'First, we’ll extract a function containing a JSX snippet for rendering errors.
    Just above the JSX return value in `CustomerForm`, add a new function named `renderFirstNameError`
    with the following content:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将提取一个包含 JSX 片段的函数，用于渲染错误。在 `CustomerForm` 中的 JSX 返回值上方添加一个名为 `renderFirstNameError`
    的新函数，内容如下：
- en: '[PRE15]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, you can use that in the JSX to replace the `span` alert. Your tests should
    still be passing at each step:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以在 JSX 中使用它来替换 `span` 警报。你的测试在每个步骤中都应该通过：
- en: '[PRE16]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we’ll introduce a parameter into this function that will reference the
    ID of the field we’re showing the error from. Adjust the line you just added to
    introduce that new parameter:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将向此函数引入一个参数，该参数将引用我们显示错误字段的 ID。调整你刚刚添加的行以引入新参数：
- en: '[PRE17]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Always having green tests – JavaScript versus TypeScript
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 总是保持绿色测试 – JavaScript 与 TypeScript
- en: This section is written in a way that your tests should still be passing at
    every step. In the preceding step, we passed a parameter to `renderFirstNameError`
    that the function can’t accept yet. In JavaScript, this is perfectly fine. In
    TypeScript, you’ll get a type error when attempting to build your source.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '这一节是以一种方式编写的，你的测试应该在每一步都通过。在上一个步骤中，我们向 `renderFirstNameError` 函数传递了一个函数无法接受的参数。在
    JavaScript 中，这是完全正常的。在 TypeScript 中，当你尝试构建源代码时，你会得到一个类型错误。 '
- en: 'Introduce that parameter into the `renderFirstNameError` function as follows,
    replacing occurrences of the `firstName` string with the `fieldName` variable.
    Your tests should still be passing after this change:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将该参数引入 `renderFirstNameError` 函数中，如下所示，用 `fieldName` 变量替换 `firstName` 字符串。在此更改后，你的测试应该仍然通过：
- en: '[PRE18]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Repeat the same process for the `hasFirstNameError` function by adding a parameter
    value:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加参数值重复相同的步骤为 `hasFirstNameError` 函数：
- en: '[PRE19]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add the `fieldName` parameter to `hasFirstNameError` and modify the function
    body so that it uses the parameter in place of the `firstName` error property:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`fieldName`参数添加到`hasFirstNameError`中，并修改函数体，使其使用参数代替`firstName`错误属性：
- en: '[PRE20]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, rename `renderFirstNameError` so that it becomes `renderError` and
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`renderFirstNameError`重命名为`renderError`，
- en: '`hasFirstNameError` so that it becomes `hasError`.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 将`hasFirstNameError`重命名为`hasError`。
- en: Refactoring support in your IDE
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的IDE中的重构支持
- en: Your IDE may have renaming support built in. If it does, you should use it.
    Automated refactoring tools lessen the risk of human error.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你的IDE可能内置了重命名支持。如果有的话，你应该使用它。自动重构工具可以减少人为错误的风险。
- en: 'Let’s tackle `handleBlur`. We’re already passing the `target` parameter, and
    we can use `target.name` to key into a map that then tells us which validator
    to run for each field:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们处理`handleBlur`。我们已经在传递`target`参数，我们可以使用`target.name`来键入一个映射，然后告诉我们为每个字段运行哪个验证器：
- en: '[PRE21]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, the first half of the function (the definition of `validators`)
    is now static data that defines how the validation should happen for `firstName`.
    This object will be extended later, with the `lastName` and `phoneNumber` fields.
    The second half is generic and will work for any input field that’s passed in,
    so long as a validator exists for that field.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，函数的前半部分（`validators`的定义）现在是静态数据，它定义了`firstName`的验证应该如何发生。这个对象将在以后扩展，包括`lastName`和`phoneNumber`字段。后半部分是通用的，将适用于任何传入的输入字段，只要存在该字段的验证器。
- en: 'The `required` validator is hardcoded with the first name description. Let’s
    pull out the entire message as a variable. We can create a higher-order function
    that returns a validation function that uses this message. Modify `required` so
    that it looks as follows:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`required`验证器硬编码了第一个名字的描述。让我们将整个消息作为一个变量提取出来。我们可以创建一个高阶函数，它返回一个使用此消息的验证函数。修改`required`，使其看起来如下：'
- en: '[PRE22]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, update the validator so that it calls this new required function:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，更新验证器，使其调用这个新的必需函数：
- en: '[PRE23]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'At this point, your tests should be passing and you should have a fully generalized
    solution. Now, let’s generalize the tests too, by converting our four validation
    tests into test generator functions:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你的测试应该通过，你应该有一个完全通用的解决方案。现在，让我们通过将我们的四个验证测试转换为测试生成器函数来通用化测试：
- en: 'Define a new `errorFor` helper at the top of the `validations` nested `describe`
    block. This will be used in the test generators:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`validations`嵌套的`describe`块顶部定义一个新的`errorFor`辅助函数。这将在测试生成器中使用：
- en: '[PRE24]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Find the first test you’ve written in this section (`renders an alert space...`).
    Modify it, as shown here, by wrapping it in a function definition that takes a
    `fieldName` parameter. Use that parameter in the test description and the expectation,
    replacing the use of `firstName`, and making use of the new `errorFor` helper
    to find the appropriate field:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本节中找到你编写的第一个测试（`渲染一个警告空间...`）。按照这里所示，通过将其包裹在一个函数定义中来修改它，该函数定义接受一个`fieldName`参数。在测试描述和期望中使用该参数，替换`firstName`的使用，并利用新的`errorFor`辅助函数来查找适当的字段：
- en: '[PRE25]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Since you’ve now lost the test for the first name, add that back in with a
    call to the new test generator, just below it:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于你现在丢失了第一个名字的测试，使用新的测试生成器将其添加回来，就在它下面：
- en: '[PRE26]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Repeat the same process for the second test: wrap it in a function definition,
    introduce a `fieldName` parameter, and replace `firstName` with `fieldName` within
    the test description and expectation:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对第二个测试重复相同的步骤：将其包裹在一个函数定义中，引入一个`fieldName`参数，并在测试描述和期望中将`firstName`替换为`fieldName`：
- en: '[PRE27]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, re-introduce the test case for the `firstName` field:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，重新引入`firstName`字段的测试用例：
- en: '[PRE28]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, it’s time to tackle the chunkiest test – the `displays error after blur...`
    test. The previous two test generators used just one parameter, `fieldName`. This
    one needs two more, `value` and `description`, that are used in the **Act** phase
    and the **Assert** phase, respectively:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，是时候处理最复杂的测试——`在失去焦点后显示错误...`测试。前两个测试生成器只使用了一个参数，`fieldName`。这个需要一个额外的两个参数，`value`和`description`，分别在**行为**阶段和**断言**阶段使用：
- en: '[PRE29]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Just below that test generator definition, re-introduce the test case for the
    `first name` field:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在那个测试生成器定义下方，重新引入`first name`字段的测试用例：
- en: '[PRE30]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, repeat the same process for the fourth test:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，对第四个测试重复相同的步骤：
- en: '[PRE31]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, re-introduce the `firstName` test case:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，重新引入`firstName`测试用例：
- en: '[PRE32]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'After all that effort, it’s time to use the new test generators to build out
    the validation for the `lastName` field. Add the following single line at the
    bottom of your test suite:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所有这些努力之后，现在是时候使用新的测试生成器来构建`lastName`字段的验证了。在你的测试套件底部添加以下单行：
- en: '[PRE33]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To make that pass, simply add the code to the `CustomerForm` JSX by rendering
    another alert just below the `lastName` field:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使其通过，只需将代码添加到`CustomerForm` JSX中，在`lastName`字段下方渲染另一个警告：
- en: '[PRE34]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, we must create the test for the `aria-describedby` attribute:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须创建`aria-describedby`属性的测试。
- en: '[PRE35]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To make it pass, add that attribute to the `lastName` input element:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使其通过，将此属性添加到`lastName`输入元素中：
- en: '[PRE36]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, add the test for the required validation rule:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加对必需验证规则的测试。
- en: '[PRE37]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Given all the hard work we’ve done already, making this test pass is now super
    simple. Add a `lastName` entry to the `validators` object, as shown here:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们已经做了这么多艰苦工作的基础上，使这个测试通过现在变得非常简单。将`lastName`条目添加到`validators`对象中，如下所示：
- en: '[PRE38]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'For completeness, we need to add the fourth and final test for the `lastName`
    field. This test passes already since we’re relying on the mechanism we’ve just
    generalized. However, given that it’s a one-liner, it’s worth specifying, even
    if it’s not necessary:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完整性，我们需要为`lastName`字段添加第四个和最后一个测试。由于我们依赖于我们刚刚泛化的机制，这个测试已经通过了。然而，鉴于它是一行代码，即使不是必需的，也值得指定：
- en: '[PRE39]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Repeat *Steps 10* to *16* for the `phone number` field.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复*步骤10*到*16*以对`phone number`字段进行测试。
- en: Who needs test generator functions?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 谁需要测试生成器函数？
- en: Test generator functions can look complex. You may prefer to keep duplication
    in your tests or find some other way to extract common functionality from your
    tests.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 测试生成器函数可能看起来很复杂。你可能更喜欢在测试中保留重复，或者找到从测试中提取公共功能的其他方法。
- en: 'There is a downside to the test generator approach: you won’t be able to use
    `it.only` or `it.skip` on individual tests.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 测试生成器方法有一个缺点：你将无法在单个测试上使用`it.only`或`it.skip`。
- en: 'With that, we’ve covered the required field validation. Now, let’s add a different
    type of validation for the `phoneNumber` field. We want to ensure the phone number
    only contains numbers and a few special characters: brackets, dashes, spaces,
    and pluses.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就涵盖了所需的字段验证。现在，让我们为`phoneNumber`字段添加不同类型的验证。我们希望确保电话号码只包含数字和一些特殊字符：括号、破折号、空格和加号。
- en: To do that, we’ll introduce a `match` validator that can perform the phone number
    matching we need, and a `list` validator that composes validations.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将引入一个可以进行所需电话号码匹配的`match`验证器和一个组合验证的`list`验证器。
- en: 'Let’s add that second validation:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加第二个验证。
- en: 'Add the following new test:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下新测试：
- en: '[PRE40]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Add the following definition at the top of `src/CustomerForm.js`. This expects
    a regular expression, `re`, which can then be matched against:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/CustomerForm.js`的顶部添加以下定义。这期望一个正则表达式`re`，然后可以将其与以下内容匹配：
- en: '[PRE41]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Learning regular expressions
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 学习正则表达式
- en: Regular expressions are a flexible mechanism for matching string formats. If
    you’re interested in learning more about them, and how to test-drive them, take
    a look at [https://reacttdd.com/testing-regular-expressions](https://reacttdd.com/testing-regular-expressions).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是匹配字符串格式的灵活机制。如果你对它们感兴趣，并想了解更多关于它们以及如何测试驱动它们的信息，请查看[https://reacttdd.com/testing-regular-expressions](https://reacttdd.com/testing-regular-expressions)。
- en: 'Now, let’s go for the `list` validator function. This is quite a dense piece
    of code that returns a short-circuiting validator. It runs each validator that
    it’s given until it finds one that returns a string, and then returns that string.
    Add this just below the definition for `match`:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们来处理`list`验证函数。这是一段相当密集的代码，它返回一个短路验证器。它会运行它所提供的每个验证器，直到找到一个返回字符串的验证器，然后返回那个字符串。将此代码添加到`match`定义的下方：
- en: '[PRE42]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Replace the existing `phoneNumber` validation in the `handleBlur` function
    with the following validation, which uses all three validator functions:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下验证替换`handleBlur`函数中现有的`phoneNumber`验证，该验证使用了所有三个验证器函数：
- en: '[PRE43]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Your test should now be passing. However, if you look back at the test we just
    wrote, it says nothing about the allowed set of characters: it just says that
    `invalid` is not a valid phone number. To prove the use of the *real* regular
    expression, we need an inverse test to check that any combination of characters
    works. You can add this in; it should already pass:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的测试现在应该通过了。然而，如果你回顾我们刚才编写的测试，它并没有提到允许的字符集：它只是说`invalid`不是一个有效的电话号码。为了证明使用*真实*正则表达式，我们需要一个反向测试来检查任何字符组合都有效。你可以添加这个测试；它应该已经通过了：
- en: '[PRE44]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Is this a valid test?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有效的测试吗？
- en: This test passes without any required changes. That breaks our rule of only
    writing tests that fail.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试通过而不需要任何修改。这违反了我们只编写失败的测试的规则。
- en: 'We got into this situation because we did too much in our previous test: all
    we needed to do was prove that the `invalid` string wasn’t a valid phone number.
    But instead, we jumped ahead and implemented the full regular expression.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们陷入这种局面是因为我们在之前的测试中做得太多：我们只需要证明`invalid`字符串不是一个有效的电话号码。但相反，我们提前实现了完整的正则表达式。
- en: If we had triangulated “properly,” with a dummy regular expression to start,
    we would have ended up in the same place we are now, except we’d have done a bunch
    of extra intermediate work that ends up being deleted.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们“正确”地进行了三角测量，从一个虚拟的正则表达式开始，我们最终会到达现在的地方，但我们做了一大堆额外的中间工作，这些工作最终都被删除了。
- en: In some scenarios, such as when dealing with regular expressions, I find it’s
    okay to short-circuit the process as it saves me some work.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些场景中，例如处理正则表达式时，我发现短路过程是可以接受的，因为它可以节省我一些工作。
- en: With that, you’ve learned how to generalize validation using TDD.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，你已经学会了如何使用TDD来泛化验证。
- en: Submitting the form
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提交表单
- en: What should happen when we submit the form? For our application, if the user
    clicks the submit button before the form is complete, the submission process should
    be canceled and all the fields should display their validation errors at once.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们提交表单时会发生什么？对于我们的应用程序，如果用户在表单完成之前点击提交按钮，提交过程应该被取消，并且所有字段应该一次性显示它们的验证错误。
- en: 'We can do this with two tests: one to check that the form isn’t submitted while
    there are errors, and another to check that all the fields are showing errors.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过两个测试来完成这个任务：一个测试用来检查在存在错误时表单不会被提交，另一个测试用来检查所有字段都显示错误。
- en: Before we do that, we’ll need to update our existing tests that submit the form,
    as they all assume that the form has been filled in correctly. First, we need
    to ensure that we pass valid customer data that can be overridden in each test.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这样做之前，我们需要更新我们现有的提交表单的测试，因为它们都假设表单已经被正确填写。首先，我们需要确保我们传递有效的客户数据，这些数据可以在每个测试中被覆盖。
- en: 'Let’s get to work on the `CustomerForm` test suite:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始编写`CustomerForm`测试套件：
- en: 'We need a new builder to help represent a `validCustomer` record. We’ll update
    many of our existing tests to use this new value. In `test/builders/customer.js`,
    define the following object:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个新构建器来帮助表示`validCustomer`记录。我们将更新我们现有的许多测试以使用这个新值。在`test/builders/customer.js`中，定义以下对象：
- en: '[PRE45]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In `test/CustomerForm.test.js`, update the import that contains `blankCustomer`,
    pulling in the new `validCustomer` too:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`test/CustomerForm.test.js`中，更新包含`blankCustomer`的导入，同时引入新的`validCustomer`：
- en: '[PRE46]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Starting at the top, modify each test that simulates a submit event. Each should
    be mounted with this new `validCustomer` object. After making these changes, run
    your tests and make sure they are still passing before continuing:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从顶部开始，修改每个模拟提交事件的测试。每个都应该使用这个新的`validCustomer`对象进行挂载。在继续之前，在做出这些更改后运行你的测试，并确保它们仍然通过：
- en: '[PRE47]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Add a new test for submitting the form. This can go alongside the other submit
    tests, rather than in the validation block:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的表单提交测试。这个测试可以和其它提交测试放在一起，而不是在验证块中：
- en: '[PRE48]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To make this pass, first, define the following `validateMany` function inside
    the `CustomerForm` component. Its job is to validate many fields at once. It takes
    a single parameter, `fields`, which is an object of the field values we care about:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使这个测试通过，首先，在`CustomerForm`组件内部定义以下`validateMany`函数。它的任务是同时验证多个字段。它接受一个参数，`fields`，这是我们关心的字段值的对象：
- en: '[PRE49]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `validateMany` function references the `validators` constant, but that constant
    is currently defined in the `handleBlur` function. Pull that definition up so
    that it exists at the top of the component scope and is now accessible by both
    `handleBlur` and `validateMany`.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`validateMany`函数引用了`validators`常量，但这个常量目前是在`handleBlur`函数中定义的。将这个定义拉上来，使其存在于组件作用域的顶部，现在`handleBlur`和`validateMany`都可以访问它。'
- en: 'We need a new function to check for errors across all fields. That’s `anyErrors`;
    add that now, as shown here. It returns `true` if we had any errors at all, and
    `false` otherwise:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个新函数来检查所有字段的错误。这就是`anyErrors`；现在添加它，如下所示。如果存在任何错误，它返回`true`，否则返回`false`：
- en: '[PRE50]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, we can use `validateMany` and `anyErrors` in our `handleSubmit` function,
    as shown here. We’re going to wrap most of the existing functions in a conditional.
    Your test should pass after adding this code:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在 `handleSubmit` 函数中使用 `validateMany` 和 `anyErrors`，如下所示。我们将用条件包装大多数现有函数。添加此代码后，你的测试应该通过：
- en: '[PRE51]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Let’s move on to the next test. We need a couple of new imports, `textOf` and
    `elements`, so that we can write an expectation across all three of the alert
    spaces. Add these now:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续下一个测试。我们需要几个新的导入，`textOf` 和 `elements`，这样我们就可以在所有三个警报空间中编写一个期望。现在添加这些：
- en: '[PRE52]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next, add the following test at the bottom of the test suite. We want to check
    whether any errors appear on the screen:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在测试套件的底部添加以下测试。我们想要检查屏幕上是否出现任何错误：
- en: '[PRE53]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Using the alert role on multiple elements
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个元素上使用警报角色
- en: This chapter uses multiple alert spaces, one for each form field. However, screen
    readers do not behave well when multiple alert roles show alerts at the same time
    – for example, if clicking the submit button causes a validation error to appear
    on all three of our fields.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用多个警报空间，每个表单字段一个。然而，当多个警报角色同时显示警报时，屏幕阅读器表现不佳——例如，如果点击提交按钮导致我们的三个字段都出现验证错误。
- en: An alternative approach would be to rework the UI so that it has an additional
    element that takes on the alert role when any errors are detected; after that,
    it should remove the alert role from the individual field error descriptions.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是对 UI 进行重构，使其在检测到任何错误时具有一个额外的元素来承担警报角色；之后，它应该从各个字段错误描述中移除警报角色。
- en: 'This one is easy to pass; we simply need to call `setValidationErrors` with
    `validationResult` when `anyErrors` returns `false`:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个很容易通过；我们只需要在 `anyErrors` 返回 `false` 时，用 `validationResult` 调用 `setValidationErrors`
    即可：
- en: '[PRE54]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: You’ve now seen how to run all field validations when the form is submitted.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经看到了如何在表单提交时运行所有字段验证。
- en: Extracting non-React functionality into a new module
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将非 React 功能提取到新模块中
- en: 'One useful design guideline is to get out of “framework land” as soon as possible.
    You want to be dealing with plain JavaScript objects. This is especially true
    for React components: extract as much logic as possible out into standalone modules.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有用的设计指南是尽快走出“框架领域”。你希望处理的是纯 JavaScript 对象。这对于 React 组件来说尤其如此：尽可能多地提取逻辑到独立的模块中。
- en: There are a few different reasons for this. First, testing components is harder
    than testing plain objects. Second, the React framework changes more often than
    the JavaScript language itself. Keeping our code bases up to date with the latest
    React trends is a large-scale task *if* our code base is, first and foremost,
    a React code base. If we keep React at bay, our lives will be simpler in the longer
    term. So, we always prefer to write plain JavaScript when it’s an option.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这有几个不同的原因。首先，测试组件比测试纯对象更难。其次，React 框架的变化比 JavaScript 语言本身更频繁。如果我们的代码库首先是一个 React
    代码库，那么保持我们的代码库与最新的 React 趋势保持一致是一项大规模的任务。如果我们能保持 React 在一边，从长远来看，我们的生活将会更简单。因此，当有选择时，我们总是更喜欢编写纯
    JavaScript。
- en: 'Our validation code is a great example of this. We have several functions that
    do not care about React at all:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的验证代码是这方面的绝佳例子。我们有一些完全不考虑 React 的函数：
- en: 'The validators: `required`, `match`, and `list`'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证器：`required`、`match` 和 `list`
- en: '`hasError` and `anyErrors`'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hasError` 和 `anyErrors`'
- en: '`validateMany`'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validateMany`'
- en: Some of the code in `handleBlur`, which is like a single-entry equivalent of
    `validateMany`
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handleBlur` 中的部分代码，它类似于 `validateMany` 的单入口等效'
- en: 'Let’s pull all of these out into a separate namespace called `formValidation`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将所有这些内容提取到一个名为 `formValidation` 的单独命名空间中：
- en: Create a new file called `src/formValidation.js`.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `src/formValidation.js` 的新文件。
- en: Move across the function definitions for `required`, `match`, and `list` from
    the top of `CustomerForm`. Make sure you delete the old definitions!
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `required`、`match` 和 `list` 的函数定义从 `CustomerForm` 的顶部移动过来。确保你删除了旧的定义！
- en: Add the word `export` to the front of each definition in the new module.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新模块的每个定义前添加单词 `export`。
- en: 'Add the following import to the top of `CustomerForm`, and then check that
    your tests are still passing:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `CustomerForm` 的顶部添加以下导入，然后检查你的测试是否仍然通过：
- en: '[PRE55]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In `src/CustomerForm.js`, change `renderError` so that it passes the errors
    from `state` into `hasError`:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/CustomerForm.js` 中，修改 `renderError` 以使其将 `state` 中的错误传递到 `hasError`：
- en: '[PRE56]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Update `hasError` so that it includes the new `validationErrors` argument,
    and uses that rather than `state`:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`hasError`，使其包含新的`validationErrors`参数，并使用该参数而不是`state`：
- en: '[PRE57]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Update `validateMany` so that it passes in the list of validators as its first
    argument, rather than using `state`:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`validateMany`，使其将验证器列表作为其第一个参数传递，而不是使用`state`：
- en: '[PRE58]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Update `handleBlur` so that it uses `validateMany`:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`handleBlur`，使其使用`validateMany`：
- en: '[PRE59]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Update `handleSubmit` so that it passes `validators` to `validateMany`:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`handleSubmit`，使其将`validators`传递给`validateMany`：
- en: '[PRE60]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Move `hasError`, `validateMany`, and `anyErrors` into `src/formValidation.js`,
    ensuring you delete the functions from the `CustomerForm` component.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`hasError`、`validateMany`和`anyErrors`移动到`src/formValidation.js`中，确保您从`CustomerForm`组件中删除这些函数。
- en: Add the word `export` in front of each of these definitions.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个定义前添加单词`export`。
- en: 'Update the import so that it pulls in these functions:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新导入，以便引入这些函数：
- en: '[PRE61]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Although this is enough to extract the code out of React-land, we’ve only just
    made a start. There is plenty of room for improvement with this API. There are
    a couple of different approaches that you could take here. The exercises for this
    chapter contain some suggestions on how to do that.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这足以将代码从React领域提取出来，但我们才刚刚开始。这个API还有很多改进的空间。这里有几个不同的方法可以采取。本章的练习包含了一些关于如何做到这一点的建议。
- en: Using test doubles for validation functions
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 使用测试替身进行验证函数
- en: You may be thinking, do these functions now need their own unit tests? And should
    I update the tests in `CustomerForm` so that test doubles are used in place of
    these functions?
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，这些函数现在需要它们自己的单元测试吗？我应该更新`CustomerForm`中的测试，以便使用测试替身代替这些函数吗？
- en: In this case, I would probably write a few tests for `formValidation`, just
    to make it clear how each of the functions should be used. This isn’t test-driving
    since you already have the code, but you can still mimic the experience by writing
    tests as you normally would.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我可能会为`formValidation`编写几个测试，以便清楚地说明每个函数应该如何使用。这并不是测试驱动开发，因为你已经有了代码，但你仍然可以通过像平时一样编写测试来模拟这种体验。
- en: When extracting functionality from components like this, it often makes sense
    to update the original components to simplify and perhaps move across tests. In
    this instance, I wouldn’t bother. The tests are high-level enough that they make
    sense, regardless of how the code is organized internally.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当从像这样的组件中提取功能时，通常有更新原始组件以简化并可能移动测试的必要。在这种情况下，我不会费心去做。测试足够高级，无论代码内部如何组织，都是有意义的。
- en: This section covered how to write validation logic for forms. You should now
    have a good awareness of how TDD can be used to implement complex requirements
    such as field validations. Next, we’ll integrate server-side errors into the same
    flow.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了如何编写表单的验证逻辑。你现在应该对如何使用TDD来实现诸如字段验证等复杂要求有很好的了解。接下来，我们将把服务器端错误集成到相同的流程中。
- en: Handling server errors
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理服务器错误
- en: The `/customers` endpoint may return a `422 Unprocessable Entity` error if the
    customer data failed the validation process. This could happen if, for example,
    the phone number already exists within the system. If this happens, we want to
    withhold calling the `onSave` callback and instead display the errors to the user
    and give them the chance to correct them.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户数据验证失败，`/customers`端点可能会返回`422 Unprocessable Entity`错误。例如，如果电话号码已经在系统中存在，这可能会发生。如果发生这种情况，我们不想调用`onSave`回调，而是向用户显示错误，并给他们机会进行更正。
- en: 'The body of the response will contain error data very similar to the data we’ve
    built for the validation framework. Here’s an example of the JSON that would be
    received:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 响应体将包含与为验证框架构建的数据非常相似的错误数据。以下是一个将接收到的JSON示例：
- en: '[PRE62]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We’ll update our code to display these errors in the same way our client errors
    appeared. Since we already handle errors for `CustomerForm`, we’ll need to adjust
    our tests in addition to the existing `CustomerForm` code.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更新我们的代码，以显示这些错误，就像我们的客户端错误出现时一样。由于我们已处理`CustomerForm`的错误，因此我们还需要调整我们的测试，以及现有的`CustomerForm`代码。
- en: Our code to date has made use of the `ok` property that’s returned from `global.fetch`.
    This property returns `true` if the HTTP status code is `200`, and false otherwise.
    Now, we need to be more specific. For a status code of `422`, we want to display
    new errors, and for anything else (such as a `500` error), we want to fall back
    to the existing behavior.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的代码使用了从`global.fetch`返回的`ok`属性。该属性在HTTP状态码为`200`时返回`true`，否则返回`false`。现在，我们需要更具体一些。对于状态码为`422`的情况，我们想要显示新的错误，而对于其他任何情况（如`500`错误），我们想要回退到现有的行为。
- en: 'Let’s add support for those additional status codes:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加对这些附加状态码的支持：
- en: 'Update the `fetchResponseError` method in `test/builders/fetch.js`, as shown
    here:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下更新`test/builders/fetch.js`中的`fetchResponseError`方法：
- en: '[PRE63]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Write a test for `422` errors in `test/CustomerForm.test.js`. I’ve placed this
    toward the top of the file, next to the other tests that manipulate the HTTP response:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`test/CustomerForm.test.js`中为`422`错误编写一个测试。我已经将这个测试放在文件顶部，靠近其他操作HTTP响应的测试：
- en: '[PRE64]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'To make that pass, add a new branch to the nested conditional statement in
    `handleSubmit`, which handles the response of the fetch request:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现这个跳转，请向`handleSubmit`中的嵌套条件语句添加一个新的分支，该分支处理fetch请求的响应：
- en: '[PRE65]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Your tests should now be passing.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你的测试现在应该通过了。
- en: This section has shown you how to integrate server-side errors into the same
    client-side validation logic that you already have. To finish up, we’ll add some
    frills.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 本节向您展示了如何将服务器端错误集成到您已经拥有的相同的客户端验证逻辑中。为了完成，我们将添加一些装饰。
- en: Indicating form submission status
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指示表单提交状态
- en: It’d be great if we could indicate to the user that their form data is being
    sent to our application servers. The GitHub repository for this book contains
    a spinner graphic and some CSS that we can use. All that our React component needs
    to do is display a `span` element with a class name of `submittingIndicator`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能向用户指示他们的表单数据正在发送到我们的应用程序服务器，那就太好了。这本书的GitHub仓库包含了一个旋转器图形和一些我们可以使用的CSS。我们的React组件需要做的只是显示一个具有`submittingIndicator`类名的`span`元素。
- en: 'Before we write out the tests, let’s look at how the production code will work.
    We will introduce a new `submitting` boolean state variable that is used to toggle
    between states. It will be toggled to `true` just before we perform the fetch
    request and toggled to `false` once the request completes. Here’s how we’ll modify
    `handleSubmit`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写测试之前，让我们看看生产代码将如何工作。我们将引入一个新的布尔状态变量`submitting`，用于在状态之间切换。在我们执行fetch请求之前，它将被切换为`true`，一旦请求完成，它将被切换为`false`。以下是我们将如何修改`handleSubmit`：
- en: '[PRE66]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: If submitting is set to `true`, then we will render the spinner graphic. Otherwise,
    we will render nothing.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提交被设置为`true`，那么我们将渲染旋转器图形。否则，我们将不渲染任何内容。
- en: Testing state before promise completion
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在promise完成前测试状态
- en: 'One of the trickiest aspects of testing React components is testing what happens
    *during* a task. That’s what we need to do now: we want to check that the submitting
    indicator is shown while the form is being submitted. However, the indicator disappears
    as soon as the promise completes, meaning that we can’t use the standard `clickAndWait`
    function we’ve used up until now because it will return at the point *after* the
    indicator has disappeared!'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 测试React组件最棘手的一个方面是测试任务期间发生的事情。这正是我们现在需要做的：我们想要检查在表单提交期间显示提交指示器。然而，指示器一旦promise完成就会消失，这意味着我们不能使用我们迄今为止使用的标准`clickAndWait`函数，因为它会在指示器消失之后的点返回！
- en: Recall that `clickAndWait` uses the asynchronous form of the `act` test helper.
    That’s the core of the issue. To get around this, a *synchronous* form of our
    function, `click`, will be needed to return *before* the task queue completes
    – in other words, before the `global.fetch` call returns any results.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 记住`clickAndWait`使用的是`act`测试辅助函数的异步形式。这是问题的关键。为了解决这个问题，我们需要一个同步形式的我们的函数`click`，以便在任务队列完成之前返回——换句话说，在`global.fetch`调用返回任何结果之前。
- en: However, to stop React’s warning sirens from going off, we still need to include
    the asynchronous `act` form *somewhere* in our test. React knows the submit handler
    returns a promise and it expects us to wait for its execution via a call to `act`.
    We need to do that after we’ve checked the toggle value of submitting, not before.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了停止React的警告警报响起，我们仍然需要在我们的测试中包含异步的`act`形式。React知道提交处理程序返回一个promise，并且它期望我们通过调用`act`等待其执行。我们需要在检查提交的切换值之后做这件事，而不是之前。
- en: 'Let’s build that test now:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来构建这个测试：
- en: 'Add `act` as an import to `test/CustomerForm.test.js`:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `act` 作为导入添加到 `test/CustomerForm.test.js`：
- en: '[PRE67]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Re-add the `click` function import:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新添加 `click` 函数导入：
- en: '[PRE68]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Create a new nested `describe` block at the bottom of the `CustomerForm` test
    suite, just below the existing form submission tests. This submits the call itself
    within a synchronous `click`, as explained previously. Then, we must wrap the
    expectation in an async `act` call that suppresses any warnings or errors from
    React:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `CustomerForm` 测试套件的底部创建一个新的嵌套 `describe` 块，位于现有的表单提交测试下方。这个测试在同步的 `click`
    中提交调用本身，如前所述。然后，我们必须将期望包裹在一个抑制 React 任何警告或错误的异步 `act` 调用中：
- en: '[PRE69]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'To make this pass, we just need to show that `span` within the JSX. Place that
    just after the submit button, as follows:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使这个通过，我们只需要在 JSX 中显示那个 `span`。将其放置在提交按钮之后，如下所示：
- en: '[PRE70]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now, we need to triangulate, to ensure the indicator only shows when the form
    has been submitted and not before:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要进行三角测量，以确保指示器仅在表单提交后才显示，而不是在提交之前：
- en: '[PRE71]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We can make this pass by using a flag called `submitting`. It should be set
    to `false` when the indicator is disabled, and `true` when it’s enabled. Add the
    following state variable to the top of the `CustomerForm` component:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过使用一个名为 `submitting` 的标志来使这个通过。当指示器禁用时，它应该设置为 `false`，当它启用时，设置为 `true`。将以下状态变量添加到
    `CustomerForm` 组件的顶部：
- en: '[PRE72]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Change the submitting `span` indicator so that it reads as follows:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将提交的 `span` 指示器更改为以下内容：
- en: '[PRE73]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The new test will now be passing, but the original test will be failing. We
    had to switch `submittingIndicator` to `true` just before we called `fetch`. In
    `handleSubmit`, add this line just above the call to `fetch`. After adding this
    code, your test should be passing:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的测试现在将通过，但原始测试将失败。我们不得不在调用 `fetch` 之前将 `submittingIndicator` 切换到 `true`。在 `handleSubmit`
    中，在调用 `fetch` 之前添加此行。添加此代码后，你的测试应该通过：
- en: '[PRE74]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Add this final test, which checks that the indicator disappears once the response
    has been received. This test is very similar to our first test for the submitting
    indicator:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加这个最后的测试，该测试检查指示器在收到响应后消失。这个测试与我们的第一个提交指示器测试非常相似：
- en: '[PRE75]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'This time, we need to add a `setSubmitting` call *after* the fetch:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次，我们需要在 fetch 之后添加一个 `setSubmitting` 调用：
- en: '[PRE76]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: That’s everything; your tests should all be passing.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是全部了；你的所有测试都应该通过。
- en: Refactoring long methods
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构长方法
- en: After this, our `handleSubmit` function is long – I have counted 23 lines in
    my implementation. That is too long for my liking!
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们的 `handleSubmit` 函数变得很长——在我的实现中我数了23行。这对我来说太长了！
- en: 'Refactoring `handleSubmit` into smaller methods is an exercise left for you;
    see the *Exercises* section for more details. But here are a couple of hints for
    how you can go about that systematically:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `handleSubmit` 重构为更小的方法是一个留给你的练习；请参阅 *练习* 部分以获取更多详细信息。但这里有一些关于如何系统地进行的提示：
- en: Extract blocks into methods; in this case, that means the contents of `if` statements.
    For example, if there are no validation errors, you could call out to a `doSave`
    method, which does the submission.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代码块提取到方法中；在这种情况下，这意味着 `if` 语句的内容。例如，如果没有验证错误，你可以调用 `doSave` 方法进行提交。
- en: Look for `true`, before the fetch call, and then `false` after. This could be
    done differently.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 fetch 调用之前寻找 `true`，然后是调用之后的 `false`。这可以有不同的实现方式。
- en: Now, let’s summarize this chapter.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们总结这一章。
- en: Summary
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter has shown you how TDD can be applied beyond just toy examples.
    Although you may not ever want to implement form validation yourself, you can
    see how complex code can be test-driven using the same methods that you learned
    in the first part of this book.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向你展示了如何将 TDD 应用于不仅仅是玩具示例之外。虽然你可能永远不会想自己实现表单验证，但你可以看到如何使用你在本书第一部分学到的相同方法来驱动复杂的代码。
- en: 'First, you learned how to validate field values at an appropriate moment: when
    fields lose focus and when forms are submitted. You also saw how server-side errors
    can be integrated into that, and how to display an indicator to show the user
    that data is in the process of being saved.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你学习了如何在适当的时候验证字段值：当字段失去焦点和表单提交时。你还看到了如何将服务器端错误集成到其中，以及如何显示指示器来告知用户数据正在保存过程中。
- en: This chapter also covered how to move logic from your React components into
    their own modules.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还介绍了如何将逻辑从你的 React 组件移动到它们自己的模块中。
- en: 'In the next chapter, we’ll add a new feature to our system: a snazzy search
    interface.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将向我们的系统添加一个新功能：一个时尚的搜索界面。
- en: Exercises
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'The following are some exercises for you to complete:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些供您完成的练习：
- en: Add a feature that clears any validation errors when the user corrects them.
    Use the `onChange` handler for this rather than `onBlur`, since we want to let
    the user know as soon as they’ve corrected the error.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个功能，当用户更正错误时清除任何验证错误。使用 `onChange` 处理器来完成此操作，而不是 `onBlur`，因为我们希望让用户在更正错误后立即知道。
- en: Add a feature that disables the submit button once the form has been submitted.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个功能，一旦表单提交，就禁用提交按钮。
- en: Write tests for each of the functions within the `formValidation` module.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `formValidation` 模块中的每个函数编写测试。
- en: The `handleSubmit` function is long. Extract a `doSave` function that pulls
    out the main body of the `if` statement.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`handleSubmit` 函数很长。提取一个 `doSave` 函数，用于提取 `if` 语句的主体部分。'
- en: Further reading
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章所涉及的主题，请查看以下资源：
- en: A guide to regular expressions, explained by examples
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过示例解释的正则表达式指南
- en: '[https://reacttdd.com/testing-regular-expressions](https://reacttdd.com/testing-regular-expressions)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://reacttdd.com/testing-regular-expressions](https://reacttdd.com/testing-regular-expressions)'
- en: More information on ARIA annotations such as `aria-describedby`
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 `aria-describedby` 等ARIA注解的更多信息
- en: '[https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Annotations](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Annotations)'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Annotations](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Annotations)'
