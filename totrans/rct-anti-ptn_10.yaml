- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Diving Deep into Composition Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The journey of building scalable and maintainable user interfaces is riddled
    with challenges. One primary challenge faced by developers is ensuring that components
    remain modular, reusable, and easy to understand as a code base grows. The more
    intertwined and tightly coupled our components become, the harder it is to maintain,
    test, or even onboard new team members.
  prefs: []
  type: TYPE_NORMAL
- en: Composition has emerged as a powerful technique to address this challenge, enabling
    developers to build more organized, scalable, and cleaner code bases. Instead
    of creating large, monolithic components that carry out numerous tasks, we break
    them down into smaller, more manageable pieces that can be combined in versatile
    ways. This offers us a clear path to streamline logic, enhance reusability, and
    maintain a clear separation of concerns.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is dedicated to understanding and mastering composition in React.
    We’ll delve into foundational techniques such as higher-order functions before
    transitioning into higher-order components and Hooks. You’ll learn how these tools
    seamlessly align with the principles of composition, allowing you to build more
    robust applications with React. Our journey will culminate with a deep dive into
    headless components, a paradigm that encapsulates logic without dictating the
    UI, offering unparalleled flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: By the chapter’s end, you’ll appreciate the benefits of employing composition
    techniques. You’ll be equipped to create UIs that are not just scalable and maintainable
    but also a pleasure to work with. Let’s embark on this enlightening exploration
    of composition in React.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding composition through higher-order components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Diving deep into custom Hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing a drop-down list component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring a headless component pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A GitHub repository has been created to host all the code we discuss in the
    book. For this chapter, you can find the recommended structure at [https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch1](https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch10)0.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding composition through higher-order components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Composition might be the most important technique in software design overall,
    and like many other fundamental design principles, it applies on many different
    levels. In this section, we’ll review how we can use higher-order functions and
    their variation in the React world – higher-order components – to implement composition.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing higher-order functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We discussed some examples of higher-order functions in [*Chapter 9*](B21103_09.xhtml#_idTextAnchor227),
    but it’s such an important concept that I would like to review it a bit more here.
    A **higher-order function** (**HOF**) is a function that either takes another
    function as its argument, returns a function, or both. The ability to accept a
    function as a parameter has a lot of advantages, especially when it comes to composition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `report` function generates a formatted report containing a header,
    the provided content, and a footer. For instance, given the input `hello world`,
    the output would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, imagine a scenario where some users wish to print the content in uppercase.
    While we could achieve this with `content.toUpperCase()`, other users might prefer
    the content as-is. Introducing conditions within our report function is one approach
    to pleasing both sets of users. Drawing inspiration from our previous discussion
    about the title example in [*Chapter 9*](B21103_09.xhtml#_idTextAnchor227), we
    can allow a `transformer` function to be passed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This enables clients to format the string as they desire, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'For flexibility, we can provide a default transformer, ensuring that those
    who don’t wish to customize the format can use the function without changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The report function generates a string with a defined header and footer, and
    the main content in between. It accepts a content string and an optional transformer
    function. If the transformer is provided, it modifies the content; otherwise,
    the content remains unchanged. The result is a formatted report with the modified
    or original content placed between the header and footer. That’s essentially how
    powerful HOFs can be, helping us to write more composable code.
  prefs: []
  type: TYPE_NORMAL
- en: Reflecting upon this, an interesting thought emerges – can we incorporate this
    composable and functional approach into our React applications? Indeed, we can.
    The ability to augment components isn’t just limited to standard functions. In
    React, we have **higher-order** **components** (**HOCs**).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing HOCs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An HOC is essentially a function that accepts a component and returns a new,
    enhanced version of it. The principle behind HOCs is straightforward – they allow
    you to inject additional functionality into an existing component. This pattern
    is especially beneficial when you want to reuse certain behaviors across multiple
    components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s delve into an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, we define a function, `checkAuthorization`, to handle the authorization
    check. Then, we create a HOC, `withAuthorization`. This HOC takes a component
    (`Component`) as its argument and returns a new function. This returned function,
    when rendered, will either render the original `Component` (if the user is authorized)
    or a `Login` component (if the user is not authorized).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, suppose we have a `ProfileComponent` that we want to secure. We can use
    `withAuthorization` to create a new, secured version of `ProfileComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This means that whenever `Profile` is rendered, it will first check whether
    a user is authorized. If so, it renders `ProfileComponent`; otherwise, it redirects
    the user to the `Login` component.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve seen how HOCs can control access with `withAuthorization`, let’s
    shift our focus to enhancing user interactions. We’ll delve into an `ExpandablePanel`
    component, showcasing how HOCs can also manage interactive UI elements and state
    transitions.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an ExpandablePanel component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s kick things off with a basic `ExpandablePanel` component. This component,
    as the name suggests, consists of a title and a content area. Initially, the content
    area is collapsed, but a click on the title expands it to reveal the content.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1: An expandable panel](img/B31103_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.1: An expandable panel'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for such a component is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, suppose we want to jazz it up a bit, making the panel expand automatically
    when rendered and then collapse after a few seconds. Here’s how we could adjust
    the code to achieve that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this revised version, we initialize `isOpen` to `true` so that the panel
    starts as expanded. Then, we utilize `useEffect` to set a timer that collapses
    the panel after 3,000 milliseconds (3 seconds).
  prefs: []
  type: TYPE_NORMAL
- en: 'This pattern of auto-collapsing components is quite common in UI development
    – think of notifications, alerts, or tooltips that disappear after a while. To
    promote code reusability, let’s extract this auto-collapsing logic into a HOC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In `withAutoClose`, we define a generic HOC that adds auto-closing functionality
    to any component. This HOC accepts a duration parameter to customize the auto-close
    delay, defaulting to 2,000 milliseconds (2 seconds).
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure a smooth integration, we can also extend `PanelProps` to include
    optional `Toggleable` properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can refactor `ExpandablePanel` to accept `isOpen` and toggle props
    from `withAutoClose`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'With this setup, creating an auto-closing version of `ExpandablePanel` is a
    breeze:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And guess what? The auto-closing logic we’ve encapsulated in `withAutoClose`
    can be reused across various components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The versatility of HOCs shines when it comes to composition – the ability to
    apply one HOC to the result of another. This capability aligns well with the principle
    of function composition in functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider another HOC, `withKeyboardToggle`, which augments a panel’s
    behavior to respond to keyboard inputs to toggle the panel’s expanded/collapsed
    state. Here’s the code for `withKeyboardToggle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the `withKeyboardToggle` HOC, a reference (`divRef`) is created for the wrapping
    `div` to enable keyboard interactions. The `handleKeyDown` function defines the
    behavior for the *Enter*, *Space*, and *Escape* keys – the *Enter* or *Space*
    keys toggle the panel’s state, while the *Escape* key removes focus from the panel.
    These keyboard event handlers allow the wrapped component to respond to keyboard
    navigation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s compose `withKeyboardToggle` and `withAutoClose` together to create
    a new component, `AccessibleAutoClosePanel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the `withAutoClose(withKeyboardToggle(ExpandablePanel), 2000);` expression,
    `withKeyboardToggle` is first applied to `ExpandablePanel`, enhancing it with
    keyboard toggle capability. The result is then fed into `withAutoClose`, which
    further enhances the component to auto-close after a 2,000-millisecond delay.
    This chaining of HOCs results in a new component, `AccessibleAutoClosePanel`,
    which inherits both the keyboard toggle and auto-close behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a vivid example of how HOCs can be nested and composed to build more
    complex behavior from simpler, single-responsibility components, which is illustrated
    further in *Figure 10**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2: A Higher-Order Component](img/B31103_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.2: A Higher-Order Component'
  prefs: []
  type: TYPE_NORMAL
- en: If you have some background in object-oriented programming, this concept might
    resonate with you, as it aligns with the **Decorator** design pattern. If you’re
    not familiar, it dynamically adds behaviors to objects by wrapping them in additional
    objects, rather than altering their structure. This allows for greater flexibility
    than subclassing, as it extends functionality without modifying the original object.
  prefs: []
  type: TYPE_NORMAL
- en: Now, while HOCs remain beneficial in various scenarios for both class components
    and functional components, React Hooks offer a more lightweight approach to achieving
    composition. Let’s look at Hooks next.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring React Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Hooks** provide a means to extract stateful logic from a component, enabling
    its independent testing and reuse. They pave the way for reutilizing stateful
    logic without altering your component hierarchy. Essentially, Hooks let you “hook
    into” React state and other life cycle features from function components.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following on from the `ExpandablePanel` component example, let’s look at this
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this `useAutoClose` Hook, we create an `isOpen` state and a function toggle
    to switch the state. The `useEffect` function sets a timer to change `isOpen`
    to `false` after a specified duration, but only if `isOpen` is `true`. It also
    cleans up the timer to prevent memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to integrate this Hook into our `ExpandablePanel`, minimal amendments
    are needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, we deleted the passed-in `isOpen` and `toggle` props and utilized the
    return value from the `useAutoClose` Hook, seamlessly incorporating the auto-close
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, to incorporate keyboard navigation, we define another Hook, `useKeyboard`,
    which captures key events to toggle the panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, embedding `useKeyboard` within `ExpandablePanel` is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, `handleKeyDown` from `useKeyboard` is employed to detect key presses,
    enhancing our component with keyboard interactivity.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 10**.3*, you can observe how the Hooks link with the underlying
    `ExpandablePanel`, contrasting the HOC scenario where the component is wrapped:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3: Using alternative Hooks](img/B31103_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.3: Using alternative Hooks'
  prefs: []
  type: TYPE_NORMAL
- en: Hooks embody a neat package of reusable logic, isolated from the component yet
    easily integrated. Unlike the wrapping approach of HOCs, Hooks offer a plugin
    mechanism, making them lightweight and well-managed by React. This characteristic
    of Hooks not only promotes code modularity but also facilitates a cleaner and
    more intuitive way to enrich our components with additional functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: However, be aware that Hooks offer more versatility than initially apparent.
    They’re not just for managing UI-related state but are also effective for handling
    UI side effects, such as data fetching and global event handling (such as page-level
    keyboard shortcuts). We have seen how to use them for keyboard event handlers,
    so now, let’s explore how Hooks can streamline network requests.
  prefs: []
  type: TYPE_NORMAL
- en: Unveiling remote data fetching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In previous chapters, we leveraged `useEffect` for data fetching, a prevalent
    approach. When retrieving data from a remote server, it typically necessitates
    the introduction of three distinct states – `loading`, `error`, and `data`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a method to implement these states:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we use React Hooks to manage asynchronous data fetching,
    initializing states for `loading`, `data`, and `error`. Inside `useEffect`, the
    `fetchData` function attempts to retrieve user data from the `"/api/users"` endpoint.
    If successful, the data is stored; if not, an error is recorded. Regardless of
    the outcome, the loading state is updated to reflect completion. `useEffect` runs
    only once, similar to the component’s initial mounting phase.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring for elegance and reusability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Incorporating fetching logic directly within our component can work, but it’s
    not the most elegant or reusable approach. Let’s refactor this by extracting the
    fetching logic into a separate function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `fetchUsers` function in place, we can take a step further by abstracting
    our fetching logic into a generic Hook. This Hook will accept a fetch function
    and manage the associated `loading`, `error`, and `data` states:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the `useService` Hook emerges as a reusable solution to fetch data across
    our application. It’s a neat abstraction that we can employ to fetch various types
    of data, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: With this refactoring, we’ve not only simplified our data fetching logic but
    also made it reusable across different scenarios in our application. This sets
    a solid foundation as we continue to enhance our drop-down component and delve
    deeper into more advanced features and optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: As we have explored Hooks and their capabilities in managing state and logic,
    let’s apply this knowledge to build a more complex UI component from scratch —
    a drop-down list. This exercise will not only reinforce our understanding of Hooks
    but also demonstrate their practical application in creating interactive UI elements.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start with a basic version of a drop-down list and then gradually introduce
    more features to make it functional and user-friendly. This process will also
    set the stage for a later discussion on headless components, showcasing a design
    pattern that further abstracts and manages state and logic in UI components.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a drop-down list component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A drop-down list is a common component used in many places. Although there’s
    a native select component for basic use cases, a more advanced version offering
    more control over each option provides a better user experience.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4: A drop-down list component](img/B31103_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.4: A drop-down list component'
  prefs: []
  type: TYPE_NORMAL
- en: When creating one from scratch, a complete implementation requires more effort
    than it appears at first glance. It’s essential to consider keyboard navigation,
    accessibility (for instance, screen reader compatibility), and usability on mobile
    devices, among others.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll begin with a simple, desktop version that only supports mouse clicks,
    gradually building in more features to make it realistic. Note that the goal here
    is to reveal a few software design patterns rather than teach you how to build
    a drop-down list for production use (actually, I don’t recommend doing this from
    scratch and would instead suggest using more mature libraries).
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, we need an element (let’s call it a trigger) for the user to click,
    and a state to control the show and hide actions of the list panel. Initially,
    we hide the panel, and when the trigger is clicked, we show the list panel. Here
    is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the code, we’ve set up the basic structure for our drop-down component. Using
    the `useState` Hook, we manage the `isOpen` and `selectedItem` states to control
    the dropdown’s behavior. A simple click on the trigger toggles the drop-down menu,
    while selecting an item updates the `selectedItem` state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s break down the component into smaller, manageable pieces to see it more
    clearly. We’ll start by extracting a `Trigger` component to handle user clicks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we’ll extract a `DropdownMenu` component to render the list of items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the `Dropdown` component, we simply use these two components, passing
    in the corresponding state, turning them into purely controlled components (stateless
    components):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In this updated code structure, we’ve separated concerns by creating specialized
    components for different parts of the dropdown, making the code more organized
    and easier to manage. We can see the result here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5: A native implementation list](img/B31103_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.5: A native implementation list'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in *Figure 10**.5*, the basic drop-down list appears, but that’s
    only a small part of the whole drop-down list features. Keyboard navigation, for
    example, is a necessary feature for an accessible component, which we will implement
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing keyboard navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Incorporating keyboard navigation within our drop-down list enhances the user
    experience by providing an alternative to mouse interactions. This is particularly
    important for accessibility and offers a seamless navigation experience on a web
    page. Let’s explore how we can achieve this using the `onKeyDown` event handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initially, we’ll attach a `handleKeyDown` function to the `onKeyDown` event
    in our `Dropdown` component. Here, we utilize a `switch` statement to determine
    the specific key pressed and perform actions accordingly. For instance, when the
    `Enter` or `Space` key is pressed, the dropdown is toggled. Similarly, the `ArrowDown`
    and `ArrowUp` keys allow navigation through the list items, cycling back to the
    start or end of the list when necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, we have updated our `DropdownMenu` component to accept a `selectedIndex`
    prop. This prop is used to apply a highlighted style and set the aria-selected
    attribute to the currently selected item, enhancing the visual feedback and accessibility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Moving forward, we can encapsulate the state and keyboard event handling logic
    within a custom Hook named `useDropdown`. This Hook returns an object containing
    the necessary states and functions, which can be destructured and used within
    our `Dropdown` component, keeping it clean and maintainable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our `Dropdow`n component is simplified and more readable; it leverages
    the `useDropdown` Hook to manage its state and handle keyboard interactions, demonstrating
    a clear separation of concerns and making the code easier to understand and manage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Through these modifications, we have successfully implemented keyboard navigation
    in our drop-down list, making it more accessible and user-friendly. This example
    also illustrates how Hooks can be utilized to manage complex state and logic in
    a structured and modular manner, paving the way for further enhancements and feature
    additions to our UI components.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can visualize the code a bit better with the React DevTools. Note that in
    the **hooks** section, all the states are listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6: Chrome DevTools to inspect what’s in the hooks section](img/B31103_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.6: Chrome DevTools to inspect what’s in the hooks section'
  prefs: []
  type: TYPE_NORMAL
- en: The power of extracting our logic into a Hook comes into full play when we need
    to implement a different UI while maintaining the same underlying functionality.
    By doing so, we’ve segregated our state management and interaction logic from
    the UI rendering, making it a breeze to change the UI without touching the logic.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve explored how utilizing small components with custom Hooks can enhance
    our code structure. However, what happens when we’re faced with managing more
    complex states? Consider a scenario where the drop-down data comes from a service
    API, requiring us to handle asynchronous service calls along with additional state
    management. In such cases, does this structure still hold up effectively?
  prefs: []
  type: TYPE_NORMAL
- en: The scenario of fetching data from a remote source brings forth the necessity
    to manage a few more states – specifically, we need to handle loading, error,
    and data states. As illustrated in *Figure 10**.7*, besides displaying a regular
    list, we also aim to manage scenarios where the data is not immediately accessible
    – either when it’s still loading from a remote API or it isn’t available.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7: Different statuses](img/B31103_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.7: Different statuses'
  prefs: []
  type: TYPE_NORMAL
- en: Such states, while common, are crucial for the user experience. Take, for instance,
    a drop-down list featuring country names. It’s a common feature, yet when we open
    the list, the names might still be loading, during which a loading indicator is
    displayed. Additionally, in situations where the downstream service is unavailable
    or other errors arise, an error message is presented instead.
  prefs: []
  type: TYPE_NORMAL
- en: When extending our existing code, it’s crucial to deliberate on the additional
    states that will be introduced. Let’s explore strategies to preserve simplicity
    as we integrate new features.
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining simplicity in the Dropdown component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Incorporating remote data fetching has not complicated our `Dropdown` component,
    thanks to the abstracted logic in the `useService` and `useDropdown` Hooks. Our
    component code remains in its simplest form, effectively managing the fetching
    states and rendering the content based on the data received:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In this updated `Dropdown` component, we utilize the `useService` Hook to manage
    the data fetching states and the `useDropdown` Hook to manage the drop-down-specific
    states and interactions. The `renderContent` function elegantly handles the rendering
    logic based on the fetching states, ensuring that the correct content is displayed,
    whether it’s loading, an error, or data.
  prefs: []
  type: TYPE_NORMAL
- en: Through the separation of concerns and the use of Hooks, our `Dropdown` component
    remains clean and straightforward, showcasing the power of composable logic in
    React. Now, this pattern actually has a particular name in building UI – the Headless
    Component pattern. Let’s look at it in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Headless Component pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Headless Component pattern** unveils a robust avenue to cleanly segregate
    our JSX code from the underlying logic. While composing a declarative UI with
    JSX comes naturally, the real challenge lies in managing state. This is where
    headless components come into play, by shouldering all the state management intricacies
    and propelling us toward a new horizon of abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, a **Headless Component** is a function or object that encapsulates
    logic but doesn’t render anything itself. It leaves the rendering part to the
    consumer, thus offering a high degree of flexibility in how the UI is rendered.
    This pattern can be exceedingly useful when we have complex logic that we want
    to reuse across different visual representations.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the following code, the `useDropdownLogic` Hook has all the logic
    but no UI elements, while `MyDropdown` uses the headless component and only has
    to deal with rendering logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In a visual representation, the headless component acts as a thin interface
    layer. On one side, it interacts with JSX views, and on the other, it communicates
    with underlying data models. We touched upon data modeling in [*Chapter 8*](B21103_08.xhtml#_idTextAnchor212)
    and will revisit it in [*Chapter 11*](B21103_11.xhtml#_idTextAnchor286). This
    pattern is particularly beneficial for individuals seeking solely the behavior
    or state management aspect of the UI, as it conveniently segregates it from the
    visual representation.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see a visual illustration in *Figure 10**.8*. You can think of your code
    as having a few layers – the JSX is on the top and is response for the look and
    feel part of the application, the headless component (Hooks in this case) manages
    all the stateful logic, and beneath them is the domain layer, which has the logic
    to handle data mapping and transformation (we will go into more detail on this
    in [*Chapter 11*](B21103_11.xhtml#_idTextAnchor286) and [*Chapter 12*](B21103_12.xhtml#_idTextAnchor323)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8: The Headless Component pattern](img/B31103_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.8: The Headless Component pattern'
  prefs: []
  type: TYPE_NORMAL
- en: In summarizing the Headless Component pattern, it’s worth mentioning that although
    it can be realized through HOCs or render props, its implementation as a React
    Hook is more prevalent. Within the Headless Component pattern, all shareable logic
    is encapsulated, allowing for a seamless transition to other UIs without necessitating
    any modifications to the stateful logic.
  prefs: []
  type: TYPE_NORMAL
- en: The advantages and drawbacks of Headless Component pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The advantages of the Headless Component pattern include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reusability**: The logic encapsulated in Headless Component pattern can be
    reused across multiple components. This fosters **Don’t Repeat Yourself** (**DRY**)
    principles in your codebase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Separation of concerns**: By decoupling logic from rendering, headless components
    promote a clear separation of concerns, which is a cornerstone of maintainable
    code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexibility**: They allow for varying UI implementations while sharing the
    same core logic, making it easier to adapt to different design requirements or
    frameworks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The drawbacks of Headless Component pattern include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Learning curve**: The pattern may introduce a learning curve for developers
    unfamiliar with it, potentially slowing down development initially.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Over-abstraction**: If not managed judiciously, the abstraction created by
    headless components can lead to a level of indirection that might make the code
    harder to follow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Libraries and further learnings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Headless Component pattern has been embraced by various libraries to facilitate
    the creation of accessible, customizable, and reusable components. Here are some
    [notable l](https://react-spectrum.adobe.com/react-aria/)ibraries along with a
    brief description of each:'
  prefs: []
  type: TYPE_NORMAL
- en: '**React Aria**: A library from Adobe that provides accessibility primitives
    and Hooks to build inclusive React applications. It offers a collection of Hooks
    to manage keyboard interactions, focus management, and Aria annot[ations, mak](https://headlessui.dev/)ing
    it easier to create accessible UI components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Headless UI**: A completely unstyled, fully accessible UI component library,
    designed to integrate beautifully with Tailwind CSS. It provides the behavior
    and accessibility f[oundation u](https://react-table.tanstack.com/)pon which you
    can build your own styled components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**React Table**: A headless utility for building fast and extendable tables
    and data grids for React. It provides a flexible Hook that allows you to create
    co[mplex tab](https://www.downshift-js.com/)les with ease, leaving the UI representation
    up to you.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Downshift**: A minimalist library to help you create accessible and customizable
    dropdowns, comboboxes, and so on. It handles all the logic while letting you define
    the rendering aspect.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These libraries embody the essence of the Headless Component pattern by encapsulating
    complex logic and behaviors, making it straightforward to create highly interactive
    and accessible UI components. While the provided example serves as a learning
    stepping stone, it’s prudent to leverage these production-ready libraries to build
    robust, accessible, and customizable components in a real-world scenario.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern not only educates us on managing complex logic and state but also
    encourages us to explore production-ready libraries that have honed the Headless
    Component approach, delivering robust, accessible, and customizable components
    for real-world use.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we delved into the world of HOCs and Hooks in React, exploring
    their utility in enhancing component logic while maintaining a clean, readable
    code base. Through the lens of creating an expandable panel and a drop-down list,
    we illustrated the composability of HOCs and the encapsulation of stateful logic
    that Hooks offer. Transitioning to a more intricate drop-down list, we introduced
    asynchronous data fetching, demonstrating how Hooks can simplify state management
    in data-loading scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: We then transitioned into the realm of Headless Component, a powerful pattern
    that separates logic from the JSX code, providing a robust framework to manage
    state while leaving the UI representation to the developer. Through examples,
    we demonstrated how this separation facilitates the creation of reusable, accessible,
    and customizable components. The discussion was enriched with a review of notable
    libraries, such as React Table, Downshift, React Aria, and Headless UI, that embody
    the Headless Component pattern, providing ready-to-use solutions to build interactive
    and accessible UI components.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming chapter, we’ll implement the patterns we’ve discussed and delve
    into architectural strategies to enhance modularity. We’ll also address the challenges
    posed by larger applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 4: Engaging in Practical Implementation'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the final part of this book, you will apply your accumulated knowledge in
    a hands-on manner by employing a layered architecture in React and journeying
    through an end-to-end project implementation. This part aims to encapsulate the
    essence of all the principles, patterns, and practices discussed throughout the
    book.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part contains the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B21103_11.xhtml#_idTextAnchor286), *Introducing Layered Architecture
    in React*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B21103_12.xhtml#_idTextAnchor323), *Implementing an End-To-End
    Project*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B21103_13.xhtml#_idTextAnchor356), *Recapping Anti-Pattern Principles*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
