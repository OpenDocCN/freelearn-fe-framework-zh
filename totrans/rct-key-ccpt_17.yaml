- en: '17'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '17'
- en: Understanding React Suspense & The use() Hook
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 React Suspense 与 use() 钩子
- en: Learning Objectives
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够做到以下内容：
- en: Describe the purpose and functionality of React’s Suspense feature
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述 React 的 Suspense 功能的目的和功能
- en: Use Suspense with RSCs to show fallback content on a granular level
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 RSCs 与 Suspense 一起显示细粒度的回退内容
- en: Use Suspense for client components via React’s `use()` Hook
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 React 的 `use()` 钩子为客户端组件提供 Suspense
- en: Apply different Suspense strategies for data fetching and fallback content
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为数据获取和回退内容应用不同的 Suspense 策略
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In *Chapter 10* , *Behind the Scenes of React and Optimization Opportunities*
    , in the *Reducing Bundle Sizes via Code Splitting (Lazy Loading)* section, you
    learned about React’s `<Suspense>` component and how it may be used in the context
    of lazy loading and code splitting to show fallback content while a code bundle
    is being downloaded.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 10 章* ，*React 和优化机会背后的场景* 中，在 *通过代码拆分（懒加载）减少包大小* 部分中，你学习了 React 的 `<Suspense>`
    组件及其如何在懒加载和代码拆分的上下文中使用，以在下载代码包时显示回退内容。
- en: As explained there, the purpose of the `Suspense` component is to simplify the
    process of showing fallback content, which, in turn, can lead to a better user
    experience. Since staring at outdated content or a blank page is not something
    most users appreciate, having a built-in feature that shows alternative content
    is very convenient.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如该处所述，`Suspense` 组件的目的是简化显示回退内容的过程，这反过来可以提高用户体验。由于大多数用户都不喜欢盯着过时的内容或空白页面，因此拥有一个显示替代内容的内置功能非常方便。
- en: In this chapter, you’ll learn that React’s `Suspense` component is not limited
    to being used for code splitting. Instead, it can also be used for data fetching
    to show some temporary content while data is being loaded (e.g., from a database).
    Though, as you will also learn, `Suspense` can only be used for data fetching
    if the data is fetched in a certain way.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解到 React 的 `Suspense` 组件不仅限于用于代码拆分。相反，它还可以用于数据获取，在数据加载时显示一些临时内容（例如，从数据库中）。然而，正如你也将学到的，`Suspense`
    只能在以特定方式获取数据时用于数据获取。
- en: In addition, this chapter will revisit the `use()` Hook, which was introduced
    in *Chapter 11* , *Working with Complex State* . As you will learn, besides using
    it for getting access to context values, this Hook can be used in conjunction
    with `Suspense` as well.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，本章将重新探讨在 *第 11 章* ，*处理复杂状态* 中引入的 `use()` 钩子。正如你将学到的，除了用于获取上下文值之外，这个钩子还可以与
    `Suspense` 一起使用。
- en: Showing Granular Fallback Content with Suspense
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Suspense 显示细粒度的回退内容
- en: When fetching data or downloading a resource (e.g., a code file), loading delays
    can occur—delays that can lead to a bad user experience. You should therefore
    consider showing some temporary fallback content while waiting for the requested
    resource.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当获取数据或下载资源（例如，代码文件）时，可能会出现加载延迟——这些延迟可能导致糟糕的用户体验。因此，你应该考虑在等待请求的资源时显示一些临时的回退内容。
- en: 'For that reason, to simplify the process of rendering fallback content while
    waiting for some resource, React offers its `Suspense` component. As shown in
    *Chapter 10* , *Behind the Scenes of React and Optimization Opportunities* , you
    can use the `Suspense` component as a wrapper around React elements that fetch
    some code or data. For example, when using it in the context of code splitting,
    you can show some temporary fallback content like this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了简化在等待某些资源时渲染回退内容的过程，React 提供了其 `Suspense` 组件。如 *第 10 章* ，*React 和优化机会背后的场景*
    所示，你可以将 `Suspense` 组件用作围绕 React 元素的包装器，这些元素会获取一些代码或数据。例如，当在代码拆分的情况下使用它时，你可以显示一些临时的回退内容，如下所示：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example (which is from a regular Vite-based React project), React’s
    `Suspense` component is wrapped around the conditionally rendered `DateCalculator`
    component. `DateCalculator` is created with the help of React’s `lazy()` function,
    which is used to lazily (i.e., on demand) load the code bundle that belongs to
    this component.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子（它来自一个基于 Vite 的常规 React 项目）中，React 的 `Suspense` 组件被包裹在条件渲染的 `DateCalculator`
    组件周围。`DateCalculator` 是通过 React 的 `lazy()` 函数创建的，该函数用于按需（即按需）加载属于此组件的代码包。
- en: As a result, the entire other page content is shown right from the start. Only
    the conditionally displayed `DateCalculator` component is replaced with the fallback
    content ( `<p>Loading...</p>` ) while the code is being fetched. Thus, `Suspense`
    is used to render some fallback JSX code on a very granular level. Instead of
    replacing the entire page or component markup with some temporary content, only
    a small part of the UI is replaced.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，整个其他页面的内容从一开始就全部显示出来。在获取代码的过程中，只有条件性显示的`DateCalculator`组件被替换为回退内容（`<p>Loading...</p>`），而其他内容保持不变。因此，`Suspense`在非常细粒度级别上渲染一些回退JSX代码。与用临时内容替换整个页面或组件标记不同，这里只替换了UI的一小部分。
- en: Of course, `Suspense` therefore provides a functionality that would also be
    nice to have when fetching data—after all, delays occur frequently there, too.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`Suspense`因此提供了一种在获取数据时也很希望拥有的功能——毕竟，延迟在那里也经常发生。
- en: Using Suspense for Data Fetching with Next.js
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Next.js进行数据获取的Suspend
- en: As explained in the previous chapter, in the *Managing Loading States with Next.js*
    section, the process of data fetching also often comes with waiting times that
    can negatively impact user experience. That’s why, in that same section, you learned
    that Next.js allows you to define a `loading.js` file that contains some fallback
    component that’s rendered during such a delay.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章中所述，在*使用Next.js管理加载状态*部分，数据获取的过程也常常伴随着等待时间，这可能会对用户体验产生负面影响。这就是为什么，在同一部分中，你学习了Next.js允许你定义一个`loading.js`文件，该文件包含一些在延迟期间渲染的回退组件。
- en: However, using that approach essentially replaces the entire page (or the main
    area of that page) with the loading fallback component content. But that’s not
    always ideal—you instead might want to display some loading fallback content on
    a more granular level when fetching data.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用这种方法实际上是用加载回退组件内容替换了整个页面（或该页面的主要区域）。但这并不总是理想的——你可能在获取数据时更希望在一个更细粒度级别上显示一些加载回退内容。
- en: Thankfully, in Next.js projects, you can use `Suspense` in a similar way, as
    shown in the example from the previous section, to wrap it around components that
    fetch data. Since Next.js supports HTTP response streaming, it’s able to render
    the rest of the page immediately while streaming the content that depends on the
    fetched data to the client side once it’s available. Until the data is loaded
    and available, `Suspense` will render its defined fallback.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在Next.js项目中，你可以像前一个示例中那样使用`Suspense`，将其包裹在获取数据的组件周围。由于Next.js支持HTTP响应流，它能够在数据可用时立即渲染页面的其余部分，并将依赖于获取数据的内
    容流式传输到客户端。在数据加载并可用之前，`Suspense`将渲染其定义的回退内容。
- en: 'Therefore, coming back to the example from the *Managing Loading States with
    Next.js* section of *Chapter 16* , *React Server Components & Server Actions*
    , you can take advantage of `Suspense` by outsourcing the data fetching code into
    a separate `UserGoals` component:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，回到第16章*React服务器组件与服务器操作*中*使用Next.js管理加载状态*的例子，你可以通过将数据获取代码外包给一个单独的`UserGoals`组件来利用`Suspense`：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This `UserGoals` component can then be wrapped with `Suspense` in the `GoalsPage`
    component like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以在`GoalsPage`组件中将`UserGoals`组件包裹在`Suspense`中，如下所示：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code now utilizes React’s `Suspense` component to show a fallback paragraph
    while the `UserGoals` component is fetching data.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码现在利用React的`Suspense`组件在`UserGoals`组件获取数据时显示回退段落。
- en: '**Note**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'You can find the complete demo project code on GitHub: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/17-suspense-use/examples/02-data-fetching-suspense](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/17-suspense-use/examples/02-data-fetching-suspense)
    .'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到完整的演示项目代码：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/17-suspense-use/examples/02-data-fetching-suspense](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/17-suspense-use/examples/02-data-fetching-suspense)。
- en: As a result, when users navigate to `/goals` , they immediately see the title
    (the `<h1>` element) in combination with the fallback content. There is no need
    for a separate `loading.js` file anymore.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当用户导航到`/goals`时，他们立即看到标题（`<h1>`元素）与回退内容的组合。不再需要单独的`loading.js`文件。
- en: '![A screen shot of a computer screen  Description automatically generated](img/B31339_17_01.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图 自动生成描述](img/B31339_17_01.png)'
- en: 'Figure 17.1: The fallback content is shown as part of the target page, instead
    of entirely replacing it'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.1：回退内容作为目标页面的一部分显示，而不是完全替换它
- en: However, the advantage of using `Suspense` in this situation is not just that
    the `loading.js` file isn’t needed anymore. Instead, data fetching and fallback
    content can now be managed on a very granular level.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这种情况下使用 `Suspense` 的优势不仅仅是 `loading.js` 文件不再需要。相反，现在可以非常细致地管理数据获取和回退内容。
- en: 'For example, in a more complex online shop application, you could have a component
    like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在一个更复杂的在线商店应用程序中，你可能有一个这样的组件：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, the `<header>` and `<section id="search">` elements are always
    visible and rendered. On the other hand, `<DailyDeal />` and `<Products />` are
    only rendered once their data has been fetched. Until then, their respective fallbacks
    are displayed.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`<header>` 和 `<section id="search">` 元素始终可见并渲染。另一方面，`<DailyDeal />` 和
    `<Products />` 只在它们的数据被获取后渲染。在此之前，将显示各自的回退内容。
- en: '![A diagram of a website  Description automatically generated](img/B31339_17_02.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![一个网站示意图  自动生成描述](img/B31339_17_02.png)'
- en: 'Figure 17.2: Placeholders are shown initially until loaded data is streamed
    in and rendered to the screen'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.2：最初显示占位符，直到加载的数据流进并渲染到屏幕上
- en: '`<DailyDeal />` and `<Products />` will be loaded and rendered independently
    from each other since they’re wrapped by two different `Suspense` blocks. Consequently,
    users will immediately see the header and search area, and then eventually see
    the daily deal and products—though either of the two may load and render first.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`<DailyDeal />` 和 `<Products />` 将独立于彼此加载和渲染，因为它们被两个不同的 `Suspense` 块包裹。因此，用户将立即看到页眉和搜索区域，然后最终看到每日特价和产品——尽管这两个中的任何一个都可能先加载和渲染。'
- en: What’s important about these examples is that the components wrapped by `Suspense`
    are RSCs that use `async/await` . As you will learn in the next section, not all
    React components will interact with the `Suspense` component. But React Server
    Components, in Next.js projects, will.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例中重要的是，被 `Suspense` 包裹的组件是使用 `async/await` 的 RSCs。正如你将在下一节中学习的，并非所有 React
    组件都会与 `Suspense` 组件交互。但在 Next.js 项目中，React Server Components 会。
- en: Using Suspense in Other React Projects—Possible, But Tricky
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在其他 React 项目中使用 `Suspense`—可能，但棘手
- en: The previous section explored how you may take advantage of `Suspense` for data
    fetching with RSCs in Next.js projects.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节探讨了如何在 Next.js 项目中使用 `Suspense` 来利用 RSCs 进行数据获取。
- en: However, `Suspense` is not a Next.js-specific feature or concept—instead, it’s
    provided by React itself. Consequently, you can use it in any React project to
    show fallback content while data is being fetched.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`Suspense` 不是一个 Next.js 特有的功能或概念——相反，它是 React 本身提供的。因此，你可以在任何 React 项目中使用它来在数据获取时显示回退内容。
- en: At least, that’s the theory. But as it turns out, you can’t use it with all
    components and data fetching strategies.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 至少，这是理论上的。但实际情况是，你无法与所有组件和数据获取策略一起使用它。
- en: Suspense Does Not Work with useEffect()
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Suspense` 与 `useEffect()` 不兼容'
- en: Since fetching data via `useEffect()` is a common strategy, you might be inclined
    to use `Suspense` in conjunction with this Hook to show some fallback content
    while data is being loaded via the effect function.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于通过 `useEffect()` 获取数据是一种常见策略，你可能会倾向于将 `Suspense` 与此 Hook 结合使用，在数据通过效果函数加载时显示一些回退内容。
- en: 'For example, the following `BlogPosts` components uses `useEffect()` to load
    and display some blog posts:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下 `BlogPosts` 组件使用 `useEffect()` 来加载和显示一些博客文章：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You could wrap this component with `Suspense` like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这个组件用 `Suspense` 包裹，如下所示：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Unfortunately, this will not work in the intended way, though. Instead of displaying
    the fallback content, nothing will be rendered while the data is being fetched.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 但不幸的是，这不会按预期工作。在数据获取时，不会渲染任何内容，而是显示回退内容。
- en: The reason for this behavior is that `Suspense` is intended to suspend when
    fetching data during the component rendering process—not when fetching inside
    of some effect function.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为的原因是 `Suspense` 的目的是在组件渲染过程中获取数据时挂起——而不是在某个效果函数内部获取数据时。
- en: 'It helps to recall how `useEffect()` works (from *Chapter 8* , *Handling Side
    Effects* ): the effect function is executed after the component function is executed,
    i.e., after the first component render cycle is done.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这有助于回忆 `useEffect()` 的工作原理（来自 *第8章* ，*处理副作用*）：效果函数在组件函数执行之后执行，即，在第一个组件渲染周期完成后。
- en: As a result, you can’t use `Suspense` to show fallback content when fetching
    data via `useEffect()` . Instead, in those cases, you need to manually manage
    and use some loading state in the component that performs the data fetching (i.e.,
    by manually managing different state slices like `isLoading` —for example, as
    explained and shown in *Chapter 11* , *Working with Complex State* , in the *Limitations
    of useState()* and *Managing State with useReducer()* sections.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在通过 `useEffect()` 获取数据时，你不能使用 `Suspense` 来显示回退内容。相反，在这些情况下，你需要手动管理并使用执行数据获取的组件中的某些加载状态（即通过手动管理不同的状态片段，如
    `isLoading` ——例如，如在第 11 章 *处理复杂状态* 中所述，在 *useState() 的局限性* 和 *使用 useReducer()
    管理状态* 部分中展示）。
- en: Fetching Data while Rendering—the Incorrect Way
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在渲染过程中获取数据——错误的方式
- en: 'Since `Suspense` intends to show fallback content while a component is fetching
    data during its rendering process, you could try to re-write the `BlogPosts` component
    to look like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Suspense` 的目的是在组件在渲染过程中获取数据时显示回退内容，你可以尝试重新编写 `BlogPosts` 组件，使其看起来像这样：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'But trying to use this code will yield an error in the browser developer tools:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 但尝试使用此代码将在浏览器开发者工具中产生错误：
- en: '![A close-up of a message  Description automatically generated](img/B31339_17_03.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![消息的特写  自动生成的描述](img/B31339_17_03.png)'
- en: 'Figure 17.3: React complains about async components on the client side'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.3：React 在客户端对异步组件发出警告
- en: React does not support the usage of `async/await` in client components. Only
    React Server Components may use that syntax (and therefore return promises). Consequently,
    regular React projects, which are not set up to support RSCs, can’t use this solution.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: React 不支持在客户端组件中使用 `async/await`。只有 React Server Components 可以使用该语法（因此返回承诺）。因此，未设置以支持
    RSCs 的常规 React 项目无法使用此解决方案。
- en: 'Of course, you could come up with a (problematic) alternative solution like
    this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以想出一个（有问题的）替代方案，如下所示：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: But this approach was already discarded in *Chapter 8* , *Handling Side Effects*
    , in the *What’s the Problem?* section—the code creates an infinite loop.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种方法已经在第 8 章 *处理副作用* 中的 *问题是什么？* 部分中被弃用——该代码创建了一个无限循环。
- en: So, fetching data as part of a component’s rendering process is really difficult
    when not working with RSCs.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果不与 RSCs（React Server Components）一起工作，将数据获取作为组件渲染过程的一部分是非常困难的。
- en: Getting Suspense Support Is Tricky
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取 Suspense 支持颇具挑战性
- en: 'Since `Suspense` requires data fetching to occur during the rendering process,
    which is difficult to set up manually, the React documentation ( [https://react.dev/reference/react/Suspense#displaying-a-fallback-while-content-is-loading](https://react.dev/reference/react/Suspense#displaying-a-fallback-while-content-is-loading)
    ) itself mentions that *“only Suspense-enabled data sources will activate the
    Suspense component,”* further stating that those data sources include:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Suspense` 需要在渲染过程中进行数据获取，这很难手动设置，因此 React 文档（[https://react.dev/reference/react/Suspense#displaying-a-fallback-while-content-is-loading](https://react.dev/reference/react/Suspense#displaying-a-fallback-while-content-is-loading)）本身提到：“只有启用
    `Suspense` 的数据源才会激活 `Suspense` 组件”，进一步说明这些数据源包括：
- en: Data fetching with Suspense-enabled frameworks like Relay and Next.js
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用像 Relay 和 Next.js 这样的 `Suspense` 启用框架进行数据获取
- en: Lazy-loading components code with `lazy()`
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `lazy()` 懒加载组件代码
- en: Reading the value of a Promise with `use()`
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `use()` 读取 Promise 的值
- en: On the same page, the official documentation highlights that *“Suspense-enabled
    data fetching without the use of an opinionated framework is not yet supported.”*
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一页面上，官方文档强调：“尚未支持使用非意见化框架启用 `Suspense` 的数据获取。”
- en: '**Note**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Documentation may change over time—and so may React. But even though the exact
    wording may differ at the point of time you’re reading this, the way of using
    `Suspense` , and the fact that it can’t be used without special libraries or features
    like `lazy()` , is highly unlikely to change.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 文档可能会随着时间的推移而改变——React 也是如此。但即使在你阅读此内容时，确切的措辞可能有所不同，使用 `Suspense` 的方式以及它不能在没有特殊库或
    `lazy()` 等功能的情况下使用的事实，极不可能改变。
- en: 'This chapter was written when React 19 was released. You can visit the official
    changelog of this book to find out whether anything significant has changed since
    then: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/main/CHANGELOG.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/main/CHANGELOG.md)
    .'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这章是在 React 19 发布时编写的。你可以访问这本书的官方变更日志，以了解自那时以来是否有什么重大变化：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/main/CHANGELOG.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/main/CHANGELOG.md)。
- en: Therefore, unless you plan on building your own Suspense-enabled library, you
    either have to stick to using `Suspense` for code-splitting (via `lazy()` ), use
    a third-party framework or library that integrates with `Suspense` , or explore
    the usage of that `use()` Hook.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，除非你打算构建自己的具有 `Suspense` 功能的库，否则你必须坚持使用 `Suspense` 进行代码拆分（通过 `lazy()`），使用与
    `Suspense` 集成的第三方框架或库，或者探索 `use()` 钩子的使用。
- en: 'Of course, the `lazy()` function (and how to use it with `Suspense` ) was already
    covered in *Chapter 10* , *Behind the Scenes of React and Optimization Opportunities*
    , in the *Reducing Bundle Sizes via Code Splitting (Lazy Loading)* section. But
    what about the other two options: `Suspense` -enabled libraries and the `use()`
    Hook?'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`lazy()` 函数（以及如何与 `Suspense` 一起使用）已经在 *第 10 章* 的 *Behind the Scenes of React
    and Optimization Opportunities* 部分的 *Reducing Bundle Sizes via Code Splitting
    (Lazy Loading)* 中进行了介绍。但其他两个选项——具有 `Suspense` 功能的库和 `use()` 钩子——又是如何的呢？
- en: Using Suspense for Data Fetching with Supporting Libraries
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用支持库进行数据获取的 Suspense
- en: As you learned in the *Using Suspense for Data Fetching with Next.js* section,
    you can use `Suspense` for data fetching when working with Next.js. But while
    Next.js is one of the most popular React frameworks that supports `Suspense` ,
    it’s not the only option you have.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在 *Using Suspense for Data Fetching with Next.js* 部分所学，当使用 Next.js 时，你可以使用
    `Suspense` 进行数据获取。但尽管 Next.js 是支持 `Suspense` 的最受欢迎的 React 框架之一，但它并不是你唯一的选择。
- en: For example, TanStack Query (formerly known as React Query) is another popular
    third-party library that unlocks `Suspense` for data fetching. This library, unlike
    Next.js, is not a library that aims to help with building full-stack React apps
    or running code on the server side, though. Instead, TanStack Query is a library
    that’s all about helping with client-side data fetching, data mutations, and asynchronous
    state management. Since it runs on the client side, it therefore works in React
    projects that do not integrate with SSR and RSCs, too—although you can also use
    it in such projects.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，TanStack Query（之前称为 React Query）是另一个流行的第三方库，它为数据获取解锁了 `Suspense`。这个库与 Next.js
    不同，不是一个旨在帮助构建全栈 React 应用或运行服务器端代码的库。相反，TanStack Query 是一个专注于帮助客户端数据获取、数据变更和异步状态管理的库。由于它在客户端运行，因此它也适用于没有集成
    SSR 和 RSC 的 React 项目——尽管你也可以在这样项目中使用它。
- en: 'TanStack Query is a complex, feature-rich library—we could probably write an
    entire book about it. But the following short code snippet (which is from a Vite-based
    project, not from a Next.js project) shows how you may fetch data with the help
    of that library:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: TanStack Query 是一个复杂且功能丰富的库——我们可能可以写一本书来专门介绍它。但以下简短的代码片段（来自一个基于 Vite 的项目，而不是
    Next.js 项目）展示了如何借助该库获取数据：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, the `BlogPosts` component uses TanStack Query’s `useSuspenseQuery()`
    Hook, in conjunction with a custom `fetchPosts()` function, to fetch data via
    an HTTP request. As the name of the Hook implies, it integrates with React’s `Suspense`
    component.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`BlogPosts` 组件使用 TanStack Query 的 `useSuspenseQuery()` 钩子，结合自定义的 `fetchPosts()`
    函数，通过 HTTP 请求获取数据。正如钩子的名字所暗示的，它与 React 的 `Suspense` 组件集成。
- en: 'As a result, the `BlogPosts` component can then be wrapped with `Suspense`
    like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`BlogPosts` 组件可以像这样被 `Suspense` 包裹：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can tell, `Suspense` is used in the same way it was used with `lazy()`
    or Next.js. So, its functionality and usage don’t change—if you’re wrapping it
    around a component that integrates with `Suspense` (like `BlogPost` does, via
    TanStack Query’s `useSuspenseQuery()` Hook), `Suspense` can be used to output
    some fallback content while some data fetching process is underway.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知，`Suspense` 的使用方式与 `lazy()` 或 Next.js 中的使用方式相同。因此，其功能和使用方式没有改变——如果你正在将
    `Suspense` 包裹在一个与 `Suspense` 集成的组件周围（例如 `BlogPost` 通过 TanStack Query 的 `useSuspenseQuery()`
    钩子），则可以使用 `Suspense` 在数据获取过程进行时输出一些后备内容。
- en: '**Note**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'You can find the complete example project on GitHub: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/17-suspense-use/examples/05-tanstack-query](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/17-suspense-use/examples/05-tanstack-query)
    .'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上找到完整的示例项目：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/17-suspense-use/examples/05-tanstack-query](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/17-suspense-use/examples/05-tanstack-query)。
- en: Of course, this is just a simple example. You can do more with TanStack Query,
    and there also are other libraries that can be used in conjunction with `Suspense`
    . It’s just important to understand that there are other options than Next.js.
    But it’s also crucial to keep in mind that not all code (and also not all libraries)
    will work with `Suspense` .
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是一个简单的例子。你可以用 TanStack Query 做更多的事情，还有其他可以与 `Suspense` 一起使用的库。重要的是要理解，除了
    Next.js 之外，还有其他选择。但也要牢记，并非所有代码（以及并非所有库）都适用于 `Suspense`。
- en: Besides using libraries that directly integrate with `Suspense` (like TanStack
    Query via its `useSuspenseQuery()` Hook), you can also use `Suspense` for data
    fetching with the help of React’s built-in `use()` Hook.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用直接与 `Suspense` 集成的库（如通过 `useSuspenseQuery()` 钩子的 TanStack Query），你还可以借助
    React 的内置 `use()` 钩子使用 `Suspense` 进行数据获取。
- en: use()ing Data while Rendering
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 渲染时使用数据
- en: The `use()` Hook offered by React is not limited to accessing context values,
    as shown in *Chapter 11* , *Working with Complex State* —instead, it may also
    be used to read values from a promise.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: React 提供的 `use()` 钩子不仅限于访问上下文值，如第 11 章 *处理复杂状态* 中所示——相反，它还可以用来从承诺中读取值。
- en: Thus, you can use the `use()` Hook during a component’s rendering process to
    extract and use the value of a promise. `use()` will automatically interact with
    any wrapping `Suspense` component and let it know about the current status of
    the data fetching process (i.e., if the promise has been resolved or not).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以在组件的渲染过程中使用 `use()` 钩子来提取和使用承诺的值。`use()` 将自动与任何包装的 `Suspense` 组件交互，并让它了解数据获取过程的当前状态（即承诺是否已解决）。
- en: 'The example from the *Fetching Data while Rendering—the Incorrect Way* section
    can therefore be adjusted to use the `use()` Hook like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，可以从 *渲染时获取数据——错误方式* 部分的示例调整为使用 `use()` 钩子，如下所示：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `BlogPosts` component is now no longer a component that uses `async/await`
    . Instead, it uses the imported `use()` Hook to read the value of the promise
    produced by calling `fetchPosts()` .
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`BlogPosts` 组件现在不再是一个使用 `async/await` 的组件。相反，它使用导入的 `use()` 钩子来读取调用 `fetchPosts()`
    生成的承诺的值。'
- en: 'As mentioned, `use()` interacts with `Suspense` , hence `BlogPosts` can be
    wrapped with `Suspense` like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`use()` 与 `Suspense` 交互，因此 `BlogPosts` 可以像这样被 `Suspense` 包装：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When running this code, it might work as intended (depending on the React version
    you’re using), but it’s more likely to not yield any results or even show an error
    message in the browser developer tools:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行此代码时，它可能按预期工作（取决于你使用的 React 版本），但更有可能不会产生任何结果，甚至在浏览器开发者工具中显示错误消息：
- en: '![A close-up of a computer error  Description automatically generated](img/B31339_17_04.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![计算机错误的特写  自动生成的描述](img/B31339_17_04.png)'
- en: 'Figure 17.4: The use() Hook only works with promises created by Suspense-compatible
    libraries'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.4：use() 钩子仅与由 Suspense 兼容库创建的承诺一起工作
- en: As explained by this error message, the `use()` Hook is not intended to be used
    with regular promises as created in the previous example. Instead, it should be
    used on promises that are provided by *Suspense-compatible* libraries or frameworks.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如此错误消息所述，`use()` 钩子不打算与像上一个例子中创建的常规承诺一起使用。相反，它应该用于由 *Suspense 兼容* 库或框架提供的承诺。
- en: '**Note**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'If you want to go against the official recommendation and try to build promises
    that support `use()` and `Suspense` , you can explore the official `Suspense`
    demo projects linked in the official React documentation ( [https://19.react.dev/reference/react/Suspense](https://19.react.dev/reference/react/Suspense)
    )—for example, this project: [https://codesandbox.io/p/sandbox/strange-black-6j7nnj](https://codesandbox.io/p/sandbox/strange-black-6j7nnj)
    .'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要违背官方建议并尝试构建支持 `use()` 和 `Suspense` 的承诺，你可以探索官方 React 文档中链接的官方 `Suspense`
    示例项目（[https://19.react.dev/reference/react/Suspense](https://19.react.dev/reference/react/Suspense)）——例如，这个项目：[https://codesandbox.io/p/sandbox/strange-black-6j7nnj](https://codesandbox.io/p/sandbox/strange-black-6j7nnj)。
- en: Please note that, as mentioned in the documentation, the approach used in that
    demo project uses unstable APIs and may not work with future React versions.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，正如文档中提到的，该演示项目使用的是不稳定API，可能无法与未来的React版本兼容。
- en: So, again, support from a third-party framework or library is needed. No matter
    if you try to use `Suspense` with components that fetch data as part of the rendering
    process with or without `use()` , you end up needing help.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，再次强调，需要第三方框架或库的支持。无论你尝试使用`Suspense`与在渲染过程中获取数据的组件（无论是否使用`use()`）一起使用，你最终都需要帮助。
- en: 'Put in other words: to take advantage of `Suspense` , you either need to directly
    fetch data via a Suspense-compatible library or framework, or you need to use
    the `use()` Hook on a promise that’s generated by a Suspense-compatible library
    or framework.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说：为了利用`Suspense`，你需要直接通过一个与`Suspense`兼容的库或框架获取数据，或者你需要在一个由与`Suspense`兼容的库或框架生成的promise上使用`use()`
    Hook。
- en: One such framework is, again, Next.js. Besides using `Suspense` around RSCs,
    as shown in the section *Using suspense for Data Fetching with Next.js* , you
    can also use `Suspense` in conjunction with the `use()` Hook on promises produced
    by Next.js.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个这样的框架又是Next.js。除了在RSC周围使用`Suspense`（如*使用Next.js进行数据获取的suspense*部分所示），你还可以将`Suspense`与Next.js生成的promise的`use()`
    Hook结合使用。
- en: Using use() with Promises Created by Next.js
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用Next.js创建的promise与use()结合使用
- en: Next.js projects are able to create promises that will work with `use()` and
    `Suspense` . To be precise, any promise you create in an RSC and pass to a (client)
    component via props qualifies as a `use()` able promise.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Next.js项目能够创建与`use()`和`Suspense`一起工作的promise。更准确地说，你在RSC中创建并传递给（客户端）组件的任何promise都符合`use()`能用的promise。
- en: 'Consider this example code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例代码：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this code snippet, a promise is created by calling `fetchGoals()` and stored
    in a constant called `fetchGoalsPromise` . The created promise ( `fetchGoalsPromise`
    ) is then passed as a value for the `promise` prop to the `UserGoals` component.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，通过调用`fetchGoals()`创建了一个promise，并将其存储在一个名为`fetchGoalsPromise`的常量中。然后，创建的promise（`fetchGoalsPromise`）被作为`promise`
    prop的值传递给`UserGoals`组件。
- en: 'Along with another component, this `UserGoals` component is defined in the
    `UserGoals.js` file like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这个`UserGoals`组件与另一个组件一起定义在`UserGoals.js`文件中，如下所示：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this code example, the `UserGoals` component uses `Suspense` to wrap the
    `Goals` component to which it essentially forwards the received `promise` prop
    value (via the `fetchGoalsPromise` prop). The `Goals` component then reads that
    promise value via the `use()` Hook.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中，`UserGoals`组件使用`Suspense`包裹`Goals`组件，并将接收到的`promise` prop值（通过`fetchGoalsPromise`
    prop）转发给该组件。然后，`Goals`组件通过`use()` Hook读取该promise值。
- en: Since the promise is created in an RSC ( `GoalsPage` ) that’s managed by Next.js,
    React will not complain about this code—Next.js creates promises that work with
    `use()` . Instead, it will show the fallback content ( `<p id="fallback">Fetching
    user goals...</p>` ) while data is being fetched and renders the final user interface
    once the data has arrived and has been streamed to the client.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于promise是在由Next.js管理的RSC（`GoalsPage`）中创建的，React不会对此代码提出异议——Next.js创建了与`use()`一起工作的promise。相反，它会在数据获取时显示后备内容（`<p
    id="fallback">Fetching user goals...</p>`），一旦数据到达并被流式传输到客户端，就会渲染最终的用户界面。
- en: As explained before, any elements not wrapped by Suspense (i.e., the `<h1>`
    element, in this example) will be displayed right from the start.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，任何未被`Suspense`包裹的元素（例如，本例中的`<h1>`元素）将立即显示。
- en: '![A screen shot of a computer screen  Description automatically generated](img/B31339_17_05.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的描述](img/B31339_17_05.png)'
- en: 'Figure 17.5: The fallback text is shown next to the title while data is fetched
    via use()'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.5：当通过`use()`获取数据时，后备文本显示在标题旁边
- en: It’s also worth noting that both `UserGoals` and `Goals` are RSCs, too—nonetheless,
    they can use the `use()` Hook.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`UserGoals`和`Goals`也都是RSC（React Server Components），尽管如此，它们仍然可以使用`use()`
    Hook。
- en: Normally, Hooks can’t be used in RSCs but the `use()` Hook is special. Just
    as it may be used inside `if` statements or loops (as explained in *Chapter 11*
    , *Working with Complex State* ), it can be executed in both server and client
    components.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Hooks不能在RSC中使用，但`use()` Hook是特殊的。正如它可以在`if`语句或循环中使用（如第11章*处理复杂状态*中所述），它可以在服务器和客户端组件中执行。
- en: However, when working with a server component, you can also simply use `async/await`
    instead of `use()` . Thus, the `use()` Hook is really only useful when it comes
    to reading promise values in client components—there, `async/await` is not available.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当与服务器组件一起工作时，你也可以简单地使用`async/await`而不是`use()`。因此，`use()`钩子实际上只有在客户端组件中读取promise值时才真正有用——在那里，`async/await`不可用。
- en: Using use() in Client Components
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在客户端组件中使用use()
- en: Besides using it for accessing context, the `use()` Hook was introduced to help
    with reading values from promises in client components—i.e., in situations where
    you can’t use `async/await` .
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 除了用于访问上下文之外，`use()`钩子被引入是为了帮助在客户端组件中读取promise值——即在你不能使用`async/await`的情况下。
- en: 'Consider this updated *user goals* example, where some state is managed and
    a side effect is triggered:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个更新的*用户目标*示例，其中管理了一些状态并触发了一个副作用：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example, the `Goals` component uses `useState()` to manage the information
    of which goal was marked as the main goal by the user. Furthermore, the `UserGoals`
    component (which uses `Suspense` ) utilizes the `useEffect()` Hook to send an
    analytics event once the component renders (i.e., before the suspended `Goals`
    component is displayed). Due to the usage of all these client-side exclusive features,
    the `'` `use client'` directive is required.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Goals`组件使用`useState()`来管理用户标记为主要目标的目标信息。此外，`UserGoals`组件（使用`Suspense`）利用`useEffect()`钩子在一旦组件渲染时发送一个分析事件（即在挂起的`Goals`组件显示之前）。由于使用了所有这些客户端特有的功能，需要`use
    client`指令。
- en: As a result, `async/await` can’t be used in the `Goals` and `UserGoals` components.
    But since the `use()` Hook can be used in client components, it offers a possible
    solution for situations like this. And, since this example is from a Next.js application,
    React will not complain about the kind of promise being consumed by `use()` .
    Instead, this example code would lead to the fallback content being displayed
    while the goals data is fetched.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`async/await`不能在`Goals`和`UserGoals`组件中使用。但由于`use()`钩子可以在客户端组件中使用，它为这种情况提供了一种可能的解决方案。而且，由于这个例子来自Next.js应用程序，React不会对`use()`消耗的promise类型提出异议。相反，这段示例代码会导致在获取目标数据时显示后备内容。
- en: Suspense Usage Patterns
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Suspense使用模式
- en: As you have learned, the `Suspense` component can be wrapped around components
    that fetch data as part of their rendering process—as long as they do it in a
    compliant way.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所学，`Suspense`组件可以包裹在那些在渲染过程中获取数据的组件周围——只要它们以合规的方式进行。
- en: Of course, in many projects, you may have multiple components that fetch data
    and that should display some fallback content while doing so. Thankfully, you
    can use the `Suspense` component as often as needed—you can even combine multiple
    `Suspense` components with each other.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在许多项目中，你可能会有多个组件需要获取数据，并且在获取数据的同时应该显示一些后备内容。幸运的是，你可以根据需要频繁地使用`Suspense`组件——你甚至可以将多个`Suspense`组件相互组合。
- en: Revealing Content Together
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一起揭示内容
- en: Thus far, in all examples, `Suspense` was always wrapped around exactly one
    component. But there is no rule that would stop you from wrapping `Suspense` around
    multiple components.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在所有示例中，`Suspense`总是包裹在恰好一个组件周围。但没有任何规则阻止你将`Suspense`包裹在多个组件周围。
- en: 'For example, the following code is valid:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码是有效的：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this code snippet, data fetching in the `DailyDeal` and `Products` components
    starts simultaneously. Since both components are wrapped by one single `Suspense`
    component, the fallback content is displayed unti both components are done fetching
    data. So, if one component (e.g., `DailyDeal` ) is done after one second, and
    the other component ( `Products` ) takes five seconds, both components are only
    revealed (and replace the fallback content) after five seconds.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，`DailyDeal`和`Products`组件的数据获取是同时开始的。由于这两个组件都被一个单一的`Suspense`组件包裹，后备内容在两个组件完成数据获取之前会显示。所以，如果一个组件（例如`DailyDeal`）在一秒后完成，而另一个组件（`Products`）需要五秒，这两个组件只有在五秒后才会被揭示（并替换后备内容）。
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_17_06.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的描述](img/B31339_17_06.png)'
- en: 'Figure 17.6: Data is fetched in parallel, and fallback content is shown via
    Suspense until all components are done'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.6：数据并行获取，并通过Suspense显示后备内容，直到所有组件完成
- en: Revealing Content as Soon as Possible
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尽快揭示内容
- en: Of course, there are situations where you might want to display fallback content
    for multiple components, but where you don’t want to wait for all components to
    finish fetching data before showing any fetched content.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有些情况下，您可能希望为多个组件显示后备内容，但又不希望等待所有组件完成数据获取后才显示任何获取的内容。
- en: 'In such situations, you can use `Suspense` multiple times:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您可以使用 `Suspense` 多次：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this adjusted code example, `DailyDeal` and `Products` are wrapped with two
    different instances of the `Suspense` component. Thus, each component’s content
    will be revealed once available, independent from the other component’s data fetching
    status.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个调整后的代码示例中，`DailyDeal` 和 `Products` 分别被两个不同的 `Suspense` 组件包裹。因此，每个组件的内容将在可用时被揭示，独立于其他组件的数据获取状态。
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_17_07.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成描述](img/B31339_17_07.png)'
- en: 'Figure 17.7: Each component replaces its fallback content with the final content
    once it’s done fetching'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.7：每个组件在完成数据获取后用最终内容替换其后备内容
- en: Nesting Suspended Content
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套挂起内容
- en: Besides fetching in parallel, you can also create more complex loading sequences
    with nested `Suspense` components.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 除了并行获取数据外，您还可以使用嵌套的 `Suspense` 组件创建更复杂的加载顺序。
- en: 'Consider this example:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个例子：
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this case, initially, the paragraph with the text `Fetching shop data` is
    displayed. Behind the scenes, data fetching in the `DailyDeal` and `Products`
    components starts.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，最初，显示文本为“获取商店数据”的段落。幕后，`DailyDeal` 和 `Products` 组件中的数据获取开始。
- en: Once the `DailyDeal` component is done fetching data, its content is displayed.
    At the same time, below `DailyDeal` , the fallback of the nested `Suspense` block
    is rendered if the `Products` component is still fetching data.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `DailyDeal` 组件完成数据获取，其内容将被显示。同时，在 `DailyDeal` 下方，如果 `Products` 组件仍在获取数据，则渲染嵌套
    `Suspense` 块的后备。
- en: Finally, once `Products` has received its data, the inner `Suspense` component’s
    fallback content is removed, and the `Products` component is rendered instead.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦 `Products` 获取了其数据，内部 `Suspense` 组件的后备内容将被移除，并渲染 `Products` 组件。
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_17_08.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成描述](img/B31339_17_08.png)'
- en: 'Figure 17.8: Nested Suspense blocks lead to sequential data fetching and content
    revelation'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.8：嵌套的 `Suspense` 块导致顺序数据获取和内容揭示
- en: Therefore, as you can see, you can use `Suspense` multiple times. In addition,
    you can combine different `Suspense` components such that you can create exactly
    the loading sequence and user experience you need.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如您所见，您可以使用 `Suspense` 多次。此外，您可以将不同的 `Suspense` 组件组合起来，以便您可以创建所需的精确加载顺序和用户体验。
- en: Should You Fetch Data via Suspense or useEffect()?
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您应该通过 `Suspense` 还是 `useEffect()` 获取数据？
- en: As you learned throughout this chapter, you can use `Suspense` in conjunction
    with RSCs, `Suspense` -enabled libraries, or the `use()` Hook (which also requires
    supporting libraries) to fetch data and show some fallback content while data
    is being fetched.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在本章中学习到的，您可以使用 `Suspense` 与 RSCs、`Suspense` 启用的库或 `use()` 钩子（这也需要支持库）一起获取数据，并在数据获取过程中显示一些后备内容。
- en: Alternatively, as covered in *Chapter 11* , *Working with Complex State* , you
    can also fetch data and manually show fallback content via `useEffect()` and `useState()`
    or `useReducer()` . In that case, you essentially manage the state that determines
    whether to show some loading fallback content on your own; with `Suspense` , React
    does that for you.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如第 11 章*处理复杂状态*中所述，您也可以通过 `useEffect()` 和 `useState()` 或 `useReducer()` 手动获取数据并显示后备内容。在这种情况下，您实际上管理着决定是否在您的应用中显示某些加载后备内容的自身状态；使用
    `Suspense`，React 会为您完成这项工作。
- en: Consequently, it’s up to you which approach you prefer. Using `Suspense` can
    save you quite a bit of code since you don’t need to manage these different state
    slices manually. Combined with frameworks like Next.js or libraries like TanStack
    Query, data fetching can therefore become significantly easier than when doing
    it manually via `useEffect()` . In addition, `Suspense` integrates with RSCs and
    SSR and therefore can be used to fetch data on the server side—unlike `useEffect()`
    , which has no effect (no pun intended) on the server side.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，选择哪种方法取决于你。使用 `Suspense` 可以节省相当多的代码，因为你不需要手动管理这些不同的状态片段。结合 Next.js 或 TanStack
    Query 这样的框架或库，数据获取可以比通过 `useEffect()` 手动进行时变得显著更容易。此外，`Suspense` 与 RSCs 和 SSR
    集成，因此可以用于在服务器端获取数据——与 `useEffect()` 不同，它对服务器端没有影响（没有开玩笑）。
- en: However, if you’re not using any library or framework that supports `Suspense`
    or `use()` -enabled promises, you don’t have much of a choice other than to fall
    back to `useEffect()` (and hence not use `Suspense` for data fetching). This may
    change with future React versions, since they might provide tools that help with
    building promises that work with `use()` . But for the time being, it’s basically
    a decision between using (the right) libraries and `Suspense` or no libraries
    and `useEffect()` .
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你没有使用支持 `Suspense` 或 `use()` -启用承诺的库或框架，你除了回退到 `useEffect()`（因此不使用 `Suspense`
    进行数据获取）之外，没有太多选择。随着未来 React 版本的更新，它们可能会提供帮助构建与 `use()` 一起工作的承诺的工具。但到目前为止，这基本上是在使用（正确的）库和
    `Suspense` 或不使用库和 `useEffect()` 之间做出决定。
- en: Summary and Key Takeaways
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要和关键要点
- en: The `Suspense` component can be used to show fallback content while data is
    fetched, or code is downloaded.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Suspense` 组件可用于在数据获取或代码下载时显示回退内容。'
- en: For data fetching, `Suspense` only works with components that fetch data via
    Suspense-enabled data sources during their rendering process.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于数据获取，`Suspense` 仅与在渲染过程中通过 `Suspense` 启用的数据源获取数据的组件一起工作。
- en: Libraries and frameworks like TanStack Query and Next.js support using `Suspense`
    for data fetching.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似于 TanStack Query 和 Next.js 这样的库和框架支持使用 `Suspense` 进行数据获取。
- en: Using Next.js, you can wrap `Suspense` around server components that use `async/await`
    .
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Next.js，你可以将 `Suspense` 包裹在使用 `async/await` 的服务器组件周围。
- en: Alternatively, `Suspense` can be wrapped around components that use React’s
    `use()` Hook for reading a promise value.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，`Suspense` 可以包裹在使用 React 的 `use()` 钩子读取承诺值的组件周围。
- en: '`use()` should only be used to read values of promises that resolve with `Suspense`
    in mind—e.g., promises created by Suspense-compatible third-party libraries.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`use()` 应仅用于读取以 `Suspense` 为目的解决的承诺的值——例如，由与 `Suspense` 兼容的第三方库创建的承诺。'
- en: When using Next.js, promises created in RSCs and passed to (client) components
    via props may be consumed via `use()` .
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用 Next.js 时，在 RSCs 中创建并通过 props 传递给（客户端）组件的承诺可以通过 `use()` 消费。
- en: The `use()` Hook helps with reading values and using `Suspense` in components
    that also need to use client-specific features like `useState()` .
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`use()` 钩子有助于在需要使用客户端特定功能（如 `useState()`）的组件中读取值和使用 `Suspense`。'
- en: '`Suspense` can be wrapped around as many components as needed to fetch data
    and display content simultaneously.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Suspense` 可以包裹任意数量的组件以同时获取数据和显示内容。'
- en: '`Suspense` can also be nested to create complex loading sequences.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Suspense` 也可以嵌套以创建复杂的加载序列。'
- en: What’s Next?
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接下来是什么？
- en: React’s `Suspense` feature can be very useful since it helps with granularly
    showing fallback content while code or data is being fetched. At the same time,
    when it comes to data fetching, it can be tricky to use `Suspense` since it only
    works with components that fetch data in the correct way (e.g., via the `use()`
    Hook, if the promise passed to the Hook is `Suspense` -compatible).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: React 的 `Suspense` 功能非常有用，因为它有助于在代码或数据正在获取时精确地显示回退内容。同时，当涉及到数据获取时，使用 `Suspense`
    可能很棘手，因为它仅与在渲染过程中通过 `use()` 钩子以正确方式获取数据的组件一起工作（例如，如果传递给钩子的承诺是 `Suspense` 兼容的）。
- en: That’s why this chapter also explored how to use `Suspense` and `use()` with
    Next.js, and how that framework simplifies the process of fetching data and showing
    fallback content with `Suspense` and `use()` .
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，本章还探讨了如何使用 `Suspense` 和 `use()` 与 Next.js 一起，以及该框架如何简化使用 `Suspense` 和 `use()`
    获取数据和显示回退内容的过程。
- en: Despite the potential complexity, `Suspense` can help with creating great user
    experiences since it allows you to easily show fallback content while a resource
    is pending.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可能很复杂，但`Suspense`可以帮助创建出色的用户体验，因为它允许你在资源挂起时轻松显示后备内容。
- en: This chapter also concludes the list of core React features you must know about
    as a React developer. Of course, you can always dive deeper to explore more patterns
    and third-party libraries. The next (and last) chapter will share some resources
    and possible next steps you could dive into after finishing this book.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还总结了作为React开发者你必须知道的React核心功能列表。当然，你总是可以深入研究，探索更多模式和第三方库。下一章（也是最后一章）将分享一些资源和可能的下一步行动，你可以在完成这本书后深入研究。
- en: Test Your Knowledge!
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识！
- en: 'Test your knowledge of the concepts covered in this chapter by answering the
    following questions. You can then compare your answers to examples that can be
    found at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/17-suspense-use/exercises/questions-answers.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/17-suspense-use/exercises/questions-answers.md)
    :'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回答以下问题来测试你对本章涵盖的概念的了解。然后，你可以将你的答案与[https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/17-suspense-use/exercises/questions-answers.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/17-suspense-use/exercises/questions-answers.md)中可以找到的示例进行比较：
- en: What’s the purpose of React’s `Suspense` component?
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React的`Suspense`组件的目的是什么？
- en: How do components need to fetch data in order to work with `Suspense` ?
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组件需要如何获取数据才能与`Suspense`一起工作？
- en: How may `Suspense` be used when working with Next.js?
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用Next.js时，`Suspense`可以如何使用？
- en: What’s the purpose of the `use()` Hook?
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`use()`钩子的目的是什么？'
- en: Which kind of promises can be read by the `use()` Hook?
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`use()`钩子可以读取哪种类型的承诺？'
- en: List three ways of using `Suspense` with multiple components.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出三种使用多个组件的`Suspense`方法。
- en: Apply What You Learned
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用你所学的知识
- en: With all the newly gained knowledge about Next.js, it’s time to apply it to
    a real demo project.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了关于Next.js的所有新知识之后，是时候将其应用到实际的演示项目中了。
- en: In the following section, you’ll find an activity that allows you to practice
    working with Next.js and `Suspense` . As always, you will also need to employ
    some of the concepts covered in earlier chapters.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将找到一个活动，让你练习使用Next.js和`Suspense`。一如既往，你还需要应用前面章节中介绍的一些概念。
- en: 'Activity 17.1: Implement Suspense in the Mini Blog'
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动十七点一：在迷你博客中实现Suspense
- en: In this activity, your job is to build upon the finished project from *Activity
    16.1* . There, a very simple blog was built. Now, your task is to enhance this
    blog to show some fallback content while the list of blog posts or the details
    for an individual blog post are loading. To prove your knowledge, you should fetch
    data via `async/await` on the starting page ( `/` ), and via the `use()` Hook
    on the `blog/<some-id>` page.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你的任务是建立在*活动16.1*完成的工程之上。在那里，建立了一个非常简单的博客。现在，你的任务是增强这个博客，以便在博客文章列表或单个博客文章的详细信息加载时显示一些后备内容。为了证明你的知识，你应该在起始页面（`/`）上通过`async/await`获取数据，并在`blog/<some-id>`页面上通过`use()`钩子获取数据。
- en: In addition, the list of available blog posts should also be displayed below
    the details for a single blog post. Of course, while fetching that list data,
    some fallback text must be displayed—though, that text should be displayed independently
    from the fallback content for the blog post details.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还应将可用的博客文章列表显示在单个博客文章的详细信息下方。当然，在获取该列表数据时，必须显示一些后备文本——尽管，该文本应独立于博客文章详细信息的后备内容显示。
- en: '**Note**'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: You can find a starting project snapshot for this activity at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/17-suspense-use/activities/practice-1-start](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/17-suspense-use/activities/practice-1-start)
    . When downloading this code, you’ll always download the entire repository. Make
    sure to then navigate to the subfolder with the starting code ( `activities/practice-1-start`
    , in this case) to use the right code snapshot.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/17-suspense-use/activities/practice-1-start](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/17-suspense-use/activities/practice-1-start)找到这个活动的起始项目快照。在下载此代码时，你将始终下载整个仓库。请确保然后导航到包含起始代码的子文件夹（在这种情况下是`activities/practice-1-start`），以使用正确的代码快照。
- en: In the provided starting project, you’ll find functions for fetching all blog
    posts and a single post. These functions contain artificial delays to simulate
    slow servers.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供的起始项目中，您将找到用于获取所有博客帖子和一个单个帖子的函数。这些函数包含人工延迟以模拟缓慢的服务器。
- en: 'After downloading the code and running `npm install` in the project folder
    to install all required dependencies, the solution steps are as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目文件夹中下载代码并运行 `npm install` 以安装所有必需的依赖项后，解决方案步骤如下：
- en: Outsource the logic for fetching and displaying a list of posts into a separate
    component.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将获取和显示博客帖子列表的逻辑外包到一个单独的组件中。
- en: Use that component on the starting page and use React’s `Suspense` component
    to display some fitting fallback content while the blog posts are being fetched.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在起始页面上使用该组件，并使用 React 的 `Suspense` 组件在获取博客帖子时显示一些合适的后备内容。
- en: Also, outsource the logic for retrieving and rendering the details for a single
    blog post into a separate client (!) component. Output that newly created component
    on the `/blog/<some-id>` page.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，将获取和渲染单个博客帖子详情的逻辑外包到一个单独的客户端 (!) 组件中。在 `/blog/<some-id>` 页面上输出这个新创建的组件。
- en: Pass a promise for fetching the details of a blog to that newly created component,
    and use the `use()` Hook to read its value. Also, take advantage of the `Suspense`
    component to output some fallback content.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将获取博客详情的承诺传递给新创建的组件，并使用 `use()` 钩子来读取其值。同时，利用 `Suspense` 组件输出一些后备内容。
- en: Re-use the component that fetches and renders a list of blog posts and output
    it below the blog post details on the `/blog/<some-id>` page. Use `Suspense` to
    show some fallback content, independently from the data fetching status of the
    blog post details.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新使用获取并渲染博客帖子列表的组件，并在 `/blog/<some-id>` 页面下方输出它。使用 `Suspense` 来显示一些后备内容，独立于博客帖子详情的数据获取状态。
- en: 'The final page should look as shown in the following screenshots:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 最终页面应如以下截图所示：
- en: '![img](img/B31339_17_09.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_17_09.png)'
- en: 'Figure 17.9: Fallback content is shown while the blog posts are fetched'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.9：在获取博客帖子时显示后备内容
- en: '![img](img/B31339_17_10.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/B31339_17_10.png)'
- en: 'Figure 17.10: Fallback content is shown while fetching blog post details and
    the list of blog posts'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.10：在获取博客帖子详情和博客帖子列表时显示后备内容
- en: '**Note**'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'You can find the full code for this activity, and an example solution, here:
    [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/17-suspense-use/activities/practice-1](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/17-suspense-use/activities/practice-1)
    .'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到此活动的完整代码和示例解决方案：[https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/17-suspense-use/activities/practice-1](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/17-suspense-use/activities/practice-1)
    .
