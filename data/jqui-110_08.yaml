- en: Chapter 8. The Button and Autocomplete Widgets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第八章 按钮和自动完成小部件
- en: The button and autocomplete widgets are two of the more recent additions to
    the library, and were released with Version 1.8.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮和自动完成小部件是库中较新的添加项之一，并随版本1.8发布。
- en: Traditionally, it has been tricky to style the form elements consistently across
    all browsers and platforms, and to confound this, most browsers and platforms
    render the form controls uniquely. Both of the widgets covered in this chapter
    are used to improve some of the traditional form elements that are used on the
    web.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，在所有浏览器和平台上一致地为表单元素设置样式是棘手的，并且使情况更加复杂的是，大多数浏览器和平台都以独特的方式呈现表单控件。本章介绍的这两个小部件用于改进Web上使用的一些传统表单元素。
- en: The button widget allows us to create visually appealing and highly configurable
    buttons from elements, including the `<button>`, `<input>`, and `<a>` elements
    that can be styled with themes generated using ThemeRoller. The types of the `<input>`
    element that are supported include `submit`, `radio`, and `checkbox`. Additional
    features, such as icons, button sets, and split buttons can be used to further
    enhance the underlying controls.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮小部件允许我们从元素创建外观引人注目且高度可配置的按钮，包括`<button>`、`<input>`和`<a>`元素，可以使用ThemeRoller生成的主题进行样式设置。支持的`<input>`元素类型包括`submit`、`radio`和`checkbox`。还可以使用附加功能，如图标、按钮集和分割按钮来进一步增强底层控件。
- en: The autocomplete widget is attached to a standard text `<input>` and is used
    to provide a menu of contextual selections. When the visitor begins typing in
    the `<input>` element, the suggestions that match the characters entered into
    the control are displayed.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 自动完成小部件附加到标准文本`<input>`上，并用于提供上下文选择菜单。当访客开始在`<input>`元素中输入时，将显示与输入控件中输入的字符匹配的建议。
- en: Autocomplete is fully accessible through the keyboard input, allowing the list
    of suggestions to be navigated with the arrow keys, a selection made with the
    **Enter** key, and the menu closed with the *Esc* key. When the arrow keys are
    used to navigate the list of suggestions, each suggestion will be added to the
    `<input`> element before a selection is made. If the *Esc* key is used to close
    the menu after the list has been navigated, the value of the `<input>` element
    will revert to the text entered by the visitor.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 通过键盘输入，自动完成可以完全访问，允许使用箭头键导航建议列表，使用**Enter**键进行选择，并使用*Esc*键关闭菜单。当使用箭头键导航建议列表时，每个建议都将添加到`<input>`元素中，然后才能进行选择。如果在导航列表后使用*Esc*键关闭菜单，则`<input>`元素的值将恢复为访客输入的文本。
- en: 'In this chapter we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: Standard button implementations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准按钮实现
- en: Configurable options
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可配置选项
- en: Adding icons
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加图标
- en: Button events
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮事件
- en: Button sets
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮集
- en: Button methods
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮方法
- en: Using local data sources with autocomplete
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自动完成与本地数据源
- en: The configurable options of autocomplete
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动完成的可配置选项
- en: Autocomplete events
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动完成事件
- en: Unique methods of autocomplete
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动完成的独特方法
- en: Using remote data sources with autocomplete
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用远程数据源与自动完成
- en: Using HTML in the autocomplete suggestions menu
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在自动完成建议菜单中使用HTML
- en: Introducing the button widget
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍按钮小部件
- en: The button widget is used to provide a consistent, fully-themed styling to a
    range of elements and input types. The widget can be created from several different
    elements and the resulting DOM of the widget, as well as the features that can
    be used, will vary slightly depending on which element is used.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮小部件用于为一系列元素和输入类型提供一致的、完全主题化的样式。小部件可以从几种不同的元素创建，并且所得到的小部件的DOM以及可用的特性将根据使用的元素略有不同。
- en: 'A standard button widget, built from either a `<button>`, `<a>`, or `<input>`
    element with a type of `button`, `submit`, or `reset` will appear as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一个标准的按钮小部件，可以通过`<button>`、`<a>`或`<input>`元素构建，其类型为`button`、`submit`或`reset`，将显示如下：
- en: '![Introducing the button widget](img/2209OS_08_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![介绍按钮小部件](img/2209OS_08_01.jpg)'
- en: Implementing the standard buttons
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现标准按钮
- en: As the button can be built from several different elements, there are some minor
    variations of the underlying code that we can use. When creating buttons using
    the `<a>`, `<button>`, or `<span>` element will be created automatically by the
    widget and nested within the underlying element. This new `<span>` will contain
    the text label of the button.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '由于按钮可以从几种不同的元素构建，因此我们可以使用一些微小的底层代码变化。 当使用<a>、<button>或<span>元素创建按钮时，小部件将自动创建并嵌套在底层元素内。
    这个新的<span>将包含按钮的文本标签。  '
- en: 'To create a link button, use the following code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '要创建链接按钮，请使用以下代码：  '
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Save this file as `button1.html`. The script required to create a button, when
    using an `<a>` element as the underlying HTML can be as simple as this, which
    should be added after the last `<script>` element in the previous code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '将此文件保存为`button1.html`。 使用<a>元素作为底层HTML时创建按钮所需的脚本可能像这样简单，应该在先前代码的最后一个<script>元素之后添加：  '
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this case, no special behavior is added to the resulting button; the `<a>`
    element will simply send the visitor to the new page or anchor specified in the
    `href` attribute of the anchor. In this case, the widget is simply themed consistently
    with other jQuery UI widgets that we may be using in the page or site. Markup
    is automatically added by the widget when compiled in the browser—if you use a
    DOM inspector such as Firebug, you will see the following code for `button1.html`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '在这种情况下，生成的按钮没有添加任何特殊行为；<a>元素只会将访问者发送到锚点的新页面或指定的页面。 在这种情况下，小部件只是与页面或站点中可能使用的其他jQuery
    UI小部件一致地进行主题设置。 在浏览器中编译时，小部件会自动添加标记——如果您使用像Firebug这样的DOM检查器，您将看到`button1.html`的以下代码：  '
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The button widget requires the following library resources:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '按钮小部件需要以下库资源：  '
- en: '`jquery.ui.all.css`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jquery.ui.all.css`  '
- en: '`jquery-2.0.3.js`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jquery-2.0.3.js`  '
- en: '`jquery.ui.core.js`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jquery.ui.core.js`  '
- en: '`jquery.ui.widget.js`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jquery.ui.widget.js`  '
- en: '`jquery.ui.button.js`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jquery.ui.button.js`  '
- en: Creating buttons using the <input> or <button> tags
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '使用<input>或<button>标签创建按钮  '
- en: We are not limited to just using hyperlinks to create buttons; the button widget
    will also work with the `<input>` or `<button>` tags.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '我们不仅限于使用超链接创建按钮；按钮小部件也可以与<input>或<button>标签一起使用。  '
- en: It is imperative that the `type` attribute of the element is set when using
    `<input>`, so that the appearance of the button matches that of other buttons
    created from other underlying elements. For a standard, single button widget,
    the `type` attribute can be set to be `submit`, `reset`, or `button`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '在使用`<input>`时，必须设置元素的`type`属性，以便按钮的外观与从其他底层元素创建的按钮的外观相匹配。 对于标准的单个按钮小部件，可以将`type`属性设置为`submit`、`reset`或`button`。  '
- en: 'Creating a button from a `<button>` element is identical to the code used in
    `button1.html` (except that we don''t add a `href` attribute to the `<button>`
    tag):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '从<button>元素创建按钮与在`button1.html`中使用的代码相同（只是我们不向<button>标签添加href属性）:  '
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Creating a button from an `<input>` element is also very similar except that
    we use the `value` attribute to set the text on the button instead of adding text
    content to the `<input>` tag:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '使用<input>元素创建按钮也非常相似，只是我们使用`value`属性来设置按钮上的文本，而不是将文本内容添加到<input>标记中：  '
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Theming
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '主题化  '
- en: Like all widgets, the button has a variety of class names added to it, which
    contribute to its overall appearance. Of course, we can use the theme's class
    names in our own stylesheets to override the default appearance of the theme in
    use, if we wish to provide custom styling. ThemeRoller is still usually the best
    tool for theming buttons.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '像所有小部件一样，按钮也有各种添加到它上面的类名，这些类名有助于其整体外观。 当然，如果希望提供自定义样式，我们可以在自己的样式表中使用主题的类名来覆盖正在使用的主题的默认外观。
    对于主题按钮，ThemeRoller通常仍然是最佳工具。  '
- en: Exploring the configurable options
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '探索可配置选项  '
- en: 'The button widget has the following configuration options:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '按钮小部件具有以下配置选项：  '
- en: '| Option | Default Value | Usage |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 默认值 | 用途 |  '
- en: '| --- | --- | --- |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |  '
- en: '| `disabled` | `false` | Disables the button instance. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `disabled` | `false` | 禁用按钮实例。  '
- en: '| `icons` | `{primary: null, secondary: null}` | Sets the icons for the button
    instance. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `icons` | `{primary: null, secondary: null}` | 设置按钮实例的图标。  '
- en: '| `label` | `The content of the underlying element or value attribute` | Sets
    the text of the button instance. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `label` | `底层元素或值属性的内容` | 设置按钮实例的文本。  '
- en: '| `text` | `true` | Hides the text of the button when using an icon-only instance.
    |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `text` | `true` | 在仅使用图标的实例时隐藏按钮的文本。  '
- en: 'In our first example, the text content of the `<a>` element was used as the
    button''s label. We can easily override this using the `label` option. Change
    the final `<script>` element in `button1.html`, so that it appears as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个示例中，`<a>`元素的文本内容被用作按钮的标签。我们可以通过使用`label`选项轻松覆盖此内容。将`button1.html`中的最终`<script>`元素更改为以下内容：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Save this file as `button2.html`. As we'd expect, when we run this file in a
    browser, we see that the `<span>` within the button widget takes the configured
    text as its label, instead of the text content of the `<a>` element.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`button2.html`。正如我们所预期的那样，当我们在浏览器中运行此文件时，我们看到按钮部件内的`<span>`采用配置的文本作为其标签，而不是`<a>`元素的文本内容。
- en: Adding the button icons
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加按钮图标
- en: We can easily configure our buttons, so that they have up to two icons in most
    cases. Whenever an `<a>` or `<button>` element is used as the underlying element
    for the button, we can use the icons' configuration option to specify one or two
    icons.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地配置我们的按钮，以便在大多数情况下具有最多两个图标。每当`<a>`或`<button>`元素被用作按钮的底层元素时，我们可以使用图标的配置选项来指定一个或两个图标。
- en: 'To see icons in action, change the configuration object in `button2.html`,
    so that it appears as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看图标的效果，请修改`button2.html`中的配置对象，使其显示如下：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Save this file as `button3.html`. The `icons` property accepts an object with
    up to two keys; `primary` and `secondary`. The values of these options can be
    any of the `ui-icon-` classes found in the `jquery.ui.theme.css` file. The icons
    that we set are displayed as shown in the following screenshot:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`button3.html`。`icons`属性接受一个最多有两个键的对象；`primary`和`secondary`。这些选项的值可以是`jquery.ui.theme.css`文件中找到的任何`ui-icon-`类。我们设置的图标显示如下所示的屏幕截图：
- en: '![Adding the button icons](img/2209OS_08_02.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![添加按钮图标](img/2209OS_08_02.jpg)'
- en: The icons are added to the widget using additional `<span>` elements, which
    are automatically created and inserted by the widget. The `primary` icon is displayed
    to the left of the button text, while the `secondary` icon is displayed to the
    right of the text.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图标是通过额外的`<span>`元素添加到部件中的，这些元素是由部件自动创建并插入的。`primary`图标显示在按钮文本的左侧，而`secondary`图标显示在文本的右侧。
- en: 'To generate an icon-only button that has no text label, change the configuration
    object in `button3.html` to the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成一个只有图标而没有文本标签的按钮，将`button3.html`中的配置对象更改为以下代码：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Save this file as `button4.html`. When we view this variation in a browser,
    we see that the button displays only two icons as shown in the following screenshot:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`button4.html`。当我们在浏览器中查看此变体时，我们看到按钮只显示了两个图标，如下面的屏幕截图所示：
- en: '![Adding the button icons](img/2209OS_08_03.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![添加按钮图标](img/2209OS_08_03.jpg)'
- en: Input icons
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入图标
- en: As child `<span>` elements are used to display the specified icons, we cannot
    use icons when using an `<input>` element as an underlying markup for a button
    instance. We can add our own icons when using the `<input>` elements, by adding
    an extra container, the required `<span>` elements, and some custom CSS.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于子`<span>`元素用于显示指定的图标，所以当使用`<input>`元素作为按钮实例的底层标记时，我们无法使用图标。当使用`<input>`元素时，我们可以通过添加额外的容器、必需的`<span>`元素和一些自定义CSS来添加我们自己的图标。
- en: 'Change the `<body>` of `button4.html`, so that it contains the following elements:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 将`button4.html`的`<body>`更改为包含以下元素：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Save this file as `button5.html`. We''ll also need to override some of the
    button''s styling for this example. Create a new stylesheet and add to it the
    following basic styles:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`button5.html`。我们还需要覆盖一些按钮的样式以供本示例使用。创建一个新的样式表，并将以下基本样式添加到其中：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In older versions of Internet Explorer, the `display: inline-block` style will
    not be applied. To prevent the button taking up the full width of its container,
    we would need to float it, or set a width explicitly.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '在较旧版本的Internet Explorer中，`display: inline-block`样式将不会被应用。为了防止按钮占用其容器的整个宽度，我们需要将其浮动，或者显式地设置宽度。'
- en: 'Save this file in the `css` directory as `buttonTheme.css`. Don''t forget to
    link to the new stylesheet from the `<head>` element of our page (after the link
    to the standard jQuery UI stylesheet):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存在`css`目录中，名称为`buttonTheme.css`。不要忘记从我们页面的`<head>`元素中链接到新样式表（在标准jQuery
    UI样式表之后）：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Visually our custom `<input>` based widget is complete, but practically it''s
    not quite there; the icons do not pick up the correct hover states (the reason
    for this is that the widget has applied the required class names to the underlying
    `<input>` element instead of our custom container). We can add the required behavior,
    like we have added the container and `<span>` elements, using jQuery. Change the
    code in the final `<script>` element, so that it appears as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 从视觉上看，我们基于自定义`<input>`的小部件已经完成，但实际上它还没有完全完成；图标没有正确地捕获悬停状态（这是因为小部件已经将所需的类名应用到了底层的`<input>`元素而不是我们的自定义容器）。我们可以使用jQuery添加所需的行为，就像我们已经添加了容器和`<span>`元素一样。更改最终的`<script>`元素中的代码，使其如下所示：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now our button should work as intended. As the previous example shows, although
    it's technically feasible to manually add the elements, the styling and the behavior
    required to add icons to a button built from an `<input>` element, in most cases,
    it will be easier and more efficient to simply use an `<a>` or `<button>` element.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的按钮应该按预期工作了。正如上一个示例所示，虽然从技术上讲手动添加元素是可行的，但要将图标添加到从`<input>`元素构建的按钮所需的样式和行为，在大多数情况下，使用`<a>`或`<button>`元素会更容易且更有效。
- en: Adding the Button events
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加按钮事件
- en: Buttons that are built from `<a>` elements will work as intended with no further
    intervention from us—the browser will simply follow the `href` as we would expect—provided
    the `<button>` or `<input>` elements are within a `<form>` element and have the
    relevant type attribute set. These elements will submit the form data in the standard
    way.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由`<a>`元素构建的按钮将按预期方式工作，无需我们进一步干预——浏览器将简单地按照我们期望的方式跟随`href`——只要`<button>`或`<input>`元素位于`<form>`元素内，并设置了相关的类型属性。这些元素将以标准方式提交表单数据。
- en: If more modern AJAX submission of any `<form>` data is required, or if the button
    is to trigger some other action or process, we can use standard jQuery click event
    handlers to react to the button being clicked.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要更现代的任何`<form>`数据的AJAX提交，或者按钮要触发某些其他操作或流程，我们可以使用标准的jQuery点击事件处理程序来对按钮的单击做出反应。
- en: 'In the next example, we use the following underlying markup for the button
    widget:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们使用以下底层标记构建按钮小部件：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The button widget exposes a single event, the `create` event, which is fired
    when the button instance is initially created. We could use this event to run
    additional code each time a button instance is created. For example, if we wanted
    the button to be initially hidden from view (in order to display later, after
    something else has occurred), we could use `.css()` to set the `displa`y property
    to `none`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮小部件公开了一个事件，即`create`事件，该事件在按钮实例最初创建时触发。我们可以使用此事件每次创建按钮实例时运行其他代码。例如，如果我们希望按钮最初被隐藏（以便稍后显示，之后发生其他事情），我们可以使用`.css()`将`display`属性设置为`none`。
- en: 'Replace the `document.ready()` code in `button5.html`, with the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 将`button5.html`中的`document.ready()`代码替换为以下代码：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Save this file as `button6.html`. Within the event handler, `$(this)` refers
    to the button instance, which is hidden from view using jQuery's `css()` method.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`button6.html`。在事件处理程序中，`$(this)`指的是按钮实例，使用jQuery的`css()`方法隐藏了它。
- en: In order for the button to fulfill its primary purpose, that is, to do something
    when clicked, we should attach a handler to the button manually. We might want
    to collect some registration information from our visitors, for example, and use
    a button to send this information to the server.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使按钮实现其主要目的，即在单击时执行某些操作，我们应该手动将处理程序附加到按钮上。例如，我们可能希望从访问者那里收集一些注册信息，并使用按钮将此信息发送到服务器。
- en: 'Replace the `<button>` in `button6.html` with the following code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 将`button6.html`中的`<button>`替换为以下代码：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Change the final `<script>` element to the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 将最终的`<script>`元素更改为以下代码：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Save this file as `button7.html`. The underlying `<button>` element is now part
    of a simple `<form>`, which simply provides text inputs for the visitor, their
    name, and an e-mail address. In the script, we first initialize the button widget,
    before creating a `click` event handler. This prevents the default action of the
    browser, which would be to post the form in a traditional non-AJAX way.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`button7.html`。底层的`<button>`元素现在是一个简单的`<form>`的一部分，该`<form>`只为访问者提供文本输入，他们的姓名和电子邮件地址。在脚本中，我们首先初始化按钮小部件，然后创建一个`click`事件处理程序。这样可以防止浏览器的默认操作，即以传统的非AJAX方式提交表单。
- en: We then collect the name and e-mail address entered into the fields, and post
    the data to the server asynchronously using jQuery's `post()` method. In the success
    handler for the request, we use the widget's `option` method to disable the button,
    then create and display a thanks message.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们收集输入字段中输入的姓名和电子邮件地址，并使用jQuery的`post()`方法异步地将数据发送到服务器。在请求的成功处理程序中，我们使用小部件的`option`方法来禁用按钮，然后创建并显示感谢消息。
- en: 'We''re not interested in the server-side of things in this example, and we
    don''t include any validation (although the latter should be included in production
    use), but you can see how easy it is to react to the button being clicked using
    standard jQuery functionality. To see the example work, we''ll need to run the
    page through a web server, and should add a PHP file of the name specified in
    the request in the same directory as the page (which doesn''t need to contain
    anything for the purposes of this example). The following screenshot shows how
    the page should appear after the button has been clicked:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们不关心服务器端的事情，也不包括任何验证（尽管后者应该在生产中包含），但是你可以看到使用标准的jQuery功能来对按钮点击作出反应有多么容易。要看示例的工作方式，我们需要通过Web服务器运行该页面，并且应该在与页面相同目录中添加一个与请求中指定名称相同的PHP文件（这个文件不需要包含任何内容）。以下截图显示了点击按钮后页面应该显示的样子：
- en: '![Adding the Button events](img/2209OS_08_04.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![添加按钮事件](img/2209OS_08_04.jpg)'
- en: Creating button sets
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建按钮组
- en: The button widget can also be used in conjunction with radio buttons and checkboxes.
    The button component is unique in jQuery UI, in that it has not one but two widget
    methods. It has the `button()` method that we have already looked at, and it has
    the `buttonset()` method, which is used to create groups of buttons based on radio
    buttons and checkboxes.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮组件还可以与单选按钮和复选框一起使用。按钮组件在jQuery UI中是独一无二的，因为它不止有一个，而是有两个小部件方法。它有我们已经介绍过的`button()`方法，还有用于基于单选按钮和复选框创建按钮组的`buttonset()`方法。
- en: Checkbox button sets
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复选框按钮组
- en: 'Change the `<body>` element of `button7.html`, so that it contains the following
    code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 更改`button7.html`的`<body>`元素，使其包含以下代码：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now change the final `<script>` element, so that it appears as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在更改最终的`<script>`元素，使其如下所示：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Save this file as `button8.html`. All we need to do is call the `buttonset()`
    method on the container in which the `<label>` and `<input>` elements reside.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`button8.html`。我们只需要在包含`<label>`和`<input>`元素的容器上调用`buttonset()`方法。
- en: 'When we run this file in a browser, we see that the checkboxes are hidden from
    view and the `<label>` elements are converted into buttons and grouped visually
    in a horizontal set as shown in the following screenshot:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在浏览器中运行此文件时，我们会看到复选框被隐藏，`<label>`元素被转换为按钮，并在水平的组中进行可视化分组，如下截图所示：
- en: '![Checkbox button sets](img/2209OS_08_05.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![复选框按钮组](img/2209OS_08_05.jpg)'
- en: Although the actual checkboxes themselves are hidden from view behind the buttons,
    whenever a button is selected, the underlying checkbox will have its `checked`
    attribute updated, so we can still harvest the states from script with ease.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然实际的复选框本身被隐藏在按钮后面，但是每当选择按钮时，底层复选框的`checked`属性将被更新，所以我们仍然可以轻松地从脚本中获取状态。
- en: When a checkbox button is clicked, it will have a selected state applied to
    it by the widget, so that the visitor can easily see that it has been selected.
    As we would expect, multiple buttons may be selected at once.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击复选框按钮时，小部件会将选定状态应用于它，以便访问者可以轻松地看到它已被选择。正如我们所期望的那样，可以同时选择多个按钮。
- en: There are a couple of rules that we need to adhere to when creating buttons
    from checkboxes. In HTML5, it is common to nest form controls within their associated
    `<label>` elements (we did this in an earlier example), but this is not allowed
    when using the button widget. Using the `for` attribute with the `<label>` element
    is required.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建复选框按钮时，我们需要遵守一些规则。在HTML5中，通常在其关联的`<label>`元素内嵌表单控件（我们在之前的示例中这样做了），但是在使用按钮小部件时，这是不被允许的。需要使用`for`属性与`<label>`元素。
- en: Radio button sets
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单选按钮组
- en: Buttons based on radio buttons are visually the same as those based on checkboxes;
    they differ only in their behavior. Only one button can be selected at any one
    time, whereas multiple buttons can be selected when using checkboxes.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 基于单选按钮的按钮与基于复选框的按钮在外观上是相同的；它们的行为不同。同一时间只能选择一个按钮，而使用复选框时可以选择多个按钮。
- en: 'Let''s see this behavior in action in `button8.html`; change the elements in
    `<body>` to the following code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`button8.html`中看到这种行为的效果；将`<body>`中的元素更改为以下代码：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Save this file as `button9.html`. The script to initialize radio buttons is
    the same: we simply call the `buttonset()` method on the container. The only difference
    to the underlying markup, other than specifying `radio` as the type, is that these
    `<input>` elements must have the `name` attribute set.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`button9.html`。初始化单选按钮的脚本相同：我们只需在容器上调用`buttonset()`方法。除了将`type`指定为`radio`之外，底层标记的唯一区别是这些`<input>`元素必须设置`name`属性。
- en: Working with button methods
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用按钮方法
- en: The button widget comes with the default `destroy`, `disable`, `enable`, `widget`,
    and `option` methods common to all widgets. In addition to these methods, the
    button widget exposes one custom method, which is the `refresh` method. This method
    is used for changing the state of checkbox and radio buttons, if they are changed
    programmatically. By combining some of the previous examples, we can see this
    method in action.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，按钮小部件带有`destroy`、`disable`、`enable`、`widget`和`option`方法，这些方法对所有小部件都是通用的。除了这些方法之外，按钮小部件还公开了一个自定义方法，即`refresh`方法。如果以编程方式更改复选框和单选按钮的状态，可以使用此方法。通过结合前面的一些示例，我们可以看到此方法的作用。
- en: 'Change the `<body>` of `button8.html`, so that it includes two new `<button>`
    elements as shown in the following code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 更改`button8.html`的`<body>`，使其包含两个新的`<button>`元素，如下所示的代码：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this example, we have reverted to the checkboxes, so that we can programmatically
    select or deselect them as a group. Now change the final `<script>` element, so
    that it appears as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们已经恢复到复选框，以便我们可以以编程方式选择或取消选择它们作为一组。现在更改最终的`<script>`元素，使其如下所示：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Save this file as `button10.html`. If we preview the results in a browser,
    you can see the effect by clicking on the **Select All** button as shown in the
    following screenshot:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`button10.html`。如果我们在浏览器中预览结果，您可以通过单击下图所示的**全选**按钮来看到效果：
- en: '![Working with button methods](img/2209OS_08_06a.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![使用按钮方法](img/2209OS_08_06a.jpg)'
- en: In this example, we have a **Select All** button and a **Deselect All** button.
    When the **Select All** button is clicked, we set the checked attribute of the
    checkboxes to `true`. This will check the underlying (and hidden) checkboxes,
    but it won't do anything to the `<label>` elements that are styled to appear as
    buttons. To update the state of these buttons, so that they appear selected, we
    call the `refresh` method.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们有一个**全选**按钮和一个**取消全部**按钮。当单击**全选**按钮时，我们将复选框的`checked`属性设置为`true`。这将检查底层（以及隐藏的）复选框，但不会对被样式化为按钮的`<label>`元素执行任何操作。为了更新这些按钮的状态，使它们显示为选定状态，我们调用`refresh`方法。
- en: The **Deselect All** button sets the `checked` attribute to `false`, and then
    calls the `refresh` method again to remove the selected states from each button.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**取消全部**按钮将`checked`属性设置为`false`，然后再次调用`refresh`方法以从每个按钮中移除所选状态。'
- en: Introducing the autocomplete widget
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍自动完成小部件
- en: The autocomplete widget, reintroduced in jQuery UI 1.8, is back and looking
    better than ever. This is one of my favorite widgets in the library, and although
    it doesn't yet have the full set of behavior that it had in its first incarnation,
    it still provides a rich set of functionality to enhance simple text inputs that
    expect data from a predefined range.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 自jQuery UI 1.8重新引入的自动完成小部件比以往任何时候都要好。这是我在库中最喜欢的小部件之一，尽管它还没有第一次版本中拥有的全部行为集合，但它仍然提供了丰富的功能集，以增强期望来自预定义范围的简单文本输入的功能。
- en: A good example is cities; you have a standard `<input type="text">` on the page,
    which asks for the visitor's city. When they begin typing in the `<input>` element,
    all of the cities that contain the letter that the visitor has typed are displayed.
    The range of cities that the visitor can enter is finite and constrained to the
    country in which the visitor lives (this is either assumed by the developer or
    has already been selected previously by the visitor).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的例子是城市；您在页面上有一个标准的`<input type="text">`，询问访问者的城市。当他们在`<input>`元素中开始输入时，将显示包含访问者已键入字母的所有城市。访问者可以输入的城市范围是有限的，并且受限于访问者所在国家（这要么由开发人员假设，要么已被访问者先前选择）。
- en: 'The following screenshot shows how this widget appears:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了此小部件的外观：
- en: '![Introducing the autocomplete widget](img/2209OS_08_06.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![介绍自动完成小部件](img/2209OS_08_06.jpg)'
- en: Like other widgets, a range of elements and class names are added programmatically
    when the widget is initialized.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 像其他小部件一样，在小部件初始化时会以编程方式添加一系列元素和类名。
- en: Working with local data sources
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用本地数据源
- en: 'To implement a basic autocomplete with a local array as its data source, create
    the following code in a new file:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用本地数组作为数据源实现基本的自动完成，请在新文件中创建以下代码：
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'All we need on the page is a standard `<input>` element of the `text` type.
    The initialization required for autocomplete is slightly larger than that required
    for other components; add the following `<script>` element, after the autocomplete
    source file:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面上我们所需的只是一个标准的`<input>`元素的`text`类型。自动完成所需的初始化略多于其他组件所需的初始化；在自动完成源文件之后添加以下`<script>`元素：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Save this file as `autocomplete1.html`. In our configuration object for the
    autocomplete, we use the `source` option to specify a local array of strings.
    The `source` option is mandatory and must be defined. The object is then passed
    to the `autocomplete` method, which is called on the city `<input>` that the autocomplete
    is to be associated with.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`autocomplete1.html`。在我们的自动完成的配置对象中，我们使用`source`选项来指定一个本地字符串数组。`source`选项是强制的，并且必须被定义。然后将该对象传递给`autocomplete`方法，在提供了autocomplete关联的城市`<input>`上调用该方法。
- en: When we run this file in a browser, we should find that as we begin to type
    into the `<input>` element, a list of the cities defined in our source array that
    contain the letter(s) that we have typed is displayed in a drop-down menu attached
    to the `<input>`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在浏览器中运行这个文件时，应该发现当我们开始在`<input>`元素中输入时，将会显示包含我们已输入的字母的源数组中定义的城市的下拉菜单。
- en: 'The autocomplete widget requires the following files in order to function:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使自动完成小部件正常工作，需要以下文件：
- en: '`jquery.ui.all.css`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jquery.ui.all.css`'
- en: '`jquery-2.0.3.js`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jquery-2.0.3.js`'
- en: '`jquery.ui.core.js`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jquery.ui.core.js`'
- en: '`jquery.ui.widget.js`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jquery.ui.widget.js`'
- en: '`jquery.ui.position.js`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jquery.ui.position.js`'
- en: '`jquery.ui.menu.js`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jquery.ui.menu.js`'
- en: '`jquery.ui.autocomplete.js`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jquery.ui.autocomplete.js`'
- en: Using an array of objects as the data source
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用对象数组作为数据源
- en: 'In addition to providing an array of strings, we can also supply an array of
    objects as the data source, which gives us more flexibility over the text added
    to the `<input>` when a suggestion from the menu is selected. Change the configuration
    object in `autocomplete1.html`, so that it appears as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供一个字符串数组外，我们还可以提供一个对象数组作为数据源，这样我们就可以更灵活地控制菜单中从列表中选择建议时添加到`<input>`的文本。修改`autocomplete1.html`中的配置对象，使其如下所示：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Save this file as `autocomplete2.html`. Each item in the array that we are
    using as the data source is now an object, instead of a simple string. Each object
    has two keys: `value` and `label`. The value of the `value` key is the text that
    is added to the `<input>` element when a suggestion is selected from the list.
    The value of `label` is what is displayed in the suggestion list. Other keys,
    which store custom data can also be used.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`autocomplete2.html`。我们现在正在使用作为数据源的数组中的每个项目都是一个对象，而不是一个简单的字符串。每个对象有两个键：`value`和`label`。`value`键的值是从建议列表中选择一个建议时添加到`<input>`元素中的文本。`label`的值是在建议列表中显示的内容。也可以使用其他键存储自定义数据。
- en: If each object in the array contains only a single property, the property will
    be used as both the `value` and `label` key. In this case, we might as well use
    an array of strings instead of an array of objects, but it is worth noting the
    alternative format of the local data.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数组中的每个对象只包含一个属性，则该属性将被用作`value`和`label`键。在这种情况下，我们可能会使用字符串数组而不是对象数组，但值得注意的是本地数据的另一种格式。
- en: Configurable autocomplete options
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可配置的自动完成选项
- en: 'The following options can be set in order to modify the behavior of the widget:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 可以设置以下选项来修改小部件的行为：
- en: '| Option | Default Value | Usage |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 默认值 | 用途 |'
- en: '| --- | --- | --- |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `appendTo` | `"body"` | Specifies which element to append the widget to.
    |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `appendTo` | `"body"` | 指定将小部件附加到哪个元素。 |'
- en: '| `autofocus` | `false` | Focuses the first suggestion in the list when displaying
    the list of suggestions. |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `autofocus` | `false` | 在显示建议列表时，使列表中的第一个建议获得焦点。 |'
- en: '| `delay` | `300` | Specifies the number of milliseconds the widget should
    wait before displaying the list of suggestions, after the visitor has started
    typing in the `<input>`. |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `delay` | `300` | 指定在访客开始在`<input>`中输入后，小部件应在显示建议列表之前等待的毫秒数。 |'
- en: '| `disabled` | `false` | Disables the widget. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `disabled` | `false` | 禁用小部件。 |'
- en: '| `minLength` | `1` | Specifies the number of characters the visitor needs
    to enter in the `<input>` before the list of suggestions is displayed. Can be
    set to `0` to make the widget display all suggestions in the menu. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `minLength` | `1` | 指定访问者需要在`<input>`中输入的字符数，然后建议列表才会显示出来。可以设置为`0`以使部件在菜单中显示所有建议。'
- en: '| `position` | `{ my: "left top", at: "left bottom", collision: "none" }` |
    Specifies how the list of suggestions should be positioned relative to the `<input>`
    element. This option is used in the exact same way, and accepts the same values
    as the position utility that we looked at earlier in the book. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `position` | `{ my: "left top", at: "left bottom", collision: "none" }` |
    指定建议列表相对于`<input>`元素应该定位的方式。该选项使用方式与我们之前在本书中看到的`position`实用程序完全相同，接受相同的值。'
- en: '| `source` | `Array, String or Function` | Specifies the data source used to
    fill the list of suggestions. This option is mandatory and must be configured.
    It accepts an array, string, or function as its value. |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `source` | `Array, String or Function` | 指定用于填充建议列表的数据源。此选项是强制性的，必须进行配置。它将数组、字符串或函数作为其值。'
- en: Configuring minimum length
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置最小长度
- en: The `minLength` option allows us to specify the minimum number of characters
    that need to be typed into the associated `<input>` element before the list of
    suggestions is displayed. By default, the suggestions that are displayed by the
    widget only contain the letters typed into the `<input>` element, rather than
    just those starting with the entered letters, which can result in many more suggestions
    being displayed than is necessary.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`minLength` 选项允许我们指定在建议列表显示之前必须在关联的`<input>`元素中键入的最小字符数。默认情况下，部件显示的建议只包含键入到`<input>`元素中的字母，而不仅仅是以输入字母开头的字母，这可能会导致显示比必要更多的建议。'
- en: Setting the `minLength` option to a number higher than the default value of
    `1` can help narrow the list of suggestions, which may be much more important
    when dealing with large remote data sources.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 将`minLength`选项设置为比默认值`1`更高的数字可以帮助缩小建议列表，当处理大型远程数据源时，这可能更加重要。
- en: 'Change the configuration object that we used in `autocomplete1.html` (we''ll
    revert to using an array of strings as the data source for the time being), so
    that it appears as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 更改我们在`autocomplete1.html`中使用的配置对象（暂时回到使用字符串数组作为数据源），使其显示如下：
- en: '[PRE24]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Save this file as `autocomplete3.html`. When we run this file in a browser,
    we should find that we need to type two characters into the `<input>`, and only
    cities that contain the characters in consecutive order are displayed, which vastly
    reduces the number of suggestions.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`autocomplete3.html`。当在浏览器中运行此文件时，我们应该发现需要在`<input>`中键入两个字符，只有包含连续顺序字符的城市才会显示出来，这大大减少了建议的数量。
- en: Although the benefits are not obvious in this basic example, this can greatly
    reduce the data returned by a remote data source.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在这个基本示例中，好处并不明显，但这可以大大减少远程数据源返回的数据量。
- en: Appending the suggestion list to an alternative element
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将建议列表附加到另一个元素
- en: By default, the suggestion list is appended to the `<body>` of the page, when
    using their autocomplete widget. We can change this, and specify that the list
    should be added to another element on the page. The autocomplete widget then uses
    the `position` utility to position the list, so that it appears to be attached
    to the `<input>` element it is associated with. We can change this and specify
    that the list should be added to another element on the page, by using the `appendTo`
    option.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，使用自动补全部件时，建议列表会附加到页面的`<body>`中。我们可以更改这一点，并指定列表应添加到页面上的另一个元素。然后自动补全部件使用`position`实用程序来定位列表，使其看起来附加到与其关联的`<input>`元素。我们可以使用`appendTo`选项更改这一点，并指定列表应添加到页面上的另一个元素。
- en: 'Wrap the underlying `<label>` and `<input>` in a container `<div>` in `autocomplete3.html`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在`autocomplete3.html`中，将基础的`<label>`和`<input>`包装在容器`<div>`中：
- en: '[PRE25]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then change the configuration object in the final `<script>` element to the
    following code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将最终`<script>`元素中的配置对象更改为以下代码：
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Save this file as `autocomplete4.html`. Usually, the suggestion list is added
    right at the bottom of the `<body>` element of the code. The `appendTo` option
    accepts a jQuery selector or an actual DOM element as its value.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`autocomplete4.html`。通常，建议列表被添加到代码的`<body>`元素的最底部。`appendTo`选项接受一个jQuery选择器或实际的DOM元素作为其值。
- en: In this example, we see that the list is appended to our `<div>` container instead
    of the `<body>` element, which we can verify using Firebug, or another DOM explorer.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们看到列表被附加到我们的`<div>`容器而不是`<body>`元素，我们可以使用Firebug或另一个DOM浏览器进行验证。
- en: Working with autocomplete events
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理自动完成事件
- en: 'The autocomplete widget exposes a range of unique events that allow us to react
    programmatically to the widget being interacted with. These events are listed
    as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 自动完成小部件公开了一系列独特的事件，允许我们对与小部件的交互做出程序化反应。这些事件列在下面：
- en: '| Event | Fired when... |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 事件 | 在...时触发 |'
- en: '| --- | --- |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `change` | A suggestion from the list is selected. This event is fired once
    the list has closed and the `<input>` has lost focus. |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `change` | 从列表中选择了一个建议。此事件在列表关闭并且`<input>`失去焦点后触发。 |'
- en: '| `close` | The suggestion list is closed. |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `close` | 关闭建议菜单。 |'
- en: '| `create` | An instance of the widget is created. |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `create` | 小部件的一个实例已创建。 |'
- en: '| `focus` | The keyboard is used to focus a suggestion in the list. |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `focus` | 键盘用于聚焦列表中的建议。 |'
- en: '| `open` | The suggestion menu is displayed. |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `open` | 显示建议菜单。 |'
- en: '| `search` | The request for the suggestions is about to be made. |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `search` | 即将发出建议请求。 |'
- en: '| `select` | A suggestion from the list is selected. |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `select` | 从列表中选择了一个建议。 |'
- en: 'The `select` event is useful when we are working with an array of objects as
    the data source and have additional data other than the `label` and `value` properties
    that we used earlier. For the next example, remove the `<div>` container that
    we used in the last example and then change the configuration object, so that
    it appears as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用对象数组作为数据源并且除了我们之前使用的`label`和`value`属性之外还有其他数据时，`select`事件非常有用。对于下一个示例，删除我们在上一个示例中使用的`<div>`容器，然后更改配置对象，使其如下所示：
- en: '[PRE27]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Save this file as `autocomplete5.html`. We've added an extra property to each
    object in our array data source—the population of each city. We use the `select`
    event to obtain the label and our extra property, and write them to the page whenever
    a city is selected.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`autocomplete5.html`。我们在数组数据源的每个对象中添加了一个额外的属性——每个城市的人口。当选择了一个城市时，我们使用`select`事件获取标签和我们的额外属性，并在页面上写入它们。
- en: The event handler that we pass to the `select` event accepts the `event` object
    and the object from the data source that was selected. The `.length` test is used
    to determine if the `pop` element exists on the page. If it does, we simply replace
    the text within it, with the updated statement. If not, we create a new `<p>`
    element, with an `id` of `pop`, and insert this immediately after the `city` input
    field. We can access any property defined within our object in the standard way.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给`select`事件的事件处理程序接受`event`对象和所选数据源中的对象。`.length`测试用于确定页面上是否存在`pop`元素。如果存在，我们只需用更新后的语句替换其中的文本。如果没有，则创建一个具有`pop`的`id`的新`<p>`元素，并将其立即插入到`city`输入字段之后。我们可以以标准方式访问对象中定义的任何属性。
- en: 'Once a city has been selected, the page should appear as shown in the following
    screenshot:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 选择了一个城市后，页面应该如下截图所示：
- en: '![Working with autocomplete events](img/2209OS_08_07.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![处理自动完成事件](img/2209OS_08_07.jpg)'
- en: The autocomplete methods
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动完成方法
- en: 'In addition to the standard methods that all widgets share, the autocomplete
    gives us two unique methods that allow us to initiate certain actions. The unique
    methods are listed as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 除了所有小部件共享的标准方法之外，自动完成还为我们提供了两种允许我们启动某些操作的独特方法。这些独特的方法列在下面：
- en: '| Method | Usage |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 用法 |'
- en: '| --- | --- |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `close` | Close the suggestion menu. |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `close` | 关闭建议菜单。 |'
- en: '| `search` | Request the list of suggestions from the data source specifying
    the search term as an optional argument |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `search` | 请求从数据源中获取建议列表，并将搜索词作为可选参数指定。'
- en: 'The `close` method is extremely easy to use, we simply call the `autocomplete`
    widget method and specify `close` as an argument:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`close`方法非常容易使用，我们只需调用`autocomplete`小部件方法，并将`close`指定为参数：'
- en: '[PRE28]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This will cause the suggestions menu to be closed, and the `close` event to
    be triggered. A possible use for the close event handler is to alert the user
    if there is a problem with the entry they have selected; if it doesn't match an
    entry in a predefined list, then this can be flagged to the user.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致关闭建议菜单，并触发`close`事件。关闭事件处理程序的一个可能用法是在用户选择的条目有问题时向用户发出警告；如果它与预定义列表中的条目不匹配，则可以向用户标记这一点。
- en: The `search` method is slightly more complex, in that it can accept an additional
    argument, although this is not mandatory. If the search method is called without
    passing an argument (which is likely to be the default behavior), the value of
    the associated `<input>` element is used as the search term. Alternatively, the
    term can be provided to the method as the argument.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`search`方法稍微复杂一些，因为它可以接受一个附加参数，尽管这不是强制的。如果调用搜索方法而没有传递参数（这可能是默认行为），则关联的`<input>`元素的值将用作搜索项。或者，术语可以作为参数提供给该方法。'
- en: Working with remote data sources
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理远程数据源
- en: So far in this example, we've worked with a rather small local array of data.
    The autocomplete widget really comes into its own when working with remote data
    sources, which is the recommended way of using the widget when the data source
    is large.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这个例子中，我们已经使用了一个相当小的本地数据数组。当处理远程数据源时，自动完成小部件真正发挥其作用，这也是当数据源很大时使用该小部件的推荐方式。
- en: Retrieving content based on input
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 根据输入检索内容
- en: 'In the next example, we''ll use a web service to retrieve the list of countries
    instead of using our local array. Change the `<input>` element in `autocomplete5.html`,
    so that it appears as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个例子中，我们将使用Web服务来检索国家列表，而不是使用我们的本地数组。将`autocomplete5.html`中的`<input>`元素更改为以下内容：
- en: '[PRE29]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then change the final `<script>` element, so that the configuration object
    is defined as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然后改变最后的`<script>`元素，使得配置对象定义如下：
- en: '[PRE30]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Save this file as `autocomplete6.html`. We changed the `<input>` element in
    this example, as we are requesting the visitor's country instead of a city.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`autocomplete6.html`。在这个例子中，我们改变了`<input>`元素，因为我们请求的是访客的国家，而不是城市。
- en: We have specified a string as the value of the source configuration object in
    this example. When a string is supplied to this option, the string should contain
    a URL that points to a remote resource. The widget assumes that the resource will
    output JSON data, and it assumes that the JSON data will be in the format that
    we saw earlier when using an array of objects as the source.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们已经将一个字符串指定为源配置对象的值。当将字符串提供给此选项时，字符串应包含指向远程资源的URL。小部件假定该资源将输出JSON数据，并且假定JSON数据将以我们之前使用对象数组作为源时看到的格式输出。
- en: Therefore, when using a simple string as the value of the `source` option, the
    data that is returned should be an array of objects, where each object contains
    at least a key called `label`. The data can be in JSON or JSONP format for cross-domain
    requests. The widget will automatically add the query string `term=`, followed
    by whatever was typed into the `<input>` element.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当使用简单字符串作为`source`选项的值时，返回的数据应该是一个对象数组，其中每个对象至少包含一个名为`label`的键。对于跨域请求，数据可以是JSON或JSONP格式。小部件将自动添加查询字符串`term=`，后跟输入到`<input>`元素中的任何内容。
- en: 'In this example, I have specified a URL of my own website. The resource at
    this URL will output the data in the correct format, so you can run this example
    from your desktop computer (without even needing a web server) and see the correct
    behavior as shown in the following screenshot:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我指定了自己网站的一个URL。这个URL上的资源将以正确的格式输出数据，所以你可以从你的台式电脑上运行这个例子（甚至不需要一个Web服务器），并看到如下屏幕截图中所示的正确行为：
- en: '![Retrieving content based on input](img/2209OS_08_08.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![根据输入检索内容](img/2209OS_08_08.jpg)'
- en: One important point that I should make is about the PHP file that I have used.
    It will only return entries from the database that start with the letter(s) typed
    into the `<input>` element, and do not contain the letters as is the default for
    the widget. I wanted to clarify that this is a change that I implemented at the
    server level, and not behavior exhibited by the widget.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该指出的一个重要点是关于我使用的PHP文件。它只会返回以键入到`<input>`元素中的字母开头的条目，而不包含像小部件默认的字母。我想澄清的是，这是我在服务器级别实现的变化，而不是小部件表现出的行为。
- en: So, using a string as the value of the `source` option is useful and convenient
    when we have a data source that outputs data in the exact format we require, which
    is usually when we are in control of the web service that returns the data, as
    well as the data itself. This may not be the case if we are trying to extract
    data from a public web service over which we have no control. In these situations,
    we will need to use a function as the value of the `source` option and parse out
    the data manually.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们控制返回数据的Web服务以及数据本身时，将字符串用作`source`选项的值是有用且方便的，因为这通常是当我们控制返回数据的Web服务以及数据本身时的情况。如果我们试图从我们无法控制的公共Web服务中提取数据，则可能不是这种情况。在这些情况下，我们将需要将函数作为`source`选项的值，并手动解析数据。
- en: Passing a function as a source option
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将函数作为源选项传递
- en: Passing a function to the `source` option, instead of a local array or a string,
    is the most powerful way of working with the widget. In this scenario, we have
    complete control over the request and how the data is processed before being passed
    to the widget to display in the suggestion menu.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数传递给`source`选项，而不是本地数组或字符串，是使用小部件的最强大方式。在这种情况下，我们完全控制请求以及在将数据传递给小部件显示在建议菜单中之前对数据进行处理的方式。
- en: 'In this example, we''ll use a different PHP file that returns different data
    which is not in the format that autocomplete expects. We''ll use the function
    to request and process the data before passing it to the widget. The context of
    the example will be the frontend for a messaging system similar to Facebook''s,
    in which the autocomplete suggests possible message recipients, but can also be
    removed after they have been selected and added to the `<input>` element. The
    page we will end up with will appear as in the following screenshot:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们将使用返回不符合自动完成预期格式的不同数据的不同PHP文件。我们将使用函数来请求和处理数据，然后将其传递给小部件。示例的上下文将是类似于Facebook的消息系统的前端，在此自动完成建议可能的消息接收者，但在被选择并添加到`<input>`元素后也可以将其删除。我们将得到的页面将如下截图所示：
- en: '![Passing a function as a source option](img/2209OS_08_09.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![将函数作为源选项传递](img/2209OS_08_09.jpg)'
- en: 'To start with, change the `<body>` of `autocomplete6.html`, so that it contains
    the following markup:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，更改`autocomplete6.html`的`<body>`，使其包含以下标记：
- en: '[PRE31]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then change the final `<script>` element, so that it appears as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将最终的`<script>`元素更改为以下内容：
- en: '[PRE32]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Save this file as `autocomplete7.html`. On the page, we've got some basic markup
    for a form and the necessary elements to recreate the Facebook-style message dialog.
    To test the effect, try entering Admiral Ozzel, Fode, or Han Solo into the textbox,
    then selecting their name when the autocomplete displays their entry.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`autocomplete7.html`。在页面上，我们有一些基本的表单标记和必要的元素，以重新创建类似Facebook样式的消息对话框。为了测试效果，尝试在文本框中输入Admiral
    Ozzel、Fode或Han Solo，然后在自动完成显示其条目时选择其名称。
- en: Note
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: The autocomplete parameter will only display certain names; if you would like
    to see possible options, then I would recommend browsing to [http://danwellman.co.uk/contacts.php](http://danwellman.co.uk/contacts.php).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 自动完成参数只会显示特定的名称；如果您想查看可能的选项，则建议浏览至[http://danwellman.co.uk/contacts.php](http://danwellman.co.uk/contacts.php)。
- en: We use a `<div>` element that is styled to look just like an `<input>` element,
    with a totally unstyled actual `<input>` within this.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个被样式化的`<div>`元素，看起来就像一个没有样式的实际`<input>`元素，内部包含一个完全没有样式的实际`<input>`。
- en: The actual `<input>` is needed, so that the visitor can type into it and so
    that it can be associated with the autocomplete. We use the `<div>` element because
    we can't insert the `<span>` elements that will make up each contact into the
    `<input>` element. We also have a hidden `<input>` element, which will be used
    to store the actual e-mail addresses.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的`<input>`是必需的，以便访问者可以在其中输入，并且可以与自动完成相关联。我们使用`<div>`元素，因为我们无法将构成每个联系人的`<span>`元素插入`<input>`元素中。我们还有一个隐藏的`<input>`元素，将用于存储实际的电子邮件地址。
- en: In the script, we use the `getData` function as the value of our `source` option;
    this is called every time the text in the `<input>` field is updated. We first
    make a JSON request to the PHP file containing the data and then iterate over
    each item in the JSON object returned by the request.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本中，我们使用`getData`函数作为我们`source`选项的值；每次更新`<input>`字段中的文本时都会调用此函数。我们首先向包含数据的PHP文件发出JSON请求，然后迭代请求返回的JSON对象中的每个项目。
- en: Each newly created object is added to the `suggestions` array, and once each
    item in the returned data has been processed, the `suggestions` array is passed
    to the `resp` callback function, which is passed to the `source` function as the
    second argument.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 每个新创建的对象都被添加到`suggestions`数组中，一旦返回数据的每个项目都被处理，`suggestions`数组就被传递给`resp`回调函数，该函数作为第二个参数传递给`source`函数。
- en: We then define the `selectEmail` handler for the autocomplete's `select` event;
    this function is automatically passed to two arguments, which are the `event`
    object and a `ui` object containing the suggestion that was selected. We use this
    function to create a `<span>` element to format and hold the text and an anchor
    element that can be used to remove the recipient. The formatted `<span>` is then
    inserted directly before the camouflaged `<input>` element.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为自动完成的`select`事件定义了`selectEmail`处理程序；此函数将自动传递给两个参数，一个是`event`对象，另一个是包含所选建议的`ui`对象。我们使用这个函数创建一个`<span>`元素来格式化并保存文本，并且一个可以用来移除收件人的锚元素。格式化的`<span>`然后直接插入在伪装的`<input>`元素之前。
- en: Lastly, we added a click handler for the `#friends` field, so that this gains
    focus when anyone clicks inside it. A click handler has also been added to the
    `#to` field, so that if you click inside it, it will automatically remove the
    contents of the previous entry.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们为`#friends`字段添加了一个点击处理程序，以便在任何人点击它时获得焦点。还为`#to`字段添加了一个点击处理程序，以便如果您在其中单击，它将自动删除先前输入的内容。
- en: 'We''ll also need a stylesheet to go with this example; add the following CSS
    to a new file:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为这个示例添加一个样式表；在一个新文件中添加以下 CSS：
- en: '[PRE33]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Save this file as `autocompleteTheme.css` in the `css` folder, and link to
    the new file from the `<head>` of our new page:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件另存为`autocompleteTheme.css`，放在`css`文件夹中，并且在我们新页面的`<head>`中链接到新文件：
- en: '[PRE34]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: When we run the page in a browser, we should find that we can type into the
    `<input>` element, select a name from the suggestions menu, and get a nicely formatted
    and styled name added to the fake input.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在浏览器中运行页面时，我们应该发现我们可以在`<input>`元素中输入，从建议菜单中选择一个名字，并且得到一个格式化和样式良好的名字添加到假输入中。
- en: Displaying HTML in the list of suggestions
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在建议列表中显示 HTML
- en: By default, the autocomplete widget will only display plain text for each suggestion
    in the list. Of course, this plain text is within HTML elements created by the
    widget, but nevertheless, if we try to use HTML within our data source, then it
    will be stripped out and ignored. However, Scott González, the current project
    leader for jQuery UI, has written an extension that allows us to use HTML for
    each suggestion in the list instead of plain text, if the need arises.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，自动完成小部件将只显示建议列表中每个建议的纯文本。当然，这些纯文本在小部件创建的HTML元素内，但是如果我们尝试在数据源中使用HTML，那么它将被剥离并被忽略。然而，jQuery
    UI的当前项目领导者斯科特·冈萨雷斯编写了一个扩展，允许我们在需要时使用HTML代替纯文本来显示建议列表中每个建议。
- en: This could be handy if we wanted to highlight to the visitor the parts of the
    suggestion that matched with what they had typed in the `<input>` element. We
    will need the extension for this example, which can be found at [https://github.com/scottgonzalez/jquery-ui-extensions/blob/master/src/autocomplete/jquery.ui.autocomplete.html.js](https://github.com/scottgonzalez/jquery-ui-extensions/blob/master/src/autocomplete/jquery.ui.autocomplete.html.js).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要突出显示与访问者在`<input>`元素中输入的内容匹配的建议部分，这可能很方便。我们需要扩展这个示例，可以在[https://github.com/scottgonzalez/jquery-ui-extensions/blob/master/src/autocomplete/jquery.ui.autocomplete.html.js](https://github.com/scottgonzalez/jquery-ui-extensions/blob/master/src/autocomplete/jquery.ui.autocomplete.html.js)找到。
- en: 'The file can be saved in our local `js` directory and a reference to it should
    be included on the page, after the source file for the autocomplete:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 文件可以保存在我们本地`js`目录中，并且在页面中添加对它的引用，放在自动完成源文件后：
- en: '[PRE35]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Before we make a start on our code, let''s take a look at how it will appear,
    when previewed in a browser:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编码之前，让我们看一下在浏览器中预览时的效果：
- en: '![Displaying HTML in the list of suggestions](img/2209OS_08_10.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![在建议列表中显示HTML](img/2209OS_08_10.jpg)'
- en: In our next example, we're going to make use of Scott's plugin with the autocomplete
    widget, to allow a user to search for some city names. If there is a match, each
    letter in the selection drop-down will begin to change color, if the letter matches
    the characters entered in the textbox.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一个示例中，我们将使用斯科特的插件与自动完成小部件，让用户搜索一些城市名称。如果匹配成功，选择下拉列表中的每个字母将开始改变颜色，只要该字母与文本框中输入的字符匹配。
- en: 'Change the final `<script>` element in `autocomplete5.html`, so that it appears
    as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 更改`autocomplete5.html`中的最后一个`<script>`元素，使其如下所示：
- en: '[PRE36]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Save this file as `autocomplete8.html`. We also need to add a styling rule
    to our code; add this to the `<head>` of your file:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`autocomplete8.html`。我们还需要在代码中添加一个样式规则；将其添加到您文件的`<head>`中：
- en: '[PRE37]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Although this appears as a short example, there are some key points here to
    note; let's explore the code we've used in more detail.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个例子看起来很简短，但这里有一些关键点需要注意；让我们更详细地探讨我们在代码中使用的内容。
- en: In this example, we've gone back to using a local array of objects, called `cityList`.
    Both the `value` and `label` properties in each object hold the same data to begin
    with.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们又回到了使用本地对象数组`cityList`。每个对象中的`value`和`label`属性最初保存相同的数据。
- en: 'In our configuration object, we specify a new `html` option, which is used
    in conjunction with the HTML extension. We set the value of this option to `true`
    as in the following code:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的配置对象中，我们指定了一个新的`html`选项，它与HTML扩展一起使用。我们将此选项的值设置为`true`，如以下代码所示：
- en: '[PRE38]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We''ve used a function as the value of the `source` option in this example.
    Within the function, we first create a new empty array and define a new regular
    expression object. This will case-insensitively match whatever is typed into the
    `<input>`, at the start of a string:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们将一个函数作为`source`选项的值使用。在函数中，我们首先创建一个新的空数组，并定义一个新的正则表达式对象。这将在字符串的开头不区分大小写地匹配`<input>`中键入的任何内容：
- en: '[PRE39]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We then iterate over each object in our data array and test whether our regular
    expression matches any of the `label` values in the objects in our array. If any
    items do match, we create a new object and give it `value` and `label` properties.
    The `value` property (which is added to the `<input>` element when a suggestion
    is selected) is simply the corresponding value from our data array, and the `label`
    (what is displayed in the suggestion menu) is a new string that contains a `<span>`
    element wrapping the text entered into the `<input>` element:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们遍历数据数组中的每个对象，并测试我们的正则表达式是否与数组中的对象的`label`值匹配。如果有任何项匹配，我们将创建一个新对象并给它`value`和`label`属性。`value`属性（在选择建议时添加到`<input>`元素中）只是来自我们数据数组的相应值，而`label`（显示在建议菜单中的内容）是一个新的字符串，其中包含一个将输入到`<input>`元素中的文本包装在`<span>`元素中的文本：
- en: '[PRE40]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Finally, we call the `resp` callback, passing in the newly constructed suggestions
    array. We should always ensure that this callback is called, as this is required
    by the widget. It doesn't matter if the suggestions array is empty, the important
    thing is that the callback is called.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用`resp`回调，传入新构造的建议数组。我们应该始终确保调用此回调，因为这是小部件所必需的。建议数组为空并不重要，重要的是调用回调。
- en: '[PRE41]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: So now, each item in the suggestions menu will have a `<span>` element, wrapping
    the text that was typed into the `<input>` element. We can use it to style this
    text slightly differently, such as with the green text `<style>` that we have
    added to our example.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，建议菜单中的每个项目都将有一个`<span>`元素，将输入到`<input>`元素中的文本包装起来。我们可以使用它轻微不同地样式化这个文本，比如我们在示例中添加的绿色文本`<style>`。
- en: Summary
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We covered two widgets in this chapter; both of them are relatively new to the
    library and both work with `<form>` elements of some description. The button widget
    can be used to turn `<a>`, `<button>`, and `<input>` (of the `button`, `submit`,
    or `reset` type) into attractively and consistently styled-rich widgets.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中介绍了两个小部件；它们都是库中相对较新的，都与某种形式的`<form>`元素一起使用。按钮小部件可用于将`<a>`、`<button>`和`<input>`（类型为`button`、`submit`或`reset`）转换为具有吸引力和一致样式的丰富小部件。
- en: The autocomplete widget is attached to an `<input>` element of the `text` type
    and is used to show a list of suggestions when the visitor begins typing into
    the `<input>` element. The widget is preconfigured to work with a local array
    of data or a URL that outputs data in the expected format. It can also be configured
    to work with data that is not in the expected format. We must first process the
    data being displayed before passing it to the widget, making this an extremely
    versatile and powerful widget.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 自动完成小部件附加到一个`text`类型的`<input>`元素上，并在访客开始在`<input>`元素中输入时显示建议列表。该小部件预配置为与本地数据数组或以预期格式输出数据的URL一起工作。它还可以配置为处理不符合预期格式的数据。在将数据传递给小部件之前，我们必须先处理要显示的数据，使其成为一个非常灵活和强大的小部件。
- en: We're almost at the end of the section covering the visible widgets, before
    focusing on the interaction helpers available with jQuery UI; let's take a look
    at the two newest additions to the library over the next couple of chapters, beginning
    with the menu widget.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经快接近结束覆盖可见小部件的章节，接下来将专注于 jQuery UI 提供的交互助手；让我们在接下来的几章中一起看看库中的两个最新添加，从菜单小部件开始。
