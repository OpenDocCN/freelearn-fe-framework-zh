- en: '*Chapter 10*: Writing Unit Tests in Angular with Jest'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*：使用Jest在Angular中编写单元测试'
- en: '*"It works on my machine…"* is a phrase that won''t lose its beauty with time.
    It is a shield for many engineers and a nightmare for the QAs. But honestly, what''s
    a better way than writing tests for your application''s robustness, right? And
    when it comes to writing unit tests, my personal favorite is Jest. That is because
    it is super fast, lightweight, and has an easy API to write tests. More importantly,
    it is faster than the Karma and Jasmine setup that comes out of the box with Angular.
    In this chapter, you''ll learn how to configure Jest with Angular to run these
    tests in parallel. You''ll learn how to test components, services, and pipes with
    Jest. You''ll also learn how to mock dependencies for these tests.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*"它在我的机器上运行……"*这句话不会随着时间的推移而失去它的美丽。对许多工程师来说，这是一个护身符，对QA人员来说则是一个噩梦。但老实说，有什么比为应用程序的健壮性编写测试更好的方式呢？当涉及编写单元测试时，我个人最喜欢的是Jest。因为它非常快速、轻量级，并且具有易于编写测试的简单API。更重要的是，它比Angular默认提供的Karma和Jasmine设置更快。在本章中，您将学习如何配置Angular与Jest，以便并行运行这些测试。您将学习如何使用Jest测试组件、服务和管道。您还将学习如何为这些测试模拟依赖项。'
- en: 'In this chapter, we''re going to cover the following recipes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Setting up unit tests in Angular with Jest
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Angular中使用Jest设置单元测试
- en: Providing global mocks for Jest
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Jest提供全局模拟
- en: Mocking services using stubs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用存根来模拟服务
- en: Using spies on an injected service in a unit test
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单元测试中对注入的服务使用间谍
- en: Mocking child components and directives using the `ng-mocks` package
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ng-mocks`包模拟子组件和指令
- en: Creating even easier component tests with Angular CDK component harnesses
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Angular CDK组件测试更简单
- en: Unit testing components with Observables
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Observables对组件进行单元测试
- en: Unit testing Angular pipes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试Angular管道
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For the recipes in this chapter, ensure you have both **Git** and **NodeJS**
    installed on your machine. You also need to have the `@angular/cli` package installed,
    which you can do using `npm install -g @angular/cli` from your Terminal. The code
    for this chapter can be found at [https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter10](https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter10).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的食谱中，请确保您的计算机上安装了**Git**和**NodeJS**。您还需要安装`@angular/cli`包，可以使用终端命令`npm install
    -g @angular/cli`来安装。本章的代码可以在[https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter10](https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter10)找到。
- en: Setting up unit tests in Angular with Jest
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Angular中使用Jest设置单元测试
- en: By default, a new Angular project comes bundled with a lot of goodness, including
    the configuration and tooling in which to run unit tests with Karma and Jasmine.
    While working with Karma is relatively convenient, many developers find that in
    large-scale projects, the whole testing process becomes much slower if there are
    a lot of tests involved. This is mainly because you can't run tests in parallel.
    In this recipe, we'll set up Jest for unit testing in an Angular app. Additionally,
    we'll migrate existing tests from the Karma syntax to the Jest syntax.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，新的Angular项目包含了很多好东西，包括配置和工具，可以使用Karma和Jasmine来运行单元测试。虽然使用Karma相对方便，但许多开发人员发现，在大型项目中，如果涉及大量测试，整个测试过程会变得非常缓慢。这主要是因为无法并行运行测试。在本章中，我们将为Angular应用程序设置Jest进行单元测试。此外，我们还将把现有的测试从Karma语法迁移到Jest语法。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project that we are going to work with resides in `chapter10/start_here/setting-up-jest`,
    which is inside the cloned repository. To begin, perform the following steps:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要处理的项目位于`chapter10/start_here/setting-up-jest`中，该文件夹位于克隆的存储库内。首先，执行以下步骤：
- en: Open the project in Visual Studio Code.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中打开项目。
- en: Open the Terminal and run `npm install` to install the dependencies of the project.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`以安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '完成后，运行`ng serve -o`。 '
- en: 'This should open the app in a new browser tab. You should see something similar
    to the following screenshot:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会在新的浏览器标签中打开应用程序。您应该会看到类似以下截图的内容：
- en: '![Figure 10.1 – The setting-up-jest app running on http://localhost:4200'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.1 - 在http://localhost:4200上运行的setting-up-jest应用程序'
- en: '](image/Figure_10.1_B15150.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_10.1_B15150.jpg)'
- en: Figure 10.1 – The setting-up-jest app running on http://localhost:4200
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 - 在http://localhost:4200上运行的setting-up-jest应用程序
- en: 'Next, try to run the test and monitor how much time it takes for the entire
    process to run. Run the `ng test` command from your Terminal; within a few seconds,
    a new Chrome window should open, as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，尝试运行测试并监视整个过程运行的时间。从终端运行`ng test`命令；几秒钟后，一个新的Chrome窗口应该会打开，如下所示：
- en: '![Figure 10.2 – The tests'' results with Karma and Jasmine'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.2 - 使用Karma和Jasmine的测试结果'
- en: '](image/Figure_10.2_B15150.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_10.2_B15150.jpg)'
- en: Figure 10.2 – The tests' results with Karma and Jasmine
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 - 使用Karma和Jasmine的测试结果
- en: Looking at the preceding screenshot, you might say *"Pfffttt Ahsan, it says
    'finished in 0.126s!' What else do you want?"* Well, that time only covers how
    long it took Karma to run the tests *in the browser after the Chrome window was
    created*. It doesn't count the time it took to actually start the process, start
    the Chrome window, and then load the tests. On my machine, it takes about *15
    seconds* to run the entire process. That's why we're going to replace it with
    Jest. Now that you understand the issue, in the next section, let's take a look
    at the steps of the recipe.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 看着前面的截图，你可能会说“Pfffttt Ahsan，它说'在0.126秒内完成！'你还想要什么？”嗯，那个时间只涵盖了Karma在Chrome窗口创建后在浏览器中运行测试所花费的时间。它没有计算实际启动过程、启动Chrome窗口，然后加载测试所花费的时间。在我的机器上，整个过程大约需要*15秒*。这就是为什么我们要用Jest替换它。现在您了解了问题，在下一节中，让我们看一下食谱的步骤。
- en: How to do it...
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Here, we have an Angular app with a really simple **Counter** component. It
    shows the value of the counter and has three action buttons: one to increment
    the value of the counter, one to decrement the value, and one to reset the value.
    Additionally, there are some tests written with Karma and Jasmine, and all of
    the tests pass if you run the `ng test` command. We''ll start by setting up Jest
    instead. Perform the following steps:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个Angular应用程序，其中有一个非常简单的**Counter**组件。它显示计数器的值，并有三个操作按钮：一个用于增加计数器的值，一个用于减少值，一个用于重置值。此外，还有一些使用Karma和Jasmine编写的测试，如果运行`ng
    test`命令，所有测试都会通过。我们将首先设置Jest。执行以下步骤：
- en: 'First, open a new Terminal window/tab and make sure you''re inside the `chapter10/start_here/setting-up-jest`
    folder. Once inside, run the following command to install the packages that are
    required to test with Jest:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开一个新的终端窗口/标签，并确保您在`chapter10/start_here/setting-up-jest`文件夹内。进入后，运行以下命令以安装使用Jest所需的软件包：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can now uninstall Karma and the unwanted dependencies. Now run the following
    command in your Terminal:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以卸载Karma和不需要的依赖项。现在在您的终端中运行以下命令：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We also need to get rid of some extra files that we don't require. Delete the
    `karma.conf.js` file and the `src/test.ts` file from the project.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要摆脱一些我们不需要的额外文件。从项目中删除`karma.conf.js`文件和`src/test.ts`文件。
- en: 'Now update the test configuration in the `angular.json` file, as follows:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在按照以下方式更新`angular.json`文件中的测试配置：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will now create a file to configure Jest for our project. Create a file
    named `jestSetup.ts` inside the project''s root folder and paste the following
    content inside:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将创建一个文件来为我们的项目配置Jest。在项目的根文件夹中创建一个名为`jestSetup.ts`的文件，并粘贴以下内容：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, let''s modify `tsconfig.spec.json` to use Jest instead of Jasmine. After
    the modification, your entire file should appear as follows:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们修改`tsconfig.spec.json`以使用Jest而不是Jasmine。修改后，整个文件应如下所示：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We''ll now modify `package.json` to add the `npm` scripts that''ll run the
    Jest tests:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将修改`package.json`以添加将运行Jest测试的`npm`脚本：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, let''s wrap up the entire configuration for our Jest tests by adding
    the Jest configuration in the `package.json` file, as follows:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们通过在`package.json`文件中添加Jest配置来完成我们Jest测试的整个配置，如下所示：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now that we have set everything up, simply run the `test` command, as follows:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一切，只需运行`test`命令，如下所示：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once the tests are finished, you should be able to see the following output:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 测试完成后，您应该能够看到以下输出：
- en: '![Figure 10.3 – The results of the tests with Jest'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.3 - 使用Jest进行测试的结果'
- en: '](image/Figure_10.3_B15150.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_10.3_B15150.jpg)'
- en: Figure 10.3 – The results of the tests with Jest
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 - 使用Jest进行测试的结果
- en: Kaboom! You will notice that the entire process of running the tests with Jest
    takes about 6 seconds. It might take more time when you run it for the first time,
    but the subsequent runs should be faster. Now that you know how to configure an
    Angular app to use Jest for unit tests, please refer to the next section for resources
    in which to learn more.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 砰！您会注意到使用Jest运行测试的整个过程大约需要6秒。第一次运行时可能需要更多时间，但随后的运行应该更快。现在您知道如何配置Angular应用程序以使用Jest进行单元测试，请参考下一节以了解更多资源。
- en: See also
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Testing* *Web Frameworks with Jest* ([https://jestjs.io/docs/en/testing-frameworks](https://jestjs.io/docs/en/testing-frameworks))'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Jest进行Web框架测试* ([https://jestjs.io/docs/en/testing-frameworks](https://jestjs.io/docs/en/testing-frameworks))'
- en: '*Getting Started with Jest* ([https://jestjs.io/docs/en/getting-started](https://jestjs.io/docs/en/getting-started))'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Jest入门* ([https://jestjs.io/docs/en/getting-started](https://jestjs.io/docs/en/getting-started))'
- en: Providing global mocks for Jest
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Jest提供全局模拟
- en: In the previous recipe, we learned how to set up Jest for Angular unit tests.
    There might be some scenarios in which you'd want to use a browser API that might
    not be part of your actual Angular code; for instance, using `localStorage` or
    `alert()`. In such cases, we need to provide some global mocks for the functions
    we want to return mock values from. This is so that we can perform tests involving
    them as well. In this recipe, you'll learn how to provide global mocks to Jest.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个食谱中，我们学习了如何为Angular单元测试设置Jest。可能会有一些情况，您希望使用浏览器API，这些API可能不是实际Angular代码的一部分；例如，使用`localStorage`或`alert()`。在这种情况下，我们需要为我们希望从中返回模拟值的函数提供一些全局模拟。这样我们就可以进行涉及它们的测试。在这个食谱中，您将学习如何为Jest提供全局模拟。
- en: Getting ready
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project for this recipe resides in `chapter10/start_here/providing-global-mocks-for-jest`.
    Perform the following steps:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此食谱的项目位于`chapter10/start_here/providing-global-mocks-for-jest`。执行以下步骤：
- en: Open the project in Visual Studio Code.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中打开项目。
- en: Open the Terminal and run `npm install` to install the dependencies of the project.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`以安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。
- en: 'This should open the app in a new browser tab. The app should appear as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签中打开应用程序。应用程序应如下所示：
- en: '![Figure 10.4 – The providing-global-mocks-for-jest app running on http://localhost:4200'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.4 - 在http://localhost:4200上运行提供全局模拟的jest应用程序'
- en: '](image/Figure_10.4_B15150.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_10.4_B15150.jpg)'
- en: Figure 10.4 – The providing-global-mocks-for-jest app running on http://localhost:4200
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 - 在http://localhost:4200上运行提供全局模拟的jest应用程序
- en: Now that we have the app running locally, in the next section, let's go through
    the steps of the recipe.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本地运行了应用程序，在接下来的部分中，让我们按照食谱的步骤进行。
- en: How to do it...
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The app we''re using for this recipe uses two global APIs: `window.localStorage`
    and `window.alert()`. Note that when the app starts, we fetch the counter value
    from `localStorage`, and then upon increment, decrement, and reset, we store it
    in `localStorage`. When the counter value becomes greater than the `MAX_VALUE`
    or lower than the `MIN_VALUE`, we show the alert using the `alert()` method. Let''s
    begin the recipe by writing some cool unit tests:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个示例中使用的应用程序使用了两个全局API：`window.localStorage` 和 `window.alert()`。请注意，当应用程序启动时，我们从
    `localStorage` 中获取计数器的值，然后在增加、减少和重置时，我们将其存储在 `localStorage` 中。当计数器的值大于 `MAX_VALUE`
    或小于 `MIN_VALUE` 时，我们使用 `alert()` 方法显示警报。让我们通过编写一些很酷的单元测试来开始这个示例：
- en: 'First, we''ll write our test cases to show the alert when the counter value
    goes beyond `MAX_VALUE` and `MIN_VALUE`. Modify the `counter.component.spec.ts`
    file as follows:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将编写我们的测试用例，以便在计数器值超过 `MAX_VALUE` 和 `MIN_VALUE` 时显示警报。修改 `counter.component.spec.ts`
    文件如下：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, you can see that the tests pass. But what if we wanted to check whether
    the value from `localStorage` is being saved and retrieved properly?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到测试通过了。但是，如果我们想要检查 `localStorage` 中的值是否被正确保存和检索呢？
- en: 'We''ll create a new test to make sure the `localStorage.getItem()` method is
    called to retrieve the last saved value from the `localStorage` API. Add the test
    to the `counter.component.spec.ts` file, as follows:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个新的测试，以确保调用 `localStorage.getItem()` 方法来从 `localStorage` API 中检索最后保存的值。将以下测试添加到
    `counter.component.spec.ts` 文件中：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Notice that we''re using `it.only` for this test case. This is to ensure that
    we''re only running this test (for now). If you run the tests, you should be able
    to see something similar to the following screenshot:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在这个测试用例中使用了 `it.only`。这是为了确保我们只运行这个测试（目前）。如果您运行测试，您应该能够看到类似以下截图的内容：
- en: '![Figure 10.5 – The test that is covering the localStorage API has failed'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.5 – 正在覆盖localStorage API的测试失败了'
- en: '](image/Figure_10.5_B15150.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_10.5_B15150.jpg)'
- en: Figure 10.5 – The test that is covering the localStorage API has failed
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 – 正在覆盖localStorage API的测试失败了
- en: 'Notice the `Matcher error: received value must be a mock or a spy function`
    message. This is what we''re going to do next, that is, provide a mock.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意 `Matcher error: received value must be a mock or a spy function` 消息。这就是我们接下来要做的事情，也就是提供一个模拟。'
- en: 'Create a file in the project''s root, called `jest-global-mocks.ts`. Then,
    add the following code to mock the `localStorage` API:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的根目录中创建一个名为 `jest-global-mocks.ts` 的文件。然后，添加以下代码以模拟 `localStorage` API：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now import this file into the `jestSetup.ts` file, as follows:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将此文件导入到 `jestSetup.ts` 文件中，如下所示：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now if you rerun the tests, they should pass.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您重新运行测试，它们应该通过。
- en: 'Let''s add another test to ensure we retrieve the last saved value from `localStorage`
    in the component initiation. Modify the `counter.component.spec.ts` file, as follows:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加另一个测试，以确保我们在组件初始化时从 `localStorage` 中检索到最后保存的值。修改 `counter.component.spec.ts`
    文件如下：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, let''s make sure that we save the counter value to `localStorage`
    whenever we trigger the `increment()`, `decrement()`, or `reset()` methods. Update
    the `counter.component.spec.ts` as follows:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们确保每当触发 `increment()`、`decrement()` 或 `reset()` 方法时，我们都将计数器的值保存到 `localStorage`
    中。更新 `counter.component.spec.ts` 如下：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Awesome sauce! You've just learned how to provide global mocks to Jest for testing.
    Please refer to the next section to understand how this works.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！您刚刚学会了如何为Jest提供全局模拟以进行测试。请参考下一节以了解其工作原理。
- en: How it works...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Jest provides a way in which to define a list of paths to the files that we
    want to load for each test. If you open the `package.json` file and see the `jest`
    property, you can view the `setupFilesAfterEnv` property, which takes an array
    of paths to the files. We already have the path defined there for the `jestSetup.ts`
    file. And one way to define global mocks is to create a new file and then import
    it into `jestSetup.ts`. This is because it is going to be called in the test environment
    anyway. And that's what we do in this recipe.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Jest提供了一种定义要为每个测试加载的文件路径列表的方法。如果打开`package.json`文件并查看`jest`属性，您可以查看`setupFilesAfterEnv`属性，它接受一个文件路径数组。我们已经在那里为`jestSetup.ts`文件定义了路径。定义全局模拟的一种方法是创建一个新文件，然后将其导入`jestSetup.ts`。这是因为它无论如何都会在测试环境中被调用。这就是我们在这个示例中所做的。
- en: Notice that we use the `Object.defineProperty` method in the `window` object
    to provide a mock implementation for the `localStorage` object. This is actually
    the same for any API that is not implemented in the JSDOM. Similarly, you can
    provide a global mock for each API that you use in your tests. Notice that in
    the `value` property, we use the `createLocalStorageMock()` method. Essentially,
    this is one way to define mocks. We create the `createLocalStorageMock()` method,
    and in there we have a private/encapsulated object named `storage` that mimics
    the `localStorage` object. We have also defined the `getItem()` and `setItem()`
    methods in there so that we can set values to this storage and get values from
    it. Notice that we do not have the implementations of the `removeItem()` and `clear()`
    methods that we have in the original `localStorage` API. We don't have to do it
    because we're not using these methods in our tests.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在`window`对象中使用`Object.defineProperty`方法为`localStorage`对象提供了一个模拟实现。对于JSDOM中未实现的任何API，情况都是一样的。同样，您可以为测试中使用的每个API提供全局模拟。请注意，在`value`属性中，我们使用了`createLocalStorageMock()`方法。实质上，这是定义模拟的一种方式。我们创建了`createLocalStorageMock()`方法，在其中我们有一个名为`storage`的私有/封装对象，模拟了`localStorage`对象。我们还在其中定义了`getItem()`和`setItem()`方法，以便我们可以向此存储设置值并从中获取值。请注意，我们没有在原始`localStorage`API中拥有的`removeItem()`和`clear()`方法的实现。我们不必这样做，因为我们在测试中没有使用这些方法。
- en: In the `'should call the localStorage.getItem method on component init'` test,
    we simply spy on the `localStorage` object's `getItem()` method, call the `ngOnInit()`
    method ourselves, and then expect it to have been called. Easy peasy.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在“应该在组件初始化时调用localStorage.getItem方法”测试中，我们只是对`localStorage`对象的`getItem()`方法进行了间谍监视，自己调用了`ngOnInit()`方法，然后期望它已被调用。非常简单。
- en: In the `'should retrieve the last saved value from localStorage on component
    init'` test, we save a value in the `localStorage` object for the counter value
    as `'12'` using the `setItem()` method. Essentially, calling the `setItem()` method
    calls our mock implementation method and not the actual `localStorage` API's `setItem()`
    method. Notice that, here, we *do not* spy on the `getItem()` method; this is
    because later on, we want the value of the component's `counter` property to be
    `12`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在“应该在组件初始化时从localStorage中检索最后保存的值”测试中，我们使用`setItem()`方法将计数器值保存在`localStorage`对象中，值为`'12'`。实质上，调用`setItem()`方法会调用我们的模拟实现方法，而不是实际的`localStorage`API的`setItem()`方法。请注意，这里我们*不*对`getItem()`方法进行间谍监视；这是因为后来，我们希望组件的`counter`属性的值为`12`。
- en: Important note
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Whenever we spy on a method, remember that any statements in the actual function
    will no longer be executed. This is why we do not spy on the `getItem()` method
    in the preceding test. If we do so, the `getItem()` method from the mock implementation
    *will not return anything*. Therefore, our expected value for the counter property
    will not be `12`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们对一个方法进行间谍操作时，请记住实际函数中的任何语句都不会再被执行。这就是为什么我们在前面的测试中不对`getItem()`方法进行间谍操作。如果我们这样做，模拟实现中的`getItem()`方法将不会返回任何内容。因此，我们对计数器属性的预期值将不会是`12`。
- en: Put simply, if you have to rely on the outcome of a function's implementation,
    or the statements executed within a function, do not spy on that function and
    write your test accordingly.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，如果您必须依赖于函数实现的结果，或者函数内部执行的语句，就不要对该函数进行间谍操作，并相应地编写您的测试。
- en: 'PS: I always end up learning this the hard way after debugging and bashing
    my head for a while. Just kidding!'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: PS：我总是在调试和苦苦思索一段时间后才艰难地学会这一点。开个玩笑！
- en: The final test is an easy one. In the `'should save the new counterValue to
    localStorage on increment, decrement and reset'` test, we simply spy on the `setItem()`
    method as we're not concerned about its implementation. Then, we manually set
    the value of the counter property multiple times before we run the `increment()`,
    `decrement()`, and `reset()` methods, respectively. Additionally, we expect the
    `setItem()` method to have been called with the right arguments to save the value
    to the store. Note that we do not check the store's value after saving it. As
    I mentioned earlier, since we have spied on the `setItem()` method, its internal
    statement won't trigger and the value won't be saved; therefore, we can't retrieve
    the saved value afterward.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的测试很简单。在`'should save the new counterValue to localStorage on increment, decrement
    and reset'`测试中，我们只是对`setItem()`方法进行了间谍操作，因为我们不关心它的实现。然后，我们手动多次设置计数器属性的值，然后分别运行`increment()`、`decrement()`和`reset()`方法。此外，我们期望`setItem()`方法已被调用，并使用正确的参数将值保存到存储中。请注意，我们在保存后不检查存储的值。正如我之前提到的，由于我们已经对`setItem()`方法进行了间谍操作，它的内部语句不会触发，值也不会被保存；因此，我们无法在保存后检索保存的值。
- en: See also
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The Jest documentation for `setupFiles` ([https://jestjs.io/docs/en/configuration#setupfiles-array](https://jestjs.io/docs/en/configuration#setupfiles-array))
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setupFiles`的Jest文档([https://jestjs.io/docs/en/configuration#setupfiles-array](https://jestjs.io/docs/en/configuration#setupfiles-array))'
- en: '*Manual Mocks with Jest* ([https://jestjs.io/docs/en/manual-mocks](https://jestjs.io/docs/en/manual-mocks))'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Jest进行手动模拟* ([https://jestjs.io/docs/en/manual-mocks](https://jestjs.io/docs/en/manual-mocks))'
- en: Mocking services using stubs
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用存根(mock)来模拟服务
- en: There's rarely an Angular app that doesn't have a `Service` created inside it.
    And where the overall business logic is concerned, services hold a great deal
    of the business logic, particularly when it comes to interacting with APIs. In
    this recipe, you'll learn how to mock services using stubs.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎没有一个Angular应用程序不会在其中创建一个`Service`。就整体业务逻辑而言，服务在与API交互时承载了大量的业务逻辑，特别是在涉及到与API交互时。在这个食谱中，您将学习如何使用存根(mock)来模拟服务。
- en: Getting ready
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project for this recipe resides in `chapter10/start_here/mocking-services-using-stubs`.
    Perform the following steps:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 该食谱的项目位于`chapter10/start_here/mocking-services-using-stubs`。执行以下步骤：
- en: Open the project in Visual Studio Code.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中打开项目。
- en: Open the Terminal and run `npm install` to install the dependencies of the project.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`来安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。
- en: 'This should open the app in a new browser tab. You should see something like
    the following screenshot:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会在新的浏览器标签页中打开应用程序。您应该会看到类似以下截图的内容：
- en: '![Figure 10.6 – The mocking-services-using-stubs app running on http://localhost:4200'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.6 - 在http://localhost:4200上运行的mocking-services-using-stubs应用程序'
- en: '](image/Figure_10.6_B15150.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_10.6_B15150.jpg)'
- en: Figure 10.6 – The mocking-services-using-stubs app running on http://localhost:4200
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 - 使用存根模拟服务的应用程序在http://localhost:4200上运行
- en: Now that we have the app running locally, in the next section, let's take a
    look at the steps of the recipe.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本地运行了应用程序，在下一节，让我们来看看食谱的步骤。
- en: How to do it...
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We have the same application as the previous recipe; however, we''ve moved
    the logic of saving and retrieving data from `localStorage` to the `CounterService`
    we''ve created. Now all the tests pass. However, what if we wanted to hide/encapsulate
    the logic of where the counter value is stored? Perhaps we want to send a backend
    API call for it. To do this, it makes more sense to spy on the service''s methods.
    Let''s follow the recipe to provide a mock stub for our service:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有与上一个食谱相同的应用程序；但是，我们已经将保存和检索数据的逻辑从`localStorage`移动到了我们创建的`CounterService`中。现在所有的测试都通过了。但是，如果我们想要隐藏/封装计数器值存储的逻辑怎么办？也许我们想要为此发送后端API调用。为了做到这一点，更有意义的是对服务的方法进行监视。让我们按照食谱为我们的服务提供一个模拟存根：
- en: 'First of all, let''s create a folder inside the `src` folder, named `__mocks__`.
    Inside it, create another folder named `services`. Then, again inside this folder,
    create the `counter.service.mock.ts` file with the following content:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`src`文件夹内创建一个名为`__mocks__`的文件夹。在其中，创建另一个名为`services`的文件夹。然后，在这个文件夹内再次创建`counter.service.mock.ts`文件，并包含以下内容：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now provide the mock service instead of the actual service in the `counter.component.spec.ts`,
    as follows:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在`counter.component.spec.ts`中提供模拟服务而不是实际服务，如下所示：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With the preceding change, you should see the following error that says the
    `localStorage.setItem` hasn''t been called. This is because we''re now spying
    on the methods on our mock stub for the service:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通过上述更改，您应该看到以下错误，指出`localStorage.setItem`没有被调用。这是因为我们现在正在对我们服务的模拟存根上的方法进行监视：
- en: '![Figure 10.7 – localStorage.setItem is not called because of the methods being
    spied on'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.7 - localStorage.setItem没有被调用，因为方法被监视了'
- en: '](image/Figure_10.7_B15150.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_10.7_B15150.jpg)'
- en: Figure 10.7 – localStorage.setItem is not called because of the methods being
    spied on
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 - localStorage.setItem没有被调用，因为方法被监视了
- en: 'Now, instead of expecting the `localStorage` object''s methods to be called,
    let''s expect our service''s methods to be called in our tests. Update the `counter.component.spec.ts`
    file as follows:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们不再期望调用`localStorage`对象的方法，而是期望在我们的测试中调用我们服务的方法。更新`counter.component.spec.ts`文件如下：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Great! You now know how to mock services to test components with service dependencies.
    Please refer to the next section to understand how it all works.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在你知道如何模拟服务来测试具有服务依赖关系的组件。请参考下一节，了解它是如何工作的。
- en: How it works...
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Providing stubs for Angular services is already a breeze. This is thanks to
    Angular's out-of-the-box methods and tooling from the `@angular/core` package,
    especially `@angular/core/testing`. First, we create the stub for our `CounterService`
    and use `jest.fn()` for every method within `CounterService`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为Angular服务提供存根已经非常简单。这要归功于Angular的开箱即用的方法和来自`@angular/core`包的工具，特别是`@angular/core/testing`。首先，我们为我们的`CounterService`创建存根，并对`CounterService`中的每个方法使用`jest.fn()`。
- en: 'Using `jest.fn()` returns a new, unused mock function that Jest automatically
    spies upon as well. Optionally, we can also pass a mock implementation method
    as a parameter to `jest.fn`. View the following example from the official documentation
    for `jest.fn()`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`jest.fn()`返回一个新的未使用的模拟函数，Jest会自动对其进行监视。可选地，我们还可以将模拟实现方法作为参数传递给`jest.fn`。查看官方文档中关于`jest.fn()`的以下示例：
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Once we create the stub, we pass it to the `TestBed` configuration in the provider's
    array against the `CounterService` – but with the `useValue` property set to the
    `CounterServiceMock`. This tells Angular to use our stub as it is for `CounterService`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了存根，我们将其传递给`TestBed`配置中的提供者数组，针对`CounterService` - 但`useValue`属性设置为`CounterServiceMock`。这告诉Angular使用我们的存根作为`CounterService`。
- en: 'Then, in the test where we expect `CounterService.getFromStorage()` to be called
    when the component initiates, we use the following statement:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们期望组件初始化时调用`CounterService.getFromStorage()`的测试中，我们使用以下语句：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice that in the preceding code, we are able to directly use `expect()` on
    `CounterServiceMock.getFromStorage`. While this isn't possible in Karma and Jasmine,
    it is possible with Jest, since we're using `jest.fn()` for each underlying method.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在前面的代码中，我们能够直接在`CounterServiceMock.getFromStorage`上使用`expect()`。虽然这在Karma和Jasmine中是不可能的，但在Jest中是可能的，因为我们对每个基础方法使用了`jest.fn()`。
- en: 'Then, for a test in which we want to check whether the `getFromStorage()` method
    is called and returns a saved value, we first use the `CounterServiceMock.getFromStorage.mockReturnValue(12);`
    statement. This ensures that when the `getFromStorage()` method is called, it
    returns the value of `12`. Then, we just run the `ngOnInit()` method in the test
    and expect that our component''s counter property has now been set to `12`. This
    actually means that the following things happen:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于我们想要检查`getFromStorage()`方法是否被调用并返回保存的值的测试，我们首先使用`CounterServiceMock.getFromStorage.mockReturnValue(12);`语句。这确保了当调用`getFromStorage()`方法时，它会返回值`12`。然后，我们只需在测试中运行`ngOnInit()`方法，并期望我们组件的counter属性现在已经设置为`12`。这实际上意味着发生了以下事情：
- en: '`ngOnInit()` calls the `getFromStorage()` method.'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ngOnInit()`调用`getFromStorage()`方法。'
- en: '`getFromStorage()` returns the previously saved value (in our case, that''s
    `12`, but in reality, that''ll be fetched from `localStorage`).'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getFromStorage()`返回先前保存的值（在我们的情况下是`12`，但实际上，这将从`localStorage`中获取）。'
- en: The component's `counter` property is set to the retrieved value, which, in
    our case, is `12`.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组件的`counter`属性设置为检索到的值，这里是`12`。
- en: 'Now, for the final test, we just expect that the `saveToStorage` method of
    our `CounterService` is called in each necessary case. For this, we use the following
    types of `expect()` statements:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于最终的测试，我们只期望`CounterService`的`saveToStorage`方法在每种必要情况下都被调用。为此，我们使用以下类型的`expect()`语句：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: That's pretty much about it. Unit tests are fun, aren't they? Now that you've
    understood how it all works, please refer to the next section for some helpful
    resources that you can use for further reading.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 大致就是这样。单元测试很有趣，不是吗？现在您已经了解了所有的工作原理，请参考下一节，了解一些有用的资源，以便进行进一步阅读。
- en: See also
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The official documentation for `jest.fn()` ([https://jestjs.io/docs/en/jest-object.html#jestfnimplementation](https://jestjs.io/docs/en/jest-object.html#jestfnimplementation))
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jest.fn()`的官方文档（[https://jestjs.io/docs/en/jest-object.html#jestfnimplementation](https://jestjs.io/docs/en/jest-object.html#jestfnimplementation)）'
- en: Angular's *Component testing scenarios* ([https://angular.io/guide/testing-components-scenarios](https://angular.io/guide/testing-components-scenarios))
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular的*组件测试场景*（[https://angular.io/guide/testing-components-scenarios](https://angular.io/guide/testing-components-scenarios)）
- en: Using spies on an injected service in a unit test
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在单元测试中使用对注入服务的间谍
- en: While you can provide stubs for your services in the unit tests with Jest, sometimes,
    it might feel like an overhead creating a mock for every new service. Let's suppose
    that if the service's usage is limited to one test file, it might make more sense
    to just use spies on the actual injected service. In this recipe, that's exactly
    what we're going to do.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以在单元测试中使用Jest为你的服务提供存根，但有时为每个新服务创建一个模拟可能会感觉有些多余。假设如果服务的使用仅限于一个测试文件，那么仅仅在实际注入的服务上使用间谍可能更有意义。在这个示例中，这正是我们要做的。
- en: Getting ready
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做好准备
- en: The project for this recipe resides in `chapter10/start_here/using-spies-on-injected-service`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的项目位于`chapter10/start_here/using-spies-on-injected-service`。
- en: Open the project in Visual Studio Code.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中打开项目。
- en: Open the Terminal and run `npm install` to install the dependencies of the project.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`来安装项目的依赖项。
- en: Once done, run `npm run test`.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`npm run test`。
- en: 'This should run the unit tests on the console using Jest. You should see something
    similar to the following output:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在控制台上使用Jest运行单元测试。你应该会看到类似以下输出：
- en: '![Figure 10.8 – Unit tests failing for the ''using-spies-on-injected-service''
    project'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.8 – ''using-spies-on-injected-service''项目的单元测试失败'
- en: '](image/Figure_10.8_B15150.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_10.8_B15150.jpg)'
- en: Figure 10.8 – Unit tests failing for the 'using-spies-on-injected-service' project
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8 – 'using-spies-on-injected-service'项目的单元测试失败
- en: Now that we have the tests running locally, in the next section, let's go through
    the steps of the recipe.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本地运行了测试，在下一节中，让我们通过配方的步骤。
- en: How to do it...
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'The tests we have in the code for `CounterComponent` are incomplete. That''s
    because we''re missing the `expect()` blocks and the code to spy on the methods
    of `CounterService`. Let''s get started with the recipe to complete writing the
    tests using spies on the actual `CounterService`, as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`CounterComponent`代码中的测试是不完整的。这是因为我们缺少`expect()`块和对`CounterService`方法进行监听的代码。让我们开始使用实际的`CounterService`来完成编写测试的配方，如下所示：
- en: 'First, we need to get an instance of the actual injected service in our tests.
    So, we''ll create a variable and get the injected service in a `beforeEach()`
    method. Update the `counter.component.spec.ts` file as follows:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要在测试中获取实际注入的服务的实例。因此，我们将创建一个变量，并在`beforeEach()`方法中获取注入的服务。更新`counter.component.spec.ts`文件如下：
- en: '[PRE20]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, we''ll write our first `expect()` block for the service. For the test
    that says `''should call the localStorage.getItem method on component init''`,
    add the following `spyOn()` and `expect()` blocks:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将为服务编写我们的第一个`expect()`块。对于测试中说的'应该在组件初始化时调用localStorage.getItem方法'，添加以下`spyOn()`和`expect()`块：
- en: '[PRE21]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If you run `npm run test` again, you should still see one test failing but the
    rest of them passing.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果再次运行`npm run test`，你应该仍然会看到一个测试失败，但其余测试通过。
- en: 'Now, let''s fix the failing test. That is `''should retrieve the last saved
    value from localStorage on component init''`. In this case, we need to spy on
    the `getFromStorage()` method of `CounterService` to return the expected value
    of `12`. To do so, update the test file, as follows:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们修复失败的测试。即'应该在组件初始化时从localStorage中检索到上次保存的值'。在这种情况下，我们需要监听`CounterService`的`getFromStorage()`方法，以返回预期值`12`。为此，请更新测试文件，如下所示：
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, let''s fix our last test where we expect the `increment()`, `decrement()`,
    and `reset()` methods to call the `saveToStorage()` method of `CounterService`.
    Update the test as follows:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们修复我们的最后一个测试，我们期望`increment()`、`decrement()`和`reset()`方法调用`CounterService`的`saveToStorage()`方法。更新测试如下：
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Awesome! With this change, you should see all 12 tests passing. Let's take a
    look at the next section to understand how it works.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！通过这个改变，你应该看到所有12个测试都通过了。让我们看看下一节，以了解它是如何工作的。
- en: How it works...
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe contained a lot of knowledge from the previous recipes of this chapter.
    However, the key highlight is the `TestBed.inject()` method. Essentially, this
    magical method gets the instance of the provided service – `CounterService` –
    to us. This is the instance of the service that is bound with the instance of
    `CounterComponent`. Since we have access to the same instance of the service that
    is being used by the component's instance, we can spy on it directly and expect
    it to be called – or even mock the returned values.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方包含了本章先前配方中的许多知识。然而，关键亮点是`TestBed.inject()`方法。基本上，这个神奇的方法会将提供的服务实例`CounterService`传递给我们。这是与`CounterComponent`实例绑定的服务实例。由于我们可以访问与组件实例使用的相同服务实例，我们可以直接对其进行监视，并期望它被调用，甚至可以模拟返回的值。
- en: See also
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: An introduction to Angular TestBed (https://angular.io/guide/testing-services#angular-testbed)
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular TestBed简介(https://angular.io/guide/testing-services#angular-testbed)
- en: Mocking child components and directives using the ng-mocks package
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ng-mocks包模拟子组件和指令
- en: Unit tests mostly revolve around testing components in isolation. However, what
    if your component depends completely on another component or directive to work
    properly? In such cases, you usually provide a mock implementation for the component,
    but that is a lot of work. However, with the `ng-mocks` package, it is super easy.
    In this recipe, we'll learn an advanced example of how to use `ng-mocks` for a
    parent component that depends on a child component to work properly.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '单元测试主要围绕着对组件进行孤立测试。但是，如果您的组件完全依赖于另一个组件或指令才能正常工作呢？在这种情况下，通常会为组件提供一个模拟实现，但这是很多工作。然而，使用`ng-mocks`包就非常简单。在这个配方中，我们将学习如何使用`ng-mocks`来进行一个高级示例，即父组件依赖于子组件才能正常工作。 '
- en: Getting ready
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'The project that we are going to work with resides in `chapter10/start_here/mocking-components-with-ng-mocks`,
    which is inside the cloned repository. Perform the following steps:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要处理的项目位于`chapter10/start_here/mocking-components-with-ng-mocks`中，这是在克隆存储库内部的。执行以下步骤：
- en: Open the project in Visual Studio Code.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中打开项目。
- en: Open the Terminal and run `npm install` to install the dependencies of the project.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`来安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。
- en: 'This should open the app in a new browser tab. You should see something similar
    to the following screenshot:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会在新的浏览器标签中打开应用程序。您应该会看到类似以下截图的内容：
- en: '![Figure 10.9 – The mocking-components-with-ng-mocks app running on http://localhost:4200'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.9 - 运行在http://localhost:4200上的mocking-components-with-ng-mocks应用程序'
- en: '](image/Figure_10.9_B15150.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_10.9_B15150.jpg)'
- en: Figure 10.9 – The mocking-components-with-ng-mocks app running on http://localhost:4200
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9 - 运行在http://localhost:4200上的mocking-components-with-ng-mocks应用程序
- en: Now that we have the app running locally, in the next section, let's go through
    the steps of the recipe.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序在本地运行，接下来让我们在下一节中按照配方的步骤进行操作。
- en: How to do it...
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'If you run the `yarn test` command or the `npm run test` command, you''ll see
    that not all of our tests pass. Additionally, there are a bunch of errors on the
    console, as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行`yarn test`命令或`npm run test`命令，您会发现并非所有测试都通过了。此外，控制台上会出现一堆错误，如下所示：
- en: '![Figure 10.10 – An unknown elements error during unit tests'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.10 - 单元测试期间出现未知元素错误'
- en: '](image/Figure_10.10_B15150.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_10.10_B15150.jpg)'
- en: Figure 10.10 – An unknown elements error during unit tests
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10 - 单元测试期间出现未知元素错误
- en: 'Let''s go through the recipe to make sure that our tests pass correctly without
    any errors using the `ng-mocks` package:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照配方确保我们的测试通过`ng-mocks`包正确无误地运行：
- en: 'First, let''s install the `ng-mocks` package within our project. To do this,
    run the following command from your project root in the Terminal:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们在项目中安装`ng-mocks`包。为此，请在终端中从项目根目录运行以下命令：
- en: '[PRE24]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, we''ll try to fix the tests for `AppComponent`. To only run specific tests
    based on a string regex, we can use the `-t` parameter with the `jest` command.
    Run the following command to only run the tests for `AppComponent`:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将尝试修复`AppComponent`的测试。为了只基于字符串正则表达式运行特定的测试，我们可以使用`jest`命令的`-t`参数。运行以下命令，只运行`AppComponent`的测试：
- en: '[PRE25]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now you can see that we only run the tests for `AppComponent`, and they fail
    as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以看到我们只运行`AppComponent`的测试，它们失败如下：
- en: '![Figure 10.11 – Error – ''app-version-control'' is not a known element'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.11 – 错误 – ''app-version-control''不是已知元素'
- en: '](image/Figure_10.11_B15150.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_10.11_B15150.jpg)'
- en: Figure 10.11 – Error – 'app-version-control' is not a known element
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11 – 错误 – 'app-version-control'不是已知元素
- en: 'To fix the error shown in *Figure 10.11*, we''ll import `VersionControlComponent`
    into the `TestBed` definition inside the `app.component.spec.ts` file. This is
    so that our test environment also knows the missing `VersionControlComponent`.
    To do this, modify the mentioned file as follows:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了解决*图10.11*中显示的错误，我们将`VersionControlComponent`导入`app.component.spec.ts`文件中的`TestBed`定义。这样我们的测试环境也会知道缺少的`VersionControlComponent`。为此，请按照以下方式修改提到的文件：
- en: '[PRE26]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If you rerun the tests for `AppComponent`, you'll see some fresher and newer
    errors. Surprise! Well, that's what happens with dependencies. We'll discuss the
    details in more detail in the *How it works...* section. However, to fix this,
    let's follow the next steps.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行`AppComponent`的测试，你会看到一些更新的错误。惊喜！这就是依赖关系的影响。我们将在*它是如何工作的...*部分详细讨论细节。然而，为了解决这个问题，让我们按照下面的步骤进行。
- en: 'Instead of providing the `VersionControlComponent` directly, we need to mock
    it since we don''t really care about it for the tests for `AppComponent`. To do
    this, update the `app.component.spec.ts` file as follows:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不需要直接提供`VersionControlComponent`，而是需要模拟它，因为我们对`AppComponent`的测试并不真正关心它。为此，请按照以下方式更新`app.component.spec.ts`文件：
- en: '[PRE27]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Boom! Problem solved. Run the tests again, just for the `AppComponent`, and
    you should see them all pass as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 问题解决了！再次运行测试，只针对`AppComponent`，你应该看到它们都通过了，如下所示：
- en: '![Figure 10.12 – Passing all of the tests for AppComponent'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.12 – 通过所有的AppComponent测试'
- en: '](image/Figure_10.12_B15150.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_10.12_B15150.jpg)'
- en: Figure 10.12 – Passing all of the tests for AppComponent
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.12 – 通过所有的AppComponent测试
- en: 'Now, let''s talk about the tests for `VersionControlComponent`. This depends
    on the `ReleaseFormComponent` as well as the `ReleaseLogsComponent`. Let''s mock
    them like a pro this time, using the `MockBuilder` and `MockRender` methods, so
    we can get rid of the errors during the tests. After the update, the `version-control.component.spec.ts`
    file should appear as follows:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们来谈谈`VersionControlComponent`的测试。这取决于`ReleaseFormComponent`以及`ReleaseLogsComponent`。这次让我们像专业人士一样模拟它们，使用`MockBuilder`和`MockRender`方法，这样我们就可以在测试过程中摆脱错误。更新后，`version-control.component.spec.ts`文件应如下所示：
- en: '[PRE28]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If you run `npm run test` now, you should see all of the tests passing. In the
    next steps, let's actually write some interesting tests.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '现在运行`npm run test`，你应该看到所有的测试都通过了。在接下来的步骤中，让我们实际编写一些有趣的测试。 '
- en: '`VersionControlComponent` uses `ReleaseLogsComponent` as a child. Additionally,
    it provides the `releaseLogs` property as `@Input()` to `ReleaseLogsComponent`
    via the `[logs]` attribute. We can actually check whether the input''s value is
    set correctly. To do so, update the `version-control.component.spec.ts` file,
    as follows:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`VersionControlComponent`将`ReleaseLogsComponent`作为子组件使用。此外，它通过`[logs]`属性将`releaseLogs`属性作为`@Input()`提供给`ReleaseLogsComponent`。我们实际上可以检查输入的值是否设置正确。为此，请按照以下方式更新`version-control.component.spec.ts`文件：'
- en: '[PRE29]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now we''ll make sure that when we have a new log created via `ReleaseFormComponent`,
    we show this new log by adding it to the `releaseLogs` array in `VersionControlComponent`.
    Then, we''ll also pass that as `@Input logs` to `ReleaseLogsComponent`. Add the
    following tests to the `version-control.component.spec.ts` file:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将确保当我们通过`ReleaseFormComponent`创建了一个新的日志时，我们通过将其添加到`VersionControlComponent`中的`releaseLogs`数组中来显示这个新的日志。然后，我们还将其作为`@Input
    logs`传递给`ReleaseLogsComponent`。将以下测试添加到`version-control.component.spec.ts`文件中：
- en: '[PRE30]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Boom! We have implemented some interesting tests by using the `ng-mocks` package.
    I absolutely love it every time I use it. Now that we've finished the recipe,
    in the next section, let's take a look at how it all works.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们通过使用`ng-mocks`包实现了一些有趣的测试。每次我使用它时，我都非常喜欢它。现在我们已经完成了这个配方，在下一节，让我们来看看它是如何工作的。
- en: How it works...
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: There are a couple of interesting things that we have covered in this recipe.
    First of all, to avoid any errors on the console complaining about unknown components,
    we use the `MockComponent` method from the `ng-mocks` package, to declare the
    components we're dependent on, as mocks. That is absolutely the simplest thing
    we achieve with the `ng-mocks` package. However, we do move on to an advanced
    situation, which I will admit is sort of an unconventional approach; that is testing
    the `@Input` and `@Output` emitters of the child components in the parent component
    in order to test an entire flow. This is what we do for the tests of `VersionControlComponent`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们涵盖了一些有趣的事情。首先，为了避免控制台报告未知组件的错误，我们使用了`ng-mocks`包中的`MockComponent`方法，将我们依赖的组件声明为模拟组件。这绝对是我们通过`ng-mocks`包实现的最简单的事情。然而，我们确实进入了一个高级的情况，我承认这是一种非常规的方法；那就是在父组件中测试子组件的`@Input`和`@Output`发射器，以测试整个流程。这就是我们为`VersionControlComponent`的测试所做的。
- en: Notice that we remove the usage of the `@angular/core/testing` package completely
    from the `version-control.component.spec.ts` file. This is because we're no longer
    using `TestBed` to create the test environment. Instead, we use the `MockBuilder`
    method from the `ng-mocks` package to build the test environment for our `VersionControlComponent`.
    Then, we use the `.mock()` method to mock each child component that we want to
    work with inside the tests later on. The `.mock()` method is not only used to
    mock components, but it can also be used to mock services, directives, pipes,
    and more. Please refer to the next section for further resources to read.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们完全从`version-control.component.spec.ts`文件中移除了对`@angular/core/testing`包的使用。这是因为我们不再使用`TestBed`来创建测试环境。相反，我们使用`ng-mocks`包中的`MockBuilder`方法来构建`VersionControlComponent`的测试环境。然后，我们使用`.mock()`方法来模拟我们稍后在测试中要使用的每个子组件。`.mock()`方法不仅用于模拟组件，还可以用于模拟服务、指令、管道等。请参考下一节以获取更多阅读资源。
- en: 'Then, in the `''should add the new log when it is created via ReleaseFormComponent''`
    test, pay attention to the `ngMocks.find()` method, which we use to find the relevant
    component and get its instance. Its use is relatively similar to what we would
    do in `TestBed`, as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`'should add the new log when it is created via ReleaseFormComponent'`测试中，注意我们使用的`ngMocks.find()`方法，用于找到相关组件并获取其实例。它的使用方式与我们在`TestBed`中所做的相对类似，如下所示：
- en: '[PRE31]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: However, using `ngMocks.find()` is better suited, as it has better support for
    types. Once we get a hold of the instance of `ReleaseFormComponent`, we use the
    `@Output` named `newReleaseLog` to create a new log using the `.emit()` method.
    Then, we do a quick `fixture.detectChanges()` to trigger the Angular change detection.
    We also check the `VersionControl.releaseLogs` array to determine whether our
    new release log has been added to the array. Afterward, we also check the `ReleaseLogsComponent.logs`
    property to make sure that the child component has updated the `logs` array via
    `@Input`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用`ngMocks.find()`更合适，因为它对类型有更好的支持。一旦我们掌握了`ReleaseFormComponent`的实例，我们就使用名为`newReleaseLog`的`@Output`来使用`.emit()`方法创建新日志。然后，我们快速进行`fixture.detectChanges()`以触发Angular变更检测。我们还检查`VersionControl.releaseLogs`数组，以确定我们的新发布日志是否已添加到数组中。之后，我们还检查`ReleaseLogsComponent.logs`属性，以确保子组件已通过`@Input`更新了`logs`数组。
- en: Important note
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Notice that we don't use a spy on the `VersionControlComponent.addNewReleaseLog`
    method. That is because if we do so, that function will become a Jest spy function.
    Therefore, it'll lose its functionality inside. In return, it'll never add the
    new log to the `releaseLogs` array, and none of our tests will pass. You can try
    it out for fun.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不在`VersionControlComponent.addNewReleaseLog`方法上使用间谍。这是因为如果我们这样做，该函数将成为Jest间谍函数。因此，它将失去其内部功能。反过来，它将永远不会将新日志添加到`releaseLogs`数组中，我们的测试也不会通过。你可以试试看。
- en: See also
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The ng-mocks `.mock` method ([https://ng-mocks.sudo.eu/api/MockBuilder#mock](https://ng-mocks.sudo.eu/api/MockBuilder#mock))
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ng-mocks的`.mock`方法（[https://ng-mocks.sudo.eu/api/MockBuilder#mock](https://ng-mocks.sudo.eu/api/MockBuilder#mock)）
- en: The ng-mocks official documentation ([https://ng-mocks.sudo.eu](https://ng-mocks.sudo.eu))
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ng-mocks官方文档（[https://ng-mocks.sudo.eu](https://ng-mocks.sudo.eu)）
- en: Creating even easier component tests with Angular CDK component harnesses
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Angular CDK组件挽具更轻松的组件测试
- en: When writing tests for components, there might be scenarios where you'd actually
    want to interact with the DOM elements. Now, this can already be achieved by using
    the `fixture.debugElement.query` method to find the element using a selector and
    then triggering events on it. However, that means maintaining it for different
    platforms, knowing the identifiers of all the selectors, and then exposing all
    of that in the tests. And this is even worse if we're talking about an Angular
    library. It certainly isn't necessary for each developer who interacts with my
    library to know all the element selectors in order to write the tests. Only the
    author of the library should know that much to respect encapsulation. Luckily,
    we have the component harnesses from the Angular CDK team, which were released
    with Angular 9 along with the IVY compiler. And they've led by example, by providing
    component harnesses for the Angular material components as well. In this recipe,
    you'll learn how to create your own component harnesses.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在为组件编写测试时，可能会出现您实际上希望与DOM元素进行交互的情况。现在，这可以通过使用`fixture.debugElement.query`方法找到使用选择器的元素，然后在其上触发事件来实现。但是，这意味着为不同平台维护它，了解所有选择器的标识符，然后在测试中公开所有这些。如果我们谈论的是一个Angular库，情况会更糟。每个与我的库交互的开发人员都不需要知道所有元素选择器才能编写测试。只有库的作者应该知道这么多以尊重封装。幸运的是，我们有来自Angular
    CDK团队的组件挽具，它们是与IVY编译器一起在Angular 9发布的。他们以身作则，为Angular材料组件提供了组件挽具。在这个教程中，您将学习如何创建自己的组件挽具。
- en: Getting ready
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'The project that we are going to work with resides in `chapter10/start_here/tests-using-cdk-harness`,
    which is inside the cloned repository. Perform the following steps:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的项目位于克隆存储库内的`chapter10/start_here/tests-using-cdk-harness`中。执行以下步骤：
- en: Open the project in Visual Studio Code.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中打开项目。
- en: Open the Terminal and run `npm install` to install the dependencies of the project.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`来安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。
- en: 'This should open the app in a new browser tab. You should see something similar
    to the following screenshot:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在新的浏览器标签页中打开应用程序。你应该看到类似于以下截图的内容：
- en: '![Figure 10.13 – The tests-using-cdk-harness app running on http://localhost:4200'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.13 - 在http://localhost:4200上运行的tests-using-cdk-harness应用程序'
- en: '](image/Figure_10.13_B15150.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_10.13_B15150.jpg)'
- en: Figure 10.13 – The tests-using-cdk-harness app running on http://localhost:4200
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.13 - 在http://localhost:4200上运行的tests-using-cdk-harness应用程序
- en: Now that you have the app running, let's move on to the next section to follow
    the recipe.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用程序正在运行，让我们继续下一节按照配方进行操作。
- en: How to do it...
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We have our favorite Angular version control app that allows us to create release
    logs. And we have the tests written already, including tests that interact with
    the DOM element to validate a few use cases. Let''s follow the recipe to use component
    harnesses instead, and discover how easy it becomes to use in the actual tests:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个我们喜爱的Angular版本控制应用程序，允许我们创建发布日志。我们已经编写了测试，包括与DOM元素交互以验证一些用例的测试。让我们按照配方改用组件
    harness，并发现在实际测试中使用它变得多么容易：
- en: 'First, open a new Terminal window/tab and ensure you''re inside the `chapter10/start_here/tests-using-cdk-harness`
    folder. Once inside, run the following command to install the Angular CDK:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开一个新的终端窗口/标签，并确保你在`chapter10/start_here/tests-using-cdk-harness`文件夹内。进入后，运行以下命令安装Angular
    CDK：
- en: '[PRE32]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You have to restart your Angular server. So, rerun the `ng serve` command.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要重新启动你的Angular服务器。因此，重新运行`ng serve`命令。
- en: 'First, we''ll create a **component harness** for the `ReleaseFormComponent`.
    Let''s create a new file inside the `release-form` folder, and name it `release-form.component.harness.ts`.
    Then, add the following code inside it:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将为`ReleaseFormComponent`创建一个**组件 harness**。让我们在`release-form`文件夹内创建一个新文件，并将其命名为`release-form.component.harness.ts`。然后，在其中添加以下代码：
- en: '[PRE33]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now we need to set up the harness environment for our tests for `VersionControlComponent`.
    For this, we''ll use `HarnessLoader` and `TestbedHarnessEnvironment` from the
    Angular CDK. Update the `version-control.component.spec.ts` file as follows:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要为我们的`VersionControlComponent`测试设置 harness 环境。为此，我们将使用Angular CDK中的`HarnessLoader`和`TestbedHarnessEnvironment`。按照以下方式更新`version-control.component.spec.ts`文件：
- en: '[PRE34]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, let''s write some methods in our `ReleaseFormComponentHarness` class to
    get the relevant information. We''ll use these methods in the later steps. Update
    the `release-form.component.harness.ts` file as follows:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在我们的`ReleaseFormComponentHarness`类中编写一些方法来获取相关信息。我们将在后续步骤中使用这些方法。按照以下方式更新`release-form.component.harness.ts`文件：
- en: '[PRE35]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, we''ll work on our first test, named `''should have the first app selected
    for the new release log''`, with the component harness. Update the `version-control.component.spec.ts`
    file as follows:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用组件 harness 来进行我们的第一个测试，命名为“'应该选择第一个应用程序以进行新的发布日志'”。按照以下方式更新`version-control.component.spec.ts`文件：
- en: '[PRE36]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now if you run `npm run test`, you should see all of the tests passing, which
    means our first test with the component harness works. Woohoo!
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果你运行`npm run test`，你应该看到所有的测试都通过了，这意味着我们使用组件 harness 进行的第一个测试成功了。哇呼！
- en: 'Now, we''ll work on our second test, that is, for `''should show error on wrong
    version number input''`. Update the test in the `version-control.component.spec.ts`
    file, as follows:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将开始进行第二个测试，即“'应该在输入错误的版本号时显示错误'”。按照以下方式更新`version-control.component.spec.ts`文件中的测试：
- en: '[PRE37]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Boom! Note that we just reduced the lines of code for this test from nine statements
    to only four statements. Isn't that amazing? I believe it is awesome and much
    cleaner, to be honest.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 砰！请注意，我们刚刚将此测试的代码行数从九个语句减少到了只有四个语句。这不是很神奇吗？老实说，我认为这很棒，而且更加清晰。
- en: 'For the final test, we also need a component harness for `ReleaseLogsComponent`.
    Let''s quickly create it. Add a new file inside the `release-logs` folder, named
    `release-logs.component.harness.ts`, and add the following code:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于最终的测试，我们还需要为`ReleaseLogsComponent`创建一个组件测试工具。让我们快速创建它。在`release-logs`文件夹中添加一个名为`release-logs.component.harness.ts`的新文件，并添加以下代码：
- en: '[PRE38]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Finally, let''s modify our final tests in the `version-control.component.spec.ts`
    file as follows:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们修改`version-control.component.spec.ts`文件中的最终测试如下：
- en: '[PRE39]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Voila! That's some amazing testing right there using the Angular CDK component
    harnesses. If you run the tests now, you should see all of the tests passing.
    Now that you've finished the recipe, please refer to the next section to learn
    how this works.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！使用Angular CDK组件测试工具进行了一些令人惊叹的测试。如果现在运行测试，你应该能看到所有的测试都通过了。现在你已经完成了这个教程，请参考下一节来了解它是如何工作的。
- en: How it works...
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: All right! That was a cool recipe, which I enjoyed working on myself. The key
    factor of this recipe is the `@angular/cdk/testing` package. If you have worked
    with `e2e` tests using Protractor before, this is a similar concept to the `Pages`
    in Protractor. First, we create a component harness for both the `ReleaseLogsComponent`
    and the `ReleaseFormComponent`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 好了！这是一个很酷的教程，我自己很喜欢。这个教程的关键因素是`@angular/cdk/testing`包。如果你之前使用Protractor进行过`e2e`测试，这与Protractor中的`Pages`概念类似。首先，我们为`ReleaseLogsComponent`和`ReleaseFormComponent`分别创建了一个组件测试工具。
- en: Notice that we import the `ComponentHarness` class from `@angular/cdk/testing`
    for both component harnesses. Then, we extend our custom classes called `ReleaseFormComponentHarness`
    and `ReleaseLogsComponentHarness` from the `ComponentHarness` class. Essentially,
    this is the correct way to author component harnesses. Did you notice the static
    property called `hostSelector`? We need this property for every component harness
    class that we create. And the value is always the selector of the target element/component.
    This ensures that when we load this harness into the test environment, the environment
    is able to find the host element in the DOM – for which we're creating the component
    harness. In our component harness class, we use the `this.locatorFor()` method
    to find elements within the host component. The `locateFor()` method takes a single
    argument as the `css selector` of the element to be found and returns an `AsyncFactoryFn`.
    This means the returned value is a function that we can use at a later time to
    get the required elements.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们从`@angular/cdk/testing`导入了`ComponentHarness`类来为两个组件测试工具。然后，我们从`ComponentHarness`类扩展了我们的自定义类`ReleaseFormComponentHarness`和`ReleaseLogsComponentHarness`。基本上，这是编写组件测试工具的正确方式。你注意到了叫做`hostSelector`的静态属性吗？我们需要为我们创建的每个组件测试工具类添加这个属性。而且这个值总是目标元素/组件的选择器。这确保了当我们将这个测试工具加载到测试环境中时，环境能够在DOM中找到宿主元素，也就是我们正在创建组件测试工具的元素。在我们的组件测试工具类中，我们使用`this.locatorFor()`方法来查找宿主组件中的元素。`locateFor()`方法接受一个参数，即要查找的元素的`css选择器`，并返回一个`AsyncFactoryFn`。这意味着返回的值是一个我们可以在以后使用的函数，用来获取所需的元素。
- en: In the `ReleaseFormComponentHarness` class, we find the submit button, the app
    name input, and the version number input using the `protected` methods' `getSubmitButton`,
    `getAppNameInput`, and `getAppVersionInput`, respectively, which are all of the
    `AsyncFactoryFn` type, as mentioned earlier. We have these methods set as `protected`
    because we don't want the people writing the unit tests to access or care about
    the information of the DOM elements. This makes it much easier for everyone to
    write tests without worrying about the internal implementation of accessing the
    DOM.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ReleaseFormComponentHarness`类中，我们使用`protected`方法`getSubmitButton`、`getAppNameInput`和`getAppVersionInput`分别找到提交按钮、应用程序名称输入和版本号输入，这些方法都是`AsyncFactoryFn`类型，如前所述。我们将这些方法设置为`protected`，因为我们不希望编写单元测试的人访问或关心DOM元素的信息。这样做可以让每个人更轻松地编写测试，而不用担心访问DOM的内部实现。
- en: Notice that the `getVersionErrorEl()` method is slightly different. It is not
    actually of the `AsyncFactoryFn` type. Instead, it is a regular `async` function
    that first calls the `locatorForAll` method to get all the elements with the `alert`
    class and the `alert-danger` class, which results in the error messages. Then,
    it selects the second alert element, which is for the app version number input.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`getVersionErrorEl()`方法略有不同。它实际上不是`AsyncFactoryFn`类型。相反，它是一个常规的`async`函数，首先调用`locatorForAll`方法获取所有具有`alert`类和`alert-danger`类的元素，这些元素是错误消息。然后，它选择第二个警报元素，用于应用程序版本号输入。
- en: One important thing to mention here is that when we call the `locatorFor()`
    method or the `locatorForAll()` method, we get back a `Promise` with the `TestElement`
    item or a `Promise` with a list of `TestElement` items, respectively. Each `TestElement`
    item has a bunch of handy methods such as `.click()`, `.sendKeys()`, `.focus()`,
    `.blur()`, `.getProperty()`, `.text()`, and more. And these methods are what we're
    interested in since we use them behind the scenes to interact with the DOM elements.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要提到的一件重要的事情是，当我们调用`locatorFor()`方法或`locatorForAll()`方法时，我们会得到一个带有`TestElement`项的`Promise`，或者一个`TestElement`项列表的`Promise`。每个`TestElement`项都有一堆方便的方法，比如`.click()`、`.sendKeys()`、`.focus()`、`.blur()`、`.getProperty()`、`.text()`等等。这些方法是我们感兴趣的，因为我们在幕后使用它们与DOM元素进行交互。
- en: Now, let's talk about configuring the test environment. In the `version-control.component.spec.ts`
    file, we set up the environment to use component harnesses for both `ReleaseLogsComponent`
    and `ReleaseFormComponent`. The `TestbedHarnessEnvironment` element is the key
    element here. We use the `.loader()` method of the `TestbedHarnessEnvironment`
    class by providing our `fixture` as an argument. Note that the fixture is what
    we get in the test environment using the `TestBed.createComponent(VersionControlComponent)`
    statement. Because we provide this fixture to the `TestbedHarnessEnvironment.loader()`
    method, we get back an element of the `HarnessLoader` statement, which can now
    load component harnesses for the other components – that is, for `ReleaseLogsComponent`
    and `ReleaseFormComponent`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们谈谈如何配置测试环境。在`version-control.component.spec.ts`文件中，我们设置环境使用`ReleaseLogsComponent`和`ReleaseFormComponent`的组件挽具。这里的关键元素是`TestbedHarnessEnvironment`元素。我们使用`TestbedHarnessEnvironment`类的`.loader()`方法，通过提供我们的`fixture`作为参数。请注意，fixture是我们在测试环境中使用`TestBed.createComponent(VersionControlComponent)`语句获得的。因为我们将这个fixture提供给`TestbedHarnessEnvironment.loader()`方法，我们得到了一个`HarnessLoader`语句的元素，现在可以为其他组件加载组件挽具，即`ReleaseLogsComponent`和`ReleaseFormComponent`。
- en: Notice that in the tests, we use the `harnessLoader.getHarness()` method by
    providing the harness class as an argument. This enables the test environment
    to find the DOM element associated with the `hostSelector` property of the harness
    class. Additionally, we get back the instance of the component harness that we
    can use further in the test.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在测试中，我们使用 `harnessLoader.getHarness()` 方法，通过提供 harness 类作为参数。这使得测试环境能够找到与
    harness 类的 `hostSelector` 属性相关联的 DOM 元素。此外，我们还可以获得组件 harness 的实例，以便在测试中进一步使用。
- en: See also
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Finding components in the DOM with component harnesses (`https://material.angular.io/cdk/test-harnesses/overview#finding-elements-in-the-components-dom`)
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用组件 harness 在 DOM 中查找组件 (`https://material.angular.io/cdk/test-harnesses/overview#finding-elements-in-the-components-dom`)
- en: '*API for component harness authors* (`https://material.angular.io/cdk/test-harnesses/overview#api-for-component-harness-authors`)'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*组件 harness 作者的 API* (`https://material.angular.io/cdk/test-harnesses/overview#api-for-component-harness-authors`)'
- en: Unit testing components with Observables
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Observables 进行组件的单元测试
- en: If you're building an Angular application, it is very likely that you'll work
    with Observables inside the app at some point. For instance, you could be fetching
    data from a third-party API or perhaps just managing the state. In either case,
    it becomes slightly difficult to test applications that have Observables in action.
    In this recipe, we're going to learn how to test unit tests with Observables.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在构建 Angular 应用程序，很可能会在应用程序中的某个时候使用 Observables。例如，您可能会从第三方 API 获取数据，或者仅仅是管理状态。在任何情况下，测试具有
    Observables 的应用程序会变得稍微困难。在本食谱中，我们将学习如何使用 Observables 进行单元测试。
- en: Getting ready
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'The project for this recipe resides in `chapter10/start_here/unit-testing-observables`.
    Perform the following steps:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 此食谱的项目位于 `chapter10/start_here/unit-testing-observables`。执行以下步骤：
- en: Open the project in Visual Studio Code.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio Code 中打开项目。
- en: Open the Terminal and run `npm install` to install the dependencies of the project.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行 `npm install` 来安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行 `ng serve -o`。
- en: 'This should open the app in a new browser tab. You should see something similar
    to the following screenshot:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在新的浏览器选项卡中打开应用程序。您应该看到类似以下截图的内容：
- en: '![Figure 10.14 – The unit-testing-observables app running on http://localhost:4200'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.14 – 在 http://localhost:4200 上运行的 unit-testing-observables 应用程序'
- en: '](image/Figure_10.14_B15150.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_10.14_B15150.jpg)'
- en: Figure 10.14 – The unit-testing-observables app running on http://localhost:4200
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.14 – 在 http://localhost:4200 上运行的 unit-testing-observables 应用程序
- en: Now that we have the app running locally, in the next section, let's take a
    look at the steps of the recipe.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本地运行了应用程序，在下一节中，让我们来看一下食谱的步骤。
- en: How to do it...
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We''ll start by writing test cases, which technically involve the usage of
    Observables. Essentially, we have to mock the methods using Observables, and we
    have to use the `fakeAsync` and `tick()` methods provided by Angular to reach
    our goal of writing good unit tests with Observables. Let''s get started:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先编写测试用例，这在技术上涉及使用 Observables。基本上，我们必须使用 Observables 模拟方法，并且必须使用 Angular
    提供的 `fakeAsync` 和 `tick()` 方法来达到编写具有 Observables 的良好单元测试的目标。让我们开始吧：
- en: 'First and foremost, we''ll write a test to see what happens when we use an
    `expect()` clause in a test that involves a function containing an Observable.
    Update the `users.component.spec.ts` file by adding a test, which checks whether
    we get the users from the server when the component initiates:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将编写一个测试，看看当我们在包含 Observable 的函数中使用 `expect()` 语句时会发生什么。通过在 `users.component.spec.ts`
    文件中添加一个测试，检查在组件初始化时是否从服务器获取用户：
- en: '[PRE40]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, as soon as you run the `npm run test` command, you''ll see that the test
    fails with the following message:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦你运行`npm run test`命令，你会看到测试失败并显示以下消息：
- en: '![Figure 10.15 – Error – Cannot make XHRs from within a fake async test'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.15 - 错误 - 无法在伪异步测试中进行XHR请求'
- en: '](image/Figure_10.15_B15150.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_10.15_B15150.jpg)'
- en: Figure 10.15 – Error – Cannot make XHRs from within a fake async test
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.15 - 错误 - 无法在伪异步测试中进行XHR请求
- en: What this means is that we can't make real HTTP calls from the `fakeAsync` tests,
    which is what happens after the `ngOnInit()` method is called.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们不能在`fakeAsync`测试中进行真实的HTTP调用，这就是在调用`ngOnInit()`方法后发生的情况。
- en: 'The proper way to test this is to mock `UserService`. Luckily, we''ve already
    done this as we have the `UserServiceMock` class in the project. We need to provide
    it as a `useClass` property for `UserService` in `TestBed` and update our test
    slightly. Let''s modify the `users.component.spec.ts` file as follows:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确的测试方法是模拟`UserService`。幸运的是，我们已经在项目中做过这个，因为我们有`UserServiceMock`类。我们需要将它提供为`TestBed`中`UserService`的`useClass`属性，并稍微更新我们的测试。让我们修改`users.component.spec.ts`文件，如下所示：
- en: '[PRE41]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now, if you run the tests again, they should pass. We'll cover this in more
    detail in the *How it works...* section later.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你再次运行测试，它们应该通过。我们稍后会在*它是如何工作...*部分详细介绍这一点。
- en: 'Let''s add another test for a scenario in which we want to search users. We''ll
    set the value for the `username` form control and search users using `UserService`,
    or more technically, `UserServiceMock`. Then, we will expect the results to be
    appropriate. Add a test in the `users.component.spec.ts` file as follows:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为一个想要搜索用户的场景添加另一个测试。我们将设置`username`表单控件的值，并使用`UserService`或更准确地说是`UserServiceMock`来搜索用户。然后，我们期望结果是合适的。在`users.component.spec.ts`文件中添加一个测试，如下所示：
- en: '[PRE42]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now we''ll write a test for `UserDetailComponent`. We need to test that our
    `UserDetailComponent` gets the appropriate user from the server when the component
    is initiated and that we get similar users as well. Update the `user-detail.component.spec.ts`
    file by adding a test, as follows:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将为`UserDetailComponent`编写一个测试。我们需要测试当组件初始化时，`UserDetailComponent`能否从服务器获取到适当的用户，并且我们也能获取到相似的用户。在`user-detail.component.spec.ts`文件中添加一个测试，如下所示：
- en: '[PRE43]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The new test should be failing at the moment. We will fix it in the next steps.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 新的测试目前应该是失败的。我们将在接下来的步骤中修复它。
- en: 'To debug, we can quickly add a `console.log()` to the `params` that we get
    from subscribing to the `route.paramMap` Observable in the `ngOnInit()` method.
    Modify the `user-detail.component.ts` file, and then run the tests again:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了调试，我们可以在`ngOnInit()`方法中订阅`route.paramMap` Observable并快速添加一个`console.log()`来打印我们从`params`中获取的内容。修改`user-detail.component.ts`文件，然后再次运行测试：
- en: '[PRE44]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now when you run the tests, you can see the error, as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你运行测试时，你会看到错误，如下所示：
- en: '![Figure 10.16 – Error – empty params and missing uuid'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.16 - 错误 - 空参数和缺少uuid'
- en: '](image/Figure_10.16_B15150.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_10.16_B15150.jpg)'
- en: Figure 10.16 – Error – empty params and missing uuid
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.16 - 错误 - 空参数和缺少uuid
- en: 'As you can see in *Figure 10.16*, we don''t have the `uuid` in the `Params`
    object. This is because it is not a real routing process for a real user. So,
    we need to mock the `ActivatedRoute` service that is used in `UserDetailComponent`
    to get the desired result. Let''s create a new file inside the `__mocks__` folder,
    named `activated-route.mock.ts`, and add the following code to it:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如你在*图10.16*中所看到的，我们在`Params`对象中没有`uuid`。这是因为这不是一个真实用户的真实路由过程。因此，我们需要模拟`UserDetailComponent`中使用的`ActivatedRoute`服务以获得期望的结果。让我们在`__mocks__`文件夹内创建一个名为`activated-route.mock.ts`的新文件，并将以下代码添加到其中：
- en: '[PRE45]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now we''ll use this mock in our tests for `UserDetailComponent`. Update the
    `user-detail.component.spec.ts` file, as follows:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将在`UserDetailComponent`的测试中使用这个模拟。更新`user-detail.component.spec.ts`文件，如下所示：
- en: '[PRE46]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now that we have injected the mock into the test environment, let''s modify
    our test to get the second user from the `DUMMY_USERS` array. Update the tests
    file as follows:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经将模拟注入到测试环境中，让我们修改我们的测试以从`DUMMY_USERS`数组中获取第二个用户。更新测试文件如下：
- en: '[PRE47]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now we''ll write a test that allows us to get similar users when `UserDetailComponent`
    is loaded. Remember that according to our current business logic, similar users
    are all users except the current user on the page, which is saved in the `user`
    property. Let''s add the test in the `user-detail.component.spec.ts` file, as
    follows:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将编写一个测试，当加载`UserDetailComponent`时，允许我们获取相似的用户。请记住，根据我们当前的业务逻辑，相似的用户是除了页面上保存在`user`属性中的当前用户之外的所有用户。让我们在`user-detail.component.spec.ts`文件中添加测试，如下所示：
- en: '[PRE48]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If you run the tests, you should see them all pass as follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行测试，你应该看到它们都通过，如下所示：
- en: '![Figure 10.17 – All of the tests are passing with mocked Observables'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.17 - 所有的测试都通过了模拟的Observables'
- en: '](image/Figure_10.17_B15150.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_10.17_B15150.jpg)'
- en: Figure 10.17 – All of the tests are passing with mocked Observables
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.17 - 所有的测试都通过了模拟的Observables
- en: Great! You now know how to work with Observables when writing unit tests for
    components. Although there's still a lot to learn about testing Observables in
    Angular, the purpose of this recipe was to keep everything simple and sweet.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在你知道如何在编写组件的单元测试时使用Observables了。虽然在Angular中测试Observables还有很多要学习的，但这个教程的目的是保持一切简单和甜美。
- en: Now that you have finished the recipe, please refer to the next section to understand
    how it works.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完成了这个教程，请参考下一节以了解它是如何工作的。
- en: How it works...
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We start our recipe by using the `fakeAsync()` and `tick()` methods from the
    `'@angular/core/testing'` package. Notice that we wrap our tests' callback method
    using the `fakeAsync()` method. The method wrapped in the `fakeAsync()` method
    is executed in something called a `fakeAsync` zone. This is contrary to how it
    works in the actual Angular application, which runs inside `ngZone`.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用`'@angular/core/testing'`包中的`fakeAsync()`和`tick()`方法来开始我们的教程。请注意，我们使用`fakeAsync()`方法包装我们测试的回调方法。在`fakeAsync()`方法中包装的方法是在一个叫做`fakeAsync`区域中执行的。这与实际的Angular应用程序运行在`ngZone`内的方式相反。
- en: Important note
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In order to work with the `fakeAsync` zone, we need to import the `zone.js/dist/zone-testing`
    library in our test environment. This is usually done in the `src/test.ts` file
    when you create an Angular project. However, since we migrated to Jest, we removed
    that file.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`fakeAsync`区域，我们需要在测试环境中导入`zone.js/dist/zone-testing`库。当你创建一个Angular项目时，通常会在`src/test.ts`文件中进行这个操作。然而，由于我们迁移到了Jest，我们删除了那个文件。
- en: '*"Okay. How does it work then, Ahsan?"* Well, I''m glad you asked. While setting
    up for Jest, we use the `jest-preset-angular` package. This package ultimately
    requires all the necessary files for the `fakeAsync` tests, as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: “好的。那么，它是如何工作的，阿赫桑？”好吧，我很高兴你问。在为Jest设置时，我们使用`jest-preset-angular`包。这个包最终需要为`fakeAsync`测试导入所有必要的文件，如下所示：
- en: '![Figure 10.18 – The jest-preset-angular package importing the required zone.js
    files'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.18 - jest-preset-angular包导入所需的zone.js文件'
- en: '](image/Figure_10.18_B15150.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_10.18_B15150.jpg)'
- en: Figure 10.18 – The jest-preset-angular package importing the required zone.js
    files
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.18 - jest-preset-angular包导入所需的zone.js文件
- en: Essentially, the `tick()` method simulates the passage of time in this virtual
    `fakeAsync` zone until all of the asynchronous tasks are finished. It takes a
    parameter as milliseconds, which either reflects how many milliseconds have passed
    or how much the virtual clock has advanced. In our case, we use `500` milliseconds
    as the value for the `tick()` method.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，“tick()”方法在这个虚拟的“fakeAsync”区域中模拟时间的流逝，直到所有的异步任务都完成。它接受一个毫秒参数，反映了经过了多少毫秒或虚拟时钟前进了多少。在我们的情况下，我们使用“500”毫秒作为“tick()”方法的值。
- en: Notice that we're mocking `UserService` for the tests for `UsersComponent`.
    Specifically for `'should get users back from the API component init'`, we call
    the `component.ngOnInit()` method in the test and then call the `tick()` method.
    In the meantime, the `ngOnInit()` method calls the `searchUsers()` method, which
    calls the `UserServiceMock.searchUsers()` method since we've provided it as the
    `useClass` property in our test environment for `UserService`. Finally, that returns
    the value of the `DUMMY_USERS` array that we have defined in the `user.service.mock.ts`
    file. The other test for the `UsersComponent`, that is, `'should get the searched
    users from the API upon searching'`, is quite similar as well.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们为“UsersComponent”的测试模拟了“UserService”。特别是对于“'should get users back from
    the API component init'”，我们在测试中调用了“component.ngOnInit()”方法，然后调用了“tick()”方法。同时，“ngOnInit()”方法调用了“searchUsers()”方法，该方法调用了“UserServiceMock.searchUsers()”方法，因为我们在测试环境中为“UserService”提供了“useClass”属性。最后，它返回了我们在“user.service.mock.ts”文件中定义的“DUMMY_USERS”数组的值。对于“UsersComponent”的另一个测试，“'should
    get the searched users from the API upon searching'”，也是非常相似的。
- en: In terms of the tests for `UserDetailComponent`, we do something different,
    that is, we also have to mock the `activatedRoute` service. Why? Well, that is
    because the `UserDetailComponent` is a page that can be navigated with a `uuid`
    and because its path is defined as `'/users/:uuid'` in the `app-routing.module.ts`
    file. Therefore, we need to populate this `uuid` parameter in our tests to work
    with the `DUMMY_USERS` array. For this, we use the `ActivatedRouteMock` class
    inside the `__mocks__` folder. Notice that it has a `setParamMap()` method. This
    allows us to specify the `uuid` parameter in our tests. Then, when the actual
    code subscribes to the `this.route.paramMap` Observable, our set `uuid` parameter
    can be found there.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 关于“UserDetailComponent”的测试，我们做了一些不同的事情，也就是，我们还必须模拟“activatedRoute”服务。为什么？那是因为“UserDetailComponent”是一个可以使用“uuid”导航的页面，并且因为它的路径在“app-routing.module.ts”文件中被定义为“'/users/:uuid'”。因此，我们需要在我们的测试中填充这个“uuid”参数，以便与“DUMMY_USERS”数组一起使用。为此，我们在“__mocks__”文件夹中使用“ActivatedRouteMock”类。请注意，它有一个“setParamMap()”方法。这允许我们在测试中指定“uuid”参数。然后，当实际代码订阅“this.route.paramMap”可观察对象时，我们设置的“uuid”参数就可以在那里找到。
- en: For the `'should get the user based on routeParams on page load'` test, we set
    the second user's `uuid` from the `DUMMY_USERS` array as the `uuid` route parameter's
    value. Then, we use the `tick()` method, after which we expect the `user` property
    to have the second user from the `DUMMY_USERS` array as the value. The other test
    in the file is also quite similar and self-explanatory. Please refer to the next
    section for more useful links regarding unit testing scenarios.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 对于“'should get the user based on routeParams on page load'”测试，我们将“DUMMY_USERS”数组中的第二个用户的“uuid”设置为“uuid”路由参数的值。然后，我们使用“tick()”方法，之后我们期望“user”属性的值是“DUMMY_USERS”数组中的第二个用户。文件中的另一个测试也是非常相似和不言自明的。有关单元测试场景的更多有用链接，请参考下一节。
- en: See also
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另外
- en: Angular testing component scenarios ([https://docs.angular.lat/guide/testing-components-scenarios](https://docs.angular.lat/guide/testing-components-scenarios))
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular测试组件场景（[https://docs.angular.lat/guide/testing-components-scenarios](https://docs.angular.lat/guide/testing-components-scenarios)）
- en: Testing routed Angular components with `RouterTestingModule` ([https://dev.to/this-is-angular/testing-angular-routing-components-with-the-routertestingmodule-4cj0](https://dev.to/this-is-angular/testing-angular-routing-components-with-the-routertestingmodule-4cj0))
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`RouterTestingModule`测试路由的Angular组件（[https://dev.to/this-is-angular/testing-angular-routing-components-with-the-routertestingmodule-4cj0](https://dev.to/this-is-angular/testing-angular-routing-components-with-the-routertestingmodule-4cj0)）
- en: Unit testing Angular Pipes
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试Angular管道
- en: In my personal opinion, pipes are the easiest components to test in an Angular
    application. Why? Well, this is because they're (supposed to be) pure functions
    that return the same result based on the same set of inputs. In this recipe, we'll
    write some tests for a really simple pipe in an Angular application.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在我个人看来，管道是Angular应用程序中最容易测试的组件。为什么？嗯，这是因为它们（应该）是根据相同的输入集返回相同结果的纯函数。在这个食谱中，我们将为Angular应用程序中的一个非常简单的管道编写一些测试。
- en: Getting ready
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project that we are going to work with resides in `chapter10/start_here/unit-testing-pipes`,
    which is inside the cloned repository. Perform the following steps:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要处理的项目位于`chapter10/start_here/unit-testing-pipes`中，这是在克隆的存储库中。执行以下步骤：
- en: Open the project in Visual Studio Code.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中打开项目。
- en: Open the Terminal and run `npm install` to install the dependencies of the project.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`来安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。
- en: 'This should open the app in a new browser tab. You should see something similar
    to the following screenshot:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在新的浏览器选项卡中打开应用程序。您应该看到类似以下截图的内容：
- en: '![Figure 10.19 – The unit-testing-pipes app running on http://localhost:4200'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.19 - 运行在http://localhost:4200上的unit-testing-pipes应用程序'
- en: '](image/Figure_10.19_B15150.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_10.19_B15150.jpg)'
- en: Figure 10.19 – The unit-testing-pipes app running on http://localhost:4200
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.19 - 运行在http://localhost:4200上的unit-testing-pipes应用程序
- en: Now that we have the app running locally, in the next section, let's go through
    the steps of the recipe.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经在本地运行了应用程序，在下一节中，让我们按照食谱的步骤进行。
- en: How to do it...
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Here, we have a simple recipe that takes two inputs – the digit and the max
    factor value. Based on these inputs, we show a multiplication table. We already
    have the `MultTablePipe` that is working fine according to our business logic.
    We''ll now write some unit tests to validate our inputs and expected outputs,
    as follows:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个简单的食谱，需要两个输入 - 数字和最大因子值。根据这些输入，我们显示一个乘法表。根据我们的业务逻辑，我们已经有了工作正常的`MultTablePipe`。现在我们将编写一些单元测试来验证我们的输入和预期输出，如下所示：
- en: 'Let''s write our first test for `MultTablePipe`. We''ll make sure it returns
    an empty array when we have an invalid value for the `digit` input. Update the
    `mult-table.pipe.spec.ts` file, as follows:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为`MultTablePipe`编写我们的第一个测试。我们将确保当`digit`输入的值无效时，它返回一个空数组。更新`mult-table.pipe.spec.ts`文件，如下所示：
- en: '[PRE49]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Let''s write another test to validate the `limit` input so that we also return
    an empty array if it is invalid:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编写另一个测试，验证`limit`输入，以便在无效时也返回一个空数组：
- en: '[PRE50]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now we''ll write a test to validate the output of the pipe''s transform method
    when both the `digit` and `limit` inputs are valid. In this scenario, we should
    get back the array containing the multiplication table. Write another test as
    follows:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将编写一个测试，验证管道的转换方法的输出，在`digit`和`limit`输入都有效时。在这种情况下，我们应该得到包含乘法表的数组。编写另一个测试如下：
- en: '[PRE51]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Right now, within the app, we have the possibility to provide decimal digits
    for the `limit` input. For instance, we can write `2.5` as the max factor in the
    input. To handle this, we use a `Math.floor()` in `MultTablePipe` to round it
    down to the lower number. Let''s write a test to make sure this works:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在应用程序中，我们有可能为“限制”输入提供小数位数。例如，我们可以在输入中将“2.5”写为最大因子。为了处理这个问题，我们在“MultTablePipe”中使用“Math.floor（）”将其向下舍入到较低的数字。让我们编写一个测试来确保这个功能有效：
- en: '[PRE52]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Easy peasy! Writing tests for Angular pipes is so straightforward that I love
    it. We could call this the power of pure functions. Now that you've finished the
    recipe, please refer to the next section for more informative links.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 易如反掌！为Angular管道编写测试是如此直接，以至于我喜欢它。我们可以称之为纯函数的力量。现在您已经完成了这个步骤，请参考下一节以获取更多信息链接。
- en: See also
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Testing Angular pipes official documentation ([https://angular.io/guide/testing-pipes](https://angular.io/guide/testing-pipes))
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试Angular管道官方文档（https://angular.io/guide/testing-pipes）
- en: '*Test Angular Pipes With Services* ([https://levelup.gitconnected.com/test-angular-pipes-with-services-4cf77e34e576](https://levelup.gitconnected.com/test-angular-pipes-with-services-4cf77e34e576))'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用服务测试Angular管道（https://levelup.gitconnected.com/test-angular-pipes-with-services-4cf77e34e576）
