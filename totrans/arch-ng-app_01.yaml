- en: Quick Look Back at Data Services for Simple Apps
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速回顾简单应用的数据服务
- en: Welcome to the first chapter of this book. You have hopefully picked up this
    book because you have experienced issues setting up the architecture of your Angular
    application. Your application has grown and in that process you slowly feel your
    are losing track of what your application knows at a given point, what we call
    the state of the application. There might be other issues, such as parts of your
    application not being in agreement with what they know. An update that happened
    in one part may not have been applied to some other part and you scratch your
    head, thinking should it be this hard and is there a better answer?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到本书的第一章。你之所以选择这本书，可能是因为你在设置 Angular 应用架构时遇到了问题。你的应用在成长过程中，你逐渐感觉到你失去了对应用在某个特定时刻所知道的内容的追踪，这就是我们所说的应用状态。可能还有其他问题，比如应用的一部分可能没有与它们所知道的内容达成一致。一个部分发生的更新可能没有被应用到其他部分，你挠头思考，这是否太难了，是否有更好的解决方案？
- en: It's entirely possible you are just picking up this book as you have heard about
    NgRx as the way to structure your application and you are curious and want to
    know more.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能你只是因为听说 NgRx 是结构化应用的一种方式而选择这本书，你好奇并想了解更多。
- en: Regardless of which motivation drives you to read this book, this book is about
    learning to structure your application and learning how to set up and communicate
    your application's state, and its changes, in a way that all parts of your application
    are in agreement on what is happening. The underlying architectural pattern for
    NgRx is Redux, which constrains data to live in only one place and ensures data
    is flowing in only one direction. We will have a chance to cover Redux in more
    depth in a dedicated chapter in this book.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是什么动机驱使你阅读这本书，本书都是关于学习如何结构化你的应用，以及如何以所有应用部分都同意的方式设置和传达应用的状态及其变化。NgRx 的底层架构模式是
    Redux，它将数据限制在仅一个地方，并确保数据仅向一个方向流动。我们将在本书的专门章节中更深入地探讨 Redux。
- en: To get to a point where we have learned to master NgRx, we first need to pick
    up some paradigms and patterns along the way. We need to build a good foundation
    of knowledge. A good foundation consists of learning concepts such as **Functional
    Reactive Programming** (**FRP**), the architectural pattern Flux, and a new and
    exciting way of thinking about async concepts, Observables.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 要达到掌握 NgRx 的水平，我们首先需要在学习过程中掌握一些范式和模式。我们需要建立一个良好的知识基础。良好的基础包括学习诸如**函数式响应式编程**（**FRP**）、架构模式
    Flux 以及一种关于异步概念的新颖且令人兴奋的思考方式，即 Observables。
- en: So why are these relevant for our learning journey of mastering NgRx? The Flux
    pattern has a lot in common with Redux and it is its shortcomings that led to
    Redux being created. NgRx itself is implemented using RxJS, which promotes a functional
    reactive style of programming. So you see, the foundations we are about to explore
    all help us grasp the theory and motivations behind NgRx.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么这些对我们学习掌握 NgRx 的旅程是相关的？Flux 模式与 Redux 有很多共同之处，正是它的不足导致了 Redux 的创建。NgRx
    本身是使用 RxJS 实现的，它促进了函数式响应式编程风格。所以你看，我们即将探索的基础知识都有助于我们掌握 NgRx 的理论和动机。
- en: In this chapter, we lay the foundations for the book by discussing the well-known
    **Model-View-Controller** (**MVC**) pattern. To verify we understand the MVC pattern,
    we use the Angular framework to make things easier. As interesting as it is to
    talk about architecture, if you don't see it applied to something real, it might
    be hard to grasp.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过讨论众所周知的**模型-视图-控制器**（**MVC**）模式为本书奠定基础。为了验证我们是否理解 MVC 模式，我们使用 Angular
    框架来简化问题。虽然谈论架构很有趣，但如果你不看到它应用于现实事物，可能很难掌握。
- en: We continue diving into an application workflow in Angular and its Dependency
    Injection machinery. Before concluding the chapter, we will also have a look at
    how to fetch data through an API because, after all, that is where the data comes
    from and should flow to.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续深入探讨 Angular 应用的工作流程及其依赖注入机制。在结束本章之前，我们还将了解如何通过 API 获取数据，因为毕竟数据是从那里来的，应该流向那里。
- en: 'In this chapter, we will:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Describe the building blocks of the MVC pattern
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述 MVC 模式的构建块
- en: Describe MVC in Angular and the core constructs that help support it
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述 Angular 中的 MVC 以及帮助支持它的核心结构
- en: Review the HTTP service and how to deal with Ajax
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复习 HTTP 服务以及如何处理 Ajax
- en: Model-View-Controller – the pattern we all know
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型-视图-控制器 – 我们都熟知的模式
- en: 'Regardless of whether you have been a programmer for a year or 20 years, you
    have almost certainly encountered the MVC pattern in some way, shape, or form.
    The pattern itself, MVC, consists of three interconnected parts: model, view,
    and controller. More important than knowing all its parts is knowing what problem
    it solves. It solves the problem of separation of concerns by decoupling view
    logic, data logic, and business logic. The MVC pattern has given rise to, among
    others:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是一名程序员一年还是20年，你几乎肯定以某种形式遇到过MVC模式。这个模式本身，MVC，由三个相互关联的部分组成：模型、视图和控制器。了解所有部分的重要性不如了解它解决的问题。它通过解耦视图逻辑、数据逻辑和业务逻辑来解决问题。MVC模式催生了以下内容：
- en: '**Model-View-Adapter** (**MVA**)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型-视图-适配器**（**MVA**）'
- en: '**Model-View-Presenter** (**MVP**)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型-视图-呈现器**（**MVP**）'
- en: '**Model-View-ViewModel** (**MVVM**)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型-视图-视图模型**（**MVVM**）'
- en: Cohesion and coupling – establishing a common language
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内聚和耦合 – 建立共同语言
- en: Without a pattern like MVC, your code could turn out to be hard to maintain
    as it could have low cohesion and high coupling. Those are fancy words, so what
    do we mean? Cohesion is about focus and what the class should do. The lower the
    cohesion, the more different things are performed by a class and therefore it
    has no clear intention of what it should perform.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 没有像MVC这样的模式，你的代码可能很难维护，因为它可能具有低内聚和高耦合。这些是华丽的词藻，那么我们的意思是什么？内聚是关于关注点和类应该做什么。内聚越低，一个类执行的不同事情就越多，因此它没有明确的意图知道它应该做什么。
- en: 'The following code shows what happens when a class has low cohesion; it does
    a lot more than storing data about an invoice, such as being able to log to a
    file or talk to a database:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了当一个类具有低内聚性时会发生什么；它做的不仅仅是存储发票数据，例如能够将日志记录到文件或与数据库通信：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now we have introduced new dedicated classes and moved methods out of the `Invoice`
    class to make sure that each and every class now has high cohesion, that is, is
    more focused on doing one thing well. We therefore now have the classes `Invoice`,
    `Printer`, `Logger`, and `InvoiceRepository`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经引入了新的专用类，并将方法从`Invoice`类中移出，以确保每个类现在都具有高内聚，即更专注于做好一件事。因此，我们现在有`Invoice`、`Printer`、`Logger`和`InvoiceRepository`这些类：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The point I am trying to make here is that a class should only do one thing
    well. This is illustrated by the unfocused `Invoice` class being split into four
    different classes that each do only one focused thing well.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里试图说明的是，一个类应该只做好一件事。这可以通过将缺乏关注的`Invoice`类拆分为四个不同的类来展示，每个类都只专注于做好一件事。
- en: 'So that deals with cohesion/focus. What about coupling? Coupling is about how
    strongly connected a software element is to another software element. Ultimately,
    the higher the coupling, the harder/more tedious it is to change. Let''s look
    at the following example of high coupling written in Java:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们解决了内聚/关注点的问题。那么耦合呢？耦合是关于一个软件元素与另一个软件元素连接的强度。最终，耦合越高，更改就越困难/繁琐。让我们看看以下用Java编写的具有高耦合的示例：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There are multiple problems with this code, especially if you aim to change
    the code in any way. Let''s say we wanted to print an email as well. It is tempting
    to think we would need an `Email` class and need to add another `print()` method
    override to the `Printer` class. We would also need to add branching logic to
    the `Program` class. Furthermore, testing the `Program` class cannot be achieved
    without causing a side-effect: calling the `run()` method would cause an actual
    call to a printer. The way we tend to work with tests nowadays is to run our tests
    every time the code changes, which it might do quite a lot as we are developing
    our program. We might end up with thousands of printed papers just developing
    our code. For that reason, we need to isolate ourselves from side effects when
    developing code and tests. What we want to test at the end of the day is that
    our code behaves correctly, not that the physical printer seems to work.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码存在多个问题，尤其是如果你打算以任何方式更改代码。假设我们想要打印一封电子邮件。我们可能会想，我们需要一个`Email`类，并需要向`Printer`类添加另一个`print()`方法重写。我们还需要向`Program`类添加分支逻辑。此外，测试`Program`类无法不引起副作用：调用`run()`方法会导致实际调用打印机。我们现在的测试方式是每次代码更改时都运行测试，因为我们正在开发程序，这可能导致代码更改非常频繁。我们可能会在开发代码的过程中打印出数千张纸。因此，我们需要在开发代码和测试时将自己与副作用隔离开。我们最终想要测试的是代码的行为是否正确，而不是物理打印机是否看起来工作正常。
- en: 'In the following code, we see an example of high coupling. We add another type,
    `Email`. The purpose of doing that is to see the effects of doing so, which is
    that we need to add code to several places at once. Having to do so is a sign
    of a code smell. The fewer changes you need to make, the better it usually is:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们看到一个高耦合的例子。我们添加了另一个类型 `Email`。这样做是为了看到这样做的影响，即我们需要同时向几个地方添加代码。必须这样做是一个代码坏味的迹象。你需要做的更改越少，通常越好：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So let''s rearrange the code a bit:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们稍微调整一下代码：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: At this point, we have made our program open to extension. How can we say that,
    you ask? Clearly, we have removed the `printer` methods from `printer`. We also
    removed the switch logic from the method run in the `Program` class. We have also
    added the abstraction `IPrintable`, which makes anything printable responsible
    for telling a printer what the printable content is.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使我们的程序可以扩展。你怎么说呢？显然，我们已经从 `printer` 中移除了 `printer` 方法。我们还从 `Program`
    类的方法 `run` 中移除了切换逻辑。我们还添加了抽象 `IPrintable`，这使得任何可打印的内容都负责告诉打印机其可打印的内容是什么。
- en: You can clearly see how we went from high coupling to low coupling when we introduced
    the types `Document` and `Note`. The only change they cause is themselves being
    added and implementing the `IPrintable` interface. Nothing else has to change.
    Success!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以清楚地看到，当我们引入 `Document` 和 `Note` 类型时，我们是如何从高耦合转变为低耦合的。它们引起的唯一变化是它们自己被添加并实现了
    `IPrintable` 接口。其他什么都不需要改变。成功！
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'OK, so to sum up our changes:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，所以总结一下我们的更改：
- en: We added the `IPrintable` interface
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了 `IPrintable` 接口
- en: We simplified/removed the branching logic in the `Program.run()` method
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们简化/移除了 `Program.run()` 方法中的分支逻辑
- en: We made each printable class implement `IPrintable`
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们让每个可打印类实现 `IPrintable`
- en: We added some code at the end of the previous snippet to demonstrate how easy
    it would be to add new types
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在之前的代码片段末尾添加了一些代码，以展示添加新类型是多么容易
- en: We injected an `IPrinter` through the `Program` class constructor to ensure
    that we can easily test the `Program` class
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过 `Program` 类构造函数注入了 `IPrinter`，以确保我们可以轻松测试 `Program` 类
- en: In particular note that we did not need to change any logic in either `Printer`
    or `Program`, when adding the `Document` and `Note` types. The only thing we needed
    to do was add `Document` and `Notes` as classes and ensure they implemented the
    `IPrintable` interface. To put emphasis on this, *any addition to a program should
    not lead to an overall system change in the code*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意，当我们添加 `Document` 和 `Note` 类型时，我们不需要在 `Printer` 或 `Program` 中更改任何逻辑。我们唯一需要做的是添加
    `Document` 和 `Notes` 作为类，并确保它们实现了 `IPrintable` 接口。为了强调这一点，*任何对程序的添加都不应该导致代码的整体系统变化*。
- en: Let's reiterate the last bullet of adding `IPrinter`. Testability is a very
    good measurement to see whether your code has low coupling. If you depend on abstractions
    rather than actual classes, you are able to easily switch out one concrete class
    for another, while maintaining high-level behavior.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重申一下添加 `IPrinter` 的最后一条。可测试性是一个非常好的衡量标准，可以用来判断你的代码是否具有低耦合。如果你依赖于抽象而不是实际类，你就可以轻松地用另一个具体类替换一个具体类，同时保持高级行为。
- en: 'Another reason for switching `Printer` to `IPrinter` is so that we remove side
    effects from the program when we test our code. Side effects are when we talk
    to files, mutate states, or talk over the network for example. Testing the `Program`
    class means we want to get rid of a side effect such as actual printing and have
    it call something fake, or we would have a large stack of papers every time we
    run our tests. So to instantiate our `Program` class for the purposes of testing,
    we would write something like this instead:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `Printer` 切换到 `IPrinter` 的另一个原因是，当我们测试代码时，可以消除程序中的副作用。副作用是指我们与文件交互、改变状态或通过网络进行通信等情况。测试
    `Program` 类意味着我们希望消除实际打印等副作用，而是调用一些虚假的函数，或者每次运行测试时都会有一大堆纸张。因此，为了测试目的实例化我们的 `Program`
    类，我们会写一些像这样的事情：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: What we see from this code is how we shift from instantiating the `Printer`
    class (which prints to a real printer) to the `Program` class using an instance
    of `FakePrinter`. In a testing scenario, this is exactly what you would do, if
    wanting to test the `Program` class. What you most likely care about is the `print()`
    method being called with the correct arguments.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 从这段代码中，我们可以看到我们是如何从实例化打印到真实打印机的 `Printer` 类，转变为使用 `FakePrinter` 实例的 `Program`
    类。在测试场景中，这正是你想要测试 `Program` 类时你会做的事情。你最关心的可能是 `print()` 方法被正确地调用。
- en: OK, so this was a pretty long way of expressing what low coupling is about.
    It is, however, important to establish what crucial terms such as coupling and
    cohesion are, especially when talking about patterns.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这已经是一种相当长的表达低耦合的方式了。然而，在谈论模式时，建立诸如耦合和内聚等关键术语的重要性是至关重要的。
- en: Explaining the components of MVC
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释 MVC 的组成部分
- en: Back to the MVC pattern. Using said pattern means we get high cohesion and low
    coupling; this is due to code being split into different layers with different
    responsibilities. View logic belongs in views, controller logic in controllers,
    and model logic in models.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 MVC 模式。使用该模式意味着我们获得高内聚和低耦合；这是由于代码被分割成具有不同责任的不同层。视图逻辑属于视图，控制器逻辑属于控制器，模型逻辑属于模型。
- en: The model
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型
- en: This is the crucial part of the application. This does not rely on any specific
    user interface but more defines the domain in which you operate. Rules, logic,
    and data live here.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是应用程序的关键部分。这并不依赖于任何特定的用户界面，而更多地定义了你在其中操作的范围。规则、逻辑和数据都生活在这里。
- en: The view
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图
- en: This can be anything from a native app view to a bar chart, or even a web page.
    The point is that it ultimately displays data from the model. There can be different
    views displaying the same thing, but depending on for whom they are designed,
    they might look different. An admin might see a totally different view than a
    user for the same information.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以是任何从原生应用视图到柱状图，甚至是网页。关键是它最终显示模型中的数据。可能有不同的视图显示相同的内容，但根据它们的设计对象，它们可能看起来不同。管理员可能看到的视图与用户看到的相同信息完全不同。
- en: The controller
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器
- en: This is really the spider in the web. It is able to take input from the view
    or from the data and turn it into commands.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上就是网中的蜘蛛。它能够从视图或数据中获取输入并将其转换为命令。
- en: Interactions – the behavior between the components
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交互 – 组件之间的行为
- en: All these three mentioned components act in different ways when talking to each
    other. A model stores data it is being given from the controller based on commands.
    A view changes its appearance based on changes happening in the model. A controller
    can send a command to the model based on a user interaction. One such example
    is a user deciding to browse between page-based records. A new set of data will
    need to be retrieved based on the new visual position.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这三个提到的组件在相互交谈时表现不同。模型根据命令存储从控制器接收到的数据。视图根据模型中的变化改变其外观。控制器可以根据用户交互向模型发送命令。一个这样的例子是用户决定在基于页面的记录之间浏览。需要根据新的视觉位置检索一组新的数据。
- en: 'These two basic flows are what mostly happens in an application-based on MVC:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个基本流程是大多数基于 MVC 的应用程序中发生的事情：
- en: 'User interaction: Controller sends command to Model => Model changes => View
    is updated'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户交互：控制器向模型发送命令 => 模型发生变化 => 视图被更新
- en: 'View asks for data: Controller sends command to Model => Model is created/changed
    => View is updated'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图请求数据：控制器向模型发送命令 => 模型被创建/更改 => 视图被更新
- en: MVC summary
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVC 概述
- en: 'A lot can be said about MVC and its many variants, but let''s be content with
    what we have for now by summarizing the properties of the pattern that we identified:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 MVC 及其许多变体有很多可以说的，但让我们现在就满足于总结我们已识别的模式属性：
- en: Low coupling
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 低耦合
- en: High cohesion, separating presentation concerns from the model
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高内聚，将表示关注点从模型中分离出来
- en: Simultaneous development is possible; due to the existence of many layers, people
    can work in parallel on a task
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时开发是可能的；由于存在许多层，人们可以并行地完成任务
- en: Ease of change; because of how things are separated, adding future concepts
    or making alterations becomes easier
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于更改；由于事物是分离的，添加未来的概念或进行更改变得更容易
- en: An MVC flow in Angular
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 中的 MVC 流程
- en: 'Let''s look at the following problems and how we solve them in Angular:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下问题以及我们如何在 Angular 中解决这些问题：
- en: Creating and rendering model data to the screen
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和渲染模型数据到屏幕
- en: Learning how the MVC pattern maps to the Angular framework
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习 MVC 模式如何映射到 Angular 框架
- en: Learning how we can structure an Angular application in different building blocks
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何以不同的构建块结构化 Angular 应用程序
- en: Fetching data/persisting data
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取数据/持久化数据
- en: The model
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型
- en: 'The model in Angular is a plain class, as we are using TypeScript. It can look
    like the following code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 中的模型是一个普通的类，因为我们使用 TypeScript。它可能看起来像以下代码：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It is a plain TypeScript file, or rather an ES2015 module, not to be confused
    with an Angular module. We will discuss in the next main section what an Angular
    module is, in terms of setup and how it is consumed. For now, remember the model
    is a simple thing.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个普通的 TypeScript 文件，或者更确切地说是一个 ES2015 模块，不要与 Angular 模块混淆。我们将在下一主要部分讨论 Angular
    模块是什么，以及它的设置和消费方式。现在，记住模型是一个简单的东西。
- en: The component – a controller and a building block
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件 – 控制器和构建块
- en: In the context of MVC, the component is the V and C, the view and the controller.
    The component allows you to define either a separate template file or an inline
    template. The template is the view part.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MVC 的上下文中，组件是 V 和 C，即视图和控制。组件允许你定义一个单独的模板文件或内联模板。模板是视图部分。
- en: The controller in this context is a component class file that handles user interactions
    and also fetches the necessary data for the template to display.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，控制器是一个处理用户交互并从模板显示所需数据的组件类文件。
- en: 'Components have come to be a central concept for a lot of frameworks that are
    popular today, such as React, Vue.js, and Polymer. A component can take inputs,
    which are either data or methods. It consists of a piece of code and an HTML template,
    which render interesting data, living on the component. A component in Angular
    consists of three major parts:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 组件已经成为许多当今流行的框架的核心概念，例如 React、Vue.js 和 Polymer。组件可以接受输入，这些输入可以是数据或方法。它由一段代码和一个
    HTML 模板组成，这些模板渲染有趣的数据，并存在于组件中。Angular 中的组件由三个主要部分组成：
- en: A decorator function
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个装饰器函数
- en: A class
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类
- en: A template
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个模板
- en: 'A component consists of a controller class and a template. It can play two
    different roles in an Angular application: either it can be the responder to the
    route or it can serve as a building block. In the first case, Angular will instantiate
    it when a new route happens and respond with that component. In the latter case,
    the component is created directly by existing as a child component within another
    component.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一个组件由一个控制器类和一个模板组成。在 Angular 应用程序中，它可以扮演两个不同的角色：要么作为路由的响应者，要么作为构建块。在前一种情况下，当发生新的路由时，Angular
    将实例化它，并使用该组件进行响应。在后一种情况下，组件直接由另一个组件作为子组件创建。
- en: We will explain next what we meant by the previous paragraph.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一部分解释前一段话的含义。
- en: First responder to a route
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由的第一个响应者
- en: 'As mentioned, a component can be used as a responder to a route. So let''s
    say the application routes to the `/products` route as a result of a user interaction,
    or programmatically. Angular''s way of dealing with this is to associate the `/products`
    route with a component. With the help of a component''s class and HTML markup,
    we are able to produce a piece of HTML containing our markup and data rendered
    together. Pointing out a component as a responder to a route, is done when defining
    the so-called route map, like so:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，组件可以用作路由的响应者。所以，假设应用程序由于用户交互或程序性地路由到 `/products` 路由，Angular 处理这种情况的方式是将
    `/products` 路由与一个组件关联。借助组件的类和 HTML 标记，我们能够生成包含我们的标记和数据一起渲染的 HTML 片段。将组件指定为路由的响应者是在定义所谓的路由映射时完成的，如下所示：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Essentially, a route is defined as an object with `path` properties, pointing
    out our route, and a `component` property pointing to the responding component.
    We can attach other properties to the route, such as `data`, to give the responding
    components some initial data to render.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，路由被定义为具有 `path` 属性的对象，指明我们的路由，以及一个指向响应组件的 `component` 属性。我们可以将其他属性附加到路由上，例如
    `data`，以给响应组件提供一些初始数据以进行渲染。
- en: Used as a building block
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作为构建块使用
- en: 'Using a component as a building block means it will be part of another component''s
    template. Essentially, it will be seen as that component''s child. This line of
    thinking is quite natural and means that we can think of our application as a
    hierarchical tree of components. A component in Angular consists of a controller
    class and a template as we have mentioned previously. A typical component looks
    like so:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 将组件作为构建块使用意味着它将成为另一个组件模板的一部分。本质上，它将被视为该组件的子组件。这种思维方式相当自然，意味着我们可以将我们的应用程序视为组件的分层树。如前所述，Angular
    中的组件由一个控制器类和一个模板组成。一个典型的组件看起来是这样的：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `@Component` decorator function adds metadata to the class. This instructs
    Angular on how to create the component so that Angular can place the component
    in the DOM. This enables you to use it as a responder to a route or as your own
    custom element. The property `selector` is what decides what your component should
    be called, if used as a custom element. Example usage looks like the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Component`装饰器函数为类添加元数据。这指导Angular如何创建组件，以便Angular可以将组件放置在DOM中。这使得你可以将其用作对路由的响应者，或者作为你自己的自定义元素。属性`selector`决定了如果你的组件用作自定义元素，它应该被称为什么。以下是一个示例用法：'
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The fact that components can be used this way makes it easy to think about
    an app as consisting of a hierarchical tree of components. A Todo application
    could therefore look like the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 组件可以以这种方式使用，这使得将应用视为由组件组成的分层树变得容易。因此，一个待办事项应用可能看起来如下所示：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s start to create this app, starting with the `AppComponent`. As this
    is the topmost component, it is also referred to as the root component. The `AppComponent`
    should render the `TodoListComponent` in its own template, like so:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建这个应用，从`AppComponent`开始。由于这是最顶层的组件，它也被称作根组件。`AppComponent`应该在它的模板中渲染`TodoListComponent`，如下所示：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The next step is defining the `TodoListComponent` and knowing that it should
    be able to render a number of `TodoItemComponent` instances within its template.
    The size of a list is usually unknown. This is exactly what the structural directive
    `*ngFor` is for. So that is what we will utilize in the following code as we define
    the `TodoListComponent`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是定义`TodoListComponent`，并知道它应该能够在其模板中渲染多个`TodoItemComponent`实例。列表的大小通常是未知的。这正是结构指令`*ngFor`的作用。因此，在定义`TodoListComponent`时，我们将利用以下代码：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here, we can see that we render out a list of `todo` items by looping out the
    todos array in the template, like so:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们通过在模板中循环`todos`数组来渲染一系列`todo`项，如下所示：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can see in the preceding code that we are rendering out the `todo-item`
    selector, which points to a `TodoItemComponent` that we are yet to define. Worth
    noting is how we pass it a `todo` object and assign it to an input property on
    the `TodoItemComponent`. The definition for said component is as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们渲染了`todo-item`选择器，它指向一个我们尚未定义的`TodoItemComponent`。值得注意的是，我们如何传递一个`todo`对象并将其分配给`TodoItemComponent`上的一个输入属性。该组件的定义如下：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Reasoning about which components should exist as part of which other components
    is something you are going to dedicate a lot of time to.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 思考哪些组件应该作为其他组件的一部分存在，这是你需要投入大量时间去做的事情。
- en: Components from an architectural standpoint
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从架构角度来看的组件
- en: You are encouraged to create a lot of components in your Angular application.
    With the former section's example of creating a `todo` list application it was
    tempting to create an application that just consisted of one component, the `AppComponent`.
    This would have meant that one component would have been responsible for a ton
    of things, such as displaying `todo` items, saving said items, removing them and
    so on. Components are meant to be used to solve one thing well. That's why we
    created a `TodoItemComponent` which only job in life was to display a `todo` item.
    Same thing goes for the `TodoListComponent`. It should only care about displaying
    a list, nothing else. The more you split down your applications into small and
    focused areas the better.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓励你在你的Angular应用中创建大量的组件。在前面的示例中，创建了一个`todo`列表应用，很容易想到创建一个只包含一个组件`AppComponent`的应用。这意味着一个组件将负责很多事情，比如显示`todo`项、保存这些项、删除它们等等。组件旨在用于解决一个问题。这就是为什么我们创建了`TodoItemComponent`，它的唯一任务是显示一个`todo`项。对于`TodoListComponent`也是如此。它应该只关心显示列表，其他什么都不管。你将应用拆分成更小、更专注的区域越多，效果越好。
- en: NgModule – our new facade (and some other bits)
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NgModule – 我们的新门面（以及一些其他部分）
- en: 'So far, we have talked about components in terms of them being dedicated to
    solving one task well. However, there are other constructs that can be used in
    Angular, such as pipes, directives, and services. A lot of our components will
    find themselves belonging to a common theme, such as products or user management
    and so on. When we realize what constructs belong to the same theme, we also realize
    that some of these constructs are constructs we want to use elsewhere in the application.
    Conversely, some constructs are only meant to be used in the context of the mentioned
    theme. To protect the latter constructs from unintended use, we would like to
    group them in a facade-like way and put a protective layer between the constructs
    and the rest of the application. The way to do that in pure ES2015 modules is
    to create a facade file, in which public constructs are exported and others are
    not, like so:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论组件时，是按照它们专注于解决一个任务来进行的。然而，Angular 中还有其他可以使用的结构，例如管道、指令和服务。我们的大部分组件都会发现自己属于一个共同的主题，比如产品或用户管理等。当我们意识到哪些结构属于同一主题时，我们也会意识到其中一些结构是我们想在应用程序的其他地方使用的。相反，有些结构只意味着在提到的主题上下文中使用。为了保护这些结构免受意外使用，我们希望以门面方式将它们分组，并在结构与其他应用程序的其余部分之间放置一个保护层。在纯
    ES2015 模块中这样做的方法是创建一个门面文件，在其中公开结构，而其他结构则不公开，如下所示：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Imagine we have a directory consisting of the following files:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个包含以下文件的目录：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The intent of creating a facade file here is to ensure there is only one place
    from where you import all the constructs you need. In this case that would be
    the `index.ts` file. A consumer of the preceding directory would do the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 创建门面文件的目的是确保只有一个地方可以从中导入所有需要的结构。在这种情况下，那就是 `index.ts` 文件。前一个目录的消费者会这样做：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`MyOtherService` is not being exposed by the `index.ts` file though, so attempting
    to access it like we do in `consumer.ts` would lead to an error. You could theoretically
    specify the full path to the construct but you are supposed to be using the barrel.
    Barrels are usually meant to be used to easily access your constructs without
    having to write import statements that are five miles long, like so:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyOtherService` 并没有在 `index.ts` 文件中公开，所以尝试像在 `consumer.ts` 中那样访问它会导致错误。理论上，您可以指定结构的完整路径，但您应该使用桶。桶通常用于轻松访问您的结构，而无需编写长达五英里的导入语句，如下所示：'
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see that barrel, `index.ts` is the one that is responsible for knowing
    where all your constructs are located. This also means that were you to move files
    around, changing directories for certain constructs, the barrel file is the only
    one where updating the paths to these constructs is needed.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，该桶，`index.ts` 是负责知道所有结构所在位置的那个。这也意味着，如果您移动文件，更改某些结构的目录，那么更新这些结构路径的唯一文件就是桶文件。
- en: 'The Angular way of dealing with this is to use Angular modules. An Angular
    module looks like the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 处理这个问题的方式是使用 Angular 模块。一个 Angular 模块看起来如下所示：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The effect of putting `MyComponent` and `MyPipe` into the declarations property
    of the module is so that these components can be freely used within `MyModule`.
    For example, you can use `MyPipe` within the `MyComponent` template. However,
    if you want to use `MyComponent` outside of this module, in a component belonging
    to another module, you will need to export it. We do that by placing it in the
    array belonging to the `exports` property:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `MyComponent` 和 `MyPipe` 放入模块的声明属性中的效果是，这些组件可以在 `MyModule` 中自由使用。例如，您可以在 `MyComponent`
    模板中使用 `MyPipe`。然而，如果您想在模块外部使用 `MyComponent`，在一个属于另一个模块的组件中，您需要将其导出。我们通过将其放置在属于
    `exports` 属性的数组中来做到这一点：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Angular takes the concept of a module way beyond grouping. Some instructions
    in our `NgModule` are meant for the compiler so that it knows how to assemble
    the components. Some other instructions we give it are meant for the Dependency
    Injection tree. Think of the Angular module as a configuration point, but also
    as the place where you logically divide up your application in to cohesive blocks
    of code.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 将模块的概念远远超出了分组。我们 `NgModule` 中的某些指令是为了让编译器知道如何组装组件。我们给出的其他指令是为了依赖注入树。将
    Angular 模块视为一个配置点，同时也是您在逻辑上将应用程序划分为代码块的地方。
- en: 'On the object sent to the `@NgModule` decorator, there are properties you can
    set that have different meanings. The most important properties are:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在发送给 `@NgModule` 装饰器的对象上，你可以设置具有不同含义的属性。最重要的属性包括：
- en: The `declarations` property is an array that states what belongs to our module
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`declarations` 属性是一个数组，指定了属于我们的模块的内容'
- en: The `imports` property is an array that states what other Angular modules we
    are dependent on; it could be basic Angular directives or common functionality
    that we want to use inside of our module
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`imports` 属性是一个数组，指定了我们依赖的其他Angular模块；它可能是基本的Angular指令或我们想在模块内部使用的通用功能'
- en: The `exports` property is an array stating what should be made available for
    any module importing this module; `MyComponent` is made public whereas `MyPipe`
    would become private for this module only
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exports` 属性是一个数组，指定了应该对任何导入此模块的模块可用的内容；`MyComponent` 被公开，而 `MyPipe` 只对此模块是私有的'
- en: The `providers` property is an array stating what services should be injectable
    into constructs belonging to this module, that is, to constructs that are listed
    in the declarations array
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`providers` 属性是一个数组，指定了哪些服务应该注入到属于此模块的构造函数中，也就是说，注入到在声明数组中列出的构造函数中。'
- en: Using ES2015 modules
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ES2015模块
- en: 'So far, we have mentioned that models are just plain classes. An ES2015 module
    is just one file. Within that file lives both public and private constructs. Things
    that are private are only visible within that file. Things that are public can
    be used outside said file. In Angular, Es2015 modules aren''t used only for models
    but for all imaginable constructs such as components, Directives, Pipes, Services,
    and so on. This is because ES2015 modules are an answer to how we split our project
    into smaller parts, which provides us with the following benefits:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经提到模型只是普通的类。ES2015模块只是一个文件。在这个文件中，既有公共构造函数也有私有构造函数。私有的事物只在该文件内部可见。公共的事物可以在文件外部使用。在Angular中，ES2015模块不仅用于模型，还用于所有可想象的构造函数，如组件、指令、管道、服务等等。这是因为ES2015模块是我们将项目拆分成更小部分的一种回答，这为我们提供了以下好处：
- en: Many small files makes it easier to parallelize the work you do and have many
    developers work on it at the same time
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多小文件使得并行处理你的工作变得更加容易，并且可以同时让许多开发者工作
- en: The ability to hide data by, making some parts of your application public and
    some other private
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使应用程序的一些部分公开而其他部分私有来隐藏数据的能力
- en: Code reuse
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码重用
- en: Better maintainability
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好的可维护性
- en: We have to remember what web development used to look like to understand these
    statements. When the web was young our JavaScript code more often than not consisted
    of one file. That quickly became a huge mess. There have been different techniques
    over the years to find a way to split up our app into many small files. Many small
    files have made it easier to maintain and also to get a good overview of what
    is going on, among many other benefits. There have been other issues though. As
    all these small files had to be stitched back together before being shipped with
    the app, a process called bundling, we suddenly had one giant file where functions
    and variables could by mistake affect each other due to naming collisions. A way
    to attack that problem is to deal with something called information hiding. This
    to ensure the variables and functions we created are only visible to certain other
    constructs. There are multiple ways, of course, to address this issue. ES2015
    has a private by default way about them. Everything declared in an ES2015 is private
    by default unless you explicitly export it, thereby making it publicly accessible
    to other modules that import the aforementioned module.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这些陈述，我们必须记住过去网页开发的样子。当网络还很年轻时，我们的JavaScript代码通常只有一个文件。这很快变成了一个巨大的混乱。多年来，我们采用了不同的技术来找到一种方法将我们的应用程序拆分成许多小文件。许多小文件使得维护变得更加容易，同时也更容易获得对正在发生的事情的良好概述，以及其他许多好处。然而，也存在其他问题。由于所有这些小文件在与应用程序一起发布之前都必须重新拼接在一起，这个过程称为打包，我们突然有一个巨大的文件，其中函数和变量可能会因为命名冲突而意外地相互影响。解决这个问题的方法之一是处理称为信息隐藏的东西。这是为了确保我们创建的变量和函数只能对某些其他构造函数可见。当然，解决这个问题有多种方法。ES2015提供了一种默认为私有的方式。在ES2015中声明的所有内容默认都是私有的，除非你明确导出它，从而使它对导入上述模块的其他模块公开可访问。
- en: So how does this connect to the previous statements? Any module system really
    allows us to maintain visibility in our project as it grows with us. The alternative
    is one file which is complete chaos. As for several developers working at the
    same time, any way of logically dividing up the app makes it easier to divide
    up the workstreams between developers.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这与前面的陈述有什么联系呢？任何模块系统实际上都允许我们在项目随着我们成长而增长时保持可见性。另一种选择是只有一个文件，那将是一团糟。对于同时工作的多个开发者来说，任何逻辑上划分应用的方法都会使开发者之间的工作流划分更容易。
- en: Consuming a module
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消费模块
- en: 'In ES2015, we use the `import` and `from` keywords to import one or several
    constructs like so:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES2015中，我们使用`import`和`from`关键字导入一个或多个结构，如下所示：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The imported file looks like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 导入的文件看起来是这样的：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The basic operations involved, working with ES2015 modules, can be summarized
    as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及的基本操作，使用ES2015模块，可以总结如下：
- en: Define a module and write the business logic of the module
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个模块并编写模块的业务逻辑
- en: Export the constructs you want to make public
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出你想要公开的结构
- en: Consume said module with an `import` keyword from a consumer file
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`import`关键字从消费者文件中导入该模块
- en: Of course there is a bit more to it than that, so let's look at what else you
    can do in the next subsection.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这不仅仅是那样，所以让我们在下一小节中看看你还能做什么。
- en: An Angular example
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个Angular示例
- en: 'We have been using ES2015 imports extensively throughout this chapter already,
    but let''s emphasize when that was. As mentioned, all constructs used ES2015 modules,
    models, services, components, and modules. For the module, this looked like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在本章中广泛使用了ES2015导入，但让我们强调一下那是何时。如前所述，所有结构都使用了ES2015模块、模型、服务、组件和模块。对于模块，它看起来是这样的：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here, we see that we import the functionality we need and we end up exporting
    this class, thereby making it available for other constructs to consume. It''s
    the same thing with modules, like so:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到我们导入了我们需要的功能，并最终导出这个类，使其可供其他结构消费。模块也是如此：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The pipe, directive, and filter all follow the same pattern of importing what
    they need and exporting themselves to be included as part of an `NgModule`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 管道、指令和过滤器都遵循相同的模式，导入它们需要的部分，并将自己导出以作为`NgModule`的一部分：
- en: Multiple exports
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多重导出
- en: 'So far, we have only shown how to export one construct. It is possible to export
    multiple things from one module by adding an `export` keyword next to all constructs
    that you wish to export, like so:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只展示了如何导出一个结构。通过在所有希望导出的结构旁边添加`export`关键字，从一个模块中导出多个东西是可能的，如下所示：
- en: '[PRE26]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Essentially, for everything you want to make public you need to add an `export`
    keyword at the start of it. There is an alternate syntax, where instead of adding
    an `export` keyword to every construct, we can instead define within curly brackets
    what constructs should be exported. It looks like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，对于你想要公开的每一件事，你都需要在它前面添加一个`export`关键字。还有一个替代语法，我们可以在大括号内定义应该导出哪些结构，而不是在每个结构前添加`export`关键字。它看起来像这样：
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Whether you put `export` in front of every construct or you place them all
    in an `export {}`, then end result is the same, it''s just a matter of taste which
    one to use. To consume constructs from this module, we would type:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是将`export`放在每个结构前面，还是将它们全部放在`export {}`中，最终结果都是相同的，只是使用哪种方式取决于个人喜好。要从这个模块中消费结构，我们就会输入：
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we have the option of specifying what we want to `import`. In the previous
    example, we have opted to export both `Math` and `PI`, but we could be content
    with only exporting `Math`, for example; it is up to us.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有选择指定我们想要`import`的内容。在先前的例子中，我们选择了导出`Math`和`PI`，但我们可以只满足于导出`Math`，例如；这取决于我们。
- en: The default import/export
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认导入/导出
- en: 'So far, we have been very explicit with what we import and what we export.
    We can, however, create a so-called default export, which looks somewhat different
    to consume:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经非常明确地说明了我们导入和导出了什么。然而，我们可以创建一个所谓的默认导出，它的消费方式略有不同：
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To consume this, we can write the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要消费这个，我们可以编写以下代码：
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note especially the first row where we no longer use the curly brackets, `{}`,
    to import a specific construct. We just use a name that we make up. In the second
    row, we have to name it correctly as `PI`, but in the first row we can choose
    the name. The player points to what we exported as default, that is, the `Player`
    class. As you can see, we can still use the normal curly brackets, `{}`, to import
    specific constructs if we want to.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意第一行，我们不再使用花括号`{}`来导入特定的构造函数。我们只需使用我们自己设定的名称。在第二行，我们必须正确地命名为`PI`，但在第一行我们可以选择名称。玩家指向的是我们默认导出的内容，即`Player`类。正如你所见，如果我们想的话，我们仍然可以使用正常的花括号`{}`来导入特定的构造函数。
- en: Renaming imports
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重命名导入
- en: 'Sometimes we may get a collision, with constructs being named the same. We
    could have this happening:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们可能会遇到冲突，构造函数被赋予相同的名称。这种情况可能发生：
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This is a situation we need to resolve. We can resolve it using the `as` keyword,
    like so:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要解决的问题。我们可以使用`as`关键字来解决这个问题，如下所示：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Thanks to the `as` keyword, the compiler now has no problem differentiating
    what is what.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了`as`关键字，编译器现在可以没有问题地区分不同的事物。
- en: The service
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 该服务
- en: 'We started this main section talking about how ES2015 modules are for all constructs
    in Angular. This section is about services, and services are no different when
    it comes to using ES2015 modules. Services we use should be declared in a separate
    file. If we intend to use a service, we need to import it. It needs to be imported
    for different reasons though, depending on what type of service it is. Services
    can be of two types:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在主部分开始时讨论了ES2015模块在Angular中适用于所有构造函数。本节是关于服务的，当使用ES2015模块时，服务并没有什么不同。我们使用的服务应该在单独的文件中声明。如果我们打算使用服务，我们需要导入它。不过，导入的原因取决于服务的类型。服务可以分为两种类型：
- en: Services without dependencies
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无依赖的服务
- en: Services with dependencies
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有依赖的服务
- en: Service without dependencies
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无依赖的服务
- en: 'A service without dependencies is a service whose constructor is empty:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 无依赖的服务是一个构造函数为空的服务：
- en: '[PRE33]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To use it, you simply type:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，你只需输入：
- en: '[PRE34]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Any module that consumes this service will get their own copy of the code,
    with this kind of code. If you, however, want consumers to share a common instance,
    you change the `service` module definition slightly to this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 任何消费此服务的模块都将获得自己的代码副本，这种代码。然而，如果你想让消费者共享一个公共实例，你只需稍微修改`service`模块的定义，如下所示：
- en: '[PRE35]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, we export an instance of the service rather than the service declaration.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们导出服务的一个实例而不是服务声明。
- en: Service with dependencies
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有依赖的服务
- en: 'A service with dependencies has dependencies in the constructor that we need
    help resolving. Without this resolution process, we can''t create the service.
    Such a service may look like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 带有依赖的服务在其构造函数中有依赖项，我们需要帮助解决这些依赖项。如果没有这个解决过程，我们无法创建服务。这样的服务可能看起来像这样：
- en: '[PRE36]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In this code, our service has two dependencies. Upon constructing a service,
    we need one `Logger` instance and one `Repository` instance. It would be entirely
    possible for us to find the `Logger` instance and `Repository` instance by typing
    something like this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们的服务有两个依赖项。在构建服务时，我们需要一个`Logger`实例和一个`Repository`实例。我们完全可以通过输入类似以下内容来找到`Logger`实例和`Repository`实例：
- en: '[PRE37]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is absolutely possible to do. However, the code is a bit tedious to write
    every time I want a service instance. When you start to have 100s of classes with
    deep object dependencies, a DI system quickly pays off.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝对是可以做到的。然而，每次我想获取服务实例时，编写代码都有些繁琐。当你开始有100多个具有深层对象依赖的类时，DI系统很快就会显示出其价值。
- en: 'This is one thing a Dependency Injection library helps you with, even if it
    is not the main motivator behind its existence. The main motivator for a DI system
    is to create loose coupling between different parts of the system and rely on
    contracts rather than concrete implementations. Take our example with the service.
    There are two things a DI can help us with:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是依赖注入库帮助你解决的一个问题，即使它不是其存在背后的主要动机。DI系统的主要动机是在系统的不同部分之间创建松散耦合，并依赖于契约而不是具体实现。以我们的服务为例。DI可以帮助我们做两件事：
- en: Switch out one concrete implementation for another
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用另一个具体实现替换一个
- en: Easily test our construct
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轻松测试我们的构造函数
- en: 'To show what I mean, let''s first assume `Logger` and `Repository` are interfaces.
    Interfaces may be implemented differently by different concrete classes, like
    so:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明我的意思，让我们首先假设`Logger`和`Repository`是接口。不同的具体类可能会以不同的方式实现接口，如下所示：
- en: '[PRE38]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This code shows how easy it is to switch out the implementation of `Logger`
    by just choosing `FileLogger` over `ConsoleLogger` or vice versa. The test case
    is also made a lot easier if you only rely on dependencies coming from the outside,
    so that everything can therefore be mocked.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示了如何通过选择`FileLogger`而不是`ConsoleLogger`或反之，轻松切换`Logger`的实现。如果只依赖外部提供的依赖项，测试用例也会变得简单得多，因此可以轻松地进行模拟。
- en: Dependency Injection
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入
- en: 'Essentially, when we ask for a construct instance, we want help constructing
    it. A DI system can act in one of two ways when asked to resolve an instance:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，当我们请求一个结构实例时，我们希望得到帮助来构建它。当请求解析一个实例时，DI系统可以以两种方式之一行事：
- en: '**Transient mode**: The dependency is always created anew'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**瞬态模式**：依赖关系始终被重新创建'
- en: '**Singleton mode**: The dependency is reused'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单例模式**：依赖关系被重用'
- en: Angular only creates singletons though which means every time we ask for a dependency
    it will only be created once and we will be given an already existing dependency
    if we are not the first construct to ask for that dependency.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Angular只创建单例，这意味着每次我们请求一个依赖项时，它只会被创建一次，如果我们不是第一个请求该依赖项的结构，我们将得到一个已经存在的依赖项。
- en: 'The default behavior of any DI framework is to use the default constructor
    on a class and create an instance from a class. If that class has dependencies,
    then it has to resolve those first. Imagine we have the following case:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 任何DI框架的默认行为都是使用类的默认构造函数，并从类中创建一个实例。如果该类有依赖项，那么它必须首先解决这些依赖项。想象一下以下情况：
- en: '[PRE39]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The DI framework would crawl the chain of dependencies, find the construct
    that does not have any dependencies, and instantiate that first. Then it would
    crawl upwards and finally resolve the construct you asked for. So with this code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: DI框架会遍历依赖链，找到没有任何依赖的结构，并首先实例化它。然后它会向上遍历，最终解决你请求的结构。所以用这段代码：
- en: '[PRE40]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The DI framework would:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: DI框架会：
- en: Instantiate the logger first
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先实例化日志记录器
- en: Instantiate the service second
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二次实例化服务
- en: Instantiate the component third
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三次实例化组件
- en: Dependency Injection in Angular using providers
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用提供者进行Angular依赖注入
- en: 'So far we have only discussed Dependency Injection in general, but Angular
    has some constructs, or decorators, to ensure that Dependency Injection does its
    job. First imagine a simple scenario, a service with no dependencies:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只讨论了依赖注入的一般概念，但Angular有一些结构或装饰器来确保依赖注入能够完成其工作。首先想象一个简单的场景，一个没有依赖的服务：
- en: '[PRE41]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If a component exists that requires an instance of the service, like so:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在一个需要服务实例的组件，如下所示：
- en: '[PRE42]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The Angular Dependency Injection system comes in and attempts to resolve it.
    Because the service has no dependencies, the solution is as simple as instantiating
    `Service`, and Angular does this for us. However, we need to tell Angular about
    this construct for the DI machinery to work. The thing that needs to know this
    is called a provider. Both Angular modules and components have access to a providers
    array that we can add the `Service` construct to. A word on this though. Since
    the arrival of Angular modules, the recommendation is to not use the providers
    array for components. The below paragraphs are merely there to inform you how
    providers for components work.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Angular依赖注入系统介入并尝试解析它。因为服务没有依赖项，解决方案就是简单地实例化`Service`，Angular为我们做这件事。然而，我们需要告诉Angular这个结构，以便DI机制能够工作。需要知道这个结构的东西被称为提供者。Angular模块和组件都可以访问一个提供者数组，我们可以将`Service`结构添加到其中。不过，关于这一点，自从Angular模块出现以来，建议不要为组件使用提供者数组。下面的段落只是为了告诉你组件的提供者是如何工作的。
- en: 'This will ensure that a `Service` instance is being created and injected at
    the right place, when asked for. Let''s tell an Angular module about a service
    construct:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保当请求`Service`实例时，它会在正确的位置创建和注入。让我们告诉Angular模块一个服务结构：
- en: '[PRE43]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This is usually enough to make it work. You can, however, register the `Service`
    construct with the `component` class instead. It looks identical:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常就足够让它工作了。然而，你可以将`Service`结构注册到`component`类中，它看起来是一样的：
- en: '[PRE44]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This has a different effect though. You will tell the DI machinery about this
    construct and it will be able to resolve it. There is a limitation, however. It
    will only be able to resolve it for this component and all its view child components.
    Some may see this as a way of limiting what components can see what services and
    therefore see it as a feature. Let me explain that by showing when the DI machinery
    can figure out our provided service:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这会有不同的效果。你会告诉DI机制这个构造函数，并且它将能够解析它。然而，有一个限制。它只能为这个组件及其所有视图子组件解析它。有些人可能会认为这是一种限制组件可以看到哪些服务的方法，因此将其视为一个特性。让我通过展示DI机制何时能够确定我们提供的服务来解释这一点：
- en: '**Everybody''s parent – it works**: Here, we can see that as long as the component
    highest up declares `Service` as a provider, all the following components are
    able to inject `Service`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**每个人的父母——它起作用了**：在这里，我们可以看到，只要最高层的组件将`Service`声明为提供者，所有后续的组件都能够注入`Service`：'
- en: '[PRE45]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s exemplify this with some code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些代码来举例说明：
- en: '[PRE46]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '**TodosComponent – will work for its children but not higher up**: Here, we
    provide Service one level down, to `TodosComponent`. This makes `Service` available
    to the child components of `TodosComponent` but `AppComponent`, its parent, misses
    out:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**TodosComponent——对其子组件有效但对其上级无效**：在这里，我们向下提供`Service`到`TodosComponent`。这使得`Service`对`TodosComponent`的子组件可用，但它的父组件`AppComponent`则无法访问：'
- en: '[PRE47]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let''s try to show this in code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试用代码来展示这一点：
- en: '[PRE48]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We can see here that adding our `Service` to a component''s `providers` array
    has limitations. Adding it to an Angular module is the sure way to ensure it can
    be resolved by all constructs residing inside of that array. This is not all though.
    Adding our `Service` to an Angular module''s providers array ensures it is accessible
    throughout our entire application. How is that possible, you ask? It has to do
    with the module system itself. Imagine we have the following Angular modules in
    our application:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里可以看到，将我们的`Service`添加到组件的`providers`数组中存在限制。将其添加到Angular模块中是确保它能够被该数组内所有构造函数解析的可靠方法。但这并非全部。将我们的`Service`添加到Angular模块的`providers`数组中确保它在整个应用程序中都是可访问的。你可能会问，这是如何实现的？这与模块系统本身有关。想象一下，在我们的应用程序中我们有以下Angular模块：
- en: '[PRE49]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'For it to be possible to use our `SharedModule`, we need to import it into
    `AppModule` by adding it to the `imports` array of `AppModule`, like so:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够使用我们的`SharedModule`，我们需要通过将其添加到`AppModule`的`imports`数组中来将其导入到`AppModule`中，如下所示：
- en: '[PRE50]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We know this has the effect of pulling all constructs from the `exports` array
    in `SharedModule`, but this will also concatenate the providers array from `SharedModule`
    to that of `AppModule`. Imagine `SharedModule` looking something like this:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道这会从`SharedModule`的`exports`数组中拉取所有构造函数，但这也会将`SharedModule`的提供者数组连接到`AppModule`的提供者数组上。想象一下`SharedModule`看起来可能像这样：
- en: '[PRE51]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'After the import has taken place, the combined providers array now contains:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入完成后，合并后的提供者数组现在包含：
- en: '`AppService`'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AppService`'
- en: '`SharedService`'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SharedService`'
- en: So the rule of thumb here is if you want to expose a service to your application,
    then put it in the Angular module's `providers` array. If you want to limit access
    to the service, then place it into a component's `providers` array. Then, you
    will ensure it can only be reached by that component and its view children.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里的经验法则是，如果你想将服务暴露给应用程序，那么请将其放入Angular模块的`providers`数组中。如果你想限制对服务的访问，那么请将其放入组件的`providers`数组中。然后，你将确保它只能被该组件及其视图子组件访问。
- en: Up next, let's talk about cases when you want to override the injection.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们谈谈当你想要覆盖注入时的情况。
- en: Overriding an existing construct
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 覆盖现有构造函数
- en: 'There are cases when you want to override the default resolution of your construct.
    You can do so at the module level, but also at the component level. What you do
    is simply express which construct you are overriding and with which other construct.
    It looks like this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你想要覆盖构造函数的默认解析。你可以在模块级别做这件事，也可以在组件级别做。你所做的就是简单地表达你正在覆盖哪个构造函数以及用哪个其他构造函数来覆盖。它看起来像这样：
- en: '[PRE52]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `provide` is our known construct and `useClass` is what it should point
    to instead. Let''s imagine we implemented our `Service` like so:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`provide`是我们已知的构造函数，而`useClass`是它应该指向的对象。让我们假设我们这样实现了我们的`Service`：'
- en: '[PRE53]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'And we added the following override to a component:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还向一个组件添加了以下覆盖：
- en: '[PRE54]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `FakeService` class has the following implementation:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`FakeService`类具有以下实现：'
- en: '[PRE55]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Now the component and all its view child components will always get `FakeService`
    when asking for the Service construct.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在组件及其所有视图子组件在请求服务构造函数时都将始终得到`FakeService`。
- en: Overriding at runtime
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行时覆盖
- en: 'There is a way to decide what to inject for/into a construct at runtime. So
    far, we have been very explicit about when to override, but we can do this with
    a bit of logic added to it by using the `useFactory` keyword. It works like the
    following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种方法可以在运行时决定为构造函数注入什么。到目前为止，我们一直非常明确地说明了何时覆盖，但我们可以通过添加一些逻辑并使用`useFactory`关键字来实现这一点。它的工作方式如下：
- en: '[PRE56]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This factory can in itself have dependencies; we specify those dependencies
    with the `deps` keyword like so:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工厂本身可能存在依赖；我们使用`deps`关键字来指定这些依赖，如下所示：
- en: '[PRE57]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Here, we highlighted the `condition` variable, which is a Boolean. There can
    be a ton of reasons why we would want to be able to switch the implementation.
    One good case is when the endpoint don't exist yet and we want to ensure it calls
    our `FakeService` instead. Another reason could be that we are in testing mode
    and by just changing this one variable we can make all our services rely on a
    fake version of themselves.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们突出了`condition`变量，它是一个布尔值。我们可能有无数的理由想要能够切换实现。一个很好的例子是当端点还不存在时，我们想要确保它调用我们的`FakeService`。另一个原因可能是我们处于测试模式，只需更改这个变量，我们就可以让所有服务都依赖于它们自己的假版本。
- en: Overriding constants
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 覆盖常量
- en: 'Not everything, though, is a class that needs to be resolved; sometimes it
    is a constant. For those cases, instead of using `useClass`, we can use `useValue`,
    like so:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有需要解析的东西都是类；有时它是一个常量。对于这些情况，我们不是使用`useClass`，而是可以使用`useValue`，如下所示：
- en: '[PRE58]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This is not really a class type, so you can''t write this in a constructor:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上不是一个类类型，所以您不能在构造函数中这样写：
- en: '[PRE59]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'That wouldn''t compile. What we can do instead is to use the `@Inject` decorator
    in the following way:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这样是无法编译的。我们可以做的是使用以下方式使用`@Inject`装饰器：
- en: '[PRE60]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The `useValue` is no different from `useClass` when it comes to how to override
    it. The difference is of course that we need to type `useValue` in our instruction
    to override rather than `useClass`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`useValue`在如何覆盖方面与`useClass`没有区别。当然，区别在于我们需要在我们的指令中键入`useValue`而不是`useClass`。'
- en: Resolving your dependencies with @Injectable
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用@Injectable解析依赖
- en: 'We took a little deep dive into DI in the previous section, but almost forgot
    about a very important decorator, `@Injectable`. `@Injectable` is not strictly
    mandatory to use for services in general. However, if that service has dependencies,
    then it needs to be used. Failure to decorate a service with `@Injectable` that
    has dependencies leads to an error where the compiler complains that it doesn''t
    know how to construct the mentioned service. Let''s look at a case where we need
    to use the `@Injectable` decorator:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们对依赖注入（DI）进行了一些深入探讨，但几乎忘记了一个非常重要的装饰器`@Injectable`。`@Injectable`对于一般的服务来说并不是强制使用的。然而，如果该服务有依赖项，那么它就需要使用。未能用`@Injectable`装饰具有依赖项的服务会导致编译错误，编译器会抱怨它不知道如何构造提到的服务。让我们看看我们需要使用`@Injectable`装饰器的一个案例：
- en: '[PRE61]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In this case, Angular''s DI machinery will look up `Logger` and inject it into
    the `Service` constructor. So, providing we have done this:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Angular的DI机制将查找`Logger`并将其注入到`Service`构造函数中。所以，只要我们做了以下操作：
- en: '[PRE62]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In a component or module, it should work. Remember, when in doubt, add `@Injectable`
    to your service if it has dependencies in the constructor or will have in the
    near future. If your service lacks the `@Injectable` keyword and you try to inject
    it into a component's constructor, then it will throw an error and your component
    will not be created.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件或模块中，它应该可以工作。记住，当不确定时，如果服务在构造函数中有依赖项或将在不久的将来有依赖项，请将`@Injectable`添加到您的服务中。如果您的服务缺少`@Injectable`关键字，并且您尝试将其注入到组件的构造函数中，那么它将抛出错误，并且您的组件将不会被创建。
- en: This section set out to explain how DI works from a general standpoint and how
    it works in Angular. For the latter, it covered how to register constructs to
    work with Angular's DI machinery, but also how to override it. It is clear that
    the DI machinery is quite sophisticated. It can be scoped to the application level,
    by adding constructs to the providers array of Angular modules, but also to the
    component level and its view children. The main reason for describing the DI machinery
    was to teach you the possibilities of it, so you know how to best use it to your
    advantage when you define the architecture of your app.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 本节旨在从一般角度解释DI（依赖注入）的工作原理，以及在Angular中的具体应用。对于后者，它涵盖了如何将构造函数注册到Angular的DI机制中，以及如何覆盖它。很明显，DI机制相当复杂。它可以通过向Angular模块的提供者数组添加构造函数来应用于应用级别，也可以应用于组件级别及其视图子组件。描述DI机制的主要原因是为了向您展示其可能性，这样您在定义应用程序架构时就能知道如何最好地利用它。
- en: Fetching and persisting data with HTTP – introducing services with Observables
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HTTP获取和持久化数据——介绍使用Observables的服务
- en: So far, we have gone through a data flow where the component is our view to
    the outside world, but also the controller. The component uses a service to get
    the data, but also to persist it. The data, however, has up until this point lived
    in the service and that's not a very likely place for it to reside. Almost certainly,
    that data should be fetched and persisted to an endpoint. That endpoint is an
    exposed URL to a backend system published somewhere on the internet. We can use
    HTTP to reach said endpoint. Angular has created a wrapper on top of the vanilla
    way of fetching data through HTTP. The wrapper is a class that wraps the functionality
    of an object called `XmlHttpRequest`. The Angular wrapper class is called the
    `HttpClient` service.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经经历了一个数据流，其中组件是我们的对外视图，同时也是控制器。组件使用服务来获取数据，也用来持久化数据。然而，直到这一点，数据一直生活在服务中，这并不是一个很合适的数据存放位置。几乎可以肯定，这些数据应该被获取并持久化到端点上。这个端点是一个暴露在互联网上某个地方的后端系统的URL。我们可以使用HTTP来访问这个端点。Angular在原始通过HTTP获取数据的方式之上创建了一个包装器。这个包装器是一个类，它封装了一个名为`XmlHttpRequest`的对象的功能。Angular的包装器类被称为`HttpClient`服务。
- en: Fetching data with the HTTP service
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HTTP服务获取数据
- en: 'There is more than one way to communicate over HTTP. One way is using the `XmlHttpRequest`
    object, but that is a quite cumbersome and low-level way of doing it. Another
    way is to use the new fetch API, which you can read more about here: [https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 通过HTTP进行通信的方式不止一种。一种方式是使用`XmlHttpRequest`对象，但这是一种相当繁琐且低级的方法。另一种方式是使用新的fetch
    API，您可以在以下链接中了解更多信息：[https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)。
- en: 'Angular has its own abstraction, the HTTP service, which can be found in the
    `HTTPModule`. To use it, simply import the `HttpModule`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Angular有自己的抽象层，即HTTP服务，它可以在`HTTPModule`中找到。要使用它，只需导入`HttpModule`：
- en: '[PRE63]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Then, inject the `HttpClient` service where you want to use it, like so:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将`HttpClient`服务注入到您想要使用它的地方，如下所示：
- en: '[PRE64]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'At this point, we are ready to use it. Let''s see a quick overview of what
    methods this HTTP service has:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经准备好使用它了。让我们快速了解一下这个HTTP服务有哪些方法：
- en: '`get(''url'', <optional options param>)` fetches the data for us'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get(''url'', <可选的options参数>)`为我们获取数据'
- en: '`post(''url'', payload,<optional options param>)` creates a resource'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`post(''url'', payload,<可选的options参数>)`创建资源'
- en: '`put(''url'', payload,<optional options param>)` updates a resource'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`put(''url'', payload,<可选的options参数>)`更新资源'
- en: '`delete(''url'',<optional options param>)` removes a resource'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete(''url'',<可选的options参数>)`删除资源'
- en: '`request` is a raw request where you can configure exactly what call you want
    to make, what headers you want to add, and so on'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`request`是一个原始请求，您可以根据需要配置要进行的调用、要添加的标头等。'
- en: When we use `http.get()` we get a construct back called an Observable. An Observable
    is just like the `Promise`, an asynchronous concept that enables us to attach
    callbacks to when the data arrives some time in the future, as well as attaching
    callbacks to an error when an error occurs. The RxJS implementation of the Observable
    comes packed with a number of operators that help us transform the data and interact
    with other Observables. One such operator is called `toPromise()` and enables
    us to convert an Observable to a Promise. With this, we can make HTTP calls in
    two different ways, or flavors. The first way is where we use the `toPromise()`
    operator and convert our `Observable` to a `Promise`, and the other is using our
    Observable and dealing with the data that way.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`http.get()`时，我们得到一个称为Observable的结构。Observable就像`Promise`一样，是一个异步概念，它使我们能够将回调附加到未来某个时间数据到达时，以及将回调附加到发生错误时。RxJS对Observable的实现包含了许多操作符，帮助我们转换数据并与其他Observable交互。其中一个操作符叫做`toPromise()`，它使我们能够将Observable转换为Promise。有了这个，我们可以以两种不同的方式，或者说两种风味进行HTTP调用。第一种方式是我们使用`toPromise()`操作符将我们的`Observable`转换为`Promise`，另一种方式是使用我们的Observable并以此方式处理数据。
- en: 'A typical call comes in two different flavors:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的调用有两种不同的风味：
- en: '**Using promises**'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用Promise**'
- en: '[PRE65]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This version feels familiar. If you need to brush up on Promises, have a look
    at the following link before continuing: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).
    We recognize the `.then()` method as the method that is called when the data arrives
    and the `.catch()` method that is called when something goes wrong with our request.
    This is what we expect when, dealing with promises.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本感觉熟悉。如果你需要复习一下Promise，在继续之前，请查看以下链接：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)。我们认识到`.then()`方法是在数据到达时被调用的方法，而`.catch()`方法是在我们的请求出现问题时被调用的方法。这就是我们在处理Promise时的期望。
- en: '**Using RxJS**'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用RxJS**'
- en: '[PRE66]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The second version looks different. Here, we are using the `.map()` method
    in much the same way as we used the `.then()` method. This statement needs some
    explanation. Let''s have a look at the promise flavor code one more time and highlight
    what we are saying:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个版本看起来不同。在这里，我们使用`.map()`方法的方式与使用`.then()`方法的方式非常相似。这个声明需要一些解释。让我们再次查看Promise风格的代码，并突出我们所说的话：
- en: '[PRE67]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The highlighted portion is the method that is called when the data first arrives
    from the service. What we do inside of this call is to create a projection of
    the data, like so:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的部分是在数据首次从服务到达时被调用的方法。我们在这次调用中做的事情是创建数据的投影，如下所示：
- en: '[PRE68]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The subsequent call to `then()` just deals with printing the data to the console:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 后续的`then()`调用仅处理将数据打印到控制台：
- en: '[PRE69]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Let''s now have a look at how the RxJS version differs by highlighting the
    projection part and the part where we print out our result:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看RxJS版本的不同之处，突出显示投影部分和打印结果的部分：
- en: '[PRE70]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The first line of our highlighted portion of the code indicates our projection:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们突出显示的代码的第一行表明了我们的投影：
- en: '[PRE71]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The call to subscribe is where we print our data, like so:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅的调用是我们打印数据的地方，如下所示：
- en: '[PRE72]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: When we use `http.get()`, we get a construct back called an Observable. An Observable
    is just like the Promise, an asynchronous concept that enables us to attach callbacks
    to when the data arrives some time in the future, as well as attaching callbacks
    to when an error happens.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`http.get()`时，我们得到一个称为Observable的结构。Observable就像Promise一样，是一个异步概念，它使我们能够将回调附加到未来某个时间数据到达时，以及将回调附加到发生错误时。
- en: The Observable is part of a library called RxJS and this is what is powering
    the `HttpClient` service. It is a powerful library meant for more than just a
    simple request/response pattern. We will spend future chapters exploring the RxJS
    library further and discover what a powerful paradigm the Observable really is,
    what other important concepts it brings, and the fact that it isn't really only
    about working with HTTP anymore, but all async concepts.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: Observable是RxJS库的一部分，这是在`HttpClient`服务中提供动力的。这是一个强大的库，不仅用于简单的请求/响应模式。我们将在未来的章节中进一步探索RxJS库，并发现Observable实际上是一个多么强大的范式，它带来了哪些其他重要概念，以及它不仅仅关于HTTP工作的事实，而是所有异步概念。
- en: Summary
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started this chapter by trying to explain how important it was to get a good
    foundation in application architecture in general, and for that reason we had
    a look at the MVC pattern. We then continued describing how the MVC pattern was
    somewhat used in Angular, even though it was called MVW, model view whatever.
    We did this to understand that the Angular framework consists of a lot of constructs
    that help us organize our application in a way that makes it easy to extend, maintain,
    and parallelize the work.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以尝试解释在应用架构方面打下良好基础的重要性开始本章，因此我们研究了MVC模式。然后我们继续描述MVC模式在Angular中的应用，尽管它被称为MVW，模型视图随意。我们这样做是为了理解Angular框架由许多帮助我们以易于扩展、维护和并行化工作的方式组织应用程序的结构组成。
- en: Angular brought a lot of new things to it though, such as ES2015 modules, which
    attempted to solve the problem of how to split up the code in a manageable way.
    After that, we argued that although ES2015 modules were great, there was a lot
    of ceremony attached to them when it came to creating complex objects. To help
    relieve us of that ceremony, we described how Angular Dependency Injection could
    be the solution to said problem. In reality, you will use ES2015 to import your
    constructs. What Angular DI helps us with is creating the dependencies needed
    for our constructs.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Angular带来了许多新事物，例如ES2015模块，它试图以可管理的方式解决如何分割代码的问题。之后，我们争论尽管ES2015模块很棒，但在创建复杂对象时，它们附带了很多仪式。为了帮助我们摆脱这种仪式，我们描述了Angular依赖注入如何成为解决该问题的方案。实际上，您将使用ES2015导入您的结构。Angular
    DI帮助我们的是创建我们结构所需的依赖项。
- en: Lastly, we tied the knot of explaining the MVC pattern by simply stating that
    data doesn't really live permanently, in either the model, the controller, or
    the view, but can be retrieved and persisted by talking to an endpoint, reachable
    through HTTP. We concluded the chapter by describing how the Angular 4.x HTTP
    service can help us with just that.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过简单地说数据实际上并不永久地存在于模型、控制器或视图中，而是可以通过与一个可通过HTTP访问的端点进行交互来检索和持久化，从而结束了MVC模式的解释。我们通过描述Angular
    4.x HTTP服务如何帮助我们做到这一点来结束本章。
- en: 'All of this is interesting from an educational standpoint. It doesn''t describe
    the elephant in the room, how do we manage our data when things gets complicated?
    The concerns we have to deal with are:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些从教育角度来看都很有趣。它没有描述房间里的大象，当事情变得复杂时我们如何管理我们的数据？我们必须处理的担忧是：
- en: Bidirectional data flow
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双向数据流
- en: Lack of predictability (a change can lead to cascading changes)
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺乏可预测性（一个变化可能导致级联变化）
- en: Spread out state (there is no one source of truth and our components can sit
    on a state that is partially updated)
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态分散（没有单一的真实来源，并且我们的组件可以位于部分更新的状态上）
- en: Let's keep these concerns in mind as we move on to [Chapter 2](81d377c1-aafe-4eff-a7cd-a1b64629454c.xhtml),
    *1.21 Gigawatt – The Flux Pattern Explained*.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续进入[第二章](81d377c1-aafe-4eff-a7cd-a1b64629454c.xhtml)，*1.21 吉瓦特 – 流量模式解释*时，让我们牢记这些担忧。
