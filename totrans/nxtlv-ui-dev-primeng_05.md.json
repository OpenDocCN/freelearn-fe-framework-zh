["```js\nimport { CommonModule } from '@angular/common'\nimport { Component } from '@angular/core'\nimport { FormsModule, NgForm } from '@angular/forms'\n@Component({\n   standalone: true,\n   imports: [CommonModule, FormsModule],\n   template: `\n      <h2>Template Driven Form</h2>\n      <form #form=\"ngForm\" (ngSubmit)=\"onSubmit(form)\" novalidate>\n         <input name=\"first\" ngModel required />\n         <button>Submit</button>\n      </form>\n      <p>Value: {{ form.value | json }}</p>\n   `\n})\nexport default class TemplateDrivenComponent {\n   onSubmit(form: NgForm) {\n      console.log(form.value) // { first: '' }\n   }\n}\n```", "```js\nimport { CommonModule } from '@angular/common'\nimport { Component } from '@angular/core'\nimport { FormControl, FormGroup, ReactiveFormsModule } from '@angular/forms'\n@Component({\n   standalone: true,\n   imports: [CommonModule, ReactiveFormsModule],\n   template: `\n      <h2>Reactive Forms</h2>\n      <form [formGroup]=\"profileForm\" (ngSubmit)=\"onSubmit()\">\n         <input type=\"text\" formControlName=\"first\" />\n         <button type=\"submit\">Submit</button>\n      </form>\n      <p>Value: {{ profileForm.value | json }}</p>\n   `\n})\nexport default class ReactiveFormsComponent {\n   profileForm = new FormGroup({\n      first: new FormControl(''),\n   })\n   onSubmit() {\n      console.log(this.profileForm.value) // { first: '' }\n   }\n}\n```", "```js\nimport { ButtonModule } from 'primeng/button'\nimport { InputTextModule } from 'primeng/inputtext'\n@Component({\n   standalone: true,\n   imports: [CommonModule, ReactiveFormsModule, ButtonModule, InputTextModule],\n   template: `\n      <h2>PrimeNg Reactive Forms</h2>\n      <form [formGroup]=\"profileForm\" (ngSubmit)=\"onSubmit()\">\n         <input pInputText formControlName=\"first\" />\n         <button pButton type=\"submit\">Submit</button>\n      </form>\n      <p>Value: {{ profileForm.value | json }}</p>\n   `,\n})\n```", "```js\nimport { InputTextModule } from 'primeng/inputtext'\n```", "```js\n<label for=\"name\">Name</label>\n<input pInputText id=\"name\" type=\"text\" formControlName=\"name\" />\n```", "```js\nimport { InputMaskModule } from 'primeng/inputmask'\n```", "```js\n<label for=\"phone\">Phone</label>\n<p-inputMask\n   id=\"phone\"\n   mask=\"(999)-999-9999\"\n   formControlName=\"phone\"\n   placeholder=\"(999)-999-9999\"\n/>\n```", "```js\nimport { CheckboxModule } from 'primeng/checkbox'\n```", "```js\n<p-checkbox\n   formControlName=\"subscribe\"\n   [binary]=\"true\"\n   label=\"Subscribe to newsletter\"\n/>\n```", "```js\nimport { RadioButtonModule } from 'primeng/radiobutton'\n```", "```js\n<p-radioButton\n   ngFor=\"let gender of genders\"\n   name=\"gender\"\n   value=\"{{ gender.value }}\"\n   label=\"{{ gender.name }}\"\n   formControlName=\"gender\"\n/>\n```", "```js\nimport { DropdownModule } from 'primeng/dropdown'\n```", "```js\n<p-dropdown\n      [options]=\"cities\"\n      ngModel\n      optionLabel=\"name\"\n      name=\"city\"\n/>\n```", "```js\n<p-dropdown\n   [options]=\"cities\"\n   ngModel\n   optionLabel=\"name\"\n   name=\"cityWithFilter\"\n   [filter]=\"true\"\n/>\n```", "```js\ngroupedCities = [\n   {\n      label: 'Canada',\n      value: 'ca',\n      items: [\n         { label: 'Vancouver', value: 'Vancouver' },\n         { label: 'Toronto', value: 'Toronto' },\n         { label: 'Montreal', value: 'Montreal' },\n         { label: 'Ottawa', value: 'Ottawa' },\n      ],\n   },\n   ...\n]\n...\n<p-dropdown\n   [options]=\"groupedCities\"\n   ngModel\n   name=\"cityWithGroup\"\n   placeholder=\"Select a City\"\n   [group]=\"true\"\n>\n   <ng-template let-group pTemplate=\"group\">\n      <div>\n         <span class=\"pi pi-map-marker\"></span>\n         <span>{{ group.label }}</span>\n      </div>\n   </ng-template>\n</p-dropdown>\n```", "```js\n<p-dropdown\n   [options]=\"cities\"\n   ngModel\n   optionLabel=\"name\"\n   name=\"cityWithTemplate\"\n   [showClear]=\"true\"\n   placeholder=\"Select a City\"\n>\n   <ng-template pTemplate=\"selectedItem\">\n      <div *ngIf=\"form.value.cityWithTemplate\">\n         <span class=\"pi pi-map-marker\"></span>\n         <span>{{ form.value.cityWithTemplate.name }}</span>\n      </div>\n   </ng-template>\n   <ng-template let-city pTemplate=\"item\">\n      <div>\n         <span class=\"pi pi-map-marker\"></span>\n         <span>{{ city.name }}</span>\n      </div>\n   </ng-template>\n</p-dropdown>\n```", "```js\n<p-dropdown\n   [options]=\"cities\"\n   ngModel\n   optionLabel=\"name\"\n   (onChange)=\"onCityChange($event.value)\"\n   name=\"cityWithEvents\"\n/>\n...\nonCityChange(value: { name: string; code: string }) {\n   alert(`You have selected: ${value.name}`)\n}\n```", "```js\nimport { MultiSelectModule } from 'primeng/multiselect'\n```", "```js\ncities = [\n   { name: 'Toronto', code: 'TOR' },\n   { name: 'Montreal', code: 'MTL' },\n   { name: 'Vancouver', code: 'VAN' },\n   { name: 'Calgary', code: 'CGY' },\n   { name: 'Ottawa', code: 'OTT' },\n   { name: 'Edmonton', code: 'EDM' },\n   { name: 'Quebec City', code: 'QUE' },\n   { name: 'Winnipeg', code: 'WIN' },\n   { name: 'Hamilton', code: 'HAM' },\n   { name: 'Kitchener', code: 'KIT' },\n]\n...\n<p-multiSelect\n   [options]=\"cities\"\n   ngModel\n   optionLabel=\"name\"\n   name=\"city\"\n/>\n```", "```js\n<p-multiSelect [options]=\"cities\" filter attribute to true, you enable the filtering feature. Now, when a user clicks on the MultiSelect box, they will see a search box at the top of the dropdown list.\n\t\t\tGrouping\n\t\t\tFor better organization of options, the `MultiSelect` component also supports grouping. We can group options under certain categories by using the `[``group]` attribute:\n\n```", "```js\n\n\t\t\tIn this example, the cities are grouped according to a property specified in the `groupedCities` array. The code `ng-template let-group pTemplate=\"group\"` defines a template for the group header with a map maker icon on the left. Let’s have a look at the result:\n\t\t\t![Figure 5.9 – Sample MultiSelect with grouping](img/B18805_05_09.jpg)\n\n\t\t\tFigure 5.9 – Sample MultiSelect with grouping\n\t\t\tTemplating\n\t\t\tThe `MultiSelect` component also supports templating, which allows you to customize the appearance of the options in the dropdown list and the selected items:\n\n```", "```js\n\n\t\t\tIn this code snippet, we use the `ng-template` element to define a template for the items in the selection list. The `let-cities` attribute in `<ng-template let-cities pTemplate=\"selectedItems\">` creates a local variable called `cities` that holds the current selected cities. The `<ng-template let-city pTemplate=\"item\">` attribute tells PrimeNG to use this template for the items in the dropdown list.\n\t\t\tNote\n\t\t\tWhen checking the PrimeNG documentation, under the `MultiSelect` component, you can find the complete list here: [https://primeng.org/multiselect#api.multiselect.templates](https://primeng.org/multiselect#api.multiselect.templates).\n\t\t\tThe PrimeNG `MultiSelect` component is a versatile tool that can enhance the user experience of your forms. In the next section, we will look into the `Calendar` component.\n\t\t\tCalendar\n\t\t\tPrimeNG **Calendar** is a date picker component that allows users to select dates, times, or both. It’s highly customizable, supporting various formats and modes such as inline, button, icon, and input styles.\n\t\t\tTo get started with the PrimeNG `Calendar` component, first import `CalendarModule` in your component:\n\n```", "```js\n\n\t\t\tPrimeNG provides the `p-calendar` component for creating date pickers. Here’s a basic example:\n\n```", "```js\n\n\t\t\tIn this example, `name=\"calendar\"` is a form control in your form and will hold the selected date:\n\t\t\t![Figure 5.10 – Sample calendar](img/B18805_05_10.jpg)\n\n\t\t\tFigure 5.10 – Sample calendar\n\t\t\tThe PrimeNG Calendar component isn’t just a simple date picker. It has a wealth of advanced features that can cater to almost any requirement you might have.\n\t\t\tFormat\n\t\t\tThe selected date has the default format of `dd/mm/yyyy`. However, you can update the format of the selected date by using the `dateFormat` property. Here is the list of the available options for `dateFormat`:\n\n\t\t\t\t*   `d`: Day of month (no leading zero).\n\t\t\t\t*   `dd`: Day of month (two digits).\n\t\t\t\t*   `o`: Day of the year (no leading zeros).\n\t\t\t\t*   `oo`: Day of the year (three digits).\n\t\t\t\t*   `D`: Day name, short.\n\t\t\t\t*   `DD`: Day name, long.\n\t\t\t\t*   `m`: Month of year (no leading zero).\n\t\t\t\t*   `mm`: Month of year (two digits).\n\t\t\t\t*   `M`: Month name, short.\n\t\t\t\t*   `MM`: Month name, long.\n\t\t\t\t*   `y`: Year (two digits).\n\t\t\t\t*   `yy`: Year (four digits).\n\t\t\t\t*   `@`: Unix timestamp (milliseconds (ms) – since 01/01/1970).\n\t\t\t\t*   `!`: Windows ticks (100ns (nanoseconds) – since 01/01/0001).\n\t\t\t\t*   `'...'`: Literal text allows you to insert any text as it is in the date string. For example, `'Day: 'dd 'Month: 'MM 'Year: 'yy` will turn into `Day: 08 Month: August` `Year: 2023`.\n\t\t\t\t*   `''`: If you want to display a single quote within your date string, you must use two single quotes together, for example, `'Today''s date is 'dd/MM/yy` will turn into `Today's date` `is 08/August/2023`.\n\t\t\t\t*   Any other characters that are not recognized as part of the date format pattern will be treated as literal text and will be displayed as is. For example, if you use the format string `dd+MM+yy`, a date might display as `16+August+2023`.\n\n\t\t\tHere is an example of changing the format of the selected date:\n\n```", "```js\n\n\t\t\tIn this example, `dateFormat=\"dd-mm-yy\"` indicates the new format of the selected date. Here is the result:\n\n\t\t\t![Figure 5.11 – Sample calendar](img/B18805_05_11.jpg)\n\n\t\t\tFigure 5.11 – Sample calendar\n\t\t\tAfter selecting the date, you can see the format of the selected date changes to `13-07-2023`.\n\t\t\tRange selection\n\t\t\tTo enable range selection in the PrimeNG Calendar component, you can use the `selectionMode` attribute along with the `ngModel` directive. The `selectionMode` attribute allows you to specify the mode of selection, including `\"single\"`, `\"multiple\"`, and `\"range\"`. Here’s how you can enable range selection:\n\n```", "```js\n\n\t\t\tHere, `calendarDateRange` is an array that will hold the start and end dates of the selected range.\n\t\t\t![Figure 5.12 – Sample calendar with date range](img/B18805_05_12.jpg)\n\n\t\t\tFigure 5.12 – Sample calendar with date range\n\t\t\tPrimeNG Calendar is a powerful, flexible, and customizable date picker component for Angular applications. It also offers extensive customization options, allowing you to tailor its appearance and behavior to your needs.\n\t\t\tNote\n\t\t\tIn this section, we’ve only scratched the surface of what the PrimeNG `Calendar` can do. We encourage you to explore its documentation to learn more about its features and capabilities: [https://primeng.org/calendar](https://primeng.org/calendar).\n\t\t\tIn this section, we went through some important input components. In the next section, let’s go through validation and input handling techniques.\n\t\t\tImplementing form validation\n\t\t\tAs we venture deeper into the realm of form controls, we come across a critical aspect of any form—**validation**. Ensuring the data entered by users is valid and as expected is paramount to maintaining data integrity and providing a seamless user experience. It’s not just about checking whether a field is empty or not; it’s about ensuring the data is in the right format, within certain limits, or meets any other criteria you set. In this section, we’ll explore how to implement form validation using Angular and PrimeNG.\n\t\t\tUnderstanding Angular form states\n\t\t\tBefore diving into the details of Angular form validation, let’s first discuss some important concepts related to form validation. In Angular, a form is represented by the `FormGroup` class, which contains an organized collection of form controls such as input fields, checkboxes, and dropdowns.\n\t\t\tAngular form validation revolves around the state of the form controls. There are several states that a form control can have:\n\n\t\t\t\t*   `pristine`: A form control is considered pristine if the user hasn’t interacted with it yet. It means that the control’s value has not been changed since it was initialized.\n\t\t\t\t*   `dirty`: A form control becomes dirty once the user interacts with it and modifies its value.\n\t\t\t\t*   `touched`: A form control is marked as touched when the user focuses on it and then moves away, indicating that they have interacted with the control.\n\t\t\t\t*   `untouched`: The opposite of touched, an untouched form control means that the user hasn’t interacted with it yet. The difference between `pristine` and `untouched` is that `untouched` refers to a form control that has not been interacted with by the user, while `pristine` indicates a form control that has not been modified.\n\t\t\t\t*   `valid`: A form control is considered valid if it satisfies all the validation rules defined for it.\n\t\t\t\t*   `invalid`: If a form control fails to satisfy any of the validation rules, it is marked as invalid.\n\n\t\t\tThese states play a crucial role in form validation, as they help determine the visual feedback to provide to the user and enable or disable form submission based on the validity of the form controls.\n\t\t\tBuilt-in Angular form validation\n\t\t\tAngular provides a set of built-in validators that cover common form validation scenarios. These validators can be used on form controls to ensure that the user input meets specific requirements. Here are a few examples:\n\n\t\t\t\t*   `required`: The `required` validator ensures that a form control has a non-empty value\n\t\t\t\t*   `minLength` and m`axLength`: These validators validate the minimum and maximum length of a form control’s value, respectively\n\t\t\t\t*   `pattern`: The `pattern` validator allows you to specify a regular expression pattern that the form control’s value must match\n\n\t\t\tTo apply these validators to a form control, you need to associate them with the control in the component code. For example, if you have an input field for the user’s name that must be filled in and has a minimum length of four characters, you can define the form with validators like this (in a template-driven form):\n\n```", "```js\n\n\t\t\tLet’s break down the example:\n\n\t\t\t\t*   `required`: This indicates that the input must have a value before the form can be submitted.\n\t\t\t\t*   `minlength=\"4\"`: This specifies that the input value must be at least four characters long.\n\t\t\t\t*   `#name=\"ngModel\"`: This creates a local template variable called `name`. This allows us to access the properties and methods of the `NgModel` directive within the template.\n\t\t\t\t*   `*ngIf=\"name.invalid && (name.dirty || name.touched)\"`: The `*ngIf` directive checks if the input is invalid (`name.invalid`) and if the input has been interacted with (`name.dirty` or `name.touched`). If both conditions are true, the content inside `<ng-container>` will be displayed.\n\t\t\t\t*   `*ngIf=\"name.errors?.['required']\"`: This displays an error message if the input is missing a value (because of the `required` attribute).\n\t\t\t\t*   `*ngIf=\"name.errors?.['minlength']\"`: This displays an error message if the input value is less than four characters long (because of the `minlength=\"4\"` attribute).\n\n\t\t\tNow let’s look at validators in reactive forms:\n\n```", "```js\n\n\t\t\tLet’s break down the code:\n\n\t\t\t\t*   `name: ['', [Validators.required, Validators.minLength(4)]]`: This initializes a form control called `name` with an empty string as its default value. The array that follows specifies the validation rules for this control:\n    *   `Validators.required`: This validator ensures that the control has a non-empty value\n    *   `Validators.minLength(4)`: This validator ensures that the control’s value is at least four characters long\n\t\t\t\t*   `*ngIf=\"contactForm.controls.name as name\"`: This checks if the name control exists in `contactForm` and assigns it to a local template variable, `name`\n\t\t\t\t*   `*ngIf=\"name.dirty && name.hasError('required'):` This displays an error message if the `name` control has been interacted with (`name.dirty`) and if it’s missing a value (`name.hasError('required')`)\n\t\t\t\t*   `*ngIf=\"name.dirty && name.hasError('minlength')\"`: This displays an error message if the `name` control has been interacted with and if its value is less than four characters long\n\n\t\t\tBased on the logic just explained, we can create the entire form with proper validation. *Figure 5**.13* shows a contact form with an invalid state:\n\t\t\t![Figure 5.13 – Sample form validation](img/B18805_05_13.jpg)\n\n\t\t\tFigure 5.13 – Sample form validation\n\t\t\tAs we can see, the error state indicates that the form requires all of the fields to be filled out before the information can be submitted.\n\t\t\tCrafting custom form validation\n\t\t\tWhile Angular provides a range of built-in validators, there are times when we need to add something specific to our application. Thankfully, Angular allows us to create custom form validators.\n\t\t\tHere’s a simple example of creating a custom validator that checks whether the name is invalid or not:\n\n```", "```js\n\n\t\t\tIn the code example, the main function, `invalidNameValidator`, takes a regular expression (`nameRe`) as its argument and returns a custom validator function. This custom validator function checks whether a form control’s value matches the provided regular expression. If the value doesn’t match the pattern, meaning that it’s valid, the function returns `null`, indicating that there are no validation errors.\n\t\t\tNote\n\t\t\tCustom validators return a key-value pair if the validation fails. The key is a string of your choosing that describes the error, and the value is the value of the control.\n\t\t\tTo use this validator, we just need to add it to the existing validators:\n\n```", "```js\n\n\t\t\tHere is the code breakdown:\n\n\t\t\t\t*   `invalidNameValidator(/test/i)`: This is a custom validator (as we discussed in the previous section). It checks whether the form control’s value matches the regular expression `/test/i`. If the value matches, the validator will flag it as invalid.\n\t\t\t\t*   `*ngIf=\"name.dirty && name.hasError('invalidName')\"`: This displays an error message if the `name` control has been interacted with and if the name is invalid.\n\n\t\t\tLet’s look at the result:\n\t\t\t![Figure 5.14 – Custom form validation](img/B18805_05_14.jpg)\n\n\t\t\tFigure 5.14 – Custom form validation\n\t\t\tPrimeNG and form validation\n\t\t\tPrimeNG complements Angular’s form validation by providing visual feedback for validation errors. It includes a variety of CSS classes that can be used to highlight invalid fields and display error messages.\n\t\t\tHere’s an example of how to use PrimeNG to display validation errors:\n\n```", "```js\n\n\t\t\tIn this example, if the `name` field is invalid and `dirty`, the `p-error` class is added to the field, and the error message is displayed.\n\t\t\tForm validation is a critical aspect of any application that involves user input. It helps ensure data integrity and enhances the user experience. Angular provides robust support for form validation, and PrimeNG complements this by providing visual feedback for validation errors.\n\t\t\tIn this section, we’ve explored how to implement form validation using Angular and PrimeNG. However, this is just the tip of the iceberg. Both Angular and PrimeNG offer a wealth of features for form validation that can cater to almost any requirement We encourage you to explore Angular documentation to learn more: [https://angular.io/guide/form-validation](https://angular.io/guide/form-validation)\n\t\t\tSummary\n\t\t\tIn this chapter, we delved into the world of input components and form controls, exploring their usage in Angular applications with PrimeNG. We started by understanding their importance in building interactive applications, setting the foundation for the practical aspects that followed.\n\t\t\tWe then navigated through the implementation of basic form controls such as text inputs, checkboxes, and radio buttons, and moved on to more complex ones such as dropdowns, multi-selects, and date pickers. Each section was enriched with code examples, demonstrating the integration of these components into our applications.\n\t\t\tToward the end, we tackled the crucial topic of form validation. We emphasized the importance of validating user input for enhancing user experience and ensuring data integrity, guiding you through the process with Angular and PrimeNG.\n\t\t\tAs we look forward to the next chapter, on data tables and other displaying components, remember that the knowledge gained here is vital for any web developer. Form controls are fundamental to web applications, and understanding their effective use is key to creating user-friendly applications.\n\n```"]