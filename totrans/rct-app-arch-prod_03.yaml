- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building and Documenting Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In React, everything is a component. This paradigm allows us to split user interfaces
    into smaller parts, thus making it easier to develop applications. It also enables
    component reusability since we can reuse the same components in multiple places.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will build some components that we will use as the application’s
    user interface base. This will make the application UI more consistent and easier
    to understand and maintain. We will also learn how to document the components
    with Storybook, a great tool that can serve as a catalog of common application
    components.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Chakra UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storybook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documenting components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, we will learn how to create and document reusable
    components that we can use for the application.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we get started, we need to set up the project. To be able to develop
    the project, you will need the following things installed on your computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Node.js** version 16 or above and **npm** version 8 or above.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are multiple ways to install Node.js and npm. Here is a great article
    that goes into more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js](https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js)'
  prefs: []
  type: TYPE_NORMAL
- en: '**VSCode** (optional) is currently the most popular editor/IDE for JavaScript/TypeScript,
    so we will be using it. It is open source, has great integration with TypeScript,
    and you can extend its features via extensions. It can be downloaded from here:
    [https://code.visualstudio.com/](https://code.visualstudio.com/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code files for this chapter can be found here: [https://github.com/PacktPublishing/React-Application-Architecture-for-Production](https://github.com/PacktPublishing/React-Application-Architecture-for-Production).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The repository can be cloned locally with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the repository is cloned, we need to install the application’s dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to provide the environment variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the dependencies have been installed, we need to select the right stage
    of the code base that matches this chapter. We can do that by executing the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will prompt us with a list of stages for each chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is the third chapter, so you can select `chapter-03-start` if you want
    to follow along or `chapter-03` to see the final results of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Once the chapter has been selected, all files required to follow along with
    the chapter will appear.
  prefs: []
  type: TYPE_NORMAL
- en: To follow along with this chapter, you don’t need to make any changes to the
    code. You can use it as a reference to help get a better overview of the code
    base.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the setup details, check out the `README.md` file.
  prefs: []
  type: TYPE_NORMAL
- en: Chakra UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever we build a UI for an application, we must decide what to use for styling
    our components. In addition, we must also consider whether we want to make all
    components from scratch or use a component library with pre-made components.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of using a component library is that it gives us a productivity
    boost as we don’t have to implement components that have already been implemented,
    such as buttons, dialogs, and tabs. Also, some libraries come with great accessibility
    defaults out of the box, so we don’t have to think about it as much as we would
    if we built everything from scratch. These libraries can come with costs, such
    as difficult customizability or a significant impact on the final bundle size.
    On the other hand, they save us a lot of development time.
  prefs: []
  type: TYPE_NORMAL
- en: For our application, we will use **Chakra UI**, a component library built on
    top of a combination of **emotion** and **styled-system**, which will allow us
    to write CSS in JavaScript in a consistent way.
  prefs: []
  type: TYPE_NORMAL
- en: Chakra UI setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We already have the Chakra UI library installed, and now we need to configure
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Chakra UI, first, we need to configure its theme provider to enable
    styles for its components. Since all our providers and wrappers are defined in
    `src/providers/app.tsx`, we can add `ChakraProvider` there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are wrapping the entire application with the provider to apply theming
    and styles to all Chakra UI components. We are also rendering the `GlobalStyles`
    component, which will take any global styles from our theme and apply it to the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Chakra UI settings and components are very customizable and can be configured
    in a custom theme, which we can pass to the provider. It will override the default
    theme configuration. Let’s configure the theme in `src/config/theme.ts` by adding
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We are defining some global styles that will be injected via the `GlobalStyles`
    component, which we have already added in `AppProvider`. We also define the theme
    colors we want to have available in the components. Then, we combine these configurations
    with the default theme values by using the `extendTheme` utility, which will merge
    all configurations and give us the complete theme object.
  prefs: []
  type: TYPE_NORMAL
- en: It is useful to centralize theme configuration since it is easy to use and change
    if the branding of the application changes. For example, we can easily change
    the primary color value in one place and apply it to the entire application without
    any additional changes.
  prefs: []
  type: TYPE_NORMAL
- en: Building components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that the Chakra UI setup is in place, we can build the components. In the
    starting files for this chapter, we already have some default components exported.
    For now, we can render them on the landing page defined in `src/pages/index.tsx`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To start the application development server, we need to run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This will make the newly created page available at `http://localhost:3000`.
    The development server will listen to any changes we make and auto-refresh the
    page with the latest changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The landing page will display the components. If we open `http://localhost:3000`,
    we should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Preview of the initial components on the landing page ](img/B17297_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Preview of the initial components on the landing page
  prefs: []
  type: TYPE_NORMAL
- en: The components aren’t doing much right now, so we need to work on their implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Button
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start by implementing the `Button` component, one of the most common components
    in every application. The component is already created in `src/components/button/button.tsx`,
    but we need to modify it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by importing its dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can create the `variants` object, which will hold all styling properties
    of our button and they will be applied accordingly to the default Chakra UI `Button`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can type the props for the `Button` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Typing the component’s props is a great way to describe its API, which is very
    useful as it documents how it should be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'And now, we can create the `Button` component, which is just a wrapper around
    the default `Button` component provided by Chakra UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can update the `Button` component usage in `src/pages/index.tsx` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: InputField
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The input field component is an input component that we want to use when building
    our forms. Let’s change `src/components/form/input-field.tsx`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to import all dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define types for the component’s props:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we implement the component itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are building an input field component that we can use with
    the `react-hook-form` library to create forms, and we will learn how to do that
    in the upcoming chapters. Notice how we are wrapping the component with `forwardRef`.
    This will allow us to pass references to the component if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s update its usage in `src/pages/index.tsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Link
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the links, we will use the `Link` component provided by Next.js. However,
    we want to centralize the configuration and styling and use it everywhere. Let’s
    modify `src/components/link/link.tsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s import all dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to what we did with the `Button` component, we want to allow the link
    to accept some variants, which will apply additional styling props to the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define the type of the component’s props:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the implementation of the `Link` component. Notice how we are using
    the `Link` component from Next.js, which we use to wrap the `Button` component
    from Chakra UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Why are we using the `Button` component instead of `Link` from Chakra UI? We
    could have used `Link`, but we want most of our links to look and feel like buttons,
    so the reason is just the style preference. Notice how we are passing `as="a"`
    to `Button`. This will make the element an anchor, which is correct from the accessibility
    standpoint, and the component will be rendered as a link element in the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s update its usage in `src/pages/index.tsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note that we can’t predict and build all shared components upfront. Sometimes
    we realize that something needs to be abstracted while we are developing it. It
    is also challenging to anticipate all edge cases of a component, so abstracting
    it too early might complicate things in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: For now, we have abstracted the most generic components we will surely use as
    they are.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, the implementation details of each component don’t matter. If you
    don’t understand everything they are doing and how they work, it’s okay. The key
    takeaway is that we want to abstract the most common components so we can reuse
    them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: Since most component libraries are very generic, with many options to fit everyone’s
    needs, it is a good idea to make our wrappers around their default components
    to reduce the default API surface and adapt them to the application’s needs. This
    will reduce the overhead of components with too many configuration options and
    props we will never use. Also, it will bring consistency since developers are
    constrained to using fewer options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at our index page where the components are rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Preview of the components on the landing page ](img/B17297_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Preview of the components on the landing page
  prefs: []
  type: TYPE_NORMAL
- en: Great! Now go ahead and try to play around with different props and see how
    the components behave.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our components are working correctly and are ready to be used in the application.
    However, there are a couple of issues:'
  prefs: []
  type: TYPE_NORMAL
- en: We are occupying the index route. What happens when we want to use it for something
    meaningful, such as the landing page? We will not be able to use that page for
    previewing our components. Sure, we can create and use another page that will
    never be used, but that is not a very good option either.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We don’t want to display all components together as it is messy, and it would
    be better to try them out in isolation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want to play around with the component props, which is impossible with the
    current approach since we would have to modify the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s see in the next section how we can solve these issues and develop and
    try components in isolation without changing our application’s code.
  prefs: []
  type: TYPE_NORMAL
- en: Storybook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Storybook** is a tool that allows us to develop and test UI components in
    isolation. We can think of it as a tool for making catalogs of all the components
    we have. It is great for documenting components. A couple of benefits of using
    Storybook include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Storybook allows developing components in isolation without the need to reproduce
    the exact state of the application, allowing developers to focus on the things
    they are building
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storybook serves as a catalog of UI components allowing all stakeholders to
    try out the components without using them in the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Storybook is configured by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This command will install all required dependencies and set up the configuration
    that resides in the `.storybook` folder at the root of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Storybook configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We already have Storybook installed, so let’s look at the configuration, which
    has two files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first file contains the main configuration, which controls how the Storybook
    server behaves and how it processes our stories. It lives in `.storybook/main.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The main configuration contains the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`stories`: An array of globs that indicates the locations of our stories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addons`: A list of add-ons used to enhance the default behavior of Storybook.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`features`: Enables Storybook’s additional features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`framework`: Framework-specific configurations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`core`: Internal feature configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`webpackFinal`: Configuration for extending default webpack configuration.
    We are enabling absolute imports by telling Storybook to use paths from the `tsconfig.json`
    file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second configuration file controls how the stories are rendered in the
    UI. This configuration lives in `.storybook/preview.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we are passing the theme to the `chakra` property in `parameters`.
    This will enable Chakra theming to be applied to our components in Storybook.
  prefs: []
  type: TYPE_NORMAL
- en: We can optionally export decorators, which will wrap all the stories. It is
    useful if the components rely on some providers that we want to have available
    in all stories.
  prefs: []
  type: TYPE_NORMAL
- en: Storybook scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our Storybook setup has two npm scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: Running Storybook in development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To start the development server, we can execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The command will open Storybook at `http://localhost:6006/`.
  prefs: []
  type: TYPE_NORMAL
- en: Building Storybook for production
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can also generate and deploy the stories to be visible without running the
    development server. To build the stories, we can execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Generated files can then be found in the `storybook-static` folder, and they
    can be deployed anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have familiarized ourselves with the setup, it’s time to write the
    stories for the components.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we recall from the previous section, the configuration in `.storybook/main.js`
    has the `stories` property as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that any file in the `src` folder that ends with `.stories.tsx`
    should be picked by Storybook and treated as a story. With that said, we will
    co-locate stories next to the components, so the structure for every component
    will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We will create our stories based on **Component Story Format** (**CSF**), an
    open standard for writing component examples.
  prefs: []
  type: TYPE_NORMAL
- en: But first, what is a story? According to the CSF standard, a story should represent
    a single source of truth for a component. We can think of a story as a user story
    where a component is presented in the corresponding state.
  prefs: []
  type: TYPE_NORMAL
- en: 'CSF requires the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Default exports should define metadata about a component, including the component
    itself, the component’s name, decorators, and parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Named exports should define all stories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s now create the stories for the components.
  prefs: []
  type: TYPE_NORMAL
- en: Button stories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create stories for the `Button` component, we need to create an `src/components/button/button.stories.tsx`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can start by adding the required imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create the meta configuration object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we are exporting it as a default export. This is what Storybook
    requires, according to CSF.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we can have multiple stories, we must create a story template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'And then we can export the first story:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We can pass any props we need to the `args` object attached to the story, which
    will be reflected in our stories in Storybook.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do the same thing for another story where we want to have a version
    of `Button` that has an icon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To see the story, let’s execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s visit `http://localhost:6006/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Button component story ](img/B17297_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Button component story
  prefs: []
  type: TYPE_NORMAL
- en: And there, we have the `Button` component previewed in isolation. Notice the
    control panel at the bottom. This gives us a friendly interface to play with the
    component’s props without touching the code.
  prefs: []
  type: TYPE_NORMAL
- en: Isn’t this much nicer than what we had first with rendering components on the
    index page? We can deploy stories anywhere and allow non-technical people to experiment
    with the components without coding knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To solidify your understanding of Storybook, let’s have a go at some exercises.
    Go ahead and create stories for the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`InputField`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default story
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: With error story
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Link`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default story
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: With icon story
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, our focus was on building base components that we will reuse
    in our application.
  prefs: []
  type: TYPE_NORMAL
- en: We started by configuring the Chakra UI provider and theming. Then we displayed
    the components on the landing page for testing purposes. They were not doing much,
    so we implemented them. The point of defining shared components is that we can
    reuse them anywhere, which makes development easier in the long run. What the
    components are doing here is not very important. The important thing is to think
    about creating shared components as a base for the application.
  prefs: []
  type: TYPE_NORMAL
- en: We then needed to preview the components somewhere and since doing that on a
    page is not a very elegant solution, we chose Storybook. We covered its configuration,
    and then we defined a couple of stories for the `Button` component. The stories
    are written in **Component Story Format** (**CSF**), which is a standard for how
    to write component examples.
  prefs: []
  type: TYPE_NORMAL
- en: As an exercise at the end of this chapter, there were further stories to implement,
    which should solidify all learnings so far.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will use these components when we start creating our
    pages.
  prefs: []
  type: TYPE_NORMAL
