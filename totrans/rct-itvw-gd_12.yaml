- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building an App Based on the Next.js Toolkit, Authentication, SWR, GraphQL,
    and Deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout our journey in this book, we have learned new skills, methodologies,
    and better ways of thinking. This chapter is the culmination of our efforts, so
    let’s move forward, as it is now time for us to put everything we have learned
    together as we seek to develop an exciting application that features an up-to-date
    modern tech stack. This chapter will allow us to progress from concept to the
    deployment of a Next.js application that has implementations for authentication,
    **stale-while-revalidate** (**SWR**), GraphQL, and deployment.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with a quick introduction to REST APIs, which will be a fantastic
    refresher if you are already familiar with them, or a great introduction if it’s
    your first time learning about this essential methodology. Then, we shall move
    on to figuring out how best to plan the architecture for an application, where
    we will go into how authentication works. This will be followed up by how effective
    SWR is and why it’s worth using, as it’s a very useful aspect that can enhance
    the performance of our applications. Next, we will learn about GraphQL and how
    it compares with traditional REST APIs. Then, we will end with deployment, which
    is where we finally publish our local development build online so that the whole
    world can use it.
  prefs: []
  type: TYPE_NORMAL
- en: In the sections that follow, we will talk about the ideas behind business logic
    and how the code we write has significant importance not just for the way our
    application runs but also for how it can reflect positively or negatively on our
    team and company depending on how well it is written. Moving on, we will go through
    creating the presentation layer, which is essential to the user interface and
    user experience. Testing is going to be the next major feature that we touch on,
    as it’s highly recommended that production-ready applications have a robust testing
    suite set up to guarantee that it is stable and in a state that is ready to be
    published as a **minimum viable** **product** (**MVP**).
  prefs: []
  type: TYPE_NORMAL
- en: With those features completed, we will finish off by learning how to deploy
    our application so that the public can access it. In the last sections, we will
    create a Git repository with a README file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of topics, the following will be the themes that we will be focusing
    on in the upcoming sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Quick introduction to REST APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Planning the application architecture including authentication, SWR, GraphQL,
    and deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the business logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the presentation layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Git repository with README documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying the application for public access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On your machine, confirm that [https://nodejs.org/en](https://nodejs.org/en)
    is up to date and that the JavaScript Node package for Next.js is set up and operational.
    You can use whatever package manager you want, be it `npm`, `yarn`, or `pnpm`.
    Just make sure that you use the appropriate commands when doing the installation.
    For simplicity’s sake, we will be using `npm`. Work on your project with your
    preferred **integrated development environment** (**IDE**) and **command-line
    interface** (**CLI**) tool. You will also need to have an account on [https://vercel.com/](https://vercel.com/)
    for the deployment section when we build our app. For the authentication section,
    we will use GitHub and Google, so in the unlikely event that you don’t have accounts
    for both of these services already, create one now. GitHub is also required for
    the version control section, so it’s essential for you to have an account.
  prefs: []
  type: TYPE_NORMAL
- en: The package for Next.js can be found at [https://nextjs.org/](https://nextjs.org/).
  prefs: []
  type: TYPE_NORMAL
- en: The project and code base can be found online at [https://github.com/PacktPublishing/React-Interview-Guide/tree/main/Chapter12/coffee-restaurant](https://github.com/PacktPublishing/React-Interview-Guide/tree/main/Chapter12/coffee-restaurant).
  prefs: []
  type: TYPE_NORMAL
- en: To begin, let’s first talk about REST APIs to understand their core concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Quick introduction to REST APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **Representational State Transfer Application Programming Interface** (**REST
    API**) is a particular technology that has established itself as the cornerstone
    of contemporary web development. By using REST APIs within JavaScript and React
    applications, developers can develop robust and dynamic web apps that can communicate
    with other platforms and information sources. Developers can transfer data between
    the server and client using the REST API without worrying about the architecture
    of the underlying apps. In simple terms, the REST API standardizes communication
    protocols, which simplifies development. With the correct tools and skills, REST
    APIs can totally alter the way web developers work.
  prefs: []
  type: TYPE_NORMAL
- en: We can easily understand the core methodology and concept of a REST API by using
    a restaurant as an example. This is considered to be a popular way to describe
    how the process works. For example, let’s say that a user has a restaurant application.
    Basically, the user requests some data for their menu page, which is equivalent
    to a user in a restaurant asking a waiter for some food. In this case, the waiter
    who is taking the food request is the same as the API taking the request to display
    the menu. The waiter then goes to the kitchen to get the food, which is equivalent
    to the API getting the application.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s imagine that the application has a list of food on the menu. A customer
    takes a look at the menu and then gives their order to a waiter. The waiter goes
    to the kitchen with the customer’s order and waits for the meal to be completed.
    When the food is ready, the kitchen staff give the food to the waiter, who then
    responds by returning to the customer with the food they requested. In a real-world
    situation, the customer now has a meal to eat. If we imagine this as a website,
    then a page has now loaded with a table that shows food from the menu inside it.
    This information was fetched via the API to the backend server application, which
    returned it.
  prefs: []
  type: TYPE_NORMAL
- en: This example is perfectly illustrated in *Figure 12**.1*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1: Describing a REST API](img/Figure_12.01_B18603.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.1: Describing a REST API'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now learn how we can manage our APIs using various tools. This is another
    important skill for developers to have.
  prefs: []
  type: TYPE_NORMAL
- en: What tools can we use for testing our APIs?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When doing API development, it is normal for a developer to use an API tool
    for managing, testing, and interacting with the API. Some of the most popular
    API development tools for JavaScript development can be seen in *Table 12.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **API tool** | **Website address** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Postman | [https://www.postman.com/](https://www.postman.com/) |'
  prefs: []
  type: TYPE_TB
- en: '| Insomnia | [https://insomnia.rest/](https://insomnia.rest/) |'
  prefs: []
  type: TYPE_TB
- en: '| Swagger | [https://swagger.io/](https://swagger.io/) |'
  prefs: []
  type: TYPE_TB
- en: '| Thunder Client | [https://www.thunderclient.com/](https://www.thunderclient.com/)
    |'
  prefs: []
  type: TYPE_TB
- en: 'Table 12.1: Popular JavaScript REST API tools'
  prefs: []
  type: TYPE_NORMAL
- en: With these tools, we can thoroughly test our REST APIs and it is even possible
    to use this as a basis for creating the documentation. There is something that
    we need to be aware of though when building APIs, and that is **cross-origin resource
    sharing** (**CORS**). CORS is basically an application integration method. CORS
    specifies a method for client web applications loaded in a single domain to communicate
    with assets located in another domain. So, essentially, if we do not specify or
    allow CORS access in our APIs, then we will be blocked from accessing them unless
    they are on the same server.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we could have an API hosted online on a website, and let’s say
    that we have a React application that is online on a different server somewhere.
    If our API is not set up for CORS, then our React application can’t connect to
    it to retrieve any data, and we will just get a CORS error in our browser console,
    as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2: A CORS error web browser console message](img/Figure_12.02_B18603.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.2: A CORS error web browser console message'
  prefs: []
  type: TYPE_NORMAL
- en: It’s time to move on to learning about REST APIs in more detail now that we
    have a better understanding of how they are set up. So, let’s see what features
    are on offer.
  prefs: []
  type: TYPE_NORMAL
- en: Which features are available in a REST API?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A REST API is a strong tool that gives developers access to a wide range of
    functions. The REST API’s excellent security system is one of its most important
    characteristics. It guarantees that any malicious attacks won’t be made on the
    data given over the API. Additionally, the REST API’s capacity to scale is another
    crucial aspect, which implies that it is a great option for apps with heavy traffic
    because it can manage a lot of queries. Another remarkable quality of REST APIs
    is their flexibility, which lets developers use any architecture or technology
    of their choosing. REST APIs are an excellent tool for developers who wish to
    create dependable and durable apps thanks to all these features taken together.
  prefs: []
  type: TYPE_NORMAL
- en: A REST API is capable of requesting and responding to requests, but what does
    that mean? Let’s find out.
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between requests and responses when making requests to
    a REST API?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Understanding how HTTP requests and responses operate is essential if you want
    to create a web application that connects to a REST API. Data is sent from a client
    to a server using HTTP requests, and it is sent back from the server to the client
    using HTTP responses. REST APIs interact between clients and servers using **GET**,
    **POST**, **PUT**, and **DELETE** standard HTTP protocols. We can build web apps
    that easily interface with REST APIs by designing them with greater effectiveness
    and efficiency by knowing how these requests and responses operate. There are
    other HTTP protocols available, but the standard ones are the most common. Now,
    let’s understand the difference between these HTTP protocols.
  prefs: []
  type: TYPE_NORMAL
- en: What is a GET request?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `GET` request is a method that is used to obtain data from the server. It
    is a read-only procedure so there is no negative impact on the server. `GET` requests
    do not cause the data or the server to change its state.
  prefs: []
  type: TYPE_NORMAL
- en: What is a POST request?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `POST` request is used to transmit information to the server in order to establish
    new data. It is not immutable, which means that submitting the same `POST` request
    many times might get different results. `POST` requests generally return the URL
    or an instance of the newly created resource.
  prefs: []
  type: TYPE_NORMAL
- en: What is a PUT request?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `PUT` request can be utilized to add new information to preexisting server
    data. It is capable of change, so you can send the same `PUT` request to get different
    results. Based on the way it’s done, if the data does not exist, the server could
    create it.
  prefs: []
  type: TYPE_NORMAL
- en: What is a DELETE request?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `DELETE` request is used to remove data from the server. It is also immutable,
    which means that sending the same `DELETE` request multiple times has the same
    outcome. Following the deletion of data, the server normally provides a status
    indicating whether the action was successful or unsuccessful.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see an example REST API application in this code example here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we have a `static` route, which is used for serving files
    such as images, CSS, and JavaScript, for example, so long as they are in a public
    folder in our app. We have a `GET` route for the API, which just returns a JSON
    object. Lastly, we have a `POST` route, which logs to the console and returns
    a JSON object of whatever text a user sends as a `POST` request, as in this example:
    `http://localhost:8080/post/helloworld`.'
  prefs: []
  type: TYPE_NORMAL
- en: HTTP protocols are just one aspect of a REST API. It is also important to have
    good authentication set up. Continue reading to see why this is the case.
  prefs: []
  type: TYPE_NORMAL
- en: Why is authentication important when using a REST API?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using a REST API requires authentication to ensure that private data is kept
    secure. Authentication requires confirming the user’s identity before giving access
    to API capabilities. This helps to avoid unauthorized data access or usage, which
    might endanger users. When communicating with an API, you’ll probably utilize
    a variety of authentication mechanisms, including token-based authentication and
    OAuth. These methods guarantee that only authorized users have access to the API
    and are allowed to send requests or get data. Understanding authentication while
    interacting with a REST API can potentially assist us in building a more secure
    and efficient solution. It is possible to understand authentication flow if we
    see it in a diagram such as this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3: The REST API authentication flow](img/Figure_12.03_B18603.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.3: The REST API authentication flow'
  prefs: []
  type: TYPE_NORMAL
- en: Another aspect worth discussing is error handling because it’s crucial that
    we check for mistakes, which is very important when authentication and user details
    are involved. Let’s discover how having effective error handling can make our
    application more trustworthy.
  prefs: []
  type: TYPE_NORMAL
- en: How can we use error handling when integrating with a REST API?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Connecting with a REST API is occasionally difficult, especially when confronted
    with errors. However, having a robust error-handling plan in place could spare
    us time and hassle in the long term. One useful strategy is to specify error codes
    and messages that our application can recognize and respond to. Furthermore, installing
    automatic retries and monitoring systems can assist in identifying and addressing
    issues more rapidly. Another important topic is dealing with data validation mistakes,
    as API inputs must be thoroughly scrutinized before being utilized in our application.
    We can ensure easy integration with a REST API and deliver an improved user experience
    for our clients by being proactive and comprehensive in our approach to error
    management.
  prefs: []
  type: TYPE_NORMAL
- en: The last topic we’ll cover in this section is GraphQL. So, let’s now see how
    GraphQL compares with a traditional REST API.
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between a REST API and GraphQL?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: REST and GraphQL are two techniques for the creation and operation of web service
    APIs; however, they differ in numerous ways. GraphQL tends to be more flexible
    because you can request only the data you need and not all at once as with REST
    APIs. This is great because it means fewer data transfer requests on the network.
    Another area GraphQL excels in is versioning history because it is not reliant
    on versions, which is the case with REST APIs, requiring more manual hands-on
    work. Despite this, they both have pros and cons over each other and, when comparing
    the two, we can see how they offer us different advantages and disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The end user often uses a REST API to access resources through preset endpoints,
    where each endpoint is associated with a single resource or a group of related
    resources. The client makes HTTP requests to these endpoints in order to get or
    modify data. When using GraphQL, a client sends queries or mutations to a single
    endpoint, indicating the data it requires or the modifications it wants to make.
    In comparison to REST API, this allows the client to only retrieve the data they
    actually need, eliminating the need for requesting more data than required or
    too little data.
  prefs: []
  type: TYPE_NORMAL
- en: Caching data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To improve efficiency and lessen server load, REST APIs can make use of ETags
    and cache-control headers, two common HTTP caching methods. In contrast, because
    of GraphQL’s flexible query form, caching is more difficult. The usage of unique
    caching techniques offered by GraphQL client-side libraries such as Apollo Client
    or application-level caching is frequently required by clients.
  prefs: []
  type: TYPE_NORMAL
- en: Documentation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Within REST APIs, documentation is frequently given separately, and it is the
    responsibility of the programmers to keep it up to date. If not kept up with,
    this can result in contradictions and inaccurate data. On the other hand, since
    GraphQL includes built-in introspection, users can dynamically learn about the
    different kinds and features of the API. Engineers can explore and comprehend
    the API more easily, frequently using tools such as GraphiQL.
  prefs: []
  type: TYPE_NORMAL
- en: To end this section, we are going to take a look at some code examples of fetching
    some data using REST and GraphQL so it becomes clear how the two methods differ
    from each other.
  prefs: []
  type: TYPE_NORMAL
- en: How do we fetch data using REST APIs and GraphQL?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will take a look at code examples for fetching data using REST and GraphQL,
    starting with REST APIs. In these examples, we will use authors and posts.
  prefs: []
  type: TYPE_NORMAL
- en: How do we fetch data using REST APIs?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first step is to get a post that has an ID of `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what a potential sample response might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When using a REST API for data retrieval, requests return all of the information
    in the data object. It is not possible to request, let’s say, only the `id` and
    `title` information. We would have to write business logic in JavaScript to filter
    the object so that we only get the data we want to use in our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if we wanted to get details for the author, then we would have to send
    a second `GET` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we’ll have the author’s info:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: So, now that we have understood the basic concept of fetching data using REST
    APIs, let’s see how we can do the same but this time using GraphQL.
  prefs: []
  type: TYPE_NORMAL
- en: How do we fetch data using GraphQL?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we use GraphQL, we first need to create a schema for our API, as shown
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to write a GraphQL query to get the author and a post:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The response will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: GraphQL allows us to retrieve the necessary data with a single request by defining
    the fields we desire.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, deciding between a REST API and GraphQL boils down to our specific
    use cases and requirements. Both have distinct characteristics and abilities that
    can help us optimize the development process while creating web or mobile apps.
    However, as with many technological issues, it is critical for us to consider
    all of our alternatives before settling on the best method. We can safely use
    a REST API or GraphQL within our React applications to obtain the desired outcome
    if we can grasp their common qualities and special benefits. Whatever technology
    we employ, the objective should always be to provide safe, scalable, and effective
    solutions for those who use the app.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have completed this introductory refresher section, let’s take the
    next step and create the foundation for building our app as we learn about the
    planning required for the architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Planning the application architecture including authentication, SWR, GraphQL,
    and deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In today’s fiercely competitive marketplace, it is imperative to possess the
    know-how of designing, developing, and deploying an application architecture that
    is efficient, secure, and meets user needs. However, with the advent of evolving
    technologies such as Next.js, authentication methods transitioning from traditional
    OAuth 2.0 to SWR, and GraphQL gaining popularity, planning our application architecture
    might seem like a daunting task.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will get valuable insights to assist us in organizing our
    application for success, from selecting the appropriate technologies to incorporating
    user experience design elements. By the end of this section, we will have a roadmap
    to guide us through building our next project, with clear steps to follow through
    to completion.
  prefs: []
  type: TYPE_NORMAL
- en: Our next topic focuses on serverless frameworks. So, let’s read on and see why
    they are a brilliant choice for building modern apps.
  prefs: []
  type: TYPE_NORMAL
- en: Why are serverless frameworks such as Next.js a brilliant choice for building
    modern applications?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: New frameworks and architectures are developed as digital technology advances
    to better the effectiveness of building web applications. Next.js is one of these
    architectures because of its speed and flexibility. Next.js apps have a distinct
    design that separates server-side code from client-side logic, resulting in faster
    processing times and better performance. This architecture employs **server-side
    rendering** (**SSR**) to generate HTML pages on the server, significantly reducing
    client-side load. Next.js apps also use a hybrid approach that utilizes dynamic
    and static rendering for increased efficiency and faster load times. Because of
    these features, Next.js is an excellent choice for programmers looking to create
    modern, powerful web applications.
  prefs: []
  type: TYPE_NORMAL
- en: The next topic that we will cover is authentication. So, let’s take a look at
    how certain security measures can enhance our defenses.
  prefs: []
  type: TYPE_NORMAL
- en: What authentication is available in Next.js applications?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The security of online apps is a high priority as they become more essential
    to our daily lives. A key component of protecting these applications is authentication,
    which is the method of confirming a user’s identity. Providing authentication
    in a Next.js application can be done using a variety of techniques, including
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Auth.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JSON Web** **Tokens** (**JWTs**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auth0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OAuth2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Login and password authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By utilizing these technologies, engineers can defend their applications against
    online threats such as hackers’ attempts to steal user data. This high degree
    of verification guarantees users a safe and reliable environment while also safeguarding
    their private data. A Next.js application must use proper authentication procedures
    given the growing significance of online privacy.
  prefs: []
  type: TYPE_NORMAL
- en: Speed is a high-priority requirement when building our app infrastructure, but
    how does SWR make it better? We will find out now in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How does SWR allow fast data retrieval?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is not surprising that quick and effective data fetching has elevated to
    the top of developers’ priorities as the world becomes increasingly data-driven.
    And that’s where **stale-while-revalidate**, or **SWR**, comes into play. SWR
    is a remote data fetching React Hooks library that prioritizes speed, caching,
    and revalidation. Fetching data is made simple with SWR, since it does away with
    annoying loading boxes and makes sure the data is continuously current. Additionally,
    it has a user-friendly API that makes it simple for programmers of any experience
    level to utilize.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will take another look at GraphQL to see why it has become the best
    choice for modern application architecture.
  prefs: []
  type: TYPE_NORMAL
- en: How can GraphQL integration optimize our data fetching?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The need to optimize productivity and simplify operations grows as technology
    develops. In response, GraphQL integration has become more common. GraphQL significantly
    boosts the speed and accuracy of data retrieval by enabling optimized data fetching.
    With GraphQL, queries can be customized to meet particular needs rather than having
    to get several datasets and sort through them to find the necessary information.
    The outcome of this is that data can be retrieved more quickly and accurately,
    which can aid companies in staying current. Because of these advantages, many
    businesses have adopted GraphQL integration, given its capacity to improve data
    fetching procedures.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment is where our application goes live online for the public to use and
    we get to show off our creation to the world. So, let’s now learn about this crucial
    step in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How do we deploy our Next.js applications online?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Deploying apps on cloud platforms is the conclusion of all of our hard work,
    and this process can be both challenging and rewarding. The best feature (which
    makes Next.js a favorite among developers) is that it allows SSR. Our Next.js
    application will now be accessible at all times and from any location when we
    deploy it on a cloud infrastructure. Numerous cloud providers are readily accessible
    on the market, each with distinctive characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most popular online cloud host providers is **Vercel**, the creators
    of Next.js, meaning that their platform is the perfect place for deploying our
    Next.js apps. Other popular serverless host providers include Netlify, AWS, Azure,
    Render, Firebase, and Supabase. There are countless others out there to choose
    from. The important thing is to find a platform that is cost-effective and offers
    many good features and services. The majority of the ones mentioned here offer
    free services.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will end this section by checking out ways to scale and maintain
    our application once it has been deployed to manage its growth.
  prefs: []
  type: TYPE_NORMAL
- en: What strategies can we use for scaling and maintaining our application architecture
    as it grows?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s critical to have a plan developed for expanding as well as sustaining our
    architecture as the popularity and usage of our application grows. Without proper
    planning, our application might not be able to cope with the surge in traffic,
    which could turn off prospective customers. Forecasting and taking into account
    potential future growth, along with the tools and technology that might assist
    us in getting there, are necessary for a scalable design. The continuous effectiveness
    of an app is also greatly dependent on the upkeep of our architecture as it develops.
    Adding user feedback to enhance the user experience, testing our software for
    faults and problems, and routinely reviewing and revising the code base are all
    part of this. Our apps can thrive for a very long time if we put the correct plans
    in place.
  prefs: []
  type: TYPE_NORMAL
- en: Having an in-depth knowledge of authentication, SWR data fetching strategies,
    GraphQL integration, and deployment strategies will greatly benefit us as we start
    to develop the architecture of our Next.js application. With these plans in place,
    we can start thinking about scaling and managing our application as it grows,
    which is a vital component of any effective application architecture. The strength
    of Next.js, combined with these strategies, will result in an excellent user experience
    and contribute to the efficiency of the development process.
  prefs: []
  type: TYPE_NORMAL
- en: Working on our coffee restaurant project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the theory out of the way, let’s start building our website. The first
    thing we need to do is set up our project, so let’s do that now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our technical stack is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Next.js**: React framework'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**styled-components**: CSS styling'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**apollographql**: Data API'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**authjs**: Authentication'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**React Testing Library** and **Jest**: Testing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GitHub**: Version control'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vercel**: Serverless online web host'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to create a restaurant application for this project. There will
    be five main pages, and two of them will require you to be authenticated to access
    them. The authentication will be taken care of with Google or GitHub, so you can
    use either account to sign in.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the final project will look like for our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4: Next.js final project home page](img/Figure_12.04_B18603.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.4: Next.js final project home page'
  prefs: []
  type: TYPE_NORMAL
- en: The project and code base can be found online at [https://github.com/PacktPublishing/React-Interview-Guide/tree/main/Chapter12/coffee-restaurant](https://github.com/PacktPublishing/React-Interview-Guide/tree/main/Chapter12/coffee-restaurant)
  prefs: []
  type: TYPE_NORMAL
- en: and there is a link on GitHub to a working website, so you can see all of the
    pages.
  prefs: []
  type: TYPE_NORMAL
- en: Building the business logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, with the theory completed, we are ready to do some practical work as we
    build our application. It’s going to be a fairly simple application; the main
    aim here is to understand how we connect all of these technologies. The application
    will be a restaurant website that has some restricted pages that require an authenticated
    user to access them. These authenticated pages will only show the data from our
    GraphQL API if the user is logged in; otherwise, they will be presented with a
    sign-in page.
  prefs: []
  type: TYPE_NORMAL
- en: With that introduction out of the way, let’s begin building the business logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a folder on your computer, such as on the desktop, and then run the
    following Next.js command to create a Next.js project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the following settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Would you like to use TypeScript with this project? …` `No/Yes`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Would you like to use ESLint with this project? …` `No/Yes`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Would you like to use Tailwind CSS with this project? …` `No/Yes`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '``Would you like to use `src/` directory with this project? …`` `No/Yes`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Use App Router (recommended)? …` `No/Yes`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Would you like to customize the default import alias? …` `No/Yes`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we have to install all of the dependencies and packages for our project.
    So `cd` into the `my-app-restaurant` directory and run the following commands
    to install the packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following script to install the regular dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following script to install the development dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If you encounter any errors when trying to install these packages you could
    try adding the --force command or using sudo if you are on a Mac like this: sudo
    npm i --save-dev @testing-library/jest-dom @testing-library/react jest jest-environment-jsdom
    --force'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the following test run script to the `scripts` section in the `package.json`
    file in the `root` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run this command inside the root of the `my-app-restaurant` folder. This
    will create all of the files and folders we will need for this project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Before we start to work on the main app files, let’s sort out the configuration
    files first.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration files setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Put this code in the `api/auth/[…nextauth]/route.js` file. We will use this
    code for setting up our authentication layer, in which GitHub and Google will
    be used for signing in to the protected routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, put this code in the `lib/registry.js` file. This code is used for configuring
    `styled-components` to work with Next.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add the following code to the `jest.config.mjs` file in the `root` directory.
    This file can be used for setting up the Jest test runner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, update the `next.config.js` file in the `root` folder with this code,
    which will enable `styled-components` to work as well as the app directory setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We just have one more step to complete, which is the GitHub and Google authentication
    setup section. We must create IDs and secrets for our `.env.local` file. The authentication
    setup can be found at [https://authjs.dev/getting-started/oauth-tutorial](https://authjs.dev/getting-started/oauth-tutorial).
    The tutorial shows you how to do the authentication setup with GitHub. However,
    the setup is fairly similar for other authentication providers, and you can find
    the one for Google at [https://developers.google.com/identity/protocols/oauth2](https://developers.google.com/identity/protocols/oauth2).
  prefs: []
  type: TYPE_NORMAL
- en: 'Just remember that when we run our app locally, the callback URL will look
    something like this if we use GitHub as an example: `http://localhost:3000/api/auth/callback/github`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we deploy it online, it might look something like this: `https://your-app-url.vercel.app/api/auth/callback/github`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is important because our authenticated routes won’t work unless we use
    the right URL. Finally, we just need to add the IDs and secrets to our `.env.local`
    file. This file also needs a secret to be created for our `NEXTAUTH_SECRET` key-value
    pair, which is required for NextAuth.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You can create your own secret key, and it can be anything you want; I would
    suggest making it secure by generating a random string of characters as you would
    if you were creating a strong password. There are many free tools that can do
    this for you, or you could just randomly make one yourself, such as this example:
    `Y@q7LH@6YoBa$Dkz`. It uses both uppercase and lowercase alphanumeric characters
    and it also has special characters. We all know how to create secure passwords;
    just use the same thinking when creating your secret key.'
  prefs: []
  type: TYPE_NORMAL
- en: Building the app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s go for it! There are quite a lot of files because the build phase has
    many files. But after this section, we will be close to completion! We have a
    data layer that will act as our database. Basically, there is an array of objects
    that we will fetch using GraphQL and then display on our frontend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following code inside the `data` folder we created. This code will
    be for the data we show on the `data/menu.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the following code is for `data/profile.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Moving on, the next batch of code is for the authenticated pages for the menu
    and profile.
  prefs: []
  type: TYPE_NORMAL
- en: The following code is for `account/menu/page.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code is quite long so let’s break it down into smaller code blocks. This
    first code block has our imports and color theme setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The next code block has our CSS and `styled-components`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'And lastly, we have the rendered data for our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now, the following code is for `account/profile/page.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Like last time, let’s break it down into smaller code blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have the imports for our page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have the color theme and `styled-components` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we have the rendered content for the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s work on some component files. The first code is for `components/MainMenu.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the following code is for the `components/Provider.js` file, which is
    required for authentication and session state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Our next file has our GraphQL schema, resolvers, and our Apollo server. The
    following code goes in `graphql/route.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, use the following code to build `nutrition/page.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'GraphQL queries are next, so the following code is for the `queries/clientQueries.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the important `utils/cors.js` file is needed so that we don’t get CORS
    errors when our app is deployed online. This will allow us to access our GraphQL
    API on the authenticated routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s keep going. We have some more code here and it’s for another GraphQL
    setup page; this time, it has the endpoints for GraphQL, which is how we will
    access our queries later. This file is in `utils/withApollo.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Almost done! We are now on the `layout.js` page file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The 404 error `not-found.js` page has the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: And lastly, the `page.js` file is in the `root` folder, which is our home page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is split in two for readability. First, we have the imports and CSS
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'And now for the function where we render our components in JSX with HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: That’s it! We are done with the bulk of the code base, and our app is almost
    complete! All that is left is a `GlobalStyles.js` file and the images for the
    frontend. We will do this in the upcoming section.
  prefs: []
  type: TYPE_NORMAL
- en: Building the presentation layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our project uses `styled-components`, which means the component and page files
    already have localized CSS. We do have one global CSS file though, which is a
    styled component with global style. Here is the code for `components/GlobalStyles.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We have waited long enough; it’s time to finally see our application running!
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that you are in the `root` folder for `my-app-restaurant` and run
    the application with the `npm run` `dev` command.
  prefs: []
  type: TYPE_NORMAL
- en: Our application should be running on `http://localhost:3000` and our GraphQL
    API should be on `http://localhost:3000/graphql`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The GraphQL API has built-in documentation for testing our queries. Here is
    an example query that should return the `menu` data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Before we put our app on GitHub and deploy it online, we will finish off with
    some unit tests for some of the files so that we get used to test-driven development.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have two test suites. First, we have the code for `nutrition/page.test.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'And lastly, the following code is for the `page.test.js` file in the `root`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Run the `npm test` command, and all tests should be passing. You can press the
    *A* button to rerun all of the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Our app is more or less complete. Let’s now put it on GitHub so that we can
    version control it. It is also preparation for getting our app to work online
    when we deploy it to Vercel, our serverless host.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Git repository with README documentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go to GitHub and create a new repo for our project. If you are new to or still
    unfamiliar with GitHub, then you can follow the *Get started* guide here: [https://docs.github.com/en/get-started](https://docs.github.com/en/get-started).
    Then, simply follow the commands to push your project to GitHub. These are the
    commands I used. Replace them with your own repo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Our project is now on GitHub! We only have one thing left to do – to deploy
    our app on Vercel – and then we are done!
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the application for public access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sign in to your Vercel account and then, on the dashboard, there should be a
    button to add a new project. Add a new project and import the Git repository you
    just created for the project.
  prefs: []
  type: TYPE_NORMAL
- en: Before you hit the `.env.local` file in the `root` folder of your project. This
    file was not uploaded to your GitHub repo because it has your GitHub and Google
    IDs and secret keys, which you don’t want people to see! When you’re done, hit
    **Deploy** and wait for the build to complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our app should be live online now. However, the `utils/withApollo.js` file,
    the URL is set to `http://localhost:3000/graphql`; our app is online now and is
    not running on our machine, so the address needs to change. Update it to the address
    of your app on Vercel, as in the following example: `https://your-app-url.vercel.app/graphql`.
    Push the latest changes to your GitHub repository, and Vercel will automatically
    update and deploy with the new URI.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following commit message should be fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'And remember from earlier, when we run our app locally, the callback URL will
    look something like this, if we use GitHub as an example: `http://localhost:3000/api/auth/callback/github`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When deployed online, it will have the following type of URL structure: `https://your-app-url.vercel.app/api/auth/callback/github`.'
  prefs: []
  type: TYPE_NORMAL
- en: So update the authentication for your app on GitHub and Google to get the **Menu**
    and **Profile** pages working online.
  prefs: []
  type: TYPE_NORMAL
- en: It should be all done. Now, our application should be available online for the
    whole world to see. Well done!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have made it to the end of this chapter and leveled up our programming skills
    considerably. Right at the beginning of this chapter, we learned about REST APIs
    and how they help us to fetch data on the internet, which we can then use in our
    applications. Afterward, we had an introduction to planning application architecture,
    where we talked about authentication followed by SWR, an HTTP cache invalidation
    strategy. The next topic was GraphQL, the popular alternative to using REST APIs,
    which requires fewer API requests as it’s possible to fetch only the data we require.
    We then touched upon deployment because it’s important to remember this setup
    from the get-go.
  prefs: []
  type: TYPE_NORMAL
- en: In the next sections, we dived into business logic and learned why our code
    needs to be well refined. This section was followed up by the presentation layer
    as we created a design that used styled-components. Testing was factored in, and
    we learned how to test the code that we wrote for our project. With our application
    completed, the final step was its deployment, and this is where we learned about
    creating a Git repository that has a README file with our documentation. In this
    step, we also put our application online so that it was publicly available for
    everyone to use.
  prefs: []
  type: TYPE_NORMAL
- en: With everything that we have absorbed, it’s safe to say that we have taken a
    huge leap forward in terms of learning and have become much more talented programmers
    in the process. We are now better prepared to tackle interviews as job seekers.
  prefs: []
  type: TYPE_NORMAL
