- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Powerful Angular Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Angular has built-in tools for everything you need to build robust web applications.
    In this chapter, you will learn about the newest and most powerful features in
    the Angular framework. We will also dive into Angular component communication,
    the router, and arguably the most important and powerful part of the Angular framework:
    dependency injection. By the end of this chapter, you will know how to inject,
    consume, provide, and adjust the hierarchy of dependencies, how to communicate
    between components, and how to effectively use the Angular router.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What makes Angular so powerful?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New features in the Angular framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A deep dive into the Angular router
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What makes Angular so powerful?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular sets itself apart from other popular frontend frameworks and libraries
    such as ReactJS and VueJS because it is strongly opinionated and has everything
    you need to develop complex web applications embedded in the framework itself.
  prefs: []
  type: TYPE_NORMAL
- en: Using Angular effectively ensures that there is a certain level of consistency
    and that best practices are implemented. This is because Angular makes many decisions
    for you, such as using TypeScript and relying on **object-oriented programming**
    (**OOP**) principles and built-in tools to handle common problems such as routing,
    HTTP requests, and testing! Because Angular has everything built into it, you
    don’t need to bring in a lot of external packages, reducing the surface for potential
    exploits or packages that stop being maintained. These aspects often make Angular
    the framework of choice when building complex frontend systems or enterprise software
    composed of multiple applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular comes packed with powerful and useful features for building web applications.
    If you are reading this book, you should already be familiar with the main features,
    but we will still mention the ones that are most essential to the framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Components and services**: Components and services are the building blocks
    of Angular applications. Components are used to develop reusable UI elements and
    pages comprised of these UI elements. Angular services are injected throughout
    your applications using dependency injection and communicate with backend APIs,
    handle state management, provide data, and implement business logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency injection**: Angular dependency injection is one of the fundamental
    concepts of the framework and is often regarded as its most powerful feature.
    Dependency injection allows you to inject values and logic throughout your applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Signals**: Signals are a new concept within the Angular framework that is
    used to define stateful properties. Angular tracks where and how the Signal values
    are used to optimize change detection, resulting in improved performance. Signals
    are also reactive, allowing you to automatically react when a Signal value changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTTP client**: The built-in HTTP client provides an elegant and intuitive
    interface for communicating with APIs and fetching data. With built-in features
    such as request and response interceptors, error handling, and observable-based
    responses, the Angular HTTP client is everything you need for handling HTTP logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`component` class and its corresponding template, facilitating data updates
    without manual intervention. In the Angular framework, data binding can be done
    in three ways: from the component class to the view by using the square bracket
    notation, from the view to the component class with events and the round bracket
    notation, and two-way data binding with the square and round bracket notation,
    also known as banana-in-a-box.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Router**: The Angular Router facilitates the creation of single-page applications
    with dynamic routing capabilities. It enables developers to define routes and
    associate them with specific components, allowing seamless navigation between
    different views and pages within the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Directives**: Angular directives are an essential building block of the framework
    and allow you to extend HTML elements with additional functionality and behavior
    or add and remove DOM elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pipes**: Pipes are used for transforming and formatting data within HTML
    templates. Using pipes helps to maintain clean and concise templates while avoiding
    excessive logic in the component code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Forms**: Forms are at the heart of each web application. Angular forms come
    in two types: **template-driven forms** and **reactive forms**. With features
    such as validation, error handling, and data synchronization, forms help you to
    develop robust applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These features are just some of the most powerful features the framework offers.
    Let’s move on and explore what the Angular team changed in the latest versions.
    The framework is changing rapidly, and new concepts and tools are being introduced
    to make Angular even more powerful and future-proof.
  prefs: []
  type: TYPE_NORMAL
- en: New features in the Angular framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The world of web development is evolving rapidly, and because of that, frameworks
    such as Angular have to keep growing to stay relevant. In this section, we will
    explore what’s new in the Angular framework and why these changes are being made.
  prefs: []
  type: TYPE_NORMAL
- en: Standalone components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Angular version 14, **standalone components** were introduced as a developer’s
    preview; version 15 released them for production usage. The Angular team introduced
    standalone components to simplify how we build Angular applications. Before standalone
    components, everything had to be declared in ngModules. Many developers dislike
    ngModules, and errors related to ngModules can be hard to resolve.
  prefs: []
  type: TYPE_NORMAL
- en: With standalone components, you can build applications without ngModules. Components,
    directives, and pipes can be marked as standalone, and then they don’t have to
    be declared in an ngModule.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [*Chapter 1*](B21625_01.xhtml#_idTextAnchor014), we made Nx generators for
    libraries and applications and applied the standalone flag for both. Because of
    that, when we generated our Angular applications, they were created with standalone
    components. Let’s look at the decorator from the `app.component.ts` file in your
    `expenses-registration` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you compare this to a non-standalone component, you might notice two things
    that are out of the ordinary: the `standalone` flag is set to `true`, the component
    becomes standalone. When something is standalone, it must import all its dependencies
    directly in the `imports` array instead of getting dependencies from an ngModule.
    For example, in `app.component.html`, we use the router outlet in the template,
    and because of that, the component needs to import `RouterModule`; you can also
    only import `RouterOutlet` instead.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also create applications without any ngModules. To do this, bootstrap
    the application with a standalone component instead of an ngModule. We need to
    look at our `main.ts` file to see how this is done. In an application that uses
    ngModules, you will find something like this in the `main.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this scenario, the Angular application bootstraps with the AppModule, the
    root ngModule. When you want to work without ngModules, you can change this and
    bootstrap with your root standalone component instead. If you look at the `main.ts`
    file of your *expenses-registration application*, you will find the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we use the `bootstrapApplication` function instead of `bootstrapModule`.
    We provide the `bootstrapApplication` function with a standalone component and
    a configuration object. This configuration object configures things such as routing,
    the HTTP client, and third-party modules. We will come back to this configuration
    object a couple of times. For now, remember you can configure application settings
    here when bootstrapping with a standalone component.
  prefs: []
  type: TYPE_NORMAL
- en: You can also mix ngModules with standalone components. If you have an application
    that already uses ngModules, you can start using standalone components alongside
    your existing code and leave your modules as-is.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand the basics of standalone components and how to use them,
    let’s explore the new `inject` function for dependency injection.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection using the inject function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another cool feature that was introduced in Angular 14 is the `inject` function,
    which is used as an alternative for constructor dependency injection. Up until
    now, constructor dependency injection was the only way to inject dependencies
    into your Angular applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `inject` function, we have an alternative approach that looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When we reach the *Dependency injection* section, we will dive deeper into
    this new syntax. For now, we will move on to the next new feature: directive composition.'
  prefs: []
  type: TYPE_NORMAL
- en: Directive composition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`component` decorator. Each time you use the component in a template, the configured
    directives will be applied automatically without adding the directive to the HTML
    element. You can also use directive composition inside other directives, resulting
    in a directive that applies multiple directives. In [*Chapter 3*](B21625_03.xhtml#_idTextAnchor058),
    we will dive deeper into the topic of directive composition.'
  prefs: []
  type: TYPE_NORMAL
- en: For now, you just need to know that you can configure directives inside the
    component decorators to share common behavior and reduce template complexity.
    Now that you know about directive composition, let’s explore Angular Signals a
    bit.
  prefs: []
  type: TYPE_NORMAL
- en: Angular Signals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Angular Signals** were introduced in Angular 16, and it’s one of the most
    significant changes for the framework since it went from AngularJS to Angular.
    In Angular 17, the framework also introduced Signal component inputs, and query
    Signals to query template elements using Signals. With Signals, we have a **reactive
    primitive** in the Angular framework with which we can manage the application
    state.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Signals allow you to declare, compute, mutate, and consume values reactively,
    meaning the Signal will automatically notify all consumers when the Signal’s value
    changes. Because Signals are reactive, you can automatically react when a Signal’s
    value changes, performing logic or updating other values when a Signal is set
    with a new value. Signals wrap around values and expose them through a getter,
    which allows the Angular framework to track who is consuming the Signal and notify
    the consumers when the value changes. Signals can wrap around simple values or
    complex data structures and can be writable or read-only. Here’s a straightforward
    example of a Signal and a computed Signal value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have a `count` `signal` value and a computed Signal
    that doubles the count. The computed Signal will automatically compute a new value
    when the `count` `signal` value changes. To better explain the advantages of Signals,
    let’s define what a reactive primitive is. In JavaScript, you have primitive and
    non-primitive values. The JavaScript primitives are `string`, `number`, `bigint`,
    `boolean`, `symbol`, `null`, and `undefined`. The non-primitives are objects.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript non-primitives are reference types, meaning that if you assign them
    to a new variable, you don’t create a new object but make a reference to the existing
    object. Primitives don’t work like that; if you assign a string to a new variable,
    it doesn’t hold a reference to the original variable but it does create a new
    string. Primitives are immutable, and non-primitives are mutable. This means you
    can change a non-primitive after it’s created. If you reassign a string, it’s
    a new string and not the same string with a different value. When you adjust an
    object, it remains the same object, only with different values.
  prefs: []
  type: TYPE_NORMAL
- en: A reactive primitive is an immutable value that alerts consumers when it’s set
    with a new value. All consumers can automatically track and react to changes in
    this reactive primitive.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The Signal itself is a reactive primitive and is immutable. You can only update
    the Signal and notify consumers of the Signal by using the `set()` or `update()`
    method on it.
  prefs: []
  type: TYPE_NORMAL
- en: Yet, the value held by the Signal is not immutable! So, if you use a non-primitive
    (an object or array) as a Signal value, you can still mutate the value without
    updating the Signal itself.
  prefs: []
  type: TYPE_NORMAL
- en: Because Signals are reactive primitives, the Angular framework can better detect
    changes and optimize change detection and rendering, resulting in better performance.
    Signals are the first step to an Angular version with fully fine-grained change
    detection that doesn’t need `Zone.js` to detect changes based on browser events.
    At the time of writing, Angular assumes that any triggered browser event handler
    can change any data bound to a template. Because of that, each time a browser
    event is triggered, Angular checks the entire component tree for changes because
    it can’t detect them in a fine-grained manner. This is a significant drain on
    resources and impacts performance negatively.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 7*](B21625_07.xhtml#_idTextAnchor129), we will dive deeper into
    Signals and look at different implementations and how you can combine them with
    RxJS. For now, you just need to know that Signals can be used to manage application
    state and that they introduce a reactive primitive, which can significantly improve
    the reactivity and performance of your Angular applications.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know what Signals are and why they are important, let’s learn about
    the new Angular control flow system.
  prefs: []
  type: TYPE_NORMAL
- en: Angular control flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The control flow system was introduced in Angular 17 and provides a new mechanism
    to show, hide, and repeat elements inside HTML templates. Until Angular 17, you
    could only use the `*ngIf`, `*ngFor`, and `*ngSwitch` directives to show, hide,
    or repeat elements inside the HTML templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'As of Angular 17, you can use both the directives and the new control flow
    system interchangeably. Let’s look at an example for each option using the new
    control flow syntax, starting with the `@if` control flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the new control flow syntax uses `@if`, `@else if`, and `@else`
    to define `if`-`else` statements inside your HTML templates. The new control flow
    syntax makes it a lot easier to create `if`-`else` statements. You can use both
    the control flow and the directive syntax, so pick whichever you and your team
    prefer. Now that you’ve seen an example of the `@if` control flow, let’s see how
    you can repeat elements inside the template using the new control flow syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@for` syntax can be used interchangeably with the `*ngFor` directive.
    The new control flow syntax requires you to define a `track` property. You assign
    the `track` property with a unique identifier such as an ID, which allows Angular
    to only re-render changed items when the list you are rendering changes. You can
    also provide an `@empty` block to display something when the array provided to
    the `@for` block is empty. Now that you know how to repeat elements inside your
    template with the new control flow syntax, let’s learn about the alternative for
    the `*``ngSwitch` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Just as with the other control flow blocks, you can use the `@switch` block
    interchangeably with the `*ngSwitch` directive. The new Angular control flow also
    introduced a new concept: the `@``defer` block.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@defer` block allows you to lazy-load components or native HTML elements
    inside your HTML templates. The `@defer` block can lazy load and display elements
    based on different triggers, such as when a condition is met, when the elements
    enter the viewport, when the users interact with the placeholder, or based on
    a timer. The `@defer` block can improve your performance because fewer components
    have to be loaded when the user lands on a page. Additionally, the `@defer` block
    reduces the bundle sizes as lazy-loaded page elements don’t have to be included
    in the initial application bundle. Here’s an example of the `@defer` block with
    a placeholder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now that you know about the new control flow syntax, let’s explore the remainder
    of the features that were introduced by the Angular framework.
  prefs: []
  type: TYPE_NORMAL
- en: Other noteworthy new Angular features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we move on to the next section of this chapter, we will briefly go over
    other noteworthy improvements that have been made to the Angular framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Types forms**: In Angular 14, reactive forms were made fully type-safe. The
    values inside form controls, groups, and arrays are now type-safe across the entire
    API of reactive forms, enabling safer forms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title` property to your route configurations. This `title` property will set
    the page title without other implementations needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NgOptimizedImage` is a built-in image directive for optimized image fetching,
    rendering, and sizing. It has been stable for usage since Angular 15.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functional approach**: Since Angular 15, you can use a functional approach
    for HTTP interceptors, route resolvers, and route guards.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Route parameter mapping**: This feature allows you to automatically map route
    data, query parameters, and path parameters to your component inputs. Because
    of this, you don’t have to subscribe anymore, reducing complexity and boilerplate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnDestroy` injectable, which allows you to inject `DestroyRef` and access
    the `OnDestroy` life cycle hook more flexibly. It allows you to subscribe to the
    `OnDestroy` life cycle as well as inject it outside of your components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Self-closing tags**: In Angular 16, you can use a self-closing tag for your
    component selectors. This can improve the readability of your HTML templates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Required inputs**: In Angular 16, you can make component inputs *required*.
    If no input is provided in the template, the compiler will specify an error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are more newly added features, such as Vite support and better page hydration,
    but the ones we mentioned in this section are the most important for your daily
    development practices.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know about the new features that have been added to the Angular
    framework, we will move on and do deep dives into specific topics, starting with
    the Angular router.
  prefs: []
  type: TYPE_NORMAL
- en: A deep dive into Angular routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will teach you about the **Angular router**, a powerful tool that
    handles navigation in your Angular applications. The router is responsible for
    seamless transitions without full page loads, updating the browser URL, as well
    as handling route data, redirects, query parameters, path parameters, route resolvers,
    and guarding routes from unauthorized visitors.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by creating two new components we can navigate to.
  prefs: []
  type: TYPE_NORMAL
- en: Creating new components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to use an Nx generator for this. You can write a custom generator,
    but I will use the built-in component generator for now. Right-click on the `app`
    folder inside your `expenses-registration` folder and select the Nx console. In
    the dropdown, search for `component` and select **@nx/angular -** **component**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to generate the necessary components:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `pages/expenses-overview-page`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the **standalone** checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Show** **all options**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **changeDetection** select box, select **OnPush**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the top-right corner, click **Generate**.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve completed these steps, repeat the same steps for creating the second
    component. You will only change the name to `pages/expenses-approval-page`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s serve the*finance-expenses-registration application* with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You can also use the Nx console to serve your application. Just select the application
    under the **PROJECTS** tab and click on the **play** button after hovering over
    **serve**.
  prefs: []
  type: TYPE_NORMAL
- en: When you open the application at `http://localhost:4200/`, you’ll see a white
    screen. This is because you only have a router outlet in your `app.component.html`
    file, which displays the current route, and no routes have been configured for
    our application yet.
  prefs: []
  type: TYPE_NORMAL
- en: Your application is running, and two components are ready to route to, so let’s
    configure some routes for your application.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring routes in Angular applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before `RouterModule` and providing it with routes in a `forRoot` or `forChild`
    method. Because we’re using the latest Angular techniques, we won’t use ngModules.
    When bootstrapping with a standalone component, your routing is configured differently.
    When you open the `main.ts` file, you’ll see an `appConfig` object being passed
    to the `bootstrapApplication` function. Open your `app.config.ts` file to locate
    this `appConfig` object. Inside, you’ll find your routing configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Routing is configured by adding the `provideRouter` function inside the `providers`
    array of the `ApplicationConfig` object. When Nx created the application, it already
    set this up for us.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `provideRouter` function, you’ll find an array of `Route` objects
    and a `with` **EnabledBlockingInitialNavigation** function, which is required
    for routing with server-side rendering. We aren’t using server-side rendering,
    so you can delete `with``EnabledBlockingInitialNavigation`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your `app.routes.ts` file to set up the routes for your application. To
    start, we will add two `Route` objects inside the `appRoutes` array – one for
    the expenses approval page and another for the expenses overview page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, each object has two properties: a `path` property to define
    the URL path and a `component` property for specifying the loaded component when
    we reach the path. For `ExpensesOverviewPageComponent`, we configured `expenses-overview`,
    which means it’s accessible at `http://localhost:4200/expenses-overview`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you navigate to this URL, you’ll see `Router` as a dependency. Then, you
    can use this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can navigate instead your HTML templates with `routerLink`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now that you’ve configured two routes, let’s explore what else you can configure
    in your route configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Route configuration options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, you will make your routing more robust and explore properties
    you can configure on your route objects.
  prefs: []
  type: TYPE_NORMAL
- en: Adding page titles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `title` property was added in Angular 14 and is used to set HTML page titles
    dynamically. Before Angular 14, you needed subscriptions and a lot of logic to
    set the page title. With the introduction of the `title` property, Angular handles
    all of that behind the scenes and sets the page title for you. You can set your
    titles with a simple string or `ResolveFn<T>`. When you use a string, you can
    use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use `ResolveFn<T>` to set page titles dynamically, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a simple example where we take the route path and replace the hyphen
    with a space, but you can add any logic you want. Once you’ve defined your title
    resolver, you can assign it to your route configuration like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also overwrite the default behavior Angular uses to add the titles
    to your pages by overwriting the `TitleStrategy` class. This is only useful in
    edge cases, but it’s good to know it’s possible. We won’t cover an example in
    this book, but you can find a simple overwrite of `TitleStrategy` in this book’s
    GitHub repository: [https://github.com/PacktPublishing/Effective-Angular/blob/main/apps/finance/expenses-registration/src/app/app.routes.ts](https://github.com/PacktPublishing/Effective-Angular/blob/main/apps/finance/expenses-registration/src/app/app.routes.ts).'
  prefs: []
  type: TYPE_NORMAL
- en: Lazy loading standalone components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`loadComponent` property in your route configuration.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Angular 15, the router also supports automated unwraps of default imports.
    With automated unwraps, you don’t need the `.then()` method to be chained to unwrap
    your import for the router. Because of this, we can make the syntax for lazy loading
    shorter and easier. Change your routes to lazy-loaded routes by changing the export
    of your component classes to `default` exports, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you’ve done this, you can configure lazy-loaded routes like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Do the same for your other route so that all your routes are lazy-loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will learn how to use multiple router outlets and auxiliary routes.
  prefs: []
  type: TYPE_NORMAL
- en: Router outlets and auxiliary routes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to develop dynamic user interfaces while reducing your bundle sizes
    even more, **named router outlets** are a great way to achieve this. We won’t
    implement named router outlets, but I do want to explain how they work.
  prefs: []
  type: TYPE_NORMAL
- en: 'With named router outlets, you can lazy load specific sections of your pages
    and lazy load different components for these page sections based on your application
    state. You can, for example, display different sidebars on each page or even on
    the same page based on application states. Because you can lazy load these sidebar
    components, they will not be part of your main application bundle and will only
    be loaded when displayed. To use named router outlets, you need to configure a
    route with an `outlet` property, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: <router-outlet name="sidebar"><router-outlet/>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'this.router.navigate([''path'', { outlets: { sidebar: ''path''} }]);'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[routerLink]="[''path'', { outlets: { sidebar: ''path''} }]"'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '{ path: ''……'', loadComponent: ……,'
  prefs: []
  type: TYPE_NORMAL
- en: 'canActivate: [IsLoggedInGuard, IsAdminGuard],'
  prefs: []
  type: TYPE_NORMAL
- en: 'canDeactivate: [hasDoneSomeTaskGuard] },'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '{ path: ''dashboard'', component: DashboardComponent,'
  prefs: []
  type: TYPE_NORMAL
- en: 'children: [{ path: ''summary'', component: SummaryComponent }]}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '{ path: ''**'', component: NotFoundComponent }'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '{ path: '''', pathMatch: ''full'', redirectTo: ''/expenses-overview'' }'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'export const userDataResolver: ResolveFn<User> = ('
  prefs: []
  type: TYPE_NORMAL
- en: 'route: ActivatedRouteSnapshot) => inject(UserService)'
  prefs: []
  type: TYPE_NORMAL
- en: .getUserData(route.paramMap.get("userId")).catch(……);
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '{ path: ''path'', resolve: productResolver, component: ……},'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: protected readonly route = inject(ActivatedRoute)
  prefs: []
  type: TYPE_NORMAL
- en: ngOnInit() { this.route.snapshot.data; }
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: export * from './lib/navbar/navbar.component';
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'export interface NavbarItem {label: string; route: string;}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '@Input() is a decorator for the navbarItems field that tells the Angular compiler
    that the property can receive input from parent components. We gave the field
    a NavbarItem array type and an empty array’s default value. If you don’t give
    it a default value, the compiler will start to complain; you can prevent this
    by adding an exclamation mark after the property’s name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'navItems: NavbarItem[] = [navItems array to the navbar component using the
    navbarItems input property. We can do this in the HTML template of the app component,
    where we declare the HTML selector tag for the navbar component. You can pass
    the navItems array as input using this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: On the left-hand side, between the square brackets, you’ll use the property
    name of the input property that’s declared inside the `navbar` component – in
    our case `navbarItems`. On the right-hand side, you must assign the input with
    a value that’s declared in the parent component – in our case, the `navItems`
    array.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to know that when a component receives input values, the `ngOnChanges`
    life cycle hook is triggered – once this component has been created, before the
    `ngOnInit` life cycle hook runs, and then once more every time an input receives
    a new value. You can access the previous and new input values inside the `ngOnChanges`
    method like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The current value inside the `SimpleChanges` object should be equal to the value
    of the input property declared in the component. So, if you need the current value,
    you can also access the component property. In our example, this would be `navbarItems`.
  prefs: []
  type: TYPE_NORMAL
- en: The `ngOnChanges` life cycle hook is a good place to perform extra logic when
    you receive an input value. Still, this can become messy when you have a lot of
    input properties and want to perform logic for each when they receive a new value.
    If this is the case, or if you want to transform the value into something else,
    you can use the `@Input()` decorator as a getter and setter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say we want to add `NavbarItem` for the home page to our input each time
    it receives values so that we don’t have to declare the home page and its route
    inside the object we pass as input to the `navbar` component. We can do this by
    transforming the input into an input with a getter and setter. Start by adding
    a private property to the `navbar` component, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, change the `navbarItems` input property to a getter and setter and use
    the private property inside the getter and setter, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '@Input({addHome with the transformation logic. You can add this function to
    a separate file or the same file underneath the navbar component class. The function
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: That’s all you need; no more private property or getter and setter needed for
    transforming input values! If you need to perform other logic, such as setting
    component properties or running functions inside the `component` class, you can
    still use the getter and setter approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, since Angular 16, you can also make input properties required. When
    you make an input property required, it needs to be declared on the HTML tag when
    the component is used in a component’s template. The parent that’s using the component
    in its template must add the input property to the HTML tags and pass it a valid
    value; otherwise, the compiler will throw an error. To make our `navbarItem` input
    property required, we can change the input decorator like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '@output decorator and the property name for our EventEmitter. On the right-hand
    side, we assign the property with new EventEmitter, and between the arrow symbols
    we add the type we wish to emit – in this example, this is tableData.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you need to listen for the `dataChanged` event in the HTML template of
    a parent component where the data table component would be defined. Listening
    for `@Output` works the same as listening for regular DOM events such as *click*
    and *mouseleave*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'this.dataChanged.dataChanged property and call the .emit() method on it. You
    can pass whatever value you want to emit to the parent component inside the brackets.
    In this example, that would be the updated table data. To better illustrate how
    the input and output mechanism works, *Figure 2**.1* shows how data flows from
    the parent to the child and vice versa:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1: Hierarchical dependency creation](img/B21625_02_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: Hierarchical dependency creation'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you also know how to emit events to the parent component using the
    `@output` decorator, let’s explore how we can combine the input and output decorators
    to create custom two-way data bindings.
  prefs: []
  type: TYPE_NORMAL
- en: Two-way data binding using @Input and @Output
  prefs: []
  type: TYPE_NORMAL
- en: '`select` drop-down component with two input properties, one for the select
    options and one for the selected option. Besides this, the component also has
    a `selectionChanged` output to emit a value when a new selection is made.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the parent component, we have a property for the currently selected value
    of the select component. This property is used as an input for the selected input
    and needs to be updated whenever a new value is selected and the `selectionChanged`
    output is emitted. To achieve this, you must have something like the following
    inside the template of the parent component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We can improve the preceding code snippet with two-way data binding and the
    banana-in-a-box syntax. For two-way data binding to work, the input and output
    properties in the child component must have the same name; only the output needs
    to add `changed` after the name. So, in our example, the input is named `selected`,
    which means the output needs to be named `selectedChanged`. When we use this naming
    convention, Angular knows to handle it as two-way data binding.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use two-way data binding, in the parent component, we must update the HTML
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: <select [(selected)]= "selectedValue" />
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: <select [selected]= "selectedValue" (selectedChanged)="this. selectedValue =
    $event" />
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '@ViewChild(NavbarComponent) navBar!: NavbarComponent;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: this.navBar.navbarItems;
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'const routes = [{ path: ''dashboard/:id'','
  prefs: []
  type: TYPE_NORMAL
- en: 'component: DashboardComponent,'
  prefs: []
  type: TYPE_NORMAL
- en: 'data: {caption: ''Dashboard caption''},'
  prefs: []
  type: TYPE_NORMAL
- en: 'resolve: {permissions: DashboardResolver}}]'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: private route = inject(ActivatedRoute);
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: this.route.snapshot.paramMap.get('id');
  prefs: []
  type: TYPE_NORMAL
- en: this.route.snapshot.queryParamMap.get('queryParam');
  prefs: []
  type: TYPE_NORMAL
- en: this.route.snapshot.data['caption'];
  prefs: []
  type: TYPE_NORMAL
- en: this.route.snapshot.data['permissions'];
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: this.route.queryParamMap.subscribe(……)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'provideRouter(appRoutes, component class, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to use a different property name, you can alias the inputs like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This will probably give you a linting error because aliasing inputs is not recommended,
    but when using input aliases for binding your route data, it’s not a bad practice.
    So, in this case, you can disable the linting rule if it’s throwing an error.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know everything about component communication using decorators
    and route data, we will start to look at dependency injection, which can be used
    to provide data to every part of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection
  prefs: []
  type: TYPE_NORMAL
- en: '`@Injectable()` decorator), but they can be strings, functions, or anything
    else you want to provide throughout your application.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Injector` abstraction is the core element of the Angular dependency injection
    system and facilitates the connection between providers and consumers of your
    dependencies. Make sure you distinguish `Injector` from the `@Injectable()` decorator,
    which marks a class as a candidate for dependency injection. The `Injector` abstraction
    checks if an instance of a dependency has already been created and provides it
    if the dependency has already been registered; it provides the dependency and
    registers if it hasn’t been registered before. When your application is bootstrapped,
    Angular creates an application-wide *root* `Injector` and makes other injectors
    as needed for all dependencies that aren’t accessible throughout the application.
  prefs: []
  type: TYPE_NORMAL
- en: Providing dependencies
  prefs: []
  type: TYPE_NORMAL
- en: You can provide classes and other values such as strings, dates, objects, and
    functions as dependencies. Both are provided differently. We will start with the
    most common use case, which is providing classes.
  prefs: []
  type: TYPE_NORMAL
- en: Providing classes as dependencies
  prefs: []
  type: TYPE_NORMAL
- en: 'When you provide a class in Angular, it’s most likely an Angular service, but
    you can provide any class through dependency injection. The most common way to
    prepare a class for dependency injection is to decorate it with the `@Injectable()`
    decorator, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@Injectable()` decorator shows a class is used for dependency injection;
    you can do this by marking it as a root injector or by adding it inside a `providers`
    array of a specific component or ngModule. The `@Injectable()` decorator also
    ensures Angular can perform optimizations such as tree shaking. You can also provide
    classes without the `@Injectable()` decorator inside your `providers` array, but
    it’s a good practice to mark them with the decorator unless you need to provide
    the classes in a specific place. Here’s an example of how to provide a service
    inside the `providers` array of a component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'When using the component-level `providers` array, the provided dependency becomes
    available for dependency injection for each component instance and all child components
    or directives used within the component’s tree. If you add a dependency inside
    the `providers` array of an ngModule, the dependency can be injected and accessed
    everywhere within that module. You can declare classes inside the `providers`
    array of your modules like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'In our *expenses-registration application*, we don’t have ngModules. When developing
    an Angular application without ngModules, you can provide dependencies inside
    your `ApplicationConfig` object; this is similar to marking a dependency as a
    root injector because it will be available for dependency injection throughout
    your application. Adding classes to your `providers` array inside the `ApplicationConfig`
    objects works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, the most common way to provide your classes as dependencies is by marking
    the class as a *root* injector. You can do this inside the `@Injectable()` decorator
    with the `providedIn` property, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'providers: [{ provide: Logger, useClass: Logger }]'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'providers: [Logger]'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'providers: [{ provide: Logger, useClass: BetterLogger }]'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'providers: [ BetterLogger,'
  prefs: []
  type: TYPE_NORMAL
- en: '{ provide: Logger, BetterLogger and Logger tokens. Both will provide the same
    instance of the service. Be careful not to use the useClass definition for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'const DashboardServiceFactory = (userService: UserService) => userService.user.isAdmin
    ? new AdminDashboardService() : new DashboardService();'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '{ provide: DashboardService,'
  prefs: []
  type: TYPE_NORMAL
- en: UserService to check if the current user is an admin user. Because of this,
    you need to add UserService inside a deps array of your provider object.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know more about `useFactory`, let’s export `useValue`.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring provider objects with useValue
  prefs: []
  type: TYPE_NORMAL
- en: 'The `useValue` provider definition is the simplest one. It returns a constant
    value such as a string, date, or Boolean. It’s useful for providing things such
    as a base website URL, base API URLs, or other constant values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'export const BASE_URL = BASE_URL – and assign it with new InjectionToken. The
    value between the arrow brackets is the type of your dependency – in this example,
    a string – and the value between the round brackets is a description for your
    InjectionToken. Now, you can use this InjectionToken in a provider object like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'When assigning a provider token, you can also use a simple string like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'constructor(private logger: LoggerService) {}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'private logger = InjectionToken as a provider token. The syntax to do this
    is slightly different in the case of constructor injection. You need to use the
    @Inject() decorator function inside your constructor like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: private logger = inject(LoggerService);
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: inject function, why you should use it instead of contractor injection, and
    where to declare the inject function.
  prefs: []
  type: TYPE_NORMAL
- en: Using the inject function for better dependency injection
  prefs: []
  type: TYPE_NORMAL
- en: 'The `inject` function is more flexible than constructor injection because it
    can be used in more places and works better when using inheritance. You can declare
    the `inject` function anywhere, but it needs to run inside the *injection context*;
    otherwise, you’ll get an error. The injection context is inside the constructor
    of a class, where you initialize fields inside a class inside the factory function
    of `useFactory`, route guards, route resolvers, and HTTP interceptors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'One of the main advantages of the `inject` function is that it allows you to
    abstract logic into a function. Let’s say you want to fetch dashboards; you can
    abstract this logic into a separate function using the `inject` function. To do
    this, you can create a function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we use an arrow function. Because we don’t use brackets, the arrow function
    directly returns what we write after the arrow. This is the same as writing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: export default class DashboardsListComponent {
  prefs: []
  type: TYPE_NORMAL
- en: dashboards$ = fetchDashboards();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: <h1 *ngFor="let dashboard of (dashboards$ | async)">
  prefs: []
  type: TYPE_NORMAL
- en: '{{dashboard.title}}'
  prefs: []
  type: TYPE_NORMAL
- en: </h1>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'return component class, you must assign this closure function to a property,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The `fetchDashboards` function returns another function, and because of that,
    the `_fetchDashboards` property is also a function. This `_fetchDashboards` function
    now holds the function that returns the observable HTTP call for fetching the
    dashboards and can be used anywhere in your class, also outside the injection
    context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Before converting the `fetchDashboards` function so that it can use closure,
    it can’t be used inside the `loadDashboards` function of the component because
    this is outside the injection context. By using a closure and returning the function
    to a property in our injection context, we can now use the function to fetch the
    dashboards outside the injection context. Using this pattern allows for great
    abstraction of logic and functions with a single responsibility that can be shared
    throughout your application while keeping component classes simple and clean.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides abstracting logic into dedicated functions, the `inject` function offers
    some advantages when working with inheritance. When using dependency injection
    in both the base class and the class inheriting from the base class, you need
    to call `super()` and pass the dependencies to the base class. Here’s a simple
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling `super()` and passing along dependencies can become a hindrance and
    look messy. With the `inject` function, you can prevent this. By using the `inject`
    function in both classes, you don’t have to pass along anything or call the `super()`
    method anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, you don’t have to pass along `router` to the base service,
    and there is no need for the `super()` call anymore; that looks much cleaner!
    Let’s say you only used the router for navigation inside the base class. In that
    case, you can even take it a step further and abstract the navigation functionality
    into a separate closure function, as we did before, with the `fetchDashboards`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we’re using an arrow function that returns another arrow function,
    we can use `_navigateFn` outside the injection context. Inside the service that
    inherits the base class, you can navigate using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Now that you know why, when, and how to use the `inject` function instead of
    constructor injection, let’s explore how dependency injection creates instances
    of the injected services and what hierarchical injectors are.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency instances, injector hierarchy, and resolution modifiers
  prefs: []
  type: TYPE_NORMAL
- en: The last thing you need to learn is how Angular creates instances of the dependencies
    you inject, how the **injector hierarchy** works, and how to control it with **resolution
    modifiers**.
  prefs: []
  type: TYPE_NORMAL
- en: Each time you inject a dependency, Angular will check how the dependency is
    provided, starting at the lowest level of the injector hierarchy – the `providers`
    array inside your component or directive. If Angular can’t find a provider, it
    will start to move up in the injector hierarchy, first to the parent components;
    if it can’t find the provider in any of the parent components, Angular will check
    the ngModule of the component or your `ApplicationConfig` object in case you don’t
    use ngModules. If Angular can’t find a provider in the ngModules, it will look
    in the root injector for a service with the `@Injectable` decorator and `providedIn`
    root. If Angular still can’t find a provider for the inject dependency, Angular
    will throw an error. If you inject a dependency in a service, Angular will skip
    the component hierarchy steps.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say we want to inject `LoggerService` as a dependency. When Angular finds
    the provider for `LoggerService`, it will check if the injector already created
    an instance of `LoggerService` at the hierarchy level where the provider was located.
    If the injector already made `LoggerService` for the given hierarchy level, it
    will return the created instance. Otherwise, it will create one and then return
    it. For each hierarchy level, a singleton instance will be created and shared
    by all consumers on the lower hierarchical levels. If two or more sibling components
    declare a provider, a singleton will be created for each provider, and each component
    will use its own singleton of `LoggerService` and share it with all its subsequent
    child components and directives.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2**.2* depicts how hierarchical dependencies are created and shared:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2: Hierarchical dependency creation](img/B21625_02_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: Hierarchical dependency creation'
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how Angular dependency injection creates and shares dependencies allows
    you to provide the correct instance to all application sections. If you want a
    singleton to be shared among all dependency consumers in the application, you
    just need to provide the dependency in the root injector. In some more complex
    and edge cases, you need to be able to have more control over how Angular looks
    for providers. In this scenario, you can adjust the behavior with resolution modifiers.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four resolution modifiers you can apply to your injected dependencies.
    Each has its own function and how you apply these modifiers differs depending
    on if you use constructor injection or the `inject` function. Let’s examine these
    four resolution modifiers and what they do:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Optional()`: The `@Optional()` modifier makes sure a dependency is optional.
    Angular won’t throw an error if it can’t find a provider for the given dependency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@SkipSelf()`: With the `@SkipSelf()` modifier, you tell Angular it should
    start looking for a provider in the first parent in the dependency hierarchy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Self()`: The `@Self()` modifier tells Angular to only look at the component
    or directive itself for the provider.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@Host()`: The `@Host()` property marks a component as the last step in the
    search for a provider, even if there are more components higher up in the tree.
    When the `@Host()` property is found, Angular stops looking for the dependency
    provider.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that you know what resolution modifiers are available and what they do,
    let’s see how you can apply them to dependencies. When you want to apply a resolution
    modifier to a dependency that’s been injected with constructor injection, you
    can use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'logger = inject(Logger, {optional: true, self: true});'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: export * from './lib/services/expenses.service';
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
