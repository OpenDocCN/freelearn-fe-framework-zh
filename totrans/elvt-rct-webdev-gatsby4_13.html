<html><head></head><body>
		<div id="_idContainer070">
			<h1 id="_idParaDest-139"><em class="italic"><a id="_idTextAnchor141"/>Chapter 10</em>: Creating Gatsby Plugins</h1>
			<p>In this chapter, we will look at Gatsby's plugin ecosystem. We'll start by learning how to make our Gatsby site more modular as it grows. We will then create our first source plugin to fetch data from GitHub. We will also create our first theme plugin to create events pages for our website. Finally, we will learn how to share our plugins with the world via Gatsby's plugin ecosystem.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Understanding Gatsby plugins </li>
				<li>Introducing local plugin development</li>
				<li>Creating source plugins</li>
				<li>Creating theme plugins</li>
				<li>Contributing to the plugin ecosystem</li>
			</ul>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor142"/>Technical requirements</h1>
			<p>To complete this chapter, you will need to have completed <a href="B15983_09_ePub_RK.xhtml#_idTextAnchor127"><em class="italic">Chapter 9</em></a>, <em class="italic">Deployment and Hosting</em>. You will also need a GitHub account.</p>
			<p>The code for this chapter can be found at <a href="https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter10">https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter10</a>.</p>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor143"/>Understanding Gatsby plugins </h1>
			<p>By this stage in this book, you should have all the tools you need to get a Gatsby site into production. In this <a id="_idIndexMarker547"/>chapter, we are going to go one step further and talk about creating reusability across multiple Gatsby sites using something called <strong class="bold">Gatsby plugins</strong>. Gatsby plugins are node packages that abstract common site functionality that utilizes Gatsby APIs. By bundling functionality into a plugin, you can source data, create pages, implement SEO, and so much more with just a few lines. Gatsby plugins also <a id="_idIndexMarker548"/>act as a way to modularize larger sites into more manageable chunks of functionality. </p>
			<p>The two most common types of plugins are as follows:</p>
			<ul>
				<li><strong class="bold">Gatsby Source Plugins</strong>: Source plugins allow you to gather data from a data source and ingest it into <a id="_idIndexMarker549"/>Gatsby's GraphQL data layer. You could source data from anywhere, such as APIs, RSS feeds, or CMSes, as we did in <a href="B15983_03_ePub_RK.xhtml#_idTextAnchor057"><em class="italic">Chapter 3</em></a>, <em class="italic">Sourcing and Querying Data </em><em class="italic">(from Anywhere!)</em>. Once data has been ingested into your GraphQL data layer, you can query it from within your <strong class="source-inline">gatsby-node.js</strong> file, as well as within your pages.</li>
				<li><strong class="bold">Gatsby Theme Plugins</strong>: Theme plugins focus more on the user interface of your application. Often, theme plugins contain code that creates pages of a site, such as <a id="_idIndexMarker550"/>an FAQ section. They act to split your Gatsby site into smaller manageable projects, which can be very useful when you have multiple teams working on the same site.</li>
			</ul>
			<p>These two types can be identified by the plugin name, which will either begin with <strong class="source-inline">gatsby-source</strong> or <strong class="source-inline">gatsby-theme</strong>. While these two types are the most common, they are not the only types. Plugins that encapsulate any other functionality have a plugin name that begins with <strong class="source-inline">gatsby-plugin</strong>. </p>
			<p>Before we dive in and start creating plugins, let's learn about local plugin development so that we can avoid common pitfalls.</p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor144"/>Introducing local plugin development</h1>
			<p>Local plugin development begins with a new folder called <strong class="source-inline">plugins</strong>, which you need to create within your root directory. This is the folder that will house the plugins we create. When you add a plugin <a id="_idIndexMarker551"/>to your Gatsby config, Gatsby first looks within your <strong class="source-inline">node_modules</strong> folder. If it cannot find a plugin there, it will check within this local <strong class="source-inline">plugins</strong> folder. If it finds a plugin here with the same name within its <strong class="source-inline">package.json</strong> file, it will use it.</p>
			<p>As you may have guessed by the mention of a <strong class="source-inline">package.json</strong> file, plugins come in the form of npm packages. npm packages take care of their dependencies, so it is important that, when you're installing packages for use in a plugin, you make sure that you open the terminal within <a id="_idIndexMarker552"/>the plugin's folder and not the root directory. Otherwise, your site and plugin dependencies may be inaccurate.</p>
			<p class="callout-heading">Quick Tip</p>
			<p class="callout">If you don't have any intention of ever sharing the plugins you create, you can choose to install dependencies that your plugins require in the root directory instead. This can be easier to manage if you prefer having one source of truth for your dependencies. But be careful – <em class="italic">if you think the plugin could be shared at any point, do not do this</em>, as you will have to manually sort through your dependencies and find those that the plugin requires. </p>
			<p>While creating local plugins, you may find that your code does not behave like the rest of your project. Let's look at how we can debug common issues.</p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor145"/>Debugging local plugins</h2>
			<p>Gatsby does not treat the local plugins folder the same as the rest of the code base. Changes to pages, templates, and configs may not necessarily appear while hot reloading. Here <a id="_idIndexMarker553"/>are a couple of tips to make your life a little easier:</p>
			<ul>
				<li>If you make a change and do not see it reflected, even after restarting the server, try clearing the cache using <strong class="source-inline">gatsby clean</strong>. Gatsby caches plugin data in the <strong class="source-inline">.cache</strong> folder. To make itself faster, Gatsby uses this cache.</li>
				<li>If you are unsure whether your plugin is even being run, try adding the following command to your plugin's <strong class="source-inline">gatsby-node.js</strong> file:<p class="source-code">exports.onPreInit = () =&gt; console.log("Plugin</p><p class="source-code">Started!")</p><p>This command will run first during Gatsby's execution. If Gatsby is aware of your plugin, you will see <strong class="bold">Plugin Started!</strong> logged to the console.</p></li>
			</ul>
			<p>Now that we know when it's a good idea to make plugins, let's learn how we can create them.</p>
			<h1 id="_idParaDest-144"><a id="_idTextAnchor146"/>Creating source plugins</h1>
			<p>As we mentioned in the <em class="italic">Understanding Gatsby plugins</em> section, source plugins are those that allow us to ingest data from a new source into our GraphQL layer. By creating a source plugin, we <a id="_idIndexMarker554"/>abstract the logic to source this data away from our site so that we can reuse it across multiple Gatsby projects if we want to. To understand how source plugins work, let's build one together. Let's source our total contributions from GitHub so that we can display them on our <strong class="bold">about</strong> page:</p>
			<ol>
				<li>The first thing we need to be able to do to pull data from GitHub is use an access token. Navigate to <a href="https://github.com/settings/tokens/new">https://github.com/settings/tokens/new</a>.</li>
				<li>Write a <strong class="bold">Note</strong> to help you identify your access token later:<div id="_idContainer066" class="IMG---Figure"><img src="image/Figure_10.01_B15983.jpg" alt="Figure 10.1 – GitHub personal access token generation&#13;&#10;"/></div><p class="figure-caption">Figure 10.1 – GitHub personal access token generation</p></li>
				<li>Change the <strong class="bold">Expiration</strong> property to your desired length. Once the length of time has been <a id="_idIndexMarker555"/>selected, the token will be deleted and no longer work. If you prefer that it doesn't expire, you can select <strong class="bold">No Expiry</strong> from this list.</li>
				<li>Scroll down the list and check <strong class="bold">read:user</strong>:<div id="_idContainer067" class="IMG---Figure"><img src="image/Figure_10.02_B15983.jpg" alt="Figure 10.2 – GitHub personal access token generation (continued)&#13;&#10;"/></div><p class="figure-caption">Figure 10.2 – GitHub personal access token generation (continued)</p></li>
				<li>Click <strong class="bold">Generate token</strong>.</li>
				<li>On the next screen, you will be presented with your access token – make a note of this immediately as you will not be able to see it again. <p class="callout-heading">Important Note</p><p class="callout">If you ever lose your access token, you will not be able to see it again. GitHub does this to prevent your key being used by someone else for malicious purposes. In an instance where you do lose your key, you will have to create a new one with the same scopes and replace the token wherever it was being used.</p></li>
				<li>Create a <strong class="source-inline">.env</strong> file in your root directory and add the following line:<p class="source-code">GITHUB_PROFILE_BEARER_TOKEN=your-token-here</p><p>You may already have a <strong class="source-inline">.env</strong> file within your project at this point. If this is the case, simply <a id="_idIndexMarker556"/>append the preceding code block line to that file. </p></li>
				<li>Ensure that <strong class="source-inline">dotenv</strong> is installed as a dependency at the root of your project. If it is not, run the following command:<p class="source-code"><strong class="bold">npm i dotenv</strong></p></li>
				<li>Create a new folder called <strong class="source-inline">gatsby-source-github-profile</strong> in your <strong class="source-inline">plugins</strong> folder.</li>
				<li>Open a terminal in the <strong class="source-inline">gatsby-source-github-profile</strong> folder and run the following command:<p class="source-code"><strong class="bold">npm init -y</strong></p><p>This initializes an npm package for our plugin.</p></li>
				<li>Install the <strong class="source-inline">node-fetch</strong> package:<p class="source-code">npm i node-fetch@2.6.5</p><p>The <strong class="source-inline">node-fetch</strong> package brings the <strong class="source-inline">fetch</strong> browser API to <strong class="source-inline">node</strong>. I've used it in this example as I suspect most of you will be familiar with <strong class="source-inline">fetch</strong>, as this book is aimed at React developers.</p><p class="callout-heading">Important Note</p><p class="callout">Node Fetch is ESM only from version 3.0. This means it will not play nicely with the ES5 format that's being used in our Gatsby configuration files. The maintainers suggest using version 2.6.5 in our case.</p></li>
				<li>Create a <strong class="source-inline">gatsby-node.js</strong> file in your <strong class="source-inline">gatsby-source-github-profile</strong> folder and add the following code to it:<p class="source-code">const fetch = require("node-fetch");</p><p class="source-code">const crypto = require("crypto");</p><p class="source-code">/* </p><p class="source-code">  Code added here in the next step</p><p class="source-code">*/</p><p>Here, we are importing <a id="_idIndexMarker557"/>our most recent install, <strong class="source-inline">node-fetch</strong>, and the <strong class="source-inline">crypto</strong> library (which comes with node) into our project. <strong class="source-inline">crypto</strong> provides cryptographic functionality, which we will be using later in this file.</p></li>
				<li>Under your imports, add the following code:<p class="source-code">exports.sourceNodes = async ({ actions },</p><p class="source-code"> configOptions) =&gt; {</p><p class="source-code">  const { createNode } = actions;</p><p class="source-code">  /* </p><p class="source-code">    Code added here in the next step</p><p class="source-code">  */</p><p class="source-code">};</p><p>Here, we are utilizing the <strong class="source-inline">sourceNodes</strong> Gatsby node API. As its name suggests, we will add code here that sources our data and then creates nodes using the <strong class="source-inline">createNode</strong> action. You may have also noticed that we are passing <strong class="source-inline">configOptions</strong> into this as an argument. This object gives us access to any of the options we provide to the plugin when we use it in our <strong class="source-inline">gatsby-config.js</strong> file. We are going to be passing our access token and username as options.</p><p class="callout-heading">Quick Tip</p><p class="callout">To improve the understandability of this file, it's been broken down into its parts. If you are finding it hard to follow, you can see the file in its entirety within the repository listed in the <em class="italic">Technical requirements</em> section of this chapter.</p></li>
				<li>Create a <strong class="source-inline">POST</strong> request, like the <a id="_idIndexMarker558"/>following, inside <strong class="source-inline">sourceNodes</strong> for the GitHub API:<p class="source-code">  const headers = {</p><p class="source-code">    Authorization: 'bearer ${configOptions.token}',</p><p class="source-code">  };</p><p class="source-code">  const body = {</p><p class="source-code">    query: 'query {</p><p class="source-code">              user(login: "${configOptions.username}") {</p><p class="source-code">                contributionsCollection {</p><p class="source-code">                  contributionCalendar {</p><p class="source-code">                      totalContributions</p><p class="source-code">                  }</p><p class="source-code">                }</p><p class="source-code">              }</p><p class="source-code">            }',</p><p class="source-code">  };</p><p class="source-code">  const response = await</p><p class="source-code">  fetch("https://api.github.com/graphql", {</p><p class="source-code">    method: "POST",</p><p class="source-code">    body: JSON.stringify(body),</p><p class="source-code">    headers: headers,</p><p class="source-code">  });</p><p class="source-code">  const data = await response.json();</p><p class="source-code">  /* </p><p class="source-code">    Code added here in the next step</p><p class="source-code">  */</p><p>We use <strong class="source-inline">node-fetch</strong> to make the <strong class="source-inline">POST</strong> request to the GitHub API. We provide it with token authentication in the request header. Here, you can see we are using the <a id="_idIndexMarker559"/>token that's provided within <strong class="source-inline">configOptions</strong>. Like Gatsby, the GitHub API uses GraphQL. As with any GraphQL API, to select which data we want from GitHub, we have to pass a query into the body of our request. The query that's defined in <strong class="source-inline">body</strong> retrieves the total contributions for a given username (in this case, yours!). We pass our username in from <strong class="source-inline">configOptions</strong>. </p></li>
				<li>Add the following code after your request:<p class="source-code">const { contributionsCollection } = data.data.user;</p><p class="source-code">  const totalContributions =</p><p class="source-code">    contributionsCollection.contributionCalendar.totalCont</p><p class="source-code"> ributions;</p><p class="source-code">  createNode({</p><p class="source-code">    totalContributions: Number(totalContributions),</p><p class="source-code">    id: "Github-Contributions",</p><p class="source-code">    internal: {</p><p class="source-code">      type: 'GitHubContributions',</p><p class="source-code">      contentDigest: crypto</p><p class="source-code">        .createHash('md5')</p><p class="source-code">        .update(</p><p class="source-code">          JSON.stringify({</p><p class="source-code">            totalContributions,</p><p class="source-code">          })</p><p class="source-code">        )</p><p class="source-code">        .digest('hex'),</p><p class="source-code">      description: 'Github Contributions Information',</p><p class="source-code">    },</p><p class="source-code">  });</p><p>Here, we deconstruct the data from our request to receive the total contributions. Then, we <a id="_idIndexMarker560"/>utilize the <strong class="source-inline">createNode</strong> function to add this data to our GraphQL data layer. Let's break down the object I am passing to the function:</p><p>a. <strong class="source-inline">totalContributions</strong>: The first key value in the object is the value of the total contributions. This is the variable we will query for later when we try to retrieve this information on our pages.</p><p>b. <strong class="source-inline">id</strong>: Each node must have a globally unique ID. Because there is a single instance of this node type, we can just use the<strong class="source-inline">"Github-Contributions"</strong> string.</p><p>c. <strong class="source-inline">internal.type</strong>: A globally unique type that we can use to identify this data source.</p><p>d. <strong class="source-inline">internal.contentDigest</strong>: This field helps Gatsby avoid regenerating nodes when they haven't changed. While creating the node if this field remains constant, it won't regenerate. So, we need to make sure that if our total contributions change, so too does this <strong class="source-inline">contentDigest</strong>. To do that, I am using the <strong class="source-inline">crypto</strong> library to create an <strong class="source-inline">md5</strong> hash of our total contributions. This might seem a little overkill in this particular instance, but it works well if the amount of data on a node is more than one key-value pair, as you can just add them to the object that's being passed to <strong class="source-inline">JSON.stringify</strong>. </p><p>e. <strong class="source-inline">internal.description</strong>: This field allows us to describe the source type, which is helpful if we are confused about what this source is at any point. This field is not required <a id="_idIndexMarker561"/>but is nice to have. Our plugin is now ready to be used – the process from this point is the same as it is for a plugin that's been installed via npm.</p></li>
				<li>Navigate to your <strong class="source-inline">gatsby-config.js</strong> file at the root of your project and add the following code:<p class="source-code">require("dotenv").config({</p><p class="source-code">  path: '.env',</p><p class="source-code">});</p><p class="source-code">module.exports = {</p><p class="source-code">  // rest of config</p><p class="source-code">  plugins: [</p><p class="source-code">   {</p><p class="source-code">      resolve: 'gatsby-source-github-profile',</p><p class="source-code">      options: {</p><p class="source-code">        token:</p><p class="source-code">         process.env.GITHUB_PROFILE_BEARER_TOKEN,</p><p class="source-code">         username: "your-github-username-here",</p><p class="source-code">      },</p><p class="source-code">    },</p><p class="source-code">   // other plugins</p><p class="source-code">  ]</p><p class="source-code">}</p><p>Note that we are passing in the options to the plugin that we utilized in the plugin's <strong class="source-inline">gatsby-node.js</strong> file. We source the token from our <strong class="source-inline">.env</strong> file. You can pass your GitHub username in as plain text as this is public information.</p><p class="callout-heading">Quick Note</p><p class="callout">You may be tempted to try adding someone else's username here instead of your own, but this will cause the fetch request to fail as your access token does not have permission to retrieve another user's data.</p></li>
				<li>Start your <a id="_idIndexMarker562"/>development server. Navigate to <strong class="source-inline">http://localhost:8000/_graphql</strong> –  you should be able to query your total contributions with the following query:<p class="source-code">query Contributions {</p><p class="source-code">  gitHubContributions {</p><p class="source-code">    totalContributions</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>Let's add this new source of data to our <strong class="source-inline">about</strong> page:<p class="source-code">export default function About({ data }) {</p><p class="source-code">  const {</p><p class="source-code">    markdownRemark: { html },</p><p class="source-code">    <strong class="bold">gitHubContributions: { totalContributions }</strong></p><p class="source-code">  } = data;</p><p class="source-code">  return (</p><p class="source-code">    &lt;Layout&gt;</p><p class="source-code">      &lt;div className="max-w-5xl mx-auto py-16 lg:py-24</p><p class="source-code">     text-center"&gt;</p><p class="source-code">     &lt;div dangerouslySetInnerHTML={{ __html: html</p><p class="source-code">      }}&gt;&lt;/div&gt;</p><p class="source-code"><strong class="bold">        &lt;p&gt;In the last year I have made</strong></p><p class="source-code"><strong class="bold">         &lt;b&gt;{totalContributions}&lt;/b&gt; on Github.&lt;/p&gt;</strong></p><p class="source-code">      &lt;/div&gt;</p><p class="source-code">    &lt;/Layout&gt;</p><p class="source-code">  );</p><p class="source-code">}</p><p class="source-code">export const query = graphql'</p><p class="source-code">  {</p><p class="source-code">    markdownRemark(frontmatter: { type: { eq: "bio" } }) {</p><p class="source-code">      html</p><p class="source-code">    }</p><p class="source-code"><strong class="bold">    gitHubContributions {</strong></p><p class="source-code"><strong class="bold">      totalContributions</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code">  }</p><p class="source-code">';</p><p>We have updated the page query so that it includes the new source. We can then access it <a id="_idIndexMarker563"/>within the page via the <strong class="source-inline">data</strong> prop and render it to the screen, as shown in the highlighted section of code.</p></li>
			</ol>
			<p>Congratulations – you've just built your first local plugin. You could replicate the methods outlined here <a id="_idIndexMarker564"/>to fetch data from another API. So, at this point, we can create source plugins with ease, but what about theme plugins?</p>
			<h1 id="_idParaDest-145"><a id="_idTextAnchor147"/>Creating theme plugins</h1>
			<p>As we have discovered, theme plugins are all about adding visual elements to our Gatsby site. Theme plugins are unique in that they have to contain a <strong class="source-inline">gatsby-config.js</strong> file. To better <a id="_idIndexMarker565"/>understand theme plugins, let's look at the most minimal of examples. Let's use a plugin to add a simple sample page to our site:</p>
			<ol>
				<li value="1">Create a new folder called <strong class="source-inline">gatsby-theme-sample-page</strong> in your <strong class="source-inline">plugins</strong> folder.</li>
				<li>Open a terminal in the <strong class="source-inline">gatsby-theme-sample-page</strong> folder and run the following command:<p class="source-code"><strong class="bold">npm init -y</strong></p></li>
				<li>Create an <strong class="source-inline">src</strong> folder in <strong class="source-inline">/gatsby-theme-sample-page</strong>.</li>
				<li>Create a <strong class="source-inline">pages</strong> folder in your <strong class="source-inline">src</strong> folder.</li>
				<li>Create a <strong class="source-inline">sample.js</strong> file inside your new <strong class="source-inline">pages</strong> folder and add the following code:<p class="source-code">import React from "react";</p><p class="source-code">const Sample = () =&gt; {</p><p class="source-code">  return (</p><p class="source-code">    &lt;div&gt;</p><p class="source-code">      &lt;h1&gt;Sample page&lt;/h1&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">  );</p><p class="source-code">};</p><p class="source-code">export default Sample;</p><p>This page is very basic and just renders a heading on the page.</p></li>
				<li>Navigate to your <strong class="source-inline">gatsby-config.js</strong> file at the root of your project and add the following code:<p class="source-code">module.exports = {</p><p class="source-code">  // rest of config</p><p class="source-code">  plugins: [</p><p class="source-code">    'gatsby-theme-sample-page',</p><p class="source-code">   // other plugins</p><p class="source-code">  ]</p><p class="source-code">}</p></li>
				<li>Start your Gatsby <a id="_idIndexMarker566"/>development server and navigate to <strong class="source-inline">/sample</strong>; you should see your sample page.</li>
			</ol>
			<p>You may have noticed that a plugin consists of the same building blocks as your Gatsby site. This is one of the reasons why creating plugins is so straightforward in Gatsby. By building a site with this tool, you also inherit the ability to create plugins.</p>
			<p>Now that we have seen a basic example, let's try and build something a little more useful and a little more complex. Let's create a plugin that takes a folder of events (in JSON format) and creates a page for each one:</p>
			<ol>
				<li value="1">First, we're going to need some events that we can source within our plugin. Let's assume each event will have a <strong class="source-inline">title</strong>, <strong class="source-inline">description</strong>, <strong class="source-inline">location</strong>, and <strong class="source-inline">date</strong>. Create a folder called <strong class="source-inline">events</strong> within your root directory. Add some JSON files within this folder that are in the following format:<p class="source-code">{</p><p class="source-code">    "title": "Elevating Your Hack",</p><p class="source-code">    "description": "Tips &amp; tricks to make your hack</p><p class="source-code">      stand out from the crowd.",</p><p class="source-code">    "location": "King's College",</p><p class="source-code">    "date": "2021-12-25"</p><p class="source-code">  }</p><p>Ensure that the JSON is <a id="_idIndexMarker567"/>valid as errors will cause the plugin to crash out.</p></li>
				<li>Create a new folder called <strong class="source-inline">gatsby-theme-events-section</strong> in your <strong class="source-inline">plugins</strong> folder.</li>
				<li>Open a terminal in the <strong class="source-inline">gatsby-theme-events-section</strong> folder and run the following command:<p class="source-code"><strong class="bold">npm init -y</strong></p></li>
				<li>Create an <strong class="source-inline">src</strong> folder in <strong class="source-inline">/gatsby-theme-events-section</strong>.</li>
				<li>Open a terminal in the <strong class="source-inline">gatsby-theme-events-section</strong> folder and run the following command:<p class="source-code"><strong class="bold">npm i gatsby-transformer-json</strong></p><p>As its name suggests, this installs the transformer plugin for handling JSON.</p></li>
				<li>Create a <strong class="source-inline">gatsby-config.js</strong> file and add the following code:<p class="source-code">module.exports = {</p><p class="source-code">  plugins: [</p><p class="source-code">    'gatsby-transformer-json',</p><p class="source-code">    {</p><p class="source-code">      resolve: 'gatsby-source-filesystem',</p><p class="source-code">      options: {</p><p class="source-code">        path: './events',</p><p class="source-code">      },</p><p class="source-code">    },</p><p class="source-code">  ],</p><p class="source-code">};</p><p>Here, we are adding our newly installed plugin, as well as pointing our plugin to source files from <a id="_idIndexMarker568"/>the filesystem that exists in the <strong class="source-inline">events</strong> directory. These plugins will work together to create a new node for each JSON file within the events directory.</p></li>
				<li>Create a <strong class="source-inline">gatsby-node.js</strong> file and add the following code:<p class="source-code">const { createFilePath } = require('gatsby-source-</p><p class="source-code">  filesystem');</p><p class="source-code">exports.onCreateNode = ({ node, getNode, actions }) =&gt; {</p><p class="source-code">  const { createNodeField } = actions;</p><p class="source-code">  if (node.internal.type === 'EventsJson') {</p><p class="source-code">    const slug = createFilePath({ node, getNode });</p><p class="source-code">    createNodeField({</p><p class="source-code">      node,</p><p class="source-code">      name: 'slug',</p><p class="source-code">      value: slug,</p><p class="source-code">    });</p><p class="source-code">  }</p><p class="source-code">};</p><p>The <strong class="source-inline">onCreateNode</strong> function is called whenever a new node is created. Using this function, we can transform nodes by adding, removing, or manipulating their fields. In this specific case, we are adding a <strong class="source-inline">slug</strong> field if the node is of the <strong class="source-inline">EventsJson</strong> type. A <strong class="source-inline">slug</strong> is the address of a specific page on our site, so in the case of our <a id="_idIndexMarker569"/>event page, we want every event to have a unique <strong class="source-inline">slug</strong> where it will render on the site. </p></li>
				<li>Prepend your <strong class="source-inline">gatsby-node.js</strong> file with the following code:<p class="source-code">exports.createPages = async ({ actions, graphql,</p><p class="source-code"> reporter }) =&gt; {</p><p class="source-code">  const { createPage } = actions;</p><p class="source-code">  const EventTemplate =</p><p class="source-code">    require.resolve('./src/templates/event');</p><p class="source-code">  const EventsQuery = await graphql('</p><p class="source-code">  {</p><p class="source-code">    allEventsJson {</p><p class="source-code">      nodes {</p><p class="source-code">        fields {</p><p class="source-code">          slug</p><p class="source-code">        }</p><p class="source-code">      }</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">  ');</p><p class="source-code">  if (EventsQuery.errors) {</p><p class="source-code">    reporter.panicOnBuild('Error while running GraphQL</p><p class="source-code">      query.');</p><p class="source-code">    return;</p><p class="source-code">  }</p><p class="source-code">  const events = EventsQuery.data.allEventsJson.nodes;</p><p class="source-code">  events.forEach(({ fields: { slug } }) =&gt; {</p><p class="source-code">    createPage({</p><p class="source-code">      path: 'event${slug}',</p><p class="source-code">      component: EventTemplate,</p><p class="source-code">      context: {</p><p class="source-code">        slug: slug,</p><p class="source-code">      },</p><p class="source-code">    });</p><p class="source-code">  });</p><p class="source-code">};</p><p>This code should look very familiar as it is very similar to the code we saw in the <em class="italic">Creating templates and programmatic page generation</em> section of <a href="B15983_04_ePub_RK.xhtml#_idTextAnchor072"><em class="italic">Chapter 4</em></a>, <em class="italic">Creating Reusable Templates</em>. Here, we are utilizing the <strong class="source-inline">createPage</strong> function, which allows us to create pages dynamically. Inside this function, we destructure the <strong class="source-inline">actions</strong> object to retrieve the <strong class="source-inline">createPage</strong> function. Then, we tell Gatsby where <a id="_idIndexMarker570"/>to find our event template. With these two pieces in place, we are now ready to query our data. You should see a familiar GraphQL query upon selecting the <strong class="source-inline">slug</strong> property from all the events. After this, we can iterate through the events and create a page for each one, providing the <strong class="source-inline">slug</strong> property as context.</p></li>
				<li>Create a <strong class="source-inline">templates</strong> folder in <strong class="source-inline">/gatsby-theme-events-section/src</strong>.</li>
				<li>Create an <strong class="source-inline">event.js</strong> file in <strong class="source-inline">/gatsby-theme-events-section/src/templates</strong> and add the following code:<p class="source-code">import React from "react";</p><p class="source-code">import { graphql } from "gatsby";</p><p class="source-code">export default function Event({ data }){</p><p class="source-code">  const {</p><p class="source-code">    event: { description, title, location, date },</p><p class="source-code">  } = data;</p><p class="source-code">  return (</p><p class="source-code">    &lt;div className="prose max-w-5xl"&gt;</p><p class="source-code">      &lt;h1&gt;{title}&lt;/h1&gt;</p><p class="source-code">      &lt;p&gt;</p><p class="source-code">        {date} - {location}</p><p class="source-code">      &lt;/p&gt;</p><p class="source-code">      &lt;p&gt;{description}&lt;/p&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">  );</p><p class="source-code">}</p><p>Here, we take <strong class="source-inline">title</strong>, <strong class="source-inline">location</strong>, <strong class="source-inline">description</strong>, and <strong class="source-inline">date</strong>, which we will retrieve in the <a id="_idIndexMarker571"/>page query, and render them on the screen.</p></li>
				<li>Append the <strong class="source-inline">events.js</strong> file with the following code:<p class="source-code">export const pageQuery = graphql'</p><p class="source-code">  query($slug: String!) {</p><p class="source-code">    event: eventsJson(fields: { slug: { eq: $slug } }) {</p><p class="source-code">      description</p><p class="source-code">      title</p><p class="source-code">      location</p><p class="source-code">      date(formatString: "dddd Do MMMM yyyy")</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">';</p><p>Here, we are using <strong class="source-inline">slug</strong> from the context to find the event where <strong class="source-inline">slug</strong> matches in the <a id="_idIndexMarker572"/>node's fields. We query for all the data that we need to populate this page by retrieving <strong class="source-inline">title</strong>, <strong class="source-inline">location</strong>, <strong class="source-inline">description</strong>, and <strong class="source-inline">date</strong>, which have been formatted. This is then passed into the template via the <strong class="source-inline">data</strong> prop.</p></li>
				<li>Now, let's create a page with all the events listed. Create a <strong class="source-inline">pages</strong> folder in <strong class="source-inline">/gatsby-theme-events-section/src</strong>.</li>
				<li>Create an <strong class="source-inline">events.js</strong> file in <strong class="source-inline">/gatsby-theme-events-section/src/pages</strong> and add the following code:<p class="source-code">import React from "react";</p><p class="source-code">import { graphql, Link } from "gatsby";</p><p class="source-code">const Events = ({ data }) =&gt; {</p><p class="source-code">  const events = data.allEventsJson.nodes;</p><p class="source-code">  return (</p><p class="source-code">    &lt;div className="prose max-w-5xl"&gt;</p><p class="source-code">      &lt;h1&gt;Upcoming Events:&lt;/h1&gt;</p><p class="source-code">      {events.map(({ title, location, date, fields: {</p><p class="source-code">       slug } }) =&gt; (</p><p class="source-code">        &lt;Link to={'/event${slug}'}&gt;</p><p class="source-code">          &lt;h2&gt;{title}&lt;/h2&gt;</p><p class="source-code">          &lt;p&gt;</p><p class="source-code">            {date} - {location}</p><p class="source-code">          &lt;/p&gt;</p><p class="source-code">        &lt;/Link&gt;</p><p class="source-code">      ))}</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">  );</p><p class="source-code">};</p><p class="source-code">export default Events</p><p>Here, we are mapping through our events and creating a <strong class="source-inline">Link</strong> to an event's dedicated <a id="_idIndexMarker573"/>page with <strong class="source-inline">title</strong>, <strong class="source-inline">data</strong>, and <strong class="source-inline">location</strong>.</p></li>
				<li>Append <strong class="source-inline">events.js</strong> with the following code:<p class="source-code">export const query = graphql'</p><p class="source-code">  {</p><p class="source-code">    allEventsJson {</p><p class="source-code">      nodes {</p><p class="source-code">        location</p><p class="source-code">        title</p><p class="source-code">        date</p><p class="source-code">        fields {</p><p class="source-code">          slug</p><p class="source-code">        }</p><p class="source-code">      }</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">';</p><p>This query will retrieve all the events and return them in a nodes array, which can be retrieved via the <strong class="source-inline">data</strong> prop on the page.</p></li>
				<li>You're all done – run your <a id="_idIndexMarker574"/>development server and navigate to <strong class="source-inline">localhost:8000/events</strong>. You should see the following output:</li>
			</ol>
			<div>
				<div id="_idContainer068" class="IMG---Figure">
					<img src="image/Figure_10.03_B15983.jpg" alt="Figure 10.3 – Events page preview&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.3 – Events page preview</p>
			<p>Clicking on an event should take you to its dedicated page:</p>
			<div>
				<div id="_idContainer069" class="IMG---Figure">
					<img src="image/Figure_10.04_B15983.jpg" alt="Figure 10.4 – Events page preview&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.4 – Events page preview</p>
			<p>You've just made your first local theme plugin. Adding an event to the <strong class="source-inline">events</strong> folder will see it appended to the list and get a dedicated page. If we were to publish this plugin, we could then use it within multiple Gatsby sites to create these pages by simply creating an <strong class="source-inline">events</strong> folder <a id="_idIndexMarker575"/>and populating it. No additional configuration is required!</p>
			<p class="callout-heading">Quick Tip</p>
			<p class="callout">You'll notice a lack of styling in the examples set out in this chapter. This chapter focuses on the Gatsby APIs that are being utilized and less on styling. By now, you should feel confident enough to create styling for these pages.</p>
			<p>Now that we understand how to create both types of plugins, let's learn how we can publish them and contribute them back to the community.</p>
			<h1 id="_idParaDest-146"><a id="_idTextAnchor148"/>Contributing to the plugin ecosystem</h1>
			<p>So, you've built a plugin and now you want to use it in a separate Gatsby project? Or perhaps you think the plugin could help other developers? In either case, you'll need to publish your plugin. By publishing your plugin with npm, your plugin will automatically become visible <a id="_idIndexMarker576"/>on Gatsby's site plugins page (<a href="https://www.gatsbyjs.com/plugins">https://www.gatsbyjs.com/plugins</a>). Let's start this journey by looking at a pre-publish checklist.</p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor149"/>Pre-publish checklist</h2>
			<p>Before we publish our plugin, it's important to ensure that we are ready to do so. The following <a id="_idIndexMarker577"/>is a suggested pre-publish checklist:</p>
			<ul>
				<li>Ensure your plugin's name explains what it does. This might seem a little trivial but naming your plugin in a way that makes it clear what it does will make it easier to find online.</li>
				<li>Ensure your plugin's name is unique. Two npm packages cannot share the same name, so you mustn't try and deploy a package with a name that is already in use. To check whether your name is in use, visit <a href="https://www.npmjs.com/">https://www.npmjs.com/</a> and search for your plugin's name.</li>
				<li>Ensure your plugin adheres to the naming convention that was outlined in the <em class="italic">Understanding Gatsby plugins</em> section. This is the way that Gatsby determines which npm packages are Gatsby plugins so that it can add them to their site. </li>
				<li>Ensure your plugin has a comprehensive <strong class="source-inline">README.md</strong> file. This file will be picked up by Gatsby and included within the plugin ecosystem, so it's vitally important that the <strong class="source-inline">README.md</strong> file explains what your plugin does and how to use it. You should include the specific configuration options that might be required.</li>
				<li>Check that both React and Gatsby are peer dependencies. </li>
				<li>Ensure your <a id="_idIndexMarker578"/>code has been tested properly. Unit tests are so important, but even more so if you're about to pass your code onto others. Aim for 100% test code coverage.<p class="callout-heading">Important Note</p><p class="callout">If you ended up changing your plugin's name, be sure that this new name is reflected in the <strong class="source-inline">package.json</strong> file, as well as the folder's name. Having the old name anywhere can be confusing when you're using/searching for your plugin later down the line.</p></li>
			</ul>
			<p>Now that we have gone through our checklist, let's learn how to publish a plugin.</p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor150"/>Publishing a plugin</h2>
			<p>Publishing a Gatsby plugin <a id="_idIndexMarker579"/>follows the same process as publishing any npm package. Let's learn how to do this:</p>
			<ol>
				<li value="1">Ensure you have an npm account. If you do not, you can create one at <a href="https://www.npmjs.com/signup">https://www.npmjs.com/signup</a>.</li>
				<li>Log into the npm CLI from your terminal by running the following command:<p class="source-code"><strong class="bold">npm login</strong></p><p>The CLI will ask for your name, email, and password as part of the login process.</p></li>
				<li>Navigate your terminal to your Gatsby plugin's directory. <em class="italic">This is vitally important</em>. If you continue these steps within your root directory, you will end up accidentally <a id="_idIndexMarker580"/>releasing your entire site as a package, so ensure you have navigated to the plugin.</li>
				<li>Finally, run the <strong class="source-inline">publish</strong> command:<p class="source-code"><strong class="bold">npm publish</strong></p><p>If this command finishes successfully, congratulations! Your plugin is now available via npm. If, however, you saw permission errors, this is most likely because your plugin name is not unique. Refer back to the <em class="italic">Pre-publish checklist</em> section and if the name is clashing, change the name in the <strong class="source-inline">package.json</strong> file and retry.</p><p class="callout-heading">Quick Tip</p><p class="callout">After your first publish, you will most likely find things you want to change. If you follow these instructions again, be sure to bump the version number in your <strong class="source-inline">package.json</strong> file as npm will reject a publish with the same version number. </p></li>
			</ol>
			<p>Now that your plugin has been published, it should be visible on the Gatsby website plugins page within 24 hours. </p>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor151"/>Summary</h1>
			<p>In this chapter, we learned what a Gatsby plugin is and what types exist. We learned about local plugin development and how to create source and theme plugins. We created both source and theme plugins and then tested them locally by including them on our site. We then learned about sharing plugins online. We discussed what you should consider before deploying a plugin and then learned how to share a plugin by publishing them online via npm. By completing this chapter, you should now feel confident that you can create and share source and theme plugins with ease. This has been a brief introduction to a massive topic, and I hope you can build on this knowledge to create plugins for any use case.</p>
			<p>In the next chapter, we will look at another advanced concept – authentication. We will learn how to create login experiences on your website.</p>
		</div>
	</body></html>