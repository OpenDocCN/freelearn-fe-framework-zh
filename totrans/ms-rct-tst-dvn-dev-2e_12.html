<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer037">
<h1 class="chapter-number" id="_idParaDest-205"><a id="_idTextAnchor231"/>12</h1>
<h1 id="_idParaDest-206"><a id="_idTextAnchor232"/>Test-Driving Redux</h1>
<p><strong class="bold">Redux</strong> is a <strong class="bold">predictable state container</strong>. To <a id="_idIndexMarker1097"/>the uninitiated, these <a id="_idIndexMarker1098"/>words mean very little. Thankfully, TDD can help us understand how to think about and implement our Redux application architecture. The tests in the chapter will help you see how Redux can be integrated into any application.</p>
<p>The headline benefit of Redux is the ability to share state between components in a way that provides data consistency when operating in an asynchronous browser environment. The big drawback is that you must introduce a whole bunch of plumbing and complexity into your application.</p>
<p class="callout-heading">Here be dragons</p>
<p class="callout">For many applications, the complexity of Redux outweighs the benefits. Just because this chapter exists in this book does not mean you should be rushing out to use Redux. In fact, I hope that the code samples contained herein serve as warning enough for the complexity you will be introducing.</p>
<p>In this chapter, we’ll build a reducer and a saga to manage the submission of our <strong class="source-inline">CustomerForm</strong> component.</p>
<p>We’ll use a testing library named <strong class="source-inline">expect-redux</strong> to test Redux interactions. This library allows us to write tests that <a id="_idIndexMarker1099"/>are not tied to the <strong class="source-inline">redux-saga</strong> library. Being independent of libraries is a great way of ensuring that your tests are not brittle and are resilient to change: you could replace <strong class="source-inline">redux-saga</strong> with <strong class="source-inline">redux-thunk</strong> and your tests would still work. </p>
<p>This chapter covers the following topics:</p>
<ul>
<li>Up-front design for a reducer and a saga</li>
<li>Test-driving a reducer</li>
<li>Test-driving a saga</li>
<li>Switching component state for Redux state</li>
</ul>
<p>By the end of the chapter, you’ll have seen all the techniques you need for testing Redu<a id="_idTextAnchor233"/>x.</p>
<h1 id="_idParaDest-207"><a id="_idTextAnchor234"/>Technical requirements</h1>
<p>The code files for this chapter can be found here: </p>
<p><a href="https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter12">https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter12</a></p>
<h1 id="_idParaDest-208"><a id="_idTextAnchor235"/>Up-front design for a reducer and a saga</h1>
<p>In this <a id="_idIndexMarker1100"/>section, we’ll<a id="_idIndexMarker1101"/> do the usual thing of mapping out a rough plan of what we’re going to build.</p>
<p>Let’s start by looking at what the actual technical change is going to be and discuss why we’re going to do it.</p>
<p>We’re going to move the logic for submitting a customer—the <strong class="source-inline">doSave</strong> function in <strong class="source-inline">CustomerForm</strong>—out of the React component and into Redux. We’ll use a Redux reducer to manage the status of the operation: whether it’s currently submitting, finished, or had a validation error. We’ll use a Redux saga to perform the asynchronous operation.</p>
<h2 id="_idParaDest-209"><a id="_idTextAnchor236"/>Why Redux?</h2>
<p>Given the<a id="_idIndexMarker1102"/> current feature set of the application, there’s really no reason to use Redux. However, imagine that in the future, we’d like to support these features:</p>
<ul>
<li>After adding a new customer, the <strong class="source-inline">AppointmentForm</strong> component shows the customer information just before submitting it, without having to re-fetch the data from the server</li>
<li>After finding a customer from the <strong class="source-inline">CustomerSearch</strong> component and choosing to create an appointment, the same customer information is shown on the appointment screen, without having to re-fetch the data</li>
</ul>
<p>In this future scenario, it <em class="italic">might</em> make sense to have some shared Redux state for the customer data.</p>
<p>I say “might” because there are other, potentially simpler solutions: component context, or perhaps some kind of HTTP response caching. Who knows what the solution would look like? It’s too hard to say without a concrete requirement.</p>
<p>To sum up: in this chapter, we’ll use Redux to store customer data. It has no real benefit over our current <a id="_idIndexMarker1103"/>approach, and in fact, has the drawback of all the additional plumbing. However, let’s press on, given that the purpose of this book is educational.</p>
<h2 id="_idParaDest-210"><a id="_idTextAnchor237"/>Designing the store state and actions</h2>
<p>A Redux <a id="_idIndexMarker1104"/>store is <a id="_idIndexMarker1105"/>simply an object of data with some restrictions on how it is accessed. Here’s how we want ours to look. The object encodes all the information that <strong class="source-inline">CustomerForm</strong> already uses about a <strong class="source-inline">fetch</strong> request to save customer data:</p>
<pre class="source-code">
{
  customer: {
    status: SUBMITTING | SUCCESSFUL | FAILED | ...
    // only present if the customer was saved successfully
    customer: { id: 123, firstName: "Ashley" ... },
    // only present if there are validation errors
    validationErrors: { phoneNumber: "..." },
    // only present if there was another type of error
    error: true | false
  }
}</pre>
<p>Redux changes this state by means of named actions. We will have the following actions:</p>
<ul>
<li><strong class="source-inline">ADD_CUSTOMER_REQUEST</strong>, called when the user presses the button to submit a customer. This triggers the saga, which then fires off the remaining actions</li>
<li><strong class="source-inline">ADD_CUSTOMER_SUBMITTING</strong>, when the saga begins its work</li>
<li><strong class="source-inline">ADD_CUSTOMER_SUCCESSFUL</strong>, when the server saves the customer and returns a new customer ID. With this action, we’ll also save the new customer information in the reducer, ready for later use</li>
<li><strong class="source-inline">ADD_CUSTOMER_VALIDATION_FAILED</strong>, if the provided customer data is invalid</li>
<li><strong class="source-inline">ADD_CUSTOMER_FAILED</strong>, if there is some other reason the server fails to save data</li>
</ul>
<p>For reference, here’s <a id="_idIndexMarker1106"/>the existing code that we’ll be extracting<a id="_idIndexMarker1107"/> from <strong class="source-inline">CustomerForm</strong>. It’s all helpfully in one function, <strong class="source-inline">doSave</strong>, even though it is quite long:</p>
<pre class="source-code">
const doSave = async () =&gt; {
  setSubmitting(true);
  const result = await global.fetch("/customers", {
    method: "POST",
    credentials: "same-origin",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(customer),
  });
  setSubmitting(false);
  if (result.ok) {
    setError(false);
    const customerWithId = await result.json();
    onSave(customerWithId);
  } else if (result.status === 422) {
    const response = await result.json();
    setValidationErrors(response.errors);
  } else {
    setError(tru<a id="_idTextAnchor238"/>e);
  }
};</pre>
<p>We’ll replace all this <a id="_idIndexMarker1108"/>code with a combination of a saga and <a id="_idIndexMarker1109"/>reducer. We’ll start with the reducer, in the next section.</p>
<h1 id="_idParaDest-211"><a id="_idTextAnchor239"/>Test-driving a reducer</h1>
<p>In this section, we’ll<a id="_idIndexMarker1110"/> test-drive a new reducer function, and then pull out some repeated code.</p>
<p>A reducer is a simple function that takes an action and the current store state as input and returns a new state object as output. Let’s build that now, as follows:</p>
<ol>
<li>Create a new file (in a new directory) named <strong class="source-inline">test/reducers/customer.test.js</strong>. Add the following first test, which checks that if the reducer is invoked with an unknown action, our reducer should return a default state for our object. This is standard behavior for Redux reducers, so you should always start with a test like this:<p class="source-code">import { reducer } from "../../src/reducers/customer";</p><p class="source-code">describe("customer reducer", () =&gt; {</p><p class="source-code">  it("returns a default state for an undefined existing state", () =&gt; {</p><p class="source-code">    expect(reducer(undefined, {})).toEqual({</p><p class="source-code">      customer: {},</p><p class="source-code">      status: undefined,</p><p class="source-code">      validationErrors: {},</p><p class="source-code">      error: false</p><p class="source-code">    });</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>Create a <strong class="source-inline">src/reducers/customer.js</strong> file, as follows, and let’s make that test <a id="_idIndexMarker1111"/>pass:<p class="source-code">const defaultState = {</p><p class="source-code">  customer: {},</p><p class="source-code">  status: undefined,</p><p class="source-code">  validationErrors: {},</p><p class="source-code">  error: false</p><p class="source-code">};</p><p class="source-code">export const reducer = (state = defaultState, action) =&gt; {</p><p class="source-code">  return state;</p><p class="source-code">};</p></li>
<li>For the next test, add in support for the <strong class="source-inline">ADD_CUSTOMER_SUBMITTING</strong> action, as follows. This test checks that when this action is received, the status value is updated to <strong class="source-inline">SUBMITTING</strong>:<p class="source-code">describe("ADD_CUSTOMER_SUBMITTING action", () =&gt; {</p><p class="source-code">  const action = { type: "ADD_CUSTOMER_SUBMITTING" };</p><p class="source-code">  it("sets status to SUBMITTING", () =&gt; {</p><p class="source-code">    expect(reducer(undefined, action)).toMatchObject({</p><p class="source-code">      status: "SUBMITTING"</p><p class="source-code">    });</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>Make that <a id="_idIndexMarker1112"/>pass by replacing the body of the reducer with the following code. We can jump directly to using a <strong class="source-inline">switch</strong> statement here (rather than using an <strong class="source-inline">if</strong> statement) because<a id="_idIndexMarker1113"/> we know for certain that we’ll be filling out other action types:<p class="source-code">switch(action.type) {</p><p class="source-code">  case "ADD_CUSTOMER_SUBMITTING":</p><p class="source-code">    return { status: "SUBMITTING" };</p><p class="source-code">  default:</p><p class="source-code">    return state;</p><p class="source-code">}</p></li>
<li>Add a second test to the <strong class="source-inline">ADD_CUSTOMER_SUBMITTING</strong> <strong class="source-inline">describe</strong> block, as follows. This test specifies behavior that’s expected for reducer actions: any state that we don’t care about (which is <strong class="source-inline">status</strong> in this case) is maintained:<p class="source-code">it("maintains existing state", () =&gt; {</p><p class="source-code">  expect(reducer({ a: 123 }, action)).toMatchObject({</p><p class="source-code">    a: 123</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>Make that pass by modifying the reducers, as follows:<p class="source-code">export const reducer = (state = defaultState, action) =&gt; {</p><p class="source-code">  switch (action.type) {</p><p class="source-code">    case "ADD_CUSTOMER_SUBMITTING":</p><p class="source-code">      return { <strong class="bold">...state,</strong> status: "SUBMITTING" };</p><p class="source-code">    default:</p><p class="source-code">      return state;</p><p class="source-code">  }</p><p class="source-code">};</p></li>
<li>We need to <a id="_idIndexMarker1114"/>handle the <strong class="source-inline">ADD_CUSTOMER_SUCCESSFUL</strong> action. Start with the two tests shown next. I’m cheating by writing two tests at once, but that’s fine because I know they are a close replica of the <strong class="source-inline">ADD_CUSTOMER_SUBMITTING</strong> tests:<p class="source-code">describe("ADD_CUSTOMER_SUCCESSFUL action", () =&gt; {</p><p class="source-code">  const customer = { id: 123 };</p><p class="source-code">  const action = {</p><p class="source-code">    type: "ADD_CUSTOMER_SUCCESSFUL",</p><p class="source-code">    customer</p><p class="source-code">  };</p><p class="source-code">  it("sets status to SUCCESSFUL", () =&gt; {</p><p class="source-code">    expect(reducer(undefined, action)).toMatchObject({</p><p class="source-code">      status: "SUCCESSFUL"</p><p class="source-code">    });</p><p class="source-code">  });</p><p class="source-code">  it("maintains existing state", () =&gt; {</p><p class="source-code">    expect(</p><p class="source-code">      reducer({ a: 123 }, action)</p><p class="source-code">    ).toMatchObject({ a: 123 });</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>To make that pass, add a final <strong class="source-inline">case</strong> statement to your reducer, like so: <p class="source-code">case "ADD_CUSTOMER_SUCCESSFUL":</p><p class="source-code">  return { ...state, status: "SUCCESSFUL" };</p></li>
<li>Add a third <a id="_idIndexMarker1115"/>test, shown next. The action provides a new <strong class="source-inline">customer</strong> object with its assigned ID, which we should save in the<a id="_idIndexMarker1116"/> reducer for later use:<p class="source-code">it("sets customer to provided customer", () =&gt; {</p><p class="source-code">  expect(reducer(undefined, action)).toMatchObject({</p><p class="source-code">    customer</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>Make that pass by adding in the <strong class="source-inline">customer</strong> property, as follows:<p class="source-code">case "ADD_CUSTOMER_SUCCESSFUL":</p><p class="source-code">  return {</p><p class="source-code">    ...state,</p><p class="source-code">    status: "SUCCESSFUL"<strong class="bold">,</strong></p><p class="source-code"><strong class="bold">    customer: action.customer</strong></p><p class="source-code">  };</p></li>
<li>Add the next <strong class="source-inline">describe</strong> block, for <strong class="source-inline">ADD_CUSTOMER_FAILED</strong>, as follows:<p class="source-code">describe("ADD_CUSTOMER_FAILED action", () =&gt; {</p><p class="source-code">  const action = { type: "ADD_CUSTOMER_FAILED" };</p><p class="source-code">  it("sets status to FAILED", () =&gt; {</p><p class="source-code">    expect(reducer(undefined, action)).toMatchObject({</p><p class="source-code">      status: "FAILED"</p><p class="source-code">    });</p><p class="source-code">  });</p><p class="source-code">  it("maintains existing state", () =&gt; {</p><p class="source-code">    expect(</p><p class="source-code">      reducer({ a: 123 }, action)</p><p class="source-code">    ).toMatchObject({ a: 123 });</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>Make<a id="_idIndexMarker1117"/> those <a id="_idIndexMarker1118"/>both pass by adding a new <strong class="source-inline">case</strong> statement to the <strong class="source-inline">switch</strong> reducer, like so:<p class="source-code">case "ADD_CUSTOMER_FAILED":</p><p class="source-code">  return { ...state, status: "FAILED" };</p></li>
<li>We aren’t quite done with <strong class="source-inline">ADD_CUSTOMER_FAILED</strong>. In this case, we also want to set <strong class="source-inline">error</strong> to <strong class="source-inline">true</strong>. Recall that we used an <strong class="source-inline">error</strong> state variable in the <strong class="source-inline">CustomerForm</strong> component to mark when an unexplained error had occurred. We need to replicate that here. Add this third test to the <strong class="source-inline">describe</strong> block, as follows:<p class="source-code">it("sets error to true", () =&gt; {</p><p class="source-code">  expect(reducer(undefined, action)).toMatchObject({</p><p class="source-code">    error: true</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>Make that pass by modifying the <strong class="source-inline">case</strong> statement, as shown here:<p class="source-code">case "ADD_CUSTOMER_FAILED":</p><p class="source-code">  return { ...state, status: "FAILED"<strong class="bold">, error: true</strong> };</p></li>
<li>Add tests for the <strong class="source-inline">ADD_CUSTOMER_VALIDATION_FAILED</strong> action, which occurs if field<a id="_idIndexMarker1119"/> validation failed. The code is illustrated here:<p class="source-code">describe("ADD_CUSTOMER_VALIDATION_FAILED action", () =&gt; {</p><p class="source-code">  const validationErrors = { field: "error text" };</p><p class="source-code">  const action = {</p><p class="source-code">    type: "ADD_CUSTOMER_VALIDATION_FAILED",</p><p class="source-code">    validationErrors</p><p class="source-code">  };</p><p class="source-code">  it("sets status to VALIDATION_FAILED", () =&gt; {</p><p class="source-code">    expect(reducer(undefined, action)).toMatchObject({</p><p class="source-code">      status: "VALIDATION_FAILED"</p><p class="source-code">    });</p><p class="source-code">  });</p><p class="source-code">  it("maintains existing state", () =&gt; {</p><p class="source-code">    expect(</p><p class="source-code">      reducer({ a: 123 }, action)</p><p class="source-code">    ).toMatchObject({ a: 123 });</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>Make these tests pass with another <strong class="source-inline">case</strong> statement in the reducer, as follows:<p class="source-code">case "ADD_CUSTOMER_VALIDATION_FAILED":</p><p class="source-code">  return { ...state, status: "VALIDATION_FAILED" };</p></li>
<li>This action also needs a third test. This time, the action can include error information<a id="_idIndexMarker1120"/> on what the validation errors were, as shown <a id="_idIndexMarker1121"/>in the following code snippet:<p class="source-code">it("sets validation errors to provided errors", () =&gt; {</p><p class="source-code">  expect(reducer(undefined, action)).toMatchObject({</p><p class="source-code">    validationErrors</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>Make that pass with the change shown here:<p class="source-code">case "ADD_CUSTOMER_VALIDATION_FAILED":</p><p class="source-code">  return {</p><p class="source-code">    ...state,</p><p class="source-code">    status: "VALIDATION_FAILED"<strong class="bold">,</strong></p><p class="source-code"><strong class="bold">    validationErrors: action.validationErrors</strong></p><p class="source-code">  };</p></li>
</ol>
<p>That completes the reducer, but before we use it from within a saga, how about we dry <a id="_idTextAnchor240"/>these tests up a little?</p>
<h2 id="_idParaDest-212"><a id="_idTextAnchor241"/>Pulling out generator functions for reducer actions</h2>
<p>Most reducers <a id="_idIndexMarker1122"/>will follow the<a id="_idIndexMarker1123"/> same pattern: each action will set some new data to ensure that the existing state is not lost.</p>
<p>Let’s write a couple of test-generator functions to do that for us, to help us dry up our tests. Proceed as follows:</p>
<ol>
<li value="1">Create a new file, <strong class="source-inline">test/reducerGenerators.js</strong>, and add the following function to it:<p class="source-code">export const itMaintainsExistingState = (reducer, action) =&gt; {</p><p class="source-code">  it("maintains existing state", () =&gt; {</p><p class="source-code">    const existing = { a: 123 };</p><p class="source-code">    expect(</p><p class="source-code">      reducer(existing, action)</p><p class="source-code">    ).toMatchObject(existing);</p><p class="source-code">  });</p><p class="source-code">};</p></li>
<li>Add the following <strong class="source-inline">import</strong> statement to the top of <strong class="source-inline">src/reducers/customer.test.js</strong>:<p class="source-code">import {</p><p class="source-code">  itMaintainsExistingState</p><p class="source-code">} from "../reducerGenerators";</p></li>
<li>Modify your tests to use this function, deleting the test in each <strong class="source-inline">describe</strong> block and replacing it with the following single line:<p class="source-code">itMaintainsExistingState(reducer, action);</p></li>
<li>Back in <strong class="source-inline">test/reducerGenerators.js</strong>, define the following function:<p class="source-code">export const itSetsStatus = (reducer, action, value) =&gt; {</p><p class="source-code">  it(`sets status to ${value}`, () =&gt; {</p><p class="source-code">    expect(reducer(undefined, action)).toMatchObject({</p><p class="source-code">      status: value</p><p class="source-code">    });</p><p class="source-code">  });</p><p class="source-code">};</p></li>
<li>Modify the existing <strong class="source-inline">import</strong> statement to pull in the new function, like so:<p class="source-code">import {</p><p class="source-code">  itMaintainsExistingState,</p><p class="source-code"><strong class="bold">  itSetsStatus</strong></p><p class="source-code">} from "../reducerGenerators";</p></li>
<li>Modify your<a id="_idIndexMarker1124"/> tests to use <a id="_idIndexMarker1125"/>this function, just as you did before. Make sure you run your tests to prove they work! Your tests should now be much shorter. Here’s an example of the <strong class="source-inline">describe</strong> block for <strong class="source-inline">ADD_CUSTOMER_SUCCESSFUL</strong>:<p class="source-code">describe("ADD_CUSTOMER_SUBMITTING action", () =&gt; {</p><p class="source-code">  const action = { type: "ADD_CUSTOMER_SUBMITTING" };</p><p class="source-code">  itMaintainsExistingState(reducer, action);</p><p class="source-code">  itSetsStatus(reducer, action, "SUBMITTING");</p><p class="source-code">});</p></li>
</ol>
<p>That concludes the reducer. Before we move on to the saga, let’s tie it into the application. We won’t make use of it at all, but it’s good to get the plumbing in now.</p>
<h2 id="_idParaDest-213"><a id="_idTextAnchor242"/>Setting up a store and an entry point</h2>
<p>In addition to <a id="_idIndexMarker1126"/>the<a id="_idIndexMarker1127"/> reducer we’ve written, we need to define a function named <strong class="source-inline">configureStore</strong> that we’ll then call when our application starts. Proceed as follows:</p>
<ol>
<li value="1">Create a new file named <strong class="source-inline">src/store.js</strong> with the following content. There’s no need to test this just yet, as it’s a bit like <strong class="source-inline">src/index.js</strong>: plumbing that connects everything together. However, we will utilize it in the next section when we<a id="_idIndexMarker1128"/> test the <a id="_idIndexMarker1129"/>saga:<p class="source-code">import { createStore, combineReducers } from "redux";</p><p class="source-code">import {</p><p class="source-code"> reducer as customerReducer</p><p class="source-code">} from "./reducers/customer";</p><p class="source-code">export const configureStore = (storeEnhancers = []) =&gt; </p><p class="source-code">  createStore(</p><p class="source-code">    combineReducers({ customer: customerReducer }),</p><p class="source-code">    storeEnhancers</p><p class="source-code">  );</p></li>
<li>In <strong class="source-inline">src/index.js</strong>, add the<a id="_idIndexMarker1130"/> following two <strong class="source-inline">import</strong> statements to the top of the file:<p class="source-code">import { Provider } from "react-redux";</p><p class="source-code">import { configureStore } from "./store";</p></li>
<li>Then, wrap the <a id="_idIndexMarker1131"/>existing JSX in a <strong class="source-inline">Provider</strong> component, as shown here. This is how all our components will gain access to the Redux store:<p class="source-code">ReactDOM.createRoot(</p><p class="source-code">  document.getElementById("root")</p><p class="source-code">).render(</p><p class="source-code"><strong class="bold">  &lt;Provider store={configureStore()}&gt;</strong></p><p class="source-code">    &lt;BrowserRouter&gt;</p><p class="source-code">      &lt;App /&gt;</p><p class="source-code">    &lt;/BrowserRouter&gt;</p><p class="source-code"><strong class="bold">  &lt;/Provider&gt;</strong></p><p class="source-code">);</p></li>
</ol>
<p>With<a id="_idIndexMarker1132"/> that<a id="_idIndexMarker1133"/> in place, we’re ready to write the tricky part: the saga.</p>
<h1 id="_idParaDest-214"><a id="_idTextAnchor243"/>Test-driving a saga</h1>
<p>A saga is a <a id="_idIndexMarker1134"/>special bit of code that uses JavaScript generator functions to manage asynchronous operations to the Redux store. Because it’s super complex, we won’t actually test the saga itself; instead, we’ll dispatch an action to the store and observe the results.</p>
<p>Before we get started on the <a id="_idIndexMarker1135"/>saga tests, we need a new test helper function named <strong class="source-inline">renderWithStore</strong>.</p>
<h3>Adding the renderWithStore test extension</h3>
<p>Proceed<a id="_idIndexMarker1136"/> as<a id="_idIndexMarker1137"/> follows:</p>
<ol>
<li value="1">At the top of <strong class="source-inline">test/reactTestExtensions.js</strong>, add the following new <strong class="source-inline">import</strong> statements:<p class="source-code">import { Provider } from "react-redux";</p><p class="source-code">import { storeSpy } from "expect-redux";</p><p class="source-code">import { configureStore } from "../src/store";</p></li>
</ol>
<p class="callout-heading">The expect-redux package</p>
<p class="callout">For that, we’ll <a id="_idIndexMarker1138"/>use the <strong class="source-inline">expect-redux</strong> package from NPM, which has<a id="_idIndexMarker1139"/> already been included in the <strong class="source-inline">package.json</strong> file for you—make sure to run <strong class="source-inline">npm install</strong> before you begin.</p>
<ol>
<li value="2">Add a new variable, <strong class="source-inline">store</strong>, and initialize it in <strong class="source-inline">initializeReactContainer</strong>, as illustrated in the following code snippet. This makes use of <strong class="source-inline">storeSpy</strong> from <strong class="source-inline">expect-redux</strong>, which we’ll use in our tests to check calls to the store:<p class="source-code">export let store;</p><p class="source-code">export const initializeReactContainer = () =&gt; {</p><p class="source-code"><strong class="bold">  store = configureStore([storeSpy]);</strong></p><p class="source-code">  container = document.createElement("div");</p><p class="source-code">  document.body.replaceChildren(container);</p><p class="source-code">  reactRoot = ReactDOM.createRoot(container);</p><p class="source-code">};</p></li>
<li>Add your<a id="_idIndexMarker1140"/> new render <a id="_idIndexMarker1141"/>function below the <strong class="source-inline">renderWithRouter</strong> function, as illustrated in the following code snippet:<p class="source-code">export const renderWithStore = (component) =&gt;</p><p class="source-code">  act(() =&gt;</p><p class="source-code">    reactRoot.render(</p><p class="source-code">      &lt;Provider store={store}&gt;{component}&lt;/Provider&gt;</p><p class="source-code">    )</p><p class="source-code">  );</p></li>
<li>Finally, add <strong class="source-inline">dispatchStore</strong>, which we’ll need when we start dispatching actions in our component, as follows:<p class="source-code">export const dispatchToStore = (action) =&gt;</p><p class="source-code">  act(() =&gt; store.dispatch(action));</p></li>
</ol>
<p>You’ve now got all the helpers you need to begin testing both sagas and components that are <a id="_idIndexMarker1142"/>connected to a Redux<a id="_idIndexMarker1143"/> store. With all that in place, let’s get started on the saga tests.</p>
<h2 id="_idParaDest-215"><a id="_idTextAnchor244"/>Using expect-redux to write expectations</h2>
<p>The saga<a id="_idIndexMarker1144"/> we’re writing will <a id="_idIndexMarker1145"/>respond to an <strong class="source-inline">ADD_CUSTOMER_REQUEST</strong> action that’s dispatched from the <strong class="source-inline">CustomerForm</strong> component <a id="_idIndexMarker1146"/>when the user submits the form. The functionality of the saga is just the same as the <strong class="source-inline">doSave</strong> function listed in the <em class="italic">Designing the store state and actions</em> section at the beginning of this chapter. The difference is we’ll need to use the saga’s function <a id="_idIndexMarker1147"/>calls of <strong class="source-inline">put</strong>, <strong class="source-inline">call</strong>, and so forth.</p>
<p>Let’s begin by writing a generator function named <strong class="source-inline">addCustomer</strong>. Proceed as follows:</p>
<ol>
<li value="1">Create a new file (in a new directory) named <strong class="source-inline">test/sagas/customer.test.js</strong> and add the following code to set up our <strong class="source-inline">describe</strong> block. We initialize a <strong class="source-inline">store</strong> variable that both our sagas and our test expectations will make use of. This is a repeat of the code we had previously in our <strong class="source-inline">initializeReactContainer</strong> test helper—which we can’t use here because we’re not writing a component:<p class="source-code">import { storeSpy, expectRedux } from "expect-redux";</p><p class="source-code">import { configureStore } from "../../src/store";</p><p class="source-code">describe("addCustomer", () =&gt; {</p><p class="source-code">  let store;</p><p class="source-code">  beforeEach(() =&gt; {</p><p class="source-code">    store = configureStore([ storeSpy ]);</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>Just below the <strong class="source-inline">beforeEach</strong> block, add the following helper function, which gives us a slightly more elegant way of constructing the action—you’ll see that in the first test, coming up next:<p class="source-code">const addCustomerRequest = (customer) =&gt; ({</p><p class="source-code">  type: "ADD_CUSTOMER_REQUEST",</p><p class="source-code">  customer,</p><p class="source-code">});</p></li>
<li>Now for the first test. What is the first thing our saga should do? It must update our store state to reflect that the form is submitting. That way, the <strong class="source-inline">CustomerForm</strong> component can immediately show a submitting indicator to the user. We <a id="_idIndexMarker1148"/>use<a id="_idIndexMarker1149"/> an expectation from <strong class="source-inline">expect-redux</strong> to ensure that we dispatch the right action, as shown here:<p class="source-code">it("sets current status to submitting", () =&gt; {</p><p class="source-code">  store.dispatch(addCustomerRequest());</p><p class="source-code">  return expectRedux(store)</p><p class="source-code">    .toDispatchAnAction()</p><p class="source-code">    .matching({ type: "ADD_CUSTOMER_SUBMITTING" });</p><p class="source-code">});</p></li>
</ol>
<p class="callout-heading">Returning promises from tests</p>
<p class="callout">This test returns a promise. This is a shortcut we can use instead of marking our test function as <strong class="source-inline">async</strong> and the expectation with <strong class="source-inline">await</strong>. Jest knows to wait if the test function returns a promise.</p>
<ol>
<li value="4">Let’s start with the saga implementation. Create a new file named <strong class="source-inline">src/sagas/customer.js</strong> with the following content. Notice the <strong class="source-inline">function*</strong> syntax, which signifies a generator function, and <a id="_idIndexMarker1150"/>the use of <strong class="source-inline">put</strong> to fire off another<a id="_idIndexMarker1151"/> action to the store:<p class="source-code">import { put } from "redux-saga/effects";</p><p class="source-code">export function* addCustomer() {</p><p class="source-code">  yield put({ type: "ADD_CUSTOMER_SUBMITTING" });</p><p class="source-code">}</p></li>
</ol>
<p class="callout-heading">Generator-function syntax</p>
<p class="callout">The arrow-function syntax that we’ve been using throughout the book does not work for generator functions, so we need to fall back to using the <strong class="source-inline">function</strong> keyword.</p>
<ol>
<li value="5">Before <a id="_idIndexMarker1152"/>that <a id="_idIndexMarker1153"/>test will pass, we need to update the store<a id="_idIndexMarker1154"/> with a <strong class="bold">root saga</strong>. That root saga then registers our <strong class="source-inline">addCustomer</strong> saga. Starting with the imports statements, update <strong class="source-inline">src/store.js</strong> to read as follows:<p class="source-code">import {</p><p class="source-code">  createStore,</p><p class="source-code"><strong class="bold">  applyMiddleware,</strong></p><p class="source-code">  compose,</p><p class="source-code">  combineReducers</p><p class="source-code">} from "redux";</p><p class="source-code"><strong class="bold">import createSagaMiddleware from "redux-saga";</strong></p><p class="source-code"><strong class="bold">import { takeLatest } from "redux-saga/effects";</strong></p><p class="source-code"><strong class="bold">import { addCustomer } from "./sagas/customer";</strong></p><p class="source-code">import {</p><p class="source-code">  reducer as customerReducer</p><p class="source-code">} from "./sagas/customer";</p></li>
<li>Just below those imports, add this definition of <strong class="source-inline">rootSaga</strong>:<p class="source-code">function* rootSaga() {</p><p class="source-code">  yield takeLatest(</p><p class="source-code">    "ADD_CUSTOMER_REQUEST",</p><p class="source-code">    addCustomer</p><p class="source-code">  );</p><p class="source-code">}</p></li>
<li>Now, update <strong class="source-inline">configureStore</strong> to <a id="_idIndexMarker1155"/>include<a id="_idIndexMarker1156"/> the <a id="_idIndexMarker1157"/>saga middleware and “run” <strong class="source-inline">rootSaga</strong>, like so. After this change, your test should pass:<p class="source-code">export const configureStore = (storeEnhancers = []) =&gt; {</p><p class="source-code"><strong class="bold">  const sagaMiddleware = createSagaMiddleware();</strong></p><p class="source-code">  const store = createStore(</p><p class="source-code">    combineReducers({ customer: customerReducer }),</p><p class="source-code"><strong class="bold">    compose(</strong></p><p class="source-code"><strong class="bold">      applyMiddleware(sagaMiddleware),</strong></p><p class="source-code"><strong class="bold">      ...storeEnhancers</strong></p><p class="source-code"><strong class="bold">    )</strong></p><p class="source-code">  );</p><p class="source-code"><strong class="bold">  sagaMiddleware.run(rootSaga);</strong></p><p class="source-code">  return store;</p><p class="source-code">};</p></li>
</ol>
<p>That completes the first test for the saga, and gets all the necessary plumbing into place. You<a id="_idTextAnchor245"/>’ve <a id="_idIndexMarker1158"/>also<a id="_idIndexMarker1159"/> seen how to use <strong class="source-inline">put</strong>. Next up, let’s introduce <strong class="source-inline">call</strong>.</p>
<h2 id="_idParaDest-216"><a id="_idTextAnchor246"/>Making asynchronous requests with sagas</h2>
<p>Within a <a id="_idIndexMarker1160"/>saga, <strong class="source-inline">call</strong> allows us to <a id="_idIndexMarker1161"/>perform an <a id="_idIndexMarker1162"/>asynchronous request. Let’s introduce that now. Follow these steps:</p>
<ol>
<li value="1">Add the following test, to check the call to <strong class="source-inline">fetch</strong>:<p class="source-code">it("sends HTTP request to POST /customers", async () =&gt; {</p><p class="source-code">  const inputCustomer = { firstName: "Ashley" };</p><p class="source-code">  store.dispatch(addCustomerRequest(inputCustomer));</p><p class="source-code">  expect(global.fetch).toBeCalledWith(</p><p class="source-code">    "/customers",</p><p class="source-code">    expect.objectContaining({</p><p class="source-code">      method: "POST",</p><p class="source-code">    })</p><p class="source-code">  );</p><p class="source-code">});</p></li>
<li>We’ll need to define a spy on <strong class="source-inline">global.fetch</strong> for this to work. Change the <strong class="source-inline">beforeEach</strong> block as follows, including the new customer constant:<p class="source-code">beforeEach(() =&gt; {</p><p class="source-code"><strong class="bold">  jest.spyOn(global, "fetch");</strong></p><p class="source-code">  store = configureStore([ storeSpy ]);</p><p class="source-code">});</p></li>
<li>In <strong class="source-inline">src/sagas/customer.js</strong>, update the saga<a id="_idIndexMarker1163"/> import to include the <strong class="source-inline">call</strong> function, like so:<p class="source-code">import { put<strong class="bold">, call</strong> } from "redux-saga/effects";</p></li>
<li>Now, create a <strong class="source-inline">fetch</strong> function<a id="_idIndexMarker1164"/> and invoke it in the saga with <strong class="source-inline">call</strong>, as follows. After this, your test should be passing:<p class="source-code">const fetch = (url, data) =&gt;</p><p class="source-code">  global.fetch(url, {</p><p class="source-code">    method: "POST",</p><p class="source-code">  });</p><p class="source-code">export function* addCustomer({ customer }) {</p><p class="source-code">  yield put({ type: "ADD_CUSTOMER_SUBMITTING" });</p><p class="source-code">  yield call(fetch, "/customers", customer);</p><p class="source-code">}</p></li>
<li>Alright—now, let’s<a id="_idIndexMarker1165"/> add a <a id="_idIndexMarker1166"/>test to add in the configuration for our <strong class="source-inline">fetch</strong> request, as follows:<p class="source-code">it("calls fetch with correct configuration", async () =&gt; {</p><p class="source-code">  const inputCustomer = { firstName: "Ashley" };</p><p class="source-code">  store.dispatch(addCustomerRequest(inputCustomer));</p><p class="source-code">  expect(global.fetch).toBeCalledWith(</p><p class="source-code">    expect.anything(),</p><p class="source-code">    expect.objectContaining({</p><p class="source-code">      credentials: "same-origin",</p><p class="source-code">      headers: { "Content-Type": "application/json" },</p><p class="source-code">    })</p><p class="source-code">  );</p><p class="source-code">});</p></li>
<li>To make that pass, add the following lines to the <strong class="source-inline">fetch</strong> definition:<p class="source-code">const fetch = (url, data) =&gt;</p><p class="source-code">  global.fetch(url, {</p><p class="source-code">    method: "POST",</p><p class="source-code"><strong class="bold">    credentials: "same-origin",</strong></p><p class="source-code"><strong class="bold">    headers: { "Content-Type": "application/json" }</strong></p><p class="source-code">  });</p></li>
<li>Now, let’s <a id="_idIndexMarker1167"/>test that we’re <a id="_idIndexMarker1168"/>sending the right customer data across. Here’s how we can do that:<p class="source-code">it("calls fetch with customer as request body", async () =&gt; {</p><p class="source-code">  const inputCustomer = { firstName: "Ashley" };</p><p class="source-code">  store.dispatch(addCustomerRequest(inputCustomer));</p><p class="source-code">  expect(global.fetch).toBeCalledWith(</p><p class="source-code">    expect.anything(),</p><p class="source-code">    expect.objectContaining({</p><p class="source-code">      body: JSON.stringify(inputCustomer),</p><p class="source-code">    })</p><p class="source-code"> );</p><p class="source-code">});</p></li>
<li>To make that pass, complete the <strong class="source-inline">fetch</strong> definition, as shown here:<p class="source-code">const fetch = (url, data) =&gt;</p><p class="source-code">  global.fetch(url, {</p><p class="source-code"><strong class="bold">    body: JSON.stringify(data),</strong></p><p class="source-code">    method: "POST",</p><p class="source-code">    credentials: "same-origin",</p><p class="source-code">    headers: { "Content-Type": "application/json" }</p><p class="source-code">  });</p></li>
<li>For the next test, we want to dispatch an <strong class="source-inline">ADD_CUSTOMER_SUCCESSFUL</strong> event when the <strong class="source-inline">fetch</strong> call returns successfully. It uses a constant named <strong class="source-inline">customer</strong> that <a id="_idIndexMarker1169"/>we’ll define in <a id="_idIndexMarker1170"/>the next step. Here’s the code we need to execute:<p class="source-code">it("dispatches ADD_CUSTOMER_SUCCESSFUL on success", () =&gt; {</p><p class="source-code">  store.dispatch(addCustomerRequest());</p><p class="source-code">  return expectRedux(store)</p><p class="source-code">    .toDispatchAnAction()</p><p class="source-code">    .matching({</p><p class="source-code">      type: "ADD_CUSTOMER_SUCCESSFUL",</p><p class="source-code">      customer</p><p class="source-code">    });</p><p class="source-code">});</p></li>
<li>When we set up our <strong class="source-inline">fetch</strong> spy before, we didn’t set a return value. So, now, create a <strong class="source-inline">customer</strong> constant and set up the <strong class="source-inline">fetch</strong> spy to return it, like so:<p class="source-code"><strong class="bold">const customer = { id: 123 };</strong></p><p class="source-code">beforeEach(() =&gt; {</p><p class="source-code">  jest</p><p class="source-code">    .spyOn(global, "fetch")</p><p class="source-code"><strong class="bold">    .mockReturnValue(fetchResponseOk(customer));</strong></p><p class="source-code">  store = configureStore([ storeSpy ]);</p><p class="source-code">});</p></li>
<li>Import <strong class="source-inline">fetchResponseOk</strong>, like so. After this, you’ll be able to run your test:<p class="source-code">import { fetchResponseOk } from "../builders/fetch";</p></li>
<li>Make the<a id="_idIndexMarker1171"/> test pass by processing <a id="_idIndexMarker1172"/>the result<a id="_idIndexMarker1173"/> from the <strong class="source-inline">call</strong> function, like so:<p class="source-code">export function* addCustomer({ customer }) {</p><p class="source-code">  yield put({ type: "ADD_CUSTOMER_SUBMITTING" });</p><p class="source-code"><strong class="bold">  const result = </strong>yield call(fetch, "/customers", customer);</p><p class="source-code"><strong class="bold">  const customerWithId = yield call([result, "json"]);</strong></p><p class="source-code"><strong class="bold">  yield put({</strong></p><p class="source-code"><strong class="bold">    type: "ADD_CUSTOMER_SUCCESSFUL",</strong></p><p class="source-code"><strong class="bold">    customer: customerWithId</strong></p><p class="source-code"><strong class="bold">  });</strong></p><p class="source-code">}</p></li>
<li>What about if the <strong class="source-inline">fetch</strong> call isn’t successful, perhaps because of a network failure? Add a test for that, as follows:<p class="source-code">it("dispatches ADD_CUSTOMER_FAILED on non-specific error", () =&gt; {</p><p class="source-code">  global.fetch.mockReturnValue(fetchResponseError());</p><p class="source-code">  store.dispatch(addCustomerRequest());</p><p class="source-code">  return expectRedux(store)</p><p class="source-code">    .toDispatchAnAction()</p><p class="source-code">    .matching({ type: "ADD_CUSTOMER_FAILED" });</p><p class="source-code">});</p></li>
<li>That test makes use of <strong class="source-inline">fetchResponseError</strong>; import it now, like so:<p class="source-code">import {</p><p class="source-code">  fetchResponseOk,</p><p class="source-code"><strong class="bold">  fetchResponseError</strong></p><p class="source-code">} from "../builders/fetch";</p></li>
<li>Make the<a id="_idIndexMarker1174"/> test pass by wrapping <a id="_idIndexMarker1175"/>the existing code in an <strong class="source-inline">if</strong> statement with an <strong class="source-inline">else</strong> clause, as follows:<p class="source-code">export function* addCustomer({ customer }) {</p><p class="source-code">  yield put({ type: "ADD_CUSTOMER_SUBMITTING" });</p><p class="source-code">  const result = yield call(</p><p class="source-code">    fetch,</p><p class="source-code">    "/customers",</p><p class="source-code">    customer</p><p class="source-code">  );</p><p class="source-code"> <strong class="bold"> if(result.ok) {</strong></p><p class="source-code"><strong class="bold"> </strong>   const customerWithId = yield call(</p><p class="source-code">      [result, "json"]</p><p class="source-code">    );</p><p class="source-code">    yield put({</p><p class="source-code">      type: "ADD_CUSTOMER_SUCCESSFUL",</p><p class="source-code">      customer: customerWithId</p><p class="source-code">    });</p><p class="source-code">  }<strong class="bold"> else {</strong></p><p class="source-code"><strong class="bold">    yield put({ type: "ADD_CUSTOMER_FAILED" });</strong></p><p class="source-code"><strong class="bold">  }</strong></p><p class="source-code">}</p></li>
<li>Finally, add <a id="_idIndexMarker1176"/>a<a id="_idIndexMarker1177"/> test for a more specific type of failure—a validation failure, as follows:<p class="source-code">it("dispatches ADD_CUSTOMER_VALIDATION_FAILED if validation errors were returned", () =&gt; {</p><p class="source-code">  const errors = {</p><p class="source-code">    field: "field",</p><p class="source-code">    description: "error text"</p><p class="source-code">  };</p><p class="source-code">  global.fetch.mockReturnValue(</p><p class="source-code">    fetchResponseError(422, { errors })</p><p class="source-code">  );</p><p class="source-code">  store.dispatch(addCustomerRequest());</p><p class="source-code">  return expectRedux(store)</p><p class="source-code">    .toDispatchAnAction()</p><p class="source-code">    .matching({</p><p class="source-code">      type: "ADD_CUSTOMER_VALIDATION_FAILED",</p><p class="source-code">      validationErrors: errors</p><p class="source-code">    });</p><p class="source-code">});</p></li>
<li>Make <a id="_idIndexMarker1178"/>that pass with the<a id="_idIndexMarker1179"/> following code:<p class="source-code">export function* addCustomer({ customer }) {</p><p class="source-code">  yield put({ type: "ADD_CUSTOMER_SUBMITTING" });</p><p class="source-code">  const result = yield call(fetch, "/customers", customer);</p><p class="source-code">  if(result.ok) {</p><p class="source-code">    const customerWithId = yield call(</p><p class="source-code">     [result, "json"]</p><p class="source-code">    );</p><p class="source-code">    yield put({</p><p class="source-code">      type: "ADD_CUSTOMER_SUCCESSFUL",</p><p class="source-code">      customer: customerWithId</p><p class="source-code">    });</p><p class="source-code">  } <strong class="bold">else if (result.status === 422) {</strong></p><p class="source-code"><strong class="bold">    const response = yield call([result, "json"]);</strong></p><p class="source-code"><strong class="bold">    yield put({</strong></p><p class="source-code"><strong class="bold">      type: "ADD_CUSTOMER_VALIDATION_FAILED",</strong></p><p class="source-code"><strong class="bold">      validationErrors: response.errors</strong></p><p class="source-code"><strong class="bold">    });</strong></p><p class="source-code"><strong class="bold">  }</strong> else {</p><p class="source-code">    yield put({ type: "ADD_CUSTOMER_FAILED" });</p><p class="source-code">  }</p><p class="source-code">}</p></li>
</ol>
<p>The saga is now complete. Compare this function to the function in <strong class="source-inline">CustomerForm</strong> that we’re replacing: <strong class="source-inline">doSave</strong>. The structure is identical. That’s a good indicator that we’re<a id="_idIndexMarker1180"/> ready<a id="_idIndexMarker1181"/> to work on removing <strong class="source-inline">doSave</strong> from <strong class="source-inline">CustomerForm<a id="_idTextAnchor247"/></strong>.</p>
<p>In the next section, we’ll update <strong class="source-inline">CustomerForm</strong> to make use of our new Redux store.</p>
<h1 id="_idParaDest-217"><a id="_idTextAnchor248"/>Switching component state for Redux state</h1>
<p>The saga and <a id="_idIndexMarker1182"/>reducer are now complete <a id="_idIndexMarker1183"/>and ready to be used in the <strong class="source-inline">CustomerForm</strong> React component. In this section, we’ll replace the use of <strong class="source-inline">doSave</strong>, and then as a final flourish, we’ll <a id="_idTextAnchor249"/>push our React Router navigation into the saga, removing the <strong class="source-inline">onSave</strong> callback from <strong class="source-inline">App</strong>.</p>
<h2 id="_idParaDest-218"><a id="_idTextAnchor250"/>Submitting a React form by dispatching a Redux action</h2>
<p>At the <a id="_idIndexMarker1184"/>start<a id="_idIndexMarker1185"/> of the chapter, we looked at how the purpose of this change was essentially a transplant of <strong class="source-inline">CustomerForm</strong>’s <strong class="source-inline">doSave</strong> function into a Redux action.</p>
<p>With our new Redux setup, we used component state to display a submitting indicator and show any validation errors. That information is now stored within the Redux store, not component state. So, in addition to dispatching an action to replace <strong class="source-inline">doSave</strong>, the component also needs to read state from the store. The component state variables can be deleted.</p>
<p>This has a knock-on effect on our tests. Since the saga tests the failure modes, our component tests for <strong class="source-inline">CustomerForm</strong> simply need to handle various states of the Redux store, which we’ll<a id="_idIndexMarker1186"/> manipulate using our <strong class="source-inline">dispatchToStore</strong> extension.</p>
<p>We’ll start by making our component Redux-aware, as follows:</p>
<ol>
<li value="1">Add the following <strong class="source-inline">import</strong> statement to the top of <strong class="source-inline">test/CustomerForm.test.js</strong>:<p class="source-code">import { expectRedux } from "expect-redux";</p></li>
<li>Update the test extensions <strong class="source-inline">import</strong> statement, replacing <strong class="source-inline">render</strong> with <strong class="source-inline">renderWithStore</strong>, and<a id="_idIndexMarker1187"/> adding the two new imports, as follows:<p class="source-code">import {</p><p class="source-code">  initializeReactContainer,</p><p class="source-code">  render<strong class="bold">WithStore</strong>,</p><p class="source-code"><strong class="bold">  dispatchToStore,</strong></p><p class="source-code"><strong class="bold">  store,</strong></p><p class="source-code">  ...</p><p class="source-code">} from "./reactTestExtensions";</p></li>
<li>Replace all calls to <strong class="source-inline">render</strong> with <strong class="source-inline">renderWithStore</strong>. Be careful if you’re doing a search and replace operation: the word <em class="italic">render</em> appears in some of the test descriptions, and you should keep those as they are.</li>
<li>Let’s rework a single test: the one with the <strong class="source-inline">sends HTTP request to POST /customers when submitting data</strong> description. Change that test<a id="_idIndexMarker1188"/> to<a id="_idIndexMarker1189"/> the following:<p class="source-code">it("dispatches ADD_CUSTOMER_REQUEST when submitting data", async () =&gt; {</p><p class="source-code">  <strong class="bold">renderWithStore(</strong></p><p class="source-code"><strong class="bold">    &lt;CustomerForm {...validCustomer} /&gt;</strong></p><p class="source-code"><strong class="bold">  );</strong></p><p class="source-code">  await clickAndWait(submitButton());</p><p class="source-code">  <strong class="bold">return expectRedux(store)</strong></p><p class="source-code"><strong class="bold">    .toDispatchAnAction()</strong></p><p class="source-code"><strong class="bold">    .matching({</strong></p><p class="source-code"><strong class="bold">      type: 'ADD_CUSTOMER_REQUEST',</strong></p><p class="source-code"><strong class="bold">      customer: validCustomer</strong></p><p class="source-code"><strong class="bold">  });</strong></p><p class="source-code">});</p></li>
<li>To make this pass, we’ll use a side-by-side implementation to ensure our other tests continue to pass. In <strong class="source-inline">handleSubmit</strong>, add the line highlighted in the following code snippet. This calls a new <strong class="source-inline">addCustomerRequest</strong> prop that we’ll define soon:<p class="source-code">const handleSubmit = async (event) =&gt; {</p><p class="source-code">  event.preventDefault();</p><p class="source-code">  const validationResult = validateMany(</p><p class="source-code">    validators, customer</p><p class="source-code">  );</p><p class="source-code">  if (!anyErrors(validationResult)) {</p><p class="source-code">    await doSave();</p><p class="source-code"><strong class="bold">    dispatch(addCustomerRequest(customer));</strong></p><p class="source-code">  } else {</p><p class="source-code">    setValidationErrors(validationResult);</p><p class="source-code">  }</p><p class="source-code">};</p></li>
<li>That makes<a id="_idIndexMarker1190"/> use of the <strong class="source-inline">useDispatch</strong> hook. Import that now, as follows:<p class="source-code">import {  useDispatch } from "react-redux";</p></li>
<li>Then, add<a id="_idIndexMarker1191"/> this<a id="_idIndexMarker1192"/> line <a id="_idIndexMarker1193"/>to the top of the <strong class="source-inline">CustomerForm</strong> component:<p class="source-code">const dispatch = useDispatch();</p></li>
<li>To make the test pass, all that’s left is the definition of <strong class="source-inline">addCustomerRequest</strong>, which you can add just below the <strong class="source-inline">import</strong> statements and above the <strong class="source-inline">CustomerForm</strong> component definition, like so:<p class="source-code">const addCustomerRequest = (customer) =&gt; ({</p><p class="source-code">  type: "ADD_CUSTOMER_REQUEST",</p><p class="source-code">  customer,</p><p class="source-code">});</p></li>
</ol>
<p>At this point, your component is now Redux-aware, and it’s dispatching the right action to Redux. The remaining work is to modify the component to deal with validation errors coming from Redux rather than the component state.</p>
<h2 id="_idParaDest-219"><a id="_idTextAnchor251"/>Making use of store state within a component</h2>
<p>Now, it’s time to <a id="_idIndexMarker1194"/>introduce the <strong class="source-inline">useSelector</strong> hook to pull out state <a id="_idIndexMarker1195"/>from the store. We’ll kick things off with the <strong class="source-inline">ADD_CUSTOMER_FAILED</strong> generic error action. Recall that when the reducer receives this, it updates the <strong class="source-inline">error</strong> store state value to <strong class="source-inline">true</strong>. Follow these steps:</p>
<ol>
<li value="1">Find the test named <strong class="source-inline">renders error message when fetch call fails</strong>. Replace it with the implementation shown here. It simulates an <strong class="source-inline">ADD_CUSTOMER_FAILED</strong> action so that we make sure all the Redux wiring is correct. Don’t forget to remove the <strong class="source-inline">async</strong> keyword from the test function:<p class="source-code">it("renders error message when error prop is true", () =&gt; {</p><p class="source-code">  renderWithStore(</p><p class="source-code">    &lt;CustomerForm {...validCustomer} /&gt;</p><p class="source-code">  );</p><p class="source-code"><strong class="bold">  dispatchToStore({ type: "ADD_CUSTOMER_FAILED" });</strong></p><p class="source-code">  expect(element("[role=alert]")).toContainText(</p><p class="source-code">    "error occurred"</p><p class="source-code">  );</p><p class="source-code">});</p></li>
<li>Add an <strong class="source-inline">import</strong> statement<a id="_idIndexMarker1196"/> for the <strong class="source-inline">useSelector</strong> hook at the top of <strong class="source-inline">src/CustomerForm.js</strong>, as follows:<p class="source-code">import {</p><p class="source-code">  useDispatch,</p><p class="source-code">  <strong class="bold">useSelector</strong></p><p class="source-code"> } from "react-redux";</p></li>
<li>Call the <strong class="source-inline">useSelector</strong> hook at the top of the <strong class="source-inline">CustomerForm</strong> component, as shown in the following code snippet. It pulls out the <strong class="source-inline">error</strong> state value from the <strong class="source-inline">customer</strong> section of the Redux store:<p class="source-code">const {</p><p class="source-code">  error,</p><p class="source-code">} = useSelector(({ customer }) =&gt; customer);</p></li>
<li>Delete any line where <strong class="source-inline">setError</strong> is called. There are two occurrences, both in <strong class="source-inline">doSave</strong>.</li>
<li>Now, you can delete the <strong class="source-inline">error</strong>/<strong class="source-inline">setError</strong> pair of variables that are defined with the <strong class="source-inline">useState</strong> hook at the top of <strong class="source-inline">CustomerForm</strong>. Your tests won’t run until you do this, due to <strong class="source-inline">error</strong> being declared twice. Your tests should be passing at this stage.</li>
<li>The next test, <strong class="source-inline">clears error message when fetch call succeeds</strong>, can <a id="_idIndexMarker1197"/>be deleted. The reducer, as it stands, doesn’t actually do this; completing it is one of the exercises in the <em class="italic">Exercise</em> section.</li>
<li>Find the <strong class="source-inline">does not submit the form when there are validation errors</strong> test and update it as follows. It should pass already:<p class="source-code">it("does not submit the form when there are validation errors", async () =&gt; {</p><p class="source-code">  renderWithStore(</p><p class="source-code">    &lt;CustomerForm original={blankCustomer} /&gt;</p><p class="source-code">  );</p><p class="source-code">  await clickAndWait(submitButton());</p><p class="source-code"><strong class="bold">  return expectRedux(store)</strong></p><p class="source-code"><strong class="bold">    .toNotDispatchAnAction(100)</strong></p><p class="source-code"><strong class="bold">    .ofType("ADD_CUSTOMER_REQUEST");</strong></p><p class="source-code">});</p></li>
</ol>
<p class="callout-heading">The toNotDispatchAnAction matcher</p>
<p class="callout">This matcher should always be used with a timeout, such as 100 milliseconds in this case. That’s because, in an asynchronous environment, events may just be slow to occur, rather than not occurring at all.</p>
<ol>
<li value="8">Find the next test, <strong class="source-inline">renders field validation errors from server</strong>. Replace it with the following code, remembering to remove the <strong class="source-inline">async</strong> keyword<a id="_idIndexMarker1198"/> from the function definition:<p class="source-code">it("renders field validation errors from server", () =&gt; {</p><p class="source-code">  const errors = {</p><p class="source-code">    phoneNumber: "Phone number already exists in the system"</p><p class="source-code">  };</p><p class="source-code">  renderWithStore(</p><p class="source-code">    &lt;CustomerForm {...validCustomer} /&gt;</p><p class="source-code">  );</p><p class="source-code"><strong class="bold">  dispatchToStore({</strong></p><p class="source-code"><strong class="bold">    type: "ADD_CUSTOMER_VALIDATION_FAILED",</strong></p><p class="source-code"><strong class="bold">    validationErrors: errors</strong></p><p class="source-code"><strong class="bold">  });</strong></p><p class="source-code">  expect(</p><p class="source-code">    errorFor(phoneNumber)</p><p class="source-code">  ).toContainText(errors.phoneNumber);</p><p class="source-code">});</p></li>
<li>To make this pass, we need to pull out <strong class="source-inline">validationErrors</strong> from the Redux customer store. There’s a bit of complexity here: the component already has a <strong class="source-inline">validationErrors</strong> state variable that covers <em class="italic">both</em> server and client validation errors. We can’t replace that entirely, because it handles client errors in addition to server errors.</li>
</ol>
<p>So, let’s <em class="italic">rename</em> the prop we get back from the server, like so:</p>
<p class="source-code">const {</p>
<p class="source-code">  error,</p>
<p class="source-code"><strong class="bold">  validationErrors: serverValidationErrors,</strong></p>
<p class="source-code">} = useSelector(({ customer }) =&gt; customer);</p>
<p class="callout-heading">A design issue</p>
<p class="callout">This highlights a design issue in our original code. The <strong class="source-inline">validationErrors</strong> state variable had <em class="italic">two</em> uses, which were mixed up. Our change here will separate those uses.</p>
<ol>
<li value="10">We’re not done <a id="_idIndexMarker1199"/>with this test just yet. Update the <strong class="source-inline">renderError</strong> function to render errors for both <strong class="source-inline">validationErrors</strong> (client-side validation) and <strong class="source-inline">serverValidationErrors</strong> (server-side validation), as follows:<p class="source-code">const renderError = fieldName =&gt; {</p><p class="source-code"><strong class="bold">  const allValidationErrors = {</strong></p><p class="source-code"><strong class="bold">    ...validationErrors,</strong></p><p class="source-code"><strong class="bold">    ...serverValidationErrors</strong></p><p class="source-code"><strong class="bold">  };</strong></p><p class="source-code">  return (</p><p class="source-code">    &lt;span id={`${fieldname}error`} role="alert"&gt;</p><p class="source-code"><strong class="bold">      {hasError(allValidationErrors, fieldName)</strong></p><p class="source-code"><strong class="bold">        ? allValidationErrors[fieldname]</strong></p><p class="source-code"><strong class="bold">        : ""}</strong></p><p class="source-code">    &lt;/span&gt;</p><p class="source-code">  );</p><p class="source-code">};</p></li>
<li>The next tests we need to look at are for the submitting indicator. We’ll update these tests to respond to store actions rather than a form submission. Here’s the first <a id="_idIndexMarker1200"/>one:<p class="source-code">it("displays indicator when form is submitting", () =&gt; {</p><p class="source-code">  renderWithStore(</p><p class="source-code">    &lt;CustomerForm {...validCustomer} /&gt;</p><p class="source-code">  );</p><p class="source-code"><strong class="bold">  dispatchToStore({</strong></p><p class="source-code"><strong class="bold">   type: "ADD_CUSTOMER_SUBMITTING"</strong></p><p class="source-code"><strong class="bold">  });</strong></p><p class="source-code">  expect(</p><p class="source-code">    element(".submittingIndicator")</p><p class="source-code">  ).not.toBeNull();</p><p class="source-code">});</p></li>
<li>To make this pass, add <strong class="source-inline">status</strong> to the <strong class="source-inline">useSelector</strong> call, like so:<p class="source-code">const {</p><p class="source-code">  error,</p><p class="source-code"><strong class="bold">  status,</strong></p><p class="source-code">  validationErrors: serverValidationErrors,</p><p class="source-code">} = useSelector(({ customer }) =&gt; customer);</p></li>
<li>Delete anywhere that <strong class="source-inline">setSubmitting</strong> is called within this component.</li>
<li>Delete the state variable for <strong class="source-inline">submitting</strong>, and replace it with the following line of code. The test should now pass:<p class="source-code">const submitting = status === "SUBMITTING";</p></li>
<li>Then, update the test named <strong class="source-inline">hides indicator when form has submitted</strong>, as follows. This<a id="_idIndexMarker1201"/> test won’t need any change to the production code:<p class="source-code">it("hides indicator when form has submitted", () =&gt; {</p><p class="source-code">  renderWithStore(</p><p class="source-code">    &lt;CustomerForm {...validCustomer} /&gt;</p><p class="source-code">  );</p><p class="source-code"><strong class="bold">  dispatchToStore({</strong></p><p class="source-code"><strong class="bold">    type: "ADD_CUSTOMER_SUCCESSFUL"</strong></p><p class="source-code"><strong class="bold">  });</strong></p><p class="source-code">  expect(element(".submittingIndicator")).toBeNull();</p><p class="source-code">});</p></li>
<li>Finally, find the <strong class="source-inline">disable the submit button when submitting</strong> test and modify it in the same way as <em class="italic">Step 12</em>.</li>
</ol>
<p>That’s it for test <a id="_idIndexMarker1202"/>changes, and <strong class="source-inline">doSave</strong> is almost fully redundant. However, the call to <strong class="source-inline">onSave</strong> still needs to be migrated across into the Redux saga, which we’ll do in the next section.</p>
<h2 id="_idParaDest-220"><a id="_idTextAnchor252"/>Navigating router history in a Redux saga</h2>
<p>Recall<a id="_idIndexMarker1203"/> that <a id="_idIndexMarker1204"/>it is the <strong class="source-inline">App</strong> component that renders <strong class="source-inline">CustomerForm</strong>, and <strong class="source-inline">App</strong> passes a function to the <strong class="source-inline">CustomerForm</strong>’s <strong class="source-inline">onSave</strong> prop that causes page navigation. When the customer information has been submitted, the user is moved onto the <strong class="source-inline">/addAppointment</strong> route.</p>
<p>But now that the form submission happens within a Redux saga, how do we call the <strong class="source-inline">onSave</strong> prop? The answer is that we can’t. Instead, we can move page navigation into the saga itself and delete the <strong class="source-inline">onSave</strong> prop entirely.</p>
<p>To do this, we must update <strong class="source-inline">src/index.js</strong> to use <strong class="source-inline">HistoryRouter</strong> rather than <strong class="source-inline">BrowserRouter</strong>. That allows<a id="_idIndexMarker1205"/> you to pass in your own history singleton object, which you can then explicitly construct yourself and then access via the saga. Proceed as follows:</p>
<ol>
<li value="1">Create a new file named <strong class="source-inline">src/history.js</strong> and add the following content to it. This is<a id="_idIndexMarker1206"/> very<a id="_idIndexMarker1207"/> similar to what we already did in <strong class="source-inline">test/reactTestExtensions.js</strong>:<p class="source-code">import { createBrowserHistory } from "history";</p><p class="source-code">export const appHistory = createBrowserHistory();</p></li>
<li>Update <strong class="source-inline">src/index.js</strong>, as shown here:<p class="source-code">import React from "react";</p><p class="source-code">import ReactDOM from "react-dom/client";</p><p class="source-code">import { Provider } from "react-redux";</p><p class="source-code"><strong class="bold">import {</strong></p><p class="source-code"><strong class="bold">  unstable_HistoryRouter as HistoryRouter</strong></p><p class="source-code"><strong class="bold">} from "react-router-dom";</strong></p><p class="source-code"><strong class="bold">import { appHistory } from "./history";</strong></p><p class="source-code">import { configureStore } from "./store";</p><p class="source-code">import { App } from "./App";</p><p class="source-code">ReactDOM.createRoot(</p><p class="source-code">  document.getElementById("root")</p><p class="source-code">).render(</p><p class="source-code">  &lt;Provider store={configureStore()}&gt;</p><p class="source-code"><strong class="bold">    &lt;HistoryRouter history={appHistory}&gt;</strong></p><p class="source-code">      &lt;App /&gt;</p><p class="source-code"><strong class="bold">   &lt;/HistoryRouter&gt;</strong></p><p class="source-code">  &lt;/Provider&gt;</p><p class="source-code">);</p></li>
<li>Now, we can use <strong class="source-inline">appHistory</strong> in our saga. Open <strong class="source-inline">test/sagas/customer.js</strong> and add the following <strong class="source-inline">import</strong> statement to the<a id="_idIndexMarker1208"/> top <a id="_idIndexMarker1209"/>of the file:<p class="source-code">import { appHistory } from "../../src/history";</p></li>
<li>Then, add the following two tests to define how the navigation should occur:<p class="source-code">it("navigates to /addAppointment on success", () =&gt; {</p><p class="source-code">  store.dispatch(addCustomerRequest());</p><p class="source-code">  expect(appHistory.location.pathname).toEqual(</p><p class="source-code">    "/addAppointment"</p><p class="source-code">  );</p><p class="source-code">});</p><p class="source-code">it("includes the customer id in the query string when navigating to /addAppointment", () =&gt; {</p><p class="source-code">  store.dispatch(addCustomerRequest());</p><p class="source-code">  expect(</p><p class="source-code">    appHistory.location.search</p><p class="source-code">  ).toEqual("?customer=123");</p><p class="source-code">});</p></li>
<li>To make these pass, start by opening <strong class="source-inline">src/sagas/customer.js</strong> and adding the following <strong class="source-inline">import</strong> statement:<p class="source-code">import { appHistory } from "../history";</p></li>
<li>Then, update the <strong class="source-inline">addCustomer</strong> generator function to navigate after a customer<a id="_idIndexMarker1210"/> has <a id="_idIndexMarker1211"/>been added successfully, like so:<p class="source-code">export function* addCustomer({ customer }) {</p><p class="source-code">  ...</p><p class="source-code">  yield put({</p><p class="source-code">    type: "ADD_CUSTOMER_SUCCESSFUL",</p><p class="source-code">    customer: customerWithId,</p><p class="source-code">  });</p><p class="source-code"><strong class="bold">  appHistory.push(</strong></p><p class="source-code"><strong class="bold">    `/addAppointment?customer=${customerWithId.id}`</strong></p><p class="source-code"><strong class="bold">  );</strong></p><p class="source-code">}</p></li>
<li>Now, all that’s left is to delete the existing <strong class="source-inline">onSave</strong> plumbing from <strong class="source-inline">App</strong> and <strong class="source-inline">CustomerForm</strong>. Open <strong class="source-inline">test/App.test.js</strong> and delete the following three tests:<ul><li><strong class="source-inline">calls fetch with correct configuration</strong></li>
<li><strong class="source-inline">navigates to /addAppointment after the CustomerForm is submitted</strong></li>
<li><strong class="source-inline">passes saved customer to AppointmentFormLoader after the CustomerForm is submitted</strong></li>
</ul></li>
<li>You can also delete the <strong class="source-inline">beforeEach</strong> block that sets up <strong class="source-inline">global.fetch</strong> in the nested <strong class="source-inline">describe</strong> block labeled <strong class="source-inline">when POST request returns an error</strong>.</li>
<li>In <strong class="source-inline">src/App.js</strong>, delete the definition of <strong class="source-inline">transitionToAddAppointment</strong> and change the <strong class="source-inline">/addCustomer</strong> route to have no <strong class="source-inline">onSave</strong> prop, as shown in the following code snippet. Your <strong class="source-inline">App</strong> tests should be passing at this point:<p class="source-code">&lt;Route</p><p class="source-code">  path="/addCustomer"</p><p class="source-code"><strong class="bold">  element={&lt;CustomerForm original={blankCustomer} /&gt;}</strong></p><p class="source-code">/&gt;</p></li>
<li>Now, we <a id="_idIndexMarker1212"/>can<a id="_idIndexMarker1213"/> delete the <strong class="source-inline">onSave</strong> prop from <strong class="source-inline">CustomerForm</strong>. Start by deleting the following tests from the <strong class="source-inline">CustomerForm</strong> test suite that are no longer necessary:<ul><li><strong class="source-inline">notifies onSave when form is submitted</strong></li>
<li><strong class="source-inline">does not notify onSave if the POST request returns an error</strong></li>
</ul></li>
<li>Delete the <strong class="source-inline">onSave</strong> prop from the <strong class="source-inline">CustomerForm</strong> component.</li>
<li>Finally, remove the invocation of <strong class="source-inline">doSave</strong> from <strong class="source-inline">handleSubmit</strong>. This function no longer awaits anything, so you can safely remove <strong class="source-inline">async</strong> from the function definition. At this point, all your tests should be passing.</li>
</ol>
<p>You’ve now seen how you can integrate a Redux store into your React components, and how you can control React Router navigatio<a id="_idTextAnchor253"/>n from within a Redux saga.</p>
<p>All being well, your application should now be running with Redux managing the workflow.</p>
<h1 id="_idParaDest-221"><a id="_idTextAnchor254"/>Summary</h1>
<p>This has been a whirlwind tour of Redux and how to refactor your application to it, using TDD.</p>
<p>As warned in the introduction of this chapter, Redux is a complex library that introduces a lot of extra plumbing into your application. Thankfully, the<a id="_idTextAnchor255"/> testing approach is straightforward.</p>
<p>In the next chapter, we’ll add yet another library: Relay, the GraphQL client.</p>
<h1 id="_idParaDest-222">Exercise<a id="_idTextAnchor256"/></h1>
<ul>
<li>Modify the customer reducer to ensure that <strong class="source-inline">error</strong> is reset to <strong class="source-inline">false</strong> when the <strong class="source-inline">ADD_CUSTOMER_SUCCESSFUL</strong> action occurs.</li>
</ul>
<h1 id="_idParaDest-223"><a id="_idTextAnchor257"/>Further reading</h1>
<p>For more information, have a look at the following sources:</p>
<ul>
<li>MDN documentation on generator functions:</li>
</ul>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function*">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function*</a></p>
<ul>
<li>Home page for the <strong class="source-inline">expect-redux</strong> package:</li>
</ul>
<p><a href="https://github.com/rradczewski/expect-redux">https://github.com/rradczewski/expect-redux</a></p>
</div>
<div>
<div id="_idContainer038">
</div>
</div>
</div></body></html>