- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Diving Deep into Composition Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入探索组合模式
- en: The journey of building scalable and maintainable user interfaces is riddled
    with challenges. One primary challenge faced by developers is ensuring that components
    remain modular, reusable, and easy to understand as a code base grows. The more
    intertwined and tightly coupled our components become, the harder it is to maintain,
    test, or even onboard new team members.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 构建可扩展和可维护的用户界面的旅程充满了挑战。开发者面临的一个主要挑战是确保组件在代码库增长时保持模块化、可重用和易于理解。我们的组件变得越来越交织和紧密耦合，维护、测试或甚至让新团队成员加入就变得更加困难。
- en: Composition has emerged as a powerful technique to address this challenge, enabling
    developers to build more organized, scalable, and cleaner code bases. Instead
    of creating large, monolithic components that carry out numerous tasks, we break
    them down into smaller, more manageable pieces that can be combined in versatile
    ways. This offers us a clear path to streamline logic, enhance reusability, and
    maintain a clear separation of concerns.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 组合已成为解决这一挑战的有力技术，使开发者能够构建更组织化、可扩展和更干净的代码库。我们不是创建执行众多任务的大型、单体组件，而是将它们分解成更小、更易于管理的部分，这些部分可以以多种方式组合。这为我们提供了一条清晰的路径，以简化逻辑、增强可重用性，并保持关注点的清晰分离。
- en: This chapter is dedicated to understanding and mastering composition in React.
    We’ll delve into foundational techniques such as higher-order functions before
    transitioning into higher-order components and Hooks. You’ll learn how these tools
    seamlessly align with the principles of composition, allowing you to build more
    robust applications with React. Our journey will culminate with a deep dive into
    headless components, a paradigm that encapsulates logic without dictating the
    UI, offering unparalleled flexibility.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章致力于理解和掌握React中的组合。在过渡到高阶组件和Hooks之前，我们将深入研究基础技术，如高阶函数。你将学习这些工具如何无缝地与组合原则相匹配，使你能够使用React构建更健壮的应用程序。我们的旅程将以深入研究无头组件为高潮，这种范式封装了逻辑，而不规定UI，提供了无与伦比的灵活性。
- en: By the chapter’s end, you’ll appreciate the benefits of employing composition
    techniques. You’ll be equipped to create UIs that are not just scalable and maintainable
    but also a pleasure to work with. Let’s embark on this enlightening exploration
    of composition in React.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将欣赏到采用组合技术的益处。你将准备好创建不仅可扩展和可维护，而且令人愉悦的UI。让我们开始这次关于React中组合的启发式探索之旅。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding composition through higher-order components
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过高阶组件理解组合
- en: Diving deep into custom Hooks
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入探索自定义Hooks
- en: Developing a drop-down list component
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发下拉列表组件
- en: Exploring a headless component pattern
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索无头组件模式
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: A GitHub repository has been created to host all the code we discuss in the
    book. For this chapter, you can find the recommended structure at [https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch1](https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch10)0.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 已创建一个GitHub仓库来托管本书中讨论的所有代码。对于本章，你可以在[https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch1](https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch10)找到推荐的架构。
- en: Understanding composition through higher-order components
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过高阶组件理解组合
- en: Composition might be the most important technique in software design overall,
    and like many other fundamental design principles, it applies on many different
    levels. In this section, we’ll review how we can use higher-order functions and
    their variation in the React world – higher-order components – to implement composition.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 组合可能是软件设计中最重要的技术之一，就像许多其他基本设计原则一样，它适用于许多不同的层面。在本节中，我们将回顾如何在React世界中使用高阶函数及其变体——高阶组件——来实现组合。
- en: Reviewing higher-order functions
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复习高阶函数
- en: We discussed some examples of higher-order functions in [*Chapter 9*](B21103_09.xhtml#_idTextAnchor227),
    but it’s such an important concept that I would like to review it a bit more here.
    A **higher-order function** (**HOF**) is a function that either takes another
    function as its argument, returns a function, or both. The ability to accept a
    function as a parameter has a lot of advantages, especially when it comes to composition.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第9章讨论了一些高阶函数的例子，但这是一个如此重要的概念，我想在这里再详细回顾一下。**高阶函数**（**HOF**）是一个函数，它要么接受另一个函数作为其参数，要么返回一个函数，或者两者都是。接受函数作为参数的能力有很多优点，尤其是在组合方面。
- en: 'Consider the following example:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, the `report` function generates a formatted report containing a header,
    the provided content, and a footer. For instance, given the input `hello world`,
    the output would be as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`report`函数生成一个包含标题、提供的内容和页脚的格式化报告。例如，给定输入`hello world`，输出将如下所示：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, imagine a scenario where some users wish to print the content in uppercase.
    While we could achieve this with `content.toUpperCase()`, other users might prefer
    the content as-is. Introducing conditions within our report function is one approach
    to pleasing both sets of users. Drawing inspiration from our previous discussion
    about the title example in [*Chapter 9*](B21103_09.xhtml#_idTextAnchor227), we
    can allow a `transformer` function to be passed.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一个场景，其中一些用户希望将内容打印为大写。虽然我们可以通过`content.toUpperCase()`来实现这一点，但其他用户可能更喜欢内容保持原样。在报告函数中引入条件是取悦这两组用户的一种方法。从我们之前关于第9章标题示例的讨论中汲取灵感，我们可以允许传递一个`transformer`函数。
- en: 'This enables clients to format the string as they desire, like so:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得客户可以按照自己的意愿格式化字符串，如下所示：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For flexibility, we can provide a default transformer, ensuring that those
    who don’t wish to customize the format can use the function without changes:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了灵活性，我们可以提供一个默认的转换器，确保那些不想自定义格式的人可以使用该函数而不做任何更改：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The report function generates a string with a defined header and footer, and
    the main content in between. It accepts a content string and an optional transformer
    function. If the transformer is provided, it modifies the content; otherwise,
    the content remains unchanged. The result is a formatted report with the modified
    or original content placed between the header and footer. That’s essentially how
    powerful HOFs can be, helping us to write more composable code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 报告函数生成一个包含定义的标题和页脚以及中间主要内容的字符串。它接受一个内容字符串和一个可选的转换函数。如果提供了转换函数，它将修改内容；否则，内容保持不变。结果是带有修改后或原始内容放置在标题和页脚之间的格式化报告。这就是HOFs如此强大的本质，帮助我们编写更可组合的代码。
- en: Reflecting upon this, an interesting thought emerges – can we incorporate this
    composable and functional approach into our React applications? Indeed, we can.
    The ability to augment components isn’t just limited to standard functions. In
    React, we have **higher-order** **components** (**HOCs**).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 反思这一点，一个有趣的想法浮现出来——我们能否将这种可组合和功能性的方法融入到我们的React应用程序中？确实，我们可以。增强组件的能力并不仅限于标准函数。在React中，我们有**高阶组件**（**HOCs**）。
- en: Introducing HOCs
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍HOCs
- en: An HOC is essentially a function that accepts a component and returns a new,
    enhanced version of it. The principle behind HOCs is straightforward – they allow
    you to inject additional functionality into an existing component. This pattern
    is especially beneficial when you want to reuse certain behaviors across multiple
    components.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: HOC本质上是一个接受组件并返回其新、增强版本的函数。HOC背后的原理很简单——它们允许你向现有组件注入额外的功能。这种模式特别有益于当你想在多个组件之间重用某些行为时。
- en: 'Let’s delve into an example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入一个例子：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this snippet, we define a function, `checkAuthorization`, to handle the authorization
    check. Then, we create a HOC, `withAuthorization`. This HOC takes a component
    (`Component`) as its argument and returns a new function. This returned function,
    when rendered, will either render the original `Component` (if the user is authorized)
    or a `Login` component (if the user is not authorized).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们定义了一个函数`checkAuthorization`来处理授权检查。然后，我们创建了一个HOC，`withAuthorization`。这个HOC接受一个组件（`Component`）作为其参数，并返回一个新的函数。这个返回的函数在渲染时，将根据用户是否授权来渲染原始的`Component`或`Login`组件。
- en: 'Now, suppose we have a `ProfileComponent` that we want to secure. We can use
    `withAuthorization` to create a new, secured version of `ProfileComponent`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们有一个想要保护的`ProfileComponent`。我们可以使用`withAuthorization`来创建一个新的、受保护的`ProfileComponent`版本：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This means that whenever `Profile` is rendered, it will first check whether
    a user is authorized. If so, it renders `ProfileComponent`; otherwise, it redirects
    the user to the `Login` component.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着每当`Profile`被渲染时，它首先会检查用户是否有权限。如果有，它将渲染`ProfileComponent`；否则，它将用户重定向到`Login`组件。
- en: Now that we’ve seen how HOCs can control access with `withAuthorization`, let’s
    shift our focus to enhancing user interactions. We’ll delve into an `ExpandablePanel`
    component, showcasing how HOCs can also manage interactive UI elements and state
    transitions.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何使用`withAuthorization`来控制访问权限，让我们将注意力转向增强用户交互。我们将深入研究`ExpandablePanel`组件，展示HOC如何管理交互式UI元素和状态转换。
- en: Implementing an ExpandablePanel component
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现`ExpandablePanel`组件
- en: Let’s kick things off with a basic `ExpandablePanel` component. This component,
    as the name suggests, consists of a title and a content area. Initially, the content
    area is collapsed, but a click on the title expands it to reveal the content.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基本的`ExpandablePanel`组件开始。正如其名所示，这个组件由一个标题和一个内容区域组成。最初，内容区域是折叠的，但点击标题可以将其展开以显示内容。
- en: '![Figure 10.1: An expandable panel](img/B31103_10_01.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1：可展开的面板](img/B31103_10_01.jpg)'
- en: 'Figure 10.1: An expandable panel'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1：可展开的面板
- en: 'The code for such a component is straightforward:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一个组件的代码很简单：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, suppose we want to jazz it up a bit, making the panel expand automatically
    when rendered and then collapse after a few seconds. Here’s how we could adjust
    the code to achieve that:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想要让它更加生动，使得面板在渲染时自动展开，然后几秒钟后折叠。以下是调整代码以实现这一目标的方法：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this revised version, we initialize `isOpen` to `true` so that the panel
    starts as expanded. Then, we utilize `useEffect` to set a timer that collapses
    the panel after 3,000 milliseconds (3 seconds).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个修订版本中，我们将`isOpen`初始化为`true`，以便面板以展开状态开始。然后，我们使用`useEffect`设置一个计时器，在3,000毫秒（3秒）后折叠面板。
- en: 'This pattern of auto-collapsing components is quite common in UI development
    – think of notifications, alerts, or tooltips that disappear after a while. To
    promote code reusability, let’s extract this auto-collapsing logic into a HOC:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这种自动折叠组件的模式在UI开发中相当常见——想想通知、警报或提示，它们在一段时间后会消失。为了提高代码的可重用性，让我们将这个自动折叠逻辑提取到一个HOC中：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In `withAutoClose`, we define a generic HOC that adds auto-closing functionality
    to any component. This HOC accepts a duration parameter to customize the auto-close
    delay, defaulting to 2,000 milliseconds (2 seconds).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在`withAutoClose`中，我们定义了一个通用的HOC，它为任何组件添加自动关闭功能。这个HOC接受一个持续时间参数来定制自动关闭延迟，默认为2,000毫秒（2秒）。
- en: 'To ensure a smooth integration, we can also extend `PanelProps` to include
    optional `Toggleable` properties:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保顺利集成，我们还可以扩展`PanelProps`以包括可选的`Toggleable`属性：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we can refactor `ExpandablePanel` to accept `isOpen` and toggle props
    from `withAutoClose`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以重构`ExpandablePanel`以接受`isOpen`和从`withAutoClose`来的切换属性：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'With this setup, creating an auto-closing version of `ExpandablePanel` is a
    breeze:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种设置，创建一个自动关闭版本的`ExpandablePanel`变得轻而易举：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And guess what? The auto-closing logic we’ve encapsulated in `withAutoClose`
    can be reused across various components:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 而且你知道吗？我们封装在`withAutoClose`中的自动关闭逻辑可以在各种组件之间重用：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The versatility of HOCs shines when it comes to composition – the ability to
    apply one HOC to the result of another. This capability aligns well with the principle
    of function composition in functional programming.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: HOC的通用性在组合方面表现得尤为出色——将一个HOC应用于另一个HOC的结果的能力。这种能力与函数式编程中的函数组合原则相吻合。
- en: 'Let’s consider another HOC, `withKeyboardToggle`, which augments a panel’s
    behavior to respond to keyboard inputs to toggle the panel’s expanded/collapsed
    state. Here’s the code for `withKeyboardToggle`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一个HOC，`withKeyboardToggle`，它增强面板的行为以响应键盘输入来切换面板的展开/折叠状态。以下是`withKeyboardToggle`的代码：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the `withKeyboardToggle` HOC, a reference (`divRef`) is created for the wrapping
    `div` to enable keyboard interactions. The `handleKeyDown` function defines the
    behavior for the *Enter*, *Space*, and *Escape* keys – the *Enter* or *Space*
    keys toggle the panel’s state, while the *Escape* key removes focus from the panel.
    These keyboard event handlers allow the wrapped component to respond to keyboard
    navigation.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `withKeyboardToggle` 高阶组件（HOC）中，创建了一个引用（`divRef`）用于包装 `div` 以启用键盘交互。`handleKeyDown`
    函数定义了 *Enter*、*Space* 和 *Escape* 键的行为——*Enter* 或 *Space* 键切换面板的状态，而 *Escape* 键则从面板移除焦点。这些键盘事件处理器允许包装组件响应键盘导航。
- en: 'Now, let’s compose `withKeyboardToggle` and `withAutoClose` together to create
    a new component, `AccessibleAutoClosePanel`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将 `withKeyboardToggle` 和 `withAutoClose` 组合起来创建一个新的组件，`AccessibleAutoClosePanel`：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the `withAutoClose(withKeyboardToggle(ExpandablePanel), 2000);` expression,
    `withKeyboardToggle` is first applied to `ExpandablePanel`, enhancing it with
    keyboard toggle capability. The result is then fed into `withAutoClose`, which
    further enhances the component to auto-close after a 2,000-millisecond delay.
    This chaining of HOCs results in a new component, `AccessibleAutoClosePanel`,
    which inherits both the keyboard toggle and auto-close behaviors.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `withAutoClose(withKeyboardToggle(ExpandablePanel), 2000);` 表达式中，`withKeyboardToggle`
    首先应用于 `ExpandablePanel`，增强了其键盘切换功能。然后，这个结果被输入到 `withAutoClose` 中，进一步增强了组件，使其在
    2,000 毫秒后自动关闭。这种 HOCs 的链式调用产生了一个新的组件，`AccessibleAutoClosePanel`，它继承了键盘切换和自动关闭的行为。
- en: 'This is a vivid example of how HOCs can be nested and composed to build more
    complex behavior from simpler, single-responsibility components, which is illustrated
    further in *Figure 10**.2*:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个生动的例子，说明了如何将 HOCs 嵌套和组合起来，从更简单、单一职责的组件构建更复杂的行为，这在 *图 10.2* 中进一步说明。2*：
- en: '![Figure 10.2: A Higher-Order Component](img/B31103_10_02.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.2：高阶组件](img/B31103_10_02.jpg)'
- en: 'Figure 10.2: A Higher-Order Component'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2：高阶组件
- en: If you have some background in object-oriented programming, this concept might
    resonate with you, as it aligns with the **Decorator** design pattern. If you’re
    not familiar, it dynamically adds behaviors to objects by wrapping them in additional
    objects, rather than altering their structure. This allows for greater flexibility
    than subclassing, as it extends functionality without modifying the original object.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一些面向对象编程的背景，这个概念可能对你有共鸣，因为它与 **装饰器** 设计模式相吻合。如果你不熟悉，它通过将对象包装在额外的对象中来动态地为对象添加行为，而不是改变其结构。这比继承提供了更大的灵活性，因为它在不修改原始对象的情况下扩展了功能。
- en: Now, while HOCs remain beneficial in various scenarios for both class components
    and functional components, React Hooks offer a more lightweight approach to achieving
    composition. Let’s look at Hooks next.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尽管 HOCs 在各种场景下对类组件和函数组件都有益，但 React Hooks 提供了一种更轻量级的方法来实现组合。让我们接下来看看 Hooks。
- en: Exploring React Hooks
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 React Hooks
- en: '**Hooks** provide a means to extract stateful logic from a component, enabling
    its independent testing and reuse. They pave the way for reutilizing stateful
    logic without altering your component hierarchy. Essentially, Hooks let you “hook
    into” React state and other life cycle features from function components.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**Hooks** 提供了一种从组件中提取有状态逻辑的方法，使其能够独立测试和重用。它们为在不改变组件层次结构的情况下重用有状态逻辑铺平了道路。本质上，Hooks
    允许你从函数组件中“钩入”React 状态和其他生命周期特性。'
- en: 'Following on from the `ExpandablePanel` component example, let’s look at this
    code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接着从 `ExpandablePanel` 组件的例子来看，让我们看看这段代码：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this `useAutoClose` Hook, we create an `isOpen` state and a function toggle
    to switch the state. The `useEffect` function sets a timer to change `isOpen`
    to `false` after a specified duration, but only if `isOpen` is `true`. It also
    cleans up the timer to prevent memory leaks.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `useAutoClose` Hooks 中，我们创建了一个 `isOpen` 状态和一个切换状态的函数。`useEffect` 函数设置一个计时器，在指定的时间后将
    `isOpen` 改为 `false`，但仅当 `isOpen` 为 `true` 时。它还清理计时器以防止内存泄漏。
- en: 'Now, to integrate this Hook into our `ExpandablePanel`, minimal amendments
    are needed:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了将这个 Hook 集成到我们的 `ExpandablePanel` 中，需要做的最小修改：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we deleted the passed-in `isOpen` and `toggle` props and utilized the
    return value from the `useAutoClose` Hook, seamlessly incorporating the auto-close
    functionality.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们删除了传入的 `isOpen` 和 `toggle` 属性，并利用了 `useAutoClose` Hooks 的返回值，无缝地结合了自动关闭功能。
- en: 'Next, to incorporate keyboard navigation, we define another Hook, `useKeyboard`,
    which captures key events to toggle the panel:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了实现键盘导航，我们定义了另一个 Hook，`useKeyboard`，它捕获按键事件以切换面板：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, embedding `useKeyboard` within `ExpandablePanel` is straightforward:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `ExpandablePanel` 中嵌入 `useKeyboard` 是直接的：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, `handleKeyDown` from `useKeyboard` is employed to detect key presses,
    enhancing our component with keyboard interactivity.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`useKeyboard` 的 `handleKeyDown` 被用来检测按键，增强了我们的组件的键盘交互性。
- en: 'In *Figure 10**.3*, you can observe how the Hooks link with the underlying
    `ExpandablePanel`, contrasting the HOC scenario where the component is wrapped:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 10*.*3* 中，你可以观察到钩子如何与底层的 `ExpandablePanel` 相关联，与组件被包装的 HOC 场景形成对比：
- en: '![Figure 10.3: Using alternative Hooks](img/B31103_10_03.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.3：使用替代钩子](img/B31103_10_03.jpg)'
- en: 'Figure 10.3: Using alternative Hooks'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3：使用替代钩子
- en: Hooks embody a neat package of reusable logic, isolated from the component yet
    easily integrated. Unlike the wrapping approach of HOCs, Hooks offer a plugin
    mechanism, making them lightweight and well-managed by React. This characteristic
    of Hooks not only promotes code modularity but also facilitates a cleaner and
    more intuitive way to enrich our components with additional functionalities.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 钩子体现了一组整洁的可重用逻辑，与组件隔离但易于集成。与 HOCs 的包装方法不同，Hooks 提供了一种插件机制，使它们轻量级且由 React 管理良好。Hooks
    的这一特性不仅促进了代码模块化，还提供了一种更干净、更直观的方式来丰富我们的组件，增加额外的功能。
- en: However, be aware that Hooks offer more versatility than initially apparent.
    They’re not just for managing UI-related state but are also effective for handling
    UI side effects, such as data fetching and global event handling (such as page-level
    keyboard shortcuts). We have seen how to use them for keyboard event handlers,
    so now, let’s explore how Hooks can streamline network requests.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，Hooks 的多功能性比最初看起来更广。它们不仅用于管理与 UI 相关的状态，而且对于处理 UI 副作用也非常有效，例如数据获取和全局事件处理（如页面级别的键盘快捷键）。我们已经看到了如何使用它们来处理键盘事件处理器，现在，让我们探索
    Hooks 如何简化网络请求。
- en: Unveiling remote data fetching
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 揭示远程数据获取
- en: In previous chapters, we leveraged `useEffect` for data fetching, a prevalent
    approach. When retrieving data from a remote server, it typically necessitates
    the introduction of three distinct states – `loading`, `error`, and `data`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们利用 `useEffect` 进行数据获取，这是一种常见的做法。当从远程服务器获取数据时，通常需要引入三种不同的状态 – `loading`、`error`
    和 `data`。
- en: 'Here’s a method to implement these states:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个实现这些状态的方法：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding code, we use React Hooks to manage asynchronous data fetching,
    initializing states for `loading`, `data`, and `error`. Inside `useEffect`, the
    `fetchData` function attempts to retrieve user data from the `"/api/users"` endpoint.
    If successful, the data is stored; if not, an error is recorded. Regardless of
    the outcome, the loading state is updated to reflect completion. `useEffect` runs
    only once, similar to the component’s initial mounting phase.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用 React 钩子来管理异步数据获取，初始化 `loading`、`data` 和 `error` 的状态。在 `useEffect`
    中，`fetchData` 函数尝试从 `"/api/users"` 端点获取用户数据。如果成功，数据将被存储；如果不成功，将记录错误。无论结果如何，都会更新加载状态以反映完成情况。`useEffect`
    只运行一次，类似于组件的初始挂载阶段。
- en: Refactoring for elegance and reusability
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化重构以实现优雅和可重用性
- en: 'Incorporating fetching logic directly within our component can work, but it’s
    not the most elegant or reusable approach. Let’s refactor this by extracting the
    fetching logic into a separate function:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 将获取逻辑直接嵌入我们的组件中是可以工作的，但这不是最优雅或最可重用的方法。让我们通过将获取逻辑提取到单独的函数中来重构它：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'With the `fetchUsers` function in place, we can take a step further by abstracting
    our fetching logic into a generic Hook. This Hook will accept a fetch function
    and manage the associated `loading`, `error`, and `data` states:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `fetchUsers` 函数就位后，我们可以通过将获取逻辑抽象成一个通用的钩子来更进一步。这个钩子将接受一个获取函数并管理相关的 `loading`、`error`
    和 `data` 状态：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, the `useService` Hook emerges as a reusable solution to fetch data across
    our application. It’s a neat abstraction that we can employ to fetch various types
    of data, as seen here:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`useService` 钩子作为跨应用获取数据的可重用解决方案出现。它是一个整洁的抽象，我们可以用它来获取各种类型的数据，如下所示：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: With this refactoring, we’ve not only simplified our data fetching logic but
    also made it reusable across different scenarios in our application. This sets
    a solid foundation as we continue to enhance our drop-down component and delve
    deeper into more advanced features and optimizations.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这次重构，我们不仅简化了数据获取逻辑，还使其可以在应用的不同场景中重用。这为我们继续增强下拉组件并深入研究更高级的功能和优化奠定了坚实的基础。
- en: As we have explored Hooks and their capabilities in managing state and logic,
    let’s apply this knowledge to build a more complex UI component from scratch —
    a drop-down list. This exercise will not only reinforce our understanding of Hooks
    but also demonstrate their practical application in creating interactive UI elements.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们探索了钩子和它们在管理状态和逻辑方面的能力，让我们将这些知识应用到从头构建一个更复杂的UI组件——下拉列表。这个练习不仅将加强我们对钩子的理解，还将展示它们在创建交互式UI元素中的实际应用。
- en: We’ll start with a basic version of a drop-down list and then gradually introduce
    more features to make it functional and user-friendly. This process will also
    set the stage for a later discussion on headless components, showcasing a design
    pattern that further abstracts and manages state and logic in UI components.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从下拉列表的基本版本开始，然后逐步引入更多功能，使其功能齐全且用户友好。这个过程也将为后续关于无头组件的讨论奠定基础，展示一个进一步抽象和管理UI组件状态和逻辑的设计模式。
- en: Developing a drop-down list component
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发下拉列表组件
- en: A drop-down list is a common component used in many places. Although there’s
    a native select component for basic use cases, a more advanced version offering
    more control over each option provides a better user experience.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 下拉列表是一个在许多地方都常用的组件。尽管有原生选择组件用于基本用例，但一个更高级的版本，提供对每个选项的更多控制，可以提供更好的用户体验。
- en: '![Figure 10.4: A drop-down list component](img/B31103_10_04.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4：下拉列表组件](img/B31103_10_04.jpg)'
- en: 'Figure 10.4: A drop-down list component'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4：下拉列表组件
- en: When creating one from scratch, a complete implementation requires more effort
    than it appears at first glance. It’s essential to consider keyboard navigation,
    accessibility (for instance, screen reader compatibility), and usability on mobile
    devices, among others.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当从头开始创建时，完整的实现所需的努力比最初看起来要多。必须考虑键盘导航、可访问性（例如，屏幕阅读器兼容性）以及移动设备上的可用性等问题。
- en: We’ll begin with a simple, desktop version that only supports mouse clicks,
    gradually building in more features to make it realistic. Note that the goal here
    is to reveal a few software design patterns rather than teach you how to build
    a drop-down list for production use (actually, I don’t recommend doing this from
    scratch and would instead suggest using more mature libraries).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从简单的桌面版本开始，仅支持鼠标点击，逐步添加更多功能以使其更真实。请注意，这里的目的是揭示一些软件设计模式，而不是教你如何构建用于生产环境的下拉列表（实际上，我不建议从头开始构建，而是建议使用更成熟的库）。
- en: 'Basically, we need an element (let’s call it a trigger) for the user to click,
    and a state to control the show and hide actions of the list panel. Initially,
    we hide the panel, and when the trigger is clicked, we show the list panel. Here
    is the code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们需要一个用户可以点击的元素（让我们称它为触发器），以及一个状态来控制列表面板的显示和隐藏操作。最初，我们隐藏面板，当触发器被点击时，我们显示列表面板。以下是代码：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the code, we’ve set up the basic structure for our drop-down component. Using
    the `useState` Hook, we manage the `isOpen` and `selectedItem` states to control
    the dropdown’s behavior. A simple click on the trigger toggles the drop-down menu,
    while selecting an item updates the `selectedItem` state.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们已经为我们的下拉组件设置了基本结构。使用`useState`钩子，我们管理`isOpen`和`selectedItem`状态来控制下拉的行为。简单的点击触发器可以切换下拉菜单，而选择一个项目会更新`selectedItem`状态。
- en: 'Let’s break down the component into smaller, manageable pieces to see it more
    clearly. We’ll start by extracting a `Trigger` component to handle user clicks:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将组件分解成更小、更易于管理的部分，以便更清晰地看到它。我们将首先提取一个`Trigger`组件来处理用户点击：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Similarly, we’ll extract a `DropdownMenu` component to render the list of items:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们将提取一个`DropdownMenu`组件来渲染项目列表：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, in the `Dropdown` component, we simply use these two components, passing
    in the corresponding state, turning them into purely controlled components (stateless
    components):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`Dropdown`组件中，我们只需简单地使用这两个组件，传入相应的状态，将它们转换为纯受控组件（无状态组件）：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In this updated code structure, we’ve separated concerns by creating specialized
    components for different parts of the dropdown, making the code more organized
    and easier to manage. We can see the result here:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个更新的代码结构中，我们通过为下拉的不同部分创建专门的组件来分离关注点，使代码更加有序且易于管理。我们在这里可以看到结果：
- en: '![Figure 10.5: A native implementation list](img/B31103_10_05.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5：原生实现列表](img/B31103_10_05.jpg)'
- en: 'Figure 10.5: A native implementation list'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5：原生实现列表
- en: As you can see in *Figure 10**.5*, the basic drop-down list appears, but that’s
    only a small part of the whole drop-down list features. Keyboard navigation, for
    example, is a necessary feature for an accessible component, which we will implement
    next.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在*图10**.5*中看到的，基本的下拉列表出现了，但这只是整个下拉列表功能的一小部分。例如，键盘导航是一个可访问组件的必要功能，我们将在下一部分实现它。
- en: Implementing keyboard navigation
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现键盘导航
- en: Incorporating keyboard navigation within our drop-down list enhances the user
    experience by providing an alternative to mouse interactions. This is particularly
    important for accessibility and offers a seamless navigation experience on a web
    page. Let’s explore how we can achieve this using the `onKeyDown` event handler.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下拉列表中集成键盘导航，通过提供鼠标交互的替代方案来增强用户体验。这对于可访问性尤为重要，并在网页上提供无缝的导航体验。让我们探讨如何使用`onKeyDown`事件处理器来实现这一点。
- en: 'Initially, we’ll attach a `handleKeyDown` function to the `onKeyDown` event
    in our `Dropdown` component. Here, we utilize a `switch` statement to determine
    the specific key pressed and perform actions accordingly. For instance, when the
    `Enter` or `Space` key is pressed, the dropdown is toggled. Similarly, the `ArrowDown`
    and `ArrowUp` keys allow navigation through the list items, cycling back to the
    start or end of the list when necessary:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我们将`handleKeyDown`函数附加到`Dropdown`组件中的`onKeyDown`事件。在这里，我们使用`switch`语句来确定按下的特定键并执行相应的操作。例如，当按下`Enter`或`Space`键时，下拉菜单会切换。同样，`ArrowDown`和`ArrowUp`键允许在列表项之间导航，当需要时循环回到列表的开始或结束：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Additionally, we have updated our `DropdownMenu` component to accept a `selectedIndex`
    prop. This prop is used to apply a highlighted style and set the aria-selected
    attribute to the currently selected item, enhancing the visual feedback and accessibility:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们已更新我们的`DropdownMenu`组件以接受`selectedIndex`属性。此属性用于应用高亮样式并将`aria-selected`属性设置为当前选定的项，增强视觉反馈和可访问性：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Moving forward, we can encapsulate the state and keyboard event handling logic
    within a custom Hook named `useDropdown`. This Hook returns an object containing
    the necessary states and functions, which can be destructured and used within
    our `Dropdown` component, keeping it clean and maintainable:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的工作中，我们可以将状态和键盘事件处理逻辑封装在一个名为`useDropdown`的自定义钩子中。此钩子返回一个包含必要状态和函数的对象，可以在`Dropdown`组件中使用解构，保持其整洁和可维护性：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, our `Dropdow`n component is simplified and more readable; it leverages
    the `useDropdown` Hook to manage its state and handle keyboard interactions, demonstrating
    a clear separation of concerns and making the code easier to understand and manage:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的`Dropdow`n组件已经简化并更具可读性；它利用`useDropdown`钩子来管理其状态和处理键盘交互，展示了关注点的清晰分离，使得代码更容易理解和维护：
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Through these modifications, we have successfully implemented keyboard navigation
    in our drop-down list, making it more accessible and user-friendly. This example
    also illustrates how Hooks can be utilized to manage complex state and logic in
    a structured and modular manner, paving the way for further enhancements and feature
    additions to our UI components.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些修改，我们成功地在下拉列表中实现了键盘导航，使其更具可访问性和用户友好性。此示例还说明了如何利用钩子以结构化和模块化的方式管理复杂的状态和逻辑，为我们的UI组件的进一步增强和功能添加铺平道路。
- en: 'We can visualize the code a bit better with the React DevTools. Note that in
    the **hooks** section, all the states are listed:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用React DevTools更好地可视化代码。请注意，在**钩子**部分，所有状态都被列出：
- en: '![Figure 10.6: Chrome DevTools to inspect what’s in the hooks section](img/B31103_10_06.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6：使用Chrome DevTools检查钩子部分的内容](img/B31103_10_06.jpg)'
- en: 'Figure 10.6: Chrome DevTools to inspect what’s in the hooks section'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6：使用Chrome DevTools检查钩子部分的内容
- en: The power of extracting our logic into a Hook comes into full play when we need
    to implement a different UI while maintaining the same underlying functionality.
    By doing so, we’ve segregated our state management and interaction logic from
    the UI rendering, making it a breeze to change the UI without touching the logic.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要实现不同的UI同时保持相同的基本功能时，将我们的逻辑提取到钩子中时，其威力就完全显现出来。通过这样做，我们将状态管理和交互逻辑从UI渲染中分离出来，使得在不接触逻辑的情况下更改UI变得轻而易举。
- en: We’ve explored how utilizing small components with custom Hooks can enhance
    our code structure. However, what happens when we’re faced with managing more
    complex states? Consider a scenario where the drop-down data comes from a service
    API, requiring us to handle asynchronous service calls along with additional state
    management. In such cases, does this structure still hold up effectively?
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了如何利用带有自定义钩子的小组件来增强我们的代码结构。然而，当我们面临管理更复杂的状态时会发生什么？考虑一个下拉数据来自服务 API 的场景，需要我们处理异步服务调用以及额外的状态管理。在这种情况下，这种结构是否仍然有效？
- en: The scenario of fetching data from a remote source brings forth the necessity
    to manage a few more states – specifically, we need to handle loading, error,
    and data states. As illustrated in *Figure 10**.7*, besides displaying a regular
    list, we also aim to manage scenarios where the data is not immediately accessible
    – either when it’s still loading from a remote API or it isn’t available.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 从远程源获取数据的场景需要管理更多的状态——具体来说，我们需要处理加载、错误和数据状态。如图 *图 10*.7 所示，除了显示常规列表外，我们还旨在管理数据不可立即访问的情况——要么是它仍在从远程
    API 加载，要么是不可用。
- en: '![Figure 10.7: Different statuses](img/B31103_10_07.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.7：不同的状态](img/B31103_10_07.jpg)'
- en: 'Figure 10.7: Different statuses'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7：不同的状态
- en: Such states, while common, are crucial for the user experience. Take, for instance,
    a drop-down list featuring country names. It’s a common feature, yet when we open
    the list, the names might still be loading, during which a loading indicator is
    displayed. Additionally, in situations where the downstream service is unavailable
    or other errors arise, an error message is presented instead.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的状态，虽然很常见，但对于用户体验至关重要。以一个包含国家名称的下拉列表为例。这是一个常见的功能，但当我们打开列表时，名称可能仍在加载，此时会显示一个加载指示器。此外，在下游服务不可用或其他错误发生的情况下，会显示错误消息。
- en: When extending our existing code, it’s crucial to deliberate on the additional
    states that will be introduced. Let’s explore strategies to preserve simplicity
    as we integrate new features.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当扩展我们现有的代码时，深思熟虑将要引入的额外状态至关重要。让我们探讨在集成新功能时保持简洁的策略。
- en: Maintaining simplicity in the Dropdown component
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在下拉组件中保持简洁性
- en: 'Incorporating remote data fetching has not complicated our `Dropdown` component,
    thanks to the abstracted logic in the `useService` and `useDropdown` Hooks. Our
    component code remains in its simplest form, effectively managing the fetching
    states and rendering the content based on the data received:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `useService` 和 `useDropdown` 钩子中的抽象逻辑，引入远程数据获取并没有使我们的 `Dropdown` 组件变得复杂。我们的组件代码保持最简形式，有效地管理获取状态并根据接收到的数据渲染内容：
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this updated `Dropdown` component, we utilize the `useService` Hook to manage
    the data fetching states and the `useDropdown` Hook to manage the drop-down-specific
    states and interactions. The `renderContent` function elegantly handles the rendering
    logic based on the fetching states, ensuring that the correct content is displayed,
    whether it’s loading, an error, or data.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个更新的 `Dropdown` 组件中，我们使用 `useService` 钩子来管理数据获取状态，使用 `useDropdown` 钩子来管理下拉特定的状态和交互。`renderContent`
    函数优雅地处理基于获取状态的渲染逻辑，确保正确的内容被显示，无论是加载、错误还是数据。
- en: Through the separation of concerns and the use of Hooks, our `Dropdown` component
    remains clean and straightforward, showcasing the power of composable logic in
    React. Now, this pattern actually has a particular name in building UI – the Headless
    Component pattern. Let’s look at it in more detail.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过关注点的分离和钩子的使用，我们的 `Dropdown` 组件保持简洁直观，展示了 React 中可组合逻辑的力量。现在，这种模式在构建 UI 时实际上有一个特定的名称——无头组件模式。让我们更详细地看看它。
- en: Introducing the Headless Component pattern
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入无头组件模式
- en: The **Headless Component pattern** unveils a robust avenue to cleanly segregate
    our JSX code from the underlying logic. While composing a declarative UI with
    JSX comes naturally, the real challenge lies in managing state. This is where
    headless components come into play, by shouldering all the state management intricacies
    and propelling us toward a new horizon of abstraction.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**无头组件模式**揭示了一条强大的途径，可以干净地分离我们的 JSX 代码和底层逻辑。虽然使用 JSX 构建声明性 UI 来说很自然，但真正的挑战在于管理状态。这就是无头组件发挥作用的地方，它承担了所有状态管理的复杂性，并推动我们迈向抽象的新境界。'
- en: In essence, a **Headless Component** is a function or object that encapsulates
    logic but doesn’t render anything itself. It leaves the rendering part to the
    consumer, thus offering a high degree of flexibility in how the UI is rendered.
    This pattern can be exceedingly useful when we have complex logic that we want
    to reuse across different visual representations.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本质上，**无头组件**是一个封装逻辑但不自身渲染任何内容的函数或对象。它将渲染部分留给消费者，从而在UI的渲染方式上提供了高度的灵活性。当我们有复杂的逻辑想要在不同视觉表示中重用时，这种模式可以非常有用。
- en: 'As shown in the following code, the `useDropdownLogic` Hook has all the logic
    but no UI elements, while `MyDropdown` uses the headless component and only has
    to deal with rendering logic:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下代码所示，`useDropdownLogic` Hook拥有所有逻辑但没有UI元素，而`MyDropdown`使用无头组件，并且只需处理渲染逻辑：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In a visual representation, the headless component acts as a thin interface
    layer. On one side, it interacts with JSX views, and on the other, it communicates
    with underlying data models. We touched upon data modeling in [*Chapter 8*](B21103_08.xhtml#_idTextAnchor212)
    and will revisit it in [*Chapter 11*](B21103_11.xhtml#_idTextAnchor286). This
    pattern is particularly beneficial for individuals seeking solely the behavior
    or state management aspect of the UI, as it conveniently segregates it from the
    visual representation.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在视觉表示中，无头组件充当一个薄接口层。在一侧，它与JSX视图交互，在另一侧，它与底层数据模型通信。我们在[*第8章*](B21103_08.xhtml#_idTextAnchor212)中提到了数据建模，我们将在[*第11章*](B21103_11.xhtml#_idTextAnchor286)中重新讨论它。这种模式对那些只寻求UI的行为或状态管理方面的人来说特别有益，因为它方便地将它从视觉表示中分离出来。
- en: Let’s see a visual illustration in *Figure 10**.8*. You can think of your code
    as having a few layers – the JSX is on the top and is response for the look and
    feel part of the application, the headless component (Hooks in this case) manages
    all the stateful logic, and beneath them is the domain layer, which has the logic
    to handle data mapping and transformation (we will go into more detail on this
    in [*Chapter 11*](B21103_11.xhtml#_idTextAnchor286) and [*Chapter 12*](B21103_12.xhtml#_idTextAnchor323)).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在*图10*.*8*中看看一个视觉说明。你可以把你的代码看作有几个层次——JSX在顶部，负责应用的外观和感觉部分，无头组件（在这种情况下是Hooks）管理所有有状态的逻辑，在其下方是领域层，它具有处理数据映射和转换的逻辑（我们将在[*第11章*](B21103_11.xhtml#_idTextAnchor286)和[*第12章*](B21103_12.xhtml#_idTextAnchor323)中详细介绍这一点)。
- en: '![Figure 10.8: The Headless Component pattern](img/B31103_10_08.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图10.8：无头组件模式](img/B31103_10_08.jpg)'
- en: 'Figure 10.8: The Headless Component pattern'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8：无头组件模式
- en: In summarizing the Headless Component pattern, it’s worth mentioning that although
    it can be realized through HOCs or render props, its implementation as a React
    Hook is more prevalent. Within the Headless Component pattern, all shareable logic
    is encapsulated, allowing for a seamless transition to other UIs without necessitating
    any modifications to the stateful logic.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 总结无头组件模式时，值得提到的是，尽管它可以通过HOCs或render props实现，但作为React Hook的实现更为普遍。在无头组件模式中，所有可共享的逻辑都被封装起来，允许无缝过渡到其他UI，而无需对状态逻辑进行任何修改。
- en: The advantages and drawbacks of Headless Component pattern
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无头组件模式的优势和缺点
- en: 'The advantages of the Headless Component pattern include the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 无头组件模式的优势包括以下内容：
- en: '**Reusability**: The logic encapsulated in Headless Component pattern can be
    reused across multiple components. This fosters **Don’t Repeat Yourself** (**DRY**)
    principles in your codebase.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重用性**：封装在无头组件模式中的逻辑可以在多个组件之间重用。这促进了代码库中的**不要重复自己**（DRY）原则。'
- en: '**Separation of concerns**: By decoupling logic from rendering, headless components
    promote a clear separation of concerns, which is a cornerstone of maintainable
    code.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关注点分离**：通过将逻辑与渲染解耦，无头组件促进了关注点的清晰分离，这是可维护代码的基石。'
- en: '**Flexibility**: They allow for varying UI implementations while sharing the
    same core logic, making it easier to adapt to different design requirements or
    frameworks.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**：它们允许在共享相同核心逻辑的同时，实现不同的UI实现，这使得适应不同的设计要求或框架变得更加容易。'
- en: 'The drawbacks of Headless Component pattern include the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 无头组件模式的缺点包括以下内容：
- en: '**Learning curve**: The pattern may introduce a learning curve for developers
    unfamiliar with it, potentially slowing down development initially.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**学习曲线**：这种模式可能会给不熟悉它的开发者带来学习曲线，这可能会在最初阶段减缓开发速度。'
- en: '**Over-abstraction**: If not managed judiciously, the abstraction created by
    headless components can lead to a level of indirection that might make the code
    harder to follow.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过度抽象**：如果不加以妥善管理，无头组件创建的抽象可能会导致代码难以跟踪的间接层次。'
- en: Libraries and further learnings
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图书馆和进一步的学习
- en: 'The Headless Component pattern has been embraced by various libraries to facilitate
    the creation of accessible, customizable, and reusable components. Here are some
    [notable l](https://react-spectrum.adobe.com/react-aria/)ibraries along with a
    brief description of each:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Headless Component 模式已被各种库所采用，以促进可访问、可定制和可重用组件的创建。以下是一些[知名库](https://react-spectrum.adobe.com/react-aria/)及其简要描述：
- en: '**React Aria**: A library from Adobe that provides accessibility primitives
    and Hooks to build inclusive React applications. It offers a collection of Hooks
    to manage keyboard interactions, focus management, and Aria annot[ations, mak](https://headlessui.dev/)ing
    it easier to create accessible UI components.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**React Aria**：Adobe 提供的库，提供可访问性原语和 Hooks，以构建包容性的 React 应用程序。它提供了一系列 Hooks，用于管理键盘交互、焦点管理和
    Aria 注释，使创建可访问的 UI 组件变得更加容易。'
- en: '**Headless UI**: A completely unstyled, fully accessible UI component library,
    designed to integrate beautifully with Tailwind CSS. It provides the behavior
    and accessibility f[oundation u](https://react-table.tanstack.com/)pon which you
    can build your own styled components.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Headless UI**：一个完全无样式的、完全可访问的 UI 组件库，旨在与 Tailwind CSS 美妙集成。它提供了构建自定义样式组件的行为和可访问性基础。'
- en: '**React Table**: A headless utility for building fast and extendable tables
    and data grids for React. It provides a flexible Hook that allows you to create
    co[mplex tab](https://www.downshift-js.com/)les with ease, leaving the UI representation
    up to you.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**React Table**：一个为 React 构建快速和可扩展表格和数据网格的无头实用工具。它提供了一个灵活的 Hook，允许你轻松创建复杂的表格，并将
    UI 表示留给你自己。'
- en: '**Downshift**: A minimalist library to help you create accessible and customizable
    dropdowns, comboboxes, and so on. It handles all the logic while letting you define
    the rendering aspect.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Downshift**：一个帮助您创建可访问和可定制下拉列表、组合框等的简约库。它处理所有逻辑，同时让您定义渲染方面。'
- en: These libraries embody the essence of the Headless Component pattern by encapsulating
    complex logic and behaviors, making it straightforward to create highly interactive
    and accessible UI components. While the provided example serves as a learning
    stepping stone, it’s prudent to leverage these production-ready libraries to build
    robust, accessible, and customizable components in a real-world scenario.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这些库通过封装复杂的逻辑和行为，体现了 Headless Component 模式的精髓，使得创建高度交互和可访问的 UI 组件变得简单。虽然提供的示例可以作为学习的垫脚石，但在实际场景中构建强大、可访问和可定制的组件时，利用这些生产级库是明智的。
- en: This pattern not only educates us on managing complex logic and state but also
    encourages us to explore production-ready libraries that have honed the Headless
    Component approach, delivering robust, accessible, and customizable components
    for real-world use.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式不仅教会我们如何管理复杂的逻辑和状态，还鼓励我们探索经过磨炼的 Headless Component 方法，为实际应用提供强大、可访问和可定制的组件的生产级库。
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we delved into the world of HOCs and Hooks in React, exploring
    their utility in enhancing component logic while maintaining a clean, readable
    code base. Through the lens of creating an expandable panel and a drop-down list,
    we illustrated the composability of HOCs and the encapsulation of stateful logic
    that Hooks offer. Transitioning to a more intricate drop-down list, we introduced
    asynchronous data fetching, demonstrating how Hooks can simplify state management
    in data-loading scenarios.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了 React 中的高阶组件（HOCs）和钩子（Hooks）的世界，探讨了它们在增强组件逻辑的同时保持干净、可读的代码库中的效用。通过创建可展开的面板和下拉列表的视角，我们展示了
    HOCs 的可组合性和 Hooks 提供的状态逻辑封装。过渡到更复杂的下拉列表，我们介绍了异步数据获取，展示了 Hooks 如何简化数据加载场景中的状态管理。
- en: We then transitioned into the realm of Headless Component, a powerful pattern
    that separates logic from the JSX code, providing a robust framework to manage
    state while leaving the UI representation to the developer. Through examples,
    we demonstrated how this separation facilitates the creation of reusable, accessible,
    and customizable components. The discussion was enriched with a review of notable
    libraries, such as React Table, Downshift, React Aria, and Headless UI, that embody
    the Headless Component pattern, providing ready-to-use solutions to build interactive
    and accessible UI components.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们过渡到了无头组件的领域，这是一种强大的模式，它将逻辑与JSX代码分离，提供了一个强大的框架来管理状态，同时将UI表示留给开发者。通过示例，我们展示了这种分离如何促进可重用、可访问和可定制的组件的创建。讨论内容得到了对一些知名库的回顾，如React
    Table、Downshift、React Aria和Headless UI，这些库体现了无头组件模式，提供了构建交互式和可访问UI组件的现成解决方案。
- en: In the upcoming chapter, we’ll implement the patterns we’ve discussed and delve
    into architectural strategies to enhance modularity. We’ll also address the challenges
    posed by larger applications.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将实现我们讨论过的模式，并深入研究增强模块化的架构策略。我们还将解决大型应用程序带来的挑战。
- en: 'Part 4: Engaging in Practical Implementation'
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四部分：参与实际实施
- en: In the final part of this book, you will apply your accumulated knowledge in
    a hands-on manner by employing a layered architecture in React and journeying
    through an end-to-end project implementation. This part aims to encapsulate the
    essence of all the principles, patterns, and practices discussed throughout the
    book.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的最后一部分，您将通过在React中使用分层架构并经历端到端项目实施的过程，以实际操作的方式应用您积累的知识。本部分旨在总结书中讨论的所有原则、模式和最佳实践。
- en: 'This part contains the following chapters:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 11*](B21103_11.xhtml#_idTextAnchor286), *Introducing Layered Architecture
    in React*'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B21103_11.xhtml#_idTextAnchor286), *在React中引入分层架构*'
- en: '[*Chapter 12*](B21103_12.xhtml#_idTextAnchor323), *Implementing an End-To-End
    Project*'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B21103_12.xhtml#_idTextAnchor323), *实施端到端项目*'
- en: '[*Chapter 13*](B21103_13.xhtml#_idTextAnchor356), *Recapping Anti-Pattern Principles*'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B21103_13.xhtml#_idTextAnchor356), *回顾反模式原则*'
