- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Transforming Streams
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换流
- en: When dealing with streams, one of the most frequent use cases you will face
    is the need to transform a stream of certain values into a stream of other values.
    That’s what this chapter is about.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理流时，您将面临的最常见用例之一是需要将某些值的流转换为其他值的流。这正是本章的主题。
- en: This chapter revolves around adding an autosave feature to our project that
    we will be resolving by transforming streams. We will start by explaining the
    autosave requirement that we will be implementing in the recipe app. Then, we
    will explore the imperative way of implementing this feature. After that, we will
    learn about the declarative pattern for doing it and study the most commonly used
    RxJS transformation operators for this situation.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章围绕向我们的项目添加自动保存功能展开，我们将通过转换流来解决。首先，我们将解释我们将要在食谱应用中实现的自定义保存需求。然后，我们将探索实现此功能的命令式方法。之后，我们将了解实现此功能的声明式模式，并研究在此情况下最常用的RxJS转换操作符。
- en: Finally, we will delve into the different transformation operators provided
    by RxJS and their respective use cases, enriching our understanding through hands-on
    examples.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将深入研究RxJS提供的不同转换操作符及其相应的用例，通过实际示例丰富我们的理解。
- en: 'So, in this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将涵盖以下主要内容：
- en: Defining the autosave requirement
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义自动保存需求
- en: Exploring the imperative pattern for the autosave feature
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索自动保存功能的命令式模式
- en: Exploring the declarative pattern for the autosave feature
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索自动保存功能的声明式模式
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter assumes that you have a basic understanding of RxJS.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设您对RxJS有基本的了解。
- en: For more details about Reactive forms, please refer to [https://angular.dev/guide/forms/reactive-forms](https://angular.dev/guide/forms/reactive-forms).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于响应式表单的详细信息，请参阅[https://angular.dev/guide/forms/reactive-forms](https://angular.dev/guide/forms/reactive-forms)。
- en: For demonstration purposes, we will be using a fake autosave service. Its implementation
    is available in the `recipes-book-api` module in this book’s GitHub repository.
    Note that we won’t be going through the details of this service as the focus is
    not the backend of the project.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示目的，我们将使用一个假自动保存服务。其实现可在本书GitHub仓库的`recipes-book-api`模块中找到。请注意，我们不会详细介绍这个服务，因为重点不是项目的后端。
- en: The source code of this chapter is available at [https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap06](https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap06).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可在[https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap06](https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap06)找到。
- en: Defining the autosave requirement
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义自动保存需求
- en: 'As described in the *View 2 – The New Recipe interface* section of [*Chapter
    2*](B21180_02.xhtml#_idTextAnchor031), *Walking through Our Application*, the
    user can add a new recipe by clicking on the **New Recipe** menu item. This will
    display the following form to be filled out:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如[*第二章*](B21180_02.xhtml#_idTextAnchor031)中“浏览我们的应用”部分的*视图2 – 新食谱界面*所述，用户可以通过点击**新食谱**菜单项来添加新食谱。这将显示以下需要填写的表单：
- en: '![Figure 6.1 – The New Recipe form](img/B21180_06_1.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 – 新食谱表单](img/B21180_06_1.jpg)'
- en: Figure 6.1 – The New Recipe form
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 新食谱表单
- en: The standalone component that’s responsible for displaying the `RecipeCreationComponent`
    and is available under `recipes-book-front\src\app\recipe-creation`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 负责显示`RecipeCreationComponent`的独立组件，可在`recipes-book-front\src\app\recipe-creation`下找到。
- en: Here, we want to implement the autosave behavior, which consists of storing
    the user’s changes in the form automatically. In this example, we will be storing
    the form changes in the backend so that the user can retrieve the last changes
    any time after a disconnection, a timeout, or other problems – this feature improves
    the user experience by preventing data loss.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们想要实现自动保存行为，这包括自动将用户更改以表单形式存储。在这个例子中，我们将把表单更改存储在后端，以便用户在断开连接、超时或其他问题后随时检索最后更改——这个功能通过防止数据丢失来提高用户体验。
- en: Now that we understand the requirement, let’s look at the imperative way to
    implement the autosave feature.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经理解了需求，让我们看看实现自动保存功能的命令式方法。
- en: Exploring the imperative pattern for the autosave feature
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索自动保存功能的命令式模式
- en: We used Angular Reactive forms to build the `valueChanges` Observable to track
    the `FormControl` changes. This makes our implementation easier since we want
    to listen to the form’s value changes to perform a save on every change.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了Angular响应式表单来构建`valueChanges` Observable以跟踪`FormControl`的变化。这使得我们的实现更加简单，因为我们想监听表单值的变化，以便在每次变化时执行保存操作。
- en: 'You can find the HTML code of the `recipe-creation.component.html` file template.
    Then, in `recipe-creation.component.ts`, we can define the form as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`recipe-creation.component.html`文件模板中找到HTML代码。然后，在`recipe-creation.component.ts`中，我们可以定义表单如下：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we used the Angular `FormBuilder` API to build the reactive form and pass
    to it a JSON object where we define the different fields of the form. This JSON
    object represents our recipe’s data; we’re going to save this later. Every time
    we open the **New Recipe** form, a new empty object will be created.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了Angular的`FormBuilder` API来构建响应式表单，并将其传递给一个JSON对象，在该对象中我们定义了表单的不同字段。这个JSON对象代表了我们的食谱数据；我们稍后会保存这个数据。每次我们打开**新食谱**表单时，都会创建一个新的空对象。
- en: Note that the first property of this JSON object, `id`, is not going to be displayed
    in the form. We only add it to initialize the new `Recipe` object with a random
    identifier to save the recipe’s data properly in the backend. The `tags` property
    is retrieved from a constant declared in `src/app/core/model/tags.ts` that represents
    the static list of available tags.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个JSON对象的第一属性`id`在表单中不会显示。我们只添加它来初始化新的`Recipe`对象，并使用随机标识符来正确地在后端保存食谱数据。`tags`属性是从`src/app/core/model/tags.ts`中声明的常量检索的，它代表了可用的静态标签列表。
- en: 'Now that we’ve prepared our form, let’s see how we can implement the autosave
    feature. The first thing that comes to mind is subscribing to the `valueChanges`
    Observable of `recipeForm` in the `ngOninit()` instance of `RecipeCreationComponent`.
    Then, every time the `valueChanges` Observable emits a new form value, we should
    raise a save request to save the most recent value of the form. We can do this
    like so:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了表单，让我们看看如何实现自动保存功能。首先想到的是在`RecipeCreationComponent`的`ngOninit()`实例中订阅`recipeForm`的`valueChanges`
    Observable。然后，每次`valueChanges` Observable发出新的表单值时，我们应该发起一个保存请求来保存表单的最新值。我们可以这样做：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `saveRecipe` method is then defined and implemented in `RecipeService`,
    as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`RecipeService`中定义并实现了`saveRecipe`方法，如下所示：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we use the `HTTPClient` API and call the save service in the backend.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`HTTPClient` API并调用了后端的保存服务。
- en: Note
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Backend implementation is not the focus of this book. For that reason, we’ve
    provided a fake implementation of the POST save service in the `recipes-book-api`
    project. Here, the goal is to simulate the call to an HTTP request to save the
    data.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 本书不关注后端实现。因此，我们在`recipes-book-api`项目中提供了一个POST保存服务的模拟实现。在这里，目标是模拟对HTTP请求的调用以保存数据。
- en: 'So, to recap, the code for `RecipeCreationComponent` will look like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结一下，`RecipeCreationComponent`的代码将如下所示：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'However, this code won’t work. You should know by now that the result of `this.service.saveRecipe(<Recipe>formValue)`,
    which calls ``this.http.post<Recipe>(`${BASE_PATH}/recipes`, formValue)``, is
    an Observable, and since Observables are lazy, we should subscribe to `this.service.saveRecipe(<Recipe>formValue)`
    to initiate the HTTP POST request. So, let’s add a `subscribe` value, like so:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这段代码不会工作。您现在应该知道，`this.service.saveRecipe(<Recipe>formValue)`的结果，它调用`this.http.post<Recipe>(`${BASE_PATH}/recipes`,
    formValue)`，是一个Observable，由于Observables是懒加载的，我们应该订阅`this.service.saveRecipe(<Recipe>formValue)`来初始化HTTP
    POST请求。所以，让我们添加一个`subscribe`值，如下所示：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you may have noticed, we called a `subscribe` value inside another `subscribe`,
    something we call a nested subscription. However, this is considered an anti-pattern
    in RxJS and is problematic for several reasons:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经注意到的，我们在另一个`subscribe`内部调用了一个`subscribe`值，这被称为嵌套订阅。然而，这在RxJS中被认为是一种反模式，并且存在几个问题：
- en: Every time we use `subscribe()`, we open the door to imperative code. As we
    have learned throughout this book, we should avoid this as much as possible.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次我们使用`subscribe()`时，我们打开了命令式代码的大门。正如我们在这本书中学到的，我们应该尽可能避免这样做。
- en: Nested subscriptions require careful cleanup; otherwise, we can run into various
    performance problems. In the previous example, we didn’t clean up the subscriptions,
    which means the possibility of serious timing issues arises. If multiple form
    values are emitted by `valueChanges` successively, many save requests will be
    sent in parallel. If the requests take some time to complete, there is no guarantee
    that the backend will process the save requests in order. For instance, we cannot
    ensure that the last valid form value is the one that’s been saved in the backend.
    Consequently, we will end up with data incoherence.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套订阅需要仔细清理；否则，我们可能会遇到各种性能问题。在上一个例子中，我们没有清理订阅，这意味着可能会出现严重的时序问题。如果有多个表单值连续由`valueChanges`发出，将并行发送许多保存请求。如果请求需要一些时间来完成，无法保证后端会按顺序处理保存请求。例如，我们无法确保最后一个有效的表单值是已保存到后端的那一个。因此，我们最终会得到不一致的数据。
- en: What we want to do is perform a save request after the previous one is completed.
    Luckily, RxJS includes some interesting operators that fix this for us. So, without
    further ado, in the following section, we’ll learn how to implement this in a
    reactive and declarative way.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要做的是在先前的请求完成后执行保存请求。幸运的是，RxJS包括一些有趣的操作符，可以为我们解决这个问题。所以，无需多言，在接下来的部分，我们将学习如何以响应式和声明式的方式实现这一点。
- en: Exploring the reactive pattern for the autosave feature
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索自动保存功能的响应式模式
- en: You remember the golden rule from [*Chapter 5*](B21180_05.xhtml#_idTextAnchor083),
    right? We should think of everything as a stream. So, let’s start by identifying
    our streams.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得[第5章](B21180_05.xhtml#_idTextAnchor083)中的黄金法则，对吧？我们应该把所有东西都看作是一个流。所以，让我们首先识别我们的流。
- en: Here, we can think of the save operation as a stream – it is the result of the
    `this.service.saveRecipe(<Recipe>formValue)` method, which calls ``this.http.post<Recipe>(`${BASE_PATH}/recipes`,
    formValue``. We will call it `saveRecipe$`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以将保存操作看作是一个流——它是`this.service.saveRecipe(<Recipe>formValue)`方法的结果，该方法调用`this.http.post<Recipe>(`${BASE_PATH}/recipes`,
    formValue)`。我们将称之为`saveRecipe$`。
- en: The `saveRecipe$` Observable is responsible for saving the data in the backend
    and will initiate the `http` request when subscribed to.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`saveRecipe$`可观察对象负责在后台保存数据，并在订阅时初始化`http`请求。'
- en: To avoid nesting subscriptions, what we can do in this situation is map or transform
    the form value emitted by the `valueChanges` Observable to the `saveRecipe$` Observable.
    The result is what we call a higher-order Observable.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免嵌套订阅，在这种情况下我们可以将`valueChanges`可观察对象发出的表单值映射或转换成`saveRecipe$`可观察对象。结果是我们要称之为高阶可观察对象的东西。
- en: Not clear? Don’t worry – we will explain this in detail in the next section.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 不清楚？不用担心——我们将在下一节中详细解释。
- en: Higher-order Observables
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高阶可观察对象
- en: So, what is a higher-order Observable? A **higher-order Observable** is just
    an Observable like any other, but its values are Observables as well. So, instead
    of emitting simple values such as strings, numbers, or arrays, it emits Observables
    that you can subscribe to separately.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是高阶可观察对象？一个**高阶可观察对象**就像其他任何可观察对象一样，但它的值也是可观察对象。所以，它不是发出简单的值，如字符串、数字或数组，而是发出你可以单独订阅的可观察对象。
- en: Okay, but when is it useful? You can create a higher-order Observable whenever
    you use data emitted from one Observable to emit another Observable. In our case,
    for every emitted form value from the `valueChanges` Observable, we want to emit
    the `saveRecipe$` Observable. In other words, we want to transform (or map) the
    form value to the `saveRecipe$` Observable. This would create a higher-order Observable
    where each value represents a save request.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，但它在什么时候有用？你可以在使用一个可观察对象发出的数据来发出另一个可观察对象时创建高阶可观察对象。在我们的例子中，对于`valueChanges`可观察对象发出的每个表单值，我们想要发出`saveRecipe$`可观察对象。换句话说，我们想要将表单值转换（或映射）到`saveRecipe$`可观察对象。这将创建一个高阶可观察对象，其中每个值代表一个保存请求。
- en: In this situation, the `valueChanges` Observable is called the outer Observable,
    and `saveRecipe$` is called the inner Observable. Under the hood, we want to subscribe
    to each `saveRecipe$` Observable that’s emitted and receive the response all in
    one go to avoid nested treatments.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`valueChanges`可观察对象被称为外部可观察对象，而`saveRecipe$`被称为内部可观察对象。在底层，我们想要订阅每个发出的`saveRecipe$`可观察对象并一次性接收响应，以避免嵌套处理。
- en: Now that we’ve learned what higher-order Observables are and when to use them,
    let’s look at higher-order mapping operators.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了高阶可观察对象是什么以及何时使用它们，让我们来看看高阶映射操作符。
- en: Higher-order mapping operators
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高阶映射操作符
- en: To transform the outer Observable, we should use higher-order mapping operators.
    The role of these operators is to map each value from an outer Observable to a
    new inner Observable and automatically subscribe and unsubscribe to/from that
    inner Observable.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要转换外部 Observable，我们应该使用高阶映射操作符。这些操作符的作用是将外部 Observable 的每个值映射到一个新的内部 Observable，并自动订阅和取消订阅该内部
    Observable。
- en: But what is the difference between regular mapping and higher-order mapping?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 但常规映射和高阶映射之间有什么区别呢？
- en: 'Well, regular mapping involves mapping one value to another value. One of the
    most used basic mapping operators is the `map` operator:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，常规映射涉及将一个值映射到另一个值。最常用的基本映射操作符之一是 `map` 操作符：
- en: '![Figure 6.2 – The map operator – marble diagram](img/B21180_06_2.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2 – 地图操作符 – 琥珀图](img/B21180_06_2.jpg)'
- en: Figure 6.2 – The map operator – marble diagram
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – 地图操作符 – 琥珀图
- en: As described in this marble diagram, the map operator will transform the values
    of the input stream by multiplying each emitted value by 10\. Here, `x=>10*x`
    is the transformation function.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如此琥珀图所述，地图操作符将通过将每个发出的值乘以 10 来转换输入流的值。这里，`x=>10*x` 是转换函数。
- en: On the other hand, higher-order mapping is about mapping one value into an Observable.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，高阶映射是关于将一个值映射到一个 Observable。
- en: RxJS provides several higher-order mapping operators. In the next section, we
    will learn about the `concatMap()` operator – which we will use to implement the
    autosave behavior – before discovering some other commonly used operators.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: RxJS 提供了几个高阶映射操作符。在下一节中，我们将学习 `concatMap()` 操作符——我们将使用它来实现自动保存行为——然后再了解一些其他常用操作符。
- en: The concatMap operator
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: concatMap 操作符
- en: '`concatMap` is a combination of the concatenation strategy and higher-order
    mapping:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`concatMap` 是连接策略和高阶映射的组合：'
- en: '*concatMap = concat (concatenation) + map (**higher-order mapping)*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*concatMap = concat (连接) + map (高阶映射)*'
- en: 'We looked at the concepts of regular and higher-order mapping in the previous
    section, so let’s look at the following marble diagram to understand the concatenation
    strategy, taking the example of the `concat` operator:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们探讨了常规和高阶映射的概念，现在让我们通过以下琥珀图来了解连接策略，以 `concat` 操作符为例：
- en: '![Figure 6.3 – The concat operator – marble diagram](img/B21180_06_3.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3 – concat 操作符 – 琥珀图](img/B21180_06_3.jpg)'
- en: Figure 6.3 – The concat operator – marble diagram
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – concat 操作符 – 琥珀图
- en: 'Let’s break down the marble diagram:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下琥珀图：
- en: The first line represents the timeline of the first Observable passed as input
    to the `concat` operator.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行表示传递给 `concat` 操作符的第一个 Observable 的时间线。
- en: The second line represents the timeline of the second Observable passed as input
    to the `concat` operator.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二行表示传递给 `concat` 操作符的第二个 Observable 的时间线。
- en: The `concat` operator in this example has two inputs. It will subscribe to the
    first Observable but not to the second one. The first Observable will emit the
    values **a** and **b**, which get reflected in the result Observable (the last
    line).
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在此示例中，`concat` 操作符有两个输入。它将订阅第一个 Observable，但不会订阅第二个。第一个 Observable 将发出值 **a**
    和 **b**，这些值将反映在结果 Observable（最后一行）中。
- en: Then, the first Observable completes, and at that moment, the `concat` operator
    subscribes to the second Observable. This is how a sequential process is guaranteed.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，第一个 Observable 完成，此时，`concat` 操作符订阅第二个 Observable。这就是保证顺序过程的方式。
- en: The second Observable will emit the values **x** and **y**, which get reflected
    in the result Observable.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个 Observable 将发出值 **x** 和 **y**，这些值将反映在结果 Observable 中。
- en: When the second Observable completes, the output Observable will also complete.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当第二个 Observable 完成，输出 Observable 也会完成。
- en: As you may have noticed, Observable concatenation is all about Observable completion.
    This is the key point. It emits the values of the first Observable, waits for
    it to complete, and then emits the values of the next Observable, and so on, until
    all the Observables complete.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能注意到的，Observable 连接完全是关于 Observable 完成的。这是关键点。它发出第一个 Observable 的值，等待它完成，然后发出下一个
    Observable 的值，依此类推，直到所有 Observable 都完成。
- en: 'Now that we understand the concatenation strategy, we can understand how the
    `concatMap` operator is a mixture of higher-order mapping and Observable concatenation:
    it waits for each inner Observable to complete before processing the next one.
    It’s like a line at a ticket counter, where each customer (Observable) waits for
    their turn to be served before the next one is called.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们理解了连接策略，我们可以理解`concatMap`运算符是如何结合高阶映射和Observable连接的：它在处理下一个之前等待每个内部Observable完成。它就像在票务柜台排队，每个客户（Observable）在下一个被叫到之前等待他们的服务。
- en: Using concatMap for autosaving
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用concatMap进行自动保存
- en: 'Based on the previous discussion, the `concatMap` operator fits very well with
    our autosave requirement for the following reasons:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 根据之前的讨论，`concatMap`运算符非常适合我们的自动保存需求，原因如下：
- en: We want to take the form value and turn it into a `saveRecipe$` Observable and
    automatically subscribe and unsubscribe from the `saveRecipe$` inner Observable
    – this is what a higher-order mapping operation does.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望将表单值转换为`saveRecipe$` Observable，并自动订阅和取消订阅`saveRecipe$`内部Observable - 这就是高阶映射操作所做的事情。
- en: We only want to perform a save request after the previous one is completed.
    When one HTTP save request is in progress, the other requests that come in the
    meantime should wait for its completion before being called to ensure sequentiality.
    So, we need to concatenate the `saveRecipe$` Observables together.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们只想在完成上一个请求后执行保存请求。当一个HTTP保存请求正在进行时，在此期间到达的其他请求应该在被调用之前等待其完成，以确保顺序性。因此，我们需要将`saveRecipe$`
    Observables连接起来。
- en: 'This is what our code will look like:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的代码将看起来像这样：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let’s break down what’s going on:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下正在发生的事情：
- en: Here, the outer Observable, `this.recipeForm.valueChanges`, emits form values.
    For each emitted form value, `concatMap` transforms it into `this.service.saveRecipe(<Recipe>formValue)`,
    which is the `saveRecipe$` Observable – our inner Observable.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这里，外部Observable `this.recipeForm.valueChanges`发出表单值。对于每个发出的表单值，`concatMap`将其转换为`this.service.saveRecipe(<Recipe>formValue)`，这是`saveRecipe$`
    Observable - 我们的内部Observable。
- en: '`concatMap` automatically subscribes to the inner Observable and the HTTP POST
    request will be issued.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`concatMap`自动订阅内部Observable，并将发出HTTP POST请求。'
- en: Another form value might come faster than the time it takes to save the previous
    form value in the backend. In this case, the form value will not be mapped to
    the `saveRecipe$` Observable. Instead, `concatMap` will wait for the previous
    save request to return a response and complete it before transforming the new
    form value to `saveRecipe$`, subscribing to it, and sending a new save request.
    When all inner Observables complete, the result stream completes.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个表单值可能比在后台保存上一个表单值所需的时间更快。在这种情况下，表单值将不会映射到`saveRecipe$` Observable。相反，`concatMap`将等待之前的保存请求返回响应并完成它，然后再将新的表单值转换为`saveRecipe$`，订阅它，并发送新的保存请求。当所有内部Observable完成时，结果流完成。
- en: Then, we use the `catchError` operator to handle the errors and register a side
    effect with the `tap` operator to log the `Saved successfully` message in the
    backend. You can customize this, of course, and display a message to the end user.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们使用`catchError`运算符来处理错误，并使用`tap`运算符注册副作用以在后台记录`Saved successfully`消息。当然，您可以自定义此操作，并向最终用户显示一条消息。
- en: 'To recap, the complete code for `RecipeCreationComponent` will now look like
    this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，`RecipeCreationComponent`的完整代码现在将看起来像这样：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, there’s just one thing left to do: we should subscribe to the `valueChanges$`
    Observable to make all of this work. As usual, we will do this through the async
    pipe in our `RecipeCreationComponent` HTML template, as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只剩下一件事要做：我们应该订阅`valueChanges$` Observable以使所有这些工作。像往常一样，我们将在`RecipeCreationComponent`
    HTML模板中的异步管道中这样做，如下所示：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With that, the reactive implementation is complete.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，响应式实现就完成了。
- en: As you may have noticed, the first benefit of using `concatMap` is that we no
    longer have nested subscriptions. We also get rid of explicit subscriptions thanks
    to the async pipe. Besides this, all form values are going to be sent to the backend
    sequentially.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经注意到的，使用`concatMap`的第一个好处是我们不再有嵌套订阅。由于异步管道，我们还消除了显式订阅。除此之外，所有表单值都将按顺序发送到后端。
- en: When a delay is introduced in the backend save service (which I’ve set up by
    default in the provided implementation of the save recipe service), you’ll notice
    that requests aren’t initiated while another one is still processing. Instead,
    they wait until the current request finishes before being triggered. This is exactly
    what `concatMap` aims to achieve.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当后端保存服务（我在提供的保存食谱服务实现中默认设置）引入延迟时，你会注意到在另一个请求仍在处理时不会发起请求。相反，它们会等待当前请求完成后才被触发。这正是`concatMap`旨在实现的效果。
- en: 'Now, let’s take a look at the behavior `concatMap` manifests in the Chrome
    DevTools **Network** tab:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`concatMap`在Chrome DevTools **网络**标签页中表现出的行为：
- en: '![Figure 6.4 – The concatMap network requests](img/B21180_06_4.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图6.4 – concatMap网络请求](img/B21180_06_4.jpg)'
- en: Figure 6.4 – The concatMap network requests
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – concatMap网络请求
- en: Here, upon typing a character, a POST save request is sent to the server. When
    trying to input other characters before the initial request, a response is received.
    You’ll notice that requests are not immediately triggered; they are queued and
    executed sequentially once the preceding request is completed.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在输入一个字符后，会向服务器发送一个POST保存请求。当尝试在初始请求之前输入其他字符时，会收到响应。你会注意到请求不是立即触发的；它们被排队，并在前一个请求完成后按顺序执行。
- en: Our example served as a straightforward illustration of how the `concatMap`
    operator works. However, we could optimize our implementation more to avoid sending
    requests for every character introduced by the user. To do so, we could use the
    `debounceTime(waitingTime)` operator to wait for the user input to stabilize before
    sending the requests. We could also optimize it further by ignoring duplicates
    and making the `distinctUntilChanged()` operator handle invalid values.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例直接说明了`concatMap`操作符的工作原理。然而，我们可以进一步优化我们的实现，以避免为用户输入的每个字符发送请求。为此，我们可以使用`debounceTime(waitingTime)`操作符等待用户输入稳定后再发送请求。我们还可以通过忽略重复项并让`distinctUntilChanged()`操作符处理无效值来进一步优化它。
- en: Note
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more details about the `debounceTime` and `distinctUntilChanged` operators,
    refer to [https://rxjs.dev/api/operators/debounceTime](https://rxjs.dev/api/operators/debounceTime)
    and [https://rxjs.dev/api/operators/distinctUntilChanged](https://rxjs.dev/api/operators/distinctUntilChanged),
    respectively.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`debounceTime`和`distinctUntilChanged`操作符的更多详细信息，请参阅[https://rxjs.dev/api/operators/debounceTime](https://rxjs.dev/api/operators/debounceTime)和[https://rxjs.dev/api/operators/distinctUntilChanged](https://rxjs.dev/api/operators/distinctUntilChanged)。
- en: Using concatMap for pagination
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用concatMap进行分页
- en: Besides autosaving, we can also use `concatMap` for list pagination. In our
    recipe app, we handle the Recipes list pagination on the client side – we retrieve
    all the recipes when loading `RecipesListComponent` by making a `GET` request
    to the `/api/recipes` service, as explained in [*Chapter 3*](B21180_03.xhtml#_idTextAnchor047),
    *Fetching Data* *as Streams*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 除了自动保存，我们还可以使用`concatMap`进行列表分页。在我们的食谱应用中，我们在客户端处理食谱列表的分页 – 当加载`RecipesListComponent`时，我们通过向`/api/recipes`服务发送`GET`请求来检索所有食谱，如[*第3章*](B21180_03.xhtml#_idTextAnchor047)中所述，*作为流获取数据*。
- en: 'However, if we were handling a lazy loading mechanism, where we fetch just
    a few items (let’s say 10) when the component loads initially, and then load more
    items as needed when the user clicks the **Next** or **Previous** buttons, as
    shown in the following screenshot, we’d need to adjust our logic:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们处理的是一个懒加载机制，在组件初始加载时只获取少量项目（比如说10个），然后在用户点击**下一页**或**上一页**按钮时按需加载更多项目，如图所示，我们需要调整我们的逻辑：
- en: '![Figure 6.5 – Recipes list pagination](img/B21180_06_5.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图6.5 – 食谱列表分页](img/B21180_06_5.jpg)'
- en: Figure 6.5 – Recipes list pagination
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 – 食谱列表分页
- en: This would involve sending a `GET` HTTP request to fetch the data for the next
    page, using a URL structure such as `GET /api/recipes?page=1&limit=10`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这将涉及发送一个`GET` HTTP请求来获取下一页的数据，使用类似于`GET /api/recipes?page=1&limit=10`的URL结构。
- en: 'In such a scenario, `concatMap` is a very good option to issue a request for
    each emitted “next page” event, as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`concatMap`是一个很好的选项来为每个发出的“下一页”事件发起请求，如下所示：
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, `pageNumberChange$` is a `BehaviorSubject` subject that emits the current
    page number whenever the user clicks on the `concatMap` then triggers subsequent
    HTTP GET requests, sequentially fetching the next page’s list based on the current
    page number and size limit parameters. This sequential handling ensures data integrity
    and systematic pagination flow.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`pageNumberChange$` 是一个 `BehaviorSubject` 主题，当用户点击 `concatMap` 时，它会发射当前的页面编号，然后触发后续的
    HTTP GET 请求，按顺序获取基于当前页面编号和大小限制参数的下一页列表。这种顺序处理确保了数据完整性和系统化的分页流程。
- en: To summarize, `concatMap` is the ideal choice when you want to ensure that operations
    are processed sequentially, and that each inner Observable is processed *one at
    a time and in order*. However, when using `concatMap`, it’s important to ensure
    that the inner Observable completes since `concatMap` waits for the completion
    of each inner Observable before subscribing to the next one in the sequence. If
    an inner Observable never completes, `concatMap` will also never subscribe to
    the subsequent Observables in the sequence. This can lead to blocking subsequent
    emissions and potential memory leaks or performance issues if there is a buildup
    of pending Observables. So, never use `concatMap` for endless streams.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，当你想确保操作按顺序处理，并且每个内部 Observable 都一次按顺序处理时，`concatMap` 是理想的选择。然而，当使用 `concatMap`
    时，重要的是要确保内部 Observable 完成，因为 `concatMap` 等待每个内部 Observable 完成后才订阅序列中的下一个 Observable。如果一个内部
    Observable 永远不完成，`concatMap` 也不会订阅序列中的后续 Observable。这可能导致阻塞后续发射，并可能导致挂起的 Observable
    堆积，从而引发潜在的内存泄漏或性能问题。因此，永远不要为无限流使用 `concatMap`。
- en: It’s important to note that not all higher-order mapping operators follow the
    `concat` strategy. There are other higher-order mapping operators, such as `switch`,
    `merge`, and `exhaust`, that offer different strategies and are useful in many
    situations. We’ll break down those operators and their respective strategies in
    the following sections.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，并非所有高阶映射操作符都遵循 `concat` 策略。还有其他高阶映射操作符，如 `switch`、`merge` 和 `exhaust`，它们提供不同的策略，并在许多情况下很有用。我们将在以下部分中分析这些操作符及其相应的策略。
- en: The switchMap operator
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: The switchMap operator
- en: '`switchMap` is a combination of the switch and transformation (or mapping)
    strategies:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`switchMap` 是 switch 和转换（或映射）策略的组合：'
- en: '*switchMap = switch(switch) + map (**higher-order mapping)*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*switchMap = switch(switch) + map（高阶映射）*'
- en: 'Let’s look at the marble diagram of the `switch` operator to understand the
    switch strategy:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `switch` 操作符的弹珠图，以了解 switch 策略：
- en: '![Figure 6.6 – The switch operator – marble diagram](img/B21180_06_6.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.6 – `switch` 操作符 – 弹珠图](img/B21180_06_6.jpg)'
- en: Figure 6.6 – The switch operator – marble diagram
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 – `switch` 操作符 – 弹珠图
- en: 'Let’s break down what’s happening here (you are not used to seeing those diagonal
    lines, I know!):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下这里发生的事情（我知道你们不习惯看到那些对角线，我知道！）：
- en: The top line is the higher-order Observable. The higher-order Observable emits
    the first inner Observable (which has the values **a**, **b**, **c**, and **d**).
    The switch operator subscribes to it under the hood.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶部行是高阶 Observable。高阶 Observable 发射第一个内部 Observable（具有值 **a**、**b**、**c** 和 **d**）。`switch`
    操作符在幕后订阅它。
- en: The first inner Observable emits the values **a** and **b**, and they get reflected
    automatically to the resulting Observable.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个内部 Observable 发射值 **a** 和 **b**，并且它们会自动反射到结果 Observable 中。
- en: Then, the higher-order Observable emits the second inner Observable (which has
    the values **e**, **f**, and **g**).
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，高阶 Observable 发射第二个内部 Observable（具有值 **e**、**f** 和 **g**）。
- en: The switch will unsubscribe from the first inner Observable (**a**-**b**-**c**-**d**)
    and subscribe to the second inner Observable (**e**-**f**-**g**); that’s why the
    values **e**, **f**, and **g** get reflected right after **a** and **b**. As you
    may have noticed, in switching, if a new Observable starts emitting values, then
    the switch will subscribe to the new Observable and unsubscribe from the previous
    one.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`switch` 将取消订阅第一个内部 Observable（**a**-**b**-**c**-**d**）并订阅第二个内部 Observable（**e**-**f**-**g**）；这就是为什么
    **e**、**f** 和 **g** 的值在 **a** 和 **b** 之后立即反映出来。正如你可能已经注意到的，在切换过程中，如果一个新的 Observable
    开始发射值，那么 `switch` 将订阅新的 Observable 并取消订阅之前的那个。'
- en: So, the `switchMap` operator is a higher-order mapping operator that unsubscribes
    from any prior inner Observable and switches to any new inner Observable. It is
    useful when you want to cancel an operation when a new one is triggered. In other
    words, `switchMap` only focuses on the most recent data, ensuring that only the
    latest updates are processed while canceling any ongoing operations triggered
    by previous data.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`switchMap`运算符是一个高阶映射运算符，它会取消订阅任何先前的内部Observable，并切换到任何新的内部Observable。当你想要在触发新操作时取消操作时，它非常有用。换句话说，`switchMap`只关注最新的数据，确保在取消由先前数据触发的任何正在进行的操作的同时，只处理最新的更新。
- en: 'Think of `switchMap` as changing TV channels: each time you press a button,
    you switch to a different channel, ignoring whatever was playing before. Similarly,
    `switchMap` lets you dynamically switch to a new Observable stream whenever the
    source emits, discarding any ongoing processing from previous emissions.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 将`switchMap`想象成切换电视频道：每次你按按钮，你都会切换到不同的频道，忽略之前正在播放的内容。同样，`switchMap`允许你在源发射时动态切换到新的Observable流，丢弃之前发射的任何正在进行的处理。
- en: Using switchMap for autosaving
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用`switchMap`进行自动保存
- en: 'Going back to our autosave reactive implementation in the Recipe app, if you’re
    interested in saving the most recent form value and want to cancel any ongoing
    save operation if a new one is initiated before the current one finishes, then
    `switchMap` is the operator to use (instead of `concatMap`):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们在食谱应用中的自动保存响应式实现，如果你想要保存最新的表单值，并且希望在当前操作完成之前启动新的操作时取消任何正在进行的保存操作，那么`switchMap`就是你要使用的运算符（而不是`concatMap`）：
- en: '[PRE9]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As mentioned previously, I introduced a slight delay in the backend save service
    to illustrate how ongoing requests are handled when subsequent requests are made
    concurrently. So, when inspecting the network console, you’ll notice the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我在后端保存服务中引入了轻微的延迟，以说明当并发提交后续请求时，如何处理正在进行的请求。因此，当检查网络控制台时，你会注意到以下情况：
- en: '![Figure 6.7 – The switchMap network requests](img/B21180_06_7.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图6.7 – switchMap网络请求](img/B21180_06_7.jpg)'
- en: Figure 6.7 – The switchMap network requests
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 – switchMap网络请求
- en: 'Here, we have two requests: one is marked as **canceled**, while the other
    is **pending**. The pending request is the most recent one, indicating that it
    was initiated while the previous request was still in progress, resulting in the
    cancellation of the prior request. And this is the behavior we aim for.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有两个请求：一个是标记为**已取消**，另一个是**挂起**。挂起的请求是最新的一个，这表明它在先前的请求仍在进行时被发起，导致先前的请求被取消。这正是我们想要的行为。
- en: In this example, we’re making an HTTP POST request, but we’re only interested
    in the success or failure status and don’t need any other data from the response.
    However, if you’re expecting a response from the POST request to update the UI
    or perform tasks, keep in mind that *only the response from the latest request
    will be propagated*. In such cases, it’s better to use `concatMap` instead.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在发送一个HTTP POST请求，但我们只对成功或失败状态感兴趣，不需要从响应中获取任何其他数据。然而，如果你期望从POST请求中获取响应以更新UI或执行任务，请记住，**只有最新请求的响应将被传播**。在这种情况下，最好使用`concatMap`。
- en: Using switchMap for autocompletion
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用`switchMap`进行自动完成
- en: 'Now, let’s explore another practical scenario of using `switchMap`: autocompleting
    suggestions. This is a very common feature in web applications. In our recipe
    app, we’ll implement an autocomplete dropdown for the `tags` field in `RecipeCreationComponent`.
    Currently, this field is displayed as a radio button with static values retrieved
    from the constant tags defined in `src/app/core/model/tags.ts`. However, we’ll
    transform it into a user-friendly autocomplete dropdown that dynamically fetches
    tag suggestions based on the user’s input.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索使用`switchMap`的另一个实际场景：自动完成建议。这是网络应用程序中一个非常常见的功能。在我们的食谱应用中，我们将实现`RecipeCreationComponent`中`tags`字段的自动完成下拉菜单。目前，该字段以单选按钮的形式显示，其静态值是从`src/app/core/model/tags.ts`中定义的常量标签检索的。然而，我们将将其转换为一个用户友好的自动完成下拉菜单，该菜单根据用户的输入动态获取标签建议。
- en: Whenever a user types a query, we’ll retrieve the corresponding tags from a
    backend service. We have already implemented a service for that in our ready-to-use
    backend – that is, `recipes-book-api`. This service has an endpoint called `/api/tags`,
    accepts some criteria (the user’s typed input) as a query parameter, and returns
    a list of tags that match the provided criteria. The code is available in this
    book’s GitHub repository.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户键入查询时，我们将从后端服务检索相应的标签。我们已经在我们的现成后端中实现了该服务 – 那就是我们的 `recipes-book-api`。此服务有一个名为
    `/api/tags` 的端点，接受一些标准（用户的输入）作为查询参数，并返回与提供的标准匹配的标签列表。代码可在本书的 GitHub 仓库中找到。
- en: 'Let’s delve into the implementation details. First and foremost, let’s prepare
    our streams. How many streams do we have? We have two:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解实现细节。首先，让我们准备我们的流。我们有多少个流？我们有两个：
- en: 'A stream, named `searchTerms`, that emits the user’s input, represented by
    a `BehaviorSubject` subject that’s initialized with an empty string:'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `searchTerms` 的流，它发出用户输入，由一个初始化为空字符串的 `BehaviorSubject` 主题表示：
- en: '[PRE10]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We’ll update this stream whenever the user’s input changes by using an `update`
    method:'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用 `update` 方法来更新此流，每当用户输入更改时：
- en: '[PRE11]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `searchTerms` stream and the `updateSearchTerm` method will be available
    in `RecipeCreationComponent`.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`searchTerms` 流和 `updateSearchTerm` 方法将在 `RecipeCreationComponent` 中可用。'
- en: 'A stream, named `getTags$`, that emits the fetched tags matching the user’s
    input. We’ll define this stream in `RecipesService`, as follows:'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `getTags$` 的流，它发出与用户输入匹配的检索到的标签。我们将在 `RecipesService` 中定义此流，如下所示：
- en: '[PRE12]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`getTags$` represents a function that takes a string parameter, `term`, and
    returns an Observable of the `Tag[]` type that issues an HTTP GET request to retrieve
    an array of `Tag` objects matching the provided search term.'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`getTags$` 代表一个函数，它接受一个字符串参数 `term`，并返回一个 `Tag[]` 类型的可观察对象，该对象发出一个 HTTP GET
    请求以检索与提供的搜索词匹配的 `Tag` 对象数组。'
- en: We defined the `Tag` type in `\src\app\core\model\tags.ts`.
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在 `\src\app\core\model\tags.ts` 中定义了 `Tag` 类型。
- en: 'Now, it’s time to use `switchMap`, which will map each value emitted by the
    `searchTerms` stream to the `getTags$` Observable:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候使用 `switchMap` 了，它将映射 `searchTerms` 流发出的每个值到 `getTags$` 可观察对象：
- en: '[PRE13]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We will define `tagValues$` in `RecipeCreationComponent`. So, overall, `tagValues$`
    issues a search request for every unique user’s input and ensures only the latest
    search results are displayed, discarding previous ones.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `RecipeCreationComponent` 中定义 `tagValues$`。所以，总的来说，`tagValues$` 为每个唯一的用户输入发出搜索请求，并确保只显示最新的搜索结果，丢弃之前的搜索结果。
- en: 'Finally, we will update the `RecipeCreationComponent` HTML template to modify
    how tags are displayed from a radio button to an autocomplete dropdown:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将更新 `RecipeCreationComponent` 的 HTML 模板，以修改显示标签的方式，从单选按钮更改为自动完成下拉菜单：
- en: '[PRE14]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we subscribed to `tagValues$` using the async pipe and stored the emitted
    value in a `tags` array. Then, we used the PrimeNG autocomplete component to provide
    suggestions as the user types in the `"Tags"` input field. The autocomplete component
    binds to a form control named `"tags",` receives suggestions from the `tags` array,
    and triggers the `updateSearchTerm` method with the user’s query when the user
    starts typing. `concatMap` will issue a GET request for every unique user’s input
    and ensure only the latest search results are displayed, canceling previous requests.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用异步管道订阅了 `tagValues$`，并将发出的值存储在 `tags` 数组中。然后，我们使用了 PrimeNG 自动完成组件来提供在用户在
    `"Tags"` 输入字段中输入时的建议。自动完成组件绑定到一个名为 `"tags"` 的表单控件，从 `tags` 数组接收建议，并在用户开始输入时触发
    `updateSearchTerm` 方法，使用户的查询。`concatMap` 将为每个唯一的用户输入发出 GET 请求，并确保只显示最新的搜索结果，取消之前的请求。
- en: 'And that’s it! Here’s an illustration of the implemented behavior. Here, when
    we enter **B** in the search field, we receive **Breakfast** a suggestion:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！以下是我们实现行为的说明。在这里，当我们搜索字段中输入 **B** 时，我们收到 **Breakfast** 的建议：
- en: '![Figure 6.8 – The autocompletion suggestion](img/B21180_06_8.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.8 – 自动完成建议](img/B21180_06_8.jpg)'
- en: Figure 6.8 – The autocompletion suggestion
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8 – 自动完成建议
- en: Now, let’s move on to another operator, `mergeMap`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续介绍另一个操作符，`mergeMap`。
- en: The mergeMap operator
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 合并映射操作符
- en: '`mergeMap` is a combination of the merge and transformation (or mapping) strategies:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`mergeMap` 是合并和转换（或映射）策略的组合：'
- en: '*mergeMap = merge(merge) + map (**higher-order mapping)*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*`mergeMap = merge(merge) + map (高阶映射)*'
- en: 'Now that you understand the concepts of higher-order mapping, let’s understand
    the merging strategy by looking at the following marble diagram, which considers
    the `merge` operator:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了高阶映射的概念，让我们通过查看以下考虑 `merge` 操作符的玛瑙图来了解合并策略：
- en: '![Figure 6.9 – The merge operator – marble diagram](img/B21180_06_9.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.9 – 合并操作符 – 玛瑙图](img/B21180_06_9.jpg)'
- en: Figure 6.9 – The merge operator – marble diagram
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.9 – 合并操作符 – 玛瑙图
- en: Unlike `concat`, `merge` will not wait for an Observable to complete before
    subscribing to the next Observable. It subscribes to every inner Observable at
    the same time and then outputs the values to the combined result. As described
    in this marble diagram, the values of the input Observables are reflected in the
    output immediately. The result will only be completed once all the merged Observables
    are completed.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `concat` 不同，`merge` 不会等待可观察对象完成再订阅下一个可观察对象。它同时订阅每个内部可观察对象，然后将值输出到组合结果中。如这个玛瑙图所示，输入可观察对象的值会立即反映在输出中。结果只有在所有合并的可观察对象都完成后才会完成。
- en: '`mergeMap` is a higher-order mapping operator that processes each inner Observable
    in parallel. It is like multitasking in the kitchen, where you’re simultaneously
    handling different cooking tasks, such as chopping, boiling, and mixing, all at
    once. However, you should only use `mergeMap` if the resulting order doesn’t matter
    because these requests may be processed out of order.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`mergeMap` 是一个高阶映射操作符，它并行处理每个内部可观察对象。这就像厨房中的多任务处理，你同时处理不同的烹饪任务，如切菜、煮菜和搅拌，所有这些同时进行。然而，只有当结果顺序不重要时才应使用
    `mergeMap`，因为这些请求可能会以不同的顺序处理。'
- en: 'Suppose we aim to retrieve a list of recipes that match specific tags. For
    every tag, we want to initiate an HTTP request to fetch the recipes corresponding
    to that tag. The order of tag requests is not important; all requests should be
    executed concurrently. Here’s the code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们旨在检索匹配特定标签的食谱列表。对于每个标签，我们想要发起一个 HTTP 请求以获取该标签对应的食谱。标签请求的顺序不重要；所有请求都应并发执行。以下是代码：
- en: '[PRE15]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we created an Observable named `selectedTags$` from a static array of
    tags. `selectedTags$` emits the tags (array elements) one by one. Whenever a tag
    is emitted by `selectedTags$`, an HTTP request is issued by `this.getRecipesByTag(tagName)`
    to fetch the corresponding recipes. The `mergeMap` operator is used to concurrently
    handle multiple tag requests. When another tag is emitted while the previous request
    is still in progress, the new request is executed concurrently.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从一个静态的标签数组中创建了一个名为 `selectedTags$` 的可观察对象。`selectedTags$` 逐个发出标签（数组元素）。每当
    `selectedTags$` 发出一个标签时，`this.getRecipesByTag(tagName)` 就会发出一个 HTTP 请求以获取相应的食谱。`mergeMap`
    操作符用于并发处理多个标签请求。当另一个标签在之前的请求仍在进行时发出，新的请求将并发执行。
- en: We used the `mergeAll` operator to flatten the results that were obtained from
    the different inner Observables into a single Observable stream. This ensures
    that the recipes emitted by each inner Observable are merged into a cohesive stream
    of recipes.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 `mergeAll` 操作符将来自不同内部可观察对象的结果扁平化到一个单一的观察者流中。这确保了每个内部可观察对象发出的食谱被合并成一个连贯的食谱流。
- en: Finally, the `toArray` operator is used to convert all emitted recipes into
    a single array, making it convenient for a list display in the UI.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用 `toArray` 操作符将所有发出的食谱转换成一个单一的数组，这使得在 UI 中进行列表显示变得方便。
- en: 'Again, I previously added a delay to the backend service that returns the recipes
    by tag. Upon opening the console, we’ll find that all the requests were run concurrently,
    even if there are pending ones:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我之前向按标签返回食谱的后端服务添加了延迟。打开控制台后，我们会发现所有请求都是并发运行的，即使有挂起的请求：
- en: '![Figure 6.10 – mergeMap’s execution](img/B21180_06_10.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.10 – mergeMap 的执行](img/B21180_06_10.jpg)'
- en: Figure 6.10 – mergeMap’s execution
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.10 – mergeMap 的执行
- en: 'We can also use `mergeMap` to fetch data from multiple sources in parallel
    and combine the results. Imagine that we have multiple Review sources for our
    recipes, and we want to collect them (in this case, the order here is not important).
    Here’s the code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `mergeMap` 并行从多个来源获取数据并合并结果。想象一下，我们有多个针对食谱的评论来源，我们想要收集它们（在这种情况下，顺序并不重要）。以下是代码：
- en: '[PRE16]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, `getRecipesReviews(recipeId: number)` is a method that fetches reviews
    for a recipe identified by `recipeId` from two different sources (`source1` and
    `source2`) by issuing parallel HTTP GET requests to each source.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，`getRecipesReviews(recipeId: number)` 是一个方法，它通过向每个来源（`source1` 和 `source2`）发出并行的
    HTTP GET 请求，从两个不同的来源获取由 `recipeId` 标识的菜谱的评论。'
- en: The `from([${BASE_PATH}/source1/reviews, ${BASE_PATH}/source2/reviews])` line
    creates an Observable from an array containing two different endpoints to fetch
    reviews. The `from` operator emits each item of the array as a separate value
    in the Observable sequence.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`from([${BASE_PATH}/source1/reviews, ${BASE_PATH}/source2/reviews])` 这一行从一个包含两个不同端点的数组创建了一个
    Observable，用于获取评论。`from` 操作符将数组中的每个项目作为 Observable 序列中的单独值发出。'
- en: Then, `mergeMap` is used to raise a GET request to fetch reviews for the specified
    `recipeId` for each endpoint emitted by the `from` operator, ensuring that both
    requests are made concurrently.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用 `mergeMap` 发起一个 GET 请求以获取每个由 `from` 操作符发出的端点指定的 `recipeId` 的评论，确保这两个请求是并发执行的。
- en: With that, let’s move on to the last operator that we will discuss, `exhaustMap`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，让我们继续讨论最后一个我们将要讨论的操作符，`exhaustMap`。
- en: The exhaustMap operator
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 排放Map操作符
- en: '`exhaustMap` is a combination of the exhaust and transformation (or mapping)
    strategies:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`exhaustMap` 是排放和转换（或映射）策略的组合：'
- en: '*exhaustMap = exhaust(exhaust) + map ()**higher-order mapping*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*exhaustMap = exhaust(exhaust) + map ()**高阶映射**'
- en: 'Let’s look at this marble diagram to understand the exhaust strategy:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个水晶图来理解排放策略：
- en: '![Figure 6.11 – The exhaust operator – marble diagram](img/B21180_06_11.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.11 – 排放操作符 – 水晶图](img/B21180_06_11.jpg)'
- en: Figure 6.11 – The exhaust operator – marble diagram
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.11 – 排放操作符 – 水晶图
- en: The top line is a higher-order Observable that produces three inner Observables
    over time. When the first inner Observable (`exhaust` will subscribe to it so
    that the values `exhaust` operator; it will not be subscribed to (this is the
    key part of `exhaust`).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部行是一个高阶 Observable，它在一段时间内产生三个内部 Observable。当第一个内部 Observable（`exhaust` 将会订阅它，以便
    `exhaust` 操作符的值；它不会被订阅（这是 `exhaust` 的关键部分）。
- en: Only when the first inner Observable completes will `exhaust` subscribe to new
    Observables. So, `exhaust` is ready now to treat other Observables. At that point,
    the third inner Observable comes. The switch will subscribe to and the values
    of the third inner Observable, **g**-**h**-**i**, get reflected in the output.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当第一个内部 Observable 完成时，`exhaust` 才会订阅新的 Observable。因此，`exhaust` 现在准备好处理其他 Observable。此时，第三个内部
    Observable 出现。切换将订阅第三个内部 Observable 的值，**g**-**h**-**i** 的值反映在输出中。
- en: So, `exhaustMap` waits for the completion of the current inner Observable before
    allowing the next Observable to emit values. Once the inner Observable completes,
    `exhaustMap` subscribes to the next Observable in the sequence. It ensures that
    only one inner Observable is active at a time, ignoring any new Observables that
    are emitted while the current one is still ongoing. This is particularly useful
    in scenarios where you want to ignore new events until a previous operation has
    finished, such as handling user clicks on a button, where subsequent clicks are
    ignored until the current operation completes.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`exhaustMap` 等待当前内部 Observable 完成后再允许下一个 Observable 发射值。一旦内部 Observable 完成，`exhaustMap`
    就会订阅序列中的下一个 Observable。它确保一次只有一个内部 Observable 激活，忽略在当前一个仍在进行时发出的任何新的 Observable。这在需要忽略新事件直到先前的操作完成的情况下特别有用，例如处理按钮上的用户点击，后续的点击在当前操作完成之前会被忽略。
- en: It’s similar to how you might handle tasks when you’re busy with something important.
    If someone tries to get your attention with a new task, you might say, “I’m busy
    right now, please don’t disturb me until I finish what I’m doing.” `exhaustMap`
    operates similarly, ensuring that ongoing tasks are completed before considering
    new ones.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于当你忙于重要的事情时处理任务的方式。如果有人试图用新的任务来吸引你的注意力，你可能会说：“我现在很忙，请在我完成手头的事情之前不要打扰我。” `exhaustMap`
    以类似的方式操作，确保在考虑新的任务之前完成当前的任务。
- en: 'Let’s consider a scenario in our recipe app where users can edit recipe details
    and save their changes through a `exhaustMap` comes in handy here by ignoring
    subsequent save requests until the current save operation completes. Here’s the
    implementation:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑在我们的菜谱应用中的一个场景，用户可以编辑菜谱详情并通过 `exhaustMap` 在这里很有用，因为它会忽略后续的保存请求，直到当前的保存操作完成。以下是实现方式：
- en: '[PRE17]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the component responsible for editing the recipe, we defined the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在负责编辑菜谱的组件中，我们定义了以下内容：
- en: A private `saveClick` subject to track the `saveClick` represents our first
    stream.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个私有的 `saveClick` 主题，用于跟踪 `saveClick` 代表我们的第一个流。
- en: A private `saveRecipe$` Observable that issues an HTTP save request to save
    the recipe.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个私有的 `saveRecipe$` Observable，它发出 HTTP 保存请求以保存食谱。
- en: '`saveClick$`, our second stream that listens to `saveClick` emissions and uses
    `exhaustMap` operator to issue a new save request only after the previous one
    is completed.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`saveClick$`，我们的第二个流，它监听 `saveClick` 发射并使用 `exhaustMap` 操作符在先前的请求完成后才发出新的保存请求。'
- en: A `saveRecipe` method. This will be invoked when the `true` to the `saveClick`
    subject.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `saveRecipe` 方法。当 `saveClick` 主题的值为 `true` 时，将调用此方法。
- en: 'Finally, we must subscribe to `saveClick$` using the async pipe in the HTML
    template and add the click handler to the `saveRecipe` method, as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须在 HTML 模板中使用异步管道订阅 `saveClick$`，并将点击处理程序添加到 `saveRecipe` 方法中，如下所示：
- en: '[PRE18]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This ensures that only one save request is processed at a time, preventing duplicate
    entries or data corruption. You can test this code in `RecipeCreationComponent`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了一次只处理一个保存请求，防止重复条目或数据损坏。您可以在 `RecipeCreationComponent` 中测试此代码。
- en: You can also use `exhaustMap` in drag and drop features to ensure that actions
    are only processed when a user’s dragging action has been completed, preventing
    multiple actions from being triggered simultaneously.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在拖放功能中使用 `exhaustMap`，以确保只有在用户的拖动动作完成后才处理操作，防止同时触发多个操作。
- en: Wrapping up the operators
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结操作符
- en: 'Let’s summarize all the operators that were mentioned in this chapter:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下本章中提到的所有操作符：
- en: If the order is important and you need to process operations in sequence while
    waiting for completion, then `concatMap` is the right choice
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果顺序很重要，并且您需要在等待完成时按顺序处理操作，那么 `concatMap` 是正确的选择
- en: If the order is not important and you need to process operations in parallel
    to enhance performance, `mergeMap` is the best operator
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果顺序不重要，并且您需要并行处理操作以提高性能，则 `mergeMap` 是最佳操作符
- en: If you need to put a cancellation logic to release resources and take always
    the most recent information, then `switchMap` is the way to go
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您需要添加取消逻辑来释放资源并始终获取最新信息，那么 `switchMap` 是正确的选择
- en: To ignore new Observables while the current one is still ongoing, use `exhaustMap`
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在当前 Observables 仍在进行时忽略新的 Observables，请使用 `exhaustMap`
- en: All you have to do is pick the right operator based on your specific use case.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要做的只是根据您的特定用例选择正确的操作符。
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we began by illustrating the traditional, imperative approach
    to implementing the autosave feature in our recipe app. However, we soon encountered
    limitations with this method. We highlighted these problems before exploring a
    more reactive pattern to address these challenges.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先展示了在食谱应用中实现自动保存功能的传统、命令式方法。然而，我们很快遇到了这种方法的一些局限性。在探索更反应式模式来应对这些挑战之前，我们强调了这些问题。
- en: Then, we delved into higher-order Observables and higher-order mapping operators,
    learning how the `concatMap` operator works and how it can help us implement the
    autosave requirement in the Recipe app reactively.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们深入研究了高阶 Observables 和高阶映射操作符，学习了 `concatMap` 操作符的工作原理以及它如何帮助我们以反应式方式实现食谱应用中的自动保存要求。
- en: Additionally, we expanded our exploration to include other strategies, namely
    the `merge`, `switch`, and `exhaust` higher-order mapping operators. We explained
    their functionality by using practical examples and use cases to gain a deeper
    understanding of these concepts.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还扩展了我们的探索，包括其他策略，即 `merge`、`switch` 和 `exhaust` 高阶映射操作符。我们通过使用实际示例和用例来解释它们的功能，以更深入地理解这些概念。
- en: In the next chapter, we will explore another useful reactive pattern that allows
    you to share data between your components. As usual, we will demystify the concepts
    and then learn the reactive way to do it.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨另一种有用的反应式模式，允许您在组件之间共享数据。像往常一样，我们将揭示这些概念，然后学习以反应式方式实现它们。
