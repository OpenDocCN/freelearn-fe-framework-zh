<html><head></head><body>
        <section>

            <header>
                <h1 class="header-title">Third Project - The Facebook Client</h1>
            </header>

            <article>
                
<p>Until now, we've mainly built applications that deal only with information provided by a user. However, lots of applications tend to send and receive data from other sources around the web. For our third and final project in this book, we will build an app that accesses the external Facebook API so that users can access their profile.</p>
<p>In this chapter, you will do the following things:</p>
<ul>
<li>Plan <kbd>Friends</kbd>, our Facebook application, by deciding what key factors it should have</li>
<li>Gain access to the Facebook API and install the official SDK for both iOS and Android</li>
<li>Use the Facebook API's <strong>Login</strong> SDK to grant the app appropriate permissions</li>
<li>Grab information from the Facebook API using <kbd>GraphRequest</kbd> and <kbd>GraphRequestManager</kbd></li>
<li>Utilize an <kbd>ActivityIndicator</kbd> to let the user visually know that data is currently loading</li>
<li>Begin building the essential features of our Facebook application</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Planning the app</h1>
            </header>

            <article>
                
<p><kbd>Friends</kbd> will be the first full-fledged example we build of just how powerful React Native is. It will deal with a lot of moving parts, so it's good to plan out the app in depth. On a basic level, accessing the Facebook <strong>Graph</strong> API gives us the following permissions:</p>
<ul>
<li>Signing in</li>
<li>Viewing your feed</li>
<li>Viewing the list of posts on your feed along with its comments and likes</li>
<li>Adding new posts and comments on your feed</li>
<li>Browsing the photos that you've uploaded to your Facebook profile along with their comments and likes</li>
<li>Viewing the events that you have RSVPd</li>
<li>Rediscovering the list of pages that you have liked</li>
</ul>
<p>As in the previous chapters, we want to break this off into bite-sized accomplishments. By the end of this chapter, <kbd>Friends</kbd> should do the following things:</p>
<ul>
<li>Prompt the user to sign in to Facebook, if they haven't already, and save their authentication token automatically with the SDK</li>
<li>While the feed is loading, show a spinning animation to visualize that data is loading</li>
<li>Show the user their feed</li>
<li>For each post on the feed, render the contents of the post along with the number of comments and likes on the post</li>
<li>Upon tapping, load and show just the comment chain of that specific post</li>
<li>Allow the reader to respond to comments on a specific post or create a new post</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">About the Facebook API</h1>
            </header>

            <article>
                
<p>Before we proceed further, a note about the level of access we can gain with the Facebook API--you will only be able to gain information about the user who is logged in. The specific user's friend list is inaccessible through Facebook's API, but a small subset of friends who have also installed the same app is available. Since it's not very useful in our project, I'm purposefully omitting it.</p>
<p>While the user's posts and photos will certainly have a list of comments along with the names and pictures of the people who posted them, accessing those friends' profiles is not possible using the current iteration of the Facebook API.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Obtaining Facebook API credentials</h1>
            </header>

            <article>
                
<p>This looks like a great starting point. However, before we can begin, we need to register our app with Facebook. Head over to Facebook's developer site and select <span class="packt_screen">Add a New App</span>. At the time of writing, the URL is <a href="https://developers.facebook.com"><span class="URLPACKT">https://developers.facebook.com</span></a>.</p>
<p>Once you have your application registered, download the Facebook SDK for iOS at <a href="https://developers.facebook.com/docs/ios/">https://developers.facebook.com/docs/ios/</a> and unzip its contents to your <kbd>Documents</kbd> folder, naming it <kbd>FacebookSDK</kbd>. Keep this folder open; we will need it shortly.</p>
<p>After that, go to the dashboard of your application and take note of the <span class="packt_screen">App ID</span>. You'll also need this in a moment. You can find it here:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="186" src="assets/image_05_001.png" width="644"/></div>
<p>In the following section, we'll look at how to install the official Facebook SDK for React Native.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Installing the Facebook SDK on iOS and Android</h1>
            </header>

            <article>
                
<p>Initialize a new React Native project using the following command line:</p>
<pre>
<strong>react-native init Friends</strong> 
</pre>
<p>Afterwards, navigate to <span>the</span> new project <span>you</span><span> just created using a command line.</span></p>
<p>The Facebook SDK for React Native is available through <kbd>npm</kbd> in a package called <kbd>react-native-fbsdk</kbd>. We'll install it as such:</p>
<pre>
<strong>npm install --save react-native-fbsdk</strong> 
</pre>
<p>Now link the SDK, as follows:</p>
<pre>
<strong>react-native link react-native-fbsdk</strong> 
</pre>
<p>Now, follow the detailed instructions on the <kbd>react-native-fbsdk</kbd> repo on GitHub found at <a href="https://github.com/facebook/react-native-fbsdk">https://github.com/facebook/react-native-fbsdk</a>. Since the installation instructions are prone to being changed at any given time, I highly recommend that you use the instructions found in that repo.</p>
<p>Afterward, install the <kbd>react-native-vector-icons</kbd> library that we used in <kbd>Expenses</kbd> using the process we saw earlier (refer to <a href="94aea5f2-1fde-4cb4-b28e-8b3c6354a298.xhtml">Chapter 4</a>, <em>Advanced Functionality with the Expenses App</em>, if you need a refresher).</p>
<p>Once you have initialized the app for this project and installed both the Facebook SDK and <kbd>react-native-vector-icons</kbd> library, it's time to start playing around.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Logging in with the Facebook SDK</h1>
            </header>

            <article>
                
<p>The first thing we can try in our app is logging in the user. The FBSDK has access to a built-in component called <kbd>LoginButton</kbd> that, on press, will send the user to a login screen using a <kbd>WebView</kbd> while being within the app. If the login is successful, an access token will be saved for your app to make use of, without you needing to personally track it.</p>
<p>Start by adding the <kbd>LoginButton</kbd> snippet found in the FBSDK repository's <kbd>README</kbd> to your app's <kbd>index</kbd> file. You'll get something like this:</p>
<pre>
// Friends/index.ios.js <br/><br/>import React, { Component } from 'react'; <br/>import { <br/>  AppRegistry, <br/>  StyleSheet, <br/>  View <br/>} from 'react-native'; <br/> <br/>import { <br/>  AccessToken, <br/>  LoginButton <br/>} from 'react-native-fbsdk'; 
</pre>
<p>Import the <kbd>AccessToken</kbd> and <kbd>LoginButton</kbd> modules from the <kbd>react-native-fbsdk</kbd> repo, using destructuring notation.</p>
<pre>
export default class Friends extends Component { <br/>  render() { <br/>    return ( <br/>      &lt;View style={ styles.container }&gt; <br/>        &lt;LoginButton <br/>          readPermissions={["public_profile", "user_photos", <br/>          "user_posts", "user_events", "user_likes"]} 
</pre>
<p>The <kbd>readPermissions</kbd> prop accepts an array of strings and asks the user for specific read-only permissions equal to the array passed in.</p>
<p>The Facebook API has a lot of different permissions you can request, and for the purposes of this project, we will ask for the following:</p>
<ul>
<li><kbd>public_profile</kbd>: This provides access to a subset of items that are part of the user's public Facebook profile. This includes their ID, name, profile picture, and more.</li>
<li><kbd>user_events</kbd>: This is a list of events that a person is either hosting or has RSVPd to.</li>
<li><kbd>user_likes</kbd>: This is the collection of Facebook pages that the user has clicked <span class="packt_screen">Like</span> on.</li>
<li><kbd>user_photos</kbd>: These are the user's uploaded or tagged photos.</li>
<li><kbd>user_posts</kbd>: These are the posts on the user's timeline.</li>
</ul>
<p>The <kbd>onLoginFinished</kbd> method is written to be asynchronous:</p>
<pre>
          async onLoginFinished={        <br/>            async (error, result) =&gt; { <br/>              if (error) { <br/>              } else if (result.isCancelled) { <br/>                alert("login is cancelled."); <br/>              } else { <br/>                 const data = await AccessToken.getCurrentAccessToken() <br/>                 alert(data); <br/>              } <br/>            } <br/>          } <br/>          onLogoutFinished={() =&gt; alert("logout.")} <br/>        /&gt; <br/>      &lt;/View&gt; <br/>    ); <br/>  } <br/>} <br/> <br/>const styles = StyleSheet.create({ <br/>  container: { <br/>    flex: 1, <br/>    justifyContent: 'center', <br/>    alignItems: 'center', <br/>    backgroundColor: '#F5FCFF', <br/>  } <br/>}); <br/> <br/>AppRegistry.registerComponent('Friends', () =&gt; Friends); <br/> 
</pre>
<p>While there are some other props available for <kbd>LoginButton</kbd>, the three presented in the preceding code are the only ones we will worry about. Here's what each of these props refer to:</p>
<ul>
<li><kbd>publishPermissions</kbd>: This represents the publishing permissions to request from the logged-in user when the button is pressed</li>
<li><kbd>onLoginFinished</kbd>: This is a callback that gets invoked when a login request has either been completed or produces an error</li>
<li><kbd>onLogoutFinished</kbd>: This is another <kbd>callback</kbd> that invokes itself when a logout request has been completed</li>
</ul>
<p>If everything works out, you will see the following screen with the Facebook log in button--<span class="packt_screen">Log in with Facebook</span>, in the center:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1450 image-border" height="457" src="assets/image_05_002-1.png" width="264"/></div>
<p>By tapping on this logo, you will be taken to a login page within a <kbd>WebView</kbd> component that handles Facebook login.</p>
<p>After logging in, the user will see a prompt that asks for read-only permissions equal to the ones we asked for in the <kbd>readPermissions</kbd> array passed in as a prop to the <kbd>LoginButton</kbd> component:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1451 image-border" height="436" src="assets/image_05_003-1.png" width="240"/></div>
<p>Once your user is authorized, you'll be able to grab data from Facebook's Graph API.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Using the Facebook Graph API</h1>
            </header>

            <article>
                
<p>The FBSDK lets us make requests to the Facebook Graph API using the <kbd>GraphRequest</kbd> and <kbd>GraphRequestManager</kbd> classes to create those requests and execute them.</p>
<p><kbd>GraphRequest</kbd> is used to create a request to the Graph API, while <kbd>GraphRequestManager</kbd> is called to execute that request.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">GraphRequest</h1>
            </header>

            <article>
                
<p>To instantiate a new <kbd>GraphRequest</kbd>, we can pass up to three arguments:</p>
<ul>
<li><kbd>graphPath</kbd>: This is a string pertaining to the endpoint in the Graph API that we wish to hit. For example, to get information about the logged-in user, a <kbd>graphPath</kbd> of <kbd>/me</kbd> will be used.</li>
<li><kbd>config</kbd>: This is an optional object that can configure the request. The props that this object accepts are all optional:
<ul>
<li><kbd>httpMethod</kbd>: This is a string that describes the HTTP method for this request, for example, <kbd>GET</kbd> or <kbd>POST</kbd>.</li>
<li><kbd>version</kbd>: This is a string that describes the specific Graph API version to use.</li>
<li><kbd>parameters</kbd>: This is an object containing the request's parameters.</li>
<li><kbd>accessToken</kbd>: This is a stringified version of the access token used by this request.</li>
</ul>
</li>
<li><kbd>callback</kbd>: This is a callback function that is fired once the request has either been completed or has failed.</li>
</ul>
<p>A sample <kbd>GraphRequest</kbd> instance will look like this:</p>
<pre>
const requestMyPhotos = new GraphRequest('/me/photos/uploaded',  <br/>  null, this._responseInfoCallback); <br/> <br/>_responseInfoCallback (error, result) { <br/>  if (error) { <br/>    console.log('Error fetching data: ' + error.toString()) <br/>  } else { <br/>    console.log(result); <br/>  } <br/>} 
</pre>
<p>For this request to be executed, we will use <kbd>GraphRequestManager</kbd>.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">GraphRequestManager</h1>
            </header>

            <article>
                
<p>The <kbd>GraphRequestManager</kbd> queue requests the Facebook Graph API and executes it when told to do so.</p>
<p>It has access to the following methods:</p>
<ul>
<li><kbd>addRequest</kbd>: This is a function that accepts an instance of <kbd>GraphRequest</kbd> and pushes the request into the queue of <kbd>GraphRequestManager</kbd>. It also pushes the callback into a separate <kbd>requestCallbacks</kbd> queue for execution once the request has been completed or failed.</li>
<li><kbd>addBatchCallback</kbd>: This accepts an optional callback to be executed once the entire batch of requests has been completed. Each instance of <kbd>GraphRequestManager</kbd> can only accept up to one callback, and the invocation of that callback does not indicate that every graph request in the batch was successful--the only thing it is indicative of is that the entire batch has completed execution.</li>
<li><kbd>start</kbd>: This accepts an optional number equal to a timeout value. The timeout value defaults to 0 if it's not passed in. When <kbd>GraphRequestManager.start</kbd> is invoked, the <kbd>GraphRequestManager</kbd> makes a series of requests to the Facebook Graph API on a first-in, first-out basis and executes the callbacks for each request made, if applicable.</li>
</ul>
<p>Adding to the preceding example, a <kbd>GraphRequestManager</kbd> request looks something like this:</p>
<pre>
new GraphRequestManager().addRequest(requestMyPhotos).start(); 
</pre>
<p>This request creates a new instance of <kbd>GraphRequestManager</kbd> complete with its own new batch, adds the preceding <kbd>requestMyPhotos</kbd> task to the batch, and then starts it. From here, the Facebook Graph API will return some form of data.</p>
<p>The callback passed into the instance of <kbd>requestMyPhotos</kbd> in <kbd>GraphRequest</kbd> will then execute, logging either an error or the result of the request.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Creating our first request</h1>
            </header>

            <article>
                
<p>It's time to create our first request to verify that the access token we've received has worked.</p>
<p>Within your <kbd>Friends</kbd> component in <kbd>index.ios.js</kbd>, let's do the following things:</p>
<ul>
<li>Create a method, called <kbd>_getFeed</kbd>, that creates a <kbd>GraphRequest</kbd> to your Facebook feed. This method should grab data at the <span class="KeyPACKT"><kbd>/me/feed</kbd></span> endpoint and reference a callback to be executed when that <kbd>GraphRequest</kbd> is complete. You can skip the optional <kbd>config</kbd> object that <kbd>GraphRequest</kbd> can optionally accept.</li>
<li>In the same <kbd>_getFeed</kbd> function, create a new <kbd>GraphRequestManager</kbd> and add the <kbd>GraphRequest</kbd> instance to it; then start the <kbd>GraphRequestManager</kbd>.</li>
<li>For the callback referenced by <kbd>_getFeed</kbd>, have it log either the error or the result that it receives when your <kbd>GraphRequest</kbd> is completed.</li>
<li>Call <kbd>_getFeed</kbd> as part of the <kbd>onLoginFinished</kbd> callback in <kbd>LoginButton</kbd>.</li>
</ul>
<p>When you have finished, the result should look somewhat like this:</p>
<pre>
// Friends/index.ios.js <br/><br/>... <br/>import { <br/>  ... <br/>  GraphRequest, <br/>  GraphRequestManager, <br/>} from 'react-native-fbsdk'; <br/> <br/>export default class Friends extends Component { <br/>  render() { <br/>    return ( <br/>      &lt;View style={ styles.container }&gt; <br/>        &lt;LoginButton <br/>          ... <br/>          onLoginFinished={ <br/>            async (error, result) =&gt; { <br/>              ... <br/>              } else { <br/>                  await AccessToken.getCurrentAccessToken(); <br/>                  this._getFeed(); 
</pre>
<p>Rather than alerting the access token, I am calling <kbd>_getFeed</kbd>.</p>
<pre>
              } <br/>            } <br/>          } <br/>          ... <br/>        /&gt; <br/>      &lt;/View&gt; <br/>    ); <br/>  }
</pre>
<p>Create a new instance of <kbd>GraphRequest</kbd> by passing it the endpoint desired along with the callback to be fired once the request is complete:</p>
<pre>
  _getFeed () { <br/>    const infoRequest = new GraphRequest('/me/feed', null,<br/>    this._responseInfoCallback); 
</pre>
<p>Now, create a new instance of <kbd>GraphRequestManager</kbd>, add the <kbd>infoRequest</kbd> object to it, and then start the request:</p>
<pre>
    new GraphRequestManager().addRequest(infoRequest).start(); <br/>  } 
</pre>
<p>When the request is completed, it will log either the result or an error if one was encountered:</p>
<pre>
  _responseInfoCallback (error, result) { <br/>    if (error) { <br/>      console.log('Error fetching data: ', error.toString()); <br/>      return; <br/>    } <br/> <br/>    console.log(result); <br/>  } <br/>} <br/>... 
</pre>
<p>With your iOS simulator and remote debugging opened, check out your browser's console as you log in:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" height="379" src="assets/image_05_004.png" width="431"/></div>
<p>This is great! It shows that we are linked up with the Graph API and that it accepts the access token we've given it. Now, let's create a separate <kbd>graphMethods.js</kbd> utility file that we can use in different components.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">GraphMethods</h1>
            </header>

            <article>
                
<p>The goal of this file is to create some commonly used methods that interact with the Facebook Graph API and export them so that we can use them in different components throughout the app.</p>
<p>Like the utility files we created for <kbd>Expenses</kbd>, this <kbd>graphMethods</kbd> file should live inside a <kbd>utils</kbd> folder, nested inside an <kbd>app</kbd> folder that rests at the root level of our project:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" height="150" src="assets/image_05_005.png" width="148"/></div>
<p>Create this utilities file and have it do the following things:</p>
<ul>
<li>Create a function called <kbd>makeSingleGraphRequest</kbd> that accepts a request as an argument, creates a new instance of <kbd>GraphRequestManager</kbd>, passes in the request to <kbd>GraphRequestManager</kbd>, and then calls the <kbd>start</kbd> method of <kbd>GraphRequestManager</kbd>.</li>
<li>Create and export a function, called <kbd>getFeed</kbd>, that accepts a callback, creates a new <kbd>GraphRequest</kbd> pointing to <kbd><span class="KeyPACKT">/me/feed</span></kbd> with that callback, and then calls <kbd>makeSingleGraphRequest</kbd> with it.</li>
</ul>
<p>Once your version is complete, check out mine below:</p>
<pre>
// Friends/app/utils/graphMethods.js <br/><br/>import { <br/>  GraphRequest, <br/>  GraphRequestManager <br/>} from 'react-native-fbsdk'; <br/> <br/>const makeSingleGraphRequest = (request) =&gt; { <br/>  return new GraphRequestManager().addRequest(request).start(); <br/>} <br/> <br/>export const getFeed = (callback) =&gt; { <br/>  const request = new GraphRequest('/me/feed', null, callback); <br/> <br/>  makeSingleGraphRequest(request) <br/>} 
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">NavigatorIOS and App component</h1>
            </header>

            <article>
                
<p>Now, let's create an <kbd>App</kbd> component using an <kbd>App.js</kbd> file. Create this within the <kbd>app</kbd> folder of your project:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" height="195" src="assets/image_05_006.png" width="172"/></div>
<p>This component should contain logic similar to what we had in <kbd>index.ios.js</kbd> previously--we will replace the <kbd>index.ios.js</kbd> file with a <kbd>NavigatorIOS</kbd> component shortly.</p>
<p>Your new <kbd>App</kbd> component should be a reflection of the <kbd>index.ios.js</kbd> file you wrote earlier in this chapter, except that it should import and use the <kbd>graphMethods</kbd> file instead of the component-specific <kbd>_getFeed</kbd> method.</p>
<p>Once you have completed this task, refer to my version:</p>
<pre>
// Friends/app/App.js <br/><br/>import React, { Component } from 'react'; <br/>import { <br/>  View <br/>} from 'react-native'; <br/> <br/>import { <br/>  AccessToken, <br/>  LoginButton <br/>} from 'react-native-fbsdk'; 
</pre>
<p>Since <kbd>GraphRequest</kbd> and <kbd>GraphRequestManager</kbd> are being imported within <kbd>graphMethods</kbd>, I can omit them from the <kbd>import</kbd> statement in the preceding code.</p>
<p>I am using destructuring notation to import just the <kbd>getFeed</kbd> method from <kbd>graphMethods</kbd>. This will come in handy in the future as that file is populated with more helper methods:</p>
<pre>
import { getFeed } from './utils/graphMethods'; 
</pre>
<p>Since the callback for <kbd>GraphRequest</kbd> contains the <kbd>error</kbd> and <kbd>result</kbd> arguments, I pass them in so that <kbd>_responseInfoCallback</kbd> can make use of them:</p>
<pre>
import styles from './styles'; <br/> <br/>export default class App extends Component { <br/>  render() { <br/>    return ( <br/>      &lt;View style={ styles.container }&gt; <br/>        &lt;LoginButton <br/>        readPermissions={["public_profile", "user_photos", <br/>        "user_posts", "user_events", "user_likes"]} <br/>          onLoginFinished={ <br/>            async (error, result) =&gt; { <br/>              if (error) { <br/>              } else if (result.isCancelled) { <br/>                alert("login is cancelled."); <br/>              } else { <br/>                  await AccessToken.getCurrentAccessToken(); <br/>                  getFeed((error, result) =&gt;<br/>                  this._responseInfoCallback(error, result)) <br/>              } <br/>            } <br/>          } <br/>          onLogoutFinished={() =&gt; alert("logout.")} <br/>        /&gt; <br/>      &lt;/View&gt; <br/>    ); <br/>  } <br/> <br/>  _responseInfoCallback (error, result) { <br/>    if (error) { <br/>      console.log('Error fetching data: ', error.toString()); <br/>      return; <br/>    } <br/> <br/>    console.log(result); <br/>  } <br/>}
</pre>
<p>Here is the basic styling for our <kbd>App</kbd> component:</p>
<pre>
// Friends/app/styles.js <br/><br/>import { StyleSheet } from 'react-native'; <br/> <br/>const styles = StyleSheet.create({ <br/>  container: { <br/>    flex: 1, <br/>    justifyContent: 'center', <br/>    alignItems: 'center', <br/>    backgroundColor: '#F5FCFF', <br/>  } <br/>}); <br/> <br/>export default styles;  
</pre>
<p>Great work! The next step is to refactor <kbd>index.ios.js</kbd> at your project's root to do the following things:</p>
<ul>
<li>Import <kbd>NavigatorIOS</kbd> from the React Native SDK as well as the <kbd>App</kbd> component you just created</li>
<li>Render the root <kbd>NavigatorIOS</kbd> component, passing it the <kbd>App</kbd> component as its initial route</li>
</ul>
<p>When you have finished this part, feel free to check out my solution:</p>
<pre>
// Friends/index.ios.js <br/><br/>import React, { Component } from 'react'; <br/>import { <br/>  AppRegistry, <br/>  NavigatorIOS, <br/>  StyleSheet, <br/>} from 'react-native'; <br/> <br/>import App from './app/App'; <br/> <br/>export default class Friends extends Component { <br/>  render() { <br/>    return ( <br/>      &lt;NavigatorIOS <br/>        initialRoute={{ <br/>          component: App, <br/>          title: 'Friends' <br/>        }} <br/>        style={ styles.container } <br/>      /&gt; <br/>    ); <br/>  } <br/>} <br/> <br/>const styles = StyleSheet.create({ <br/>  container: { <br/>    flex: 1, <br/>    backgroundColor: '#F5FCFF', <br/>  } <br/>}); <br/> <br/>AppRegistry.registerComponent('Friends', () =&gt; Friends); <br/> 
</pre>
<p>Now it's time to create a login prompt for the user so that they only see the <kbd>LoginButton</kbd> component when they are not logged in.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Creating a login prompt</h1>
            </header>

            <article>
                
<p>The first thing we should do is think about how our app will behave. When it's launched, we should check for an available access token using the FBSDK <kbd>AccessToken</kbd> API. If it's not available, then our user isn't logged in and we should show them the <span class="packt_screen">Log In</span> button, just like we required a budget in our previous project, <kbd>Expense</kbd>.</p>
<p>If/when the user is logged in, we should grab their feed data, load it into the component state, and then log it to the console to show that we have it.</p>
<p>The first thing we should do is modify the <kbd>App</kbd> component so that:</p>
<ul>
<li>On the <kbd>componentWillMount</kbd> event, we use the <kbd>AccessToken</kbd> API's <kbd>getCurrentAccessToken</kbd> method to check and see whether the user is logged in.
<ul>
<li>If the user is not logged in, we should alert the user that they are not logged in. In the next section, we will replace this part with the login screen that we will create.</li>
<li>If the user is logged in, we should call the <kbd>getFeed</kbd> method of <kbd>graphMethods</kbd>.</li>
</ul>
</li>
<li>Also, it should no longer render the <kbd>LoginButton</kbd>--this will go into a different component in a moment. Instead, let's have the <kbd>App</kbd> component render a string that says <kbd>'Logged In'</kbd> for the time being.</li>
</ul>
<p>Take the time you need to make these changes, then check the code below for my working example:</p>
<pre>
// Friends/app/App.js <br/><br/>... <br/>import { <br/>  Text, <br/>  ... <br/>} from 'react-native'; <br/> <br/>import { <br/>  ... <br/>} from 'react-native-fbsdk'; 
</pre>
<p>I removed the import of <kbd>LoginButton</kbd> to <kbd>App</kbd> since it will be broken off into a different component.</p>
<p>The <kbd>componentWillMount</kbd> logic calls the <kbd>_checkLoginStatus</kbd> method:</p>
<pre>
... <br/>export default class App extends Component { <br/>  componentWillMount () { <br/>    this._checkLoginStatus(); <br/>  } 
</pre>
<p>The <kbd>LoginButton</kbd> component in the <kbd>render</kbd> method of <kbd>App</kbd> has been replaced with a <kbd>Text</kbd> block for the time being. The <kbd>_responseInfoCallback</kbd> function has not been changed nor removed:</p>
<pre>
  render() { <br/>    return ( <br/>      &lt;View style={ styles.container }&gt; <br/>        &lt;Text&gt;Logged In&lt;/Text&gt; <br/>      &lt;/View&gt; <br/>    ); <br/>  } 
</pre>
<p>The <kbd>async _checkLoginStatus</kbd> function is similar to the <kbd>onLoginFinished</kbd> callback of the <kbd>LoginButton</kbd> component we previously rendered:</p>
<pre>
  async _checkLoginStatus ( ){ <br/>    const result = await AccessToken.getCurrentAccessToken(); <br/> <br/>    if (result === null) { <br/>      alert('You are not logged in!'); <br/>      return; <br/>    } <br/> <br/>    getFeed((error, result) =&gt; this._responseInfoCallback(error,<br/>    result)); <br/>  } <br/>  ... <br/>} 
</pre>
<p>If the user is not logged in when they refresh the app, they will see this message:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1452 image-border" height="460" src="assets/image_05_007-1.png" width="253"/></div>
<p>Great job on your progress! For the next step, create a <kbd>components</kbd> folder within the <kbd>app</kbd> folder, within which create a <kbd>LoginPage</kbd> folder that contains both an <kbd>index</kbd> and a <kbd>styles</kbd> file:</p>
<div class="CDPAlignCenter CDPAlign"><img class=" image-border" height="260" src="assets/image_05_008.png" width="160"/></div>
<p>Now, let's modify the <kbd>App</kbd> component again while we create the <kbd>LoginPage</kbd>. The <kbd>App</kbd> component should do the following things:</p>
<ul>
<li>Import the <kbd>LoginPage</kbd> component</li>
<li>Use the <kbd>push</kbd> method of the navigator to push the <kbd>LoginPage</kbd> component when the user is not logged in; replace the part in your code that alerts the user that they are not logged in with this logic</li>
<li>Pass the <kbd>_checkLoginStatus</kbd> callback to the <kbd>LoginPage</kbd> component so that, when the user is logged in, we can check the login status with the <kbd>App</kbd> component and log their list of posts within <kbd>/me/feed</kbd></li>
</ul>
<p>The <kbd>LoginPage</kbd> component should do the following things:</p>
<ul>
<li>Contain a view that wraps around the <kbd>LoginButton</kbd> component that we rendered previously in this chapter.</li>
<li>Have an <kbd>onLoginFinished</kbd> callback that does the following things:
<ul>
<li>Logs an error to the console if the login action is cancelled</li>
<li>Calls the <kbd>getFeed</kbd> callback that was passed to it along with the <kbd>pop</kbd> method of the navigator if the login action is successful</li>
</ul>
</li>
</ul>
<p>When you are finished, your result should look something like this:</p>
<pre>
// Friends/app/App.js <br/><br/>... <br/>import LoginPage from './components/LoginPage'; <br/> <br/>export default class App extends Component { <br/>  ... <br/>  async _checkLoginStatus ( ){ <br/>    ... <br/>    if (result === null) { <br/>      this.props.navigator.push({ <br/>        component: LoginPage, <br/>        title: 'Log In to Facebook', <br/>        navigationBarHidden: true, <br/>        passProps: { <br/>          getFeed: () =&gt; getFeed() <br/>        } <br/>      }); <br/>      return; <br/>    } <br/>    ... <br/>  } <br/>  ... <br/>} 
</pre>
<p>Rather than alerting the user that they are not logged in, I'm now pushing the <kbd>LoginPage</kbd> component via the app's navigator if the user is not logged in. This is how I wrote the <kbd>LoginPage</kbd> component:</p>
<pre>
// Friends/app/components/LoginPage/index.js <br/><br/>import React, { Component } from 'react'; <br/>import { <br/>  View <br/>} from 'react-native'; <br/> <br/>import { <br/>  LoginButton <br/>} from 'react-native-fbsdk'; <br/> <br/>import styles from './styles'; <br/> <br/>export default class LoginPage extends Component { <br/>  render() { <br/>    return ( <br/>      &lt;View style={ styles.container }&gt; <br/>        &lt;LoginButton <br/>        readPermissions={["public_profile", "user_photos",<br/>        "user_posts", "user_events", "user_likes"]} <br/>          onLoginFinished={ <br/>            (error, result) =&gt; { <br/>              if (error) { <br/>                console.log('Error logging in: ', error.toString()); <br/>                return; <br/>              } 
</pre>
<p>The preceding part logs an error if one occurred during login.</p>
<p>In the following code we log the fact that the user cancelled the login process:</p>
<pre>
              if (result.isCancelled) { <br/>                console.log('login was cancelled'); <br/>                return; <br/>              } 
</pre>
<p>However, we call the <kbd>getFeed</kbd> and <kbd>navigator.pop</kbd> methods if the login was successful:</p>
<pre>
              this.props.getFeed(); <br/>              this.props.navigator.pop(); 
</pre>
<pre>
            } <br/>          } <br/>          onLogoutFinished={() =&gt; alert("logout.")} <br/>        /&gt; <br/>      &lt;/View&gt; <br/>    ); <br/>  } <br/>} 
</pre>
<p>The stylesheet for <kbd>LoginPage</kbd> is the exact same as the one found in <kbd>Expenses/app/styles.js</kbd>, so I left it out for the sake of brevity.</p>
<p>Great progress! In the next section, we will create some storage methods to handle the rate limit for Facebook's Graph API.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Optimizing for the API</h1>
            </header>

            <article>
                
<p>The current rate limit for Facebook's Graph API is 200 calls per hour per user. This means that if your app has 100 users, you can make 20,000 calls per hour. The limit is in aggregate, meaning that any single user could take up all 20,000 calls in that given hour.</p>
<p>To reduce the number of network calls we make to the API, we should tweak our <kbd>App</kbd> component to save feed data within <kbd>AsyncStorage</kbd> and only refresh its data when manually prompted to do so by the user.</p>
<p>We can begin by creating methods for <kbd>AsyncStorage</kbd>, which are similar to the ones we had in <kbd>Expenses</kbd>:</p>
<pre>
// Friends/app/utils/storageMethods.js <br/><br/>import { AsyncStorage } from 'react-native'; <br/> <br/>export const getAsyncStorage = async (key) =&gt; { <br/>  let response = await AsyncStorage.getItem(key); <br/>  let parsedData = JSON.parse(response) || {}; <br/> <br/>  return parsedData; <br/>} <br/> <br/>export const setAsyncStorage = async (key, value, callback) =&gt; { <br/>  await AsyncStorage.setItem(key, JSON.stringify(value)); <br/> <br/>  if (callback) { <br/>    return callback(); <br/>  } <br/> <br/>  return true; <br/>} 
</pre>
<p>For this app, we will be storing different key-value pairs within <kbd>AsyncStorage</kbd>; so, we want to explicitly pass the <kbd>getAsyncStorage</kbd> and <kbd>setAsyncStorage</kbd> methods a key.</p>
<p>The <kbd>resetAsyncStorage</kbd> and <kbd>logAsyncStorage</kbd> methods remain the same from when we used them in <kbd>Expenses</kbd>:</p>
<pre>
export const resetAsyncStorage = (key) =&gt; { <br/>  return setAsyncStorage(key, {}); <br/>} <br/> <br/>export const logAsyncStorage = async (key) =&gt; { <br/>  let response = await getAsyncStorage(key); <br/> <br/>  console.log('Logging Async Storage'); <br/>  console.table(response); <br/>} 
</pre>
<p>Next, modify the <kbd>_checkLoginStatus</kbd> method in <kbd>App.js</kbd> so that it does the following things:</p>
<ul>
<li>Calls the <kbd>getAsyncStorage</kbd> method in <kbd>storageMethods</kbd> to check for the existence of data within the <kbd>feed</kbd> property if the user is logged in.
<ul>
<li>If the <kbd>feed</kbd> property exists, we should save its results to the <kbd>App</kbd> component's state under the same name. We will not call <kbd>getFeed</kbd> if this is the case.</li>
<li>If the key does not exist, we should call <kbd>getFeed</kbd>.</li>
</ul>
</li>
</ul>
<p>Now, let's modify the <kbd>_requestInfoCallback</kbd> method in <kbd>App.js</kbd> so that if it does not contain an error, it will do the following things:</p>
<ul>
<li>Save the <kbd>response.data</kbd> array using the <kbd>setAsyncStorage</kbd> method from <kbd>storageMethods</kbd>, using <kbd>feed</kbd> as the key that is passed in.</li>
<li>Save the same array to the <kbd>App</kbd> component's local state.</li>
</ul>
<p>Here's how my version looks:</p>
<pre>
// Friends/app/App.js <br/><br/>... <br/>import { getAsyncStorage, setAsyncStorage } from './utils<br/>/storageMethods'; <br/>... <br/>export default class App extends Component { <br/>  ... <br/>  async _checkLoginStatus () { <br/>    ... <br/>    const feed = await getAsyncStorage('feed'); <br/> <br/>    if (feed &amp;&amp; feed.length &gt; 0) { <br/>      this.setState({ <br/>        feed <br/>      }); <br/>      return; <br/>    } 
</pre>
<p>If the <kbd>feed</kbd> array exists, set it to local state.</p>
<p>Otherwise, call <kbd>getFeed</kbd>:</p>
<pre>
    getFeed((error, result) =&gt; this._responseInfoCallback<br/>    (error, result)); <br/><br/>  } <br/> <br/>  _responseInfoCallback (error, result) { <br/>    ... <br/>    setAsyncStorage('feed', result.data); <br/>    this.setState({ <br/>      feed: result.data <br/>    }); <br/>  } <br/>} 
</pre>
<p>This change first checks for any feed data that we have saved in the app before resorting to making an external API call for that data. In the next chapter, we will explore a component that will allow us to refresh this data on demand.</p>
<p>The next step we should take is to give the user an indication that data is being loaded so that they don't have a static screen for too long. We will use the <kbd>ActivityIndicator</kbd> component to do so.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Using ActivityIndicator</h1>
            </header>

            <article>
                
<p>The <kbd>ActivityIndicator</kbd> component displays a circular loading indicator that lets you visualize a <em>loading</em> action for the user. It's helpful for the overall user experience since your users shouldn't feel like their actions aren't accomplishing their intentions.</p>
<p>The two <kbd>ActivityIndicator</kbd> props we will use in this app are as follows:</p>
<ul>
<li><kbd>animating</kbd>: This is a Boolean that either shows or hides the component. It defaults to <kbd>true</kbd>.</li>
<li><kbd>size</kbd>: This is the physical size of the component. On iOS, your options are one of two strings: <kbd>small</kbd> and <kbd>large</kbd>. On Android, in addition to those two strings, you can pass it a number. This prop defaults to <kbd>small</kbd>.</li>
</ul>
<p>We should modify our app to show this <kbd>ActivityIndicator</kbd> when data hasn't been loaded from the Graph API.</p>
<p>Let's modify the <kbd>App</kbd> component so that it conditionally renders the <kbd>ActivityIndicator</kbd> component when data has not yet been saved into the <kbd>feed</kbd> property of the <kbd>App</kbd> component's state.</p>
<p>The solution I came up with is as follows:</p>
<pre>
// Friends/app/App.js <br/><br/>... <br/>import { <br/>  ActivityIndicator, <br/>  ... <br/>} from 'react-native'; <br/>... <br/>export default class App extends Component { <br/>  constructor (props) { <br/>    super (props); <br/> <br/>    this.state = { <br/>      feed: undefined, <br/>      spinning: true <br/>    } <br/>  } 
</pre>
<p>Set the <kbd>feed</kbd> and <kbd>spinning</kbd> values in the <kbd>App</kbd> component's state upon initialization.</p>
<p>Call the new <kbd>_renderView</kbd> method to conditionally determine what to render:</p>
<pre>
  ... <br/>  render() { <br/>    return ( <br/>      &lt;View style={ styles.container }&gt; <br/>        { this._renderView() } <br/>      &lt;/View&gt; <br/>    ); <br/>  } 
</pre>
<p>Modify <kbd>_checkLoginStatus</kbd> to set the <kbd>spinning</kbd> property to <kbd>false</kbd> when loading data:</p>
<pre>
  async _checkLoginStatus () { <br/>    ... <br/>    if (feed &amp;&amp; feed.length &gt; 0) { <br/>      this.setState({ <br/>        feed, <br/>        spinning: false <br/>      }); <br/>      return; <br/>    } <br/>    ... <br/>  } 
</pre>
<p>Check to see whether the <kbd>ActivityIndicator</kbd> should still be spinning. If so, return the <kbd>ActivityIndicator</kbd> component. If not, return the original <kbd>Text</kbd> component instead:</p>
<pre>
  _renderView () { <br/>    if (this.state.spinning) { <br/>      return ( <br/>        &lt;ActivityIndicator <br/>          animating={ this.state.spinning } <br/>          size={ 'large' } <br/>        /&gt; <br/>      ); <br/>    } <br/> <br/>    return ( <br/>      &lt;Text&gt;Logged In&lt;/Text&gt; <br/>    ) <br/>  } 
</pre>
<p>Like <kbd>_checkLoginStatus</kbd>, modify <kbd>_responseInfoCallback</kbd> to set <kbd>spinning</kbd> to <kbd>false</kbd>:</p>
<pre>
  _responseInfoCallback (error, result) { <br/>    ... <br/>    setAsyncStorage('feed', result.data); <br/>    this.setState({ <br/>      feed: result.data, <br/>      spinning: false <br/>    }); <br/>  } <br/>} 
</pre>
<p>Now, we should take the data we received and display it within a <kbd>ListView</kbd>.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Creating a standard ListView</h1>
            </header>

            <article>
                
<p>The next step is to take the data received from the Graph API and render it into the view.</p>
<p>Right now, the <kbd>feed</kbd> array in the <kbd>App</kbd> component state contains 25 objects. Each object contains the following key-value pairs:</p>
<ul>
<li><kbd>created_time</kbd>: This is the date and time this post was made</li>
<li><kbd>id</kbd>: This is an identifier that will let us grab the details of the post</li>
<li><kbd>story</kbd>: This an optional post description that adds context, such as whether the post contained a location-based check-in, whether it was a shared memory or link, and so on</li>
<li><kbd>message</kbd>: This an optional message that the user personally wrote for this post</li>
</ul>
<p>Each post contains several edges, just like a node on a graph data structure. For <kbd>Friends</kbd>, we will access these following edges:</p>
<ul>
<li><kbd>/likes</kbd>: This is a list of users who like this specific post</li>
<li><kbd>/comments</kbd>: These are the comments made to this post</li>
<li><kbd>/attachments</kbd>: These are the media attachments associated with the said post</li>
</ul>
<p>Before we can access the edges, we should render a <kbd>ListView</kbd> component that displays these 25 posts in a coherent manner. Take some time to create a <kbd>ListView</kbd> that does the following things:</p>
<ul>
<li>Renders the 25 posts in individual rows</li>
<li>Has conditional logic to show the story and message only if they exist</li>
</ul>
<p>If you have gone through the first two projects in this book, the <kbd>ListView</kbd> is nothing new to you.</p>
<p>Create a new component titled <kbd>FeedList</kbd> within your <kbd>components</kbd> folder. In this file, create a <kbd>ListView</kbd> component that takes its array from a prop passed into it and renders a standard <kbd>ListView</kbd>.</p>
<p>Then, create a new helper file, called <kbd>dateMethods</kbd>. It should contain a function that accepts a date string and returns a formatted date. I like to use the MomentJS for things like this, but feel free to do this however you like.</p>
<p>Additionally, create another component titled <kbd>FeedListRow</kbd>, which will be responsible for rendering each individual row of the <kbd>FeedList</kbd>.</p>
<p>Afterward, in <kbd>App.js</kbd>, import the <kbd>FeedList</kbd> component you created and render it where the <kbd>Text</kbd> component is currently placed within <kbd>_renderData</kbd>. Ensure that you pass it the <kbd>feed</kbd> array so that it has data to render. Render the <kbd>FeedList</kbd> instead of the old <kbd>Text</kbd> component:</p>
<pre>
// Friends/app/App.js <br/><br/>... <br/>import FeedList from './components/FeedList'; <br/>...
</pre>
<p><kbd>Text</kbd> is no longer imported:</p>
<pre>
export default class App extends Component { <br/>  ... <br/>  _renderView () { <br/>    if (this.state.spinning) { <br/>      ... <br/>    } <br/> <br/>    return ( <br/>      &lt;FeedList <br/>        feed={ this.state.feed } <br/>        navigator={ this.props.navigator } <br/>      /&gt; <br/>    ); <br/>  } <br/>  ... <br/>} 
</pre>
<p>Next, the <kbd>FeedList</kbd> component takes in the <kbd>feed</kbd> array from the <kbd>App</kbd> component state and renders a standard <kbd>ListView</kbd>, explicitly passing in each post's details:</p>
<pre>
// Friends/app/components/FeedList/index.js <br/><br/>import React, { Component } from 'react'; <br/>import { <br/>  ListView, <br/>  View <br/>} from 'react-native'; <br/> <br/>import FeedListRow from '../FeedListRow'; <br/> <br/>import styles from './styles'; <br/> <br/>export default class FeedList extends Component {
</pre>
<p>Instantiate a new <kbd>ListView.DataSource</kbd> object:</p>
<pre>
  constructor (props) { <br/>    super (props); <br/> <br/>    this.state = { <br/>      ds: new ListView.DataSource({ <br/>        rowHasChanged: (r1, r2) =&gt; r1 !== r2 <br/>      }) <br/>    } <br/>  } 
</pre>
<p>Use the <kbd>feed</kbd> array passed in from <kbd>App</kbd> to render the <kbd>ListView</kbd>, as illustrated:</p>
<pre>
   render () { <br/>    const dataSource = this.state.ds.cloneWithRows<br/>    (this.props.feed || []); 
</pre>
<p>Render a <kbd>ListView</kbd> component using <kbd>FeedListRow</kbd> for each individual row, as follows:</p>
<pre>
    return ( <br/>      &lt;View style={ styles.container }&gt; <br/>        &lt;ListView <br/>          automaticallyAdjustContentInsets={ false } <br/>          dataSource={ dataSource } <br/>          renderRow={ (rowData, sectionID, rowID) =&gt; <br/>            &lt;FeedListRow <br/>              createdTime={ rowData.created_time } <br/>              message={ rowData.message } <br/>              navigator={ this.props.navigator } <br/>              postID={ rowData.id } <br/>              story={ rowData.story } <br/>            /&gt; <br/><br/>          } <br/>          renderSeparator={ (sectionID, rowID) =&gt; <br/>            &lt;View <br/>              key={ rowID } <br/>              style={ styles.separator } <br/>            /&gt; <br/>          } <br/>        /&gt; <br/>      &lt;/View&gt; <br/>    ) <br/>  } <br/>}
</pre>
<p>The <kbd>separator</kbd> gets its own styling for separating each post, as shown:</p>
<pre>
// Friends/app/components/FeedList/styles.js <br/><br/>import { StyleSheet } from 'react-native'; <br/> <br/>const styles = StyleSheet.create({ <br/>  container: { <br/>    flex: 1, <br/>    marginTop: 65 <br/>  }, <br/>  separator: { <br/>    flex: 1, <br/>    height: StyleSheet.hairlineWidth, <br/>    marginLeft: 15, <br/>    marginRight: 15, <br/>    backgroundColor: '#1d2129' <br/>  } <br/>}); <br/> <br/>export default styles; 
</pre>
<p>Use the date string taken from the Facebook API and then format it with <kbd>moment</kbd>:</p>
<pre>
// Friends/app/utils/dateMethods.js <br/><br/>import moment from 'moment'; <br/> <br/>export const getDateTimeString = (date) =&gt; { <br/> <br/>  return moment(date).format('lll'); <br/>} 
</pre>
<p>In <kbd>FeedListRow</kbd>, import the <kbd>getDateTimeString</kbd> method from the <kbd>dateMethods</kbd> file that was just created:</p>
<pre>
// Friends/app/components/FeedListRow/index.js <br/><br/>import React, { Component } from 'react'; <br/>import { <br/>  Text, <br/>  TouchableHighlight, <br/>  View <br/>} from 'react-native'; <br/> <br/>import { getDateTimeString } from '../../utils/dateMethods'; 
</pre>
<p>Wrap a <kbd>TouchableHighlight</kbd> component around for future navigation purposes, as illustrated:</p>
<pre>
import styles from './styles'; <br/> <br/>export default class FeedListRow extends Component { <br/>  render () { <br/>    return ( <br/>      &lt;View style={ styles.container }&gt; <br/>        &lt;TouchableHighlight <br/>          onPress={ () =&gt; this._navigateToPostView() } <br/>          underlayColor={ '#D3D3D3' } <br/>        &gt; <br/>          &lt;View&gt; <br/>            &lt;Text style={ styles.created }&gt; <br/>              { this._renderCreatedString() } <br/>            &lt;/Text&gt; <br/>              { this._renderStoryString() } <br/>            &lt;Text style={ styles.message }&gt; <br/>              { this._renderMessageString() } <br/>            &lt;/Text&gt; <br/>          &lt;/View&gt; <br/>        &lt;/TouchableHighlight&gt; <br/>      &lt;/View&gt; <br/>    ) <br/>  }
</pre>
<p>Placeholder function for now, we will modify this later.</p>
<pre>
  _navigateToPostView () { <br/>    // TODO: Push to navigator <br/>    console.log('pushed'); <br/>  } 
</pre>
<p>Methods to render certain parts of the post's data.</p>
<pre>
  _renderCreatedString () { <br/>    return 'Posted ' + getDateTimeString(this.props.createdTime); <br/>  } <br/> <br/>  _renderMessageString () { <br/>    return this.props.message <br/>  } <br/> <br/>  _renderStoryString () { <br/>    if (this.props.story) { <br/>      return ( <br/>        &lt;Text style={ styles.story }&gt; <br/>          { this.props.story } <br/>        &lt;/Text&gt; <br/>      ) <br/>    } <br/>  } <br/>} 
</pre>
<p>This is the styling I built for <kbd>FeedListRow</kbd>:</p>
<pre>
// Friends/app/components/FeedListRow/styles.js <br/><br/>import { StyleSheet } from 'react-native'; <br/> <br/>const styles = StyleSheet.create({ <br/>  container: { <br/>    flex: 1, <br/>    margin: 10 <br/>  }, <br/>  created: { <br/>    color: '#365899', <br/>    fontWeight: 'bold', <br/>    marginBottom: 5 <br/>  }, <br/>  story: { <br/>    marginBottom: 5, <br/>    textDecorationLine: 'underline' <br/>  } <br/>}); <br/> <br/>export default styles;  
</pre>
<p>You'll notice that this component's <kbd>_navigateToPostView</kbd> method has a commented task to take care of. This is the basis for the next step in this exercise, and we will jump right to it in the next chapter.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Summary</h1>
            </header>

            <article>
                
<p>This was a long chapter, so thank you for staying with me! In this chapter, we obtained access to the Facebook Graph API, installed the Facebook SDK for iOS and Android, and began using the Facebook SDK to log the user into the app and use their access token to grab their feed data and render it onto the screen.</p>
<p>Along the way, you also used an <kbd>ActivityIndicator</kbd> component to visually communicate to the user that we are currently loading data.</p>
<p>We will ramp up a lot more in the next chapter. See you there.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </body></html>