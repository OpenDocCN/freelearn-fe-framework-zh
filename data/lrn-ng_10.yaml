- en: Forms in Angular
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular中的表单
- en: 'Using forms, in general, is our way of collecting data from the web so we can
    later persist it. We have expectations of the form experience, such as:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用表单通常是我们从网络收集数据的方式，以便稍后持久化。我们对表单体验有期望，比如：
- en: Easily being able to declare different kinds of input fields
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轻松声明不同类型的输入字段
- en: Setting up different kind of validations and displaying any validation errors
    to the user
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置不同类型的验证并向用户显示任何验证错误
- en: Supporting different strategies for stopping a post submission if the form contains
    errors
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持不同的策略来阻止提交，如果表单包含错误
- en: 'There are two approaches to handling forms: template-driven forms and reactive
    forms. Neither approach is considered better than the other; you just have to
    go with the one that suits your scenario the best. The major difference between
    the two approaches is who is responsible for what:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 处理表单有两种方法：模板驱动表单和响应式表单。没有一种方法被认为比另一种更好；你只需要选择最适合你情况的方法。两种方法之间的主要区别是谁负责什么：
- en: In the template-driven approach, the template is responsible for creating elements,
    forms, and setting up validation rules, and synchronization happens with two-way
    data binding
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模板驱动的方法中，模板负责创建元素、表单，并设置验证规则，同步是通过双向数据绑定实现的
- en: In the reactive approach, the `Component` class is responsible for creating
    the form, its elements, and setting up the validation.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在响应式方法中，`Component`类负责创建表单、其元素，并设置验证。
- en: 'In this chapter, we will:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Learn about template-driven forms
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解模板驱动表单
- en: Bind data models and interface types for forms and input controls
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定数据模型和表单和输入控件的接口类型
- en: Design forms using the reactive forms approach
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用响应式表单方法设计表单
- en: Dive into the alternatives for input validation
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解输入验证的替代方法
- en: Build our own custom validators
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建我们自己的自定义验证器
- en: Template-driven forms
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板驱动表单
- en: Template-driven forms are one of two different ways of setting up forms with
    Angular. This approach is all about doing the setup in the template, which greatly
    resembles the approach used in AngularJS. So, if you have a background in AngularJS,
    this approach will be quite familiar to you.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 模板驱动表单是使用Angular设置表单的两种不同方式之一。这种方法完全是在模板中进行设置，非常类似于AngularJS中使用的方法。因此，如果您有AngularJS的背景，这种方法对您来说将非常熟悉。
- en: Turning a simple form into a template-driven form
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将简单表单转换为模板驱动表单
- en: 'We have defined the following form, which consists of a `form` tag, two `input`
    fields, and a `button`, like so:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了以下表单，包括一个`form`标签，两个`input`字段和一个`button`，如下所示：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, we clearly have two `input` fields that are required, hence the `required`
    attribute for the input elements. We also have a Save button. The requirement
    we have on such a form is that it should not submit its data until all required
    fields are filled in. To accomplish this, we need to do two things:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们明显有两个需要的`input`字段，因此`input`元素有`required`属性。我们还有一个保存按钮。我们对这样一个表单的要求是，在所有必填字段填写完毕之前，不应提交其数据。为了实现这一点，我们需要做两件事：
- en: Save the input field values to an object with `[(ngModel)]`
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将输入字段的值保存到一个对象中，使用`[(ngModel)]`
- en: Only submit the form if it has no errors, by using the `ngForm` directive
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有在没有错误时才提交表单，使用`ngForm`指令
- en: 'We now change the form to look like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将表单更改为如下所示：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s talk about the changes we made. First off, we have the following piece
    of code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈我们所做的更改。首先，我们有以下代码片段：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We created a view reference called `formPerson` that has the value `ngForm`assigned
    to it. This means we have a reference to the form. The form view reference now
    contains a lot of interesting properties that will help us determine whether the
    form is ready to be submitted.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`formPerson`的视图引用，其值为`ngForm`。这意味着我们有一个对表单的引用。表单视图引用现在包含了许多有趣的属性，这些属性将帮助我们确定表单是否准备好提交。
- en: 'As for the second change we made, we connected the input data to `ngModel`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 至于我们所做的第二个改变，我们将输入数据连接到了`ngModel`：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `ngModel` allows us to create a double binding to a property. It is known
    as a *banana in a box*, which is really a memory rule for you to be able to remember
    how to type it. We create it in two steps. First we have `ngModel`, then we add
    the banana, the parenthesis, like this: `(ngModel)`. After that we put the banana
    in a box. Square brackets will serve as our box, which means we finally have `[(ngModel)]`.
    Remember, it's called *banana in a box*, not *box in a banana*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngModel`允许我们对属性创建双向绑定。它被称为*香蕉在盒子里*，这实际上是一个记忆规则，让你能够记住如何输入它。我们分两步创建它。首先是`ngModel`，然后我们添加香蕉，括号，就像这样：`(ngModel)`。之后我们把香蕉放在盒子里。方括号将作为我们的盒子，这意味着我们最终有了`[(ngModel)]`。记住，它被称为*香蕉在盒子里*，而不是*盒子在香蕉里*。'
- en: Here, we ensured that the value of the input was saved down to `person.name`,
    by utilizing the `ngModel` directive.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过使用`ngModel`指令，确保了输入的值被保存到`person.name`。
- en: 'Lastly, we decorated our button element using the `*ngIf` directive, like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`*ngIf`指令装饰了我们的按钮元素，就像这样：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We used an `*ngIf`directive to be able to hide the button, should the form prove
    to be invalid. As you can see, we are utilizing our form view reference and its
    valid property. If the form is valid, then show the button; otherwise, hide it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`*ngIf`指令来隐藏按钮，如果表单被证明是无效的。正如你所看到的，我们正在利用我们的表单视图引用及其有效属性。如果表单有效，则显示按钮；否则，隐藏它。
- en: 'This is the very basics of setting up a template-driven form. Let''s investigate
    this a little deeper by looking at:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是设置模板驱动表单的基础知识。让我们通过查看一下来深入了解一下：
- en: What CSS is being rendered, so we can render that appropriately depending on
    the form state
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正在呈现的CSS是什么，这样我们就可以根据表单状态适当地进行呈现
- en: How to detect a specific error on an input element
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何检测输入元素上的特定错误
- en: Input field error – from a CSS standpoint
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入字段错误-从CSS的角度来看
- en: 'There are different CSS classes being assigned to an input element depending
    on what state it is in. Let''s have a look at an input element with a required
    attribute set, prior to us inputting any data. We expect it to tell us that something
    is wrong, due to the fact that the `input` field is empty and we have added a
    `required` attribute to it:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 根据输入元素所处的状态，会分配不同的CSS类。让我们看看一个具有必填属性的输入元素，在我们输入任何数据之前。我们期望它告诉我们有什么地方出错了，因为`input`字段为空，并且我们已经为其添加了`required`属性：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can see that the following classes have been set:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到已设置以下类：
- en: '`ng-untouched`, which means that no one has attempted to press the Submit button
    yet'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-untouched`，这意味着还没有人尝试按提交按钮'
- en: '`ng-pristine`, which essentially means that no attempts have been made to input
    data into this field. It would be set to `false` if you enter a character and
    remove the said character'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-pristine`，这基本上意味着尚未尝试向该字段输入数据。如果您输入一个字符并删除该字符，则它将被设置为`false`。'
- en: '`ng-invalid`, which means that the validator is reacting and says something
    is wrong'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-invalid`，这意味着验证器正在反应并指出有错误'
- en: Entering a character into the field, we see that `ng-pristine` disappears. Entering
    some characters in both fields and pressing Submit, we see that `ng-untouched`
    turns into `ng-touched`. This also causes `ng-invalid` to turn into `ng-valid`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在字段中输入一个字符，我们看到`ng-pristine`消失了。在两个字段中输入一些字符并点击提交，我们看到`ng-untouched`变成了`ng-touched`。这也导致`ng-invalid`变成了`ng-valid`。
- en: OK, so now we have a better understanding of what CSS turns into what, at what
    time, and can style our component appropriately.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们更好地了解了CSS在什么时候会变成什么样，并且可以适当地为我们的组件设置样式。
- en: Detecting an error on an input field with named references
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测具有命名引用的输入字段上的错误
- en: 'So far, we have settled for looking at the form reference when we want to know
    whether our form is valid or not. We can do a lot better here, we can detect whether
    a specific input control has an error. An input control may have more than one
    validator, which means we might have more than one validation error to show as
    well. So how do we detect that? There are a number of steps to be taken to accomplish
    this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，当我们想知道我们的表单是否有效时，我们一直在查看表单引用。我们可以做得更好，我们可以检测特定输入控件是否有错误。输入控件可能有多个验证器，这意味着我们可能有多个验证错误要显示。那么我们如何检测呢？要完成这个任务，需要采取一些步骤：
- en: 'We need to:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要：
- en: Create a view reference for each input element and also assign it the value
    `ngModel`.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个输入元素创建一个视图引用，并为其分配值`ngModel`。
- en: Give each element a `name` attribute.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给每个元素添加一个`name`属性。
- en: 'Let''s update our form code and add view references and `name` attributes according
    to the preceding steps:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新我们的表单代码，并根据前面的步骤添加视图引用和`name`属性：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once we have done the pre-work, it is time to talk about what errors we can
    detect. There are two types of errors that are of interest:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了前期工作，就是时候谈谈我们可以检测到哪些错误了。感兴趣的错误有两种类型：
- en: A general error, which is an error that says there is something wrong on the
    input control, but doesn't specify what
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一般错误，即指示输入控件有问题，但不指定具体问题是什么
- en: A specific error, which will indicate the exact type of error, for example,
    the value is too short
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定错误，将指示确切的错误类型，例如，值太短
- en: 'Let''s start with a general error:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一般错误开始：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We use our view reference `firstName` and query it for its valid property, which
    indicates whether an error exists.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用我们的视图引用`firstName`并查询其valid属性，该属性指示是否存在错误。
- en: 'Now for the other more detailed error. To detect a more detailed error we use
    the errors object on our view reference and output the whole object using the
    JSON pipe:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看看其他更详细的错误。要检测更详细的错误，我们使用视图引用上的errors对象，并使用JSON管道输出整个对象：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This means we can suddenly find out whether a specific error has been set and
    we can therefore decide to display a conditional text based on a certain error
    being present, like so:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们突然可以知道是否设置了特定错误，因此我们可以决定基于特定错误的存在来显示条件文本，就像这样：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Other specific errors will populate the errors object, and the only thing you
    have to do is know what the error is called. When in doubt, output the errors
    object using the JSON pipe to find out what the validation error is called for
    a certain validator, and what validation error values go with it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 其他特定错误将填充errors对象，你需要做的唯一的事情就是知道错误的名称。如果有疑问，可以使用JSON管道输出errors对象，以找出特定验证器的验证错误名称以及相应的验证错误值。
- en: Improving the form
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进表单
- en: 'So far, we have covered the basic mechanisms for knowing when a form is erroneous
    and how to display a text based on a specific error. Let''s build on that knowledge
    by covering some more examples. First off, we will add more validation types to
    our input field:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了了解表单何时出错以及如何根据特定错误显示文本的基本机制。让我们通过一些更多的例子来扩展这些知识。首先，我们将向我们的输入字段添加更多的验证类型：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now we have added `minlength`as a validation rule to our element, besides the
    pre-existing required rule. Required is the prioritized error, so that will show
    first. If we input some characters then the required error goes away. It should
    now display the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将`minlength`添加为我们元素的验证规则，除了现有的required规则。Required是优先错误，所以它会首先显示。如果我们输入一些字符，那么required错误就会消失。现在它应该显示以下内容：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Just like with the required error, we can show an error text for just this
    error, like so:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 就像required错误一样，我们可以仅为此错误显示错误文本，如下所示：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'There are some validation rules already written for us:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 已经为我们编写了一些验证规则：
- en: '`required`, which requires the value to be non empty'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`required`，要求值不能为空'
- en: '`requiredTrue`, which specifically requires the value to be `true`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requiredTrue`，特别要求值为`true`'
- en: '`minlength`, which says the value needs to have a certain minimum length'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minlength`，表示值需要具有一定的最小长度'
- en: '`maxlength`, which says the value cannot be over a certain length'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxlength`，表示值不能超过一定长度'
- en: '`pattern`, which forces the value to adhere to a `RegEx` pattern'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pattern`，强制值遵循`RegEx`模式'
- en: '`nullValidator`, which checks the value is not null'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nullValidator`，检查值不为空'
- en: '`compose`, which is used if you want to compose multiple validators into one,
    the validation rule is the result of taking the union of all validators provided'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compose`，如果您想将多个验证器组合成一个，验证规则是取所有提供的验证器的并集的结果'
- en: Try to see if any of those covers your scenario. You might find that some validation
    rules are missing. If that is the case, then this can be remedied by creating
    a custom validator. We will cover how to build a custom validator rule later in
    this chapter.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试看看这些是否符合您的情况。您可能会发现一些验证规则缺失。如果是这种情况，那么可以通过创建自定义验证器来解决。我们将在本章后面介绍如何构建自定义验证器规则。
- en: Showing errors at the right time
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在正确的时间显示错误
- en: So far, our form has had a behavior of not showing the Submit button if at least
    one error exists. There are alternate approaches to take here. Sometimes it might
    be perceived as the UI being broken when a button doesn't exist or shows as disabled.
    This has to do with how you construct the UI in other places. A consistent approach
    is better. For that reason, there are different ways we could control how a form
    gets submitted.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的表单在至少存在一个错误时不显示提交按钮。这里有一些替代方法。有时，当按钮不存在或显示为禁用时，可能会被认为UI出现了问题。这与您在其他地方构建UI的方式有关。一致的方法更好。因此，我们可以控制表单如何提交的不同方式。
- en: 'Here are the main approaches:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是主要方法：
- en: Show the Submit button when there are no errors in the form, we have covered
    how to do this one already. This approach may look like we forgot to design the
    form properly because the button seems to be missing entirely when the form has
    an error.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当表单中没有错误时显示提交按钮，我们已经知道如何做到这一点。这种方法可能看起来像我们忘记正确设计表单，因为当表单出现错误时，按钮似乎完全消失了。
- en: Disable the submit button as long as there are form errors. It is nice if this
    is accompanied with showing validation errors to avoid any misunderstandings on
    why it is disabled.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在表单存在错误时禁用提交按钮。如果伴随着显示验证错误，这样做会很好，以避免任何误解为什么它被禁用。
- en: Enable the call to submit only when there are no errors, the major difference
    here is that the Submit button is clickable but the submit action won't be taking
    place. The drawback of this version is making the user feel like nothing is happening.
    This approach needs to be accompanied with showing the validation error that prevents
    the form from being submitted.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有当没有错误时才启用提交调用，这里的主要区别是提交按钮是可点击的，但提交操作不会发生。这个版本的缺点是让用户感觉好像什么都没有发生。这种方法需要配合显示阻止表单提交的验证错误。
- en: 'This is how you would code the first approach. Here, we hide the button if
    the form is not valid:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你会编写第一种方法的方式。在这里，如果表单无效，我们会隐藏按钮：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The second approach involves setting the button to a disabled state. We can
    do so by binding to the `disabled` attribute:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法涉及将按钮设置为禁用状态。我们可以通过绑定到`disabled`属性来实现：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The third and final approach is to create a `Boolean` condition that needs
    to return `true` for the other statement to be executed:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种和最后一种方法是创建一个布尔条件，需要返回`true`才能执行其他语句：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Reactive forms
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式表单
- en: For reactive forms, we have a programmatic approach to how we create form elements
    and set up validation. We set everything up in the `Component` class and merely
    point out our created constructs in the template.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于响应式表单，我们有一种程序化的方法来创建表单元素并设置验证。我们在`Component`类中设置所有内容，只需在模板中指出我们创建的结构。
- en: 'The key classes involved in this approach are:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中涉及的关键类包括：
- en: '`FormGroup`, which is a grouping containing one-to-many form controls'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FormGroup`，它是一个包含一到多个表单控件的分组'
- en: '`FormControl`, which represents an input element'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FormControl`，表示一个输入元素'
- en: AbstractControl
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AbstractControl
- en: Both the `FormGroup` and `FormControl` inherit from `AbstractControl`, which
    contains a lot of interesting properties that we can look at and use to render
    the UI differently, based on what status a certain thing has. For example, you
    might want to differ UI-wise between a form that has never been interacted with
    and one that has. It could also be of interest to know whether a certain control
    has been interacted with at all, to know what values would be part of an update.
    As you can imagine, there are a lot of scenarios where it is interesting to know
    a specific status.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormGroup`和`FormControl`都继承自`AbstractControl`，其中包含许多有趣的属性，我们可以查看并根据某个状态以不同的方式渲染UI。例如，您可能希望在从未与表单交互过和已经交互过的表单之间在UI上有所区别。还有可能想知道某个控件是否已经被交互过，以了解哪些值将成为更新的一部分。可以想象，有很多情况下了解特定状态是很有趣的。'
- en: 'The following list contains all the possible statuses:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表包含所有可能的状态：
- en: '`controls`, a list of `FormControl` instances that you added through the constructor`new
    FormGroup(group)`.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`controls`，一个通过构造函数`new FormGroup(group)`添加的`FormControl`实例列表。'
- en: '`value`, a dictionary representing a key-value pair. The key is the reference
    you gave the `FormControl` at creation and the value is what you entered in the
    input control `{ :''<reference>'', <value entered> }`.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`，表示键值对的字典。键是你在创建时给`FormControl`的引用，值是你在输入控件中输入的内容`{ :''<reference>'',
    <value entered> }`。'
- en: '`dirty`, once we enter something in the form it is considered dirty.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dirty`，一旦我们在表单中输入了内容，它就被认为是脏的。'
- en: '`disabled`, the form can be disabled.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`disabled`，表单可以被禁用。'
- en: '`pristine`, a form where none of the controls have been interacted with.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pristine`，一个没有任何控件被交互的表单。'
- en: '`status`, a string representation of whether it is valid or not,  it says invalid
    if it isn''t.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`status`，一个表示它是否有效的字符串表示，如果无效则显示无效。'
- en: '`touched`, the Submit button has been pressed at least once.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`touched`，提交按钮至少被按下一次。'
- en: '`untouched`, the Submit button has not yet been pressed.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`untouched`，提交按钮尚未被按下。'
- en: '`enabled`, Boolean saying whether the form is enabled.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`启用`，布尔值，表示表单是否启用。'
- en: '`valid`, if there are no errors this one is `true`.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`有效`，如果没有错误，这个是`true`。'
- en: '`invalid`, the opposite of valid.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`无效`，与有效相反。'
- en: Programmatic and dynamic approach
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序化和动态的方法
- en: 'We have a programmatic approach to how things are being done, and we have two
    possible approaches to this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对事情的处理方式是程序化的，我们有两种可能的方法：
- en: We can create forms with N number of elements. This means we can generate forms
    that are completely dynamic in what and how many input controls, as well as forms,
    that should be used. A typical example is when creating a content management system
    where pages and their content are completely configurable from a config file or
    database.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以创建具有N个元素的表单。这意味着我们可以生成完全动态的表单，包括输入控件的种类和数量，以及应该使用的表单。一个典型的例子是创建一个内容管理系统，其中页面和它们的内容完全可以从配置文件或数据库中配置。
- en: We can create deep structures. Normally we have a form and N number of elements
    in it, but reactive forms allow us to nest forms within forms.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以创建深层结构。通常我们有一个表单和其中的N个元素，但是响应式表单允许我们在表单中嵌套表单。
- en: 'Notice here how the `FormGroup`is being called a group and not a `Form`. This
    is because you should consider this as only a grouping and not necessarily the
    only one of its kind. You could easily have a structure like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里`FormGroup`被称为组而不是`Form`。这是因为你应该把它看作只是一种分组，而不一定是唯一的。你可以很容易地有这样的结构：
- en: '`Person : FormGroup`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`人：FormGroup`'
- en: '`Name : FormControl`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`姓名：FormControl`'
- en: '`Surname : FormControl`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`姓氏：FormControl`'
- en: '`Age : FormControl`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`年龄：FormControl`'
- en: '`Address : FormGroup`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`地址：FormGroup`'
- en: '`City: FormControl`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`城市：FormControl`'
- en: '`Country: FormControl`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`国家：FormControl`'
- en: Here we have a representation of `Person` and we can see that we want to handle
    the input of that person's address in a form by itself, hence the hierarchy.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们有一个`Person`的表示，我们可以看到我们想要单独处理这个人的地址输入，因此有了这种层次结构。
- en: Turning a form into a dynamic form
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将表单转换为动态表单
- en: 'The `FormGroup` is the construct that consists of many form controls. To create
    such a construct we need to do the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormGroup`是由许多表单控件组成的结构。要创建这样的结构，我们需要做以下事情：'
- en: Import the reactive `Forms` module.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入响应式`Forms`模块。
- en: Instantiate as many `FormControls` as you need, through code.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过代码实例化尽可能多的`FormControls`。
- en: Place the controls in a dictionary.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将控件放在一个字典中。
- en: Assign the dictionary as input to the `FormGroup`.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将字典分配为`FormGroup`的输入。
- en: Associate our `Form` group instance with the `[formGroup]` directive.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的`Form`组实例与`[formGroup]`指令关联。
- en: Associate each `FormControl` instance to a `[formControlName]` directive.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个`FormControl`实例与`[formControlName]`指令关联。
- en: 'The first step lies in importing the module:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是导入模块：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The second step is creating form controls. Let''s create two different ones,
    one with validation and one without:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是创建表单控件。让我们创建两个不同的控件，一个带有验证，一个没有：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The third step is to create a dictionary for this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步是为此创建一个字典：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The fourth step is to assign the group to a `formGroup` instance:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 第四步是将组分配给`formGroup`实例：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Your full code should look something like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你的完整代码应该看起来像这样：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Your form''s UI should look like this. As you can see, your `start value` is
    set to the input control:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你的表单UI应该看起来像这样。你可以看到，你的`起始值`被设置为输入控件：
- en: '![](assets/a4b4d126-7af6-4300-b171-a4b4ca55a706.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a4b4d126-7af6-4300-b171-a4b4ca55a706.png)'
- en: Adding controls with validation rules
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加带有验证规则的控件
- en: 'Let''s add a validator to a form control:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给一个表单控件添加一个验证器：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If you investigate the markup for this newly added form, you can see that indeed
    its CSSclass has been set to `ng-invalid` due to its value being empty.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你调查一下这个新添加的表单的标记，你会发现它的CSS类确实被设置为`ng-invalid`，因为它的值为空。
- en: 'Now the next burning question, how do I reference individual elements so I
    know what errors they may or may not have? The answer is simple, under your form
    member, of type `FormGroup`, is a controls dictionary that contains controls.
    One of these controls works just like a view reference with template forms:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的紧要问题是，我如何引用单个元素，以便知道它们可能具有或不具有哪些错误？答案很简单，在您的表单成员下，类型为`FormGroup`，有一个包含控件的控件字典。其中一个这些控件就像模板表单中的视图引用一样工作：
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As you can see in the preceding code snippet, we can refer to an individual
    control through `form.controls[''key'']`. It has the properties valid and errors
    on it so we can show individual errors, like so:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码片段中所示，我们可以通过`form.controls['key']`引用单个控件。它具有valid和errors属性，因此我们可以显示单个错误，就像这样：
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Refactoring – making the code more dynamic
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构 - 使代码更加动态
- en: 'So, we have understood the basic mechanisms so far with `FormGroup` and `FormControl`and
    the involved directives, but our code looks very static, so let''s fix that. We
    need to have some kind of dataset that we loop through that creates our `Form`
    controls on demand:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了`FormGroup`和`FormControl`以及相关指令的基本机制，但是我们的代码看起来非常静态，让我们来解决这个问题。我们需要有一种数据集，通过循环创建我们的`Form`控件：
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now for defining the UI. We have a list of questions that we use an `*ngFor`
    to display:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来定义UI。我们有一个问题列表，我们使用`*ngFor`来显示：
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We loop through the questions array and assign the `[formControl]`directive
    the appropriate control. From our question instance, we are also able to output
    the question itself. This looks a lot more dynamic.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遍历问题数组，并为`[formControl]`指令分配适当的控件。从我们的问题实例中，我们还能够输出问题本身。这看起来更加动态。
- en: 'Now we just have one step left, and that is accessing the values the user actually
    fills in:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只剩下一步，那就是访问用户实际填写的值：
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This gives us a dictionary of the form control reference along with any value
    the user entered in the input upon pressing Submit.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我们一个控件引用的字典，以及用户在按下提交按钮时输入的任何值。
- en: Updating our component form model – using setValue and patchValue
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新我们的组件表单模型 - 使用setValue和patchValue
- en: 'First off, let''s have a little reminder of how we can create a form programmatically.
    We used to use the dictionary variable and pass that to the `FormGroup` constructor,
    but we may as well skip that variable and define the dictionary inline, as in
    the following code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们稍微回顾一下如何以编程方式创建表单。我们过去使用字典变量并将其传递给`FormGroup`构造函数，但我们也可以跳过该变量并在内联中定义字典，就像以下代码中一样：
- en: '[PRE27]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To change any of the values in the form, we can use one of two approaches:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改表单中的任何值，我们可以使用两种方法之一：
- en: '`setValue()`, which will replace all values'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setValue()`，它将替换所有值'
- en: '`patchValue()`, which will only update the mentioned controls'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`patchValue()`，它只会更新提到的控件'
- en: setValue
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: setValue
- en: 'Using this method completely replaces all the values. As long as you mention
    all the values that the form was created with then you are fine, like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此方法完全替换所有值。只要提到表单创建时的所有值，那么就没问题，就像这样：
- en: '[PRE28]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If however, you forget a field, you will get an error back saying you must
    specify a value for all fields:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您忘记了一个字段，您将收到一个错误，指示您必须为所有字段指定一个值：
- en: '[PRE29]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If you only wanted to do a partial update then the `patchValue()` function is
    for you.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想进行部分更新，那么`patchValue()`函数就是为您准备的。
- en: patchValue
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: patchValue
- en: 'Using `patchValue()` is as easy as typing the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`patchValue()`就像输入以下内容一样简单：
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'For example, if the previous values before calling `patchValue()` were as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果在调用`patchValue()`之前的值如下：
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then applying `form.patchValue()`, defined earlier, will cause the resulting
    form to contain the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后应用`form.patchValue()`，之前定义的，将导致生成的表单包含以下内容：
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Upon closer inspection, we can see that the surname and name have been updated
    but the age property has been left alone.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细检查后，我们可以看到姓和名已经更新，但年龄属性保持不变。
- en: Cleaning up our form creation and introducing FormBuilder
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理我们的表单创建并引入FormBuilder
- en: 'So far, we have been creating our forms like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直是这样创建我们的表单的：
- en: '[PRE33]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This, however, constitutes a lot of noise. We can use a construct called `FormBuilder`to
    take away a lot of that noise. To use the `FormBuilder` we need to do the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这构成了很多噪音。我们可以使用一个叫做`FormBuilder`的结构来消除很多噪音。要使用`FormBuilder`，我们需要执行以下操作：
- en: Import it from `@angular/forms`.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`@angular/forms`导入它。
- en: Inject it into the constructor.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将它注入到构造函数中。
- en: Use the instance and call the group function on the `FormBuilder` instance.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用实例并在`FormBuilder`实例上调用group函数。
- en: 'Let''s showcase this in the following code snippet:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以下代码片段中展示这一点：
- en: '[PRE34]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This looks a lot easier to read and we don't have to deal with the `FormGroup` and `FormControl` data
    types explicitly, although that is what is being created implicitly.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来更容易阅读，我们不必明确处理`FormGroup`和`FormControl`数据类型，尽管这是隐式创建的。
- en: 'There are three different ways of specifying a value to our element:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种不同的方式来为我们的元素指定值：
- en: '`elementName : ''''`, here the default value is being set to a primitive'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`elementName：''''`，这里默认值被设置为原始值'
- en: '`elementName: { value : '''',  disabled: false }`, here we assign the `elementName` to
    an entire object, where the property value in the object is what the default value
    will become'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`elementName：{value：''''，disabled：false}`，在这里我们将`elementName`分配给整个对象，对象中的value属性是默认值将变为的值'
- en: '`elementName : [ ''default value'', <optional validator> ]`, here we assign
    it a complete array with the first item in the array being the default value and
    the second to Nth values being the validators'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`elementName：[''默认值''，<可选验证器>]`，在这里我们为它分配一个完整的数组，数组中的第一项是默认值，第二到第N个值是验证器'
- en: 'Here is what the code looks like using all three approaches:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用所有三种方法的代码的样子：
- en: '[PRE35]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here, we are rendering out the mentioned field in our preceding backing code.
    As you can see, the key names in the group object correspond to the `formControlName` attribute
    in the markup:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在前面的后备代码中呈现了提到的字段。正如您所看到的，组对象中的键名称对应于标记中的`formControlName`属性：
- en: '[PRE36]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'How do we show a specific error though? That''s an easy one, it looks like
    this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如何显示特定的错误呢？这很容易，看起来像这样：
- en: '[PRE37]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note how we refer to the form by its property name on the class `dynamicForm2`,
    we call the `get()` method and specify the key as an argument, and lastly, we
    call `hasError`and ask for a specific error. In this particular case, the address
    property is defined in the code as consisting of city and country. Specifying
    an error like this would just tell us that either city or country has an error
    on it, or both.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们如何通过类`dynamicForm2`的属性名称引用表单，我们调用`get()`方法并指定键作为参数，最后，我们调用`hasError`并要求特定的错误。在这种特殊情况下，地址属性在代码中被定义为由城市和国家组成。像这样指定错误只会告诉我们城市或国家中有一个错误，或者两者都有错误。
- en: Building your own custom validator
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建自定义验证器
- en: Sometimes the default validators won't cover all the scenarios that you might
    have in your application. Luckily, it is quite easy to write your own custom validator.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 有时默认验证器可能无法涵盖应用程序中可能出现的所有情况。幸运的是，编写自定义验证器非常容易。
- en: A custom validator is just a function that needs to return an object with the
    error specified or null. Null means we don't have an error.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义验证器只是一个需要返回指定错误对象或null的函数。Null表示我们没有错误。
- en: 'Starting to define such a function is easy:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 开始定义这样一个函数很容易：
- en: '[PRE38]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In this case, we are building a `minValue` validator. The outer function takes
    the parameter we will compare to. We return an inner function that tests the control''s
    value to our compare value. If our condition is `true` we raise an error where
    we return an error structure`{ ''minValue'' : {  value : control.value } }`, or
    if it is `false` then we return null.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '在这种情况下，我们正在构建一个`minValue`验证器。外部函数接受我们将要比较的参数。我们返回一个测试控件值与我们比较值的内部函数。如果我们的条件为`true`，我们会引发一个错误，其中我们返回一个错误结构`{
    ''minValue'' : {  value : control.value } }`，或者如果为`false`，我们返回null。'
- en: 'To use this new validator all we have to do is import it in our component file
    and type the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个新的验证器，我们只需要在我们的组件文件中导入它并输入以下内容：
- en: '[PRE39]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'And to show an error message in the template, if this error is raised, we just
    write this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 要在模板中显示错误消息，如果出现此错误，我们只需写入：
- en: '[PRE40]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Watching state changes and being reactive
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察状态变化和响应
- en: So far, we have seen how we can create forms programmatically using the `FormBuilder`
    and how we can specify all our fields and their validations in the code. We haven't
    really talked about why a reactive form is called *reactive.* Here is the thing,
    we can listen to changes on the input fields in the form when they happen and
    react accordingly. A suitable reaction could be to disable/enable a control, provide
    a visual hint, or something else. You get the idea.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何使用`FormBuilder`以编程方式创建表单，以及如何在代码中指定所有字段及其验证。我们还没有真正讨论为什么响应式表单被称为*reactive*。事实是，当表单中的输入字段发生更改时，我们可以监听并做出相应的反应。适当的反应可能是禁用/启用控件，提供视觉提示或其他操作。你明白了。
- en: How is this made possible though? It is made possible by the fact that the fields
    we declare have two Observables connected to them, `statusChanges` and `valueChanges`.
    By subscribing to those, we are able to listen to changes and make the suggested
    changes we mentioned earlier in this paragraph.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何实现的呢？这是通过我们声明的字段与它们连接的两个可观察对象`statusChanges`和`valueChanges`的事实而实现的。通过订阅它们，我们能够监听更改并进行前面段落中提到的建议更改。
- en: 'An interesting case for demonstrating how we can watch state changes is that
    of login. In a login scenario we want the user to type in their username and password,
    followed by pressing a button. What we should be able to support the user with
    in such a scenario is:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的案例，用于演示我们如何观察状态变化的情况是登录。在登录场景中，我们希望用户输入他们的用户名和密码，然后按下按钮。在这种情况下，我们应该能够支持用户：
- en: Showing a hint if something is wrong with the entered username, it may be empty
    or entered in a way that is not allowed
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果输入的用户名有问题，可能为空或以不允许的方式输入，显示提示
- en: Disabling the login button if not all required fields are entered
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有输入所有必填字段，则禁用登录按钮。
- en: We opt for showing a hint if the username is not constructed correctly. We don't
    want to show the hint unless the user has started to enter values.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户名没有正确构造，我们选择显示提示。除非用户已经开始输入值，我们不想显示提示。
- en: 'Let''s do this in steps. We first build our component, like so:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分步进行。首先构建我们的组件，如下所示：
- en: '[PRE41]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here we have set up a form with two input fields, a `username` field and a
    `password` field. We have also stated that these two fields are required by the
    way we have set up the validation rules. The next step is to set up the subscriber
    to the username fields so we can be notified of changes to it. The required changes
    are highlighted in bold:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置了一个具有两个输入字段的表单，一个`username`字段和一个`password`字段。我们还声明了这两个字段是必填的，通过我们设置的验证规则的方式。下一步是设置对用户名字段的订阅，以便我们可以收到有关其更改的通知。需要进行的更改已用粗体标出：
- en: '[PRE42]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can see here that we do this in two steps. First we create a reference to
    our username field by asking the `loginForm` for it, like so: `this.loginForm.controls[''username'']`.
    Then we set up a subscription to the form control reference `username:FormControl` by
    calling `username.subscribe(...)`. Inside of the `.subscribe()` we evaluate whether
    to set the `this.showUsernameHint`variable to `true` or `false`. The logic reads
    that if an `@` character is missing and the user has started typing, then show
    the visual hint. Setting the hint to `true` will trigger the template to show
    the hint text, like so:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们分两步来做这件事。首先，我们通过向`loginForm`请求来创建一个对用户名字段的引用，如：`this.loginForm.controls['username']`。然后，我们通过调用`username.subscribe(...)`来设置对表单控件引用`username:FormControl`的订阅。在`.subscribe()`内部，我们评估是否将`this.showUsernameHint`变量设置为`true`或`false`。逻辑是，如果缺少`@`字符并且用户已经开始输入，则显示视觉提示。将提示设置为`true`将触发模板显示提示文本，如下所示：
- en: '[PRE43]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Of course, there is more to creating a login component, such as sending the
    username and password to an endpoint and rerouting the user to a suitable page,
    and so on, but this code shows off the reactive nature.  Hopefully, this has clearly
    conveyed how you can take advantage of the reactive nature of forms and respond
    accordingly.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，创建登录组件还有更多内容，比如将用户名和密码发送到端点并将用户重定向到适当的页面等，但这段代码展示了响应式的特性。希望这清楚地传达了如何利用表单的响应式特性并做出相应的响应。
- en: Summary
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this section, we have learned that Angular provides you with two different
    flavors for creating forms, template-driven and reactive forms, and that neither
    approach can be said to be better than the other. We have also covered what different
    types of validations exist and we now know how to create our own validations.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经了解到Angular为创建表单提供了两种不同的方式，即模板驱动和响应式表单，并且不能说其中任何一种方法比另一种更好。我们还介绍了不同类型的验证存在，并且现在知道如何创建自己的验证。
- en: In the next chapter, we will take a look at how we can skin our application
    to look more beautiful with the help of the framework Angular Material. Angular
    Material comes with a lot of components and styling ready for you to use in your
    next project. So, let's give your Angular project the love it deserves.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看看如何利用Angular Material框架来美化我们的应用程序，使其看起来更加美观。Angular Material带有许多组件和样式，可以直接在你的下一个项目中使用。所以，让我们给你的Angular项目一些应有的关注。
