<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Explaining Pipes and Communicating with RESTful Services"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Explaining Pipes and Communicating with RESTful Services</h1></div></div></div><p>In the last chapter, we covered some very powerful features of the framework. However, we can go even deeper into the functionality of Angular's forms module and router. In the next sections, we'll explain how we can:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Develop model-driven forms.</li><li class="listitem" style="list-style-type: disc">Define parameterized routes.</li><li class="listitem" style="list-style-type: disc">Define child routes.</li><li class="listitem" style="list-style-type: disc">Use the HTTP module for communication with RESTful APIs.</li><li class="listitem" style="list-style-type: disc">Transform data with custom pipes.</li></ul></div><p>We will explore all these concepts in the process of extending the functionality of the "Coders repository" application. At the beginning of the preceding chapter, we mentioned that we will allow the import of developers from GitHub. However, before we implement this feature, let's extend the functionality of the form.</p><div class="section" title="Developing model-driven forms in Angular"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec59"/>Developing model-driven forms in Angular</h1></div></div></div><p>These will be the last steps for finishing the "Coders repository". You can build on top of the code available at <code class="literal">ch6/ts/step-1/</code> (or <code class="literal">ch6/ts/step-2</code>, depending on your previous work), in order to extend the application's functionality with the new concepts we will cover. The complete example is located at <code class="literal">ch7/ts/multi-page-model-driven</code>.</p><p>This is the result that we will achieve by the end of this section:</p><p>
</p><div class="mediaobject"><img alt="Developing model-driven forms in Angular" src="graphics/1-2.jpg"/></div><p>
</p><p>Figure 1</p><p>In the preceding screenshot, there are two forms:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A form that contains the following controls for importing existing users from GitHub:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The input for the GitHub handle.</li><li class="listitem" style="list-style-type: disc">A checkbox that points out whether we want to import the developer from GitHub or enter it manually.</li></ul></div><p>
</p></li><li class="listitem" style="list-style-type: disc">A form for entering new users manually.</li></ul></div><p>The second form looks exactly the way we left it in the last chapter. However, this time, its definition looks a little bit different:</p><pre class="programlisting">&lt;form class="form col-md-4" [formGroup]="addDevForm" [hidden]="submitted"&gt;&#13;
  &lt;!-- TODO --&gt; &#13;
&lt;/form&gt; &#13;
</pre><p>Note that, this time, we don't have the <code class="literal">submit</code> handler or the <code class="literal">#f="ngForm"</code> attribute. Instead, we bind the <code class="literal">[formGroup]</code> property to <code class="literal">addDevForm</code> defined inside the component's controller. Using this attribute, we can bind to something called <code class="literal">FormGroup</code>. As its name states, the <code class="literal">FormGroup</code> class consists of a list of controls grouped together with the sets of validation rules associated with them.</p><p>We need to use a similar declaration in the form used for importing a developer. However, this time, we will provide a different value of the <code class="literal">[formGroup]</code> property, as we will define a different form group in the component's controller. Place the following snippet above the form we introduced earlier:</p><pre class="programlisting">&lt;form class="form col-md-4" [formGroup]="importDevForm" [hidden]="submitted"&gt;&#13;
&lt;!-- TODO --&gt; &#13;
&lt;/form&gt; &#13;
</pre><p>Now, let's declare the <code class="literal">importDevForm</code> and <code class="literal">addDevForm</code> properties in the component's controller:</p><pre class="programlisting">import {FormGroup} from '@angular/forms';&#13;
 &#13;
@Component(...) &#13;
export class AddDeveloper { &#13;
  importDevForm: FormGroup; &#13;
  addDevForm: FormGroup; &#13;
  ... &#13;
  constructor(private developers: DeveloperCollection, &#13;
    fb: FormBuilder) {...} &#13;
  addDeveloper() {...} &#13;
} &#13;
</pre><p>Initially, we import the <code class="literal">FormGroup</code> class from the <code class="literal">@angular/forms</code> module and, later, declare the required properties in the controller. Note that we have one additional parameter of the constructor of <code class="literal">AddDeveloper</code> called <code class="literal">fb</code> of the <code class="literal">FormBuilder</code> type.</p><p>
<code class="literal">FormBuilder</code> provides a programmable API for the definition of <code class="literal">FormGroup</code> where we can attach validation behavior to each control in the group. Let's use the <code class="literal">FormBuilder</code> instance for the initialization of the <code class="literal">importDevForm</code> and <code class="literal">addDevForm</code> properties:</p><pre class="programlisting">... &#13;
constructor(private developers: DeveloperCollection, &#13;
  fb: FormBuilder) { &#13;
  this.importDevForm = fb.group({&#13;
    githubHandle: ['', Validators.required],&#13;
    fetchFromGitHub: [false]&#13;
  });&#13;
  this.addDevForm = fb.group({&#13;
    realName: ['', Validators.required],&#13;
    email: ['', validateEmail],&#13;
    technology: ['', Validators.required],&#13;
    popular: [false]&#13;
  });&#13;
} &#13;
... &#13;
</pre><p>The <code class="literal">FormBuilder</code> instance has a method called <code class="literal">group</code> that allows us to define properties, such as the default values and the validators for the individual controls in a given form.</p><p>According to the previous snippet, <code class="literal">importDevForm</code> has two fields: <code class="literal">githubHandle</code> and <code class="literal">fetchFromGitHub</code>. We declare that the value of the <code class="literal">githubHandle</code> control is required, and set the default value of the control <code class="literal">fetchFromGitHub</code> to <code class="literal">false</code>.</p><p>In the second form, <code class="literal">addDevForm</code>, we declare four controls. For the <code class="literal">realName</code> control as the default value, we set the empty string and use <code class="literal">Validators.requred</code> in order to introduce validation behavior (which is exactly what we did for the <code class="literal">githubHandle</code> control). As a validator for the e-mail input, we will use the <code class="literal">validateEmail</code> function and set the control's initial value to an empty string. The <code class="literal">validateEmail</code> function used for validation is the one we defined in the last chapter:</p><pre class="programlisting">function validateEmail(emailControl) { &#13;
  if (!emailControl.value || &#13;
     /^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$/.test(emailControl.value)) { &#13;
    return null; &#13;
  } else { &#13;
    return { 'invalidEmail': true }; &#13;
  } &#13;
} &#13;
</pre><p>The last two controls we define here are the <code class="literal">technology</code> control, for which a value is required and has an empty string as its initial value, and the <code class="literal">popular</code> control, with its initial value set to <code class="literal">false</code>.</p><div class="section" title="Using composition of control validators"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec100"/>Using composition of control validators</h2></div></div></div><p>We took a look at how we can apply a single validator to form controls. Using model-driven approach, we applied the <code class="literal">Validators.required</code> validator in a way equivalent to what we did in the preceding chapter, where we used template-driven forms and added the <code class="literal">required</code> attribute. However, in some applications, the domain may require a more complex validation logic. For example, if we want to apply both the required and the <code class="literal">validateEmail</code> validators to the e-mail control, we should do the following:</p><pre class="programlisting">this.addDevForm = fb.group({ &#13;
  ... &#13;
  email: ['', Validators.compose([ &#13;
    Validators.required, &#13;
    validateEmail] &#13;
  )], &#13;
  ... &#13;
}); &#13;
</pre><p>The <code class="literal">compose</code> method of the <code class="literal">Validators</code> object accepts an array of validators as an argument and returns a new validator. The new validator's behavior will be a composition of the logic defined in the individual validators passed as an argument, and they will be applied in the same order as they were introduced in the array.</p><p>The property names in the object literal passed to the <code class="literal">group</code> method, of the <code class="literal">FormBuilder</code>, should match with the values that we set to the <code class="literal">formControlName</code> attributes of the inputs in the template. This is the complete template of <code class="literal">importDevForm</code>:</p><pre class="programlisting">&lt;form class="form col-md-4" [formGroup]="importDevForm" [hidden]="submitted"&gt;&#13;
  &lt;div class="form-group"&gt;&#13;
  &lt;label class="control-label" for="githubHandleInput"&gt;GitHub handle&lt;/label&gt;&#13;
  &lt;div&gt;&#13;
    &lt;input id="githubHandleInput" class="form-control"&#13;
           type="text" <span class="strong"><strong>formControlName="githubHandle"</strong></span>&gt;&#13;
    &lt;control-errors control="githubHandle"&#13;
      [errors]="{&#13;
        'required': 'The GitHub handle is required'&#13;
      }"&gt;&lt;/control-errors&gt;&#13;
   &lt;/div&gt;&#13;
  &lt;/div&gt;&#13;
  &lt;div class="form-group"&gt;&#13;
    &lt;label class="control-label" for="fetchFromGitHubCheckbox"&gt;&#13;
      Fetch from GitHub&#13;
    &lt;/label&gt;&#13;
    &lt;input class="checkbox-inline" id="fetchFromGitHubCheckbox"&#13;
      type="checkbox" <span class="strong"><strong>formControlName="fetchFromGitHub"</strong></span>&gt;&#13;
  &lt;/div&gt;&#13;
&lt;/form&gt;&#13;
</pre><p>In the preceding template, we can note that, once the <code class="literal">submitted</code> flag has the value <code class="literal">true</code>, the form will be hidden from the user. Next to the first input element, we will set the value of the <code class="literal">formControlName</code> attribute to <code class="literal">githubHandle</code>. The <code class="literal">formControlName</code> attribute associates an existing form input in the template with one declared in the <code class="literal">FormGroup</code>, corresponding to the form element where HTML input resides. This means that the key associated with the controls' definition inside the object literal, which we pass to the <code class="literal">group</code> method of the <code class="literal">FormBuilder</code>, must match with the name of the corresponding control in the template, set with <code class="literal">formControlName</code>.</p><p>Now we want to implement the following behavior:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">When the <span class="strong"><strong>Fetch from GitHub</strong></span> checkbox is checked, disable the form for entering a new developer and enable the form for importing a developer from GitHub.</li><li class="listitem" style="list-style-type: disc">When the current active (or enabled) form is invalid, disable the submit button.</li></ul></div><p>We'll explore how we can achieve this functionality using Angular's reactive forms (also known as model-driven forms) API.</p><p>Inside the <code class="literal">AddDeveloper</code> class, add the following methods definitions:</p><pre class="programlisting">...&#13;
export class AddDeveloper {&#13;
  //...&#13;
  ngOnInit() {&#13;
    this.toggleControls(this.importDevForm.controls['fetchFromGitHub'].value);&#13;
    this.subscription = this.importDevForm.controls['fetchFromGitHub']&#13;
      .valueChanges.subscribe(this.toggleControls.bind(this));&#13;
  }&#13;
&#13;
  ngOnDestroy() {&#13;
    this.subscription.unsubscribe();&#13;
  }&#13;
&#13;
  private toggleControls(importEnabled: boolean) {&#13;
    const addDevControls = this.addDevForm.controls;&#13;
    if (importEnabled) {&#13;
      this.importDevForm.controls['githubHandle'].enable();&#13;
      Object.keys(addDevControls).forEach((c: string) =&gt;&#13;
        addDevControls[c].disable());&#13;
    } else {&#13;
      this.importDevForm.controls['githubHandle'].disable();&#13;
      Object.keys(addDevControls).forEach((c: string) =&gt;&#13;
        addDevControls[c].enable());&#13;
    }&#13;
  }&#13;
}&#13;
...</pre><p>Note that in <code class="literal">ngOnInit</code>, we invoke the <code class="literal">toggleControls</code> method with the current value of the <code class="literal">fetchFromGitHub</code> checkbox. We can get reference to the <code class="literal">AbstractControl</code>, which represents the checkbox, by getting the <code class="literal">fetchFromGitHub</code> property of the <code class="literal">controls</code> within the <code class="literal">importDevForm</code>.</p><p>After that, we subscribe to the <code class="literal">valueChange</code> event of the checkbox by passing a callback to its <code class="literal">subscribe</code> method. Each time the value of the checkbox is changed, the callback we've passed to <code class="literal">subscribe</code> will be invoked.</p><p>Later, in <code class="literal">ngOnDestroy</code>, we unsubscribe from the <code class="literal">valueChange</code> subscription in order to prevent our code from memory leaks.</p><p>Finally, the most interesting thing happens in <code class="literal">toggleControls</code>. To this method, we pass a flag that indicates whether we want the <code class="literal">importDevForm</code> to be enabled or not. If we want the form to be enabled, all we need to do is to invoke the <code class="literal">enable</code> method of the <code class="literal">githubHandle</code> control and disable all the controls in the <code class="literal">addDevForm</code>. We can disable all the controls in <code class="literal">addDevForm</code> by iterating over the control names (that is, the keys of the <code class="literal">controls</code> property of the <code class="literal">addDevForm</code>), getting the corresponding control instance for each individual name, and invoking its disable method. In case the <code class="literal">importEnabled</code> flag has value <code class="literal">false</code>, we do the exact opposite, by invoking the <code class="literal">enable</code> method of the controls from the <code class="literal">addDevForm</code> and the <code class="literal">disable</code> method of the control from <code class="literal">importDevForm</code>.</p></div></div></div>
<div class="section" title="Exploring the HTTP module of Angular"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec60"/>Exploring the HTTP module of Angular</h1></div></div></div><p>Now, after we have developed both forms – for importing existing and adding new developers, it is time to implement the logic behind them in the controller of the component.</p><p>For this purpose, we will need to communicate with the GitHub API. Although we can do this directly from the component's controller, by approaching the problem this way, we would couple the component with the RESTful API of GitHub. In order to enforce better separation of concerns, we can extract the logic for communication with GitHub into a separate service called <code class="literal">GitHubGateway</code>. Open the file called <code class="literal">github_gateway.ts</code>, and enter the following content:</p><pre class="programlisting">import {Injectable} from '@angular/core'; &#13;
import {Http} from '@angular/http'; &#13;
 &#13;
@Injectable() &#13;
export class GitHubGateway { &#13;
  constructor(private http: Http) {}&#13;
 &#13;
  getUser(username: string) { &#13;
    return this.http &#13;
      .get(`https://api.github.com/users/${username}`); &#13;
  } &#13;
} &#13;
</pre><p>Initially, we import the <code class="literal">Http</code> class from the <code class="literal">@angular/http</code> module. All the HTTP-related functionalities are externalized and are outside the Angular's core. Since <code class="literal">GitHubGateway</code> accepts a dependency, which needs to be injected through the DI mechanism of the framework, we will decorate it with the <code class="literal">@Injectable</code> decorator.</p><p>The only functionality from the GitHub's API we use is the one for fetching users, so we define a single method called <code class="literal">getUser</code>. As an argument, it accepts the GitHub handle of the developer.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note42"/>Note</h3><p>Note that, if you make more than 60 requests per day to the GitHub's API, you might get the error <span class="strong"><strong>GitHub API Rate limit exceeded</strong></span>. This is due to the rate limits for requests without a GitHub API token. For further information, visit <a class="ulink" href="https://github.com/blog/1509-personal-api-tokens">
https://github.com/blog/1509-personal-api-tokens
</a>.</p></div></div><p>Inside the <code class="literal">getUser</code> method, we use the instance of the <code class="literal">Http</code> service that we received in the <code class="literal">constructor</code>. The <code class="literal">Http</code> service's API stays as close to the HTML5 fetch API as possible. However, there are a couple of differences. The most significant one of them is that, at the moment of writing this content, all the methods of the <code class="literal">Http</code> instances return <code class="literal">Observables</code> instead of <code class="literal">Promises</code>.</p><p>The <code class="literal">Http</code> service instances have the following API:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">request(url: string | Request, options: RequestOptionsArgs)</code>: This makes a request to the specified URL. The request can be configured using <code class="literal">RequestOptionsArgs</code>, as follows:</li></ul></div><pre class="programlisting">      http.request('http://example.com/', { &#13;
        method: 'get', &#13;
        search: 'foo=bar', &#13;
        headers: new Headers({ &#13;
          'X-Custom-Header': 'Hello'&#13;
        }) &#13;
      }); &#13;
</pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">get(url: string, options?: RequestOptionsArgs)</code>: This makes a get request to the specified URL. The request headers and other options can be configured using the second argument.</li><li class="listitem" style="list-style-type: disc"><code class="literal">post(url: string, options?: RequestOptionsArgs)</code>: This makes a post request to the specified URL. The request body, headers, and other options can be configured using the second argument.</li><li class="listitem" style="list-style-type: disc"><code class="literal">put(url: string, options?: RequestOptionsArgs)</code>: This makes a put request to the specified URL. The request headers and other options can be configured using the second argument.</li><li class="listitem" style="list-style-type: disc"><code class="literal">patch(url: string, options?: RequestOptionsArgs)</code>: This makes a patch request to the specified URL. The request headers and other options can be configured using the second argument.</li><li class="listitem" style="list-style-type: disc"><code class="literal">delete(url: string, options?: RequestOptionsArgs)</code>: This makes a delete request to the specified URL. The request headers and other options can be configured using the second argument.</li><li class="listitem" style="list-style-type: disc"><code class="literal">head(url: string, options?: RequestOptionsArgs)</code>: This makes a head request to the specified URL. The request headers and other options can be configured using the second argument.</li></ul></div><div class="section" title="Using Angular's HTTP module"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec101"/>Using Angular's HTTP module</h2></div></div></div><p>Now, let's implement the logic for importing the existing developers from GitHub. First, we will need to import the <code class="literal">HttpModule</code> in our <code class="literal">AppModule</code>:</p><pre class="programlisting">import {HttpModule} from '@angular/http';&#13;
...&#13;
&#13;
@NgModule({&#13;
  imports: [..., HttpModule],&#13;
  declarations: [...],&#13;
  providers: [...],&#13;
  bootstrap: [...]&#13;
})&#13;
class AppModule {}&#13;
...</pre><p>After that, open the <code class="literal">ch6/ts/step-2/add_developer.ts</code> file and enter the following imports:</p><pre class="programlisting">import {Response} from '@angular/http'; &#13;
import {GitHubGateway} from './github_gateway'; &#13;
</pre><p>Add <code class="literal">GitHubGateway</code> to the list of providers of the <code class="literal">AddDeveloper</code> component:</p><pre class="programlisting">@Component({ &#13;
  ... &#13;
  providers: [GitHubGateway] &#13;
}) &#13;
class AddDeveloper {...} &#13;
</pre><p>As the next step, we have to include the following parameters in the constructor of the class:</p><pre class="programlisting">constructor(private githubAPI: GitHubGateway, &#13;
  private developers: DeveloperCollection, &#13;
  fb: FormBuilder) { &#13;
  //... &#13;
} &#13;
</pre><p>This way, the <code class="literal">AddDeveloper</code> class' instances will have a private property called <code class="literal">githubAPI</code>.</p><p>The only thing left is to implement the <code class="literal">addDeveloper</code> method and allow the user to import the existing developers using the <code class="literal">GitHubGateway</code> instance.</p><p>Once the user presses the <span class="strong"><strong>Add</strong></span> button, we will need to check whether we need to import an existing GitHub user or add a new developer. For this purpose, we can use the value of the <code class="literal">fetchFromGitHub</code> control:</p><pre class="programlisting">if (this.importDevForm.controls['fetchFromGitHub'].value) { &#13;
  // Import developer &#13;
} else { &#13;
  // Add new developer &#13;
} &#13;
</pre><p>If it has a truthy value, then we can invoke the <code class="literal">getUser</code> method of the <code class="literal">githubAPI</code> property and pass the value of the <code class="literal">githubHandle</code> control as an argument:</p><pre class="programlisting">this.githubAPI.getUser(model.githubHandle) &#13;
</pre><p>In the <code class="literal">getUser</code> method of the <code class="literal">GitHubGateway</code> instance, we delegate the call to the <code class="literal">Http</code> service's <code class="literal">get</code> method, which returns an observable. In order to get the result that the observable will push, we will need to pass a callback to its <code class="literal">subscribe</code> method:</p><pre class="programlisting">this.githubAPI.getUser(model.githubHandle) &#13;
  .map((r: Response) =&gt; r.json()) &#13;
  .subscribe((res: any) =&gt; { &#13;
    // "res" contains the response of the GitHub's API  &#13;
  }); &#13;
</pre><p>In the preceding snippet, we first establish the HTTP <code class="literal">get</code> request. After this, we get the corresponding observable that, in general cases, will emit a series of values (in this case, only a single one-the response of the request) and map them to their JSON representations. If the request fails, or the response's body is not a valid JSON string, then we will get an error.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note43"/>Note</h3><p>Note that, in order to reduce the bundle size of Angular, the team at Google has included only the core of RxJS in the framework. In order to use the <code class="literal">map</code> and <code class="literal">catch</code> methods, you will need to add the following imports at <code class="literal">add_developer.ts</code>:
<code class="literal">import 'rxjs/add/operator/map'; </code>
<code class="literal">import 'rxjs/add/operator/catch';</code>
</p></div></div><p>Now, let's implement the body of the callback we pass to <code class="literal">subscribe</code>:</p><pre class="programlisting">let dev = new Developer(); &#13;
dev.githubHandle = res.login; &#13;
dev.email = res.email; &#13;
dev.popular = res.followers &gt;= 1000; &#13;
dev.realName = res.name; &#13;
dev.id = res.id; &#13;
dev.avatarUrl = res.avatar_url; &#13;
this.developers.addDeveloper(dev); &#13;
this.successMessage = `Developer ${dev.githubHandle} successfully imported from GitHub`; &#13;
</pre><p>In the preceding example, we set the properties of a new <code class="literal">Developer</code> instance. Here, we establish the mapping between the object returned from GitHub's API and the developer's representation in our application. We consider a developer as popular if they have more than 1,000 followers.</p><p>The entire implementation of the <code class="literal">addDeveloper</code> method can be found at <code class="literal">ch7/ts/multi-page-model-driven/add_developer.ts</code>.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note44"/>Note</h3><p>In order to handle failed requests, we can use the <code class="literal">catch</code> method of the observable instances:
<code class="literal">this.githubAPI.getUser(model.githubHandle) </code>
<code class="literal">.catch((error, source, caught) =&gt; { </code>
   <code class="literal">console.log(error) </code>
   <code class="literal">return error; </code>
<code class="literal">});</code>
</p></div></div></div></div>
<div class="section" title="Defining parameterized views"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec61"/>Defining parameterized views</h1></div></div></div><p>As the next step, let's dedicate a special page for each developer. On it, we'll be able to take a detailed look at their profile. Once the user clicks on the name of any of the developers on the home page of the application, they should be redirected to a page with a detailed profile of the selected developer. The end result will look as follows:</p><p>
</p><div class="mediaobject"><img alt="Defining parameterized views" src="graphics/2-2.jpg"/></div><p>
</p><p>Figure 2</p><p>In order to do this, we will need to pass an identifier of the developer to the component that shows the developer's detailed profile. Open <code class="literal">app.ts</code>, and add the following import:</p><pre class="programlisting">import {DeveloperDetails} from './developer_details'; &#13;
</pre><p>We haven't developed the <code class="literal">DeveloperDetails</code> component yet, so, if you run the application, you will get an error. We will define the component in the next paragraph, but before this, let's alter the routes' definition of the <code class="literal">app.ts</code>:</p><pre class="programlisting">const routingModule = RouterModule.forRoot([&#13;
  ...&#13;
  {&#13;
    component: DeveloperDetails,&#13;
    path: 'dev-details/:id',&#13;
    children: devDetailsRoutes&#13;
  }&#13;
]);&#13;
</pre><p>We add a single route with the <code class="literal">dev-details/:id</code> path and associate the <code class="literal">DeveloperDetails</code> component with it.</p><p>Note that, in the <code class="literal">path</code> property, we declare that the route has a single parameter called <code class="literal">id</code> and also set the <code class="literal">children</code> property to the <code class="literal">devDetailsRoutes</code>. The <code class="literal">devDetailsRoutes</code> contains the nested routes, which should be rendered within the <code class="literal">router-outlet</code> located in <code class="literal">DeveloperDetails</code> component.</p><p>Now, let's pass the <code class="literal">id</code> of the current developer as a parameter to the <code class="literal">routerLink</code> directive. Open <code class="literal">home.html</code> in your working directory and replace the table cell, where we display the developer's <code class="literal">realName</code> property with the following content:</p><pre class="programlisting">&lt;td&gt; &#13;
  &lt;a [routerLink]="['/dev-details', dev.id, 'dev-basic-info']"&gt; &#13;
    {{dev.realName}} &#13;
  &lt;/a&gt; &#13;
&lt;/td&gt; &#13;
</pre><p>The value of the <code class="literal">routerLink</code> directive is an array with the following three elements:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">'/dev-details'</code>: A string that shows the root route.</li><li class="listitem" style="list-style-type: disc"><code class="literal">dev.id</code>: The ID of the developer whose details we want to see.</li><li class="listitem" style="list-style-type: disc"><code class="literal">'dev-basic-info'</code>: The path of a route that shows which component within the nested route should be rendered.</li></ul></div></div>
<div class="section" title="Defining nested routes"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec62"/>Defining nested routes</h1></div></div></div><p>Now, let's jump to the <code class="literal">DeveloperDetails</code> definition. In your working directory, create a file called <code class="literal">developer_details.ts</code> and enter the following content:</p><pre class="programlisting">import {Component} from '@angular/core';&#13;
import {ActivatedRoute} from '@angular/router';&#13;
import {Developer} from './developer';&#13;
import {DeveloperCollection} from './developer_collection';&#13;
import {DeveloperBasicInfo} from './developer_basic_info';&#13;
import {DeveloperAdvancedInfo} from './developer_advanced_info';&#13;
&#13;
import 'rxjs/add/operator/take';&#13;
&#13;
@Component({&#13;
  selector: 'dev-details',&#13;
  template: `...`,&#13;
})&#13;
export class DeveloperDetails {&#13;
  public dev: Developer;&#13;
&#13;
  constructor(private route: ActivatedRoute,&#13;
    private developers: DeveloperCollection) {}&#13;
&#13;
  ngOnInit() {&#13;
    this.route.params.take(1)&#13;
     .subscribe((params: any) =&gt; {&#13;
       this.dev = this.developers.getUserById(parseInt(params['id']));&#13;
    });&#13;
  }&#13;
}&#13;
&#13;
export const devDetailsRoutes = [...];&#13;
</pre><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip45"/>Tip</h3><p>For the sake of simplicity, in order to not introduce a complex directory/file structure in the examples for this book, we have a few component and route declarations in a single file. Keep in mind that, according to best practices, the individual declarations should be placed into separate files. For further information, visit
<a class="ulink" href="https://angular.io/styleguide">https://angular.io/styleguide</a>.</p></div></div><p>In the previous snippet, we define a component with controller called <code class="literal">DeveloperDetails</code>. Note that, within the controller's constructor, through the DI mechanism of Angular, we inject a parameter associated with the <code class="literal">ActivatedRoute</code> token. The injected parameter provides us with access to the parameters visible by the current route. In <code class="literal">ngOnInit</code>, we apply an imperative approach, where we subscribe changes in the value of the route's <code class="literal">params</code> property, get the first set of parameters, and assign the <code class="literal">dev</code> property to the result of the invocation of <code class="literal">this.developers.getUserById</code> with the selected developer's identifier as an argument.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip46"/>Tip</h3><p>
</p><p>Note that a more declarative and reactive approach would be to take advantage of the higher-order functions provided by RxJS, where we'd be able to get access to the selected developer using code similar to the following:</p><p>
</p><p>
<code class="literal">...</code>
<code class="literal"> get dev$() {</code>
<code class="literal">   return this.route.params.map((params: any) =&gt; </code>
<code class="literal">     this.developers.getUserById(parseInt(params['id'])));</code>
<code class="literal"> } </code>
<code class="literal"> ...</code>
</p><p>
</p><p>Later, we can bind to the result of the invocation with the Angular's async pipe, that we will explain later in this chapter.</p><p>
</p></div></div><p>Since the parameter we got from <code class="literal">routeParams.params['id']</code> is a string, we will need to parse it to a number in order to get the developer associated with the given route.</p><p>Now, let's define the child routes, which will be rendered in the template of <code class="literal">DeveloperDetails</code>:</p><pre class="programlisting">export const devDetailsRoutes = [&#13;
  { path: '', redirectTo: 'dev-basic-info', pathMatch: 'full' },&#13;
  { component: DeveloperBasicInfo, path: 'dev-basic-info' },&#13;
  { component: DeveloperAdvancedInfo, path: 'dev-details-advanced' }&#13;
];&#13;
</pre><p>In the preceding code, there is nothing new for us. The route definition follows the exact same rules we're already familiar with.</p><p>Now, to the template of the component, let's add links associated with the individual nested routes:</p><pre class="programlisting">@Component({&#13;
 selector: 'dev-details',&#13;
 template: `&#13;
   &lt;section class="col-md-4"&gt;&#13;
   &lt;ul class="nav nav-tabs"&gt;&#13;
     &lt;li&gt;&lt;a [routerLink]="['./dev-basic-info']"&gt;Basic profile&lt;/a&gt;&lt;/li&gt;&#13;
     &lt;li&gt;&lt;a [routerLink]="['./dev-details-advanced']"&gt;Advanced details&lt;/a&gt;&lt;/li&gt;&#13;
   &lt;/ul&gt;&#13;
   &lt;router-outlet&gt;&lt;/router-outlet&gt;&#13;
   &lt;/section&gt;&#13;
 `&#13;
})&#13;
export class DeveloperDetails {...}&#13;
</pre><p>Within the template, we declare two relative to the current path links. The first one points to <code class="literal">dev-basic-info</code>, which is the path of the first route defined within <code class="literal">devDetailsRoutes</code>, and the second one points to <code class="literal">dev-details-advanced</code>.</p><p>Since the implementations of the components associated with both routes are quite similar, let's take a look only at <code class="literal">DeveloperBasicInfo</code>. As an exercise, you can develop the second one or take a look at its implementation at <code class="literal">ch7/ts/multi-page-model-driven/developer_advanced_info.ts</code>:</p><pre class="programlisting">import {Component, Inject, forwardRef, Host} from '@angular/core';&#13;
import {DeveloperDetails} from './developer_details';&#13;
import {Developer} from './developer';&#13;
&#13;
@Component({&#13;
  selector: 'dev-details-basic',&#13;
  styles: [`&#13;
    .avatar {&#13;
      border-radius: 150px;&#13;
    }`&#13;
  ],&#13;
  template: `&#13;
    &lt;h2&gt;{{dev.githubHandle | uppercase}}&lt;/h2&gt;&#13;
    &lt;img *ngIf="dev.avatarUrl == null" class="avatar"&#13;
     src="http://hippycanada.ca/wordpress/wp-content/uploads/2014/12/gravatar-60-grey.jpg" width="150"&gt;&#13;
    &lt;img *ngIf="dev.avatarUrl != null" class="avatar" [src]="dev.avatarUrl" width="150"&gt;&#13;
 `&#13;
})&#13;
export class DeveloperBasicInfo {&#13;
  dev: Developer;&#13;
&#13;
  constructor(@Inject(forwardRef(() =&gt; DeveloperDetails))&#13;
     @Host() parent: DeveloperDetails) {&#13;
   this.dev = parent.dev;&#13;
  }&#13;
}&#13;
</pre><p>In the preceding snippet, we inject the parent component using the <code class="literal">@Inject</code> parameter decorator. Inside <code class="literal">@Inject</code>, we use <code class="literal">forwardRef</code>, since we have a circular dependency between the <code class="literal">developer_basic_info</code> and <code class="literal">developer_details</code> packages (inside <code class="literal">developer_basic_info</code>, we import <code class="literal">developer_details</code>, and within <code class="literal">developer_details</code>, we import <code class="literal">developer_basic_info</code>).</p><p>We need a reference to the instance of the parent component in order to get the instance of the current developer that corresponds to the selected route.</p></div>
<div class="section" title="Transforming data with pipes"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec63"/>Transforming data with pipes</h1></div></div></div><p>It is time to take a look at the last building block that Angular provides for the development of applications that we haven't covered in detail yet-the pipes.</p><p>Just like the filters in AngularJS, pipes are intended to encapsulate all the data transformation logic. Let's take a look at the template of the home page of the application we have just developed:</p><pre class="programlisting">... &#13;
&lt;td [ngSwitch]="dev.popular"&gt; &#13;
  &lt;span *ngSwitchCase="true"&gt;Yes&lt;/span&gt; &#13;
  &lt;span *ngSwitchCase="false"&gt;Not yet&lt;/span&gt; &#13;
&lt;/td&gt; &#13;
... &#13;
</pre><p>In the preceding snippet, depending on the value of the <code class="literal">popular</code> property, we show different data using the <code class="literal">NgSwitch</code> and <code class="literal">NgSwitchCase</code> directives. Although this works, it is redundant.</p><div class="section" title="Developing stateless pipes"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec102"/>Developing stateless pipes</h2></div></div></div><p>Let's develop a pipe that transforms the value of the <code class="literal">popular</code> property and uses it in place of <code class="literal">NgSwitch</code> and <code class="literal">NgSwitchCase</code>. The pipe will accept three arguments: a value that should be transformed, a string that should be displayed when the value is truthy, and another string that should be displayed in case of a falsy value.</p><p>With the use of an Angular custom pipe, we will be able to simplify the template to the following:</p><pre class="programlisting">&lt;td&gt;{{dev.popular | boolean: 'Yes': 'No'}}&lt;/td&gt; &#13;
</pre><p>We could even use emojis, as follows:</p><code class="literal">&lt;td&gt;{{dev.popular | boolean: '<span class="inlinemediaobject"><img alt="Developing stateless pipes" src="graphics/yes.jpg"/></span>': '<span class="inlinemediaobject"><img alt="Developing stateless pipes" src="graphics/no.jpg"/></span>'}}&lt;/td&gt; &#13;
</code><p>We apply the pipe to the value the same way we would do in AngularJS. The arguments we pass to the pipe should be separated by the colon (<code class="literal">:</code>) symbol.</p><p>In order to develop an Angular pipe, we will need the following imports:</p><pre class="programlisting">import {Pipe, PipeTransform} from '@angular/core'; &#13;
</pre><p>The <code class="literal">Pipe</code> decorator can be used for adding metadata to the class that implements the data transformation logic. The <code class="literal">PipeTransform</code> is an interface with a single method, called <code class="literal">transform</code>:</p><pre class="programlisting">import {Pipe, PipeTransform} from '@angular/core'; &#13;
 &#13;
@Pipe({ name: 'boolean' })&#13;
export class BooleanPipe implements PipeTransform {&#13;
  transform(flag: boolean, trueValue: any, falseValue: any): string {&#13;
    return flag ? trueValue : falseValue;&#13;
  }&#13;
}&#13;
</pre><p>The preceding snippet is the entire implementation of <code class="literal">BooleanPipe</code>. The <code class="literal">name</code> that we pass to the <code class="literal">@Pipe</code> decorator determines how we should reference it in templates.</p><p>The last thing we need to do before being able to use the <code class="literal">BooleanPipe</code> is to add it to the list of declarations in our <code class="literal">AppModule</code>:</p><pre class="programlisting">@NgModule({&#13;
  ...&#13;
  declarations: [..., <span class="strong"><strong>BooleanPipe</strong></span>, ...],&#13;
  ...&#13;
})&#13;
class AppModule {}&#13;
</pre></div><div class="section" title="Using Angular's built-in pipes"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec103"/>Using Angular's built-in pipes</h2></div></div></div><p>Angular provides the following set of built-in pipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">CurrencyPipe</code>: This pipe is used for formatting currency data. As an argument, it accepts the abbreviation of the currency type (that is, <code class="literal">"EUR"</code>, <code class="literal">"USD"</code>, and so on). It can be used in the following way:</li></ul></div><pre class="programlisting">      {{ currencyValue | currency: 'USD' }} &lt;!-- USD42 --&gt; &#13;
</pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">DatePipe</code>: This pipe is used for the transformation of dates. It can be used in the following way:</li></ul></div><pre class="programlisting">      {{ dateValue | date: 'shortTime'  }} &lt;!-- 12:00 AM --&gt; &#13;
</pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">DecimalPipe</code>: This pipe is used for transformation of decimal numbers. The argument it accepts is of the following form: <code class="literal">"{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}"</code>. It can be used in the following way:</li></ul></div><pre class="programlisting">      {{ 42.1618 | number: '3.1-2' }} &lt;!-- 042.16 --&gt; &#13;
</pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">JsonPipe</code>: This transforms a JavaScript object into a JSON string. It can be used in the following way:</li></ul></div><pre class="programlisting">      {{ { foo: 42 } | json }} &lt;!-- { "foo": 42 } --&gt; &#13;
</pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">LowerCasePipe</code>: This transforms a string to lowercase. It can be used in the following way:</li></ul></div><pre class="programlisting">      {{ FOO | lowercase }} &lt;!-- foo --&gt; &#13;
</pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">UpperCasePipe</code>: This transforms a string to uppercase. It can be used in the following way:</li></ul></div><pre class="programlisting">      {{ 'foo' | uppercase }} &lt;!-- FOO --&gt; &#13;
</pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">PercentPipe</code>: This transforms a number into a percentage. It can be used in the following way:</li></ul></div><pre class="programlisting">      {{ 42 | percent: '2.1-2' }}  &lt;!-- 4,200.0% --&gt; &#13;
</pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">SlicePipe</code>: This returns a slice of an array. The pipe accepts the start and the end indexes of the slice. It can be used in the following way:</li></ul></div><pre class="programlisting">      {{ [1, 2, 3] | slice: 1: 2 }} &lt;!-- 2 --&gt; &#13;
</pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">AsyncPipe</code>: This is a <code class="literal">stateful</code> pipe that accepts an observable or a promise; we will take a look at it at the end of the chapter.</li></ul></div></div><div class="section" title="Developing stateful pipes"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec104"/>Developing stateful pipes</h2></div></div></div><p>There is one common thing among all the pipes mentioned earlier – all of them return exactly the same result each time we apply them to the same value and pass them the same set of arguments. Such pipes, which hold the referentially transparency property, are called <span class="strong"><strong>pure pipes</strong></span>.</p><p>The <code class="literal">@Pipe</code> decorator accepts an object literal of the <code class="literal">{ name: string, pure?: boolean }</code> type, where the default value for the <code class="literal">pure</code> property is <code class="literal">true</code>. This means that, when we define any given pipe, we can declare whether it is stateful or stateless. The pure property is important because, in case the pipe is stateless (that is, it returns the same result in case it is applied over the same value with the same set of arguments), the change detection can be optimized.</p><p>Now, let's build a stateful pipe. Our pipe will make an HTTP <code class="literal">get</code> request to a JSON API. For this purpose, we will use the <code class="literal">@angular/http</code> module.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note47"/>Note</h3><p>Note that having business logic in a pipe is not considered as a best practice. This type of logic should be extracted into a service. The example here is for learning purposes only.</p></div></div><p>In this case, the pipe needs to hold a different state depending on the status of the request (that is, whether it is pending or completed). We will use the pipe in the following way:</p><pre class="programlisting">{{ "http://example.com/user.json" | fetchJson | json }} &#13;
</pre><p>This way, we apply the <code class="literal">fetchJson</code> pipe over the URL. Once we have the body of the response, we can apply the <code class="literal">json</code> pipe over it. This example also shows how we can chain pipes with Angular.</p><p>Similar to stateless pipes, for the development of stateful pipes, we have to decorate the class that implements the pipe's logic with <code class="literal">@Pipe</code> and implement the <code class="literal">PipeTransform</code> interface. This time, because of the HTTP request functionality, we will also need to import the <code class="literal">Http</code> and <code class="literal">Response</code> classes from the <code class="literal">@angular/http</code> module:</p><pre class="programlisting">import {Pipe, PipeTransform} from '@angular/core'; &#13;
import {Http, Response} from '@angular/http'; &#13;
import 'rxjs/add/operator/toPromise'; &#13;
</pre><p>Each time it happens to apply the <code class="literal">fetchJson</code> pipe to an argument with a different value, we will need to make a new HTTP <code class="literal">get</code> request. This means that, as the state of the pipe, we need to keep at least the values of the response of the remote service and the last URL:</p><pre class="programlisting">@Pipe({ &#13;
  name: 'fetchJson', &#13;
  pure: false &#13;
}) &#13;
export class FetchJsonPipe implements PipeTransform { &#13;
  private data: any; &#13;
  private prevUrl: string = null; &#13;
  constructor(private http: Http) {} &#13;
  transform(url: string): any {...} &#13;
} &#13;
</pre><p>The only piece of logic we need to implement is the <code class="literal">transform</code> method:</p><pre class="programlisting">... &#13;
transform(url: string): any { &#13;
  if (this.prevUrl !== url) { &#13;
    this.http.get(url).toPromise(Promise) &#13;
      .then((data: Response) =&gt; data.json()) &#13;
      .then(result =&gt; this.data = result); &#13;
    this.prevUrl = url; &#13;
  } &#13;
  return this.data || {}; &#13;
} &#13;
... &#13;
</pre><p>Inside of it, we initially compare the URL passed as an argument with the one we already have (by default, it's value will be <code class="literal">null</code>). If they are different, we initiate a new HTTP <code class="literal">get</code> request using the local instance of the <code class="literal">Http</code> class, which was passed to the <code class="literal">constructor</code> function. Once the request is completed, we parse the response to JSON and set the <code class="literal">data</code> property to the result.</p><p>Now, let's suppose that the pipe has started an <code class="literal">Http</code>
<code class="literal">get</code> request, and before it is completed, the change detection mechanism invokes the pipe again. In this case, we will compare the <code class="literal">prevUrl</code> property with the <code class="literal">url</code> parameter. If they are the same, we won't perform a new <code class="literal">http</code> request and will immediately return the value of the <code class="literal">data</code> property. If <code class="literal">prevUrl</code> has a different value from <code class="literal">url</code>, we will start a new request.</p></div><div class="section" title="Using stateful pipes"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec105"/>Using stateful pipes</h2></div></div></div><p>Now, let's use the pipe that we developed. The application that we will implement provides a text input and a button with label <span class="strong"><strong>Get Avatar</strong></span> to the user. Once the user enters a value in the text input and presses the button, the avatar corresponding to the GitHub user will appear below the text input, as shown in the following screenshot:</p><p>
</p><div class="mediaobject"><img alt="Using stateful pipes" src="graphics/3-2.jpg"/></div><p>
</p><p>Figure 3</p><p>Now, let's develop a sample component, which will allow us to enter the GitHub user's handle:</p><pre class="programlisting">// ch7/ts/statful_pipe/app.ts &#13;
 &#13;
@Component({ &#13;
  selector: 'app',&#13;
  template: ` &#13;
    &lt;input type="text" #input&gt; &#13;
    &lt;button (click)="setUsername(input.value)"&gt;Get Avatar&lt;/button&gt; &#13;
  ` &#13;
}) &#13;
class App { &#13;
  username: string; &#13;
  setUsername(user: string) { &#13;
    this.username = user; &#13;
  } &#13;
} &#13;
</pre><p>The only thing left is to show the GitHub avatar of the user. We can easily achieve this by altering the template of the preceding component with the following <code class="literal">img</code> declaration:</p><pre class="programlisting">&lt;img width="160"&#13;
  [src]="(('https://api.github.com/users/' + username) | fetchJson).avatar_url"&gt; &#13;
</pre><p>Initially, we append the GitHub handle to the base URL used for fetching users from the API. Later, we will apply the <code class="literal">fetchJson</code> filter over it and get the <code class="literal">avatar_url</code> property from the returned result.</p></div><div class="section" title="Using Angular's AsyncPipe"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec106"/>Using Angular's AsyncPipe</h2></div></div></div><p>Angular's <code class="literal">AsyncPipe</code>
<code class="literal">transform</code> method accepts an observable or a promise as an argument. Once the argument pushes a value (that is, the promise has been resolved or the <code class="literal">subscribe</code> callback of the observable is invoked), <code class="literal">AsyncPipe</code> will return it as a result. Let's take a look at the following example:</p><pre class="programlisting">// ch7/ts/async-pipe/app.ts &#13;
&#13;
@Component({ &#13;
  selector: 'greeting', &#13;
  template: 'Hello {{ greetingPromise | async }}' &#13;
}) &#13;
class Greeting { &#13;
  greetingPromise = new Promise&lt;string&gt;(resolve =&gt; this.resolve = resolve); &#13;
  resolve: Function;&#13;
 &#13;
  constructor() { &#13;
    setTimeout(_ =&gt; { &#13;
      this.resolve('Foobar!'); &#13;
    }, 3000); &#13;
  } &#13;
} &#13;
</pre><p>Here, we define an Angular component that has two properties, that is, <code class="literal">greetingPromise</code> of the type <code class="literal">Promise&lt;string&gt;</code> and <code class="literal">resolve</code> of the type <code class="literal">Function</code>. We initialized the <code class="literal">greetingPromise</code> property with a new <code class="literal">Promise&lt;string&gt;</code> instance, and as the value of the <code class="literal">resolve</code> property, we set the <code class="literal">resolve</code> callback of the <code class="literal">promise</code>.</p><p>In the constructor of the class, we start a time-out with the duration of 3,000 ms, and inside of its callback, we resolve the promise. Once the promise is resolved, the value of the expression <code class="literal">{{ greetingPromise | async }}</code> will be evaluated to the string <code class="literal">Foobar!</code>. The end result that the user will see on the screen is the text <span class="strong"><strong>"Hello Foobar!"</strong></span>.</p><p>The <code class="literal">async</code> pipe is extremely powerful when we combine it with an <code class="literal">Http</code> request or with an observable, which pushes a sequence of values.</p><div class="section" title="Using AsyncPipe with observables"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec18"/>Using AsyncPipe with observables</h3></div></div></div><p>We're already familiar with the concept of observables from the previous chapters. We can say that an observable object allows us to subscribe to the emission of a sequence of values, for instance:</p><pre class="programlisting">let observer = Observable.create(observer =&gt; { &#13;
  setInterval(() =&gt; { &#13;
    observer.next(new Date().getTime()); &#13;
  }, 1000); &#13;
}); &#13;
observer.subscribe(date =&gt; console.log(date)); &#13;
</pre><p>Once we subscribe to the observable, it will start emitting values each second, which will be printed in the console. Let's combine this snippet with component definition and implement a simple timer:</p><pre class="programlisting">// ch7/ts/async-pipe/app.ts&#13;
 &#13;
@Component({  selector: 'timer' }) &#13;
class Timer { &#13;
  username: string; &#13;
  timer: Observable&lt;number&gt;;&#13;
 &#13;
  constructor() { &#13;
    let counter = 0; &#13;
    this.timer = new Observable&lt;number&gt;(observer =&gt; { &#13;
      setInterval(() =&gt; { &#13;
        observer.next(new Date().getTime()); &#13;
      }, 1000); &#13;
    }); &#13;
  } &#13;
} &#13;
</pre><p>The only thing left in order to be able to use the timer component is to add its template. We can subscribe to the observable directly in the template using the <code class="literal">async</code> pipe:</p><pre class="programlisting">{{ timer | async | date: "medium" }} &#13;
</pre><p>This way, each second we will get the new value emitted by the observable, and the <code class="literal">date</code> pipe will transform it into a readable form.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec64"/>Summary</h1></div></div></div><p>In this chapter, we took a deep dive into the Angular's forms module, by developing a model-driven (reactive) form and combining it with the HTTP module. We took a look at some advanced features of the new component-based router and saw how we can use and develop custom stateful and stateless pipes.</p><p>The next chapter will be dedicated to how we can make our Angular applications SEO-friendly by taking advantage of the server-side rendering that the module Universal provides. Another thing that we'll take a look at is angular-cli and other tools that make our experience as developers better. Finally, we'll explain what Ahead-of-Time compilation is in the context of Angular, and why we should take advantage of it in our applications.</p></div></body></html>