- en: '*Chapter 2*: Crafting States in Functions'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第二章*：在函数中构建状态'
- en: In the previous chapter, we learned how to write function components in *React*.
    In this chapter, we will craft a special variable called a state in the function
    components. We will see what benefits a state can bring us, including requesting
    a new update, making a variable persistent, listening to a value change, as well
    as performing tasks upon the mount. We will also see an example of applying a
    state to a single-page application. In the end, we will look closely at what role
    the states play within the *UI*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何用 *React* 编写函数组件。在本章中，我们将在函数组件中构建一个特殊变量，称为状态。我们将看到状态能给我们带来什么好处，包括请求新的更新、使变量持久化、监听值的变化，以及在挂载时执行任务。我们还将看到一个将状态应用于单页应用程序的例子。最后，我们将仔细研究状态在
    *UI* 中扮演的角色。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Crafting a state in a function component
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数组件中构建状态
- en: Applying states to single-page applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将状态应用于单页应用程序
- en: How states work with UIs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态如何与 UI 一起工作
- en: Questions and answers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题和答案
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Before beginning, I would like you to know about the timeline sketch:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，我想让你了解一下时间线草图：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The timeline sketch is a unique illustrative chart type that displays a series
    of events during a period. The left bar (`|`) stands for the time origin, representing
    the first update. The horizontal dash (`-`) moves with the time from left to right
    with an arrow `>` at the end. Each letter or number, such as `x` , indicates one
    event that happened in this timeline. In this book, we will use the timeline sketch
    to better understand a situation when multiple things happen simultaneously along
    the timeline.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 时间线草图是一种独特的图表类型，它显示了一个时间段内的一系列事件。左侧的条（`|`）代表时间起点，表示第一次更新。水平破折号（`-`）随时间从左向右移动，并在末尾有一个箭头
    `>`。每个字母或数字，如 `x`，表示在这个时间线中发生的一个事件。在这本书中，我们将使用时间线草图来更好地理解在时间线上同时发生多个事件的情况。
- en: Crafting a state in a function component
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在函数组件中构建状态
- en: When you visit a typical web page, it asks for your username and password. After
    you log in, it displays the content of what the website provides, such as blogs,
    tweets, or videos, in a chronological order. You can vote on them and put your
    comments there – a very typical web experience these days.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当你访问一个典型的网页时，它会要求你输入用户名和密码。登录后，它会按时间顺序显示网站提供的内容，如博客、推文或视频。你可以对它们进行投票并在那里发表评论——这是当今非常典型的网络体验。
- en: When you surf a website like that as a user, you don't put too much thought
    into how any of the actions are implemented, nor do you care about the order in
    which each is fired. However, when it comes to building the site yourself, each
    action and the time at which each gets fired starts to become important.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当你作为一个用户浏览这样的网站时，你不会过多地思考任何动作是如何实现的，也不会关心每个动作被触发的顺序。然而，当你自己构建网站时，每个动作以及每个动作被触发的时机开始变得重要。
- en: 'An action handler fires when a user clicks a button, hovers over an icon, scrolls
    down a paragraph, types on the keyboard, and so on. A typical relationship between
    a user event and an action handler is illustrated in the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击按钮、悬停在图标上、向下滚动段落、在键盘上输入等动作时，会触发动作处理程序。用户事件和动作处理程序之间的一种典型关系如下所示：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding sketch, basically, an `x` in the `user event` series is followed
    by an `a` in the `user event` series. Based on this, we can start to handle a
    user action.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的草图中，基本上，`user event` 系列中的一个 `x` 后面跟着 `user event` 系列中的一个 `a`。基于此，我们可以开始处理用户动作。
- en: 'Let''s turn ourselves to a "Hello World" `Title` component with a button inside.
    Each time we click the button, a counter gets incremented by one and appended
    after **Hello World+**, as shown in *Figure 2.1*:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转向一个包含按钮的 "Hello World" `Title` 组件。每次我们点击按钮，计数器就会增加一，并附加在 **Hello World+**
    之后，如图 *图 2.1* 所示：
- en: '![Figure 2.1 – Hello World with no state'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.1 – 无状态的 Hello World'
- en: '](img/Figure_2.01_B17963.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.01_B17963.jpg)'
- en: Figure 2.1 – Hello World with no state
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 无状态的 Hello World
- en: 'To implement that, we start with a `count` variable to store a number initialized
    as `0`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们从一个初始化为 `0` 的 `count` 变量开始：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding `Title` component, the response to the user click is implemented
    via a React event handler, `onClick`, wired to a `button` element.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 `Title` 组件中，用户点击的响应是通过一个 React 事件处理程序 `onClick` 实现的，该处理程序连接到一个 `button`
    元素。
- en: A *React* event handler is written slightly differently from a *DOM* event handler.
    You can tell from the `onClick` camel case name, rather than the `onclick` lowercase
    name. A *React* event is a synthetic event that is a cross-browser wrapper around
    the browser native event. In this book, we expect them to behave in exactly the
    same way.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*React*事件处理器的编写方式略不同于*DOM*事件处理器。你可以从`onClick`驼峰命名法中看出，而不是`onclick`小写名称。*React*事件是一个跨浏览器的合成事件，它是对浏览器原生事件的包装。在这本书中，我们希望它们的行为完全相同。'
- en: Thanks to the *JavaScript* closure, we can directly access any component variable
    inside the event handler. The `count` variable does not need to be passed into
    `onClick` as a function input argument to be accessed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了*JavaScript*闭包，我们可以在事件处理程序中直接访问任何组件变量。`count`变量不需要作为函数输入参数传递给`onClick`以供访问。
- en: If we run the code, we'd expect the title to display `console.log` to two locations.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行代码，我们预计标题会显示`console.log`到两个位置。
- en: 'One is placed before `count = count + 1` to confirm what the `count` is after
    incrementation. Another one is placed before the `return` statement to confirm
    what the updated `count` is when the `Title` component is updated. They are marked
    at ➀ and ➁ in the following code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一个放在`count = count + 1`之前，以确认增量后的`count`值。另一个放在`return`语句之前，以确认当`Title`组件更新时的更新后的`count`值。它们在以下代码中标记为➀和➁：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With these two logs placed, we can rerun the code and generate a new timeline
    sketch:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 放置这两个日志后，我们可以重新运行代码并生成一个新的时间线草图：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: From the preceding printout, a `clicked` series at ➀ showed the `count` number
    when the button was clicked, and it was clicked six times. Let's turn to another
    log, the `updated` series at ➁; the `count` value got updated once as `0`, which
    explains why the display remained as `Hello World+0`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的打印输出中，➀处的`clicked`系列显示了按钮点击时的`count`数字，并且它被点击了六次。让我们转向另一个日志，➁处的`updated`系列；`count`值更新了一次，值为`0`，这解释了为什么显示仍然是`Hello
    World+0`。
- en: The `updated` series with only one printout at the very beginning indicates
    that there weren't any more updates after the first one. This is quite a discovery.
    If there were no more updates, how can we expect to see a change on the screen?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在最初打印一次的`updated`系列表明在第一个更新之后没有更多的更新。这是一个相当大的发现。如果没有更多的更新，我们怎么能期待在屏幕上看到变化呢？
- en: Playground – No State
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 操场 – 无状态
- en: Feel free to play with this example online at [https://codepen.io/windmaomao/pen/jOLNXzO](https://codepen.io/windmaomao/pen/jOLNXzO).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以免费在此在线尝试此示例：[https://codepen.io/windmaomao/pen/jOLNXzO](https://codepen.io/windmaomao/pen/jOLNXzO).
- en: As you might already realize, we need to request a new update after the click.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经意识到的，点击后我们需要请求一个新的更新。
- en: Requesting a new update
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求新的更新
- en: 'To make an update, for the time being, we can borrow the `render` function
    provided by *React*, as we have already used it to update the `rootEl` element:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行更新，目前，我们可以借用*React*提供的`render`函数，因为我们已经用它来更新了`rootEl`元素：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s take a minute to see how *React* updates the screen in general (see
    *Figure 2.2*). The detail involving updates can be quite complex; for now, let''s
    treat it as a black box. We will get into more details later in the book:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花一分钟时间看看*React*通常是如何更新屏幕的（见*图2.2*）。涉及更新的细节可能相当复杂；现在，让我们将其视为一个黑盒。我们将在本书的后面部分深入了解：
- en: '![Figure 2.2 – React update'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.2 – React更新'
- en: '](img/Figure_2.02_B17963.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.02_B17963.jpg)'
- en: Figure 2.2 – React update
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – React更新
- en: When an app starts, it lands on an update. This first update is a bit special.
    Because all the DOM elements need to be created, we refer to this update as a
    mount.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个应用启动时，它会进入一个更新。这个第一个更新有点特殊。因为所有DOM元素都需要被创建，所以我们把这个更新称为挂载。
- en: What's important to know is that a new update wouldn't arrive unless it's requested,
    just as we invoke a `render` function. When people first come to React, they might
    think it works as a game engine.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 需要知道的重要一点是，除非请求，否则不会到来新的更新，就像我们调用`render`函数一样。当人们第一次来到React时，他们可能会认为它像游戏引擎一样工作。
- en: For instance, a game engine would request a new update every 1/60 second behind
    the scenes. But *React* does not do that! Instead, the developer should get precise
    control of when a new update is requested. And most of the time, the frequency
    is a lot lower than 1/60 second, and it's more or less driven by how fast a user
    acts on the website.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个游戏引擎会在幕后每1/60秒请求一个新的更新。但*React*并不这样做！相反，开发者应该精确控制何时请求新的更新。而且，大多数时候，频率要低得多，这更多或更少地取决于用户在网站上如何快速行动。
- en: 'So with this, to bring the new `count` to the screen, another update needs
    to be requested manually; if we borrow the `render`, we can use it after the `count`
    is incremented:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，为了将新的`count`值带到屏幕上，我们需要手动请求另一个更新；如果我们借用`render`，我们可以在`count`递增后使用它：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we run the preceding code with the addition of `render`, the timeline sketch
    changes to the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在前面的代码中添加`render`，时间线草图将变为以下内容：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To our surprise, all numbers displayed were `0`. Looking at the `updated` series
    at `➁`, note we got seven printouts, which means we got six more updates on top
    of the first update. However, the `clicked` series at `➀` shows that the `count`
    value changed to `0` and stopped to increment any more. Weird?!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们惊讶的是，显示的所有数字都是`0`。查看`updated`系列在`➁`处，注意我们得到了七次打印，这意味着我们在第一次更新之上又进行了六次更新。然而，`clicked`系列在`➀`处显示，`count`值变为了`0`并停止了进一步的递增。奇怪吗？！
- en: How could the `count` value be stuck at `0`? Something must happen to the new
    update, but the `render` function can't be the one that resets the `count` value
    back to `0`, can it?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: “`count`值怎么会卡在`0`呢？新的更新肯定发生了某些事情，但`render`函数不可能就是那个将`count`值重置回`0`的函数，对吧？”
- en: 'It''s important to know that upon the `render` function being called and a
    function component being updated, the function that defines the component gets
    invoked, as shown in *Figure 2.3*:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道，当调用`render`函数并更新函数组件时，定义组件的函数会被调用，如图*图2.3*所示：
- en: '![Figure 2.3 – React render for a function component'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.3 – 函数组件的React渲染'
- en: '](img/Figure_2.03_B17963.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.03_B17963.jpg)'
- en: Figure 2.3 – React render for a function component
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – 函数组件的React渲染
- en: 'With this knowledge, let''s take a look at the `Title` function again:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这个知识，让我们再次看看`Title`函数：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code, we intentionally omit the `onClick` and `return` statements
    to make the code a bit cleaner. What was left became a `let count = 0` declaration
    statement. During each update, the `Title` function gets invoked, thus creating
    a new scope of the function. Inside this scope, there's a variable `count` value
    created locally to hold a `0` number. So this code doesn't seem to do much.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们故意省略了`onClick`和`return`语句，以使代码更简洁。剩下的就是一个`let count = 0`声明语句。在每次更新中，`Title`函数都会被调用，从而创建一个新的函数作用域。在这个作用域内，有一个局部创建的`count`变量值，用来保存`0`这个数字。所以这段代码看起来似乎没有做什么。
- en: It's not too difficult to see now why the `count` value remains at `0`, isn't
    it? It doesn't really matter if we have added the increment logic `onClick` or
    `return` statement. Upon each update, the entire function scope gets a new one
    with a `count` value declared and set to `0`. That explains why the `console.log`
    statement followed a printed `0`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在不难看出为什么`count`值保持在`0`，不是吗？无论我们是否添加了`onClick`或`return`语句的逻辑，每次更新后，整个函数作用域都会获得一个新的作用域，其中`count`值被声明并设置为`0`。这解释了为什么`console.log`语句后面跟着打印的`0`。
- en: This is actually the reason why a function component was named as a stateless
    function when it was introduced to *React* initially. "Stateless" refers to the
    fact that a function component can't carry or share a value to another update.
    In a simple word, the function reruns in each update with the same output.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上就是为什么函数组件在最初被引入到*React*时被命名为无状态函数的原因。这里的“无状态”指的是函数组件不能携带或共享值到另一个更新。简单来说，函数在每次更新中都会以相同的输出重新运行。
- en: Okay, now we understand the problem. So, it makes us consider saving the `count`
    value somewhere and making it persistent for another update.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们理解了问题。所以，这让我们考虑将`count`值保存在某个地方，并使其在另一个更新中持久化。
- en: Making a value persistent
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使值持久化
- en: '*JavaScript* supports a function scope: Variables defined inside a function
    cannot be accessed from anywhere outside the function, thus each function has
    its own scope. If you invoke a function multiple times, there''ll be multiple
    scopes. But no matter how many times we invoke it, it wouldn''t create a different
    output, such as what happened in the movie *Groundhog Day*.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*JavaScript*支持函数作用域：在函数内部定义的变量不能从函数外部访问，因此每个函数都有自己的作用域。如果你多次调用一个函数，会有多个作用域。但无论我们调用多少次，它都不会创建不同的输出，就像电影*
    Groundhog Day*中发生的那样。'
- en: Note
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The movie *Groundhog Day* is a 1993 fantasy comedy film, where Phil wakes up
    every day to find he experiences the previous day's events repeating exactly and
    believes he is experiencing déjà vu.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 电影* Groundhog Day*是一部1993年的奇幻喜剧片，其中菲尔每天醒来发现自己经历了前一天的事件重复发生，并相信他在经历似曾相识的感觉。
- en: 'For our `count` value, we can visualize what happened with the two updates
    in two different scopes in *Figure 2.4*:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的`count`值，我们可以在*图2.4*中可视化两次更新在两个不同作用域中发生的情况：
- en: '![Figure 2.4 – Two function scopes for the two updates'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.4 – 两次更新中的两个函数作用域'
- en: '](img/Figure_2.04_B17963.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_2.04_B17963.jpg)'
- en: Figure 2.4 – Two function scopes for the two updates
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – 两次更新中的两个函数作用域
- en: Luckily, *JavaScript* supports a function scope in a way that it can access
    all variables defined inside the scope in which it is defined. In our case, if
    a variable is defined outside of the `Title` function, we can access this variable
    inside the `Title` functions, as this value is shared now between multiple `Title`
    functions.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，*JavaScript*以一种方式支持函数作用域，它可以访问定义在其定义作用域内的所有变量。在我们的情况下，如果一个变量在`Title`函数外部定义，我们可以在`Title`函数内部访问这个变量，因为这个值现在在多个`Title`函数之间是共享的。
- en: The easiest way of sharing is to create a global variable because the global
    variable lives in the most outer scope of the *JavaScript* code, thus it can be
    accessed inside any function.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 分享的最简单方式是创建一个全局变量，因为全局变量位于*JavaScript*代码的最外层作用域，因此可以在任何函数内部访问。
- en: Note
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Don't be intimidated by a global variable used in this chapter. In [*Chapter
    3*](B17963_03_Epub.xhtml#_idTextAnchor080), *Hooking into React*, we will refine
    this approach and see how *React* defines the variable in a better location.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被本章中使用的全局变量吓倒。在[*第3章*](B17963_03_Epub.xhtml#_idTextAnchor080)“Hooking into
    React”中，我们将完善这种方法，并看看*React*如何在一个更好的位置定义变量。
- en: 'This way, each local `count` value can set/get this global `count` value, as
    shown in *Figure 2.5*:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，每个局部`count`值都可以设置/获取这个全局`count`值，如图2.5所示：
- en: '![Figure 2.5 – A shared value among the two updates'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.5 – 两次更新之间的共享值'
- en: '](img/Figure_2.05_B17963.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_2.05_B17963.jpg)'
- en: Figure 2.5 – A shared value among the two updates
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 – 两次更新之间的共享值
- en: 'Okay, with this new global variable idea, let''s see whether we can break out
    of our *Groundhog Day* situation:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，有了这个新的全局变量想法，让我们看看我们是否可以摆脱我们的*土拨鼠日*情况：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the preceding code, a global variable, `m`, is allocated, and it comes with
    `_getM` getter and `_setM` setter methods. The `_getM` function returns the value
    but sets the initial value for the first time. The `_setM` function sets the value
    and requests a new update. Let''s apply `_getM` and `_setM` to our `Title` component:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，分配了一个全局变量`m`，它附带`_getM`获取器和`_setM`设置器方法。`_getM`函数返回值但设置第一次的初始值。`_setM`函数设置值并请求新的更新。让我们将`_getM`和`_setM`应用于我们的`Title`组件：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Inside the preceding amended `Title` component, all `count` variables across
    updates are linked with the help of `_getM` and `_setM`. If we rerun the code,
    we can see the following timeline sketch:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的修改后的`Title`组件中，所有更新中的`count`变量都通过`_getM`和`_setM`的帮助相互链接。如果我们重新运行代码，我们可以看到以下时间线草图：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Wow! The screen changes to `Hello World+1` upon the first click and increments
    further upon more clicks, as shown in Figure 2.6:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！第一次点击后屏幕变为`Hello World+1`，并且随着更多点击进一步增加，如图2.6所示：
- en: '![Figure 2.6 – Hello World counter using a state'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.6 – 使用状态的Hello World计数器'
- en: '](img/Figure_2.06_B17963.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_2.06_B17963.jpg)'
- en: Figure 2.6 – Hello World counter using a state
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 – 使用状态的Hello World计数器
- en: Congratulations! You just crafted a state inside a function component.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你刚刚在函数组件中创建了一个状态。
- en: Playground – Count State
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 操场 – 计数状态
- en: Feel free to play with this example online at [https://codepen.io/windmaomao/pen/KKvPJdg](https://codepen.io/windmaomao/pen/KKvPJdg).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎在线尝试这个例子：[https://codepen.io/windmaomao/pen/KKvPJdg](https://codepen.io/windmaomao/pen/KKvPJdg)。
- en: The word "state" refers to the fact that it's persisted for all updates. For
    our convenience, we also change the state and request a new update afterward to
    reflect the change to the screen.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: “状态”一词指的是它对所有更新都是持久的。为了方便起见，我们还在更改状态并随后请求新的更新以反映屏幕上的更改。
- en: So, now we know how to handle a user action with a state. Let's see whether
    we can expand this idea further to support multiple states instead of one state.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们知道了如何使用状态来处理用户操作。让我们看看我们是否可以将这个想法进一步扩展以支持多个状态而不是一个状态。
- en: Support multiple states
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持多个状态
- en: It's great that we can establish a state persistent within a function component.
    But we want more states like that. An app normally contains lots of buttons, switches,
    and actionable items; each requires a state to be persistent. So, it's a must-have
    to support multiple states in the same app.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在函数组件内建立持久状态真是太好了。但我们想要更多这样的状态。一个应用通常包含很多按钮、开关和可操作项；每个都需要持久状态。因此，支持同一应用中的多种状态是必须的。
- en: 'So, say we need two buttons and each needs to be driven by a state. Let''s
    extend what we have learned from a single state:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要两个按钮，每个按钮都需要由一个状态驱动。让我们扩展我们从单一状态中学到的知识：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the preceding code, we first created two buttons, one with a `onC1ickH`
    and `onClickW` respectively. Also, we applied `_getM` and `_setM` to both of them,
    and installed a couple of logs to help the debug, as shown in the following timeline
    sketch:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先创建了两个按钮，一个具有`onC1ickH`和`onClickW`，分别。我们还对它们应用了`_getM`和`_setM`，并在以下时间轴草图上安装了一些日志来帮助调试：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: From the preceding sketch, we clicked the `updatedH` and `updatedW` series.
    However, the two series seem to be inseparable and in sync, meaning clicking one
    button would increment both values at the same time!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的草图来看，我们点击了`updatedH`和`updatedW`系列。然而，这两个系列似乎是不可分割且同步的，这意味着点击一个按钮会同时增加两个值！
- en: Playground – Linked States
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏场 – 链接状态
- en: Feel free to play with this example online at [https://codepen.io/windmaomao/pen/qBXWgay](https://codepen.io/windmaomao/pen/qBXWgay).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎在线尝试此示例：[https://codepen.io/windmaomao/pen/qBXWgay](https://codepen.io/windmaomao/pen/qBXWgay).
- en: 'Okay, it''s not too difficult to find out that we actually made a mistake by
    wiring the same state to both buttons; no wonder they updated at the same time:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，找出我们实际上将相同状态连接到两个按钮上的错误并不难；难怪它们会同时更新：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Although this is not what we wanted to achieve, it's interesting to see that
    a state is shared by two buttons. Visually, we linked two buttons; clicking one
    triggers the click on another.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这不是我们想要达到的效果，但看到两个按钮共享一个状态是很有趣的。从视觉上看，我们链接了两个按钮；点击一个会触发另一个的点击。
- en: So, what can we do if we want to have two separate states with each controlling
    one button? Well, we can just add another state. This time, we want to be a bit
    more generic in using a list to hold any number of states.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果我们想要有两个独立的状态，每个控制一个按钮，我们能做什么呢？嗯，我们只需添加另一个状态。这次，我们希望使用列表来更通用地存储任意数量的状态。
- en: 'There are lots of ways to keep track of a list of values in *JavaScript*; one
    of the ways is to use a key/value pair, as in an object:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *JavaScript* 中跟踪一系列值的方法有很多；其中一种方法是在对象中使用键/值对：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding code, we declare a `states` object to store all state values.
    The `_getM2` and `_setM2` functions are almost similar to the single-value version
    we crafted earlier, except this time we store each state under `states[key]` instead
    of `m`, thus a `key` is needed to identify each state. With this change, let''s
    amend the `Title` component:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们声明了一个`states`对象来存储所有状态值。`_getM2`和`_setM2`函数几乎与之前我们制作的单一值版本相似，但这次我们是在`states[key]`下存储每个状态而不是`m`，因此需要一个`key`来识别每个状态。有了这个变化，让我们修改`Title`组件：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the preceding amended version, we give a key to two states as `H` and `W`.
    We need this key for both `set` and `get` when a state is involved. Rerun the
    code and take a look at the timeline sketch:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的修改版本中，我们给两个状态分别赋予`H`和`W`作为键。当涉及到状态时，我们需要这个键来进行`set`和`get`操作。重新运行代码并查看时间轴草图：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Once again, we clicked the `countH` and `countW` are actually incremented separately,
    as you can see in the `updatedH` and `updatedW` series.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 再次点击，`countH`和`countW`实际上是分别增加的，正如你在`updatedH`和`updatedW`系列中看到的那样。
- en: 'After the first three clicks on the `countH` stays at `3` when we click on
    the **World** button. This is what we want to have, two separate states, as shown
    in *Figure 2.7*:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击“World”按钮时，`countH`在第一次点击后保持在`3`。这正是我们想要的结果，两个独立的状态，如图 2.7 所示：
- en: '![Figure 2.7 – Hello and World buttons with two states'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.7 – 具有两种状态的 Hello 和 World 按钮'
- en: '](img/Figure_2.07_B17963.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 2.07_B17963.jpg](img/Figure_2.07_B17963.jpg)'
- en: Figure 2.7 – Hello and World buttons with two states
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 – 具有两种状态的 Hello 和 World 按钮
- en: Playground – Multiple States
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏场 – 多种状态
- en: Feel free to play with this example online at [https://codepen.io/windmaomao/pen/dyzbaVr](https://codepen.io/windmaomao/pen/dyzbaVr).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎在线尝试此示例：[https://codepen.io/windmaomao/pen/dyzbaVr](https://codepen.io/windmaomao/pen/dyzbaVr).
- en: The state we crafted so far requests a new update. This is a very good use of
    persistency in a function component; since being persistent is actually quite
    a generic feature, it should be utilized for many different purposes. So, what
    other things can we do with it? Let's take a look at another usage of a state.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止构建的状态请求新的更新。这是在函数组件中使用持久性的一个好例子；因为持久性实际上是一个非常通用的功能，它应该被用于许多不同的目的。那么，我们还能用它做什么呢？让我们看看状态的另一种用法。
- en: Listen to a value change
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监听值变化
- en: You might wonder why we need to listen to a value change. Aren't the developers
    the ones who control the change of a value? As in the previous example, we use
    the event handler to change a counter. We know in this case exactly when the value
    gets changed.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么我们需要监听值变化。难道不是开发者控制值的改变吗？就像前面的例子一样，我们使用事件处理器来改变计数器。在这种情况下，我们知道值何时被更改。
- en: That's true for this case, but there are other cases. You might send a value
    into a child component via a prop, or there might be two components that touch
    a value at the same time. In either of these cases, you can lose track of the
    moment when the value is changed, but you still want to perform an action upon
    the value change. This means that you want to have the ability to listen to a
    value change. Let's set up one example to demonstrate this.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个案例来说，这是真的，但还有其他情况。你可能会通过属性将值发送到子组件，或者可能有两个组件同时接触一个值。在这两种情况下，你可能会失去跟踪值变化的那一刻，但你仍然想在值变化时执行操作。这意味着你想要有监听值变化的能力。让我们设置一个例子来演示这一点。
- en: 'Say in our `count` change, we want to know whether this value has recently
    been changed:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在我们的 `count` 变化中，我们想知道这个值是否最近被更改过：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the preceding `Changed` component, there''s a `count` prop that is sent
    from its parent, say any of the `Y` or `N`, depending on whether the `count` value
    has changed. We can use this `Changed` component in the `Title` component:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 `Changed` 组件中，有一个 `count` 属性是从其父组件发送的，比如说任何 `Y` 或 `N`，这取决于 `count` 值是否已更改。我们可以在
    `Title` 组件中使用这个 `Changed` 组件：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Note that in the preceding code, we add the `Changed` component between two
    buttons, and what we want to see is the `Changed` component display `Y` when we
    click the `Changed` component display `N` when we click on the **World** button.
    Essentially, we want to know whether the change is coming from the **Hello** button
    or not. But when we ran the code, here''s what we got in the timeline sketch:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面的代码中，我们在两个按钮之间添加了 `Changed` 组件，我们想要看到的是当我们点击 `Changed` 组件时显示 `Y`，当我们点击
    **World** 按钮时显示 `N`。本质上，我们想知道变化是否来自 **Hello** 按钮。但当我们运行代码时，在时间轴草图上我们得到了以下结果：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: From the preceding sketch, you can see that no matter which button is clicked,
    the `flag` in the `Changed flag` series displayed `N`. This comes as no surprise,
    since you might have already noticed that the `flag` inside the `Changed` component
    is fixed at `N`, so it wouldn't work the way we wanted. But the reason we wrote
    `N` there is because we don't know what to write there to flip the `flag`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的草图可以看出，无论哪个按钮被点击，`Changed flag` 系列中显示的 `flag` 都是 `N`。这并不令人惊讶，因为你可能已经注意到
    `Changed` 组件内部的 `flag` 被固定在 `N`，所以它不会按我们想要的方式工作。但我们之所以在那里写 `N` 是因为我们不知道该写什么来翻转
    `flag`。
- en: When the `countH` value, as in the `updatedH` series, increments to `3`. Similarly,
    when the `countW` value, as in the `updatedW` series, increments to `3`. However,
    note that as the `countW` value increments, the `countH` value also gets printed
    out; see `3-3-3` in the `updatedH` series.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `countH` 值，如在 `updatedH` 系列中，增加到 `3`。同样，当 `countW` 值，如在 `updatedW` 系列中，增加到
    `3`。然而，请注意，随着 `countW` 值的增加，`countH` 值也会被打印出来；参见 `updatedH` 系列中的 `3-3-3`。
- en: This indicates that for each update, every element under the `return` statement
    gets updated. Either `countW` or `countH` changes; it comes to a new update of
    the `Title` component, thus updating all `button` and `h1` elements. The same
    applies to the `Changed` component; whichever button changes, the `Changed` function
    gets invoked. Therefore, we can't tell whether the update to the `Changed` component
    is due to the **Hello** button or the **World** button.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明对于每次更新，`return` 语句下的每个元素都会被更新。`countW` 或 `countH` 发生变化；这导致 `Title` 组件的新更新，从而更新所有
    `button` 和 `h1` 元素。同样适用于 `Changed` 组件；无论哪个按钮发生变化，都会调用 `Changed` 函数。因此，我们无法确定 `Changed`
    组件的更新是由于 **Hello** 按钮还是 **World** 按钮。
- en: 'If we print out the `count` prop under the `Changed` component, it will look
    the same as in the `updatedH` series:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 `Changed` 组件下打印出 `count` 属性，它看起来将与 `updatedH` 系列中的相同：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Looking at the preceding `count` value, in order to come up with the changed
    `flag` for whether it changes from the previous value, we need to make a value
    persistent again – in this case, to get hold of the previous value. For example,
    `0` to `1` is a change, but `3` to `3` isn't.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 观察前面的 `count` 值，为了生成是否从上一个值变化的变化 `flag`，我们需要再次使值持久化——在这种情况下，是为了获取上一个值。例如，`0`
    到 `1` 是一个变化，但 `3` 到 `3` 并不是。
- en: 'Okay, to put this idea to work, let''s borrow the state approach but this time
    apply it to a `prev` value:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，为了将这个想法付诸实践，让我们借用状态方法，但这次将其应用于 `prev` 值：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the preceding code, we allocated a `prev` global variable and a `_onM` utility
    function. The `onM` function is designed to run a `callback` function when the
    `value` changes. It first checks whether the `value` is equal to the `prev` value.
    It returns if there''s no change. But if there is, the `callback` function is
    then invoked, and the current `value` replaces the `prev` value. Let''s apply
    this `_onM` function to the `Changed` component:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们分配了一个 `prev` 全局变量和一个 `_onM` 工具函数。`onM` 函数旨在在 `value` 发生变化时运行 `callback`
    函数。它首先检查 `value` 是否等于 `prev` 值。如果没有变化，则返回。但如果确实有变化，则调用 `callback` 函数，并将当前 `value`
    替换为 `prev` 值。让我们将这个 `_onM` 函数应用到 `Changed` 组件上：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'With the preceding change, we rerun the code and take a look at the updated
    timeline sketch:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行上述更改后，我们重新运行代码并查看更新的时间线草图：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Interestingly enough, when we clicked the `Y`, and when we clicked the `N`,
    as shown in *Figure 2.8*:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，当我们点击 `Y` 时，当我们点击 `N` 时，如 *Figure 2.8* 所示：
- en: '![Figure 2.8 – Listen to value change'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.8 – 监听值变化'
- en: '](img/Figure_2.08_B17963.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.08_B17963.jpg]'
- en: Figure 2.8 – Listen to value change
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 2.8 – 监听值变化
- en: Wonderful! Also, notice the first `Y` at the mount in the `Changed flag` series,
    which is when `countH` changes from `undefined` to `0`. Please make a note here;
    we'll talk about it in the next section.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！请注意，在 `Changed flag` 系列中，安装时的第一个 `Y`，这是 `countH` 从 `undefined` 变为 `0` 的时候。请在此处做笔记；我们将在下一节讨论它。
- en: Playground – Listening to State Change
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Playground – 监听状态变化
- en: Feel free to play with this example online at [https://codepen.io/windmaomao/pen/MWvgxLR](https://codepen.io/windmaomao/pen/MWvgxLR).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎在线尝试这个示例：[https://codepen.io/windmaomao/pen/MWvgxLR](https://codepen.io/windmaomao/pen/MWvgxLR)。
- en: Being able to listen to a value change is quite useful because it provides us
    with another way to perform tasks. Without it, we have to rely on an event handler,
    which is mostly driven by user actions. With `_onM`, we can perform a task upon
    a value change, which can come out of any other process.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 能够监听值的变化非常有用，因为它为我们提供了执行任务的另一途径。没有它，我们必须依赖于事件处理器，这通常是由用户操作驱动的。有了 `_onM`，我们可以在值变化时执行任务，这个变化可能来自任何其他过程。
- en: When listening to a value change, there exists a moment at the mount. This means
    that we can perform a task at the mount because of it. Let's take a look at it
    more closely.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在监听值变化时，存在一个挂载时刻。这意味着我们可以因为这个原因在挂载时执行任务。让我们更仔细地看看它。
- en: Performing a task at the mount
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 挂载时执行任务
- en: Components mount and un-mount as things show up and disappear based on the business
    requirement. At the mount, it's common to want to perform a task such as initializing
    some variables, calculating some formulas, or fetching an *API* to get some resources
    over the internet. Let's use an *API* call as an example.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 组件根据业务需求的出现和消失进行挂载和卸载。在挂载时，通常想要执行一些任务，比如初始化一些变量、计算一些公式，或者调用 *API* 从互联网上获取一些资源。让我们用一个
    *API* 调用作为例子。
- en: 'Say a `count` value needs to be fetched from an online service called `/giveMeANumber`.
    When this fetch returns successfully, we would like to reflect the change to the
    screen:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 假设需要从名为 `/giveMeANumber` 的在线服务中获取 `count` 值。当这个获取操作成功返回时，我们希望将变化反映到屏幕上：
- en: '[PRE25]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding code is what we'd like to do; however, we run into a technical
    issue right away. Though a new update can be requested, how can we send the returned
    data to the `Title` component?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是我们想要做的；然而，我们立即遇到了一个技术问题。尽管可以请求新的更新，但我们如何将返回的数据发送到 `Title` 组件？
- en: 'Maybe we can set up a prop on the `Title` component to send it in. However,
    doing that would require us to change the component interface. Since we already
    have had states crafted to issue a new update, let''s try that approach:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我们可以在`Title`组件上设置一个prop来发送它。然而，这样做将需要我们更改组件接口。由于我们已经有了用于发出新更新的状态，让我们尝试这种方法：
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding code, by using `_setM` after the fetch returns, we can update
    a state with the received `res.data` and request a new update afterward. The new
    update invokes `Title` and reads the latest `count` from the state via `_getM`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，通过在获取返回后使用`_setM`，我们可以使用接收到的`res.data`更新状态，并在之后请求新的更新。新的更新调用`Title`并通过`_getM`从状态中读取最新的`count`。
- en: 'Currently, we define the `fetch` function parallel to the `Title` component,
    but this is not the right location since we want to fetch only at the mount. To
    fix that, we can listen to the mount, as we have learned in the previous section:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们定义的`fetch`函数与`Title`组件平行，但这并不是正确的位置，因为我们只想在挂载时进行获取。为了解决这个问题，我们可以监听挂载，就像我们在上一节中学到的那样：
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Using the preceding line, we can listen for a mount moment. Note that we watched
    a constant `0` instead of any variable. During the mount, the value that `_onM`
    listens to changes from `undefined` to `0`, but for other future updates, the
    value stays at `0`; therefore, the `...` callback gets invoked only once at the
    mount. Let''s write `fetch` inside this callback:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的行，我们可以监听挂载时刻。请注意，我们监视的是一个常量`0`而不是任何变量。在挂载期间，`_onM`监听到的值从`undefined`变为`0`，但对于未来的其他更新，该值保持在`0`；因此，`...`回调只在挂载时被调用一次。让我们在这个回调中编写`fetch`：
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If we run the preceding code, the timeline sketch should generate the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的代码，时间线草图应该生成以下内容：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: At the mount of the `Title` component, the `count` state is set to be `0` initially.
    A `fetch` function is performed right away, depicted as the first `u` in the preceding
    `updates` series. Only when `fetch` returns successfully does the `count` state
    get updated to a new value and refreshed to the screen. The new update is depicted
    as the second `u` in the `updates` series.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Title`组件挂载时，`count`状态最初被设置为`0`。立即执行`fetch`函数，在先前的`updates`系列中表现为第一个`u`。只有当`fetch`成功返回时，`count`状态才会更新为新值并刷新到屏幕上。新的更新在`updates`系列中表现为第二个`u`。
- en: Playground – Task at Mount
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 操场 – 挂载时的任务
- en: Feel free to play with this example online at [https://codepen.io/windmaomao/pen/PoKobVZ](https://codepen.io/windmaomao/pen/PoKobVZ).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以自由地在这个示例中在线玩耍：[https://codepen.io/windmaomao/pen/PoKobVZ](https://codepen.io/windmaomao/pen/PoKobVZ)。
- en: 'Between the first and the second update, that''s how long it takes for the
    API to finish. The relationship between the API, the state, and two updates is
    illustrated in *Figure 2.9*. Essentially, after the API returns, it communicates
    to the shared state where the new update picks up later:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次和第二次更新之间，这是API完成所需的时间。API、状态和两个更新之间的关系在*图 2.9*中说明。本质上，在API返回后，它将新更新将从中继续的位置通知给共享状态：
- en: '![Figure 2.9 – Fetch API within the stateful component'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.9 – 状态组件内的 Fetch API'
- en: '](img/Figure_2.09_B17963.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 2.09_B17963.jpg](img/Figure_2.09_B17963.jpg)'
- en: Figure 2.9 – Fetch API within the stateful component
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9 – 状态组件内的 Fetch API
- en: Now that we have crafted a state, and also seen how flexible a state can be
    used to either make a new update or listen to a value change, let's get hands-on
    and apply what we have learned to an app.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个状态，并且也看到了状态如何灵活地用于创建新的更新或监听值的变化，让我们动手实践，将所学应用到应用程序中。
- en: Applying states to single-page application
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将状态应用于单页应用程序
- en: 'We want to continue what we started in the previous chapter in building a single-page
    application. We couldn''t finish it back then because we lacked a way to switch
    to a different page other than the home page. We had put together a `Nav` component:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望继续在上一章中开始构建单页应用程序的工作。当时我们无法完成它，因为我们缺乏切换到除主页之外的其他页面的方法。我们已组装了一个`Nav`组件：
- en: '[PRE30]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Given a list of pages, the `Nav` component displays them as links to navigate.
    The currently `selected` page needs to be provided as well. Now that we know how
    to define a state, let''s use it to keep track of the `selected` page:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一系列页面，`Nav`组件将它们显示为导航链接。同时还需要提供当前`selected`页面。现在我们知道了如何定义状态，让我们使用它来跟踪`selected`页面：
- en: '[PRE31]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the preceding `App` component, we used a state for `selected` to hold the
    `home` key initially, which is then passed into the `Nav` component. To allow
    the state to be updated after a user click, we need to modify `Nav` by adding
    the support of an `onSelect` callback function:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`App`组件中，我们使用一个状态`selected`来保存初始的`home`键，然后将其传递到`Nav`组件。为了允许在用户点击后更新状态，我们需要通过添加对`onSelect`回调函数的支持来修改`Nav`：
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding amended `Nav` component, an `onSelect` prop is passed so that
    after `onClick`, the parent `App` component can be notified to update the `selected`
    page via the `_setM` function.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面修改过的`Nav`组件中，传递了一个`onSelect`属性，以便在`onClick`之后，父`App`组件可以通过`_setM`函数通知更新`selected`页面。
- en: 'To confirm that the user does reach a different page, based on the current
    selected page, we can use a `Route` component to switch between page content:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认用户确实到达了不同的页面，基于当前选中的页面，我们可以使用一个`Route`组件在页面内容之间进行切换：
- en: '[PRE33]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'What the preceding `Route` component does is display the page content based
    on the `selected` page. Note that it uses a `&&` symbol, which is a common line
    in *React* code. It''s equivalent to the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`Route`组件所做的就是根据`selected`页面显示页面内容。注意，它使用了一个`&&`符号，这是*React*代码中常见的行。它等同于以下内容：
- en: '[PRE34]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If the condition matches on the left part, it returns `<Home />`; otherwise,
    it returns `false`. And according to *React*, any `true`, `false`, `null`, or
    `undefined` values are all valid elements, but when updated, they all get ignored
    without being displayed. Essentially, if the left part condition doesn't meet,
    it displays nothing.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果左侧的条件匹配，它返回`<Home />`；否则，它返回`false`。根据*React*，任何`true`、`false`、`null`或`undefined`值都是有效的元素，但在更新时，它们都会被忽略而不显示。本质上，如果左侧部分的条件不满足，则不显示任何内容。
- en: 'Putting the `Nav` and `Route` components together, we can amend the `App` component:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Nav`和`Route`组件组合起来，我们可以修改`App`组件：
- en: '[PRE35]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, we got two pages working, as shown in *Figure 2.10*! If you click
    the **Product** link, it''ll land on the product page:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们得到了两个页面可以正常工作，如图2.10所示！如果您点击**产品**链接，它将跳转到产品页面：
- en: '![Figure 2.10 – A single-page application using a state'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.10 – 使用状态的单一页面应用程序'
- en: '](img/Figure_2.10_B17963.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.10_B17963.jpg)'
- en: Figure 2.10 – A single-page application using a state
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 – 使用状态的单一页面应用程序
- en: To recap, the `App` component defines a `selected` state to hold the currently
    `selected` page. The `Nav` component is used to display all the links and allow
    it to choose a different page by clicking on the link. The `Route` component is
    used to display a page based on the `selected` state. Essentially, based on this
    setup, adding more pages is just a matter of adding new components under the `Route`
    component.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，`App`组件定义了一个`selected`状态来保存当前选中的页面。`Nav`组件用于显示所有链接，并允许通过点击链接选择不同的页面。`Route`组件用于根据`selected`状态显示页面。本质上，基于这种设置，添加更多页面只是简单地在`Route`组件下添加新的组件。
- en: Playground – Single-Page Application
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 操场 – 单一页面应用程序
- en: Feel free to play with this example online at [https://codepen.io/windmaomao/pen/PoKoWPG](https://codepen.io/windmaomao/pen/PoKoWPG).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎在线尝试这个示例：[https://codepen.io/windmaomao/pen/PoKoWPG](https://codepen.io/windmaomao/pen/PoKoWPG)。
- en: Before we end this chapter, let's take a minute to look at how exactly a state
    drives the UI under *React*.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本章之前，让我们花一分钟时间看看在*React*中状态是如何驱动UI的。
- en: How states work with UI
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态如何与UI协同工作
- en: 'With the introduction of state to the function component, we sometimes can
    get dizzy by the roles that it plays. We will use three components to elaborate,
    as shown in *Figure 2.11*:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 随着状态在函数组件中的引入，我们有时会因它所扮演的角色而感到困惑。我们将使用三个组件来阐述，如图2.11所示：
- en: '![Figure 2.11 – Props in components'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.11 – 组件中的属性'
- en: '](img/Figure_2.11_B17963.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.11_B17963.jpg)'
- en: Figure 2.11 – Props in components
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11 – 组件中的属性
- en: We have three components depicted in solid boxes. The outer component contains
    the middle one as a child, and the middle one contains the inner one as a child.
    Props, depicted as arrow lines crossing the boundary of a solid box, pass values
    from a parent to a child component.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三个组件用实心框表示。外层组件包含中间组件作为子组件，中间组件又包含内层组件作为子组件。属性，用穿过实心框边界的箭头线表示，从父组件传递到子组件。
- en: '*React* is a state machine. For a given fixed set of variables, it paints the
    screen the same way. With props, this is quite straightforward since each component
    is solely determined by its props. Now, let''s add the states to the picture,
    as shown in *Figure 2.12*. States, depicted as a symbol with a circle and a dot,
    are defined inside each component:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '*React*是一个状态机。对于给定的一组固定变量，它会以相同的方式绘制屏幕。由于每个组件仅由其属性决定，所以使用属性非常直接。现在，让我们将状态添加到图中，如图*图2.12*所示。状态，以带有圆圈和点的符号表示，是在每个组件内部定义的：'
- en: '![Figure 2.12 – States and props in components'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.12 – 组件中的状态和属性'
- en: '](img/Figure_2.12_B17963.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.12_B17963.jpg)'
- en: Figure 2.12 – States and props in components
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12 – 组件中的状态和属性
- en: Taking the **C** inner component first, it doesn't have any state defined. So,
    it's still determined by its props.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 首先考虑**C**内部组件，它没有定义任何状态。因此，它仍然由其属性决定。
- en: The **B** middle component has one state defined. With a fixed set of its props,
    the screen corresponding to the component still can vary because this state can
    take a different value on each update.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**B** 中间组件定义了一个状态。当其属性固定时，对应组件的屏幕仍然可以变化，因为这种状态可以在每次更新时取不同的值。'
- en: The **A** outer component has two states defined. Similarly, with all its props
    fixed, the screen corresponding to it can still vary. The variation can come from
    any of its two states, and it can come from the state of the **B** component as
    well because the states of the parent and the child can work independently upon
    updates.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**A** 外部组件定义了两种状态。同样，当所有属性固定时，对应的屏幕仍然可以变化。这种变化可以来自其两种状态中的任何一种，也可以来自**B**组件的状态，因为父组件和子组件的状态可以在更新时独立工作。'
- en: Therefore, we can conclude that to get the screen painted for the **A** component,
    we need to fix all props and states within itself and all its child components
    underneath. This is not a mathematical theory, but given the states from multiple
    components, this observation is apparent.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以得出结论，要为**A**组件绘制屏幕，我们需要固定其内部及其所有子组件的所有属性和状态。这并不是一个数学理论，但考虑到多个组件的状态，这个观察结果是明显的。
- en: In short, props and states now both serve as the input of the component. The
    states can be especially vibrant since their values can be, but are not always,
    wired with an external system. The external system can be browser events or the
    *API* fetch, or anything else. Because a state can send to a child component via
    a prop, the effect of the state can cascade down deep into the app tree quickly.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，属性和状态现在都作为组件的输入。状态可以特别生动，因为它们的值可以是，但并不总是与外部系统连接。外部系统可以是浏览器事件或*API*获取，或任何其他东西。因为状态可以通过属性发送到子组件，所以状态的影响可以迅速地级联到应用树的深处。
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started to craft a new thing called a state inside the function
    component. The state is persistent across updates and can be used to request a
    new update, listen to a value change, as well as perform a task at the mount.
    Later, we applied the state we developed to a single-page application to draft
    a simplified `Nav` with a route system. In the end, we briefly studied how states
    work for *UI* under *React*.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始在函数组件内构建一个新事物，称为状态。状态在更新期间是持久的，可以用来请求新的更新、监听值的变化，以及在挂载时执行任务。后来，我们将开发的状态应用于单页应用程序，以创建一个具有路由系统的简化`Nav`。最后，我们简要研究了在*React*下状态如何影响*UI*。
- en: In the next chapter, we will introduce you to what a React hook is and how this
    persistent state is designed under the *React* engine.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将向您介绍React钩子的概念以及这种持久状态是如何在*React*引擎下设计的。
- en: Questions and answers
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题和答案
- en: 'Here are some questions and answers to refresh your knowledge:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些问题和答案来更新您的知识：
- en: What is a state?
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 状态是什么？
- en: For a function component, a state is a value created to be persistent during
    the life of the component. From each update, including the mount, this value can
    be accessed from inside a function.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于函数组件，状态是在组件生命周期内创建的用于持久化的值。从每次更新（包括挂载）中，这个值都可以在函数内部访问。
- en: What are the usages of states?
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 状态有哪些用途？
- en: If a task can't be done within one update, that is the time we can think of
    using a state to reference a memory that can be accessed in multiple updates.
    We normally use a state to request a new update, listen to a value change, as
    well as perform a task at the mount. But the states can be very versatile.
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果一个任务不能在一个更新周期内完成，那么这就是我们可以考虑使用状态来引用可以在多个更新周期中访问的内存的时候。我们通常使用状态来请求新的更新、监听值的变化，以及在挂载时执行任务。但状态可以非常灵活。
- en: What does a state do to the UI?
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 状态对UI做了什么？
- en: To determine the screen corresponding to a component, we need to know its states
    as well as its props. While the props are passively defined on the component interface,
    the states are defined inside the component to actively refine its behavior. Apps
    built with states can change with time, driven by either user interactions or
    any other external processes.
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了确定与组件对应的屏幕，我们需要知道它的状态以及它的属性。虽然属性是在组件接口上被动定义的，但状态是在组件内部定义的，以积极调整其行为。使用状态构建的应用可以随时间变化，由用户交互或任何其他外部过程驱动。
