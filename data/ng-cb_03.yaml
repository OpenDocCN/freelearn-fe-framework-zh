- en: '*Chapter 3*: The Magic of Dependency Injection in Angular'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*：Angular中的依赖注入的魔力'
- en: This chapter is all about the magic of **dependency injection** (**DI**) in
    Angular. Here, you'll learn some detailed information about the concept of DI
    in Angular. DI is the process that Angular uses to inject different dependencies
    into components, directives, and services. You'll work with several examples using
    services and providers to get some hands-on experience that you can utilize in
    your later Angular projects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要讲解Angular中**依赖注入**（**DI**）的魔力。在这里，您将学习有关Angular中DI概念的详细信息。DI是Angular用来将不同的依赖项注入到组件、指令和服务中的过程。您将使用几个示例来使用服务和提供程序，以获得一些实践经验，这些经验可以在以后的Angular项目中使用。
- en: 'In this chapter, we''re going to cover the following recipes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Configuring an injector with a DI token
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用DI令牌配置注入器
- en: Optional dependencies
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选依赖项
- en: Creating a singleton service using `providedIn`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`providedIn`创建单例服务
- en: Creating a singleton service using `forRoot()`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`forRoot()`创建单例服务
- en: Providing different services to the app with the same Aliased class provider
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用相同的别名类提供程序为应用程序提供不同的服务
- en: Value providers in Angular
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular中的值提供程序
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术要求
- en: For the recipes in this chapter, ensure you have **Git** and **NodeJS** installed
    on your machine. You also need to have the `@angular/cli` package installed, which
    you can do so using `npm install -g @angular/cli` from your Terminal. The code
    for this chapter can be found at [https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter03](https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter03).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的示例，请确保您的机器上安装了**Git**和**NodeJS**。您还需要安装`@angular/cli`包，可以在终端中使用`npm install
    -g @angular/cli`来安装。本章的代码可以在[https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter03](https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter03)找到。
- en: Configuring an injector with a DI token
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用DI令牌配置注入器
- en: In this recipe, you'll learn how to create a basic DI token for a regular TypeScript
    class to be used as an Angular service. We have a service (`UserService`) in our
    application, which currently uses the `Greeter` class to create a user with a
    `greet` method. Since Angular is all about DI and services, we'll implement a
    way in which to use this regular TypeScript class, named `Greeter`, as an Angular
    service. We'll use `InjectionToken` to create a DI token and then the `@Inject`
    decorator to enable us to use the class in our service.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将学习如何为常规的TypeScript类创建一个基本的DI令牌，以便用作Angular服务。我们的应用程序中有一个服务（`UserService`），它当前使用`Greeter`类来创建一个具有`greet`方法的用户。由于Angular完全依赖于DI和服务，我们将实现一种方式来使用这个常规的TypeScript类，名为`Greeter`，作为Angular服务。我们将使用`InjectionToken`来创建一个DI令牌，然后使用`@Inject`装饰器来使我们能够在我们的服务中使用该类。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project that we are going to work with resides in `chapter03/start_here/ng-di-token`,
    which is inside the cloned repository. Perform the following steps:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要处理的项目位于`chapter03/start_here/ng-di-token`中，该项目位于克隆存储库内。执行以下步骤：
- en: Open the project in Visual Studio Code.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中打开项目。
- en: Open the Terminal and run `npm install` to install the dependencies of the project.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行`npm install`来安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。
- en: 'This should open the app in a new browser tab; you should see something similar
    to the following screenshot:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签中打开应用程序；您应该看到类似以下截图的内容：
- en: '![Figure 3.1 – The ng-di-token app running on http://localhost:4200'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.1- ng-di-token应用程序在http://localhost:4200上运行'
- en: '](image/Figure_3.1_B15150.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.1_B15150.jpg)'
- en: Figure 3.1 – The ng-di-token app running on http://localhost:4200
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1- ng-di-token应用程序在http://localhost:4200上运行
- en: Now that we have the app running, we can move on to the steps for the recipe.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序正在运行，我们可以继续进行食谱的步骤。
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The app we have right now shows a greeting message to a random user that has
    been retrieved from our `UserService`. And `UserService` uses the `Greeter` class
    as it is. Instead of using it as a class, we''ll use it as an Angular service
    using DI. We''ll start by creating an `InjectionToken` for our `Greeter` class,
    which is a regular TypeScript class, and then we''ll inject it into our services.
    Perform these steps to follow along:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的应用程序向从我们的`UserService`中检索到的随机用户显示问候消息。而`UserService`使用`Greeter`类就像它是的。我们将不再将其作为类使用，而是使用DI将其作为Angular服务使用。我们将首先为我们的`Greeter`类创建一个`InjectionToken`，然后将其注入到我们的服务中。按照以下步骤进行：
- en: 'We''ll create an `InjectionToken` in the `greeter.class.ts` file, called `''Greeter''`,
    using the `InjectionToken` class from the `@angular/core` package. Additionally,
    we''ll export this token from the file:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在`greeter.class.ts`文件中创建一个`InjectionToken`，名为`'Greeter'`，使用`@angular/core`包中的`InjectionToken`类。此外，我们将从文件中导出此令牌：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we''ll use the `Inject` decorator from the `@angular/core` package and
    the `GREETER` token from `greeter.class.ts` so that we can use them in the next
    step:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用`@angular/core`包中的`Inject`装饰器和`greeter.class.ts`中的`GREETER`令牌，以便我们可以在下一步中使用它们：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We'll now inject the `Greeter` class using the `@Inject` decorator in `constructor`
    of `UserService` as an Angular service.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将使用`@Inject`装饰器在`UserService`的`constructor`中注入`Greeter`类作为Angular服务。
- en: 'Notice that we''ll be using `typeof Greeter` instead of just `Greeter` because
    we need to use the constructor later on:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将使用`typeof Greeter`而不是只使用`Greeter`，因为我们需要稍后使用构造函数。
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, we can replace the usage of `new Greeter(user)` inside the `getUser`
    method by using the injected service, as follows:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以通过使用注入的服务来替换`getUser`方法中`new Greeter(user)`的用法，如下所示：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that we know the recipe, let's take a closer look at how it works.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了方法，让我们更仔细地看看它是如何工作的。
- en: How it works
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'Angular doesn''t recognize regular TypeScript classes as injectables in services.
    However, we can create our own injection tokens and use the `@Inject` decorator
    to inject them whenever possible. Angular recognizes our token behind the scenes
    and finds its corresponding definition, which is usually in the form of a factory
    function. Notice that we''re using `providedIn: ''root''` within the token definition.
    This means that there will be only one instance of the class in the entire application.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 'Angular在服务中不认识普通的TypeScript类作为可注入的对象。然而，我们可以创建自己的注入令牌，并使用`@Inject`装饰器在可能的情况下注入它们。Angular在后台识别我们的令牌并找到其对应的定义，通常是以工厂函数的形式。请注意，我们在令牌定义中使用了`providedIn:
    ''root''`。这意味着整个应用程序中只会有一个类的实例。'
- en: See also
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Dependency Injection in Angular ([https://angular.io/guide/dependency-injection](https://angular.io/guide/dependency-injection))
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular中的依赖注入（[https://angular.io/guide/dependency-injection](https://angular.io/guide/dependency-injection)）
- en: InjectionToken documentation ([https://angular.io/api/core/InjectionToken](https://angular.io/api/core/InjectionToken))
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: InjectionToken文档（[https://angular.io/api/core/InjectionToken](https://angular.io/api/core/InjectionToken)）
- en: Optional dependencies
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可选依赖
- en: Optional dependencies in Angular are really powerful when you use or configure
    a dependency that may or may not exist or that has been provided within an Angular
    application. In this recipe, we'll learn how to use the `@Optional` decorator
    to configure optional dependencies in our components/services. We'll work with
    `LoggerService` and ensure our components do not break if it has not already been
    provided.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，可选依赖项在您使用或配置可能存在或已在Angular应用程序中提供的依赖项时非常强大。在本示例中，我们将学习如何使用`@Optional`装饰器来配置组件/服务中的可选依赖项。我们将使用`LoggerService`，并确保我们的组件在未提供时不会中断。
- en: Getting ready
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project for this recipe resides in `chapter03/start_here/ng-optional-dependencies`.
    Perform the following steps:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例项目位于`chapter03/start_here/ng-optional-dependencies`中。执行以下步骤：
- en: Open the project in Visual Studio Code.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中打开项目。
- en: Open the Terminal, and run `npm install` to install the dependencies of the
    project.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，并运行`npm install`来安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。
- en: 'This should open the app in a new browser tab. You should see something similar
    to the following screenshot:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在新的浏览器选项卡中打开应用程序。您应该看到类似以下截图的内容：
- en: '![Figure 3.2 – The ng-optional-dependencies app running on http://localhost:4200'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.2 - ng-optional-dependencies应用程序在http://localhost:4200上运行'
- en: '](image/Figure_3.2_B15150.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.2_B15150.jpg)'
- en: Figure 3.2 – The ng-optional-dependencies app running on http://localhost:4200
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 - ng-optional-dependencies应用程序在http://localhost:4200上运行
- en: Now that we have the app running, we can move on to the steps for the recipe.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序正在运行，我们可以继续进行该示例的步骤。
- en: How to do it
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'We''ll start with an app that has a `LoggerService` with `providedIn: ''root''`
    set to its injectable configuration. We''ll see what happens when we don''t provide
    this service anywhere. Then, we''ll identify and fix the issues using the `@Optional`
    decorator. Follow these steps:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将从一个具有`providedIn: ''root''`设置为其可注入配置的`LoggerService`的应用程序开始。我们将看到当我们没有在任何地方提供此服务时会发生什么。然后，我们将使用`@Optional`装饰器来识别和解决问题。按照以下步骤进行操作：'
- en: First, let's run the app and change the version in the input.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们运行应用程序并更改输入中的版本。
- en: 'This will result in the logs being saved in `localStorage` via `LoggerService`.
    Open **Chrome Dev Tools**, navigate to **Application**, select **Local Storage**,
    and then click on `localhost:4200`. You will see the `key log_log` with log values,
    as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致日志通过`LoggerService`保存在`localStorage`中。打开**Chrome Dev Tools**，导航到**Application**，选择**Local
    Storage**，然后点击`localhost:4200`。您将看到具有日志值的`key log_log`，如下所示：
- en: '![Figure 3.3 – The logs are saved in localStorage for http://localhost:4200'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.3 - 日志保存在http://localhost:4200的localStorage中'
- en: '](image/Figure_3.3_B15150.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.3_B15150.jpg)'
- en: Figure 3.3 – The logs are saved in localStorage for http://localhost:4200
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 - 日志保存在http://localhost:4200的localStorage中
- en: 'Now, let''s try to remove the configuration provided in the `@Injectable` decorator
    for `LoggerService`, which is highlighted in the following code:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试删除`@Injectable`装饰器中提供的`LoggerService`的配置，如下面的代码中所突出显示的那样：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will result in Angular not being able to recognize it and throwing an
    error to `VcLogsComponent`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致Angular无法识别它，并向`VcLogsComponent`抛出错误：
- en: '![Figure 3.4 – An error detailing that Angular doesn''t recognize LoggerService'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.4 - 详细说明了Angular无法识别LoggerService的错误'
- en: '](image/Figure_3.4_B15150.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.4_B15150.jpg)'
- en: Figure 3.4 – An error detailing that Angular doesn't recognize LoggerService
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 - 详细说明了Angular无法识别LoggerService的错误
- en: 'We can now use the `@Optional` decorator to mark the dependency as optional.
    Let''s import it from the `@angular/core` package and use the decorator in the
    constructor of `VcLogsComponent` in the `vc-logs.component.ts` file, as follows:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`@Optional`装饰器将依赖项标记为可选。让我们从`@angular/core`包中导入它，并在`vc-logs.component.ts`文件中的`VcLogsComponent`构造函数中使用装饰器，如下所示：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Great! Now if you refresh the app and view the console, there shouldn''t be
    any errors. However, if you change the version and hit the **Submit** button,
    you''ll see that it throws the following error because the component is unable
    to retrieve `LoggerService` as a dependency:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在，如果您刷新应用程序并查看控制台，就不应该有任何错误。但是，如果您更改版本并点击**提交**按钮，您将看到它抛出以下错误，因为组件无法检索`LoggerService`作为依赖项：
- en: '![Figure 3.5 – An error detailing that this.logger is essentially null at the
    moment'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.5 - 一个错误，详细说明此时this.logger实质上为null'
- en: '](image/Figure_3.5_B15150.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.5_B15150.jpg)'
- en: Figure 3.5 – An error detailing that this.logger is essentially null at the
    moment
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 - 一个错误，详细说明此时this.logger实质上为null
- en: 'To fix this issue, we can either decide not to log anything at all, or we can
    fall back to the `console.*` methods if `LoggerService` is not provided. The code
    to fall back to the `console.*` methods should appear as follows:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以决定根本不记录任何东西，或者如果未提供`LoggerService`，我们可以回退到`console.*`方法。回退到`console.*`方法的代码应该如下所示：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, if you update the version and hit **Submit**, you should see the logs
    on the console, as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您更新版本并点击**提交**，您应该在控制台上看到日志，如下所示：
- en: '![Figure 3.6 – The logs being printed on the console as a fallback to LoggerService
    not being provided'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.6 - 作为LoggerService未提供的回退而在控制台上打印的日志'
- en: '](image/Figure_3.6_B15150.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.6_B15150.jpg)'
- en: Figure 3.6 – The logs being printed on the console as a fallback to LoggerService
    not being provided
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 - 作为LoggerService未提供的回退而在控制台上打印的日志
- en: Great! We've finished the recipe and everything looks great. Please refer to
    the next section to understand how it works.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们已经完成了这个示例，一切看起来都很好。请参考下一节以了解它是如何工作的。
- en: How it works
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: The `@Optional` decorator is a special parameter from the `@angular/core` package,
    which allows you to mark a parameter for a dependency as optional. Behind the
    scenes, Angular will provide the value as `null` when the dependency doesn't exist
    or is not provided to the app.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Optional`装饰器是来自`@angular/core`包的特殊参数，它允许您将一个依赖项的参数标记为可选的。在幕后，当依赖项不存在或未提供给应用程序时，Angular将提供值为`null`。'
- en: See also
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Optional Dependencies in Angular ([https://angular.io/guide/dependency-injection#optional-dependencies](https://angular.io/guide/dependency-injection#optional-dependencies))
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular中的可选依赖项（[https://angular.io/guide/dependency-injection#optional-dependencies](https://angular.io/guide/dependency-injection#optional-dependencies)）
- en: Hierarchical Injectors in Angular ([https://angular.io/guide/hierarchical-dependency-injection](https://angular.io/guide/hierarchical-dependency-injection))
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular中的分层注入器（[https://angular.io/guide/hierarchical-dependency-injection](https://angular.io/guide/hierarchical-dependency-injection)）
- en: Creating a singleton service using providedIn
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用providedIn创建单例服务
- en: 'In this recipe, you''ll learn several tips on how to ensure your Angular service
    is being used as a singleton. This means that there will only be one instance
    of your service in the entire application. Here, we''ll use a couple of techniques,
    including the `providedIn: ''root''` statement and making sure we only provide
    the service once in the entire app by using the `@Optional()` and `@SkipSelf()`
    decorators.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个示例中，您将学习如何确保您的Angular服务被用作单例的几个技巧。这意味着整个应用程序中只会有一个服务实例。在这里，我们将使用一些技术，包括`providedIn:
    ''root''`语句，并确保我们只在整个应用程序中提供服务一次，使用`@Optional()`和`@SkipSelf()`装饰器。'
- en: Getting ready
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'The project for this recipe resides in the `chapter03/start_here/ng-singleton-service`
    path. Perform the following steps:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方的项目位于`chapter03/start_here/ng-singleton-service`路径中。执行以下步骤：
- en: Open the project in Visual Studio Code.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中打开项目。
- en: Open the Terminal, and run `npm install` to install the dependencies of the
    project.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，并运行`npm install`来安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。
- en: 'This should open the app in a new browser tab. You should see something similar
    to the following screenshot:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在新的浏览器选项卡中打开应用程序。您应该看到类似于以下截图的内容：
- en: '![Figure 3.7 – The ng-singleton-service app running on http://localhost:4200'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.7 - ng-singleton-service应用程序在http://localhost:4200上运行'
- en: '](image/Figure_3.7_B15150.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.7_B15150.jpg)'
- en: Figure 3.7 – The ng-singleton-service app running on http://localhost:4200
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 - ng-singleton-service应用程序在http://localhost:4200上运行
- en: Now that you have your app running, let's see move ahead and look at the steps
    of this recipe.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的应用程序正在运行，让我们继续并查看这个配方的步骤。
- en: How to do it
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到
- en: 'The problem with the app is that if you add or remove any notifications, the
    count on the bell icon in the header does not change. That''s due to us having
    multiple instances of `NotificationsService`. Please refer to the following steps
    to ensure we only have a single instance of the service in the app:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序的问题在于，如果您添加或删除任何通知，标题中的铃铛图标上的计数不会改变。这是因为我们有多个`NotificationsService`的实例。请参考以下步骤，以确保我们在应用程序中只有一个服务实例：
- en: 'Firstly, as Angular developers, we already know that we can use `providedIn:
    ''root''` for a service to tell Angular that it is only provided in the root module,
    and it should only have one instance in the entire app. So, let''s go to `notifications.service.ts`
    and pass `providedIn: ''root''` in the `@Injectable` decorator parameters, as
    follows:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '首先，作为Angular开发人员，我们已经知道我们可以使用`providedIn: ''root''`来告诉Angular一个服务只在根模块中提供，并且在整个应用程序中只应该有一个实例。因此，让我们去`notifications.service.ts`并在`@Injectable`装饰器参数中传递`providedIn:
    ''root''`，如下所示：'
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Great! Now even if you refresh and try adding or removing notifications, you'll
    still see that the count in the header doesn't change. "But why is this, Ahsan?"
    Well, I'm glad you asked. That's because we're still providing the service in
    `AppModule` as well as in `VersioningModule`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在即使您刷新并尝试添加或删除通知，您仍然会看到标题中的计数没有改变。"但是，为什么会这样，Ahsan？"好吧，我很高兴你问。那是因为我们仍然在`AppModule`以及`VersioningModule`中提供了该服务。
- en: 'First, let''s remove `NotificationsService` from the `providers` array in `app.module.ts`,
    as highlighted in the following code block:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`app.module.ts`中的`providers`数组中删除`NotificationsService`，如下面的代码块所示：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we''ll remove `NotificationsService` from `versioning.module.ts`, as highlighted
    in the following code block:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将从`versioning.module.ts`中删除`NotificationsService`，如下面的代码块所示：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Awesome! Now you should be able to see the count in the header change according
    to whether you add/remove notifications. However, what happens if someone still
    provides it in another lazily loaded module by mistake?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在您应该能够看到标题中的计数根据您添加/删除通知而改变。但是，如果有人仍然错误地在另一个懒加载的模块中提供它会发生什么呢？
- en: 'Let''s put `NotificationsService` back in the `versioning.module.ts` file:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们把`NotificationsService`放回`versioning.module.ts`文件中：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Boom! We don't have any errors on the console or during compile time. However,
    we do have the issue of the count not updating in the header. So, how do we alert
    the developers if they make such a mistake? Please refer to the next step.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 砰！控制台或编译时没有任何错误。然而，我们的问题是标题中的计数没有更新。那么，如果开发人员犯了这样的错误，我们该如何通知他们呢？请参考下一步。
- en: 'In order to alert the developer about potential duplicate providers, use the
    `@SkipSelf` decorator from the `@angular/core` package in our `NotificationsService`,
    and throw an error to notify and modify `NotificationsService`, as follows:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了提醒开发人员可能存在重复提供者，我们在`NotificationsService`中使用`@angular/core`包中的`@SkipSelf`装饰器，并抛出错误来通知和修改`NotificationsService`，如下所示：
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With the previous step now complete, you''ll notice that we have a problem.
    That is we have failed to provide `NotificationsService` to our app at all. You
    should see this in the console:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，前面的步骤已经完成，你会注意到我们有一个问题。那就是我们未能为我们的应用程序提供`NotificationsService`。你应该在控制台中看到这个：
- en: '![Figure 3.8 – An error detailing that NotificationsService can''t be injected
    into NotificationsService'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.8 - 详细说明NotificationsService无法注入到NotificationsService中的错误'
- en: '](image/Figure_3.8_B15150.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.8_B15150.jpg)'
- en: Figure 3.8 – An error detailing that NotificationsService can't be injected
    into NotificationsService
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 - 详细说明NotificationsService无法注入到NotificationsService中
- en: The reason for this is that `NotificationsService` is now a dependency of `NotificationsService`
    itself. This can't work as it has not already been resolved by Angular. To fix
    this, we'll also use the `@Optional()` decorator in the next step.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是`NotificationsService`现在是`NotificationsService`本身的一个依赖项。这是行不通的，因为它还没有被Angular解析。为了解决这个问题，我们在下一步中也将使用`@Optional()`装饰器。
- en: 'All right, now we''ll use the `@Optional()` decorator in `notifications.service.ts`,
    which is in the constructor for the dependency alongside the `@SkipSelf` decorator.
    The code should appear as follows:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好了，现在我们将在`notifications.service.ts`中的构造函数中，与`@SkipSelf`装饰器一起使用`@Optional()`装饰器。代码应该如下所示：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We have now fixed the `NotificationsService -> NotificationsService` dependency
    issue. You should see the proper error for the `NotificationsService` being provided
    multiple times in the console, as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经解决了`NotificationsService -> NotificationsService`的依赖问题。你应该在控制台中看到`NotificationsService`被多次提供的正确错误，如下所示：
- en: '![Figure 3.9 – An error detailing that NotificationsService is already provided
    in the app'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.9 - 详细说明NotificationsService已经在应用程序中提供'
- en: '](image/Figure_3.9_B15150.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.9_B15150.jpg)'
- en: Figure 3.9 – An error detailing that NotificationsService is already provided
    in the app
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 - 详细说明NotificationsService已经在应用程序中提供
- en: 'Now, we''ll safely remove the provided `NotificationsService` from the `providers`
    array in the `versioning.module.ts` file and check whether the app is working
    correctly:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将安全地从`versioning.module.ts`文件的`providers`数组中移除提供的`NotificationsService`，并检查应用程序是否正常工作：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Bam! We now have a singleton service using the `providedIn` strategy. In the
    next section, let's discuss how it works.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 砰！我们现在使用了`providedIn`策略来创建一个单例服务。在下一节中，让我们讨论它是如何工作的。
- en: How it works
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'Whenever we try to inject a service somewhere, by default, it tries to find
    a service inside the associated module of where you''re injecting the service.
    When we use `providedIn: ''root''` to declare a service, whenever the service
    is injected anywhere in the app, Angular knows that it simply has to find the
    service definition in the root module and not in the feature modules or anywhere
    else.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '每当我们尝试在某个地方注入一个服务时，默认情况下，它会尝试在注入服务的相关模块中查找服务。当我们使用`providedIn: ''root''`来声明一个服务时，无论在应用程序的任何地方注入服务，Angular都知道它只需在根模块中找到服务定义，而不是在功能模块或其他任何地方。'
- en: 'However, you have to make sure that the service is only provided once in the
    entire application. If you provide it in multiple modules, then even with `providedIn:
    ''root''`, you''ll have multiple instances of the service. To avoid providing
    a service in multiple modules or at multiple places in the app, we can use the
    `@SkipSelf()` decorator with the `@Optional()` decorator in the services'' constructor
    to check whether the service has already been provided in the app.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '但是，您必须确保该服务在整个应用程序中只提供一次。如果您在多个模块中提供它，即使使用了`providedIn: ''root''`，您也会有多个服务实例。为了避免在应用程序中的多个模块或多个位置提供服务，我们可以在服务的构造函数中使用`@SkipSelf()`装饰器和`@Optional()`装饰器来检查服务是否已经在应用程序中提供。'
- en: See also
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Hierarchical Dependency Injection in Angular ([https://angular.io/guide/hierarchical-dependency-injection](https://angular.io/guide/hierarchical-dependency-injection))
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular中的分层依赖注入([https://angular.io/guide/hierarchical-dependency-injection](https://angular.io/guide/hierarchical-dependency-injection))
- en: Creating a singleton service using forRoot()
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用forRoot()创建一个单例服务
- en: In this recipe, you'll learn how to use `ModuleWithProviders` and the `forRoot()`
    statement to ensure your Angular service is being used as a singleton in the entire
    app. We'll start with an app that has multiple instances of `NotificationsService`,
    and we'll implement the necessary code to make sure we end up with a single instance
    of the app.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，您将学习如何使用`ModuleWithProviders`和`forRoot()`语句来确保您的Angular服务在整个应用程序中作为单例使用。我们将从一个具有多个`NotificationsService`实例的应用程序开始，并实现必要的代码，以确保最终得到一个应用程序的单个实例。
- en: Getting ready
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project for this recipe resides in the `chapter03/start_here/ng-singleton-service-forroot`
    path. Perform the following steps:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱的项目位于`chapter03/start_here/ng-singleton-service-forroot`路径下。执行以下步骤：
- en: Open the project in Visual Studio Code.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中打开项目。
- en: Open the Terminal, and run `npm install` to install the dependencies of the
    project.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，运行`npm install`来安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。
- en: 'This should open the app in a new browser tab. The app should appear as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会在新的浏览器标签中打开应用程序。应用程序应该如下所示：
- en: '![Figure 3.10 – The ng-singleton-service-forroot app running on http://localhost:4200'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.10 – ng-singleton-service-forroot应用程序运行在http://localhost:4200'
- en: '](image/Figure_3.10_B15150.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.10_B15150.jpg)'
- en: Figure 3.10 – The ng-singleton-service-forroot app running on http://localhost:4200
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 – ng-singleton-service-forroot应用程序运行在http://localhost:4200
- en: Now that we have the app running, in the next section, we can move on to the
    steps for the recipe.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序正在运行，在接下来的部分，我们可以继续进行食谱的步骤。
- en: How to do it
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤
- en: 'In order to make sure we only have a singleton service in the app with the
    `forRoot()` method, you need to understand how `ModuleWithProviders` and the `static
    forRoot()` method are created and implemented. Perform the following steps:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们在应用程序中只有一个单例服务使用`forRoot()`方法，您需要了解如何创建和实现`ModuleWithProviders`和`static
    forRoot()`方法。执行以下步骤：
- en: 'First, we''ll make sure that the service has its own module. In many Angular
    applications, you''ll probably see `CoreModule` where the services are provided
    (given we''re not using the `providedIn: ''root''` syntax for some reason). To
    begin, we''ll create a module, named `ServicesModule`, using the following command:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '首先，我们要确保服务有自己的模块。在许多Angular应用程序中，您可能会看到`CoreModule`，其中提供了服务（假设我们没有出于某种原因使用`providedIn:
    ''root''`语法）。首先，我们将使用以下命令创建一个名为`ServicesModule`的模块：'
- en: '[PRE14]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now that we have created the module, let''s create a static method inside the
    `services.module.ts` file. We''ll name the method `forRoot` and return a `ModuleWithProviders`
    object that contains the `NotificationsService` provided in the `providers` array,
    as follows:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经创建了模块，让我们在`services.module.ts`文件中创建一个静态方法。我们将命名该方法为`forRoot`，并返回一个包含在`providers`数组中提供的`NotificationsService`的`ModuleWithProviders`对象，如下所示：
- en: '[PRE15]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now we'll remove the `NotificationsService` from the `app.module.ts` file's
    `imports` array and include `ServicesModule` in the `app.module.ts` file; in particular,
    we'll add in the `imports` array using the `forRoot()` method, as highlighted
    in the following code block.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将从`app.module.ts`文件的`imports`数组中删除`NotificationsService`，并在`app.module.ts`文件中包含`ServicesModule`；特别是，我们将在`imports`数组中使用`forRoot()`方法添加，如下面的代码块中所示。
- en: 'This is because it injects `ServicesModule` with the providers in `AppModule`,
    for instance, with the `NotificationsService` being provided as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为它在`AppModule`中用`ServicesModule`注入了提供者，例如，`NotificationsService`的提供方式如下：
- en: '[PRE16]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You'll notice that when adding/removing notifications, the count in the header
    still doesn't change. This is because we're still providing the `NotificationsService`
    in the `versioning.module.ts` file.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，当添加/删除通知时，标题中的计数仍然不会改变。这是因为我们仍然在`versioning.module.ts`文件中提供了`NotificationsService`。
- en: 'We''ll remove the `NotificationsService` from the `providers` array in the
    `versioning.module.ts` file, as follows:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从`versioning.module.ts`文件的`providers`数组中删除`NotificationsService`，如下所示：
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: All right, so far, you've done a great job. Now that we have finished the recipe,
    in the next section, let's discuss how it works.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，到目前为止，你做得很好。现在我们已经完成了这个教程，在下一节中，让我们讨论它是如何工作的。
- en: How it works
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: '`ModuleWithProviders` is a wrapper around `NgModule`, which is associated with
    the `providers` array that is used in `NgModule`. It allows you to declare `NgModule`
    with providers, so the module where it is being imported gets the providers as
    well. We created a `forRoot()` method in our `ServicesModule` class that returns
    `ModuleWithProviders` containing our provided `NotificationsService`. This allows
    us to provide `NotificationsService` only once in the entire app, which results
    in only one instance of the service in the app.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`ModuleWithProviders`是`NgModule`的包装器，与`NgModule`中使用的`providers`数组相关联。它允许您声明带有提供者的`NgModule`，因此导入它的模块也会得到这些提供者。我们在`ServicesModule`类中创建了一个`forRoot()`方法，它返回包含我们提供的`NotificationsService`的`ModuleWithProviders`。这使我们能够在整个应用程序中只提供一次`NotificationsService`，这导致应用程序中只有一个服务实例。'
- en: See also
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The `ModuleWithProviders` Angular documentation (h[ttps://angular.io/api/core/ModuleWithProviders](https://angular.io/api/core/ModuleWithProviders)).
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ModuleWithProviders` Angular文档（h[ttps://angular.io/api/core/ModuleWithProviders](https://angular.io/api/core/ModuleWithProviders)）。'
- en: The `ModuleWithProviders` migration documentation (h[ttps://angular.io/guide/migration-module-with-providers).](https://angular.io/guide/migration-module-with-providers)
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ModuleWithProviders`迁移文档（h[ttps://angular.io/guide/migration-module-with-providers)。](https://angular.io/guide/migration-module-with-providers)'
- en: Providing different services to the app with the same Aliased class provider
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用相同的别名类提供者为应用程序提供不同的服务
- en: In this recipe, you'll learn how to provide two different services to the app
    using `Aliased` class providers. This is extremely helpful in complex applications
    where you need to narrow down the implementation of the base class for some components/modules.
    Additionally, aliasing is used in component/service unit tests to mock the dependent
    service's actual implementation so that we don't rely on it.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，您将学习如何使用`Aliased`类提供者为应用程序提供两种不同的服务。这在复杂的应用程序中非常有帮助，其中您需要缩小一些组件/模块的基类实现。此外，别名在组件/服务单元测试中用于模拟依赖服务的实际实现，以便我们不依赖于它。
- en: Getting ready
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project that we are going to work with resides in the `chapter03/start_here/ng-aliased-class-providers`
    path, which is inside the cloned repository. Perform the following steps:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要处理的项目位于 `chapter03/start_here/ng-aliased-class-providers` 路径中，该路径位于克隆存储库内。执行以下步骤：
- en: Open the project in Visual Studio Code.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio Code 中打开项目。
- en: Open the Terminal and run `npm install` to install the dependencies of the project.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行 `npm install` 来安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行 `ng serve -o`。
- en: This should open the app in a new browser tab.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在新的浏览器选项卡中打开应用程序。
- en: 'Click on the **Login as Admin** button. You should see something similar to
    the following screenshot:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**以管理员身份登录**按钮。您应该看到类似以下截图的内容：
- en: '![Figure 3.11 – The ng-aliased-class-providers app running on http://localhost:4200'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.11 - ng-aliased-class-providers 应用程序在 http://localhost:4200 上运行'
- en: '](image/Figure_3.11_B15150.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.11_B15150.jpg)'
- en: Figure 3.11 – The ng-aliased-class-providers app running on http://localhost:4200
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 - ng-aliased-class-providers 应用程序在 http://localhost:4200 上运行
- en: Now that we have the app running, let's move to the next section to follow the
    steps for the recipe.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用程序正在运行，让我们转到下一节，按照食谱的步骤进行操作。
- en: How to do it
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点
- en: 'We have a shared component named `BucketComponent`, which is being used in
    both the admin and employee modules. `BucketComponent` uses `BucketService` behind
    the scenes to add/remove items from and to a bucket. For the employee, we''ll
    restrict the the ability to remove an item by providing an `aliased` class provider
    and a different `EmployeeBucketService`. This is so that we can override the remove
    item functionality. Perform the following steps:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为 `BucketComponent` 的共享组件，它在管理员和员工模块中都在使用。`BucketComponent` 在后台使用 `BucketService`
    来向桶中添加/删除物品。对于员工，我们将通过提供一个 `aliased` 类提供程序和一个不同的 `EmployeeBucketService` 来限制删除物品的能力。这样我们就可以覆盖删除物品的功能。执行以下步骤：
- en: 'We''ll start by creating `EmployeeBucketService` within the `employee` folder,
    as follows:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先在 `employee` 文件夹中创建 `EmployeeBucketService`，如下所示：
- en: '[PRE18]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we''ll extend `EmployeeBucketService` from `BucketService` so that we
    get all the goodness of `BucketService`. Let''s modify the code as follows:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将从 `BucketService` 扩展 `EmployeeBucketService`，以便我们获得 `BucketService` 的所有好处。让我们修改代码如下：
- en: '[PRE19]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We will now override the `removeItem()` method to simply display a simple `alert()`
    mentioning that the employees can''t remove items from the bucket. Your code should
    appear as follows:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将覆盖 `removeItem()` 方法，简单地显示一个简单的 `alert()`，说明员工无法从桶中删除物品。您的代码应如下所示：
- en: '[PRE20]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As a final step, we need to provide the `aliased` class provider to the `employee.module.ts`
    file, as follows:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步，我们需要在 `employee.module.ts` 文件中提供 `aliased` 类提供程序，如下所示：
- en: '[PRE21]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If you now log in as an employee in the app and try to remove an item, you'll
    see an alert pop up, which says **Employees cannot delete items**.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在以员工身份登录应用程序并尝试删除物品，您将看到一个警报弹出，其中写着**员工无法删除物品**。
- en: How it works
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'When we inject a service into a component, Angular tries to find that component
    from the injected place by moving up the hierarchy of components and modules.
    Our `BucketService` is provided in `''root''` using the `providedIn: ''root''`
    syntax. Therefore, it resides at the top of the hierarchy. However, since, in
    this recipe, we use an `aliased` class provider in `EmployeeModule`, when Angular
    searches for `BucketService`, it quickly finds it inside `EmployeeModule` and
    stops there before it even reaches `''root''` to get the actual `BucketService`.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '当我们将一个服务注入到一个组件中时，Angular会尝试从注入的位置向上移动组件和模块的层次结构来找到该组件。我们的`BucketService`是使用`providedIn:
    ''root''`语法在`''root''`中提供的。因此，它位于层次结构的顶部。然而，在这个示例中，我们在`EmployeeModule`中使用了一个`别名`类提供者，当Angular搜索`BucketService`时，它很快就在`EmployeeModule`中找到了它，并在甚至到达`''root''`之前停在那里获取实际的`BucketService`。'
- en: See also
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Dependency Injection in Angular ([https://angular.io/guide/dependency-injection](https://angular.io/guide/dependency-injection))
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular中的依赖注入（[https://angular.io/guide/dependency-injection](https://angular.io/guide/dependency-injection)）
- en: Hierarchical Injectors in Angular ([https://angular.io/guide/hierarchical-dependency-injection](https://angular.io/guide/hierarchical-dependency-injection))
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular中的分层注入器（[https://angular.io/guide/hierarchical-dependency-injection](https://angular.io/guide/hierarchical-dependency-injection)）
- en: Value providers in Angular
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular中的值提供者
- en: In this recipe, you'll learn how to use value providers in Angular to provide
    constants and config values to your app. We'll start with the same example from
    the previous recipe, that is, `EmployeeModule` and `AdminModule` using the shared
    component named `BucketComponent`. We will restrict the employee from deleting
    items from the bucket by using a value provider, so the employees won't even see
    the **delete** button.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将学习如何在Angular中使用值提供者为应用程序提供常量和配置值。我们将从上一个示例中的相同示例开始，即`EmployeeModule`和`AdminModule`使用名为`BucketComponent`的共享组件。我们将使用值提供者限制员工从桶中删除项目，这样员工甚至看不到**删除**按钮。
- en: Getting ready
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'The project that we are going to work with resides in the `chapter03/start_here/ng-value-providers`
    path, which is inside the cloned repository. Perform the following steps:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要处理的项目位于`chapter03/start_here/ng-value-providers`路径中，该路径位于克隆的存储库内。执行以下步骤：
- en: Open the project in Visual Studio Code.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio Code中打开项目。
- en: Open the Terminal, and run `npm install` to install the dependencies of the
    project.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，并运行`npm install`来安装项目的依赖项。
- en: Once done, run `ng serve -o` .
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。
- en: This should open the app in a new browser tab.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用程序。
- en: 'Click on the **Login as Admin** button. You should see something similar to
    the following screenshot:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**以管理员身份登录**按钮。您应该看到类似以下截图：
- en: '![Figure 3.12 – The ng-value-providers app running on http://localhost:4200'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.12 - ng-value-providers应用程序在http://localhost:4200上运行'
- en: '](image/Figure_3.12_B15150.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_3.12_B15150.jpg)'
- en: Figure 3.12 – The ng-value-providers app running on http://localhost:4200
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12 - ng-value-providers应用程序在http://localhost:4200上运行
- en: We have a shared component, named `BucketComponent`, that is being used in both
    the admin and employee modules. For the employee, we'll restrict the ability to
    remove an item by providing a value provider in `EmployeeModule`. This is so that
    we can hide the **delete** button based on its value.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为`BucketComponent`的共享组件，它在管理员和员工模块中都在使用。对于员工，我们将通过在`EmployeeModule`中提供一个值提供者来限制删除项目的能力。这样我们就可以根据其值隐藏**删除**按钮。
- en: How to do it
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做
- en: 'First, we''ll start by creating the value provider with `InjectionToken` within
    a new file, named `app-config.ts`, inside the `app/constants` folder. The code
    should appear as follows:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将通过在`app/constants`文件夹中的新文件`app-config.ts`中创建`InjectionToken`的值提供者。代码应如下所示：
- en: '[PRE22]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Before we can actually use this `AppConfig` constant in our `BucketComponent`,
    we need to register it to the `AppModule` so that when we inject this in the `BucketComponent`,
    the value of the provider is resolved.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实际在`BucketComponent`中使用这个`AppConfig`常量之前，我们需要将其注册到`AppModule`中，以便在我们在`BucketComponent`中注入它时，提供者的值得到解析。
- en: 'Let''s add the provider to the `app.module.ts` file, as follows:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`app.module.ts`文件中添加提供者，如下所示：
- en: '[PRE23]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now the app knows about the `AppConfig` constants. The next step is to use this
    constant in `BucketComponent`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用程序知道了`AppConfig`常量。下一步是在`BucketComponent`中使用这个常量。
- en: 'We''ll use the `@Inject()` decorator to inject it inside the `BucketComponent`
    class, in the `shared/components/bucket/bucket.component.ts` file, as follows:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`@Inject()`装饰器在`BucketComponent`类中注入它，在`shared/components/bucket/bucket.component.ts`文件中，如下所示：
- en: '[PRE24]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Great! The constant has been injected. Now, if you refresh the app, you shouldn't
    get any errors. The next step is to use the `canDeleteItems` property from `config`
    in `BucketComponent` to show/hide the **delete** button.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！常量已经被注入。现在，如果您刷新应用程序，就不应该出现任何错误。下一步是在`BucketComponent`中使用`config`中的`canDeleteItems`属性来显示/隐藏**删除**按钮。
- en: 'We''ll first add the property to the `shared/components/bucket/bucket.component.ts`
    file and assign it to the `ngOnInit()` method, as follows:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先将属性添加到`shared/components/bucket/bucket.component.ts`文件中，并将其分配给`ngOnInit()`方法，如下所示：
- en: '[PRE25]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, we''ll add an `*ngIf` directive in the `shared/components/bucket/ bucket.component.html`
    file to only show the **delete** button if the value of `canDeleteItems` is `true`:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将在`shared/components/bucket/bucket.component.html`文件中添加一个`*ngIf`指令，只有当`canDeleteItems`的值为`true`时才显示**删除**按钮：
- en: '[PRE26]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can test whether everything works by setting the `AppConfig` constant's
    `canDeleteItems` property to `false`. Note that the **delete** button is now hidden
    for both the admin and employee. Once tested, set the value of `canDeleteItems`
    back to `true` again.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将`AppConfig`常量的`canDeleteItems`属性设置为`false`来测试一切是否正常。请注意，**删除**按钮现在对管理员和员工都是隐藏的。测试完成后，将`canDeleteItems`的值再次设置为`true`。
- en: Now we have everything set up. Let's add a new constant so that we can hide
    the **delete** button for the employee only.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了一切。让我们添加一个新的常量，这样我们就可以只为员工隐藏**删除**按钮。
- en: 'We''ll create a folder, named `constants`, inside the `employee` folder. Then,
    we''ll create a new file underneath the `employee/constants` path, called `employee-config.ts`,
    and we will add the following code to it:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在`employee`文件夹内创建一个名为`constants`的文件夹。然后，我们将在`employee/constants`路径下创建一个名为`employee-config.ts`的新文件，并向其中添加以下代码：
- en: '[PRE27]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, we''ll provide this `EmployeeConfig` constant to the `EmployeeModule`
    for the same `APP_CONFIG` injection token. The code in the `employee.module.ts`
    file should appear as follows:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将为相同的`APP_CONFIG`注入令牌，将这个`EmployeeConfig`常量提供给`EmployeeModule`。`employee.module.ts`文件中的代码应该如下所示：
- en: '[PRE28]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: And we're done! The recipe is now complete. You can see that the **delete**
    button is visible to the admin but hidden for the employee. It's all thanks to
    the magic of value providers.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了！配方现在已经完成。您可以看到**删除**按钮对管理员可见，但对员工隐藏。这都归功于值提供者的魔力。
- en: How it works
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: When we inject a token into a component, Angular tries to find the resolved
    value of the token from the injected place by moving up the hierarchy of components
    and modules. We provided `EmployeeConfig` as `APP_CONFIG` in `EmployeeModule`.
    When Angular tries to resolve its value for `BucketComponent`, it finds it early
    at `EmployeeModule` as `EmployeeConfig`. Therefore, Angular stops right there
    and doesn't reach `AppComponent`. Notice that the value for `APP_CONFIG` in `AppComponent`
    is the `AppConfig` constant.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向组件注入一个标记时，Angular会尝试从组件和模块的层次结构中向上移动，找到标记的解析值。我们在`EmployeeModule`中将`EmployeeConfig`提供为`APP_CONFIG`。当Angular尝试解析`BucketComponent`的值时，它在`EmployeeModule`中早早地找到了`EmployeeConfig`。因此，Angular就停在那里，没有到达`AppComponent`。请注意，`AppComponent`中`APP_CONFIG`的值是`AppConfig`常量。
- en: See also
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Dependency Injection in Angular )[https://angular.io/guide/dependency-injection](https://angular.io/guide/dependency-injection))
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular中的依赖注入（[https://angular.io/guide/dependency-injection](https://angular.io/guide/dependency-injection)）
- en: Hierarchical Injectors in Angular ([https://angular.io/guide/hierarchical-dependency-injection](https://angular.io/guide/hierarchical-dependency-injection))
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular中的层次依赖注入（[https://angular.io/guide/hierarchical-dependency-injection](https://angular.io/guide/hierarchical-dependency-injection)）
