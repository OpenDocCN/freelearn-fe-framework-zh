- en: '*Chapter 6*: Building an Application Exploring TDD Using the React Testing
    Library and Cypress'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第6章*：使用React Testing Library和Cypress探索TDD构建应用'
- en: To keep your application maintainable, it is good practice to have testing set
    up for your project. Whereas some developers hate writing tests and therefore
    try to avoid writing them, other developers like to make testing the core of their
    development process by implementing a **Test-Driven Development** (**TDD**) strategy.
    There are many opinions about testing your applications and how to do this. Luckily,
    when building an application with React, many great libraries can help you with
    testing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持您的应用可维护，为项目设置测试是一个好的实践。虽然一些开发者讨厌编写测试并因此试图避免编写它们，但其他开发者喜欢将测试作为他们开发过程的核心，通过实施**测试驱动开发**（**TDD**）策略。关于测试应用和如何进行测试有许多不同的观点。幸运的是，当使用React构建应用时，许多优秀的库可以帮助您进行测试。
- en: In this chapter, you'll use the **React Testing Library** tool to unit-test
    React applications. This library is maintained by the React community itself and
    ships with Create React App. It has lots of functionalities tailored to testing
    entire life cycles within your components and other React features. Therefore,
    the React Testing Library is a great fit for testing most React applications if
    you want to test whether functions or components behave as expected when they're
    given a certain input. Also, we'll be exploring another tool called **Cypress**
    that is perfect for end-to-end testing of our React application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将使用**React Testing Library**工具对React应用进行单元测试。这个库由React社区本身维护，并随Create
    React App一起提供。它具有许多针对测试组件和其他React功能整个生命周期的功能。因此，如果您想测试函数或组件在给定特定输入时是否按预期行为，React
    Testing Library是测试大多数React应用的绝佳选择。此外，我们还将探索另一个名为**Cypress**的工具，它非常适合对我们的React应用进行端到端测试。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Unit testing components
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试组件
- en: Testing React state and Hooks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试React状态和Hooks
- en: End-to-end testing with Cypress
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Cypress进行端到端测试
- en: Project overview
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: In this chapter, we will create a hotel review application build with React
    that has state management with the Context API. The React Testing Library will
    be added to perform unit and integration testing for this application, while Cypress
    is used for end-to-end testing. The application has been prebuilt and uses the
    same patterns that we've looked at in the previous chapters.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个使用React构建的酒店评论应用，该应用使用Context API进行状态管理。我们将添加React Testing Library来对这个应用进行单元和集成测试，同时使用Cypress进行端到端测试。该应用已经预构建，并使用我们在前几章中查看过的相同模式。
- en: The build time is 2 hours.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 构建时间为2小时。
- en: Getting started
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始
- en: 'The application for this chapter builds upon an initial version, which can
    be found at [https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter06-initial](https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter06-initial).
    The complete code for this chapter can be found on GitHub: [https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter06](https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter06).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的应用基于一个初始版本，您可以在[https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter06-initial](https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter06-initial)找到。本章的完整代码可以在GitHub上找到：[https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter06](https://github.com/PacktPublishing/React-Projects-Second-Edition/tree/main/Chapter06)。
- en: 'Start by downloading the initial project from GitHub and move into the root
    directory for this project, where you must run the `npm install` command. Since
    this project builds upon Create React App, running this command will install `react`,
    `react-dom`, and `react-scripts`. Also, `styled-components` and `react-router-dom`
    will be installed so that they can handle styling and routing for the application.
    Something else that will be installed is the React Test Library, which you will
    recognize with the `@testing-library/*` prefix. After finishing the installation
    process, you can execute the `npm start` command to run the application so that
    you can visit the project in the browser at `http://localhost:3000`. The initial
    application consists of a simple header and a list of hotels. These hotels have
    a title and meta information, such as a thumbnail. This page will look as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从GitHub下载初始项目，然后进入此项目的根目录，在那里你必须运行`npm install`命令。由于此项目基于Create React App构建，运行此命令将安装`react`、`react-dom`和`react-scripts`。此外，还将安装`styled-components`和`react-router-dom`，以便它们可以处理应用程序的样式和路由。还将安装的是React
    Test Library，你可以通过`@testing-library/*`前缀来识别它。完成安装过程后，你可以执行`npm start`命令来运行应用程序，以便你可以在浏览器中访问`http://localhost:3000`上的项目。初始应用程序包括一个简单的页眉和酒店列表。这些酒店有标题和元信息，例如缩略图。此页面将如下所示：
- en: '![Figure 6.1 – The initial application](img/Figure_6.1_B17390.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 – 初始应用程序](img/Figure_6.1_B17390.jpg)'
- en: Figure 6.1 – The initial application
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 初始应用程序
- en: 'If you click on any of the hotels in the list, a new page will open with a
    list of reviews for this hotel. By clicking the button at the top left of this
    page, you can move back to the previous page, and with the button at the top right,
    a page with a form where you can add a review will open. If you add a new review,
    this data will be stored in a global context and sent to a mock API server:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击列表中的任何酒店，将打开一个新页面，显示该酒店的评论列表。通过点击页面左上角的按钮，你可以返回上一页，而通过点击右上角的按钮，将打开一个表单页面，你可以在此添加评论。如果你添加了新的评论，这些数据将被存储在全局上下文中，并发送到模拟API服务器：
- en: 'If you look at the project''s structure, you''ll see that it''s using the same
    structure as the projects we created previously:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看项目的结构，你会看到它与我们之前创建的项目使用相同的结构：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Important for this chapter is the `setupTests.js` file, which is used to configure
    the React Testing Library for this project. The entry point of this application
    is a file called `src/index.js`, which renders a component called `App`. In this
    `App` component, all the routes are declared and wrapped within a `Router` component.
    These routes are as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中非常重要的文件是`setupTests.js`，该文件用于为此项目配置React Testing Library。此应用的入口点是一个名为`src/index.js`的文件，它渲染了一个名为`App`的组件。在这个`App`组件中，所有路由都被声明并包裹在一个`Router`组件中。这些路由如下所示：
- en: '`/`: This renders `Hotels`, with an overview of all of the hotels.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/`：此页面渲染`Hotels`，显示所有酒店的概述。'
- en: '`/hotel/:hotelId`: This renders `HotelDetail`, with an overview of all reviews
    for a specific hotel.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/hotel/:hotelId`：此页面渲染`HotelDetail`，显示特定酒店的评论概述。'
- en: '`/hotel/:hotelId/new`: This renders `ReviewForm`, with a form to add new reviews
    to a specific hotel.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/hotel/:hotelId/new`：此页面渲染`ReviewForm`，包含一个表单，可以添加特定酒店的评论。'
- en: 'The data is fetched from a mock server that was created using the free `db.json`
    file in the root directory of your project in GitHub. This file consists of a
    JSON object that has two fields, `hotels` and `reviews`, which creates multiple
    endpoints on a mock server. The ones you''ll be using in this chapter are as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 数据是从使用GitHub项目根目录中的免费`db.json`文件创建的模拟服务器中获取的。此文件包含一个具有两个字段`hotels`和`reviews`的JSON对象，在模拟服务器上创建了多个端点。在本章中，你将使用以下端点：
- en: '[https://my-json-server.typicode.com/PacktPublishing/React-Projects-Second-Edition/hotels](https://my-json-server.typicode.com/PacktPublishing/React-Projects-Second-Edition/hotels)'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://my-json-server.typicode.com/PacktPublishing/React-Projects-Second-Edition/hotels](https://my-json-server.typicode.com/PacktPublishing/React-Projects-Second-Edition/hotels)'
- en: '[https://my-json-server.typicode.com/PacktPublishing/React-Projects-Second-Edition/reviews](https://my-json-server.typicode.com/PacktPublishing/React-Projects-Second-Edition/reviews)'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://my-json-server.typicode.com/PacktPublishing/React-Projects-Second-Edition/reviews](https://my-json-server.typicode.com/PacktPublishing/React-Projects-Second-Edition/reviews)'
- en: The `db.json` file must be present in the master branch (or default branch)
    of your GitHub repository for My JSON Server to work. Otherwise, you'll receive
    a **404 Not Found** message when trying to request the API endpoints.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`db.json` 文件必须存在于你的 GitHub 仓库的 master 分支（或默认分支）中，以便 My JSON Server 能够正常工作。否则，当你尝试请求
    API 端点时，你会收到一个 **404 Not Found** 的消息。'
- en: The hotel review application
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 酒店评论应用程序
- en: In this section, we will add unit and integration testing to the hotel review
    application that was created in Create React App. This application lets you add
    reviews to a list of hotels and controls this data from an application context.
    The React Testing Library will be used to render React components to test assertions
    on these components.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向在 Create React App 中创建的酒店评论应用程序添加单元测试和集成测试。这个应用程序允许你向酒店列表添加评论，并从应用程序上下文中控制这些数据。我们将使用
    React Testing Library 来渲染 React 组件，以测试这些组件的断言。
- en: Unit testing components
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件的单元测试
- en: Unit testing is an important part of your application, since you want to know
    that your functions and components behave as expected, even when you make code
    changes. For this, we're going to use the React Testing Library, an open source
    testing package for React applications that was created by the React community.
    With the React Testing Library, you can test assertions – for example, whether
    the output of a function matches the value you expected.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是应用程序的重要组成部分，因为你希望知道你的函数和组件在代码更改时仍然按预期行为。为此，我们将使用 React Testing Library，这是一个由
    React 社区创建的开源测试包，用于 React 应用程序。使用 React Testing Library，你可以测试断言——例如，函数的输出是否与预期的值匹配。
- en: 'To get started, we don''t have to install anything; it''s part of Create React
    App. If you look at the `package.json` file, you will see that a script is already
    there for running tests. Let''s see what happens if you execute the following
    command from your terminal:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们不需要安装任何东西；它是 Create React App 的一部分。如果你查看 `package.json` 文件，你会看到已经有一个用于运行测试的脚本。让我们看看如果你从终端执行以下命令会发生什么：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will return a message saying `No tests found related to files changed
    since last commit.`, which means our tests are running in watch mode and only
    running tests for files that have been changed. Under the hood, the Jest test
    runner is used to run our tests. By pressing the *A* key, you can run all the
    tests, even if you haven''t modified any files. If you press this key, the following
    message will be displayed:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一条消息，说明 `No tests found related to files changed since last commit.`，这意味着我们的测试正在监视模式下运行，并且只针对已更改的文件运行测试。在底层，我们使用
    Jest 测试运行器来运行我们的测试。按下 *A* 键，你可以运行所有测试，即使你没有修改任何文件。如果你按下这个键，将会显示以下消息：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Jest will automatically check all our files within the `src` directory and look
    for test files. In the first part of this section, we'll show how we can create
    tests that can be run with Jest using the React Test Library.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 将自动检查 `src` 目录下的所有文件，并寻找测试文件。在本节的第一部分，我们将展示如何使用 React Test Library 创建可以运行的测试。
- en: Creating a unit test
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建单元测试
- en: 'Since there are multiple ways that Jest can detect which file contains a test,
    let''s choose a structure where every component has a separate test file. This
    test file will have the same name as the file that holds the component, with the
    `.test` suffix. If we choose the `NavBar` component, we can create a new file
    called `NavBar.test.js` in the `src/components/NavBar` directory. Add the following
    code to this file:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Jest 有多种方法可以检测哪个文件包含测试，让我们选择一个结构，其中每个组件都有一个单独的测试文件。这个测试文件将与包含组件的文件具有相同的名称，并带有
    `.test` 后缀。如果我们选择 `NavBar` 组件，我们可以在 `src/components/NavBar` 目录中创建一个名为 `NavBar.test.js`
    的新文件。将以下代码添加到该文件中：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The global `test` function from Jest is used here to define a test; the test
    assertions can be placed within the curly brackets. Alternatively, you can also
    use the `describe` or `it` functions to declare a (block) of tests.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用 Jest 的全局 `test` 函数来定义一个测试；测试断言可以放置在大括号内。或者，你也可以使用 `describe` 或 `it` 函数来声明一个（块）测试。
- en: 'If we now run the `npm run test` command again, the Jest runner will find our
    first test and show the following output:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在再次运行 `npm run test` 命令，Jest 运行器将找到我们的第一个测试并显示以下输出：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Within the definition of a test, you can add assumptions such as `toEqual`
    or `toBe`, which check whether the value is exactly equal to something or whether
    the types just match respectively. The assumptions can be added within the callback
    of the `test` function:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试的定义中，你可以添加如 `toEqual` 或 `toBe` 这样的假设，这些假设检查值是否与某物完全相等，或者类型是否仅匹配。这些假设可以添加到
    `test` 函数的回调中：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you still have the test script running in your terminal, you will see that
    Jest has detected your test. The test succeeds, since `1+2` is indeed `3`. Let''s
    go ahead and change the assumption to the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还在终端中运行测试脚本，你会看到 Jest 已经检测到你的测试。测试成功，因为 `1+2` 确实等于 `3`。让我们继续将假设更改为以下内容：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, the test will fail, as the second assumption doesn't match. Although `1+2`
    still equals `3`, it's assumed that a string type with a value of `3` is returned,
    while in fact a number type is returned. If you're still running the `npm run
    test` command in the terminal, you can also see this explanation described there.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，测试将失败，因为第二个假设不匹配。尽管 `1+2` 仍然等于 `3`，但假设返回的是一个值为 `3` 的字符串类型，而实际上返回的是一个数字类型。如果你还在终端中运行
    `npm run test` 命令，你还可以在那里看到这个解释。
- en: However, this assumption has no actual usage, as it doesn't test your component.
    To test your component, you need to render it. Rendering components so that you
    can test them will be handled in the next part of this section.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个假设实际上没有使用，因为它没有测试你的组件。要测试你的组件，你需要渲染它。渲染组件以便测试它们将在本节的下一部分处理。
- en: Rendering a React component for testing
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 渲染 React 组件进行测试
- en: 'Jest is based upon Node.js, meaning that it can''t use the browser or (virtual)
    DOM to render your component and test its functionality. Therefore, we''ll be
    using the React Testing Library to help us render these components. Create React
    App comes with this library by default, and the packages it uses can be found
    in the `package.json` file:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 基于 Node.js，这意味着它不能使用浏览器或（虚拟）DOM 来渲染你的组件并测试其功能。因此，我们将使用 React 测试库来帮助我们渲染这些组件。Create
    React App 默认包含这个库，它使用的包可以在 `package.json` 文件中找到：
- en: '`@testing-library/jest-dom`: Provides custom elements to test the DOM'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@testing-library/jest-dom`：提供用于测试 DOM 的自定义元素'
- en: '`@testing-library/react`: The core package for the React Testing Library'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@testing-library/react`：React 测试库的核心包'
- en: '`@testing-library/user-events`: Provides methods to test user interactions'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@testing-library/user-events`：提供用于测试用户交互的方法'
- en: 'The React Testing Library can render React components for us so that we can
    write tests for them. The preceding packages will be used to create our tests:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: React 测试库可以为我们渲染 React 组件，这样我们就可以为它们编写测试。前面的包将用于创建我们的测试：
- en: 'In our test file for the `NavBar` component, we can render the component with
    the `render` method from `@testing-library/react` and get the output of this component.
    With the Jest `toMatchSnapshot` assumption, we can test the structure of the component
    by creating a snapshot from this render and comparing it to the actual component
    every time this test is run:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 `NavBar` 组件的测试文件中，我们可以使用 `@testing-library/react` 的 `render` 方法来渲染组件，并获取该组件的输出。通过
    Jest 的 `toMatchSnapshot` 假设，我们可以通过从这个渲染创建快照并与每次运行测试时实际组件进行比较来测试组件的结构：
- en: '[PRE7]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the `src/components/NavBar` directory, a new directory called `__snapshots__`
    has now been created by Jest. Inside this directory is a file called `NavBar.test.js.snap`,
    which includes the snapshot. If you open this file, you will see that a rendered
    version of the `NavBar` component is stored here:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/components/NavBar` 目录中，Jest 已经创建了一个名为 `__snapshots__` 的新目录。在这个目录中有一个名为
    `NavBar.test.js.snap` 的文件，其中包含快照。如果你打开这个文件，你会看到存储在这里的 `NavBar` 组件的渲染版本：
- en: '[PRE8]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The components that have been created with `styled-components` will be rendered
    as HTML elements with a class name prefixed by `sc-*`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `styled-components` 创建的组件将被渲染为带有 `sc-*` 前缀的类名的 HTML 元素。
- en: 'No actual values are being rendered by the React Testing Library since no props
    have been passed to the `NavBar` component. You can inspect how the snapshot works
    by passing, for instance, a `title` prop to the component:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于没有将属性传递给 `NavBar` 组件，React 测试库实际上没有渲染任何值。你可以通过传递，例如，一个 `title` 属性给组件来检查快照是如何工作的：
- en: '[PRE9]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The next time the tests are run, a new snapshot will be added to the `src/components/NavBar/__snapshots__/NavBar.test.js.snap`
    file. This snapshot has a value rendered for the `title` prop. If you change the
    `title` prop that is displayed by the `NavBar` component in your test file, the
    rendered component will no longer match the snapshot. You can try this by changing
    the value for the `title` prop in the test scenario:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下次运行测试时，将在 `src/components/NavBar/__snapshots__/NavBar.test.js.snap` 文件中添加一个新的快照。此快照具有
    `title` 属性的渲染值。如果您更改测试文件中 `NavBar` 组件显示的 `title` 属性，渲染的组件将不再匹配快照。您可以通过更改测试场景中的
    `title` 属性的值来尝试此操作：
- en: '[PRE10]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Jest will return the following message in the terminal, where it specifies
    which lines have changed in comparison to the snapshot. In this case, the title
    that''s being displayed is no longer `Test Application` but `Test Application
    #2`, which doesn''t match the title in the snapshot:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 'Jest 将在终端返回以下消息，其中指定了与快照相比哪些行已更改。在这种情况下，正在显示的标题不再是 `Test Application`，而是 `Test
    Application #2`，这与快照中的标题不匹配：'
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: By pressing the *U* key, you can update the snapshot to handle this new test
    scenario. This is an easy way to test the structure of your component and see
    whether the title has been rendered. With the preceding test, the initially created
    snapshot still matches the rendered component for the first test. Also, another
    snapshot was created for the second test, where a `title` prop was added to the
    `NavBar` component.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通过按 *U* 键，您可以更新快照以处理此新的测试场景。这是一种测试组件结构和查看标题是否已渲染的简单方法。在先前的测试中，最初创建的快照仍然与第一个测试的渲染组件匹配。此外，为第二个测试还创建了一个快照，其中为
    `NavBar` 组件添加了 `title` 属性。
- en: Note
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can do the same for the other props that are passed to the `NavBar` component,
    which renders differently if you do or don't pass certain props to it. Next to
    `title`, this component takes `goBack` and `openForm` as props, which can also
    be tested.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以对传递给 `NavBar` 组件的其他属性做同样的事情，如果传递或不传递某些属性，该组件的渲染方式将不同。除 `title` 外，此组件还接受 `goBack`
    和 `openForm` 作为属性，这些属性也可以进行测试。
- en: 'We''ve now created two tests for our `NavBar` component, which is a good start.
    But something else that Jest does is show you how many lines of code have been
    covered by your tests. The higher your testing coverage, the more reason to assume
    your code is stable. You can check the test coverage of your code by executing
    the `test` script command with the `--coverage` flag and an extra `--` in between,
    or use the following command in your terminal:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在为我们的 `NavBar` 组件创建了两个测试，这是一个良好的开始。但 Jest 还会向您展示您的测试覆盖了多少行代码。测试覆盖率越高，就越有理由假设您的代码是稳定的。您可以通过使用带有
    `--coverage` 标志和中间额外一个 `--` 的 `test` 脚本命令来检查代码的测试覆盖率，或者在您的终端中使用以下命令：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This command will run your tests and generate a report with all the test coverage
    information about your code per file. After adding the tests for `NavBar`, this
    report will look as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将运行您的测试并生成一个报告，其中包含有关您代码每个文件的所有测试覆盖率信息。在为 `NavBar` 添加测试之后，此报告将如下所示：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Testing coverage only tells us something about the lines and the functions of
    your code that have been tested and not their actual implementation. Having a
    test coverage of 100% doesn't mean that there aren't any bugs in your code, as
    there will always be edge cases. Also, reaching a testing coverage of 100% means
    that you may end up spending more time on writing tests than on actual code. Usually,
    a testing coverage above 80% is considered good practice.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 测试覆盖率仅告诉我们有关您代码中已测试的行和函数的信息，而不是它们的实际实现。测试覆盖率为100%并不意味着您的代码中没有错误，因为总会存在边缘情况。此外，达到100%的测试覆盖率意味着您可能花费更多的时间在编写测试上，而不是实际代码上。通常，测试覆盖率超过80%被认为是良好的实践。
- en: As you can see, the test coverage for the component is 60%, meaning that most
    of the lines are covered in your test. To go to a 100% coverage, we will also
    need to add tests for the other props that are used in the `NavBar` component
    to render the buttons to return to the previous stage or the `form` component.
    Also, the coverage for the `Button` component is 100% due to no actual elements
    being rendered there.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，组件的测试覆盖率为60%，这意味着您的测试覆盖了大多数行。要达到100%的覆盖率，我们还需要为在 `NavBar` 组件中用于渲染返回上一阶段按钮或
    `form` 组件的其他属性添加测试。此外，`Button` 组件的覆盖率为100%，因为没有实际元素在那里渲染。
- en: However, this method of testing with snapshots will create a lot of new files
    and lines of code. We'll look at other ways we can test our components in the
    next part of this section.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用快照进行测试的方法将会创建大量的新文件和代码行。我们将在本节下一部分探讨其他测试组件的方法。
- en: Testing components with assertions
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用断言测试组件
- en: In theory, snapshot testing is not necessarily a bad practice; however, your
    files can get quite big over time. Also, since you're not explicitly telling Jest
    what part of the component you want to test, you might need to update your code
    regularly.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，快照测试并不一定是不良实践；然而，随着时间的推移，你的文件可能会变得相当大。另外，由于你没有明确告诉Jest你想测试组件的哪个部分，你可能需要定期更新你的代码。
- en: Luckily, using snapshots isn't the only method we can use to test whether our
    components are rendering the correct props. Instead, we can also directly compare
    which props are being rendered by checking the value of the component and making
    assertions. The big advantage of testing with assertions is that you can test
    a lot without having to dig deeper into the logic of the component you're testing.
    For instance, you can see what the children that are being rendered look like.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，使用快照并不是测试组件是否正确渲染属性的唯一方法。相反，我们还可以直接比较渲染的属性，通过检查组件的值并做出断言。使用断言测试的优势在于，你可以在不深入测试组件逻辑的情况下测试很多内容。例如，你可以看到正在渲染的子组件的外观。
- en: 'Let''s change our second snapshot test for the `NavBar` component to compare
    the impact on the test coverage. We''ll need to import the `screen` method from
    the React Testing Library, which is used to scan the rendered components. Instead
    of making a snapshot of the whole component and finding the title in there, we
    will look for any heading components (such as `h2`) and check whether their value
    is equal to the prop that we set on `NavBar`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`NavBar`组件的第二张快照测试更改为比较对测试覆盖率的影响。我们需要从React Testing Library导入`screen`方法，该方法用于扫描渲染的组件。我们不会对整个组件创建快照并在其中找到标题，而是会寻找任何标题组件（如`h2`），并检查它们的值是否等于我们在`NavBar`上设置的属性：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We''ve used the `getByRole` React Testing Library method to find the `Title`
    component in the `NavBar` component, and the `toHaveTextContent` method to check
    whether the text inside `Title` is equal to our prop. The test still passes and
    also allows us to delete the snapshot, as we''re now using an assumption to test
    this part of the component:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用了React Testing Library的`getByRole`方法在`NavBar`组件中找到`Title`组件，并使用`toHaveTextContent`方法检查`Title`内部的文本是否与我们设置的属性相等。测试仍然通过，并且允许我们删除快照，因为我们现在正在使用假设来测试组件的这一部分：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'By pressing *U* or running `npm run test` with the `-u` flag, the snapshot
    for the `NavBar` component is removed by Jest:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通过按*U*键或使用带有`-u`标志的`npm run test`命令，Jest将移除`NavBar`组件的快照：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The test coverage of the `NavBar` component should still be 60%, as we continued
    testing whether the `title` prop was presented and rendered, which you can check
    by running again:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`NavBar`组件的测试覆盖率仍应为60%，因为我们继续测试`title`属性是否被呈现和渲染，你可以通过再次运行来检查：'
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: However, the `NavBar` component doesn't just take the `title` prop – it also
    takes the `goBack` and `openForm` functions as props. You also want to test whether
    these functions are triggered when you click on any of the buttons.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`NavBar`组件不仅接受`title`属性，还接受`goBack`和`openForm`函数作为属性。你还需要测试在点击任何按钮时这些函数是否被触发。
- en: 'To test these props, we need to create a mock function that we can pass as
    a prop to `NavBar` and mock the user click events to test whether this function
    is being called. The `fireEvent` method from the React Testing Library can be
    used to mock user events, and with Jest, we can mock a function and check whether
    that function is called:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这些属性，我们需要创建一个模拟函数，并将其作为属性传递给`NavBar`，以模拟用户点击事件来测试该函数是否被调用。React Testing
    Library中的`fireEvent`方法可以用来模拟用户事件，并且使用Jest，我们可以模拟一个函数并检查该函数是否被调用：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'By running the preceding test, a click on the *back* button in `NavBar` will
    be simulated, and Jest will check whether the mocked function is being called.
    The same can be done for the `openForm` prop:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行前面的测试，将在`NavBar`中模拟点击*后退*按钮，Jest将检查模拟函数是否被调用。同样，也可以对`openForm`属性进行操作：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The mocked function for both the `goBack` and `openForm` props are the same,
    so we need to check whether this function is called twice after clicking the open
    form button. By testing the user events on these two buttons, we''ve tested 100%
    of the `NavBar` component, as you can also see in the coverage report:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`goBack` 和 `openForm` 属性的模拟函数是相同的，因此我们需要检查在点击打开表单按钮后这个函数是否被调用两次。通过测试这两个按钮上的用户事件，我们已经测试了
    `NavBar` 组件的 100%，正如你可以在覆盖率报告中看到的那样：'
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this section, we've created unit tests that will test a specific part of
    our code. However, it can be interesting to test how different parts of our code
    work together. For this, we'll add integration tests to test our state management
    and Hooks.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们创建了单元测试来测试我们代码的特定部分。然而，测试我们代码的不同部分如何协同工作可能很有趣。为此，我们将添加集成测试来测试我们的状态管理和
    Hooks。
- en: Testing React state and Hooks
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试 React 状态和 Hooks
- en: The tests that we've created all render components without state management,
    but with the React Testing Library, we also have the option to test state and
    Hooks. In our setup, the pages that are rendered by our router are wrapped in
    an application context component. If we want to test the page components, we need
    to make sure that the data for these pages is being mocked or stubbed, so the
    integration of this component with the state can be tested.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的所有测试都渲染了没有状态管理的组件，但使用 React Testing Library，我们也有测试状态和 Hooks 的选项。在我们的设置中，由我们的路由器渲染的页面被包裹在一个应用程序上下文组件中。如果我们想要测试页面组件，我们需要确保这些页面的数据被模拟或存根，以便可以测试该组件与状态集成。
- en: 'A good example of where we can test this is the `Hotels` component, which renders
    the list of hotels that were returned by the context:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的例子是我们可以测试的 `Hotels` 组件，它渲染了上下文返回的酒店列表：
- en: 'As always, the starting point is to create a new file with the `.test` suffix
    in the same directory where the component we want to test is located. Here, we
    need to create the `Hotels.test.js` file in the `src/pages` directory. In this
    file, we need to add the following code:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 和往常一样，起点是在我们想要测试的组件所在的同一目录下创建一个以 `.test` 后缀的新文件。在这里，我们需要在 `src/pages` 目录中创建
    `Hotels.test.js` 文件。在这个文件中，我们需要添加以下代码：
- en: '[PRE21]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding test imports the context object that the `Hotels` component uses
    to render the page and creates a wrapper function that creates a provider on the
    `HotelsContext`. To this `Provider`, we've added the mock values for the context
    that is used by the `Hotels` component. Our test assertion tries to find an element
    with the `Loading…` text value and checks whether it exists. As the value for
    `loading` in our context is `true`, that element can indeed be found.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的测试导入 `Hotels` 组件用于渲染页面的上下文对象，并创建一个包装函数，该函数在 `HotelsContext` 上创建一个提供者。我们向这个
    `Provider` 添加了 `Hotels` 组件使用的上下文的模拟值。我们的测试断言尝试查找具有 `Loading…` 文本值的元素，并检查它是否存在。由于我们上下文中
    `loading` 的值为 `true`，该元素确实可以找到。
- en: Note
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To run just a selection of tests, you can press *P* after running the `npm run
    test` command; you can now type a string in the terminal that will be used to
    pattern-match the test files.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行测试的一部分，你可以在运行 `npm run test` 命令后按 *P* 键；你现在可以在终端中输入一个字符串，该字符串将用于模式匹配测试文件。
- en: 'To test whether the hotels are being rendered when data is present in the context,
    we need to mock this data in a new test in the `Hotels.test.js` file:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试当上下文中存在数据时酒店是否被渲染，我们需要在 `Hotels.test.js` 文件中创建一个新的测试来模拟这些数据：
- en: '[PRE22]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding mocked context value, the value for `loading` is set to `false`,
    and mocked hotels are also added. Note that we also wrapped the Provider with
    `BrowserRouter` from React Router, as the `Hotels` component uses a `Link` component
    to make the hotels clickable.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的模拟上下文值中，`loading` 的值被设置为 `false`，并添加了模拟的酒店。请注意，我们还用 React Router 的 `BrowserRouter`
    包装了 `Provider`，因为 `Hotels` 组件使用 `Link` 组件使酒店可点击。
- en: 'To test whether the hotels are being rendered, we need to add a test assertion
    to check whether the `loading` message is gone and whether the correct number
    of links to hotels are rendered:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试酒店是否被渲染，我们需要添加一个测试断言来检查 `loading` 消息是否消失以及渲染了正确数量的酒店链接：
- en: '[PRE23]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `getBy` methods we used before will throw an error when an element cannot
    be found; to test whether something is not rendered, we need to use the `queryBy`
    methods instead. Also, we need to check whether two `Link` components are present
    by looking for the `link` role and counting them.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前使用的 `getBy` 方法在找不到元素时会抛出错误；为了测试某些内容没有被渲染，我们需要使用 `queryBy` 方法。此外，我们需要通过查找
    `link` 角色并计数来检查是否存在两个 `Link` 组件。
- en: 'The `useEffect` Hook in the `Hotels` component can also be tested to check
    whether the `fetchHotels` function is being called if there are no hotels in the
    context. Therefore, we can edit the first test by importing the `waitFor` method
    from the React Testing Library and altering the context value slightly:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Hotels` 组件中的 `useEffect` 钩子也可以被测试，以检查在上下文中没有酒店时是否调用了 `fetchHotels` 函数。因此，我们可以通过从
    React Testing Library 导入 `waitFor` 方法并稍微调整上下文值来编辑第一个测试：'
- en: '[PRE24]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We also add the test assertion to wait for the mock function to be called.
    Here, we specifically state that the mocked function, which is `fetchHotels` from
    `HotelsContext`, is called only once. In our `Hotels` component, `useEffect` has
    a check to only fetch the hotels if there is no data:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还添加了测试断言以等待模拟函数被调用。在这里，我们特别声明模拟的函数，即来自 `HotelsContext` 的 `fetchHotels`，只被调用一次。在我们的
    `Hotels` 组件中，`useEffect` 有一个检查，只有在没有数据时才会获取酒店：
- en: '[PRE25]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: With this test, we've tested both the context in the `Hotels` component and
    the `useEffect` Hook to fetch hotel data in that function.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个测试，我们已经测试了 `Hotels` 组件中的上下文以及在该函数中获取酒店数据的 `useEffect` 钩子。
- en: 'After running the tests again with the `--coverage` flag, we will be able to
    see what impact writing this integration test has on our coverage. Since an integration
    test not only tests one specific component but multiple components at once, the
    testing coverage for `Hotels` will be updated. This test also covers the `HotelItem`
    component, which we will be able to see in the coverage report after running `npm
    run test --coverage`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行带有 `--coverage` 标志的测试后，我们将能够看到编写这个集成测试对我们覆盖率的影响。由于集成测试不仅测试一个特定的组件，而是同时测试多个组件，因此
    `Hotels` 的测试覆盖率将得到更新。这个测试还覆盖了 `HotelItem` 组件，我们将在运行 `npm run test --coverage`
    后在覆盖率报告中看到这一点：
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: According to Jest, the coverage for `Hotels` is 100%. The test coverage for
    `HotelItems` has also reached 100%. This means that we can skip writing unit tests
    for `HotelItem`, assuming that we only use this component within the `Hotels`
    component. The `HotelsContext` component with our context already has a small
    amount of coverage through testing it from the `Hotels` component. To get a higher
    coverage, we can test even more, such as testing how the context itself or the
    `useReducer` Hook in the context is behaving.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 Jest，`Hotels` 的覆盖率达到了 100%。`HotelItems` 的测试覆盖率也达到了 100%。这意味着如果我们只在这个 `Hotels`
    组件中使用这个组件，我们可以跳过为 `HotelItem` 编写单元测试。我们的 `HotelsContext` 组件已经通过从 `Hotels` 组件测试它而获得了一小部分覆盖率。为了获得更高的覆盖率，我们可以测试更多，例如测试上下文本身或上下文中的
    `useReducer` 钩子的行为。
- en: The only downside of having integration tests over unit tests is that they're
    harder to write, as they usually contain more complex logic. Also, these integration
    tests will run slower than unit tests because of them having more logic and bringing
    together multiple components. In the final section of this chapter, we'll be adding
    an end-to-end test that will test the entire application from a user perspective
    using Cypress.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在集成测试相对于单元测试的唯一缺点是，它们更难编写，因为它们通常包含更复杂的逻辑。此外，由于它们包含更多的逻辑并集成了多个组件，这些集成测试的运行速度会比单元测试慢。在本章的最后部分，我们将添加一个端到端测试，该测试将从用户的角度使用
    Cypress 测试整个应用程序。
- en: End-to-end testing with Cypress
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Cypress 进行端到端测试
- en: So far, we've covered both unit and integration testing with the React Testing
    Library that tests our code in an isolated setting. But in order to make sure
    that our application is tested as a whole, we can also write an end-to-end test
    to cover certain aspects of our application from start to finish. End-to-end tests
    are considered more time-consuming to write and run than unit or integration tests.
    It's recommended to have more unit and integrations tests for your project than
    end-to-end tests, and think about what aspects of your application you really
    want to have tested.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用 React Testing Library 覆盖了单元测试和集成测试，该库在隔离环境中测试我们的代码。但为了确保我们的应用程序作为一个整体被测试，我们还可以编写端到端测试来覆盖应用程序的某些方面从开始到结束。端到端测试被认为比单元测试或集成测试编写和运行更耗时。建议您的项目中单元测试和集成测试的数量要多于端到端测试，并考虑您真正希望测试应用程序的哪些方面。
- en: 'To add end-to-end tests, we''ll install the open source test tool Cypress,
    which can be used to write and run such tests. Adding Cypress to the project requires
    several steps:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加端到端测试，我们将安装开源测试工具 Cypress，它可以用来编写和运行此类测试。将 Cypress 添加到项目需要几个步骤：
- en: 'Install the library from npm in our project by running the following command
    from the terminal:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在终端中运行以下命令，在我们的项目中从 npm 安装库：
- en: '[PRE27]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'After completing the installation, the script to run Cypress needs to be added
    to the `package.json` file so that it can be started with a single command:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成安装后，需要将运行 Cypress 的脚本添加到 `package.json` 文件中，以便可以通过单个命令启动：
- en: '[PRE28]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can now run the `npm run cypress` command to start Cypress. Make sure to
    do this in a new tab in the terminal, as you need to have both the application
    and Cypress running simultaneously. If this is the first time that you''re running
    Cypress, it will validate whether it''s able to run on your system. When all goes
    well, Cypress will open and create a new directory called `cypress` in our project,
    as shown in the following screenshot:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在可以运行 `npm run cypress` 命令来启动 Cypress。请确保在终端的新标签页中这样做，因为您需要同时运行应用程序和 Cypress。如果您这是第一次运行
    Cypress，它将验证是否能在您的系统上运行。一切顺利的话，Cypress 将打开并在我们的项目中创建一个名为 `cypress` 的新目录，如下面的截图所示：
- en: '![Figure 6.2 – Cypress running for the first time](img/Figure_6.2_B17390.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2 – Cypress 首次运行](img/Figure_6.2_B17390.jpg)'
- en: Figure 6.2 – Cypress running for the first time
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – Cypress 首次运行
- en: 'Cypress has created example tests in the `cypress/integration/examples` directory,
    which you can use to learn more about how the library is working. Otherwise, you
    can delete these, as they will clutter the Cypress runner when we add new tests.
    In the `cypress/integration` directory ,we can add a new end-to-end test for our
    project called `hotels.spec.js` with the following contents:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Cypress 在 `cypress/integration/examples` 目录中创建了示例测试，您可以使用这些测试来了解库的工作方式。否则，您可以删除这些测试，因为当我们添加新测试时，它们会
    clutter Cypress 运行器。在 `cypress/integration` 目录中，我们可以为我们的项目添加一个名为 `hotels.spec.js`
    的新端到端测试，其内容如下：
- en: '[PRE29]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can run this test by pressing on it in the Cypress runner, after which
    the test will run in a browser. Which browser it uses depends on what you''ve
    selected at the top right in Cypress. This test will open the application within
    a browser and test it with Cypress, giving the following output:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过在 Cypress 运行器中点击它来运行此测试，之后测试将在浏览器中运行。它使用的浏览器取决于您在 Cypress 右上角选择的选项。此测试将在浏览器中打开应用程序并使用
    Cypress 进行测试，输出如下：
- en: '![Figure 6.3 – Cypress rendering our application in a test'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.3 – Cypress 在测试中渲染我们的应用程序](img/Figure_6.3_B17390.jpg)'
- en: '](img/Figure_6.3_B17390.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.3 – Cypress 在测试中渲染我们的应用程序](img/Figure_6.3_B17390.jpg)'
- en: Figure 6.3 – Cypress rendering our application in a test
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – Cypress 在测试中渲染我们的应用程序
- en: Note
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You need to make sure that you have both Cypress and the application running
    in your terminal. This means that one terminal tab must have `npm run cypress`
    running and the other `npm start`. If you don't have the application running,
    you'll get an error that the web page is not available.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要确保在您的终端中同时运行 Cypress 和应用程序。这意味着一个终端标签必须运行 `npm run cypress`，另一个运行 `npm start`。如果您没有运行应用程序，您将收到一个错误，表明网页不可用。
- en: The preceding test will just render our application, without making any assertions.
    To test the application using Cypress, we need to use any of the assertions that
    are provided by the library. Using these assertions, we'll write an end-to-end
    test that checks the entire flow, from visiting the application to adding a review
    for a hotel. This way, we have tested the most critical process of our application,
    namely reviewing hotels.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的测试将仅渲染我们的应用程序，而不进行任何断言。为了使用Cypress测试应用程序，我们需要使用库提供的任何断言。使用这些断言，我们将编写一个端到端测试，检查从访问应用程序到为酒店添加评论的整个流程。这样，我们就测试了应用程序中最关键的过程，即酒店评论。
- en: 'To start, we need to change the `hotels.spec.js` file so that it will open
    the application and navigate to a hotel page, and on that page, click on the button
    to open the form. After filling in this form, we want our test to submit the form
    and check whether our review has been added. Follow these steps to make these
    changes:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要更改`hotels.spec.js`文件，使其打开应用程序并导航到酒店页面，然后在那个页面上点击按钮以打开表单。填写此表单后，我们希望测试提交表单并检查我们的评论是否已添加。按照以下步骤进行这些更改：
- en: 'All the tests in the `hotels.spec.js` file will start by visiting the application
    in the browser, so it can click on any of the hotels listed on this page. After
    clicking on a hotel, we need to verify whether the location in the browser has
    changed by using the `cy.location` method:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有在`hotels.spec.js`文件中的测试都将从在浏览器中访问应用程序开始，以便它可以点击此页面上列出的任何酒店。点击酒店后，我们需要使用`cy.location`方法验证浏览器中的位置是否已更改：
- en: '[PRE30]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Running this test will validate that you can click on a hotel and navigate to
    the correct page, which you can check in the Cypress runner.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此测试将验证您是否可以点击酒店并导航到正确的页面，您可以在Cypress运行器中检查。
- en: Note
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'When you need to visit many URLs over different development environments, you
    can also define `baseUrl` in a `cypress.json` file:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要在不同的开发环境中访问多个URL时，您还可以在`cypress.json`文件中定义`baseUrl`：
- en: '`{`'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`{`'
- en: '`"id": "http://localhost:3000",`'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`"id": "http://localhost:3000",`'
- en: '`}`'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: 'In the second test, we tell Cypress to find the button with the `+ Add Review`
    text and click on it, which should change the browser''s location to the page
    to add the review. This page is located at the `/hotel/:hotelId/new` route and
    includes the `new` string. Note that we don''t have to navigate to the application
    anymore, as this test builds upon the previous test and is therefore already at
    the correct page:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二个测试中，我们告诉Cypress找到带有`+ Add Review`文本的按钮并点击它，这将改变浏览器的位置到添加评论的页面。此页面位于`/hotel/:hotelId/new`路由，并包含`new`字符串。请注意，我们不再需要导航到应用程序，因为这个测试基于前面的测试，因此已经位于正确的页面：
- en: '[PRE31]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the preceding test, Cypress will look for a button that contains a specific
    word, something that is not future-proof if someone changes the content of the
    button. Deciding which selector to use (`id`, `class`, or content) is important
    when writing tests. To prevent failing tests, you can also add the `data-cy`,
    `data-test`, or `data-testid` attributes to your elements. Therefore, we need
    to change how the `Button` component is rendered in `src/components/NavBar`:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的测试中，Cypress将寻找包含特定单词的按钮，如果有人更改了按钮的内容，这并不是一个未来兼容的解决方案。在编写测试时决定使用哪个选择器（`id`、`class`或内容）非常重要。为了防止测试失败，您还可以向您的元素添加`data-cy`、`data-test`或`data-testid`属性。因此，我们需要更改`src/components/NavBar`中`Button`组件的渲染方式：
- en: '[PRE32]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the `cypress/integrations/hotels.spec.js` Cypress test file, we can look
    for the `data-cy` attribute instead of using the content of the button as a selector:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`cypress/integrations/hotels.spec.js` Cypress测试文件中，我们可以寻找`data-cy`属性而不是使用按钮的内容作为选择器：
- en: '[PRE33]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'A third test to fill in the form to add the review and submit it can also be
    added to this file. Using the `cy.get` command, Cypress can find the `form` element
    on this page, and the `within` method is used to find the `input` elements inside
    the form. It will search for the name of the `input` field, add a value to it,
    and finally submit `button` inside the form:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以将一个用于填写表单以添加评论并提交的第三个测试也添加到该文件中。使用`cy.get`命令，Cypress可以找到此页面上的`form`元素，并使用`within`方法在表单内查找`input`元素。它将搜索`input`字段的名称，向其中添加一个值，并最终提交表单内的`button`：
- en: '[PRE34]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, we need to write a test that checks the hotel details page again and
    tries to find the new review that we''ve added. To find this review, we need to
    search the page for the contents of the review that was just added by Cypress;
    also, we need to add a `wait` command to make sure that the review has been processed
    and displayed on the screen:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要编写一个测试，再次检查酒店详情页面，并尝试找到我们添加的新评论。为了找到这个评论，我们需要在页面上搜索Cypress刚刚添加的评论内容；同时，我们还需要添加一个`wait`命令以确保评论已经被处理并显示在屏幕上：
- en: '[PRE35]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: By adding this final test to Cypress, we've tested the most important scenario
    of our application, which you can expand even more by adding tests for edge cases
    such as error messages.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向Cypress添加这个最后的测试，我们已经测试了我们应用程序最重要的场景，您可以通过添加测试边缘情况（如错误消息）来进一步扩展。
- en: Tip
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: We didn't add a `data-cy` attribute to the elements that display the review,
    which is something that you could add yourself. As we're aware of the content
    that we just added, it's safe to assume that we don't need a complicated selector
    for this.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有为显示评论的元素添加`data-cy`属性，这是您可以自己添加的。由于我们了解我们刚刚添加的内容，因此可以安全地假设我们不需要一个复杂的选择器。
- en: You can add more functionalities, such as mocking the API requests and responses,
    as the preceding test is using the same API as the application itself. In this
    scenario, there's nothing wrong with that, as the API we're using is already a
    mock API. If you're working in a production environment, you will want to replace
    that with a mocked response that can be generated by Cypress.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以添加更多功能，例如模拟API请求和响应，因为前面的测试正在使用与应用程序本身相同的API。在这种情况下，这并没有什么问题，因为我们使用的API已经是一个模拟API。如果您在生产环境中工作，您将希望用Cypress可以生成的模拟响应来替换它。
- en: 'For this, we need to add a `beforeEach` Hook to our test file that intercepts
    the API calls and replaces the response with a mocked value. The format of that
    mocked value should be equal to the format of the actual API. Luckily, our API
    is being populated from the `db.json` file that you can find in the repository
    for this book. From the contents of that file, you can take the data for the hotels
    field and paste it into two separate files inside the `cypress/fixtures` directory.
    Let''s look at the steps:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这一点，我们需要在我们的测试文件中添加一个`beforeEach`钩子，以拦截API调用并将响应替换为模拟值。这个模拟值的格式应该与实际API的格式相同。幸运的是，我们的API正在从您可以在本书仓库中找到的`db.json`文件中填充。从该文件的内容中，您可以提取酒店字段的数据，并将其粘贴到`cypress/fixtures`目录内的两个单独的文件中。让我们看看步骤：
- en: 'The first one can be called `hotels.json` and needs to have an array of objects
    with hotel details:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个可以命名为`hotels.json`，需要有一个包含酒店详细信息的对象数组：
- en: '[PRE36]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The second fixture needs to have a single object that replaces the API request
    for a single hotel, in a file called `hotel.json`:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个固定值需要有一个单独的对象，用于替换单个酒店的API请求，文件名为`hotel.json`：
- en: '[PRE37]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Intercepting the calls to the actual API can be done from the test file in
    `cypress/integrations/hotels.spec.js` by adding a `beforeEach` Hook and the `cy.intercept`
    method. For the `hotels` and `hotels/*` endpoints, it can return the fixture,
    and the `reviews` endpoint can return an empty array, as Cypress will add a review
    itself:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`cypress/integrations/hotels.spec.js`测试文件中添加一个`beforeEach`钩子和`cy.intercept`方法，可以拦截对实际API的调用。对于`hotels`和`hotels/*`端点，它可以返回固定值，而对于`reviews`端点，可以返回一个空数组，因为Cypress将自行添加评论：
- en: '[PRE38]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: By opening the Cypress runner, you can see that our tests are now being executed
    with the data from the fixtures, as the API calls are being intercepted.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 通过打开Cypress运行器，您可以看到我们的测试现在正在使用固定值中的数据执行，因为API调用正在被拦截。
- en: The tests we've created in this section gave you a good start on writing end-to-end
    tests for React applications with Cypress. Also, Cypress can be used to do visual
    regression testing for your application or to test API responses.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节中创建的测试为您编写React应用程序的端到端测试提供了一个良好的起点。此外，Cypress还可以用于对您的应用程序进行视觉回归测试或测试API响应。
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered testing for React applications using the React Testing
    Library in combination with Jest. Both packages are a great resource for any developer
    that wants to add test scripts to their application, and they work very well with
    React. The advantages of having tests for your application were discussed in this
    chapter, and hopefully, you now know how to add test scripts to any project. The
    differences between unit tests and integration tests were shown, and you've also
    learned how to write end-to-end tests with Cypress.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了使用 React Testing Library 和 Jest 对 React 应用程序进行测试。这两个包都是任何希望向其应用程序添加测试脚本的开发人员的绝佳资源，并且它们与
    React 的工作非常出色。本章讨论了为您的应用程序编写测试的优势，并希望您现在知道如何向任何项目添加测试脚本。本章展示了单元测试和集成测试之间的区别，并且您还学习了如何使用
    Cypress 编写端到端测试。
- en: Since the application that was tested in this chapter has the same structure
    as the applications from previous chapters, the same testing principles can be
    applied to any of the applications we've built in this book.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章测试的应用程序结构与之前章节中的应用程序相同，因此相同的测试原则可以应用于本书中我们构建的任何应用程序。
- en: The next chapter will combine a lot of the patterns and libraries we've already
    used in this book, as we'll be creating a full-stack e-commerce store with React,
    GraphQL, and Apollo.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将结合本书中我们已经使用过的许多模式和库，因为我们将会使用 React、GraphQL 和 Apollo 创建一个全栈电子商务商店。
- en: Further reading
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information, refer to the following links:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请参考以下链接：
- en: 'The React Testing Library: [https://testing-library.com/docs/react-testing-library/intro/](https://testing-library.com/docs/react-testing-library/intro/)'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 测试库：[https://testing-library.com/docs/react-testing-library/intro/](https://testing-library.com/docs/react-testing-library/intro/)
- en: 'Cypress: [https://docs.cypress.io/](https://docs.cypress.io/)'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cypress：[https://docs.cypress.io/](https://docs.cypress.io/)
