<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Exercising MERN Skills with an Online Marketplace</h1>
                </header>
            
            <article>
                
<p>With more business being conducted over the internet than ever before, the ability to buy and sell in an online marketplace setting has become a core requirement for many web platforms. In this and the next two chapters, we will utilize the MERN stack technologies to develop an online marketplace application complete with features that enable users to buy and sell.</p>
<p>We will build out everything from simple to advanced features for this application, starting in this chapter with a reiteration of the full-stack development lessons learned in previous chapters to set up a base for the marketplace platform. We will be extending the MERN skeleton application with support for seller accounts and shops with products, to incrementally integrate marketplace functionalities <span>such as product search and suggestions</span>. By the end of this chapter, you will have a better grasp of how to extend, integrate, and combine the different aspects of full-stack implementations to add complex features to your applications.  </p>
<p>In this chapter, we will start building the online marketplace by covering the following topics:</p>
<ul>
<li>Introducing the MERN Marketplace app</li>
<li style="font-weight: 400">Users with seller accounts</li>
<li style="font-weight: 400">Adding shops to the marketplace</li>
<li style="font-weight: 400">Adding products to shops</li>
<li style="font-weight: 400">Searching for products by name and category</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing the MERN Marketplace app</h1>
                </header>
            
            <article>
                
<p>The MERN Marketplace application will allow users to become sellers, who can manage multiple shops and add the products they want to sell in each shop. Users who visit MERN Marketplace will be able to search for and browse products they want to buy and add products to their shopping cart to place an order. The resulting marketplace application will look as pictured in the following screenshot:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-814 image-border" src="assets/5b37e049-33ed-46e7-818c-dffdde8444de.png" style="width:62.58em;height:37.17em;"/></div>
<div class="packt_tip"><span>The code for the complete MERN Marketplace application is available on GitHub at</span> <a href="https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter07%20and%2008/mern-marketplace" target="_blank">https://github.com/PacktPublishing/Full-Stack-React-Projects-Second-Edition/tree/master/Chapter07%20and%2008/mern-marketplace</a><span>.</span> <span>The implementations discussed in this and the next chapter can be accessed in the shop-cart-order-pay branch of the repository. You can</span><span> clone this code and run the application as you go through the code explanations for the rest of this chapter. </span></div>
<p>In this chapter, we will extend the MERN skeleton to build a simple version of the online marketplace, starting with the following features:</p>
<ul>
<li style="font-weight: 400">Users with seller accounts</li>
<li style="font-weight: 400">Shop management</li>
<li style="font-weight: 400">Product management</li>
<li style="font-weight: 400">Product search by name and category</li>
</ul>
<p>The views needed for these <span>features related to </span>seller accounts, shops, and products will be developed by extending and modifying the existing <span>React components</span> in the MERN skeleton application.<span> The component tree pictured next shows all the custom</span> React components that make up the MERN Marketplace frontend developed in this chapter:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-815 image-border" src="assets/77ecbd46-3384-4646-b9c4-091c10d0de6c.png" style="width:42.83em;height:20.50em;"/></div>
<p>We will add new React components to implement views for managing <span>shops and products </span>as well as browsing and <span>searching for products. We will</span> also modify existing components such as the EditProfile, Menu, and Home components to develop the skeleton code into a marketplace application as we build out the different features in the rest of the chapter. These marketplace features will depend on the user's ability to update their accounts into seller accounts. In the next section, we will begin building the MERN Marketplace application by updating the existing user implementation to enable seller account features.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Allowing users to be sellers</h1>
                </header>
            
            <article>
                
<p>Any user with an account on the MERN Marketplace application will have the option to update their accounts to seller accounts by making changes to their profiles. We will add this option to convert to a seller account in the <q>Edit Profile</q> page, as shown in the following screenshot:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-816 image-border" src="assets/de5922cb-2463-4326-8285-5896ae0dedc8.png" style="width:31.42em;height:10.42em;"/></div>
<p>A user with an active seller account will be allowed to create and manage their own shops, where they can manage products. Regular users will not have access to a seller dashboard, whereas users with active seller accounts will see a link to their dashboard on the menu as <span class="packt_screen">MY SHOPS</span>. The following screenshot shows how the menu looks to a regular user in contrast to a user with an active seller account: </p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-817 image-border" src="assets/a4970b51-3707-4888-ab58-45b8c68f8d8b.png" style="width:31.42em;height:2.83em;"/></div>
<p>To add this seller account feature, we need to update the user model, the Edit Profile view and add a <span class="packt_screen">MY SHOPS</span> link to the menu that will only be visible to sellers, as discussed in the following sections. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating the user model</h1>
                </header>
            
            <article>
                
<p>We need to store additional detail about each user to determine whether a user is an active seller or not. We will update the user model that we developed in <a href="a9dedbd8-baf6-4ec8-b766-0b370227fbe4.xhtml">Chapter 3</a>, <em>Building a Backend with MongoDB, Express, and Node</em>, to add a <kbd>seller</kbd> value that will be set to <kbd>false</kbd> by default to represent regular users and can additionally be set to <kbd>true</kbd> to represent users who are also sellers. We will update the existing user schema to add this <kbd>seller</kbd> field with the following code:</p>
<p><kbd>mern-marketplace/server/models/user.model.js</kbd>:</p>
<pre>seller: {<br/>    type: Boolean,<br/>    default: false<br/>}</pre>
<p class="mce-root">This <kbd>seller</kbd> value for each user must be sent to the client with the user details received on successful sign-in, so the view can be rendered accordingly to show information relevant to the seller. <span>We will update the response sent back in the <kbd>signin</kbd> controller method to add this detail, as highlighted in the following code:</span></p>
<p><kbd>mern-marketplace/server/controllers/auth.controller.js</kbd>:</p>
<pre><span>...<br/>return res.json({<br/>      token,<br/>      user: {<br/>        _id: user._id,<br/>        name: user.name,<br/>        email: user.email,<br/>        <strong>seller: user.seller</strong><br/>      }<br/>    })<br/>...<br/>} </span></pre>
<p>Using this<span> </span><kbd>seller</kbd><span> </span>field value, we can render the frontend based on authorizations permitted only to seller accounts. Before rendering views based on seller authorizations, we first need to implement the option to activate seller account features in the<span> </span><kbd>EditProfile</kbd><span> </span>view, as discussed in the next section. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating the Edit Profile view</h1>
                </header>
            
            <article>
                
<p>A signed-in user will see a toggle in the Edit Profile view, allowing them to either activate or deactivate the seller feature. We will update the <kbd>EditProfile</kbd> component to add a <kbd>Material-UI</kbd> <kbd>Switch</kbd> component in <kbd>FormControlLabel</kbd>, as shown in the following code:</p>
<p><kbd>mern-marketplace/client/user/EditProfile.js</kbd>:</p>
<pre>&lt;Typography variant="subtitle1" className={classes.subheading}&gt;<br/>   Seller Account<br/>&lt;/Typography&gt;<br/>&lt;FormControlLabel<br/>     control={&lt;Switch<br/>                checked={values.seller}<br/>                onChange={handleCheck}<br/>             /&gt;}<br/>     label={values.seller? 'Active' : 'Inactive'}<br/>/&gt;</pre>
<p>Any changes to the switch will be set to the value of the <kbd>seller</kbd> in state by calling the <kbd>handleCheck</kbd> method. The <kbd>handleCheck</kbd> method is implemented as shown here:</p>
<p><kbd><span>mern-marketplace/client/user/EditProfile.js</span></kbd>:</p>
<pre>const handleCheck = (event, checked) =&gt; {<br/>    setValues({...values, 'seller': checked})<br/>} </pre>
<p>When the form to edit profile details is submitted, the <kbd>seller</kbd> value is also added to details sent in the update to the server, as highlighted in the following code:</p>
<p><kbd><span>mern-marketplace/client/user/EditProfile.js</span></kbd>:</p>
<pre>const clickSubmit = () =&gt; {<br/>    const jwt = auth.isAuthenticated() <br/>    const <strong>user</strong> = {<br/>      name: values.name || undefined,<br/>      email: values.email || undefined,<br/>      password: values.password || undefined,<br/>      <strong>seller: values.seller || undefined</strong><br/>    }<br/>    update({<br/>      userId: match.params.userId<br/>    }, {<br/>      t: jwt.token<br/>    }, <strong>user</strong>).then((data) =&gt; {<br/>      if (data &amp;&amp; data.error) {<br/>        setValues({...values, error: data.error})<br/>      } else {<br/>        <strong>auth.updateUser(data, ()=&gt;{</strong><br/><strong>          setValues({...values, userId: data._id, redirectToProfile: true})</strong><br/><strong>        })</strong><br/>      }<br/>    })<br/>  }</pre>
<p>On successful update, the user details stored in <kbd>sessionStorage</kbd> for auth purposes should also be updated. The <kbd>auth.updateUser</kbd> method is called to do this <kbd>sessionStorage</kbd> update. The implementation for the <kbd>auth.updateUser</kbd> method was discussed in <em>Updating the Edit Profile view</em> section of <a href="c58ac055-5a1e-4bf4-b8a6-c9b311cf267a.xhtml" target="_blank">Chapter 6</a>, <em>Building a Web-Based Classroom Application</em>.</p>
<p><span>Once the updated <kbd>seller</kbd> value is available in the frontend, we can use it to render the interface accordingly. In the next section, we will see how to render the menu differently based on whether the user viewing the application has an active seller account. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating the menu</h1>
                </header>
            
            <article>
                
<p>In the frontend of the marketplace application, we can render different options based on whether the user currently browsing the application has an active seller account. In this section, we will add the code to conditionally display a link to<span> </span><em><span class="packt_screen">MY SHOPS</span></em> on the <span>navigation bar,</span><span> </span>which will only be visible to the signed-in users who have active seller accounts.</p>
<p>We will update the<span> </span><kbd>Menu</kbd><span> </span>component <span>within the previous code so </span>that it only renders when a user is signed in, <span>as follows:</span></p>
<p><kbd>mern-marketplace/client/core/Menu.js</kbd>:</p>
<pre>{auth.isAuthenticated().user.seller &amp;&amp; <br/>  (&lt;Link to="/seller/shops"&gt;<br/>  &lt;Button color = {isPartActive(history, "/seller/")}&gt; My Shops &lt;/Button&gt;<br/>   &lt;/Link&gt;)<br/>}</pre>
<p>This <em><span class="packt_screen">MY SHOPS </span></em>link on the navigation bar will take users with active seller accounts to the seller dashboard view where they can manage the shops they own on the marketplace.</p>
<p>With these updates to the user implementation, it is now possible for users on the marketplace to update their regular accounts to seller accounts, and we can begin incorporating features that will allow these sellers to add shops to the marketplace. We will see how to do this in the following section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding shops to the marketplace</h1>
                </header>
            
            <article>
                
<p>Sellers on MERN Marketplace can create shops and add products to each shop. To store the shop data and enable shop management, we will implement a Mongoose Schema for shops, backend APIs to access and modify the shop data, and frontend views for both the shop owner and buyers browsing through the marketplace.</p>
<p>In the following sections, we will build out the shop module in the application by first defining the shop model fo<span>r storing</span> shop data in the datab<span>ase, then implementing the backend APIs and frontend views for the shop-related features including creating new shops, listing all shops, listing shops by owner, displaying a single shop, editing shops, and deleting shops from the application. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining a Shop model</h1>
                </header>
            
            <article>
                
<p>We will implement a Mongoose model to define a Shop model for storing the details of each shop. This model will be defined in <kbd>server/models/shop.model.js</kbd>, and the implementation will be similar to<span> other Mongoose model implementations covered in previous chapters, like the Course model defined in <a href="c58ac055-5a1e-4bf4-b8a6-c9b311cf267a.xhtml" target="_blank">Chapter 6</a></span><span>, <em>Building a Web-Based Classroom Application</em></span><span>. The Shop schema in this model </span>will have simple fields to store shop details, along with a logo image, and a reference to the user who owns the shop. <span>The code blocks defining the shop fields are given in the following list with explanations:</span></p>
<ul>
<li><strong>Shop name and description</strong>: The <span><kbd>name</kbd> and <kbd>description</kbd> fields will be string types, with <kbd>name</kbd> as a required field:</span></li>
</ul>
<pre style="padding-left: 60px">name: { <br/>    type: String, <br/>    trim: true, <br/>    required: 'Name is required' <br/>},<br/>description: { <br/>    type: String, <br/>    trim: true <br/>},</pre>
<ul>
<li><strong>Shop logo image</strong>: <span>The <kbd>image</kbd> field will store the logo image file uploaded by the user as data in the MongoDB database:</span></li>
</ul>
<pre style="padding-left: 60px">image: { <br/>    data: Buffer, <br/>    contentType: String <br/>},</pre>
<ul>
<li><strong>Shop owner</strong>: <span>The <kbd>owner</kbd> field will reference the user who creates the shop:</span></li>
</ul>
<pre style="padding-left: 60px">owner: {<br/>    type: mongoose.Schema.ObjectId, <br/>    ref: 'User'<br/>}</pre>
<ul>
<li><strong><em>Created at</em> and <em>updated at</em> times</strong>: <span>The</span> <kbd>created</kbd> <span>and</span> <kbd>updated</kbd> <span>fields will be <kbd>Date</kbd> types, with</span> <kbd>created</kbd> <span>generated when a new shop is added, and</span> <kbd>updated</kbd> <span>changed when any shop details are modified:</span></li>
</ul>
<pre style="padding-left: 60px">updated: Date,<br/>created: { <br/>    type: Date, <br/>    default: Date.now <br/>},</pre>
<p>The fields added in this schema definition will enable us to implement the shop-related features in MERN Marketplace.  I<span>n the next section, we will start developing these features by implementing the full-stack slice that will allow sellers to create new shops.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a new shop</h1>
                </header>
            
            <article>
                
<p><span>In MERN Marketplace, a</span> user who is signed in and has an active seller account will be able to create new shops. <span>To implement this feature, in the following sections we will add a create shop API in the backend, along with a way to fetch this API in the frontend, and a create new shop form view that takes user input for shop fields.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The create shop API</h1>
                </header>
            
            <article>
                
<p>For <span>the implementation of the create shop API that will allow creating new shops in the database</span>, we will first add a <kbd>POST</kbd> route, as shown in the following code:</p>
<p><kbd>mern-marketplace/server/routes/shop.routes.js</kbd>:</p>
<pre>router.route('/api/shops/by/:userId')<br/>    .post(authCtrl.requireSignin, authCtrl.hasAuthorization, <br/>           userCtrl.isSeller, shopCtrl.create)</pre>
<p>A <kbd>POST</kbd> request to this route at <kbd>/api/shops/by/:userId</kbd> will first ensure the requesting user is signed in and is also the authorized owner, in other words, it is the same user associated with the <kbd>:userId</kbd> specified in the route param.</p>
<p>To process the <kbd>:userId</kbd><span> </span>param and retrieve the associated user from the database, we will utilize the<span> </span><kbd>userByID</kbd><span> </span>method in the user controller. We will add the following to the<span> </span><kbd>Shop</kbd><span> </span>routes in<span> </span><kbd>shop.routes.js</kbd>, so the user is available in the<span> </span><kbd>request</kbd><span> </span>object as<span> </span><kbd>profile</kbd>:</p>
<p><kbd><span>mern-marketplace/server/routes/shop.routes.js</span></kbd>:</p>
<pre>router.param('userId', userCtrl.userByID) </pre>
<p>The <kbd>shop.routes.js</kbd> file containing the shop routes will be very similar to the <kbd>user.routes</kbd> file. To load these new shop routes in the Express app, we need to mount the shop routes in <kbd>express.js</kbd> as shown in the following code, as we did for the auth and user routes:</p>
<p><kbd>mern-marketplace/server/express.js</kbd>:</p>
<pre>app.use('/', shopRoutes)</pre>
<p>The request to the create shop route <span>will also verify that the current user is a seller before creating a new shop with the shop data passed in the request. </span>We will update the user controller to add the <kbd>isSeller</kbd> method, which will ensure that the current user is actually a seller. The <kbd>isSeller</kbd> method is defined as follows:</p>
<p><kbd>mern-marketplace/server/controllers/user.controller.js</kbd>:</p>
<pre>const isSeller = (req, res, next) =&gt; {<br/>  const isSeller = req.profile &amp;&amp; req.profile.seller<br/>  if (!isSeller) {<br/>    return res.status('403').json({<br/>      error: "User is not a seller"<br/>    })<br/>  }<br/>  next()<br/>}</pre>
<p>The <kbd>create</kbd> method in the shop controller, which is invoked after a seller is verified, uses the <kbd>formidable</kbd> node module to parse the multipart request that may contain an image file uploaded by the user for the shop logo. If there is a file, <kbd>formidable</kbd> will store it temporarily in the filesystem, and we will read it using the <kbd>fs</kbd> module to retrieve the filetype and data to store it in the <kbd>image</kbd> field in the shop document. <span>The <kbd>create</kbd> controller method will look as shown in the following code block:</span></p>
<p><kbd>mern-marketplace/server/controllers/shop.controller.js</kbd>:</p>
<pre>const create = (req, res, next) =&gt; {<br/>  let form = new formidable.IncomingForm()<br/>  form.keepExtensions = true<br/>  form.parse(req, (err, fields, files) =&gt; {<br/>    if (err) {<br/>      res.status(400).json({<br/>        message: "Image could not be uploaded"<br/>      })<br/>    }<br/>    let shop = new Shop(fields)<br/>    shop.owner= req.profile<br/>    if(files.image){<br/>      shop.image.data = fs.readFileSync(files.image.path)<br/>      shop.image.contentType = files.image.type<br/>    }<br/>    shop.save((err, result) =&gt; {<br/>      if (err) {<br/>        return res.status(400).json({<br/>          error: errorHandler.getErrorMessage(err)<br/>        })<br/>      }<br/>      res.status(200).json(result)<br/>    })<br/>  })<br/>}</pre>
<p class="mce-root"><span>The logo image file for the shop is uploaded by the user and stored in MongoDB as data. Then, in order to be shown in the views, it is retrieved from the database as an image file at a separate <kbd>GET</kbd> API. The <kbd>GET</kbd> API is set up as an Express route at <kbd>/api/shops/logo/:shopId</kbd>, which gets the image data from MongoDB and sends it as a file in the response. The implementation steps for file upload, storage, and retrieval are outlined in detail in the <em>Upload profile photo</em> section of</span> <a href="" target="_blank">Chapter 5</a><span>,</span> <em>Starting with a Simple Social Media Application</em><span>.</span></p>
<div class="page">
<div class="layoutArea">
<div class="column">
<p><span>This create shop API endpoint can now be used in the frontend to make a <kbd>POST</kbd> request. Next, we will add a <kbd>fetch</kbd> method on the client side to make this request from the application's client interface.</span></p>
</div>
</div>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fetching the create API in the view</h1>
                </header>
            
            <article>
                
<p><span>In the frontend, to make a request to</span> this cre<span>ate API, we will set up a <kbd>fetch</kbd> method on the client side to make a <kbd>POST</kbd> request to the API route and pass it the multipart form data containing details of the new shop. This <kbd>fetch</kbd> method will be defined as follows:</span></p>
<p><span><kbd>mern-marketplace/client/shop/api-shop.js</kbd></span>:</p>
<pre>const create = (params, credentials, shop) =&gt; {<br/>  return fetch('/api/shops/by/'+ params.userId, {<br/>      method: 'POST',<br/>      headers: {<br/>        'Accept': 'application/json',<br/>        'Authorization': 'Bearer ' + credentials.t<br/>      },<br/>      body: shop<br/>    })<br/>    .then((response) =&gt; {<br/>      return response.json()<br/>    }).catch((err) =&gt; console.log(err))<br/>}</pre>
<div class="page">
<div class="layoutArea">
<div class="column">
<p><span>We will use this method in the create new shop form view, implemented in the next section, to send the user-entered shop details to the backend.</span></p>
</div>
</div>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The NewShop component</h1>
                </header>
            
            <article>
                
<p>Sellers in the marketplace application will interact with a form view to enter details of a new shop and create the new shop. We will render this form in the <kbd>NewShop</kbd> component, which will allow a seller to create a shop by entering a name and description, and uploading a logo image file from their local filesystem, as pictured in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-818 image-border" src="assets/e7d9a06a-023f-470c-bd8d-a6bf34ab6634.png" style="width:13.92em;height:11.00em;"/></div>
<p>We will implement this form in a React component named <kbd>NewShop</kbd>. For the view, we will first add the file upload elements using a Material-UI button and an HTML5 file input element, as shown in the following code:</p>
<p><kbd>mern-marketplace/client/shop/NewShop.js</kbd>:</p>
<pre>&lt;input accept="image/*" onChange={handleChange('image')} <br/>       id="icon-button-file"<br/>       style={display:'none'} type="file" /&gt;<br/>&lt;label htmlFor="icon-button-file"&gt;<br/>   &lt;Button variant="contained" color="secondary" component="span"&gt;<br/>      Upload Logo &lt;FileUpload/&gt;<br/>   &lt;/Button&gt;<br/>&lt;/label&gt; <br/>&lt;span&gt;{values.image ? values.image.name : ''}&lt;/span&gt;<br/>          </pre>
<p>Then, we add the name and description form fields with the <kbd>TextField</kbd> components, as shown next:</p>
<p><kbd>mern-marketplace/client/shop/NewShop.js</kbd>:</p>
<pre>&lt;TextField <br/>    id="name" <br/>    label="Name" <br/>    value={values.name} <br/>    onChange={handleChange('name')}/&gt; &lt;br/&gt;<br/>&lt;TextField <br/>    id="multiline-flexible" <br/>    label="Description"<br/>    multiline rows="2" <br/>    value={values.description}<br/>    onChange={handleChange('description')}/&gt;</pre>
<p>These form field changes will be tracked with the <kbd>handleChange</kbd> method when a user interacts with the input fields to enter values. <span>The</span> <kbd><span>handleChange</span></kbd> <span>function will be defined as shown in the following code:</span></p>
<p><kbd><span>mern-marketplace/client/shop/NewShop.js</span></kbd>:</p>
<pre>const handleChange = name =&gt; event =&gt; {<br/>    const value = name === 'image'<br/>      ? event.target.files[0]<br/>      : event.target.value<br/>    setValues({ ...values, [name]: value })<br/>}</pre>
<p>The <kbd>handleChange</kbd> method updates the state with the new values<span>, including the name of the image file, should one be uploaded by the user.</span></p>
<div class="page">
<div class="layoutArea">
<div class="column">
<p><span>Finally, you can complete this form view by adding a submit button that when clicked, should send the form data to the server. We will define a <kbd>clickSubmit</kbd> method, as shown next, which will be called when the submit button is clicked by the user:</span></p>
</div>
</div>
</div>
<p><kbd><span>mern-marketplace/client/shop/NewShop.js</span></kbd>:</p>
<pre>const clickSubmit = () =&gt; {<br/>    const jwt = auth.isAuthenticated()<br/>    let shopData = new FormData()<br/>    values.name &amp;&amp; shopData.append('name', values.name)<br/>    values.description &amp;&amp; shopData.append('description', values.description)<br/>    values.image &amp;&amp; shopData.append('image', values.image)<br/>    create({<br/>      userId: jwt.user._id<br/>    }, {<br/>      t: jwt.token<br/>    }, shopData).then((data) =&gt; {<br/>      if (data.error) {<br/>        setValues({...values, error: data.error})<br/>      } else {<br/>        setValues({...values, error: '', redirect: true})<br/>      }<br/>    })<br/>}</pre>
<p><span>This <kbd>clickSubmit</kbd> function will take the input values and populate </span><kbd>shopData</kbd><span>, which is a </span><kbd>FormData</kbd><span> object that ensures the data is stored in the correct format needed for the </span><kbd>multipart/form-data</kbd><span> encoding type. Then</span><span> the </span><kbd>create</kbd><span> fetch method is called to create the new shop in the backend with this form data. </span>On successful shop creation, the user is redirected back to the <kbd>MyShops</kbd> view with the following code:</p>
<p><kbd><span>mern-marketplace/client/shop/NewShop.js</span></kbd>:</p>
<pre>if (values.redirect) {<br/>      return (&lt;Redirect to={'/seller/shops'}/&gt;)<br/>}</pre>
<p>The <kbd>NewShop</kbd> component can only be viewed by a signed-in user who is also a seller. So we will add a <kbd>PrivateRoute</kbd> in the <kbd>MainRouter</kbd> component, as shown in the following code block, that will render this form only for authenticated users at <kbd>/seller/shop/new</kbd>:</p>
<p><kbd>mern-marketplace/client/MainRouter.js</kbd>:</p>
<pre>&lt;PrivateRoute path="/seller/shop/new" component={NewShop}/&gt;</pre>
<p>This link can be added to any of the view components that may be accessed by the seller, for example in a view where a seller manages their shops in the marketplace. Now that it is possible to add new shops in the marketplace, in the next section we will discuss the implementations to fetch and list these shops from the database in the backend to the application views in the frontend. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Listing shops</h1>
                </header>
            
            <article>
                
<p>In MERN Marketplace, regular users will be able to browse through a list of all the shops on the platform, and each shop owner will manage a list of their own shops. In the following sections, we will implement the full-stack slices for retrieving and displaying two different lists of shops – a list of all the shops, and the list of shops owned by a specific user.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Listing all shops</h1>
                </header>
            
            <article>
                
<p>Any user browsing through the marketplace will be able to see a list of all the shops on the marketplace. In order to implement this feature, we will have to query the <kbd>shops</kbd> collection to retrieve all the <span>shops in the database and display it in a view to the end user. We achieve this by adding a full-stack slice with the following:</span></p>
<ul>
<li>A backend API to retrieve the list of shops</li>
<li>A <kbd>fetch</kbd> method in the frontend to make a request to the API</li>
<li>A React component to display the list of shops</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The shops list API</h1>
                </header>
            
            <article>
                
<p>In the backend, we will define an API to retrieve all the shops from the database, so the shops in the marketplace can be listed in the frontend. This API will accept a request from the client to query the <kbd>shops</kbd> collection and return the resulting shop documents in the response. First, we will add a route to retrieve all the shops stored in the database when the server receives a <kbd>GET</kbd> request at <kbd>'/api/shops'</kbd><span>. This route is declared as shown in the following code:</span></p>
<p><span> </span><kbd>mern-marketplace/server/routes/shop.routes.js</kbd></p>
<pre>router.route('/api/shops')<br/>    .get(shopCtrl.list)</pre>
<p>A <kbd>GET</kbd> request received at this route will invoke the <kbd>list</kbd> controller method, which will query the <kbd>shops</kbd> collection in the database to return all the shops. The <kbd>list</kbd> method is defined as follows:</p>
<p><kbd>mern-marketplace/server/controllers/shop.controller.js</kbd>:</p>
<pre>const list = async (req, res) =&gt; {<br/>  try {<br/>    let shops = await Shop.find()<br/>    res.json(shops)<br/>  } catch (err){<br/>    return res.status(400).json({<br/>      error: errorHandler.getErrorMessage(err)<br/>    })<br/>  }<br/>}</pre>
<p>This method will return all the shops in the database in response to the requesting client. Next, we will see how to make a request to this shop list API from the client side. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fetch all shops for the view</h1>
                </header>
            
            <article>
                
<div class="page">
<div class="layoutArea">
<div class="column">
<p><span>In order to use the shop list API in the frontend, we will define a <kbd>fetch</kbd> method that can be used by React components to load this list of shops. The</span><span> <kbd>list</kbd> </span><span>method on the client side will use <kbd>fetch</kbd> to make a <kbd>GET</kbd> request to the API, as shown in the following code:</span></p>
</div>
</div>
</div>
<p><kbd>mern-marketplace/client/shop/api-shop.js</kbd>:</p>
<pre>const list = async (signal) =&gt; {<br/>  try {<br/>    let response = await fetch('/api/shops', {<br/>      method: 'GET',<br/>      signal: signal<br/>    })<br/>    return response.json()<br/>  }catch(err) {<br/>    console.log(err)<br/>  }<br/>}</pre>
<p><span>As we will see in the next section, t</span>his <kbd>list</kbd> method can be used in the React component to display the list of shops. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Shops component</h1>
                </header>
            
            <article>
                
<p>In the <kbd>Shops</kbd> component, we will render the list of shops in a Material-UI <kbd>List</kbd>, after fetching the data from the server and setting the data in a state to be displayed as shown in the following screenshot:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-819 image-border" src="assets/28ad986e-83a7-4eab-aac2-6835cd66fec8.png" style="width:21.08em;height:18.33em;"/></div>
<div class="page">
<div class="layoutArea">
<div class="column">
<p><span>To implement this component, we first need to fetch and render the list of shops. We will make the fetch API call in the</span> <kbd><span>useEffect</span></kbd> <span>hook, and set the received <kbd>shops</kbd> array in the state, as shown here:</span></p>
</div>
</div>
</div>
<p><kbd>mern-marketplace/client/shop/Shops.js</kbd>:</p>
<pre>export default function Shops(){<br/>  <strong>const [shops, setShops] = useState([])</strong><br/><br/>  useEffect(() =&gt; {<br/>    const abortController = new AbortController()<br/>    const signal = abortController.signal<br/>    <strong>list</strong>(signal).then((data) =&gt; {<br/>      if (!data.error) {<br/>        <strong>setShops(data)</strong><br/>      }<br/>    })<br/>    return function cleanup(){<br/>      abortController.abort()<br/>    }<br/><br/>  }, [])<br/>...<br/>}</pre>
<p>In the <kbd>Shops</kbd> component view, this retrieved <kbd>shops</kbd> array is iterated over using <kbd>map</kbd>, with each shop's data rendered in the view in a Material-UI <kbd>ListItem</kbd>, and each <kbd>ListItem</kbd> is also linked to the individual shop's view, as shown in the following code:</p>
<p><kbd>mern-marketplace/client/shop/Shops.js</kbd>:</p>
<pre>{shops.map((shop, i) =&gt; {<br/>     return &lt;Link to={"/shops/"+shop._id} key={i}&gt;<br/>              &lt;Divider/&gt;<br/>              &lt;ListItem button&gt;<br/>                 &lt;ListItemAvatar&gt;<br/>                    &lt;Avatar src={'/api/shops/logo/'+shop._id+"?" + new Date().getTime()}/&gt;<br/>                 &lt;/ListItemAvatar&gt;<br/>                 &lt;div className={classes.details}&gt;<br/>                    &lt;Typography type="headline" <br/>                        component="h2" color="primary"&gt;<br/>                      {shop.name}<br/>                    &lt;/Typography&gt;<br/>                    &lt;Typography type="subheading" component="h4"&gt;<br/>                      {shop.description}<br/>                    &lt;/Typography&gt;<br/>                 &lt;/div&gt;<br/>              &lt;/ListItem&gt;<br/>              &lt;Divider/&gt;<br/>             &lt;/Link&gt;<br/>})}</pre>
<p>The <kbd>Shops</kbd> component will be accessed by the end user at <kbd>/shops/all</kbd>, which is set up with React Router and declared in <kbd>MainRouter.js</kbd> as follows:</p>
<p><kbd>mern-marketplace/client/MainRouter.js</kbd>:</p>
<pre> &lt;Route path="/shops/all" component={Shops}/&gt;</pre>
<p>Adding this link to any view in the application will redirect the user to a view displaying all the shops in the marketplace. Next, we will similarly implement the feature to list the shops owned by a specific user.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Listing shops by owner</h1>
                </header>
            
            <article>
                
<p>Authorized sellers on the marketplace will see a list of the shops they created, which they can manage by editing or deleting any shop on the list. <span>In order to implement this feature, we will have to query the shops' collection to retrieve all the </span><span>shops with the same owner and display it only to the authorized owner of the shops. We achieve this by adding a full-stack slice with the following:</span></p>
<ul>
<li>A backend API that ensures the requesting user is authorized and retrieves the relevant list of shops</li>
<li>A <kbd>fetch</kbd> method in the frontend to make a request to this API</li>
<li>A React component to display the list of shops to the authorized user</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The shops by owner API</h1>
                </header>
            
            <article>
                
<div class="page">
<div class="layoutArea">
<div class="column">
<p><span>We will implement an API in the backend to return the list of shops of a specific owner, so it can be rendered in the frontend for the end user. We will</span> start by <span>adding a route in the backend to retrieve all the shops created by a given user when the server receives a <kbd>GET</kbd> request at </span><kbd>/api/shops/by/:userId</kbd>. This route is declared as shown in the following code:</p>
</div>
</div>
</div>
<p><kbd>mern-marketplace/server/routes/shop.routes.js</kbd>:</p>
<pre>router.route('/api/shops/by/:userId')<br/>    .get(authCtrl.requireSignin, authCtrl.hasAuthorization, shopCtrl.listByOwner)</pre>
<p>A <kbd>GET</kbd> request to this route will first ensure the requesting user is signed in and is also the authorized owner, before invoking the <kbd>listByOwner</kbd> controller method in <kbd>shop.controller.js</kbd>. This method will query the <kbd>Shop</kbd> collection in the database to get the matching shops. <span>This </span><kbd>listByOwner</kbd><span> method </span>is defined as follows:</p>
<p><kbd>mern-marketplace/server/controllers/shop.controller.js</kbd>:</p>
<pre>const listByOwner = async (req, res) =&gt; {<br/>   try {<br/>     let shops = await Shop.find({owner: req.profile._id}).populate('owner', '_id name')<br/>     res.json(shops)<br/>   } catch (err){<br/>     return res.status(400).json({<br/>         error: errorHandler.getErrorMessage(err)<br/>     })<br/>   }<br/>}</pre>
<p>In the query to the Shop collection, we find all the shops where the <kbd>owner</kbd> field matches the user-specified with the <kbd>userId</kbd> param, then populate the referenced user's ID and name in the <kbd>owner</kbd> field, and return the resulting shops in an array in the response to the client. <span>Next, we will see how to make a request to this API from the client side.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fetch all shops owned by a user for the view</h1>
                </header>
            
            <article>
                
<p>In the frontend, to fetch the shops for a specific user using this list by owner API, we will add a <kbd>fetch</kbd> method that takes the signed-in user's credentials to make a <kbd>GET</kbd> request to the API route with the specific user ID passed in the URL. This <kbd>fetch</kbd> method is defined as shown in the following code:</p>
<p><kbd>mern-marketplace/client/shop/api-shop.js</kbd>:</p>
<pre>const listByOwner = async (params, credentials, signal) =&gt; {<br/>  try {<br/>    let response = await fetch('/api/shops/by/'+params.userId, {<br/>      method: 'GET',<br/>      signal: signal,<br/>      headers: {<br/>        'Accept': 'application/json',<br/>        'Authorization': 'Bearer ' + credentials.t<br/>      }<br/>    })<br/>    return response.json()<br/>  } catch(err){<br/>    console.log(err)<br/>  }<br/>}</pre>
<p>The shops returned in the response from the server using this method can be rendered in a React component to display the shops to the authorized user, as discussed in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The MyShops component</h1>
                </header>
            
            <article>
                
<p>The <kbd>MyShops</kbd> component is similar to the <kbd>Shops</kbd> component. It fetches the list of shops owned by the current user, and renders each shop in a <kbd>ListItem</kbd>, as pictured in the following screenshot:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-820 image-border" src="assets/b3cdc2c2-1081-41c0-b549-a56521a2954c.png" style="width:23.50em;height:11.17em;"/></div>
<p>Additionally, each shop has an <kbd>edit</kbd> and a <kbd>delete</kbd> option, unlike the list of items in <kbd>Shops</kbd>. The implementation for the <kbd>MyShops</kbd> component is the same as <kbd>Shops</kbd>, except for these edit and delete buttons, which are added as follows:</p>
<p><kbd>mern-marketplace/client/shop/MyShops.js</kbd>:</p>
<pre>&lt;ListItemSecondaryAction&gt;<br/>   &lt;Link to={"/seller/shop/edit/" + shop._id}&gt;<br/>       &lt;IconButton aria-label="Edit" color="primary"&gt;<br/>             &lt;Edit/&gt;<br/>       &lt;/IconButton&gt;<br/>   &lt;/Link&gt;<br/>   &lt;DeleteShop shop={shop} onRemove={removeShop}/&gt;<br/>&lt;/ListItemSecondaryAction&gt;</pre>
<p>The <kbd>Edit</kbd> button links to an <q>Edit Shop</q> view, whereas the <kbd>DeleteShop</kbd> component, which is discussed later in the chapter, handles the delete action. T<span>he </span><kbd>DeleteShop</kbd><span> component </span>updates the list by calling the <kbd>removeShop</kbd> method passed from <kbd>MyShops</kbd>. T<span>his </span><kbd>removeShop</kbd><span> method</span> allows us to update the state with the modified list of shops for the current user and <span>is defined in the <kbd>MyShops</kbd> component, as shown here:</span> </p>
<p><kbd>mern-marketplace/client/shop/MyShops.js</kbd>:</p>
<pre>const removeShop = (shop) =&gt; {<br/>    const updatedShops = [...shops]<br/>    const index = updatedShops.indexOf(shop)<br/>    updatedShops.splice(index, 1)<br/>    setShops(updatedShops)<br/>}</pre>
<p>The <kbd>MyShops</kbd> component can only be viewed by a signed-in user who is also a seller. So we will add a <kbd>PrivateRoute</kbd> in the <kbd>MainRouter</kbd> component, which will render this component only for authenticated users at <kbd>/seller/shops</kbd>, as shown in the following code:</p>
<p><kbd>mern-marketplace/client/MainRouter.js</kbd>:</p>
<pre>&lt;PrivateRoute path="/seller/shops" component={MyShops}/&gt;</pre>
<p>In the marketplace application, we add this link to the navigation menu to redirect a signed-in seller to the view where they can manage the shops they own by editing or deleting a shop. Before adding the ability to edit or delete shops, next we will look into how to retrieve a single shop from the backend and display it to the end user. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Displaying a shop</h1>
                </header>
            
            <article>
                
<p>Any users visiting MERN Marketplace will be able to browse through each individual shop. In the following sections, we will implement the individual shop view by adding a read shop API to the backend, a way to call this API from the frontend, and the React component that will display the shop details in the view. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The read a shop API</h1>
                </header>
            
            <article>
                
<div class="page">
<div class="layoutArea">
<div class="column">
<p><span>In order to implement the read shop API in the backend, we will start </span><span>by adding a</span><span> </span><kbd>GET</kbd><span> route that queries the</span><span> </span><kbd>Shop</kbd><span> </span><span>collection with an ID and returns the shop in the response. The route is declared along with a route parameter handler, as shown in the following code:</span></p>
</div>
</div>
</div>
<p><kbd>mern-marketplace/server/routes/shop.routes.js</kbd>:</p>
<pre>router.route('/api/shop/:shopId')<br/>    .get(shopCtrl.read)<br/>router.param('shopId', shopCtrl.shopByID)</pre>
<p>The<kbd>:shopId</kbd><span> </span>param in the route URL will invoke the<span> </span><kbd>shopByID</kbd><span> </span>controller method, which is similar to the<span> </span><kbd>userByID</kbd><span> </span>controller method. It retrieves the shop from the database and attaches it to the request object to be used in the<span> </span><kbd>next</kbd><span> </span>method. The <kbd>shopByID</kbd> method is defined as follows:</p>
<p><kbd><span>mern-marketplace/server/controllers/shop.controller.js</span></kbd>:</p>
<pre>const shopByID = async (req, res, next, id) =&gt; {<br/>  try {<br/>    let shop = await Shop.findById(id).populate('owner', '_id name').exec()<br/>    if (!shop)<br/>      return res.status('400').json({<br/>        error: "Shop not found"<br/>      })<br/>    req.shop = shop<br/>    next()<br/>  } catch (err) {<br/>    return res.status('400').json({<br/>      error: "Could not retrieve shop"<br/>    })<br/>  }<br/>}</pre>
<div class="page">
<div class="layoutArea">
<div class="column">
<p><span>The shop object queried from the database will also contain the name and ID details of the owner, as we specified in the</span> <kbd><span>populate()</span></kbd> <span>method. The</span> <kbd><span>read</span></kbd> <span>controller method then returns this</span> <span>shop </span><span>object in response to the client. </span><span>The</span><span> </span><kbd>read</kbd><span> </span><span>controlle</span><span>r method is defined as shown in the following code:</span></p>
</div>
</div>
</div>
<p><kbd>mern-marketplace/server/controllers/shop.controller.js</kbd>:</p>
<pre>const read = (req, res) =&gt; {<br/>  req.shop.image = undefined<br/>  return res.json(req.shop)<br/>}</pre>
<div class="page">
<div class="layoutArea">
<div class="column">
<p><span>We are removing the image field before sending the response since images will be retrieved as files in separate routes. With this API ready in the backend, you can now add the implementation to call it in the frontend by adding a <kbd>fetch</kbd> method in</span> <kbd><span>api-shop.js</span></kbd><span>, similar to other fetch methods already added for other API implementations. We will use the <kbd>fetch</kbd> method to call the read shop API in the React component that will render the shop details, as discussed in the next section.</span></p>
</div>
</div>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Shop component </h1>
                </header>
            
            <article>
                
<p>The<span> </span><kbd>Shop</kbd><span> </span>component will render the shop details and also a list of products in the specified shop using a product list component, which will be discussed in the<span> </span><em>Products</em><span> </span>section. The completed single <kbd>Shop</kbd> view will look as pictured in the following screenshot: </p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-821 image-border" src="assets/5576ec5c-cc59-498c-bb56-cea81e1bcb12.png" style="width:40.00em;height:19.50em;"/></div>
<p>To implement <span>this</span> <span><kbd>Shop</kbd> </span><span>component, we will first retrieve the shop details with a fetch call to the read API in a <kbd>useEffect</kbd> hook, and set the received values to state, as shown in the following code:<br/></span></p>
<p><kbd>mern-marketplace/client/shop/Shop.js</kbd>:</p>
<pre>export default function Shop({match}) {<br/>  const [shop, setShop] = useState('')<br/>  const [error, setError] = useState('')<br/><br/>  useEffect(() =&gt; {<br/>    const abortController = new AbortController()<br/>    const signal = abortController.signal<br/><br/>    read({<br/>      shopId: match.params.shopId<br/>    }, signal).then((data) =&gt; {<br/>      if (data.error) {<br/>        setError(data.error)<br/>      } else {<br/>        setShop(data)<br/>      }<br/>    })<br/>    return function cleanup(){<br/>      abortController.abort()<br/>    }<br/><br/>  }, [match.params.shopId])<br/>...<br/>}</pre>
<div class="page">
<div class="layoutArea">
<div class="column">
<p><span>This</span> <kbd><span>useEffect</span></kbd> hook <span>will only run when the</span> <kbd><span>shopId</span></kbd> <span>changes in the route params.</span></p>
</div>
</div>
</div>
<p>The retrieved shop data is set to state and rendered in the view to display the shop's name, logo, and description with the following code:</p>
<p><kbd><span>mern-marketplace/client/shop/Shop.js</span></kbd>:</p>
<pre>&lt;CardContent&gt;<br/>  &lt;Typography type="headline" component="h2"&gt;<br/>    {shop.name}<br/>  &lt;/Typography&gt;&lt;br/&gt;<br/>  &lt;Avatar src={logoUrl}/&gt;&lt;br/&gt;<br/>  &lt;Typography type="subheading" component="h2"&gt;<br/>    {shop.description}<br/>  &lt;/Typography&gt;&lt;br/&gt;<br/>&lt;/CardContent&gt;</pre>
<p>The<span> </span><kbd>logoUrl</kbd><span> </span>points to the route from where the logo image can be retrieved from the database (if the image exists), and it's defined as follows:</p>
<p><kbd><span>mern-marketplace/client/shop/Shop.js</span></kbd>:</p>
<pre>const logoUrl = shop._id<br/>          ? `/api/shops/logo/${shop._id}?${new Date().getTime()}`<br/>          : '/api/shops/defaultphoto'</pre>
<p>The<span> </span><kbd>Shop</kbd><span> </span>component will be accessed in the browser at the<span> </span><kbd>/shops/:shopId</kbd><span> </span>route, which is defined in<span> </span><kbd>MainRouter</kbd><span> </span>as follows:</p>
<p><kbd>mern-marketplace/client/MainRouter.js</kbd>:</p>
<pre>&lt;Route path="/shops/:shopId" component={Shop}/&gt;</pre>
<div class="page">
<div class="layoutArea">
<div class="column">
<p><span>This route can be used in any component to link to a specific shop, and this link will take the user to the corresponding <kbd>Shop</kbd> view with the shop details loaded. In the next section, we will add the ability to allow the shop owners to edit these shop details.</span></p>
</div>
</div>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Editing a shop</h1>
                </header>
            
            <article>
                
<p>Authorized sellers in the application will be able to update the shops they have already added to the marketplace. <span>To implement this capability, we will have to create a backend API that allows the update operation on a given shop after ensuring that the requesting user is authenticated and authorized. Then this updated API needs to be called from the frontend with the changed details of the shop. In the following sections, we will build this backend API and the React component to</span><span> allow sellers to make changes to their shops.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The edit shop API</h1>
                </header>
            
            <article>
                
<div class="page">
<div class="layoutArea">
<div class="column">
<p><span>In the backend, we will need an API that allows updating an existing shop in the database if the user making the request is the authorized seller of the given shop. We will first declare the PUT route that accepts the update request from the client as follows:</span></p>
</div>
</div>
</div>
<p><kbd>mern-marketplace/server/routes/shop.routes.js</kbd>:</p>
<pre>router.route('/api/shops/:shopId')<br/>    .put(authCtrl.requireSignin, shopCtrl.isOwner, shopCtrl.update)</pre>
<div class="page">
<div class="layoutArea">
<div class="column">
<p><span>A PUT request received at the</span> <kbd><span>/api/shops/:shopId</span></kbd><span> route first checks if the signed-in user is the owner of the shop associated with the</span> <kbd><span>shopId</span></kbd> <span>provided in the URL using the</span><span> </span><kbd>isOwner</kbd> <span>controller method, which is defined as follows:</span></p>
</div>
</div>
</div>
<p><kbd><span>mern-marketplace/server/controllers/shop.controller.js</span></kbd>:</p>
<pre>const isOwner = (req, res, next) =&gt; {<br/>  const isOwner = req.shop &amp;&amp; req.auth <br/>                           &amp;&amp; req.shop.owner._id == req.auth._id<br/>  if(!isOwner){<br/>    return res.status('403').json({<br/>      error: "User is not authorized"<br/>    })<br/>  }<br/>  next()<br/>}</pre>
<div class="page">
<div class="layoutArea">
<div class="column">
<p><span>In this method, if the user is found to be authorized, the <kbd>update</kbd> controller is invoked with a call to <kbd>next()</kbd>.</span></p>
</div>
</div>
</div>
<p>The <kbd>update</kbd> controller method will use the <kbd>formidable</kbd> and <kbd>fs</kbd> modules as in the <kbd>create</kbd> controller method discussed earlier, to parse the form data and update the existing shop in the database. <span>The <kbd>update</kbd> method in the shop controllers </span><span>is defined as shown in the following code:</span></p>
<p><kbd><span>mern-marketplace/server/controllers/shop.controller.js</span></kbd>:</p>
<pre>const update = (req, res) =&gt; {<br/>  let form = new formidable.IncomingForm()<br/>  form.keepExtensions = true<br/>  form.parse(req, async (err, fields, files) =&gt; {<br/>    if (err) {<br/>      res.status(400).json({<br/>        message: "Photo could not be uploaded"<br/>      })<br/>    }<br/>    let shop = req.shop<br/>    shop = extend(shop, fields)<br/>    shop.updated = Date.now()<br/>    if(files.image){<br/>      shop.image.data = fs.readFileSync(files.image.path)<br/>      shop.image.contentType = files.image.type<br/>    }<br/>    try {<br/>      let result = await shop.save()<br/>      res.json(result)<br/>    } catch (err){<br/>      return res.status(400).json({<br/>        error: errorHandler.getErrorMessage(err)<br/>      })<br/>    }<br/>  })<br/>}</pre>
<div class="page">
<div class="layoutArea">
<div class="column">
<p><span>To use this update API in the frontend, you will need to define a <kbd>fetch</kbd> method that takes the shop ID, user auth credentials, and the updated shop details to make the fetch call to this update shop API, as we have done for other API implementations including the create shop API in the </span><em>Creating a new shop</em> section<span>.</span></p>
<p><span>We now have a shop update API that can be used in the frontend to update the details of a shop. We will use this in the</span> <span><kbd>EditShop</kbd> </span><span>component, which is discussed next.</span></p>
</div>
</div>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The EditShop component</h1>
                </header>
            
            <article>
                
<p>The <kbd>EditShop</kbd> component will show a form similar to the create new shop form, pre-populated with the existing shop details. This component will also show a list of the products in this shop, to be discussed in the <em>Products</em> section. The completed <span class="packt_screen">Edit Shop</span> view is pictured in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-822 image-border" src="assets/18bbcae5-8299-4b14-a40f-f69bd2e35523.png" style="width:42.58em;height:26.25em;"/></div>
<p>The form part of this view for editing shop details is similar to the form in the <kbd>NewShop</kbd> component, with the same form fields and a <kbd>formData</kbd> object that holds the multipart form data to be sent with the <kbd>update</kbd> <kbd>fetch</kbd> method. In contrast to the <kbd>NewShop</kbd> component, in this component, we will need to utilize the read shop API to fetch the given shop's details in an <kbd>useEffect</kbd> hook and pre-populate the form fields. You can combine the implementations discussed for the <kbd>NewShop</kbd> component and <kbd>Shop</kbd> component to complete the <kbd>EditShop</kbd> component.</p>
<p>The <kbd>EditShop</kbd> component will only be accessible by authorized shop owners. So we will add a <kbd>PrivateRoute</kbd> in the <kbd>MainRouter</kbd> component as shown next, which will render this component only for authenticated users at <kbd>/seller/shop/edit/:shopId</kbd>:</p>
<p><kbd>mern-marketplace/client/MainRouter.js</kbd>:</p>
<pre>&lt;PrivateRoute path="/seller/shop/edit/:shopId" component={EditShop}/&gt;</pre>
<p>This link is added with an edit icon for each shop in the <kbd>MyShops</kbd> component, allowing a seller to access the edit page for each of their shops. In the <kbd>MyShops</kbd> view, sellers are also able to delete their shops, as implemented in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deleting a shop</h1>
                </header>
            
            <article>
                
<p>As a part of managing the shops they own, authorized sellers will have the option to delete any of their own shops. <span>In order to allow a seller to remove a shop from the marketplace, in the following sections, first we will define a backend API for shop deletion from the database, and then implement a React component that makes use of this API when the user interacts with the frontend to perform this deletion.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The delete shop API</h1>
                </header>
            
            <article>
                
<p>In order to delete a shop from the database, we will implement a delete shop API in the backend, which will accept a DELETE request from the client at <kbd>/api/shops/:shopId</kbd>. We will add the <kbd>DELETE</kbd> route for this API as shown in the following code, which will allow an authorized seller to delete one of their own shops:</p>
<p><kbd><span>mern-marketplace/server/routes/shop.routes.js</span></kbd>:</p>
<pre>router.route('/api/shops/:shopId')<br/>    .delete(authCtrl.requireSignin, shopCtrl.isOwner, shopCtrl.remove)</pre>
<p>When a DELETE request is received at this route, <span>if the </span><kbd>isOwner</kbd><span> method confirms that the signed-in user is the owner of the shop, then </span>the <kbd>remove</kbd> controller method deletes the shop specified by the <kbd>shopId</kbd> in the param. The <kbd>remove</kbd> method is defined as follows:</p>
<p><kbd>mern-marketplace/server/controllers/shop.controller.js</kbd>:</p>
<pre>const remove = async (req, res) =&gt; {<br/>  try {<br/>    let shop = req.shop<br/>    let deletedShop = shop.remove()<br/>    res.json(deletedShop)<br/>  } catch (err) {<br/>    return res.status(400).json({<br/>      error: errorHandler.getErrorMessage(err)<br/>    })<br/>  } <br/>}</pre>
<div class="page">
<div class="layoutArea">
<div class="column">
<p><span>This </span><kbd><span>remove</span></kbd> <span>method simply deletes the shop document that corresponds to the provided ID from the <kbd>Shops</kbd> collection in the database. To access this backend API in the frontend, you will also need a <kbd>fetch</kbd> method with this route, similar to other API implementations. The <kbd>fetch</kbd> method will need to take the shop ID and current user's auth credentials then call the delete shop API with these values.</span></p>
<p><span>The <kbd>fetch</kbd> method will be used when the user performs the delete operation by clicking a button in the frontend interface. In the next section, we will discuss a React component called</span> <kbd><span>DeleteShop</span></kbd><span>, where this delete shop action will be performed by the user.</span></p>
</div>
</div>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The DeleteShop component</h1>
                </header>
            
            <article>
                
<p>The <kbd>DeleteShop</kbd> component is added to the <kbd>MyShops</kbd> component for each shop in the list. It takes the <kbd>shop</kbd> object and a <kbd>onRemove</kbd> method as props from <kbd>MyShops</kbd>. This <span>component is basically a button that, when clicked, opens a <kbd>Dialog</kbd> component asking the user to confirm the</span> <span>delete</span> <span>action, as shown in the following screenshot:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-823 image-border" src="assets/be1cb170-87e7-481a-be9b-90862d50edd8.png" style="width:11.50em;height:5.67em;"/></div>
<div class="page">
<div class="layoutArea">
<div class="column">
<p><span>The implementation of the</span> <span><kbd>DeleteShop</kbd> </span><span>component is similar to the</span> <kbd><span>DeleteUser</span></kbd> <span>component discussed in <a href="6f2ca10a-8079-4e3a-9d42-a3db8e85b9d9.xhtml" target="_blank">Chapter 4,</a></span> <em><span>Adding a React Frontend to Complete MERN</span></em><span>.</span> <span>Instead of a user ID, the</span> <span><kbd>DeleteShop</kbd> </span><span>component will take the <kbd>shop</kbd> object and</span> <kbd><span>onRemove</span></kbd> <span>function definition from the</span> <span><kbd>MyShops</kbd> </span><span>component as props when it is added to</span> <span><kbd>MyShops</kbd>, </span><span>as shown in the following code:</span></p>
</div>
</div>
</div>
<p><kbd>mern-marketplace/client/shop/MyShops.js</kbd>:</p>
<pre>&lt;DeleteShop shop={shop} onRemove={removeShop}/&gt;</pre>
<div class="page">
<div class="layoutArea">
<div class="column">
<p><span>With this implementation, authorized sellers will be able to remove a shop that they own from the marketplace.</span></p>
<p>We have implemented the shop module for the marketplace by first defining the Shop model for storing shop data, and then integrating the backend APIs and frontend views to be able to perform CRUD operations on shops from the application. <span>These shop features, with the ability to create new shops, display a shop, edit and delete shops, will allow both buyers and sellers to interact with the shops in the marketplace. The shops will also have products, discussed next, which the owners will manage and the buyers will be able to browse through, with an option to add products to their cart.</span></p>
</div>
</div>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding products to shops</h1>
                </header>
            
            <article>
                
<p>Products are the most crucial aspect of a marketplace application. In the MERN Marketplace, sellers can manage products in their shops, and visitors can search for and <span>browse products</span>. While we will implement the features to allow authorized sellers to add, modify, and delete products from their shops, we will also incorporate features to list products in ways that are meaningful to the end user. In the application, we will retrieve and display products by a specific shop, products related to a given product, and the latest products added to the marketplace. In the following sections, we will build out the product module incorporating these features by first defining a product model for storing product <span>data in the database, and then implementing the backend APIs and frontend views for the product-related features including adding new products to a shop, rendering different lists of products, displaying a single product, editing products, and deleting products. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining a Product model</h1>
                </header>
            
            <article>
                
<p>Products will be stored in a product collection in the database. <span>To implement this, we will add a Mongoose model to define a Product model for storing the details of each product. This model will be defined in <kbd>server/models/product.model.js</kbd>, and the implementation will be similar to other Mongoose model implementations covered in previous chapters, like the Course model defined in <a href="c58ac055-5a1e-4bf4-b8a6-c9b311cf267a.xhtml" target="_blank">Chapter 6</a>, <em>Building a Web-Based Classroom Application</em>.</span> </p>
<p>For MERN Marketplace, we will keep the product schema simple with support for fields such as product <kbd>name</kbd>, <kbd>description</kbd>, <kbd>image</kbd>, <kbd>category</kbd>, <kbd>quantity</kbd>, <kbd>price</kbd>, <kbd>created at</kbd>, <kbd>updated at</kbd>, and a reference to the shop. <span>The code defining the product fields in the product schema are given in the following list, along with explanations:</span></p>
<ul>
<li><strong>Product name and description</strong>: The <kbd>name</kbd><span> and <kbd>description</kbd> fields will be <kbd>String</kbd> types, with <kbd>name</kbd> as a <kbd>required</kbd> field:</span></li>
</ul>
<pre style="padding-left: 60px">name: { <br/>    type: String, <br/>    trim: true, <br/>    required: 'Name is required' <br/>},<br/>description: { <br/>    type: String, <br/>    trim: true <br/>},</pre>
<ul>
<li><strong>Product image</strong>: <span>The <kbd>image</kbd> field will store an image file to be uploaded by the user as data in the MongoDB database:</span></li>
</ul>
<pre style="padding-left: 60px">image: { <br/>    data: Buffer, <br/>    contentType: String <br/>},</pre>
<ul>
<li><strong>Product category</strong>: <span>The <kbd>category</kbd> value will allow grouping products of the same type together:</span></li>
</ul>
<pre style="padding-left: 60px">category: { <br/>    type: String <br/>},</pre>
<ul>
<li><strong>Product quantity</strong>: <span>The <kbd>quantity</kbd> field will represent the amount available for selling in the shop:</span></li>
</ul>
<pre style="padding-left: 60px">quantity: { <br/>    type: Number, <br/>    required: "Quantity is required" <br/>},</pre>
<ul>
<li><strong>Product price</strong>: <span>The <kbd>price</kbd> field will hold the unit price this product will cost the buyer:</span></li>
</ul>
<pre style="padding-left: 60px">price: { <br/>    type: Number, <br/>    required: "Price is required" <br/>},</pre>
<ul>
<li><strong>Product shop</strong>: <span>The <kbd>shop</kbd> field will reference the shop to which the product was added:</span></li>
</ul>
<pre style="padding-left: 60px">shop: {<br/>    type: mongoose.Schema.ObjectId, <br/>    ref: 'Shop'<br/>}</pre>
<ul>
<li><strong>Created and updated at times</strong>: <span>The</span> <kbd>created</kbd> <span>and</span> <kbd>updated</kbd> <span>fields will be <kbd>Date</kbd> types, with</span> <kbd>created</kbd> generated when a new product is added, and the <kbd>updated</kbd> time changed when the product's details are modified:</li>
</ul>
<pre style="padding-left: 60px">updated: Date,<br/>created: { <br/>    type: Date, <br/>    default: Date.now <br/>},</pre>
<p>The fields in this schema definition will enable us to implement the product-related features in MERN Marketplace. <span>To begin the implementation of these features, in the next section, we will implement the full-stack slice that will allow sellers to add new products to their existing shops in the marketplace.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a new product</h1>
                </header>
            
            <article>
                
<p>Sellers in MERN Marketplace will be able to add new products to the shops they own on the platform. To implement this feature, in the following sections we will add a create product API in the backend, along with a way to fetch this API in the frontend, and a create new product form view that takes user input for product fields.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The create product API</h1>
                </header>
            
            <article>
                
<p>We will add a backend API that will let authorized shop owners save new products to the database with a <kbd>POST</kbd> request from the client side. In order to implement this create product API in the backend, we will first add a route at <kbd>/api/products/by/:shopId</kbd>, which accepts a <kbd>POST</kbd> request containing the product data. Sending a request to this route will create a new product associated with the shop identified by the <kbd>:shopId</kbd> param. This create product API route is declared as shown in the following code:</p>
<p><kbd>mern-marketplace/server/routes/product.routes.js</kbd>:</p>
<pre>router.route('/api/products/by/:shopId')<br/>  .post(authCtrl.requireSignin, shopCtrl.isOwner, productCtrl.create)<br/>router.param('shopId', shopCtrl.shopByID)</pre>
<p>The <kbd>product.routes.js</kbd> file containing this route declaration will be very similar to the <kbd>shop.routes.js</kbd> file, and to load these new routes in the Express app, we need to mount the product routes in <kbd>express.js</kbd>, as shown next:</p>
<p><kbd>mern-marketplace/server/express.js</kbd>:</p>
<pre>app.use('/', productRoutes)</pre>
<p><span>The code to handle a request to the create product API route will first check that the current user is the owner of the shop to which the new product will be added before creating the new product in the database. This API utilizes the <kbd>shopByID</kbd> and <kbd>isOwner</kbd> methods from the shop controller to process the <kbd>:shopId</kbd> param and to verify that the current user is the shop owner, before invoking the <kbd>create</kbd> controller method. </span><span>The <kbd>create</kbd> method is defined as follows:</span></p>
<p><kbd>mern-marketplace/server/controllers/product.controller.js</kbd>:</p>
<pre>const create = (req, res, next) =&gt; {<br/>  let form = new formidable.IncomingForm()<br/>  form.keepExtensions = true<br/>  form.parse(req, async (err, fields, files) =&gt; {<br/>    if (err) {<br/>      return res.status(400).json({<br/>        message: "Image could not be uploaded"<br/>      })<br/>    }<br/>    let product = new Product(fields)<br/>    product.shop= req.shop<br/>    if(files.image){<br/>      product.image.data = fs.readFileSync(files.image.path)<br/>      product.image.contentType = files.image.type<br/>    }<br/>    try {<br/>      let result = await product.save()<br/>      res.json(result)<br/>    } catch (err){<br/>      return res.status(400).json({<br/>        error: errorHandler.getErrorMessage(err)<br/>      })<br/>    }<br/>  })<br/>}</pre>
<p><span>This <kbd>create</kbd> method, in the product controller, uses the <kbd>formidable</kbd> node module to parse the multipart request that may contain an image file uploaded by the user along with the product fields. The parsed data is then saved to the Products collection as a new product.</span></p>
<p><span>In the frontend, to</span> use this creat<span>e product API, you will also need to set up a <kbd>fetch</kbd> method in <kbd>client/product/api-product.js</kbd></span><span> to make a <kbd>POST</kbd> request to the create API by passing the multipart form data from the view. This <kbd>fetch</kbd> method can then be utilized in the React component, which takes the product details from the user and sends the request to create a new product. The implementation of this form-based React component to create new products is discussed in the next section.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The NewProduct component</h1>
                </header>
            
            <article>
                
<p><span>An authorized seller who already has a shop created in the marketplace will see a form view for adding new products to the shop. We will implement this form view in a React component named <kbd>NewProduct</kbd>. The <kbd>NewProduct</kbd> component w</span>ill be similar to t<span>he <kbd>NewShop</kbd> component. It will contain a form that allows a seller to create a product by entering a name, description, category, quantity, and price, and to upload a product image file from their local filesystem, as pictured in the following screenshot:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-824 image-border" src="assets/a6dcfa2a-ed05-40c5-90c2-01538f736a4b.png" style="width:27.25em;height:37.25em;"/></div>
<p>The <kbd>NewProduct</kbd> component can be implemented almost exactly the same as the <kbd>NewShop</kbd> component, with the exception of retrieving the shop ID from the frontend route URL that will render the <kbd>NewProduct</kbd> component. This component will load at a route that is associated with a specific shop, so only signed-in users who are sellers can add a product to a shop they own. To define this route, we add a <kbd>PrivateRoute</kbd> in the <kbd>MainRouter</kbd> component<span> as shown next</span>, which will render this form only for authorized users at the URL <kbd>/seller/:shopId/products/new</kbd>:</p>
<p><kbd>mern-marketplace/client/MainRouter.js</kbd>:</p>
<div>
<pre>&lt;PrivateRoute path="/seller/:shopId/products/new" component={NewProduct}/&gt;</pre></div>
<p>Adding this link for a specific shop to any view in the frontend will render the <kbd>NewProduct</kbd> component for the signed-in user. In this view, the users will be able to fill out the new product details in the form and then save the product to the database in the backend, only if they are the authorized owner of the given shop. Next, we will look into the implementations for retrieving and displaying these products on different lists.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Listing products</h1>
                </header>
            
            <article>
                
<p>In MERN Marketplace, products will be presented to users in multiple ways. The two main distinctions will be in the way products are listed for sellers and the way they are listed for buyers. In the following sections, we will see how to list products in a shop for both sellers and buyers, then also discuss how to list product suggestions for buyers, featuring products that are related to a specific product, along with the latest products added to the marketplace. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Listing by shop</h1>
                </header>
            
            <article>
                
<p>Visitors to the marketplace will browse products in each shop, and sellers will manage a list of products in each of their shops. Both these features will share the same backend API that will retrieve all the products for a specific shop but will be rendered differently for the two types of users. In the following sections, first, we will implement the backend API for fetching the products in a specific shop. Then, we will use the API in two different React components to render the list of products to the seller of the shop in one component, and to the buyers in another component. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The products by shop API</h1>
                </header>
            
            <article>
                
<p>In order to implement the backend API to retrieve products from a specific shop in the database, we will set up a <kbd>GET</kbd> route at <kbd>/api/products/by/:shopId</kbd>, as shown in the following code:</p>
<p><kbd>mern-marketplace/server/routes/product.routes.js</kbd>:</p>
<pre>router.route('/api/products/by/:shopId')<br/>    .get(productCtrl.listByShop)</pre>
<p>The <kbd>listByShop</kbd> controller method executed in response to this request will query the Product collection to return the products matching the given shop's reference. <span>The </span><kbd>listByShop</kbd><span> method is defined as shown in the following code:</span></p>
<p><kbd>mern-marketplace/server/controllers/product.controller.js</kbd>:</p>
<pre>const listByShop = async (req, res) =&gt; {<br/>  try {<br/>    let products = await Product.find({shop: req.shop._id})<br/>                          .populate('shop', '_id name').select('-image')<br/>    res.json(products)<br/>  } catch (err) {<br/>    return res.status(400).json({<br/>      error: errorHandler.getErrorMessage(err)<br/>    })<br/>  }<br/>}</pre>
<p>Each product in the resulting products array will contain the name and ID details of the associated shop, and we will omit the <kbd>image</kbd> field since images can be retrieved via separate API routes.</p>
<p>In the frontend, to fetch the products in a specific shop using this API to list by shop, we will also need to add a <kbd>fetch</kbd> method in <kbd>api-product.js</kbd>, similar to our other API implementations. Then, the <kbd>fetch</kbd> method can be called in any React component to render the products, for example, to display products in a shop to all buyers, <span>as discussed in the next section</span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Products component for buyers</h1>
                </header>
            
            <article>
                
<div class="page">
<div class="layoutArea">
<div class="column">
<p><span>We will build a <kbd>Products</kbd> component, m</span>ainly for di<span>splaying the products to visitors who may buy the products. We can reuse this component across the application to render different product lists relevant to the buyer. It will receive the product list as props from a parent </span>component that displays a list of products. A rendered <span class="packt_screen">Products</span> view may look as shown in the following screenshot:</p>
</div>
</div>
</div>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-825 image-border" src="assets/ab101983-f154-4f96-bc60-6509979c0896.png" style="width:28.00em;height:10.75em;"/></div>
<p>In the marketplace application, the list of products in a shop will be displayed to the user in an individual <kbd>Shop</kbd> view. So this <kbd>Products</kbd> component is added to the <kbd>Shop</kbd> component and given the list of relevant products as props, as shown next:</p>
<p><kbd>mern-marketplace/client/shop/Shop.js</kbd>:</p>
<pre>&lt;Products products={products} searched={false}/&gt;&lt;/Card&gt;</pre>
<p><span>The </span><kbd>searched</kbd><span> prop relays whether this list is a result of a product search, so appropriate messages can be rendered.</span></p>
<p>In the <kbd>Shop</kbd> component, we need to add a call to the <kbd>listByShop</kbd> fetch method in a <kbd>useEffect</kbd> hook to retrieve the relevant products and set it to state, as shown in the following code:</p>
<p><kbd><span>mern-marketplace/client/shop/Shop.js</span></kbd>:</p>
<pre>useEffect(() =&gt; {<br/>    const abortController = new AbortController()<br/>    const signal = abortController.signal<br/><br/>    listByShop({<br/>      shopId: match.params.shopId<br/>    }, signal).then((data)=&gt;{<br/>      if (data.error) {<br/>        setError(data.error)<br/>      } else {<br/>        setProducts(data)<br/>      }<br/>    })<br/><br/>    return function cleanup(){<br/>      abortController.abort()<br/>    }<br/>}, [match.params.shopId])<br/><br/></pre>
<p>In the <kbd>Products</kbd> component, if the product list sent in the props contains products, the list is iterated over and the relevant details of each product are rendered in a Material-UI <kbd>GridListTile</kbd>, with a link to the individual product view and an <kbd>AddToCart</kbd> component (the implementation for which is discussed in <a href="7514f26d-29e1-46e2-ac46-7515b2c3a6d0.xhtml" target="_blank">Chapter 8</a>, <em>Extending the Marketplace for Orders and Payments</em>. The code to render the list of products is added as follows:</p>
<p><kbd>mern-marketplace/client/product/Products.js</kbd>:</p>
<pre>{props.products.length &gt; 0 ?<br/>    (&lt;div&gt;<br/>       &lt;GridList cellHeight={200} cols={3}&gt;<br/>           {props.products.map((product, i) =&gt; (<br/>            &lt;GridListTile key={i}&gt;<br/>              &lt;Link to={"/product/"+product._id}&gt;<br/>                &lt;img src={'/api/product/image/'+product._id}<br/>                     alt={product.name} /&gt;<br/>              &lt;/Link&gt;<br/>              &lt;GridListTileBar<br/>                title={&lt;Link to={"/product/"+product._id}&gt;<br/>                    {product.name}&lt;/Link&gt;}<br/>                subtitle={&lt;span&gt;$ {product.price} &lt;/span&gt;}<br/>                actionIcon={<br/>                  &lt;AddToCart item={product}/&gt;<br/>                }<br/>              /&gt;<br/>            &lt;/GridListTile&gt;))<br/>           }<br/>       &lt;/GridList&gt;<br/>    &lt;/div&gt;) : props.searched &amp;&amp; (&lt;Typography component="h4"&gt;<br/>                                    No products found! :(&lt;/Typography&gt;)}</pre>
<p>If the <kbd>products</kbd> array sent in the props is found to be empty, and this was a result of a search action by the user, we render an appropriate message to inform the user that no products were found.</p>
<p>This <kbd>Products</kbd> component can be used to render different lists of products for buyers, including products in a shop, products by category, and products in search results. In the next section, we will implement a <kbd>MyProducts</kbd> component that will render a list of products only for shop owners, giving them a different set of interaction options.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">MyProducts component for shop owners</h1>
                </header>
            
            <article>
                
<p>In contrast to the <kbd>Products</kbd> component, t<span>he <kbd>MyProducts</kbd> component in <kbd>client/product/MyProducts.js</kbd> is only for displaying produc</span>ts to sellers so <span>they can manage the products in each shop they own and will be displayed to the end user as pictured in the following screenshot:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-826 image-border" src="assets/e9532c67-1d7a-4a33-bcf3-1633f80b84d0.png" style="width:23.25em;height:21.58em;"/></div>
<p>The <kbd>MyProducts</kbd> component is added to the <kbd>EditShop</kbd> view as shown in the following code, so sellers can manage a shop and its contents in one place. It is provided with the shop's ID in a prop so that relevant products can be fetched:</p>
<p><kbd>mern-marketplace/client/shop/EditShop.js</kbd>:</p>
<pre>&lt;MyProducts shopId={match.params.shopId}/&gt;</pre>
<p>In <kbd>MyProducts</kbd>, the relevant products are first loaded in a state with an <kbd>useEffect</kbd> hook using the <kbd>listByShop</kbd><span> fetch method, </span>as shown in the following code:</p>
<p><kbd>mern-marketplace/client/product/MyProducts.js</kbd>:</p>
<pre>export default function MyProducts (props){<br/>  const [products, setProducts] = useState([])<br/>  useEffect(() =&gt; {<br/>    const abortController = new AbortController()<br/>    const signal = abortController.signal<br/>    listByShop({<br/>      shopId: props.shopId<br/>    }, signal).then((data)=&gt;{<br/>      if (data.error) {<br/>        console.log(data.error)<br/>      } else {<br/>        setProducts(data)<br/>      }<br/>    })<br/>    return function cleanup(){<br/>      abortController.abort()<br/>    }<br/>  }, [])<br/>...<br/>}<br/><br/></pre>
<p>This list of products is then iterated over with each product rendered in the <kbd>ListItem</kbd> components along with edit and delete options, similar to the <kbd>MyShops</kbd> list view. <span>The edit button links to the <span class="packt_screen">Edit Product</span> view. The <kbd>DeleteProduct</kbd> component handles the delete action, and reloads the list by calling an <kbd>onRemove</kbd> method passed from <kbd>MyProducts</kbd> to update </span><span>the state with the updated list of products for the current shop.</span></p>
<p><span>The <kbd>removeProduct</kbd> method, defined in <kbd>MyProducts</kbd>, is provided as the <kbd>onRemove</kbd> prop to the <kbd>DeleteProduct</kbd> component. The <kbd>removeProduct</kbd> method is defined as follows:</span></p>
<p><kbd>mern-marketplace/client/product/MyProducts.js</kbd><span>:</span></p>
<pre><span>const <strong>removeProduct</strong> = (product) =&gt; {<br/>    const updatedProducts = [...products]<br/>    const index = updatedProducts.indexOf(product)<br/>    updatedProducts.splice(index, 1)<br/>    setProducts(updatedProducts)<br/>}   <br/></span></pre>
<p>Then it is passed as a prop to the <kbd>DeleteProduct</kbd> component when it is added to <kbd>MyProducts</kbd> as shown next:</p>
<p><kbd>mern-marketplace/client/product/MyProducts.js</kbd>:</p>
<pre><span>&lt;DeleteProduct<br/>       product={product}<br/>       shopId={props.shopId}<br/>       <strong>onRemove={removeProduct}</strong>/&gt;</span></pre>
<p>Implementing a separate <kbd>MyProducts</kbd> component this way gives the shop owner the ability to see the list of products in their shop with the option to edit and delete each. In the next section, we will complete the implementation for retrieving different types of product lists from the backend and rendering them as product suggestions for buyers in the frontend.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Listing product suggestions</h1>
                </header>
            
            <article>
                
<p>Visitors to MERN Marketplace will see product suggestions, such as the latest products added to the marketplace and products related to the product they are currently viewing. In the following sections, we will first look at the implementation of the backend APIs for retrieving the latest products and a list of products related to a given product, and then implement a React component called Suggestions to render these lists of products.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Latest products</h1>
                </header>
            
            <article>
                
<p>On the home page of the MERN Marketplace, we will display five of the latest products added to the marketplace. To fetch the latest products, we will set up a backend API that will receive a <kbd>GET</kbd> request at <kbd>/api/products/latest</kbd>, as shown in the following code:</p>
<p><kbd>mern-marketplace/server/routes/product.routes.js</kbd>:</p>
<pre>router.route('/api/products/latest')<br/>      .get(productCtrl.listLatest)</pre>
<p>A <kbd>GET</kbd> request received at this route will invoke the <kbd>listLatest</kbd> controller method. This method will find all products, sort the list of products in the database with the <kbd>created</kbd> date field from newest to oldest, and return the first five from the sorted list in the response. <span>This </span><kbd>listLatest</kbd><span> controller method is defined as follows:</span></p>
<p><kbd>mern-marketplace/server/controllers/product.controller.js</kbd>:</p>
<pre>const listLatest = async (req, res) =&gt; {<br/>  try {<br/>    let products = await Product.find({}).sort('-created')<br/>         .limit(5).populate('shop', '_id name').exec()<br/>    res.json(products)<br/>  } catch (err){<br/>    return res.status(400).json({<br/>      error: errorHandler.getErrorMessage(err)<br/>    })<br/>  }<br/>}</pre>
<p>To use this API in the frontend, you will also need to set up a corresponding <kbd>fetch</kbd> method in <kbd>api-product.js</kbd> for this latest products API, similar to other API implementations. This retrieved list will then be rendered in the <kbd>Suggestions</kbd> component to be added to the home page. Next, we will discuss a similar API for retrieving a list of related products. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Related products</h1>
                </header>
            
            <article>
                
<p>In each individual product view, we will show five related products as suggestions. To retrieve these related products, we will set up a backend API that accepts a request at <kbd>/api/products/related</kbd>, as shown in the following code.</p>
<p><kbd>mern-marketplace/server/routes/product.routes.js</kbd>:</p>
<pre>router.route('/api/products/related/:productId')<br/>              .get(productCtrl.listRelated)<br/><span>router.param('productId', productCtrl.productByID)</span></pre>
<p>The<kbd>:productId</kbd> param in the route URL route will call the <kbd>productByID</kbd> controller method, which is similar to the <kbd>shopByID</kbd> controller method, and retrieves the product from the database and attaches it to the request object to be used in the <kbd>next</kbd> method. T<span>he </span><kbd>productByID</kbd><span> controller method is defined as follows:</span></p>
<p><kbd><span>mern-marketplace/server/controllers/product.controller.js</span></kbd>:</p>
<pre>const productByID = async (req, res, next, id) =&gt; {<br/>  try {<br/>    let product = await Product.findById(id)<br/>       .populate('shop', '_id  name').exec()<br/>    if (!product)<br/>      return res.status('400').json({<br/>        error: "Product not found"<br/>      })<br/>    req.product = product<br/>    next()<br/>  } catch (err) {<br/>    return res.status('400').json({<br/>      error: "Could not retrieve product"<br/>    })<br/>  }<br/>}</pre>
<p>Once the product is retrieved, the <kbd>listRelated</kbd> controller method is invoked. This method queries the <kbd>Product</kbd> collection in the database to find other products with the same category as the given product, excluding the given product, and returns the first five products in the resulting list. T<span>his </span><kbd>listRelated</kbd><span> controller method is defined as follows:</span></p>
<p><kbd><span>mern-marketplace/server/controllers/product.controller.js</span></kbd>:</p>
<pre>const listRelated = async (req, res) =&gt; {<br/>  try{<br/>    let products = await Product.find({ "_id": { "$ne": req.product }, <br/>         "category": req.product.category})<br/>             .limit(5).populate('shop', '_id name').exec()<br/>    res.json(products)<br/>  } catch (err){<br/>    return res.status(400).json({<br/>      error: errorHandler.getErrorMessage(err)<br/>    })<br/>  }<br/>}</pre>
<p>In order to utilize this related products API in the frontend, we will set up a corresponding <kbd>fetch</kbd> method in <kbd>api-product.js</kbd>. The <kbd>fetch</kbd> method will be called in the <kbd>Product</kbd> component with the product ID to populate the <kbd>Suggestions</kbd> component rendered in the product view. We will look at the implementation of this <kbd>Suggestions</kbd> component in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Suggestions component</h1>
                </header>
            
            <article>
                
<p>The <kbd>Suggestions</kbd> component will be rendered on the home page and on an individual product page to show the latest products and related products, respectively. Once rendered, the <kbd>Suggestions</kbd> component may look as shown in the following screenshot:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-827 image-border" src="assets/e32fbd8f-3a5c-4a2d-9415-c8d5ae3915a4.png" style="width:22.42em;height:26.50em;"/></div>
<p>This component will receive the relevant list of products from the parent component as props, along with a title for the list:</p>
<pre>&lt;Suggestions  products={suggestions} title={suggestionTitle}/&gt;</pre>
<p>In the <kbd>Suggestions</kbd> component, the received list is iterated over and individual products are rendered with relevant details, a link to the individual product page, and an <kbd>AddToCart</kbd> component, as shown in the following code.</p>
<p><kbd>mern-marketplace/client/product/Suggestions.js</kbd>:</p>
<pre>&lt;Typography type="title"&gt; {<strong>props.title</strong>} &lt;/Typography&gt;<br/>{<strong>props.products</strong>.map((item, i) =&gt; { <br/>  return &lt;span key={i}&gt; <br/>           &lt;Card&gt;<br/>             &lt;CardMedia image={'/api/product/image/'+item._id} <br/>                        title={item.name}/&gt;<br/>                &lt;CardContent&gt;<br/>                   &lt;Link to={'/product/'+item._id}&gt;<br/>                     &lt;Typography type="title" component="h3"&gt;<br/>                    {item.name}&lt;/Typography&gt;<br/>                   &lt;/Link&gt;<br/>                   &lt;Link to={'/shops/'+item.shop._id}&gt;<br/>                     &lt;Typography type="subheading"&gt;<br/>                        &lt;Icon&gt;shopping_basket&lt;/Icon&gt; {item.shop.name}<br/>                     &lt;/Typography&gt;<br/>                   &lt;/Link&gt;<br/>                   &lt;Typography component="p"&gt;<br/>                      Added on {(new <br/>                     Date(item.created)).toDateString()}<br/>                   &lt;/Typography&gt;<br/>                &lt;/CardContent&gt;<br/>                &lt;Typography type="subheading" component="h3"&gt;$ <br/>                 {item.price}&lt;/Typography&gt;<br/><span>                &lt;Link to={'/product/'+item._id}&gt;<br/>                  &lt;IconButton color="secondary" dense="dense"&gt;</span><br/>                    &lt;ViewIcon className={classes.iconButton}/&gt;<br/>                  &lt;/IconButton&gt;<br/>                &lt;/Link&gt;<br/>                &lt;AddToCart item={item}/&gt;<br/>           &lt;/Card&gt;<br/>         &lt;/span&gt;})}</pre>
<p>This <kbd>Suggestions</kbd> component can be reused to render any list of products to buyers, and in this section, we have discussed how to retrieve and display two different lists of products. Each product in the lists is linked to a view that will render details of the individual product. In the next section, we will look at the implementation of reading and displaying a single product to the end user.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Displaying a product</h1>
                </header>
            
            <article>
                
<p>Visitors to the MERN Marketplace will be able to view more details of each product in a separate view. In the following sections, we will implement a backend API to retrieve a single product from the database and then use it in the frontend to render the single product <span>in a React comp</span><span>onent</span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Read a product API</h1>
                </header>
            
            <article>
                
<p>In the backend, we will add an API with a <kbd>GET</kbd> route that queries the Products collection with an ID and returns the product in the response. The route will be declared as shown in the following code:</p>
<p><kbd>mern-marketplace/server/routes/product.routes.js</kbd>:</p>
<pre>router.route('/api/products/:productId')<br/>      .get(productCtrl.read) </pre>
<p>The<kbd>:productId</kbd> param in the URL invokes the <kbd>productByID</kbd> controller method, which retrieves the product from the database and appends it to the request object. The product in the request object is used by the <kbd>read</kbd> controller method to respond to the <kbd>GET</kbd> request. The read controller method is defined as follows:</p>
<p><kbd><span>mern-marketplace/server/controllers/product.controller.js</span></kbd>:</p>
<pre>const read = (req, res) =&gt; {<br/>  req.product.image = undefined<br/>  return res.json(req.product)<br/>}</pre>
<p>To use this read product API in the frontend, we will need to add a <kbd>fetch</kbd> method i<span>n </span><kbd>client/product/api-product.js</kbd><span>, similar to other API implementations. Then this <kbd>fetch</kbd> method can be used in the React component, which will render the individual product details, as discussed in the next section.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Product component</h1>
                </header>
            
            <article>
                
<p>We will add a React component named <kbd>Product</kbd> to render the individual product details, along with an <span class="packt_screen">add to cart</span> option. In this single product view, we will also show a list of related products, as pictured in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-828 image-border" src="assets/a73d395e-7600-4c12-92ac-955d2496864e.png" style="width:61.08em;height:20.67em;"/></div>
<p>The <kbd>Product</kbd> component can be accessed in the browser at the <kbd>/product/:productID</kbd> route, which is defined in <kbd>MainRouter</kbd> as follows:</p>
<p><kbd>mern-marketplace/client/MainRouter.js</kbd>:</p>
<pre>&lt;Route path="/product/:productId" component={Product}/&gt;</pre>
<p>The product details and the related product list data will be fetched by calling the relevant APIs with <kbd>useEffect</kbd> hooks using the <kbd>productId</kbd> specified in the route param, as shown in the following code:</p>
<p><kbd>mern-marketplace/client/product/Product.js</kbd>:</p>
<pre>export default function Product ({match}) {<br/>  const [product, setProduct] = useState({shop:{}})<br/>  const [suggestions, setSuggestions] = useState([])<br/>  const [error, setError] = useState('')<br/>    <strong>useEffect</strong>(() =&gt; {<br/>      const abortController = new AbortController()<br/>      const signal = abortController.signal<br/>  <br/>      <strong>read</strong>({productId: <strong>match.params.productId</strong>}, signal).then((data) =&gt; {<br/>        if (data.error) {<br/>          setError(data.error)<br/>        } else {<br/>          setProduct(data)<br/>        }<br/>      })<br/>    return function cleanup(){<br/>      abortController.abort()<br/>    }<br/>  }, [match.params.productId])<br/><br/>  <strong>useEffect</strong>(() =&gt; {<br/>    const abortController = new AbortController()<br/>    const signal = abortController.signal<br/><br/>        <strong>listRelated</strong>({<br/>          productId: <strong>match.params.productId</strong>}, signal).then((data) =&gt; {<br/>          if (data.error) {<br/>            setError(data.error)<br/>          } else {<br/>            setSuggestions(data)<br/>          }<br/>        })<br/>  return function cleanup(){<br/>    abortController.abort()<br/>  }<br/>}, [match.params.productId])</pre>
<p>In the first <kbd>useEffect</kbd> hook, we call the <kbd>read</kbd>  API to retrieve the specified product and set it to state. In the second hook, we call the <kbd>listRelated</kbd> API to get the list of related products and set it to the state to be passed as a prop to a <kbd>Suggestions</kbd> component added in the product view.</p>
<p>The product details part of the component displays relevant information about the product and an <kbd>AddToCart</kbd> component in a Material-UI <kbd>Card</kbd> component, as shown in the following code:</p>
<p><kbd><span>mern-marketplace/client/product/Product.js</span></kbd>:</p>
<pre>&lt;Card&gt;<br/>  &lt;CardHeader<br/><span>    action={</span><span>&lt;AddToCart cartStyle={classes.addCart} <br/>    item={product}/&gt;</span><span>}</span><br/>    title={product.name}<br/>    subheader={product.quantity &gt; 0? 'In Stock': 'Out of   <br/>   Stock'}<br/>  /&gt;<br/>  &lt;CardMedia image={imageUrl} title={product.name}/&gt;<br/>  &lt;Typography component="p" variant="subtitle1"&gt;<br/>    {product.description}&lt;br/&gt;<br/><span>    $ {product.price}</span><br/>    &lt;Link to={'/shops/'+product.shop._id}&gt;<br/>      &lt;Icon&gt;shopping_basket&lt;/Icon&gt; {product.shop.name}<br/>    &lt;/Link&gt;<br/>  &lt;/Typography&gt;<br/>&lt;/Card&gt;</pre>
<p>The <kbd>Suggestions</kbd> component is added in the <kbd>Product</kbd> view with the related list data passed as a prop, as shown next:</p>
<p><kbd><span>mern-marketplace/client/product/Product.js</span></kbd>:</p>
<pre>&lt;Suggestions products={suggestions} title='Related Products'/&gt;</pre>
<p><span>With this view complete, visitors to the marketplace application will be able to find out more about a specific product as well as explore other similar products. In the next section, we will discuss how to add the ability for shop owners to edit and delete the products they added to the marketplace.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Editing and deleting a product</h1>
                </header>
            
            <article>
                
<p>Implementations to edit and delete products in the application are similar to editing and deleting shops, as covered in the previous sections, <em>Editing a shop</em> and <em>Deleting a shop</em>. These functionalities will require the corresponding APIs in the backend, fetch methods in the frontend, and React component views with forms and actions. In the following sections, we will highlight the frontend view, route, and backend API endpoints for editing and deleting a product from the marketplace.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Edit</h1>
                </header>
            
            <article>
                
<p>The edit functionality is very similar to the create product functionality we implemented earlier. The <kbd>EditProduct</kbd> form component, which can be implemented to render a form that allows product detail modification, will also only be accessible by verified sellers at <kbd>/seller/:shopId/:productId/edit</kbd>.</p>
<p>To restrict access to this view, we can add a <kbd>PrivateRoute</kbd> in <kbd>MainRouter</kbd> to declare the route to the <kbd>EditProduct</kbd> view as follows:</p>
<p><kbd>mern-marketplace/client/MainRouter.js</kbd>:</p>
<pre>&lt;PrivateRoute path="/seller/:shopId/:productId/edit" component={EditProduct}/&gt;</pre>
<p>The <kbd>EditProduct</kbd> component contains the same form as <kbd>NewProduct</kbd>, but with populated values of the product retrieved using the read product API. On form submit, it uses a <kbd>fetch</kbd> method to send multipart form data with a PUT request to the edit product API in the backend at <kbd>/api/products/by/:shopId</kbd>. This backend route declaration for the edit product API will be as follows:</p>
<p><kbd><span>mern-marketplace/server/routes/product.routes.js</span></kbd>:</p>
<pre>router.route('/api/product/:shopId/:productId')<br/>      .put(authCtrl.requireSignin, shopCtrl.isOwner, productCtrl.update)</pre>
<p>The <kbd>update</kbd> controller method is invoked when an authorized user sends a PUT request to this API. It is similar to the product <kbd>create</kbd> method and the shop <kbd>update</kbd> method. It handles the multipart form data using <kbd>formidable</kbd> and extends the product details to save the updates to the database.</p>
<p>This implementation of an edit product form view integrated with an update API in the backend will allow shop owners to modify the details of products in their shops. Next, we will look at the highlights for integrating product deletion functionality to the application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Delete</h1>
                </header>
            
            <article>
                
<p>In order to implement the delete product functionality, we can implement a <kbd>DeleteProduct</kbd> component similar to the <kbd>DeleteShop</kbd> component, and add it to the <kbd>MyProducts</kbd> component for each product in the list. It can take the <kbd>product</kbd> object, <kbd>shopID</kbd>, and an <kbd>onRemove</kbd> method as a prop from <kbd>MyProducts</kbd>, as discussed in the <em>MyProducts component for shop owners</em> <span>section.</span></p>
<p>The component will function the same as <kbd>DeleteShop</kbd>, opening a dialog for confirmation on button-click and then, when the delete intent is confirmed by the user, calling the <kbd>fetch</kbd> method for delete, which makes the DELETE request to the server at <kbd>/api/product/:shopId/:productId</kbd>. This backend API for deleting a product from the database will be declared as follows with the other product routes:</p>
<p><kbd><span>mern-marketplace/server/routes/product.routes.js</span></kbd>:</p>
<pre>router.route('/api/product/:shopId/:productId')<br/>      .delete(authCtrl.requireSignin, shopCtrl.isOwner, productCtrl.remove)</pre>
<p>The <kbd>remove</kbd> controller method will be invoked if an authorized user makes the DELETE request to this API, and it will delete the specified product from the database, like the <kbd>remove</kbd> controller method for shops.</p>
<p>We started the implementation of the product-related features for the marketplace in this section by first defining a schema for storing product details and then discussing the full-stack slices for creating, listing, reading, updating, and deleting products in the application. In the next section, we will look into how to allow users in the marketplace to search for products in varied ways, so they can easily find the products they are looking for.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Searching for products with name and category</h1>
                </header>
            
            <article>
                
<p>In MERN Marketplace, visitors will be able to search for specific products by name and also in a specific category. In the following sections, we will discuss how this search functionality can be added by first looking at backend APIs that will retrieve the distinct categories from the Products collection, and perform the search query against the products stored. Then, we will discuss different cases for utilizing these APIs, such as a view to perform the search action and a view for displaying products by categories. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The categories API</h1>
                </header>
            
            <article>
                
<p>To allow users to select a specific category to search in, we will first set up an API that retrieves all the distinct categories present in the Products collection in the database. A <kbd>GET</kbd> request to <kbd>/api/products/categories</kbd> will return an array of unique categories, and this route is declared as shown here:</p>
<p><kbd><span>mern-marketplace/server/routes/product.routes.js</span></kbd>:</p>
<pre>router.route('/api/products/categories')<br/>      .get(productCtrl.listCategories)</pre>
<p>The <kbd>listCategories</kbd> controller method queries the Products collection with a <kbd>distinct</kbd> call against the <kbd>category</kbd> field, as shown in the following code:</p>
<p><kbd><span>mern-marketplace/server/controllers/product.controller.js</span></kbd>:</p>
<pre>const listCategories = async (req, res) =&gt; {<br/>  try {<br/>    let products = await Product.distinct('category',{})<br/>    res.json(products)<br/>  } catch (err){<br/>    return res.status(400).json({<br/>      error: errorHandler.getErrorMessage(err)<br/>    })<br/>  }<br/>}</pre>
<p>This categories API can be used in the frontend with a corresponding <kbd>fetch</kbd> method to retrieve the array of distinct categories and displayed in the view. This can be paired with a search API to allow users to search for products by its name in a specific category. In the next section, we will discuss this search API. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The search products API</h1>
                </header>
            
            <article>
                
<p>We can define a search products API that will take a <kbd>GET</kbd> request at <kbd>/api/products?search=value&amp;category=value</kbd>, with query parameters in the URL to query the Products collection with the provided search text and category values. The route for this search API will be defined as follows:</p>
<p><kbd><span>mern-marketplace/server/routes/product.routes.js</span></kbd>:</p>
<pre>router.route('/api/products')<br/>      .get(productCtrl.list)</pre>
<p>The <kbd>list</kbd> controller method will first process the query parameters in the request, then find products in the given category, if any, with names that partially match with the provided search text. This <kbd>list</kbd> method is defined as shown in the following code:</p>
<p><kbd>mern-marketplace/server/controllers/product.controller.js</kbd>:</p>
<pre>const list = async (req, res) =&gt; {<br/>  const query = {}<br/>  if(req.query.search)<br/>    query.name = {'$regex': req.query.search, '$options': "i"}<br/>  if(req.query.category &amp;&amp; req.query.category != 'All')<br/>    query.category = req.query.category<br/>  try {<br/>    let products = await Product.find(query)<br/>                                .populate('shop', '_id name')<br/>                                .select('-image').exec()<br/>    res.json(products)<br/>  } catch (err){<br/>    return res.status(400).json({<br/>      error: errorHandler.getErrorMessage(err)<br/>    })<br/>  }<br/>}</pre>
<p>The resulting products returned against the provided query parameters in the request are populated with shop details and downsized by removing the image field value, before being sent back in the response. To use this API in the frontend to perform a product search, we will need a <kbd>fetch</kbd> method that can construct the query parameters in the request URL, as discussed in the next section.  </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fetch search results for the view</h1>
                </header>
            
            <article>
                
<p>To utilize this search API in the frontend, we will set up a method that constructs the URL with query parameters and calls a fetch to make a request to the search product API. This <kbd>fetch</kbd> method will be defined as follows.</p>
<p><kbd>mern-marketplace/client/product/api-product.js</kbd>:</p>
<pre>import queryString from 'query-string'<br/>const list = (params) =&gt; {<br/>  const query = queryString.stringify(params)<br/>  return fetch('/api/products?'+query, {<br/>    method: 'GET',<br/>  }).then(response =&gt; {<br/>    return response.json()<br/>  }).catch((err) =&gt; console.log(err))<br/>}</pre>
<p>In order to construct the query parameters in the correct format, we will use the <kbd>query-string</kbd> node module, which will help stringify the params object into a query string that can be attached to the request route URL. The keys and values in this params object will be defined by the React component where we call this <kbd>list</kbd> method. Next, we will look at the <kbd>Search</kbd> component, which will utilize this method to enable the end user to search for products in the marketplace.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Search component</h1>
                </header>
            
            <article>
                
<p>The first use case for applying the categories API and search API together to perform a search action is in the <kbd>Search</kbd> component. This component, once implemented and functional, will render as shown in the following screenshot:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-829 image-border" src="assets/0c9b6d9c-46d2-4394-b9ec-ae4007260df1.png" style="width:40.33em;height:18.92em;"/></div>
<p>This <kbd>Search</kbd> component provides the user with a simple form containing a search input text field and a dropdown of the category options received from a parent component that will retrieve the list using the distinct categories API. The code to render this search form view will be as follows:</p>
<p><kbd>mern-marketplace/client/product/Search.js</kbd>:</p>
<pre>&lt;TextField id="select-category" select label="Select category" value={category}<br/>     onChange={handleChange('category')}<br/>     selectProps={{ MenuProps: { className: classes.menu, } }}&gt;<br/>  &lt;MenuItem value="All"&gt; All &lt;/MenuItem&gt;<br/>  {props.categories.map(option =&gt; (<br/>    &lt;MenuItem key={option} value={option}&gt; {option} &lt;/MenuItem&gt;<br/>        ))}<br/>&lt;/TextField&gt;<br/>&lt;TextField id="search" label="Search products" type="search" onKeyDown={enterKey}<br/>     onChange={handleChange('search')}<br/>/&gt;<br/>&lt;Button raised onClick={<strong>search</strong>}&gt; Search &lt;/Button&gt;</pre>
<p>Once the user enters a search text and hits <em>Enter</em>, we will make a call to the <kbd>search</kbd> method. To detect that the <em>Enter</em> key was pressed, we use the <kbd>onKeyDown</kbd> attribute on the <kbd>TextField</kbd> and define the <kbd>enterKey</kbd> handler method as follows:</p>
<p><kbd>mern-marketplace/client/product/Search.js</kbd>:</p>
<pre>const enterKey = (event) =&gt; {<br/>   if(event.keyCode == 13){<br/>     event.preventDefault()<br/>     search()<br/>   }<br/>}</pre>
<p>The <kbd>search</kbd> method makes a call to the search API using the <kbd>list</kbd> fetch method, providing it with the necessary search query parameters and values. This <kbd>search</kbd> method is defined as shown in the following code:</p>
<p><kbd>mern-marketplace/client/product/Search.js</kbd>:</p>
<pre>const search = () =&gt; {<br/>    if(values.search){<br/>      list({<br/>        search: values.search || undefined, category: values.category<br/>      }).then((data) =&gt; {<br/>        if (data.error) {<br/>          console.log(data.error)<br/>        } else {<br/>          setValues({...values, results: data, searched:true})<br/>        }<br/>      })<br/>    }<br/>}</pre>
<p>In this method, the query parameters provided to the <kbd>list</kbd> method are the search text value, if any, and the selected category value. Then the results array received from the backend is set to the values in state and passed as a prop to the <kbd>Products</kbd> component, as shown next, to render the matching products underneath the search form:</p>
<p><kbd>mern-marketplace/client/product/Search.js</kbd><span>:</span></p>
<pre><strong>&lt;Products products={results} searched={searched}/&gt;</strong></pre>
<p>This search view gives visitors a useful tool to look for the specific product they want among many that may be stored in the database for the complete marketplace. In the next section, we will look at another simple use case for utilizing the categories and search APIs in the frontend. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Categories component</h1>
                </header>
            
            <article>
                
<p>The <kbd>Categories</kbd> component is the second use case for the distinct categories and search APIs. For this component, we first fetch the list of categories in a parent component and send it as props to display the categories to the user, as shown in the following screenshot:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-830 image-border" src="assets/e0cdf37a-d434-45ff-9d28-ef6f24f8f4f7.png" style="width:38.25em;height:15.33em;"/></div>
<p>When the user selects a category in the displayed list, a call is made to the Search API with just a category value, and the backend returns all the products in the selected category. The returned products are then rendered in a <kbd>Products</kbd> component. This can be a simple way to combine these APIs and display meaningful products to buyers browsing through the marketplace.</p>
<p>In this first version of the MERN Marketplace, users can become sellers to create shops and add products, and visitors can browse shops and search for products, while the application also suggests products to the visitors.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we started building an online marketplace application using the MERN stack. The MERN skeleton was extended to allow users to have active seller accounts, so they can create shops and add products to each shop with the intention to sell to other users. We also explored how to utilize the stack to implement features such as product browsing, searching, and suggestions for regular users who are interesting in buying.</p>
<p>While going through the implementations in this chapter, we explored how to lay down the foundations with full-stack implementations to be able to combine and extend interesting features such as search and suggestions. You can apply these same approaches while building out other full-stack applications that may require these features. </p>
<p>Even with these features incorporated, a marketplace application is still incomplete without a shopping cart for checkout, order management, and payment processing. In the next chapter, we will grow our marketplace application to add these advanced features and learn more about how the MERN stack can be used to implement these core aspects of an e-commerce application.</p>


            </article>

            
        </section>
    </body></html>