- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Tracking Application State with Signals
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用信号跟踪应用程序状态
- en: Angular empowers developers to use built-in reactivity in their applications
    using **signals** . Angular signals are a synchronous approach to reactive programming
    that efficiently improves application performance and manages application state.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Angular通过**信号**赋予开发者使用其应用程序内内置反应性的能力。Angular信号是反应式编程的同步方法，它有效地提高了应用程序性能并管理应用程序状态。
- en: We met signals in previous chapters where we used the `input` method to exchange
    data between components and the `viewChild` method to query child components.
    The Signals API can be used in different parts of an Angular application, thus,
    its usage is scattered throughout the chapters of this book.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的章节中遇到了信号，当时我们使用`input`方法在组件之间交换数据，使用`viewChild`方法查询子组件。信号API可以在Angular应用程序的不同部分使用，因此，其使用分散在这本书的各个章节中。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding signals
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解信号
- en: Reading and writing signals
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取和写入信号
- en: Computed signals
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算信号
- en: Cooperating with RxJS
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与RxJS协作
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The chapter contains various code samples to walk you through the concept of
    Angular signals. You can find the related source code in the `ch07` folder of
    the following GitHub repository:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含各种代码示例，以向您介绍Angular信号的概念。您可以在以下GitHub仓库的`ch07`文件夹中找到相关源代码：
- en: '[https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition](https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition](https://www.github.com/PacktPublishing/Learning-Angular-Fifth-Edition)'
- en: Understanding signals
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解信号
- en: As we learned in *Chapter 3* , *Structuring User Interfaces with Components*
    , **Zone.js** plays a significant role in the performance of an Angular application.
    It triggers the Angular change detection mechanism when particular events occur
    inside the application. The framework checks every application component in each
    detection cycle and evaluates its bindings, degrading application performance.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在*第3章*，*使用组件构建用户界面*中学习的那样，**Zone.js**在Angular应用程序的性能中发挥着重要作用。当应用程序内部发生特定事件时，它会触发Angular的变更检测机制。框架在每次检测周期中检查每个应用程序组件，并评估其绑定，从而降低应用程序的性能。
- en: 'The rationale of change detection with Zone.js is based on the fact that Angular
    cannot know when or where a change has happened inside the application. Inevitably,
    Angular developers try to limit change detection cycles using the following techniques:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Zone.js的变更检测的原理是基于Angular无法知道应用程序内部何时或何地发生了变化。不可避免地，Angular开发者试图通过以下技术来限制变更检测周期：
- en: Configuring components with the `OnPush` change detection strategy
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`OnPush`变更检测策略配置组件
- en: Interacting manually with the change detection mechanism using the `ChangeDetectorRef`
    service
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ChangeDetectorRef`服务手动与变更检测机制交互
- en: Signals improve how developers interact with the Angular change detection mechanism
    by simplifying and enhancing the preceding techniques according to application
    needs.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 信号通过根据应用程序需求简化并增强先前的技术来改善开发者与Angular变更检测机制的交互。
- en: Angular signals provide more robust and ergonomic management of the change detection
    cycle based on reactivity. They watch how the application state changes and allow
    the framework to react by triggering change detection only in parts affected by
    the change.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Angular信号提供了基于反应性的更稳健和更人性化的变更检测周期管理。它们监视应用程序状态的变化，并允许框架通过仅在受变化影响的区域触发变更检测来做出反应。
- en: Signals are an innovative feature of the Angular framework that will enable
    further improvements in the application’s performance by introducing **zone-less
    applications** and **signal-based components** in the future.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 信号是Angular框架的一个创新特性，它将通过引入未来的**无Zone应用程序**和**基于信号的组件**来进一步提高应用程序的性能。
- en: Signals also act as containers for values, which the change detection mechanism
    must check. When a value changes, signals notify the framework about that change.
    The framework is responsible for triggering change detection and updating any
    signal consumers. A signal value can change either directly using **writable**
    signals or indirectly using read-only or **computed** signals.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 信号还充当值的容器，变更检测机制必须检查这些值。当值发生变化时，信号会通知框架该变化。框架负责触发变更检测并更新任何信号消费者。信号值可以通过**可写**信号直接更改，或者通过只读或**计算**信号间接更改。
- en: In the following section, we will learn how writable signals work.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习可写信号的工作方式。
- en: Reading and writing signals
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取和写入信号
- en: A writable signal is indicated by the `signal` type from the `@angular/core`
    npm package.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 可写信号由`@angular/core` npm包中的`signal`类型指示。
- en: You will need the source code of the Angular application we created in *Chapter
    6* , *Reactive Patterns in Angular* , to follow along with the rest of the chapter.
    After you get the code, we suggest you remove the `key-logger` folder for simplicity.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要我们在*第6章*，*Angular中的响应式模式*中创建的Angular应用程序的源代码，以便跟随本章的其余部分。在您获取代码后，我们建议您为了简化，删除`key-logger`文件夹。
- en: 'Let’s get started and learn how we can write a value in a signal:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始学习如何在信号中写入一个值：
- en: 'Open the `app.component.ts` file and import the `signal` artifact from the
    `@angular/core` npm package:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`app.component.ts`文件，并从`@angular/core` npm包中导入`signal`实体：
- en: '[PRE0]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Declare the following property in the `AppComponent` class as a `signal` and
    initialize it:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AppComponent`类中声明以下属性为`signal`并初始化它：
- en: '[PRE1]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Replace the `timestamp` variable in the `setTitle` property with the following
    snippet:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`setTitle`属性中的`timestamp`变量替换为以下代码片段：
- en: '[PRE2]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding snippet, we use the `set` method to write a new value in the
    signal. The method notifies the Angular framework that the value has changed,
    and it must run the change detection mechanism.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，我们使用`set`方法在信号中写入新值。该方法通知Angular框架值已更改，并且它必须运行变更检测机制。
- en: 'Modify the `title` property to use the value of the `currentDate` signal:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`title`属性修改为使用`currentDate`信号的值：
- en: '[PRE3]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding snippet, we call the `currentDate` getter method to read the
    value of the signal.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，我们调用`currentDate`获取器方法来读取信号的值。
- en: 'Signals are a great choice in cases where the speed and performance of an application
    matters, such as:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序的速度和性能很重要时，信号是一个很好的选择，例如：
- en: A dashboard page with widgets and live data that must be updated regularly,
    such as a stock exchange application.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含小部件和实时数据的仪表板页面，必须定期更新，例如股票交易应用程序。
- en: 'A component that needs to display properties from a large or complex object,
    such as the following:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要显示来自大型或复杂对象的属性组件，例如以下内容：
- en: '[PRE4]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this case, we can extract the object properties we want in a signal without
    involving the whole object in the change detection cycle, such as:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以在不涉及整个对象进入变更检测周期的情况下，从信号中提取我们想要的属性，例如：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A similar method of signals that also triggers change detection is the `update`
    method. It is used when we want to set a new value on a signal based on its current
    value:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 与信号类似的方法，也可以触发变更检测的是`update`方法。当我们要根据信号当前值设置新的信号值时使用它：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding snippet will get the value of the `currentDate` signal in the
    `d` variable and use it to return a new `Date` object.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段将获取`currentDate`信号在`d`变量中的值，并使用它来返回一个新的`Date`对象。
- en: In the following section, we will explore how computed signals behave in an
    Angular application.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨计算信号在Angular应用程序中的行为。
- en: Computed signals
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算信号
- en: A computed or read-only signal depends on other signals, writable or computed.
    The value of a computed signal cannot change directly using the `set` or the `update`
    method, it can only change indirectly when the value of any of the other signals
    changes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 计算信号或只读信号依赖于其他信号，无论是可写还是计算。计算信号的值不能直接使用`set`或`update`方法更改，它只能在其他信号的值更改时间接更改。
- en: 'Let’s see how it works:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何工作的：
- en: 'Open the `app.component.ts` file and import the `computed` and `Signal` artifacts
    from the `@angular/core` npm package:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`app.component.ts`文件，并从`@angular/core` npm包中导入`computed`和`Signal`实体：
- en: '[PRE7]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Change the type of the `title` component property to `Signal` :'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`title`组件属性的类型更改为`Signal`：
- en: '[PRE8]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `Signal` type indicates that the signal is a computed one.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`Signal`类型表示该信号是一个计算信号。'
- en: 'Remove the `title` assignment from the `setTitle` method and add it inside
    the `constructor` as follows:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`setTitle`方法中删除`title`赋值，并将其添加到`constructor`中，如下所示：
- en: '[PRE9]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding snippet, we use the `computed` function to set the value of
    the `title` signal. The value of the `title` signal depends on the `currentDate`
    signal. It is updated every 2 seconds when the value of the `currentDate` signal
    changes.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，我们使用`computed`函数设置`title`信号的值。`title`信号的值取决于`currentDate`信号。当`currentDate`信号的值更改时，它每2秒更新一次。
- en: 'Open the `app.component.html` file and modify the `<header>` HTML element as
    follows:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `app.component.html` 文件并按以下方式修改 `<header>` HTML 元素：
- en: '[PRE10]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Run the application using `ng serve` and verify that the title is updated correctly.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `ng serve` 运行应用程序并验证标题是否正确更新。
- en: 'Computed signals have great performance when it comes to more complicated calculations
    than the preceding one due to the following reasons:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之前的计算，计算信号在更复杂的计算方面具有优异的性能，原因如下：
- en: The computed function executes when the signal value is first read on the template
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算函数在模板中首次读取信号值时执行
- en: A new signal value is calculated only when the derived signals change
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有当派生信号发生变化时，才会计算新的信号值
- en: Computed signals use a cache mechanism to memoize values and return them without
    recalculating
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算信号使用缓存机制来记忆值并在不重新计算的情况下返回它们
- en: Although signals are a modern reactive approach for Angular, they are relatively
    new to the Angular ecosystem compared to RxJS. In the following section, we will
    learn how they can cooperate with RxJS in an Angular application.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管信号是 Angular 的现代反应式方法，但与 RxJS 相比，它们在 Angular 生态系统中相对较新。在下一节中，我们将学习它们如何在 Angular
    应用程序中与 RxJS 协作。
- en: Cooperating with RxJS
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 RxJS 协作
- en: 'Signals and RxJS empower Angular applications with reactive capabilities. These
    libraries can complement each other to provide reactivity while using the benefits
    of the Angular framework. Signals was not built to replace RxJS but to provide
    an alternate reactive approach to developers with the following additional characteristics:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 信号和 RxJS 为 Angular 应用程序赋予了反应式能力。这些库可以相互补充，在利用 Angular 框架优势的同时提供反应性。信号并非旨在取代
    RxJS，而是为开发者提供了一种具有以下额外特性的替代反应式方法：
- en: Fine-grained reactivity
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精细粒度反应性
- en: Imperative programming
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制性编程
- en: Improved usage of the change detection mechanism
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进了变更检测机制的用法
- en: However, there are core parts in the Angular framework that still use RxJS and
    observables, such as the HTTP client and the router. Additionally, many developers
    prefer the declarative approach that the RxJS library provides out of the box.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Angular 框架的核心部分仍然使用 RxJS 和可观察者，例如 HTTP 客户端和路由器。此外，许多开发者更喜欢 RxJS 库提供的开箱即用的声明式方法。
- en: At the time of writing, the Angular team is currently investigating and experimenting
    to make RxJS *optional* for Angular applications in the foreseeable future. They
    are also working to convert built-in APIs such as the HTTP client and router into
    signals.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Angular 团队目前正在调查和实验，以便在可预见的未来将 RxJS 作为 Angular 应用程序的**可选**组件。他们还在努力将内置
    API，如 HTTP 客户端和路由器，转换为信号。
- en: 'Angular Signals provides a built-in API to cooperate with RxJS and observables.
    The signals API provides a function that can convert an observable into a signal:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 信号提供了与 RxJS 和可观察者协作的内置 API。信号 API 提供了一个可以将可观察者转换为信号的功能：
- en: 'Open the `product-list.component.ts` file and import the `inject` and `toSignal`
    artifacts:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `product-list.component.ts` 文件并导入 `inject` 和 `toSignal` 依赖项：
- en: '[PRE11]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `@angular/core/rxjs-interop` npm package includes all the utility methods
    for handling signal and observable cooperation. The `toSignal` function can convert
    an observable into a signal.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`@angular/core/rxjs-interop` npm 包包括处理信号和可观察者协作的所有实用方法。`toSignal` 函数可以将可观察者转换为信号。'
- en: The `rxjs-interop` package also contains utility methods for converting a signal
    to an observable. You can read more in *Reactive Patterns with RxJS and Angular
    Signals* by Lamis Chebbi (Packt Publishing).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`rxjs-interop` 包还包含将信号转换为可观察者的实用方法。您可以在 Lamis Chebbi（Packt Publishing）的《使用
    RxJS 和 Angular 信号的反应式模式》中了解更多信息。'
- en: 'Create the following signal in the `ProductListComponent` class:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ProductListComponent` 类中创建以下信号：
- en: '[PRE12]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We pass two parameters in the `toSignal` function: the observable we want to
    convert and an initial value optionally. In this case, we pass the `getProducts`
    method of the `ProductService` class that returns an observable, and we also set
    the initial value of the signal to an empty array.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `toSignal` 函数中，我们传递两个参数：我们想要转换的可观察者和可选的初始值。在这种情况下，我们传递 `ProductService` 类的
    `getProducts` 方法，该方法返回一个可观察者，我们还设置了信号的初始值为空数组。
- en: 'Open the `product-list.component.html` file and modify its contents as follows:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `product-list.component.html` 文件并按以下方式修改其内容：
- en: '[PRE13]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding template, we removed the top `@if` block and converted the
    `products` property into a signal. We do not need the `async` pipe because signals
    subscribe automatically to an observable.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的模板中，我们移除了顶部的`@if`块，并将`products`属性转换成了一个信号。我们不需要`async`管道，因为信号会自动订阅到一个可观察对象。
- en: 'To further clean up our component, we can remove any code that is related to
    the `async` pipe and observables since it is no longer needed. The resulting `product-list.component.ts`
    file should be the following:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了进一步清理我们的组件，我们可以移除任何与`async`管道和可观察对象相关的代码，因为它们不再需要。结果`product-list.component.ts`文件应该是以下内容：
- en: '[PRE14]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Run the application using `ng serve` and observe that the application output
    displays the product list.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ng serve`运行应用程序，并观察应用程序输出显示产品列表。
- en: The preceding snippet looks much simpler. Angular signals improve the developer
    experience and ergonomics in addition to the performance of our applications.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段看起来简单多了。Angular信号不仅提高了我们应用程序的性能，还改善了开发者的体验和人体工程学。
- en: Summary
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored signals, which is a new reactive pattern in Angular
    that is used for managing application state. We learned their rationale and how
    they compare with Zone.js. We explored examples of how to read and write values
    into signals. We also learned how to create computed signals that depend on values
    from other signals.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了信号，这是Angular中一个新的响应式模式，用于管理应用程序状态。我们学习了其原理以及它们与Zone.js的比较。我们还探讨了如何将值读入和写入信号。我们还学习了如何创建依赖于其他信号值的计算信号。
- en: In the next chapter, we will learn how to use the Angular HTTP client and consume
    data from a remote endpoint.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用Angular HTTP客户端并从远程端点获取数据。
