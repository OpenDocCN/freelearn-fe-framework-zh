- en: Chapter 3. Developing Web Components Using Polymer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned how to install and configure the Polymer
    library in a web page. Now it is time to explore a few more useful features and
    learn to develop a custom element.
  prefs: []
  type: TYPE_NORMAL
- en: PolymerJS ready event
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Polymer library can be included to a page by importing a `polymer.html`
    file. Polymer checks each and every element definition that registers it asynchronously.
    If we try to render the element before this, it will create the **Flash of Unstyled
    Content** (**FOUC**) problem. To resolve this issue, we need to catch the `polymer-ready`
    event .We can hide the page elements before Polymer is ready, and once Polymer
    is ready, we can make them visible. The following code shows the use of the `polymer-ready`
    event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have two callback methods listening to `DOMContentLoaded`
    and `polymer-ready` events. In the callback code, the console logs the time when
    the event is fired. The following screenshot shows the output of the preceding
    code, showing the time when `DOMContentLoaded` and `polymer-event` are fired:'
  prefs: []
  type: TYPE_NORMAL
- en: '![PolymerJS ready event](img/image00259.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding screenshot, it is evident that once DOM is loaded, Polymer
    starts registering the element, and once it is completed, it fires the `polymer-ready`
    event.
  prefs: []
  type: TYPE_NORMAL
- en: Polymer expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The separation of concern during development is an age-old topic of discussion.
    The goal of separation concern is to separate the rendering logic from the markup.
    It reduces the code maintenance cost and increases productivity. Polymer provides
    expression features that can be used inline with HTML code, while the computation
    logic is present in another JavaScript file. The syntax for a Polymer expression
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding syntax, the Polymer expression is wrapped around two curly
    braces. There are a few points to note down about Polymer expression:'
  prefs: []
  type: TYPE_NORMAL
- en: Polymer expression is used as inline with HTML code for simple text value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymer expression should not be used for HTML value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Eval` method cannot be used inside the expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Polymer supports many operations for working with expression. These operations
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Identifiers and paths**: This represents the object and the properties present
    inside the current page scope. Normally, paths are represented using dot (`.`)
    operator. The following code shows an example of identifier and paths:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Array access**: This represents the members present inside an array object.
    Normally, array access can be represented using a square (`[]`) bracket. The following
    code shows an example of array access:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Logical not operator**: This represents the Boolean operator to negate the
    truth value. The following code shows an example of not operator:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Unary operators**: This represents the unary operators like `+` and `–` to
    work with single operand. The following code shows an example of unary operator:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Binary operators**: This represents the binary operators to work with two
    operands. The following code shows an example of binary operator:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Comparators**: This represents `<, >`, `<=, >=`, `==`, `!=`, `===`, `!==`,
    and returns a Boolean value. The following code shows an example of comparator:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Logical comparators**: This represents logical operators like AND (`&&`)
    and OR(`||`), and returns a Boolean value. The following code shows an example
    of logical comparator:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Ternary operator**: This represents ternary operators like the `if` condition.
    The following code shows an example of ternary operator:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Parenthesis**: This helps in grouping the expression to be evaluated. The
    following code shows an example of parenthesis:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Literal values**: This represents literal identifiers like null and undefined.
    The following code shows an example of literals:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Array and object initializers**: This represents the anonymous array and
    object declaration. The following code shows an example of array initializer:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Function**: A function can be called using Polymer expression. The following
    code shows an example of a function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: To find out more about Polymer expression, refer to [https://www.polymer-project.org/docs/polymer/expressions.html](https://www.polymer-project.org/docs/polymer/expressions.html).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can also use filters on the Polymer expression. Before jumping into filter
    expression, let's learn about the Polymer template with auto-binding. The reason
    for looking at auto-binding first is that the examples in the coming section are
    independent and run in the current page scope.
  prefs: []
  type: TYPE_NORMAL
- en: Polymer templating with auto-binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 1](lrn-web-cmpn-dev_ch01.html#aid-DB7S1 "Chapter 1. Introducing
    Web Components"), *Introducing Web Components*, we learned about the `<template>`
    element defined in the W3C web component specification. Polymer adds some additional
    features, such as expressions and template binding. This means we can use expressions
    inside a template, which can be rendered to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: The Polymer templating works differently than the traditional templating. The
    DOM model of a template instance remains in the browser as long as the respective
    data is in use. If there are any changes to the data, then Polymer compares and
    modifies the specific part of DOM. It results in the smallest changes into the
    DOM tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'Polymer templating can be used on a page level by using the auto-binding feature.
    As we know, the `<template>` content is inert in nature until it is activated.
    Polymer template comes with a solution called auto-binding, where the template
    gets activated by considering the template, and the data model is present on the
    template itself. A template can be used as auto-bound by using the `is` attribute
    auto-binding value. The syntax for the auto-binding a template is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check out a simple example of auto-binding a template. The code for
    the usage of the auto-binding feature is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the template has an auto-binding property and some content
    within the `h1` element. If we run this code in a browser, the `<template>` element
    gets activated due to the auto-binding feature, and then the content is rendered.
    The following screenshot shows the output and HTML inspection of the preceding
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Polymer templating with auto-binding](img/image00260.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, we can see that the HTML instance markup generated
    by the template is appended just after it. This is a unique feature of a template
    with auto-binding. The `<template>` element has the bind property attached to
    itself as the template is auto-bound.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To find out more about the Polymer template auto-binding feature, refer to [https://www.polymer-project.org/docs/polymer/databinding-advanced.html#autobinding](https://www.polymer-project.org/docs/polymer/databinding-advanced.html#autobinding).
  prefs: []
  type: TYPE_NORMAL
- en: Polymer template attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Polymer provides additional features to the `<template>` element to make it
    more useful. Polymer derives its templating mechanism from the `TemplateBinding`
    library. You can find more details about this library at [https://github.com/polymer/TemplateBinding](https://github.com/polymer/TemplateBinding).
    It provides many useful attributes to help in data binding. These attributes are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bind`: This attribute can be used to bind a template to a JavaScript object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`repeat`: This attribute can be used to iterate a template by binding the template
    to a list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if`: This attribute can be used to check a logical condition by comparing
    a property of the bound JavaScript object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ref`: This attribute can be used to include another template in the current
    template. The `ref` attribute takes the ID of other templates to include it to
    the current template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s check out an example to help understand the use of these attributes
    in a template element. The following code shows the use of these attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The details of the preceding code are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The template element with the `template1` ID has the `myData` model, which has
    the `myFlag` property with true Boolean value. The template has the `if` attribute,
    which checks the `myFlag` value and displays the HTML content of `template1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The template element with the `template2` ID has the `students` model containing
    an array of names. The `template2` element has the `repeat` attribute to iterate
    the array of names to render in the browser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The template element with the `template3` ID is bound with the `subjects` model
    containing objects having `name` and `country` property. The `template3` ID contains
    another nested template, which is bound to the `sub` instance of subject to display
    `name` and `country` values inside it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The template element with the `template5` ID has the `ref` attribute referring
    to `template4`. The `template4` ID has a text message wrapped inside the `h1`
    element. On activation of the `template5` element, the contents of `template4`
    are included and rendered in the browser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The output of the preceding code is listed in the following screenshot, which
    shows the use of the mentioned attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Polymer template attributes](img/image00261.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows the Chrome developer console, showing template
    attributes in action, and the generated HTML instances are inserted just after
    the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Polymer template attributes](img/image00262.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Filtering expression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Polymer provides filter support to work with the expression. Filters are useful
    to modify the output of an expression. The syntax of using filter with an expression
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, an expression and filter is combined using a bar (`|`)
    symbol. The filter function takes the value of the given expression and modifies
    it based on the filter logic, and then renders it in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in filtering expression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Polymer has two built-in filters to work with the expression. These two predefined
    filters are `tokenList` and `styleObject`. Let's explore these built-in filters
    in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: The TokenList filter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `tokenList` filter can be used for adding and removing a string based on
    the supplied object. It is a really good fit to programmatically modify the class
    names. However, for demonstration, we have used a string. The following code shows
    the use of the `tokenList` filter with an expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The details of the preceding code are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, `template1` is attached with the `student` object having
    two properties—`name` and `score`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside `template1`, the score of the student is compared against a passing marks
    `60` with the built-in filter `tokenList`. If the score is more than `60`, the
    **Passed** string is rendered in place of an expression.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following screenshot shows the output of the preceding code containing the
    name of the student, score of the student, and their result. The score of the
    student is `70`, and compared with the pass mark of `60`, it returns true and
    the **Passed** string is rendered in a browser.
  prefs: []
  type: TYPE_NORMAL
- en: '![The TokenList filter](img/image00263.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The styleObject filter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `styleObject` filter is used for converting a JSON object into a string
    of key value pair. This filter is a good fit for working with the `style` attribute
    of an element. The following code shows the use of the `styleObject` filter with
    an expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The details of the preceding code are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `myStyle` property of the student object has a set of key/value pairs, containing
    CSS properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The template expression is used with the `styleObject` filter to convert the
    key/value pairs to complete the CSS string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The output of the preceding code is listed in the following screenshot, where
    we can see that the `myStyle` object''s key/value pairs are converted to CSS string
    and gets applied to the `style` attribute of the `div` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The styleObject filter](img/image00264.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Custom filtering expression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Polymer supports development of our own custom filters to be used in the expression.
    Let''s check out an example of creating a custom filter. The code for creating
    a custom filter and its use is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The details of the preceding code are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `template1` variable has an expression for displaying the name of the student
    with a custom filter named `sayHello`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The definition of the `sayHello` filter method is present as a value of the
    `sayHello` attribute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `sayHello` filter method takes an expression value and prepends the `Hello`
    text before the name of the student
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of the preceding code, where the
    **Hello** string is prepended to the name **Sandeep** due to the `sayHello` filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom filtering expression](img/image00265.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Global filtering expression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Polymer supports defining global filters to increase their reusability. A global
    filter is available as an API to the application developer. A global filter can
    be created by using the `PolymerExpression` object. A new filter can be added
    to the Polymer by creating a new property of the `PolymerExpression` object by
    using the `prototype` attribute. The code for creating a global filter is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, a global filter named `sayBye` is created by defining
    a new property in `PolymerExpression.prototype`. The output of the preceding code
    is listed in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Global filtering expression](img/image00266.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Developing Polymer custom elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Polymer has built-in elements—core and paper. Polymer also supports development
    of our own custom element. Some of the benefits of developing custom elements
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: They are reusable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They reduce the code size of the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They increase the developer's productivity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They help in achieving encapsulation by hiding the definition of the element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: In Polymer, everything is an element.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the following section, we will learn to develop a custom element. The steps
    for developing a custom element are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining a custom element
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Defining element attributes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Defining default attributes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Defining public properties and methods
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Publishing properties
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Defining a lifecycle method
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Registering a custom element
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Defining a custom element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A custom element can be defined using the `<polymer-element>` tag. The code
    syntax for developing a custom element is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The details of the preceding syntax are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, a custom element definition has been wrapped within the
    `<polymer-element>` tag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The definition contains the `<template>` element containing the HTML markup
    for the custom element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The definition also contains the `<script>` element containing the properties
    and methods for the custom element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `<polymer-element>` tag takes the following attributes while defining a
    new custom element:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Name`: This is a required field and represents the name of the custom element.
    The name must be separated with a hyphen (`-`).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Attributes`: This is an optional field and can be used for defining the attribute
    that the custom element can have.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Extends`: This is an optional field and can be used for extending another
    element through inheritance.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Noscript`: This is an optional attribute and can be used by a custom element
    while defining an attribute, when it does need any properties and methods. Put
    more simply, it creates a simple element that has only name and constructor.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Constructor`: This is an optional attribute and represents the name of the
    constructor that can be used by the programmer to create a new instance of the
    custom element, using the `new` keyword.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining element attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Custom attributes can be defined using the attribute property of `<polymer-element>`.
    This can take multiple attribute names separated by a *space*. A property defined
    inside the attribute property is published by default .The syntax of the attribute
    declaration is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Defining default attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can define default attributes to a custom element. The default attributes
    directly get attached with the custom element while rendering. The syntax for
    defining a default attribute is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code a default property named `myDefaultProperty1` is defined.
    To define any default properties just add the name to the `<polymer-element>`
    element as an attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Defining public properties and methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can define public properties and methods for a custom element while also
    defining it. The following code shows the syntax of declaring public properties
    and methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The details of the preceding code are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the mentioned definition, `message` is a property with a `get` methods `greeting`
    function. The `get` method can access the message property with the `this` keyword.
    The `this` keyword refers to the custom element `<tag-name>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the previous definition, the `sayBye` method is a public function and returns
    a `Bye` string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The properties defined inside the attribute are by default public. There is
    another way to publish the properties of a custom element—using the `publish`
    attribute. The syntax for publishing properties is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, `property1` and `property2` are published using the
    `publish` keyword. Publishing properties using the attribute approach is the preferable
    way, as it follows a declarative method. However, the use of the publish keyword
    approach can be selected in if the following statements are true:'
  prefs: []
  type: TYPE_NORMAL
- en: If there are long lists of attributes that need to be published for a custom
    element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we need to define default values for the properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we need two-way declarative binding to a published property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining a lifecycle method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Polymer element goes through different states during its lifecycle. The
    following diagram shows the possible states of a custom element:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining a lifecycle method](img/image00267.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The different states of a custom element are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Created**: This is the state when an instance of the custom element is created'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ready**: This is the state when the shadow DOM is ready, event listeners
    are attached, and the property observers are set up'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attached**: This is the state when the custom element is attached to the
    DOM'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DOMReady**: This is the state when the initial sets of custom element children
    are exists in DOM'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AttributeChanged**: This is the state when one of the attribute values is
    changed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Detached**: This is the state when the custom element is removed from the
    DOM'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The syntax of the callback methods for the lifecycle states, to define our
    own custom logic, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding syntax, we can see the callback method representing each lifecycle
    state of a custom element.
  prefs: []
  type: TYPE_NORMAL
- en: Registering a custom element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The native way of defining a custom element is using the `Polymer` method in
    the `<polymer-element>` tag. The syntax of registering an element is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Developing a sample custom element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, it is time to develop a simple `<say-hello>` element with a `mytext` attribute
    with the default text `World!!!` and a template to render in the browser. The
    code definition for the `<say-hello>` element is present inside the `hello-component.html`
    file and is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The details of the preceding code are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A new custom element `<say-hello>` is defined using the `<polymer-element>`
    tag.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The custom element has the `mytext` attribute, which is published as public
    and initialized with a default value `world` using the `created` callback method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The custom element has a constructor named `SayHello`. By using this constructor,
    we can programmatically create an instance of a `SayHello` element using the `new`
    keyword. The syntax for using a `new` keyword is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following code shows the use of the `<say-hello>` element in an HTML page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have called the `<say-hello>` element in the following
    three different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Without the `mytext` attribute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the `mytext` attribute value as `John`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the JavaScript constructor `new SayHello` and assigning the `mytext` property
    to the `Polymer` string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The output of the preceding code is shown in the following screenshot with
    three different message generated by the `<say-hello>` element used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Developing a sample custom element](img/image00268.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Extending a custom element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A custom element can be extended from another element using the `extends` attribute.
    We can only extend from one element at a time. Let''s develop an element named
    `<say-good>`, which is extended from `<say-hello>`. The following code presents
    the `good-component.html` file and has the definition of `<say-good>` custom element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The details of the preceding code are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A new custom element named `<say-good>` is created by extending the `<say-hello>`
    element with a published property named `time`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default value of the `time` property is assigned to `Morning` using the
    `created` callback method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The template of the `<say-good>` element contains a **shadow insertion point**
    for the parent element markup with a text message `Good` and an expression `{{time}}`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code shows the use of the `<say-good>` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The details of the preceding code are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `<say-good>` element is called using `mytext` and the `time` attribute with
    values `John` and `Night`, respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An object of the `SayGood` element is initialized using its constructor with
    the `new` keyword. The `mytext` object property and time is then assigned with
    values `Smith` and `Afternoon`, respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The output of the preceding code is shown in the following screenshot, which
    shows the message from the parent element `<say-hello>` inserted in the shadow
    insertion point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Extending a custom element](img/image00269.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Polymer methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The PolymerJS library has some utility methods to deal with mixins, imports,
    and element registration. In the following section, we will learn how to use these
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: The Polymer mixin method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Polymer provides mixins for sharing common methods among custom elements. Mixin
    helps to reduce duplicate code. The syntax for creating a mixin is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check out an example of sharing common methods using mixins. The details
    of the example are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The common mixin methods are present in the `common-mixin.html` file. The `window.commonMixins`
    object will contain the shared methods. The code for the `common-mixin.html` file
    is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `commonMixins` object has a `printMyName` method and is shared to the custom
    components, which use it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A new custom component `<print-hi>` is defined in the `printHi-component.html`
    file. The `<print-hi>` element has used the `commonMixins` object. The following
    code shows the definition of the `<print-hi>` component:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Another custom element `<print-bye>` has been defined in the `printBye-component.html`
    file. This component also uses the `commonMixins` object to get access to the
    `printMyName` method. The `printMyName` method returns the local name of the custom
    element. The code for the `<print-bye>` element is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, it is time to test the mixin methods shared by these elements. The test
    code is present in `mixin-demo.html`. In this code, we have created two objects—one
    from the `PrintHi` constructor and the other is from the `PrintBye` constructor
    using the `new` keyword. Then, the `printMyName` name is called from each object,
    which is logged in the console. The following code contains the test code for
    checking the mixin methods:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The complete code can be downloaded from Packt's website. The following screenshot
    shows the output of the preceding code:![The Polymer mixin method](img/image00270.jpeg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Polymer import method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Polymer provides the `Polymer.import` method for importing the external HTML
    file. Let''s check out an example of using the `import` method. The details of
    the example are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `number-detail.html` file contains a JavaScript file containing a variable
    `luckyNumber` assigned a value `7`. The code present inside the `number-detail.html`
    file is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `number-detail.html` file has been imported in the `import-method.html`
    file . Once the `number-detail.html` file is imported the lucky number is displayed
    in the browser as the template is using auto-binding feature. The following code
    shows the import of the `number-detail.html` file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The following screenshot shows the output of the preceding code, where the lucky
    number 7 is rendered in the browser:![The Polymer import method](img/image00271.jpeg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Polymer waitingFor method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Polymer provides the `waitingFor` method to detect the unregistered element
    in the application. This method returns a list of elements that are not registered
    yet. Let''s check out an example that demonstrates the usage of the `waitingFor`
    method. The details of the example are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A custom component `<good-morning>` is created, and intentionally we have delayed
    the registration for 3 seconds using the `setTimeout` method. Code for the `<good-morning>`
    element is present in the `morning-component.html` file and is listed as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In another HTML file, we have used the `waitingFor` method to check whether
    it contains the `<good-morning>` element inside the array during the initial 3
    seconds. The following code shows the use of the `waitingFor` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The following screenshot shows the output of the preceding code, which logs
    the unregistered element in a console:![The Polymer waitingFor method](img/image00272.jpeg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Polymer forceReady method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Polymer provides the `forceReady` method to notify Polymer to register all
    the elements to the DOM. Let''s check out an example that demonstrates the usage
    of the `forceReady` method. The code for the example is present in the `evening-component.html`
    file and the details are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A new custom component `<good-evening>` is created and intentionally delays
    the registration for 3 seconds. The following code contains the definition of
    the `<good-evening>` element:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In another HTML file, we have used the `forceReady` method to register all
    the custom elements. A callback method `Polymer.whenReady` is then called, which
    tries to register the `<good-evening>` element. The following code contains the
    use of the `forceReady` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As the `<good-evening>` element method is already registered due to use of the
    `forceReady` method, when we call the registration process again using `Polymer('good-evening')`,
    it will throw an error saying, it is already registered. The following screenshot
    shows the output of the preceding code with an error message logged in the console:![The
    Polymer forceReady method](img/image00273.jpeg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous task execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Polymer provides a method named `async`, which helps with the execution of
    a code block after a curtailed period of time. The syntax of the `async` method
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check out an example demonstrating the use of `async` method. The details
    of the example are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A new custom element `<my-text>` is created with the message property initialized
    to `Hello` in a `ready` block. An `async` method is used which will be executed
    after 2 seconds and another string is appended to the `message` property. The
    code for this example is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The output of the preceding code is shown in the following screenshot, with
    two strings appended after 2 seconds of page rendering:![Asynchronous task execution](img/image00274.jpeg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: To find out more about the `async` method, refer to [https://www.polymer-project.org/docs/polymer/polymer.html#asyncmethod](https://www.polymer-project.org/docs/polymer/polymer.html#asyncmethod).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Developing a digital clock
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we have learned about many concepts of Polymer. Now,
    it is time to develop a custom component. We will develop a digital clock that
    we have already created in [Chapter 1](lrn-web-cmpn-dev_ch01.html#aid-DB7S1 "Chapter 1. Introducing
    Web Components"), *Introducing Web Components*. In this section, we will develop
    the same digital clock using Polymer. The code definition of a digital clock is
    present in the `clock-component.html` file and is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The details of the preceding code are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the digital clock is `<ts-clock>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The HTML markup is the same as that we used in the [Chapter 1](lrn-web-cmpn-dev_ch01.html#aid-DB7S1
    "Chapter 1. Introducing Web Components"), *Introducing Web Components*, containing
    three `div` elements as a place holder for hours (HH), minutes (MM), and seconds
    (SS).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The template is bound to the `clock` object using the `bind` attribute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The definition of the digital clock contains an `updateClock` method, which
    creates the `clock` object containing three properties—hour, minute, and second—which
    get the value from a `new Date()` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `updateClock` method is called recursively and asynchronously using the
    `this.async` method after 1 second. It means that every 1 second, the `clock`
    object gets updated with new values, which, in turn, updates the template.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code shows the use of the `<ts-clock>` element in another HTML
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of the preceding code with the current
    time in hours, minutes, and seconds format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Developing a digital clock](img/image00275.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Working with Yeoman
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 2](lrn-web-cmpn-dev_ch02.html#aid-PNV61 "Chapter 2. Introducing
    Polymer"), *Introducing Polymer*, we installed Yeoman and explored some of the
    usage of Polymer. In this section, we will find more of them to work with Polymer.
    The `generator-polymer` module can be installed using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Considering that we have already installed Yeoman and `generator-polymer`, let's
    learn about the element, seed, and GitHub page generator.
  prefs: []
  type: TYPE_NORMAL
- en: Yeoman element generator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Yeoman provides an element generator to create a skeleton of a custom element.
    The command for generating a skeleton of a custom element is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The details of the preceding command are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the custom element is `my-element`. We can provide our own name,
    which must be separated with a hyphen(`-`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The directory structure created by this command is `app/elements/elements.html`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create a custom element `<say-time>` using Yeoman element generator.
    The command for generating a skeleton of the `<say-time>` element is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the terminal with Yeoman element generator in
    effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Yeoman element generator](img/image00276.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'On successful execution of the preceding command, it creates a directory structure
    `app/element/say-time.html`. The skeleton of the generated custom element for
    the `<say-time>` element is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'There are few changes we need to make to adjust the library path, and some
    code needed for our chapter demonstration. We have overridden the created callback
    method by assigning the `currentTime` attribute with a `new Date` object. The
    modified code of the `<say-time>` component is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code shows the use of the `<say-time>` custom element in a current
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is rendered as the following screenshot, showing
    the current time due to the expression `{{currentTime}}` in the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Yeoman element generator](img/image00277.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Yeoman seed generator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Yeoman Seed generator is used for developing a reusable element. It creates
    all the necessary boilerplate directories and files needed to publish a new custom
    element. The command for running a seed generator is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the terminal with a seed generator in effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Yeoman seed generator](img/image00278.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the preceding command is executed successfully, a directory structure
    is created for developing a reusable component, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Yeoman seed generator](img/image00279.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'After the directory structure is generated, we can modify the definition of
    the `<display-year>` custom element in the `display-year.html` file. We have overridden
    the `created` callback method with the `currentYear` property. The modified code
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The modified template for the `<display-year>` element is as follows, with
    the added expression `{{currentYear}}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: You can find the complete source code containing all the directory structures
    with dependent files from Packt's website.
  prefs: []
  type: TYPE_NORMAL
- en: Yeoman GitHub page generator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This generator is used for creating a GitHub page for the custom element. The
    syntax of the command for the GitHub page generator is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the terminal with the GitHub page generator
    in execution for the `<display-year>` custom element:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Yeoman GitHub page generator](img/image00280.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To find out more about the GitHub page generator, refer to [https://github.com/yeoman/generator-polymer#gh](https://github.com/yeoman/generator-polymer#gh).
  prefs: []
  type: TYPE_NORMAL
- en: Preparing for production using vulcanize
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Polymer-based web application development, we may find a situation where
    we need to use a lot of HTML Import for a web page. Each HTML Import is an HTTP
    call to the server. This can really hamper the application performance, and definitely
    the application is not a good candidate for production deployment. This problem
    can be solved by a vulcanize process that makes the Polymer application a more
    durable and production-ready application.
  prefs: []
  type: TYPE_NORMAL
- en: Vulcanize installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Node package manager** (**npm**) is required before installing the **vulcanize**
    package. Considering npm is present in the system, use the following command to
    start the installation of vulcanize:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will install vulcanize globally. The following screenshot
    shows the terminal with the vulcanize installation process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Vulcanize installation](img/image00281.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Running vulcanize process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once vulcanize is installed in the system, we can run the process to optimize
    the files, to make them production ready. The syntax of the vulcanize command
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The vulcanize process concatenates the files into a single file for deployment.
    The following screenshot shows the vulcanize process in progress for the `clockDemo.html`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running vulcanize process](img/image00282.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: On completion of the preceding command, the `build.html` file is generated,
    which concatenates the dependent files. Now, the `build.html` file is optimized
    and ready for production. Vulcanize is also available as Grunt and Gulp tasks
    as well. Take a look at [https://www.npmjs.com/package/grunt-vulcanize](https://www.npmjs.com/package/grunt-vulcanize)
    for the `grunt-vulcanize` package and [https://www.npmjs.com/package/gulp-vulcanize](https://www.npmjs.com/package/gulp-vulcanize)
    for the `gulp-vulcanize` package.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To find out more about the vulcanize process, refer to [https://github.com/Polymer/vulcanize](https://github.com/Polymer/vulcanize).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the key concepts of the Polymer library such
    as expression, filter expression, and element lifecycle. You have also explored
    custom element development using the Polymer library, followed by a sample digital
    clock development. In the next chapter, you will learn about Bosonic framework.
  prefs: []
  type: TYPE_NORMAL
