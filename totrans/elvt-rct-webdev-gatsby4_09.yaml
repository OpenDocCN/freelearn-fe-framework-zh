- en: '*Chapter 7*: Testing and Auditing Your Site'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*: 测试和审计您的网站'
- en: In this chapter, we will learn about what unit testing is, why it's useful,
    and how to start unit testing your Gatsby site. We will then learn how we can
    use Git hooks to trigger your unit tests and other commands when running common
    Git commands. Following this, we will investigate how we can measure core web
    vitals to understand how well our Gatsby site's page experience is performing,
    both in lab and field environments. By the end of this chapter, you should feel
    comfortable that you can analyze how well a Gatsby site is working locally by
    using unit tests and looking at web vitals when it is out there on the web.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解单元测试是什么，为什么它有用，以及如何开始对您的Gatsby网站进行单元测试。然后我们将学习如何使用Git钩子在运行常见的Git命令时触发单元测试和其他命令。接着，我们将研究如何测量核心Web指标，以了解我们的Gatsby网站页面体验在实验室和现场环境中的表现情况。到本章结束时，您应该能够舒适地分析Gatsby网站在本地运行得如何，通过使用单元测试并在网站上查看Web指标。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Exploring unit testing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索单元测试
- en: Adding Git hooks for tests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为测试添加Git钩子
- en: Auditing core web vitals
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审计核心Web指标
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To complete this chapter, you will need to have completed [*Chapter 6*](B15983_06_ePub_RK.xhtml#_idTextAnchor092),
    *Improving Your Site's Search Engine Optimization*. You will also need Google
    Chrome installed.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章，您需要完成[*第6章*](B15983_06_ePub_RK.xhtml#_idTextAnchor092)，*提高您的网站搜索引擎优化*。您还需要安装Google
    Chrome。
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter07](https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter07).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在[https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter07](https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter07)找到。
- en: Exploring unit testing
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索单元测试
- en: Unit testing is a way of testing the smallest piece of code that you have logically
    defined within your application. During unit testing, we isolate a small part
    of the code and verify that it is behaving as intended independently from the
    rest of the code base. We instantiate this piece of code, invoke it, and then
    observe its behavior. If the observed behavior matches what we expected, then
    we know that our code is doing what it should be. By setting up a multitude of
    these tests, we can have a better understanding of where something has broken
    when we edit large parts of the code base.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是一种测试您在应用程序中逻辑上定义的最小代码片段的方法。在单元测试期间，我们将一小部分代码隔离出来，并验证它是否独立于代码库的其余部分按预期行为。我们实例化这段代码，调用它，然后观察其行为。如果观察到的行为与我们预期的相符，那么我们知道我们的代码正在做它应该做的事情。通过设置大量的这些测试，我们可以更好地了解在编辑代码库的大部分内容时，哪里出了问题。
- en: 'Within React and Gatsby, there are multiple different ways in which you can
    set up unit tests. Here, we will focus on one of the most popular combinations
    – **Jest** and **React Testing Library**. Let''s create a structure within our
    repository that will allow us to test our site using these tools:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在React和Gatsby中，有多个不同的方式可以设置单元测试。在这里，我们将关注最受欢迎的组合之一——**Jest**和**React Testing
    Library**。让我们在我们的仓库中创建一个结构，以便我们可以使用这些工具测试我们的网站：
- en: 'Install the necessary dependencies:'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装必要的依赖项：
- en: '[PRE0]'
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a `jest.config.js` file:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `jest.config.js` 文件：
- en: '[PRE1]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Both Gatsby and Jest use Babel under the hood. However, unlike Gatsby, Jest
    does not handle its own Babel configuration. We use the `jest.config.js` file
    to manually set up Jest with Babel, as well as configure our tests.
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Gatsby和Jest都在底层使用Babel。然而，与Gatsby不同，Jest不处理自己的Babel配置。我们使用`jest.config.js`文件手动设置Jest与Babel，以及配置我们的测试。
- en: 'Let''s break down the contents of this file so that we understand what each
    part is doing:'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们分解这个文件的内容，以便我们了解每个部分的作用：
- en: 'a. `transform`: This tells Jest that all the files that end in `.js` or `.jsx`
    need to be handled with a `jest-preprocess.js` file, which we will create in the
    next step.'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. `transform`：这告诉Jest，所有以`.js`或`.jsx`结尾的文件都需要用`jest-preprocess.js`文件处理，我们将在下一步创建这个文件。
- en: 'b. `moduleNameMapper`: When testing, it is uncommon to test static assets such
    as images. As such, Jest does not care for them. But it is still important that
    it knows how to handle them as they may be embedded in your code. Here, we are
    giving Jest a mock for handling stylesheets that uses the `identity-obj-proxy`
    package, which we installed in the first step, and another mock that handles common
    image, video, and sound files. We will create this second mock later in this section.'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'b. `moduleNameMapper`: 在测试时，测试静态资产（如图像）是不常见的。因此，Jest 不关心它们。但是，它仍然很重要，因为它需要知道如何处理它们，因为它们可能嵌入到您的代码中。在这里，我们为
    Jest 提供了一个处理样式的模拟，该模拟使用我们在第一步中安装的 `identity-obj-proxy` 包，以及另一个处理常见图像、视频和音频文件的模拟。我们将在本节稍后创建第二个模拟。'
- en: 'c. `testPathIgnorePatterns`: This tells Jest to ignore any tests found within
    `node_modules` as we do not want to bring in tests that have been found within
    our packages and the `.cache` directory.'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'c. `testPathIgnorePatterns`: 这告诉 Jest 忽略在 `node_modules` 中找到的任何测试，因为我们不希望引入在我们的包和
    `.cache` 目录中找到的测试。'
- en: 'd. `transformIgnorePatterns`: Here, we tell Jest to ignore Gatsby when it is
    transforming code, as Gatsby includes untranspiled ES6 code.'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'd. `transformIgnorePatterns`: 在这里，我们告诉 Jest 在转换代码时忽略 Gatsby，因为 Gatsby 包含未转换的
    ES6 代码。'
- en: 'e. `globals`: This is where we define a global variable called `__PATH_PREFIX__`
    that Gatsby uses behind the scenes. We need to define it here too as some Gatsby
    components will break without it being present.'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'e. `globals`: 在这里，我们定义了一个名为 `__PATH_PREFIX__` 的全局变量，Gatsby 在幕后使用它。我们还需要在这里定义它，因为一些
    Gatsby 组件如果没有它将无法正常工作。'
- en: 'f. `setupFiles`: Here, we list the configuration files that we would like to
    use to configure the testing environment. It is run once per test. Here, we tell
    it to run `loadershim.js`, which we will create later in this section.'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'f. `setupFiles`: 在这里，我们列出我们想要用于配置测试环境的配置文件。它对每个测试运行一次。在这里，我们告诉它运行我们将在本节稍后创建的
    `loadershim.js`。'
- en: 'g. `setupFilesAfterEnv`: Here, we specify the configuration files we would
    like to use to set up our tests. Crucially, these files run after the testing
    environment has been set up.'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'g. `setupFilesAfterEnv`: 在这里，我们指定我们想要用于设置测试的配置文件。关键的是，这些文件在测试环境设置之后运行。'
- en: 'Create a `jest-preprocess.js` file within your root directory:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的根目录中创建一个 `jest-preprocess.js` 文件：
- en: '[PRE2]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is where we define our Babel configuration. As we are working with Gatsby,
    we are using the `babel-preset-gatsby` preset. You can expand this preset list
    as necessary.
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是我们定义我们的 Babel 配置的地方。由于我们使用 Gatsby，我们使用 `babel-preset-gatsby` 预设。根据需要，您可以扩展此预设列表。
- en: 'Create a `loadershim.js` file within your root directory:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的根目录中创建一个 `loadershim.js` 文件：
- en: '[PRE3]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We use this file to mock a global `loader.enqueue` function using a Jest mock
    function.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用此文件使用 Jest 模拟函数模拟全局 `loader.enqueue` 函数。
- en: Create a new folder in your root directory called `__mocks__`.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的根目录中创建一个新的文件夹，命名为 `__mocks__`。
- en: 'Create a `file-mock.js` file within the `__mocks__` folder:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `__mocks__` 文件夹中创建一个 `file-mock.js` 文件：
- en: '[PRE4]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As we mentioned in *Step 2*, this file mocks out static asset file types.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如我们在 *步骤 2* 中提到的，此文件模拟了静态资产文件类型。
- en: 'Create a `gatsby.js` file within the `__mocks__` folder:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `__mocks__` 文件夹中创建一个 `gatsby.js` 文件：
- en: '[PRE5]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we are mocking out any components or functions that we are using from
    the `gatsby` package. We strip the props from the `Link` component and return
    an `<a/>` tag instead. We return a `div` in place of the `StaticQuery` component.
    Finally, we also mock out the `useStaticQuery` function with a Jest mock function.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们模拟了我们从 `gatsby` 包中使用的任何组件或函数。我们从 `Link` 组件中移除属性，并返回一个 `<a/>` 标签。我们用 `div`
    替代 `StaticQuery` 组件。最后，我们还使用 Jest 模拟函数模拟了 `useStaticQuery` 函数。
- en: 'Create a `gatsby-plugin-image.js` file within the `__mocks__` folder:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `__mocks__` 文件夹中创建一个 `gatsby-plugin-image.js` 文件：
- en: '[PRE6]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we are mocking out any components or functions that we are using from
    the `gatsby-plugin-image` package. We return a `div` in place of the `StaticImage`
    component.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们模拟了我们从 `gatsby-plugin-image` 包中使用的任何组件或函数。我们用 `div` 替代 `StaticImage` 组件。
- en: 'Create a `jest.setup.js` file within your root directory:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的根目录中创建一个 `jest.setup.js` 文件：
- en: '[PRE7]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Before each test, we need to mock a return value for `useStaticQuery`. Any page
    components that make use of the SEO component will fail unless they can retrieve
    this data from the function.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在每个测试之前，我们需要为 `useStaticQuery` 模拟一个返回值。任何使用 SEO 组件的页面组件将失败，除非它们可以从该函数检索此数据。
- en: 'Create a `test-utils.js` file within your `src` directory:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的 `src` 目录中创建一个 `test-utils.js` 文件：
- en: '[PRE8]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This file is not required but is helpful. Much of your application might make
    use of a provider, which we would normally wrap our root element in, within `gatsby-browser.js`.
    We can't do that in Jest. So, instead of defining `wrapper` in every test, it
    is preferable to create a custom `render` function that wraps any content in the
    required providers. We then call this `render` instead of the one that's exported
    from `@testing-library/react` when required.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此文件不是必需的，但很有帮助。你的应用程序可能很大一部分会使用一个提供者，我们通常会在 `gatsby-browser.js` 中将其包装在根元素中。在
    Jest 中我们无法这样做。因此，我们不是在每次测试中都定义 `wrapper`，而是更倾向于创建一个自定义的 `render` 函数，该函数将任何内容包装在所需的提供者中。然后，在需要时，我们调用这个
    `render` 而不是从 `@testing-library/react` 导出的那个。
- en: 'Create a test script within your `package.json` file:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `package.json` 文件中创建一个测试脚本：
- en: '[PRE9]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We now have everything in place to start testing! This book does not have space
    for a full guide on unit testing. However, let's create a few example tests for
    a few different component types, such as simple components, SEO components, and
    our Gatsby page components.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好开始测试了！这本书没有足够的空间来提供一个完整的单元测试指南。然而，让我们为几种不同的组件类型创建一些示例测试，例如简单组件、SEO
    组件和我们的 Gatsby 页面组件。
- en: Testing simple components
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试简单组件
- en: Testing simple components can be done in the same way you would do so in any
    standard react project. Let's take a look at how we would test our header component,
    as an example.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 测试简单组件可以像在任何标准的 React 项目中做的那样进行。让我们以测试我们的头部组件为例来看看。
- en: 'Create a `Header.test.js` file next to your header component using the following
    code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的头部组件旁边创建一个 `Header.test.js` 文件，使用以下代码：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we are rendering our `Header` component to the screen. We are then testing
    that the screen contains some text stating `Site Header` to ensure that the `Header`
    component is rendered. We do this by using the `screen.getByText` function.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将 `Header` 组件渲染到屏幕上。然后我们测试屏幕是否包含一些显示 `Site Header` 的文本，以确保 `Header` 组件已被渲染。我们通过使用
    `screen.getByText` 函数来完成这项测试。
- en: Now that we understand how to test simple components, let's look at a more complex
    example – your site's SEO component.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何测试简单的组件，让我们来看一个更复杂的例子——你网站的 SEO 组件。
- en: Testing the SEO component
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试 SEO 组件
- en: A common component among Gatsby pages that is important to test is the SEO component.
    It is important to ensure that the meta tags we are adding using the component
    are being correctly applied to the document's head so that we know that when that
    page is shared, it will have the rich previews that we set up in [*Chapter 6*](B15983_06_ePub_RK.xhtml#_idTextAnchor092),
    *Improving Your Site's Search Engine Optimization*. Let's look at how we could
    test this.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Gatsby 页面中一个常见的组件，重要的是要测试的是 SEO 组件。确保我们使用该组件添加的元标签被正确地应用到文档的头部，这样我们就可以知道当页面被分享时，它将具有我们在
    [*第 6 章*](B15983_06_ePub_RK.xhtml#_idTextAnchor092)，*提高你的网站搜索引擎优化* 中设置的丰富预览。让我们看看我们如何进行这项测试。
- en: 'Create a `SEO.test.js` file next to your SEO component using the following
    code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 SEO 组件旁边创建一个 `SEO.test.js` 文件，使用以下代码：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: First, we inform `react-helmet-async` from `HelmetProvider` that it cannot use
    the `SEO` component. After rendering, we check that the context's helmet object
    contains meta, and if it does, we make sure it matches the snapshot.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通知 `react-helmet-async` 从 `HelmetProvider` 中它不能使用 `SEO` 组件。渲染后，我们检查上下文中的
    helmet 对象是否包含 meta，如果包含，我们确保它与快照匹配。
- en: Now, let's understand how we would test whole site pages.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解如何测试整个网站页面。
- en: Testing Gatsby page components
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试 Gatsby 页面组件
- en: If you ever want to test pages, you can make use of the custom `render` function
    we set up in *Step 10* of the *Exploring unit testing* section. Let's take a look
    at how we would test our site's index page as an example.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要测试页面，你可以使用我们在 *探索单元测试* 部分的 *第 10 步* 中设置的定制 `render` 函数。让我们以测试我们网站的首页为例来看看。
- en: Unlike our component tests, it is best to avoid placing your page tests in the
    same directory as the page files. This is because Gatsby will automatically try
    and create pages for every exported React component in the `pages` directory.
    Instead, create a folder alongside the `pages` directory called `pages-lib` that's
    specifically for Gatsby page tests.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的组件测试不同，最好避免将页面测试放在与页面文件相同的目录中。这是因为 Gatsby 会自动尝试在 `pages` 目录中为每个导出的 React
    组件创建页面。相反，在 `pages` 目录旁边创建一个名为 `pages-lib` 的文件夹，专门用于 Gatsby 页面测试。
- en: 'Create an `index.test.js` file in the `pages-lib` directory using the following
    code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `pages-lib` 目录中创建一个 `index.test.js` 文件，使用以下代码：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this instance, we are making use of the custom render function that we set
    up in the `test-utils.js` file. This is because page components typically also
    contain an `SEO` component, which uses the `Helmet` component, and, as such, needs
    to be wrapped in `HelmetProvider`. It's also important to pass any data to the
    `data` prop that the page would normally retrieve via GraphQL, as GraphQL queries
    on the page will not run.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们正在使用在`test-utils.js`文件中设置的定制渲染函数。这是因为页面组件通常还包含一个`SEO`组件，它使用`Helmet`组件，因此需要包裹在`HelmetProvider`中。同时，也很重要将页面通常通过GraphQL检索的任何数据传递给`data`属性，因为页面上的GraphQL查询将不会运行。
- en: Now that we understand how to write tests, let's understand how we can trigger
    them with Git hooks.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何编写测试，让我们了解如何通过Git钩子触发它们。
- en: Adding Git hooks for tests
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加测试的Git钩子
- en: A `push` our code, and if they fail, we can stop the push. By implementing this
    feature, it's unlikely that the code being pushed will break any functionality
    we test for.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`push`我们的代码，如果它们失败，我们可以停止推送。通过实现这个功能，被推送的代码不太可能破坏我们测试的任何功能。'
- en: 'Let''s implement this functionality now by creating a Git hook that is triggered
    by a `git push`. This will ensure our unit tests pass before allowing the `push`
    command to run. We will be using the `husky` package to do this as it is easy
    to set up and maintain:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个由`git push`触发的Git钩子来实现这个功能。这将确保在允许`push`命令运行之前，我们的单元测试已经通过。我们将使用`husky`包来完成这项工作，因为它易于设置和维护：
- en: 'Install the necessary dependencies:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装必要的依赖项：
- en: '[PRE13]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create a `postinstall` script in your `package.json` file with the following
    command:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`package.json`文件中创建一个`postinstall`脚本，使用以下命令：
- en: '[PRE14]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This command will add a new script to our `package.json` file called `postinstall`
    that causes `husky` to be installed.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令将在我们的`package.json`文件中添加一个新的脚本，称为`postinstall`，这将导致安装`husky`。
- en: 'Run this new script:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行这个新脚本：
- en: '[PRE15]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As we are setting this up for the first time, we will need to trigger the `husky`
    install manually by running the `postinstall` script via the command line. Every
    subsequent developer will never need to run this manually.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们第一次设置此功能，我们需要通过命令行手动触发`postinstall`脚本来手动安装`husky`。后续的每个开发者将永远不需要手动运行此操作。
- en: 'Add a hook:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个钩子：
- en: '[PRE16]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This adds a `pre-push` hook that runs our npm `test` script. After running this
    command, every subsequent push will run the `test` script and only push on success.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这添加了一个`pre-push`钩子，它会运行我们的npm `test`脚本。运行此命令后，后续的每次推送都会运行`test`脚本，并且只有在成功的情况下才会进行推送。
- en: Important Note
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: Running tests on push is not always the best test. We may have uncommitted code
    locally that is causing the tests to pass, which are not included in the push.
    This can cause the same tests to fail in **continuous integration/continuous deployment**
    (**CI/CD**) environments.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在推送时运行测试并不总是最好的测试方式。我们可能在本地的未提交代码中存在导致测试通过，但未包含在推送中的代码。这可能导致在**持续集成/持续部署**（**CI/CD**）环境中相同的测试失败。
- en: Now that we understand how to trigger unit tests with Git hooks, let's turn
    our attention to a different kind of test – auditing core web vitals.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何通过Git钩子触发单元测试，让我们将注意力转向另一种类型的测试——审计核心Web vitals。
- en: Auditing core web vitals
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审计核心Web vitals
- en: Web vitals ([https://web.dev/vitals](https://web.dev/vitals)) are an initiative
    by Google to provide unified guidance for quality signals that are essential to
    delivering a great user experience on the web. These directly tie into the signals
    discussed in [*Chapter 6*](B15983_06_ePub_RK.xhtml#_idTextAnchor092), *Improving
    Your Site's Search Engine Optimization*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Web vitals ([https://web.dev/vitals](https://web.dev/vitals))是谷歌发起的一项倡议，旨在为提供统一指导的质量信号提供指导，这些信号对于在网络上提供良好的用户体验至关重要。这些信号直接关联到[*第6章*](B15983_06_ePub_RK.xhtml#_idTextAnchor092)中讨论的信号，即*提高网站搜索引擎优化*。
- en: 'The core web vitals are a small group of Google''s web vitals that focus on
    three pillars – how fast the page loads, how soon you can interact with the page,
    and how stable the page is while it is loading and while the user is interacting
    with it. These three pillars are encompassed in the following three metrics:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 核心Web vitals是谷歌Web vitals中的一小部分，专注于三个支柱——页面加载速度有多快，你有多快可以与页面交互，以及页面在加载期间和用户交互期间有多稳定。这三个支柱包含在以下三个指标中：
- en: '**Largest Contentful Paint**: A representation of load time. It is the measure
    of the time the browser takes to make the majority of a page''s content visible
    from the moment you start navigating to it. This is the moment at which a user
    perceives the site to have finished loading.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大内容渲染时间**：表示加载时间的指标。它是从您开始导航到页面时，浏览器将页面的大部分内容变为可见所需的时间的度量。这是用户感知网站加载完成的时刻。'
- en: '**First Input Delay**: Measures the response time to interact. First input
    delay is the time the browser takes from navigation to a point where you can interact
    with any element on the page, such as a form or button.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**首次输入延迟**：衡量交互响应时间。首次输入延迟是浏览器从导航到一个可以与页面上的任何元素（如表单或按钮）交互的点所需的时间。'
- en: '**Cumulative Layout Shift**: A measurement of how stable the page is while
    it loads. The less your elements shift around the page while the page loads, the
    higher your score will be.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**累积布局偏移**：衡量页面在加载过程中稳定性的指标。在页面加载时，您的元素在页面上的移动越少，您的得分就越高。'
- en: 'Now that we understand these core web vitals, how do we measure them? There
    are two different methods we can use to retrieve these metrics. They are as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了这些核心Web核心指标，我们如何衡量它们？我们可以使用两种不同的方法来检索这些指标。如下所示：
- en: '**Lab Test Data**: Data generated on demand by you for testing. This is less
    accurate as it is based on approximations of user data. But while developing,
    it is often incredibly useful as we can use it to develop our site iteratively,
    without ever having to deploy it.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实验室测试数据**：您根据需求生成用于测试的数据。由于它基于用户数据的近似值，因此准确性较低。但在开发过程中，它通常非常有用，因为我们可以用它来迭代地开发我们的网站，而无需部署它。'
- en: '**Field Data**: Data collected from users when viewing your site. This is the
    most accurate source of data as it directly corresponds to how your users are
    perceiving your site.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字段数据**：从查看您网站的用户那里收集的数据。这是数据最准确的数据源，因为它直接对应于您的用户如何感知您的网站。'
- en: Let's look at how we can retrieve lab test data using the lighthouse tool and
    field data using the `web-vitals` package.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用灯塔工具检索实验室测试数据，以及使用`web-vitals`包检索字段数据。
- en: Using Chrome's lighthouse tool
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Chrome的灯塔工具
- en: The lighthouse tool will analyze your website for performance, accessibility,
    search engine optimization, and progressive web app features. Not only does it
    give you a score in each of these categories, but it will also tell you how to
    improve your site to increase these scores. The best part? It's built into Google
    Chrome – no other downloads or tooling installation is required.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 灯塔工具将分析您的网站的性能、可访问性、搜索引擎优化和渐进式Web应用功能。它不仅在每个类别中给出分数，还会告诉您如何改进网站以提高这些分数。最好的部分？它是内置在Google
    Chrome中的 - 不需要其他下载或工具安装。
- en: 'Now, let''s generate a lighthouse report for our site using the tool:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用此工具为我们网站生成一个灯塔报告：
- en: Build your site using the `gatsby build` command. As we saw in [*Chapter 1*](B15983_01_ePub_RK.xhtml#_idTextAnchor013),
    *An Overview of Gatsby.js for the Uninitiated*, this creates a production build
    of your website. It is *vitally* important that we audit a production build of
    the site instead of a development build, since the development tools that Gatsby
    adds into the build drastically increase your site's bundle.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`gatsby build`命令构建您的网站。正如我们在[*第一章*](B15983_01_ePub_RK.xhtml#_idTextAnchor013)中看到的，“Gatsby.js入门概述”，这将创建您网站的生成版本。我们审核网站的生成版本而不是开发版本至关重要，因为Gatsby添加到构建中的开发工具会极大地增加您网站的包大小。
- en: Serve your build using the `gatsby serve` command. With the default settings,
    your site should be live on http://localhost:9000/.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`gatsby serve`命令提供您的构建。默认设置下，您的网站应该已活化为http://localhost:9000/。
- en: Open Google Chrome in incognito mode and navigate to http://localhost:9000/.
    You should see the index page of your site. By loading this page in incognito
    mode, we ensure that no Chrome extensions you have installed interfere with the
    test.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在隐身模式下打开Google Chrome并导航到http://localhost:9000/。您应该看到您网站的索引页面。通过在隐身模式下加载此页面，我们确保您安装的任何Chrome扩展都不会干扰测试。
- en: Right-click anywhere on the page and click **Inspect**. This will bring up **Developer
    Tools** on the right-hand side of the window.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在页面的任何位置右键单击并点击**检查**。这将打开窗口右侧的**开发者工具**。
- en: Click the chevron in the center of the top bar and select **Lighthouse**:![Figure
    7.1 – Lighthouse location Within Developer Tools
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击顶部栏中央的箭头并选择**灯塔工具**：![图 7.1 – 开发者工具中的灯塔位置
- en: '](img/Figure_7.1_B15983.jpg)'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.1_B15983.jpg)'
- en: Figure 7.1 – Lighthouse location Within Developer Tools
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.1 – 灯塔在开发者工具中的位置
- en: This will present you with the lighthouse report generator window, which looks
    like this:![Figure 7.2 – Lighthouse report generator
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将显示灯塔报告生成器窗口，其外观如下：![图7.2 – 灯塔报告生成器
- en: '](img/Figure_7.2_B15983.jpg)'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.2_B15983.jpg)'
- en: Figure 7.2 – Lighthouse report generator
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.2 – 灯塔报告生成器
- en: Select the categories you would like to audit, all of which will be switched
    on by default. All of these categories are important, and it is advised to keep
    them all on unless you are specifically trying to improve a single metric and
    want the report to be generated more quickly.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选择你想要审计的类别，所有这些类别默认都是开启的。所有这些类别都很重要，除非你特别想提高单个指标并希望报告生成得更快，否则建议保持所有类别开启。
- en: You must also select a **Device** type. By default, this setting is set to **Mobile**.
    Lighthouse will try to emulate a mobile device attempting to access the page,
    which includes using a smaller viewport and throttling the network connection.
    Running multiple reports – one for each device type – is a great idea as it ensures
    that your site has a great experience on every device. Note that for SEO purposes,
    Google uses mobile metrics in their site rankings.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你还必须选择一个**设备**类型。默认情况下，此设置设置为**移动设备**。灯塔将尝试模拟一个移动设备尝试访问页面，这包括使用较小的视口和限制网络连接。运行多个报告——每个设备类型一个——是个好主意，因为它确保你的网站在每种设备上都有良好的体验。请注意，出于SEO目的，谷歌在其网站排名中使用移动指标。
- en: Clicking **Generate report** will start lighthouse. You may see the page flash
    a few times during this process. This is nothing to worry about. Congratulations
    – you've just run your first lighthouse report!
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**生成报告**将启动灯塔工具。在这个过程中，你可能看到页面闪烁几次。这没有什么好担心的。恭喜你——你已经运行了你的第一个灯塔报告！
- en: 'Once lighthouse has finished running, you will see that the report generator
    window has been replaced with a report that contains a section for each category.
    Let''s take a look at the **Performance** category:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦灯塔运行完成，你将看到报告生成器窗口已被包含每个类别的报告所取代。让我们看看**性能**类别：
- en: '![Figure 7.3 – Lighthouse Performance report'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.3 – 灯塔性能报告'
- en: '](img/Figure_7.3_B15983.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.3_B15983.jpg)'
- en: Figure 7.3 – Lighthouse Performance report
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – 灯塔性能报告
- en: 'You may notice some familiar items within these metrics. Lighthouse has audited
    each of the three core web vitals as part of its audit. Each metric will be color-coded
    to give you an indication of where you need to focus your efforts. Green means
    good, orange means that it needs improvement, while red means that the score for
    this metric is considered poor. In cases where your scores are not optimal, lighthouse
    will propose changes that you can make to your site to improve the score. Let''s
    look at an example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会在这些指标中注意到一些熟悉的项目。灯塔将其审计作为其审计的一部分，对三个核心网络指标进行了审计。每个指标都将用颜色编码，以指示你需要集中精力改进的地方。绿色表示良好，橙色表示需要改进，而红色表示该指标的得分被认为很差。在得分不理想的情况下，灯塔将提出你可以对网站进行的更改，以改善得分。让我们看看一个例子：
- en: '![Figure 7.4 – Lighthouse Accessibility report with suggested improvements'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.4 – 带有建议改进的灯塔可访问性报告'
- en: '](img/Figure_7.4_B15983.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_7.4_B15983.jpg)'
- en: Figure 7.4 – Lighthouse Accessibility report with suggested improvements
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – 带有建议改进的灯塔可访问性报告
- en: In the preceding screenshot, we can see that our buttons are not currently accessible
    as they do not have accessible names. Hovering over the failing element will highlight
    it within the site so that we can rectify it quickly.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们可以看到我们的按钮目前不可访问，因为它们没有可访问的名称。将鼠标悬停在失败的元素上将在网站中突出显示它，这样我们就可以快速纠正它。
- en: Now that we understand how to retrieve lab test data, let's investigate how
    we can retrieve field data using the `web-vitals` JavaScript package.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何检索实验室测试数据，让我们来探讨如何使用`web-vitals` JavaScript包检索现场数据。
- en: Using the web-vitals JavaScript package
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`web-vitals` JavaScript包
- en: The `web-vitals` package is a 1 KB package that's developed by the Google Chrome
    team. This package monitors web vitals, including core web vitals on real users
    as they visit your site. It aims to measure them in a way that is incredibly similar
    to other Google reporting tools.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`web-vitals`包是由谷歌Chrome团队开发的一个1KB大小的包。此包监控网络核心指标，包括当真实用户访问你的网站时的核心网络指标。它旨在以与其他谷歌报告工具极其相似的方式测量它们。'
- en: Important Note
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The `web-vitals` package makes use of browser APIs that are not supported in
    all browsers. The package only guarantees complete support in Google Chrome. If
    you are gathering metrics using this tool, please consider that the results will
    only be retrievable on supported browsers. If you are collating these metrics,
    it is important to remember that they do not necessarily represent all your site
    visitors.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`web-vitals` 包利用了并非所有浏览器都支持的浏览器API。该包仅保证在Google Chrome中提供完整支持。如果您正在使用此工具收集指标，请考虑结果只能在受支持的浏览器中检索。如果您正在汇总这些指标，请记住，它们并不一定代表您网站的所有访客。'
- en: 'To understand how to use `web-vitals` within our application, let''s create
    a rudimentary example where we simply log the vitals when the user navigates to
    our site:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解如何在我们的应用程序中使用 `web-vitals`，让我们创建一个基本的示例，其中我们简单地记录用户导航到我们的网站时的核心指标：
- en: 'Install the `web-vitals` package:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 `web-vitals` 包：
- en: '[PRE17]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create a function that utilizes the `web-vitals` package:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个利用 `web-vitals` 包的函数：
- en: '[PRE18]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this example, we retrieve the metrics and then simply log them to the console.
    It is important to wrap them in a `try catch` block to avoid crashing the page
    when the APIs are not supported. This also allows you to handle the error accordingly.
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个例子中，我们检索指标，然后简单地记录到控制台。将它们包裹在 `try catch` 块中非常重要，以避免在API不受支持时崩溃页面。这也允许您相应地处理错误。
- en: 'Use the following code within your `gatsby-browser.js` file:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的 `gatsby-browser.js` 文件中使用以下代码：
- en: '[PRE19]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: By calling the function within this file, it will run once when the user initially
    navigates to our site from an external source, but not on every page navigation
    within the site.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过在此文件中调用函数，当用户从外部来源首次导航到我们的网站时，它将运行一次，但不会在网站内的每次页面导航时运行。
- en: Starting your development server and navigating to your site via Google Chrome,
    you should see the metrics logged in the console. In this example, we are simply
    displaying them, but we could be sending these to our analytics platform. We will
    look at this in more detail in [*Chapter 8*](B15983_08_ePub_RK.xhtml#_idTextAnchor116),
    *Web Analytics and Performance Monitoring*.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 启动您的开发服务器并通过Google Chrome导航到您的网站，您应该在控制台中看到记录的指标。在这个例子中，我们只是简单地显示它们，但我们可以将它们发送到我们的分析平台。我们将在第8章[*“网络分析和性能监控”*](B15983_08_ePub_RK.xhtml#_idTextAnchor116)中更详细地探讨这一点。
- en: We now have a good understanding of how to measure web vitals both in the field
    and during development.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在对如何在现场和开发过程中测量网站核心指标有了很好的理解。
- en: Summary
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about unit testing – what it is and why it is important.
    Then, we integrated unit testing into our Gatsby site. We also looked at a few
    different recipes for unit tests that we can use to test different types of react
    components. We then learned about Git hooks and implemented a Git hook that runs
    unit tests using `husky`. Finally, we investigated core web vitals. We used web
    vitals to test our page experience both locally using lighthouse, and in the field
    using the `web-vitals` package. Using what you've learned, you should now feel
    that you can test a site locally, as well as audit its performance, accessibility,
    and SEO once it is out on the web.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了单元测试——它是什么以及为什么它很重要。然后，我们将单元测试集成到我们的Gatsby网站中。我们还查看了一些不同的单元测试配方，我们可以使用它们来测试不同类型的React组件。然后，我们学习了Git钩子，并实现了一个使用
    `husky` 运行单元测试的Git钩子。最后，我们调查了网站核心指标。我们使用网站核心指标在本地使用Lighthouse以及在现场使用 `web-vitals`
    包来测试我们的页面体验。通过您所学的知识，您现在应该感觉到您可以在本地测试一个网站，一旦它上线，还可以审计其性能、可访问性和SEO。
- en: In the next chapter, we will discover how we can add analytics to our site,
    including how we can track `web-vitals` field data.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何将分析功能添加到我们的网站中，包括如何跟踪 `web-vitals` 字段数据。
