<html><head></head><body>
        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Continuous Integration with Unit and Behavioral Tests</h1>
            

            <article>
                
<p class="calibre2">We made it; congratulations! We have created a full-stack app that runs under a certain domain name (in this book its <em class="calibre21">reactjs.space</em>). The missing parts in the whole setup are the deployments processes. Deployments should be zero downtime. We need to have a redundant server of our application.</p>
<p class="calibre2">We are also missing some steps in our app to make it professionally work as minification, unit, and behavioral tests.</p>
<p class="calibre2">In this chapter, we will introduce you to some additional concepts that are required in order to master the full-stack development. The remaining missing pieces are left for you as homework.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">When to write unit and behavioral tests</h1>
            

            <article>
                
<p class="calibre2">Generally, there are some advices about when to write unit and/or behavioral tests.</p>
<p class="calibre2">We in ReactPoland often have clients who run startups. As a general governance for them, we suggest the following:</p>
<ul class="calibre14">
<li class="calibre15">If your startup is looking for traction and you need your product in order to make it, then don't worry about tests</li>
<li class="calibre15">After you have created your <strong class="calibre1">Minimum Viable Product</strong> (<strong class="calibre1">MVP</strong>), you <em class="calibre21">must</em> have those tests when expanding your application</li>
<li class="calibre15">If you are a well-established company, which is building an app for your clients and you know their needs very well, then you must have tests</li>
</ul>
<p class="calibre2">The preceding first two points are related to startups and young companies. The third point is related mostly to well-established companies.</p>
<p class="calibre2">Depending on where you and your product are, then you need to decide on your own, if it is worth to write the tests.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">React conventions</h1>
            

            <article>
                
<p class="calibre2">There is a project that shows fully how the full-stack development setup should be looking like at <a href="http://reactjs.co/" class="calibre6">http://React JS.co</a>.</p>
<p class="calibre2">Visit this website and learn how to integrate your app with unit and behavioral tests and learn up-to-date best conventions about how to make React Redux applications.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Karma for testing</h1>
            

            <article>
                
<p class="calibre2">We won't guide you in setting up the tests in this chapter because it's not in the scope of this book. The aim of this chapter is intended to present you with online resources that will help you to understand the bigger picture. </p>
<p class="calibre2">Karma is the one of most popular tools for unit and behavioral tests. The main goal is to bring a productive testing environment while working on any application.</p>
<p class="calibre2">There are many features that you are provided with by using this test runner. There is a nice video that explains the big picture about Karma at <a href="https://karma-runner.github.io" class="calibre6"><span>https://karma-runner.github.io</span></a>.</p>
<p class="calibre2">Some of the main features are as follows:</p>
<ul class="calibre14">
<li class="calibre15"><strong class="calibre1">Tests on real devices</strong>: You can use real browsers and real devices such as phones, tablets, or PhantomJS to run the tests (PhantomJS is a headless WebKit scriptable with a JavaScript API; it has fast and native support for various web standards: DOM handling, CSS selector, JSON, Canvas, and SVG.) There are different environments, but one tool that runs on them all.</li>
<li class="calibre15"><strong class="calibre1">Remote control</strong>: You can run the tests remotely, for example, on each save from your IDE, so that you don't have to do it manually.</li>
<li class="calibre15"><strong class="calibre1">Testing framework agnostic</strong>: You can write your tests in Jasmine, Mocha, QUnit, and other frameworks. It's totally up to you.</li>
<li class="calibre15"><strong class="calibre1">Continuous integration</strong>: Karma works great with CI tools such as Jenkins, Travis, or CircleCI.</li>
</ul>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">How to write unit and behavioral tests</h1>
            

            <article>
                
<p class="calibre2">Let's provide an example of how to set up properly a project in order to have an ability to write tests.</p>
<p class="calibre2">Visit the GitHub repo of the very popular Redux starter kit at <a href="https://github.com/davezuko/react-redux-starter-kit" class="calibre6"><span>https://github.com/davezuko/react-redux-starter-kit</span></a>.</p>
<p class="calibre2">Then visit the <kbd class="calibre11">package.json</kbd> file of this repository. We can find out there what the possible commands/scripts are:</p>
<pre class="calibre22">
 "scripts": { <br class="title-page-name"/>    "clean": "rimraf dist", <br class="title-page-name"/>    "compile": "better-npm-run compile", <br class="title-page-name"/>    "lint": "eslint src tests server", <br class="title-page-name"/>    "lint:fix": "npm run lint -- --fix", <br class="title-page-name"/>    "start": "better-npm-run start", <br class="title-page-name"/>    "dev": "better-npm-run dev", <br class="title-page-name"/>    "dev:no-debug": "npm run dev -- --no_debug", <br class="title-page-name"/>    "test": "better-npm-run test", <br class="title-page-name"/>    "test:dev": "npm run test -- --watch", <br class="title-page-name"/>    "deploy": "better-npm-run deploy", <br class="title-page-name"/>    "deploy:dev": "better-npm-run deploy:dev", <br class="title-page-name"/>    "deploy:prod": "better-npm-run deploy:prod", <br class="title-page-name"/>    "codecov": "cat coverage/*/lcov.info | codecov" <br class="title-page-name"/>  },
</pre>
<p class="calibre2">As you can find, after the NPM test that it runs the following command:</p>
<pre class="calibre22">
   "test": { <br class="title-page-name"/>      "command": "babel-node ./node_modules/karma/bin/ <br class="title-page-name"/>       karma start build/karma.conf", <br class="title-page-name"/>      "env": { <br class="title-page-name"/>        "NODE_ENV": "test", <br class="title-page-name"/>        "DEBUG": "app:*" <br class="title-page-name"/>      } <br class="title-page-name"/>    }
</pre>
<p class="calibre2">You can find the configuration file of Karma located at <kbd class="calibre11">build/karma.conf</kbd> from <a href="https://github.com/davezuko/react-redux-starter-kit/blob/master/build/karma.conf.js" class="calibre6"><span>https://github.com/davezuko/react-redux-starter-kit/blob/master/build/karma.conf.js</span></a>.</p>
<p class="calibre2">And the content (July 2016) is as follows:</p>
<pre class="calibre22">
import { argv } from 'yargs' <br class="title-page-name"/>import config from '../config' <br class="title-page-name"/>import webpackConfig from './webpack.config' <br class="title-page-name"/>import _debug from 'debug' <br class="title-page-name"/><br class="title-page-name"/>const debug = _debug('app:karma') <br class="title-page-name"/>debug('Create configuration.') <br class="title-page-name"/><br class="title-page-name"/>const karmaConfig = { <br class="title-page-name"/>  basePath: '../', // project root in relation to bin/karma.js <br class="title-page-name"/>  files: [ <br class="title-page-name"/>    { <br class="title-page-name"/>      pattern: &amp;grave;./${config.dir_test}/test-bundler.js&amp;grave;, <br class="title-page-name"/>      watched: false, <br class="title-page-name"/>      served: true, <br class="title-page-name"/>      included: true <br class="title-page-name"/>    } <br class="title-page-name"/>  ], <br class="title-page-name"/>  singleRun: !argv.watch, <br class="title-page-name"/>  frameworks: ['mocha'], <br class="title-page-name"/>  reporters: ['mocha'], <br class="title-page-name"/>  preprocessors: { <br class="title-page-name"/>    [&amp;grave;${config.dir_test}/test-bundler.js&amp;grave;]: ['webpack'] <br class="title-page-name"/>  }, <br class="title-page-name"/>  browsers: ['PhantomJS'], <br class="title-page-name"/>  webpack: { <br class="title-page-name"/>    devtool: 'cheap-module-source-map', <br class="title-page-name"/>    resolve: { <br class="title-page-name"/>      ...webpackConfig.resolve, <br class="title-page-name"/>      alias: { <br class="title-page-name"/>        ...webpackConfig.resolve.alias, <br class="title-page-name"/>        sinon: 'sinon/pkg/sinon.js' <br class="title-page-name"/>      } <br class="title-page-name"/>    }, <br class="title-page-name"/>    plugins: webpackConfig.plugins, <br class="title-page-name"/>    module: { <br class="title-page-name"/>      noParse: [ <br class="title-page-name"/>        //sinon.js/ <br class="title-page-name"/>      ], <br class="title-page-name"/>      loaders: webpackConfig.module.loaders.concat([ <br class="title-page-name"/>        { <br class="title-page-name"/>          test: /sinon(|/)pkg(|/)sinon.js/, <br class="title-page-name"/>          loader: 'imports?define=&gt;false,require=&gt;false' <br class="title-page-name"/>        } <br class="title-page-name"/>      ]) <br class="title-page-name"/>    }, <br class="title-page-name"/>    // Enzyme fix, see: <br class="title-page-name"/>    // https://github.com/airbnb/enzyme/issues/47 <br class="title-page-name"/>    externals: { <br class="title-page-name"/>      ...webpackConfig.externals, <br class="title-page-name"/>      'react/addons': true, <br class="title-page-name"/>      'react/lib/ExecutionEnvironment': true, <br class="title-page-name"/>      'react/lib/ReactContext': 'window' <br class="title-page-name"/>    }, <br class="title-page-name"/>    sassLoader: webpackConfig.sassLoader <br class="title-page-name"/>  }, <br class="title-page-name"/>  webpackMiddleware: { <br class="title-page-name"/>    noInfo: true <br class="title-page-name"/>  }, <br class="title-page-name"/>  coverageReporter: { <br class="title-page-name"/>    reporters: config.coverage_reporters <br class="title-page-name"/>  } <br class="title-page-name"/>} <br class="title-page-name"/><br class="title-page-name"/>if (config.globals.__COVERAGE__) { <br class="title-page-name"/>  karmaConfig.reporters.push('coverage') <br class="title-page-name"/>  karmaConfig.webpack.module.preLoaders = [{ <br class="title-page-name"/>    test: /.(js|jsx)$/, <br class="title-page-name"/>    include: new RegExp(config.dir_client), <br class="title-page-name"/>    loader: 'isparta', <br class="title-page-name"/>    exclude: /node_modules/ <br class="title-page-name"/>  }] <br class="title-page-name"/>} <br class="title-page-name"/><br class="title-page-name"/>// cannot use &amp;grave;export default&amp;grave; because of Karma. <br class="title-page-name"/>module.exports = (cfg) =&gt; cfg.set(karmaConfig)
</pre>
<p class="calibre2">As you can see in <kbd class="calibre11">karma.conf.js</kbd> they are using Mocha (check the line with <kbd class="calibre11">"frameworks: ['mocha']"</kbd>). The rest of the options used in the config files are described in the documentation that is available at <a href="http://karma-runner.github.io/1.0/config/configuration-file.html" class="calibre6"><span>http://karma-runner.github.io/1.0/config/configuration-file.html</span></a>. If you are interested in learning the Karma configuration, then <kbd class="calibre11">karma.conf.js</kbd> should be your starting file. </p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">What is Mocha and why do you need it?</h1>
            

            <article>
                
<p class="calibre2">In the Karma config file, we have found that it uses Mocha as the JS testing framework (<a href="https://mochajs.org/" class="calibre6"><span>https://mochajs.org/</span></a>). Let's analyze the codebase.</p>
<p class="calibre2">We can find <kbd class="calibre11">dir_test : 'tests'</kbd> in the <kbd class="calibre11">config/index.js</kbd> file, so based on that variable, Karma's <kbd class="calibre11">config</kbd> knows that the Mocha's tests are located in the <kbd class="calibre11">tests/test-bundler.js</kbd> file.</p>
<p class="calibre2">Let's see what is in the <kbd class="calibre11">tests</kbd> directory at <span>https://github.com/davezuko/react-redux-starter-kit/tree/master/tests</span>. As you can see in the <kbd class="calibre11">test-bundler.js</kbd> file, there are plenty of dependencies:</p>
<pre class="calibre22">
// --------------------------------------- <br class="title-page-name"/>// Test Environment Setup <br class="title-page-name"/>// --------------------------------------- <br class="title-page-name"/>import 'babel-polyfill' <br class="title-page-name"/>import sinon from 'sinon' <br class="title-page-name"/>import chai from 'chai' <br class="title-page-name"/>import sinonChai from 'sinon-chai' <br class="title-page-name"/>import chaiAsPromised from 'chai-as-promised' <br class="title-page-name"/>import chaiEnzyme from 'chai-enzyme' <br class="title-page-name"/><br class="title-page-name"/>chai.use(sinonChai) <br class="title-page-name"/>chai.use(chaiAsPromised) <br class="title-page-name"/>chai.use(chaiEnzyme()) <br class="title-page-name"/><br class="title-page-name"/>global.chai = chai <br class="title-page-name"/>global.sinon = sinon <br class="title-page-name"/>global.expect = chai.expect <br class="title-page-name"/>global.should = chai.should()
</pre>
<p class="calibre2">Let's roughly describe what is used there:</p>
<ul class="calibre14">
<li class="calibre15">Babel-polyfill emulates a full ES6 environment</li>
<li class="calibre15">Sinon is a standalone and test framework agnostic JavaScript test for spies, stubs, and mocks</li>
</ul>
<p class="calibre2">Spies are useful if in a tested piece of code, you call for an other external's services. You can check if it was called, what parameters it had, if it returned something, or even how many times it was called!</p>
<p class="calibre2">The stubs concept is very similar to the spies concept. The biggest difference is that stubs replace the target function. They also replace the called code with custom behavior (replacing it) such as throwing exceptions or returning a value. They are also able to call a callback function that has been provided as a parameter. Stubs code returns a specified result.</p>
<p class="calibre2">Mocks are kind of <em class="calibre21">smarter stubs</em>. Mocks are used for asserting data and should never return data, when a stub is used simply for returning data and should never assert. Mocks can file your tests (when asserting), while stubs can't.</p>
<p class="calibre2">Chai is the BDD/TDD assertion framework for Node.js and the browser. In the previous example, it has been paired with the Mocha testing framework.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Testing CoreLayout step-by-step</h1>
            

            <article>
                
<p class="calibre2">Let's analyze the <kbd class="calibre11">CoreLayout.spec.js</kbd> tests. This component has a role similar to the CoreLayout in the publishing app, and so it's a good way to describe how you can start writing tests for your application.</p>
<p class="calibre2">The CoreLayout tests file location (July 2016) is available at <a href="https://github.com/davezuko/react-redux-starter-kit/blob/master/tests/layouts/CoreLayout.spec.js" class="calibre6"><span>https://github.com/davezuko/react-redux-starter-kit/blob/master/tests/layouts/CoreLayout.spec.js</span></a>.</p>
<p class="calibre2">The content is as follows:</p>
<pre class="calibre22">
import React from 'react' <br class="title-page-name"/>import TestUtils from 'react-addons-test-utils' <br class="title-page-name"/>import CoreLayout from 'layouts/CoreLayout/CoreLayout' <br class="title-page-name"/><br class="title-page-name"/>function shallowRender (component) { <br class="title-page-name"/>  const renderer = TestUtils.createRenderer() <br class="title-page-name"/><br class="title-page-name"/>  renderer.render(component) <br class="title-page-name"/>  return renderer.getRenderOutput() <br class="title-page-name"/>} <br class="title-page-name"/><br class="title-page-name"/>function shallowRenderWithProps (props = {}) { <br class="title-page-name"/>  return shallowRender(&lt;CoreLayout {...props} /&gt;) <br class="title-page-name"/>} <br class="title-page-name"/><br class="title-page-name"/>describe('(Layout) Core', function () { <br class="title-page-name"/>  let _component <br class="title-page-name"/>  let _props <br class="title-page-name"/>  let _child <br class="title-page-name"/><br class="title-page-name"/>  beforeEach(function () { <br class="title-page-name"/>    _child = &lt;h1 className='child'&gt;Child&lt;/h1&gt; <br class="title-page-name"/>    _props = { <br class="title-page-name"/>      children: _child <br class="title-page-name"/>    } <br class="title-page-name"/><br class="title-page-name"/>    _component = shallowRenderWithProps(_props) <br class="title-page-name"/>  }) <br class="title-page-name"/><br class="title-page-name"/>  it('Should render as a &lt;div&gt;.', function () { <br class="title-page-name"/>    expect(_component.type).to.equal('div') <br class="title-page-name"/>  }) <br class="title-page-name"/>})
</pre>
<p class="calibre2">The <kbd class="calibre11">react-addons-test-utils</kbd> library makes it easy to test React components with Mocha. The method that we used in the preceding example is <strong class="calibre1">shallow rendering,</strong> which is available at <a href="https://facebook.github.io/react/docs/test-utils.html#shallow-rendering" class="calibre6"><span>https://facebook.github.io/react/docs/test-utils.html#shallow-rendering</span></a>.</p>
<p class="calibre2">This feature helps us test the <kbd class="calibre11">render</kbd> function and is the result of rendering a one level deep in our components. Then we can assert facts about what its <kbd class="calibre11">render</kbd> method returns, as shown in the following:</p>
<pre class="calibre22">
function shallowRender (component) { <br class="title-page-name"/>  const renderer = TestUtils.createRenderer() <br class="title-page-name"/><br class="title-page-name"/>  renderer.render(component) <br class="title-page-name"/>  return renderer.getRenderOutput() <br class="title-page-name"/>} <br class="title-page-name"/><br class="title-page-name"/>function shallowRenderWithProps (props = {}) { <br class="title-page-name"/>  return shallowRender(&lt;CoreLayout {...props} /&gt;) <br class="title-page-name"/>}
</pre>
<p class="calibre2">First, we provide a component in the <kbd class="calibre11">shallowRender</kbd> method (in this example, it will be CoreLayout). Later, we use <kbd class="calibre11">method.render</kbd> and then we return the output with the use of <kbd class="calibre11">renderer.getRenderOutput</kbd>.</p>
<p class="calibre2">In our case, that function is called here (note that the semicolons are missing in the following example, because the starter that we are describing has different linting options than ours):</p>
<pre class="calibre22">
describe('(Layout) Core', function () { <br class="title-page-name"/>  let _component <br class="title-page-name"/>  let _props <br class="title-page-name"/>  let _child <br class="title-page-name"/><br class="title-page-name"/>  beforeEach(function () { <br class="title-page-name"/>    _child = &lt;h1 className='child'&gt;Child&lt;/h1&gt; <br class="title-page-name"/>    _props = { <br class="title-page-name"/>      children: _child <br class="title-page-name"/>    } <br class="title-page-name"/><br class="title-page-name"/>    _component = shallowRenderWithProps(_props) <br class="title-page-name"/>  }) <br class="title-page-name"/><br class="title-page-name"/>  it('Should render as a &lt;div&gt;.', function () { <br class="title-page-name"/>    expect(_component.type).to.equal('div') <br class="title-page-name"/>  }) <br class="title-page-name"/>})
</pre>
<p class="calibre2">You can find that the <kbd class="calibre11">_component</kbd> variable contains the result of the <kbd class="calibre11">renderer.getRenderOutput</kbd>. This value is asserted as follows:</p>
<pre class="calibre22">
expect(_component.type).to.equal('div')
</pre>
<p class="calibre2">In that test, we test our code if it returns <kbd class="calibre11">div</kbd>. But if you visit the documentation, then you can find the code example as follows:</p>
<pre class="calibre22">
&lt;div&gt; <br class="title-page-name"/>  &lt;span className="heading"&gt;Title&lt;/span&gt; <br class="title-page-name"/>  &lt;Subcomponent foo="bar" /&gt; <br class="title-page-name"/>&lt;/div&gt;
</pre>
<p class="calibre2">You can also find the assertion example as follows:</p>
<pre class="calibre22">
var renderer = ReactTestUtils.createRenderer(); <br class="title-page-name"/>result = renderer.getRenderOutput(); <br class="title-page-name"/>expect(result.type).toBe('div'); <br class="title-page-name"/>expect(result.props.children).toEqual([ <br class="title-page-name"/>  &lt;span className="heading"&gt;Title&lt;/span&gt;, <br class="title-page-name"/>  &lt;Subcomponent foo="bar" /&gt; <br class="title-page-name"/>]);
</pre>
<p class="calibre2">As you can see in the preceding two examples, you can expect a type as <kbd class="calibre11">div</kbd> or you can expect more specific information about the CoreLayout return (depending on your needs).</p>
<p class="calibre2">The first test asserts the type of a component (if it is <kbd class="calibre11">div</kbd>), and the second example test asserts if a CoreLayout returns correct components that are as follows:</p>
<pre class="calibre22">
[ <br class="title-page-name"/>  &lt;span className="heading"&gt;Title&lt;/span&gt;, <br class="title-page-name"/>  &lt;Subcomponent foo="bar" /&gt; <br class="title-page-name"/>]
</pre>
<p class="calibre2">The first one is a unit test because this isn't testing exactly if users see a correct thing. The second one is a behavioral test.</p>
<p class="calibre2">Generally, Packt has many books on <strong class="calibre1">Behavior-Driven Development</strong> (<strong class="calibre1">BDD</strong>) and <strong class="calibre1">Test-Driven Development</strong> (<strong class="calibre1">TDD</strong>).</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Continuous integration with Travis</h1>
            

            <article>
                
<p class="calibre2">In the given example, you can find a <kbd class="calibre11">.yml</kbd> file at <a href="https://github.com/davezuko/react-redux-starter-kit/blob/master/.travis.yml" class="calibre6"><span>https://github.com/davezuko/react-redux-starter-kit/blob/master/.travis.yml</span></a>.</p>
<p class="calibre2">This is a configuration file for Travis. What is this? It's a hosted CI service used to build and test software. Generally, it's a tool that is free for open source projects to use. If you want a hosted Travis CI for private projects, then their fees apply.</p>
<p class="calibre2">Configuration for Travis is made by adding the <kbd class="calibre11">.travis.yml</kbd> file, as mentioned earlier. The YAML form is a text file that is placed to the root directory of your project. This file's content describes all the steps that have to be done to test, install, and build a project.</p>
<p class="calibre2">The Travis CI goal is to make every commit to your GitHub account and to run the tests, and when the tests are passing, you can deploy the app to a staging server on an Amazon AWS. The continuous integration is not in the scope of this book, so if you are interested in adding this step to the whole publishing app project, there are books related to this as well.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
            

            <article>
                
<p class="calibre2"><span>Our publishing app is working. As with any digital project, there are still plenty of stuff that we can improve in order to have a better end product. For example, the following homework is for you:</span></p>
<ul class="calibre14">
<li class="calibre15">Add a minifaction on the frontend side so that it will be lighter when loading over the Internet.</li>
<li class="calibre15">As mentioned earlier, you need to start using Karma and Mocha for unit and behavioral tests. An example setup was described in detail in this chapter.</li>
<li class="calibre15">You need to choose a CI tool such as Travis, create your YML file, and prepare the environment on AWS.</li>
</ul>
<p class="calibre2">That is all you can additionally do besides all that has been covered in the 350+ pages of this book, where you built a full-stack React + Redux + Falcor + Node + Express + Mongo application. I hope to keep in touch with you; follow me on Twitter/GitHub in order to keep in touch or send me an e-mail if you have any additional questions.</p>
<p class="calibre2">Good luck in getting your hands dirty with the next commercial full-stack applications and see you again.</p>


            </article>

            <footer class="calibre4">
                
            </footer>

        </section>
    </body></html>