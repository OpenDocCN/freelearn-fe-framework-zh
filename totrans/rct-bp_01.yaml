- en: Chapter 1. Diving Headfirst into ReactJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome dear reader! In this book, you'll find a set of blueprints that you
    can use to develop modern web apps with ReactJS.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will introduce you to ReactJS and cover how to work with a component-based
    architecture. You will learn all the important concepts in ReactJS, such as creating
    and mounting components, working with props and states, understanding the life
    cycle methods, and setting up a development workflow for efficient development.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduce ReactJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explore the props and states
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn all about the important life cycle methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Walk through synthetic events and the virtual DOM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn the modern JavaScript developer's workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a basic scaffolding for all our apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even if you have previous experience with ReactJS, it's worth reading through
    this chapter, especially the scaffolding part, as we'll be using this scaffold
    for the majority of the blueprints in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin!
  prefs: []
  type: TYPE_NORMAL
- en: Introducing ReactJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To efficiently develop with ReactJS, it is vital to understand what it is and
    is not. ReactJS is not a framework. ReactJS describes itself as the **V** in the
    **MVC** (**Model-View-Controller**) design pattern. It's a view library that you
    can combine with frameworks such as **AngularJS**, **Ember**, and **Meteor** or
    even in conjunction with other popular JavaScript libraries, such as **Knockout**.
  prefs: []
  type: TYPE_NORMAL
- en: Many people use **React** on its own and combine it with a data flow pattern
    called **Flux**. The idea behind Flux is to establish unidirectional data flow,
    meaning that data should originate at a single point in your app and flow downwards.
    We'll look more closely into this pattern in [Chapter 2](ch02.html "Chapter 2. Creating
    a Web Shop"), *Creating a Web Shop*.
  prefs: []
  type: TYPE_NORMAL
- en: Modern JavaScript development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In 2015, JavaScript got its first major upgrade in many years. The syntax is
    JavaScript 2015\. You may know it as EcmaScript 6\. The EcmaScript committee decided
    on a name change in mid-2015, and from now on, JavaScript is going to be updated
    yearly. Modern browsers are slowly implementing support for the new features.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A note on the code you'll be seeing in this book. We will be using JavaScript
    2015 throughout the book. Evergreen browsers such as Firefox, Chrome, and Microsoft
    Edge will implement the new functionality on their own timeline, which means that
    some browsers may support new features before others, while some features may
    not be implemented at all.
  prefs: []
  type: TYPE_NORMAL
- en: You will most likely find yourself in a situation where you'd like to take advantage
    of new language features without wanting to wait for it to be implemented. Backwards
    compatibility is also an issue because you don't want to leave your users behind.
  prefs: []
  type: TYPE_NORMAL
- en: The solution to both of these concerns is to use a transpiler to generate a
    baseline EcmaScript-5-compatible code, such as **Traceur** or **Babel**. Since
    Babel was partly built with ReactJS in mind, I suggest that you go with this one,
    and throughout the book, we'll be depending on Babel for our transpiling needs.
  prefs: []
  type: TYPE_NORMAL
- en: We'll be exploring the modern developer's workflow in this book by developing
    and iterating a scaffolding or a basic setup that we can use when starting new
    projects. When setting up and using this scaffolding, we'll rely heavily on the
    terminal, `Node.js` and `npm`. Don't worry if this is unfamiliar ground for you.
    We'll go slow.
  prefs: []
  type: TYPE_NORMAL
- en: Component specification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ReactJS components have a built-in set of methods and properties that you'll
    come to rely on. Some of them are for debugging, such as `displayName` and `propTypes`;
    some for setting initial data, such as `getInitialState` and `getDefaultProps`;
    and finally, there are a number of methods dealing with the component life cycle,
    such as `componentDidMount`, `componentShouldUpdate`, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Props and states
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data within a component can come from the outside (*props*) or be instantiated
    from the inside (*states*).
  prefs: []
  type: TYPE_NORMAL
- en: For testability and immutability concerns, it's desirable to rely on data that
    is passed to components as much as possible rather than working with an internal
    state. However, there are lots of reasons why you'd want to use an internal state,
    so let's take a detailed look at props and states and when you want to use which.
  prefs: []
  type: TYPE_NORMAL
- en: Props
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s look at a simple component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When you execute this component, you will see the words **My first component**
    in your browser window.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the app renders to `div` with the `id` app.
  prefs: []
  type: TYPE_NORMAL
- en: 'The corresponding HTML file needs to look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This component defines a constant called `app`, which creates a React component
    with the built-in `createClass` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `rende`r method is the only required method in a ReactJS component. You
    can eschew all other methods, but this one. In `render`, you can either write
    a combination of HTML and JavaScript called **JSX** or compose your HTML code
    using ReactJS elements.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JavaScript doesn't understand JSX, so when you write JSX code, you need to convert
    it to JavaScript before executing it in the JavaScript environment. The easiest
    way to convert JSX is using the Babel transpiler because it will do this automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whichever way you decide to do it, the following JSX code will be transformed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It will be transformed to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `createElement()` method accepts three parameters: the `html` tag, a `null`
    field, and the HTML code. The second field is actually an object with properties
    (or `null`). We''ll get back to this a little bit later.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s introduce the concept of properties and make this component a bit more
    interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'All component properties are available for use by accessing `this.props`. Here,
    we set an initial message, **Hello World!**, and now, this is what you see when
    you execute the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Props](img/B04943_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Props cannot be modified and should be treated as immutable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that props are sent together with the call to the component.
  prefs: []
  type: TYPE_NORMAL
- en: You can send as many properties as you want, and they are always available under
    `this.props`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have multiple properties that you want to send, just add them sequentially
    to the component call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can set a component''s initial props by calling `getDefaultProps`. This
    can be helpful when you anticipate that a prop will be used, but it''s not available
    until a later point in the component''s life cycle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you call the component by adding a greeting, the component will simply show
    an empty page. If you don't have an initial prop, React will throw an error and
    complain that you're referencing a property that doesn't exist.
  prefs: []
  type: TYPE_NORMAL
- en: States
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'States are similar to props, but are meant for variables that are only available
    within the component. You can set a state in the same way as props:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, you can call the variable with `this.state`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Similar to props, if you try to use a nonexisting state variable, ReactJS will
    throw an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'A state is primarily used when you make changes that only make sense within
    the component. Let''s look at an example to understand this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set a `random_number` variable to `0`. We access the built-in `componentDidMount`
    method and start an interval that sets a new random number for this variable every
    second. In the render, we simply output the variable. Every time the state changes,
    ReactJS responds by re-rendering the output. Whenever you run `setState`, ReactJS
    triggers a re-render of the component. It's worth taking care to limit the number
    of times you apply `setState`, as you may run into performance issues if you're
    liberal with the use of them.
  prefs: []
  type: TYPE_NORMAL
- en: render
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the only required method in a component. It should return a single
    child element, such as a JSX structure, but if you don''t want to render anything,
    it can also return `null` or `false` to indicate that you don''t want anything
    rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: statics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This object can be used to define static methods that can be called on the
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that static methods don't have access to the props or state of your components.
  prefs: []
  type: TYPE_NORMAL
- en: propTypes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This object allows you to validate props being passed to your components. This
    is an optional tool to help you when developing your apps and will show up in
    your console log if the props you pass to a component do not match your specifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The final example creates a custom validator, which you can use to validate
    even more complex data values.
  prefs: []
  type: TYPE_NORMAL
- en: displayName
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This value is set automatically if you don''t set it explicitly, and it is
    used for debugging purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Life cycle methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Life cycle methods are a set of functions that you can override in your component.
    Initially, all but `shouldComponentUpdate` (which defaults to `true`) is empty.
  prefs: []
  type: TYPE_NORMAL
- en: componentDidMount
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is one of the most common methods you'll employ in your apps. Here's where
    you place any functions you want to run directly after the component has been
    rendered for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: You have access to the current contents of states and props in this method,
    but take care to never run `setState` in here, as that will trigger an endless
    update loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s worth noting that if you''re making a server-side app, this component
    will not be called. In this case, you''ll have to rely on `componentWillMount`
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: componentWillMount
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This method will be executed before the component is rendered for the first
    time. You have access to the current component's state and props here, and unlike
    `componentDidMount`, it's safe to run `setState` here (ReactJS will understand
    that state changes in this method should be set immediately and not trigger a
    re-render).
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is executed on both server-side and client-side apps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: shouldComponentUpdate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This method is invoked whenever the component receives new props or a change
    in state occurs.
  prefs: []
  type: TYPE_NORMAL
- en: By default, `shouldComponentUpdate` returns a `true` value. If you override
    it and return `false`, the component will never be updated despite receiving updated
    props or a new state. This can be useful if you create a component that should
    only be updated if certain conditions are met or if it should never be updated
    at all. You can benefit from speed increases if you set this to `false` when you
    have a component that should never be updated. However, you should take great
    care when using this method because careless use can lead to bugs that can be
    very hard to track down.
  prefs: []
  type: TYPE_NORMAL
- en: componentWillReceiveProps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This method lets you compare the incoming props and can be used as an opportunity
    to react to a prop transition before the render method is called. Invoke this
    method with `componentWillReceiveProps(object nextProps)` in order to access the
    incoming props with `nextProps`.
  prefs: []
  type: TYPE_NORMAL
- en: It's worth noting that if you call `setState` here, an additional re-render
    will not be triggered. It's not called for the initial render.
  prefs: []
  type: TYPE_NORMAL
- en: There's no analogous method to react to a pure state change, but you can use
    `componentWillUpdate` if you need a way to react to state changes before they
    are rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is not executed on the initial render:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: componentWillUpdate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This method is executed before the rendering, when the component receives new
    props or states but not on the initial render.
  prefs: []
  type: TYPE_NORMAL
- en: Invoke this method with `componentWillUpdate(object nextProps, object nextState)`
    in order to access the incoming props and states with `nextProps` and `nextState`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since you can evaluate a new state in this method, calling `setState` here
    will trigger an endless loop. This means that you cannot use `setState` in this
    method. If you want to run `setState` based on a prop change, use `componentWillReceiveProps`
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: componentDidUpdate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This method is executed whenever the component receives new props or states
    and the render method has been executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: componentWillUnmount
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The final life cycle method is `componentWillUnmount`. This is invoked just
    before the component is unmounted from the DOM. If you need to clean up memory
    or invalidate timers, this is the place to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Synthetic events and the Virtual DOM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's explore the differences between the regular DOM and the virtual DOM and
    what you need to consider when writing your code.
  prefs: []
  type: TYPE_NORMAL
- en: The DOM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Document Object Model** (**DOM**) is a programming API for HTML documents.
    Whenever you ask a browser to render HTML, it parses what you have written and
    turns it into a DOM and then displays it in the browser. It is very forgiving,
    so you can write invalid HTML and still get the result you want without even knowing
    you made a mistake.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, say, you write the following line of code and parse it with a
    web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, the DOM will show the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The DOM](img/B04943_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The closing `</p>` tag is automatically inserted for you, and a DOM element
    for the `<p>` tag has been created with all its associated properties.
  prefs: []
  type: TYPE_NORMAL
- en: ReactJS is not as forgiving. If you write the same HTML in your `render` method,
    it will fail to render and throw an `«Unterminated JSX contents»` error. This
    is because JSX requires a strict match between opening and closing tags. This
    is actually a good thing because it helps you with writing syntactically correct
    HTML.
  prefs: []
  type: TYPE_NORMAL
- en: The virtual DOM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The virtual DOM is basically a simpler implementation of the real DOM.
  prefs: []
  type: TYPE_NORMAL
- en: ReactJS doesn't work directly with the DOM. It uses a concept of virtual DOM,
    whereby it maintains a smaller and more simplified internal set of elements, and
    only pushes changes to the visible DOM when there has been a change of state in
    the set of elements. This enables you to switch out parts of your visible elements
    without the other elements being affected, and in short, this makes the process
    of DOM updates very efficient. The best part of this is that you get it all for
    free. You don't have to worry about it because ReactJS handles everything in the
    background.
  prefs: []
  type: TYPE_NORMAL
- en: It does, however, mean that you cannot look for changes in the DOM and make
    changes directly, like you would normally do with libraries, such as **jQuery**,
    or native JavaScript functions, such as `getElementById()`.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, you need to attach a reference named `refs` to the elements you want
    to target. You can do this by adding `ref="myReference"` to your element. The
    reference is now available through a call to `React.findDOMNode(this.refs.myReference)`.
  prefs: []
  type: TYPE_NORMAL
- en: Synthetic event handlers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever you call an event handler within ReactJS, they are passed an instance
    of **SyntheticEvent** instead of the native event handler. This has the same interface
    as the native event handler's, except it's cross-browser compatible so you can
    use it without worrying whether you need to make exceptions in your code for different
    browser implementations.
  prefs: []
  type: TYPE_NORMAL
- en: The events are triggered in a bubbling phase. This means that the event is first
    captured down to the deepest target and then propagated to outer elements.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you may find yourself wanting to capture the event immediately. In
    such cases, adding `Capture` behind the event can achieve this. For instance,
    to capture `onClick` immediately, use `onClickCapture` and so on.
  prefs: []
  type: TYPE_NORMAL
- en: You can stop propagation by calling `event.stopPropagation()` or `event.preventDefault()`
    where appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A complete list of the available event handlers is available at [https://facebook.github.io/react/docs/events.html](https://facebook.github.io/react/docs/events.html).
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we put all this together, we can extend the sample app with referenced
    elements and an event handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Let's start at the end. As we did earlier, we initialize our app by rendering
    a single ReactJS component called **app** with a single prop onto the element
    with the `#app` ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before the app mounts, we set initial values for our two state values: `greeting`
    and `message`. Before the app mounts, we set the state for greeting to be the
    same value as the greeting property passed to the app.'
  prefs: []
  type: TYPE_NORMAL
- en: We then add the input box and a clear button as well as some text in our `render`
    method and attach an `onChange` handler and an `onClick` handler to these. We
    also add `ref` to the input box.
  prefs: []
  type: TYPE_NORMAL
- en: After the component has mounted, we locate the message box by its `ref` parameter
    and tell the browser to focus on it.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can go the event handlers. The `onChange` handler is bound to `handleChange`.
    It will activate on every key press and save a new message state, which is the
    current content of the input box. ReactJS will then re-render the content in the
    `render` method. In the reconciliation process, it will note that the value in
    the input box is different from the last render, and it will make sure that this
    box is rendered with the updated value. At the same time, ReactJS will also populate
    the empty text element after **Your message:** with the state value.
  prefs: []
  type: TYPE_NORMAL
- en: The `handleClear` method simply resets the message state and clears the input
    box using `refs`.
  prefs: []
  type: TYPE_NORMAL
- en: This example is slightly contrived. It could be shortened quite a bit, and storing
    props as states is generally something you should avoid, unless you have a very
    good reason for doing so. In my experience, working with a local state is the
    single most bug-prone code you will encounter and the hardest code to write tests
    for.
  prefs: []
  type: TYPE_NORMAL
- en: Composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Composition is the act of combining things together to make more complex things
    and then putting these things together to make even more complex things, and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to put together ReactJS components is vital when creating apps that
    go beyond Hello World. An app composed of many small parts is more manageable
    than a single large monolith app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Composing apps is very simple with ReactJS. For instance, the Hello World app
    we just created can be imported into a new component with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In your new component, you can use the `HelloWorld` variable like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Every component you created can be imported and used in this manner, and this
    is one of the many compelling reasons for choosing ReactJS.
  prefs: []
  type: TYPE_NORMAL
- en: Developing with modern frontend tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's hard to overstate the importance of `Node.js` and `npm` in modern JavaScript
    development. These key pieces of technology are central to the development of
    JavaScript web apps, and we'll be relying on `Node.js` and `npm` for the applications
    that we will be developing in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js is available for Windows, Mac, and Linux, and is a breeze to install.
    We'll be using `Node.js` and `npm` for all of the examples in this book. We'll
    also be using EcmaScript 2015 and a transpiler to convert the code to a baseline
    JavaScript code that is compatible with older browsers.
  prefs: []
  type: TYPE_NORMAL
- en: If you haven't been using this workflow before, get ready to be excited because
    not only will it make you more productive, it will also open a world of developer
    goodness.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin.
  prefs: []
  type: TYPE_NORMAL
- en: Browserify
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The traditional method of developing for the Web had you manually adding scripts
    to your `index.html` file. It usually consisted of a mix of frameworks or libraries
    topped off with your own code, which you then added sequentially so that it was
    loaded and executed in the correct order. There are a few drawbacks to this method
    of development. Version control becomes difficult because you have no good way
    of controlling whether newer versions of your external libraries are compatible
    with the rest of your code. As a consequence, many web apps ship with old JavaScript
    libraries. Organizing your scripts is another problem because you have to add
    and remove old versions manually when upgrading. File size is also problematic
    because many libraries ship with more bells and whistles than you need.
  prefs: []
  type: TYPE_NORMAL
- en: Wouldn't it be nice if we had tools that could keep your dependencies up to
    date, inform you when there are incompatibility issues, and remove code you don't
    use? The answer to all of this is yes, and fortunately, such utilities exist.
  prefs: []
  type: TYPE_NORMAL
- en: The only drawback is that you have to change the way you write your code. Instead
    of writing scripts that rely on global environment variables, you write modular
    code that is self-contained, and you always specify your dependencies up front.
    If you think that this doesn't sound like much of a drawback, you're right. In
    fact, it's a huge improvement because this makes it very easy to read and understand
    code and allows easy dependency injection when writing tests.
  prefs: []
  type: TYPE_NORMAL
- en: Two of the most popular tools for assembling modular code are **Browserify**
    and **Webpack**.
  prefs: []
  type: TYPE_NORMAL
- en: In the beginning, we'll focus on **Browserify** for the simple reason that it's
    very easy to work with and has excellent plugin support. We'll look at **Webpack**
    in [Chapter 6](ch06.html "Chapter 6. Advanced React"), *Advanced React*. Both
    of these tools will analyze your application, figure out which modules you're
    using, and assemble a JavaScript file that contains everything you need to load
    the code in a browser.
  prefs: []
  type: TYPE_NORMAL
- en: In order for this to work, you need a base file, a starting point for your application.
    In our scaffold, we'll call this `app.jsx`. This file will contain references
    to your modules and the components that it uses. When you create new components
    and connect them to `app.jsx` or the children of `app.jsx`, **Browserify** will
    add them to the bundle.
  prefs: []
  type: TYPE_NORMAL
- en: A number of tools exist to enhance the bundle generation with Browserify. For
    EcmaScript 2015 and newer JavaScript code, we'll use **Babelify**. It's a handy
    tool that in addition to converting JavaScript to EcmaScript 5 will also to convert
    React-specific code such as JSX. In other words, you don't have to use a separate
    JSX transformer in order to use JSX.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also be using **Browser-sync**, which is a tool that auto reloads your
    code while you edit. This speeds up the development process immensely, and after
    using it for a while, you'll never want to go back to refreshing your app manually.
  prefs: []
  type: TYPE_NORMAL
- en: Scaffolding our React app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These are the steps we''ll be taking to set up our development workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an `npm` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a server file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a development directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create our base `app.jsx` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First of all, make sure that you have `npm` installed. If not, head over to
    [https://nodejs.org/download/](https://nodejs.org/download/) and download the
    installer. The detailed explanation of the preceding steps is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a directory where you want the app to be sorted and open a terminal window
    and `cd` in this folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize your app by typing `npm init` followed by the *Enter* key. Give the
    project a name and answer the few questions that follow or just leave them empty.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We''re going to grab a few packages from `npm` to get started. Issuing the
    following command will get the packages and add the dependencies to your newly
    created `package.json` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Babel requires a configuration file called `.babelrc`. Add it to the following
    code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new text file with your favorite text editor, add the following code,
    and save it as `server.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This segment sets up our app using **express** as our web server. It also initalizes
    `browserify`, `babelify`, and `browser-sync`. Finally, we set up our app to run
    on port `8080`. The line `process.env.PORT || 8080` simply means that you can
    override the port by prefixing the server script with `PORT 8085` to run on port
    `8085` or any other port you''d like to use:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This sets up Browserify to transform all code with that of the file extension
    `.jsx` with Babelify. The stage `0` configuration means that we want to use experimental
    code that has yet to be approved by the EcmaScript committee:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We want to reference our JavaScript bundle with `<script src="img/bundle.js"></script>`
    in our `index.html` file. When the web server notices a call for this file, we
    tell the server to send the browserified `app.jsx` file in our `source` folder
    instead:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With this configuration, we tell the web server to serve any of the listed
    files from `public.folder`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This line instructs the web server to serve `index.html` if the user accesses
    the root path:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, this runs the web server with `browser-sync`, proxying your app at
    the port you choose. This means that if you specify port `8080` as your port,
    your front-facing port will be a proxy port (usually `3000`), which will access
    `8080` on your behalf.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We tell `browser-sync` to monitor all JSX files in our `source/` folder and
    our CSS files in our `public/` folder. Whenever these change, `browser-sync` will
    update and refresh the page. We also tell it to ignore all the files in the `node_modules/`
    folder. This is generally wise to do because the folder will often contain thousands
    of files, and you don't want to waste time waiting for these files to be scanned.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, create two a directories called `public` and `source`. Add the following
    three files: `index.html` and `app.css` to your public folder and `app.jsx` to
    your `source` folder.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write this in the `index.html` file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write this in the `app.css` file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write this in the `app.jsx` file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Your file structure should now look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Scaffolding our React app](img/B04943_01_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Running the app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go the root of the app, type `node server`, and then press *Enter*. This will
    start a node server and in a few seconds, `browser-sync` will open a web browser
    with the location `http://localhost:3000`. If you have any other web servers or
    processes running on port `3000`, `browser-sync` will choose a different port.
    Take a look at the console output to make sure which port it has chosen.
  prefs: []
  type: TYPE_NORMAL
- en: You will see the contents of your render method from `app.jsx` on the screen.
    In the background, Browserify has employed Babelify to convert your JSX and ES2015
    code as well as your imported dependencies to a single `bundle.js` file that is
    served on `http://localhost:3000`. The app and CSS code will be refreshed every
    time you make a change in the code while this server is running, so I urge you
    to experiment with the code, implement a few life cycle methods, try working with
    states and props, and generally get a feel of working with ReactJS.
  prefs: []
  type: TYPE_NORMAL
- en: If this is your first time working with this kind of setup, I'd imagine you
    feel quite a rush surging through you right now. This setup is very empowering
    and fun to work with, and best of all, it's almost effortless to scaffold.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at all the important concepts you will come to work
    with when you develop applications with ReactJS. We looked at the component specification,
    how to compose components, and life cycle methods before we went to look at how
    to set up and structure a ReactJS app. Finally, we went through the scaffolding
    that we'll be using for the blueprints in this book.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll go through our first blueprint and create a web shop.
    We'll explore the concept of unidirectional data flow by taking advantage of the
    Flux pattern.
  prefs: []
  type: TYPE_NORMAL
