- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Session Management
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话管理
- en: 'Session management describes the process of preserving data across different
    user interactions and request-response roundtrips. Session management is crucial
    to provide personalized experiences on the web. In this chapter, we will work
    with Remix’s primitives to manage application state and user session data. This
    chapter covers the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 会话管理描述了在不同用户交互和请求-响应往返中保留数据的过程。会话管理对于在网络上提供个性化体验至关重要。在本章中，我们将使用 Remix 的原语来管理应用程序状态和用户会话数据。本章涵盖了以下主题：
- en: Working with search parameters
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用搜索参数
- en: Creating user sessions with cookies
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 cookies 创建用户会话
- en: Authenticating access to user data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证用户数据的访问权限
- en: First, we will work with Remix's primitives to tie application states to URL
    search parameters. Then, we will utilize HTTP cookies to persist user session
    data. Finally, we will use the session cookie to authenticate users in `loader`
    and `action` functions.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用 Remix 的原语将应用程序状态与 URL 搜索参数关联起来。然后，我们将利用 HTTP cookies 来持久化用户会话数据。最后，我们将使用会话
    cookie 在 `loader` 和 `action` 函数中验证用户身份。
- en: After reading this chapter, you will understand how to work with search parameters
    to control application states in Remix. You will also know how to submit forms
    programmatically using Remix’s `useSubmit` hook. You will further practice working
    with Remix’s session cookie helpers and learn how to implement login, signup,
    and logout functionalities in Remix. Finally, you will understand how to authenticate
    users on the server and how to access loader data globally across your application.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章之后，您将了解如何在 Remix 中使用搜索参数来控制应用程序状态。您还将知道如何使用 Remix 的 `useSubmit` 钩子程序来程序化地提交表单。您将进一步练习使用
    Remix 的会话 cookie 辅助工具，并学习如何在 Remix 中实现登录、注册和注销功能。最后，您将了解如何在服务器上验证用户身份，以及如何在您的应用程序中全局访问加载器数据。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the code for this chapter here: [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/blob/main/08-session-management/](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/blob/main/08-session-management/).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到本章的代码：[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/blob/main/08-session-management/](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/blob/main/08-session-management/)。
- en: Before starting this chapter, follow the instructions in the `README.md` file
    in this chapter’s `bee-rich` folder on GitHub. This `README` file guides you through
    adding a `User` model to the database schema of the BeeRich application. It further
    helps you initiate a `session.server.ts` file with some useful helper functions.
    Note that following the `README` guide will temporarily break the create and edit
    expense and income form actions. We will update the code in this chapter. Until
    then, use the seed data to populate the database for testing purposes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始本章之前，请遵循 GitHub 上本章 `bee-rich` 文件夹中的 `README.md` 文件中的说明。此 `README` 文件指导您将
    `User` 模型添加到 BeeRich 应用程序的数据库模式中。它还帮助您初始化一个包含一些有用辅助函数的 `session.server.ts` 文件。请注意，遵循
    `README` 指南将暂时中断创建和编辑费用和收入表单操作。我们将在本章中更新代码。在此期间，请使用种子数据来填充数据库以进行测试。
- en: Working with search parameters
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用搜索参数
- en: The URL stores information about the user’s current location. We already utilize
    dynamic route parameters for expense and invoice identifiers. Similarly, we can
    use URL search parameters to store additional application states.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: URL 存储有关用户当前位置的信息。我们已利用动态路由参数来处理费用和发票标识符。同样，我们可以使用 URL 搜索参数来存储额外的应用程序状态。
- en: A URL is the perfect place to persist state that concerns only one or a few
    pages. In this section, we will use URL search parameters to create a search filter
    on the expense overview page in BeeRich.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: URL 是持久化仅涉及一个或几个页面的状态的完美位置。在本节中，我们将使用 URL 搜索参数在 BeeRich 的费用概览页上创建一个搜索过滤器。
- en: 'Did you know that Google uses a search parameter to implement search queries?
    Open [google.com](http://google.com) and use the search input field to start a
    new Google search. After pressing *Enter*, Google navigates you to the search
    results page. If you inspect the URL, you will see that Google uses a search parameter
    called `q` (short for query probably) to store your search query: [https://www.google.com/search?q=Using+search+params+in+Remix.run](https://www.google.com/search?q=Using+search+params+in+Remix.run).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道吗？Google使用搜索参数来实现搜索查询？打开[google.com](http://google.com)，并使用搜索输入字段开始一个新的Google搜索。按下*Enter*后，Google会带你到搜索结果页面。如果你检查URL，你会看到Google使用一个名为`q`（可能是查询的简称）的搜索参数来存储你的搜索查询：[https://www.google.com/search?q=Using+search+params+in+Remix.run](https://www.google.com/search?q=Using+search+params+in+Remix.run)。
- en: Search parameters are key-value pairs that are added to the URL after the pathname
    following a question mark (`?`) and appended via ampersands (`&`). Search parameters
    allow us to store additional optional application states outside of the URL path.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索参数是添加到路径名之后、问号(`?`)之后的URL中的键值对，并通过`&`符号附加。搜索参数允许我们在URL路径之外存储额外的可选应用程序状态。
- en: Let’s build an experience similar to Google Search in BeeRich to filter the
    expense list through a search filter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在BeeRich中构建一个类似于Google搜索的体验，通过搜索过滤器过滤支出列表。
- en: Reading search parameters in loader functions
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在`loader`函数中读取搜索参数
- en: The expenses list is fetched and rendered in the `dashboard.expenses.tsx` route
    module. Now, we want to allow users to filter the list by using a search input
    field.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 支出列表在`dashboard.expenses.tsx`路由模块中获取并渲染。现在，我们希望允许用户通过搜索输入字段来过滤列表。
- en: 'We can divide the work into two steps:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将工作分为两个步骤：
- en: Update the database query so that it filters by a search query.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新数据库查询，使其通过搜索查询进行过滤。
- en: Provide the user with the UI so that they can enter search queries.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供用户界面，以便他们可以输入搜索查询。
- en: 'First, let’s update the `loader` function. The goal is to update the `loader`
    function so that it only fetches expenses that match the query string provided
    through the request URL:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们更新`loader`函数。目标是更新`loader`函数，使其只获取通过请求URL提供的查询字符串匹配的支出：
- en: Open the `dashboard.expenses.tsx` route module in your editor and inspect the
    module’s `loader` function.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的编辑器中打开`dashboard.expenses.tsx`路由模块，检查模块的`loader`函数。
- en: 'First, add the `request` parameter to the `loader` function arguments:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将`request`参数添加到`loader`函数的参数中：
- en: '[PRE0]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'export async function loader({ request }: LoaderFunctionArgs) {  q - short
    for query. You can find more information about the URL interface in the MDN Web
    Docs: https://developer.mozilla.org/en-US/docs/Web/API/URL.'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`export async function loader({ request }: LoaderFunctionArgs) {  q - 查询的简称。你可以在MDN
    Web文档中找到更多关于URL接口的信息：https://developer.mozilla.org/en-US/docs/Web/API/URL。'
- en: '[PRE1]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Update the database query so that it only returns the expenses where the title
    contains the search string:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新数据库查询，使其只返回标题包含搜索字符串的支出：
- en: '[PRE2]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If the URL does not contain a query string, we search against an empty string,
    which matches all expenses. In this case, the `loader` function behaves as before.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果URL不包含查询字符串，我们针对空字符串进行搜索，这将匹配所有支出。在这种情况下，`loader`函数的行为与之前相同。
- en: Run BeeRich in development mode by executing `npm run dev` in a terminal and
    navigate to the expenses overview page ([http://localhost:3000/dashboard/expenses](http://localhost:3000/dashboard/expenses)).
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在终端中执行`npm run dev`来以开发模式运行BeeRich，并导航到支出概览页面([http://localhost:3000/dashboard/expenses](http://localhost:3000/dashboard/expenses))。
- en: Since we didn’t include a query string in the URL, we still return the full
    list of expenses.
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们没有在URL中包含查询字符串，我们仍然返回完整的支出列表。
- en: Next, update the URL in the URL bar by adding a query string such as [http://localhost:3000/dashboard/expenses?q=Groceries](http://localhost:3000/dashboard/expenses?q=Groceries)
    and refresh the page. It should now display a filtered list of expenses.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过添加查询字符串（例如[http://localhost:3000/dashboard/expenses?q=Groceries](http://localhost:3000/dashboard/expenses?q=Groceries)）更新URL栏中的URL，并刷新页面。现在应该显示一个过滤后的支出列表。
- en: Great! The `loader` function now handles the `q` search parameters when present
    and returns a filtered list of expenses. Next, let’s add a search input field
    to let the user search for specific expenses.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在`loader`函数在存在`q`搜索参数时处理它，并返回一个过滤后的支出列表。接下来，让我们添加一个搜索输入字段，让用户可以搜索特定的支出。
- en: Updating search parameters with form submissions
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过表单提交更新搜索参数
- en: 'Next, we’ll provide the user with a search input field:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为用户提供一个搜索输入字段：
- en: Optionally, disable JavaScript to ensure the base implementation works without
    client-side JavaScript.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，禁用 JavaScript 以确保基本实现可以在没有客户端 JavaScript 的情况下工作。
- en: You can disable JavaScript in your browser’s developer tools or by removing
    the `Script` component in `root.tsx`.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以在浏览器开发者工具中禁用 JavaScript 或通过从 `root.tsx` 中移除 `Script` 组件来实现。
- en: 'Import Remix’s `Form` component from `@remix-run/react`:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `@remix-run/react` 中导入 Remix 的 `Form` 组件：
- en: '[PRE3]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: import { Input } from '~/components/forms';
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: import { Input } from '~/components/forms';
- en: '[PRE4]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, use the `Form` and `Input` components to implement a search input field
    between the **All expenses** screenreader heading and the unordered list of expenses:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用 `Form` 和 `Input` 组件在 **所有支出** 屏幕阅读器标题和无序列表支出之间实现一个搜索输入字段：
- en: '[PRE5]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Import the `useLocation` hook from Remix to access the current URL path:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Remix 中导入 `useLocation` 钩子以访问当前 URL 路径：
- en: '[PRE6]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Access the location in the function body of the route component:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在路由组件的功能体中访问位置：
- en: '[PRE7]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Use the path of the current location to set the form’s action dynamically:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用当前位置的路径动态设置表单的动作：
- en: '[PRE8]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: A submission now creates a GET request to the current page with an updated search
    parameter to filter the list of expenses.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提交现在会创建一个对当前页面的 GET 请求，并带有更新后的搜索参数以过滤支出列表。
- en: Try out the new search input field by typing a search query and hitting *Enter*
    to submit the form.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入搜索查询并按 *Enter* 键提交表单来尝试新的搜索输入字段。
- en: Note that the search input field is empty after every full-page reload, even
    when a `q` search parameter is set.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，在每次完整页面重新加载后，搜索输入字段都是空的，即使设置了 `q` 搜索参数。
- en: 'Import the `useSearchParams` hook from Remix:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Remix 中导入 `useSearchParams` 钩子：
- en: '[PRE9]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: const [searchParams] = useSearchParams();const searchQuery = searchParams.get('q')
    || '';
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: const [searchParams] = useSearchParams();const searchQuery = searchParams.get('q')
    || '';
- en: '[PRE10]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Use the `searchQuery` value as the `defaultValue` property for the input field:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `searchQuery` 值用作输入字段的 `defaultValue` 属性：
- en: '[PRE11]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![Figure 8.1 – Screenshot of the filtered expenses list](img/Figure_8.01_B17399.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1 – 过滤支出列表的截图](img/Figure_8.01_B17399.jpg)'
- en: Figure 8.1 – Screenshot of the filtered expenses list
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 过滤支出列表的截图
- en: Great! Hitting *Enter* after typing a search query submits the form and updates
    the URL so that it includes the search query. The `loader` function then returns
    an updated filtered list of expenses. Note that we didn’t use any React state
    to implement this feature, and as always, the search feature also works without
    JavaScript.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！在输入搜索查询后按 *Enter* 键会提交表单并更新 URL，使其包含搜索查询。然后 `loader` 函数返回更新后的过滤支出列表。注意，我们没有使用任何
    React 状态来实现此功能，并且始终如一，搜索功能在没有 JavaScript 的情况下也能工作。
- en: Mapping UIs to URLs
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 将 UI 映射到 URL
- en: The advantage of search parameters over React state is that they can be accessed
    on the server by reading from the request URL. Search parameters persist on full-page
    reloads and work with the browser’s back and forward buttons. Additionally, search
    parameters create URL variants that CDNs and browsers can cache.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索参数相较于 React 状态的优势在于它们可以通过读取请求 URL 在服务器上访问。搜索参数在完整页面重新加载时保持不变，并且与浏览器的后退和前进按钮一起工作。此外，搜索参数创建的
    URL 变体可以被 CDNs 和浏览器缓存。
- en: Implement the same behavior for the income overview route. Update the `dashboard.income.tsx`
    route module’s `loader` function and implement the search form to query invoices.
    Once the income route has been updated, we can enhance the experience with custom
    JavaScript.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为收入概览路由实现相同的行为。更新 `dashboard.income.tsx` 路由模块的 `loader` 函数并实现搜索表单以查询发票。一旦更新了收入路由，我们就可以通过自定义
    JavaScript 来增强体验。
- en: Programmatically submitting forms
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 程序化提交表单
- en: 'Currently, the user needs to press *Enter* to trigger a new search. Let’s add
    a debounced search that submits the form automatically whenever the user changes
    the value in the input field:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，用户需要按 *Enter* 键来触发新的搜索。让我们添加一个防抖搜索，当用户更改输入字段中的值时自动提交表单：
- en: 'First, import `useSubmit` from Remix:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，从 Remix 中导入 `useSubmit`：
- en: '[PRE12]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the route module’s component body, create a new submit function by calling
    `useSubmit`:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在路由模块的组件体中，通过调用 `useSubmit` 创建一个新的提交函数：
- en: '[PRE13]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add the following change event handler to the search input:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下更改事件处理程序添加到搜索输入：
- en: '[PRE14]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: On change, we programmatically submit the form using the `submit` function.
    We pass `submit` the HTML form element, accessing it from the event's target object.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在更改时，我们通过 `submit` 函数程序化地提交表单。我们将 `submit` 传递 HTML 表单元素，从事件的目标对象中访问它。
- en: Try out the current implementation and type something into the search input
    field.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试当前实现，并在搜索输入字段中输入一些内容。
- en: You may notice that we are currently submitting a new form for every change
    event. This is not very efficient. Instead, we should delay the submission until
    the user finishes typing. This method of delaying a function call is called debouncing.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能会注意到，我们目前为每个更改事件提交一个新的表单。这并不高效。相反，我们应该延迟提交，直到用户完成输入。这种延迟函数调用的方法称为防抖。
- en: 'Replace `Input` with `SearchInput`:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Input`替换为`SearchInput`：
- en: '[PRE15]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, update the JSX so that it renders `SearchInput` instead of the `Input`
    component:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，更新JSX以渲染`SearchInput`组件而不是`Input`组件：
- en: '[PRE16]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Since the submission is now handled inside the `SearchInput` component, remove
    the `useSubmit` hook from the `dashboard.expenses.tsx` route module.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于提交现在是在`SearchInput`组件内部处理的，因此请从`dashboard.expenses.tsx`路由模块中移除`useSubmit`钩子。
- en: 'You now know three ways of submitting data in Remix: the `Form` component,
    the `useFetcher` hook, and the `useSubmit` hook. This raises the question of when
    to best use which utility.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在知道了在Remix中提交数据的三种方式：`Form`组件、`useFetcher`钩子和`useSubmit`钩子。这引发了一个问题：何时最好使用哪种实用工具。
- en: When to use Remix data fetching primitives
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 何时使用Remix数据获取原语
- en: Use the `Form` component for the main interactions on the page. The `Form` component
    is the most straightforward way to implement a form interaction in Remix. Stick
    with the `Form` component for all simple use cases.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Form`组件处理页面上的主要交互。`Form`组件是实现Remix中表单交互的最直接方式。对于所有简单用例，请坚持使用`Form`组件。
- en: Use the `useSubmit` hook when you want to programmatically submit a `Form` component
    (for example, on change). You can add `useSubmit` to `Form` implementations to
    enhance the experience progressively.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想以编程方式提交`Form`组件（例如，在更改时）时，请使用`useSubmit`钩子。你可以将`useSubmit`添加到`Form`实现中，以逐步增强体验。
- en: Remember that there can only ever be one active navigation at a time. Use the
    `useFetcher` hook to implement a list of forms, or aside user interactions, that
    should support concurrent submissions. Aside interactions are usually not meant
    to trigger page navigations and should have access to isolated navigation states
    and action data. Whenever you want to trigger a `useFetcher` hook’s `Form` component
    programmatically, you can use `useFetcher.load` and `useFetcher.submit`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，一次只能有一个活动导航。使用`useFetcher`钩子实现应支持并发提交的表单列表或辅助用户交互。辅助交互通常不旨在触发页面导航，并且应该有权访问隔离的导航状态和操作数据。每当你想以编程方式触发`useFetcher`钩子的`Form`组件时，可以使用`useFetcher.load`和`useFetcher.submit`。
- en: In this section, you learned how to handle application state with the URL. You
    also learned that forms can execute GET requests by setting the form method to
    `"GET"`. Finally, you practiced how to programmatically submit a form with `useSubmit`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了如何使用URL处理应用程序状态。你还了解到，可以通过将表单方法设置为`"GET"`来执行GET请求。最后，你练习了如何使用`useSubmit`以编程方式提交表单。
- en: Ensure you update the income route to practice what you’ve learned in this section.
    Once you’ve done that, we can start investigating how to handle user sessions
    with cookies.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 确保更新收入路由以练习本节学到的内容。一旦完成，我们就可以开始调查如何使用cookie处理用户会话。
- en: Creating user sessions with cookies
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用cookie创建用户会话
- en: A session maintains the state of a user’s interactions with a web application
    across multiple requests. Sessions track information such as user authentication
    credentials, shopping cart contents, color scheme preferences, and other user-specific
    data. In this section, we will use Remix’s session cookie helpers to create a
    login and signup flow in BeeRich.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 会话在多个请求中维护用户与Web应用程序交互的状态。会话跟踪诸如用户认证凭据、购物车内容、颜色方案偏好以及其他特定于用户的数据。在本节中，我们将使用Remix的会话cookie助手在BeeRich中创建登录和注册流程。
- en: One way to manage sessions is via cookies. Cookies contain small pieces of data
    and are appended to both document and fetch requests, making them a great way
    to handle user sessions, personalization, and tracking. Additionally, cookies
    can be encrypted to securely carry user credentials without client access.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 管理会话的一种方式是通过cookie。cookie包含小数据块，并附加到文档和fetch请求中，这使得它们成为处理用户会话、个性化跟踪的绝佳方式。此外，cookie可以被加密，以安全地携带用户凭据，而无需客户端访问。
- en: Cookies are part of the HTTP protocol and enable persisting information in the
    otherwise stateless HTTP protocol. Where URL search parameters are visible to
    the user and can be bookmarked and shared, cookie data can be encrypted and are
    then only accessible on the server. Search parameters are handy for storing application
    states that are not tied to specific users. Cookies are ideal for authenticating
    users and storing small chunks of private session data.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Cookie 是 HTTP 协议的一部分，它使得在无状态的 HTTP 协议中持久化信息成为可能。与用户可见的 URL 搜索参数不同，cookie 数据可以被加密，并且只能在服务器上访问。搜索参数非常适合存储与应用程序状态相关但不特定于用户的会话。Cookie
    是用于用户身份验证和存储少量私有会话数据的理想选择。
- en: A web server can append a cookie to the current session by setting the **Set-Cookie**
    header on the HTTP response. Once a cookie has been set, the browser attaches
    the cookie using the **Cookie** header to all subsequent requests based on the
    lifetime specified during cookie setup.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一个网络服务器可以通过在 HTTP 响应中设置 **Set-Cookie** 标头来将 cookie 添加到当前会话中。一旦设置了 cookie，浏览器就会根据在
    cookie 设置期间指定的生命周期，使用 **Cookie** 标头将 cookie附加到所有后续请求中。
- en: 'Remix provides two different abstractions to work with cookies:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 提供了两种不同的抽象来处理 cookie：
- en: '`createCookie` to read and write cookies'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`createCookie` 用于读取和写入 cookie'
- en: '`createCookieSessionStorage` to implement a session storage using a cookie'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`createCookieSessionStorage` 用于实现使用 cookie 的会话存储'
- en: In this chapter, we will use Remix’s `createCookieSessionStorage` function since
    our goal is to implement user sessions for authentication and authorization. We
    will have a look at the `createCookie` helper function in [*Chapter 15*](B17399_15.xhtml#_idTextAnchor214),
    *Advanced Session Management,* to persist visitor tracking data.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 Remix 的 `createCookieSessionStorage` 函数，因为我们的目标是实现用户会话进行身份验证和授权。我们将在
    [*第 15 章*](B17399_15.xhtml#_idTextAnchor214) *高级会话管理* 中查看 `createCookie` 辅助函数，以持久化访客跟踪数据。
- en: Working with Remix’s session helpers
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Remix 的会话辅助函数
- en: 'Let’s implement the register and login pages in BeeRich:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 BeeRich 中实现注册和登录页面：
- en: First, follow the `README.md` file in this chapter’s folder on GitHub to prepare
    BeeRich for this section.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，遵循本章节文件夹中 GitHub 上的 `README.md` 文件来为 BeeRich 准备本节。
- en: Once you’ve followed the setup guide in the `README.md` file, open the `modules/session/session.server.ts`
    file in your editor.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您按照 `README.md` 文件中的设置指南完成设置后，打开编辑器中的 `modules/session/session.server.ts` 文件。
- en: 'Next, import the `createCookieSessionStorage` and `redirect` helper functions
    from Remix:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，从 Remix 中导入 `createCookieSessionStorage` 和 `redirect` 辅助函数：
- en: '[PRE17]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, add the following code below the already existing `registerUser` and `loginUser`
    functions:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在已经存在的 `registerUser` 和 `loginUser` 函数下方添加以下代码：
- en: '[PRE18]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Open the `.env` file in your project’s root folder and add a `SESSION_SECRET`
    environment variable:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目根目录中的 `.env` 文件中打开并添加一个 `SESSION_SECRET` 环境变量：
- en: '[PRE19]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: HTTP cookie signing involves adding a cryptographic signature to a cookie using
    a secret key known only to the server. When the client sends this signed cookie
    back in future requests, the server uses the secret key to verify that the cookie
    has not been tampered with. This adds an extra layer of security.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: HTTP cookie 签名涉及使用只有服务器知道的秘密密钥对 cookie 添加加密签名。当客户端在未来的请求中发送此已签名的 cookie 时，服务器使用秘密密钥来验证
    cookie 是否被篡改。这增加了额外的安全层。
- en: We read the environment variables when first starting our server environment.
    Make sure you restart your development server in case it is currently running
    to ensure the new environment variable is picked up.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在启动服务器环境时读取环境变量。确保您重启开发服务器，以防它目前正在运行，以确保新的环境变量被拾取。
- en: 'Finally, add the following helper function to the `session.server.ts` file:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将以下辅助函数添加到 `session.server.ts` 文件中：
- en: '[PRE20]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now that we can create new user sessions, let’s implement a signup flow to register
    new users.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够创建新的用户会话了，让我们实现一个注册流程来注册新用户。
- en: Adding a user registration flow
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加用户注册流程
- en: In this section, we will apply what we have learned thus far to implemnet a
    registration form and associated `action` function. Before reading through the
    solution, I encourage you to try it yourself. Start by updating the signup route
    module component. Then, add an `action` function and parse the form data.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将应用到目前为止所学的内容来实现注册表单和相关 `action` 函数。在阅读解决方案之前，我鼓励您自己尝试一下。首先，更新注册路由模块组件。然后，添加一个
    `action` 函数并解析表单数据。
- en: 'Now, let’s go through the implementation step by step:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们一步一步地实现：
- en: 'Open the `_layout.signup.tsx` route module and update the route module component:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`_layout.signup.tsx`路由模块并更新路由模块组件：
- en: '[PRE21]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that we use some reusable components to add our custom styles. Also, note
    that we set the form method to POST. A signup flow mutates data and must not be
    a GET request. Finally, we again utilize the `useNavigation` hook to add pending
    indicators when the form is submitting.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们使用了一些可重用的组件来添加我们的自定义样式。另外，注意我们设置了表单方法为POST。注册流程会修改数据，不能是GET请求。最后，我们再次利用`useNavigation`钩子来在表单提交时添加挂起指示器。
- en: 'Next, add an `action` function to handle registration form submissions:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一个`action`函数来处理注册表单提交：
- en: '[PRE22]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Import `useActionData` from Remix:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Remix导入`useActionData`：
- en: '[PRE23]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Access the error message action data in the route component:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在路由组件中访问错误消息操作数据：
- en: '[PRE24]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Import our styled inline error component:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入我们的样式内联错误组件：
- en: '[PRE25]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Render the `InlineError` component below the submit button to display any error
    messages:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提交按钮下方渲染`InlineError`组件以显示任何错误消息：
- en: '[PRE26]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Open the developer tools in your browser window and navigate to the **Application**
    tab:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的浏览器窗口中打开开发者工具并导航到**应用程序**标签页：
- en: '![Figure 8.2 – The Application tab of the developer tools](img/Figure_8.02_B17399.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – 开发者工具的应用程序标签页](img/Figure_8.02_B17399.jpg)'
- en: Figure 8.2 – The Application tab of the developer tools
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 开发者工具的应用程序标签页
- en: Under `httpOnly` flag.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在`httpOnly`标志下。
- en: Right-click on the cookie and select **Delete**.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击cookie并选择**删除**。
- en: This allows us to play around with the registration form a bit more before we
    implement our logout flow.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '这允许我们在实现登出流程之前对注册表单进行更多操作。 '
- en: Try to register the same email address again. You should now see an inline error.
    Awesome!
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次尝试使用注册流程中使用的电子邮件地址进行注册。你现在应该看到一个内联错误。太棒了！
- en: Feel free to spend more time on this section and investigate the code flow through
    the `action` function and the `session.server.ts` file. Use the `debugger` or
    `console.log` statements to review what happens during signup.
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 随意花更多时间在这一部分，并通过`action`函数和`session.server.ts`文件中的代码流来调查代码。使用`debugger`或`console.log`语句来检查注册过程中发生的情况。
- en: Once you feel comfortable with the added code, delete the cookie using the developer
    tools. This will let us implement and test the login flow.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你对添加的代码感到满意，使用开发者工具删除cookie。这将使我们能够实现和测试登录流程。
- en: Adding a user login flow
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加用户登录流程
- en: Copy and paste the route module component from the registration flow and see
    whether you can update it to make it work for the login page. Maybe try the same
    for the `action` function.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 将注册流程的路由模块组件复制并粘贴，看看你是否可以更新它使其适用于登录页面。也许你可以尝试对`action`函数做同样的操作。
- en: 'Once you have tried it out, let’s go through the implementation together:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你尝试过它，让我们一起来查看实现过程：
- en: 'Add the following code to update the `_layout.login.tsx` route component:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到更新`_layout.login.tsx`路由组件：
- en: '[PRE27]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The login and signup forms are nearly identical; only the number of input fields
    differs.
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 登录和注册表单几乎相同；只是输入字段的数目不同。
- en: 'Next, add the `action` function to handle the login form submissions:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加`action`函数来处理登录表单提交：
- en: '[PRE28]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Try out the login flow using the email address you used during the registration
    flow. You should now be able to register and log in to BeeRich.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你在注册流程中使用的电子邮件地址尝试登录流程。你现在应该能够注册并登录到BeeRich。
- en: So far, we have utilized session helper functions to create a user session after
    successful registration or login. By inspecting the developer tools, we ensured
    that the browser registered the cookie. Next, we’ll add a logout flow that removes
    the session cookie.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经利用会话辅助函数在成功注册或登录后创建用户会话。通过检查开发者工具，我们确保浏览器注册了cookie。接下来，我们将添加一个登出流程来删除会话cookie。
- en: Deleting a session during logout
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 登出时删除会话
- en: 'Removing a session cookie is straightforward. In `session.server.ts`, we have
    access to three session life cycle methods: `getSession`, `commitSession`, and
    `destroySession`. Follow these steps:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 删除会话cookie非常简单。在`session.server.ts`中，我们可以访问三个会话生命周期方法：`getSession`、`commitSession`和`destroySession`。按照以下步骤操作：
- en: 'Let’s add a helper function to `session.server.ts` to get the current user
    session from an incoming request:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`session.server.ts`中添加一个辅助函数来从传入的请求中获取当前用户会话：
- en: '[PRE29]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Add a logout function to `session.server.ts`:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`session.server.ts`中添加一个登出函数：
- en: '[PRE30]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'import type { ActionFunctionArgs } from ''@remix-run/node'';import { redirect
    } from ''@remix-run/node'';import { logout } from ''~/modules/session/session.server'';export
    function action({ request }: ActionFunctionArgs) {  action function that executes
    the logout function. This removes the session cookie and redirects the user to
    login. The logout route module also has a loader function to redirect all traffic
    to login. This is convenient if a user accidentally navigates to the logout page.Remember
    that Remix refetches all loader data from all active `loader` functions after
    an `action` function executes. Since `logout` mutates the server state (the user
    session), we use an `action` function and not a `loader` function to implement
    `logout`. After logging out, we want to remove all user-specific data from the
    page by revalidating all loader data.Note that the logout route module does not
    export a route component. Thus, it is not a document but a resource route.'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`import type { ActionFunctionArgs } from ''@remix-run/node'';import { redirect
    } from ''@remix-run/node'';import { logout } from ''~/modules/session/session.server'';export
    function action({ request }: ActionFunctionArgs) {  action function that executes
    the logout function. This removes the session cookie and redirects the user to
    login. The logout route module also has a loader function to redirect all traffic
    to login. This is convenient if a user accidentally navigates to the logout page.Remember
    that Remix refetches all loader data from all active `loader` functions after
    an `action` function executes. Since `logout` mutates the server state (the user
    session), we use an `action` function and not a `loader` function to implement
    `logout`. After logging out, we want to remove all user-specific data from the
    page by revalidating all loader data.Note that the logout route module does not
    export a route component. Thus, it is not a document but a resource route.`'
- en: '[PRE31]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Open the `dashboard.tsx` route module and locate the current logout link in
    the navigation bar:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`dashboard.tsx`路由模块，找到导航栏中的当前注销链接：
- en: '[PRE32]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Currently, the logout button is a placeholder linking to a non-existent page.
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 目前，注销按钮是一个占位符链接到一个不存在的页面。
- en: 'Import `Form` from Remix and replace the code to create a form that submits
    a POST request to the logout route:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Remix导入`Form`并替换代码以创建一个提交POST请求到注销路由的表单：
- en: '[PRE33]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Clicking the **Log out** link submits a form to the logout action function,
    redirecting the user to log in and removing the current user session cookie. And
    with that, we have successfully implemented a logout flow in BeeRich.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 点击**注销**链接会提交一个表单到注销动作函数，将用户重定向到登录并移除当前用户会话cookie。就这样，我们在BeeRich中成功实现了注销流程。
- en: In this section, we practiced creating and deleting session cookies using Remix’s
    session cookie helpers. Next, we will read from the session cookie to authenticate
    the user and return user-specific data from our `loader` functions.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们练习了使用Remix的会话cookie助手创建和删除会话cookie。接下来，我们将从会话cookie中读取以验证用户，并从我们的`loader`函数中返回特定于用户的数据。
- en: Authenticating access to user data
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证对用户数据的访问
- en: We can access cookies in our `loader` and `action` functions as cookies are
    appended to every HTTP request to the web server. This makes cookies a great tool
    for managing sessions. In this section, we will read from the session cookie to
    authenticate users and query user-specific data.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`loader`和`action`函数中访问cookie，因为cookie被附加到每个发送到Web服务器的HTTP请求中。这使得cookie成为管理会话的绝佳工具。在本节中，我们将从会话cookie中读取以验证用户并查询特定于用户的数据。
- en: Accessing cookie data on the server
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在服务器上访问cookie数据
- en: 'Once we append a cookie to a response, we can access the cookie data on every
    following request to the server. This lets us build personalized and session-based
    user experiences. Let’s add some helper functions to make this task easier:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将cookie附加到响应中，我们就可以在随后的每个对服务器的请求中访问cookie数据。这使我们能够构建个性化的基于会话的用户体验。让我们添加一些助手函数来简化这项任务：
- en: 'Add the following code to the `session.server.ts` file:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`session.server.ts`文件中：
- en: '[PRE34]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Add the following `loader` functions to the login and signup route modules:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`loader`函数添加到登录和注册路由模块中：
- en: '[PRE35]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this section, we implemented the `getUserId` and `getUser` helper functions.
    We use `getUserId` to check whether a user is logged in. Next, we will use `getUser`
    to get the user object of the currently logged-in user, if any.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们实现了`getUserId`和`getUser`助手函数。我们使用`getUserId`来检查用户是否已登录。接下来，我们将使用`getUser`来获取当前登录用户的用户对象（如果有的话）。
- en: Working with user data on the client
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在客户端处理用户数据
- en: 'In this section, we will use `getUser` to work with the user object of the
    currently logged-in user:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用`getUser`来处理当前登录用户的用户对象：
- en: First, import `LoaderFunctionArgs` and `getUser` in root.tsx.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在root.tsx中导入`LoaderFunctionArgs`和`getUser`。
- en: '[PRE36]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'export async function loader({ request }: LoaderFunctionArgs) {  getUser returns
    a user object without the password property. This is important as we forward the
    user object to the client. We must not leak user or app secrets to the client
    application.We can now access the user object with `useLoaderData` in `root.tsx`.
    However, we likely want to have access to the user object throughout our application.
    Let’s see how we can do this with Remix.'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`export async function loader({ request }: LoaderFunctionArgs) {  getUser`
    返回一个不带密码属性的用户对象。这很重要，因为我们把用户对象转发到客户端。我们不得向客户端应用程序泄露用户或应用程序的秘密。我们现在可以使用 `useLoaderData`
    在 `root.tsx` 中访问用户对象。然而，我们可能希望在整个应用程序中都能访问用户对象。让我们看看我们如何使用 Remix 来实现这一点。'
- en: '[PRE37]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Create a `session.ts` file in `app/modules/session`.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `app/modules/session` 中创建一个 `session.ts` 文件。
- en: We plan to create a small React hook to access the root loader user data across
    our React app. Since we also want to access the hook in our React app on the client,
    we must not put the hook in the `session.server.ts` file as it is only included
    in the server bundle.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们计划创建一个小的 React 钩子来访问 React 应用程序中的根 `loader` 用户数据。由于我们还想在客户端的 React 应用程序中访问该钩子，因此我们不应将钩子放在
    `session.server.ts` 文件中，因为它只包含在服务器包中。
- en: 'Add the following `useUser` hook to `session.ts`:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 `useUser` 钩子添加到 `session.ts`：
- en: '[PRE38]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Use the `useUser` hook in the `_layout.tsx` route component:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `_layout.tsx` 路由组件中使用 `useUser` 钩子：
- en: '[PRE39]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the unordered list of the navigation, replace the current **Log in** and
    **Sign in** list items with the following code:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在导航的无序列表中，将当前的 **登录** 和 **注册** 列表项替换为以下代码：
- en: '[PRE40]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We now conditionally render the **Log in** and **Sign up** links if no user
    is logged in or a link to **Dashboard** if a user is already logged in.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果没有用户登录或用户已登录，我们现在将条件性地渲染 **登录** 和 **注册** 链接，如果用户已登录，则显示 **仪表板** 链接。
- en: Note that the user object returned by `useUser` can also be `null`. We try to
    query a user object if a session exists or return `null` otherwise. However, sometimes,
    we must ensure that a user is logged in. We’ll look at enforcing authentication
    in the next section.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`useUser` 返回的用户对象也可以是 `null`。如果存在会话，我们尝试查询用户对象，否则返回 `null`。然而，有时我们必须确保用户已登录。我们将在下一节中查看如何强制执行身份验证。
- en: Enforcing authentication on the server
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在服务器上强制执行身份验证
- en: The dashboard routes of BeeRich are for logged-in users only. Can you think
    of a way to enforce that a session cookie is present?
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: BeeRich 的仪表板路由仅适用于已登录用户。你能想到一种强制检查是否存在会话cookie的方法吗？
- en: 'Let’s implement some authentication logic that redirects the user to the login
    page if no user session exists:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一些身份验证逻辑，如果不存在用户会话，则将用户重定向到登录页面：
- en: 'Create another helper function in `session.server.tsx`:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `session.server.tsx` 中创建另一个辅助函数：
- en: '[PRE41]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, add the following line to the top of all `loader` and `action` functions
    in the dashboard route modules:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将以下行添加到所有 `loader` 和 `action` 函数的顶部，在仪表板路由模块中：
- en: '[PRE42]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `requireUserId` call ensures that the user is redirected to the login page
    in case they are not authenticated.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`requireUserId` 调用确保如果用户未进行身份验证，则将用户重定向到登录页面。'
- en: Since `loader` functions run in parallel and `action` functions expose API endpoints
    over the internet, we must add the authentication check to every single `loader`
    and `action` function that requires authentication.
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于 `loader` 函数并行运行，而 `action` 函数通过互联网公开API端点，我们必须将身份验证检查添加到每个需要身份验证的 `loader`
    和 `action` 函数中。
- en: We must also ensure that we only retrieve data associated with the current `userId`.
    A user should not be able to view the expenses and invoices of other users. Let’s
    update our `loader` and `action` functions further.
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还必须确保我们只检索与当前 `userId` 相关的数据。用户不应能够查看其他用户的费用和发票。让我们进一步更新我们的 `loader` 和 `action`
    函数。
- en: 'Open the `dashboard.tsx` route module and update the `loader` function to require
    a user session and use `userId` to query user-specific expense and income objects:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `dashboard.tsx` 路由模块并更新 `loader` 函数，以便要求用户会话并使用 `userId` 查询特定于用户的费用和收入对象：
- en: '[PRE43]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Open the `dashboard.expenses.tsx` route module and update the `loader` function
    so that it checks for an existing user session:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `dashboard.expenses.tsx` 路由模块并更新 `loader` 函数，以便检查现有的用户会话：
- en: '[PRE44]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Open the `dashboard.expenses._index.tsx` route module and update the `action`
    function:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `dashboard.expenses._index.tsx` 路由模块并更新 `action` 函数：
- en: '[PRE45]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Open the `dashboard.expenses.$id.tsx` route module and update the `loader`
    function:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `dashboard.expenses.$id.tsx` 路由模块并更新 `loader` 函数：
- en: '[PRE46]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Update the `deleteExpense` handler function in `dashboard.expenses.$id.tsx`:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `dashboard.expenses.$id.tsx` 中的 `deleteExpense` 处理函数：
- en: '[PRE47]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Update the `updateExpense` handler function in `dashboard.expenses.$id.tsx`:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `dashboard.expenses.$id.tsx` 中的 `updateExpense` 处理函数：
- en: '[PRE48]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'export async function action({ params, request }: ActionFunctionArgs) {  requireUserId
    to enforce an existing user session. Then, we pass userId to the deleteExpense
    and updateExpense handler functions.That was quite a bit of code to go through,
    but by making some minor changes here and there, we have fully authenticated our
    application’s HTTP endpoints and ensured that only authenticated users can visit
    our dashboard pages.'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '导出异步函数 action({ params, request }: ActionFunctionArgs) {  requireUserId to
    enforce an existing user session. Then, we pass userId to the deleteExpense and
    updateExpense handler functions.That was quite a bit of code to go through, but
    by making some minor changes here and there, we have fully authenticated our application’s
    HTTP endpoints and ensured that only authenticated users can visit our dashboard
    pages.'
- en: '[PRE49]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Now is a good time to play around with BeeRich. See whether you can still access
    any of the dashboard routes without logging in first.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是玩 BeeRich 的好时机。看看你是否可以在不先登录的情况下访问任何仪表板路由。
- en: See whether you can hack into BeeRich by playing around with several tabs. Open
    the expense creation form in the first tab and log yourself out in the second
    tab. Can you still successfully create a new expense? Notice how cookies are appended
    and updated across different tabs.
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尝试通过在几个标签页中操作来破解 BeeRich。在第一个标签页中打开费用创建表单，并在第二个标签页中注销。你还能成功创建新的费用吗？注意 cookies
    在不同标签页之间的附加和更新情况。
- en: Securing loader and action functions
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 保护 loader 和 action 函数
- en: Remix’s `loader` functions run in parallel for faster execution. However, their
    concurrent nature also dictates that we must secure each loader function. Both
    `loader` and `action` functions are accessible over the internet and must be treated
    and secured like API endpoints.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Remix 的 `loader` 函数并行运行以提高执行速度。然而，它们的并发性也决定了我们必须保护每个 `loader` 函数。`loader` 和
    `action` 函数都可以通过互联网访问，必须像 API 端点一样处理和保护。
- en: We still need to update the income routes. This will be good practice to ensure
    you understand how to authenticate `loader` and `action` functions. Take your
    time and go over each `loader` and `action` function in the income routes to practice
    what you’ve learned in this chapter.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要更新收入路由。这将是一个很好的实践，以确保你理解如何验证 `loader` 和 `action` 函数。花些时间仔细检查收入路由中的每个 `loader`
    和 `action` 函数，以练习你在本章中学到的内容。
- en: In this section, you learned how to access state from session cookies in Remix
    and how to use session cookies to authenticate users in `loader` and `action`
    functions.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了如何在 Remix 中从会话 cookie 中访问状态，以及如何使用会话 cookie 在 `loader` 和 `action` 函数中验证用户。
- en: Summary
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about session and state management in Remix. First,
    you learned how to use URL search parameters to persist application state using
    Remix’s `Form` component and the `useSearchParams` hook. The URL is often all
    we need to handle application state.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了 Remix 中的会话和状态管理。首先，你学习了如何使用 URL 搜索参数通过 Remix 的 `Form` 组件和 `useSearchParams`
    钩子来持久化应用程序状态。URL 经常是我们处理应用程序状态所需的一切。
- en: You also practiced using `useSubmit` to submit a form programmatically and learned
    more about Remix’s different mutation utilities. We concluded that we use the
    `Form` component and the `useSubmit` hook for the primary actions on the page;
    `useFetcher` is used to support concurrent submissions with isolated submission
    states.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你还练习了使用 `useSubmit` 以编程方式提交表单，并更多地了解了 Remix 的不同突变工具。我们得出结论，我们使用 `Form` 组件和 `useSubmit`
    钩子来处理页面上的主要操作；`useFetcher` 用于支持具有隔离提交状态的并发提交。
- en: Next, you learned that cookies are part of the HTTP protocol and can be used
    to persist state across page transitions. Cookies are a great tool for session
    management. Remix provides helper functions for working with cookies and sessions.
    Remix’s session primitives allow us to manage sessions using different strategies,
    such as storing session data in memory, files, databases, or cookies.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你了解到 cookies 是 HTTP 协议的一部分，可以用于在页面转换之间持久化状态。Cookies 是会话管理的一个很好的工具。Remix
    提供了用于处理 cookies 和会话的辅助函数。Remix 的会话原语允许我们使用不同的策略来管理会话，例如在内存、文件、数据库或 cookies 中存储会话数据。
- en: We utilized Remix’s primitives to implement an authentication flow with login,
    signup, and logout functionalities in BeeRich. You learned how to authenticate
    users and use session cookies to query for user-specific content.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用 Remix 的原语在 BeeRich 中实现了一个包含登录、注册和注销功能的身份验证流程。你学习了如何验证用户并使用会话 cookie 查询特定用户的内容。
- en: On register and login, we create and fetch a user object and write `userId`
    to Remix’s session object. The object is then serialized to a string and added
    as a cookie to the HTTP response using the `loader` and `action` functions to
    authenticate user sessions and query user-specific data.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在注册和登录过程中，我们创建和获取用户对象，并将`userId`写入Remix的会话对象。然后，使用`loader`和`action`函数将该对象序列化为字符串，并添加到HTTP响应的cookie中，以验证用户会话和查询特定用户的数据。
- en: You also learned how to access loader data globally throughout your application
    using Remix’s `useRouteLoaderData` hook. You practiced creating a small custom
    hook to abstract accessing the user object from the root `loader`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学习了如何在你的应用程序中全局访问加载器数据，使用Remix的`useRouteLoaderData`钩子。你练习了创建一个小的自定义钩子，以抽象从根`loader`访问用户对象。
- en: After reading this chapter, you understand that `action` functions are standalone
    endpoints and `loader` functions run in parallel. Conclusively, we must authenticate
    the user in every restricted `loader` and `action` function to prevent unauthorized
    access.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章之后，你将理解`action`函数是独立的端点，而`loader`函数是并行运行的。最终，我们必须在每个受限的`loader`和`action`函数中验证用户，以防止未经授权的访问。
- en: In the next chapter, you will learn more about working with static assets and
    files in Remix.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何在Remix中处理静态资源和文件。
- en: Further reading
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Review the MDN Web Docs for more information about URL search parameters and
    the `URLSearchParams` interface: [https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams).'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 有关URL搜索参数和`URLSearchParams`接口的更多信息，请参阅MDN Web Docs：[https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams)。
- en: 'Also refer to the MDN Web Docs if you want to learn more about HTTP cookies:
    [https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies)
    or the `Headers` interface: [https://developer.mozilla.org/en-US/docs/Web/API/Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers).'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于HTTP cookie的信息，请参考MDN Web Docs：[https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies)或`Headers`接口：[https://developer.mozilla.org/en-US/docs/Web/API/Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers)。
- en: 'Refresh your knowledge about HTML forms by reading through the MDN Web Docs:
    [https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form).'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 通过阅读MDN Web Docs来刷新你对HTML表单的知识：[https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form)。
- en: 'Remix provides several primitives for working with sessions. You can find more
    information in the Remix documentation: [https://remix.run/docs/en/2/utils/sessions](https://remix.run/docs/en/2/utils/sessions).'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Remix为处理会话提供了几个原语。你可以在Remix文档中找到更多信息：[https://remix.run/docs/en/2/utils/sessions](https://remix.run/docs/en/2/utils/sessions)。
- en: 'Remix also provides lower-level primitives for working with cookies: [https://remix.run/docs/en/2/utils/cookies](https://remix.run/docs/en/2/utils/cookies).'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Remix还提供了用于处理cookie的底层原语：[https://remix.run/docs/en/2/utils/cookies](https://remix.run/docs/en/2/utils/cookies)。
