- en: Asynchronous Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步编程
- en: 'To learn what asynchronous code is, let''s first cover what synchronous code
    is. With synchronous code, you have one statement being executed after another.
    The code is predictable; you know what happens and when. This is because you can
    read the code from top to bottom like this:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解异步代码是什么，我们首先来了解一下同步代码是什么。使用同步代码，一个语句在另一个语句之后执行。代码是可预测的；你知道会发生什么以及何时发生。这是因为你可以像这样从上到下阅读代码：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, with asynchronous code you lose all the nice predictability that the synchronous
    code offers. In fact, there is very little you know about asynchronous code other
    than that it finishes executing, eventually. So asynchronous, or async, code looks
    more like this:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用异步代码，你将失去同步代码提供的所有美好的可预测性。事实上，关于异步代码，你了解的很少，除了它最终会执行完成。所以，异步代码，或者称为async代码，看起来更像是这样的：
- en: '[PRE1]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, the order in which a statement finishes is not determined by
    when a statement occurs in the code. Instead, there is a time element involved
    that decides when a statement has run its course.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，一个语句完成的顺序并不是由该语句在代码中出现的顺序决定的。相反，有一个时间元素参与其中，它决定了何时一个语句完成了它的运行过程。
- en: 'Asynchronous code runs in an event loop. This means that async code runs in
    the following order:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 异步代码在事件循环中运行。这意味着async代码按照以下顺序运行：
- en: Run async code
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行异步代码
- en: Wait for the response to be ready, then fire an interrupt
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待响应准备好，然后触发中断
- en: Run the event handler
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行事件处理器
- en: An important thing to stress here is that async code is non-blocking—other operations
    can take place while async code is running. Therefore, async code is a good candidate
    to be used when dealing with I/O, long-running tasks, and network requests.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要强调的一个重要事情是，异步代码是非阻塞的——其他操作可以在异步代码运行时进行。因此，异步代码是处理I/O、长时间运行的任务和网络请求的好候选。
- en: 'In this chapter, we will:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Learn what asynchronous programming is and how it differs from synchronous programming
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解异步编程是什么以及它与同步编程有何不同
- en: Explain the callback model
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释回调模型
- en: Describe promises and how they completely reformed how we write asynchronous
    code
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述承诺以及它们是如何完全改变我们编写异步代码的方式
- en: Look at which other asynchronous libraries exist and in what cases they should
    be used
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看其他存在的异步库以及它们应该在什么情况下使用
- en: Discover the new standard async/await
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现新的标准async/await
- en: The callback pattern
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回调模式
- en: 'Previously, we described what asynchronous and synchronous code looks like
    when you encounter it in your everyday life as a developer. What might be of interest
    is to know how an operating system looks at such code and how it deals with it.
    An operating system deals with asynchronous code by thinking of it in terms of
    the following concepts:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，我们描述了当你在作为开发者的日常生活中遇到异步和同步代码时，它们看起来是什么样子。可能有趣的是了解操作系统如何看待此类代码以及它是如何处理它们的。操作系统通过以下概念来处理异步代码：
- en: Events, these are messages that signals to the operating system that a certain
    type of action has occurred
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件，这些是向操作系统发出信号的消息，表明已经发生某种类型动作
- en: Event handler, this is the piece of code that should run when an event has occurred
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件处理器，这是当事件发生时应该运行的代码片段
- en: Event queue, this is where all events and their event handlers are placed, waiting
    to be executed
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件队列，这是放置所有事件及其事件处理器的位置，等待执行
- en: 'Let''s illustrate this flow in the following diagram:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以下图中说明这种流程：
- en: '![](img/479cdc64-c4d1-459e-86d2-c0d74e1b9a52.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/479cdc64-c4d1-459e-86d2-c0d74e1b9a52.png)'
- en: 'What we can see in the preceding image is how events are being picked from
    an event queue. Here, the **CLICK** event is being run when a Dispatcher tells
    it to and its corresponding event handler is executed. The event handler runs
    the associated lines of code in the event handler and when that''s done, gives
    control back to the Dispatcher. Thereafter, the cycle begins anew for the next
    event in the queue. This is what it usually looks like in a single-threaded system,
    where only one event handler is executed at a time. There is also such a thing
    as a multithreaded system. In a multithreaded system, multiple threads exist.
    This means we might have several event handlers being executed at once. But even
    though there are multiple threads, there is only one active thread. The system
    itself is still single-threaded. Confused? Here is the thing: threads in a multithreaded
    system are cooperative, which means they can be interrupted. This means that the
    active thread is changed after a unit of work has been carried out. This creates
    an effect where it seems like everything happens in parallel. Let''s illustrate
    this for clarity:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图像中，我们可以看到事件是如何从一个事件队列中被选取的。在这里，当分发器告诉它时，**点击**事件会被执行，并且相应的事件处理程序被执行。事件处理程序运行事件处理程序中的相关代码行，当完成时，将控制权交还给分发器。之后，队列中的下一个事件开始新一轮的循环。这就是在单线程系统中通常的样子，其中一次只执行一个事件处理程序。也存在多线程系统。在多线程系统中，存在多个线程。这意味着我们可能同时执行几个事件处理程序。但尽管有多个线程，只有一个活动线程。系统本身仍然是单线程的。困惑吗？这里的关键是：多线程系统中的线程是协作的，这意味着它们可以被中断。这意味着在完成一个工作单元后，活动线程会被改变。这产生了一种效果，似乎所有事情都在并行发生。让我们为了清晰起见来举例说明：
- en: '![](img/72f27ff3-d8a0-471b-942d-cd3010f29b8d.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/72f27ff3-d8a0-471b-942d-cd3010f29b8d.png)'
- en: Here, we can see that a piece of code is divided into different regions. When
    a certain region has been executed, it gives control to the next **Thread**, which
    becomes the new **Active thread**. Once that thread has executed code through
    one of its regions, it gives control to the next thread. With the arrival of multiple
    CPUs, we are able to go from perceived parallelism (described previously) to actual
    parallel execution. In such a reality, one thread per CPU exists and we therefore
    have multiple active threads.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到一段代码被分成了不同的区域。当某个区域被执行后，它将控制权交给下一个**线程**，这个线程成为新的**活动线程**。一旦该线程通过其某个区域执行了代码，它将控制权交给下一个线程。随着多个CPU的出现，我们能够从感知的并行性（之前已描述）转变为实际的并行执行。在这种现实中，每个CPU存在一个线程，因此我们有多条活动线程。
- en: These are the different ways you can execute asynchronous code. We will focus
    on single-threaded execution, as this is how it is implemented in JavaScript and
    on the web.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是您可以执行异步代码的不同方式。我们将关注单线程执行，因为这是JavaScript和网页中实现的方式。
- en: The callback pattern on the web
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网页上的回调模式
- en: 'The way to go about it is to attach functions to future events. When the event
    occurs, our attached function gets executed. An example of this is `XMLHttpRequest`,
    which looks like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 处理它的方法是附加函数到未来的事件上。当事件发生时，我们附加的函数被执行。一个例子是`XMLHttpRequest`，它看起来像这样：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'What we can see here is that all lines are executed synchronously except for
    `xhr.onload`. Attaching the function to `onload` happens synchronously, but running
    the function that `onload` is pointing to doesn''t happen until the request finishes.
    We can also define other events, such as `onreadystatechange` , and attach a function
    to that as well:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到除了`xhr.onload`之外的所有行都是同步执行的。将函数附加到`onload`是同步的，但是运行`onload`指向的函数不会发生，直到请求完成。我们也可以定义其他事件，例如`onreadystatechange`，并将一个函数附加到它上：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As the web is single-threaded, this is how we deal with asynchronous code. The
    `onreadystatechange` object and its callback are registered with the operating
    system. Once the asynchronous part has been completed the operating system is
    woken up by an event being dispatched. Thereafter, the callback is invoked.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于网页是单线程的，这就是我们处理异步代码的方式。`onreadystatechange`对象及其回调被注册到操作系统中。一旦异步部分完成，操作系统会被一个事件分发唤醒。之后，回调被调用。
- en: The callback pattern in Node.js
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js中的回调模式
- en: 'Node.js is single-threaded, just like the web. To handle long running operations
    it also uses a callback pattern. The callback pattern in Node.js has a a few more
    details to it and can be described as having the following properties:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js是单线程的，就像网络一样。为了处理长时间运行的操作，它也使用回调模式。Node.js中的回调模式有一些更详细的细节，可以描述为具有以下属性：
- en: There is only one function to handle success and error responses
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有一个函数来处理成功和错误响应
- en: The callback is called only once
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调只被调用一次
- en: The function is the last parameter of the calling function
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数是调用函数的最后一个参数
- en: The callback consists of the parameter's errors and results, in that order,
    which is also called error-first
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调包含参数的错误和结果，顺序排列，这也被称为错误优先
- en: 'Let''s now showcase what the calling code looks like, with a callback supplied
    as the function''s last argument:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来展示调用代码的样子，其中回调作为函数的最后一个参数提供：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This piece of code fulfills all the properties laid out by the pattern, namely
    that the last parameter in the function call is the callback function. Furthermore,
    the callback function has the error as the first parameter and the response as
    the second parameter. In addition, the body of the callback function checks whether
    there is an error first and then, in the absence of an error, deals with the response
    we get back.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码满足了模式所规定的所有属性，即函数调用中的最后一个参数是回调函数。此外，回调函数将错误作为第一个参数，将响应作为第二个参数。此外，回调函数的主体首先检查是否存在错误，然后在没有错误的情况下处理我们得到的响应。
- en: 'For reference, let''s also look at how `callAsync()` is implemented:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 作为参考，让我们也看看`callAsync()`是如何实现的：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding implementation is just a mockup but it does show off two important
    aspects. One aspect is the time factor the `setTimeout()` function represents
    and the fact that the function takes time to complete.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的实现只是一个原型，但它确实展示了两个重要的方面。一方面是`setTimeout()`函数所代表的时间因素，以及函数需要时间才能完成的事实。
- en: The other aspect is our third parameter, `fn()` which is invoked differently.
    We call `fn(null, 'success')` when everything is alright and `fn('error', null)`
    when an error has occurred. The way we invoke `fn()` is how we communicate success
    and failure.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面是我们的第三个参数`fn()`，它的调用方式不同。当一切顺利时，我们调用`fn(null, 'success')`；当发生错误时，我们调用`fn('error',
    null)`。我们调用`fn()`的方式就是如何传达成功和失败。
- en: Problems with structuring async code – callback hell
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构化异步代码的问题——回调地狱
- en: 'In the previous section, we introduced the callback pattern as a way to deal
    with asynchronous calls. The pattern offers a structured way of dealing with such
    calls, in that we can always know what to expect in its method signature; the
    error is the first parameter, the second parameter is the response, and so on.
    But the pattern does have its shortcomings. The shortcomings might not be obvious
    at first, because you might only call the code like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们介绍了回调模式作为处理异步调用的方法。该模式提供了一种处理此类调用的结构化方式，因为我们总可以在其方法签名中知道期望什么；错误是第一个参数，第二个参数是响应，依此类推。但是，该模式确实有其缺点。这些缺点可能一开始并不明显，因为你可能只是像这样调用代码：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: What we see here is how we invoke the method `openFile()`. Once that runs to
    completion, the callback is called and, inside of the callback, we continue invoking
    `statement4` and `statement5`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到的是如何调用`openFile()`方法。一旦它运行完成，回调就会被调用，并在回调内部，我们继续调用`statement4`和`statement5`。
- en: 'This looks okay in the sense that it is still readable. The problem arises
    when you need to do several async calls one after another and those calls are
    dependent upon each other. It might be that you first need to log in to a system
    and then fetch the other data, or it might mean that you need to make a call as
    to whose data needs to be used as input for the next call, like in this example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 从可读性的角度来看，这看起来是不错的。但是，当你需要连续进行多个异步调用，并且这些调用相互依赖时，问题就出现了。可能首先需要登录到系统中，然后获取其他数据，或者可能意味着你需要进行一个调用，以确定哪些数据需要作为下一个调用的输入，就像这个例子中一样：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The anti-pattern we see emerging here is that of tabulation and lost readability.
    For each call we make, we see the code is tabbed one step in; it's nested. When
    we have three calls like this, we can see that the code doesn't look very nice;
    it is readable, but not very pleasing to the eye. Another drawback is it's also
    technically hard to get right, in that we might struggle to place the parentheses
    and curly brackets in the correct place. Throw a few `if...else` clauses in there
    and you will have a hard time matching all the symbols.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到的一个反模式是表格化和可读性的丧失。对于每一次调用，我们看到代码缩进了一步；它是嵌套的。当我们有三次这样的调用时，我们可以看到代码看起来并不美观；它是可读的，但并不那么吸引人。另一个缺点是，从技术上讲，正确地放置括号和大括号也是一项技术挑战，我们可能会在放置这些符号时遇到困难。如果在其中加入几个`if...else`语句，你将很难匹配所有符号。
- en: 'There are several ways you can address this problem:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以解决这个问题：
- en: Keep the code shallow and use named functions over anonymous ones
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持代码简洁，并使用命名函数而不是匿名函数
- en: Reduce the cognitive load and move functions into their own modules
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少认知负担，并将函数移动到它们自己的模块中
- en: Use more advanced constructs, such as promises, generators, and async functions
    from ES7 and other async libraries
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用更高级的结构，例如Promise、生成器和ES7及其他异步库中的异步函数
- en: 'Keeping the code shallow is about giving our anonymous functions a dedicated
    name and breaking them out into their own functions; this will make our code look
    like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 保持代码简洁是关于给我们的匿名函数一个专有的名字并将它们拆分成自己的函数；这样我们的代码看起来会是这样：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This clearly flattens out the code and makes it more easier to read. It also
    removes the need to match curly brackets correctly as the functions are only one
    level deep.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这清楚地扁平化了代码，并使其更容易阅读。它还消除了正确匹配大括号的必要性，因为函数只有一层深度。
- en: 'This gets the code part out of the way, but there is still a cognitive load
    as we have to process three function definitions and one function call. We can
    move them out to their own dedicated modules, like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这将代码部分移除，但仍然存在认知负担，因为我们不得不处理三个函数定义和一个函数调用。我们可以将它们移动到它们自己的专用模块中，如下所示：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And for the other method, it would look like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他方法，它看起来会是这样：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以及这个：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now we have removed quite a lot of the cognitive code. It may not have paid
    for itself in this case, as the methods were not that long, but imagine the methods
    spanned 30 or 40 lines in size; putting them in a separate module would have made
    a lot more sense.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经移除了很多认知代码。在这个例子中，它可能没有物有所值，因为方法并不长，但想象一下，如果方法有30或40行长；将它们放入一个单独的模块中会更有意义。
- en: The third option is to deal with this kind of code using more advanced constructs.
    We will address these in the upcoming sections.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个选择是使用更高级的结构来处理这类代码。我们将在接下来的章节中讨论这些内容。
- en: Promises
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Promises
- en: 'Promises came about as a response to the callback hell problem described in
    the previous section. They have quite a long history, stretching back to the early
    80s, when the legendary *Barbara Liskov* coined the term `Promise`. The idea of
    a `Promise` is to flatten out async code. A promise is said to have the following
    states:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Promises的出现是对上一节中描述的回调地狱问题的一种回应。它们有着相当长的历史，可以追溯到20世纪80年代初，当时传奇人物*芭芭拉·利斯科夫*提出了`Promise`这个术语。`Promise`的想法是将异步代码扁平化。一个`Promise`据说有以下状态：
- en: '**Pending**: This means it has not yet been decided or that the data is not
    available yet'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pending**：这意味着它尚未决定，或者数据尚未可用'
- en: '**Fulfilled**: The data has come back'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Fulfilled**：数据已返回'
- en: '**Rejected**: An error happened during the operation'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Rejected**：操作过程中发生了错误'
- en: Thenables
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Thenables
- en: 'Something important to know is that a `Promise` returns straight away, but
    the result is not available straight away. Promises are also known as *thenables*,
    because you need to register a callback with its `then()` method once the data
    has been received, like so:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个重要的事情要知道，`Promise`会立即返回，但结果不会立即可用。Promise也被称为*thenables*，因为一旦数据接收，你需要使用其`then()`方法注册一个回调，如下所示：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code, we demonstrated how to create a promise and how to register
    it with the `then()` method. The `promise` variable instance contains a construct
    that is returned straight away. The callback in the `then()` method gets invoked
    once the data is ready for us to use. In that sense, a `Promise` resembles a callback
    pattern.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们展示了如何创建一个Promise以及如何使用`then()`方法注册它。`promise`变量实例包含一个会立即返回的结构。`then()`方法中的回调会在数据准备好供我们使用时被调用。从这个意义上说，`Promise`类似于回调模式。
- en: A `Promise` is really just a wrapping around an asynchronous construct.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise`实际上只是围绕异步构造的一个包装。'
- en: 'In short, to use Promises we need to:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，要使用Promises，我们需要：
- en: Create the `promise` and make sure to call `resolve()` or `reject()` when the
    data has arrived or an error has occurred
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建`promise`并确保在数据到达或发生错误时调用`resolve()`或`reject()`
- en: Register a callback with its `then()` method
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用其`then()`方法注册回调
- en: Register a callback to handle errors as well, as that is the responsible thing
    to do
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册一个回调来处理错误，因为这是负责任的做法
- en: 'To put a promise to use, we need to instantiate it and make it part of a method,
    like so:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用承诺，我们需要实例化它并使其成为方法的一部分，如下所示：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We see that; when we instantiate a `Promise` object, its constructor takes
    two parameters, `resolve` and `reject`. Let''s connect this to the states we know
    a promise can have, namely, pending, fulfilled, and rejected. When `getData()`
    is initially called, the `promise` returned and has the state `pending`. After
    a second, the promise will be fulfilled, because we called the `resolve()` method.
    Let''s look at the `getMoreData()` method to see how we can put a `Promise` into
    a rejected state:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，当我们实例化一个`Promise`对象时，它的构造函数接受两个参数，`resolve`和`reject`。让我们将这个与我们所知的承诺可以有的状态联系起来，即挂起、已解决和拒绝。当`getData()`最初被调用时，返回的`promise`处于`pending`状态。两秒后，承诺将得到解决，因为我们调用了`resolve()`方法。让我们看看`getMoreData()`方法，看看我们如何将`Promise`置于拒绝状态：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this case, we call the `reject()` method after a second. This will put the
    promise into a rejected state. To get the data from a `promise` instance, we need
    to call the `then()` method on it, like so:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们在两秒后调用`reject()`方法。这将使承诺处于拒绝状态。要从`promise`实例获取数据，我们需要在其上调用`then()`方法，如下所示：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'A promise''s `then()` method takes two callbacks: the first callback is the
    data callback and the second callback is an optional error callback. Let''s put
    this in use on our defined `getData()` method, like so:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺的`then()`方法接受两个回调：第一个回调是数据回调，第二个回调是可选的错误回调。让我们在我们的定义的`getData()`方法中使用它，如下所示：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It's clear that we can't just call `getData()` on the method straight away to
    get the data, but we need to call `.then()` on the `promise` it returns. Once
    we provide a callback, we are able to get the data and deal with it as we see
    fit.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，我们不能直接在方法上调用`getData()`来获取数据，但我们需要在它返回的`promise`上调用`.then()`。一旦我们提供了一个回调，我们就能获取数据并按我们的意愿处理它。
- en: Handling rejected promises
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理拒绝的承诺
- en: 'For a rejected promise, we have two ways of handling it: we can either use
    the second callback in the `.then()` method, or we can use the `.catch()` method.
    Here are the two versions available to us:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于拒绝的承诺，我们有两种处理方式：我们可以在`.then()`方法中使用第二个回调，或者我们可以使用`.catch()`方法。以下是我们可以使用的两个版本：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the first case, we have a second callback added to the `then()` method, and
    in the second version, we chain a `catch()` method to the existing `then()` method.
    They are equivalent so you can use either one, but only one.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，我们在`then()`方法中添加了第二个回调，而在第二种版本中，我们将一个`catch()`方法链接到现有的`then()`方法上。它们是等效的，所以你可以使用任何一个，但只能使用一个。
- en: Chaining – dealing with several promises
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链式操作 – 处理多个承诺
- en: 'The most powerful feature of the promise lies in its ability to chain calls,
    thereby making code look synchronous. A chain looks like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺最强大的功能在于其链式调用的能力，从而使代码看起来是同步的。一个链式调用看起来像这样：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This makes the code very easy to read. You are able to tell in which order
    things happen; namely, `getData()` followed by `getMoreData()`, followed by `getEvenMoreData()`.
    Not only are we able to run the methods in the order that we want, but we are
    also able to access the data from the previous `promise`, like so:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得代码非常易于阅读。你可以知道事情发生的顺序；即，`getData()`之后是`getMoreData()`，然后是`getEvenMoreData()`。我们不仅能够按照我们想要的顺序运行方法，而且还可以访问前一个`promise`中的数据，如下所示：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We can also see how we can add the `.catch()` method to the end to handle errors.
    The nature of chained promises are such that an error propagates all the way down
    to the `catch()` method.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到如何将`.catch()`方法添加到末尾以处理错误。链式承诺的性质是这样的，错误会一直传播到`catch()`方法。
- en: 'It is, however, quite possible to handle an error at a specific level, like
    so:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在特定级别处理错误是完全可能的，如下所示：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we have two error handlers, one at a local level `.then(getMoreData, (err)
    => {})` as the second argument in the `then()` method. This has a different effect
    than only adding `.catch()` to the bottom of our call chain. If only the `.catch()`
    method at the bottom exists, then the chain is short-circuited. As it stands,
    the current chain will call the local error function, the `.catch()` method, and
    the last `.then()` method when a `promise` is rejected from the `getMoreData()`
    method. The data parameter in the last `.then()` method will, however, not be
    set if the `promise` is rejected. Chaining is powerful and gives us the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个错误处理器，一个在本地级别，即`.then(getMoreData, (err) => {})`作为`then()`方法的第二个参数。这与只在调用链底部添加`.catch()`的效果不同。如果只有底部的`.catch()`方法存在，那么链路就会短路。目前，当`getMoreData()`方法拒绝`promise`时，当前链路将调用本地错误函数、`.catch()`方法和最后一个`.then()`方法。然而，如果`promise`被拒绝，最后一个`.then()`方法中的数据参数将不会被设置。链式调用非常强大，它给我们带来了以下功能：
- en: An ordered way of calling async methods
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按顺序调用异步方法
- en: The previously resolved promise data as input to our method
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将之前解析的承诺（promise）数据作为我们方法的输入
- en: The ability to handle errors globally as well as per promise, though with different
    results
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够全局处理错误以及针对每个承诺（promise）处理错误，尽管结果可能不同
- en: Asynchronous libraries
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步库
- en: 'So far, we have discussed callback patterns and how using promises gives your
    code that badly needed sense of order. Writing asynchronous code isn''t just about
    stopping yourself from drowning in messy code, it''s about being productive as
    well. Libraries exist out there that will make you really productive if you mean
    business about taking asynchronous coding head on. The best known libraries at
    the time of writing are:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了回调模式以及使用承诺如何给你的代码带来急需的秩序感。编写异步代码不仅仅是停止自己陷入混乱的代码中，它还关乎生产力。有些库可以让你在真正致力于直接处理异步编程时变得非常高效。在撰写本文时，最知名的库包括：
- en: '**Async**: This is by far the best known. It can be found at [https://caolan.github.io/async/](https://caolan.github.io/async/).'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Async**：这是最广为人知的。它可以在[https://caolan.github.io/async/](https://caolan.github.io/async/)找到。'
- en: '**Step**: This library sells itself as a library that will help you with serial
    execution, parallel execution, and promises to make error handling painless. It
    can be found at [https://github.com/creationix/step](https://github.com/creationix/step).'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤**：这个库将自己定位为一个可以帮助你进行串行执行、并行执行，并承诺使错误处理变得轻松的库。它可以在[https://github.com/creationix/step](https://github.com/creationix/step)找到。'
- en: '**Node fibers**: This is a very different library than the first two and can
    be thought of more as bringing a light-thread support to JavaScript. It can be
    found at [https://github.com/laverdet/node-fibers](https://github.com/laverdet/node-fibers).'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Node fibers**：这是一个与前面两个库非常不同的库，可以将其视为为JavaScript带来轻量级线程（light-thread）支持。它可以在[https://github.com/laverdet/node-fibers](https://github.com/laverdet/node-fibers)找到。'
- en: Async library
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Async库
- en: 'We have so far shown callbacks and Promises. We went from the problem with
    callbacks, namely callback hell, and how Promises solved that. However, there
    is a library called **async**, which is an alternative to callbacks and promises.
    So why would we want to use the async library instead? The async library is meant
    to operate on collections in an asynchronous context. The library authors themselves
    say this about it:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了回调和承诺。我们从回调的问题，即回调地狱，以及承诺是如何解决这个问题的。然而，有一个名为**async**的库，它是回调和承诺的替代品。那么，我们为什么要使用async库呢？async库旨在在异步上下文中操作集合。库的作者自己是这样说的：
- en: Async is a utility module which provides straight-forward, powerful functions
    for working with asynchronous JavaScript
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Async是一个提供直接、强大函数的实用模块，用于处理异步JavaScript
- en: So, if your asynchronous code starts to become unmanageable and you find yourself
    wanting to operate on asynchronous collections rather than a few calls here and
    there, this library might be for you. In most scenarios, promises are most likely
    what you want though.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你的异步代码开始变得难以管理，而你又发现自己想要操作异步集合而不是零散的几个调用，这个库可能适合你。在大多数情况下，承诺（promises）可能是你想要的。
- en: The async library comes with a lot of nice functionality. The idea of the async
    library is to make your code look a lot better so you can focus on building things
    instead of struggling to see what the code is doing.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Async库提供了许多有用的功能。Async库的思路是让你的代码看起来更好，这样你就可以专注于构建事物，而不是挣扎着去理解代码在做什么。
- en: 'To use it, simply install it by typing:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，只需通过输入以下命令进行安装：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: async.map()
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: async.map()
- en: 'Let''s have a look at an example where `async` shines and is able to remove
    unnecessary code. The following example shows how we call the `fs.stat()` method
    that will asynchronously tell us about a file, such as its size, when it was created,
    and so on. A normal call `fs.stat()` would look like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子，其中`async`大放异彩，能够移除不必要的代码。以下示例展示了我们如何调用`fs.stat()`方法，该方法将异步地告诉我们关于文件的信息，例如其大小、创建时间等。一个普通的调用`fs.stat()`看起来像这样：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'What if we wanted to make several calls and wanted to know the stats of several
    files? Firing off a number of calls- one per file- would mean our calls would
    come back at different times, depending on the size of the file. What if we don''t
    care about the response until everything comes back? This is what the async library
    can help us with. There is a `map()` function that will allow us to fire off several
    calls at once and only return once all the calls are done, like so:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要进行多个电话并且想要知道几个文件的状态呢？一次发送多个电话——每个文件一个电话——意味着我们的电话会在不同时间返回，这取决于文件的大小。如果我们不介意在所有电话都返回之前不关心响应怎么办？这正是异步库能帮助我们解决的问题。这里有一个`map()`函数，它允许我们同时发送多个电话，并且只有在所有电话都完成后才返回，如下所示：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'So, what makes this so great? First off, our code aims to find out some file
    statistics about every file. Let''s look at what life would look like without
    the async library:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，是什么让它如此出色呢？首先，我们的代码旨在找出每个文件的一些文件统计信息。让我们看看没有异步库的生活会是什么样子：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We can see that we need to introduce a states array just to collect all the
    results and even then, we probably need to add some logic to know that we are
    on the last item in the array and can therefore start processing based on the
    fact that we now have all the results. Conversely, using `async.map()` means we
    have access to a function that collects the result in an array and also waits
    until the full array has been processed and all the results have come back.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们需要引入一个状态数组来收集所有结果，即使这样，我们可能还需要添加一些逻辑来知道我们是否处于数组的最后一个项目，因此可以根据我们现在已经拥有所有结果的事实开始处理。
- en: So, the takeaway from all this is that `async.map()` helps us call a list of
    asynchronous calls into one call enabling us to process all the results once every
    single call is done, not before.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从所有这些中我们可以得出的结论是，`async.map()`帮助我们调用一系列异步调用到一个调用中，使我们能够在每个电话完成后处理所有结果，而不是在之前。
- en: async.parallel()
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: async.parallel()
- en: 'Another important method in this library is `async.parallel()`, which lets
    us send off a lot of statements in parallel, like so:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库中另一个重要的方法是`async.parallel()`，它允许我们并行发送很多语句，如下所示：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: What we can see from the previous code is that it allows us to kick off several
    calls in parallel. We specify the calls in an array that we provide to the `async.parallell([])`
    method. From what you can discern here, the functions we provide take one parameter,
    `fn`, which is the callback, for example `getOrders(fn) {}`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中我们可以看到，它允许我们并行启动多个电话。我们在提供给`async.parallell([])`方法的数组中指定电话。从你在这里可以辨别出的信息来看，我们提供的函数接受一个参数，`fn`，它是回调函数，例如`getOrders(fn)
    {}`。
- en: async.series()
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: async.series()
- en: 'Another scenario is that you might want to actually have the calls happen one
    after another. For that, we get the `async.series()` method, which we call like
    this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种情况是，你可能希望电话一个接一个地发生。为此，我们得到了`async.series()`方法，我们这样调用它：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Running the code like this guarantees the order in which it will be run, but
    also ensures that the chain of calls does not continue if there is an error.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式运行代码保证了代码的运行顺序，同时也确保了如果发生错误，调用链不会继续。
- en: There are a ton of useful functions in this library and we urge you to have
    a look at the documentation at [https://caolan.github.io/async/docs.html](https://caolan.github.io/async/docs.html).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库中有许多有用的函数，我们强烈建议您查看[https://caolan.github.io/async/docs.html](https://caolan.github.io/async/docs.html)上的文档。
- en: Async/await
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Async/await
- en: 'The async/await is part of the ECMAScript standard ES2017\. This construct
    provides a synchronous-looking experience when dealing with async. Currently,
    you need something like Babel to run it in the frontend, but for Node.js it is
    sufficient to run it on version >= 8\. Async/await is currently implemented with
    a concept called generators in the background. Generators are functions that can
    be exited and re-entered later. To read more about generators, have a look at
    the following link: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*).
    It is the new way of dealing with asynchronous code and it really helps make our
    code look synchronous, which takes away a lot of the cognitive pain associated
    with asynchronous programming.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: async/await是ECMAScript标准ES2017的一部分。这个构造在处理异步操作时提供了同步的体验。目前，您需要像Babel这样的工具在前端运行它，但对于Node.js来说，在版本>=
    8上运行它就足够了。Async/await在后台通过一个称为生成器（generators）的概念来实现。生成器是可以在之后退出和重新进入的函数。要了解更多关于生成器的信息，请查看以下链接：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*)。这是处理异步代码的新方法，它确实有助于使我们的代码看起来更同步，从而减少了与异步编程相关的认知痛苦。
- en: 'Let''s remind ourselves of our old example, illustrating the callback hell
    situation:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们的旧例子，说明回调地狱的情况：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We clearly see the downsides to calling the code this way. The async/await
    plays the role of a savior, in that it really cleans things up here. However,
    let''s first explain the different parts and how we can work towards refactoring
    the previous example. A method using async/await is usually the highest-level
    method; the highest level in the sense that it is the first method to be called
    in a chain of `async` methods. In the previous example, this would be the `getData()`
    method. Let''s transform `getData()` to look like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们清楚地看到了以这种方式调用代码的缺点。async/await扮演了救世主的角色，因为它确实清理了这里的事情。然而，让我们首先解释不同的部分以及我们如何努力重构先前的例子。使用async/await的方法通常是最高级的方法；在链式`async`方法中的最高级意味着它是第一个被调用的方法。在先前的例子中，这将是由`getData()`方法。让我们将`getData()`转换成如下形式：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'What we need to realize at this point, is that we need to refactor the other
    two methods, `getMoreData()` and `getEvenMoreData()`, into methods that return
    promises instead of being callback-based. Why is that, you might wonder? Well,
    when we use async/await, we want to call the code in a certain way. As hinted
    at earlier, we will use the keyword `async` in front of our `getData()` function.
    What''s more is that we want to use the keyword `await` in the following way:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们需要意识到的是，我们需要将另外两个方法`getMoreData()`和`getEvenMoreData()`重构为返回Promise而不是基于回调的方法。为什么你会这样问呢？好吧，当我们使用async/await时，我们希望以某种方式调用代码。正如之前所暗示的，我们将在`getData()`函数前使用关键字`async`。更重要的是，我们希望以下方式使用关键字`await`：
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Looking at the preceding code, we realize that there is a mismatch in our existing
    method signature. The mismatch is not the main reason we need to switch our implementation
    to being promise-based. The real reason is the fact the `await` keyword is able
    to unwrap promises but not callback based methods. Unwrapping means it can take
    the resulting value of our asynchronous operation and return it.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 看看前面的代码，我们意识到我们的现有方法签名存在不匹配。不匹配不是我们需要将我们的实现切换为基于Promise的主要原因。真正的原因是`await`关键字能够展开Promise，但不能展开基于回调的方法。展开意味着它可以从我们的异步操作的结果中取出值并返回。
- en: 'The current state of our methods before changing them into promises is:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在将它们转换为Promise之前，我们的方法当前的状态是：
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Turning them into promise-based methods means they should now look something
    like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 将它们转换为基于Promise的方法意味着它们现在应该看起来像这样：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'At this point, we are ready to return back to our `getData()` method and add
    the missing code. When we call `getMoreData()` and `getEvenMoreData()`, we can
    now use the keyword `await` to wait for the promise to resolve, like so:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们准备返回到`getData()`方法并添加缺失的代码。当我们调用`getMoreData()`和`getEvenMoreData()`时，我们现在可以使用关键字`await`等待Promise解析，如下所示：
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'What we get now is completely synchronous-looking code. How do we retrieve
    the data from `getData()` though? Easy—it returns a `promise`. So, we can call
    it like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们得到的是完全同步看起来似的代码。那么我们如何从`getData()`中检索数据呢？很简单——它返回一个`promise`。因此，我们可以这样调用它：
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The async/await is a truly powerful construct, in that it takes away a lot of
    the cognitive pain caused by callback hell and further improves upon the concept
    of promises.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: async/await 真的是一个强大的结构，因为它消除了由回调地狱引起的许多认知痛苦，并进一步改进了承诺的概念。
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we have covered asynchronous code, when it is used, and for
    what purposes. It is clear that asynchronous code becomes harder and harder to
    read and maintain as it grows, giving rise to patterns such as callback hell.
    There are several techniques to deal with this, as described throughout this chapter.
    Changing your coding style a little is one way. Looking at constructs such as
    promises, especially in conjunction with async/await, is another way. Using async/await
    means we suddenly get something that can be likened to order in your async code.
    We have tried to keep things as framework free as possible as it is important
    to understand all the mentioned concepts without mixing them up with concepts
    from a specific application framework. One thing can be said though: Angular allows
    you to use whichever asynchronous method you want to organize your code. Doing
    HTTP calls, for example, uses an Angular service that is strongly tied to the
    RxJS library, but you are free to use a promise-based style such as the `fetch()`
    API. It is also possible to leverage async/await with Angular using Babel and
    the transformer that supports it.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了异步代码的使用情况及其目的。很明显，随着异步代码的增多，其可读性和可维护性会越来越低，从而产生了诸如回调地狱等模式。本章描述了处理这些问题的几种技术。改变你的编码风格是一种方法。查看诸如承诺（promises）之类的结构，尤其是在与async/await结合使用时，是另一种方法。使用async/await意味着我们突然获得了一种可以类比为异步代码中的顺序的东西。我们尽量保持尽可能不依赖框架，因为理解所有提到的概念而不将它们与特定应用框架的概念混淆是很重要的。尽管如此，可以说：Angular
    允许你使用任何你想要的异步方法来组织你的代码。例如，进行HTTP调用时，使用的是与RxJS库紧密相关的Angular服务，但你也可以自由地使用基于承诺的样式，如`fetch()`
    API。使用Babel和它支持的转换器，也可以利用Angular中的async/await。
- en: This chapter has laid a foundation for what asynchronous coding is. The next
    chapter will build on that foundation by introducing the concept of **Functional
    Reactive Programming** (**FRP**). It deals more with how to reason around the
    fact that data arrives seemingly when it wants to. As messy as that sounds, even
    that can be modeled to create a sense of structure and order if we think of our
    data as a stream. More on that in the next chapter.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为异步编程奠定了基础。下一章将通过介绍**函数式响应式编程**（**FRP**）的概念来在此基础上进行构建。它更多地涉及如何处理数据似乎在它想出现的时候出现的事实。尽管听起来很混乱，但如果我们将数据视为流，即使是这种情况也可以被建模，以创建一种结构和秩序的感觉。更多内容将在下一章中介绍。
