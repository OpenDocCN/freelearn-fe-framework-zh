- en: Customization and Further Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we saw how to use the JHipster Domain Language to
    model and generate our domain model. We also learned about entity relationships
    and the `import-jdl` sub-generator. In this chapter, we will see how we can further
    customize and add business logic to the generated application to suit our needs.
    We will learn about:'
  prefs: []
  type: TYPE_NORMAL
- en: Live reload with Spring DevTools and BrowserSync
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing the angular frontend for an entity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Editing an entity created using the JHipster entity generator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the look and feel of the application using a Bootstrap theme
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a new i18n language using the JHipster language generator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing the generated REST API to add additional role-based authorization
    with Spring Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating new Spring Data JPA queries and methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Live reload for development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When developing an application, one of the most annoying and time-consuming
    parts is recompiling the code and restarting the servers to see the code changes
    we have made. Traditionally, JavaScript code used to be easier, as it didn''t
    need any compilation and you could just refresh the browser and see the changes.
    However, even though current MVVM stacks make the client side more important than
    before, they also introduce side effects, such as transpiling of client-side code,
    and more. So, if you are refactoring a field for an entity, you would traditionally
    need to do the following tasks to see the changes in your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: Compile the server-side Java code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply the table changes to the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recompile the client-side code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Restart the application server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refresh the browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This takes a lot of time, is frustrating to do for every small change, and results
    in you making more changes before checking them, hence affecting productivity.
  prefs: []
  type: TYPE_NORMAL
- en: What if I told you that you don't have to do any of these, and all of this could
    happen automatically as you save your changes using your IDE? That would be awesome,
    wouldn't it?
  prefs: []
  type: TYPE_NORMAL
- en: With JHipster you get exactly that. JHipster uses Spring Boot DevTools, webpack
    dev server, and BrowserSync to enable a nice live reload feature for the end-to-end
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a quick look at the technologies used.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot DevTools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Boot DevTools ([https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-devtools.html](https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-devtools.html))
    enables Spring Boot applications to reload the embedded server when there is a
    change in the classpath. It states the following—*The aim of this module is to
    try and improve the development-time experience when working on Spring Boot applications*, and
    it does exactly that. It uses a custom classloader to restart the application
    when a class is updated and recompiled, and since the server is hot reloaded it
    is much faster than a cold restart.
  prefs: []
  type: TYPE_NORMAL
- en: It isn't as cool as JRebel or similar technologies, which do instant reload,
    but it beats doing it manually and doesn't require any extra configuration to
    enable it.
  prefs: []
  type: TYPE_NORMAL
- en: JHipster DevTools is automatically enabled in the `dev` profile, using an IDE
    that can automatically recompile classes on saving. The DevTools will ensure the
    application is reloaded and up to date. Since Liquibase is used, any schema updates
    using proper changelogs will also get updated. Make sure not to change existing
    changelogs as it will cause a checksum error. Application reloads can also be
    triggered by simply using the commands `mvnw compile` or `gradlew compileJava`
    depending on the build tool used.
  prefs: []
  type: TYPE_NORMAL
- en: If you choose a NoSQL DB, such as MongoDB, Cassandra, or Couchbase, JHipster
    provides database migration tools for those as well.
  prefs: []
  type: TYPE_NORMAL
- en: Webpack dev server and BrowserSync
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Webpack dev server ([https://github.com/webpack/webpack-dev-server](https://github.com/webpack/webpack-dev-server))
    provides a simple Express server using webpack dev middleware, and supports live
    reloads when assets change. Webpack dev middleware supports features such as hot
    module replacement and in memory file access.
  prefs: []
  type: TYPE_NORMAL
- en: In Webpack Version 4 and above a new alternative called webpack-serve ([https://github.com/webpack-contrib/webpack-serve](https://github.com/webpack-contrib/webpack-serve))
    is used instead of Webpack dev server. It uses native WebSocket support in newer
    browsers.
  prefs: []
  type: TYPE_NORMAL
- en: BrowserSync ([https://browsersync.io/](https://browsersync.io/)) is a Node.js
    tool that helps in browser testing by synchronizing file changes and interactions
    of the web page across multiple browsers and devices. It provides features such
    as auto-reload on file changes, synchronized UI interactions, scrolling, and so
    on. JHipster integrates BrowserSync with Webpack dev server to provide a productive
    development setup. It makes testing a web page on different browsers and devices
    super easy. Changes to CSS are loaded without a browser refresh.
  prefs: []
  type: TYPE_NORMAL
- en: To use live reload on the client side you need to run `yarn start`, which will
    start the development server and open up a browser pointing to `http://localhost:9000`.
    Notice the port `9000`. BrowserSync will be using this port, while the application
    backend will be served at `8080`, which all requests will be proxied through via
    webpack dev middleware.
  prefs: []
  type: TYPE_NORMAL
- en: Open another browser, for example, Firefox if BrowserSync has opened Chrome
    already or vice versa. Now place them side by side and play around with the application.
    You will see your actions are replicated, thanks to BrowserSync. Try changing
    some code and save the file to see live reload in action.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up live reload for an application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start the perfect development setup for the application we created. In
    a terminal, start the server in dev mode by running `./gradlew` and in another
    terminal, start the client side development server by running `yarn start`.
  prefs: []
  type: TYPE_NORMAL
- en: Now when you make any changes on the server side simply run `./gradlew compileJava`
    or if you are using an IDE click on the compile button.
  prefs: []
  type: TYPE_NORMAL
- en: With IntelliJ IDEA, files are automatically saved and so you can set up *Ctrl*
    + *S* to compile the classes giving you a nice workflow. In Eclipse, saving a
    class automatically compiles it.
  prefs: []
  type: TYPE_NORMAL
- en: When you make changes on the client side, simply save the file and webpack dev
    server and BrowserSync will do the rest.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the Angular frontend for an entity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our entity domain model created and working, let's make it
    more usable. The Product listing screen has a table view generated by JHipster;
    it is sufficient for simple CRUD operations but isn't the best-suited user experience
    for end users who want to browse our product listing. Let's see how we can easily
    change to something more appealing. We will also add a nice client-side filter
    option to filter the listing. We will be using both Angular and Bootstrap features
    for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s find the source code that we would need to edit. In your favorite
    editor/IDE navigate to `src/main/webapp/app/entities/product`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bca08683-2256-4fd8-8465-f61b3530b443.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s start by customizing the `product.component.html` file to update the
    UI view of the product listing. The HTML code currently renders a table view and
    uses some Angular directives to enhance the view with sorting and pagination.
    Let''s first change the view from a table into a list, but first open the development
    web server from BrowserSync, if it''s not already open, by navigating to `http://localhost:9000`.
    Log in and navigate to Entities | Product Category and create a category, then
    navigate to Entities | Product and create few new products so that we have something
    to list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5cf97e13-399a-4bb3-8b1e-2a78d11690e2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can use the Bootstrap List group ([https://getbootstrap.com/docs/4.0/components/list-group/](https://getbootstrap.com/docs/4.0/components/list-group/))
    component for this purpose. Let''s use the following snippet and change the view.
    Replace the `div` with `class="table-responsive"` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we are iterating the products using the Angular directive `*ngFor="let
    product of products; trackBy: trackId"` on the anchor element so that the element
    is created for each product in the list. We wrap this in a `*ngIf="products"`
    directive so that the view is rendered only when the product''s object is defined.
    The `[routerLink]="[''../product'', product.id ]"` directive will create a href
    for the anchor using the Angular router so that we can navigate to the particular
    product route.  We then use properties from the product in template strings to
    be rendered using `{{product.name}}` syntax. As you save the code, you might notice
    that the view refreshes automatically, thanks to BrowserSync.'
  prefs: []
  type: TYPE_NORMAL
- en: The `trackBy` function used in `ngFor` lets Angular decide which items are added
    or removed from a collection. This improves rendering performance as Angular can
    now figure out which items need to be added or removed from DOM exactly, without
    having to recreate the entire collection. Here, we provide `trackId` as the function
    to uniquely identify an item in the collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will produce the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a312031d-0b47-4d3d-8350-488708564282.png)'
  prefs: []
  type: TYPE_IMG
- en: 'While it''s a good start, it''s not enough. So, let''s go in and make it better.
    Let''s add the image to the listing first. Modify the code to add Bootstrap rows
    and columns, as shown in the following code, the original code rendering the content
    is moved into the second column and remains unchanged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the code highlighted in bold. We added a Bootstrap row ([https://getbootstrap.com/docs/4.0/layout/grid/](https://getbootstrap.com/docs/4.0/layout/grid/))
    with two column divs, the first div takes up two columns in a 12 column grid specified
    by `col-2`, while we also say that when the display is **xs** (**extra small**)
    the `div` tag should take 12-columns using `col-xs-12`. The second `div` is kept
    responsive by specifying just `col` so it takes the remaining available columns
    after the first `div`, and when the display is extra small it takes up 12 columns
    as well. The image inside the first column `div` uses a data URL as `src` to render
    the image. Now we have an even better view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e0a5d8d9-4d36-460c-8eb5-b73798c4cdd7.png)'
  prefs: []
  type: TYPE_IMG
- en: We can polish it further. We can use the Angular currency pipe ([https://angular.io/api/common/CurrencyPipe](https://angular.io/api/common/CurrencyPipe))
    for the price and remove the redundant label for it by changing to `{{product.price
    | currency:'USD'}}`.  We can add a label for the category shown on the right-hand
    side of the list as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can add the Edit and Delete buttons back, but we need to show them
    only for users who have the role `ADMIN` so that normal users will only be able
    to view the product listing. We can copy the HTML code for `edit` and `delete`
    buttons from the original table. The final code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `*jhiHasAnyAuthority="''ROLE_ADMIN''"` directive is provided by JHipster
    and can be used to control presentation based on user roles. By default, JHipster
    provides `ROLE_ADMIN` and `ROLE_USER`, but controlling this only on the client
    side is not secure as it can be easily bypassed, so we should secure this on the
    server side as well. We will look at this later in the chapter. Log out and log
    in again using the user account to see the directive in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/917bd423-64fd-47df-85d5-6f899bb36ae3.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's also add the `*jhiHasAnyAuthority="'ROLE_ADMIN'"` directive to the
    create button element.
  prefs: []
  type: TYPE_NORMAL
- en: Now that our view is much better, let's bring back the sorting functionality
    we originally had. Since we do not have table headers anymore we can use some
    buttons to sort based on certain fields that are important.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use Bootstrap button group ([https://getbootstrap.com/docs/4.0/components/button-group/](https://getbootstrap.com/docs/4.0/components/button-group/))
    for this. Place the following snippet above the `<div class="list-group">` element
    we created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use Bootstrap margin and flexbox utility classes such as `mb-2 d-flex
    justify-content-end align-items-center` to position and align the item properly.
    We use the `btn-group` class on a div element to group our button elements together
    on which we have placed the `jhiSort` directive and its bound properties such
    as `predicate`, `ascending`, and `callback`. On the buttons themselves, we use
    the `jhiSortBy` directive to specify which field it would use to sort. Now our
    page looks as follows, where products are sorted by price:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/113a2cb2-3da0-485d-a5ac-21d3b37fc3f9.png)'
  prefs: []
  type: TYPE_IMG
- en: Finally, let's add some good old client-side filtering for the page.
  prefs: []
  type: TYPE_NORMAL
- en: JHipster provides an option to enable server-side filtering using JPA metamodel.
    Another option is to enable Elasticsearch, for which JHipster will automatically create
    full-text search fields for every entity. So for any serious filtering requirements,
    you should use these.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s add a new instance variable called `filter` of type string to
    the `ProductComponent` class in the `product.component.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s use this variable in the `product.component.html` file. Add the
    highlighted snippet from the following code to the `div` we created for the sort-by
    buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We bound the filter variable to an input element using the `ngModel` directive,
    and using `[()]` ensures two-way binding on the variable.
  prefs: []
  type: TYPE_NORMAL
- en: '`[(ngModel)]="filter"` creates a two-way binding, `[ngModel]="filter"` creates
    a one-way binding from model to view, and `(ngModel)="filter"` creates a one-way
    binding from view to model.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, update the `ngFor` directive on our list-group-item element as follows.
    We use a pipe provided by JHipster to filter the list using the name field of
    the product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it, and we get a shiny filter option on our screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8753e58a-9256-42b6-a546-6a45f1a157b1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The UX is much better than before but for a real-world use case you could build
    a much better UI for the client-facing website, with features to add items to
    a cart, pay for items online, and so on, and leave this part for the back office
    use. Let''s commit this to `git`: this is very important for managing changes
    to the project later. Run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Editing an entity using the JHipster entity sub-generator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While looking through the generated entity screens, we might realize that there
    are some minor issues that affect the user experience. For example, on the product
    screens we have a relationship to a product category but when choosing the product
    category from the drop-down menu during creation, or when showing the category
    in the list, we show the category by its ID, which is not user-friendly. It would
    be nice if we could show the product category name instead. This is the default
    JHipster behavior but it can be customized while defining the relationships. Let's
    see how we can make our generated screens more user-friendly by editing the JDL
    model. This will overwrite existing files, but since we are using `git` we can
    easily cherry-pick the changes we made, we will see how this is done in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our JDL, we defined relationships between entities using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'By specifying the field to use for displaying the relationship in JDL using
    the `(<field name>)` syntax as follows, we can change how the client-side code
    displays relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run this using the `import-jdl` command. The command only generates
    entities that underwent changes from the last run. But before we run let''s also
    switch to a new branch, because it''s a good practice to do major changes on a
    separate branch and merge them back so you have more control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Read more about Git flow here: [https://guides.github.com/introduction/flow/](https://guides.github.com/introduction/flow/).
  prefs: []
  type: TYPE_NORMAL
- en: Accept the changes to the files and wait for the build to finish. Now, let's
    look at the entity pages to verify that the display names are used properly and
    create some entities to try it out. Now we realize that the `Invoice` entity has
    empty drop-down menus, and that is because the `Invoice` entity does not have
    a field called **code**. Since we use `{{invoice.order?.code}}` in the template
    the symbol `?` makes Angular skip undefined values preventing errors in rendering.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is easy to fix. Sometimes we might want to make a small change to an entity
    after we have created it using JDL and the `import-jdl` command. The best way
    would be to make the change in JDL and regenerate it using the import JDL command
    as we saw in the previous code. Now there is also another option, the entity sub
    generator, which can yield the same result. For the sake of familiarizing yourself
    with this option, let''s use that to add the field to our `Invoice` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'From the options select Yes, add more fields and relationships:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Select Yes for the next question and provide the field name, type, and validation
    in the questions that follow:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Select n for the prompts that follow to add more fields and relationships. Accept
    the proposed file changes and that's it, we are done.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now just make sure to update the JDL so that the entity `Invoice` has `code
    String required` as a field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You could also run `jhipster export-jdl online-store.jh` to export the current
    model back to the JDL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have displayed entity relationships properly, we also need to make
    sure certain entities have relationship values mandatory. For example, for customers
    it should be mandatory to have a user, `ProductOrder` should have a customer,
    order item should have an order, Invoice should have an order, and finally, the
    shipment should have an invoice. Since JHipster supports making relationships
    required, we can make these changes using JDL. Update the relationships to the
    following snippet in `online-store.jh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now, run `jhipster import-jdl online-store.jh` and accept the proposed updates.
    Make sure to check what has changed using the `git diff` command or your Git UI
    tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s commit this step so that it can be rolled back if required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now we have a problem, regenerating the entities overwrote all the files and
    that means we lost all the changes we made for the product listing page, but since
    we use `git` it's easy to get it back. So far, our project has only a few commits,
    so it will be easy to cherry-pick the commit we made for the product listing UI
    change and apply it back on top of the current codebase. However, in real-world
    scenarios, there could be a lot of changes before you can regenerate the JDL,
    and so it will require some effort to verify and merge the required changes back.
    Always rely on pull requests so that you can see what has changed and others can
    review and find any issues.
  prefs: []
  type: TYPE_NORMAL
- en: Let's cherry-pick the changes that we need.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the documentation for cherry-picking advanced options at: [https://git-scm.com/docs/git-cherry-pick](https://git-scm.com/docs/git-cherry-pick).
  prefs: []
  type: TYPE_NORMAL
- en: Since the commit we need is the last one on the master we can simply use `git
    cherry-pick master`. We could also switch to the master and use the `git log`
    command to list the commits, then copy the commit hash of the required commit
    and use that with `git cherry-pick <commit-sha>`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, this results in merge conflicts, as the `product.component.html` file was
    updated in the commit we picked on our current branch tip. We need the incoming
    change from the commit but also need to update the product category display name
    from ID to code, so let's accept the incoming change and make a manual update
    from `{{product.productCategory?.id}}` to `{{product.productCategory?.name}}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Resolve the conflict by staging the file and commit. Now we can merge the branch
    into the master:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If you are new to Git, it is advisable to use a UI tool such as SourceTree or
    GitKraken to cherry-pick and resolve merge conflicts. IDEs such as IntelliJ and
    editors such as VSCode, also provide good options for these.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now our page view should be good:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d0c78f86-2f00-4628-8a7a-2ac64f32fb98.png)'
  prefs: []
  type: TYPE_IMG
- en: Of course, we could also make it more user-friendly by making the product listing
    our home page. But for now, let's skip that.
  prefs: []
  type: TYPE_NORMAL
- en: Since we were working on the client-side code we didn't pay attention to the
    server-side code that was changed during this. We need to compile the Java code
    to reload our server. Let's run `./gradlew compileJava`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, we receive an error during the reload regarding a failure to
    update the database changelogs by Liquibase due to a checksum error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This is due to the changes made to the original changelog by JHipster. In an
    ideal world, new schema changes should be done in new changelogs so that Liquibase
    can apply them, but JHipster doesn't generate this by default yet. For local development
    using an H2 DB we can run `./gradlew clean` to clear the DB and start the application
    again, but in real use cases you might be using an actual DB, and you would want
    to retain the data, so we would have to handle this manually here using the diff
    features provided by Liquibase.
  prefs: []
  type: TYPE_NORMAL
- en: JHipster provides an integration for Liquibase in both Gradle and Maven builds.
    You can make use of it to create new changelogs and to create diff changelogs.
    In cases like these, when we would like to resolve conflicts while retaining data,
    the Liquibase diff feature is our friend. With Gradle, you could run the `./gradlew liquibaseDiffChangeLog`
    command to create a diff changelog of your changesets and the database. You can
    add this changeset to the `src/main/resources/config/liquibase/master.xml` file
    and it will get applied the next time you restart your server. By default, the
    command is configured to run against your development database, if you would like
    to do this against your production database just update the liquibaseCommand command
    definition in the `gradle/liquibase.gradle` file with the details of the production
    DB. Refer to [http://www.jhipster.tech/development/#using-a-database](http://www.jhipster.tech/development/#using-a-database)
    for more.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to clear checksums in your DB, use the `./gradlew liquibaseClearChecksums`
    task.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the look and feel of the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The good thing about using Bootstrap is that it lets us easily change the look
    and feel of the application using any available Bootstrap themes. Let's see how
    we can install a cool theme for our application, then we will also fine tune the
    styles to fit our needs using Sass variables provided by Bootstrap.
  prefs: []
  type: TYPE_NORMAL
- en: There are hundreds of Bootstrap themes out there. Since we are using Bootstrap
    4 it is important to pick a theme that is made for Bootstrap 4.
  prefs: []
  type: TYPE_NORMAL
- en: Bootswatch is a nice collection of themes for Bootstrap; check it out to see
    all the available themes at: [https://bootswatch.com/](https://bootswatch.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Let's use a Bootswatch theme called **materia**.
  prefs: []
  type: TYPE_NORMAL
- en: In your terminal, run `yarn add bootswatch` to install all the themes. Don't
    worry; we will only import the theme that we want to use so you do not have to
    worry about installing all themes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s import this using Sass. Open `src/main/webapp/content/scss/vendor.scss`
    and find the line `@import ''node_modules/bootstrap/scss/bootstrap'';` and add
    the following code highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The name of the theme here is materia, you can use any theme available in Bootswatch
    here. Make sure that name is in all lowercase. Also, notice the order of imports.
    It is important that we import the theme variables after importing Bootstrap variables
    and themes after importing the Bootstrap theme so that SASS variables and styles
    are overridden properly.
  prefs: []
  type: TYPE_NORMAL
- en: We can customize the theme further by overriding Bootstrap variables defined
    in `src/main/webapp/content/scss/_bootstrap-variables.scss`.
  prefs: []
  type: TYPE_NORMAL
- en: You can override any variable supported by Bootstrap. The full list of supported
    variables can be found in `node_modules/bootstrap/scss/_variables.scss`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s change some colors as follows, in `_bootstrap-variables.scss`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: There might be some UI glitches when you apply a new theme, you could solve
    them by updating the generated SASS files.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, add the following CSS to `src/main/webapp/content/scss/global.scss`
    to fix the glitch in checkboxes that we got after the theme change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have a cool new theme:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0982f799-068a-476d-aced-59efc6d5dd2f.png)'
  prefs: []
  type: TYPE_IMG
- en: Further reference can be found at: [https://getbootstrap.com/docs/4.0/getting-started/theming/.](https://getbootstrap.com/docs/4.0/getting-started/theming/)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s commit this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Adding a new i18n language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we enabled i18n support for our application we can add new i18n languages
    easily, at any time, using the JHipster language generator. Let's add a new language
    to our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the terminal, switch to a new branch and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You will now see a prompt like this, where you can choose any available language
    listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Let's select French here for now. Accept the file changes proposed and we are
    good to go. Once the application automatically refreshes you can see the new language
    in the language drop-down menu in the application menu. Now, wasn't that easy!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now there is a problem, since we have some entities and we added a new language.
    We will need to get i18n French files for entities as well. We can do this easily
    by running the `jhipster --with-entities` command, which will regenerate the application
    along with entities. Now make sure to carefully stage only changes that you need
    (i18n related JSON files) from the diff and discard the remaining changes. The
    following are the files and folders that need to be staged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s commit this and merge it back to the master. If we have picked
    only i18n related changes we shouldn''t have any merge conflicts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Authorization with Spring Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you may have noticed, when it comes to generated code, JHipster doesn't provide
    much in terms of role-based security, authorization management, and so on. This
    is intentional, as these heavily depend on the use case and most often associated
    with the business logic of the application. So, it would be better if this was
    hand-coded by the developers as part of the business code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normal users have `ROLE_USER` and admin users have `ROLE_ADMIN` assigned in
    user management. For our use case there are few security holes that we need to
    take care of:'
  prefs: []
  type: TYPE_NORMAL
- en: Normal users should only have access to view the product listing, product order,
    order item, invoice, and shipment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Normal users should not have access to create/edit/delete entities via the CRUD
    API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Normal users should not be able to access the product order, order item, invoice,
    and shipment of other users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could overcome these issues using features provided by Spring Security.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting access to entities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let's limit the access for normal users. This can be done easily at the
    API level using Spring Security. Add the following snippet to the configure method
    of `src/main/java/com/mycompany/store/config/SecurityConfiguration.java`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add it right before the line `.antMatchers("/api/**").authenticated()`. The
    position is very important:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We specify that when the request path matches `api/customers` or `api/product-categories`
    the user should have `ROLE_ADMIN` to access them. Now sign out and log in as `user` and
    try to access the customer entity page. Look at the console in your browser's
    development tools and you should see a `403 Forbidden` error for calls made to
    `GET http://localhost:9000/api/customers`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that our backend handles this properly let's hide these entries in the menu
    for normal users. Let's add a `*jhiHasAnyAuthority="'ROLE_ADMIN'"` directive to
    the elements for customer and product category in `src/main/webapp/app/layouts/navbar/navbar.component.html`.
  prefs: []
  type: TYPE_NORMAL
- en: Now only admin users will see these items on the menu.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting access to create/edit/delete entities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we need to ensure that only admin users can edit entities, normal users
    should only be able to view entities authorized to them. For this, it would be
    better to handle it at the API level using the Spring Security `PreAuthorize` annotation.
    Let''s start with the order item. Go to `src/main/java/com/mycompany/store/web/rest/OrderItemResource.java`
    and add `@PreAuthorize("hasAuthority(''ROLE_ADMIN'')")` to methods `createOrderItem`, `updateOrderItem`,
    and `deleteOrderItem`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We are asking Spring Security interceptors to provide access to these methods
    only when the user has `ROLE_ADMIN`.The `PreAuthorize` annotation stops access
    before executing the method. Spring Security also provides `PostAuthorize` and
    more general `Secured` annotations. More about these can be found in the Spring
    Security documentation at: [https://projects.spring.io/spring-security/](https://projects.spring.io/spring-security/).
  prefs: []
  type: TYPE_NORMAL
- en: Compile the backend using `./gradlew compileJava` or using the IDE. Now go to
    the order items page and try to create an order item. You will get an `POST http://localhost:9000/api/order-items
    403 (Forbidden)` error from the API call on the web console. Now let's add the
    annotation to all the entity Resource class create, update, and delete methods.
    You could skip customer and product category entities as they are entirely forbidden
    to the `ROLE_USER` already.
  prefs: []
  type: TYPE_NORMAL
- en: Let's also hide the create, edit, and delete buttons from the Angular views
    using the `*jhiHasAnyAuthority="'ROLE_ADMIN'"` directive.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting access to data of other users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, this is a little more tricky, as this requires us to change code at the
    service layer on the backend, but it is not hard. Let's get right to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the product order entity. Let''s modify the `findAll` method
    in `src/main/java/com/mycompany/store/service/ProductOrderService.java` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we modified the original call to `productOrderRepository.findAll(pageable)`
    so that we call it only when the current user has the `Admin` role, else we call `findAllByCustomerUserLogin`,
    but our generated `ProductOrderRepository` interface does not have this method
    yet so let''s add that. In `src/main/java/com/mycompany/store/repository/ProductOrderRepository.java`
    let''s add a new method as follows. Currently, the interface doesn''t have any
    methods and only uses methods inherited from `JpaRepository`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a lot of magic going on here. This is a Spring Data interface and
    hence, we can simply write a new method and expect Spring Data to create an implementation
    for this automatically; we just need to follow the naming conventions. In our
    use case, we need to find all product orders where the user relationship for the
    customer has the same login as our current logged in user. In SQL, this would
    be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In simple terms, we could say *find all product orders where* `customer.user.login`
    *equals* `login` and that is exactly what we have written as the `findAllByCustomerUserLogin` method.
    The entity under operation is implicit, hence the product order is omitted. By
    providing the Pageable parameter we tell Spring Data to provide us a page from
    the paginated list of entities. You can refer to the Spring Data docs ([https://docs.spring.io/spring-data/jpa/docs/current/reference/html/](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/))
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: While calling the `productOrderRepository.findAllByCustomerUserLogin` method
    we can pass the current user login using the `SecurityUtils.getCurrentUserLogin()`
    method. The SecurityUtils class is generated by JHipster as well, as it has useful
    methods such as `getCurrentUserLogin`, `getCurrentUserJWT`, `isAuthenticated`,
    and `isCurrentUserInRole`.
  prefs: []
  type: TYPE_NORMAL
- en: That is it. Now log in as admin and create two new users, create two customers,
    and create product orders for each of them. Then log out and log in again as the
    default user and see if you can see the product order for the newly created user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s make similar updates for other services. The repository methods
    for those would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For `src/main/java/com/mycompany/store/repository/InvoiceRepository`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'For `src/main/java/com/mycompany/store/repository/OrderItemRepository`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'For `src/main/java/com/mycompany/store/repository/ShipmentRepository`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now we need to make similar changes for `findOne` methods on the services.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `ProductOrderService` it would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we changed the methods to find one by ID and customer user
    login. The repository method for the same would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'For `src/main/java/com/mycompany/store/repository/InvoiceRepository`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'For `src/main/java/com/mycompany/store/repository/OrderItemRepository`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'For `src/main/java/com/mycompany/store/repository/ShipmentRepository`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The same queries can be written using the `@Query` annotation provided by Spring
    Data as well.
  prefs: []
  type: TYPE_NORMAL
- en: That's it. We have implemented a good role-based authorization logic for the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s commit this checkpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In a real-world scenario, the changes we have made so far are not enough for
    an e-commerce website. But since our aim is to learn JHipster and its supported
    tools rather than to create a feature perfect application, consider this a minimum
    viable product. To make this e-commerce application usable, we would need to build
    more features, such as a shopping cart, invoice generation, customer registration,
    and so on. Why don't you take it up as an assignment and see if you can build
    more features for this application? This would be part of the next steps to take
    once you finish the book. The use case and instructions will be detailed in [Chapter
    14](7a7b29a3-0ff7-4d86-be16-2c4b88d3a16a.xhtml), *Best Practices with JHipster*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how we can easily customize a web application created
    using JHipster. We also learned about Angular and Bootstrap when we customized
    our Product listing page. In addition to this, we saw how to secure our application
    with role-based authorization using Spring Security. We also learned about Spring
    Data and used Git to manage our source code properly. We saw our application evolving
    with business logic and becoming more user-friendly. In the next chapter, we will
    see how we can integrate continuous integration with our application using Jenkins.
  prefs: []
  type: TYPE_NORMAL
