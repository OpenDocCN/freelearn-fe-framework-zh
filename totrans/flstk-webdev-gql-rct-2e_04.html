<html><head></head><body>
		<div id="_idContainer028">
			<h1 id="_idParaDest-53"><em class="italic"><a id="_idTextAnchor054"/>Chapter 3</em>: Connecting to the Database</h1>
			<p>Our backend and frontend can communicate, create new posts, and respond with a list of all posts while using fake data. The next step on our list will be to use a database, such as a SQL server, to serve as data storage.</p>
			<p>We want our backend to persist data to our SQL database by using Sequelize. Our Apollo Server should use this data for queries and mutations, as needed. For this to happen, we must implement database models for our GraphQL entities.</p>
			<p>This chapter will cover the following topics:</p>
			<ul>
				<li>Using databases in GraphQL</li>
				<li>Using Sequelize in Node.js</li>
				<li>Writing database models</li>
				<li>Seeding data with Sequelize</li>
				<li>Using Apollo with Sequelize</li>
				<li>Performing database migrations with Sequelize</li>
			</ul>
			<h1 id="_idParaDest-54"><a id="_idTextAnchor055"/>Technical requirements</h1>
			<p>The source code for this chapter is available in the following GitHub repository: <a href="https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter03">https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter03</a>.</p>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor056"/>Using databases in GraphQL</h1>
			<p><strong class="bold">GraphQL</strong> is a <a id="_idIndexMarker131"/>protocol for sending and <a id="_idIndexMarker132"/>receiving data. <strong class="bold">Apollo</strong> is one <a id="_idIndexMarker133"/>of the many libraries that you can use to implement <a id="_idIndexMarker134"/>that protocol. Neither GraphQL (in its specifications) nor Apollo works directly on the data layer. Where the data that you put into your response comes from, and where the data that you send with your request is saved, are up to the developer to decide.</p>
			<p>This logic indicates that the database and the services that you use do not matter to Apollo, so long as the data that you respond with matches the GraphQL schema.</p>
			<p>As we are living in the Node.js ecosystem in this project and book, it would be fitting to use MongoDB. MongoDB offers a great client library for Node.js and uses JavaScript as its native choice of language for interactions and querying.</p>
			<p>The general alternative to a database system such as MongoDB is a typical MySQL server with proven stability and global usage. One case that I encounter frequently involves systems and <a id="_idIndexMarker135"/>applications relying on older code bases and <a id="_idIndexMarker136"/>databases that need upgrades. A great way to accomplish this is to get an over-layering API level with GraphQL. In this scenario, the GraphQL server receives all requests and, one by one, you can replace the existing code bases that the GraphQL server relies on. In these cases, it is helpful that GraphQL is database agnostic.</p>
			<p>In this book, we will use SQL via Sequelize to see this feature in a real-world use case. For future purposes, it will also help you to handle problems with existing SQL-based systems.</p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor057"/>Installing MySQL for development</h2>
			<p>MySQL is <a id="_idIndexMarker137"/>an excellent starting point for getting on track in a developmental career. It is also well suited for local development on your machine since the setup is easy.</p>
			<p>How to set up MySQL on your machine depends on your operating system. As we mentioned in <a href="B17337_01_Final_ASB_ePub.xhtml#_idTextAnchor017"><em class="italic">Chapter 1</em></a>, <em class="italic">Preparing Your Development Environment</em>, we are assuming that you are using a Debian-based system. For this, you can use the following instructions. If you already have a working setup for MySQL or Apache, these commands may not work, or may not be required in the first place.</p>
			<p class="callout-heading"><strong class="bold">Tip</strong></p>
			<p class="callout">For other operating systems, there are great prebuilt packages. I recommend that all Windows users use XAMPP and that Mac users use MAMP. These offer an easy installation process for what we did manually on Linux. They also implement MySQL, Apache, and PHP, including phpMyAdmin.</p>
			<p class="callout"><strong class="bold">Important Note</strong></p>
			<p class="callout">Do not follow these instructions when setting up a real SQL server for public and production use. A professional setup includes many security features to protect you against attacks. This installation should only be used in development, on your local machine.</p>
			<p>Execute <a id="_idIndexMarker138"/>the following steps to get MySQL running:</p>
			<ol>
				<li>First, you should always install all the updates available for your system:<p class="source-code"><strong class="bold">sudo apt-get update &amp;&amp; sudo apt-get upgrade -y</strong></p><p>We want to install MySQL and a GUI to see what we have inside our database. The most common GUI for a MySQL server is phpMyAdmin. For this, you need to install a web server and PHP. We are going to install Apache as our web server.</p><p class="callout-heading">Important Note</p><p class="callout">If, at any point in the process, you receive an error stating that the package could not be found, ensure that your system is Debian-based. The installation process can differ on other systems. You can easily search for the matching package for your system on the internet.</p></li>
				<li>Install all the necessary dependencies with the following command:<p class="source-code"><strong class="bold">sudo apt-get install apache2 mysql-server php php-pear php-mysql</strong></p></li>
				<li>After the installation, you will need to run the MySQL setup in the root shell. You will have to enter the root password for this. Alternatively, you can run <strong class="source-inline">sudo -i</strong>:<p class="source-code"><strong class="bold">su -</strong></p></li>
				<li>Now, you can execute the MySQL installation command; follow the steps as p<a id="_idTextAnchor058"/><a id="_idTextAnchor059"/>rompted:<p class="source-code"><strong class="bold">mysql_secure_installation</strong></p><p>You can ignore most of these steps and security settings but be careful when you are asked for the root password of your MySQL instance.</p></li>
				<li>We must <a id="_idIndexMarker139"/>create a separate user for development aside from the root user. You are discouraged from using the root user at all. Log into our MySQL server with the root user to accomplish this:<p class="source-code"><strong class="bold">mysql -u root</strong></p></li>
				<li>Now, run the following SQL command.<p class="source-code"><strong class="bold">GRANT ALL PRIVILEGES ON *.* TO 'devuser'@'%' IDENTIFIED BY 'PASSWORD';</strong></p><p>You can replace the <strong class="source-inline">PASSWORD</strong> string with the password that you want. This is the password that you will use for the database connection in your application, but also when logging into phpMyAdmin. This command creates a user called <strong class="source-inline">devuser</strong>, with root privileges that are acceptable for local development.</p><p class="callout-heading">Note</p><p class="callout">If you are already using MySQL8, the command that you need execute is a little different. Just run the following lines:</p><p class="callout"><strong class="bold">CREATE USER 'devuser'@'%' IDENTIFIED BY 'PASSWORD';</strong></p><p class="callout"><strong class="bold">GRANT ALL PRIVILEGES ON *.* TO 'devuser'@'%' WITH GRANT OPTION;</strong></p><p class="callout"><strong class="bold">FLUSH PRIVILEGES;</strong></p><p class="callout">The above commands will create a new user with the same permissions on your MySQL server.</p></li>
				<li>You can install phpMyAdmin since our MySQL server has been set up. You will be asked for a web server when executing the following command. Select <strong class="source-inline">apache2</strong> with the spacebar and navigate to <strong class="bold">ok</strong> by hitting the <em class="italic">Tab</em> key. When you're asked for it, select the automatic setup method for phpMyAdmin. You should not do this manually.<p>Furthermore, phpMyAdmin will want you to enter a password. I recommend that you choose the same password that you chose for the root user:</p><p class="source-code"><strong class="bold">sudo apt-get install phpmyadmin</strong></p></li>
				<li>After the installation, we will need to set up Apache to serve phpMyAdmin. The following <strong class="source-inline">ln</strong> command creates a symbolic link in the root folder of the Apache public <strong class="source-inline">HTML</strong> folder. Apache will now serve phpMyAdmin:<p class="source-code"><strong class="bold">cd /var/www/html/</strong></p><p class="source-code"><strong class="bold">sudo ln -s /usr/share/phpmyadmin</strong></p></li>
			</ol>
			<p>Now, we <a id="_idIndexMarker140"/>can visit phpMyAdmin under <strong class="source-inline">http://localhost/phpmyadmin</strong> and log in with the newly created user. This should look as follows:</p>
			<div>
				<div id="_idContainer018" class="IMG---Figure">
					<img src="image/Figure_3.01_B17337.jpg" alt="Figure 3.1 – phpMyAdmin&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – phpMyAdmin</p>
			<p>With that, we have installed the database for our development environment.</p>
			<p>phpMyAdmin chooses the language according to your environment, so it might differ slightly from what's shown in the preceding screenshot.</p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor060"/>Creating a database in MySQL</h2>
			<p>Before we <a id="_idIndexMarker141"/>start implementing our backend, we need to <a id="_idIndexMarker142"/>add a new database that we can use.</p>
			<p>You are free to do this via the command line or phpMyAdmin. As we have just installed phpMyAdmin, we are going to use it.</p>
			<p>You can run raw SQL commands in the <strong class="bold">SQL</strong> tab of phpMyAdmin. The corresponding command to create a new database is as follows:</p>
			<p class="source-code">CREATE DATABASE graphbook_dev CHARACTER SET utf8 COLLATE utf8_general_ci;</p>
			<p>Otherwise, you can follow the next set of steps to use the graphical method. In the left-hand panel, click on the <strong class="bold">New</strong> button.</p>
			<p>You will be presented with a screen like the following. It will show all the databases, including their collation of your MySQL server:</p>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="image/Figure_3.02_B17337.jpg" alt="Figure 3.2 – phpMyAdmin databases&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – phpMyAdmin databases</p>
			<p>Enter a database name, such as <strong class="source-inline">graphbook_dev</strong>, and then choose the <strong class="source-inline">uft8_general_ci</strong> collation. After doing so, click on <strong class="bold">Create</strong>.</p>
			<p>You will <a id="_idIndexMarker143"/>see a page that says <strong class="bold">No tables found in database</strong>, which is <a id="_idIndexMarker144"/>correct. This will change later, when we have implemented our database models, such as posts and users.</p>
			<p>In the next chapter, we will start to set up Sequelize in Node.js and connect it to our SQL server.</p>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor061"/>Integrating Sequelize into our Node.js stack</h1>
			<p>We have just set up a MySQL database, and we want to use it inside of our Node.js backend. There <a id="_idIndexMarker145"/>are many libraries to connect <a id="_idIndexMarker146"/>to and query your MySQL database. We are going to use Sequelize in this book.</p>
			<p class="callout-heading">Alternative Object–Relational Mappers (ORMs)</p>
			<p class="callout">Alternatives include <a id="_idIndexMarker147"/>Waterline ORM and js-data, which offer the same functionalities as Sequelize. What is great about these is that they not only offer SQL dialects, but also feature database adapters for MongoDB, Redis, and more. So, if you need an alternative, check them out.</p>
			<p>Sequelize is an ORM for Node.js. It supports the PostgreSQL, MySQL, SQLite, and MSSQL standards.</p>
			<p>Install Sequelize in your project via <strong class="source-inline">npm</strong>. We will also install a second package, called <strong class="source-inline">mysql2</strong>:</p>
			<p class="source-code">npm install --save sequelize mysql2</p>
			<p>The <strong class="source-inline">mysql2</strong> package allows Sequelize to speak with our MySQL server.</p>
			<p>Sequelize is just a wrapper around the various libraries for the different database systems. It offers great features for intuitive model usage, as well as functions for creating and updating database structures and inserting development data.</p>
			<p>Typically, you would run <strong class="source-inline">npx sequelize-cli init</strong> before starting with the database connection or models, but I prefer a more custom approach. From my point of view, this is a bit cleaner. This approach is also why we are setting up the database connection in an extra <a id="_idIndexMarker148"/>file and are not relying on boilerplate <a id="_idIndexMarker149"/>code.</p>
			<p class="callout-heading">Setting Up Sequelize Traditionally</p>
			<p class="callout">You can look at the official tutorial in the Sequelize documentation if you want to see how it would usually be done. The approach that we are taking and the one from the tutorial do <a id="_idIndexMarker150"/>not differ too much, but it is always good to see another way of doing things. The documentation can be found at <a href="https://sequelize.org/master/manual/migrations.html">https://sequelize.org/master/manual/migrations.html</a>.</p>
			<p>Let's start by setting Sequelize up in our backend.</p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor062"/>Connecting to a database with Sequelize</h2>
			<p>The first step <a id="_idIndexMarker151"/>is to initialize the connection <a id="_idIndexMarker152"/>from Sequelize to our MySQL server. To do this, we will create a new folder and file, as follows:</p>
			<p class="source-code">mkdir src/server/database</p>
			<p class="source-code">touch src/server/database/index.js</p>
			<p>Inside the <strong class="source-inline">index.js</strong> database, we will establish a connection to our database with Sequelize. Internally, Sequelize relies on the <strong class="source-inline">mysql2</strong> package, but we do not use it ourselves, which is very convenient:</p>
			<p class="source-code">import Sequelize from 'sequelize';</p>
			<p class="source-code">const sequelize = new Sequelize('graphbook_dev', 'devuser', 'PASSWORD', {</p>
			<p class="source-code">  host: 'localhost',</p>
			<p class="source-code">  dialect: 'mysql', </p>
			<p class="source-code">  pool: {</p>
			<p class="source-code">    max: 5,</p>
			<p class="source-code">    min: 0,</p>
			<p class="source-code">    acquire: 30000,</p>
			<p class="source-code">    idle: 10000,</p>
			<p class="source-code">  },</p>
			<p class="source-code">});</p>
			<p class="source-code">export default sequelize;</p>
			<p>As you <a id="_idIndexMarker153"/>can see, we load Sequelize from <strong class="source-inline">node_modules</strong> and then <a id="_idIndexMarker154"/>create an instance of it. The <a id="_idIndexMarker155"/>following properties are important for Sequelize:</p>
			<ul>
				<li>We pass the database name as the first parameter, which we just created.</li>
				<li>The second and third parameters are the credentials of our <strong class="source-inline">devuser</strong>. Replace them with the username and password that you entered for your database. <strong class="source-inline">devuser</strong> has permission to access all the databases in our MySQL server. This makes development a lot easier.</li>
				<li>The fourth parameter is a general options object that can hold many more properties. The preceding object is an example configuration.</li>
				<li>The <strong class="source-inline">host</strong> option of our MySQL database is our local machine alias, <strong class="source-inline">localhost</strong>. If this is not the case, you can also specify the IP or URL of the MySQL server.</li>
				<li><strong class="source-inline">dialect</strong> is, of course, <strong class="source-inline">mysql</strong>.</li>
				<li>With the <strong class="source-inline">pool</strong> option, you tell Sequelize the configuration for every database connection. The preceding configuration allows for a minimum of zero connections, which means that Sequelize should not maintain one connection, but should create a new one whenever it is needed. The maximum number of connections is five. This option also relates to the number of replica sets that your database system has. <p>The <strong class="source-inline">idle</strong> field of the <strong class="source-inline">pool</strong> option specifies how long a connection can be unused before it gets closed and removed from the pool of active connections.</p><p>When trying to establish a new connection to our MySQL server, the timeout before the connection is aborted is defined by the <strong class="source-inline">acquire</strong> option. In cases in which a connection cannot be created, this option helps stop your server from freezing.</p></li>
			</ul>
			<p>Executing <a id="_idIndexMarker156"/>the preceding code will instantiate <a id="_idIndexMarker157"/>Sequelize and will successfully create a connection to our MySQL server. Going further, we need to handle multiple databases for every environment that our application can run in, from development to production. You will see that in the next section.</p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor063"/>Using a configuration file with Sequelize</h2>
			<p>The previous <a id="_idIndexMarker158"/>setup for our database connection <a id="_idIndexMarker159"/>with Sequelize is fine, but it is not made for later deployment. The best option is to have a separate configuration file that is read and used according to the environment that the server is running in.</p>
			<p>For this, create a new <strong class="source-inline">index.js</strong> file inside a separate folder (called <strong class="source-inline">config</strong>), next to the <strong class="source-inline">database</strong> folder:</p>
			<p class="source-code">mkdir src/server/config</p>
			<p class="source-code">touch src/server/config/index.js</p>
			<p>Your sample configuration should look like the following code if you have followed the instructions for creating a MySQL database. The only thing that we did here was copy our current configuration into a new object indexed with the <strong class="source-inline">development</strong> or <strong class="source-inline">production</strong> environment:</p>
			<p class="source-code">module.exports = {</p>
			<p class="source-code">  "development": {</p>
			<p class="source-code">    "username": "devuser",</p>
			<p class="source-code">    "password": "PASSWORD",</p>
			<p class="source-code">    "database": "graphbook_dev",</p>
			<p class="source-code">    "host": "localhost",</p>
			<p class="source-code">    "dialect": "mysql",</p>
			<p class="source-code">    "pool": {</p>
			<p class="source-code">      "max": 5,</p>
			<p class="source-code">      "min": 0,</p>
			<p class="source-code">      "acquire": 30000,</p>
			<p class="source-code">      "idle": 10000</p>
			<p class="source-code">    }</p>
			<p class="source-code">  },</p>
			<p class="source-code">  "production": {</p>
			<p class="source-code">    "host": process.env.host,</p>
			<p class="source-code">    "username": process.env.username,</p>
			<p class="source-code">    "password": process.env.password,</p>
			<p class="source-code">    "database": process.env.database,</p>
			<p class="source-code">    "logging": false,</p>
			<p class="source-code">    "dialect": "mysql",</p>
			<p class="source-code">    "pool": {</p>
			<p class="source-code">      "max": 5,</p>
			<p class="source-code">      "min": 0,</p>
			<p class="source-code">      "acquire": 30000,</p>
			<p class="source-code">      "idle": 10000</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>Sequelize <a id="_idIndexMarker160"/>expects a <strong class="source-inline">config.json</strong> file inside this folder <a id="_idIndexMarker161"/>by default, but this setup will allow us to take on a more custom approach in later chapters. The <strong class="source-inline">development</strong> environment directly stores the credentials for your database, whereas the <strong class="source-inline">production</strong> configuration uses environment variables to fill them.</p>
			<p>We can remove the configuration that we hardcoded earlier and replace the contents of our <strong class="source-inline">database/index.js</strong> file to require our <strong class="source-inline">configFile</strong> instead.</p>
			<p>This should look as follows:</p>
			<p class="source-code">import Sequelize from 'sequelize';</p>
			<p class="source-code">import configFile from '../config/';</p>
			<p class="source-code">const env = process.env.NODE_ENV || 'development';</p>
			<p class="source-code">const config = configFile[env];</p>
			<p class="source-code">const sequelize = new Sequelize(config.database,</p>
			<p class="source-code">  config.username, config.password, config);</p>
			<p class="source-code">const db = {</p>
			<p class="source-code">  sequelize,</p>
			<p class="source-code">};</p>
			<p class="source-code">export default db;</p>
			<p>In the <a id="_idIndexMarker162"/>preceding code, we are using the <strong class="source-inline">NODE_ENV</strong> environment variable to get the environment that the server is running in. We read <a id="_idIndexMarker163"/>the <strong class="source-inline">config</strong> file and pass the correct configuration to the Sequelize instance. The environment variable will allow us to switch to a new environment, such as <strong class="source-inline">production</strong>, later in this book.</p>
			<p>The Sequelize instance is then exported for use throughout our application. We use a special <strong class="source-inline">db</strong> object for this. You will see why we are doing this later.</p>
			<p>Next, you will learn how to generate and write models and migrations for all the entities that our application will have.</p>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor064"/>Writing database models</h1>
			<p>After creating a connection to our MySQL server via Sequelize, we want to use it. However, our <a id="_idIndexMarker164"/>database is missing a table or structure that we can query or manipulate. Creating those is the next thing that we need to do.</p>
			<p>Currently, we have two GraphQL entities: <strong class="source-inline">User</strong> and <strong class="source-inline">Post</strong>.</p>
			<p>Sequelize lets us create a database schema for each of our GraphQL entities. The schema is validated when we insert or update rows in our database. We already wrote a schema for GraphQL in the <strong class="source-inline">schema.js</strong> file, which is used by Apollo Server, but we need to create a second one for our database. The field types, as well as the fields themselves, can vary between the database and the GraphQL schema.</p>
			<p>GraphQL schemas can have more fields than our database model, or vice versa. Perhaps you do not want to export all the data from your database through the API, or maybe you want to generate data for your GraphQL API on the fly when you're requesting data.</p>
			<p>Let's create the first model for our posts. Create two new folders (one called <strong class="source-inline">models</strong> and another called <strong class="source-inline">migrations</strong>) next to the <strong class="source-inline">database</strong> folder:</p>
			<p class="source-code">mkdir src/server/models</p>
			<p class="source-code">mkdir src/server/migrations</p>
			<p>Creating each model in a separate file is much cleaner than having one big file for all the models.</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor065"/>Your first database model</h2>
			<p>We will use <a id="_idIndexMarker165"/>the Sequelize CLI to generate our first database model. Install it globally with the following command:</p>
			<p class="source-code">npm install -g sequelize-cli</p>
			<p>This gives you the ability to run the <strong class="source-inline">sequelize</strong> command inside your Terminal.</p>
			<p>The Sequelize CLI allows us to generate the model automatically. This can be done by running the following command:</p>
			<p class="source-code">sequelize model:generate --models-path src/server/models --migrations-path src/server/migrations --name Post --attributes text:text</p>
			<p>Sequelize expects us to run the command in the folder where we have run <strong class="source-inline">sequelize init</strong> by default. Our file structure is different because we have two layers with <strong class="source-inline">src/server</strong>. For this reason, we specify the path manually with the first two parameters; that is, <strong class="source-inline">--models-path</strong> and <strong class="source-inline">--migrations-path</strong>.</p>
			<p>The <strong class="source-inline">--name</strong> parameter gives our model a name under which it can be used. The <strong class="source-inline">--attributes</strong> option specifies the fields that the model should include.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you are customizing your setup, you may want to know about other options that the CLI offers. You can view the manual for every command easily by appending <strong class="source-inline">--help</strong> as an option: <strong class="source-inline">sequelize model:generate --help</strong>.</p>
			<p>This command <a id="_idIndexMarker166"/>creates a <strong class="source-inline">post.js</strong> model file in your <strong class="source-inline">models</strong> folder and a database migration file, named <strong class="source-inline">XXXXXXXXXXXXXX-create-post.js</strong>, in your <strong class="source-inline">migrations</strong> folder. The <strong class="source-inline">X</strong> icons indicate the timestamp when you're generating the files with the CLI. You will see how migrations work in the next section.</p>
			<p>The following model file was created for us:</p>
			<p class="source-code">'use strict';</p>
			<p class="source-code">const {</p>
			<p class="source-code">  Model</p>
			<p class="source-code">} = require('sequelize');</p>
			<p class="source-code">module.exports = (sequelize, DataTypes) =&gt; {</p>
			<p class="source-code">  class Post extends Model {</p>
			<p class="source-code">    /**</p>
			<p class="source-code">     * Helper method for defining associations.</p>
			<p class="source-code">     * This method is not a part of Sequelize lifecycle.</p>
			<p class="source-code">     * The 'models/index' file will call this method </p>
			<p class="source-code">       automatically.</p>
			<p class="source-code">     */</p>
			<p class="source-code">    static associate(models) {</p>
			<p class="source-code">      // define association here</p>
			<p class="source-code">    }</p>
			<p class="source-code">  };</p>
			<p class="source-code">  Post.init({</p>
			<p class="source-code">    text: DataTypes.TEXT</p>
			<p class="source-code">  }, {</p>
			<p class="source-code">    sequelize,</p>
			<p class="source-code">    modelName: 'Post',</p>
			<p class="source-code">  });</p>
			<p class="source-code">  return Post;</p>
			<p class="source-code">};</p>
			<p>Here, we are <a id="_idIndexMarker167"/>creating the <strong class="source-inline">Post</strong> class and extending the <strong class="source-inline">Model</strong> class from Sequelize. Then, we are using the <strong class="source-inline">init</strong> function of Sequelize to create a database model:</p>
			<ul>
				<li>The first parameter is the model attributes.</li>
				<li>The second parameter is an <strong class="source-inline">option</strong> object, where the <strong class="source-inline">sequelize</strong> connection instance and model name are passed. <p class="callout-heading">Model Customization</p><p class="callout">There are <a id="_idIndexMarker168"/>many more options that Sequelize offers us to customize our database models. If you want to look up which options are available, you can find them at <a href="https://sequelize.org/master/manual/model-basics.html">https://sequelize.org/master/manual/model-basics.html</a>.</p></li>
			</ul>
			<p>A <strong class="source-inline">post</strong> object has the <strong class="source-inline">id</strong>, <strong class="source-inline">text</strong>, and <strong class="source-inline">user</strong> properties. The user will be a separate model, as shown in the GraphQL schema. Consequently, we only need to configure <strong class="source-inline">id</strong> and <strong class="source-inline">text</strong> as columns of a post.</p>
			<p><strong class="source-inline">id</strong> is the key that uniquely identifies a data record from our database. We do not specify this when running the <strong class="source-inline">model:generate</strong> command because it is generated by MySQL automatically.</p>
			<p>The <strong class="source-inline">text</strong> column is just a MySQL <strong class="source-inline">TEXT</strong> field that allows us to write long posts. Alternatively, there are other MySQL field types, with <strong class="source-inline">MEDIUMTEXT</strong>, <strong class="source-inline">LONGTEXT</strong>, and <strong class="source-inline">BLOB</strong>, which could save more characters. A regular <strong class="source-inline">TEXT</strong> column should be fine for our use case.</p>
			<p>The Sequelize CLI <a id="_idIndexMarker169"/>created a model file, exporting a function that, after execution, returns the real database model. You will soon see why this is a great way of initializing our models.</p>
			<p>Let's take a look at the migration file that is also created by the CLI.</p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor066"/>Your first database migration</h2>
			<p>So far, MySQL has not known anything about our plan to save posts inside of it. Our database tables <a id="_idIndexMarker170"/>and columns need to be created, hence <a id="_idIndexMarker171"/>why the migration file was created.</p>
			<p>A migration file has <a id="_idIndexMarker172"/>multiple advantages, such as the following:</p>
			<ol>
				<li value="1">Migrations allow us to track database changes through our regular version control system, such as Git or SVN. Every change to our database structure should be covered in a migration file.</li>
				<li>Migration files enable us to write updates that automatically apply database changes for new versions of our application.</li>
			</ol>
			<p>Our first migration file creates a <strong class="source-inline">Posts</strong> table and adds all the required columns, as follows:</p>
			<p class="source-code">'use strict';</p>
			<p class="source-code">module.exports = {</p>
			<p class="source-code">  up: async (queryInterface, Sequelize) =&gt; {</p>
			<p class="source-code">    await queryInterface.createTable('Posts', {</p>
			<p class="source-code">      id: {</p>
			<p class="source-code">        allowNull: false,</p>
			<p class="source-code">        autoIncrement: true,</p>
			<p class="source-code">        primaryKey: true,</p>
			<p class="source-code">        type: Sequelize.INTEGER</p>
			<p class="source-code">      },</p>
			<p class="source-code">      text: {</p>
			<p class="source-code">        type: Sequelize.TEXT</p>
			<p class="source-code">      },</p>
			<p class="source-code">      createdAt: {</p>
			<p class="source-code">        allowNull: false,</p>
			<p class="source-code">        type: Sequelize.DATE</p>
			<p class="source-code">      },</p>
			<p class="source-code">      updatedAt: {</p>
			<p class="source-code">        allowNull: false,</p>
			<p class="source-code">        type: Sequelize.DATE</p>
			<p class="source-code">      }</p>
			<p class="source-code">    });</p>
			<p class="source-code">  },</p>
			<p class="source-code">  down: async (queryInterface, Sequelize) =&gt; {</p>
			<p class="source-code">    await queryInterface.dropTable('Posts');</p>
			<p class="source-code">  }</p>
			<p class="source-code">};</p>
			<p>By convention, the model name is pluralized in migrations, but it is singular inside model definitions. Our table names are also pluralized. Sequelize offers options to change this.</p>
			<p>A migration has <a id="_idIndexMarker173"/>two properties, as follows:</p>
			<ul>
				<li>The <strong class="source-inline">up</strong> property states what should be done when running the migration.</li>
				<li>The <strong class="source-inline">down</strong> property states what is run when undoing a migration.</li>
			</ul>
			<p>As we mentioned previously, the <strong class="source-inline">id</strong> and <strong class="source-inline">text</strong> columns are created, as well as two additional <strong class="source-inline">datetime</strong> columns, to save the creation and update time.</p>
			<p>The <strong class="source-inline">id</strong> field <a id="_idIndexMarker174"/>has set <strong class="source-inline">autoIncrement</strong> and <strong class="source-inline">primaryKey</strong> to <strong class="source-inline">true</strong>. <strong class="source-inline">id</strong> will count upward, from one to nearly infinite, for each post in our table. This <strong class="source-inline">id</strong> uniquely identifies posts for us. Passing <strong class="source-inline">allowNull</strong> with <strong class="source-inline">false</strong> disables this feature so that we can insert a row with an empty field value.</p>
			<p>To execute <a id="_idIndexMarker175"/>this migration, we will use the Sequelize CLI again, as follows:</p>
			<p class="source-code">sequelize db:migrate --migrations-path src/server/migrations --config src/server/config/index.js</p>
			<p>Look inside of phpMyAdmin. Here, you will find the new table, called <strong class="source-inline">posts</strong>. The structure of the table should look as follows:</p>
			<div>
				<div id="_idContainer020" class="IMG---Figure">
					<img src="image/Figure_3.03_B17337.jpg" alt="Figure 3.3 – Posts table structure&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.3 – Posts table structure</p>
			<p>All the columns were created as we desired.</p>
			<p>Furthermore, two additional fields – <strong class="source-inline">createdAt</strong> and <strong class="source-inline">updatedAt</strong> – were created. These two fields tell us when a row was either created or updated. The fields were created by Sequelize automatically. If you do not want this, you can set the <strong class="source-inline">timestamps</strong> property in the model to <strong class="source-inline">false</strong>.</p>
			<p>Every time you use Sequelize and its migration feature, you will have an additional table called <strong class="source-inline">sequelizemeta</strong>. The contents of the table should look as follows:</p>
			<div>
				<div id="_idContainer021" class="IMG---Figure">
					<img src="image/Figure_3.04_B17337.jpg" alt="Figure 3.4 – Migrations table&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.4 – Migrations table</p>
			<p>Sequelize <a id="_idIndexMarker176"/>saves every migration that has been executed. If we <a id="_idIndexMarker177"/>add more fields in development or a news release cycle, we can write a migration that runs all the table-altering statements for us as an update. Sequelize skips all the migrations that are saved inside the meta table.</p>
			<p>One major step is to bind our model to Sequelize. This process can be automated by running <strong class="source-inline">sequelize init</strong>, but understanding it will teach us way more than relying on premade boilerplate commands.</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor067"/>Importing models with Sequelize</h2>
			<p>We want <a id="_idIndexMarker178"/>to import all the database models <a id="_idIndexMarker179"/>at once, in a central file. Our database connection instantiator will then rely on this file.</p>
			<p>Create an <strong class="source-inline">index.js</strong> file in the <strong class="source-inline">models</strong> folder and use the following code:</p>
			<p class="source-code">import Sequelize from 'sequelize';</p>
			<p class="source-code">if (process.env.NODE_ENV === 'development') {</p>
			<p class="source-code">  require('babel-plugin-require-context-hook/register')()</p>
			<p class="source-code">}</p>
			<p class="source-code">export default (sequelize) =&gt; {</p>
			<p class="source-code">  let db = {};</p>
			<p class="source-code">  const context = require.context('.', true,</p>
			<p class="source-code">    /^\.\/(?!index\.js).*\.js$/, 'sync')</p>
			<p class="source-code">  context.keys().map(context).forEach(module =&gt; {</p>
			<p class="source-code">    const model = module(sequelize, Sequelize);</p>
			<p class="source-code">    db[model.name] = model;</p>
			<p class="source-code">  });</p>
			<p class="source-code">  Object.keys(db).forEach((modelName) =&gt; {</p>
			<p class="source-code">    if (db[modelName].associate) {</p>
			<p class="source-code">      db[modelName].associate(db);</p>
			<p class="source-code">    }</p>
			<p class="source-code">  });</p>
			<p class="source-code">  return db;</p>
			<p class="source-code">};</p>
			<p>The preceding logic will also be generated when running <strong class="source-inline">sequelize init</strong>, but this way, the database connection is set up in a separate file from loading the models. Usually, this would <a id="_idIndexMarker180"/>happen in just one file when <a id="_idIndexMarker181"/>using the Sequelize boilerplate code. Furthermore, we have introduced some webpack-specific configurations.</p>
			<p>To summarize what happens in the preceding code, we search for all the files ending with <strong class="source-inline">.js</strong> in the same folder as the current file and load them all with the <strong class="source-inline">require.context</strong> statement. In development, we must execute the <strong class="source-inline">babel-plugin-require-context-hook/register</strong> Hook to load the <strong class="source-inline">require.context</strong> function at the top. This package must be installed with <strong class="source-inline">npm</strong>, with the following command:</p>
			<p class="source-code">npm install --save-dev babel-plugin-require-context-hook</p>
			<p>We need to load the Babel plugin at the start of our development server, so, open the <strong class="source-inline">package.json</strong> file and edit the <strong class="source-inline">server</strong> script, as follows:</p>
			<p class="source-code">nodemon --exec babel-node --plugins require-context-hook --watch src/server src/server/index.js</p>
			<p>When the plugin is loaded and we run the <strong class="source-inline">require('babel-plugin-require-context-hook/register')()</strong> function, the <strong class="source-inline">require.context</strong> method becomes available for us. Make sure that you set the <strong class="source-inline">NODE_ENV</strong> variable to <strong class="source-inline">development</strong>; otherwise, this won't work.</p>
			<p>In production, the <strong class="source-inline">require.context</strong> function is included in the generated bundle of webpack.</p>
			<p>The loaded <a id="_idIndexMarker182"/>model files export a function with the following two parameters:</p>
			<ul>
				<li>Our Sequelize instance, after creating a connection to our database</li>
				<li>The <strong class="source-inline">sequelize</strong> class itself, including the data types it offers, such as integer or text</li>
			</ul>
			<p>Running the <a id="_idIndexMarker183"/>exported functions imports <a id="_idIndexMarker184"/>the actual Sequelize model. Once all the models have been imported, we loop through them and check whether they have a function called <strong class="source-inline">associate</strong>. If this is the case, we execute the <strong class="source-inline">associate</strong> function and, through that, we establish relationships between multiple models. Currently, we have not set up an association, but that will change later in this chapter.</p>
			<p>Now, we want to use our models. Go back to the <strong class="source-inline">index.js</strong> database file and import all the models through the aggregated <strong class="source-inline">index.js</strong> file that we just created:</p>
			<p class="source-code">import models from '../models';</p>
			<p>Before exporting the <strong class="source-inline">db</strong> object at the end of the file, we need to run the <strong class="source-inline">models</strong> wrapper to read all model <strong class="source-inline">.js</strong> files. We pass our Sequelize instance as a parameter, as follows:</p>
			<p class="source-code">const db = {</p>
			<p class="source-code">  models: models(sequelize),</p>
			<p class="source-code">  sequelize,</p>
			<p class="source-code">};</p>
			<p>The new database object in the preceding command has <strong class="source-inline">sequelize</strong> and <strong class="source-inline">models</strong> as properties. Under <strong class="source-inline">models</strong>, you can find the <strong class="source-inline">Post</strong> model and every new model that we are going to add later.</p>
			<p>The database <strong class="source-inline">index.js</strong> file is ready and can now be used. You should import this file only once because it can get messy when you're creating multiple instances of Sequelize. The pool functionality won't work correctly, and we will end up with more connections than the maximum of five that we specified earlier.</p>
			<p>We must <a id="_idIndexMarker185"/>create the global database <a id="_idIndexMarker186"/>instance in the <strong class="source-inline">index.js</strong> file of the root server folder. Add the following code:</p>
			<p class="source-code">import db from './database';</p>
			<p>We require the <strong class="source-inline">database</strong> folder and the <strong class="source-inline">index.js</strong> file inside this folder. Loading the file instantiates the Sequelize object, including all the database models.</p>
			<p>Going forward, we want to query some data from our database via the GraphQL API that we implemented in <a href="B17337_02_Final_ASB_ePub.xhtml#_idTextAnchor032"><em class="italic">Chapter 2</em></a>, <em class="italic">Setting Up GraphQL with Express.js</em>.</p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor068"/>Seeding data with Sequelize</h1>
			<p>We should <a id="_idIndexMarker187"/>fill the empty <strong class="source-inline">Posts</strong> table with our fake data. To accomplish this, we will use Sequelize's feature for seeding data to our database.</p>
			<p>Create a <a id="_idIndexMarker188"/>new folder called <strong class="source-inline">seeders</strong>:</p>
			<p class="source-code">mkdir src/server/seeders</p>
			<p>Now, we can run our next Sequelize CLI command to generate a boilerplate file:</p>
			<p class="source-code">sequelize seed:generate --name fake-posts --seeders-path src/server/seeders</p>
			<p>Seeders are great for importing test data into a database for development. Our <strong class="source-inline">seed</strong> file has the timestamp and the words <strong class="source-inline">fake-posts</strong> in the name, and should look as follows:</p>
			<p class="source-code">'use strict';</p>
			<p class="source-code">module.exports = {</p>
			<p class="source-code">  up: (queryInterface, Sequelize) =&gt; {</p>
			<p class="source-code">    /*</p>
			<p class="source-code">      Add altering commands here.</p>
			<p class="source-code">      Return a promise to correctly handle asynchronicity.</p>
			<p class="source-code">      </p>
			<p class="source-code">      Example:</p>
			<p class="source-code">      return queryInterface.bulkInsert('Person', [{</p>
			<p class="source-code">        name: 'John Doe',</p>
			<p class="source-code">        isBetaMember: false</p>
			<p class="source-code">      }], {});</p>
			<p class="source-code">    */</p>
			<p class="source-code">  },</p>
			<p class="source-code">  down: (queryInterface, Sequelize) =&gt; {</p>
			<p class="source-code">    /*</p>
			<p class="source-code">      Add reverting commands here.</p>
			<p class="source-code">      Return a promise to correctly handle asynchronicity.</p>
			<p class="source-code"> </p>
			<p class="source-code">      Example:</p>
			<p class="source-code">      return queryInterface.bulkDelete('Person', null, {});</p>
			<p class="source-code">    */</p>
			<p class="source-code">  }</p>
			<p class="source-code">};</p>
			<p>As shown in the preceding code snippet, nothing is done here. It is just an empty boilerplate file. We need to edit this file to create the fake posts that we already had in our backend. This <a id="_idIndexMarker189"/>file looks like our migration from the <a id="_idIndexMarker190"/>previous section. Replace the contents of the file with the following code:</p>
			<p class="source-code">'use strict';</p>
			<p class="source-code">module.exports = {</p>
			<p class="source-code">  up: (queryInterface, Sequelize) =&gt; {</p>
			<p class="source-code">    return queryInterface.bulkInsert('Posts', [{</p>
			<p class="source-code">      text: 'Lorem ipsum 1',</p>
			<p class="source-code">      createdAt: new Date(),</p>
			<p class="source-code">      updatedAt: new Date(),</p>
			<p class="source-code">    },</p>
			<p class="source-code">    {</p>
			<p class="source-code">      text: 'Lorem ipsum 2',</p>
			<p class="source-code">      createdAt: new Date(),</p>
			<p class="source-code">      updatedAt: new Date(),</p>
			<p class="source-code">    }],</p>
			<p class="source-code">    {});</p>
			<p class="source-code">  },</p>
			<p class="source-code">  down: (queryInterface, Sequelize) =&gt; {</p>
			<p class="source-code">    return queryInterface.bulkDelete('Posts', null, {});</p>
			<p class="source-code">  }</p>
			<p class="source-code">};</p>
			<p>In the <strong class="source-inline">up</strong> migration, we are bulk inserting two posts through <strong class="source-inline">queryInterface</strong> and its <strong class="source-inline">bulkInsert</strong> command. For this, we will pass an array of posts, excluding the <strong class="source-inline">id</strong> property and the associated user. This <strong class="source-inline">id</strong> is created automatically, and the user is saved in a separate table later. <strong class="source-inline">queryInterface</strong> of Sequelize is the general interface that Sequelize uses to talk to all databases.</p>
			<p>In our seed file, we need to add the <strong class="source-inline">createdAt</strong> and <strong class="source-inline">updatedAt</strong> fields since Sequelize does not set up default values for the timestamp columns in MySQL. In reality, Sequelize takes care <a id="_idIndexMarker191"/>of the default values of those fields by itself, but not <a id="_idIndexMarker192"/>when seeding data. If you do not provide these values, the seed will fail, because <strong class="source-inline">NULL</strong> is not allowed for <strong class="source-inline">createdAt</strong> and <strong class="source-inline">updatedAt</strong>.</p>
			<p>The <strong class="source-inline">down</strong> migration bulk deletes all the rows in the table since this is the apparent reverse action of the <strong class="source-inline">up</strong> migration.</p>
			<p>Execute all the seeds from the <strong class="source-inline">seeders</strong> folder with the following command:</p>
			<p class="source-code">sequelize db:seed:all --seeders-path src/server/seeders --config src/server/config/index.js</p>
			<p>Sequelize does not check or save whether a seed has been run already, as we are doing it with the preceding command. This means that you can run seeds multiple times if you want to.</p>
			<p>The following screenshot shows a filled-in <strong class="source-inline">Posts</strong> table:</p>
			<div>
				<div id="_idContainer022" class="IMG---Figure">
					<img src="image/Figure_3.05_B17337.jpg" alt="Figure 3.5 – The Posts table with seed data&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.5 – The Posts table with seed data</p>
			<p>The demo posts are now inside our database.</p>
			<p>We will cover how to use Sequelize with our Apollo Server, as well as how to add the relationship between the user and their posts, in the next section.</p>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor069"/>Using Sequelize with GraphQL</h1>
			<p>The database object is initialized upon starting the server within the root <strong class="source-inline">index.js</strong> file. We pass <a id="_idIndexMarker193"/>it from this global location down to the spots where <a id="_idIndexMarker194"/>we rely on the database. This way, we do not import the database file repeatedly but have a single instance that handles all the database queries for us.</p>
			<p>The services that we want to publicize through the GraphQL API need access to our MySQL database. The first step is to implement the posts in our GraphQL API. It should respond with the fake posts from the database we just inserted.</p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor070"/>Global database instance</h2>
			<p>To pass <a id="_idIndexMarker195"/>the database down to our GraphQL resolvers, we must create a new object in the server <strong class="source-inline">index.js</strong> file:</p>
			<p class="source-code">import db from './database';</p>
			<p class="source-code">const utils = {</p>
			<p class="source-code">  db,</p>
			<p class="source-code">};</p>
			<p>Here, we created a <strong class="source-inline">utils</strong> object directly under the <strong class="source-inline">import</strong> statement of the <strong class="source-inline">database</strong> folder.</p>
			<p>The <strong class="source-inline">utils</strong> object holds all the utilities that our services might need access to. This can be anything from third-party tools to our MySQL server, or any other database, as shown in the preceding code.</p>
			<p>Replace the line where we import the <strong class="source-inline">services</strong> folder, as follows:</p>
			<p class="source-code">import servicesLoader from './services';</p>
			<p class="source-code">const services = servicesLoader(utils);</p>
			<p>The preceding code might look weird to you, but what we are doing here is executing the function that is the result of the <strong class="source-inline">import</strong> statement and passing the <strong class="source-inline">utils</strong> object as a parameter. We must do this in two separate lines since the <strong class="source-inline">import</strong> syntax does not allow it in just one line; so, we must first import the function that's been exported from the <strong class="source-inline">services</strong> folder into a separate variable.</p>
			<p>So far, the return value of the <strong class="source-inline">import</strong> statement has been a simple object. We have to change this so that it matches our requirements.</p>
			<p>To do this, go to the services <strong class="source-inline">index.js</strong> file and change the contents of the file, as follows:</p>
			<p class="source-code">import graphql from './graphql';</p>
			<p class="source-code">export default utils =&gt; ({</p>
			<p class="source-code">  graphql: graphql(utils),</p>
			<p class="source-code">});</p>
			<p>We surrounded <a id="_idIndexMarker196"/>the preceding <strong class="source-inline">services</strong> object with a function, which was then exported. That function accepts only one parameter, which is our <strong class="source-inline">utils</strong> object.</p>
			<p>That object is then given to a new function, called <strong class="source-inline">graphql</strong>. Every service that we are going to use has to be a function that accepts this parameter. This allows us to hand over any property that we want to the deepest point in our application.</p>
			<p>When executing the preceding exported function, the result is the regular <strong class="source-inline">services</strong> object we used previously. We only wrapped it inside a function to pass the <strong class="source-inline">utils</strong> object.</p>
			<p>The <strong class="source-inline">graphql</strong> import that we are doing needs to accept the <strong class="source-inline">utils</strong> object.</p>
			<p>Open the <strong class="source-inline">index.js</strong> file from the <strong class="source-inline">graphql</strong> folder and replace everything but the <strong class="source-inline">require</strong> statements at the top with the following code:</p>
			<p class="source-code">export default (utils) =&gt; {</p>
			<p class="source-code">    const server = new ApolloServer({</p>
			<p class="source-code">        typeDefs: Schema,</p>
			<p class="source-code">        resolvers: Resolvers.call(utils),</p>
			<p class="source-code">        context: ({ req }) =&gt; req</p>
			<p class="source-code">    });</p>
			<p class="source-code">    return server;</p>
			<p class="source-code">};</p>
			<p>Again, we have surrounded everything with a function that accepts the <strong class="source-inline">utils</strong> object. The aim of all this is to have access to the database within our GraphQL resolvers, which are given to <strong class="source-inline">ApolloServer</strong>.</p>
			<p>To accomplish this, we are using the <strong class="source-inline">Resolvers.call</strong> function from JavaScript. This function allows <a id="_idIndexMarker197"/>us to set the owner object of the exported <strong class="source-inline">Resolvers</strong> function. What we are saying here is that the scope of <strong class="source-inline">Resolvers</strong> is the <strong class="source-inline">utils</strong> object.</p>
			<p>So, within the <strong class="source-inline">Resolvers</strong> function, accessing this now gives us the <strong class="source-inline">utils</strong> object as the scope. At the moment, <strong class="source-inline">Resolvers</strong> is just a simple object, but because we used the <strong class="source-inline">call</strong> method, we must also return a function from the <strong class="source-inline">resolvers.js</strong> file.</p>
			<p>Surround the <strong class="source-inline">resolvers</strong> object in this file with a function and return the <strong class="source-inline">resolvers</strong> object from inside the function:</p>
			<p class="source-code">export default function resolver() { </p>
			<p class="source-code">  ...</p>
			<p class="source-code">  return resolvers;</p>
			<p class="source-code">}</p>
			<p>We cannot use the arrow syntax, as we did previously. ES6 arrow syntax would automatically take a scope, but we want the <strong class="source-inline">call</strong> function to take over here.</p>
			<p>An alternative way of doing this would be to hand over the <strong class="source-inline">utils</strong> object as a parameter. I think the way that we have chosen to do things is a bit cleaner, but handle it as you like.</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor071"/>Running the first database query</h2>
			<p>Now, we can <a id="_idIndexMarker198"/>start to use the database. Add the following code to the top of the <strong class="source-inline">export default function resolver</strong> statement:</p>
			<p class="source-code">const { db } = this;</p>
			<p class="source-code">const { Post } = db.models;</p>
			<p>The <strong class="source-inline">this</strong> keyword is the owner of the current method and holds the <strong class="source-inline">db</strong> object, as stated previously. We extracted the database models from the <strong class="source-inline">db</strong> object that we built in the previous section.</p>
			<p>The good thing about models is that you do not need to write raw queries against the database. You have already told Sequelize which fields and tables it can use by creating a model. At this point, you can use Sequelize's methods to run queries against the database within your resolvers.</p>
			<p>We can query <a id="_idIndexMarker199"/>all the posts through the Sequelize model, instead of returning the fake posts from before. Replace the <strong class="source-inline">posts</strong> property within <strong class="source-inline">RootQuery</strong> with the following code:</p>
			<p class="source-code">posts(root, args, context) {</p>
			<p class="source-code">  return Post.findAll({order: [['createdAt', 'DESC']]});</p>
			<p class="source-code">},</p>
			<p>In the preceding code, we searched for and selected all the posts that we have in our database. We used the Sequelize <strong class="source-inline">findAll</strong> method and returned the result of it. The return value will be a JavaScript promise, which automatically gets resolved once the database has finished collecting the data.</p>
			<p>A typical news feed, such as on Twitter or Facebook, orders the posts according to the creation date. That way, you have the newest posts at the top and the oldest at the bottom. Sequelize expects an array of arrays as a parameter of the order property that we pass as the first parameter to the <strong class="source-inline">findAll</strong> method. The results are ordered by their creation date.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">There are many other methods that Sequelize offers. You can query for just one entity, count them, find them, create them if they are not found, and much more. You can look up the <a id="_idIndexMarker200"/>methods that Sequelize provides at <a href="https://sequelize.org/master/manual/model-querying-basics.html">https://sequelize.org/master/manual/model-querying-basics.html</a>.</p>
			<p>You can start the server with <strong class="source-inline">npm run server</strong> and execute the GraphQL posts query from <a href="B17337_02_Final_ASB_ePub.xhtml#_idTextAnchor032"><em class="italic">Chapter 2</em></a>, <em class="italic">Setting Up GraphQL with Express.js</em>, again. The output will look as follows:</p>
			<p class="source-code">{</p>
			<p class="source-code">  "data": {</p>
			<p class="source-code">    "posts": [{</p>
			<p class="source-code">      "id": 1,</p>
			<p class="source-code">      "text": "Lorem ipsum 1",</p>
			<p class="source-code">      "user": null</p>
			<p class="source-code">    },</p>
			<p class="source-code">    {</p>
			<p class="source-code">      "id": 2,</p>
			<p class="source-code">      "text": "Lorem ipsum 2",</p>
			<p class="source-code">      "user": null</p>
			<p class="source-code">    }]</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">id</strong> and <strong class="source-inline">text</strong> fields look fine, but the <strong class="source-inline">user</strong> object is <strong class="source-inline">null</strong>. This happened because we did not <a id="_idIndexMarker201"/>define a user model or declare a relationship between the user and the post model. We will change this in the next section.</p>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor072"/>One-to-one relationships in Sequelize</h1>
			<p>We need to associate each post with a user, to fill in the gap that we created in our GraphQL <a id="_idIndexMarker202"/>response. A post must have an author. It would <a id="_idIndexMarker203"/>not make sense to have a post without an associated user.</p>
			<p>First, we will generate a <strong class="source-inline">User</strong> model and migration. We will use the Sequelize CLI again, as follows:</p>
			<p class="source-code">sequelize model:generate --models-path src/server/models --migrations-path src/server/migrations --name User --attributes avatar:string,username:string</p>
			<p>The migration file creates the <strong class="source-inline">Users</strong> table and adds the <strong class="source-inline">avatar</strong> and <strong class="source-inline">username</strong> columns. A data row looks like a post in our fake data, but it also includes an autogenerated ID and two timestamps, as you saw previously.</p>
			<p>The relationship of the users to their specific posts is still missing as we have only created the model and migration file. We still have to add the relationship between posts and users. This will be covered in the next section.</p>
			<p>What <a id="_idIndexMarker204"/>every post needs is an extra field called <strong class="source-inline">userId</strong>. This column acts as the foreign key to reference a unique user. Then, we can join <a id="_idIndexMarker205"/>the user that's related to each post.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">MySQL offers great documentation for people that are not used to foreign key constraints. If you <a id="_idIndexMarker206"/>are one of them, you should read up on this topic at <a href="https://dev.mysql.com/doc/refman/8.0/en/create-table-foreign-keys.html">https://dev.mysql.com/doc/refman/8.0/en/create-table-foreign-keys.html</a>.</p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor073"/>Updating the table structure with migrations</h2>
			<p>We have <a id="_idIndexMarker207"/>to write a third migration, adding the <strong class="source-inline">userId</strong> column to our <strong class="source-inline">Post</strong> table, but also including it in our database <strong class="source-inline">Post</strong> model.</p>
			<p>Generating a boilerplate migration file is very easy with the Sequelize CLI:</p>
			<p class="source-code">sequelize migration:create --migrations-path src/server/migrations --name add-userId-to-post</p>
			<p>You can directly replace the content of the generated migration file, as follows:</p>
			<p class="source-code">'use strict';</p>
			<p class="source-code">module.exports = {</p>
			<p class="source-code">  up: async (queryInterface, Sequelize) =&gt; {</p>
			<p class="source-code">    return Promise.all([</p>
			<p class="source-code">      queryInterface.addColumn('Posts',</p>
			<p class="source-code">        'userId',</p>
			<p class="source-code">        {</p>
			<p class="source-code">          type: Sequelize.INTEGER, </p>
			<p class="source-code">        }),</p>
			<p class="source-code">      queryInterface.addConstraint('Posts', {</p>
			<p class="source-code">        fields: ['userId'],</p>
			<p class="source-code">        type: 'foreign key',</p>
			<p class="source-code">        name: 'fk_user_id',</p>
			<p class="source-code">        references: {</p>
			<p class="source-code">          table: 'Users',</p>
			<p class="source-code">          field: 'id',</p>
			<p class="source-code">        },</p>
			<p class="source-code">        onDelete: 'cascade',</p>
			<p class="source-code">        onUpdate: 'cascade',</p>
			<p class="source-code">      }),</p>
			<p class="source-code">    ]);</p>
			<p class="source-code">  },</p>
			<p class="source-code">  down: async (queryInterface, Sequelize) =&gt; {</p>
			<p class="source-code">    return Promise.all([</p>
			<p class="source-code">      queryInterface.removeColumn('Posts', 'userId'),</p>
			<p class="source-code">    ]);</p>
			<p class="source-code">  }</p>
			<p class="source-code">};</p>
			<p>This migration <a id="_idIndexMarker208"/>is a bit more complex, and I will explain it on a step-by-step basis:</p>
			<ol>
				<li value="1">In the <strong class="source-inline">up</strong> migration, we are using <strong class="source-inline">queryInterface</strong> to add the <strong class="source-inline">userId</strong> column to the <strong class="source-inline">Posts</strong> table.</li>
				<li>Next, we are adding a foreign key constraint with the <strong class="source-inline">addConstraint</strong> function. This constraint represents the relationship between both the user and the post entities. The relationship is saved in the <strong class="source-inline">userId</strong> column of the <strong class="source-inline">Post</strong> table.</li>
				<li>I experienced some issues when running the migrations without using <strong class="source-inline">Promise.all</strong>, which ensures that all the promises in the array are resolved. Returning only the array did not run both the <strong class="source-inline">addColumn</strong> and <strong class="source-inline">addConstraint</strong> methods.</li>
				<li>The preceding <strong class="source-inline">addConstraint</strong> function receives the <strong class="source-inline">foreign key</strong> string as a <strong class="source-inline">type</strong>, which says that the data type is the same as the corresponding column in the <strong class="source-inline">Users</strong> table. We want to give our constraint the custom name <strong class="source-inline">fk_user_id</strong> to identify it later.</li>
				<li>Then, we are specifying the <strong class="source-inline">references</strong> field for the <strong class="source-inline">userId</strong> column. Sequelize requires a table, which is the <strong class="source-inline">Users</strong> table, and the field that our foreign key relates to, which is the <strong class="source-inline">id</strong> column of the <strong class="source-inline">User</strong> table. This is everything that is required to get a working database relationship.</li>
				<li>Furthermore, we are changing the <strong class="source-inline">onUpdate</strong> and <strong class="source-inline">onDelete</strong> constraints to <strong class="source-inline">cascade</strong>. What this means is that, when a user either gets deleted or has their user ID updated, the change is reflected in the user's posts. Deleting a user results in deleting all the posts of a user, while updating a user's ID updates the ID on all the user's posts. We do not need to handle all this in our application code, which would be inefficient.<p class="callout-heading">Note</p><p class="callout">There is a lot more about this topic in the Sequelize documentation. If you want to read up on this, you can find more information at <a href="https://sequelize.org/master/manual/query-interface.html">https://sequelize.org/master/manual/query-interface.html</a>.</p></li>
			</ol>
			<p>Rerun the migration to see what changes occurred:</p>
			<p class="source-code">sequelize db:migrate --migrations-path src/server/migrations --config src/server/config/index.js</p>
			<p>The benefit of running migrations through Sequelize is that it goes through all the possible migrations from the <strong class="source-inline">migrations</strong> folder. It excludes those that are already saved inside the <strong class="source-inline">SequelizeMeta</strong> table, and then chronologically runs the migrations that are left. Sequelize can do this because the timestamp is included in every migration's filename.</p>
			<p>After <a id="_idIndexMarker209"/>running the migration, there should be a <strong class="source-inline">Users</strong> table, and the <strong class="source-inline">userId</strong> column should have been added to the <strong class="source-inline">Posts</strong> table.</p>
			<p>Take a look at the relationship view of the <strong class="source-inline">Posts</strong> table in phpMyAdmin. You can find it under the <strong class="bold">Structure</strong> view, by clicking on <strong class="bold">Relation view</strong>:</p>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<img src="image/Figure_3.06_B17337.jpg" alt="Figure 3.6 – MySQL foreign keys&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.6 – MySQL foreign keys</p>
			<p>As you can see, we have our foreign key constraint. The correct name was taken, as well as the cascade option.</p>
			<p>If you receive an error when running migrations, you can easily undo them, as follows:</p>
			<p class="source-code">sequelize db:migrate:undo --migrations-path src/server/migrations --config src/server/config/index.js</p>
			<p>This command undoes the most recent migrations. Always be conscious of what you do here. Keep a backup if you are unsure whether everything works correctly.</p>
			<p>You can also revert all migrations at once, or only revert to one specific migration so that you can go back to a specific timestamp:</p>
			<p class="source-code">sequelize db:migrate:undo:all --to XXXXXXXXXXXXXX-create-posts.js --migrations-path src/server/migrations --config src/server/config/index.js</p>
			<p>Leave out the <strong class="source-inline">--to</strong> parameter to undo all migrations.</p>
			<p>With <a id="_idIndexMarker210"/>that, we have established the database relationship, but Sequelize must know about the relationship too. You will learn how this is done in the next section.</p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor074"/>Model associations in Sequelize</h2>
			<p>Now that <a id="_idIndexMarker211"/>we have the relationship configured with the foreign key, it needs to be configured inside our Sequelize model.</p>
			<p>Go back to the <strong class="source-inline">Post</strong> model file and replace the <strong class="source-inline">associate</strong> function with the following code:</p>
			<p class="source-code">static associate(models) {</p>
			<p class="source-code">  this.belongsTo(models.User);</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">associate</strong> function gets evaluated inside our aggregating <strong class="source-inline">index.js</strong> file, where all the model files are imported.</p>
			<p>We are using the <strong class="source-inline">belongsTo</strong> function here, which tells Sequelize that every post belongs to exactly one user. Sequelize gives us a new function on the <strong class="source-inline">Post</strong> model, called <strong class="source-inline">getUser</strong>, to retrieve the associated user. This naming is done by convention, as you can see. Sequelize does all this automatically.</p>
			<p>Do not forget to add <strong class="source-inline">userId</strong> as a queryable field to the <strong class="source-inline">Post</strong> model itself, as follows:</p>
			<p class="source-code">userId: DataTypes.INTEGER,</p>
			<p>The <strong class="source-inline">User</strong> model needs to implement the reverse association too. Add the following code to the <strong class="source-inline">User</strong> model file:</p>
			<p class="source-code">static associate(models) {</p>
			<p class="source-code">  this.hasMany(models.Post);</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">hasMany</strong> function means the exact opposite of the <strong class="source-inline">belongsTo</strong> function. Every user can have multiple posts associated in the <strong class="source-inline">Post</strong> table. It can be anything, from zero to multiple posts.</p>
			<p>You can compare the new data layout with the preceding one. Up to this point, we had the posts and users inside one big array of objects. Now, we have split every object into two tables. Both tables connect through the foreign key. This is required every time we run the GraphQL query to get all the posts, including their authors.</p>
			<p>So, we must <a id="_idIndexMarker212"/>extend our current <strong class="source-inline">resolvers.js</strong> file. Add the <strong class="source-inline">Post</strong> property to the <strong class="source-inline">resolvers</strong> object, as follows:</p>
			<p class="source-code">Post: {</p>
			<p class="source-code">  user(post, args, context) {</p>
			<p class="source-code">    return post.getUser();</p>
			<p class="source-code">  },</p>
			<p class="source-code">},</p>
			<p><strong class="source-inline">RootQuery</strong> and <strong class="source-inline">RootMutation</strong> were the two main properties that we've had so far. <strong class="source-inline">RootQuery</strong> is the starting point where all GraphQL queries begin.</p>
			<p>With the old demo posts, we were able to directly return a valid and complete response, since everything that we needed was in there already. Now, a second query, or a <strong class="source-inline">JOIN</strong>, is being executed to collect all the necessary data for a complete response.</p>
			<p>The <strong class="source-inline">Post</strong> entity is introduced to our <strong class="source-inline">resolvers</strong>, where we can define functions for every property of our GraphQL schema. Only the user is missing in our response; the rest is there. That is why we have added the <strong class="source-inline">user</strong> function to the resolvers.</p>
			<p>The first parameter of the function is the <strong class="source-inline">post</strong> model instance that we are returning inside the <strong class="source-inline">RootQuery</strong> resolver.</p>
			<p>Then, we are using the <strong class="source-inline">getUser</strong> function that Sequelize gave us. Executing the <strong class="source-inline">getUser</strong> function runs the correct MySQL <strong class="source-inline">SELECT</strong> query to get the correct user from the <strong class="source-inline">Users</strong> table. It does not run a real MySQL <strong class="source-inline">JOIN</strong>; it only queries the user in a separate MySQL command. Later, in the <em class="italic">Chats and messages in GraphQL</em> section, you will learn about another way to run a <strong class="source-inline">JOIN</strong> directly, which is more efficient.</p>
			<p>However, if you query for all the posts via the GraphQL API, the user will still be <strong class="source-inline">null</strong>. We have not added any users to the database yet, so let's insert them next.</p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor075"/>Seeding foreign key data</h2>
			<p>The challenge <a id="_idIndexMarker213"/>of adding users is that we have already introduced a foreign key constraint to the database. You can follow these instructions to learn how to get it working:</p>
			<ol>
				<li value="1">First, we must use the Sequelize CLI to generate an empty <strong class="source-inline">seeders</strong> file, as follows:<p class="source-code"><strong class="bold">sequelize seed:generate --name fake-users --seeders-path src/server/seeders</strong></p></li>
				<li>Fill in the following code to insert the fake users:<p class="source-code">'use strict';</p><p class="source-code">module.exports = {</p><p class="source-code">  up: async (queryInterface, Sequelize) =&gt; {</p><p class="source-code">    return queryInterface.bulkInsert('Users', [{</p><p class="source-code">      avatar: '/uploads/avatar1.png',</p><p class="source-code">      username: 'TestUser',</p><p class="source-code">      createdAt: new Date(),</p><p class="source-code">      updatedAt: new Date(),</p><p class="source-code">    },</p><p class="source-code">    {</p><p class="source-code">      avatar: '/uploads/avatar2.png',</p><p class="source-code">      username: 'TestUser2',</p><p class="source-code">      createdAt: new Date(),</p><p class="source-code">      updatedAt: new Date(),</p><p class="source-code">    }],</p><p class="source-code">    {});</p><p class="source-code">  },</p><p class="source-code">  down: async (queryInterface, Sequelize) =&gt; {</p><p class="source-code">    return queryInterface.bulkDelete('Users', null,</p><p class="source-code">      {});</p><p class="source-code">  }</p><p class="source-code">};</p><p>The preceding code looks like the <strong class="source-inline">seeders</strong> file for the posts, but instead, we are now inserting users with the correct fields. Every user receives an auto-incremented ID by our MySQL server when inserting a user.</p></li>
				<li>We <a id="_idIndexMarker214"/>must maintain the relationships that have been configured in our database. Adjust the <strong class="source-inline">posts</strong> seed file to reflect this and replace the <strong class="source-inline">up</strong> migration so that the correct user IDs are inserted for every post:<p class="source-code">up: (queryInterface, Sequelize) =&gt; {</p><p class="source-code">  // Get all existing users</p><p class="source-code">  return queryInterface.sequelize.query(</p><p class="source-code">    'SELECT id from Users;',</p><p class="source-code">  ).then((users) =&gt; {</p><p class="source-code">    const usersRows = users[0];  </p><p class="source-code">    return queryInterface.bulkInsert('Posts', [{</p><p class="source-code">      text: 'Lorem ipsum 1',</p><p class="source-code">      userId: usersRows[0].id,</p><p class="source-code">      createdAt: new Date(),</p><p class="source-code">      updatedAt: new Date(),</p><p class="source-code">    },</p><p class="source-code">    {</p><p class="source-code">      text: 'Lorem ipsum 2',</p><p class="source-code">      userId: usersRows[1].id,</p><p class="source-code">      createdAt: new Date(),</p><p class="source-code">      updatedAt: new Date(),</p><p class="source-code">    }],</p><p class="source-code">    {});</p><p class="source-code">  });</p><p class="source-code">},</p></li>
			</ol>
			<p>Here, we are using a raw MySQL query to get all the users and their IDs to insert them with our posts. This ensures that we have a valid foreign key relationship that MySQL allows us to insert.</p>
			<p>The posts we have currently stored in our table do not receive a <strong class="source-inline">userId</strong>, and we do not want to write a separate migration or seed to fix those posts.</p>
			<p>There <a id="_idIndexMarker215"/>are two options here. You can either manually truncate the tables through phpMyAdmin and SQL statements, or you can use the Sequelize CLI. It is easier to use the CLI, but the result will be the same either way. The following command will undo all the seeds:</p>
			<p class="source-code">sequelize db:seed:undo:all --seeders-path src/server/seeders --config src/server/config/index.js</p>
			<p>When undoing seeds, the tables are not truncated, so the <strong class="source-inline">autoIncrement</strong> index is not set back to one; instead, it stays at the current index. Reverting seeds multiple times raises the user's or post's ID, which stops the seeds from working. We have fixed this by using the raw MySQL query that retrieves the current user IDs before inserting the posts.</p>
			<p>We have one problem before running our seeders again: we created the <strong class="source-inline">users</strong> seed file after the <strong class="source-inline">post</strong> seeders file. This means that the posts are inserted before the users exist, because of the timestamps of the files. Generally, this is not a problem, but since we have introduced a foreign key constraint, we are not able to insert posts with a <strong class="source-inline">userId</strong> when the underlying user does not exist in our database. MySQL forbids this. Simply adjust the timestamp of the fake user seed file so that it's before the post seed file's timestamp, or vice versa.</p>
			<p>After renaming the files, run all the seeds with the following command again:</p>
			<p class="source-code">sequelize db:seed:all --seeders-path src/server/seeders --config src/server/config/index.js</p>
			<p>If you take a look inside your database, you should see a filled <strong class="source-inline">Posts</strong> table, including <strong class="source-inline">userId</strong>. The <strong class="source-inline">Users</strong> table should look as follows:</p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/Figure_3.07_B17337.jpg" alt="Figure 3.7 – The Users table&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.7 – The Users table</p>
			<p>Now, you <a id="_idIndexMarker216"/>can rerun the GraphQL query, and you should see a working association between the users and their posts because the <strong class="source-inline">user</strong> field is filled in.</p>
			<p>So far, we have achieved a lot as we can serve data from our database through the GraphQL API by matching its schema.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">There are some ways to automate this process, through additional npm packages. There is a package that automates the process of creating a GraphQL schema from your database models for you. As always, you are more flexible when you do not rely on pre-configured packages. You can find the package at <a href="https://www.npmjs.com/package/graphql-tools-sequelize">https://www.npmjs.com/package/graphql-tools-sequelize</a>.</p>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor076"/>Mutating data with Sequelize</h1>
			<p>Requesting <a id="_idIndexMarker217"/>data from our database via the GraphQL API works. Now <a id="_idIndexMarker218"/>comes the tough part: adding a new post to the <strong class="source-inline">Posts</strong> table.</p>
			<p>Before we start, we must extract the new database model from the <strong class="source-inline">db</strong> object at the top of the exported function in our <strong class="source-inline">resolvers.js</strong> file:</p>
			<p class="source-code">const { Post, User } = db.models;</p>
			<p>Currently, we have no authentication to identify the user that is creating the post. We will fake this step until the authentication is implemented <a href="B17337_06_Final_ASB_ePub.xhtml#_idTextAnchor141"><em class="italic">Chapter 6</em></a>, <em class="italic">Authentication with Apollo and React</em>.</p>
			<p>We have to <a id="_idIndexMarker219"/>edit the GraphQL resolvers to add the new post. Replace <a id="_idIndexMarker220"/>the old <strong class="source-inline">addPost</strong> function with the new one, as shown in the following code snippet:</p>
			<p class="source-code">addPost(root, { post }, context) { </p>
			<p class="source-code">  return User.findAll().then((users) =&gt; {</p>
			<p class="source-code">    const usersRow = users[0];</p>
			<p class="source-code">    </p>
			<p class="source-code">    return Post.create({</p>
			<p class="source-code">      ...post,</p>
			<p class="source-code">    }).then((newPost) =&gt; {</p>
			<p class="source-code">      return Promise.all([</p>
			<p class="source-code">        newPost.setUser(usersRow.id),</p>
			<p class="source-code">      ]).then(() =&gt; {</p>
			<p class="source-code">        logger.log({</p>
			<p class="source-code">          level: 'info',</p>
			<p class="source-code">          message: 'Post was created',</p>
			<p class="source-code">        });</p>
			<p class="source-code">        return newPost;</p>
			<p class="source-code">      });</p>
			<p class="source-code">    });</p>
			<p class="source-code">  });</p>
			<p class="source-code">},</p>
			<p>As always, the preceding mutation returns a promise. This promise is resolved when the deepest query has been executed successfully. The execution order is as follows:</p>
			<ol>
				<li value="1">We retrieve all the users from the database through the <strong class="source-inline">User.findAll</strong> method.</li>
				<li>We insert the post into our database with the <strong class="source-inline">create</strong> function from Sequelize. The only property that we pass is the <strong class="source-inline">post</strong> object from the original request, which only holds the text of the post. MySQL autogenerates the <strong class="source-inline">id</strong> property of the post.<p class="callout-heading">Note</p><p class="callout">Sequelize also offers a <strong class="source-inline">build</strong> function, which initializes the model instance for us. In this case, we would have to run the <strong class="source-inline">save</strong> method to insert the model manually. The <strong class="source-inline">create</strong> function does this for us all at once.</p></li>
				<li>The post <a id="_idIndexMarker221"/>has been created, but <strong class="source-inline">userId</strong> has not been set.<p>You could <a id="_idIndexMarker222"/>also directly add the user ID to the <strong class="source-inline">Post.create</strong> function. The problem here is that we would not establish the model associations, even though this is reflected in the database. If we return the created post model without explicitly using <strong class="source-inline">setUser</strong> on the model instance, we cannot use the <strong class="source-inline">getUser</strong> function, which is used to return the user for the mutation's response.</p><p>So, to fix this problem, we must run the <strong class="source-inline">create</strong> function, resolve the promise, and then run <strong class="source-inline">setUser</strong> separately. As a parameter of <strong class="source-inline">setUser</strong>, we statically take the ID of the first user from the <strong class="source-inline">users</strong> array.</p><p>We resolve the promise of the <strong class="source-inline">setUser</strong> function by using an array surrounded by <strong class="source-inline">Promise.all</strong>. This allows us to add further Sequelize methods later. For example, you could add a category to each post, too.</p></li>
				<li>Once we have set <strong class="source-inline">userId</strong> correctly, the returned value is the newly created post model instance.</li>
			</ol>
			<p>Everything is set now. To test our API, we are going to use Postman again. We need to change the <strong class="source-inline">addPost</strong> request. <strong class="source-inline">userInput</strong>, which we added previously, is not needed anymore, because the backend statically chooses the first user out of our database. You can send the following request body:</p>
			<p class="source-code">{</p>
			<p class="source-code">  "operationName": null,</p>
			<p class="source-code">  "query": "mutation addPost($post : PostInput!) { </p>
			<p class="source-code">    addPost(post : $post) { </p>
			<p class="source-code">    id text user { username avatar }}}",</p>
			<p class="source-code">  "variables":{</p>
			<p class="source-code">    "post": {</p>
			<p class="source-code">      "text": "You just added a post."</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>Your <a id="_idIndexMarker223"/>GraphQL schema <a id="_idIndexMarker224"/>must reflect this change, so remove <strong class="source-inline">userInput</strong> from there, too:</p>
			<p class="source-code">addPost (</p>
			<p class="source-code">  post: PostInput!</p>
			<p class="source-code">): Post</p>
			<p>Running the <strong class="source-inline">addPost</strong> GraphQL mutation now adds a post to the <strong class="source-inline">Posts</strong> table, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="image/Figure_3.08_B17337.jpg" alt="Figure 3.8 – Post inserted into the database table&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.8 – Post inserted into the database table</p>
			<p>As we are not using the demo <strong class="source-inline">posts</strong> array anymore, you can remove it from the <strong class="source-inline">resolvers.js</strong> file.</p>
			<p>With that, we have rebuilt the example from the previous chapter, but we are using a database in our backend. To extend our application, we are going to add two new entities called <strong class="source-inline">Chat</strong> and <strong class="source-inline">Message</strong>.</p>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor077"/>Many-to-many relationships</h1>
			<p>Facebook provides users with various ways to interact. Currently, we only have the opportunity to request and insert posts. As is the case with Facebook, we want to have chats <a id="_idIndexMarker225"/>with our friends and colleagues. We will introduce two new entities to cover this.</p>
			<p>The first entity is called <strong class="source-inline">Chat</strong>, while the second entity is called <strong class="source-inline">Message</strong>.</p>
			<p>Before we start the implementation, we need to lay out a detailed plan of what those entities will enable us to do.</p>
			<p>A user can have multiple chats, and a chat can belong to multiple users. This relationship allows us to have group chats with multiple users, as well as private chats between only two users. A message belongs to one user, but every message also belongs to one chat.</p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor078"/>Model and migrations</h2>
			<p>When transferring this into real code, we must generate the <strong class="source-inline">Chat</strong> model. The problem here is <a id="_idIndexMarker226"/>that we have a many-to-many relationship between users and chats. In MySQL, this kind of relationship requires a table to store the relationships between all the entities separately.</p>
			<p>These tables <a id="_idIndexMarker227"/>are called <strong class="bold">join tables</strong>. Instead of using a foreign key on the chat or a user to save the relationship, we have a table called <strong class="source-inline">user_chats</strong>. The user's ID and the chat's ID are associated with each other inside this table. If a user participates in multiple chats, they will have multiple rows in this table, with different chat IDs.</p>
			<h3>Chat model</h3>
			<p>Let's start by <a id="_idIndexMarker228"/>creating the <strong class="source-inline">Chat</strong> model and migration. A chat itself does not store any data; we use it for grouping specific users' messages:</p>
			<p class="source-code">sequelize model:generate --models-path src/server/models --migrations-path src/server/migrations --name Chat --attributes firstName:string,lastName:string,email:string</p>
			<p>Generate the migration for our association table, as follows:</p>
			<p class="source-code">sequelize migration:create --migrations-path src/server/migrations --name create-user-chats</p>
			<p>Adjust the <strong class="source-inline">users_chats</strong> migration that's generated by the Sequelize CLI. We specify the user and <a id="_idIndexMarker229"/>chat IDs as attributes for our relationship. References inside a migration automatically create foreign key constraints for us. The migration file should look as follows:</p>
			<p class="source-code">'use strict';</p>
			<p class="source-code">module.exports = {</p>
			<p class="source-code">  up: async (queryInterface, Sequelize) =&gt; {</p>
			<p class="source-code">    return queryInterface.createTable('users_chats', {</p>
			<p class="source-code">      id: {</p>
			<p class="source-code">        allowNull: false,</p>
			<p class="source-code">        autoIncrement: true,</p>
			<p class="source-code">        primaryKey: true,</p>
			<p class="source-code">        type: Sequelize.INTEGER</p>
			<p class="source-code">      },</p>
			<p class="source-code">      userId: {</p>
			<p class="source-code">        type: Sequelize.INTEGER,</p>
			<p class="source-code">        references: {</p>
			<p class="source-code">          model: 'Users',</p>
			<p class="source-code">          key: 'id'</p>
			<p class="source-code">        },</p>
			<p class="source-code">        onDelete: 'cascade',</p>
			<p class="source-code">        onUpdate: 'cascade',</p>
			<p class="source-code">      },</p>
			<p class="source-code">      chatId: {</p>
			<p class="source-code">        type: Sequelize.INTEGER,</p>
			<p class="source-code">        references: {</p>
			<p class="source-code">          model: 'Chats',</p>
			<p class="source-code">          key: 'id'</p>
			<p class="source-code">        },</p>
			<p class="source-code">        onDelete: 'cascade',</p>
			<p class="source-code">        onUpdate: 'cascade',</p>
			<p class="source-code">      },</p>
			<p class="source-code">      createdAt: {</p>
			<p class="source-code">        allowNull: false,</p>
			<p class="source-code">        type: Sequelize.DATE</p>
			<p class="source-code">      },</p>
			<p class="source-code">      updatedAt: {</p>
			<p class="source-code">        allowNull: false,</p>
			<p class="source-code">        type: Sequelize.DATE</p>
			<p class="source-code">      }</p>
			<p class="source-code">    });</p>
			<p class="source-code">  },</p>
			<p class="source-code">  down: async (queryInterface, Sequelize) =&gt; {</p>
			<p class="source-code">    return queryInterface.dropTable('users_chats');</p>
			<p class="source-code">  }</p>
			<p class="source-code">};</p>
			<p>A separate model file for the association table is not needed because we can rely on this table in the models where the association is required. The <strong class="source-inline">id</strong> column could be left out because the row can only be identified by the user and chat ID.</p>
			<p>Associate the <strong class="source-inline">User</strong> model with the <strong class="source-inline">Chat</strong> model via the new relationship table in the <strong class="source-inline">User</strong> model, as follows:</p>
			<p class="source-code">this.belongsToMany(models.Chat, { through: 'users_chats' });</p>
			<p>Do the same for the <strong class="source-inline">Chat</strong> model, as follows:</p>
			<p class="source-code">this.belongsToMany(models.User, { through: 'users_chats' });</p>
			<p>The <strong class="source-inline">through</strong> property tells Sequelize that the two models are related via the <strong class="source-inline">users_chats</strong> table. Normally, when you are not using Sequelize and are trying to select all users and chats merged in raw SQL, you need to maintain this association manually and <a id="_idIndexMarker230"/>join the three tables on your own. Sequelize's querying and association capabilities are so complex, so this is all done for you.</p>
			<p>Rerun the migrations to let the changes take effect:</p>
			<p class="source-code">sequelize db:migrate --migrations-path src/server/migrations --config src/server/config/index.js</p>
			<p>The following screenshot shows what your database should look like now:</p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/Figure_3.09_B17337.jpg" alt="Figure 3.9 – Database structure&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.9 – Database structure</p>
			<p>You should see two foreign key constraints in the relationship view of the <strong class="source-inline">users_chats</strong> table. The naming is done automatically:</p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/Figure_3.10_B17337.jpg" alt="Figure 3.10 – Foreign keys for the users_chats table&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.10 – Foreign keys for the users_chats table</p>
			<p>This setup <a id="_idIndexMarker231"/>was the tough part. Next up is the message entity, which is a simple one-to-one relationship. One message belongs to one user and one chat.</p>
			<h3>Message model</h3>
			<p>A message is much <a id="_idIndexMarker232"/>like a post, except that it can only be read inside a chat and is not public to everyone.</p>
			<p>Generate the model and migration file with the CLI, as follows:</p>
			<p class="source-code">sequelize model:generate --models-path src/server/models --migrations-path src/server/migrations --name Message --attributes text:string,userId:integer,chatId:integer</p>
			<p>Add the missing references to the created migration file by replacing the following properties:</p>
			<p class="source-code">userId: {</p>
			<p class="source-code">  type: Sequelize.INTEGER,</p>
			<p class="source-code">  references: {</p>
			<p class="source-code">    model: 'Users',</p>
			<p class="source-code">    key: 'id'</p>
			<p class="source-code">  },</p>
			<p class="source-code">  onDelete: 'SET NULL',</p>
			<p class="source-code">  onUpdate: 'cascade',</p>
			<p class="source-code">},</p>
			<p class="source-code">chatId: {</p>
			<p class="source-code">  type: Sequelize.INTEGER,</p>
			<p class="source-code">  references: {</p>
			<p class="source-code">    model: 'Chats',</p>
			<p class="source-code">    key: 'id'</p>
			<p class="source-code">  },</p>
			<p class="source-code">  onDelete: 'cascade',</p>
			<p class="source-code">  onUpdate: 'cascade',</p>
			<p class="source-code">},</p>
			<p>Now, we can run the migrations again to create the <strong class="source-inline">Messages</strong> table using the <strong class="source-inline">sequelize db:migrate</strong> Terminal command.</p>
			<p>The references <a id="_idIndexMarker233"/>also apply to our model file, where we need to use Sequelize's <strong class="source-inline">belongsTo</strong> function to get all those convenient model methods for our resolvers. Replace the <strong class="source-inline">associate</strong> function of the <strong class="source-inline">Message</strong> model with the following code:</p>
			<p class="source-code">static associate(models) {</p>
			<p class="source-code">  this.belongsTo(models.User);</p>
			<p class="source-code">  this.belongsTo(models.Chat);    </p>
			<p class="source-code">}</p>
			<p>In the preceding code, we defined that every message is related to exactly one user and chat.</p>
			<p>On the other hand, we must also associate the <strong class="source-inline">Chat</strong> model with the messages. Add the following code to the <strong class="source-inline">associate</strong> function of the <strong class="source-inline">Chat</strong> model:</p>
			<p class="source-code">this.hasMany(models.Message);</p>
			<p>The next step is to adjust our GraphQL API to provide chats and messages.</p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor079"/>Chats and messages in GraphQL</h2>
			<p>So far, we <a id="_idIndexMarker234"/>have introduced <a id="_idIndexMarker235"/>some new entities with messages and chats. Let's include those in our Apollo schema. In the following code, you can see an excerpt <a id="_idIndexMarker236"/>of the changed <a id="_idIndexMarker237"/>entities, fields, and parameters of our GraphQL schema:</p>
			<p class="source-code">type User {</p>
			<p class="source-code">  id: Int</p>
			<p class="source-code">  avatar: String</p>
			<p class="source-code">  username: String</p>
			<p class="source-code">}</p>
			<p class="source-code">type Post {</p>
			<p class="source-code">  id: Int</p>
			<p class="source-code">  text: String</p>
			<p class="source-code">  user: User</p>
			<p class="source-code">}</p>
			<p class="source-code">type Message {</p>
			<p class="source-code">  id: Int</p>
			<p class="source-code">  text: String</p>
			<p class="source-code">  chat: Chat</p>
			<p class="source-code">  user: User</p>
			<p class="source-code">}</p>
			<p class="source-code">type Chat {</p>
			<p class="source-code">  id: Int</p>
			<p class="source-code">  messages: [Message]</p>
			<p class="source-code">  users: [User]</p>
			<p class="source-code">}</p>
			<p class="source-code">type RootQuery {</p>
			<p class="source-code">  posts: [Post]</p>
			<p class="source-code">  chats: [Chat]</p>
			<p class="source-code">}</p>
			<p>Take a look <a id="_idIndexMarker238"/>at the following short changelog of our GraphQL schema:</p>
			<ul>
				<li>The <strong class="source-inline">User</strong> type received an <strong class="source-inline">id</strong> field, thanks to our database.</li>
				<li>The <strong class="source-inline">Message</strong> type is entirely new. It has a text field like a typical message, and user and chat fields, which are requested from the referenced tables in the database model.</li>
				<li>The <strong class="source-inline">Chat</strong> type is also new. A chat contains a list of messages that are returned as an array. These can be queried through the chat ID, which is saved in the message table. Furthermore, a chat has an unspecified number of users. The relationships between users and chats are saved in our separate <strong class="bold">join table</strong>. The interesting thing here is that our schema does not know anything about this table; it is just for our internal use to save the data appropriately in our MySQL server.</li>
				<li>I have also added a new <strong class="source-inline">RootQuery</strong>, called <strong class="source-inline">chats</strong>. This query returns all the user's chats.</li>
			</ul>
			<p>These <a id="_idIndexMarker239"/>factors should <a id="_idIndexMarker240"/>be implemented in our resolvers too. Our resolvers should look as follows:</p>
			<p class="source-code">Message: {</p>
			<p class="source-code">  user(message, args, context) {</p>
			<p class="source-code">    return message.getUser();</p>
			<p class="source-code">  },</p>
			<p class="source-code">  chat(message, args, context) {</p>
			<p class="source-code">    return message.getChat();</p>
			<p class="source-code">  },</p>
			<p class="source-code">},</p>
			<p class="source-code">Chat: {</p>
			<p class="source-code">  messages(chat, args, context) {</p>
			<p class="source-code">    return chat.getMessages({ order: [['id', 'ASC']] });</p>
			<p class="source-code">  },</p>
			<p class="source-code">  users(chat, args, context) {</p>
			<p class="source-code">    return chat.getUsers();</p>
			<p class="source-code">  },</p>
			<p class="source-code">},</p>
			<p class="source-code">RootQuery: {</p>
			<p class="source-code">  posts(root, args, context) {</p>
			<p class="source-code">    return Post.findAll({order: [['createdAt', 'DESC']]});</p>
			<p class="source-code">  },</p>
			<p class="source-code">  chats(root, args, context) {</p>
			<p class="source-code">    return User.findAll().then((users) =&gt; {</p>
			<p class="source-code">      if (!users.length) {</p>
			<p class="source-code">        return [];</p>
			<p class="source-code">      }</p>
			<p class="source-code">      const usersRow = users[0];</p>
			<p class="source-code"> </p>
			<p class="source-code">      return Chat.findAll({</p>
			<p class="source-code">        include: [{</p>
			<p class="source-code">          model: User,</p>
			<p class="source-code">          required: true,</p>
			<p class="source-code">          through: { where: { userId: usersRow.id } },</p>
			<p class="source-code">        },</p>
			<p class="source-code">        {</p>
			<p class="source-code">          model: Message,</p>
			<p class="source-code">        }],</p>
			<p class="source-code">      });</p>
			<p class="source-code">    });</p>
			<p class="source-code">  },</p>
			<p class="source-code">},</p>
			<p>Let's go <a id="_idIndexMarker241"/>through the <a id="_idIndexMarker242"/>changes one by one:</p>
			<ul>
				<li>We added the <strong class="source-inline">Message</strong> property to our resolvers.</li>
				<li>We added the <strong class="source-inline">Chat</strong> property to the <strong class="source-inline">resolvers</strong> object. There, we run the <strong class="source-inline">getMessages</strong> and <strong class="source-inline">getUsers</strong> functions, to retrieve all the joined data. All the messages are sorted by the ID in ascending order (to show the latest message at the bottom of a chat window, for example).</li>
				<li>I added the new <strong class="source-inline">RootQuery</strong>, called <strong class="source-inline">chats</strong>, to return all the fields, as in our schema:<p>a) Until we get a working authentication, we will statically use the first user when querying for all chats.</p><p>b) We are using the <strong class="source-inline">findAll</strong> method of Sequelize and joining the users of any returned chat. For this, we use the <strong class="source-inline">include</strong> property of Sequelize on the <strong class="source-inline">User</strong> model within the <strong class="source-inline">findAll</strong> method. It runs a MySQL <strong class="source-inline">JOIN</strong>, not a second <strong class="source-inline">SELECT</strong> query.</p><p>c) Setting the <strong class="source-inline">include</strong> statement to <strong class="source-inline">required</strong> runs an <strong class="source-inline">INNER JOIN</strong>, not a <strong class="source-inline">LEFT OUTER JOIN</strong>, by default. Any chat that does not match the condition in the <strong class="source-inline">through</strong> property is excluded. In our example, the condition is that the user ID must match.</p><p>d) Lastly, we join all the available messages for each chat in the same way, without any condition.</p></li>
			</ul>
			<p>We must <a id="_idIndexMarker243"/>use the new <a id="_idIndexMarker244"/>models here. We should not forget to extract them from the <strong class="source-inline">db.models</strong> object inside the <strong class="source-inline">resolver</strong> function. It must look as follows:</p>
			<p class="source-code">const { Post, User, Chat, Message } = db.models;</p>
			<p>You can send this GraphQL request to test the changes:</p>
			<p class="source-code">{</p>
			<p class="source-code">  "operationName":null,</p>
			<p class="source-code">  "query": "{ chats { id users { id } messages { id text</p>
			<p class="source-code">    user { id username } } } }",</p>
			<p class="source-code">  "variables":{}</p>
			<p class="source-code">}</p>
			<p>The response should give us an empty <strong class="source-inline">chats</strong> array, as follows:</p>
			<p class="source-code">{</p>
			<p class="source-code">  "data": {</p>
			<p class="source-code">    "chats": []</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>This empty array was returned because we do not have any chats or messages in our database. You will learn how to fill it with data in the next section.</p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor080"/>Seeding many-to-many data</h2>
			<p>Testing our implementation requires data to be in our database. We have three new tables, so we <a id="_idIndexMarker245"/>will create three new seeders to get some test data to work with.</p>
			<p>Let's start with the chats, as follows:</p>
			<p class="source-code">sequelize seed:generate --name fake-chats --seeders-path src/server/seeders</p>
			<p>Now, replace the new seeder file with the following code. Running the following code creates a chat in our database. We do not need more than two timestamps because the chat ID is generated automatically:</p>
			<p class="source-code">'use strict';</p>
			<p class="source-code">module.exports = {</p>
			<p class="source-code">  up: async (queryInterface, Sequelize) =&gt; {</p>
			<p class="source-code">    return queryInterface.bulkInsert('Chats', [{</p>
			<p class="source-code">      createdAt: new Date(),</p>
			<p class="source-code">      updatedAt: new Date(),</p>
			<p class="source-code">    }],</p>
			<p class="source-code">    {});</p>
			<p class="source-code">  },</p>
			<p class="source-code">  down: async (queryInterface, Sequelize) =&gt; {</p>
			<p class="source-code">    return queryInterface.bulkDelete('Chats', null, {});</p>
			<p class="source-code">  }</p>
			<p class="source-code">};</p>
			<p>Next, we must insert the relationship between two users and the new chat. We can do this by creating two entries in the <strong class="source-inline">users_chats</strong> table where we reference them. Now, generate the boilerplate seed file, as follows:</p>
			<p class="source-code">sequelize seed:generate --name fake-chats-users-relations --seeders-path src/server/seeders</p>
			<p>Our seed <a id="_idIndexMarker246"/>should look much like the previous ones, as follows:</p>
			<p class="source-code">'use strict';</p>
			<p class="source-code">module.exports = {</p>
			<p class="source-code">  up: async (queryInterface, Sequelize) =&gt; {</p>
			<p class="source-code">    const usersAndChats = Promise.all([</p>
			<p class="source-code">      queryInterface.sequelize.query(</p>
			<p class="source-code">        'SELECT id from Users;',</p>
			<p class="source-code">      ),</p>
			<p class="source-code">      queryInterface.sequelize.query(</p>
			<p class="source-code">        'SELECT id from Chats;',</p>
			<p class="source-code">      ),</p>
			<p class="source-code">    ]);</p>
			<p class="source-code">    </p>
			<p class="source-code">    return usersAndChats.then((rows) =&gt; {</p>
			<p class="source-code">      const users = rows[0][0];</p>
			<p class="source-code">      const chats = rows[1][0];</p>
			<p class="source-code"> </p>
			<p class="source-code">      return queryInterface.bulkInsert('users_chats', [{</p>
			<p class="source-code">        userId: users[0].id,</p>
			<p class="source-code">        chatId: chats[0].id,</p>
			<p class="source-code">        createdAt: new Date(),</p>
			<p class="source-code">        updatedAt: new Date(),</p>
			<p class="source-code">      },</p>
			<p class="source-code">      {</p>
			<p class="source-code">        userId: users[1].id,</p>
			<p class="source-code">        chatId: chats[0].id,</p>
			<p class="source-code">        createdAt: new Date(),</p>
			<p class="source-code">        updatedAt: new Date(),</p>
			<p class="source-code">      }],</p>
			<p class="source-code">      {});</p>
			<p class="source-code">    });</p>
			<p class="source-code">  },</p>
			<p class="source-code">  down: async (queryInterface, Sequelize) =&gt; {</p>
			<p class="source-code">    return queryInterface.bulkDelete('users_chats', null, {});</p>
			<p class="source-code">  }</p>
			<p class="source-code">};</p>
			<p>Inside the <strong class="source-inline">up</strong> migration, we resolve all the users and chats using <strong class="source-inline">Promise.all</strong>. This ensures that, when <a id="_idIndexMarker247"/>the promise is resolved, all the chats and users are available at the same time. To test the chat functionality, we choose the first chat and the first two users that are returned from the database. We take their IDs and save them in our <strong class="source-inline">users_chats</strong> table. Those two users should be able to talk to each other through this one chat later.</p>
			<p>The last table without any data in it is the <strong class="source-inline">Messages</strong> table. Generate the seed file, as follows:</p>
			<p class="source-code">sequelize seed:generate --name fake-messages --seeders-path src/server/seeders</p>
			<p>Again, replace the generated boilerplate code, as follows:</p>
			<p class="source-code">'use strict';</p>
			<p class="source-code">module.exports = {</p>
			<p class="source-code">  up: async (queryInterface, Sequelize) =&gt; {</p>
			<p class="source-code">    const usersAndChats = Promise.all([</p>
			<p class="source-code">      queryInterface.sequelize.query(</p>
			<p class="source-code">        'SELECT id from Users;',</p>
			<p class="source-code">      ),</p>
			<p class="source-code">      queryInterface.sequelize.query(</p>
			<p class="source-code">        'SELECT id from Chats;',</p>
			<p class="source-code">      ),</p>
			<p class="source-code">    ]);</p>
			<p class="source-code"> </p>
			<p class="source-code">    return usersAndChats.then((rows) =&gt; {</p>
			<p class="source-code">      const users = rows[0][0];</p>
			<p class="source-code">      const chats = rows[1][0];</p>
			<p class="source-code"> </p>
			<p class="source-code">      return queryInterface.bulkInsert('Messages', [{</p>
			<p class="source-code">        userId: users[0].id,</p>
			<p class="source-code">        chatId: chats[0].id,</p>
			<p class="source-code">        text: 'This is a test message.',</p>
			<p class="source-code">        createdAt: new Date(),</p>
			<p class="source-code">        updatedAt: new Date(),</p>
			<p class="source-code">      },</p>
			<p class="source-code">      {</p>
			<p class="source-code">        userId: users[1].id,</p>
			<p class="source-code">        chatId: chats[0].id,</p>
			<p class="source-code">        text: 'This is a second test message.',</p>
			<p class="source-code">        createdAt: new Date(),</p>
			<p class="source-code">        updatedAt: new Date(),</p>
			<p class="source-code">      }],</p>
			<p class="source-code">      {});</p>
			<p class="source-code">    });</p>
			<p class="source-code">  },</p>
			<p class="source-code">  down: async (queryInterface, Sequelize) =&gt; {</p>
			<p class="source-code">    return queryInterface.bulkDelete('Messages', null, {});</p>
			<p class="source-code">  }</p>
			<p class="source-code">};</p>
			<p>Now, all the seed files should be ready. It makes sense to empty all the tables before running the <a id="_idIndexMarker248"/>seeds so that you can work with clean data. I like to delete all the tables in the database from time to time and rerun all the migrations and seeds to test them from zero. Whether or not you are doing this, you should at least be able to run the new seed.</p>
			<p>Try to run the GraphQL <strong class="source-inline">chats</strong> query again. It should look as follows:</p>
			<p class="source-code">{</p>
			<p class="source-code">  "data": {</p>
			<p class="source-code">    "chats": [{</p>
			<p class="source-code">      "id": 1,</p>
			<p class="source-code">      "users": [</p>
			<p class="source-code">        {</p>
			<p class="source-code">          "id": 1</p>
			<p class="source-code">        },</p>
			<p class="source-code">        {</p>
			<p class="source-code">          "id": 2</p>
			<p class="source-code">        }</p>
			<p class="source-code">      ],</p>
			<p class="source-code">      "messages": [</p>
			<p class="source-code">        {</p>
			<p class="source-code">          "id": 1,</p>
			<p class="source-code">          "text": "This is a test message.",</p>
			<p class="source-code">          "user": {</p>
			<p class="source-code">            "id": 1,</p>
			<p class="source-code">            "username": "Test User"</p>
			<p class="source-code">          }</p>
			<p class="source-code">        },</p>
			<p class="source-code">        {</p>
			<p class="source-code">          "id": 2,</p>
			<p class="source-code">          "text": "This is a second test message.",</p>
			<p class="source-code">          "user": {</p>
			<p class="source-code">            "id": 2,</p>
			<p class="source-code">            "username": "Test User 2"</p>
			<p class="source-code">          }</p>
			<p class="source-code">        }</p>
			<p class="source-code">      ]}</p>
			<p class="source-code">    ]</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>Great! Now, we can request all the chats that a user participates in and get all the referenced users and their messages.</p>
			<p>Now, we also <a id="_idIndexMarker249"/>want to do this for only one chat. Follow these steps:</p>
			<ol>
				<li value="1">Add a <strong class="source-inline">RootQuery</strong> chat that takes a <strong class="source-inline">chatId</strong> as a parameter:<p class="source-code">chat(root, { chatId }, context) {</p><p class="source-code">  return Chat.findByPk(chatId, {</p><p class="source-code">    include: [{</p><p class="source-code">      model: User,</p><p class="source-code">      required: true,</p><p class="source-code">    },</p><p class="source-code">    {</p><p class="source-code">      model: Message,</p><p class="source-code">    }],</p><p class="source-code">  });</p><p class="source-code">},</p><p>With this implementation, we have the problem that all the users can send a query to our Apollo Server and, in return, get the complete chat history, even if they are not referenced in the chat. We will not be able to fix this until we implement authentication later in <a href="B17337_06_Final_ASB_ePub.xhtml#_idTextAnchor141"><em class="italic">Chapter 6</em></a>, <em class="italic">Authentication with Apollo and React</em>.</p></li>
				<li>Add the new query to the GraphQL schema, under <strong class="source-inline">RootQuery</strong>:<p class="source-code">chat(chatId: Int): Chat</p></li>
				<li>Send the GraphQL request to test the implementation, as follows:<p class="source-code">{</p><p class="source-code">  "operationName":null,</p><p class="source-code">  "query": "query($chatId: Int!){ chat(chatId:</p><p class="source-code">    $chatId) { </p><p class="source-code">    id users { id } messages { id text user { id</p><p class="source-code">      username } } } }",</p><p class="source-code">  "variables":{ "chatId": 1 }</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we are sending this query, including <strong class="source-inline">chatId</strong> as a parameter. To pass a parameter, you must define it in the query with its GraphQL data type. Then, you can set it in the specific GraphQL query that you are executing, which is the <strong class="source-inline">chat</strong> query. Lastly, you must insert the parameter's value into the <strong class="source-inline">variables</strong> field of the GraphQL request.</p>
			<p>You may <a id="_idIndexMarker250"/>remember the response from the last time. The new response will look much like a result of the <strong class="source-inline">chats</strong> query, but instead of an array of chats, we will just have one <strong class="source-inline">chat</strong> object.</p>
			<p>We are missing a major feature: sending new messages or creating a new chat. We will create the corresponding schema, and the resolvers for it, in the next section.</p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor081"/>Creating a new chat</h2>
			<p>New users <a id="_idIndexMarker251"/>want to chat with their friends, so creating a new chat is essential.</p>
			<p>The best way to do this is to accept a list of user IDs so that we can allow group chats too. Do this as follows:</p>
			<ol>
				<li value="1">Add the <strong class="source-inline">addChat</strong> function to <strong class="source-inline">RootMutation</strong> in the <strong class="source-inline">resolvers.js</strong> file, as follows:<p class="source-code">addChat(root, { chat }, context) {</p><p class="source-code">  return Chat.create().then((newChat) =&gt; {</p><p class="source-code">    return Promise.all([</p><p class="source-code">      newChat.setUsers(chat.users),</p><p class="source-code">    ]).then(() =&gt; {</p><p class="source-code">      logger.log({</p><p class="source-code">        level: 'info',</p><p class="source-code">        message: 'Message was created',</p><p class="source-code">      });</p><p class="source-code">      return newChat;</p><p class="source-code">    });</p><p class="source-code">  });</p><p class="source-code">},</p><p>Sequelize added the <strong class="source-inline">setUsers</strong> function to the chat model instance. It was added <a id="_idIndexMarker252"/>because of the associations using the <strong class="source-inline">belongsToMany</strong> method in the chat model. There, we can directly provide an array of user IDs that should be associated with the new chat, through the <strong class="source-inline">users_chats</strong> table.</p></li>
				<li>Change the schema so that you can run the GraphQL mutation. We must add the new input type and mutation, as follows:<p class="source-code">input ChatInput {</p><p class="source-code">  users: [Int]</p><p class="source-code">}</p><p class="source-code">type RootMutation {</p><p class="source-code">  addPost (</p><p class="source-code">    post: PostInput!</p><p class="source-code">  ): Post</p><p class="source-code">  addChat (</p><p class="source-code">    chat: ChatInput!</p><p class="source-code">  ): Chat</p><p class="source-code">}</p></li>
				<li>Test the new GraphQL <strong class="source-inline">addChat</strong> mutation as your request body:<p class="source-code">{</p><p class="source-code">  "operationName":null,</p><p class="source-code">  "query": "mutation addChat($chat: ChatInput!) { </p><p class="source-code">    addChat(chat: $chat) { id users { id } }}",</p><p class="source-code">  "variables":{</p><p class="source-code">    "chat": {</p><p class="source-code">      "users": [1, 2]</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p></li>
			</ol>
			<p>You can verify that everything worked by checking the users that were returned inside the <strong class="source-inline">chat</strong> object.</p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor082"/>Creating a new message</h2>
			<p>We can <a id="_idIndexMarker253"/>use the <strong class="source-inline">addPost</strong> mutation as our basis and extend it. The result accepts a <strong class="source-inline">chatId</strong> and uses the first user from our database. Later, the authentication will be the source of the user ID:</p>
			<ol>
				<li value="1">Add the <strong class="source-inline">addMessage</strong> function to <strong class="source-inline">RootMutation</strong> in the <strong class="source-inline">resolvers.js</strong> file, as follows:<p class="source-code">addMessage(root, { message }, context) {</p><p class="source-code">  return User.findAll().then((users) =&gt; {</p><p class="source-code">    const usersRow = users[0];</p><p class="source-code"> </p><p class="source-code">    return Message.create({</p><p class="source-code">      ...message,</p><p class="source-code">    }).then((newMessage) =&gt; {</p><p class="source-code">      return Promise.all([</p><p class="source-code">        newMessage.setUser(usersRow.id),</p><p class="source-code">        newMessage.setChat(message.chatId),</p><p class="source-code">      ]).then(() =&gt; {</p><p class="source-code">        logger.log({</p><p class="source-code">          level: 'info',</p><p class="source-code">          message: 'Message was created',</p><p class="source-code">        });</p><p class="source-code">        return newMessage;</p><p class="source-code">      });</p><p class="source-code">    });</p><p class="source-code">  });</p><p class="source-code">},</p></li>
				<li>Then, add <a id="_idIndexMarker254"/>the new mutation to your GraphQL schema. We also have a new input type for our messages:<p class="source-code">input MessageInput {</p><p class="source-code">  text: String!</p><p class="source-code">  chatId: Int!</p><p class="source-code">}</p><p class="source-code">type RootMutation {</p><p class="source-code">  addPost (</p><p class="source-code">    post: PostInput!</p><p class="source-code">  ): Post</p><p class="source-code">  addChat (</p><p class="source-code">    chat: ChatInput!</p><p class="source-code">  ): Chat</p><p class="source-code">  addMessage (</p><p class="source-code">    message: MessageInput!</p><p class="source-code">  ): Message</p><p class="source-code">}</p></li>
				<li>You can <a id="_idIndexMarker255"/>send the request in the same way as the <strong class="source-inline">addPost</strong> request:<p class="source-code">{</p><p class="source-code">   "operationName":null,</p><p class="source-code">   "query": "mutation addMessage($message :</p><p class="source-code">     MessageInput!) { </p><p class="source-code">     addMessage(message : $message) { id text }}",</p><p class="source-code">   "variables":{</p><p class="source-code">     "message": {</p><p class="source-code">       "text": "You just added a message.",</p><p class="source-code">       "chatId": 1</p><p class="source-code">     }</p><p class="source-code">   }</p><p class="source-code">}</p></li>
			</ol>
			<p>Now, everything is set. The client can now request all posts, chats, and messages. Furthermore, users can create new posts, create new chat rooms, and send chat messages.</p>
			<h1 id="_idParaDest-80"><a id="_idTextAnchor083"/>Summary</h1>
			<p>Our goal in this chapter was to create a working backend with a database as storage, which we have achieved pretty well. We can add further entities and migrate and seed them with Sequelize. Migrating our database changes won't be a problem for us when it comes to going into production.</p>
			<p>In this chapter, we also covered what Sequelize automates for us when using its models, and how great it works in coordination with our Apollo Server.</p>
			<p>In the next chapter, we will focus on how to use the Apollo React Client library with our backend, as well as the database behind it.</p>
		</div>
	</body></html>