- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Designing Your React Components
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to this pivotal chapter on mastering React component design. In this
    chapter, we’ll embark on an enriching journey to recognize and eradicate common
    anti-patterns in designing React components, including issues such as large monolithic
    components, prop drilling, and other prevalent pitfalls that often perplex developers
    and hamper the maintainability and scalability of React applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll introduce the single responsibility principle. In the realm of
    React, this guides us to ensure that each component has one specific purpose.
    Adhering to this principle makes components easier to understand, test, and maintain,
    all while making your code more readable and manageable.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll explore the don’t repeat yourself principle. One of the core tenets
    of effective programming, this encourages developers to minimize repetition and
    promote reuse. In the context of React, this principle can be the key to unlocking
    a more streamlined, efficient, and maintainable code base.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we’ll delve into the component composition principle. Composition allows
    us to build complex UIs by combining simpler, reusable components. In React, composition
    is favored over inheritance, leading to more flexible and easier-to-manage components.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we’ll take a deep dive into each of these principles,
    providing real-world examples and practical applications. By doing so, we aim
    to guide you in crafting more efficient components, bolstering your understanding
    of React’s potential, and enhancing your problem-solving skills in this powerful
    library.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in this chapter, we will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the single responsibility principle
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about the don’t repeat yourself principle
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using composition
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining component design principles
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A GitHub repository has been created to host all the code we discuss in the
    book. For this chapter, you can find the recommended structure under [https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch4](https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch4).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the single responsibility principle
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **single responsibility principle** (**SRP**) is one of the fundamental
    concepts in software engineering, asserting that a function, class, or, in the
    context of React, a component, should have only one reason to change. In other
    words, each component should ideally handle a single task or functionality. Following
    this principle can make your code more readable, maintainable, and easier to test
    and debug.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s illustrate this with an example. Suppose you initially have a `BlogPost`
    component that fetches blog post data, displays the post, and handles the user
    liking the post, all in one component:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The code defines a functional component called `BlogPost` that takes an `id`
    prop of the `string` type. Inside the component, there are two state variables
    defined using the `useState` Hook: `post` and `isLiked`. The `post` state represents
    the blog post data, initialized with a default value of an empty blog post. The
    `isLiked` state represents whether the post is liked or not, initialized as `false`.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Following this, we need to manage the side effect (sending network requests)
    in the `useEffect` Hook. It is used to fetch the blog post data from the server
    based on the provided `id` prop. It triggers the `fetch` operation whenever the
    `id` prop changes. Once the data is fetched, the `post` state is updated with
    the retrieved post using the `setPost` function.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `useEffect` Hook call, for the network request, there is a function
    called `fetchPostById`. The function is simply a `fetch` call to a remote API
    endpoint. We can assume the function is implemented with something like the following
    code snippet:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The component renders the title and summary of the blog post from the `post`
    state. It also renders a button that toggles the `isLiked` state when clicked,
    displaying `isLiked`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'While this code works, it violates the SRP. It’s doing three separate things:
    fetching data, displaying the blog post, and handling the like functionality.
    Instead, let’s refactor it into smaller, single-responsibility components:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, we’ve refactored `BlogPost` into smaller, single-responsibility components:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '`useFetchPost` is a custom Hook responsible for fetching the blog post data'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LikeButton` is a component responsible for handling the like functionality'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BlogPost` is now just responsible for rendering the blog post content and
    `LikeButton`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each part has a single responsibility and could be tested and maintained independently,
    leading to a more manageable code base.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: In a real-world application, clicking a `fetch` request that is sent to an endpoint
    such as https://post.service/post/<id> to change the `isLiked` status.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: So, in the first section, we explored the SRP. This principle encourages each
    component to take charge of a single piece of functionality, making our code more
    maintainable and understandable. Here, we applied this principle to break down
    large, monolithic components into smaller, more manageable pieces.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: As we advance further into our design journey, our next section leads us to
    a principle that intertwines closely with the philosophy of SRP – the don’t repeat
    yourself principle.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Don’t repeat yourself
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **don’t repeat yourself** (**DRY**) principle is a fundamental concept in
    software development that aims to reduce repetition within the code. Following
    this principle leads to better maintainability, readability, and testability,
    and can prevent bugs that occur due to the duplication of logic.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say that you have a shopping website, and you want to display a list
    of products and the user’s cart side by side, something like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1: The product list page](img/B31103_04_01.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: The product list page'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: The `ProductList` component will display the product’s image, name, and price,
    with an `Cart` component will display a list of cart items with a **Remove from**
    **Cart** button.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'A naive implementation of `ProductList` might look like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This functional component named `ProductList` accepts two props: `products`
    (an array of product objects) and `addToCart` (a function used to add a product
    to a shopping cart).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Each product object is of the `Product` type, which has the `id`, `name`, `image`,
    and `price` properties.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: The component maps over the `products` array and renders a `div` for each product,
    including an image, product name, price, and an `addToCart` function is invoked
    with the corresponding product’s `id` prop as an argument.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Cart` component has a similar structure, as you can imagine; it requires
    a list of items and renders a button with the text **Remove from Cart**, and a
    callback function for the user to invoke:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `Cart` component iterates over the `cartItems` array and, for each item,
    it renders a `div` with the item’s image, name, price, and a `removeFromCart`
    function with the respective item’s `id` prop as an argument, signifying that
    this item should be removed from the cart.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'To reduce the duplication and make each component only do one thing, we can
    extract a `LineItem` component:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We defined a functional component called `LineItem` that renders a product’s
    details and a button. It accepts properties for `product`, `performAction`, and
    `label`, and uses destructuring to extract the necessary values. The component
    returns JSX code to display the product’s information and trigger the `performAction`
    function when the button is clicked.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `ProductList` and `Cart` components, you can simply pass in different
    props to the `LineItem` component to reduce the duplication we had before:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The new `ProductList` component receives `products` and `addToCart` as props.
    It renders a list of products, with each product having an **Add to** **Cart**
    button.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, for the `Cart` component, we’ll have a similar structure that reuses
    the `LineItem` component for rendering the product details (`image`, `name`, and
    `price`):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is a more maintainable and reusable approach by following the DRY principle.
    There is less chance of introducing bugs because changes only need to be made
    in one place, and if we must add new features of `LineItem`, we only need to touch
    a single component.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we dove into the DRY principle. It guided us to eliminate redundancy
    in our code, reducing the likelihood of inconsistencies and bugs. By avoiding
    code duplication, we’ve simplified maintenance as changes in functionality need
    to be addressed in a single place. As we refined our understanding of DRY, we
    prepared ourselves to enhance our component structure using a key concept in React
    – composition.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Using composition
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In React, `div` with an `h2` tag seamlessly, without the need to incorporate
    anything new.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: The custom component is nothing more special than the built-in ones like a `div`;
    you can use your `Cart` component with a `div` just as you can use a `p` tag with
    it. This pattern enables more straightforward reuse of components, which can contribute
    to cleaner and more maintainable code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider an example. Suppose we’re building a `UserDashboard` component
    that displays user information. The profile includes an avatar, a name, and a
    list of the user’s friends and the latest posts. Here’s how it might look:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this simplified example, `UserDashboard` is responsible for rendering the
    user’s profile, a list of friends, and the latest posts, which violates the SRP.
    We can break it down into smaller components, each responsible for one thing.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we can extract the profile-related JSX into a `UserProfile` component
    that displays the user’s profile, which includes an `h1` tag (the user’s name)
    and an `avatar` image:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we create a `FriendList` component that displays a list of the user’s
    friends; it includes an `h2` tag and a `friends` list:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, we create a `PostList` component that displays a feed of posts, which
    includes an `h2` tag and a list of `posts`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, our `UserDashboard` component becomes simpler and delegates its responsibilities
    to these smaller components:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The refactored version of the `UserDashboard` component is superior due to
    several reasons:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '`UserProfile`, `FriendList`, and `PostList`), you ensure that each component
    is responsible for one task. This improves the maintainability of the code.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UserDashboard` is easier to read and understand. It becomes immediately clear
    what this component is rendering: a user profile, a list of friends, and a list
    of posts. There’s no need to read through details about how each of these parts
    is rendered.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UserProfile`, `FriendList`, and `PostList` components can now be reused in
    other parts of the application if needed, thereby promoting code reuse and reducing
    redundancy.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testability**: Smaller, single-responsibility components are easier to test,
    as they tend to have less complex interactions and dependencies. We’ll cover the
    testing and testability in [*Chapter 5*](B21103_05.xhtml#_idTextAnchor124).'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is a simple example, but it illustrates the basic idea of composition
    in React. Composition can become more complex as you deal with components that
    have their own state or logic, but the core principle remains the same: building
    larger components from smaller, reusable parts.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: This section brought us to the power of composition in React. With composition,
    we could efficiently structure and combine our components, creating complex user
    interfaces from simpler, single-responsibility components. We observed how composition
    allowed us to fully leverage the principles of SRP and DRY, leading to the creation
    of sophisticated UIs that remain easy to understand, test, and maintain.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Combining component design principles
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve separately analyzed the principles of single responsibility, don’t repeat
    yourself, and composition. However, in practical coding scenarios, things can
    get intricate, necessitating the simultaneous application of multiple principles
    to enhance the readability and maintainability of the code.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider an example of a `Page` component, which might have many responsibilities
    such as managing the state and behavior of a header, sidebar, and main content
    area. Also, there are a bunch of props for configuring each of these sections.
    It’s typical to encounter such code when individuals simply replicate the existing
    code base without much consideration or critical thinking; so the prop list grows
    as new features are added.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simplified example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We defined a `Page` component; the component uses the preceding props to render
    a page with a clickable header, a sidebar containing clickable links, and a main
    content section. The component expects an object of the `PageProps` type as its
    properties.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a closer look inside `PageProps`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '`headerTitle`: This string will be displayed as the main title in the page’s
    header'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`headerSubtitle`: This string will be displayed as the subtitle in the page’s
    header'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sidebarLinks`: This is an array of strings, where each string represents a
    link that will be displayed in the page’s sidebar'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isLoading`: This is a flag to determine whether the main content is ready
    or not'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mainContent`: This can be any valid React node (a component, an element, null,
    etc.) that represents the main content of the page'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onHeaderClick`: This function will be executed when the header section of
    the page is clicked'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onSidebarLinkClick`: This function will be executed when any sidebar link
    is clicked. The function will receive the clicked link as an argument'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Page` component has multiple responsibilities, and it has a long list of
    props that could make it hard to work with. A long prop list – when a component
    has over five props – typically signals a need for component breakdown. This is
    because remembering the purpose of each prop can be challenging, and it also increases
    the likelihood of passing the wrong prop or misordering them.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: We can group the props based on how they are used. The `headerTitle`, `headerSubtitle`,
    and `onHeaderClick` props can be split out into a group, while `isLoading` and
    `mainContent` belong to another group.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'Extracting a small part of the large component is always a good starting point.
    Note that there might be many ways to do the extracting; if the information looks
    related to each other, we can group them and create a new component for that group
    of data. For example, we can extract a `Header` component first:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This `Header` component in React takes three props – `headerTitle`, `headerSubtitle`,
    and `onHeaderClick` – and renders a header with the provided title and subtitle.
    The `onHeaderClick` prop is then called when the header is clicked.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, because `title`, `subtitle`, and the `onClick` callback are already in
    the `Header` component, we don’t need the `header` prefix in the prop names. Let’s
    rename these props:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It’s now much clearer regarding what `Header` does – it accepts `title`, `subtitle`,
    and `onClick` and doesn’t need to know anything beyond that. This extraction also
    increases the reusability of `Header`, meaning we might reuse the component in
    a different place.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can extract a `Sidebar` component with the same approach:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `Sidebar` component accepts an array of `links` and an `onLinkClick` function
    as props and generates a list of clickable items from the `links` array. The `onLinkClick`
    function is triggered when a link is clicked, passing the clicked link as an argument.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'After we extracted `Header` and `Sidebar`, the only thing left in `Page` is
    the part related to the main content. We can apply the same approach for the main
    content, extracting a `Main` component with the simple JSX fragment, as in the
    following code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As we extracted most of the content out of the `Page` component, we can now
    use these simple components without changing the public interface of `Page`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `Page` component arranges the `Header`, `Sidebar`, and `Main` components
    and takes in several props. It then passes these props to the respective child
    components – `Header` gets the title, subtitle, and a click handler; `Sidebar`
    receives a list of links and a click handler; and the `Main` component gets the
    main content and a loading state.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: The refactored `Page` looks much nicer, but it’s not perfect. Let’s consider
    a common issue with the current code. What happens if we need to pass in new props
    to `Sidebar` or `Main`?
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: To accept the new props passed into `Sidebar` or `Main`, we need to extend the
    prop list, which already has seven props. For people who use the `Page` component,
    as more props are added, they will have to remember even more props, which wouldn’t
    be a good experience (not to mention the additional testing efforts because of
    these props).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of accepting these detailed descriptions to customize `Header` or `Sidebar`,
    we can pass in an instance of `Header` and then just plug it into the correct
    slot (to replace the `Header` component):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, the `Page` component accepts a `header` prop (along with a list of sidebar
    links, a loading state, main content, and a link click handler as props) and renders
    the `Header` component directly. That means we can pass in any `header` instance
    from outside of `Page`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can do the same for `Sidebar` and `Main`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `Page` component accepts three props – `header`, `sidebar`, and `main` –
    with each expected to be a `Page` component simply renders these three props in
    a `div` in the order they are provided, effectively forming a simple page layout
    with a header, a sidebar, and a main section.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then use `Page` in the most flexible way – you can pass in a fully
    customized `Header`, `Sidebar`, and `Main` as parameters into the `Page` component:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This `MyPage` component renders a `Page` component, passing in `Header`, `Sidebar`,
    and `Main` components as props, while click events on the `Header` and `Sidebar`
    components will log certain messages to the console.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that here you can pass anything into `Page` to define `header`, `sidebar`,
    or `main`. Here’s an example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `MyPage` component wraps a `Page` component. The `Page` component receives
    three props: `header`, `sidebar`, and `main`, each containing JSX elements that
    specify what’s to be rendered in each respective section of the page. The `header`
    prop has a heading, the `sidebar` prop includes a list with `main` section contains
    the main content of the page.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: The original `Page` component was heavily burdened with a multitude of responsibilities,
    leading to a long list of props. This design presented a **prop drilling** problem,
    where a large amount of data had to be passed down through multiple layers of
    components. This setup was both complex and hard to maintain.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: With that, let’s review our process of how we applied different principles.
    The refactoring process started by breaking down the monolithic `Page` component
    into smaller, more manageable components – `Header`, `Sidebar`, and `Main` – using
    the SRP. These sub-components were designed to handle their respective responsibilities,
    thus simplifying their individual prop requirements.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Once these components were extracted, we modified the `Page` component to accept
    these sub-components (`Header`, `Sidebar`, and `Main`) as props using composition.
    This approach significantly reduced the prop drilling issue, as each sub-component
    now receives props directly at the point of usage.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: This refactoring exercise streamlined the `Page` component, resulting in a cleaner,
    more manageable code base. It utilized the principles of component composition
    and single responsibility to solve the prop drilling problem effectively.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter covered several key principles in designing and developing components
    in React: the SRP, DRY, and the use of component composition. Each of these principles
    provides different strategies for achieving clean, maintainable, and scalable
    code bases.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: By understanding and applying these principles, we can create a solid foundation
    for our React applications. These strategies lead to more organized, scalable,
    and robust code bases, ultimately making our work as developers more effective
    and enjoyable.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll start to look into an exciting topic in React applications
    – testing – and see how good structured tests can protect us from making mistakes
    while helping us to improve the code quality.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: Embracing Testing Techniques'
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, you will delve into the significance of testing in frontend development,
    exploring various testing methodologies and refactoring techniques that will ensure
    the robustness and maintainability of your React applications.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分，你将深入了解测试在前端开发中的重要性，探索各种测试方法和重构技术，以确保你的React应用程序的健壮性和可维护性。
- en: 'This part contains the following chapters:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 5*](B21103_05.xhtml#_idTextAnchor124), *Testing in React*'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B21103_05.xhtml#_idTextAnchor124), *React中的测试*'
- en: '[*Chapter 6*](B21103_06.xhtml#_idTextAnchor153), *Exploring Common Refactoring
    Techniques*'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B21103_06.xhtml#_idTextAnchor153), *探索常见的重构技术*'
- en: '[*Chapter 7*](B21103_07.xhtml#_idTextAnchor176), *Introducing Test-Driven Development
    with React*'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B21103_07.xhtml#_idTextAnchor176), *使用React介绍测试驱动开发*'
