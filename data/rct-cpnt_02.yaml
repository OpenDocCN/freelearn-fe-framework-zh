- en: Chapter 2. Working with Properties and State
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：使用属性和状态
- en: In the previous chapter, we set up our workflow. We worked out how to compile
    ReactJS and ES6 code through a build step, interpret it directly in our browser,
    and even run it using services such as JSBin. Now, we can begin creating components
    for our content management system.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们设置了我们的工作流程。我们解决了如何通过构建步骤编译ReactJS和ES6代码，直接在我们的浏览器中解释它，甚至使用JSBin等服务运行它的问题。现在，我们可以开始为我们的内容管理系统创建组件。
- en: In this chapter, we're going to start building our interface. We'll see interesting
    and effective ways to connect components. The important thing in this chapter
    is learning how to arrange components in complex hierarchies. We're going to nest
    several components and communicate between them and our data source, using a custom
    data backend.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始构建我们的界面。我们将看到连接组件的有趣和有效的方法。本章的重要之处在于学习如何安排复杂层次结构中的组件。我们将嵌套几个组件，并通过自定义数据后端与它们以及我们的数据源进行通信。
- en: Nesting components
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件嵌套
- en: Let's think about how we want to structure the components of our interface.
    Many content management systems feature lists of items—items that we store in
    and retrieve from a database. For example, let's imagine a system through which
    we can manage the pages of a website.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考一下我们想要如何构建我们界面的组件。许多内容管理系统都包含项目列表——这些项目是我们存储在数据库中并从中检索出来的。例如，让我们想象一个可以管理网站页面的系统。
- en: 'For such a system, we need an entry-point—something like `PageAdmin`, which
    connects our persistence layer to our interface:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样的系统，我们需要一个入口点——类似于`PageAdmin`的东西，它将我们的持久层连接到我们的界面：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can also represent the persistence layer in the form of a backend class:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将持久层表示为后端类：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Later, we'll look at ways of persisting this data. For now, it's OK to just
    use static data in this class.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将探讨持久化这些数据的方法。现在，在这个类中使用静态数据是可以的。
- en: 'We could connect `PageAdmin` to this class by proving an instance of `Backend`
    as a property:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过提供一个`Backend`实例作为属性来将`PageAdmin`连接到这个类：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we can start using the `Backend` data in our `PageAdmin` component:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在`PageAdmin`组件中使用`Backend`数据：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The truth is that we don't really need to define a default state, or store the
    page objects to the state. I've done so to demonstrate the idiomatic way of defining
    initial component state and overriding state when working with ES6-style components.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们并不真的需要定义一个默认状态，或者将页面对象存储到状态中。我这样做是为了演示使用ES6风格组件定义初始组件状态和覆盖状态时的惯用方法。
- en: 'There''s a lot going on here, so let''s break it down bit-by-bit:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多事情在进行中，所以让我们一点一点地分解它：
- en: We made a constructor. In the constructor, we defined the initial state of a
    component. We defined the state as an object with an empty `pages` array.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个构造函数。在构造函数中，我们定义了组件的初始状态。我们将状态定义为具有空`pages`数组的对象。
- en: React will call a few *magic* methods in the life cycle of a component. We used
    `componentWillMount` to get an array of pages, so we have something to render.
    We also passed this array of pages to the `setState` method. This exists to store
    state data and update the markup of a component at the same time. The `this.state.pages`
    method will now contain the array of pages from the backend.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React将在组件的生命周期中调用几个*魔法*方法。我们使用`componentWillMount`来获取页面数组，以便我们有东西可以渲染。我们还把这个页面数组传递给`setState`方法。这是为了存储状态数据和同时更新组件的标记。现在，`this.state.pages`方法将包含来自后端的页面数组。
- en: When we use curly braces inside markup, it acts like a dynamic value (just like
    with properties). We can use the `Array.prototype.map` method to return a new
    element for each page in the array of pages. This will return a new list of `li`
    components. React also expects components in a list to have a special `key` property,
    which it uses to identify them. React uses this to track which components it can
    remove, add, or change efficiently.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们在标记中使用花括号时，它就像一个动态值（就像属性一样）。我们可以使用`Array.prototype.map`方法为页面数组中的每个页面返回一个新的元素。这将返回一个新的`li`组件列表。React还期望列表中的组件具有特殊的`key`属性，它使用这个属性来识别它们。React使用这个属性来高效地跟踪它可以删除、添加或更改的组件。
- en: Note
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The code references `page.id`. The pages returned by the backend should have
    the `id`, `title`, and `body` properties for these examples to work.
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码引用`page.id`。后端返回的页面应该有`id`、`title`和`body`属性，以便这些示例可以工作。
- en: 'Let''s concentrate on how to show each page through the content management
    system. The `PageAdmin` renders each page as a list item, so let''s think about
    what we want to do inside each list item. I think it makes sense to have a non-interactive
    summary of each page. Think of a tabular view of all pages in a website:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们集中讨论如何通过内容管理系统展示每一页。`PageAdmin`会将每一页渲染为一个列表项，因此让我们思考在每个列表项内部我们想要做什么。我认为为每一页提供一个非交互式的摘要是有意义的。想象一下，一个网站中所有页面的表格视图：
- en: Home
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首页
- en: Products
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品
- en: Terms of service
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务条款
- en: Contact us
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联系我们
- en: 'So there''s one aspect to pages that is static: the view of the page title.
    Perhaps we can also include links to edit or delete each page.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，页面的一个方面是静态的：页面标题的视图。也许我们还可以包括编辑或删除每个页面的链接。
- en: We also want to be able to update each page. We're probably going to need some
    sort of form, with text inputs for each field we might want to update.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望能够更新每一页。我们可能需要某种形式的表单，为可能更新的每个字段提供文本输入。
- en: 'We can represent these two scenarios in a single component:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在单个组件中表示这两个场景：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we can switch between the different components, based on whether we''re
    editing or not. Of course, we also need to define these new components:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以根据是否在编辑之间切换不同的组件。当然，我们还需要定义这些新组件：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that we can define input elements in a way you might expect, if you've
    worked with HTML markup before. We'll revisit this component later, so don't worry
    about the details just yet.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果我们之前使用过HTML标记，我们可以以我们可能期望的方式定义输入元素。我们稍后会重新审视这个组件，所以现在不用担心细节。
- en: 'The preview mode, for this component, is a little similar:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个组件，预览模式有一点相似：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This raises an interesting question. How can we efficiently transfer properties
    from one component to another? ES6 provides a great tool for this in the form
    of a language feature called the *spread* operator. First, we need to provide
    pages to page components in `PageAdmin`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这引发了一个有趣的问题。我们如何高效地将属性从一个组件传输到另一个组件？ES6提供了一个名为*扩展运算符*的语言特性，这是一个很好的工具。首先，我们需要在`PageAdmin`中将页面提供给页面组件：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We''re replacing `a new page` with the `Page` component we created earlier.
    We use the spread operator to assign each object key as a component property.
    We can repeat this concept in `Page`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在用我们之前创建的`Page`组件替换`a new page`。我们使用扩展运算符将每个对象键分配为组件属性。我们可以在`Page`中重复这个概念：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `{...this.props}` expands the page object keys. The `page.id` becomes `this.props.id`
    inside the `PageEditor` and `PageView` components. This method is great for transferring
    many properties; we don't need to write out each one.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`{...this.props}`扩展了页面对象的键。在`PageEditor`和`PageView`组件内部，`page.id`变成了`this.props.id`。这个方法对于传输许多属性非常棒；我们不需要逐个写出每一个。'
- en: Shared component actions
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享组件操作
- en: 'So, how do we change from a `PageView` class to a `PageEditor` class? For that,
    we need to hook into browser events and fiddle with the state:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何从`PageView`类转换为`PageEditor`类？为此，我们需要挂钩到浏览器事件并调整状态：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We're providing a way for *child* components to call methods in *parent* components
    by passing down methods child components can use. When a `PageView` class wants
    to put the `Page` into edit mode, it can call `this.props.onEdit`. The `Page`
    will know how to handle that. We'll see this pattern often, so it's good to understand
    what it's doing here before moving on!
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一个方法，允许*子*组件通过传递方法来调用*父*组件中的方法。当一个`PageView`类想要将`Page`放入编辑模式时，它可以调用`this.props.onEdit`。`Page`将知道如何处理。我们将在后续内容中经常看到这个模式，所以在这里移动之前理解它在做什么是很好的！
- en: In the same way, we provide a way for a `PageEditor` class to cancel edit mode.
    In both these cases, we use `setState` to switch between editing and viewing states.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，我们为`PageEditor`类提供了一个取消编辑模式的方法。在这两种情况下，我们使用`setState`在编辑和查看状态之间切换。
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: We bind the handle methods, because otherwise `this` will mean something different
    when the methods are called. Binding like this is not efficient, so we'll revisit
    this later with an alternative!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们绑定处理方法，因为否则当方法被调用时`this`将意味着不同的东西。这种绑定方式不是很高效，所以稍后我们会用一种替代方案来重新审视这个问题！
- en: 'We can connect these handlers to click events in each component:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些处理程序连接到每个组件的点击事件：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We need to prevent default form submission before calling the `onCancel` passed
    down through props. The code is as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用通过props传递下来的`onCancel`之前，我们需要防止默认表单提交。代码如下：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You should now be able to run this in a browser and toggle between the edit
    and view aspects of each page. This is a good time to stop and take stock of what
    we''ve achieved:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够在浏览器中运行此代码，并在每个页面的编辑和查看方面之间切换。这是一个停下来总结我们所取得的成果的好时机：
- en: We created an entry-point component to page management called `PageAdmin`. This
    component handles fetching and persisting page data. It uses a `Backend` class
    to do these. It also renders `Page` components for each page that `Backend` returns.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `PageAdmin` 的页面管理的入口点组件。该组件处理获取和持久化页面数据。它使用 `Backend` 类来完成这些操作。它还渲染
    `Page` 组件，每个 `Backend` 返回一个页面。
- en: We created a `Page` component to encapsulate page data as well as edit and view
    aspects of each page. The `Page` component handles switching between these two
    child components, via callbacks.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个 `Page` 组件来封装页面数据以及每个页面的编辑和查看方面。`Page` 组件通过回调处理这两个子组件之间的切换。
- en: We created `PageEditor` as an interface for editing page data. It contains a
    couple of fields, which we'll shortly discuss.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个 `PageEditor` 组件作为编辑页面数据的接口。它包含一些字段，我们将在下面简要讨论。
- en: Finally, we created `PageView` as an interface for viewing page data and getting
    to the edit mode. We're about to make the **Delete** button work too.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建了一个 `PageView` 组件作为查看页面数据和进入编辑模式的接口。我们即将使 **删除** 按钮也能工作。
- en: 'If you''ve been following along, your interface may look something like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直在跟随，你的界面可能看起来像这样：
- en: '![Shared component actions](img/5268_02_01.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![共享组件操作](img/5268_02_01.jpg)'
- en: 'We have created new function references throughout this chapter. Every time
    we use `fn.bind(this)`, we create a new function. This is inefficient if we''re
    doing it inside render methods. We can get around this by creating a base component:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中创建了许多新的函数引用。每次我们使用 `fn.bind(this)`，我们都会创建一个新的函数。如果我们这样做是在渲染方法内部，这就不太高效。我们可以通过创建一个基础组件来解决这个问题：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If we extend this base component (instead of the usual `React.Component`), then
    we will have access to the `bind` method. It takes one or more function names,
    and replaces them with bound versions.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们扩展这个基础组件（而不是通常的 `React.Component`），那么我们将能够访问 `bind` 方法。它接受一个或多个函数名称，并将它们替换为绑定版本。
- en: 'Now, we need to add event handlers for updating and deleting pages. Let''s
    start with `PageView` and `PageEditor`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要添加更新和删除页面的事件处理器。让我们从 `PageView` 和 `PageEditor` 开始：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We added an `onClick` handler to the Delete button. This will trigger a bound
    version of `onDelete` in which we pass the correct:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在删除按钮上添加了一个 `onClick` 处理程序。这将触发一个绑定的 `onDelete` 版本，我们传递正确的：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we added `onUpdate` so that we can determine which input changed. It calls
    the props `onUpdate` method with the correct property name and value.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了 `onUpdate`，这样我们就可以确定哪个输入发生了变化。它调用带有正确属性名称和值的 `props `onUpdate` 方法。
- en: We also add the `name` and `value` attributes for the inputs, setting the values
    to the corresponding properties. These updates are triggered when the inputs change,
    calling the `onUpdate` method. This means property updates will reflect in the
    fields.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了 `name` 和 `value` 属性给输入，将值设置为相应的属性。这些更新会在输入改变时触发，调用 `onUpdate` 方法。这意味着属性更新将反映在字段中。
- en: 'Where do these new handler properties come from? We need to add them to `PageAdmin`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这些新的处理程序属性从何而来？我们需要将它们添加到 `PageAdmin` 中：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Finally, we create a couple of methods to handle updates and deletes. These
    are bound, as we've been doing to methods in the other classes. They also use
    the rest/spread operators as a bit of a shortcut!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建了一些处理更新和删除的方法。这些方法与我们之前在其他类中做的方法一样被绑定。它们还使用剩余/展开操作符作为一点快捷方式！
- en: 'We can fake the backend data and operations with an array of pages and a few
    array modifier methods:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一组页面和一些数组修改方法来伪造后端数据和操作：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Tip
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: This is by no means an efficient implementation. Please do not use this code
    in production. It's just an example interface against which we can test our code!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝对不是一个高效的实现。请勿在生产环境中使用此代码。它只是一个示例接口，我们可以用它来测试我们的代码！
- en: The `all` method returns a filtered and mapped array of initial pages. The `()
    => {}` syntax is a shortcut for `(function(){}).bind(this)`. The brackets are
    even optional, if there is exactly one property for the function. The filter checks
    that each page `id` is not in the `deleted` array. We're not actually deleting
    pages in this pretend backend. We're simply excluding ones we know we don't want
    to see.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`all` 方法返回一个过滤并映射的初始页面数组。`() => {}` 语法是 `(function(){}).bind(this)` 的快捷方式。如果函数只有一个属性，括号是可选的。过滤器检查每个页面的
    `id` 是否不在 `deleted` 数组中。在这个模拟的后端中，我们实际上并没有删除页面。我们只是排除了我们不想看到的页面。'
- en: We don't update the pages directly, but we apply updates to the array before
    `all` returns it. This isn't efficient, but it does allow us to see out interface
    in action.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是直接更新页面，而是在 `all` 返回数组之前应用更新。这并不高效，但它确实允许我们看到我们的界面在行动。
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can learn more about these array tricks at [https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array).
    It's a great place to learn about JavaScript language features.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array)
    上了解更多关于这些数组技巧的信息。这是一个学习 JavaScript 语言特性的好地方。
- en: Component life cycle methods
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件生命周期方法
- en: There are a couple of tricks I want to show you before we wrap up. The first
    is a *life cycle method* we can use to tell when a component's properties will
    change. We can use this to change the appearance of a component, or refresh the
    internal state.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束之前，我想展示几个技巧。第一个是我们可以用来自定义组件属性变化时机的一个 *生命周期方法*。我们可以使用这个方法来改变组件的外观，或者刷新内部状态。
- en: 'We can add this method to `PageEditor`, for example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以将此方法添加到 `PageEditor` 中：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can now tell when the page changes, even though the changes are immediately
    propagated.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以知道页面何时发生变化，即使变化是立即传播的。
- en: 'Another magic method we can use will help cut down on the comparisons React
    needs to perform. It''s called `shouldComponentUpdate` and we can add it to `PageView`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个我们可以使用的神奇方法将有助于减少 React 需要执行的比较。它被称为 `shouldComponentUpdate`，我们可以将其添加到 `PageView`：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `shouldComponentUpdate` method gives us a way to tell React not to look
    for changes in this component. At this scale, we're not likely to see huge performance
    improvements. But when we add this method to more complex layouts, it will drastically
    reduce the amount of work required to work out how the document should change.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`shouldComponentUpdate` 方法为我们提供了一种告诉 React 不要在此组件中查找变化的方式。在这个规模上，我们不太可能看到巨大的性能提升。但是当我们将此方法添加到更复杂的布局中时，它将极大地减少确定文档应该如何更改所需的工作量。'
- en: We'll be using these tricks later, as we build more complex content management
    features.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在构建更复杂的内容管理功能时使用这些技巧。
- en: Summary
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned even more about ES6 classes and how they complement
    React components in structure and functionality. We also looked at some interesting
    uses of state and properties.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了更多关于 ES6 类以及它们如何在结构和功能上补充 React 组件的知识。我们还探讨了状态和属性的一些有趣用法。
- en: Above all, we saw how it's both possible and beneficial to avoid the internal
    component state. Properties are a powerful tool for component design. We know
    how to react to changing properties and how to reduce the work React needs to
    do to render our interfaces.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 总而言之，我们看到了避免内部组件状态的可能性和好处。属性是组件设计的一个强大工具。我们知道如何对变化的属性做出反应，以及如何减少 React 渲染我们界面所需的工作量。
- en: In the next chapter, we are going to discuss how to persist this data (to different
    kinds of local storage). We will see how to connect to these data stores through
    events.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何持久化这些数据（到不同类型的本地存储）。我们将看到如何通过事件连接到这些数据存储。
