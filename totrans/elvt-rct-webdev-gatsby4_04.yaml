- en: '*Chapter 3*: Sourcing and Querying Data (from Anywhere!)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*：获取和查询数据（来自任何地方！）'
- en: In this chapter, you will learn about Gatsby's data layer. You will start by
    understanding what we mean by data in the context of Gatsby before learning the
    basics of **GraphQL**. Once you have this understanding, you will learn how to
    source and query data from local files. We will then look at sourcing data from
    a couple of Headless CMSes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解Gatsby的数据层。你将从理解Gatsby上下文中的数据含义开始，然后学习**GraphQL**的基础知识。一旦你有了这个理解，你将学习如何从本地文件中获取和查询数据。然后我们将探讨从几个无头CMS中获取数据。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Data in Gatsby
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gatsby中的数据
- en: Introducing GraphQL
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 GraphQL
- en: Sourcing and querying data from local files
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从本地文件获取和查询数据
- en: Sourcing and querying data from a Headless CMS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从无头CMS获取和查询数据
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To complete this chapter, you will need to have completed [*Chapter 2*](B15983_02_ePub_RK.xhtml#_idTextAnchor036),
    *Styling Choices and Creating Reusable Layouts*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章，你需要完成 [*第2章*](B15983_02_ePub_RK.xhtml#_idTextAnchor036)，*样式选择和创建可重用布局*。
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter03](https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter03).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在[https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter03](https://github.com/PacktPublishing/Elevating-React-Web-Development-with-Gatsby-4/tree/main/Chapter03)找到。
- en: Data in Gatsby
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gatsby中的数据
- en: Before diving in, I think it's important to establish what we mean by **data**
    in the context of this book. When referring to data, we are referring to any medium
    of static content that is not React code. Up until now, we have been adding text
    within our React components directly. As a developer, this can be a perfectly
    acceptable way to build a small site but as things scale up, having content mixed
    into your markup can make it much harder to develop. It also makes it impossible
    for colleagues without React experience to update or add new content to the site.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入之前，我认为明确我们在这本书中提到的“数据”的含义很重要。当我们提到数据时，我们指的是任何静态内容的媒介，而不是React代码。到目前为止，我们一直在React组件中直接添加文本。对于开发者来说，这可能是一种完全可接受的方式来构建小型网站，但随着规模的扩大，将内容混合到标记中会使开发变得更加困难。这也使得没有React经验的同事无法更新或添加网站的新内容。
- en: 'It is a much more common practice to store data that''s separate from our pages
    and components, pulling it in as required. There are two ways in which we can
    store this data:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据存储在页面和组件之外，并在需要时将其拉入，这是一种更常见的做法。我们可以以两种方式存储此类数据：
- en: '**Locally**: Files stored alongside our source code in the respective repository,
    such as JSON, CSV, Markdown, or MDX files.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地**：存储在与我们的源代码相同的仓库中的文件，例如JSON、CSV、Markdown或MDX文件。'
- en: '**Remotely**: Files stored in another location that we ingest as part of our
    build processes, such as content from a Headless CMS, database, or API.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**远程**：存储在另一个位置的文件，我们将其作为构建过程的一部分摄取，例如来自无头CMS、数据库或API的内容。'
- en: Important Note
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: You may have noticed the absence of images being referenced when talking about
    data and might be wondering how to work with them. Due to their complexity, images
    have a dedicated chapter in this book – [*Chapter 5*](B15983_05_ePub_RK.xhtml#_idTextAnchor080),
    *Working with Images*.
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在谈论数据时没有引用图像，可能会想知道如何处理它们。由于它们的复杂性，本书中专门有一章介绍图像 – [*第5章*](B15983_05_ePub_RK.xhtml#_idTextAnchor080)，*处理图像*。
- en: Now that we understand what we mean by data in Gatsby, let's learn how we can
    query it within our application so that we can use it on our site pages.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Gatsby中的数据含义，让我们学习如何在我们的应用程序中查询它，以便我们可以在网站页面上使用它。
- en: Introducing GraphQL
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 GraphQL
- en: '**GraphQL** is a specification for querying data – general guidelines on how
    to query data efficiently. This specification was developed by engineers at Facebook
    in 2012 while working on their mobile application''s **REST** services. They wanted
    to use their existing REST service on their mobile platforms, but it was going
    to require heavy modification and specific logic for mobile platforms in various
    areas of their APIs. The engineers also noticed that there were lots of data points
    in the responses to their API requests that they were not using. This meant that
    people with low network bandwidth were loading data they weren''t even using.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**GraphQL** 是一个查询数据的规范——关于如何高效查询数据的通用指南。这个规范是在2012年由Facebook的工程师在开发他们的移动应用程序的**REST**服务时开发的。他们希望在他们的移动平台上使用现有的REST服务，但这将需要在他们的API的各个区域进行大量的修改和特定的逻辑。工程师们还注意到，他们的API请求的响应中有许多数据点他们并没有使用。这意味着那些网络带宽较低的人正在加载他们甚至没有使用的数据。'
- en: So, the team at Facebook started to work on GraphQL to solve these problems
    and rethink the way they could fetch data for devices. GraphQL shifted the focus
    from the backend engineers specifying what data is returned by what request, to
    the frontend developers specifying what they need.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Facebook的团队开始着手开发GraphQL来解决这些问题，并重新思考他们为设备获取数据的方式。GraphQL将重点从后端工程师指定由什么请求返回什么数据，转移到了前端开发者指定他们需要什么。
- en: GraphQL for Gatsby
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Gatsby的GraphQL
- en: Gatsby always uses GraphQL whenever you want to get data from within it. This
    is a great feature as we have an efficient way of getting data, regardless of
    its type. Gatsby can call GraphQL APIs directly if you already have a GraphQL
    server set up. However, a lot of the data we need to use on the web is not already
    in GraphQL format.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要从Gatsby内部获取数据时，Gatsby总是使用GraphQL。这是一个很棒的功能，因为我们有一个高效的方式来获取数据，无论它的类型如何。如果你已经设置了一个GraphQL服务器，Gatsby可以直接调用GraphQL
    API。然而，我们在网上需要使用的大量数据并不是已经以GraphQL格式存在的。
- en: Luckily, Gatsby's plugin architecture allows you to get non-GraphQL data into
    Gatsby, then use GraphQL to query it once you have it there. Regardless of whether
    your data is local or remote, or what format it is in, you can use one of Gatsby's
    plugins to pull the data. Then, you can use the GraphQL specification to query
    for that data on our pages.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Gatsby的插件架构允许你将非GraphQL数据引入Gatsby，然后在你拥有这些数据后使用GraphQL来查询它。无论你的数据是本地还是远程，或者它是什么格式，你都可以使用Gatsby的一个插件来拉取数据。然后，你可以使用GraphQL规范在我们的页面上查询这些数据。
- en: This is a great architecture that works with all of our content, no matter where
    it comes from. When it gets into Gatsby, we always query and retrieve that data
    in the same way.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常适合我们所有内容的优秀架构，无论它来自哪里。当它进入Gatsby时，我们总是以相同的方式查询和检索数据。
- en: 'Let''s look at a high-level example of what a GraphQL query contains:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个GraphQL查询包含的高级示例：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, you can see that we used the word `query`, followed by the name of the
    query, which, in our case, is `SampleQuery`. Then, inside of the curly braces,
    we specify what kind of content we want to get – where you see `content` here,
    this would change to be the source of content you want. `edges` refers to a collection
    of connected items within that content source that have a relationship returned
    as an array. Then, when we go a level deeper, we have `node`, which refers to
    an individual item. Here, you can see that we are querying a single property.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们使用了“query”这个词，后面跟着查询的名称，在我们的例子中是“SampleQuery”。然后，在大括号内，我们指定了我们想要获取的内容类型——在这里你看到“content”，这会改变成你想要的内容来源。`edges`指的是内容源中具有作为数组返回的关系的连接项集合。然后，当我们深入一层，我们有`node`，它指的是单个项。在这里，你可以看到我们正在查询一个单个属性。
- en: One of the great things about GraphQL is that you can be very specific about
    the data you need and only get that specific content. As shown in the previous
    example, we are only querying a single property of the node, but what if it contained
    a hundred properties instead? By pulling out only exactly what we need, we can
    create a very specific query that only gets us what we need.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL的其中一个优点是你可以非常具体地说明你需要的数据，并且只获取那些具体的内容。正如前一个示例所示，我们只查询了节点的单个属性，但如果它包含了一百个属性呢？通过只提取我们需要的，我们可以创建一个非常具体的查询，只获取我们需要的。
- en: 'Now, let''s look at a Gatsby-specific GraphQL query:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个针对Gatsby的特定GraphQL查询：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we can see that we are naming the query `MySitePages`. The content we
    are retrieving is from the `allSitePage` source, which is a default collection
    that contains all the pages that have been created within a Gatsby project. `edges`
    refers to all the pages, whereas `node` refers to a specific page we want. Inside
    each page, we are querying for the `path` parameter of that page.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们正在将查询命名为 `MySitePages`。我们正在检索的内容来自 `allSitePage` 源，这是一个默认集合，包含在
    Gatsby 项目中创建的所有页面。`edges` 指的是所有页面，而 `node` 指的是我们想要的特定页面。在每一页中，我们正在查询该页面的 `path`
    参数。
- en: 'When running this query in Gatsby, it is going to return JSON. If you run the
    preceding query within our site and log the result, you would see the following
    object:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 Gatsby 中运行此查询时，它将返回 JSON。如果您在我们的网站上运行前面的查询并记录结果，您将看到以下对象：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, what we get back is an object with a data property. Within that,
    you can see our named query and its edges. The edges contain each node and its
    corresponding path property. Within the result, we can see every page that exists
    on the site – we have our `404` page, the `about` page, and the `home` page.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们得到的是一个具有数据属性的对象。在其中，您可以看到我们的命名查询及其边缘。边缘包含每个节点及其相应的路径属性。在结果中，我们可以看到网站上存在的每个页面
    – 我们有 `404` 页面、`about` 页面和 `home` 页面。
- en: Now, let's learn about filtering and sorting data within GraphQL.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解如何在 GraphQL 中过滤和排序数据。
- en: Filtering in GraphQL
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GraphQL 中的过滤
- en: 'Sometimes, all the nodes of the returned data are not useful. We may occasionally
    want to filter out nodes based on a particular field. Let''s take a look at an
    example where we are filtering out nodes from our `allSitePage` source:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，返回的数据中的所有节点都不太有用。我们可能偶尔想根据特定字段过滤掉节点。让我们看看一个例子，其中我们正在从 `allSitePage` 源中过滤节点：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here is an example in which we get a single page where the path does not equal
    (`ne` for short) `/404/`. Filtering is something we will look at in more detail
    as we start to develop more complex queries for our pages. Right now, it's important
    just to recognize that it is possible.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们得到一个路径不等于 (`ne` 为简称) `/404/` 的单个页面。随着我们开始为页面开发更复杂的查询，我们将更详细地研究过滤。现在，重要的是要认识到这是可能的。
- en: 'In Gatsby, it is possible to obtain a single node on its own, but it is more
    common to query a collection. For example, if we wanted to retrieve a single `SitePage`
    node, we could use the following query:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Gatsby 中，可以单独获取一个节点，但更常见的是查询一个集合。例如，如果我们想检索一个单独的 `SitePage` 节点，我们可以使用以下查询：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This query will receive the first node that matches the request and return it
    as an object instead of a larger array.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询将接收与请求匹配的第一个节点，并将其作为对象返回，而不是更大的数组。
- en: Now that we understand how GraphQL queries are constructed, let's take a look
    at how we can use GraphiQL to explore our data.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何构建 GraphQL 查询，让我们看看我们如何使用 GraphiQL 来探索我们的数据。
- en: Using GraphiQL
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 GraphiQL
- en: When it comes to learning GraphQL, it's fortunate that Gatsby ships with a tool
    called GraphiQL ([https://github.com/graphql/graphiql](https://github.com/graphql/graphiql)).
    This is a web interface that hooks up to all of the GraphQL options in Gatsby
    and gives us a nice interface for testing and playing around with queries before
    we embed them into our code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到学习 GraphQL 时，幸运的是 Gatsby 随附了一个名为 GraphiQL 的工具 ([https://github.com/graphql/graphiql](https://github.com/graphql/graphiql))。这是一个连接到
    Gatsby 中所有 GraphQL 选项的 Web 接口，为我们提供了一个测试和在我们将查询嵌入到代码之前进行查询的好界面。
- en: 'As we know, when developing our site, Gatsby opens up `http://localhost:8000`
    to preview our site while we are building it. If you navigate to `http://localhost:8000/___graphql`,
    you will pull up a GraphiQL interface that is connected to your development Gatsby
    site. When you open this page, you should be presented with something that looks
    like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，在开发我们的网站时，Gatsby 会打开 `http://localhost:8000` 来预览我们在构建网站时的网站。如果您导航到 `http://localhost:8000/___graphql`，您将打开一个连接到您的开发
    Gatsby 网站的 GraphiQL 接口。当您打开这个页面时，您应该会看到一个类似下面的界面：
- en: '![Figure 3.1 – GraphiQL user interface'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.1 – GraphiQL 用户界面]'
- en: '](img/B15983_03_01.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B15983_03_01.jpg]'
- en: Figure 3.1 – GraphiQL user interface
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – GraphiQL 用户界面
- en: On the far left, you will see **Explorer**, which shows all the possible pieces
    of content we could get using GraphQL inside of Gatsby. You can check the properties
    within the **Explorer** area to have GraphiQL automatically build the query for
    you. In the central left column, we can see the query that we need to use to retrieve
    the data we want. When you hit the **Play** button above the query, you will see
    the result of that query on the central right column, with a JSON object containing
    the data property and our query's result inside it. On the far right, you will
    see the **Documentation Explorer** area, which you can use as an alternative way
    to explore your data and identify the different types of data you have available.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在最左侧，你会看到**探索器**，它显示了在 Gatsby 中使用 GraphQL 可以获取的所有可能的内容片段。你可以在**探索器**区域内检查属性，让
    GraphiQL 自动为你构建查询。在中央左侧列中，我们可以看到我们需要使用的查询来检索我们想要的数据。当你点击查询上方的**播放**按钮时，你将在中央右侧列中看到该查询的结果，其中包含一个包含数据属性和我们的查询结果的
    JSON 对象。在最右侧，你会看到**文档探索器**区域，你可以使用它作为探索你的数据并识别你拥有的不同类型数据的替代方式。
- en: Now, let's learn where we can use queries to retrieve data within our application.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习我们可以在应用程序内使用查询来检索数据的位置。
- en: Using constructed GraphQL queries
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用构建的 GraphQL 查询
- en: 'There are three main places where you can use a GraphQL query in your Gatsby
    projects:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 Gatsby 项目中，你可以使用 GraphQL 查询的三个主要位置：
- en: '`Gatsby-node.js`: This file is one of the places we can create pages programmatically
    based on dynamic data. If we had a list of blog posts in Markdown and we wanted
    to create a page for each one, we would use a query here to retrieve the data
    from the posts that we need to dynamically create the pages for.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Gatsby-node.js`：这个文件是我们可以基于动态数据程序化创建页面的地方之一。如果我们有一份 Markdown 格式的博客文章列表，并且想要为每篇文章创建一个页面，我们就会在这里使用查询来检索我们需要动态创建页面的文章数据。'
- en: '**Within pages**: We can append queries to single instance pages to make data
    available within that page. This is how we will be testing the data we source
    within this chapter. We can also query inside **page templates**, something we
    haven''t discussed yet, but it is a key concept we will look at in detail in [*Chapter
    4*](B15983_04_ePub_RK.xhtml#_idTextAnchor072), *Creating Reusable Templates*.
    A page template could take a slug based on the URL and then run a query based
    on that URL to work out what page to display. In both single-instance pages and
    templates, the query is run at build time, so the pages that are created are still
    static.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在页面内**：我们可以向单个实例页面添加查询，以便在该页面内提供数据。这就是我们将测试本章中获取的数据的方式。我们还可以在**页面模板**内进行查询，这是我们尚未讨论的内容，但它是我们将在[*第
    4 章*](B15983_04_ePub_RK.xhtml#_idTextAnchor072)“创建可重用模板”中详细探讨的关键概念。页面模板可以基于 URL
    中的 slug 运行查询，然后根据该 URL 确定要显示的页面。在单个实例页面和模板中，查询是在构建时运行的，因此创建的页面仍然是静态的。'
- en: '**Within any other component**: We can also retrieve GraphQL data within any
    React component we have created. There is a different method to retrieving data
    outside of page templates because outside of a page template, you cannot get dynamic
    content using variables. As such, queries run this way are static. We will see
    examples of static queries in [*Chapter 5*](B15983_05_ePub_RK.xhtml#_idTextAnchor080),
    *Working with Images*.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在任何其他组件内**：我们还可以在我们的任何 React 组件内检索 GraphQL 数据。在页面模板之外检索数据的方法不同，因为在外部页面模板之外，你不能使用变量获取动态内容。因此，这种方式的查询是静态的。我们将在[*第
    5 章*](B15983_05_ePub_RK.xhtml#_idTextAnchor080)“与图像一起工作”中看到静态查询的示例。'
- en: Now that you understand the basics of GraphQL in Gatsby, let's start ingesting
    different kinds of data into our GraphQL layer.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 Gatsby 中 GraphQL 的基础知识，让我们开始将不同类型的数据导入到我们的 GraphQL 层中。
- en: Sourcing data from local files
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从本地文件中获取数据
- en: In this section, we will learn how to source and query data from local files.
    As we mentioned previously, when we say local files, we are referring to files
    located alongside the code in our repository.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何从本地文件中获取和查询数据。正如我们之前提到的，当我们说本地文件时，我们指的是位于我们仓库代码旁边的文件。
- en: Site metadata
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网站元数据
- en: A great place to store small reusable pieces of data is within the `gatsby-config.js`
    file. Gatsby exposes the `siteMetadata` property to the data layer so that you
    can retrieve it throughout your application. In the context of our website, I
    would suggest storing your website address, your name, your role, and a short
    bio here. If this is implemented consistently, whenever any of these pieces of
    information change, you can change the field once in `siteMetadata` and see the
    change reflected across your whole site.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `gatsby-config.js` 文件中存储小块可重用数据是一个很好的地方。Gatsby 将 `siteMetadata` 属性暴露给数据层，这样你就可以在整个应用程序中检索它。在我们的网站上下文中，我建议在这里存储你的网站地址、你的名字、你的角色和简短的传记。如果实施得一致，当任何这些信息发生变化时，你只需在
    `siteMetadata` 中更改一次字段，就可以在整个网站上看到更改。
- en: Tip
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: '`gatsby-config.js` is a file that you will often find growing quite large as
    you expand your Gatsby projects. To try and keep things ordered, try and reserve
    your `siteMetadata` for a handful of small strings. If you are considering adding
    a large block of text here, it might be better to add it as a Markdown file.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`gatsby-config.js` 是一个文件，随着你扩展 Gatsby 项目，你经常会发现它变得相当大。为了尽量保持有序，尽量为你的 `siteMetadata`
    保留少量小字符串。如果你考虑在这里添加大块文本，可能更好的做法是将它作为一个 Markdown 文件添加。'
- en: 'Let''s create some site metadata and ingest it on our home page:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在主页上创建一些网站元数据并将其导入：
- en: 'First, update `gatsby-config.js` with the following code:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用以下代码更新 `gatsby-config.js`：
- en: '[PRE5]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Use the GraphiQL interface to construct the GraphQL query to retrieve the data.
    This should look like this:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 GraphiQL 界面构建 GraphQL 查询以检索数据。它应该看起来像这样：
- en: '[PRE6]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Your site metadata is available within the `site` source. In the preceding query,
    we are only retrieving `name` and `role`.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你的网站元数据在 `site` 源中可用。在前面的查询中，我们只检索了 `name` 和 `role`。
- en: 'Embed your constructed query on your index page:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的主页上嵌入构建的查询：
- en: '[PRE7]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, let's learn about how we can ingest data from sources that are not included
    with Gatsby out of the box – starting with Markdown.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解如何从 Gatsby 默认不包含的数据源中获取数据——从 Markdown 开始。
- en: Markdown
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Markdown
- en: The Markdown syntax is a popular way to write content on a Gatsby site. If you
    have used GitHub or Bitbucket before, chances are you've already encountered this
    format as they both make use of it in `README` files. Markdown is a great format
    for longer pieces of writing within your site – documentation, blog posts, or
    even a long bio.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Markdown 语法是在 Gatsby 网站上编写内容的一种流行方式。如果你之前使用过 GitHub 或 Bitbucket，那么你很可能已经遇到过这种格式，因为它们都在
    `README` 文件中使用它。Markdown 是在你的网站上编写较长的写作内容的一个很好的格式——文档、博客文章，甚至是一个长的传记。
- en: To start using Markdown in Gatsby, you only need to create text files – no additional
    infrastructure is required to implement it. Gatsby also provides **core-plugin**
    (a plugin owned and maintained by the Gatsby team) to process Markdown into content
    that can be used by our components. Using core-plugin, no code is required to
    implement Markdown and get set up.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始在 Gatsby 中使用 Markdown，你只需要创建文本文件——不需要额外的基础设施来实现它。Gatsby 还提供了一个 **核心插件**（由
    Gatsby 团队拥有和维护），用于将 Markdown 转换为可以由我们的组件使用的内联内容。使用核心插件，不需要编写代码即可实现 Markdown 并进行设置。
- en: 'Let''s create a short biography in Markdown and add it to our about page:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Markdown 中创建一个简短的传记并将其添加到我们的关于页面：
- en: Create a folder to store our Markdown called `MD` at the root of your project.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的项目根目录下创建一个名为 `MD` 的文件夹来存储我们的 Markdown。
- en: It's good practice to keep this folder outside of your `src` directory as it
    does not contain any source code but instead is text content. This makes it much
    easier for a developer without React experience to modify site content.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将这个文件夹放在你的 `src` 目录之外是一个好习惯，因为它不包含任何源代码，而是文本内容。这使得没有 React 经验的开发者修改网站内容变得更加容易。
- en: Create a folder inside `/MD` to store your bio called `bio`. As we add more
    Markdown files that serve up different types of content, it's helpful to keep
    them separated.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `/MD` 目录下创建一个名为 `bio` 的文件夹来存储你的传记。随着我们添加更多提供不同类型内容的 Markdown 文件，将它们分开存储是有帮助的。
- en: 'Create a `bio.md` file inside our newly created `bio` folder and add the following
    code:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们新创建的 `bio` 文件夹内创建一个 `bio.md` 文件，并添加以下代码：
- en: '[PRE8]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is the first part of the file and contains `type`. This `type` will help
    us query for this exact file in our GraphQL query.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是文件的第一部分，包含 `type`。这个 `type` 将帮助我们通过 GraphQL 查询查询到这个特定的文件。
- en: 'Create the body of your biography using Markdown syntax:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Markdown 语法创建你的传记正文：
- en: '[PRE9]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can use any valid Markdown syntax here; I have kept this example brief by
    just including one heading and a paragraph, but feel free to add as much as you
    like.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以使用任何有效的 Markdown 语法在这里；我通过只包括一个标题和一段段落来使这个例子简短，但请随意添加你想要的任何内容。
- en: 'Install `gatsby-source-filesystem`:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 `gatsby-source-filesystem`：
- en: '[PRE10]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As its name might suggest, this plugin allows Gatsby to read local files.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如其名所示，这个插件允许 Gatsby 读取本地文件。
- en: 'Install `gatsby-transformer-remark`:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 `gatsby-transformer-remark`：
- en: '[PRE11]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can use this plugin to recognize Markdown files and read their content. This
    plugin will read in the syntax and convert it into HTML that we can then embed
    in our components.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以使用这个插件来识别 Markdown 文件并读取它们的内容。这个插件将读取语法并将其转换为我们可以嵌入到组件中的 HTML。
- en: 'Next, let''s configure our new dependencies in `gatsby-config.js`:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们在 `gatsby-config.js` 中配置我们的新依赖项：
- en: '[PRE12]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Start your development server and navigate to your GraphiQL interface. Construct
    and run the query to retrieve just the `bio` information:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的开发服务器并导航到你的 GraphiQL 接口。构建并运行查询以检索 `bio` 信息：
- en: '[PRE13]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here, we have constructed a query where we are retrieving the HTML from `markdownRemark`.
    We are filtering the Markdown where the frontmatter type is equal to `bio` and
    since there is only one such file, we will always retrieve the correct file. By
    running this query in the GraphiQL interface, you should see something that looks
    like this:'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们构建了一个查询，其中我们从 `markdownRemark` 中检索 HTML。我们过滤 Markdown，其中 frontmatter 类型等于
    `bio`，由于只有一个这样的文件，我们将始终检索正确的文件。通过在 GraphiQL 接口中运行此查询，你应该会看到类似以下的内容：
- en: '[PRE14]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, you can see that the Markdown we wrote in the file has been transformed
    into HTML that we can now use within our pages.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们编写的 Markdown 已经被转换成了 HTML，我们现在可以在我们的页面中使用它。
- en: 'Embed this query in your `about` page:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `about` 页面中嵌入这个查询：
- en: '[PRE15]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Markdown can be a great option if you want to write long-form articles, but
    what if you want to make your articles more interactive? Maybe you want a poll
    in the middle of your post or a prompt for users to sign up to your email between
    two paragraphs? There are plenty of scenarios like these that simply cannot be
    achieved elegantly in Markdown. For functionalities such as these, MDX is the
    answer.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要写长篇的文章，Markdown 可以是一个很好的选择，但如果你想要让你的文章更加互动呢？也许你想要在文章中间加入一个投票或者在一个段落之间让用户注册你的电子邮件？有许多这样的场景在
    Markdown 中无法优雅地实现。对于这些功能，MDX 就是答案。
- en: MDX
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MDX
- en: MDX is a format that allows you to enhance your Markdown with JSX. You can import
    components into your Markdown and embed them in your content.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: MDX 是一种格式，它允许你使用 JSX 来增强你的 Markdown。你可以在 Markdown 中导入组件并将它们嵌入到你的内容中。
- en: 'Let''s make an enhanced biography on our about page using MDX that contains
    your employment history:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在关于页面中使用 MDX 创建一个包含你的工作历史的增强型个人简介：
- en: Create a folder to store our Markdown called `MDX` at the root of your project.
    As with Markdown (and for the same reasons), it's good practice to keep this folder
    outside of `src`, even though it can contain React components.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的项目根目录下创建一个名为 `MDX` 的文件夹来存储我们的 Markdown（就像 Markdown 一样，出于相同的原因），良好的做法是将这个文件夹放在
    `src` 之外，即使它可以包含 React 组件。
- en: Create a folder inside `/MDX` to store your bio called `bio` (as we did with
    our Markdown).
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `/MDX` 目录下创建一个名为 `bio` 的文件夹来存储你的个人资料（就像我们处理 Markdown 一样）。
- en: Create a folder called `components` within your `/MDX` folder to store React
    components specifically for use within our MDX files.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `/MDX` 文件夹中创建一个名为 `components` 的文件夹来存储专门用于我们的 MDX 文件中的 React 组件。
- en: 'Create an `EmploymentHistory` component in the `components` folder that we
    can embed in our `mdx` file:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `components` 文件夹中创建一个 `EmploymentHistory` 组件，以便我们可以在我们的 MDX 文件中嵌入：
- en: '[PRE16]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: I am using employment history as an example here, but this can be any valid
    React component. In this example, we have defined a small array of employment
    experiences containing objects, each with a company and role. In `EmploymentHistory`,
    we map over those roles and lay them out in a grid. We then export the component
    as normal.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我在这里以工作历史为例，但这也可以是任何有效的 React 组件。在这个例子中，我们定义了一个包含对象的就业经验小数组，每个对象都有一个公司和角色。在
    `EmploymentHistory` 中，我们遍历这些角色并将它们布局成网格。然后我们像平常一样导出这个组件。
- en: 'Create `bio.mdx` in `/MDX/bio`:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `/MDX/bio` 目录下创建 `bio.mdx` 文件：
- en: '[PRE17]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Install the necessary `mdx` dependencies:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装必要的 `mdx` 依赖项：
- en: '[PRE18]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Configure `gatsby-config.js` so that it includes the `gatsby-plugin-mdx` plugin:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置 `gatsby-config.js` 以包含 `gatsby-plugin-mdx` 插件：
- en: '[PRE19]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Start your development server and navigate to your GraphiQL interface. Construct
    and run the query to retrieve our updated MDX bio:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的开发服务器并导航到你的GraphiQL界面。构建并运行查询以检索更新的MDX bio：
- en: '[PRE20]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we have constructed a query where we are retrieving the `mdx` body from
    the `mdx` source, where the frontmatter type is equal to `bio`.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们构建了一个查询，其中我们从`mdx`源检索`mdx`主体的内容，其中前缀类型等于`bio`。
- en: 'Embed the query in your about page:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的关于页面中嵌入查询：
- en: '[PRE21]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now that we understand how to ingest local data, let's look at sourcing data
    from a remote source – a **Content Management System (CMS)**!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何摄取本地数据，让我们来看看从远程来源获取数据——一个**内容管理系统（CMS）**！
- en: Sourcing data from a Headless CMS
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Headless CMS获取数据
- en: A Headless CMS is a CMS that purely focuses on the content itself and does not
    care about how it's presented. Traditional CMSes store content in a database and
    then use a series of HTML templates to control how content gets presented to viewers.
    In Headless CMSes, however, instead of returning HTML, we return structured data
    via an API.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Headless CMS是一种只关注内容本身而不关心其呈现方式的CMS。传统的CMS将内容存储在数据库中，然后使用一系列HTML模板来控制内容如何呈现给观众。然而，在Headless
    CMS中，我们不是返回HTML，而是通过API返回结构化数据。
- en: Content creators can still add and edit data via a user interface, but the frontend
    is stored completely separately. This is perfect for when your content creators
    are not developers, or when you're out and about and want to write a post on your
    phone without having to spin up your laptop.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 内容创作者仍然可以通过用户界面添加和编辑数据，但前端完全独立存储。这对于你的内容创作者不是开发者，或者当你在外出时想在手机上写一篇帖子而不需要启动笔记本电脑时非常完美。
- en: With Gatsby's vast plugin ecosystem, your site can support many different Headless
    CMSes with very little effort. You could write a book on how to implement every
    one of them into your project, so, instead, let's focus on two – GraphCMS and
    Prismic.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Gatsby拥有庞大的插件生态系统，你的网站可以轻松支持许多不同的Headless CMS。你可以写一本书来介绍如何将它们中的每一个都集成到你的项目中，所以，让我们专注于两个——GraphCMS和Prismic。
- en: Important Note
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: '*Only implement one of the Headless CMS choices outlined in this chapter*.
    Not only would having two different sources for the same type of data be confusing,
    but it would also lead to longer site build times as data will need to be retrieved
    from two sources instead of one.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*仅在此章节中概述的Headless CMS选择中实现一个*。拥有两个相同类型数据的来源不仅会令人困惑，而且还会导致网站构建时间更长，因为需要从两个来源而不是一个来源检索数据。'
- en: GraphCMS
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GraphCMS
- en: 'GraphCMS is a fully-hosted SaaS platform that''s used by over 30,000 teams
    of all sizes across the world. Their queries are cached across 190 edge CDN nodes
    globally, meaning that wherever you''re located, pulling data from GraphCMS into
    your Gatsby projects should be blazingly fast. Let''s introduce ourselves to using
    GraphCMS by creating a list of hobbies within the tool that we can then ingest
    within our application:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: GraphCMS是一个全托管SaaS平台，被全球超过30,000个不同规模的团队使用。他们的查询在全球190个边缘CDN节点上缓存，这意味着无论你身处何地，将数据从GraphCMS拉入你的Gatsby项目应该非常快。让我们通过在工具中创建一个我们可以在应用程序中摄取的兴趣爱好列表来介绍如何使用GraphCMS：
- en: Navigate to the GraphCMS website ([graphcms.com](https://graphcms.com)) and
    log in.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到GraphCMS网站([graphcms.com](https://graphcms.com))并登录。
- en: Create a new blank project and pick the region you want to host your data in.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的空白项目并选择你想要托管数据所在的区域。
- en: Navigate to your project's `Models` will open the following dialog:![Figure
    3.2 – Model creation in GraphCMS
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到你的项目的`模型`将打开以下对话框：![图3.2 – 在GraphCMS中创建模型]
- en: '](img/B15983_03_02.jpg)'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15983_03_02.jpg]'
- en: Figure 3.2 – Model creation in GraphCMS
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.2 – 在GraphCMS中创建模型
- en: Here, you can see I am creating a model called **Icebreakers**. You'll notice
    that you need to provide an **API ID** and its plural form to make it easier to
    distinguish between when you are querying a single item versus the whole collection.
    Upon hitting **Update Model**, you should see that **Icebreakers** has been added
    to the model on the left sidebar.
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我正在创建一个名为**Icebreakers**的模型。你会注意到你需要提供一个**API ID**及其复数形式，以便在查询单个项目与整个集合之间更容易区分。点击**更新模型**后，你应该能看到**Icebreakers**已经被添加到左侧侧边栏的模型中。
- en: We can now start to define what type of data is in our Icebreakers model by
    adding fields. Upon clicking on the Icebreakers model, you will see many field
    options on the right-hand side. We can use these to explain to GraphCMS what format
    our data will take. In our case, a hobby consists of one to three words each,
    so it would be appropriate to use the **Single Line Text** field option. Selecting
    this option will open the following dialog:![Figure 3.3 – Field creation in GraphCMS
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以通过添加字段来定义Icebreakers模型中包含的数据类型。点击Icebreakers模型后，您将在右侧看到许多字段选项。我们可以使用这些选项来告诉GraphCMS我们的数据将采用什么格式。在我们的例子中，一个爱好由一到三个单词组成，因此使用**单行文本**字段选项是合适的。选择此选项将打开以下对话框：![图3.3
    – 在GraphCMS中创建字段
- en: '](img/B15983_03_03.jpg)'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15983_03_03.jpg)'
- en: Figure 3.3 – Field creation in GraphCMS
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.3 – 在GraphCMS中创建字段
- en: Enter an appropriate display name and API ID, such as **hobbies**. Write **Collection
    of hobbies I have** as the description. I have also checked **Allow multiple values**
    so that we can store a list of hobbies instead of one. Click **Update** to save
    this configuration.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输入一个合适的显示名称和API ID，例如**hobbies**。将描述写为**我拥有的爱好集合**。我还勾选了**允许多个值**，这样我们就可以存储一个爱好列表而不是单个爱好。点击**更新**以保存此配置。
- en: Navigate to the content section of the site. Click **Create item** at the top
    right of the page. This will open the following window:![Figure 3.4 – Populating
    content in GraphCMS
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到网站的“内容”部分。在页面右上角点击**创建项目**。这将打开以下窗口：![图3.4 – 在GraphCMS中填充内容
- en: '](img/B15983_03_04.jpg)'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15983_03_04.jpg)'
- en: Figure 3.4 – Populating content in GraphCMS
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.4 – 在GraphCMS中填充内容
- en: We can now start to fill in our hobbies, adding them to the list as we go. Once
    you've done this, hit **Save** at the top right.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在可以开始填写我们的爱好，在添加时将它们添加到列表中。一旦完成，请点击页面右上角的**保存**。
- en: Returning to the content window, you will see that your created icebreaker is
    in **Draft** mode. This means that we are not happy with the content yet and that
    we will not be able to retrieve it from the API yet:![Figure 3.5 – GraphCMS content
    and its draft status
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到内容窗口，您会看到您创建的Icebreaker处于**草稿**模式。这意味着我们还不满意内容，而且我们还不能从API中检索它：![图3.5 – GraphCMS内容和其草稿状态
- en: '](img/B15983_03_05.jpg)'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15983_03_05.jpg)'
- en: Figure 3.5 – GraphCMS content and its draft status
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.5 – GraphCMS内容和其草稿状态
- en: To make the content live, we need to publish it by selecting the item and then
    clicking the **Publish** button.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使内容生效，我们需要通过选择项目然后点击**发布**按钮来发布它。
- en: Next, we need to modify the endpoint settings to allow for public API access.
    By default, your GraphCMS API is not accessible from outside of their platform.
    You can change the settings for your public API access or create permanent authentication
    tokens with access permissions. Often, I lean toward keeping my data public as
    it is still only retrievable if you know the API's URL. Since it can't be edited
    by default, all of it will be displayed publicly on my site anyway.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要修改端点设置以允许公共API访问。默认情况下，您的GraphCMS API无法从其平台外部访问。您可以更改公共API访问的设置或创建具有访问权限的永久性认证令牌。通常，我倾向于保持我的数据公开，因为即使不知道API的URL，它仍然可以检索。由于默认情况下无法编辑，所以所有内容仍然会在我网站上公开显示。
- en: 'Navigate to **Settings**, then **API Access**, and modify your public API permissions
    to the following:'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 导航到**设置**，然后是**API访问**，并修改您的公共API权限如下：
- en: '![Figure 3.6 – GraphCMS public API settings'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图3.6 – GraphCMS公共API设置'
- en: '](img/B15983_03_06.jpg)'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15983_03_06.jpg)'
- en: Figure 3.6 – GraphCMS public API settings
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.6 – GraphCMS公共API设置
- en: You will see that I have checked **Content from stage Published**. By doing
    so, we can now retrieve data that has been published via the URL endpoint, located
    at the top of the API's **Access** page.
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您会看到我已经勾选了**从已发布阶段获取内容**。通过这样做，我们现在可以检索通过API的**访问**页面顶部URL端点发布的所有数据。
- en: Scroll to the top of this page and take note of your master URL endpoint. We
    will now move over to our Gatsby project and start ingesting data using this URL.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到页面顶部并注意您的master URL端点。现在我们将转到我们的Gatsby项目，并使用此URL开始摄取数据。
- en: 'Open a terminal at the root of your project and install the necessary dependencies,
    the official GraphCMS source plugin, and `dot-env`:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的根目录下打开一个终端，并安装必要的依赖项、官方GraphCMS源插件和`dot-env`：
- en: '[PRE22]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`gatsby-source-graphcms` will allow us to source data from GraphCMS within
    our application, while `dotenv` is a zero-dependency module that loads environment
    variables from a `.env` file. We will be storing our API endpoint in the `.env`
    format. This plugin also requires `gatsby-plugin-image` under the hood, so make
    sure to install it. We will talk more about `gatsby-plugin-image` in [*Chapter
    5*](B15983_05_ePub_RK.xhtml#_idTextAnchor080), *Working with Images*.'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`gatsby-source-graphcms`将允许我们在应用程序中从GraphCMS获取数据，而`dotenv`是一个零依赖模块，它从`.env`文件中加载环境变量。我们将以`.env`格式存储我们的API端点。此插件还要求在内部使用`gatsby-plugin-image`，所以请确保安装它。我们将在[*第五章*](B15983_05_ePub_RK.xhtml#_idTextAnchor080)，*与图像一起工作*中更多地讨论`gatsby-plugin-image`。'
- en: 'Create a `.env` file at the root of your project and add your master URL endpoint
    for GraphCMS as a variable:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的项目根目录创建一个`.env`文件，并将GraphCMS的主URL端点作为变量添加：
- en: '[PRE23]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Modify your `gatsby-config.js` file so that it includes `gatsby-plugin-image`
    and `gatsby-source-graphcms`:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改你的`gatsby-config.js`文件，使其包含`gatsby-plugin-image`和`gatsby-source-graphcms`：
- en: '[PRE24]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We can now start our development server. You will notice that when the development
    server starts, a new folder is created called `graphcms-fragments`. This folder
    is maintained by the plugin and contains fragments that explain the structure
    of our data to the GraphQL data layer.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以启动我们的开发服务器。你会注意到，当开发服务器启动时，会创建一个名为`graphcms-fragments`的新文件夹。这个文件夹由插件维护，包含解释我们数据结构的片段，以供GraphQL数据层使用。
- en: 'At this point, we can query our data as if it were any other source. First,
    we must construct a query:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以像查询任何其他来源的数据一样查询我们的数据。首先，我们必须构建一个查询：
- en: '[PRE25]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, I have created a query that extracts our hobbies array from the auto-generated
    `graphCmsIcebreaker` source.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我创建了一个查询，从自动生成的`graphCmsIcebreaker`源中提取我们的爱好数组。
- en: 'We can now embed this query in our `about` page:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以将此查询嵌入到我们的`about`页面中：
- en: '[PRE26]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You'll notice that I have just appended the new query to the existing page query,
    bundled into the same GraphQL string. Gatsby expects to only find one query per
    page. I then deconstructed the data prop to retrieve the hobbies array.
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会注意到我只是将新的查询附加到现有的页面查询中，捆绑到同一个GraphQL字符串中。Gatsby期望每个页面只有一个查询。然后我解构了数据属性以检索爱好数组。
- en: Now that we understand how GraphCMS works, let's turn our attention to how you
    would implement one of GraphCMS's competitors, Prismic.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了GraphCMS的工作原理，让我们转向如何实现GraphCMS的一个竞争对手，Prismic。
- en: Prismic
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Prismic
- en: 'Prismic is smaller than GraphCMS, with around 5,000 paying customers. One feature
    that makes it stand out is they offer **dynamic multi-session previews**, allowing
    you to share multiple simultaneous dynamic previews (with shareable links) in
    Gatsby. This can improve your workflow when you''re working with clients and you
    need to send the client''s site content back and forth. Let''s learn how to integrate
    Prismic by adding a list of hobbies within the UI so that we can then ingest them
    within our Gatsby site:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Prismic比GraphCMS小，大约有5,000个付费客户。使其脱颖而出的一个特性是他们提供**动态多会话预览**，允许你在Gatsby中共享多个同时动态预览（带有可分享的链接）。当你与客户一起工作时，这可以提高你的工作流程，因为你需要来回发送客户的网站内容。让我们通过在UI中添加一个爱好列表来学习如何集成Prismic，这样我们就可以在我们的Gatsby网站上摄取它们：
- en: Create a folder in `/src` called `schemas`. Unlike GraphCMS, Prismic does not
    automatically create the schemas for us; instead, we will retrieve them using
    the Prismic UI as we create them.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/src`目录下创建一个名为`schemas`的文件夹。与GraphCMS不同，Prismic不会自动为我们创建模式；相反，我们将使用Prismic
    UI在创建它们时检索它们。
- en: Navigate to Prismic's website ([prismic.io](https://prismic.io)) and log in.
    Create a new repository with the free plan (you can always scale up later if you
    need to).
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到Prismic的网站([prismic.io](https://prismic.io))并登录。使用免费计划创建一个新的存储库（如果你需要，你总是可以稍后扩展）。
- en: Click the **Create your first custom type** button and select the **single**
    type. Name your type **Icebreaker** and submit.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建第一个自定义类型**按钮，选择**单选**类型。将你的类型命名为**Icebreaker**并提交。
- en: Scroll to the bottom of the build-mode sidebar on the right and drag a group
    into the central page:![Figure 3.7 – Prismic group field options
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右侧构建模式侧边栏的底部滚动，并将一个组拖到中央页面：![图3.7 – Prismic组字段选项
- en: '](img/B15983_03_07.jpg)'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15983_03_07.jpg)'
- en: Figure 3.7 – Prismic group field options
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.7 – Prismic组字段选项
- en: Name your field **hobbies**; the corresponding API ID should populate on its
    own. Click **OK** to confirm this.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的字段命名为**hobbies**；相应的API ID将自动填充。点击**确定**以确认这一点。
- en: Drag a rich text field into this group:![Figure 3.8 – Prismic text field configuration
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个富文本字段拖动到这个组中：![图3.8 – Prismic文本字段配置
- en: '](img/B15983_03_08.jpg)'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15983_03_08.jpg]'
- en: Figure 3.8 – Prismic text field configuration
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.8 – Prismic文本字段配置
- en: This will open the side panel shown to the left of the preceding screenshot.
    We will use the rich text field as the type for a single hobby. First, let's give
    it a name – **hobby** seems appropriate. Ensure that **API ID** matches the assigned
    name. Uncheck the **Allow multiple paragraphs** box and then ensure that only
    the paragraph object is highlighted. By doing so, we can ensure that our hobbies
    are always single lines that only consist of paragraphs. Submit this using the
    **OK** button.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将打开前面截图左侧显示的侧面板。我们将使用富文本字段作为单个爱好的类型。首先，让我们给它起个名字——**爱好**似乎很合适。确保**API ID**与分配的名称匹配。取消勾选**允许多个段落**框，然后确保只有段落对象被突出显示。通过这样做，我们可以确保我们的爱好总是单行，只包含段落。使用**确定**按钮提交。
- en: Save the document.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文档。
- en: Now that we have defined our type, navigate to the JSON editor and copy its
    contents.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的类型，导航到JSON编辑器并复制其内容。
- en: Create a new file inside your `schemas` folder called `icebreaker.json` and
    paste the JSON you have copied.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`schemas`文件夹内创建一个名为`icebreaker.json`的新文件，并将复制的JSON粘贴进去。
- en: Navigate back home and click on **Documents.** Then click the *pencil icon*
    button to create a new instance of your Icebreaker type:![Figure 3.9 – Prismic
    collection interface
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回首页并点击**文档**。然后点击**铅笔图标**按钮创建你的Icebreaker类型的新实例：![图3.9 – Prismic集合界面
- en: '](img/B15983_03_09.jpg)'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15983_03_09.jpg]'
- en: Figure 3.9 – Prismic collection interface
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.9 – Prismic集合界面
- en: You can now use your hobbies type to create your data. Once you are happy with
    your list of hobbies, you can hit **Save**, followed by **Publish**.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你现在可以使用你的爱好类型来创建你的数据。一旦你对你的爱好列表满意，你可以点击**保存**，然后点击**发布**。
- en: Return home, navigate to **Settings**, and click on **API and security**. Ensure
    that your repository security is set to **Public API for Master only**:![Figure
    3.10 – Repository security
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回首页，导航到**设置**，然后点击**API和安全**。确保您的仓库安全设置为**仅对主分支的公共API**：![图3.10 – 仓库安全
- en: '](img/B15983_03_10.jpg)'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/B15983_03_10.jpg]'
- en: Figure 3.10 – Repository security
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.10 – 仓库安全
- en: This means that anyone with your API URL can access what is currently live but
    not preview future releases. Make a note of your API entry point, which should
    be located at the top of this page. Now, let's look at our Gatsby project and
    start ingesting data using that URL.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这意味着任何拥有您API URL的人都可以访问当前正在直播的内容，但不能预览未来的发布。请记下您的API入口点，它应该位于本页面的顶部。现在，让我们看看我们的Gatsby项目，并开始使用该URL获取数据。
- en: 'Install the Gatsby Prismic source plugin:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Gatsby Prismic源插件：
- en: '[PRE27]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Modify your `gatsby-config.js` file:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改你的`gatsby-config.js`文件：
- en: '[PRE28]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can now start our development server and query our data as normal. Upon
    opening GraphiQL, you should see `prismicIcebreaker` as a new source that we can
    use to query for our hobbies:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以启动我们的开发服务器，并像往常一样查询我们的数据。在打开GraphiQL后，你应该会看到一个新来源`prismicIcebreaker`，我们可以用它来查询我们的爱好：
- en: '[PRE29]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, we are retrieving the text value of every hobby from within the `hobbies`
    object.
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们正在检索`hobbies`对象中每个爱好的文本值。
- en: 'We can now embed this query in our `about` page:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以将这个查询嵌入到我们的`about`页面中：
- en: '[PRE30]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You should be starting to see the power of using GraphQL in Gatsby. As soon
    as we have ingested data, we can use the same format to query it every time. Using
    these two as examples, you should feel comfortable sourcing data from another
    CMS using a source plugin.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该开始看到使用GraphQL在Gatsby中的强大功能。一旦我们摄入了数据，我们就可以使用相同的格式来查询它。以这两个为例，你应该能够使用源插件从另一个CMS中获取数据。
- en: Summary
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to use Gatsby's data layer. You learned about
    the basics of how to explore your GraphQL data layer via GraphiQL and should now
    feel comfortable sourcing and ingesting data into your Gatsby project from a multitude
    of different sources – `siteMetadata`, Markdown, MDX, and CMSes using their plugins.
    If you are interested in how source plugins are created and how to make your own,
    check out [*Chapter 10*](B15983_10_ePub_RK.xhtml#_idTextAnchor141), *Creating
    Gatsby Plugins*.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用Gatsby的数据层。你了解了如何通过GraphiQL探索你的GraphQL数据层的基础知识，现在你应该能够从多种不同的来源（`siteMetadata`、Markdown、MDX和CMS使用其插件）轻松地获取和摄入数据到你的Gatsby项目中。如果你对如何创建源插件以及如何创建自己的插件感兴趣，请查看[*第10章*](B15983_10_ePub_RK.xhtml#_idTextAnchor141)，*创建Gatsby插件*。
- en: In the next chapter, we will create and use reusable templates for pages that
    appear more than once, such as blog pages. This is great for when you have multiple
    pieces of data that you want to make use of while using the same layout.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将创建并使用可重复使用的模板来处理那些出现多次的页面，例如博客页面。这对于当你想要使用相同布局同时利用多份数据时非常有用。
