- en: TypeScript Crash Course
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will start working with TypeScript: the language Angular
    is written with. All the features that ECMAScript 2015 and ECMAScript 2016 provide,
    such as functions, classes, modules, and decorators, are already implemented in
    or added to the roadmap of TypeScript. Because of the extra type annotations,
    there are some syntactical additions compared to JavaScript.'
  prefs: []
  type: TYPE_NORMAL
- en: Being already familiar with AngularJS and subsequently ES5, we'll go through
    a process of smooth transition to TypeScript. We'll start by introducing ES2015
    and ES2016\. As we mentioned previously, TypeScript is a superset of these new
    ECMAScript standards, which means that by learning the new versions of JavaScript
    you'll also learn very important bits of TypeScript. In the second half of the
    chapter, we'll add the extra syntax for explicit type annotations.
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter, we will explain the extra features TypeScript provides,
    such as static typing and extra syntax. We will discuss the different consequences
    based on these features, which will help us to be more productive and less error-prone.
    Let's get going!
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeScript is an open source programming language that is developed and maintained
    by Microsoft. Its initial public release was in October 2012\. TypeScript is a
    superset of ECMAScript, supporting all of the syntax and semantics of JavaScript
    with some extra features on top, such as static typing and richer syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 1* shows the relationships among ES5, ES2015, ES2016, and TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cdbf660b-f4bd-48e6-9c32-65bdde97a088.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1
  prefs: []
  type: TYPE_NORMAL
- en: As TypeScript is statically typed, it can provide a number of benefits to us
    as JavaScript developers. Let's take a quick look at those benefits now.
  prefs: []
  type: TYPE_NORMAL
- en: Compile-time type checking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most common mistakes we make while writing JavaScript code is to
    misspell a property or a method name. Usually, we find out about the mistake when
    we get a runtime error. This can happen during development as well as during production.
    Hoping that we will know about the error before we deploy our code to the production
    environment isn't a comfortable feeling! However, this is not a problem specific
    to JavaScript; it is something common to all the dynamic languages. Even with
    lots of unit tests, these errors can slip by.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript provides a compiler, which takes care of such mistakes for us using
    static code analysis. If we take advantage of static typing, TypeScript will be
    aware of the existing properties a given object has, and if we misspell any of
    them, the compiler will warn us with a compile-time error.
  prefs: []
  type: TYPE_NORMAL
- en: Another great benefit of TypeScript is that it allows large teams to collaborate
    since it provides formal, verifiable naming. This way, it allows us to write easy-to-understand
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Better support by text editors and IDEs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a number of tools, such as Tern, that are trying to bring better autocompletion
    support for JavaScript in text editors and IDEs. However, as JavaScript is a dynamic
    language, it is impossible for the IDEs and text editors to make sophisticated
    suggestions without any metadata. Google Closure Compiler, for instance, uses
    type annotations provided in the JSDoc in order to provide static typing to the
    language.
  prefs: []
  type: TYPE_NORMAL
- en: Annotating the code with such metadata is a built-in feature of TypeScript known
    as type annotations. Based on them, text editors and IDEs can perform a better
    static analysis on our code. This provides better refactoring tools and autocompletion,
    which increases our productivity and allows us to make fewer mistakes while writing
    the source code for our applications.
  prefs: []
  type: TYPE_NORMAL
- en: There's even more to TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TypeScript by itself has a number of other benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**It is a superset of JavaScript**: All JavaScript programs (for example, ES5
    and ES2015) are already valid TypeScript ones. In essence, you have already been
    writing TypeScript code. Since it is based on the latest version of the ECMAScript
    standard, it allows us to take advantage of the latest bleeding-edge syntax provided
    by the language.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It supports optional type checking**: If, for any reason, we decide that
    we don''t want to explicitly define the type of a variable or a method, we can
    just skip the type definition. However, we should be aware that this means we
    are no longer taking advantage of the static typing, so we are giving up on all
    the benefits mentioned earlier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It is developed and maintained by Microsoft**: The quality of the implementation
    of the language is very high, and it is unlikely that support will be dropped
    unexpectedly. TypeScript is based on the work of some of the world''s best experts
    in programming language development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It is open source**: This allows the community to freely contribute to the
    language and suggest features, which are discussed in an open manner. The fact
    that TypeScript is open source makes the development of third-party extensions
    and tools easier. This extends the scope of its usage even further.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since modern browsers do not support TypeScript natively, there is a compiler
    that translates the TypeScript code we write into readable JavaScript in a predefined
    target version of ECMAScript. Once the code is compiled, all the type annotations
    are removed.
  prefs: []
  type: TYPE_NORMAL
- en: Using TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start writing some TypeScript!
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will take a look at different snippets showing
    some of the features of TypeScript. In order to be able to run the snippets and
    play with them yourself, you'll need to install the TypeScript compiler on your
    computer. Let's take a look at how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to install TypeScript is using **Node package manager** (**npm**).
    I'd recommend that you use version 5.0.0 or a newer version of `npm`. If you don't
    have node.js and `npm` installed already, you can visit [https://nodejs.org](https://nodejs.org)
    and follow the instructions there.
  prefs: []
  type: TYPE_NORMAL
- en: Installing TypeScript with npm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you have `npm` installed and running, verify that you have the latest
    version by opening your terminal window and running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following command in order to install TypeScript 2.5.0 or newer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will install the TypeScript compiler and add its executable
    (`tsc`) as global.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to verify that everything works properly, you can use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The output should be similar to the preceding one, though possibly with a different
    minor or patch version.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we install TypeScript by prefixing the version with caret. This means
    that `npm` will download any version in the range 2.y.z, but below 3.0.0.
  prefs: []
  type: TYPE_NORMAL
- en: Running our first TypeScript program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s compile our first TypeScript program! Create a file called `hello-world.ts`
    and enter the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we''ve already installed the TypeScript compiler, we should have a global
    executable command called `tsc`. You can use it in order to compile the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you should see the `hello-world.js` file in the same directory where `hello-world.ts`
    is. The `hello-world.js` file is the output of the TypeScript compiler; it contains
    the JavaScript equivalent to the TypeScript we wrote. We can run this file using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you''ll see the `Hello world!` string printed on the screen. In order
    to combine the process of compiling and running the program, you can use the `ts-node`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You should see the same result, but without the `hello-world.js` file stored
    on the disk.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code for this book at [https://github.com/mgechev/switching-to-angular](https://github.com/mgechev/switching-to-angular).
    Most code snippets in the book's content have a comment as the first line, which
    shows where you can find the complete example in the directory structure of the
    samples repository. Note that the paths are relative to the `app` directory.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript syntaxes and features introduced by ES2015 and ES2016
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As TypeScript is a superset of JavaScript, before we start learning about its
    syntax, it'll be easier to start by introducing some of the bigger changes in
    ES2015 and ES2016; to understand TypeScript, we first must understand ES2015 and
    ES2016\. We will have a whistle-stop tour through these changes before diving
    into TypeScript properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'A detailed explanation of ES2015 and ES2016 is beyond the scope of this book.
    In order to get familiar with all the new features and syntaxes, I strongly recommend
    that you take a look at *Exploring ES6: Upgrade to the next version of JavaScript*
    by *Dr. Axel Rauschmayer*.'
  prefs: []
  type: TYPE_NORMAL
- en: The next couple of pages will introduce new standards and allow us to take advantage
    of most of the features we will need during the development of Angular applications.
  prefs: []
  type: TYPE_NORMAL
- en: ES2015 arrow functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JavaScript has first-class functions, which means that they can be passed around
    like any other value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This syntax is great; however, it is a bit too verbose. ES2015 introduced a
    new syntax to define anonymous functions called the arrow function syntax. Using
    it, we can create anonymous functions, as seen in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the first example here, we got the total sum of the elements in the `[1,
    2, 3]` array. In the second example, we got all the even numbers from the `[3,
    1, 56, 7]` array. In the third example, we sorted an array by the `price` and
    `total` properties in ascending order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Arrow functions have a few more features that we need to look at. The most
    important feature is that they keep the context (`this`) from the surrounding
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: For example, when we invoke the `MyComponent` function with the `new`; operator,
    `this` will point to the new object instantiated by the call. The arrow function
    will keep the context (`this`), in the callback of `setTimeout`, and print `43`
    on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: This is extremely useful in Angular since the binding context for a given component
    is its instance (that is, its `this` reference). If we define `MyComponent` as
    an Angular component and we have a binding to the `age` property, the preceding
    code will be valid and all the bindings will work (note that we don't have the
    scope, neither do we have explicit calls to the `$digest` loop, although we have
    called `setTimeout` directly).
  prefs: []
  type: TYPE_NORMAL
- en: Using the ES2015 and ES2016 classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developers new to JavaScript hear that the language empowers the **object-oriented**
    (**OO**) paradigm, they're normally confused when they discover that there's no
    syntax for the definition of classes. This perception was born of the fact that
    some of the most popular programming languages, such as Java, C#, and C++, have
    the concept of classes used for the construction of objects. However, JavaScript
    implements the OO paradigm differently. JavaScript has a prototype-based, object-oriented
    programming model, where we can instantiate objects using the object literal syntax
    or functions (also known as the constructor functions), and we can take advantage
    of the inheritance using the so called prototype chain.
  prefs: []
  type: TYPE_NORMAL
- en: Although this is a valid way to implement the OO paradigm, and the semantics
    are similar to the one in the classical object-oriented model, it is confusing
    for inexperienced JavaScript developers who are not sure how to process this properly.
    This is one of the reasons TC39 decided to provide an alternative syntax to use
    the object-oriented paradigm in the language. Behind the scenes, the new syntax
    has the same semantics as the one we're used to, such as using the constructor
    functions and the prototype-based inheritance. However, it provides a more convenient
    syntax to empower the features of OO paradigm with less boilerplate.
  prefs: []
  type: TYPE_NORMAL
- en: ES2016 adds some extra syntax to the ES2015 classes, such as static and instance
    property declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that demonstrates the syntax used to define the classes
    in ES2016:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In ES2015, the explicit declaration of the `_name` property is not required;
    however, since the TypeScript compiler should be aware during compile time of
    the existing properties of the instances of a given class, we would need to add
    the declaration of the property to the class definition itself.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding snippet is both a valid TypeScript and JavaScript code. In it,
    we defined a class called `Human`, which adds a single property to the objects
    instantiated by it. It does this by setting the value of the property to the value
    of the parameter `name` passed to its constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Later, the `Developer` class extends the `Human` class by specifying a reference
    to it in the `extends` clause. This way, the instances of the `Developer` class
    will have the entire functionality that the `Human` class provides, plus the extra
    features introduced by `Developer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open the `ch4/es6-classes/sample-classes.ts` file and play around with
    it! You can create different instances of the classes in the same way you create
    objects using constructor functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to execute the code, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Classes are commonly used in Angular. You can use them to define your components,
    directives, services, and pipes.
  prefs: []
  type: TYPE_NORMAL
- en: Defining variables with block scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another confusing point of JavaScript for developers with a different background
    is the variable scope in the language. In Java and C++, for example, we're used
    to the block lexical scope. This means that a given variable defined inside a
    specific block will be visible only inside that block and all of the nested blocks
    inside of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in JavaScript, things are a little bit different. ECMAScript defines
    a functional lexical scope that has similar semantics to the block lexical scope,
    but it uses functions instead of blocks. Let''s take a look at the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This has some weird implications. Once the code is executed, it will log five
    times the number `5`.
  prefs: []
  type: TYPE_NORMAL
- en: 'ES2015 added a new syntax to define variables with block scope visibility.
    The syntax is similar to the current one, however, instead of `var`, it uses the
    `let` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the semantics will be as expected: we''ll see the numbers from `0` to `4`
    logged in the console.'
  prefs: []
  type: TYPE_NORMAL
- en: Meta-programming with ES2016 decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JavaScript is a dynamic language that allows us to easily modify and/or alter
    the behavior to suit the programs we write. Decorators are a proposal to ES2016,
    and the design document at [https://github.com/wycats/javascript-decorators](https://github.com/wycats/javascript-decorators)
    describes their work as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"...make it possible to annotate and modify classes and properties at design
    time."'
  prefs: []
  type: TYPE_NORMAL
- en: Their syntaxes are quite similar to the annotations in Java, and they are even
    closer to the decorators in Python. ES2016 decorators are used commonly in Angular
    to define components, directives, and pipes, and to take advantage of the dependency
    injection mechanism of the framework. Most use cases of decorators involve altering
    the behavior to a predefined logic or adding some metadata to different constructs.
  prefs: []
  type: TYPE_NORMAL
- en: ES2016 decorators allow us to do a lot of fancy things by changing the behavior
    of our programs. Typical use cases could be to annotate the given methods or properties
    as deprecated or read only. A set of predefined decorators that can improve the
    readability of the code we produce can be found in a project called `core-decorators.js`.
    Another use case is taking advantage of the proxy-based, aspect-oriented programming
    using a declarative syntax. The library providing this functionality is `aspect.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, ES2016 decorators are just a new syntax sugar, which translates
    to JavaScript code we''re already familiar with from the previous versions of
    the language. Let''s take a look at a simple example from the draft of the proposal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we have an ES2015 class called `Person` with a single getter
    called `kidCount`. Over the `kidCount` getter, we have applied the `@nonenumerable`
    decorator. The decorator is a function that accepts a target (the `Person` class),
    the name of the target property we intend to decorate (`kidCount`), and the descriptor
    of the target property. After we change the descriptor, we need to return it in
    order to apply the modification. Basically, the decorator''s application can be
    translated into ECMAScript 5 in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Using configurable decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is an example of using the decorators defined by Angular:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'When decorators accept arguments (just like `Component` in the preceding example),
    they need to be defined as functions that accept arguments and return the actual
    decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we defined a function called `Component` that accepts a single
    argument called `config` and returns a decorator. On the other hand, the decorator
    accepts the constructor function as argument, which is the desugared version of
    the class.
  prefs: []
  type: TYPE_NORMAL
- en: Writing modular code with ES2015
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another problem that JavaScript professionals have experienced over the years
    is the lack of a module system in the language. Initially, the community developed
    different patterns, aiming to enforce the modularity and the encapsulation of
    the software we produce. Such patterns included the module pattern, which takes
    advantage of the functional lexical scope and closures. Another example is the
    namespace pattern, which represents the different namespaces as nested objects.
    AngularJS introduced its own module system that unfortunately doesn't provide
    features, such as lazy module loading. However, these patterns were more like
    workarounds rather than real solutions.
  prefs: []
  type: TYPE_NORMAL
- en: '**CommonJS** (used in node.js) and **AMD** (short for, **Asynchronous Module
    Definition**) were later invented. They are still widely used today and provide
    features such as handling of circular dependencies and asynchronous module loading
    (in AMD).'
  prefs: []
  type: TYPE_NORMAL
- en: 'TC39 took the best of the existing module systems and introduced this concept
    on a language level. ES2015 provides two APIs to define and consume modules. They
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Declarative API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imperative API using a module loader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular takes full advantage of the ES2015 module system, so let's dive into
    it! In this section, we will take a look at the syntax used for the declarative
    definition and consumption of modules. We will also take a peek at the API of
    the module loader in order to see how we can programmatically load modules in
    an explicit asynchronous manner.
  prefs: []
  type: TYPE_NORMAL
- en: Using the ES2015 module syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we defined a simple ES2015 module in the `math.ts`
    file. We can think of it as a sample math Angular utility module. Inside it, we
    define and export the `square` and `log` functions and the constants `E` and `PI`.
    The `const` keyword is another keyword brought by ES2015 that is used to define
    constants. As you can see, what we do is nothing more than prefixing the definitions
    of the function with the `export` keyword. If we want to export the entire functionality
    in the end and skip the duplicate explicit usage of `export`, we can use the following
    approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax on the last line is an enhanced object literal syntax, introduced
    by ES2015\. Now, let''s take a look at how we can consume this module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As an identifier of the module, we use its relative path to the current file.
    Using destructuring, we import the required symbols: in this case, `square`, `log` and
    `E`. Now run the `app.ts` file with `ts-node`: `ts-node app.ts`. As output on
    the screen you should see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Taking advantage of the implicit asynchronous behavior of the module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An important thing to note is that the ES2015 module syntax has implicit asynchronous
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/531918ef-6460-4640-af28-91457c3e19f9.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram (*Figure 2)*, we have the `A`, `B`, and `C` modules.
    The `A` module uses the `B` and `C` modules, so it depends on them. Once the user
    requires the `A` module, the JavaScript module loader will need to load the `B`
    and `C` modules before being able to invoke any of the logic that resides in the
    `A` module because of the dependencies they have. The `B` and `C` modules will
    be loaded asynchronously. Once they are loaded completely, the JavaScript virtual
    machine will be able to execute the `A` module.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, the modern bundlers are going to combine `A`, `B`, and `C` in a single
    file in order to reduce the overhead of the additional HTTP requests that the
    browser needs to perform in order to resolve the dependencies of `A`.
  prefs: []
  type: TYPE_NORMAL
- en: Using aliases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another typical situation is when we want to use an alias for a given export.
    For example, if we use a third-party library, we may want to rename some of its
    exports in order to escape name collisions or just to have a more convenient naming:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Importing all the module exports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can import the entire `math` module using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The semantics behind this syntax is quite similar to CommonJS, although, in
    the browser, we have implicit asynchronous behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that the `import *` syntax is often not recommended because it
    will get all the exported symbols from the target module even if we don't need
    them. This can lead to an unnecessary increase in the size of the production build
    of our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Default exports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If a given module defines an `export`, which would quite likely be used by
    any of its consumer modules, we can take advantage of the default `export` syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to consume this module, we can use the following `app.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if we want to import the default export, together with additional
    exports, we can use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In general, the default export is nothing more than an named export named with
    the `default` reserved word:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: ES2015 module loader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The new version of the standard defines a programmatic API to work with modules.
    This is the so called module loader API. It allows us to define and import modules,
    or configure the module loading.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s suppose we have the following module definition in the `app.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'From the `init.js` file, we can programmatically load the `app` module and
    invoke its `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The global object `System` has a method called `import` that allows us to import
    modules using their identifier. In the preceding snippet, we import the `app`
    module defined in `app.js`. Moreover, `System.import` returns a promise that can
    be resolved on success or rejected in case of an error. Once the promise is resolved
    as the first parameter of the callback passed to `then`, we will get the module
    instance. The first parameter of the callback registered in case of rejection
    is an object representing the error that happened.
  prefs: []
  type: TYPE_NORMAL
- en: The code from the previous snippet does not exist in the GitHub repository since
    it requires additional configuration and is not crucial for our purposes.
  prefs: []
  type: TYPE_NORMAL
- en: ES2015 and ES2016 recap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations! We're more than halfway toward learning TypeScript. All the
    features we just saw are part of TypeScript since it implements a superset of
    JavaScript; since all these features are an upgrade on top of the current syntax,
    they are easy for experienced JavaScript developers to grasp.
  prefs: []
  type: TYPE_NORMAL
- en: In the next sections, we will describe all the amazing features of TypeScript
    that are outside the intersection with ECMAScript.
  prefs: []
  type: TYPE_NORMAL
- en: Taking advantage of static typing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Static typing is what can provide better tooling for our development process.
    While writing JavaScript, the most that IDEs and text editors can do is to highlight
    syntax and provide some basic autocompletion suggestions based on sophisticated
    type inference for our code. This means that we can only verify that we haven't
    made any typos by running the code.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous sections, we described the new features provided by ECMAScript
    expected to be implemented by browsers in the near future. In this section, we
    will take a look at what TypeScript provides in order to help us be less error
    prone and more productive. At the time of writing this book, there were no plans
    to implement built-in support for static typing in the browsers.
  prefs: []
  type: TYPE_NORMAL
- en: The TypeScript code goes through intermediate preprocessing that performs the
    type checking and drops all the type annotations in order to provide valid JavaScript
    supported by modern browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Using explicit type declarations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like Java and C++, TypeScript allows us to explicitly declare the type
    of the given variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The preceding line defines the `foo` variable in the current block using the
    `let` syntax. We explicitly declare that we want `foo` to be of the `number` type
    and we set the value of `foo` to `42`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s try to change the value of `foo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, after the declaration of `foo`, we will set its value to the `''42''`
    string. This is a perfectly valid JavaScript code; however, if we compile it using
    the TypeScript''s compiler, we will get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Once `foo` is associated with the given type, we cannot assign to it values
    belonging to different types. This is one of the reasons we can skip the explicit
    type definition in case we assign a value to the given variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The semantics of this code will be the same as the one with the explicit type
    definition because of the type inference of TypeScript. We'll further take a look
    at it at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The any type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the types in TypeScript are subtypes of a type called `any`. We can declare
    variables belonging to the `any` type using the `any` keyword. Such variables
    can hold the value of any type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is a valid TypeScript, and it will not throw any error during
    compilation or runtime. If we use the `any` type for all of our variables, we
    will be basically writing the code with dynamic typing, which drops all the benefits
    of the TypeScript's compiler. This is why we have to be careful with `any` and
    use it only when it is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other types in TypeScript that we will take a look at are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Primitive types**: These include the Number, String, Boolean, Void, Null,
    Undefined, and Enum types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Object types**: These include Function types, classes and interface type
    references, array types, tuple types, function types, and constructor types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Type parameters**: These include Generics that will be described in the *Writing
    generic code using type parameters* section'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the primitive types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most of the primitive types in TypeScript are the ones we are already familiar
    with in JavaScript: Number, String, Boolean, Null, and Undefined. So, we will
    skip their formal explanation here. Another set of types that is handy while developing
    Angular applications is the `enum` types defined by users.'
  prefs: []
  type: TYPE_NORMAL
- en: The Enum types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Enum types are primitive user-defined types that, according to the specification,
    are subclasses of Number. The concept of enums exists in the Java, C++, and C#
    languages, and it has the same semantics in TypeScript: user-defined types consisting
    of sets of named values called elements. In TypeScript, we can define an `enum`
    using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be translated to the following JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `enum` type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Understanding the object types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will take a look at the array and function types, which
    belong to the more generic class of Object types. We will also explore how we
    can define classes and interfaces. Tuple types were introduced by TypeScript 1.3,
    and their main purpose is to allow the language to begin typing the new features
    introduced by ES2015, such as destructuring. We will not describe them in this
    book. For further reading, you can take a look at the language's specification
    at [http://www.typescriptlang.org](http://www.typescriptlang.org).
  prefs: []
  type: TYPE_NORMAL
- en: The array types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In TypeScript, arrays are JavaScript arrays with a common element type. This
    means that we cannot have elements from different types in a given array. We have
    different array types for all the built-in types in TypeScript, plus all the custom
    types that we define.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define an array of numbers as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to have an array, which seems heterogeneous, similar to the arrays
    in JavaScript, we can use the `any[]` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This is possible since the types of all the values we're pushing to the array
    are subtypes of the `any` type and the array we've declared contains values of
    the `any` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the array methods we''re familiar with in JavaScript with all the
    TypeScript Array types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have the square-brackets operator that gives us random access to the
    elements of the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The Function types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re already familiar with how to define a new function in JavaScript. We
    can use function expression or function declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can use the new arrow function syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The only thing TypeScript alters is the feature to define the types of the
    arguments of the function and the type of its return result (that is, the signature
    of the function). After the compiler of the language performs its type checking
    and transpilation, all the type annotations will be removed. If we use function
    expression and assign a function to a variable, we will be able to define the
    variable type in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to define a method in an object literal, we can do it in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we defined an object literal with the method called
    `squareRoot` using the ES2015 syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'In case we want to define a function that produces some side effects instead
    of returning a result, we can declare its return type as `void`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Defining classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TypeScript classes are similar to what ES2015 offers. However, TypeScript alters
    the type declarations and adds more syntax sugar. For example, let''s take the
    `Human` class we defined earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'There is no difference between the current TypeScript definition and the one
    we already introduced; however, in this case, the declaration of the `_name` property
    is mandatory. Here is how we can use the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Using access modifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similarly, for most conventional object-oriented languages that support classes,
    TypeScript allows a definition of access modifiers. In order to deny direct access
    to the `_name` property outside the class it is defined in, we can declare it
    as private:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The supported access modifiers by TypeScript are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Public**: All the properties and methods declared as public can be accessed
    from anywhere'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Private**: All the properties and methods declared as private can be accessed
    only from inside the definition of the class itself'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Protected**: All the properties and methods declared as protected can be
    accessed from inside the definition of the class or the definition of any other
    class extending the one that owns the property or the method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Access modifiers are a great way to implement Angular services with good encapsulation
    and a well-defined interface. In order to understand this concept better, let''s
    take a look at an example using the hierarchy of the class defined earlier, which
    is ported to TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Just like ES2015, TypeScript supports the `extends` keyword and desugars it
    to the prototypal JavaScript inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, we set the access modifiers of the `name` and `age`
    properties directly inside the constructor function. The semantics behind this
    syntax differs from the one used in the previous example. It has the following
    meaning: define a protected property called `name` of the `string` type and assign
    the first value passed to the constructor call to it. It is the same for the private
    `age` property. This saves us from explicitly setting the value in the constructor
    itself. If we take a look at the constructor of the `Developer` class, we can
    see that we can use the mixture between these syntaxes. We can explicitly define
    the property in the constructor''s signature, or we can only define that the constructor
    accepts a parameters of the given types.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create a new instance of the `Developer` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'During compilation, TypeScript will throw an error telling us that:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Property languages is private and only accessible inside the class "Developer"`.
    Now, let''s see what will happen if we create a new `Human` class and try to access
    its properties from outside its definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we''ll get the following two errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Property age is private and is only accessible inside the class "Human"`,
    and the `Property name is a protected and only accessible inside class "Human"
    and its subclasses`.'
  prefs: []
  type: TYPE_NORMAL
- en: However, if we try to access the `_name` property from inside the definition
    of `Developer`, the compiler won't throw any errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to get a better sense of what the TypeScript compiler will produce
    out of a type-annotated class, let''s take a look at the JavaScript produced by
    the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting ECMAScript 5 will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The defined property will be added directly to the objects instantiated when
    calling the constructor function with the `new` operator. This means that once
    the code is compiled, we can directly access the private members of the created
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: In order to wrap this up, access modifiers are added in the language in order
    to help us enforce better encapsulation and get compile-time errors in case we
    violate it.
  prefs: []
  type: TYPE_NORMAL
- en: Defining interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Subtyping** in programming languages allows us to treat objects in the same
    way based on the observation that they are specialized versions of a generic object.
    This doesn''t mean that they have to be instances of the same class of objects,
    or that they have a complete intersection between their interfaces. The objects
    might have only a few common properties and still be treated the same way in a
    specific context. In JavaScript, we usually use duck typing. We may invoke specific
    methods for all the objects passed to a function based on the assumption that
    these methods exist. However, all of us have experienced the `undefined is not
    a function` error thrown by the JavaScript interpreter.'
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented programming and TypeScript come with a solution. They allow
    us to make sure that our objects have similar behavior if they implement interfaces
    that declare the subset of the properties they own.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can define an interface as `Accountable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can make sure that both `Individual` and `Firm implement` this interface
    by performing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: In case we implement a given interface, we need to provide an implementation
    for all the methods defined inside it, otherwise, the TypeScript compiler will
    throw an error. The methods we implement must have the same signature as the ones
    declared in the interface definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript interfaces also support properties. In the `Accountable` interface,
    we can include a field called `accountNumber` with a type of string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: We can define it in our class as a field or a getter.
  prefs: []
  type: TYPE_NORMAL
- en: Interface inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Interfaces may also extend each other. For example, we may turn our `Individual`
    class into an interface that has a social security number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Since interfaces support multiple inheritances, `Individual` may also extend
    the `Human` interface that has the `name` and `age` properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Implementing multiple interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In case the behavior of the class is a union of the properties defined in a
    couple of interfaces, it may implement all of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we need to provide the implementation of all the methods and properties
    declared inside the interfaces our class implements, otherwise, the compiler will
    throw a compile-time error.
  prefs: []
  type: TYPE_NORMAL
- en: Further expressiveness with TypeScript decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In ES2015, we are able to decorate only classes, properties, methods, getters,
    and setters. TypeScript takes this further by allowing us to decorate functions
    or method parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that the parameter decorators should not alter any additional behavior.
    Instead, they are used to generate metadata. The most typical use case of these
    decorators is the dependency injection mechanism of Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Writing generic code using type parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the beginning of the section on using static typing, we mentioned the type
    parameters. In order to get a better understanding of them, let''s begin with
    an example. Let''s suppose that we want to implement the classical data structure
    `BinarySearchTree`. Let''s define its interface using a class without applying
    any method implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we defined a class called `Node`. The instances of
    this class represent the individual nodes in our tree. Each node has a `left`
    and `right` child nodes and a value of the `any` type; we use `any` in order to
    be able to store data of any type inside our nodes and subsequently inside `BinarySearchTree`.
  prefs: []
  type: TYPE_NORMAL
- en: Although the earlier implementation looks reasonable, we're giving up on using
    the most important feature that TypeScript provides, that is, static typing. Using
    `any` as a type of the value field inside the `Node` class, we can't take complete
    advantage of the compile-time type checking. This also limits the autocompletion
    and refactoring features that IDEs and text editors provide when we access the
    `value` property of the instances of the `Node` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript comes with an elegant solution that is already widely popular in
    the world of static typing: type parameters. Using generics, we can parameterize
    the classes we create with the type parameters. For example, we can turn our `Node`
    class into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `Node<T>` indicates that this class has a single type parameter called
    `T` that is used somewhere inside the definition of the class. We can use `Node`
    by performing the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we created three nodes: `numberNode`, `stringNode`,
    and another node of the `Node<number>` type, assigning its value to the right
    child of `numberNode`. Note that since `numberNode` is of the `Node<number>` type,
    we can set its value to `42`, but we can''t use the `''42''` string. The same
    is applicable to its left child. In the definition, we''ve explicitly declared
    that we want the left and right children to be of the `Node<number>` type. This
    means that we cannot assign values of the `Node<string>` type to them; this is
    why, we get the second compile-time error.'
  prefs: []
  type: TYPE_NORMAL
- en: Using generic functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another typical use of generics is for defining functions that operate over
    a set of types. For example, we may define an `identity` function that accepts
    an argument of type `T` and returns it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'However, in some cases, we may want to use only the instances of the types
    that have some specific properties. For achieving this, we can use an extended
    syntax that allows us to declare that we want the types used as type parameters
    to be subtypes of the given type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: For example, here, we defined an interface called `Comparable`. It has a single
    operation called `compare`. The classes that implement the `Comparable` interface
    need to implement the `compare` operation. When `compare` is called with a given
    argument, it returns `1` if the target object is bigger than the passed argument,
    `0` if they are equal, and `-1` if the target object is smaller than the passed
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: Having multiple type parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TypeScript allows us to use multiple type parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we can create an instance of the `Pair<K, V>` class using the
    following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Writing less verbose code with the type inference of TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Static typing has a number of benefits; however, it makes us write a more verbose
    code by adding all the type annotations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases, the compiler of TypeScript is able to guess the types of expressions
    inside our code; let''s consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we defined an `answer` variable and assigned the value
    `42` to it. Since TypeScript is statically typed and the type of a variable cannot
    change once declared, the compiler is smart enough to guess that the type of `answer`
    is `number`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we don''t assign a value to a variable within its definition, the compiler
    will set its type to `any`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet will compile without any compile-time errors.
  prefs: []
  type: TYPE_NORMAL
- en: Best common type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, the type inference could be a result of several expressions. Such
    is the case when we assign a heterogeneous array to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the type of `x` will be `any[]`. However, suppose we have the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The type of `x` will then be `number[]` since the `Number` type is a subtype
    of `Null`.
  prefs: []
  type: TYPE_NORMAL
- en: Contextual type inference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Contextual typing occurs when the type of an expression is implied from its
    location; let''s take this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the type of the argument of the `e` callback is *guessed* by the
    compiler based on the context in which it is used. The compiler understands that
    the type of `e` is based on the call of `addEventListener` and the arguments passed
    to the method. In case we were using a keyboard event (`keydown`, for example),
    TypeScript would have been aware that `e` is of the `KeyboardEvent` type.
  prefs: []
  type: TYPE_NORMAL
- en: Type inference is a mechanism that allows us to write less verbose code by taking
    advantage of the static analysis performed by TypeScript. Based on the context,
    the compiler of TypeScript is able to guess the type of a given expression without
    explicit definition.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing structural typing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An important feature of the type system of TypeScript is that it's **structurally
    typed**. Formally this means that the types equivalence and compatibility are
    determined by the structure of the types, not by other characteristics such as
    name or inheritance hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 'This may sound quite abstract at first, so let''s take a look at a specific
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding snippet defines an interface called `Namable`, which has a declaration
    of a single property called `name`. We also define the `Cat` and `Castle` classes:
    both of them having a `name` property but neither of them implementing the `Namable`
    interface.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we invoke `formatName` with a new instance of `Cat` or `Castle`, the code
    will compile just fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we won't get any compile type errors because the properties that
    the `Namable` interface declares are a subset of the properties declared by `Cat`
    and `Castle`. Although in this case, the explicit interface implementation may
    look unnecessary, it's much more convenient to have it because during development
    of a given class; we'll get an inline error in our text editor or IDE in case
    of incorrect interface implementation. To some of the readers, this may look familiar
    to the *implicit interface implementation* in Go, however, we can go one step
    further.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s take the signature of `formatName` to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can perform this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'If we invoke `formatName` with an instance of `Castle`, the code will compile
    just fine again! This is due to compatibility of the `Cat` and `Castle` classes:
    the `Cat` class has a subset of the properties declared by `Castle`. This may
    look unnatural to developers used to nominal typing, since in this case `Cat`
    and `Castle` are not in the same inheritance chain.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s change the definition of the `Cat` class definition to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'If we keep the same signature of the `formatName` function, then invoking `formatName`
    with an instance of `Castle` will produce an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: As the compilation error says, we cannot pass objects instances of a class that
    lacks some of the properties or methods of the type of the parameter of a given
    function or method signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''re familiar with structural typing, let''s go to our next stop:
    ambient type definitions.'
  prefs: []
  type: TYPE_NORMAL
- en: Using ambient type definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although static typing is amazing, most of the frontend libraries we use are
    built with JavaScript, which is dynamically typed. Since we'd want to use TypeScript
    with Angular, not having type definitions in the code that uses external JavaScript
    libraries is a big issue; it prevents us from taking advantage of the compile-time
    type checking.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript was built keeping these points in mind. In order to allow the TypeScript
    compiler to take care of what it does best, we can use the so called ambient type
    definitions. They allow us to provide external type definitions for the existing
    JavaScript libraries. This way, they provide hints to the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Using predefined ambient type definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fortunately, we don't have to create ambient type definitions for all JavaScript
    libraries and frameworks we use. The community and/or the authors of these libraries
    have already published such definitions online; the biggest repository resides
    at [https://github.com/DefinitelyTyped/DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped).
    During the last couple of months, the community developed a few tools for managing
    ambient type definitions, such as `tsd` and `typings`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Later, Microsoft introduced an official way to manage them: using **`npm`**
    by providing an additional configuration in `tsconfig.json`. The type definitions
    are now distributed as scoped packages under the `@types` namespace and installed
    in `node_modules`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a directory and add a `package.json` file to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'After we provide the default values for the properties that `npm` asks us,
    our `package.json`  file in the `types-test` directory should look something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'We can install a new type definition using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will download the type definitions for AngularJS and save
    them in `node_modules/@types/angular`. Note that we provided the `--save-dev`
    flag to `npm` in order to save the type definition under `devDependencies` of
    `package.json`.
  prefs: []
  type: TYPE_NORMAL
- en: When installing ambient type definitions, we would usually use `--save-dev`
    instead of `--save`, because the definitions are mostly used in development.
  prefs: []
  type: TYPE_NORMAL
- en: 'After running the preceding command, your `package.json` file should look similar
    to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in order to use AngularJS with TypeScript, create `app.ts` and enter the
    following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile `app.ts`, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: The TypeScript compiler will output the compiled content into `app.js`. In order
    to add extra automation and invoke the TypeScript compiler each time we change
    any of the files in our project, we can use a task runner, such as gulp or grunt,
    or pass the `-w` option to `tsc`.
  prefs: []
  type: TYPE_NORMAL
- en: Since using the `reference` element for including type definitions is considered
    bad practice, we can use a `tsconfig.json` file instead. There, we can configure
    which directories need to be included in the compilation process by `tsc`. For
    more information, visit [http://www.typescriptlang.org/docs/handbook/tsconfig-json.html](http://www.typescriptlang.org/docs/handbook/tsconfig-json.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create a file called `tsconfig.json` in the same directory, with
    the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: In this configuration file, we provide the `compilerOptions` property so that
    we don't have to pass parameters, such as `outDir` and `module` formats, as flags
    to `tsc`. Note that in the `files` property, we also list the files that we want
    to be compiled. TypeScript will compile all of them plus all their transitive
    dependencies!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s modify our preceding simple snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The only change we made was to add the line where we declare and initialize
    a new constant with the returned result by the invocation of the `Set` constructor
    function, with `any` as the type parameter. By having `tsconfig.json` in the same
    directory where our `app.ts` file and `node_modules` are, we can compile the project
    by running this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we''ll get the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '`demo.ts(4,22): error TS2304: Cannot find name ''Set''`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, `Set` implements the set data structure and is part of the ES2015 standard.
    Since using the ambient type definitions for ES2015 is a very common practice
    in all TypeScript projects, Microsoft added them as part of TypeScript itself.
    To the `compilerOptions` property inside `tsconfig.json`, add the following `lib`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Here, `lib` has the value of an array, which includes both `"es2015"` and `"dom"`
    because we need ES2015 Set, and the type definitions of Angular require the type
    definitions for the **Document Object Model** (**DOM**). Now when we run `tsc`
    in the directory where your `tsconfig.json` file is located, the compilation process
    should pass successfully and the output file should be located in `./dist/demo.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Custom ambient type definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To understand how everything works together, let''s take a look at an example.
    Suppose, we have the following interface of a JavaScript library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'We have an object literal assigned to a variable called `DOM`. The object has
    the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`selectElements`: This accepts a single argument with the `string` type and
    returns a set of `DOM` elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hide`: This accepts a `DOM` node as an argument and returns nothing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`show`: This accepts a `DOM` node as an argument and returns nothing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In TypeScript, the preceding definition would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that we can define the interface of our library as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'After we have the interface of our library, it will be easy to create the ambient
    type definition; we just have to create a file with a `d.ts` extension called
    `dom` and enter the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we defined the interface called `DOMLibraryInterface`
    and declared the `DOM` variable of the `DOMLibraryInterface` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only thing left before being able to use static typing with our JavaScript
    library is including the external type definition in the script files we want
    to use our library in. We can do it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet hints the compiler on where to find the ambient type definitions.
    An alternative, and better, way to provide a reference to the `d.ts` file is to
    use `tsconfig.json` as described earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we made an introduction to the TypeScript language that is
    used for the implementation of Angular.
  prefs: []
  type: TYPE_NORMAL
- en: While exploring the language, we looked at some of the core features of ES2015
    and ES2016\. We explained the ES2015 and ES2016 classes, arrow functions, block
    scope variable definitions, destructuring, and modules. Since Angular takes advantage
    of the ES2016 decorators, and more accurately their extension in TypeScript, a
    section was dedicated to them.
  prefs: []
  type: TYPE_NORMAL
- en: After this, we took a look at how we can take advantage of static typing using
    explicit type definitions. We described some of the built-in types in TypeScript
    and how we can define classes in the language by specifying access modifiers for
    their members. Our next stop was the interfaces. We ended our adventures in TypeScript
    by explaining the type parameters, structural typing, and the ambient type definitions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapters, we will explore Angular in depth starting with the components
    and directives of the framework.
  prefs: []
  type: TYPE_NORMAL
