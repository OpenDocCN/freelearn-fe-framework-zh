["```js\n<div appRedBackgroundHover. When you use an attribute directive with an input, you use the square bracket syntax like this:\n\n```", "```js\n\n In the preceding example, `ngClass` is the attribute directive, and we add it between square brackets because it receives an input. Now that you know how to use attribute directives in HTML templates, let’s explore the most commonly used built-in attribute directives and, after that, create a custom attribute directive.\nCommon built-in attribute directives\nThe most commonly used built-in attribute directives are the following:\n\n*   `ngClass` or `class`: These directives are used to conditionally add CSS classes.\n*   `ngStyle` or `style`: These directives are used to conditionally add inline styling.\n*   `ngModel`: This directive is used for two-way data binding on “from” elements.\n\nMore built-in attribute directives exist, but these additional built-in directives belong to specific Angular packages, such as `routerLink` from the `formGroup` from the `routerLink` in [*Chapter 2*](B21625_02.xhtml#_idTextAnchor033), and we will learn more about directives from the forms package in [*Chapter 4*](B21625_04.xhtml#_idTextAnchor072). Now, let us learn how to create custom attribute directives.\nCreating custom attribute directives\nWe will start by creating a new library with our custom generator. Name the new library `common-directives` and select `libs\\shared\\ui\\common-directives\\src\\lib folder`, right-click, and select `directive` and select **@nx/angular – directive**. Now, follow these steps:\n\n1.  Enter `highlight` for the **name*** field.\n2.  Click on **Show** **all options**.\n3.  Check the **standalone** checkbox.\n4.  Click on **generate** in the top right of the window.\n5.  When the directive is generated, export the directive in the `index.ts` file of the library:\n\n```", "```js\n\n When you look at the `highlight.directive.ts` file, you will see an empty class with a directive decorator above it:\n\n```", "```js\n\n Inside the decorator, you’ll see the standalone flag set to true, indicating that the directive is standalone and doesn’t have to be included in an `NgModule`. Besides that, you’ll find the directive selector. The selector is used to apply the directive.\nNow, let’s add some logic in the `HighlightDirective` class so that our directive does something. Start by injecting `ElementRef`. `ElementRef` gives you access to the host DOM element, the HTML elements applying the directive. After injecting `ElementRef`, you need to use `ElementRef` to adjust the host element that applies the directive. Here is an example highlighting the host element with a background color:\n\n```", "```js\n@HostBinding('style.backgroundColor') get color() { return 'red'; }\n```", "```js\n<div @Input() decorators. The most common way to pass a value to a directive is to add an @Input() with the same name as the directive selector. In our case, this would look as follows:\n\n```", "```js\n\n Now, you can use the `btLibsUiHighlight` property to assign the background color:\n\n```", "```js\n\n To give the directive input a value, you need to add square brackets around the directive when you declare it on an HTML element and give it the value you want:\n\n```", "```js\n\n If you don’t like using the selector name in your TypeScript file but instead use a more descriptive property name, you can alias the input like this:\n\n```", "```js\n\n This will probably give you a lint error because aliasing inputs is not generally recommended. Still, you can disable the lint error in this scenario if you prefer a more descriptive property name.\nIf you also want to customize the text color, add another `@Input()` property to the directive class. We will name the input property `textColor` and assign it a default value of `white`:\n\n```", "```js\n\n This is how you assign additional inputs and their values in the HTML template:\n\n```", "```js\n@Input() background = 'black';\n@Input() textColor = 'white';\n```", "```js\n<div @HostListner() directive. Inside the function brackets of the @HostListner() directive, you need to add the browser event you want to listen for. This is how we can adjust our directive so it will apply the highlight for mouseenter and restore the original text and background color for mouseleave:\n\n```", "```js\n\n We’ve added a property to save the original background and text color to restore that for `mouseleave`. Lastly, we’ve added the host listeners so we can react to the `mouseenter` and leave the events of the host element. We’ve added the logic to adjust the background and text color inside the host listeners.\nNow that you know how to create custom attribute directives and enhance them with inputs and host listeners, let’s explore structural directives.\nAngular structural directives\n**Structural directives** represent a tool for adding and removing DOM elements based on logic. The logic of when to add or remove DOM elements is defined in the directive class. Defining structural directives in your HTML templates is achieved like so:\n\n```", "```js\n<ng-container *ngIf=\"expression\">\n  <div *ngFor=»let item of list»>{{item}}</div>\n</ng-container>\n```", "```js\n<div *ngIf=\"showContent\">Show if true</div>\n<div *ngIf=\"!showContent\">Show if false</div>\n```", "```js\n<div *ngIf=\"showContent; else elseBlock\">Show if true</div>\n<ng-template #elseBlock>\n  <div>Show if false</div>\n</ng-template>\n```", "```js\n<div *ngFor=\"let item of list;\n    let i = index; let isFirst = first;\n    let isLast = last; let isEven = even; let isOdd = odd»\n>\n  Item at index {{ i }}: {{ item }}\n  Is first: {{ isFirst }} Is last: {{ isLast }}\n  Is even: {{ isEven }} Is odd: {{ isOdd }}\n</div>\n```", "```js\nItem at index 0: 0 Is first: true Is last: false Is even: true Is odd: false\nItem at index 1: 1 Is first: false Is last: false Is even: false Is odd: true\nItem at index 2: 2 Is first: false Is last: false Is even: true Is odd: false\nItem at index 3: 3 Is first: false Is last: true Is even: false Is odd: true\n```", "```js\n<div *ngFor=\"let item of users; trackBy: trackByFunction\">\n{{ item }} </div>\n```", "```js\ntrackByFunction(index, user) { return user.id; }\n```", "```js\n<ng-template [ ngIf ]=\"condition\">\n  <div>Shown when condition is true</div>\n</ng-template>\n```", "```js\nprivate templateRef = inject(TemplateRef);\nprivate viewContainer = inject(ViewContainerRef);\n```", "```js\nprivate embeddedTemplateAdded = false;\n```", "```js\n@Input() set btLibsUiIfFalse(condition: boolean) {}\n```", "```js\n@Input() set btLibsUiIfFalse(condition: boolean) {\n if (!condition && !this.embeddedTemplateAdded) {\n   this.viewContainer.createEmbeddedView(this.templateRef);\n   this.embeddedTemplateAdded = true;\n } else if (condition && this.embeddedTemplateAdded) {\n   this.viewContainer.clear();\n   this.embeddedTemplateAdded = false;\n }}\n```", "```js\n<div *btLibsUiIfFalse=\"condition\">shown when false</div>\n```", "```js\nselector: 'span, [btLibsUiHighlight]',\n```", "```js\nselector: 'span:not([noHighlight]), [btLibsUiHighlight]',\n```", "```js\n<span noHighlight>Test</span>\n```", "```js\nselector: '[btLibsUiHighlight]:not(label)',\n```", "```js\nselector: '#someId, .someCssClass, [data-highlight=\"true\"]'\n```", "```js\n@Component({ ………, hostDirectives: [\n{directive: TypeDirective, inputs: ['btLibsUiType']},\n{directive: SizeDirective, inputs: ['btLibsUiSizeType']}]})\nexport class ButtonComponent { }\n```", "```js\n{directive: TypeDirective, inputs: ['btLibsUiType: style']}\n```", "```js\n<bt-libs-button [style]=\"'secondary'\">XX</bt-libs-button>\n```", "```js\n<div>{{currentDate | date}}</div>\n```", "```js\n<div>{{currentDate | date: 'YYYY-MM-dd'}}</div>\n```", "```js\n<div>{{currentDate | date: 'YYYY-MM-dd':'GMT'}}</div>\n```", "```js\n<div>{{currentDate | date: 'YYYY-MM-dd' | uppercase}}</div>\n```", "```js\nconst formattedDate = this.datePipe.transform(this.currentDate, 'dd/MM/yyyy');\n```", "```js\n<div *ngFor=\"let dashboard of dashboards | active\">\n    {{dashboard.name}}\n</div>\n```", "```js\ntimer: Observable<number> = interval(2000);\n```", "```js\nthis.timer.subscribe((n) => { this.count = n; });\n```", "```js\n<div>{{count}}</div>\n```", "```js\n<div>{{timer | async}}</div>\n```", "```js\n    export * from './lib/multiply.pipe';\n    ```", "```js\ntransform(value: number, multiplier = 2): number {\n  return value * multiplier;\n}\n```", "```js\n<div>{{10 | multiply}}</div>\n```", "```js\n<div>{{10 | multiply: 5}}</div>\n```", "```js\ntransform(value: number, multiplier = 2, additional = 1): number {\n  return value * multiplier * additional;\n}\n```", "```js\n<div>{{10 | multiply: 5: 10}}</div>\n```", "```js\n@Pipe({\n  name: 'multiply',\n  standalone: true,\n  pure: false,\n})\n```", "```js\nprovideAnimations(),\n```", "```js\nexport * from './lib/selectable-label/selectable-label.component';\n```", "```js\n@Input() labelText!: string;\n@Input() get selected() {\n  return this._selected;\n}\nset selected(selected) {\n  this._selected = selected;\n  this.animationState = selected ? ‹selected› : ‹deselected›;\n}\n@Output() selectedChange = new EventEmitter<boolean>();\nprivate _selected = false;\nanimationState = 'deselected';\nonSelectionChanged() {\n  this.selected = !this.selected;\n  this.selectedChange.emit(this.selected);\n}\n```", "```js\nspan {\n  color: white; background-color: #455b66;\n  padding: 5px 15px; border-radius: 15px; cursor: pointer;\n}\n```", "```js\n<span (click)=\"onSelectionChanged()\">{{labelText}}</span>\n```", "```js\n@Component({ ………, animations: []})\n```", "```js\ntrigger('selectedState', [\n  state('selected', style({ backgroundColor: '#382632' })),\n  state('deselected', style({ backgroundColor: '#455b66'})),\n  transition('selected <=> deselected', [animate('2s')])\n])\n```", "```js\nselectedState. The animation metadata array contains state and transition functions that define the behavior of our animation. Let’s explore these functions in more detail.\nAnimation state\nInside our animation metadata array, by using our `selectedState` trigger, you’ll find the state functions:\n\n```", "```js\n\n Your animation can have as many state functions as are needed. You can define animations without a state or with many state functions. Each state defines a state your animation can transition to. If you have an animation without any state functions, you can define the style changes inside the transition functions, and the animation will still run, but after it finishes, the HTML element will be as it was before the animation started. When you have a state, you can transition an element from one state to another. When the animation transitions to a specific animation state, the HTML element will stay styled as the state defined it until the animation transitions the HTML element to another animation state.\nEach animation state receives a name to indicate the state and a style function to define the style properties with which to transition to for the specific animation state. It is important to note that the styles are indicated with camel case, so no hyphens are used. The background color CSS property becomes `backgroundColor`.\nIn our example, we have two states: `selected` and `deselected`. Inside the component class, we also have a property called `animationState`, which holds the current state of our animation. By default, it’s set to `deselected`. When we click on our label, we will set the `selected` property, and inside the setter of our `selected` property, we will set `animationState` to its proper value.\nAnimation transition\nAfter our state functions, we define a transition function inside the animation metadata array:\n\n```", "```js\n\n Transition functions specify how to transition from one animation state to another and they can take three parameters: the transition statement, an animation metadata array, and an object that can define a delay for your transition.\nTransition expression\nThe `transition` expression indicates what state transition to cover when using a specific `transition` function. The syntax of the `transition` expression reads from left to right and uses arrows to indicate the state transition. For example, `selected => deselected` would target state transitions from `selected` to `deselected`, `deselected => selected` would target state transitions from `deselected` to `selected`, and `selected <=> deselected` would target state transitions from `selected` to `deselected` and from `deselected` to `selected`. You can also use an asterisk inside your selection expression. The asterisk symbol is a wildcard and stands for every state. For example, `* => deselected` would trigger the transition if any state transfers to `deselected`, and `* => *` would trigger if any state transfers to another.\nThe `transition` expression has a few more special selectors that are similar to the asterisk. For example, you can use `:enter` and `:leave` as transition expressions. The `:enter` expression will be applied to an element entering the DOM, and `:leave` targets elements that are removed from the DOM. The `:enter` and `:leave` expressions do not care about the animation state an HTML element currently has. These two expressions are useful when combined with the `*ngIf` or `*``ngFor` directives.\nYou can also use `:increment` and `:decrement` as expressions. The `:increment` and `:decrement` expressions will trigger the animation when the value inside the HTML element is a number, and it gets incremented or decremented.\nAnimation metadata array\nAfter the transition expression, the `transition` function also takes an animation metadata array as input. In our example, we only declared an `animate` function inside, which indicates how long the transition takes, which is 2 seconds in our case. The animate function can also take a `style` function like this:\n\n```", "```js\n\n The `style` function inside the `animate` function is useful if you have no states for your animation or if you want to perform additional animations during the transition that will not last once the state transition is finished.\nYou can also define keyframes for your `animate` function. With keyframes, you can indicate different stages of the animation; the offset defines how far into the animation you are, with `0` defining the start and `1` defining the end of the animation:\n\n```", "```js\n\n Besides the `animate` function, the animation metadata array inside the transition function can take more configurations. The most commonly used are `group` and `sequence`.\nThe `sequence` function is used to trigger multiple animate steps one after another. These can be steps that lead to the result of the state you are transitioning to or just additional animation steps that are not included in your animation state:\n\n```", "```js\n\n The `group` function is used to group different `animate` functions. When you group `animate` functions, they will be executed simultaneously during the transition. Each group is executed one after another:\n\n```", "```js\n\n Now that you know how to define animations inside your component class, let’s examine how you can add those animations to HTML elements inside your template.\nAdding animations to your template\nAdding animations inside your HTML template is pretty straightforward. To add our animation to the selectable label, we need to add the following code line on the span tag:\n\n```", "```js\n\n On the left-hand side, you define the animation trigger, which is preceded by an `@` sign and enclosed by square brackets. On the right-hand side, you declare the animation state; in our case, we used the `animationState` property from our component class for this, but you can also add ternary operations.\nYou can also trigger events when the animation starts or finishes by adding the following code to your HTML tag with the animation defined on it:\n\n```", "```js\n\n Lastly, you can disable an animation within HTML child elements based on a Boolean value and the `@.disabled` animation control binding like this:\n\n```", "```js\n\n In the preceding example, all animations inside `div` with `@.disabled` are disabled if the `isDisabled` property is `true`.\nNow that you know how to create and use animations, let’s explore how you can reuse animations.\nReusing animations\nCreating animations, especially complex ones, can be a lot of work. If you want to apply them within multiple components, you don’t want to add duplicated code and create the same animation multiple times. To reuse animations, you can create an `animations.ts` file in your application or a `utils` library, depending on your use case. You can create exported functions in this file. Here is an example of our animation as a reusable animation:\n\n```", "```js\n\n Now, inside the component class, you can define the animation as follows:\n\n```", "```js\n\n This maintains readability in your component and allows you to use the animation inside multiple components without creating it again.\nSummary\nIn this chapter, you learned the difference between structural and attribute directives. You learned how to add and remove DOM elements using directives. You’ve learned to change the styling and behavior of DOM elements using directives, and you now know how to listen out for the events of host elements. You can use built-in directives and create your own. Besides directives, you learned how to transform values using Angular pipes. You learned about pure and impure pipes and how they can be made and impact your performance. Lastly, you made your own Angular animation and learned about animation triggers, states, and transform functions. Now, you know how to declare animations in your templates and how to reuse them throughout your application.\nIn the next chapter, you will learn about reactive and template-driven forms.\n\n```", "```js\n\n```", "```js\n\n```", "```js\n\n```"]