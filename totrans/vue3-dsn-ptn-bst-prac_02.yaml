- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software Design Principles and Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software development is fundamentally a *human-intensive discipline.* This means
    that it requires knowledge of both techniques and technology, but also comprehension
    of the problem and the ability to make decisions to implement a solution on multiple
    levels of abstraction. Programming has much to do with how a developer thinks.
    Over the years, and within each context and language, guidelines and solutions
    have emerged to solve recurring problems. Knowledge of these *patterns* will help
    you identify when to apply them and speed your development on a sure footing.
    On the other hand, *principles* are guiding concepts that should be applied at
    every stage of the process and have more to do with how you approach the process.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will take a look at a non-exclusive and non-exhaustive list
    of principles and patterns that are common in Vue 3 application development.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Principles** | **Patterns** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Separation of concerns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composition over inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single responsibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: KIC – keep it clean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DRY – don’t repeat yourself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: KISS – keep it simple stupid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code for the next
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Singleton
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proxy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decorator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Façade
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Callbacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Promises
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Table 2.1 – The principles and patterns covered in this chapter
  prefs: []
  type: TYPE_NORMAL
- en: Understanding these principles and patterns will help you use the framework
    more efficiently and more often than not, it will prevent you from “reinventing
    the wheel”. Together with the first chapter, this will conclude the *foundational
    part* of this book and will give you the basis to follow the practical parts and
    implementation of application examples in the rest of the book.
  prefs: []
  type: TYPE_NORMAL
- en: What are the principles of software design?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In software development, design principles are high-level conceptual guidelines
    that should apply to the entire process. Not every project will use the same principles,
    and these are not mandatory rules to be enforced. They can appear in a project
    from the architecture down to the **user interface** (**UI**) and the last bit
    of code. In practice, some of these principles can also influence software attributes,
    such as maintainability and re-usability.
  prefs: []
  type: TYPE_NORMAL
- en: A non-exclusive list of design principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Design principles vary somewhat depending on the context, domain, and even the
    team one may be part of at the time. The principles included in this chapter are,
    therefore, non-exclusive.
  prefs: []
  type: TYPE_NORMAL
- en: Separation of concerns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is perhaps the most important principle in software engineering. Separation
    of concerns implies that a system must be divided into subsystems of elements
    grouped by their function or service (the **concern**). For example, we can consider
    the human body as a *system* composed of many subsystems (respiratory, circulatory,
    digestive, etc.). These, in turn, are integrated by different organs, which are
    made of tissues, and so forth, down to the smallest cell. Following the same idea
    in software, an application can be divided into elements grouped by concerns,
    from the large architecture all the way down to the last function. Without this
    breakdown of complexity into manageable parts, creating a functional system would
    be much harder, if not impossible.
  prefs: []
  type: TYPE_NORMAL
- en: In general, the application of this principle starts with the big picture of
    what the system should be, looks into what it should do to accomplish that, and
    then breaks it down into manageable working parts.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, here is a crude graphical representation of separation of concerns
    for a web application. Each box in this diagram identifies a different *concern*
    that, in turn, can be detailed into smaller functional parts. Even better, you
    can see how this principle allows you to identify the integrating parts of a system.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – A simple architectural view of a web application showing separation
    of concerns](img/Figure_2.01_B18602.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – A simple architectural view of a web application showing separation
    of concerns
  prefs: []
  type: TYPE_NORMAL
- en: If we were to drill down into any of these small boxes within their respective
    domains, we could still find more concerns to subdivide until we reach an indivisible
    atomic element (a component or function, for example). This principle has much
    to do with and benefits from other principles, such as abstraction and single
    responsibility. We will review them further down the line in this same chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Composition over inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The principle of *composition over inheritance* comes directly from **Object-Oriented
    Programming** (**OOP**). It states that an object should attempt to use other
    objects’ functionality when needed, by referencing or instantiating them instead
    of creating a large and complex inheritance family tree of classes to add such
    functionality. Now, JavaScript is fundamentally a *functional* language, even
    though it supports multiple paradigms, including features from OOP, so this principle
    applies as well. There is one note of warning for those migrating from OOP into
    JavaScript, and that is to avoid the temptation to treat JavaScript as a pure
    OOP language. Doing so could create unnecessary complexity instead of benefiting
    from the virtues of the language.
  prefs: []
  type: TYPE_NORMAL
- en: In Vue 3, there is no extension or inheritance of components. When we need shared
    or inherited functionality, we have a nice toolset of options to replace the inheritance
    paradigm. We will see later how we can comply with this principle by using *composable
    components* in [*Chapter 4*](B18602_04.xhtml#_idTextAnchor102), *User Interface
    Composition* *with Components.*
  prefs: []
  type: TYPE_NORMAL
- en: Single responsibility principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This principle can be found in OOP as well as in functional programming. Simply
    put, it states that a class, method, function, or *component* should deal with
    only one responsibility or functionality. If you have worked in other disciplines
    and languages, this comes naturally. Multipurpose functions are hard to maintain
    and tend to grow out of control, especially in a language such as JavaScript,
    which is loosely typed and highly dynamic. The same concept also applies directly
    to Vue 3 components. Each component should deal with one specific operation and
    avoid attempting to do too much by itself. In practice, when a component grows
    beyond a certain scope, it is best to split it into multiple components or extract
    the behavior into external modules. There are cases when you may end up with a
    many-thousand-lines-long component, but in my experience, this is rarely necessary
    and can and should be avoided. A warning, though, is that too much specificity
    could also lead to unnecessary complexity.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let’s imagine a sign-in screen that also displays a sign-up
    option. This approach is common on many sites today. You could include all the
    functionalities inside just one component, but that would break this principle.
    A better alternative would be to split the components into at least three components
    for this task:'
  prefs: []
  type: TYPE_NORMAL
- en: A parent component that handles the UI logic. This component decides when to
    show/hide the sign-in and sign-up components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A child component that handles the sign-in function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A child component that handles the sign-up function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a graphical representation of this configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – The composition of a sign-in/up interface using multiple components](img/Figure_2.02_B18602.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – The composition of a sign-in/up interface using multiple components
  prefs: []
  type: TYPE_NORMAL
- en: I think that you can quickly grasp the benefits of this principle. It makes
    the code easy to manage, maintain, and adapt since web applications have the tendency
    to mutate and evolve very, very quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Best practice tip
  prefs: []
  type: TYPE_NORMAL
- en: Give components a single responsibility and functionality. Avoid mammoth monolithic
    components as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Encapsulation is the notion that you should wrap data and methods to act as
    a single unit while exposing a well-defined **application programming interface**
    (**API**). Often, this is done in the form of classes, modules, or libraries.
    JavaScript is not an exception, and it is highly recommended to follow this principle.
    In Vue 3, this concept applies to not only components but also CSS styles and
    HTML. The introduction of *single-file components* is a clear example of how the
    framework promotes this principle in action and how important it is for today’s
    development. With only a few edge-case situations, we should consider the (**UI**)
    components as black boxes that receive incoming parameters and provide outgoing
    data. Other components should not be *aware* of their inner workings, only the
    API. As we build example applications throughout this book, you will see this
    principle in action.
  prefs: []
  type: TYPE_NORMAL
- en: KIC – keep it clean
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This principle refers mainly to the way *you write* code. I should emphasize
    here that KIC applies directly to two categories that strongly affect web and
    Vue 3 applications:'
  prefs: []
  type: TYPE_NORMAL
- en: How you format your code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How you tidy up events and variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first item includes the use of code conventions, comments, and indentation
    to the organization of the code and logical grouping of functions. For example,
    if you have methods that deal with **create, read, update, and delete** (**CRUD**)
    operations, it would be best to place them near each other in the code, rather
    than spread around the source file. Many **integrated development environments**
    (**IDEs**) contain features to collapse or expand the inner code of functions.
    This helps to quickly review and locate sections in the code with similar logic.
  prefs: []
  type: TYPE_NORMAL
- en: The second part of this principle has to do with memory and reference handling.
    JavaScript has a very good garbage collector, the function of which is to discard
    unused data to reclaim memory. However, there are occasions when the algorithm
    is prevented from freeing up resources because a reference is still pending. If
    you have worked with other languages, such as C/C++, this issue may sound familiar
    as you need to manually reserve and release memory when not in use. In JavaScript,
    if you register a function to listen to an event, it is best to manually deregister
    it at the appropriate life cycle event of your component when no longer needed.
    This will prevent memory leaks and waste of memory and also prevent some security
    risks (which are out of the scope of this book).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will review the component’s life cycle in [*Chapter 4*](B18602_04.xhtml#_idTextAnchor102)*,
    User Interface Composition with Components,* but for now, take the following example
    as a good application of this principle and keep it as best practice. In this
    example, we will create a *composable* component to detect when the window size
    changes, so in the `script setup` section we will find something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Registers a function on the window object’s resize event during the mounting
    state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deregisters the event before the component is unmounted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `onMounted` and `onBeforeUnmount` functions are part of the Vue 3 framework
    and are triggered by the appropriate component life cycle event. Here, we attach
    our function to the `resize` event when the component is mounted to the **Document
    Object Model** (**DOM**), and we release it just before it is removed. The important
    concept to remember is to clean up after yourself and *keep* *it clean*.
  prefs: []
  type: TYPE_NORMAL
- en: DRY – don’t repeat yourself
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This principle is quite famous, almost to the point of turning into a cliché.
    Sadly, it is easily forgotten. It is credited to Andrew Hunt and David Thomas,
    who used it in the book *The Pragmatic Programmer*. It is mostly thought of as
    *don’t write the same thing twice* and is not far off, but it goes beyond that.
    It encompasses the notion of avoiding redundancy in the process as well as in
    the logic of the application. The core idea is that each process that executes
    business logic should exist in only one place in your entire application.
  prefs: []
  type: TYPE_NORMAL
- en: For example, most web applications have some asynchronous connection with a
    server through the use of an API. There may also be multiple elements in the application
    that will use or need to use this remote computer/server communication. If you
    were going to code the entire code/logic to communicate with the server in each
    component, we would end up with not only duplication of code but also application
    logic. Maintaining such a system would open up the door to an amazing number of
    negative side effects and security concerns, poor user experience, and much more.
    According to this principle, a better approach is to abstract all communication
    code related to the server API into a single module, or class. In practice, in
    JavaScript this can even be delegated to a web worker in a separate thread. We
    will explore this implementation later in [*Chapter 8*](B18602_08.xhtml#_idTextAnchor186),
    *Multithreading with* *Web Workers*.
  prefs: []
  type: TYPE_NORMAL
- en: As a rule of thumb, if you see yourself writing kind-of-the-same-code” in different
    components or classes, it is a clear opportunity to abstract the functionality
    into its own module or component.
  prefs: []
  type: TYPE_NORMAL
- en: KISS – keep it simple and short
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This principle is not exclusive to the software design realm. It was coined
    by the US Navy back in the ’60s (according to Wikipedia, [https://en.wikipedia.org/wiki/KISS_principle](https://en.wikipedia.org/wiki/KISS_principle)).
    The idea is pure common sense: it is better to build simple, small functional
    parts that work together than attempt to create a big and complex program in one
    go. Also, algorithms should be implemented in the most simple and efficient way.
    In web development, this principle is essential. Modern web applications are composed
    of hundreds of working parts spread over multiple computers, servers, and environments.
    The more complex a system or code implementation is, the harder it is also to
    maintain and adapt.'
  prefs: []
  type: TYPE_NORMAL
- en: There is a warning, though. Keeping things simple does not mean over-simplification
    or unnecessary segregation. Too many small parts can introduce unnecessary complexity
    in the system. Applying the KISS principle means staying in that sweet middle
    point where things are manageable and easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Code for the next
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This principle is the idea that you should make your code readable and easy
    to understand for someone else besides you. Naming conventions, logic flow, and
    inter-line comments are all part of this. Not only for the case when you may need
    to delegate your code to another but also when you come back in a year or two
    to the same code. The last thing you want to do is to waste time thinking about
    what the past inexperienced you did with that clever line of spaghetti code Smart
    developers code as if they were going to teach somebody else, simply and elegantly.
    Especially if you are using or contributing to open-source code, this principle
    is vital for group collaboration. In this case, it is worth mentioning the *Boy
    Scout Principle,* which is similar but applies in groups. It states that when
    you find a hard-to-read or “spaghetti” code, you refactor it to make it clean.
  prefs: []
  type: TYPE_NORMAL
- en: Best practice tip
  prefs: []
  type: TYPE_NORMAL
- en: Keep your code clean with on-source comments and documentation explaining your
    logic, as if teaching somebody else. More often than not, you will be teaching
    yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Design principles apply to many different scenarios, some beyond the practice
    of software development. It is important to consider them until they become second
    nature. In general, the application of these and other principles, together with
    the application of design patterns, make an important mark on your professional
    development.
  prefs: []
  type: TYPE_NORMAL
- en: What is a software design pattern?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In software development, it is common for certain processes and tasks to appear
    in multiple projects, in one way or another, or with some degree of variation.
    A *design pattern* is a proven solution for such similar problems. It does not
    prescribe code but acts like a reasoning template, an approach that has been abstracted
    independent of the implementation to be reused and adapted to particular circumstances.
    In practice, there is plenty of room for creativity to apply a pattern. Entire
    books have been dedicated to this subject and provide more detail than the scope
    of this book allows. In the following pages, we will take a look at what I consider
    to be the most recurrent patterns to keep in mind for Vue 3 applications. Even
    though we see them in isolation for the purposes of studying them, the reality
    is that often the implementation overlaps, mixes, and encapsulates multiple patterns
    in a single piece of code. For example, you can use a **singleton** to act as
    a **decorator** and a **proxy** to simplify or alter the communication between
    services in your application (we will do this quite often, actually, and the full
    code can be seen in [*Chapter 8*](B18602_08.xhtml#_idTextAnchor186)*, Multithreading
    with* *Web Workers*).
  prefs: []
  type: TYPE_NORMAL
- en: Design patterns can also be understood as software engineering and development
    *best practices*. And the opposite of that, *bad practice*, is often referred
    to as an **anti-pattern**. Anti-patterns are “solutions” that, even though they
    fix an issue in the short term, create problems and bad consequences along the
    line. They generate the need to work around the problem and destabilize the whole
    structure and implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now view a list of patterns that should be part of your toolbox for Vue
    3 projects.
  prefs: []
  type: TYPE_NORMAL
- en: A quick reference list of patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Patterns are classified according to the type of function or problem they solve.
    There are plenty of patterns according to the context, language, and architecture
    of a system. Here is a non-exclusive list of patterns that we will use throughout
    this book and that, in my experience, are more likely to appear in Vue applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creational patterns**: These deal with the approach to creating classes,
    objects, and data structures:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Singleton pattern
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency injection pattern
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Factory pattern
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Behavioral patterns**: These deal with communication between objects, components,
    and other elements of the application:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observer pattern
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Command pattern
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Structural patterns**: These provide templates that affect the design of
    your application and the relationship between components:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proxy pattern
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Decorator pattern
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Façade pattern
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Asynchronous patterns**: These deal with data and process flow with asynchronous
    requests and events in single-threaded applications (heavily used in web applications):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Callbacks pattern
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Promises pattern
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Not by any means this list of patterns is exclusive. There are many more patterns
    and classifications, and a full library is dedicated to this subject. It is worth
    mentioning that the description and application for some of these may differ from
    one literature to another and there is some overlapping depending on the context
    and implementation.
  prefs: []
  type: TYPE_NORMAL
- en: With that introduction to design patterns, let’s look at them in detail with
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: The singleton pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a very common pattern in JavaScript and perhaps one of, if not the most
    important. The basic concept defines that one object’s instance must only exist
    once in the entire application, and all references and function calls are done
    through this object. A singleton can act as a gateway to resources, libraries,
    and data.
  prefs: []
  type: TYPE_NORMAL
- en: When to use it
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is a short rule of thumb to know when to apply this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: When you need to make sure a resource is accessed through only one gateway,
    for example, the global application state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you need to encapsulate or simplify behavior or communications (used in
    conjunction with other patterns). For example, the API access object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the *cost* of multiple instantiations is detrimental. For example, the
    creation of web workers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many ways that you can apply this pattern in JavaScript. In some cases,
    the implementation from other languages is migrated to JavaScript, often following
    Java examples with the use of a `getInstance()` method to obtain the singleton.
    However, there are better ways to implement this pattern in JavaScript. Let’s
    see them next.
  prefs: []
  type: TYPE_NORMAL
- en: Method 1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The simplest way is through a module that exports a plain object literal or
    a **JavaScript Object Notation** (**JSON**), which is a static object:'
  prefs: []
  type: TYPE_NORMAL
- en: ./chapter 2/singleton-json.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You then can import this module into other modules and still always have the
    same object. This works because bundlers and browsers are smart enough to avoid
    the repetition of imports, so once this object has been brought in the first time,
    it will ignore the next requests. When not using a bundler, the ES6 implementation
    of JavaScript also defines that modules are singletons.
  prefs: []
  type: TYPE_NORMAL
- en: Method 2
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This method creates a class and then, on the first instantiation, saves the
    reference for future calls. In order for this to work, we use a variable (traditionally
    called `_instance`) from the class and save the reference to the instance in the
    constructor. In the following calls, we check whether the `_instance` value exists,
    and if so, return it. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: ./chapter 2/singleton-class.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This second method may be more familiar to other language developers. Notice
    how we are also exporting a new instance of the class and not the class directly.
    This way, the invoker will not have to remember to instantiate the class every
    time, and the code will be the same as in *method 1*. This use case is something
    that needs to be coordinated with your team to avoid different implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The invoker then can call methods from each one directly (assuming the singleton
    has a function/method called `myFunction()`):'
  prefs: []
  type: TYPE_NORMAL
- en: ./chapter 2/singleton-invoker.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The singleton pattern is extremely useful, though it rarely exists *in isolation*.
    Often, we use singletons to wrap the implementation of other patterns and make
    sure we have a single point of access. In our examples, we will use this pattern
    quite often.
  prefs: []
  type: TYPE_NORMAL
- en: The dependency injection pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This pattern simply states that the dependencies for a class or function are
    provided as inputs, for example, as parameters, properties, or other types of
    implementations. This simple statement opens a very wide range of possibilities.
    Let’s take, for example, a class that works with the browser’s `dbManager.js`
    file exposes an object that handles the operations with the database, and the
    `projects` object deals with CRUD operations for the projects table (or collection).
    Without using dependency injection, you will have something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: ./chapter 2/dependency-injection-1.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code shows a “normal” approach, where we import the dependencies
    at the beginning of the file and then use them in our code. Now, let’s tweak this
    same code to use dependency injection:'
  prefs: []
  type: TYPE_NORMAL
- en: ./chapter 2/dependency-injection-2.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the main difference is that `dbManager` is now passed as a parameter
    to the function. This is what is called **injection**. This opens up many ways
    to manage dependencies and, at the same time, pushes the hardcoding of dependencies
    up the implementation tree. This makes this class highly reusable, at least for
    as long as the dependency respects the expected API.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding example is not the only way to inject a dependency. We could,
    for example, assign it to a property for the object’s internal use. For example,
    if the `projects.js` file was implemented using the property approach instead,
    it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: ./chapter 2/dependency-injection-3.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the invoker of the object (a singleton, by the way) needs to
    be aware of the property and assign it before calling on any of its functions.
    Here is an example of how that would look:'
  prefs: []
  type: TYPE_NORMAL
- en: ./chapter 2/dependency-injection-4.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: But this approach is not recommended. You can clearly see that it breaks the
    principle of encapsulation, as we are directly assigning a property for the object.
    It also doesn’t feel like clean code even though it is valid code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Passing the dependencies one function at a time is also not recommended. So,
    what is a better approach? It depends on the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: In a class, it is convenient to require the dependencies in the constructor
    (and if not found, throw an error)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a plain JSON object, it is convenient to provide a function to set the dependency
    explicitly and let the object decide how to use it internally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This last approach is also recommended for passing a dependency after the instantiation
    of an object when the dependency is not ready at the time of implementation
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code example for the first point mentioned in the preceding list:'
  prefs: []
  type: TYPE_NORMAL
- en: ./chapter 2/dependency-injection-5.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the constructor, we declare the expected parameter with a default value.
    If the dependency is not provided, we throw an error. Otherwise, we assign it
    to an internal private attribute for the use of the instance. In this case, the
    invoker should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In an alternative implementation, we could have a function that basically does
    the same by receiving the dependency and assigning it to a private attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This approach is better than directly assigning the internal attribute, but
    you still need to remember to do the assignment before using any of the methods
    in the object.
  prefs: []
  type: TYPE_NORMAL
- en: Best practice note
  prefs: []
  type: TYPE_NORMAL
- en: Whatever approach you use for dependency injection, remain constant throughout
    your code base.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that we have mainly been focusing on objects. As you may
    have already guessed, passing a dependency to a function is just the same as passing
    another parameter, so it does not deserve special attention.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example has just moved the dependency implementation responsibility up
    to another class in the hierarchy. But what if we implement a singleton pattern
    to handle all or most of the dependencies in our application? This way, we could
    just delegate the loading of the dependencies to one class or object at a determined
    point in our application life cycle. But how do we implement such a thing? We
    will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A method to register the dependency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A method to retrieve the dependency by name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A structure to keep the reference to each dependency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s put that into action and create a very *naive* implementation of such
    a singleton. Please keep in mind that this is an academic exercise, so we are
    not considering error checking, de-registration, or other considerations:'
  prefs: []
  type: TYPE_NORMAL
- en: ./chapter 2/dependency-injection-6.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'With this bare minimum implementation, let’s look at each line by the line
    comment:'
  prefs: []
  type: TYPE_NORMAL
- en: We create a simple JavaScript object literal as a singleton.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We declare an empty object to use as a dictionary to hold our dependencies by
    name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `provide` function lets us register a dependency by name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, we just use the name as the field name and assign the dependency passed
    by argument (notice we are not checking pre-existing names, etc.).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, we return the source object, mainly for convenience so we can chain the
    invocation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `inject` function will take the name as registered in the `provide` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We return the dependency or `null` if not found.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With that singleton on board, we can now use it across our application to distribute
    the dependencies as needed. For that, we need a parent object to import them and
    populate the service. Here is an example of how that might look:'
  prefs: []
  type: TYPE_NORMAL
- en: ./chapter 2/dependency-injection-7.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this module has hard-coded dependencies, and its work is to
    load them into the `dependencyService` object. Then, the dependent function or
    object needs only to import the service and retrieve the dependency it needs by
    the registration name like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This approach does create a tight coupling between components but is here as
    a reference. It has the advantage that we can control all the dependencies in
    a single location so that the maintenance benefits could be significant. The choice
    of names for the methods of the `dependencyService` object was not random either:
    these are the same used by Vue 3 inside the component’s hierarchy. This is very
    useful for implementing some User Interface design patterns. We will see this
    in more detail in [*Chapter 4*](B18602_04.xhtml#_idTextAnchor102), *User Interface
    Composition with Components* and [*C**hapter 7*](B18602_07.xhtml#_idTextAnchor173),
    *Data* *Flow Management*.'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this pattern is very important and is implemented in Vue 3 with
    the `provide`/`inject` functions. It's a great addition to our toolset, but there
    is more still. Let’s move on to the next one.
  prefs: []
  type: TYPE_NORMAL
- en: The factory pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The factory pattern provides us with a way to create objects without creating
    a direct dependency. It works through a function that, based on the input, will
    return an instantiated object. The use of such an implementation will be made
    through a common or standard interface. For example, consider two classes: `Circle`
    and `Square`. Both implement the same `draw()` method, which draws the figure
    to a canvas. Then, a `factory` function would work something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This method is quite popular, especially in conjunction with other patterns,
    as we will see multiple times in this book.
  prefs: []
  type: TYPE_NORMAL
- en: The observer pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The observer pattern is very useful and one of the basis of a reactive framework.
    It defines a relationship between objects where one is being observed (the **subject**)
    for changes or events, and other(s) are notified of such changes (the **observers**).
    The observers are also called **listeners**. Here is a graphical representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – The subject emits an event and notifies the observers](img/Figure_2.03_B18602.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – The subject emits an event and notifies the observers
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the subject emits an event to notify the observers. It is for
    the subject to define what events and parameters it will **publish**. Meanwhile,
    the observers **subscribe** to each event by registering a function with the publisher.
    This implementation is why this pattern is often referred to as the **pub/sub**
    pattern, and it can have several variations.
  prefs: []
  type: TYPE_NORMAL
- en: 'When looking into the implementation of this pattern, it is important to notice
    the cardinality of the publication: `1` event to `0..N` observers (functions).
    This means that the subject must implement, on top of its main purpose, the functionality
    to publish events and keep track of the subscribers. Since this would break a
    principle or two in the design (separation of concerns, single responsibility,
    etc.), it is common to extract this functionality into a middle object. The previous
    design then changes to add a middle layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – An observer implementation with a dispatcher middle object](img/Figure_2.04_B18602.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – An observer implementation with a dispatcher middle object
  prefs: []
  type: TYPE_NORMAL
- en: 'This middle object, sometimes referred to as an “**event dispatcher** encapsulates
    the basic functionality to register observers, receive events from the subject,
    and dispatch them to the observers. It also does some clean-up activities when
    an observer is no longer observing Let’s put these concepts into a simple and
    naive implementation of an event dispatcher in plain JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: ./chapter 2/Observer-1.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding implementation is, again, naive. It doesn’t contain the necessary
    error and edge case handling that you would use in production, but it does have
    the bare basics for an event dispatcher. Let’s look into it line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: In the constructor, we declare an object to use internally as a dictionary for
    our events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `on` method allows the observers to register their functions. In this line,
    if the event is not initialized, we create an empty array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this line, we just push the function to the array (as I said, this is a naive
    implementation, as we don’t check for duplicates, for example).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `emit` method allows the subject to publish an event by its name and pass
    some data to it. Here, we run over the array and execute each function passing
    the data we received as a parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `off` method is necessary to deregister the function once it is not used
    (see the *keep it clean* principle, earlier in this chapter).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In order for this implementation to work, every observer and the subject need
    to reference the same implementation of the `ObserverClass`. The easiest way to
    secure this is to implement it through a *singleton pattern*. Once imported, each
    observer registers with the dispatcher with this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the subject emits the event and passes the data with the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, when the observer no longer needs to watch the subject, it needs to
    clean up the reference with the `off` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: There are a good number of edge cases and controls that we have not covered
    here, and rather than reinventing the wheel, I suggest using a ready-made solution
    for these cases. In our book, we will use one named `mitt` ([https://www.npmjs.com/package/mitt](https://www.npmjs.com/package/mitt)).
    That has the same methods as in our example. We will see how to install packaged
    dependencies in [*Chapter 3*](B18602_03.xhtml#_idTextAnchor079), *Setting up a*
    *Working Project*.
  prefs: []
  type: TYPE_NORMAL
- en: The command pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This pattern is very useful and easy to understand and implement. Instead of
    executing a function right away, the basic concept is to create an object or structure
    with the information necessary for the execution. This data package (the **command**)
    is then delegated to another object that will perform the execution according
    to some logic to handle it. For example, the commands can be serialized and queued,
    scheduled, reversed, grouped together, and transformed. Here is a graphical representation
    of this pattern with the necessary parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – A graphical implementation of the command pattern](img/Figure_2.05_B18602.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – A graphical implementation of the command pattern
  prefs: []
  type: TYPE_NORMAL
- en: The diagram shows how the clients submit their commands to the **Invoker**.
    The invoker usually implements some sort of queue or task array to handle the
    commands and then routes the execution to the proper **Receiver**. If there is
    any data to return, it also returns it to the proper client. It is also common
    that the invoker attaches additional data to the command to keep track of clients
    and receives, especially in the case of asynchronous executions. It also provides
    a single point of “entry” to the receivers and decouples the “clients” from them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s again work on a naive implementation of an `Invoker` class:'
  prefs: []
  type: TYPE_NORMAL
- en: ./chapter 2/Command-1.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have implemented a bare-bones example of what an
    `Invoker` should have line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Invoker` exposes a method to add commands to the object. This is only necessary
    when the commands will be somehow queued, serialized, or processed according to
    some logic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This line executes the command according to the `action` field contained in
    the `command_data` parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Based on the `action` field, the *invoker* routes the execution to the proper
    receiver.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are many ways to implement the logic for routing the execution. It is
    important to notice that this pattern can be implemented on a larger scale depending
    on the context. For example, the invoker might not even be in the web client application
    and be on the server or on a different machine. We will see an implementation
    of this pattern in [*Chapter 8*](B18602_08.xhtml#_idTextAnchor186), *Multithreading
    with Web Workers*, where we use this pattern to process tasks between different
    threads and unload the main thread (where Vue 3 runs).
  prefs: []
  type: TYPE_NORMAL
- en: The proxy pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The definition for this pattern comes directly from its name, as the word “proxy”
    means something or someone who acts on behalf of another as if it was the same.
    That is a mouthful, but it will make you remember it. Let’s look into an example
    to clarify how this works. We will need at least three entities (components, objects,
    etc.):'
  prefs: []
  type: TYPE_NORMAL
- en: A **client** entity that needs to access the API of a target entity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **target** entity that exposes a well-known API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **proxy** object that sits in between and exposes the same API as the target
    while at the same time intercepting every communication from the client and relaying
    it to the target
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can graphically represent the relationship between these entities in this
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – The proxy object exposes the same API as the target](img/Figure_2.06_B18602.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – The proxy object exposes the same API as the target
  prefs: []
  type: TYPE_NORMAL
- en: 'The key factor for this pattern is that the proxy behaves and exposes the same
    API as the target, in such a way that the client does not know or doesn’t need
    to know that it is dealing with a proxy and not the target object directly. So,
    why would we want to do such a thing? There are many good reasons, such as the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to maintain the original unmodified API, but at the same time:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Need to process the inputs or outputs for the client
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Need to intercept each API call to add internal functionality, such as maintenance
    operations, performance improvements, error checking, and validation
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The target is an expensive resource, so a proxy could implement logic to leverage
    their operations (for example, a cache)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to change the client or the target but can’t modify the API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to maintain backward compatibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are more reasons that you may come across, but I hope that by now you
    can see how this can be useful. Being a pattern, this template can be implemented
    on multiple levels, from a simple object proxy to a full application or server.
    It is quite common when performing partial upgrades of a system or application.
    On a lower level, JavaScript even natively includes a constructor for proxying
    objects that Vue 3 uses internally to create reactivity.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 1*](B18602_01.xhtml#_idTextAnchor017), *The Vue 3 Framework*, we
    reviewed the options for reactivity with the `ref()` but this new version of Vue
    also includes another alternative for complex structures, called `reactive()`.
    The first one uses pub/sub methods (the observer pattern!), but the latter uses
    native proxy handlers (this pattern!). Let’s look into an example of how this
    native implementation may work with a naive partial implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this simple example, we will make an object with reactive properties automatically
    convert Celsius degrees to and back from Fahrenheit using a `Proxy` object:'
  prefs: []
  type: TYPE_NORMAL
- en: ./chapter 2/proxy-1.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s review the code line by line to see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: In this line, we declare the `temperature` object, which is going to be our
    target to be proxied. We initialize its two properties with an equal converted
    value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We declare a `handler` object, which will be our proxy for the temperature object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `set` function in the proxy handler receives three arguments: the target
    object, the key referred to, and the value attempted to be assigned. Notice that
    I say “attempted”, as the operation has been intercepted by the proxy.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On this line, we perform the assignment as intended to the object property.
    Here, we could have done other transformations or logic, such as validation or
    raised an event (the observer pattern again!).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice how we use a switch to filter the property names that we are interested
    in. When the key is `celsius`, we calculate and assign the value in Fahrenheit.
    The opposite happens when we receive an assignment for `fahrenheit` degrees. This
    is where the **reactivity** comes into play.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the `get` function, at least in this example, we just specifically return
    the value requested. In the way this is implemented, it would be the same as if
    we skip the `getter` function. However, it is here as an example that we could
    operate and transform the value to be returned as this operation is also intercepted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, in line 7, we declare the `degrees` object as the proxy for `temperature`
    with the handler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On this line, we test the reactivity by assigning a value in *Celsius* to the
    member of the `degrees` object, just like we normally would to any other object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we print the `degrees` object to the console, we notice that the `fahrenheit`
    property has been automatically updated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is a rather limited and simple example of how the native `Proxy()` constructor
    works and applies the pattern. Vue 3 has a more complex approach to reactivity
    and tracking dependencies, using the proxy and observer patterns. However, this
    gives us a good idea of what approach is happening behind the scenes when we see
    the HTML updated live in front of our very eyes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The concept of proxying between a client and a target is also related to the
    next two patterns: the *decorator and the façade patterns* since they are also
    a sort of proxy implementation. The distinguishing key factor is that the proxy
    retains the same API as the original target object.'
  prefs: []
  type: TYPE_NORMAL
- en: The decorator pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This pattern may, at first sight, seem very similar to the *proxy pattern*,
    and indeed it is, but it adds a few distinctive features that set it apart. It
    does have the same moving parts as the proxy, meaning there is a **Client**, a
    **Target**, and a **Decorator** in between that implements the same interface
    as the target (yes, just like in the proxy pattern). However, while in the *Proxy
    pattern* the intercepted API calls mainly deal with the data and internal maintenance
    (“housekeeping”), the decorator augments the functionality of the original object
    to do more. This is the defining factor that separates them.
  prefs: []
  type: TYPE_NORMAL
- en: In the proxy example, notice how the additional functionality was an *internal
    reactivity* to keep the degrees in each scale synchronized. When you change one,
    it internally and automatically updates the other. In a decorator pattern, the
    proxy object performs additional operations before, during, or after executing
    the API call to the target object. Just like in the proxy pattern, all of this
    is transparent for the client object.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, building on the previous code, imagine that now we want to log
    each call to the API of a certain target while keeping the same functionality.
    Graphically, it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – An example of a decorator that augments the target with a logging
    feature](img/Figure_2.07_B18602.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – An example of a decorator that augments the target with a logging
    feature
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, what was first a simple proxy, now by the mere act of performing a humble
    logging call, has now become a decorator. In the code, we only need to add this
    line before the end of the `set()` method (assuming there is also a function named
    `getTimeStamp()`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Of course, this is a simple example just to make a point. In the real world,
    decoratorsare very useful for adding functionality to your application without
    having to rewrite the logic or significant portions of your code. On top of this,
    decorators can be *stackable* or *chainable*, meaning that you can create “decorators
    for decorators” if needed, so each one will represent one step of added functionality
    that would maintain the same API of the target object. And just like that, we
    are beginning to step into the boundaries of a **middleware pattern**, but we
    will not cover it in this book. Anyway, the idea behind that other pattern is
    to create layers of middleware functions with a specified API, each one that performs
    one action, but with the difference that any step can decide to abort the operation,
    so the target may or may not be called. But that is another story... let’s get
    back to decorators.
  prefs: []
  type: TYPE_NORMAL
- en: Previously in this book, we mentioned that Vue 3 components do not have inheritance
    like plain JavaScript classes implemented by extending from one another. Instead,
    we can use the decorator pattern on components to add functionality or change
    the visual appearance. Let’s look at a brief example now, as we will see components
    and UI design in detail in [*Chapter 4*](B18602_04.xhtml#_idTextAnchor102), *User
    Interface Composition* *with Components*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider that we have the simplest of components that displays a humble `h1`
    tag with a title that receives the following as input:'
  prefs: []
  type: TYPE_NORMAL
- en: ./chapter 2/decorator-1.vue
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this simple component, we declare a single input named `label` in line `//1`.
    Don’t worry about the syntax for now, as we will see this in detail in [*Chapte**r
    4*](B18602_04.xhtml#_idTextAnchor102)*,* *User Interface Composition with Components.*
    On line `//2`, we are interpolating the value plainly inside the `h1` tags just
    as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to create a decorator for this component we need to apply the following
    simple rules:'
  prefs: []
  type: TYPE_NORMAL
- en: It has to act on behalf of the component (object)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has to respect the same API (inputs, outputs, function calls, etc.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has to augment the functionality or visual representation before, after,
    or during the execution of the target API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With that in mind, we can create a decorator component that intercepts the
    label attribute, changes it a bit, and also modifies the visual appearance of
    the target component:'
  prefs: []
  type: TYPE_NORMAL
- en: ./chapter 2/decorator-2.vue
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this code, in line `//1`, you can see that we keep the same interface as
    the target component (that we imported in the previous line), and then in line
    `//2`, we modify (augment) the `color` attribute and in line `//3` we are also
    modifying the data passed to the target component by adding three exclamation
    marks. With those simple tasks, we have kept the conditions to build a decorator
    pattern extrapolated to Vue 3 components. Not bad at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Decorators are very useful, but there is still one more proxy-like pattern
    that is also very common and handy: the façade pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: The façade pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By now, you may have seen the progressive pattern in these, well, patterns.
    We started with a proxy to act on behalf of another object or entity, we augmented
    it with the use of decorators while keeping the same API, and now is the turn
    for the façade pattern. Its job is, in addition to the functions of a proxy and
    decorator, to simplify the API and hide the large complexity behind it. So, a
    façade sits between a client and a target, but now the target is highly complex,
    being an object or even a system or multiple subsystems. This pattern is also
    used to change the API of an object or to limit the exposure to the client. We
    can picture the interactions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – A façade object simplifying the interaction with a complex API
    or system](img/Figure_2.08_B18602.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – A façade object simplifying the interaction with a complex API
    or system
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the main purpose of the façade is to offer a simpler approach
    to a complex interaction or API. We will use this pattern many times during our
    examples to simplify native implementations in the browser with more developer-friendly
    approaches. We will use libraries to encapsulate the use of IndexedDB and create
    our own simplified communication with web workers in [*Chapter 8*](B18602_08.xhtml#_idTextAnchor186),
    *Multithreading with* *Web Workers*.
  prefs: []
  type: TYPE_NORMAL
- en: Needless to say, you will have seen this pattern in action before, as it is
    one of the foundational concepts of modern technology. *Hiding complexity* behind
    a simple interface (API) is all around us and is a big part of web development.
    After all, the entire internet is extremely complicated, with thousands of moving
    parts, and the technology that makes up web pages is close to magic. Without this
    pattern, we would still be programming with zeros and ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, you will add layers of simplification to your own applications
    to break down complexity. One way to do it is to use third-party libraries that
    provide a simplified interface. In the following chapters, we will use some of
    these, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Axios**: To handle all **Asynchronous JavaScript and XML** (**AJAX**) communications
    with the server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DexieDB**: To handle the API to IndexedDB (the browser’s local database)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mitt**: To create event pipelines (we mentioned this in the Observer pattern)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vue 3**: To create amazing UIs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, there are façade libraries for most of the native implementations
    of web technologies, which are well battle tested. Developers are very good at
    simplifying these and sharing the code with others, thanks to the open source
    movement. Still, when using other people’s modules, make sure they are “safe.”
    Don’t reinvent the wheel, and don’t repeat yourself But now, it is time to move
    on to the next pattern in our list.
  prefs: []
  type: TYPE_NORMAL
- en: The callback pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The callback pattern is easy to understand. It applies when an operation needs
    to be executed after a **synchronous** or **asynchronous** operation has finished.
    For this, the function invocation includes, as one of the parameters, a function
    to be executed when the operations are completed. Having said that, we need to
    distinguish between the following two types of code flow:'
  prefs: []
  type: TYPE_NORMAL
- en: Synchronous operations are executed one after another in sequential order. It
    is the basic code flow, top to bottom.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous operations are executed out of the normal flow once invoked. Their
    length is uncertain, as well as their success or failure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is for asynchronous cases that the *callback pattern* is especially useful.
    Think, for example, of a network call. Once invoked, we don’t know how long it
    will take to get an answer from the server and whether it will succeed, fail,
    or throw an error. If we didn’t have asynchronous operations, our application
    would be *frozen*, waiting until a resolution happens. That would not be a good
    user experience, even though it would be computationally correct.
  prefs: []
  type: TYPE_NORMAL
- en: One important feature in JavaScript is that, being single-threaded, asynchronous
    functions don’t block the main thread allowing the execution to continue. This
    is important since the rendering functions of the browser run on the same thread.
    However, this is not free as they do consume resources, but they won’t freeze
    the UI, at least in theory. In practice, it will depend on a number of factors
    heavily influenced by the browser environment and the hardware. Still, let’s stick
    to the theory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example of a synchronous callback function and turn it asynchronous.
    The example function is very simple: we will calculate the Fibonacci value of
    a given number using the callback pattern. But first, a refresher on the formula
    for the calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'So, here is a JavaScript function that applies the formula and receives a callback
    to return the value. Notice that this function is synchronous:'
  prefs: []
  type: TYPE_NORMAL
- en: ./chapter 2/callback-1.js - Synchronous Fibonacci
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how instead of returning the value with `return`, we are passing it
    as a parameter to the `callback` function. When is it useful to use such a thing?
    Consider these simple examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Just by replacing the callback function, we can considerably alter how the
    result is presented. However, the example function has a fundamental flaw affecting
    the user experience. Being synchronous, the calculation time is proportional to
    the parameter passed: the larger `n`, the more time it will take. With a sufficiently
    large number, we can easily hang up the browser, but also, much before that, we
    can freeze the interface. You can test that the execution is synchronous with
    the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To turn this simple function into an asynchronous function, you can simply
    wrap the logic inside a `setImmediate` call. This will take the execution out
    of the normal workflow. The new function now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we use an arrow function to wrap up the code without any modifications.
    Now, see the difference when we execute the same snippet as before with this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see by the output, the snippet outputs `After` before `34`. This
    is because our asynchronous operation has been taken out of the normal flow as
    expected. When calling an asynchronous function, the execution *does not wait*
    for a result and continues executing the next instruction. This can be confusing
    at times but is very powerful and useful. However, the pattern does not prescribe
    how to handle errors or failed operations or how to chain or sequentially run
    multiple calls. There are different ways to deal with those cases, but they are
    not part of the pattern. There is another way to handle asynchronous operations
    that offers more flexibility and control: *promises.* We will see this next, and
    in most cases, you can use either pattern interchangeably. I say, “in most cases,”
    not all!'
  prefs: []
  type: TYPE_NORMAL
- en: The promise pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *promises pattern* is made primarily to deal with asynchronous operations.
    Just like with callbacks, the invocation of a promised function takes the execution
    out of the normal flow, but it returns a special object called `Promise`. This
    object exposes a simple API with three methods: `then`, `catch`, and `finally`:'
  prefs: []
  type: TYPE_NORMAL
- en: The `then` method receives two callback functions, traditionally called `resolve`
    and `reject`. They are used in the asynchronous code to return a successful value
    (`resolve`) or a failed or negative value (`reject`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `catch` method receives an `error` parameter and is triggered when the process
    throws an `error` and the execution is interrupted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `finally` method executes in either case and receives a callback function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While a promise is running, it is said to be in an *indeterminate* state until
    it is resolved or rejected. There is no time limit for how long a promise will
    wait in this state, something that makes it especially useful for lengthy operations
    such as network calls and **inter-process** **communication** (**IPC**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how to implement the previous example with the Fibonacci series using
    promises:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: At first sight, it is easy to see that the implementation has changed a bit.
    We start on line `//1` by immediately returning a `new Promise()` object. This
    constructor receives a callback function, that will, in turn, receive two callbacks
    named `resolve()` and `reject()`. We need to use these in our logic to return
    a value in case of success (`resolve`) or failure (`reject`). Also notice that
    we don’t have to wrap our code in a `setImmediate` function, as a promise is by
    nature asynchronous. We now check for negative numbers and then reject the operation
    in that case (line `//2`). The other change we make is to replace the `callback()`
    invocation for `resolve()` in lines`//3` and `//4`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The invocation now also changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we chain to the invocation, the `then` method, and pass to
    it the two functions for success and failure (`resolve` and `reject` in our code).
    Just like before, we get the same output. Now, this may seem more verbose (it
    is), but the benefits greatly outweigh the extra typing. Promises are chainable,
    meaning that for successful operations, you can return a new promise and, that
    way, have a sequential operation. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: There are other methods exposed by the `Promise` constructor, such as `.all`,
    but I will refer you to the documentation to dig deeper into the possibilities
    and syntax ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)).
    Still, quite verbose. Lucky for us, JavaScript provides us with a simplified syntax
    to handle promises, **async/await,** and think of them as a way to code in a more
    “traditional” way. This only applies to the invocation of promised functions and
    can only be used in functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this as an example, let’s imagine that we have three functions that
    return promises, named `MyFuncA`, `MyFuncB`, and `MyFuncC` (yes, I know, not the
    greatest names). Each one returns, in case of success, *one single value* (this
    is a condition). These are then used within `MyProcessFunction` with the new syntax.
    Here is the declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We start by declaring our function with the `async` keyword (line `//1`). This
    signals to the interpreter that we will use the `await` syntax inside our function.
    One condition is to wrap the code in a `try...catch` block. Then, we can use the
    `await` keyword in front of the invocation of each promised function call, as
    in line `//3`. By line `//4`, we are certain that each variable has received a
    value. Certainly, this approach is easier to follow and read.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s investigate the equivalences for the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This will match the *thenable* (using `.``then`) syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the problem with this last syntax is that we need to make sure that
    all the variables `a`, `b`, and `c` have values before we can run line `//4`,
    `console.log(a+b+c)`, which would mean chaining the invocations like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This format is harder to follow and certainly more verbose. For these cases,
    the `async/await` syntax is preferred.
  prefs: []
  type: TYPE_NORMAL
- en: The use of promises is great for wrapping lengthy or uncertain operations and
    integrating with other patterns that we have seen (façade, decorator, etc.). It
    is an important pattern to keep in mind that we will use extensively in our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen principles for software development and important
    design patterns, with examples in plain JavaScript and, when appropriate, hinted
    at implementations with Vue 3\. These patterns can be hard to grasp the first
    time you see them, but we will use them and return to them in the rest of the
    book so that this chapter will work as a reference. This will give you a better
    idea of when and how to apply different patterns according to the needs of your
    application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will start to implement a project from scratch and will
    set the foundations for the applications we will build in the rest of the book.
    As we move forward, we will reference these patterns to help you consolidate their
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Review questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between a principle and a pattern?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why is the singleton pattern so important?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can you manage dependencies?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What patterns make reactivity possible?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do patterns intertwine? Why? Can you give an example?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is asynchronous programming, and why is it so important?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can you think of use cases for *promised* functions?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
