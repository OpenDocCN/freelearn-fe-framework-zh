- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deferring Loader Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Executing data loading on the server can speed up initial page load times and
    improve core web vitals such as **Largest Contentful Paint** (**LCP**). However,
    server-side data fetching can also become a bottleneck if a request is particularly
    slow. For such cases, Remix provides an alternative data-fetching approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will work with Remix’s `defer` function and learn how to
    utilize HTTP and React streaming, React `Suspense`, and Remix’s `Await` component
    to defer slow loader data requests. This chapter is split into two sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Streaming data to the client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deferring loader data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, we will discuss the trade-offs of server-side data fetching and review
    the requirements for working with Remix’s `defer` function. Next, we will utilize
    Remix’s `defer` function in BeeRich and practice working with React `Suspense`
    and Remix’s `Await` component.
  prefs: []
  type: TYPE_NORMAL
- en: After reading this chapter, you will know how to use `defer` to improve the
    performance of your Remix applications. You will have also learned the requirements
    for working with HTTP and React streaming. Finally, you will understand the trade-offs
    of deferring loader data and know when to utilize `defer` in Remix.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to update some code before we can get started with this chapter. Please
    follow the steps in the `README.md` file in this chapter’s folder on GitHub before
    continuing. You can find the code for this chapter here: [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/13-deferring-loader-data](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/13-deferring-loader-data).'
  prefs: []
  type: TYPE_NORMAL
- en: Streaming data to the client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several different data-fetching strategies. We can initiate data fetching
    on the client using client-side `fetch` requests or execute data fetching on the
    server to take advantage of server-side rendering. We can even fetch data during
    build time for static site generations. In this section, we will discuss the trade-offs
    of server-side data fetching and review the requirements of HTTP streaming.
  prefs: []
  type: TYPE_NORMAL
- en: Motivating server-side data fetching and streaming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remix promotes fetching data on the server using `loader` functions for each
    route, as opposed to fetching data at the component level. During the initial
    page load, the `loader` functions are called before React renders on the server.
    This guarantees that the loader data is available for the server-side rendering
    step, eliminating the need for client-side data-fetching logic and loading states.
  prefs: []
  type: TYPE_NORMAL
- en: When initiating data fetching on the client, we first need to load the HTML
    document and then wait for the JavaScript bundles to download and execute before
    executing the required fetch requests. This results in three client-server roundtrips
    before the LCP is finalized. In comparison, we can paint the LCP after one client-server
    roundtrip with server-side data fetching and rendering. Reducing the number of
    client-server roundtrips almost always results in faster response times and improved
    core web vitals.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s run through an example to understand how server-side data fetching can
    improve the LCP of the initial page load. Assume we maintain an e-commerce web
    page for a product. The site shows an image of the product and some additional
    information about the product, such as the name of the product and its price.
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s assume we operate a client-side-only SPA. What happens once a user
    visits our web page?
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 13.1 – Client-side dat\uFEFFa-fetching waterfall](img/Figure_13.1_B17399.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 13.1 – Client-side data-fetching waterfall
  prefs: []
  type: TYPE_NORMAL
- en: 'As visible in *Figure 13**.1*, the following requests are executed from the
    browser:'
  prefs: []
  type: TYPE_NORMAL
- en: The browser requests the HTML document.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The browser requests scripts and other assets referenced in the document.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The React app is running and fetches the product information. The browser executes
    the fetch requests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The React app re-renders with the fetched data, and the browser requests assets
    linked in the HTML, such as the product images. The downloaded assets are used
    to paint the LCP.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We execute four subsequent requests to display the product image and finalize
    the LCP, each request adding to the request waterfall and delaying the LCP.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s assume we use Remix to render the product page. How many client requests
    are necessary to finalize the LCP?
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 13.2 – Server-side dat\uFEFFa-fetching waterfall](img/Figure_13.2_B17399.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 13.2 – Server-side data-fetching waterfall
  prefs: []
  type: TYPE_NORMAL
- en: 'As visible in *Figure 13**.2*, the following requests are executed from the
    browser:'
  prefs: []
  type: TYPE_NORMAL
- en: The browser requests the HTML document. The received document already includes
    the product information and image HTML element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The browser requests the product image together with the other linked assets.
    The downloaded assets are used to paint the LCP.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With server-side data fetching, we only require two client-server roundtrips
    to render the product page. This is a significant improvement.
  prefs: []
  type: TYPE_NORMAL
- en: What changed? Remix flattens the request waterfall by moving the data fetching
    to the server. This way, images and other assets can load parallel to the JavaScript
    bundles.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, this model may not work well when executing particularly slow
    requests in `loader` functions. Since we wait for all `loader` functions to finish
    before server-side rendering our React application, a slow request can become
    a bottleneck for our application and slow down initial page loads. In this case,
    we might want to look for alternative approaches.
  prefs: []
  type: TYPE_NORMAL
- en: One solution could be fetching the slow request from the client after the initial
    page has been downloaded from the server. However, this results in the request
    waterfall outlined earlier – further delaying the slow data response. Luckily,
    Remix provides a simple set of primitives to defer loading a promise and instead
    stream the response to the client.
  prefs: []
  type: TYPE_NORMAL
- en: Streaming allows us to send bytes to the client, even if the full response has
    not been finalized. React provides utilities to stream server-side-rendered content
    to the client. React will start sending pieces of the rendered content to the
    client while still awaiting other pieces. With `Suspense`, React can suspend component
    subtrees from rendering until a promise resolves. Remix builds on React `Suspense`
    to defer specific loader data requests using the `defer` function and the `Await`
    component.
  prefs: []
  type: TYPE_NORMAL
- en: Remix `loader` functions fetch data at the route level to avoid network waterfalls.
    If a request is particularly slow and in danger of becoming a bottleneck, we can
    pull another lever to defer that request. This is made possible by HTTP streaming
    and the web streaming API. In the next section, we will discuss the requirements
    to utilize HTTP streaming with Remix.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding HTTP streaming requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since Remix’s `defer` function uses HTTP and React streaming, we can only utilize
    it on a server environment that supports HTTP streaming responses. In this section,
    we will discuss the requirements for HTTP streaming and `defer`.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B17399_03.xhtml#_idTextAnchor043), *Deployment Targets, Adapters,
    and Stacks*, we learned how Remix utilizes adapters to run on different JavaScript
    runtimes and server environments. Some environments, such as traditional serverless
    environments, may not support streaming responses. This is important to remember
    when evaluating hosting providers and runtimes.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, a growing number of environments do support HTTP streaming, and
    by default, Remix is set up with React streaming. This is great even without using
    `defer` as it speeds up the initial document request. With HTTP streaming, the
    client can start receiving parts of the response without needing to wait for the
    full response to be finalized.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find out whether your Remix project is set up with React streaming, you
    can check the `app/entry.server.tsx` file in your Remix project. Search for the
    `renderToPipeableStream` function. If it is in use, you can be certain that React
    streaming is set up. Otherwise, you can follow Remix’s `defer` guide to set up
    React streaming: [https://remix.run/docs/en/2/guides/streaming](https://remix.run/docs/en/2/guides/streaming)
    (if your runtime and hosting environment supports it).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you can’t locate the `app/entry.server.tsx` file, it may be that you are
    using Remix''s default implementation and that you need to reveal it by executing
    the `npx remix reveal` command. You can learn more about the `entry.server.tsx`
    file in [*Chapter 2*](B17399_02.xhtml#_idTextAnchor030), *Creating a New Remix
    Project*, or in the Remix documentation: [https://remix.run/docs/en/2/file-conventions/entry.server](https://remix.run/docs/en/2/file-conventions/entry.server).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand how Remix uses HTTP and React streaming, let’s try it
    out in BeeRich. In the next section, we will practice working with Remix’s `defer`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Deferring loader data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not all payloads are equally important to the user. Some data may only appear
    below the page’s fold and is not immediately visible to the user. Other information
    may not be of primary content of the page but slow down the initial page load.
    For example, we may want to prioritize displaying the product information for
    an e-commerce site as fast as possible. However, we might be okay deferring the
    loading of the comments section to speed up the initial page load time. For this,
    Remix provides the `defer` and `Await` primitives. In this section, we will utilize
    Remix’s primitives with React `Suspense` in BeeRich to defer specific loader data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please review the `README.md` file on GitHub for this chapter if you haven’t
    already: [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/13-deferring-loader-data/bee-rich/README.md](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/13-deferring-loader-data/bee-rich/README.md).
    This file will guide you through setting up the new expense and invoice changelog.
    Now, let’s allow users to see the full history of all changes to their expenses
    and invoices:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by fetching the changelog data in the `dashboard.expenses.$id._index.tsx`
    route module’s `loader` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create an `ExpenseLogs` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the `useLoaderData` call in the route module component to access the
    `expenseLog` array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'import { H2, ExpenseLogs component below the edit expense form:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To avoid delaying the initial page load, utilize Remix’s `defer` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: return defer acts just as json when called with resolved data. The magic only
    starts happening once we defer an unresolved Promise.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remove the `await` keyword before the `expenseLog.findMany` call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that we also chain a `then` call at the end of the query. This is a trick
    to map `PrismaPromise`, which is returned by `findMany`, to an actual `Promise`
    object, as Remix’s `defer` function requires `Promise` instances.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Snap! We broke the page as `expenseLogs` is now of the `Promise` type. We need
    to update our React code so that it can work with deferred loader data. First,
    import `Suspense` from React and `Await` from Remix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <expenseLogs request. To inform Remix which promise we are awaiting, we must
    pass the expenseLogs loader data to Await. We can also pass Await an errorElement
    component in case the promise is rejected.We pass `Await` a callback function
    as its child component. Once the promise is resolved, `Await` will call the callback
    with the resolved data. This ensures that the `ExpenseLogs` component has access
    to the resolved `expenseLogs` data.Alternatively, we can access the resolved data
    by using Remix’s `useDeferredValue` hook within the child component.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run BeeRich locally and notice how the initial page load does not include the
    `expenseLogs` data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that you may need to delay the `expenseLogs` query for better visibility.
    Otherwise, the deferred loading might be too fast on localhost to capture.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `then` statement of the `expenseLogs` query in the `loader` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, inspect the deferred data loading in the UI and the `expenseLogs` data.
    Instead, the suspense fallback string is rendered. Once the `expenseLogs` promise
    resolves, the page re-renders with the `expenseLogs` data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that `defer` introduces a pending state in the UI. It is important to understand
    that this impacts the user experience. Introducing loading spinners should be
    considered a trade off for deferring loader data. We may introduce layout shifts
    once the data resolves that affect SEO as web crawlers may now parse the fallback
    UI.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, optimize the call order in the `loader` function. Move the expense logs
    query above the expense query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: From this, we can summarize that Remix provides us with a way to defer loader
    data per request. We can decide for each request whether we want to await or defer
    in the `loader` function.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that we broke the page before adding `Await` and `Suspense`. It is
    good practice to first add the `Await` and `Suspense` components to the page before
    returning promises with `defer` in the `loader` function. This will help you avoid
    errors while implementing `Await` and `Suspense`.
  prefs: []
  type: TYPE_NORMAL
- en: Practice using `defer` by applying the same changes to the income routes. Copy-paste
    and adapt the `ExpenseLogs` component into the `dashboard.income.$id._index.tsx`
    route module. Utilize the component and implement the same `defer`, `Suspense`,
    and `Await` flow as practiced in this chapter. Use `setTimeout` to test the user
    experience.
  prefs: []
  type: TYPE_NORMAL
- en: If you want more practice, add a `defer` and optimistic UI if you need more
    guidance.
  prefs: []
  type: TYPE_NORMAL
- en: Remix provides levers
  prefs: []
  type: TYPE_NORMAL
- en: Remix provides levers so that we can optimize the user experience based on our
    app’s requirements. When considering `defer`, it is important to remember that
    deferred data loading may also degrade the user experience by adding a pending
    UI and introducing loading spinners.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you practiced working with Remix’s `defer` and `Await` primitives.
    You now know how to use deferred response data streaming to optimize slow or secondary
    data requests but are aware that `defer` is a lever that impacts the user experience
    by introducing pending UIs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned that Remix supports different data-fetching strategies.
    Deferring loader data can be utilized to resolve performance bottlenecks in your
    Remix apps when fetching from slow endpoints. Remix’s `defer` function detects
    unresolved promises in the loader data and streams them to the client once resolved.
    React `Suspense` and Remix’s `Await` component are used to manage the deferred
    loader data in React.
  prefs: []
  type: TYPE_NORMAL
- en: You also learned that using `defer` requires fallback UIs to communicate loading
    states. You now understand that using `defer` comes with trade-offs that impact
    the user experience. On one hand, deferring loader data can speed up the initial
    document request. On the other hand, using `defer` creates loading UIs, which
    results in a different user experience.
  prefs: []
  type: TYPE_NORMAL
- en: After reading this chapter, you know that Remix uses React streaming to speed
    up document requests. However, React and HTTP streaming are not supported on all
    server runtimes and environments. Conclusively, not all Remix adapters support
    React streaming. Since Remix’s `defer` function takes advantage of React `Suspense`
    and React streaming, deferring loader data only works when React streaming is
    supported and set up.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you practiced deferring loader data by implementing an expense changelog
    in BeeRich.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will extend the changelog implementation and add real-time
    data responses with **Server-Sent** **Events** (**SSE**).
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can read more about the Streams API via MDN Web Docs: [https://developer.mozilla.org/en-US/docs/Web/API/Streams_API](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Remix documentation includes a guide for streaming and `defer`: [https://remix.run/docs/en/2/guides/streaming](https://remix.run/docs/en/2/guides/streaming).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `defer` function’s documentation can be found here: [https://remix.run/docs/en/2/utils/defer](https://remix.run/docs/en/2/utils/defer).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we discussed core web vitals. You can read more about core
    web vitals, such as LCP, here: [https://web.dev/vitals/](https://web.dev/vitals/).'
  prefs: []
  type: TYPE_NORMAL
