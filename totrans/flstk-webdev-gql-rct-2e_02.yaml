- en: '*Chapter 1*: Preparing Your Development Environment'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第一章*：准备你的开发环境'
- en: The application we are going to build in this book will be a simplified version
    of Facebook, called **Graphbook**. We will allow our users to sign up and log
    in to read and write posts and chat with friends, similar to what we can do on
    common social networks.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将构建一个简化版的Facebook，称为**Graphbook**。我们将允许用户注册和登录，以阅读和撰写帖子并与朋友聊天，类似于我们在常见的社交网络上所能做的。
- en: When developing an application, being well-prepared is always a requirement.
    However, before we start, we need to put our stack together. In this chapter,
    we will explore whether our techniques work well with our development process,
    what we need before getting started, and which tools can help us when building
    software.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发应用程序时，做好充分的准备始终是一个要求。然而，在我们开始之前，我们需要将我们的栈组合起来。在本章中，我们将探讨我们的技术是否与我们的开发过程很好地配合，在开始之前我们需要什么，以及哪些工具可以帮助我们在构建软件时。
- en: This chapter explains the architecture for our application by going through
    the core concepts, the complete process, and preparing for a working React setup.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过介绍核心概念、完整流程和准备一个可工作的React设置，解释了我们应用程序的架构。
- en: 'This chapter covers the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Architecture and technology
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构和技术
- en: Thinking critically about how to architect a stack
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仔细思考如何构建栈的架构
- en: Building the React and GraphQL stack
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建React和GraphQL栈
- en: Installing and configuring Node.js
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和配置Node.js
- en: Setting up a React development environment with webpack, Babel, and other requirements
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用webpack、Babel和其他要求设置React开发环境
- en: Debugging React applications using Chrome DevTools and React Developer Tools
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Chrome DevTools和React Developer Tools调试React应用程序
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The source code for this chapter is available in the following GitHub repository:
    [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter01](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter01).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可在以下GitHub仓库中找到：[https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter01](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter01)。
- en: Understanding the application architecture
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解应用程序架构
- en: 'Since its initial release in 2015, GraphQL has become the new alternative to
    the standard SOAP and REST APIs. GraphQL is a specification, like SOAP and REST,
    that you can follow to structure your application and data flow. It is so innovative
    because it allows you to query specific fields of entities, such as users and
    posts. This functionality makes it very good for targeting multiple platforms
    at the same time. Mobile apps may not need all the data that''s displayed inside
    the browser on a desktop computer. The query you send consists of a JSON-like
    object that defines which information your platform requires. For example, a query
    for a `post` may look like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 自从2015年首次发布以来，GraphQL已经成为了标准SOAP和REST API的新替代品。GraphQL是一个规范，就像SOAP和REST一样，你可以遵循它来构建你的应用程序和数据流。它之所以创新，是因为它允许你查询实体的特定字段，例如用户和帖子。这种功能使其非常适合同时针对多个平台。移动应用可能不需要在桌面计算机浏览器中显示的所有数据。你发送的查询由一个类似于JSON的对象组成，该对象定义了你的平台需要哪些信息。例如，一个针对`post`的查询可能看起来像这样：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: GraphQL resolves the correct entities and data, as specified in your query object.
    Every field in GraphQL represents a function that resolves to a value. Those functions
    are called **Resolver functions**. The return value could be just the corresponding
    database value, such as the name of a user, or it could be a date, which is formatted
    by your server before returning it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL根据你的查询对象中指定的正确实体和数据解决问题。GraphQL中的每个字段都代表一个解析到值的函数。这些函数被称为**解析函数**。返回值可以是相应的数据库值，例如用户的姓名，也可以是一个日期，该日期在返回之前由你的服务器格式化。
- en: GraphQL is completely database agnostic and can be implemented in any programming
    language. To skip the step of implementing a GraphQL library, we are going to
    use Apollo, which is a GraphQL server for the Node.js ecosystem. Thanks to the
    team behind Apollo, this is very modular. Apollo works with many of the common
    Node.js frameworks, such as Hapi, Koa, and Express.js.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL完全与数据库无关，可以在任何编程语言中实现。为了跳过实现GraphQL库的步骤，我们将使用Apollo，这是一个Node.js生态系统的GraphQL服务器。多亏了Apollo背后的团队，这使得它非常模块化。Apollo与许多常见的Node.js框架一起工作，例如Hapi、Koa和Express.js。
- en: We are going to use Express.js as our basis because it is used on a wide scale
    in the Node.js and GraphQL communities. GraphQL can be used with multiple database
    systems and distributed systems to offer a straightforward API over all your services.
    It allows developers to unify existing systems and handle data fetching for client
    applications.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Express.js作为我们的基础，因为它在Node.js和GraphQL社区中被广泛使用。GraphQL可以与多个数据库系统和分布式系统一起使用，为所有服务提供一个简单的API。它允许开发者统一现有系统并处理客户端应用程序的数据获取。
- en: How you combine your databases, external systems, and other services into one
    server backend is up to you. In this book, we are going to use a MySQL server
    via Sequelize as our data storage. SQL is the most well-known and commonly used
    database query language, and with Sequelize, we have a modern client library for
    our Node.js server to connect with our SQL server.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如何将你的数据库、外部系统和其他服务组合成一个服务器后端取决于你。在这本书中，我们将使用Sequelize通过MySQL服务器作为我们的数据存储。SQL是最知名且最常用的数据库查询语言，而通过Sequelize，我们有一个现代客户端库，用于我们的Node.js服务器连接到我们的SQL服务器。
- en: HTTP is the standard protocol for accessing a GraphQL API. It also applies to
    Apollo Servers. However, GraphQL is not fixed to one network protocol. Everything
    we have mentioned so far is everything important for the backend.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP是访问GraphQL API的标准协议。它也适用于Apollo服务器。然而，GraphQL并不固定于一种网络协议。我们之前提到的所有内容都是后端的重要部分。
- en: When we get to the frontend of our **Graphbook** application, we are mainly
    going to use React. React is a JavaScript UI framework that was released by Facebook
    that has introduced many techniques that are now commonly used for building interfaces
    on the web, as well as on native environments.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们到达我们的**Graphbook**应用程序的前端时，我们将主要使用React。React是由Facebook发布的一个JavaScript UI框架，它引入了许多现在常用于在网络上以及原生环境中构建界面的技术。
- en: Using React comes with a bunch of significant advantages. When building a React
    application, you always split your code into many components, targeting their
    efficiency and ability to be reused. Of course, you can do this without using
    React, but it makes it very easy. Furthermore, React teaches you how to update
    application states, as well as the UI, reactively. You never update the UI and
    then the data separately.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用React带来了一系列显著的优势。在构建React应用程序时，你总是将代码拆分成许多组件，以提高它们的效率和可重用性。当然，你可以在不使用React的情况下这样做，但React使这变得非常容易。此外，React教你如何以响应式的方式更新应用程序状态以及UI。你永远不会分别更新UI和数据。
- en: React makes rerendering very efficient by using a virtual DOM, which compares
    the virtual and actual DOM and updates it accordingly. Only when there is a difference
    between the virtual and real DOM does React apply these changes. This logic stops
    the browser from recalculating the layout, **Cascading Style Sheets** (**CSS**),
    and other computations that negatively impact the overall performance of your
    application.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: React通过使用虚拟DOM，将虚拟DOM和实际DOM进行比较并相应地更新，从而使得重新渲染非常高效。只有当虚拟DOM和实际DOM之间存在差异时，React才会应用这些更改。这种逻辑阻止了浏览器重新计算布局、**层叠样式表**（**CSS**）以及其他影响应用程序整体性能的计算。
- en: Throughout this book, we are going to use the Apollo client library. It naturally
    integrates with React and our Apollo Server.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将使用Apollo客户端库。它自然地与React和我们的Apollo服务器集成。
- en: If we put all this together, the result is the main stack consisting of Node.js,
    Express.js, Apollo, SQL, Sequelize, and React.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将所有这些放在一起，结果就是由Node.js、Express.js、Apollo、SQL、Sequelize和React组成的主堆栈。
- en: The basic setup
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本设置
- en: 'The basic setup for making an application work is the logical request flow,
    which looks as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使应用程序工作的基本设置是逻辑请求流程，如下所示：
- en: '![Figure 1.1 – Logical request workflow'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.1 – 逻辑请求流程'
- en: '](img/Figure_1.1_B17337.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.1_B17337.jpg)'
- en: Figure 1.1 – Logical request workflow
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – 逻辑请求流程
- en: 'Here is how the logical request flow works:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何工作的逻辑请求流程：
- en: The client requests our site.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端请求我们的网站。
- en: The Express.js server handles these requests and serves a static HTML file.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Express.js服务器处理这些请求并服务一个静态HTML文件。
- en: The client downloads all the necessary files, according to this HTML file. The
    files also include a bundled JavaScript file.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端根据这个HTML文件下载所有必要的文件，这些文件还包括一个捆绑的JavaScript文件。
- en: This bundled JavaScript file is our React application. After executing all the
    JavaScript code from this file, all the required Ajax alias GraphQL requests are
    made to our Apollo Server.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个捆绑的 JavaScript 文件是我们的 React 应用程序。在执行完这个文件中的所有 JavaScript 代码后，所有必要的 Ajax 别名
    GraphQL 请求都会发送到我们的 Apollo 服务器。
- en: Express.js receives the requests and passes them to our Apollo endpoint.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Express.js 接收请求并将它们传递给我们的 Apollo 端点。
- en: Apollo queries all the requested data from all the available systems, such as
    our SQL server or third-party services, merges the data, and sends it back as
    JSON.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Apollo 从所有可用的系统中查询所有请求的数据，例如我们的 SQL 服务器或第三方服务，合并数据，并以 JSON 格式发送回来。
- en: React can render the JSON data as HTML.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React 可以将 JSON 数据渲染为 HTML。
- en: This workflow is the basic setup for making an application work. In some cases,
    it makes sense to offer server-side rendering for our client. The server would
    need to render and send all `XMLHttpRequests` itself before returning the HTML
    to the client. The user will save doing one or more round trips if the server
    sends the requests on the initial load. We will focus on this topic later in this
    book, but that is the application architecture in a nutshell. With that in mind,
    let's get hands-on and set up our development environment.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工作流程是使应用程序工作的基本设置。在某些情况下，为我们的客户端提供服务器端渲染是有意义的。服务器需要在返回 HTML 给客户端之前自己渲染并发送所有的
    `XMLHttpRequests`。如果服务器在初始加载时发送请求，用户将节省一次或多次往返。我们将在本书的后面部分关注这个主题，但这就是应用程序架构的精髓。考虑到这一点，让我们动手设置我们的开发环境。
- en: Installing and configuring Node.js
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和配置 Node.js
- en: 'The first step of preparing our project is to install Node.js. There are two
    ways to do this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 准备我们的项目的第一步是安装 Node.js。有两种方法可以做到这一点：
- en: One option is to install **Node Version Manager** (**NVM**). The benefit of
    using NVM is that you can easily run multiple versions of Node.js side by side,
    which handles the installation process for you on nearly all UNIX-based systems,
    such as Linux and macOS. Within this book, we do not need the option to switch
    between different versions of Node.js.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种选项是安装 **Node 版本管理器**（**NVM**）。使用 NVM 的好处是您可以在几乎所有的 UNIX 基础系统（如 Linux 和 macOS）上轻松地并行运行多个
    Node.js 版本，它为您处理安装过程。在这本书中，我们不需要在不同版本的 Node.js 之间切换的选项。
- en: The other option is to install Node.js via the package manager of your distribution
    if you are using Linux. The official PKG file is for Mac, while the MSI file is
    for Windows. We are going to use the regular Linux package manager for this book
    as it is the easiest method.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个选项是如果您使用 Linux，可以通过您发行版的包管理器安装 Node.js。官方的 PKG 文件适用于 Mac，而 MSI 文件适用于 Windows。我们将在这本书中使用常规的
    Linux 包管理器，因为它是最简单的方法。
- en: Note
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the **Downloads** section of Node.js at the following link: [https://nodejs.org/en/download/](https://nodejs.org/en/download/).'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以在以下链接找到 Node.js 的 **下载** 部分：[https://nodejs.org/en/download/](https://nodejs.org/en/download/).
- en: We are going to be using the second option here. It covers the regular server
    configurations and is easy to understand. I will keep this as short as possible
    and skip all the other options, such as Chocolatey for Windows and Brew for Mac,
    which are very specialized for those specific operating systems.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里使用第二个选项。它涵盖了常规的服务器配置，并且易于理解。我会尽量简短，并跳过所有其他选项，例如针对 Windows 的 Chocolatey
    和针对 Mac 的 Brew，这些选项非常特定于那些操作系统。
- en: I assume that you are using a Debian-based system for ease of use with this
    book. It has got the normal APT package manager and repositories for easily installing
    Node.js and MySQL. If you are not using a Debian-based system, you can look up
    the matching commands to install Node.js at [https://nodejs.org/en/download/package-manager/](https://nodejs.org/en/download/package-manager/).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设您使用基于 Debian 的系统，以便于使用这本书。它具有正常的 APT 包管理器和用于轻松安装 Node.js 和 MySQL 的仓库。如果您不是使用基于
    Debian 的系统，您可以在 [https://nodejs.org/en/download/package-manager/](https://nodejs.org/en/download/package-manager/)
    查找安装 Node.js 的匹配命令。
- en: 'Our project is going to be new so that we can use Node.js 14, which is the
    current LTS version:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目将是新的，这样我们就可以使用 Node.js 14，这是当前的 LTS 版本：
- en: 'First, let''s add the correct repository for our package manager by running
    the following command:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们通过运行以下命令添加我们的包管理器的正确仓库：
- en: '[PRE1]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we must install Node.js and the build tools for native modules using
    the following command:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须使用以下命令安装 Node.js 和用于原生模块的构建工具：
- en: '[PRE2]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, let''s open a Terminal and verify that the installation was successful:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们打开一个终端并验证安装是否成功：
- en: '[PRE3]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Installing Node.js via the package manager will automatically install npm.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过包管理器安装Node.js将自动安装npm。
- en: Great! You are now set to run server-side JavaScript with Node.js and install
    Node.js modules for your projects with npm.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！你现在可以运行Node.js的服务器端JavaScript，并使用npm为你的项目安装Node.js模块。
- en: All the dependencies that our project relies on are available at [https://npmjs.com](https://npmjs.com)
    and can be installed with npm or Yarn. We will rely on npm as it is more widely
    used than Yarn. So, let's continue and start using npm to set up our project and
    its dependencies.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们项目所依赖的所有依赖项都可在[https://npmjs.com](https://npmjs.com)找到，并可以使用npm或Yarn进行安装。我们将依赖npm，因为它比Yarn更广泛地被使用。所以，让我们继续，并开始使用npm来设置我们的项目和其依赖项。
- en: Setting up React
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置React
- en: 'The development environment for our project is ready. In this section, we are
    going to install and configure React, which is the primary aspect of this chapter.
    Let''s start by creating a new directory for our project:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们项目的开发环境已经准备好了。在本节中，我们将安装和配置React，这是本章的主要内容。让我们首先为我们的项目创建一个新的目录：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Our project will use Node.js and many npm packages. We will create a `package.json`
    file to install and manage all the dependencies for our project. It stores information
    about the project, such as the version number, name, dependencies, and much more.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目将使用Node.js和许多npm包。我们将创建一个`package.json`文件来安装和管理我们项目的所有依赖项。它存储有关项目的信息，如版本号、名称、依赖项等。
- en: 'Just run `npm init` to create an empty `package.json` file:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 只需运行`npm init`来创建一个空的`package.json`文件：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: npm will ask some questions, such as asking for the package name, which is,
    in fact, the project name. Enter `Graphbook` to insert the name of your application
    in the generated `package.json` file.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: npm会询问一些问题，例如询问包名，实际上就是项目名。输入`Graphbook`以在生成的`package.json`文件中插入你的应用程序名称。
- en: I prefer to start with version number 0.0.1 since the default version number
    that npm offers with 1.0.0 represents the first stable release for me. However,
    it is your choice regarding which version you use here.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢从版本号0.0.1开始，因为npm提供的默认版本号1.0.0对我来说代表的是第一个稳定版本。然而，关于你在这里使用哪个版本，这是你的选择。
- en: 'You can skip all the other questions by pressing the *Enter* key to save the
    default values of npm. Most of them are not relevant because they just provide
    information such as a description or the link to the repository. We are going
    to fill in the other fields, such as the scripts, while working through this book.
    You can see an example of the command line in the following screenshot:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过按*Enter*键来跳过所有其他问题，以保存npm的默认值。其中大部分都不相关，因为它们只是提供信息，如描述或仓库链接。我们将在本书的工作过程中填写其他字段，如脚本。你可以在下面的屏幕截图中看到一个命令行的示例：
- en: '![Figure 1.2 – npm project setup'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.2 – npm项目设置'
- en: '](img/Figure_1.2_B17337.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.2 – npm项目设置'
- en: Figure 1.2 – npm project setup
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 1.2 – npm项目设置
- en: 'The first and most crucial dependency for this book is React. Use npm to add
    React to our project:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的第一个也是最重要的依赖项是React。使用npm将React添加到我们的项目中：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This command installs two npm packages from [https://npmjs.com](https://npmjs.com)
    into our project folder under `node_modules`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令从[https://npmjs.com](https://npmjs.com)安装了两个npm包到我们的项目文件夹下的`node_modules`。
- en: npm automatically edited our `package.json` file since we provided the `--save`
    option and added those packages with the latest available version numbers.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们提供了`--save`选项并添加了这些包的最新版本号，npm自动编辑了我们的`package.json`文件。
- en: You might be wondering why we installed two packages, even though we only needed
    React. The `react` package only provides React-specific methods. All React Hooks,
    such as `componentDidMount`, `useState`, and even React's component class, come
    from this package. You need this package to write any React application.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们安装了两个包，尽管我们只需要React。`react`包只提供React特定的方法。所有React Hooks，如`componentDidMount`、`useState`，甚至React的组件类，都来自这个包。你需要这个包来编写任何React应用程序。
- en: In most cases, you won't even notice that you have used `react-dom`. This package
    offers all the functions to connect the actual DOM of the browser to your React
    application. Usually, you use `ReactDOM.render` to render your application at
    a specific point in your HTML and only once in your code. We will cover how to
    render React later in this book.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你甚至不会注意到你已经使用了`react-dom`。这个包提供了将浏览器实际DOM连接到你的React应用程序的所有功能。通常，你使用`ReactDOM.render`在HTML的特定位置渲染你的应用程序，并且只在你代码中渲染一次。我们将在本书的后面部分介绍如何渲染React。
- en: There is also a function called `ReactDOM.findDOMNode`, which gives you direct
    access to a DOMNode, but I strongly discourage using this since any changes on
    DOMNodes are not available in React itself. I have never needed to use this function,
    so try to avoid it if possible. Now, that our npm project has been set up and
    the two main dependencies have been installed, we need to prepare an environment
    that bundles all the JavaScript files we are going to write. We will focus on
    this in the next section.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个名为`ReactDOM.findDOMNode`的函数，它为你提供了对DOMNode的直接访问，但我强烈建议不要使用这个函数，因为DOMNodes上的任何更改在React本身中都是不可用的。我从未需要使用这个函数，所以如果可能的话，尽量避免使用它。现在，我们的npm项目已经设置好，两个主要依赖项也已经安装，我们需要准备一个环境来打包我们将要编写的所有JavaScript文件。我们将在下一节中关注这一点。
- en: Preparing and configuring webpack
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备和配置webpack
- en: 'Our browser requests an `index.html` file when accessing our application. It
    specifies all the files that are required to run our application. We need to create
    this `index.html` file, which we serve as the entry point of our application:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的浏览器访问我们的应用程序时，它会请求一个`index.html`文件。它指定了运行我们的应用程序所需的所有文件。我们需要创建这个`index.html`文件，并将其作为我们应用程序的入口点：
- en: 'Create a separate directory for our `index.html` file:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的`index.html`文件创建一个单独的目录：
- en: '[PRE7]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, save this inside `index.html`:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将以下内容保存到`index.html`中：
- en: '[PRE8]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, no JavaScript is loaded here. There is only one `div` tag with
    the `root` ID. This `div` tag is the DOMNode that our application will be rendered
    in by `ReactDOM`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这里没有加载任何JavaScript。只有一个带有`root` ID的`div`标签。这个`div`标签是`ReactDOM`将我们的应用程序渲染到的DOMNode。
- en: So, how do we get React up and running with this `index.html` file?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何使用这个`index.html`文件来启动React呢？
- en: To accomplish this, we need to use a web application bundler, which will prepare
    and bundle all our application assets. All the required JavaScript files and `node_modules`
    are bundled and minified; SASS and SCSS preprocessors are transpiled to CSS, as
    well as being merged and minified.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们需要使用一个网络应用程序打包器，它将准备和打包我们所有的应用程序资源。所有必需的JavaScript文件和`node_modules`都被打包和压缩；SASS和SCSS预处理器被转换为CSS，并且也被合并和压缩。
- en: 'A few application bundler packages are available, including webpack, Parcel,
    and Gulp. For our use case, we will use webpack. It is the most common module
    bundler and has a large community surrounding it. To bundle our JavaScript code,
    we need to install webpack and all its dependencies, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个应用程序打包器包可用，包括webpack、Parcel和Gulp。对于我们的用例，我们将使用webpack。它是最常见的模块打包器，并且有一个庞大的社区。为了打包我们的JavaScript代码，我们需要安装webpack及其所有依赖项，如下所示：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This command adds all the development tools to `devDependencies` in the `package.json`
    file. We will need these to bundle our application. They are only installed in
    a development environment and are skipped in production.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将所有开发工具添加到`package.json`文件中的`devDependencies`。我们需要这些工具来打包我们的应用程序。它们仅在开发环境中安装，并在生产中跳过。
- en: If you are not already aware, setting up webpack can be a bit of a hassle. Many
    options can interfere with each other and lead to problems when you're bundling
    your application. Now, let's create a `webpack.client.config.js` file in the root
    folder of your project.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还不知道，设置webpack可能有点麻烦。许多选项可能会相互干扰，并在你打包应用程序时导致问题。现在，让我们在项目的根目录中创建一个`webpack.client.config.js`文件。
- en: 'Enter the following code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下代码：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The webpack configuration file is just a regular JavaScript file where you
    can require `node_modules` and custom JavaScript files. This is the same as everywhere
    else inside Node.js. Let''s quickly go through all of the main properties of this
    configuration. Understanding these will make future custom webpack configs much
    easier. All the important points are explained here:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: webpack配置文件只是一个普通的JavaScript文件，你可以在这里require `node_modules`和自定义JavaScript文件。这和Node.js内部的任何地方都一样。让我们快速浏览一下这个配置的所有主要属性。理解这些将使未来的自定义webpack配置变得容易得多。所有重要点都在这里解释：
- en: '`HtmlWebpackPlugin`: This automatically generates an HTML file that includes
    all the webpack bundles. We pass our previously created `index.html` as a template.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HtmlWebpackPlugin`：这会自动生成一个包含所有webpack打包的HTML文件。我们传递之前创建的`index.html`作为模板。'
- en: '`CleanWebpackPlugin`: This empties all of the provided directories to clean
    the old build files. The `cleanOnceBeforeBuildPatterns` property specifies an
    array of folders that are cleaned before the build process is started.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CleanWebpackPlugin`：这会清空所有提供的目录以清理旧的构建文件。`cleanOnceBeforeBuildPatterns`属性指定了一个在构建过程开始之前被清理的文件夹数组。'
- en: The `entry` field tells webpack where the starting point of our application
    is. This file needs to be created by us.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entry` 字段告诉 webpack 我们应用程序的起点在哪里。这个文件需要我们创建。'
- en: The `output` object specifies how our bundle is called and where it should be
    saved. For us, this is `dist/client/bundle.js`.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`output` 对象指定了我们的包是如何命名的以及它应该保存的位置。对我们来说，这是 `dist/client/bundle.js`。'
- en: Inside `module.rules`, we match our file extensions with the correct loaders.
    All the JavaScript files (except those located in `node_modules`) are transpiled
    by Babel as specified by `babel-loader` so that we can use ES6 features inside
    our code. Our CSS gets processed by `style-loader` and `css-loader`. There are
    many more loaders for JavaScript, CSS, and other file extensions available.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `module.rules` 中，我们将我们的文件扩展名与正确的加载器匹配。所有 JavaScript 文件（除了位于 `node_modules`
    中的文件）都由 `babel-loader` 转译，以便我们可以在代码中使用 ES6 特性。我们的 CSS 由 `style-loader` 和 `css-loader`
    处理。还有许多其他用于 JavaScript、CSS 和其他文件扩展名的加载器可用。
- en: The `devServer` feature of webpack enables us to run the React code directly.
    This includes hot reloading code in the browser without rerunning a build or refreshing
    the browser tab.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: webpack 的 `devServer` 功能使我们能够直接运行 React 代码。这包括在浏览器中无需重新运行构建或刷新浏览器标签页的情况下热重载代码。
- en: Note
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you need a more detailed overview of the webpack configuration, have a look
    at the official documentation: [https://webpack.js.org/concepts/](https://webpack.js.org/concepts/).'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您需要 webpack 配置的更详细概述，请查看官方文档：[https://webpack.js.org/concepts/](https://webpack.js.org/concepts/)。
- en: 'With this in mind, let''s move on. We are missing the `src/client/index.js`
    file from our webpack configuration, so let''s create it, as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们继续前进。我们在 webpack 配置中缺少 `src/client/index.js` 文件，所以让我们创建它，如下所示：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can leave this file empty for the moment. It can be bundled by webpack without
    content inside. We are going to change it later in this chapter.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以暂时留空这个文件。它可以在没有内容的情况下由 webpack 打包。我们将在本章的后面更改它。
- en: To spin up our development webpack server, we will add a command to `package.json`
    that we can run using `npm`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启动我们的开发 webpack 服务器，我们将在 `package.json` 中添加一个命令，我们可以使用 `npm` 来运行。
- en: 'Add the following line to the `scripts` object inside `package.json`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下行添加到 `package.json` 中的 `scripts` 对象：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, execute `npm run client` in your console and watch how a new browser window
    opens. We are running `webpack serve` with the newly created configuration file.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在您的控制台中执行 `npm run client` 并观察新浏览器窗口的打开。我们正在使用新创建的配置文件运行 `webpack serve`。
- en: Sure, the browser is still empty, but if you inspect the HTML with Chrome DevTools,
    you will see that we have already got a `bundle.js` file and that our `index.html`
    file was taken as a template.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，浏览器仍然是空的，但如果你用 Chrome DevTools 检查 HTML，你会看到我们已经有了一个 `bundle.js` 文件，并且我们的
    `index.html` 文件被用作模板。
- en: With that, we've learned how to include our empty `index.js` file with the bundle
    and serve it to the browser. Next, we'll render our first React component inside
    our template `index.html` file.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们已经学会了如何将空的 `index.js` 文件包含在包中并服务于浏览器。接下来，我们将在模板 `index.html` 文件中渲染第一个
    React 组件。
- en: Rendering your first React component
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染第一个 React 组件
- en: There are many best practices for React. The central philosophy behind it is
    to split our code into separate components where possible. We are going to cover
    this approach in more detail in [*Chapter 5*](B17337_05_Final_ASB_ePub.xhtml#_idTextAnchor123),
    *Reusable React Components and React Hooks*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 React 来说，有许多最佳实践。其背后的核心哲学是在可能的情况下将我们的代码拆分为单独的组件。我们将在 [*第 5 章*](B17337_05_Final_ASB_ePub.xhtml#_idTextAnchor123)，*可重用
    React 组件和 React Hooks* 中更详细地介绍这种方法。
- en: Our `index.js` file is the main starting point of our frontend code, and this
    is how it should stay. Do not include any business logic in this file. Instead,
    keep it as clean and slim as possible.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `index.js` 文件是前端代码的主要起点，这就是它应该保持的样子。不要在这个文件中包含任何业务逻辑。相反，尽量保持它尽可能干净和精简。
- en: 'The `index.js` file should include the following code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.js` 文件应包含以下代码：'
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The release of *ECMAScript 2015* introduced the `import` feature. We can use
    it to load our `npm` packages – `react` and `react-dom` – and our first custom
    React component, which we must write now.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*ECMAScript 2015* 的发布引入了 `import` 功能。我们可以使用它来加载我们的 `npm` 包——`react` 和 `react-dom`——以及我们的第一个自定义
    React 组件，我们必须现在编写它。'
- en: Of course, we need to cover the traditional `Hello World` program.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们需要涵盖传统的 `Hello World` 程序。
- en: 'Create the `App.js` file next to your `index.js` file and ensure it contains
    the following content:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的 `index.js` 文件旁边创建 `App.js` 文件，并确保它包含以下内容：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we exported a single stateless function called `App` that is then imported
    by the `index.js` file. As we explained previously, we are now actively using
    `ReactDOM.render` in our `index.js` file.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们导出了一个名为 `App` 的单个无状态函数，然后由 `index.js` 文件导入。正如我们之前解释的，我们现在正在积极地在 `index.js`
    文件中使用 `ReactDOM.render`。
- en: The first parameter of `ReactDOM.render` is the component or function that we
    want to render, which is the exported function displaying the `DOMNode`, where
    it should render. We receive `DOMNode` with a plain `document.getElementById`
    JavaScript.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReactDOM.render` 的第一个参数是我们想要渲染的组件或函数，这是显示 `DOMNode` 的导出函数，它应该在那里渲染。我们通过一个简单的
    `document.getElementById` JavaScript 接收 `DOMNode`。'
- en: We defined our root element when we created the `index.html` file. After saving
    the `App.js` file, webpack will try to build everything again. However, it should
    not be able to do that. webpack will encounter a problem when bundling our `index.js`
    file because of the `<App />` tag syntax we are using in the `ReactDOM.render`
    method. It was not transpiled to a normal JavaScript function.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建 `index.html` 文件时，我们定义了我们的根元素。保存 `App.js` 文件后，webpack 将尝试重新构建一切。然而，它不应该能够做到这一点。webpack
    在打包我们的 `index.js` 文件时将遇到问题，因为我们使用 `ReactDOM.render` 方法中的 `<App />` 标签语法，它没有被转换为正常的
    JavaScript 函数。
- en: We configured webpack to load Babel for our JavaScript file but did not tell
    Babel what to transpile and what not to transpile.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们配置了 webpack 来加载 Babel 以处理我们的 JavaScript 文件，但没有告诉 Babel 要转换什么以及不要转换什么。
- en: 'Let''s create a `.babelrc` file in the root folder that contains the following
    content:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在根目录中创建一个 `.babelrc` 文件，其中包含以下内容：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You may have to restart the server because the `.babelrc` file is not reloaded
    when changes are made to the file. After a few moments, you should see the standard
    **Hello World!** message in your browser.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要重新启动服务器，因为当文件被修改时，`.babelrc` 文件不会被重新加载。几分钟后，你应该能在浏览器中看到标准的 **Hello World!**
    消息。
- en: Here, we told Babel to use `@babel/preset-env` and `@babel/preset-react`, which
    we installed together with webpack. These presets allow Babel to transform specific
    syntax, such as JSX. We can use those presets to create normal JavaScript that
    all browsers can understand and that webpack can bundle.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们告诉 Babel 使用 `@babel/preset-env` 和 `@babel/preset-react`，这些预设与 webpack
    一起安装。这些预设允许 Babel 转换特定的语法，例如 JSX。我们可以使用这些预设来创建所有浏览器都能理解的正常 JavaScript，并且 webpack
    可以打包。
- en: Rendering arrays from React state
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 React 状态渲染数组
- en: '`Hello World!` is a must for every good programming book, but this is not what
    we are aiming for when we use React.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: “Hello World!” 是每本好编程书的必备，但当我们使用 React 时，我们追求的并不是这个。
- en: A social network such as Facebook or Graphbook, which we are writing now, needs
    a newsfeed and an input to post news. Let's implement this.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一个像 Facebook 或 Graphbook 这样的社交网络，我们现在正在编写，需要一个新闻源和发布新闻的输入。让我们来实现这个功能。
- en: Since this is the first chapter of this book, we will do this inside `App.js`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是本书的第一章，我们将在 `App.js` 中完成这个任务。
- en: We should work with some fake data here since we have not set up our GraphQL
    API yet. We can replace this with real data later.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们还没有设置 GraphQL API，我们应该在这里使用一些假数据。我们可以在以后用真实数据替换它。
- en: 'Define a new variable above the `default` exported `App` function, like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在导出为 `default` 的 `App` 函数上方定义一个新变量，如下所示：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We are going to render these two fake posts in React. To prepare this, change
    the first line of the `App.js` file to the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 React 渲染这两个假帖子。为了准备这个，将 `App.js` 文件的第一个行更改为以下内容：
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This ensures that the `useState` function of React is imported and accessible
    by our stateless function.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了 React 的 `useState` 函数被导入并且可以被我们的无状态函数访问。
- en: 'Replace the current content of your `App` function with the following code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的 `App` 函数当前内容替换为以下代码：
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we initiated a `posts` array inside the function via the React `useState`
    function. It allows us to have a state without writing a real React class; instead,
    it only relies on raw functions. The `useState` function expects one parameter,
    which is the initial value of the state variable. In this case, this is the constant
    `initialPosts` array. This returns the `posts` state variable and a `setPosts`
    function, which you can use to update the local state.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过 React 的 `useState` 函数在函数内部初始化了一个 `posts` 数组。这允许我们拥有一个状态，而无需编写真正的 React
    类；相反，它只依赖于原始函数。`useState` 函数期望一个参数，即状态变量的初始值。在这种情况下，这是常量 `initialPosts` 数组。这返回
    `posts` 状态变量和一个 `setPosts` 函数，你可以使用它来更新本地状态。
- en: Then, we iterated over the `posts` array with the `map` function, which again
    executes the inner callback function, passing each array item as a parameter one
    by one. The second parameter is just called `i` and represents the index of the
    array element we are processing. Everything that's returned from the `map` function
    is then rendered by React.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`map`函数遍历`posts`数组，这再次执行了内部回调函数，逐个传递数组项作为参数。第二个参数简单地称为`i`，代表我们正在处理的数组元素的索引。`map`函数返回的所有内容随后都由React渲染。
- en: We merely returned HTML by putting each post's data in ES6 curly braces. These
    curly braces tell React to interpret and evaluate the code inside them as JavaScript.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是通过将每个帖子的数据放入ES6花括号中返回HTML。这些花括号告诉React将它们内部的代码解释和评估为JavaScript。
- en: As shown in the preceding code, we are relying on the posts that were returned
    by the `useState` function. This data flow is very convenient because we can update
    the state at any point in our application and the posts will rerender. The important
    thing is that this will only work by using the `setPosts` function and passing
    the updated array to it. In this case, React notices the change of state and rerenders
    the function.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，我们依赖于`useState`函数返回的帖子。这种数据流非常方便，因为我们可以在应用程序的任何位置更新状态，帖子将重新渲染。重要的是，这只能通过使用`setPosts`函数并将更新的数组传递给它来实现。在这种情况下，React会注意到状态的改变并重新渲染函数。
- en: 'The preceding method is much cleaner, and I recommend this for readability
    purposes. When saving, you should be able to see rendered posts. They should look
    like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法更简洁，我推荐这种方法以提高可读性。保存时，你应该能够看到渲染的帖子。它们应该看起来像这样：
- en: '![Figure 1.3 – Unstyled demo posts'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.3 – 未加样式演示帖子]'
- en: '](img/Figure_1.3_B17337.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.3 – 未加样式演示帖子](img/Figure_1.3_B17337.jpg)'
- en: Figure 1.3 – Unstyled demo posts
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 – 未加样式演示帖子
- en: The images I am using here are freely available. You can use any other material
    that you have got if the path matches the string from the `posts` array. You can
    find those images in the official GitHub repository for this book.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里使用的图片是免费可用的。如果路径与`posts`数组中的字符串匹配，你可以使用任何其他材料。这些图片可以在本书的官方GitHub仓库中找到。
- en: CSS with webpack
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用webpack的CSS
- en: The posts in the preceding figure have not been designed yet. I have already
    added CSS classes to the HTML our component returns.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图中的帖子尚未设计。我已经为返回的HTML组件添加了CSS类。
- en: Instead of using CSS to make our posts look better, another method is to use
    CSS-in-JS using packages such as styled components, which is a React package.
    Other alternatives include Glamorous and Radium. There are numerous reasons for
    and against using such libraries. With those other tools, you are not able to
    use SASS, SCSS, or LESS effectively. I need to work with other people, such as
    screen and graphics designers, who can provide and use CSS, but do not program
    styled components. There is always a prototype or existing CSS that can be used,
    so why should I spend time translating this into styled components CSS when I
    could just continue with standard CSS?
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用CSS使我们的帖子看起来更好，另一种方法是使用CSS-in-JS，例如使用styled components这样的包，这是一个React包。其他替代方案包括Glamorous和Radium。使用这样的库有无数的理由和反对的理由。使用那些其他工具，你无法有效地使用SASS、SCSS或LESS。我需要与其他人合作，例如屏幕和图形设计师，他们可以提供和使用CSS，但不会编写样式组件。总是有一个原型或现有的CSS可以使用，那么我为什么要花时间将这转换为样式组件CSS，而我可以继续使用标准CSS呢？
- en: There is no right or wrong option here; you are free to implement the styling
    in any way you like. However, in this book, we will keep using good old CSS.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里没有正确或错误的选择；你可以自由地以任何你喜欢的任何方式实现样式。然而，在这本书中，我们将继续使用传统的CSS。
- en: 'What we have already done in our `webpack.client.config.js` file is specify
    a CSS rule, as shown in the following code snippet:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`webpack.client.config.js`文件中，我们已经指定了一个CSS规则，如下面的代码片段所示：
- en: '[PRE19]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`style-loader` injects your bundled CSS right into the DOM. `css-loader` will
    resolve all `import` or `url` occurrences in your CSS code.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`style-loader`将你的打包CSS直接注入到DOM中。`css-loader`将解析CSS代码中的所有`import`或`url`出现。'
- en: 'Create a `style.css` file in `/assets/css` and fill in the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在`/assets/css`目录下创建一个`style.css`文件，并填写以下内容：
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Refreshing your browser will leave you with the same old HTML you had previously.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新浏览器将留下你之前相同的旧HTML。
- en: This problem occurs because webpack is a module bundler and does not know anything
    about CSS; it only knows JavaScript. We must import the CSS file somewhere in
    our code.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题发生是因为webpack是一个模块打包器，它对CSS一无所知；它只知道JavaScript。我们必须在我们的代码中某个地方导入CSS文件。
- en: Instead of using `index.html` and adding a `head` tag, we can use webpack and
    our CSS rule to load it right into `App.js`. This solution is very convenient
    since all the required CSS throughout our application gets minified and bundled.
    Webpack automates this process.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用webpack和我们的CSS规则，而不是使用`index.html`并添加一个`head`标签，将CSS直接加载到`App.js`中。这个解决方案非常方便，因为我们的应用程序中所有需要的CSS都会被压缩和捆绑。Webpack自动化了这个过程。
- en: 'In your `App.js` file, add the following behind the React `import` statement:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`App.js`文件中，在React `import`语句之后添加以下内容：
- en: '[PRE21]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: webpack magically rebuilds our bundle and refreshes our browser tab.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: webpack神奇地重建我们的包并刷新我们的浏览器标签。
- en: 'With that, you have successfully rendered fake data via React and styled it
    with bundled CSS from webpack. It should look something like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你就已经通过React渲染了假数据，并用webpack捆绑的CSS进行了样式化。它应该看起来像这样：
- en: '![Figure 1.4 – Styled demo posts'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.4 – 样式化演示帖子'
- en: '](img/Figure_1.04_B17337.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.04_B17337.jpg)'
- en: Figure 1.4 – Styled demo posts
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 – 样式化演示帖子
- en: The output looks very good already.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来已经很好了。
- en: Event handling and state updates with React
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React的事件处理和状态更新
- en: For this project, it would be great to have a simple `textarea` where we can
    click a button and then add a new post to the static `posts` array we wrote in
    the `App` function.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，有一个简单的`textarea`会很好，我们可以点击一个按钮，然后添加一个新的帖子到我们在`App`函数中编写的静态`posts`数组中。
- en: 'Add the following code above the `div` tag that contains the `feed` class:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含`feed`类的`div`标签上方添加以下代码：
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can use forms in React without any problems. React can intercept the submit
    event of requests by giving the form an `onSubmit` property, which will be a function
    to handle the logic.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在React中无任何问题地使用表单。React可以通过给表单一个`onSubmit`属性来拦截请求的提交事件，这将是一个处理逻辑的函数。
- en: We are passing the `postContent` variable to the `value` property of `textarea`
    to get what is called a **controlled input**.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`postContent`变量传递给`textarea`的`value`属性，以获得所谓的**受控输入**。
- en: 'Create an empty string variable to save the `textarea` value by using the `useState`
    function from React:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`useState`函数创建一个空字符串变量来保存`textarea`的值：
- en: '[PRE23]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `postContent` variable is already being used for our new `textarea` since
    we specified it in the `value` property. Furthermore, we directly implemented
    the `setPostContent` function in our post form. This is used for the `onChange`
    property or any event that is called whenever you type inside `textarea`. The
    `setPostContent` function receives the `e.target.value` variable, which is the
    DOM accessor for the value of `textarea`, which is then stored in the state of
    the React function.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`postContent`变量已经被用于我们的新`textarea`，因为我们已经在`value`属性中指定了它。此外，我们在帖子表单中直接实现了`setPostContent`函数。这用于`onChange`属性或任何在`textarea`内部输入时被调用的任何事件。`setPostContent`函数接收`e.target.value`变量，这是`textarea`值的DOM访问器，然后存储在React函数的状态中。'
- en: 'Look at your browser again. The form is there, but it is not pretty, so add
    the following CSS:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 再次查看你的浏览器。表单在那里，但它看起来并不漂亮，所以添加以下CSS：
- en: '[PRE24]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The last step is to implement the `handleSubmit` function for our form. Add
    it straight after the state variables and the `return` statement:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是实现我们的表单的`handleSubmit`函数。直接在状态变量和`return`语句之后添加它：
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding code looks more complicated than it is, but I am going to explain
    it quickly.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码看起来比实际要复杂，但我将快速解释它。
- en: We needed to run `event.preventDefault` to stop our browser from actually trying
    to submit the form and reload the page. Most people that come from jQuery or other
    JavaScript frameworks will know this.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要运行`event.preventDefault`来阻止浏览器实际尝试提交表单并重新加载页面。大多数来自jQuery或其他JavaScript框架的人都会知道这一点。
- en: Next, we saved our new post in the `newPost` variable, which we want to add
    to our feed.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将新帖子保存在`newPost`变量中，我们希望将其添加到我们的feed中。
- en: We faked some data here to simulate a real-world application. For our test case,
    the new post ID is the number of posts in our state variable plus one. React wants
    us to give every child in the ReactDOM a unique ID. By counting the number of
    posts with `posts.length`, we simulate the behavior of a real backend giving us
    unique IDs for our posts.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里伪造了一些数据来模拟真实世界的应用。对于我们的测试用例，新的帖子ID是我们状态变量中的帖子数加一。React希望我们给ReactDOM中的每个子元素一个唯一的ID。通过计算`posts.length`中的帖子数，我们模拟了真实后端为我们帖子提供唯一ID的行为。
- en: The text for our new post comes from the `postContent` state variable.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新帖子的文本来自`postContent`状态变量。
- en: Furthermore, we do not have a user system right now that our GraphQL server
    can use to give us the newest posts, including the matching users and their avatars.
    We can simulate this by having a static user object for all the new posts we create.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们目前还没有一个用户系统，我们的 GraphQL 服务器可以使用它来给我们提供最新的帖子，包括匹配的用户和他们的头像。我们可以通过为所有创建的新帖子创建一个静态用户对象来模拟这一点。
- en: Finally, we updated the state again. We did this by using the `setPosts` function
    and passing a merged array consisting of the new posts and the current `posts`
    array with a destructuring assignment. After that, we cleared `textarea` by passing
    an empty string to the `setPostContent` function.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们再次更新了状态。我们通过使用 `setPosts` 函数并传递一个由新帖子以及当前 `posts` 数组通过解构赋值合并而成的数组来做到这一点。之后，我们通过将空字符串传递给
    `setPostContent` 函数来清空 `textarea`。
- en: Now, go ahead and play with your working React form. Do not forget that all
    the posts you create do not persist since they are only held in the local memory
    of the browser and are not saved to a database. Consequently, refreshing deletes
    your posts.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，继续使用你的工作 React 表单。别忘了，你创建的所有帖子都不会持久化，因为它们只保存在浏览器的本地内存中，并没有保存到数据库中。因此，刷新会删除你的帖子。
- en: Controlling document heads with React Helmet
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 React Helmet 控制文档头
- en: When developing a web application, you must control your document heads. You
    might want to change the title or description, based on the content you are presenting.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发 web 应用程序时，你必须控制你的文档头。你可能想根据你展示的内容更改标题或描述。
- en: 'React Helmet is a great package that offers this on the fly, including overriding
    multiple headers and server-side rendering. Let''s see how we can do this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: React Helmet 是一个优秀的包，它提供了这些功能，包括动态覆盖多个头信息和服务器端渲染。让我们看看我们如何做到这一点：
- en: 'Install React Helmet with the following command:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令安装 React Helmet：
- en: '[PRE26]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Import `react-helmet` at the top of the file:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件顶部导入 `react-helmet`：
- en: '[PRE27]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Add `Helmet` directly above `postForm div`:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `postForm div` 上面直接添加 `Helmet`：
- en: '[PRE28]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If you reload the browser and watch the title on the tab bar of your browser
    carefully, you will see that it changes from `Graphbook` to `Graphbook - Feed`.
    This behavior happens because we already defined a title inside `index.html`.
    When React finishes rendering, the new document head is applied.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刷新浏览器并仔细观察浏览器标签栏上的标题，你会看到它从 `Graphbook` 变为 `Graphbook - Feed`。这种行为发生是因为我们在
    `index.html` 中已经定义了一个标题。当 React 完成渲染后，新的文档头就会应用。
- en: Production build with webpack
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 webpack 进行生产构建
- en: The last step for our React setup is to have a production build. Until now,
    we were only using `webpack-dev-server`, but this naturally includes an unoptimized
    development build. Furthermore, webpack automatically spawns a web server. In
    the next chapter, we will introduce Express.js as our web server so that we don't
    need webpack to start it.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 React 设置的最后一步是进行生产构建。到目前为止，我们只使用了 `webpack-dev-server`，但这自然包括一个未优化的开发构建。此外，webpack
    会自动启动一个 web 服务器。在下一章中，我们将介绍 Express.js 作为我们的 web 服务器，这样我们就不需要 webpack 来启动它了。
- en: 'A production bundle does merge all JavaScript files, but it also merges all
    the CSS files into two separate files. Those can be used directly in the browser.
    To bundle CSS files, we will rely on another webpack plugin, called `MiniCss`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 生产版本的包会合并所有 JavaScript 文件，但也会将所有 CSS 文件合并成两个单独的文件。这些文件可以直接在浏览器中使用。为了打包 CSS 文件，我们将依赖于另一个
    webpack 插件，称为 `MiniCss`：
- en: '[PRE29]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We do not want to change the current `webpack.client.config.js` file because
    it is made for development work. Add the following command to the `scripts` object
    of your `package.json`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想更改当前的 `webpack.client.config.js` 文件，因为它是为开发工作制作的。将以下命令添加到你的 `package.json`
    文件的 `scripts` 对象中：
- en: '[PRE30]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This command runs webpack using an individual production webpack config file.
    Let's create this one. First, clone the original `webpack.client.config.js` file
    and rename it `webpack.client.build.config.js`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令使用单独的生产 webpack 配置文件运行 webpack。让我们创建这个文件。首先，克隆原始的 `webpack.client.config.js`
    文件，并将其重命名为 `webpack.client.build.config.js`。
- en: 'Change the following things in the new file:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在新文件中更改以下内容：
- en: '`mode` needs to be `production`, not `development`.'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`mode` 需要设置为 `production`，而不是 `development`。'
- en: 'Require the `MiniCss` plugin:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要引入 `MiniCss` 插件：
- en: '[PRE31]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Replace the current CSS rule:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 替换当前的 CSS 规则：
- en: '[PRE32]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We are no longer using `style-loader`; instead, we're using the `MiniCss` plugin.
    The plugin goes through the complete CSS code, merges it into a separate file,
    and removes the `import` statements from the `bundle.js` file, which we generate
    in parallel.
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们不再使用`style-loader`；相反，我们使用`MiniCss`插件。该插件遍历完整的CSS代码，将其合并到一个单独的文件中，并从我们并行生成的`bundle.js`文件中删除`import`语句。
- en: 'Lastly, add the plugin to the plugins at the bottom of the configuration file:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将插件添加到配置文件底部的插件中：
- en: '[PRE33]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Remove the entire `devServer` property.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除整个`devServer`属性。
- en: When you run the new configuration, it won't spawn a server or browser window;
    it will only create a production JavaScript and CSS bundle and will require them
    in our `index.html` file. According to our `webpack.client.build.config.js` file,
    those three files are going to be saved to the `dist/client` folder.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行新的配置时，它不会启动服务器或浏览器窗口；它只会创建生产JavaScript和CSS包，并将它们包含在我们的`index.html`文件中。根据我们的`webpack.client.build.config.js`文件，这三个文件将被保存到`dist/client`文件夹中。
- en: You can run this command by executing `npm run client:build`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过执行`npm run client:build`来运行此命令。
- en: If you look in the `dist/client` folder, you will see three files. You can open
    the `index.html` file in your browser. Sadly, the images are broken because the
    image URLs are not correct anymore. We must accept this for the moment because
    it will be automatically fixed when we have a working backend.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看`dist/client`文件夹，您将看到三个文件。您可以在浏览器中打开`index.html`文件。遗憾的是，图片已损坏，因为图片URL不再正确。我们必须暂时接受这一点，因为当我们的后端工作正常时，它将自动修复。
- en: With that, we have finished the basic setup for React.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就完成了React的基本设置。
- en: Useful development tools
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有用的开发工具
- en: When you're working with React, you want to know why your application rendered
    the way that it did. You need to know which properties your components received
    and how their current state looks. Since this is not displayed in the DOM or anywhere
    else in Chrome DevTools, you need a separate plugin.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用React时，您想知道为什么您的应用程序以这种方式渲染。您需要知道组件接收了哪些属性以及它们当前的状态看起来如何。由于这些信息在DOM或Chrome
    DevTools的任何其他地方都没有显示，您需要一个单独的插件。
- en: 'Fortunately, Facebook has got you covered. Visit [https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi)
    and install React Developer Tools. This plugin allows you to inspect React applications
    and components. When you open Chrome DevTools again, you will see that there are
    two new tabs at the end of the row – one called **Components** and another called
    **Profiler**:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Facebook已经为您解决了这个问题。访问[https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi)并安装React
    Developer Tools。此插件允许您检查React应用程序和组件。当您再次打开Chrome DevTools时，您将在行尾看到两个新的标签页 - 一个称为**Components**，另一个称为**Profiler**：
- en: '![Figure 1.5 – React developer tools'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.5 – React developer tools]'
- en: '](img/Figure_1.5_B17337.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure_1.5_B17337.jpg]'
- en: Figure 1.5 – React developer tools
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 1.5 – React developer tools
- en: You will only be able to see those tabs if you are running a React application
    in development mode. If a React application is running or bundled in production,
    those extensions won't work.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 您只能在开发模式下运行React应用程序时才能看到这些标签页。如果React应用程序正在运行或以生产模式打包，这些扩展将不起作用。
- en: Note
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you are unable to see this tab, you may need to restart Chrome completely.
    You can also find React Developer Tools for Firefox.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看不到这个标签页，您可能需要完全重新启动Chrome。您还可以在Firefox上找到React Developer Tools。
- en: The first tab allows you to view, search, and edit all the components of your
    ReactDOM.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个标签页允许您查看、搜索和编辑您的ReactDOM的所有组件。
- en: 'The left-hand side panel looks much like the regular DOM tree (Elements) in
    Chrome DevTools, but instead of showing HTML markup, you will see all the components
    you used inside a tree. ReactDOM rendered this tree into real HTML, as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧面板看起来与Chrome DevTools中的常规DOM树（Elements）非常相似，但您将看到所有组件都在树中，而不是显示HTML标记。ReactDOM将此树渲染成真实的HTML，如下所示：
- en: '![Figure 1.6 – React component tree'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.6 – React component tree]'
- en: '](img/Figure_1.6_B17337.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure_1.6_B17337.jpg]'
- en: Figure 1.6 – React component tree
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 1.6 – React component tree
- en: The first component in the current version of Graphbook should be `<App />`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Graphbook当前版本的第一个组件应该是`<App />`。
- en: 'By clicking a component, your right-hand side panel will show its properties,
    state, and context. You can try this with the `App` component, which is the only
    real React component:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击一个组件，你的右侧面板将显示其属性、状态和上下文。你可以尝试使用 `App` 组件，这是唯一的真实 React 组件：
- en: '![Figure 1.7 – React component state'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.7 – React 组件状态'
- en: '](img/Figure_1.7_B17337.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 1.7](img/Figure_1.7_B17337.jpg)'
- en: Figure 1.7 – React component state
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7 – React 组件状态
- en: The `App` function is the first component of our application. This is the reason
    why it received no props. Children can receive properties from their parents;
    with no parent, there are no props.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`App` 函数是我们应用程序的第一个组件。这就是为什么它没有接收任何属性。子组件可以从父组件接收属性；没有父组件，就没有属性。'
- en: Now, test the `App` function and play around with the state. You will see that
    changing it rerenders your ReactDOM and updates the HTML. You can edit the `postContent`
    variable, which inserts the new text inside `textarea`. As you will see, all the
    events are thrown, and your handler runs. Updating the state always triggers a
    rerender, so try to update the state as little as possible to use as few computing
    resources as possible.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，测试 `App` 函数并尝试操作状态。你会看到状态的改变会重新渲染你的 ReactDOM 并更新 HTML。你可以编辑 `postContent`
    变量，它会在 `textarea` 内插入新文本。正如你将看到的，所有的事件都会被抛出，并且你的处理器会运行。更新状态总是触发重新渲染，所以尽量减少状态更新，以尽可能少地使用计算资源。
- en: Summary
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we set up a working React environment. This is a good starting
    point for our frontend as we can write and build static web pages with this setup.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们设置了一个可工作的 React 环境。这对于我们的前端来说是一个很好的起点，因为我们可以使用这个设置编写和构建静态网页。
- en: The next chapter will primarily focus on our setup for the backend. We will
    configure Express.js to accept our first requests and pass all GraphQL queries
    to Apollo. Furthermore, you will learn how to use Postman to test your API.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将主要关注我们的后端设置。我们将配置 Express.js 以接受我们的第一个请求并将所有 GraphQL 查询传递给 Apollo。此外，你还将学习如何使用
    Postman 测试你的 API。
