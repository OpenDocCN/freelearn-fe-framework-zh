- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: High-Performance State Updates
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高性能状态更新
- en: '**State** represents the dynamic aspect of your React application. When the
    state changes, your components react to those changes. Without state, you would
    have nothing more than a fancy HTML template language. Usually, the time required
    to perform a state update and have the changes rendered on the screen is barely,
    if at all, noticeable. However, there are times that complex state changes can
    lead to noticeable lag for your users. The goal of this chapter is to address
    these cases and find out how we can avoid those lags.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**状态**代表了你的React应用程序的动态方面。当状态发生变化时，你的组件会对这些变化做出反应。没有状态，你将只有一些花哨的HTML模板语言。通常，执行状态更新并在屏幕上渲染更改所需的时间几乎不明显，如果有的话。然而，有时复杂的状态变化可能导致用户注意到明显的延迟。本章的目标是解决这些问题，并找出我们如何避免这些延迟。'
- en: 'In this chapter, you’ll learn how to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: Batch your state changes together for minimal re-rendering
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将你的状态更改批量处理在一起以实现最小化重新渲染
- en: Prioritize state updates to render content that’s critical for your user experience
    first
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先更新状态以渲染对用户体验至关重要的内容
- en: Develop strategies for performing asynchronous actions while **batching** and
    prioritizing **state updates**
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**批量处理**和**优先处理**状态更新时开发执行异步操作的战略
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you’ll need your code editor (**Visual Studio Code**). The
    code we’ll be following can be found here: [https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter10](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter10).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要你的代码编辑器（**Visual Studio Code**）。我们将遵循的代码可以在以下位置找到：[https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter10](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter10)。
- en: You can open the terminal within Visual Studio Code and run `npm install` to
    make sure you’re able to follow along with the examples as you read through the
    chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Visual Studio Code中的终端运行`npm install`，以确保你能够随着阅读本章的例子而跟进。
- en: Batching state updates
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 批量处理状态更新
- en: In this section, you’ll learn about how React can **batch state** updates together
    to prevent unnecessary rendering when multiple state changes happen simultaneously.
    In particular, we’ll look at the changes introduced in **React 18** that make
    **automatic batching** of state updates commonplace.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将了解React如何将**状态更新**批量处理在一起，以防止在多个状态变化同时发生时进行不必要的渲染。特别是，我们将探讨在**React 18**中引入的更改，这些更改使得状态更新的**自动批量处理**变得普遍。
- en: 'When your React component issues a state change, this causes the React internals
    to re-render the parts of your component that have changed visually as a result
    of this state update. For example, imagine you have a component with a name state
    that’s rendered inside of a `<span>` element, and you change the name state from
    `Adam` to `Ashley`. That’s a straightforward change that results in a re-render
    that’s too fast for the user to even notice. Unfortunately, state updates in web
    applications are rarely this straightforward. Instead, there might be dozens of
    state changes in 10 milliseconds. For example, the name state might follow changes
    like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的React组件发出状态变化时，这会导致React内部重新渲染由于这种状态更新而视觉上发生变化的部分。例如，想象你有一个包含名称状态的组件，该状态渲染在`<span>`元素内部，并将名称状态从`Adam`更改为`Ashley`。这是一个简单的更改，导致重新渲染得太快，以至于用户甚至注意不到。不幸的是，Web应用程序中的状态更新很少如此简单。相反，可能会有数十个状态变化在10毫秒内发生。例如，名称状态可能会跟随以下变化：
- en: '`Adam`'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Adam`'
- en: '`Ashley`'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Ashley`'
- en: '`Andrew`'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Andrew`'
- en: '`Ashley`'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Ashley`'
- en: '`Aaron`'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Aaron`'
- en: '`Adam`'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Adam`'
- en: 'Here, we have six changes that took place with the name state in a short amount
    of time. This means that React would have re-rendered the **DOM** six times, once
    for each value that was set as the name state. What’s interesting to note about
    this scenario is the final state update: we’re back where we started with `Adam`.
    This means that we just re-rendered the DOM five times for no reason. Now, imagine
    these wasted re-renders on a web application scale and how these types of state
    updates might cause problems for performance. For example, when the app uses complex
    animations, user interactions like drag and drops, timeouts, and intervals can
    all lead to unnecessary re-renders, negatively impacting performance.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们短时间内发生了六个名为state的变化。这意味着React会重新渲染**DOM**六次，每次设置一个值作为name state。关于这个场景有趣的是最终的状态更新：我们回到了起点，`Adam`。这意味着我们无端地重新渲染了DOM五次。现在，想象一下在Web应用规模上的这些浪费的重新渲染，以及这些类型的状态更新可能会对性能造成的问题。例如，当应用使用复杂的动画、用户交互如拖放、超时和间隔时，都可能导致不必要的重新渲染，从而对性能产生负面影响。
- en: The answer to this problem is **batching**. This is how React takes several
    state updates that were made in our component code and treats them as a single
    state update. Rather than process every state update individually, while re-rendering
    the DOM between each update, the state changes are all merged, which results in
    one DOM re-render. In the aggregate, this reduces the amount of work that our
    web applications need to do by a lot.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的答案是**批处理**。这就是React如何将我们在组件代码中做出的几个状态更新视为一个单一的状态更新。而不是逐个处理每个状态更新，在每次更新之间重新渲染DOM，状态更改都被合并，从而只导致一次DOM重新渲染。总的来说，这大大减少了我们的Web应用需要执行的工作量。
- en: In **React 17**, automatic batching of state updates only happened inside of
    event handler functions. For example, let’s say you have a button with an `onClick()`
    handler that performs five state updates. React will batch all of these state
    updates together so that only one re-render is necessary. The problem arises when
    your event handlers make asynchronous calls, usually to fetch some data, and then
    make state updates when the asynchronous call finishes. These state changes are
    no longer automatically batched because they’re not running directly inside of
    the event handler function. Instead, they’re running in the `callback` code of
    the asynchronous operation and React 17 will not batch these updates. This is
    a challenge because it’s common for our React components to fetch data asynchronously
    and perform state updates in response to events!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在**React 17**中，状态更新的自动批处理仅在事件处理函数内部发生。例如，假设你有一个带有`onClick()`处理器的按钮，该处理器执行五个状态更新。React会将所有这些状态更新一起批处理，从而只需要一次重新渲染。问题出现在你的事件处理器进行异步调用，通常是为了获取一些数据，然后在异步调用完成后进行状态更新。这些状态更改不再自动批处理，因为它们不是直接在事件处理器函数中运行的。相反，它们运行在异步操作的`回调`代码中，React
    17不会批处理这些更新。这是一个挑战，因为我们的React组件异步获取数据并在事件响应中执行状态更新是很常见的！
- en: Now we know how we can handle the most common problem with unnecessary re-renders,
    which is multiple changes to a state in a short time. Now, let’s understand it
    by example.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何处理最常见的不必要重新渲染问题，即短时间内对状态进行多次更改。现在，让我们通过例子来理解它。
- en: React 18 batching
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React 18批处理
- en: 'Let’s turn our attention to some code now to see how **React 18** addresses
    the batching problem that we’ve just outlined. For this example, we’ll render
    a button that, when clicked, will perform 100 state updates. We’ll use `setTimeout()`
    so that the updates are performed asynchronously, outside of the event handler
    function. The idea is to show the difference between how this code is handled
    by two different React versions. To do this, we can open the **React profiler**
    in the browser dev tools and hit record before we press the button to execute
    our state changes. Here’s what the code looks like:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将注意力转向一些代码，看看**React 18**是如何解决我们刚刚概述的批处理问题的。在这个例子中，我们将渲染一个按钮，当点击时，将执行100次状态更新。我们将使用`setTimeout()`来确保更新是异步执行的，在事件处理函数之外。目的是展示两种不同的React版本处理此代码的方式之间的差异。为此，我们可以在浏览器开发者工具中打开**React分析器**，在按下按钮执行我们的状态更改之前点击记录。下面是代码的样子：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: By clicking the button that this component renders, we call the `onStart()`
    event handler function defined by our component. Then, our handler calls `setValue()`
    100 times inside a loop. Ideally, we do not want to perform 100 re-renders because
    this will hurt the performance of our application, and it doesn’t need to. Only
    the final call to `setValue()` matters here.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击该组件渲染的按钮，我们调用由我们的组件定义的 `onStart()` 事件处理器函数。然后，我们的处理器在循环中调用 `setValue()`
    100 次。理想情况下，我们不想进行 100 次重新渲染，因为这会损害我们应用程序的性能，而且也不需要这样做。这里只关心 `setValue()` 的最终调用。
- en: 'Let’s first take a look at the profile captured for this component using React
    17:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看使用 React 17 捕获的该组件的配置文件：
- en: '![Figure 13.1 – Using React dev tools to view re-renders every time state updates
    are made ](img/B19636_10_01.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.1 – 使用 React 开发工具查看每次状态更新时进行的重新渲染](img/B19636_10_01.png)'
- en: 'Figure 10.1: Using React dev tools to view re-renders every time state updates
    are made'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1：使用 React 开发工具查看每次状态更新时进行的重新渲染
- en: By pressing the button with our event handler attached to it, we’re making 100
    state update calls. Since this is done outside of the event handler function in
    `setTimeout()`, automatic batching doesn’t happen. We can see this in the profile
    output of the `BactchingUpdates` component, where there’s a long list of renders.
    Most of these aren’t necessary and contribute to the amount of work React needs
    to do in response to user interactions, hurting the overall performance of our
    application.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通过按下与我们事件处理器相关联的按钮，我们进行了 100 次状态更新调用。由于这是在 `setTimeout()` 函数外部完成的，所以不会发生自动批处理。我们可以在
    `BactchingUpdates` 组件的配置文件输出中看到这一点，其中有一长串的渲染。其中大部分是不必要的，并增加了 React 需要执行以响应用户交互的工作量，从而损害了我们应用程序的整体性能。
- en: 'Let’s capture a profile of the same component being rendered using React 18:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们捕获使用 React 18 渲染的相同组件的配置文件：
- en: '![Figure 13.2 – React dev tools showing only one render with automatic batching
    enabled ](img/B19636_10_02.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.2 – React 开发工具显示启用自动批处理时仅有一个渲染](img/B19636_10_02.png)'
- en: 'Figure 10.2: React dev tools showing only one render with automatic batching
    enabled'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2：React 开发工具显示启用自动批处理时仅有一个渲染
- en: '**Automatic batching** is applied everywhere that state updates are made, even
    in common asynchronous scenarios such as this one. As the profile shows, there’s
    only one re-render when we click the button instead of 100\. We didn’t have to
    make any adjustments to our component code to make this happen either. However,
    there is one change that’s required in order to make state updates batch automatically.
    Let’s say you used `ReactDOM.render()` to render your root component, like so:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动批处理**应用于所有进行状态更新的地方，甚至在像这种情况这样的常见异步场景中也是如此。正如配置文件所示，当我们点击按钮时，只有一个重新渲染，而不是
    100 个。我们也不必对我们的组件代码进行任何调整来实现这一点。然而，为了使状态更新自动批处理，我们需要进行一个更改。假设你使用了 `ReactDOM.render()`
    来渲染你的根组件，如下所示：'
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Instead, you can use `ReactDOM.createRoot()` and render that:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你可以使用 `ReactDOM.createRoot()` 并渲染它：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'By creating and rendering your root node this way, you can ensure that with
    **React 18**, you’ll get batched state updates throughout your application. You
    no longer need to worry about manually optimizing state updates so that they take
    place immediately: React does this for you now. However, sometimes, you’ll have
    state updates that are of higher priority than others. In cases like these, we
    need a way to tell React to prioritize certain state updates over others, instead
    of batching everything together.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式创建和渲染你的根节点，你可以确保在 **React 18** 中，你将获得整个应用程序的批处理状态更新。你不再需要担心手动优化状态更新以确保它们立即发生：React
    现在为你这样做。然而，有时你会有比其他状态更新优先级更高的状态更新。在这种情况下，我们需要一种方法来告诉 React 优先处理某些状态更新，而不是将所有内容一起批处理。
- en: Prioritizing state updates
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优先处理状态更新
- en: 'When something happens in our React application, we usually make several state
    updates so that the UI can reflect these changes. Typically, you can make these
    state changes without much thought about how the rendering performance is impacted.
    For example, let’s say you have a long list of items that need to be rendered.
    This will probably have some impact on the UI: while the list is being rendered,
    the user probably won’t be able to interact with certain page elements because
    the JavaScript engine is 100% utilized for a brief moment.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的React应用程序发生某些事件时，我们通常会进行多次状态更新，以便UI可以反映这些变化。通常，你可以做出这些状态变化而不必过多考虑渲染性能的影响。例如，假设你有一个需要渲染的长列表项目。这可能会对UI产生一些影响：当列表正在渲染时，用户可能无法与某些页面元素交互，因为JavaScript引擎在短时间内100%被占用。
- en: However, this can become an issue when expensive rendering disrupts the normal
    browser behavior that users expect. For example, if the user types in a text box,
    they expect the character they just typed to show up immediately. But if your
    component is busy rendering a large item list, the text box state cannot be updated
    right away. This is where the new React state update prioritization API comes
    in handy.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当昂贵的渲染干扰了用户期望的正常浏览器行为时，这可能会成为一个问题。例如，如果用户在文本框中输入文本，他们期望刚刚输入的字符立即显示出来。但如果你组件正忙于渲染一个大型项目列表，文本框的状态无法立即更新。这就是新的React状态更新优先级API派上用场的地方。
- en: The `startTransition()` API is used to mark certain state updates as transitional,
    meaning that the updates are treated as a lower priority. If you think about a
    list of items either being rendered for the first time or being changed to another
    list of items, this is a transition that doesn’t have to be immediate. On the
    other hand, state updates such as changing the value in a text box should be as
    close to immediate as possible. By using `startTransition()`, you tell React that
    any state updates within can wait if there are more important updates.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`startTransition()` API用于标记某些状态更新为过渡性，这意味着更新被视为低优先级。如果你考虑一个项目列表要么是首次渲染，要么是改变为另一个项目列表，这种转换不需要立即进行。另一方面，如更改文本框中的值这样的状态更新应该尽可能接近立即。通过使用`startTransition()`，你告诉React，如果存在更重要的更新，任何状态更新都可以等待。'
- en: 'A good rule of thumb for `startTransition()` is to use it for the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`startTransition()`的一个好的经验法则是用于以下情况：
- en: Anything that has the potential to perform a lot of rendering work
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何可能执行大量渲染工作的内容
- en: Anything that doesn’t require immediate feedback from the user in response to
    their interactions
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何不需要用户对其交互立即反馈的内容
- en: Let’s walk through an example that renders a large list of items in response
    to a user typing in a text box to filter a list.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来了解，当用户在文本框中输入以过滤列表时，如何渲染大量项目列表。
- en: 'This component will render a text box that the user can type in to filter a
    list of 25,000 items. I’ve chosen this number based on the performance of the
    laptop I’m using to write this code: you might want to tweak it up if there’s
    no delay or down if it takes too long to render anything. When the page first
    loads, you should see a filter text box that looks like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件将渲染一个用户可以输入以过滤25000个项目列表的文本框。我选择这个数字是基于我编写此代码时所使用的笔记本电脑的性能：如果你没有延迟，你可能需要调整它，如果渲染任何东西都花费太长时间，你可能需要将其降低。当页面首次加载时，你应该看到一个看起来像这样的过滤器文本框：
- en: '![](img/B19636_10_03.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19636_10_03.png)'
- en: 'Figure 10.3: The filter box before the user types anything'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3：用户输入任何内容之前的过滤器框
- en: 'When you start typing in the filter text box, the filtered items will render
    underneath it. It might take a second or two, since there are so many items to
    render:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始在过滤器文本框中输入时，过滤后的项目将显示在其下方。由于需要渲染的项目很多，可能需要一秒钟或两秒钟：
- en: '![](img/B19636_10_4.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19636_10_4.png)'
- en: 'Figure 10.4: Filtered items underneath the filter input when the user starts
    typing'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4：当用户开始输入时，过滤器输入下方的过滤项目
- en: 'Now, let’s walk through the code, starting with a large array of items:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从一组大量项目开始，逐步分析代码：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The size of the array is specified in the array constructor, and then it’s filled
    with numbered string values that we can filter by.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的尺寸是在数组构造函数中指定的，然后它被填充了我们可以通过其进行过滤的编号字符串值。
- en: 'Next, let’s look at the state used by this component:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看这个组件使用的状态：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `filter` state represents the value of the filter text box and defaults
    to an empty string. The `items` state represents the filtered items from our `unfilteredItems`
    array. This array is populated when the user types in the filter text box.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter`状态表示过滤器文本框的值，默认为空字符串。`items`状态表示来自我们的`unfilteredItems`数组的过滤项。当用户在过滤器文本框中输入时，此数组被填充。'
- en: 'Next, let’s look at the markup rendered by this component:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看这个组件渲染的标记：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The filter text box is rendered by an `<input>` element, while the filtered
    results are rendered as a list by iterating over the `items` array.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器文本框由一个`<input>`元素渲染，而过滤结果通过遍历`items`数组以列表形式渲染。
- en: 'Finally, let’s look at the event handler function that’s fired when the user
    types in the filter text box:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看当用户在过滤器文本框中输入时触发的事件处理函数：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `onChange()` function is called when the user types in the filter text box
    and sets two state values. First, it uses `setFilter()` to set the value of the
    filter text box. Then, it calls `setItems()` to set the filtered items to render
    unless the filter text is empty, in which case, we render nothing.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在过滤器文本框中输入时，会调用`onChange()`函数，并设置两个状态值。首先，它使用`setFilter()`来设置过滤器文本框的值。然后，它调用`setItems()`来设置要渲染的过滤项，除非过滤器文本为空，在这种情况下，我们不渲染任何内容。
- en: When interacting with this example, you might notice a problem with the responsiveness
    of the text box when typing in it. This is because, in this function, we’re setting
    not only the text box value but also the filtered items. This means that before
    the text value can be rendered, we have to wait for thousands of items to be rendered.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当与这个示例交互时，你可能会注意到在输入时文本框的响应性问题。这是因为在这个函数中，我们不仅设置了文本框的值，还设置了过滤项。这意味着在文本值可以渲染之前，我们必须等待数千个项被渲染。
- en: Even though these are two separate state updates (`setFilter()` and `setItems()`),
    they’re batched and treated as a single state update. Likewise, when the rendering
    starts, React makes all the changes at once, which means that the CPU won’t let
    the user interact with the text box because it’s fully utilized, rendering the
    long list of filter results. Ideally, we want to prioritize the text box state
    update while letting the items render afterward. To put it another way, we want
    to deprioritize the item rendering, since it’s expensive and the user doesn’t
    interact with it directly.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些是两个独立的状态更新（`setFilter()`和`setItems()`），但它们被批处理并被视为单一状态更新。同样，当渲染开始时，React会一次性执行所有更改，这意味着CPU不会让用户与文本框交互，因为它完全被利用，渲染出长长的过滤结果列表。理想情况下，我们希望优先处理文本框的状态更新，同时允许项在之后渲染。换句话说，我们希望降低项渲染的优先级，因为它成本高昂，并且用户不会直接与之交互。
- en: This is where the `startTransition()` API comes in. Any state updates that take
    place within the function that’s passed to `startTransition()` will be treated
    with lower priority than any state updates that happen outside of it. In our filtering
    example, we can fix the text box responsiveness issue by moving the `setItems()`
    state change inside of `startTransition()`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`startTransition()` API发挥作用的地方。传递给`startTransition()`函数内部发生的任何状态更新都将被赋予比其外部发生的任何状态更新更低的优先级。在我们的过滤示例中，我们可以通过将`setItems()`状态更改移动到`startTransition()`内部来修复文本框的响应性问题。
- en: 'Here’s what our new `onChange()` event handler looks like:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的新`onChange()`事件处理器的样子：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Note that we didn’t have to make any changes to how the item’s state is updated:
    the same code is moved to a function that’s passed to `startTransition()`. This
    tells React to only execute this state change after any other state changes are
    complete. In our case, this allows the text box to update and render before the
    `setItems()` state change runs. If you run the example now, you’ll see that the
    responsiveness of the text box is no longer affected by how long it takes to render
    a long list of items.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不需要对项的状态更新方式做出任何更改：相同的代码被移动到一个传递给`startTransition()`的函数中。这告诉React仅在所有其他状态更改完成后执行此状态更改。在我们的情况下，这允许文本框在`setItems()`状态更改运行之前更新和渲染。如果你现在运行示例，你会看到文本框的响应性不再受渲染长列表所需时间的影响。
- en: Before this new API was introduced, you could achieve state update prioritizations
    via workarounds with `setTimeout()`. The main disadvantage of this approach is
    that the internal React scheduler knows nothing about your state updates and their
    priorities. For example, by using `startTransitiion()`, React can cancel the update
    entirely if the state changes again before completion or if the component is unmounted.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新 API 介绍之前，你可以通过使用 `setTimeout()` 的变通方法来实现状态更新优先级。这种方法的主要缺点是，React 内部调度器对您的状态更新及其优先级一无所知。例如，通过使用
    `startTransitiion()`，React 可以在状态更改再次发生之前或组件卸载时取消整个更新。
- en: In real applications, it isn’t simply a matter of prioritizing which state updates
    should run first. Rather, it’s a combination of fetching data asynchronously while
    making sure that priorities are taken into account. In the final section of this
    chapter, we’ll tie all of this together.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，这不仅仅是一个优先考虑哪个状态更新应该首先运行的问题。相反，它是在确保优先级得到考虑的同时异步获取数据。在本章的最后部分，我们将把这些内容串联起来。
- en: Handling asynchronous state updates
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理异步状态更新
- en: In this final section of the chapter, we’ll look at the common scenario of fetching
    data asynchronously and setting render priorities. The key scenario that we want
    to address is making sure that users aren’t interrupted when typing or doing any
    other interaction that requires immediate feedback. This requires both proper
    prioritization and handling asynchronous responses from the server. Let’s start
    by looking at the React APIs that can potentially help with this scenario.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们将探讨异步获取数据和设置渲染优先级的常见场景。我们想要解决的关键场景是确保用户在输入或进行任何需要即时反馈的交互时不会被中断。这需要适当的优先级处理和从服务器处理异步响应。让我们首先看看可以帮助这个场景的
    React API。
- en: 'The `startTransition()` API can be used as a **Hook**. When we do this, we
    also get a Boolean value that we can check to see whether the transition is still
    pending. This is useful for showing the user that things are loading. Let’s modify
    the example from the previous section to use an asynchronous data-fetching function
    for our items. We’ll also use the `useTransition()` Hook and add loading behavior
    to the output of our component:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`startTransition()` API 可以用作 **钩子**。当我们这样做时，我们也会得到一个布尔值，我们可以检查它以确定转换是否仍在挂起。这有助于向用户显示正在加载。让我们修改上一节中的示例，使用异步数据获取函数来获取我们的项目。我们还将使用
    `useTransition()` 钩子，并给组件的输出添加加载行为：'
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'What this example shows is that once you start typing in the filter text box,
    it will trigger the `onChange()` handler, which will call the `filterItems()`
    function. We also have an `isLoading` value that we can use to show the user that
    something is happening in the background:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子表明，一旦你在过滤文本框中开始输入，它将触发 `onChange()` 处理程序，这将调用 `filterItems()` 函数。我们还有一个
    `isLoading` 值，我们可以用它来向用户显示后台正在发生某些事情：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here’s what the user will see when `isLoading` is `true`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `isLoading` 为 `true` 时，用户将看到以下内容：
- en: '![](img/B19636_10_05.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19636_10_05.png)'
- en: 'Figure 10.5: A loading indicator while a state transition is pending'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5：状态转换挂起时的加载指示器
- en: 'However, there’s a slight problem with our approach. You might have noticed
    the loading message flash briefly when typing into the text box. But then, you
    probably had a longer period when the items still weren’t visible, and the loading
    message disappeared. What’s happening here? Well, the `isPending` value that comes
    from the `useTransition()` Hook can be misleading. We’ve designed our component
    in such a way that `isPending` will be `true` in the following situations:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的方法存在一个小问题。你可能已经注意到，在文本框中输入时，加载信息会短暂闪烁。但随后，你可能有一个更长的时间段，项目仍然不可见，加载信息消失了。这里发生了什么？嗯，来自
    `useTransition()` 钩子的 `isPending` 值可能会误导。我们设计组件的方式是，以下情况下 `isPending` 将为 `true`：
- en: If the `filterItems()` function is still fetching our data
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `filterItems()` 函数仍在获取我们的数据
- en: If the `setItems()` state update is still performing an expensive render with
    lots of items
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `setItems()` 状态更新仍在执行一个昂贵的渲染，并且有很多项目
- en: Unfortunately, this isn’t how `isPending` works. The only time this value is
    `true` is before the function we pass to `startTransition()` is run. This is why
    you’ll see the loading indicator flash briefly instead of being displayed throughout
    the data-fetching operation and the rendering operation. Remember, React schedules
    state updates internally, and by using `startTransition()`, we’ve scheduled `setItems()`
    to run after other state updates.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 很不幸，`isPending` 并不是这样工作的。这个值只有在我们将函数传递给 `startTransition()` 之前是 `true` 的。这就是为什么你会在数据获取操作和渲染操作期间看到加载指示器短暂闪烁而不是一直显示的原因。记住，React
    在内部调度状态更新，通过使用 `startTransition()`，我们已经调度了 `setItems()` 在其他状态更新之后运行。
- en: 'Another way to think about `isPending` is that it’s `true` while high-priority
    updates are still running. We can call it `highPriorityUpdatesPending` to avoid
    confusion. That said, the uses of this value are narrow, but they do happen from
    time to time. For our more common case of fetching data and performing an expensive
    render, we need to think of another solution. Let’s walk through our code and
    refactor it in such a way that the loading indicator is displayed while the fetch
    and the higher-priority updates happen. First, let’s introduce a new `isLoading`
    state that defaults to `false`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种思考 `isPending` 的方式是，它在高优先级更新仍在运行时是 `true` 的。我们可以称之为 `highPriorityUpdatesPending`
    以避免混淆。尽管如此，这个值的用途很窄，但它们确实偶尔会发生。对于我们的更常见情况，即获取数据和执行昂贵的渲染，我们需要考虑另一种解决方案。让我们审查我们的代码，并以一种方式重构它，使得在获取和更高优先级的更新发生时显示加载指示器。首先，让我们引入一个新的
    `isLoading` 状态，默认为 `false`：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, inside of our `onChange()` handler, we can set the state to `true`. Inside
    of the transition that runs after the data fetch completes, we set it back to
    `false`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的 `onChange()` 处理程序内部，我们可以将状态设置为 `true`。在数据获取完成后运行的转换中，我们将其设置回 `false`：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now that we’re keeping track of the `isLoading` state, we know exactly when
    all the heavy lifting is done and can hide the loading indicator. The final change
    is to base the indicator display on `isLoading` instead of `isPending`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在跟踪 `isLoading` 状态，我们知道所有重负载何时完成，并且可以隐藏加载指示器。最后的更改是将指示器的显示基于 `isLoading`
    而不是 `isPending`：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When you run the example with these changes, the results should be a lot more
    predictable. The `setLoading()` and `setFilter()` state updates are high-priority
    and execute immediately. The call to fetch data using `filterItems()` isn’t made
    until the high-priority state updates are completed.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这些更改的示例时，结果应该会更加可预测。`setLoading()` 和 `setFilter()` 状态更新是高优先级的，并且会立即执行。使用
    `filterItems()` 获取数据的调用直到高优先级状态更新完成后才会进行。
- en: Only after we have the data do we hide the loading indicator.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在我们获取到数据后，我们才会隐藏加载指示器。
- en: Summary
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced you to the new APIs available in React 18 that help
    you achieve high-performance state updates. We started with a look at the changes
    to automatic state update batching in React 18 and how to best take advantage
    of them. We then explored the new `startTransition()` API and how it can be used
    to mark certain state updates as having a lower priority than those that require
    immediate feedback for user interactions. Finally, we looked at how state update
    prioritization can be combined with asynchronous data fetching.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍了 React 18 中可用的新 API，这些 API 有助于您实现高性能状态更新。我们从 React 18 中自动状态更新批处理的变化开始，并探讨了如何最好地利用它们。然后我们探讨了新的
    `startTransition()` API 以及如何将其用于标记某些状态更新为比那些需要即时用户交互反馈的状态更新具有更低优先级。最后，我们探讨了如何将状态更新优先级与异步数据获取相结合。
- en: In the next chapter, we’ll go over fetching data from the server.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍从服务器获取数据。
