<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer020">
<h1 class="chapter-number" id="_idParaDest-81"><a id="_idTextAnchor079"/>5</h1>
<h1 id="_idParaDest-82"><a id="_idTextAnchor080"/>Adding Complex Form Interactions</h1>
<p>It’s time to apply what you’ve learned to a more complicated HTML setup. In this chapter, we’ll test-drive a new component: <strong class="source-inline">AppointmentForm</strong>. It contains a select box, for selecting the service required, and a grid of radio buttons that form a calendar view for selecting the appointment time.</p>
<p>Combining both layout and form input, the code in this chapter shows how TDD gives you a structure for your work that makes even complicated scenarios straightforward: you will use your tests to grow the component into a component hierarchy, splitting out functionality from the main component as it begins to grow.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Choosing a value from a select box</li>
<li>Constructing a calendar view</li>
<li>Test-driving radio button groups</li>
<li>Reducing effort when constructing components</li>
</ul>
<p>By the end of the chapter, you’ll have learned how to apply test-driven development to complex user input scenarios. These techniques will be useful for all kinds of form components, not just select boxes and radio buttons.</p>
<h1 id="_idParaDest-83"><a id="_idTextAnchor081"/>Technical requirements</h1>
<p>The code files for this chapter can be found here: <a href="https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter05">https://github.com/PacktPublishing/Mastering-React-Test-Driven-Development-Second-Edition/tree/main/Chapter05</a>.</p>
<h1 id="_idParaDest-84"><a id="_idTextAnchor082"/>Choosing a value from a select box</h1>
<p>Let’s start by creating a <a id="_idIndexMarker416"/>component for booking new appointments, named <strong class="source-inline">AppointmentForm</strong>.</p>
<p>The first field is a select box for choosing which service the customer requires: cut, color, blow-dry, and so <a id="_idIndexMarker417"/>on. Let’s create that now:</p>
<ol>
<li>Create a new file, <strong class="source-inline">test/AppointmentForm.test.js</strong>, with the following test and setup:<p class="source-code">import React from "react";</p><p class="source-code">import {</p><p class="source-code">  initializeReactContainer,</p><p class="source-code">  render,</p><p class="source-code">  field,</p><p class="source-code">  form,</p><p class="source-code">} from "./reactTestExtensions";</p><p class="source-code">import { AppointmentForm } from "../src/AppointmentForm";</p><p class="source-code">describe("AppointmentForm", () =&gt; {</p><p class="source-code">  beforeEach(() =&gt; {</p><p class="source-code">    initializeReactContainer();</p><p class="source-code">  });</p><p class="source-code">  it("renders a form", () =&gt; {</p><p class="source-code">    render(&lt;AppointmentForm /&gt;);</p><p class="source-code">    expect(form()).not.toBeNull();</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>Make this test pass by implementing and creating a new file, <strong class="source-inline">src/AppointmentForm.js</strong>, as shown here:<p class="source-code">import React from "react";</p><p class="source-code">export const AppointmentForm = () =&gt; &lt;form /&gt;;</p></li>
<li>Create a nested <strong class="source-inline">describe</strong> block for the service field. We’ll jump to this right away because we know this form will <a id="_idIndexMarker418"/>have multiple fields:<p class="source-code">describe("service field", () =&gt; {</p><p class="source-code">});</p></li>
<li>Add the following<a id="_idIndexMarker419"/> test to the <strong class="source-inline">describe</strong> block:<p class="source-code">it("renders as a select box", () =&gt; {</p><p class="source-code">  render(&lt;AppointmentForm /&gt;);</p><p class="source-code">  expect(field("service").not.toBeNull();</p><p class="source-code">  expect(field("service").tagName).toEqual("SELECT");</p><p class="source-code">});</p></li>
<li>To make this test pass, modify the <strong class="source-inline">AppointmentForm</strong> component, as follows:<p class="source-code">export const AppointmentForm = () =&gt; (</p><p class="source-code">  &lt;form</p><p class="source-code">    <strong class="bold">&lt;select name="service" /&gt;</strong></p><p class="source-code">  &lt;/form&gt;</p><p class="source-code">);</p></li>
<li>Run the tests and ensure they are all passing.</li>
</ol>
<p>With that, we’ve done the basic scaffolding for the new select box field so that it’s ready to be populated with <strong class="source-inline">option</strong> elements.</p>
<h2 id="_idParaDest-85"><a id="_idTextAnchor083"/>Providing select box options</h2>
<p>Our salon <a id="_idIndexMarker420"/>provides a whole range of salon services. We should ensure that they are all listed in the app. We could start our test by defining our expectations, like this:</p>
<pre class="source-code">
it("lists all salon services", () =&gt; {
  const selectableServices = [
    "Cut",
    "Blow-dry",
    "Cut &amp; color",
    "Beard trim",
    "Cut &amp; beard trim",
    "Extensions"
  ];
  ...
});</pre>
<p>If we do this, we’ll end up repeating the same array of services in our test code and our production code. We can avoid that repetition by focusing our unit tests on the <em class="italic">behavior</em> of the select box rather than the static data that populates it: what should the select box <em class="italic">do</em>?</p>
<p>As it turns out, we can specify the functionality of our select box with just <em class="italic">two</em> items in our array. There’s another good reason for keeping it to just two, which is that keeping the array brief helps us focus the test on what’s important: the behavior, not the data.</p>
<p>That leaves the question, how do we use only two items in our test when we need six items for the production code?</p>
<p>We’ll do this by introducing a new prop, <strong class="source-inline">selectableServices</strong>, to <strong class="source-inline">AppointmentForm</strong>. Our tests can choose to specify a value if they need to. In our production code, we can specify a value for the<a id="_idIndexMarker421"/> component’s <strong class="source-inline">defaultProps</strong>.</p>
<p><strong class="source-inline">defaultProps</strong> is a nifty mechanism that React offers for setting default prop values that will be used when required props<a id="_idIndexMarker422"/> are not explicitly provided.</p>
<p>For our tests that <em class="italic">don’t</em> care about the select box values, we can avoid passing the prop and ignore it entirely in the test. For the tests that <em class="italic">do</em> care, we can provide a short, two-item array for our tests.</p>
<p class="callout-heading">How do we verify the real select box values?</p>
<p class="callout">Testing static data does happen, just <a id="_idIndexMarker423"/>not within our unit tests. One place this can be tested is within acceptance tests, which we’ll look at in <em class="italic">Part 4, Behavior-Driven Development with Cucumber</em>.</p>
<p>We’ll start with a test to <a id="_idIndexMarker424"/>ensure the first value is a blank entry. This is the value that’s initially selected when the user creates a new appointment: no option is selected. Let’s write that test now:</p>
<ol>
<li value="1">Add the following test at the end of the <strong class="source-inline">AppointmentForm</strong> test suite. It specifies that the very first item in the select box is blank, meaning the user is not automatically assigned a choice from our list of services: <p class="source-code">it("has a blank value as the first value", () =&gt; {</p><p class="source-code">  render(&lt;AppointmentForm /&gt;);</p><p class="source-code">  const firstOption = field("service").childNodes[0];</p><p class="source-code">  expect(firstOption.value).toEqual("");</p><p class="source-code">});</p></li>
<li>Make that pass<a id="_idIndexMarker425"/> by adding a blank <strong class="source-inline">option</strong> element to the existing <strong class="source-inline">select</strong> element:<p class="source-code">export const AppointmentForm = () =&gt; (</p><p class="source-code">  &lt;form</p><p class="source-code">    &lt;select name="service"<strong class="bold">&gt;</strong></p><p class="source-code"><strong class="bold">      &lt;option /&gt;</strong></p><p class="source-code">    <strong class="bold">&lt;/select&gt;</strong></p><p class="source-code">  &lt;/form&gt;</p><p class="source-code">);</p></li>
<li>Back in your tests, add this new helper just after the <strong class="source-inline">beforeEach</strong> block. We’ll make use of it in<a id="_idIndexMarker426"/> our next test to build an array of all the labels of the select box options:<p class="source-code">const labelsOfAllOptions = (element) =&gt;</p><p class="source-code">  Array.from(</p><p class="source-code">    element.childNodes,</p><p class="source-code">    (node) =&gt; node.textContent</p><p class="source-code">  );</p></li>
<li>Add the following test. This makes use of a new prop, <strong class="source-inline">selectableServices</strong>, which is simply the array of available options:<p class="source-code">it("lists all salon services", () =&gt; {</p><p class="source-code">  const services = ["Cut", "Blow-dry"];</p><p class="source-code">  </p><p class="source-code">  render(</p><p class="source-code">    &lt;AppointmentForm selectableServices={services} /&gt;</p><p class="source-code">  );</p><p class="source-code">  </p><p class="source-code">  expect(</p><p class="source-code">    labelsOfAllOptions(field("service"))</p><p class="source-code">  ).toEqual(expect.arrayContaining(services));</p><p class="source-code">});</p></li>
</ol>
<p class="callout-heading">Choosing test data</p>
<p class="callout">I’ve used “real” data for my expected services: <strong class="source-inline">Cut</strong> and <strong class="source-inline">Blow-dry</strong>. It’s also fine to use non-real names such as <strong class="source-inline">Service A</strong> and <strong class="source-inline">Service B</strong>. Often, that can be more descriptive. Both are valid approaches.</p>
<ol>
<li value="5">Let’s make<a id="_idIndexMarker427"/> this pass. Change the component definition, as follows:<p class="source-code">export const AppointmentForm = (<strong class="bold">{</strong></p><p class="source-code"><strong class="bold">  selectableServices</strong></p><p class="source-code"><strong class="bold">}</strong>) =&gt; (</p><p class="source-code">  &lt;form&gt;</p><p class="source-code">    &lt;select name="service"&gt;</p><p class="source-code">      &lt;option /&gt;</p><p class="source-code"><strong class="bold">      {selectableServices.map(s =&gt; (</strong></p><p class="source-code"><strong class="bold">        &lt;option key={s}&gt;{s}&lt;/option&gt;</strong></p><p class="source-code"><strong class="bold">      ))}</strong></p><p class="source-code">    &lt;/select&gt;</p><p class="source-code">  &lt;/form&gt;</p><p class="source-code">);</p></li>
<li>Check that the latest test now passes. However, you will see that our earlier tests break because of the introduction of the new prop.</li>
<li>We can make these tests pass<a id="_idIndexMarker428"/> again using <strong class="source-inline">defaultProps</strong>. Just below the definition of the <strong class="source-inline">AppointmentForm</strong> function in <strong class="source-inline">src/AppointmentForm.js</strong>, add the following:<p class="source-code">AppointmentForm.defaultProps = {</p><p class="source-code">  selectableServices: [</p><p class="source-code">    "Cut",</p><p class="source-code">    "Blow-dry",</p><p class="source-code">    "Cut &amp; color",</p><p class="source-code">    "Beard trim",</p><p class="source-code">    "Cut &amp; beard trim",</p><p class="source-code">    "Extensions",</p><p class="source-code">  ]</p><p class="source-code">};</p></li>
<li>Run your tests and verify they are passing.</li>
</ol>
<p>That’s all there is<a id="_idIndexMarker429"/> to it. With that, we’ve learned how to define the behavior of our <a id="_idIndexMarker430"/>component using a short two-item array and saved the real data for <strong class="source-inline">defaultProps</strong>.</p>
<h2 id="_idParaDest-86"><a id="_idTextAnchor084"/>Preselecting a value</h2>
<p>Let’s ensure that <a id="_idIndexMarker431"/>our component preselects the value that has already been saved if we’re editing an existing appointment:</p>
<ol>
<li value="1">Define a <strong class="source-inline">findOption</strong> arrow function at the top of the <strong class="source-inline">describe</strong> block. This function searches the DOM tree for a particular text node:<p class="source-code">const findOption = (selectBox, textContent) =&gt; {</p><p class="source-code">  const options = Array.from(selectBox.childNodes);</p><p class="source-code">  return options.find(</p><p class="source-code">    option =&gt; option.textContent === textContent</p><p class="source-code">  );</p><p class="source-code">};</p></li>
<li>In our next test, we can find that node and then check that it is selected:<p class="source-code">it("pre-selects the existing value", () =&gt; {</p><p class="source-code">  const services = ["Cut", "Blow-dry"];</p><p class="source-code">  const appointment = { service: "Blow-dry" };</p><p class="source-code">  render(</p><p class="source-code">    &lt;AppointmentForm</p><p class="source-code">      selectableServices={services}</p><p class="source-code">      original={appointment}</p><p class="source-code">    /&gt;</p><p class="source-code">  );</p><p class="source-code">  const option = findOption(</p><p class="source-code">    field("service"),</p><p class="source-code">    "Blow-dry"</p><p class="source-code">  );</p><p class="source-code">  expect(option.selected).toBe(true);</p><p class="source-code">});</p></li>
<li>To make this <a id="_idIndexMarker432"/>pass, set the value property on the<a id="_idIndexMarker433"/> root <strong class="source-inline">select</strong> tag:<p class="source-code">&lt;select</p><p class="source-code">  name="service"</p><p class="source-code"><strong class="bold">  value={original.service}</strong></p><p class="source-code"><strong class="bold">  readOnly</strong>&gt;</p></li>
</ol>
<p class="callout-heading">Accessible rich internet applications (ARIA) labels</p>
<p class="callout">If you have experience with building <a id="_idIndexMarker434"/>React applications, you may be expecting to set the <strong class="source-inline">aria-label</strong> property on the <strong class="source-inline">select</strong> element. However, one of this chapter’s <em class="italic">Exercises</em> is to add a label element for this <strong class="source-inline">select</strong> box that will <a id="_idIndexMarker435"/>ensure an ARIA label is set implicitly by the browser.</p>
<ol>
<li value="4">You’ll need to change your component props so that it includes the new <strong class="source-inline">service</strong> prop:<p class="source-code">export const AppointmentForm = ({</p><p class="source-code"><strong class="bold">  original,</strong></p><p class="source-code">  selectableServices<strong class="bold"> </strong></p><p class="source-code">}) =&gt;</p></li>
<li>Run your tests. Although this test is now passing, you’ll find the previous tests are failing <a id="_idIndexMarker436"/>because the original prop has not been set. To fix them, first, define a new constant, <strong class="source-inline">blankAppointment</strong>, just above your <strong class="source-inline">beforeEach</strong> block. We’ll use this in each of the failing tests:<p class="source-code">const blankAppointment = {</p><p class="source-code">  service: "",</p><p class="source-code">};</p></li>
<li>Update your previous tests so that they use this new constant as the value for the <strong class="source-inline">original </strong>prop. For example, the very first test for <strong class="source-inline">AppointmentForm</strong> will look as follows:<p class="source-code">it("renders a form", () =&gt; {</p><p class="source-code">  render(</p><p class="source-code">    &lt;AppointmentForm <strong class="bold">original={blankAppointment}</strong> /&gt;</p><p class="source-code">  );</p><p class="source-code">  expect(form()).not.toBeNull();</p><p class="source-code">});</p></li>
<li>Run the tests again with <strong class="source-inline">npm test</strong>; all your tests should be passing. (If they aren’t, go back and check that you’ve got an <strong class="source-inline">original</strong> prop value for each test.)</li>
<li>Let’s finish with a small bit of refactoring. Your last two tests both have the same definition for services. Pull that out of each test, placing it above the definition of <strong class="source-inline">blankAppointment</strong>. Make sure that you delete that line from both tests:<p class="source-code">describe("AppointmentForm", () =&gt; {</p><p class="source-code">  const blankAppointment = {</p><p class="source-code">    service: "",</p><p class="source-code">  };</p><p class="source-code"><strong class="bold">  const services = ["Cut", "Blow-dry"]; </strong></p><p class="source-code">  ...</p><p class="source-code">});</p></li>
</ol>
<p>That completes this test, but there is still more functionality to add if we want a fully functional select box. Completing those tests is left as one of the <em class="italic">Exercises</em> at the end of this chapter. They work the same as the tests for the text boxes in <strong class="source-inline">CustomerForm</strong>. </p>
<p>If you compare<a id="_idIndexMarker437"/> our select box tests to those of the text box, you will see that it’s a similar pattern but with a couple of additional techniques: we used <strong class="source-inline">defaultProps</strong> to<a id="_idIndexMarker438"/> separate the definition of production data from test behavior, and we defined a couple of localized helper methods, <strong class="source-inline">labelsOfAllOptions</strong> and <strong class="source-inline">findOption</strong>, to help keep our tests short.</p>
<p>Let’s move on to the next item in our form: the time of the appointment.</p>
<h1 id="_idParaDest-87"><a id="_idTextAnchor085"/>Constructing a calendar view</h1>
<p>In this section, we’ll learn <a id="_idIndexMarker439"/>how to use our existing helpers, such as <strong class="source-inline">element</strong> and <strong class="source-inline">elements</strong>, mixed with CSS selectors, to select specific elements we’re interested in within our HTML layout.</p>
<p>But first, let’s start with some planning.</p>
<p>We’d like <strong class="source-inline">AppointmentForm</strong> to display available time slots over the next 7 days as a grid, with columns representing days and rows representing 30-minute time slots, just like a standard calendar view. The user will be able to quickly find a time slot that works for them and then select the right radio button before submitting the form:</p>
<div>
<div class="IMG---Figure" id="_idContainer018">
<img alt="Figure 5.1 – The visual design of our calendar view " height="945" src="image/Figure_5.01_B18423.jpg" width="1049"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – The visual design of our calendar view</p>
<p>Here’s an <a id="_idIndexMarker440"/>example of the HTML structure that we’re aiming to build. We can use this<a id="_idIndexMarker441"/> as a guide as we write out our React<a id="_idIndexMarker442"/> component:</p>
<pre class="source-code">
&lt;table id="time-slots"&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;Oct 11&lt;/th&gt;
      &lt;th&gt;Oct 12&lt;/th&gt;
      &lt;th&gt;Oct 13&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;9:00&lt;/th&gt;
      &lt;td&gt;
        &lt;input type="option" name="timeSlot" value="..." /&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
    &lt;!-- ... two more cells ... --&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</pre>
<p>In the next few sections, we’ll<a id="_idIndexMarker443"/> test-drive the <strong class="source-inline">table</strong> element itself, then build a<a id="_idIndexMarker444"/> header column for times of the day, and then a header for days of the week.</p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor086"/>Adding the table</h2>
<p>Let’s begin<a id="_idIndexMarker445"/> by building <strong class="source-inline">table</strong> itself:</p>
<ol>
<li value="1">Create a nested <strong class="source-inline">describe</strong> block <a id="_idIndexMarker446"/>with a new test at the bottom of <strong class="source-inline">test/AppointmentForm.test.js</strong>:<p class="source-code">describe("time slot table", () =&gt; {</p><p class="source-code">  it("renders a table for time slots with an id", () =&gt; {</p><p class="source-code">    render(</p><p class="source-code">      &lt;AppointmentForm original={blankAppointment} /&gt;</p><p class="source-code">    );</p><p class="source-code">    expect(</p><p class="source-code">      element("table#time-slots")</p><p class="source-code">    ).not.toBeNull();</p><p class="source-code">  });</p><p class="source-code">});</p></li>
<li>You’ll need to pull the <strong class="source-inline">element</strong> helper into your imports:<p class="source-code">import {</p><p class="source-code">  initializeReactContainer,</p><p class="source-code">  render,</p><p class="source-code">  field,</p><p class="source-code">  form,</p><p class="source-code"><strong class="bold">  element,</strong></p><p class="source-code">} from "./reactTestExtensions";</p></li>
<li>To make that pass, move to <strong class="source-inline">src/AppointmentForm.js</strong> and define a new <strong class="source-inline">TimeSlotTable</strong> component, above<a id="_idIndexMarker447"/> the definition of <strong class="source-inline">AppointmentForm</strong>. We don’t need to mark this one as an export as it will only be referenced by <strong class="source-inline">AppointmentForm</strong>:<p class="source-code">const TimeSlotTable = () =&gt; &lt;table id="time-slots" /&gt;;</p></li>
</ol>
<p class="callout-heading">Why add an ID?</p>
<p class="callout">The ID is important because that’s what the application’s CSS uses to find the <strong class="source-inline">table</strong> element. Although it’s not covered in this book, if you’re using CSS and it defines selectors based on element IDs, then you should treat those IDs as a kind of technical specification that your code must satisfy. That’s why we write unit tests for them.</p>
<ol>
<li value="4">Add this component to your <strong class="source-inline">AppointmentForm</strong> JSX, right at the bottom, just below the <strong class="source-inline">select</strong> tag:<p class="source-code">&lt;form&gt;</p><p class="source-code">  ...</p><p class="source-code">  <strong class="bold">&lt;TimeSlotTable /&gt;</strong></p><p class="source-code">&lt;/form&gt;;</p></li>
</ol>
<p>Run the tests and verify that they are all passing.</p>
<p>That’s all there is to<a id="_idIndexMarker448"/> the <strong class="source-inline">table</strong> element. Now, let’s get some data into the first column.</p>
<h2 id="_idParaDest-89"><a id="_idTextAnchor087"/>Adding a header column</h2>
<p>For the next test, we’ll test<a id="_idIndexMarker449"/> the left-hand header column that displays a list of times. We’ll introduce two new props, <strong class="source-inline">salonOpensAt</strong> and <strong class="source-inline">salonClosesAt</strong>, which inform the component<a id="_idIndexMarker450"/> of which time to show each day. Follow these steps:</p>
<ol>
<li value="1">Add the following test:<p class="source-code">it("renders a time slot for every half an hour between open and close times", () =&gt; {</p><p class="source-code">  render(</p><p class="source-code">    &lt;AppointmentForm</p><p class="source-code">      original={blankAppointment}</p><p class="source-code">      salonOpensAt={9}</p><p class="source-code">      salonClosesAt={11}</p><p class="source-code">    /&gt;</p><p class="source-code">  );</p><p class="source-code">  const timesOfDayHeadings = elements("tbody &gt;* th");</p><p class="source-code">  expect(timesOfDayHeadings[0]).toContainText(</p><p class="source-code">    "09:00"</p><p class="source-code">  );</p><p class="source-code">  expect(timesOfDayHeadings[1]).toContainText(</p><p class="source-code">    "09:30"</p><p class="source-code">  );</p><p class="source-code">  expect(timesOfDayHeadings[3]).toContainText(</p><p class="source-code">    "10:30"</p><p class="source-code">  );</p><p class="source-code">});</p></li>
</ol>
<p class="callout-heading">Asserting on array patterns</p>
<p class="callout">In this example, we are checking <strong class="source-inline">textContent</strong> on <em class="italic">three</em> array entries, even though there are four <a id="_idIndexMarker451"/>entries in the array.</p>
<p class="callout">Properties that are the same for all array entries only need to be tested on one entry. Properties that vary per entry, such as <strong class="source-inline">textContent</strong>, need to be tested on two or three entries, depending on how many you need to test a pattern.</p>
<p class="callout">For this test, I want to test that it starts and ends at the right time and that each time slot increases by 30 minutes. I can do that with assertions on array entries 0, 1, and 3.</p>
<p class="callout">This test “breaks” our rule of one expectation per test. However, in this scenario, I think it’s okay. An alternative approach might be to use the <strong class="source-inline">textOf</strong> helper instead.</p>
<ol>
<li value="2">You’ll need to<a id="_idIndexMarker452"/> pull the <strong class="source-inline">elements</strong> helper into your imports:<p class="source-code">import {</p><p class="source-code">  initializeReactContainer,</p><p class="source-code">  render,</p><p class="source-code">  field,</p><p class="source-code">  form,</p><p class="source-code">  element,</p><p class="source-code"><strong class="bold">  elements,</strong></p><p class="source-code">} from "./reactTestExtensions";</p></li>
<li>To make this pass, add the following functions above the <strong class="source-inline">TimeSlotTable</strong> component. They calculate the list of daily time slots:<p class="source-code">const timeIncrements = (</p><p class="source-code">  numTimes,</p><p class="source-code">  startTime,</p><p class="source-code">  increment</p><p class="source-code">) =&gt;</p><p class="source-code">  Array(numTimes)</p><p class="source-code">    .fill([startTime])</p><p class="source-code">    .reduce((acc, _, i) =&gt;</p><p class="source-code">      acc.concat([startTime + i * increment])</p><p class="source-code">    );</p><p class="source-code">const dailyTimeSlots = (</p><p class="source-code">  salonOpensAt,</p><p class="source-code">  salonClosesAt</p><p class="source-code">) =&gt; {</p><p class="source-code">  const totalSlots =</p><p class="source-code">    (salonClosesAt – salonOpensAt) * 2;</p><p class="source-code">  const startTime = new Date()</p><p class="source-code">    .setHours(salonOpensAt, 0, 0, 0);</p><p class="source-code">  const increment = 30 * 60 * 1000;</p><p class="source-code">  return timeIncrements(</p><p class="source-code">    totalSlots,</p><p class="source-code">    startTime,</p><p class="source-code">    increment</p><p class="source-code">  );</p><p class="source-code">};</p></li>
<li>Define the <strong class="source-inline">toTimeValue</strong> function, as<a id="_idIndexMarker453"/> follows:<p class="source-code">const toTimeValue = timestamp =&gt;</p><p class="source-code">  new Date(timestamp).toTimeString().substring(0, 5);</p></li>
<li>Now, you can <a id="_idIndexMarker454"/>make use of those two<a id="_idIndexMarker455"/> functions. Update <strong class="source-inline">TimeSlotTable</strong> so that it reads as follows:<p class="source-code">const TimeSlotTable = (<strong class="bold">{</strong></p><p class="source-code"><strong class="bold">  salonOpensAt,</strong></p><p class="source-code"><strong class="bold">  salonClosesAt</strong></p><p class="source-code"><strong class="bold">}</strong>) =&gt; <strong class="bold">{</strong></p><p class="source-code"><strong class="bold">  const timeSlots = dailyTimeSlots(</strong></p><p class="source-code"><strong class="bold">    salonOpensAt,</strong></p><p class="source-code"><strong class="bold">    salonClosesAt);</strong></p><p class="source-code"><strong class="bold">  return (</strong></p><p class="source-code">    &lt;table id="time-slots"&gt;</p><p class="source-code">      <strong class="bold">&lt;tbody&gt;</strong></p><p class="source-code"><strong class="bold">        {timeSlots.map(timeSlot =&gt; (</strong></p><p class="source-code"><strong class="bold">          &lt;tr key={timeSlot}&gt;</strong></p><p class="source-code"><strong class="bold">            &lt;th&gt;{toTimeValue(timeSlot)}&lt;/th&gt;</strong></p><p class="source-code"><strong class="bold">          &lt;/tr&gt;</strong></p><p class="source-code"><strong class="bold">        ))}</strong></p><p class="source-code">      <strong class="bold">&lt;/tbody&gt;</strong></p><p class="source-code">    &lt;/table&gt;</p><p class="source-code"><strong class="bold">  );</strong></p><p class="source-code"><strong class="bold">};</strong></p></li>
<li>In the JSX for <strong class="source-inline">AppointmentForm</strong>, pass the <strong class="source-inline">salonOpensAt</strong> and <strong class="source-inline">salonClosesAt</strong> props<a id="_idIndexMarker456"/> to <strong class="source-inline">TimeSlotTable</strong>:<p class="source-code">export const AppointmentForm = ({</p><p class="source-code">  original,</p><p class="source-code">  selectableServices,</p><p class="source-code">  service, </p><p class="source-code"><strong class="bold">  salonOpensAt,</strong></p><p class="source-code"><strong class="bold">  salonClosesAt</strong></p><p class="source-code">}) =&gt; (</p><p class="source-code">  &lt;form&gt;</p><p class="source-code">    ...</p><p class="source-code">    &lt;TimeSlotTable</p><p class="source-code"><strong class="bold">      salonOpensAt={salonOpensAt}</strong></p><p class="source-code"><strong class="bold">      salonClosesAt={salonClosesAt}</strong> /&gt;</p><p class="source-code">  &lt;/form&gt;</p><p class="source-code">);</p></li>
<li>Fill<a id="_idIndexMarker457"/> in <strong class="source-inline">defaultProps</strong> for <a id="_idIndexMarker458"/>both <strong class="source-inline">salonOpensAt</strong> and <strong class="source-inline">salonsCloseAt</strong>:<p class="source-code">AppointmentForm.defaultProps = {</p><p class="source-code"><strong class="bold">  salonOpensAt: 9,</strong></p><p class="source-code"><strong class="bold">  salonClosesAt: 19,</strong></p><p class="source-code">  selectableServices: [ ... ]</p><p class="source-code">};</p></li>
<li>Run the tests and make sure everything is passing.</li>
</ol>
<p>That’s all there is to adding the left-hand side column of headings.</p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor088"/>Adding a header row</h2>
<p>Now, what about the column<a id="_idIndexMarker459"/> headings? In this section, we’ll create a new top row that contains these cells, making sure to leave an empty cell in the top-left corner, since the left column contains the time headings and not data. Follow these steps:</p>
<ol>
<li value="1">Add the following <a id="_idIndexMarker460"/>test:<p class="source-code">it("renders an empty cell at the start of the header row", () =&gt; </p><p class="source-code">  render(</p><p class="source-code">    &lt;AppointmentForm original={blankAppointment} /&gt;</p><p class="source-code">  );</p><p class="source-code">  const headerRow = element("thead &gt; tr");</p><p class="source-code">  expect(headerRow.firstChild).toContainText("");</p><p class="source-code">});</p></li>
<li>Modify the table JSX so that it includes a new table row:<p class="source-code">&lt;table id="time-slots"&gt;</p><p class="source-code"><strong class="bold">  &lt;thead&gt;</strong></p><p class="source-code"><strong class="bold">    &lt;tr&gt;</strong></p><p class="source-code"><strong class="bold">      &lt;th /&gt;</strong></p><p class="source-code"><strong class="bold">    &lt;/tr&gt;</strong></p><p class="source-code"><strong class="bold">  &lt;/thead&gt;</strong></p><p class="source-code">  &lt;tbody&gt;</p><p class="source-code">    ...</p><p class="source-code">  &lt;/tbody&gt;</p><p class="source-code">&lt;/table&gt;</p></li>
<li>For the rest of the header<a id="_idIndexMarker461"/> row, we’ll show the 7 days starting from today. <strong class="source-inline">AppointmentForm</strong> will need to take a new prop, <strong class="source-inline">today</strong>, which is the first day to display within the table. The value that’s assigned to that prop is stored in a variable named <strong class="source-inline">specificDate</strong>. This name has been chosen to <a id="_idIndexMarker462"/>highlight the fact that this chosen date affects the rendered day output, for example, <strong class="source-inline">"Sat 01"</strong>:<p class="source-code">it("renders a week of available dates", () =&gt; {</p><p class="source-code">  const specificDate = new Date(2018, 11, 1);</p><p class="source-code">  render(</p><p class="source-code">    &lt;AppointmentForm</p><p class="source-code">      original={blankAppointment}</p><p class="source-code">      today={specificDate}</p><p class="source-code">    /&gt;</p><p class="source-code">  );</p><p class="source-code">  const dates = elements(</p><p class="source-code">    "thead &gt;* th:not(:first-child)"</p><p class="source-code">  );</p><p class="source-code">  expect(dates).toHaveLength(7);</p><p class="source-code">  expect(dates[0]).toContainText("Sat 01");</p><p class="source-code">  expect(dates[1]).toContainText("Sun 02");</p><p class="source-code">  expect(dates[6]).toContainText("Fri 07");</p><p class="source-code">});</p></li>
</ol>
<p class="callout-heading">Why pass a date into the component?</p>
<p class="callout">When you’re testing a component that deals with dates and times, you almost always want a way to control the time values that the component will see, as we have in this test. You’ll rarely want to just use the real-world time because that can cause intermittent failures in the future. For example, your test may assume that a month has at least 30 days in the year, which is only true for 11 out of 12 months. It’s better to fix the month to a specific month rather than have an unexpected failure when February comes around.</p>
<p class="callout">For an in-depth discussion on this topic, take a look at <a href="https://reacttdd.com/controlling-time-within-unit-tests/">https://reacttdd.com/controlling-time</a>.</p>
<ol>
<li value="4">To make<a id="_idIndexMarker463"/> that pass, first, create a function that lists the 7 days we’re after, in the same way we did with time slots. You can place<a id="_idIndexMarker464"/> this just after the <strong class="source-inline">toTimeValue</strong> function:<p class="source-code">const weeklyDateValues = (startDate) =&gt; {</p><p class="source-code">  const midnight = startDate.setHours(0, 0, 0, 0);</p><p class="source-code">  const increment = 24 * 60 * 60 * 1000;</p><p class="source-code">  return timeIncrements(7, midnight, increment);</p><p class="source-code">};</p></li>
<li>Define the <strong class="source-inline">toShortDate</strong> function, which<a id="_idIndexMarker465"/> formats our date as a short string:<p class="source-code">const toShortDate = (timestamp) =&gt; {</p><p class="source-code">  const [day, , dayOfMonth] = new Date(timestamp)</p><p class="source-code">    .toDateString()</p><p class="source-code">    .split(" ");</p><p class="source-code">  return `${day} ${dayOfMonth}`;</p><p class="source-code">};</p></li>
<li>Modify <strong class="source-inline">TimeSlotTable</strong> so that it takes the <a id="_idIndexMarker466"/>new <strong class="source-inline">today</strong> prop and uses the two new<a id="_idIndexMarker467"/> functions:<p class="source-code">const TimeSlotTable = ({</p><p class="source-code">  salonOpensAt,</p><p class="source-code">  salonClosesAt<strong class="bold">,</strong></p><p class="source-code"><strong class="bold">  today</strong></p><p class="source-code">}) =&gt; {</p><p class="source-code">  <strong class="bold">const dates = weeklyDateValues(today);</strong></p><p class="source-code">  ...</p><p class="source-code">  return (</p><p class="source-code">    &lt;table id="time-slots"&gt;</p><p class="source-code">      &lt;thead&gt;</p><p class="source-code">        &lt;tr&gt;</p><p class="source-code">          &lt;th /&gt;</p><p class="source-code">          <strong class="bold">{dates.map(d =&gt; (</strong></p><p class="source-code"><strong class="bold">            &lt;th key={d}&gt;{toShortDate(d)}&lt;/th&gt;</strong></p><p class="source-code"><strong class="bold">          ))}</strong></p><p class="source-code">        &lt;/tr&gt;</p><p class="source-code">      &lt;/thead&gt;</p><p class="source-code">      ...</p><p class="source-code">    &lt;/table&gt;</p><p class="source-code">  )</p><p class="source-code">};</p></li>
<li>Within <strong class="source-inline">AppointmentForm</strong>, pass<a id="_idIndexMarker468"/> the <strong class="source-inline">today</strong> prop from <strong class="source-inline">AppointmentForm</strong> into <strong class="source-inline">TimeSlotTable</strong>:<p class="source-code">export const AppointmentForm = ({</p><p class="source-code">  original,</p><p class="source-code">  selectableServices,</p><p class="source-code">  service,</p><p class="source-code">  salonOpensAt,</p><p class="source-code">  salonClosesAt<strong class="bold">,</strong></p><p class="source-code"><strong class="bold">  today</strong></p><p class="source-code">}) =&gt; {</p><p class="source-code">  ...</p><p class="source-code">  return &lt;form&gt;</p><p class="source-code">    &lt;TimeSlotTable</p><p class="source-code">      ...</p><p class="source-code">      salonOpensAt={salonOpensAt}</p><p class="source-code">      salonClosesAt={salonClosesAt}</p><p class="source-code"><strong class="bold">      today={today}</strong></p><p class="source-code">    /&gt;</p><p class="source-code">  &lt;/form&gt;;</p><p class="source-code">};</p></li>
<li>Finally, add a <strong class="source-inline">defaultProp</strong> for <strong class="source-inline">today</strong>. Set it<a id="_idIndexMarker469"/> to the current date by calling the <strong class="source-inline">Date</strong> constructor:<p class="source-code">AppointmentForm.defaultProps = {</p><p class="source-code"><strong class="bold">  today: new Date(),</strong></p><p class="source-code">  ...</p><p class="source-code">}</p></li>
<li>Run the tests. They should be all green.</li>
</ol>
<p>With that, we’re done with our<a id="_idIndexMarker470"/> table layout. You’ve seen how to write tests that specify the table structure itself and fill in both a header column and a header row. In the next section, we’ll fill in the table cells with radio buttons.</p>
<h1 id="_idParaDest-91"><a id="_idTextAnchor089"/>Test-driving radio button groups</h1>
<p>Now that we have our<a id="_idIndexMarker471"/> table with headings in place, it’s time to add radio buttons to each of the table cells. Not all cells will have radio buttons – only those that represent an available time slot will have a radio button.</p>
<p>This means we’ll need to pass in another new prop to <strong class="source-inline">AppointmentForm</strong> that will help us determine which time slots to show. This prop is <strong class="source-inline">availableTimeSlots</strong>, which is an array of objects that list times that are still available. Follow these steps:</p>
<ol>
<li value="1">Add the following test, which establishes a value for the <strong class="source-inline">availableTimeSlots</strong> prop<a id="_idIndexMarker472"/> and then checks that radio buttons <a id="_idIndexMarker473"/>have been rendered for each of those slots:<p class="source-code">it("renders radio buttons in the correct table cell positions", () =&gt; {</p><p class="source-code">  const oneDayInMs = 24 * 60 * 60 * 1000;</p><p class="source-code">  const today = new Date();</p><p class="source-code">  const tomorrow = new Date(</p><p class="source-code">    today.getTime() + oneDayInMs</p><p class="source-code">  );</p><p class="source-code">  const availableTimeSlots = [</p><p class="source-code">    { startsAt: today.setHours(9, 0, 0, 0) },</p><p class="source-code">    { startsAt: today.setHours(9, 30, 0, 0) },</p><p class="source-code">    { startsAt: tomorrow.setHours(9, 30, 0, 0) },</p><p class="source-code">  ];</p><p class="source-code">  render(</p><p class="source-code">    &lt;AppointmentForm</p><p class="source-code">      original={blankAppointment}</p><p class="source-code">      availableTimeSlots={availableTimeSlots}</p><p class="source-code">      today={today}</p><p class="source-code">    /&gt;</p><p class="source-code">  );</p><p class="source-code">  expect(cellsWithRadioButtons()).toEqual([0, 7, 8]);</p><p class="source-code">});</p></li>
<li>Notice that this test uses a <strong class="source-inline">cellsWithRadioButtons</strong> helper, which we need to define <a id="_idIndexMarker474"/>now. You can place this just above the test; there’s no need to move it to the extension’s module since it’s specific to this one component:<p class="source-code">const cellsWithRadioButtons = () =&gt;</p><p class="source-code">  elements("input[type=radio]").map((el) =&gt;</p><p class="source-code">    elements("td").indexOf(el.parentNode)</p><p class="source-code">  );</p></li>
<li>This test checks that there are radio buttons in the first two time slots for today. These will be in cells 0 and 7 since <strong class="source-inline">elements</strong> returns matching elements in page order. We can make this test pass very simply by adding the following to our <strong class="source-inline">AppointmentForm</strong> render method, just <a id="_idIndexMarker475"/>below <strong class="source-inline">th</strong> within each <strong class="source-inline">tr</strong>:<p class="source-code">{timeSlots.map(timeSlot =&gt;</p><p class="source-code">  &lt;tr key={timeSlot}&gt;</p><p class="source-code">    &lt;th&gt;{toTimeValue(timeSlot)}&lt;/th&gt;</p><p class="source-code"><strong class="bold">    {dates.map(date =&gt; (</strong></p><p class="source-code"><strong class="bold">      &lt;td key={date}&gt;</strong></p><p class="source-code"><strong class="bold">        &lt;input type="radio" /&gt;</strong></p><p class="source-code"><strong class="bold">      &lt;/td&gt;</strong></p><p class="source-code"><strong class="bold">    ))}</strong></p><p class="source-code">  &lt;/tr&gt;</p><p class="source-code">)}</p></li>
</ol>
<p>At this point, your <a id="_idIndexMarker476"/>test will be passing.</p>
<p>We didn’t need to use <strong class="source-inline">availableTimeSlots</strong> in our production code, even though our tests require it! Instead, we just<a id="_idIndexMarker477"/> put a radio button in <em class="italic">every</em> cell! This is obviously “broken.” However, if you think back to our rule of only ever implementing the simplest thing that will make the test pass, then it makes sense. What we need now is another test to prove the opposite – that certain radio buttons do <em class="italic">not</em> exist, given <strong class="source-inline">availableTimeSlots</strong>.</p>
<h2 id="_idParaDest-92"><a id="_idTextAnchor090"/>Hiding input controls</h2>
<p>How can we get to the<a id="_idIndexMarker478"/> right implementation? We <a id="_idIndexMarker479"/>can do this by testing that having no available time slots renders no radio buttons at all:</p>
<ol>
<li value="1">Add the following test:<p class="source-code">it("does not render radio buttons for unavailable time slots", () =&gt; {</p><p class="source-code">  render(</p><p class="source-code">    &lt;AppointmentForm</p><p class="source-code">      original={blankAppointment}</p><p class="source-code">      availableTimeSlots={[]}</p><p class="source-code">    /&gt;</p><p class="source-code">  );</p><p class="source-code">  expect(</p><p class="source-code">    elements("input[type=radio]")</p><p class="source-code">  ).toHaveLength(0);</p><p class="source-code">});</p></li>
<li>To make that pass, first, move to <strong class="source-inline">src/AppointmentForm.js</strong> and define the <strong class="source-inline">mergeDateAndTime</strong> function above the <strong class="source-inline">TimeSlotTable</strong> component. This takes the date<a id="_idIndexMarker480"/> from a column header, along <a id="_idIndexMarker481"/>with a time from a row header, and converts them into a timestamp that we can use to compare against the <strong class="source-inline">startsAt</strong> fields<a id="_idIndexMarker482"/> in <strong class="source-inline">availableTimeSlots</strong>:<p class="source-code">const mergeDateAndTime = (date, timeSlot) =&gt; {</p><p class="source-code">  const time = new Date(timeSlot);</p><p class="source-code">  return new Date(date).setHours(</p><p class="source-code">    time.getHours(),</p><p class="source-code">    time.getMinutes(),</p><p class="source-code">    time.getSeconds(),</p><p class="source-code">    time.getMilliseconds()</p><p class="source-code">  );</p><p class="source-code">};</p></li>
<li>Update <strong class="source-inline">TimeSlotTable</strong> so that it takes the new <strong class="source-inline">availableTimeSlots</strong> prop:<p class="source-code">const TimeSlotTable = ({</p><p class="source-code">  salonOpensAt,</p><p class="source-code">  salonClosesAt,</p><p class="source-code">  today<strong class="bold">,</strong></p><p class="source-code"><strong class="bold">  availableTimeSlots</strong></p><p class="source-code">}) =&gt; {</p><p class="source-code">  ...</p><p class="source-code">};</p></li>
<li>Replace the existing radio button element in <strong class="source-inline">TimeSlotTable</strong> with a JSX conditional:<p class="source-code">{dates.map(date =&gt;</p><p class="source-code">  &lt;td key={date}&gt;</p><p class="source-code">    <strong class="bold">{availableTimeSlots.some(availableTimeSlot =&gt;</strong></p><p class="source-code"><strong class="bold">      availableTimeSlot.startsAt === mergeDateAndTime(date, timeSlot)</strong></p><p class="source-code"><strong class="bold">    )</strong></p><p class="source-code"><strong class="bold">     ? </strong>&lt;input type="radio" /&gt;</p><p class="source-code"><strong class="bold">     : null</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code">  &lt;/td&gt;</p><p class="source-code">)}</p></li>
<li>Also, update <strong class="source-inline">AppointmentForm</strong> so that<a id="_idIndexMarker483"/> it takes<a id="_idIndexMarker484"/> the new prop, and then pass it through to <strong class="source-inline">TimeSlotTable</strong>:<p class="source-code">export const AppointmentForm = ({</p><p class="source-code">  original,</p><p class="source-code">  selectableServices,</p><p class="source-code">  service,</p><p class="source-code">  salonOpensAt,</p><p class="source-code">  salonClosesAt,</p><p class="source-code">  today<strong class="bold">,</strong></p><p class="source-code"><strong class="bold">  availableTimeSlots</strong></p><p class="source-code">}) =&gt; {</p><p class="source-code">  ...</p><p class="source-code">  return (</p><p class="source-code">    &lt;form&gt;</p><p class="source-code">      ...</p><p class="source-code">      &lt;TimeSlotTable</p><p class="source-code">        salonOpensAt={salonOpensAt}</p><p class="source-code">        salonClosesAt={salonClosesAt}</p><p class="source-code">        today={today}</p><p class="source-code"><strong class="bold">        availableTimeSlots={availableTimeSlots} /&gt;</strong></p><p class="source-code">    &lt;/form&gt;</p><p class="source-code">  );</p><p class="source-code">};</p></li>
<li>Although your test<a id="_idIndexMarker485"/> will now be passing, the rest will be<a id="_idIndexMarker486"/> failing: they need a value for the <strong class="source-inline">availableTimeSlots</strong> prop. To do that, first, add the following definitions to the top of <strong class="source-inline">AppointmentForm</strong>:<p class="source-code">describe("AppointmentForm", () =&gt; {</p><p class="source-code">  const today = new Date();</p><p class="source-code">  const availableTimeSlots = [</p><p class="source-code">    { startsAt: today.setHours(9, 0, 0, 0) },</p><p class="source-code">    { startsAt: today.setHours(9, 30, 0, 0) },</p><p class="source-code">  ];</p></li>
<li>Go through each test and update<a id="_idIndexMarker487"/> each call to render to specify an <strong class="source-inline">availableTimeSlots</strong> prop with a value of <strong class="source-inline">availableTimeSlots</strong>. For example, the first test should have the following render call:<p class="source-code">render(</p><p class="source-code">  &lt;AppointmentForm</p><p class="source-code">    original={blankAppointment}</p><p class="source-code"><strong class="bold">    availableTimeSlots={availableTimeSlots}</strong></p><p class="source-code">  /&gt;</p><p class="source-code">);</p></li>
</ol>
<p class="callout-heading">Handling sensible defaults for props</p>
<p class="callout">Adding a default value for a new prop in every single test is no one’s idea of fun. Later in this chapter you'll learn how to avoid prop explosion in your tests by introducing a <strong class="source-inline">testProps</strong> object<a id="_idIndexMarker488"/> to group sensible default prop values.</p>
<ol>
<li value="8">Let’s continue with<a id="_idIndexMarker489"/> the next test. We must ensure each radio button has the correct value. We’ll use the <strong class="source-inline">startsAt</strong> value for each radio button’s value. Radio button values <a id="_idIndexMarker490"/>are strings, but the appointment object property, <strong class="source-inline">startsAt</strong>, is a number. We’ll use a standard library function, <strong class="source-inline">parseInt</strong>, to convert the button value back into a usable number:<p class="source-code">it("sets radio button values to the startsAt value of the corresponding appointment", () =&gt; {</p><p class="source-code">  render(</p><p class="source-code">    &lt;AppointmentForm</p><p class="source-code">      original={blankAppointment}</p><p class="source-code">      availableTimeSlots={availableTimeSlots}</p><p class="source-code">      today={today}</p><p class="source-code">    /&gt;</p><p class="source-code">  );</p><p class="source-code">  const allRadioValues = elements(</p><p class="source-code">    "input[type=radio]"</p><p class="source-code">  ).map(({ value }) =&gt; parseInt(value));</p><p class="source-code">  const allSlotTimes = availableTimeSlots.map(</p><p class="source-code">    ({ startsAt }) =&gt; startsAt</p><p class="source-code">  );</p><p class="source-code">  expect(allRadioValues).toEqual(allSlotTimes);</p><p class="source-code">});</p></li>
</ol>
<p class="callout-heading">Defining constants within tests</p>
<p class="callout">Sometimes, it’s preferable to keep constants <a id="_idIndexMarker491"/>within a test rather than pulling them out as helpers. In this case, these helpers are only used by this one test and are very specific in what they do. Keeping them inline helps you understand what the functions are doing without having to search through the file for the function definitions.</p>
<ol>
<li value="9">In your production code, pull <a id="_idIndexMarker492"/>out the ternary that <a id="_idIndexMarker493"/>contained the original call to <strong class="source-inline">mergeDateAndTime</strong> into a new component. Take care to add the new <strong class="source-inline">name</strong> and <strong class="source-inline">value</strong> attributes to the <strong class="source-inline">input</strong> element:<p class="source-code">const RadioButtonIfAvailable = ({</p><p class="source-code">  availableTimeSlots,</p><p class="source-code">  date,</p><p class="source-code">  timeSlot,</p><p class="source-code">}) =&gt; {</p><p class="source-code">  const startsAt = mergeDateAndTime(date, timeSlot);</p><p class="source-code">  if (</p><p class="source-code">    availableTimeSlots.some(</p><p class="source-code">      (timeSlot) =&gt; timeSlot.startsAt === startsAt</p><p class="source-code">    )</p><p class="source-code">  ) {</p><p class="source-code">    return (</p><p class="source-code">      &lt;input</p><p class="source-code">        name="startsAt"</p><p class="source-code">        type="radio"</p><p class="source-code">        value={startsAt}</p><p class="source-code">      /&gt;</p><p class="source-code">    );</p><p class="source-code">  }</p><p class="source-code">  return null;</p><p class="source-code">};</p></li>
</ol>
<p class="callout-heading">The name property</p>
<p class="callout">Radio buttons with the same <strong class="source-inline">name</strong> attribute are part <a id="_idIndexMarker494"/>of the same group. Clicking one radio button will check that button and uncheck all others in the group.</p>
<ol>
<li value="10">You can now use <a id="_idIndexMarker495"/>this within <strong class="source-inline">TimeSlotTable</strong>, replacing<a id="_idIndexMarker496"/> the existing ternary with an instance of this functional component. After this, your tests should be passing:<p class="source-code">{dates.map(date =&gt;</p><p class="source-code">  &lt;td key={date}&gt;</p><p class="source-code"><strong class="bold">    &lt;RadioButtonIfAvailable</strong></p><p class="source-code"><strong class="bold">      availableTimeSlots={availableTimeSlots}</strong></p><p class="source-code"><strong class="bold">      date={date}</strong></p><p class="source-code"><strong class="bold">      timeSlot={timeSlot}</strong></p><p class="source-code"><strong class="bold">    /&gt;</strong></p><p class="source-code">  &lt;/td&gt;</p><p class="source-code">)}</p></li>
</ol>
<p>Now that you’ve got the radio buttons displaying correctly, it’s time to give them some behavior.</p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor091"/>Selecting a radio button in a group</h2>
<p>Let’s see how we<a id="_idIndexMarker497"/> can use the <strong class="source-inline">checked</strong> property on the input element to ensure we set the right initial value for our radio button.</p>
<p>For this, we’ll use a helper called <strong class="source-inline">startsAtField</strong> that takes an index and returns the radio button at that position. To do that, the radio buttons must all be given the same name. This joins the radio button into a group, which means only one can be selected at a time. Follow these steps:</p>
<ol>
<li value="1">Start by adding the <strong class="source-inline">startsAtField</strong> helper at the top of the time slot table’s <strong class="source-inline">describe</strong> block:<p class="source-code">const startsAtField = (index) =&gt;</p><p class="source-code">  elements("input[name=startsAt]")[index];</p></li>
<li>Add the following test. It passes in an existing appointment with a <strong class="source-inline">startsAt</strong> value set to the second item in the <strong class="source-inline">availableTimeSlots</strong> list. Choosing the second item rather than the first isn’t strictly necessary (since the default will be for <em class="italic">all</em> radio buttons to be unchecked), but it can help highlight to future maintainers that a specific value has been chosen and is being checked:<p class="source-code">it("pre-selects the existing value", () =&gt; {</p><p class="source-code">  const appointment = {</p><p class="source-code">    startsAt: availableTimeSlots[1].startsAt,</p><p class="source-code">  };</p><p class="source-code">  render(</p><p class="source-code">    &lt;AppointmentForm</p><p class="source-code">      original={appointment}</p><p class="source-code">      availableTimeSlots={availableTimeSlots}</p><p class="source-code">      today={today}</p><p class="source-code">    /&gt;</p><p class="source-code">  );</p><p class="source-code">  expect(startsAtField(1).checked).toEqual(true);</p><p class="source-code">});</p></li>
<li>To make that pass, first, add a new <strong class="source-inline">checkedTimeSlot</strong> prop to <strong class="source-inline">TimeSlotTable</strong> that has<a id="_idIndexMarker498"/> the value of the original <strong class="source-inline">startsAt</strong> value:<p class="source-code">&lt;TimeSlotTable</p><p class="source-code">  salonOpensAt={salonOpensAt}</p><p class="source-code">  salonClosesAt={salonClosesAt}</p><p class="source-code">  today={today</p><p class="source-code">  availableTimeSlots={availableTimeSlots}</p><p class="source-code"><strong class="bold">  checkedTimeSlot={appointment.startsAt}</strong></p><p class="source-code">/&gt;</p></li>
<li>Update <strong class="source-inline">TimeSlotTable</strong> so that it makes use of this new prop, passing it through to <strong class="source-inline">RadioButtonIfAvailable</strong>:<p class="source-code">const TimeSlotTable = ({</p><p class="source-code">  ...,</p><p class="source-code"><strong class="bold">  checkedTimeSlot,</strong></p><p class="source-code">}) =&gt; {</p><p class="source-code">  ...</p><p class="source-code">    &lt;RadioButtonIfAvailable</p><p class="source-code">      availableTimeSlots={availableTimeSlots}</p><p class="source-code">      date={date}</p><p class="source-code">      timeSlot={timeSlot}</p><p class="source-code"><strong class="bold">      checkedTimeSlot={checkedTimeSlot}</strong></p><p class="source-code">    /&gt;</p><p class="source-code">  ...</p><p class="source-code">};</p></li>
<li>Now, you can make use of that in <strong class="source-inline">RadioButtonIfAvailable</strong>, setting the <strong class="source-inline">isChecked</strong> prop<a id="_idIndexMarker499"/> on the input element, as shown here. After this change, your test should be passing:<p class="source-code">const RadioButtonIfAvailable = ({</p><p class="source-code">  ...,</p><p class="source-code"><strong class="bold">  checkedTimeSlot,</strong></p><p class="source-code">}) =&gt; {</p><p class="source-code">  const startsAt = mergeDateAndTime(date, timeSlot);</p><p class="source-code">  if (</p><p class="source-code">    availableTimeSlots.some(</p><p class="source-code">      (a) =&gt; a.startsAt === startsAt</p><p class="source-code">    )</p><p class="source-code">  ) {</p><p class="source-code"><strong class="bold">    const isChecked = startsAt === checkedTimeSlot;</strong></p><p class="source-code">    return (</p><p class="source-code">      &lt;input</p><p class="source-code">        name="startsAt"</p><p class="source-code">        type="radio"</p><p class="source-code">        value={startsAt}</p><p class="source-code"><strong class="bold">        checked={isChecked}</strong></p><p class="source-code">      /&gt;</p><p class="source-code">    );</p><p class="source-code">  }</p><p class="source-code">  return null;</p><p class="source-code">};</p></li>
</ol>
<p>That’s it for setting the<a id="_idIndexMarker500"/> initial value. Next, we’ll hook up the component with the <strong class="source-inline">onChange</strong> behavior.</p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor092"/>Handling field changes through a component hierarchy</h2>
<p>Throughout this chapter, we <a id="_idIndexMarker501"/>have slowly built up a component hierarchy: <strong class="source-inline">AppointmentForm</strong> renders a <strong class="source-inline">TimeSlotTable</strong> component that renders a bunch of <strong class="source-inline">RadioButtonIfAvailable</strong> components that may (or may not) render the radio button input elements.</p>
<p>The final challenge involves how to take an <strong class="source-inline">onChange</strong> event from the input element and pass it back up to <strong class="source-inline">AppointmentForm</strong>, which will control the appointment object.</p>
<p>The code in this section will make <a id="_idIndexMarker502"/>use of the <strong class="source-inline">useCallback</strong> hook. This is a form of performance optimization: we can’t write a test to specify that this behavior exists. A good rule of thumb is that if you’re passing functions through as props, then you should consider using <strong class="source-inline">useCallback</strong>.</p>
<p class="callout-heading">The useCallback hook</p>
<p class="callout">The <strong class="source-inline">useCallback</strong> hook returns a <strong class="bold">memoized</strong> callback. This means <a id="_idIndexMarker503"/>you always<a id="_idIndexMarker504"/> get the same reference back each time it’s called, rather than a new constant with a new reference. Without this, child components that are passed the callback as a prop (such as <strong class="source-inline">TimeSlotTable</strong>) would re-render each time the parent re-renders, because the different reference would cause it to believe that a re-render was required.</p>
<p class="callout-heading">Event handlers on <strong class="source-inline">input</strong> elements don’t need to use <strong class="source-inline">useCallback</strong> because event handler props are handled centrally; changes to those props do not require re-renders.</p>
<p class="callout">The second parameter to <strong class="source-inline">useCallback</strong> is the set of dependencies that will cause <strong class="source-inline">useCallback</strong> to update. In this case, it’s <strong class="source-inline">[]</strong>, an empty array, because it isn’t dependent on any props or other functions that may change. Parameters to the function such as <strong class="source-inline">target</strong> don’t count, and <strong class="source-inline">setAppointment</strong> is a function that is guaranteed to remain constant across re-renders.</p>
<p class="callout">See the <em class="italic">Further reading</em> section at the end of this chapter for a link to more information on <strong class="source-inline">useCallback</strong>.</p>
<p>Since we haven’t done<a id="_idIndexMarker505"/> any work on submitting <strong class="source-inline">AppointmentForm</strong> yet, we need to start there. Let’s add a test for the form’s submit button:</p>
<ol>
<li value="1">Add the following test to your <strong class="source-inline">AppointmentForm</strong> test suite, which tests for the presence of a submit button. This can go at the top of the test suite, just underneath the <strong class="source-inline">renders a form</strong> test:<p class="source-code">it("renders a submit button", () =&gt; {</p><p class="source-code">  render(</p><p class="source-code">    &lt;AppointmentForm original={blankAppointment} /&gt;</p><p class="source-code">  );</p><p class="source-code">  expect(submitButton()).not.toBeNull();</p><p class="source-code">});</p></li>
<li>You’ll also need to import the <strong class="source-inline">submitButton</strong> helper into your tests:<p class="source-code">import {</p><p class="source-code">  initializeReactContainer,</p><p class="source-code">  render,</p><p class="source-code">  field,</p><p class="source-code">  form,</p><p class="source-code">  element,</p><p class="source-code">  elements,</p><p class="source-code"><strong class="bold">  submitButton,</strong></p><p class="source-code">} from "./reactTestExtensions";</p></li>
<li>To make that<a id="_idIndexMarker506"/> pass, add the button at the bottom of your <strong class="source-inline">AppointmentForm</strong>:<p class="source-code">&lt;form&gt;</p><p class="source-code">  ...</p><p class="source-code"><strong class="bold">  &lt;input type="submit" value="Add" /&gt;  </strong></p><p class="source-code">&lt;/form&gt;</p></li>
<li>For the next test, let’s submit the form and check that we get the original <strong class="source-inline">startsAt</strong> value submitted back. We’ll use the same <strong class="source-inline">expect.hasAssertions</strong> technique that we saw in the previous chapter. The test verifies that the <strong class="source-inline">onSubmit</strong> prop was called with the original, unchanged <strong class="source-inline">startsAt</strong> value:<p class="source-code">it("saves existing value when submitted", () =&gt; {</p><p class="source-code">  expect.hasAssertions();</p><p class="source-code">  const appointment = {</p><p class="source-code">    startsAt: availableTimeSlots[1].startsAt,</p><p class="source-code">  };</p><p class="source-code">  render(</p><p class="source-code">    &lt;AppointmentForm</p><p class="source-code">      original={appointment}</p><p class="source-code">      availableTimeSlots={availableTimeSlots}</p><p class="source-code">      today={today}</p><p class="source-code">      onSubmit={({ startsAt }) =&gt;</p><p class="source-code">        expect(startsAt).toEqual(</p><p class="source-code">          availableTimeSlots[1].startsAt</p><p class="source-code">        )</p><p class="source-code">      }</p><p class="source-code">    /&gt;</p><p class="source-code">  );</p><p class="source-code">  click(submitButton());</p><p class="source-code">});</p></li>
<li>Since this test <a id="_idIndexMarker507"/>uses the <strong class="source-inline">click</strong> helper, you’ll need to import it:<p class="source-code">import {</p><p class="source-code">  initializeReactContainer,</p><p class="source-code">  render,</p><p class="source-code">  field,</p><p class="source-code">  form,</p><p class="source-code">  element,</p><p class="source-code">  elements,</p><p class="source-code">  submitButton,</p><p class="source-code"><strong class="bold">  click,</strong></p><p class="source-code">} from "./reactTestExtensions";</p></li>
<li>For this test, all we need is to get the form’s <strong class="source-inline">onSubmit</strong> event handler in place. At this stage, it will simply submit the <strong class="source-inline">original</strong> object without any registered changes. Update the <strong class="source-inline">AppointmentForm</strong> component, as shown here:<p class="source-code">export const AppointmentForm = ({</p><p class="source-code">  ...,</p><p class="source-code"><strong class="bold">  onSubmit,</strong></p><p class="source-code">}) =&gt; <strong class="bold">{</strong></p><p class="source-code"><strong class="bold">  const handleSubmit = (event) =&gt; {</strong></p><p class="source-code"><strong class="bold">    event.preventDefault();</strong></p><p class="source-code"><strong class="bold">    onSubmit(original);</strong></p><p class="source-code"><strong class="bold">  };</strong></p><p class="source-code"><strong class="bold">  return</strong> (</p><p class="source-code">    &lt;form<strong class="bold"> onSubmit={handleSubmit}&gt;</strong></p><p class="source-code">      ...</p><p class="source-code">    &lt;/form&gt;</p><p class="source-code">  );</p><p class="source-code"><strong class="bold">};</strong></p></li>
<li>With that test passing, let’s add the final test. This uses a <strong class="source-inline">click</strong> action rather than <strong class="source-inline">change</strong>, which we<a id="_idIndexMarker508"/> used for the text box and select box. We click on the desired radio button just as a user would:<p class="source-code">it("saves new value when submitted", () =&gt; {</p><p class="source-code">  expect.hasAssertions();</p><p class="source-code">  const appointment = {</p><p class="source-code">    startsAt: availableTimeSlots[0].startsAt,</p><p class="source-code">  };</p><p class="source-code">  render(</p><p class="source-code">    &lt;AppointmentForm</p><p class="source-code">      original={appointment}</p><p class="source-code">      availableTimeSlots={availableTimeSlots}</p><p class="source-code">      today={today}</p><p class="source-code">      onSubmit={({ startsAt }) =&gt;</p><p class="source-code">        expect(startsAt).toEqual(</p><p class="source-code">          availableTimeSlots[1].startsAt</p><p class="source-code">        )</p><p class="source-code">      }</p><p class="source-code">    /&gt;</p><p class="source-code">  );</p><p class="source-code">  click(startsAtField(1));</p><p class="source-code">  click(submitButton());</p><p class="source-code">});</p></li>
<li>Now, the fun begins. Let’s<a id="_idIndexMarker509"/> work from the top down: we’ll start by defining a new <strong class="source-inline">appointment</strong> state object, which we’ll then use in a new event handler that modifies the current appointment when a radio button is clicked. Move to <strong class="source-inline">src/AppointmentForm.js</strong> and update your React import so that it reads as follows:<p class="source-code">import React<strong class="bold">, { useState, useCallback }</strong> from "react";</p></li>
<li>Introduce a new <strong class="source-inline">appointment</strong> state<a id="_idIndexMarker510"/> object and update your <strong class="source-inline">checkedTimeSlot</strong> prop to use this object, rather than the <strong class="source-inline">original</strong> prop value:<p class="source-code">export const AppointmentForm = ({</p><p class="source-code">  ...</p><p class="source-code">}) =&gt; {</p><p class="source-code"><strong class="bold">  const [appointment, setAppointment] = </strong></p><p class="source-code"><strong class="bold">    useState(original);</strong></p><p class="source-code">  ...</p><p class="source-code">  return (</p><p class="source-code">    &lt;form&gt;</p><p class="source-code">      ...</p><p class="source-code">      &lt;TimeSlotTable</p><p class="source-code">        ...</p><p class="source-code">        checkedTimeSlot={<strong class="bold">appointment</strong>.startsAt}</p><p class="source-code">     /&gt;</p><p class="source-code">      ...</p><p class="source-code">    &lt;/form&gt;</p><p class="source-code">  );</p><p class="source-code">};</p></li>
<li>Update the <strong class="source-inline">handleSubmit</strong> function so<a id="_idIndexMarker511"/> that it uses <strong class="source-inline">appointment</strong> rather than <strong class="source-inline">original</strong>:<p class="source-code">const handleSubmit = (event) =&gt; {</p><p class="source-code">  event.preventDefault();</p><p class="source-code">  onSubmit(<strong class="bold">appointment</strong>);</p><p class="source-code">};</p></li>
</ol>
<p class="callout-heading">The call to preventDefault</p>
<p class="callout">I’m avoiding writing the test for <strong class="source-inline">preventDefault</strong> since we’ve covered it previously. In a real application, I would almost certainly add that test again.</p>
<ol>
<li value="11">Now, it’s time for the new event handler. This is the one that makes use of <strong class="source-inline">useCallback</strong> so that <a id="_idIndexMarker512"/>we can safely pass it through to <strong class="source-inline">TimeSlotTable</strong> and beyond. Add the following <a id="_idIndexMarker513"/>definition just below the <strong class="source-inline">useState</strong> call you added in the previous step. The handler uses <strong class="source-inline">parseInt</strong> to convert between our radio button’s string value and the numeric timestamp value we’ll be storing:<p class="source-code">const handleStartsAtChange = useCallback(</p><p class="source-code">  ({ target: { value } }) =&gt;</p><p class="source-code">    setAppointment((appointment) =&gt; ({</p><p class="source-code">      ...appointment,</p><p class="source-code">      startsAt: parseInt(value),</p><p class="source-code">    })),</p><p class="source-code">  []</p><p class="source-code">);</p></li>
<li>We’ve got to weave the event handler through to the <strong class="source-inline">input</strong> element, just like we did with <strong class="source-inline">checkedTimeSlot</strong>. Start by passing it into <strong class="source-inline">TimeSlotTable</strong>:<p class="source-code">&lt;TimeSlotTable</p><p class="source-code">  salonOpensAt={salonOpensAt}</p><p class="source-code">  salonClosesAt={salonClosesAt}</p><p class="source-code">  today={today}</p><p class="source-code">  availableTimeSlots={availableTimeSlots}</p><p class="source-code">  checkedTimeSlot={appointment.startsAt}</p><p class="source-code"><strong class="bold">  handleChange={handleStartsAtChange}</strong></p><p class="source-code">/&gt;</p></li>
<li>Then, update <strong class="source-inline">TimeSlotTable</strong>, taking<a id="_idIndexMarker514"/> that prop and passing it through to <strong class="source-inline">RadioButtonIfAvailable</strong>:<p class="source-code">const TimeSlotTable = ({</p><p class="source-code">  ...,</p><p class="source-code"><strong class="bold">  handleChange,</strong></p><p class="source-code">}) =&gt; {</p><p class="source-code">   ...,</p><p class="source-code">  &lt;RadioButtonIfAvailable</p><p class="source-code">    availableTimeSlots={availableTimeSlots}</p><p class="source-code">    date={date}</p><p class="source-code">    timeSlot={timeSlot}</p><p class="source-code">    checkedTimeSlot={checkedTimeSlot}</p><p class="source-code"><strong class="bold">    handleChange={handleChange}</strong></p><p class="source-code">  /&gt;</p><p class="source-code">  ...</p><p class="source-code">};</p></li>
<li>Finally, in <strong class="source-inline">RadioButtonIfAvailable</strong>, remove the <strong class="source-inline">readOnly</strong> property on the input field and set <strong class="source-inline">onChange</strong> in its place:<p class="source-code">const RadioButtonIfAvailable = ({</p><p class="source-code">  availableTimeSlots,</p><p class="source-code">  date,</p><p class="source-code">  timeSlot,</p><p class="source-code">  checkedTimeSlot<strong class="bold">,</strong></p><p class="source-code"><strong class="bold">  handleChange</strong></p><p class="source-code">}) =&gt; {</p><p class="source-code">  ...</p><p class="source-code">  return (</p><p class="source-code">    &lt;input</p><p class="source-code">      name="startsAt"</p><p class="source-code">      type="radio"</p><p class="source-code">      value={startsAt}</p><p class="source-code">      checked={isChecked}</p><p class="source-code"><strong class="bold">      onChange={handleChange}</strong></p><p class="source-code">    /&gt;</p><p class="source-code">  );</p><p class="source-code">  ...</p><p class="source-code">};</p></li>
</ol>
<p>At this point, your<a id="_idIndexMarker515"/> test should pass, and your time slot table should be fully functional.</p>
<p>This section has covered a great deal of code: conditionally rendering <strong class="source-inline">input</strong> elements, as well as details of radio button elements, such as giving a group <strong class="source-inline">name</strong> and using the <strong class="source-inline">onChecked</strong> prop, and then passing its <strong class="source-inline">onChange</strong> event through a hierarchy of components.</p>
<p>This is a good moment to manually test what you’ve built. You’ll need to update <strong class="source-inline">src/index.js</strong> so that it loads <strong class="source-inline">AppointmentForm</strong>, together with sample data. These changes are included in the <strong class="source-inline">Chapter05/Complete</strong> directory:</p>
<div>
<div class="IMG---Figure" id="_idContainer019">
<img alt="Figure 5.2 – AppointmentForm on show " height="723" src="image/Figure_5.02_B18423.jpg" width="1088"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – AppointmentForm on show</p>
<p>You’ve now <a id="_idIndexMarker516"/>completed the work required to build the radio button table. Now it’s time to refactor.</p>
<h1 id="_idParaDest-95"><a id="_idTextAnchor093"/>Reducing effort when constructing components</h1>
<p>Let’s look at a couple of simple ways to reduce the amount of time and code needed for test suites like the one we’ve just built: first, extracting builder functions, and second, extracting objects to store sensible defaults for our component props.</p>
<h2 id="_idParaDest-96"><a id="_idTextAnchor094"/>Extracting test data builders for time and date functions</h2>
<p>You’ve already <a id="_idIndexMarker517"/>seen how we can extract reusable functions into namespaces of their own, such as the <strong class="source-inline">render</strong>, <strong class="source-inline">click</strong>, and <strong class="source-inline">element</strong> DOM functions. A special case of this is the <strong class="bold">builder</strong> function, which constructs objects that you’ll use in the <strong class="bold">Arrange</strong> and <strong class="bold">Act</strong> phases of your test.</p>
<p>The purpose of these functions is not just to remove duplication but also for simplification and to aid with comprehension.</p>
<p>We already have one<a id="_idIndexMarker518"/> candidate in our test suite, which is the following code:</p>
<pre class="source-code">
const today = new Date();
today.setHours(9, 0, 0, 0);</pre>
<p>We’ll update our test suite<a id="_idIndexMarker519"/> so that it uses a builder function called <strong class="source-inline">todayAt</strong>, which will save a<a id="_idIndexMarker520"/> bit of typing:</p>
<pre class="source-code">
todayAt(9);</pre>
<p>We’ll also extract<a id="_idIndexMarker521"/> the <strong class="source-inline">today</strong> value as a constant as we’ll also make use of that.</p>
<p class="callout-heading">Builders for domain objects</p>
<p class="callout">Most often, you’ll create builder functions for the domain objects in your code base. In our case, that would be <strong class="source-inline">customer</strong> or <strong class="source-inline">appointment</strong> objects, or even the time slot objects with the single <strong class="source-inline">startsAt</strong> field. Our code base hasn’t progressed enough to warrant this, so we’ll start with builders for the <strong class="source-inline">Date</strong> objects that we’re using. We’ll write more builders later in this book.</p>
<p>Let’s get started:</p>
<ol>
<li value="1">Create a new directory, <strong class="source-inline">test/builders</strong>. This is where all our <strong class="source-inline">builder</strong> functions will live.</li>
<li>Create a new file, <strong class="source-inline">test/builders/time.js</strong>. This is where we’ll throw everything related to time.</li>
<li>Add the following constant to your new file:<p class="source-code">export const today = new Date();</p></li>
<li>Back in <strong class="source-inline">test/AppointmentForm.test.js</strong>, add the following import, just below your other imports:<p class="source-code">import { today } from "./builders/time";</p></li>
<li>Delete the definition of the <strong class="source-inline">today</strong> constant in the test suite.</li>
<li>In <strong class="source-inline">test/builders/time.js</strong>, add the following <a id="_idIndexMarker522"/>definition of <strong class="source-inline">todayAt</strong>. Notice that this does<a id="_idIndexMarker523"/> allow us to specify hours, minutes, seconds, and milliseconds if we so choose, but it has a default value of <strong class="source-inline">0</strong> for each if we don’t specify them. We’ll make use of this full form in one of the tests. We must also make a copy of the <strong class="source-inline">today</strong> constant by calling the <strong class="source-inline">date</strong> constructor. This ensures that we <a id="_idIndexMarker524"/>don’t unexpectedly modify the <strong class="source-inline">today</strong> constant on any callers of this<a id="_idIndexMarker525"/> function:<p class="source-code">export const todayAt = (</p><p class="source-code">  hours,</p><p class="source-code">  minutes = 0,</p><p class="source-code">  seconds = 0,</p><p class="source-code">  milliseconds = 0</p><p class="source-code">) =&gt;</p><p class="source-code">  new Date(today).setHours(</p><p class="source-code">    hours,</p><p class="source-code">    minutes,</p><p class="source-code">    seconds,</p><p class="source-code">    milliseconds</p><p class="source-code">  );</p></li>
</ol>
<p class="callout-heading">Immutability of builder functions</p>
<p class="callout">If your namespaces use shared constant values, like we’re doing with <strong class="source-inline">today</strong> here, make sure your functions don’t inadvertently mutate them.</p>
<ol>
<li value="7">Back in <strong class="source-inline">test/AppointmentForm.test.js</strong>, update your<a id="_idIndexMarker526"/> import so that it includes the <a id="_idIndexMarker527"/>new function:<p class="source-code">import { today<strong class="bold">, todayAt</strong> } from "./builders/time";</p></li>
<li>Time for a search <a id="_idIndexMarker528"/>and replace! Find all occurrences of the following:<p class="source-code">today.setHours(9, 0, 0, 0)</p></li>
</ol>
<p>Replace it with the following:</p>
<p class="source-code">todayAt(9)</p>
<ol>
<li value="9">Find all <a id="_idIndexMarker529"/>occurrences of the following:<p class="source-code">today.setHours(9, 30, 0, 0)</p></li>
</ol>
<p>Replace it with the following:</p>
<p class="source-code">todayAt(9, 30)</p>
<ol>
<li value="10">Ensure your tests are still passing.</li>
<li>Move these<a id="_idIndexMarker530"/> lines from the test suite into <strong class="source-inline">test/builders/time.js</strong>:<p class="source-code">const oneDayInMs = 24 * 60 * 60 * 1000;</p><p class="source-code">const tomorrow = new Date(</p><p class="source-code">  today.getTime() + oneDayInMs</p><p class="source-code">);</p></li>
<li>Rather than use the <strong class="source-inline">tomorrow</strong> constant directly, let’s write a <strong class="source-inline">tomorrowAt</strong> helper for that:<p class="source-code">export const tomorrowAt = (</p><p class="source-code">  hours,</p><p class="source-code">  minutes = 0,</p><p class="source-code">  seconds = 0,</p><p class="source-code">  milliseconds = 0</p><p class="source-code">) =&gt;</p><p class="source-code">  new Date(tomorrow).setHours(</p><p class="source-code">    hours,</p><p class="source-code">    minutes,</p><p class="source-code">    seconds,</p><p class="source-code">    milliseconds</p><p class="source-code">  );</p></li>
<li>Update<a id="_idIndexMarker531"/> your import so<a id="_idIndexMarker532"/> that it includes the new function:<p class="source-code">import {</p><p class="source-code">  today,</p><p class="source-code">  todayAt<strong class="bold">,</strong></p><p class="source-code"><strong class="bold">  tomorrowAt</strong></p><p class="source-code">} from "./builders/time";</p></li>
<li>Delete the <a id="_idIndexMarker533"/>definitions of <strong class="source-inline">oneDayInMs</strong> and <strong class="source-inline">tomorrow</strong> from the test suite.</li>
<li>Find the following expression:<p class="source-code">tomorrow.setHours(9, 30, 0, 0)</p></li>
</ol>
<p>Replace it with the following code:</p>
<p class="source-code">tomorrowAt(9, 30)</p>
<ol>
<li value="16">Run the tests again; they should be passing.</li>
</ol>
<p>We’ll make use of these helpers again in <a href="B18423_07.xhtml#_idTextAnchor125"><em class="italic">Chapter 7</em></a>, <em class="italic">Testing useEffect and Mocking Components</em>. However, there’s one more extraction we can do before we finish with this chapter.</p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor095"/>Extracting a test props object</h2>
<p>A test props<a id="_idIndexMarker534"/> object is an object that sets sensible defaults for props that you can use to reduce the size of your <strong class="source-inline">render</strong> statements. For example, look at the following render call:</p>
<pre class="source-code">
render(
  &lt;AppointmentForm
    original={blankAppointment}
    availableTimeSlots={availableTimeSlots}
    today={today}
  /&gt;
);</pre>
<p>Depending on the test, some (or all) of these props may be irrelevant to the test. The <strong class="source-inline">original</strong> prop is necessary so that our render function doesn’t blow up when rendering existing field values. But if our test is checking that we show a label on the page, we don’t care about that – and that’s one reason we created the <strong class="source-inline">blankAppointment</strong> constant. Similarly, <strong class="source-inline">availableTimeSlots</strong> and the <strong class="source-inline">today</strong> prop may not be relevant to a test.</p>
<p>Not only that, but <a id="_idIndexMarker535"/>often, our components can end up needing a whole lot of props that are necessary for a test to function. This can end up making your tests extremely verbose.</p>
<p class="callout-heading">Too many props?</p>
<p class="callout">The technique you’re about to see is one way of dealing with many required props. But having a lot of props (say, more than four or five) might be a hint that the design of your components can be improved. Can the props be joined into a complex type? Or should the component be split into two or more components?</p>
<p class="callout">This is another example of listening to your tests. If the tests are difficult to write, take a step back and look at your component design.</p>
<p>We can define an <a id="_idIndexMarker536"/>object named <strong class="source-inline">testProps</strong> that exists at the top of our <strong class="source-inline">describe</strong> block:</p>
<pre class="source-code">
const testProps = {
  original: { ... },
  availableTimeSlots: [ ... ],
  today: ...
}</pre>
<p>This can then be used in the <strong class="source-inline">render</strong> call, like this:</p>
<pre class="source-code">
render(&lt;AppointmentForm {...testProps} /&gt;);</pre>
<p>If the test does depend <a id="_idIndexMarker537"/>on a prop, such as if its expectation mentions part of the <strong class="source-inline">props</strong> value, then you shouldn’t rely on the hidden-away value in the <strong class="source-inline">testProps</strong> object. Those values are <a id="_idIndexMarker538"/>sensible defaults. The values in your test should be prominently displayed, as in this example:</p>
<pre class="source-code">
const appointment = {
  ...blankAppointment,
  service: "Blow-dry"
};
render(
  &lt;AppointmentForm {...testProps} original={appointment} /&gt;
);
const option = findOption(field("service"), "Blow-dry");
expect(option.selected).toBe(true);</pre>
<p>Notice how the <strong class="source-inline">original</strong> prop is still included in the render call after <strong class="source-inline">testProps</strong>.</p>
<p>Sometimes, you’ll want to explicitly include a prop, even if the value is the same as the <strong class="source-inline">testProps</strong> value. That’s to highlight its use within the test. We’ll see an example of that in this section.</p>
<p class="callout-heading">When to use an explicit prop</p>
<p class="callout">As a rule of thumb, if the prop is used in your test assertions, or if the prop’s value is crucial for the scenario the test is testing, then the prop should be included explicitly in the <strong class="source-inline">render</strong> call, even if its value is the same as the value defined in <strong class="source-inline">testProps</strong>.</p>
<p>Let’s update the <strong class="source-inline">AppointmentForm</strong> test suite so that it uses a <strong class="source-inline">testProps</strong> object:</p>
<ol>
<li value="1">In your test suite, find the definitions for <strong class="source-inline">services</strong>, <strong class="source-inline">availableTimeSlots</strong>, and <strong class="source-inline">blankAppointment</strong>. These should be near the top.</li>
<li>Add the<a id="_idIndexMarker539"/> following <strong class="source-inline">testProps</strong> definition just after the other definitions:<p class="source-code">const testProps = {</p><p class="source-code">  today,</p><p class="source-code">  selectableServices: services,</p><p class="source-code">  availableTimeSlots,</p><p class="source-code">  original: blankAppointment,</p><p class="source-code">};</p></li>
<li>The first test <a id="_idIndexMarker540"/>in the suite looks like this:<p class="source-code">it("renders a form", () =&gt; {</p><p class="source-code">  render(</p><p class="source-code">    &lt;AppointmentForm</p><p class="source-code">      original={blankAppointment}</p><p class="source-code">      availableTimeSlots={availableTimeSlots}</p><p class="source-code">    /&gt;</p><p class="source-code">  );</p><p class="source-code">  expect(form()).not.toBeNull();</p><p class="source-code">});</p></li>
</ol>
<p>This can be updated to look as follows:</p>
<p class="source-code">it("renders a form", () =&gt; {</p>
<p class="source-code">  render(&lt;AppointmentForm <strong class="bold">{...testProps} </strong>/&gt;);</p>
<p class="source-code">  expect(form()).not.toBeNull();</p>
<p class="source-code">});</p>
<ol>
<li value="4">The next two tests, <strong class="source-inline">renders a submit button</strong> and <strong class="source-inline">renders as a select box</strong>, can use the same change. Go ahead and do that now.</li>
<li>Next up, we<a id="_idIndexMarker541"/> have the following test:<p class="source-code">it("has a blank value as the first value", () =&gt; {</p><p class="source-code">  render(</p><p class="source-code">    &lt;AppointmentForm</p><p class="source-code">      original={blankAppointment}</p><p class="source-code">      availableTimeSlots={availableTimeSlots}</p><p class="source-code">    /&gt;</p><p class="source-code">  );</p><p class="source-code">  const firstOption = field("service").childNodes[0];</p><p class="source-code">  expect(firstOption.value).toEqual("");</p><p class="source-code">});</p></li>
</ol>
<p>Since this test depends on having a blank value passed in for the <strong class="source-inline">service</strong> field, let’s keep the original prop there:</p>
<p class="source-code">it("has a blank value as the first value", () =&gt; {</p>
<p class="source-code">  render(</p>
<p class="source-code">    &lt;AppointmentForm</p>
<p class="source-code"><strong class="bold">      {...testProps}</strong></p>
<p class="source-code">      original={blankAppointment}</p>
<p class="source-code">    /&gt;</p>
<p class="source-code">  );</p>
<p class="source-code">  const firstOption = field("service").childNodes[0];</p>
<p class="source-code">  expect(firstOption.value).toEqual("");</p>
<p class="source-code">});</p>
<p>We’ve effectively hidden the <strong class="source-inline">availableTimeSlots</strong> property, which was noise before.</p>
<ol>
<li value="6">Next, we have a test that makes use of <strong class="source-inline">selectableServices</strong>:<p class="source-code">it("lists all salon services", () =&gt; {</p><p class="source-code">  const services = ["Cut", "Blow-dry"];</p><p class="source-code">  render(</p><p class="source-code">    &lt;AppointmentForm</p><p class="source-code">      original={blankAppointment}</p><p class="source-code">      selectableServices={services}</p><p class="source-code">      availableTimeSlots={availableTimeSlots}</p><p class="source-code">    /&gt;</p><p class="source-code">  );</p><p class="source-code">  expect(</p><p class="source-code">    labelsOfAllOptions(field("service"))</p><p class="source-code">  ).toEqual(expect.arrayContaining(services));</p><p class="source-code">});</p></li>
</ol>
<p>This test uses the <strong class="source-inline">services</strong> constant<a id="_idIndexMarker542"/> in its expectation, so this is a sign that we need to keep that as an explicit prop. Change it so that it matches the following:</p>
<p class="source-code">it("lists all salon services", () =&gt; {</p>
<p class="source-code">  const services = ["Cut", "Blow-dry"];</p>
<p class="source-code">  render(</p>
<p class="source-code">    &lt;AppointmentForm</p>
<p class="source-code"><strong class="source-inline">      {...testProps}</strong></p>
<p class="source-code">      selectableServices={services}</p>
<p class="source-code">    /&gt;</p>
<p class="source-code">  );</p>
<p class="source-code">  expect(</p>
<p class="source-code">    labelsOfAllOptions(field("service"))</p>
<p class="source-code">  ).toEqual(expect.arrayContaining(services));</p>
<p class="source-code">});</p>
<ol>
<li value="7">In the next<a id="_idIndexMarker543"/> test, it’s just <strong class="source-inline">availableTimeSlots</strong> that <a id="_idIndexMarker544"/>we can get rid of since both <strong class="source-inline">services</strong> and <strong class="source-inline">appointments</strong> are defined in the test itself:<p class="source-code">it("pre-selects the existing value", () =&gt; {</p><p class="source-code">  const services = ["Cut", "Blow-dry"];</p><p class="source-code">  const appointment = { service: "Blow-dry" };</p><p class="source-code">  render(</p><p class="source-code">    &lt;AppointmentForm</p><p class="source-code"><strong class="bold">      {...testProps}</strong></p><p class="source-code">      original={appointment}</p><p class="source-code">      selectableServices={services}</p><p class="source-code">    /&gt;</p><p class="source-code">  );</p><p class="source-code">  const option = findOption(</p><p class="source-code">    field("service"),</p><p class="source-code">    "Blow-dry"</p><p class="source-code">  );</p><p class="source-code">  expect(option.selected).toBe(true);</p><p class="source-code">});</p></li>
</ol>
<p>The remaining tests in this test suite are in the nested <strong class="source-inline">describe</strong> block for the time slot table. Updating<a id="_idIndexMarker545"/> this is left as an exercise for you.</p>
<p>You’ve now learned yet more ways to clean up your test suites: extracting test data builders and<a id="_idIndexMarker546"/> extracting a <strong class="source-inline">testProps</strong> object. Remember that using the <strong class="source-inline">testProps</strong> object isn’t always the right thing to do; it may be better to refactor your component so that it takes fewer props.</p>
<h1 id="_idParaDest-98"><a id="_idTextAnchor096"/>Summary</h1>
<p>In this chapter, you learned how to use two types of HTML form elements: select boxes and radio buttons.</p>
<p>The component we’ve built has a decent amount of complexity, mainly due to the component hierarchy that’s used to display a calendar view, but also because of the date and time functions we’ve needed to help display that view.</p>
<p>That is about as complex as it gets: writing React component tests shouldn’t feel any more difficult than it has in this chapter.</p>
<p>Taking a moment to review our tests, the biggest issue we have is the use of <strong class="source-inline">expect.hasAssertions</strong> and the unusual <strong class="bold">Arrange-Assert-Act </strong>order. In <a href="B18423_06.xhtml#_idTextAnchor099"><em class="italic">Chapter 6</em></a>, <em class="italic">Exploring Test Doubles</em>, we’ll discover how we can simplify these tests and get them back into<strong class="bold"> Arrange-Act-Assert </strong>order.</p>
<h1 id="_idParaDest-99"><a id="_idTextAnchor097"/>Exercises</h1>
<p>The following are some exercises for you to try out:</p>
<ol>
<li value="1">Add a <strong class="source-inline">toBeElementWithTag</strong> matcher that replaces the two expectations in the <strong class="source-inline">renders as a select box</strong> test. It should be used like so:<p class="source-code">expect(field("service")).toBeElementWithTag("select");</p></li>
<li>Complete the remaining tests for the <strong class="source-inline">AppointmentForm</strong> select box:<ul><li>Renders a label</li>
<li>Assigns an ID that matches the label ID</li>
<li>Saves an existing value when submitted</li>
<li>Saves a new value when submitted</li>
</ul></li>
</ol>
<p>These tests are practically the same as they were for <strong class="source-inline">CustomerForm</strong>, including the use of the <strong class="source-inline">change</strong> helper. If you want a challenge, you can try extracting these form test helpers into a module of their own that is shared between <strong class="source-inline">CustomerForm</strong> and <strong class="source-inline">AppointmentForm</strong>.</p>
<ol>
<li value="3">Update the time slot table tests so that they use the <strong class="source-inline">testProps</strong> object.</li>
<li>Update the <strong class="source-inline">AppointmentsDayView</strong> component so that it uses the <strong class="source-inline">todayAt</strong> builder, where appropriate.</li>
<li>Add the ability to choose a stylist before choosing a time slot. This should be a select box that filters based on the service required, as not all stylists will be qualified to provide all services. You’ll need to decide on a suitable data structure to hold this data. Modify <strong class="source-inline">availableTimeSlots</strong> so that it lists which stylists are available at each time, and update the table to reflect which stylist has been chosen and their availability during the week.</li>
</ol>
<h1 id="_idParaDest-100"><a id="_idTextAnchor098"/>Further reading</h1>
<p>The <strong class="source-inline">useCallback</strong> hook is useful when you’re passing event handlers through a hierarchy of components. Take a look at the React documentation for tips on how to ensure correct usage: https://reactjs.org/docs/hooks-reference.xhtml#usecallback.</p>
</div>
</div></body></html>