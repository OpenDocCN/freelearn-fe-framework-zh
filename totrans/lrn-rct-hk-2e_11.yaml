- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Advanced Hooks Provided by React
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React提供的高级Hooks
- en: In the previous chapter, we learned about implementing routes using React Router.
    Then, we learned about using the Params Hook for dynamic routes. Next, we learned
    about using the Link component to provide links to different routes. Finally,
    we learned how to programmatically redirect using the Navigation Hook.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用React Router实现路由。然后，我们学习了如何使用Params Hook实现动态路由。接下来，我们学习了如何使用Link组件提供不同路由的链接。最后，我们学习了如何使用Navigation
    Hook进行编程式重定向。
- en: In this chapter, we are going to learn about the various built-in Hooks provided
    by React. We will start by giving an overview of the built-in React Hooks, and
    then learn about various utility Hooks. Next, we will learn how to use Hooks to
    optimize the performance of your app. Finally, we will learn about advanced Effect
    Hooks.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习React提供的各种内置Hooks。我们将首先概述内置React Hooks，然后学习各种实用Hooks。接下来，我们将学习如何使用Hooks来优化您应用程序的性能。最后，我们将学习关于高级Effect
    Hooks的内容。
- en: By the end of this chapter, you will have a full overview of all the built-in
    Hooks that React provides.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将对React提供的所有内置Hooks有一个全面的了解。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Overview of built-in React Hooks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置React Hooks概述
- en: Using utility Hooks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用实用Hooks
- en: Using Hooks for performance optimizations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Hooks进行性能优化
- en: Using Hooks for advanced effects
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Hooks实现高级效果
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'A fairly recent version of Node.js should already be installed. The Node Package
    Manager (`npm`) also needs to be installed (it should come with Node.js). For
    more information on how to install Node.js, please check the official website:
    [https://nodejs.org/](https://nodejs.org/).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 应该已经安装了一个相当新的Node.js版本。Node包管理器（`npm`）也需要安装（它应该与Node.js一起安装）。有关如何安装Node.js的更多信息，请查看官方网站：[https://nodejs.org/](https://nodejs.org/)。
- en: 'We are going to use **Visual Studio Code** (**VS Code**) for the guides in
    this book, but everything should work similarly in any other editor. For more
    information on how to install VS Code, please refer to the official website: [https://code.visualstudio.com](https://code.visualstudio.com).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的指南中，我们将使用**Visual Studio Code**（**VS Code**），但在任何其他编辑器中都应该以类似的方式工作。有关如何安装VS
    Code的更多信息，请参阅官方网站：[https://code.visualstudio.com](https://code.visualstudio.com)。
- en: 'In this book, we use the following versions:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们使用以下版本：
- en: Node.js v22.14.0
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js v22.14.0
- en: '`npm` v10.9.2'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npm` v10.9.2'
- en: VS Code v1.97.2
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VS Code v1.97.2
- en: While installing a newer version should not be an issue, please note that certain
    steps might work differently on a newer version. If you are having an issue with
    the code and steps provided in this book, please try using the mentioned versions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然安装新版本不应该有问题，但请注意，某些步骤在新版本上可能会有所不同。如果您在这本书提供的代码和步骤中遇到问题，请尝试使用提到的版本。
- en: 'You can find the code for this chapter on GitHub: [https://github.com/PacktPublishing/Learn-React-Hooks-Second-Edition/tree/main/Chapter09](https://github.com/PacktPublishing/Learn-React-Hooks-Second-Edition/tree/main/Chapter09).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章的代码：[https://github.com/PacktPublishing/Learn-React-Hooks-Second-Edition/tree/main/Chapter09](https://github.com/PacktPublishing/Learn-React-Hooks-Second-Edition/tree/main/Chapter09)。
- en: It is highly recommended that you write the code on your own. Do not simply
    run the code examples that are provided with the book. It is important to write
    the code yourself to be able to learn and understand it properly. However, if
    you run into any issues, you can always refer to the code example.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议您亲自编写代码。不要简单地运行书中提供的代码示例。自己编写代码对于正确学习和理解代码非常重要。然而，如果您遇到任何问题，您始终可以参考代码示例。
- en: Overview of built-in React Hooks
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置React Hooks概述
- en: 'React provides certain built-in Hooks. We have already learned about the basic
    Hooks that React provides:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: React提供了一些内置Hooks。我们已经学习了React提供的基本Hooks：
- en: '`useState` in [*Chapter 2*](Chapter_02.xhtml#_idTextAnchor048)*, Using the
    State Hook*'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[*第2章*](Chapter_02.xhtml#_idTextAnchor048)*，使用State Hook*中，使用`useState`
- en: '`useEffect` in [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor103)*, Using the
    Reducer and Effect Hooks*'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[*第4章*](Chapter_04.xhtml#_idTextAnchor103)*，使用Reducer和Effect Hooks*中，使用`useEffect`
- en: '`useContext` in [*Chapter 5*](Chapter_05.xhtml#_idTextAnchor127)*, Implementing
    React Contexts*'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[*第5章*](Chapter_05.xhtml#_idTextAnchor127)*，实现React Contexts*中，使用`useContext`
- en: 'Additionally, React provides more advanced Hooks, which can be very useful
    in certain use cases. We already covered the following advanced Hooks:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，React 还提供了更多高级 Hooks，在某些用例中非常有用。我们已经介绍了以下高级 Hooks：
- en: '`useReducer` in [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor103)*, Using the
    Reducer and Effect Hooks*'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useReducer` 在 [*第 4 章*](Chapter_04.xhtml#_idTextAnchor103)*，使用 Reducer 和 Effect
    Hooks* 中。'
- en: '`useActionState` in [*Chapter 7*](Chapter_07.xhtml#_idTextAnchor169)*, Using
    Hooks for Handling Forms*'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useActionState` 在 [*第 7 章*](Chapter_07.xhtml#_idTextAnchor169)*，使用 Hooks 处理表单*
    中。'
- en: '`useFormStatus` (not covered yet, but similar to `useActionState`)'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useFormStatus`（尚未介绍，但类似于 `useActionState`）'
- en: '`useOptimistic` in [*Chapter 7*](Chapter_07.xhtml#_idTextAnchor169)*, Using
    Hooks for Handling Forms*'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useOptimistic` 在 [*第 7 章*](Chapter_07.xhtml#_idTextAnchor169)*，使用 Hooks 处理表单*
    中。'
- en: '`useTransition` in [*Chapter 7*](Chapter_07.xhtml#_idTextAnchor169)*, Using
    Hooks for Handling Forms*'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useTransition` 在 [*第 7 章*](Chapter_07.xhtml#_idTextAnchor169)*，使用 Hooks 处理表单*
    中。'
- en: 'However, there are still more advanced Hooks that React provides:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，React 还提供了更多的高级 Hooks：
- en: '`useRef`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useRef`'
- en: '`useImperativeHandle`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useImperativeHandle`'
- en: '`useId`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useId`'
- en: '`useSyncExternalStore`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useSyncExternalStore`'
- en: '`useDebugValue`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useDebugValue`'
- en: '`useDeferredValue`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useDeferredValue`'
- en: '`useMemo`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useMemo`'
- en: '`useCallback`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useCallback`'
- en: '`useLayoutEffect`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useLayoutEffect`'
- en: '`useInsertionEffect`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useInsertionEffect`'
- en: First, let’s recap and summarize the Hooks we have already learned about. Then,
    we are going to briefly cover all these advanced Hooks that React provides and
    learn why and how to use them.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们回顾和总结一下我们已经学过的 Hooks。然后，我们将简要介绍 React 提供的所有这些高级 Hooks，并学习为什么以及如何使用它们。
- en: useState
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`useState`'
- en: 'The **State Hook** returns a value that will persist across re-renders and
    a function to update it. A value for `initialState` can be passed to it as an
    argument:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**状态 Hook** 返回一个值，该值将在重新渲染之间持续存在，以及一个用于更新它的函数。可以将 `initialState` 的值作为参数传递给它：'
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Calling `setState` updates the value and re-renders the component with the updated
    value. If the value does not change, React will not re-render the component.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `setState` 更新值并使用更新后的值重新渲染组件。如果值没有变化，React 不会重新渲染组件。
- en: 'A function can also be passed to the `setState` function, with the first argument
    being the current value. For example, consider the following code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将一个函数传递给 `setState` 函数，第一个参数是当前值。例如，考虑以下代码：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Additionally, a function can be passed to the first argument of the Hook if
    the initial state is the result of a complex computation. In that case, the function
    will only be called once during initialization of the Hook:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果初始状态是复杂计算的结果，可以将一个函数传递给 Hook 的第一个参数。在这种情况下，该函数将在 Hook 初始化期间只调用一次：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The State Hook is the most ubiquitous Hook provided by React.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 状态 Hook 是 React 提供的最普遍的 Hook。
- en: We used this Hook in [*Chapter 2*](Chapter_02.xhtml#_idTextAnchor048)*, Using
    the State Hook*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [*第 2 章*](Chapter_02.xhtml#_idTextAnchor048)*，使用状态 Hook* 中使用了这个 Hook。
- en: useEffect
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`useEffect`'
- en: 'The **Effect Hook** accepts a function that contains code with side effects,
    such as timers and subscriptions. The function passed to the Hook will run after
    the render is done and the component is on the screen:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**Effect Hook** 接受一个包含具有副作用（如计时器和订阅）的代码的函数。传递给 Hook 的函数将在渲染完成后、组件在屏幕上时运行：'
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A cleanup function can be returned from the Hook, which will be called when
    the component unmounts and is used, for example, to clean up timers or subscriptions:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Hook 可以返回一个清理函数，当组件卸载时将被调用，例如，用于清理计时器或订阅：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The cleanup function will also be called if the component renders multiple times
    before the effect is activated again.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果组件在 effect 再次激活之前多次渲染，清理函数也将被调用。
- en: 'To avoid triggering the effect on every re-render, we can specify an array
    of values as the second argument to the Hook. When any of these values change,
    the effect will get triggered again:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在每次重新渲染时触发 effect，我们可以将值数组作为 Hook 的第二个参数。当这些值中的任何一个发生变化时，effect 将再次被触发：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This array passed as the second argument is called the dependency array of the
    effect. If you want the effect to only trigger during mounting and the cleanup
    during unmounting, you can pass an empty array as the second argument.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第二个参数传递的数组称为 effect 的依赖数组。如果你想使 effect 只在挂载时触发，并在卸载时清理，你可以将一个空数组作为第二个参数传递。
- en: We used this Hook in [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor103)*, Using
    the Reducer and Effect Hooks*.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [*第 4 章*](Chapter_04.xhtml#_idTextAnchor103)*，使用 Reducer 和 Effect Hooks*
    中使用了这个 Hook。
- en: useContext
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`useContext`'
- en: 'The **Context Hook** accepts a context object and returns the current value
    for the context. When the context provider updates its value, the Hook will trigger
    a re-render with the latest value:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**上下文钩子**接受一个上下文对象，并返回上下文的当前值。当上下文提供者更新其值时，钩子将触发重新渲染，并带有最新的值：'
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We used this Hook in [*Chapter 5*](Chapter_05.xhtml#_idTextAnchor127)*, Implementing
    React Contexts*.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [*第5章*](Chapter_05.xhtml#_idTextAnchor127)*，实现React上下文* 中使用了这个钩子。
- en: useReducer
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: useReducer
- en: 'The **Reducer Hook** is an advanced version of the `useState` Hook. It accepts
    a `reducer` as the first argument, which is a function with two arguments: `state`
    and `action`. The `reducer` function then returns the updated state computed from
    the current state and the action. If the `reducer` returns the same value as the
    previous state, React will not re-render components or trigger effects:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**Reducer钩子**是 `useState` 钩子的高级版本。它接受一个 `reducer` 作为第一个参数，它是一个具有两个参数的函数：`state`
    和 `action`。然后，`reducer` 函数返回从当前状态和动作计算出的更新后的状态。如果 `reducer` 返回与上一个状态相同的值，React
    不会重新渲染组件或触发效果：'
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We should use the `useReducer` Hook instead of the `useState` Hook when dealing
    with complex state changes. It is also easier to deal with a global state because
    we can simply pass down the `dispatch` function instead of multiple setter functions.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理复杂状态变化时，我们应该使用 `useReducer` 钩子而不是 `useState` 钩子。处理全局状态也更容易，因为我们只需简单地传递 `dispatch`
    函数而不是多个设置函数。
- en: The `dispatch` function is stable and will not change on re-renders, so it is
    safe to omit it from `useEffect` or the `useCallback` dependency arrays.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`dispatch` 函数是稳定的，在重新渲染时不会改变，因此可以从 `useEffect` 或 `useCallback` 依赖数组中省略它。'
- en: We can specify the initial state by setting the `initialState` value or specifying
    an `initFn` function as the third argument. Specifying such a function makes sense
    when computing the initial state takes a long time or when we want to reuse the
    function to reset the state through an action.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过设置 `initialState` 值或指定一个 `initFn` 函数作为第三个参数来指定初始状态。当计算初始状态需要很长时间或我们想要通过动作重置状态时，指定此类函数是有意义的。
- en: We used this Hook in [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor103)*, Using
    the Reducer and Effect Hooks*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [*第4章*](Chapter_04.xhtml#_idTextAnchor103)*，使用Reducer和Effect钩子* 中使用了这个钩子。
- en: useActionState
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: useActionState
- en: 'The **Action State Hook** is defined as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**动作状态钩子**的定义如下：'
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To define an Action State Hook, we need to provide an `action` function as
    the first argument, which has the following signature:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个动作状态钩子，我们需要提供一个 `action` 函数作为第一个参数，它具有以下签名：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We then need to pass the `action` prop to a `<form>` element. When this form
    gets submitted, the action function is called with the current state of the Hook
    and the `FormData` submitted inside the form.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要将 `action` 属性传递给一个 `<form>` 元素。当这个表单被提交时，动作函数会使用钩子的当前状态和表单内提交的 `FormData`
    被调用。
- en: Additionally, it is possible to provide an `initialState` for the Hook and use
    the `isPending` value to show a loading state while the action is being processed.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还可以为钩子提供一个 `initialState`，并使用 `isPending` 值在动作处理期间显示加载状态。
- en: We used this Hook in [*Chapter 7*](Chapter_07.xhtml#_idTextAnchor169)*, Using
    Hooks for Handling Forms*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [*第7章*](Chapter_07.xhtml#_idTextAnchor169)*，使用钩子处理表单* 中使用了这个钩子。
- en: useFormStatus
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: useFormStatus
- en: 'The **Form Status Hook** is defined as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**表单状态钩子**的定义如下：'
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It is used in cases where the form submission is not handled by us. For example,
    if we have a backend that handles the form submission for us, or if we are using
    a server action for the form state (relevant when carrying out full-stack React
    development).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 它用于我们未处理表单提交的情况。例如，如果我们有一个后端为我们处理表单提交，或者如果我们正在使用服务器操作来处理表单状态（在执行全栈React开发时相关）。
- en: 'It returns a `status` object with the following properties:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回一个具有以下属性的 `status` 对象：
- en: '`pending`: Is set to `true` if the parent `<form>` is currently being submitted'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pending`：如果父 `<form>` 正在提交，则设置为 `true`'
- en: '`data`: Contains the `FormData` that is being submitted by the parent form'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`：包含父表单提交的 `FormData`'
- en: '`method`: Set to either `''get''` or `''post''`, depending on which method
    was defined in the parent `<form>`.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`method`：设置为 `''get''` 或 `''post''`，取决于父 `<form>` 中定义了哪种方法。'
- en: '`action`: If an action function was passed to the parent `<form>`, this will
    contain a reference to it. Otherwise, it will be `null`.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`action`：如果向父 `<form>` 传递了动作函数，这将包含对该函数的引用。否则，它将是 `null`。'
- en: 'For example, it can be used to implement a submit button that is disabled while
    the form is submitting to the server-side:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，它可以用来实现一个在表单提交到服务器端时禁用的提交按钮：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The Form Status Hook can only be used in components rendered inside a `<form>`.
    Unlike other Hooks, at the time of writing, this is the only Hook that is exported
    from `react-dom`, and not `react`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 表单状态钩子只能用于在 `<form>` 内部渲染的组件中。与其他钩子不同，在撰写本文时，这是唯一从 `react-dom` 而不是 `react` 导出的钩子。
- en: useOptimistic
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: useOptimistic
- en: 'The **Optimistic Hook** has the following signature:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**乐观钩子**具有以下签名：'
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It can be used to optimistically update a state while we are waiting for the
    remote state from the server to finish updating. It accepts a state (usually from
    an API request, such as a **Query Hook**) and an `update` function. The Hook then
    returns an optimistic state and a function to add an optimistic state.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以在我们等待从服务器获取远程状态更新完成时乐观地更新状态。它接受一个状态（通常来自 API 请求，例如一个**查询钩子**）和一个 `update`
    函数。然后钩子返回一个乐观状态和一个添加乐观状态的功能。
- en: 'For example, the Optimistic Hook can be used to insert a new object into an
    array while we are waiting for the server to finish adding it. In that case, the
    update function would look as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，乐观钩子可以在我们等待服务器完成添加操作时将新对象插入数组中。在这种情况下，更新函数看起来如下：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This update function optimistically inserts a new object but adds a `pending:
    true` flag to it, so that we can later render pending objects in a different way
    (for example, slightly grayed out).'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '这个更新函数乐观地插入一个新对象，但给它添加一个 `pending: true` 标志，这样我们就可以稍后以不同的方式渲染挂起对象（例如，稍微变灰）。'
- en: We used this Hook in [*Chapter 7*](Chapter_07.xhtml#_idTextAnchor169)*, Using
    Hooks for Handling Forms*.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第7章*](Chapter_07.xhtml#_idTextAnchor169)*，使用钩子处理表单*中使用了这个钩子。
- en: useTransition
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: useTransition
- en: 'The **Transition Hook** lets you handle asynchronous operations by updating
    the state without blocking the UI. This is especially useful for rendering computationally
    expensive component trees, such as rendering tabs and their (potentially complex)
    contents, or when making a client-side router. The Transition Hook has the following
    signature:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**过渡钩子**允许你通过更新状态而不阻塞用户界面来处理异步操作。这对于渲染计算密集型的组件树特别有用，例如渲染标签及其（可能复杂的）内容，或者当制作客户端路由器时。过渡钩子具有以下签名：'
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `isPending` state can be used to handle the loading state. The `startTransition`
    function allows us to pass a function to start the transition. This function needs
    to be synchronous. While the updates (for example, setting state) triggered inside
    the functions are being executed and their effects on components evaluated, `isPending`
    will be set to `true`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `isPending` 状态来处理加载状态。`startTransition` 函数允许我们传递一个函数来启动过渡。这个函数需要是同步的。当函数内部触发更新（例如，设置状态）并评估其对组件的影响时，`isPending`
    将被设置为 `true`。
- en: This does not block the UI, so other components still behave normally while
    the transition is executing.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会阻塞用户界面，因此在过渡执行期间，其他组件仍然可以正常工作。
- en: We used this Hook in [*Chapter 7*](Chapter_07.xhtml#_idTextAnchor169)*, Using
    Hooks for Handling Forms*.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第7章*](Chapter_07.xhtml#_idTextAnchor169)*，使用钩子处理表单*中使用了这个钩子。
- en: After recapping the built-in Hooks we have already learned about, let’s now
    move on to learning about other advanced built-in Hooks, which we have not used,
    starting with built-in utility Hooks that React provides.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在回顾我们已经学过的内置钩子之后，现在让我们继续学习其他高级内置钩子，这些钩子我们尚未使用，从 React 提供的内置实用钩子开始。
- en: Using utility Hooks
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用实用钩子
- en: We start by learning about **utility Hooks**. These are Hooks that allow us
    to model certain use cases or help us when developing our own Hooks, as in [*Chapter
    12*](Chapter_12.xhtml#_idTextAnchor282)*, Building Your Own Hooks*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先学习关于**实用钩子**的内容。这些钩子允许我们模拟某些用例或在我们开发自己的钩子时帮助我们，如在[*第12章*](Chapter_12.xhtml#_idTextAnchor282)*，构建自己的钩子*中所述。
- en: We are now going to set up a demo page in our blog app to be able to test out
    the various utility Hooks.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将在我们的博客应用中设置一个演示页面，以便能够测试各种实用钩子。
- en: 'Let’s get started setting up the demo page to test out these Hooks:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始设置演示页面来测试这些钩子：
- en: 'Copy the `Chapter08_2` folder to a new `Chapter09_1` folder by executing the
    following command:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令将 `Chapter08_2` 文件夹复制到新的 `Chapter09_1` 文件夹：
- en: '[PRE15]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Open the new `Chapter09_1` folder in VS Code.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中打开新的 `Chapter09_1` 文件夹。
- en: Create a new `src/components/demo/` folder. This is where we will put our demo
    components later to try out the various Hooks we will learn about.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`src/components/demo/`文件夹。这是我们稍后放置演示组件以尝试我们将要学习的各种Hooks的地方。
- en: 'Create a new `src/pages/Demo.jsx` file, with the following content:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`src/pages/Demo.jsx`文件，内容如下：
- en: '[PRE16]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Edit `src/App.jsx` and import the `Demo` page:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/App.jsx`并导入`Demo`页面：
- en: '[PRE17]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, define a new `NavBarLink` for it:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，为它定义一个新的`NavBarLink`：
- en: '[PRE18]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, define a route for it:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为它定义一个路由：
- en: '[PRE19]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Start the `dev` server and keep it running throughout the chapter, as follows:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动`dev`服务器并在整章中保持其运行，如下所示：
- en: '[PRE20]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Click the **Demo** link in the nav bar to open the demo page.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击导航栏中的**Demo**链接以打开演示页面。
- en: Now that we have a demo page, we can get started learning about the other built-in
    advanced Hooks that React provides!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个演示页面，我们可以开始学习React提供的其他内置高级Hooks了！
- en: '![Figure 9.1 – The Demo page in our blog app](img/B31327_09_01.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – 我们博客应用中的Demo页面](img/B31327_09_01.png)'
- en: Figure 9.1 – The Demo page in our blog app
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 我们博客应用中的Demo页面
- en: useRef
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: useRef
- en: 'The **Ref Hook** returns a `ref` object that can be assigned to a component
    or element via the `ref` prop:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ref Hook**返回一个`ref`对象，可以通过`ref`属性将其分配给组件或元素：'
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: After assigning the ref object to an element or component, the ref object can
    be accessed via `refContainer.current`. If `initialValue` is set, `refContainer.current`
    will be set to this value before assignment.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在将ref对象分配给元素或组件后，可以通过`refContainer.current`访问ref对象。如果设置了`initialValue`，则在分配之前`refContainer.current`将被设置为这个值。
- en: 'ref objects can be used for various use cases, but the two main ones are:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ref对象可用于各种用例，但主要有两个：
- en: Getting a reference to an element to access it on the **Document Object Model**
    (**DOM**)
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取一个元素的引用以在**文档对象模型**（**DOM**）中访问它
- en: Keeping mutable values around that should not be affected by the React lifecycle
    (e.g., not triggering a re-render when the value is mutated)
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持可变值，这些值不应受React生命周期的影响（例如，当值被突变时不会触发重新渲染）
- en: Auto-focusing an input field using a Ref Hook
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Ref Hook自动聚焦输入字段
- en: We can use a Ref Hook to get a reference to an input field element and then
    access its `focus()` function via the DOM to implement an input field that automatically
    gets focused when it renders. While there is also an `autofocus` attribute that
    can be provided to elements via HTML, sometimes it’s necessary to do it programmatically
    – for example, if we want to focus a field after the user has finished doing something
    else.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Ref Hook获取输入字段元素的引用，然后通过DOM访问其`focus()`函数来实现渲染时自动聚焦的输入字段。虽然也可以通过HTML为元素提供`autofocus`属性，但有时需要程序化地完成它——例如，如果我们想在用户完成其他操作后聚焦一个字段。
- en: 'Let’s now get started implementing an auto-focusing input field using a Ref
    Hook:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在开始使用Ref Hook实现自动聚焦输入字段的实现：
- en: Create a new `src/components/demo/useRef/` folder.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`src/components/demo/useRef/`文件夹。
- en: 'Create a new `src/components/demo/useRef/AutoFocus.jsx` file. Inside it, import
    `useRef` and `useEffect`:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`src/components/demo/useRef/AutoFocus.jsx`文件。在其内部，导入`useRef`和`useEffect`：
- en: '[PRE22]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, define the component and a Ref Hook:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义组件和一个Ref Hook：
- en: '[PRE23]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, define an Effect Hook that is called on render and causes the input field
    to be focused:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，定义一个在渲染时被调用并导致输入字段聚焦的Effect Hook：
- en: '[PRE24]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Render the input field and pass the Ref to it:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染输入字段并将Ref传递给它：
- en: '[PRE25]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, edit `src/pages/Demo.jsx` and import the `AutoFocus` component:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编辑`src/pages/Demo.jsx`并导入`AutoFocus`组件：
- en: '[PRE26]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Render it on the `Demo` page by adjusting the component as follows:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调整组件如下，在`Demo`页面上渲染它：
- en: '[PRE27]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Refresh the page; you should see the input field getting focused automatically.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新页面；你应该看到输入字段正在自动聚焦。
- en: '![Figure 9.2 – The input field is automatically being focused](img/B31327_09_02.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 输入字段正在自动聚焦](img/B31327_09_02.png)'
- en: Figure 9.2 – The input field is automatically being focused
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 输入字段正在自动聚焦
- en: Changing state within a ref
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在一个ref中更改状态
- en: It is important to note that mutating the current value of a ref does not cause
    a re-render. If this is needed, we can use a `ref` callback function instead.
    This function will be called when the element is loaded. We can use this, for
    example, to get the initial size of an element in the DOM. We can then set the
    state of a State Hook inside this callback function to trigger a re-render.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，修改 ref 的当前值不会导致重新渲染。如果需要这样做，我们可以使用一个 `ref` 回调函数。这个函数将在元素加载时被调用。例如，我们可以使用这个函数来获取
    DOM 中元素的初始大小。然后，我们可以在回调函数内部设置 State Hook 的状态来触发重新渲染。
- en: If we do not just want to get the initial width of a component but also the
    current width (even when the component is resized later), we need to use a **Layout
    Effect Hook**. We are going to cover this use case later in this chapter, in the
    *Using Hooks for advanced effects* section.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不仅想要获取组件的初始宽度，还想要获取当前宽度（即使组件后来被调整大小），我们需要使用 **布局 Effect Hook**。我们将在本章的 *使用
    Hooks 进行高级效果* 部分稍后介绍这个用例。
- en: 'Let’s try out callback functions in refs to get the initial width of a component
    now:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们尝试在 refs 中使用回调函数来获取组件的初始宽度：
- en: 'Create a new `src/components/demo/useRef/InitialWidthMeasure.jsx` file. Inside
    it, import the `useState` function:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `src/components/demo/useRef/InitialWidthMeasure.jsx` 文件。在其中，导入 `useState`
    函数：
- en: '[PRE28]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, define the component and a State Hook to store the width of the component:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义组件和一个 State Hook 来存储组件的宽度：
- en: '[PRE29]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, define a callback function for the `ref`, which accepts the DOM `node`
    as an argument:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定义一个用于 `ref` 的回调函数，该函数接受 DOM `node` 作为参数：
- en: '[PRE30]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Check whether we successfully got a reference to the DOM node, then use the
    DOM API to get the current width of the element:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查我们是否成功获取了 DOM 节点的引用，然后使用 DOM API 获取元素的当前宽度：
- en: '[PRE31]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Render the component and add the callback function via the `ref` prop:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染组件并通过 `ref` 属性添加回调函数：
- en: '[PRE32]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Edit `src/pages/Demo.jsx` and import the `InitialWidthMeasure` component there:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `src/pages/Demo.jsx` 并在那里导入 `InitialWidthMeasure` 组件：
- en: '[PRE33]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, render the component on the **Demo** page:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 **Demo** 页面上渲染组件：
- en: '[PRE34]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The Demo page should now automatically refresh in your browser and show the
    component and its initial width!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Demo 页面应该会在您的浏览器中自动刷新并显示组件及其初始宽度！
- en: '![Figure 9.3 – The component displaying its initial width](img/B31327_09_03.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3 – 显示组件初始宽度的组件](img/B31327_09_03.png)'
- en: Figure 9.3 – The component displaying its initial width
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – 显示组件初始宽度的组件
- en: Using refs to persist mutable values across re-renders
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 refs 在重新渲染之间持久化可变值
- en: Refs can be used to access the DOM, but also to keep mutable values around even
    when the component is re-rendered, such as storing references to intervals.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Refs 可以用来访问 DOM，但也可以在组件重新渲染时保持可变值，例如存储间隔的引用。
- en: 'Let’s try that out by implementing a timer that counts the seconds passed:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过实现一个计算经过秒数的计时器来尝试一下：
- en: 'Create a new `src/components/demo/useRef/Timer.jsx` file. Inside it, import
    the `useRef`, `useState`, and `useEffect` functions:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `src/components/demo/useRef/Timer.jsx` 文件。在其中，导入 `useRef`、`useState`
    和 `useEffect` 函数：
- en: '[PRE35]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, define and export a `Timer` component:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义并导出 `Timer` 组件：
- en: '[PRE36]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Inside it, define a Ref Hook to store the interval and a State Hook to store
    the current count:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中，定义一个用于存储间隔的 Ref Hook 和一个用于存储当前计数的 State Hook：
- en: '[PRE37]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Define a function that will increase the count:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个将增加计数的函数：
- en: '[PRE38]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, define an Effect Hook that defines a new interval and stores it in the
    ref:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定义一个 Effect Hook 来定义一个新的间隔并将其存储在 ref 中：
- en: '[PRE39]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can now use this ref to clear the interval when the component unmounts:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以使用这个 ref 在组件卸载时清除间隔：
- en: '[PRE40]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Render the current count of the timer:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染计时器的当前计数：
- en: '[PRE41]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Lastly, render a button to cancel the timer:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，渲染一个按钮来取消计时器：
- en: '[PRE42]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If we did not need to access the interval ID outside of the Effect Hook, we
    could simply use a `const` inside the effect instead of defining a Ref. While
    we could use a State Hook to store the interval ID, this would cause the component
    to re-render. As we can see, Refs are ideal for storing values that need to change
    but are not used for rendering.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不需要在 Effect Hook 之外访问间隔 ID，我们可以在 effect 中简单地使用一个 `const` 而不是定义一个 Ref。虽然我们可以使用
    State Hook 来存储间隔 ID，但这会导致组件重新渲染。正如我们所见，Refs 对于存储需要改变但又不用于渲染的值是理想的。
- en: 'Edit `src/pages/Demo.jsx` and import the `Timer` component there:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `src/pages/Demo.jsx` 并在那里导入 `Timer` 组件：
- en: '[PRE43]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, render the component on the Demo page:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 Demo 页面上渲染组件：
- en: '[PRE44]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The Demo page should now automatically refresh in your browser and show the
    component counting seconds! Press the **Cancel** button to stop the timer.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Demo页面应该会在你的浏览器中自动刷新并显示计数秒数的组件！按下**取消**按钮停止计时器。
- en: Using refs as in the previous example makes them similar to instance variables
    in classes, such as `this.intervalRef`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用refs的方式与前面的例子相似，这使得它们类似于类中的实例变量，例如`this.intervalRef`。
- en: 'The following screenshot shows what the `Timer` component looks like on the
    Demo page after 42 seconds have elapsed since opening the page:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在页面打开后42秒，Demo页面上的`Timer`组件的外观：
- en: '![Figure 9.4 – The Timer component showing seconds elapsed since being rendered](img/B31327_09_04.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4 – 显示自渲染以来经过的秒数的计时器组件](img/B31327_09_04.png)'
- en: Figure 9.4 – The Timer component showing seconds elapsed since being rendered
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – 显示自打开页面以来经过的秒数的计时器组件
- en: Passing refs as props
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将引用作为属性传递
- en: Sometimes, you may want to get a ref to an input field inside another component
    (for example, when dealing with custom input fields). In the past, this required
    the `forwardRef` helper. However, since React 19, we can simply pass refs as props.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能想要获取另一个组件内部输入字段的引用（例如，当处理自定义输入字段时）。在过去，这需要`forwardRef`辅助函数。然而，自从React
    19以来，我们可以简单地通过属性传递refs。
- en: 'Let’s try it out:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试看：
- en: Create a new `src/components/demo/useRef/CustomInput.jsx` file.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`src/components/demo/useRef/CustomInput.jsx`文件。
- en: 'Inside it, define the following custom input component, accepting a ref as
    a prop:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中定义以下自定义输入组件，接受一个引用作为属性：
- en: '[PRE45]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can use the ref as usual now:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以像往常一样使用refs：
- en: '[PRE46]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, edit the `src/components/demo/useRef/AutoFocus.jsx` file and import the
    `CustomInput` component:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编辑`src/components/demo/useRef/AutoFocus.jsx`文件并导入`CustomInput`组件：
- en: '[PRE47]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Replace the input field with our `CustomInput` component, and pass the ref
    to it:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将输入字段替换为我们的`CustomInput`组件，并将引用传递给它：
- en: '[PRE48]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Refresh the Demo page and you will see that the input field is still getting
    autofocused!
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新Demo页面，你会看到输入字段仍然在自动聚焦！
- en: Creating ref contents only once
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 只创建一次refs内容
- en: 'If you have a complex algorithm that needs initialization, for example, a pathfinding
    algorithm, it is possible to store a reference to it in a ref to avoid creating
    it on every render. This should be done as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个需要初始化的复杂算法，例如路径查找算法，你可以将其存储在refs中，以避免在每次渲染时创建它。这应该这样做：
- en: '[PRE49]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Generally, writing or reading `ref.current` in a render like that is not allowed
    in React. However, in this case, it is fine because the condition makes it only
    execute once when the component is initialized.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在渲染中像那样写入或读取`ref.current`在React中是不允许的。然而，在这种情况下，这是可以的，因为条件使得它只在一开始初始化组件时执行一次。
- en: While React always only saves the initial value of a ref once, directly calling
    the function inside the Ref Hook, such as `useRef(createPathfinder())`, would
    unnecessarily execute the expensive function on every render.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然React总是只保存refs的初始值一次，但直接在Ref Hook内部调用函数，如`useRef(createPathfinder())`，会在每次渲染时无谓地执行昂贵的函数。
- en: 'As we have seen, there are many use cases for refs. Generally, refs are useful
    to do the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，refs有很多用例。通常，refs对于以下操作很有用：
- en: '**Store information between re-renders**, because – unlike regular variables
    – refs do not reset when re-rendering'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在重新渲染之间存储信息**，因为——与常规变量不同——refs在重新渲染时不会重置'
- en: '**Change information without triggering a re-render**, because – unlike State
    Hooks – refs do not trigger a re-render'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在不触发重新渲染的情况下更改信息**，因为——与State Hooks不同——refs不会触发重新渲染'
- en: '**Store information local to each copy of the component**, because – unlike
    regular variables outside of components – refs do not have a shared value between
    different instances of a component'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储每个组件副本本地的信息**，因为——与组件外部的常规变量不同——refs在组件的不同实例之间没有共享值'
- en: useImperativeHandle
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: useImperativeHandle
- en: The **Imperative Handle Hook** can be used to customize instance values that
    are exposed to other components when pointing a `ref` to it. Doing this should
    be avoided as much as possible, however, as it tightly couples components together,
    which harms reusability.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**强制处理Hook**可以用来自定义当将`ref`指向它时暴露给其他组件的实例值。然而，应该尽可能避免这样做，因为它紧密耦合了组件，这会损害可重用性。'
- en: 'The `useImperativeHandle` function has the following signature:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`useImperativeHandle`函数具有以下签名：'
- en: '[PRE50]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We can use this Hook, for example, to expose a special `focus` function that
    not only focuses an input field but also highlights it. Other components can then
    trigger this function via a `ref` to the component. Let’s try it out now:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个 Hook，例如，来公开一个特殊的 `focus` 函数，该函数不仅聚焦输入字段，还突出显示它。然后，其他组件可以通过对组件的 `ref`
    调用此函数。现在让我们试试看：
- en: Create a new `src/components/demo/useImperativeHandle/` folder.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `src/components/demo/useImperativeHandle/` 文件夹。
- en: Inside it, create a new `src/components/demo/useImperativeHandle/HighlightFocusInput.jsx`
    file.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中，创建一个新的 `src/components/demo/useImperativeHandle/HighlightFocusInput.jsx`
    文件。
- en: 'Import the `useImperativeHandle`, `useRef`, and `useState` functions:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `useImperativeHandle`、`useRef` 和 `useState` 函数：
- en: '[PRE51]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Then, define a component that accepts a `ref`:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义一个接受 `ref` 的组件：
- en: '[PRE52]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Inside the component, we define a Ref Hook for the input field and a State
    Hook to store the `highlight` state:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件内部，我们为输入字段定义一个 Ref Hook 和一个用于存储 `highlight` 状态的状态 Hook：
- en: '[PRE53]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, define an Imperative Handle Hook, pass the `ref` to it, and pass a function
    that returns an object:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定义一个 Imperative Handle Hook，将其 `ref` 传递给它，并传递一个返回对象的函数：
- en: '[PRE54]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This object contains a `focus` function, which will trigger the `focus` function
    on the `input` element, and then set the `highlight` state to `true` for a second:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此对象包含一个 `focus` 函数，它将在 `input` 元素上触发 `focus` 函数，并将 `highlight` 状态设置为 `true`
    一秒钟：
- en: '[PRE55]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Lastly, render an input field and pass `inputRef` to it:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，渲染一个输入字段并将 `inputRef` 传递给它：
- en: '[PRE56]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If `highlight` is set to `true`, render the background in a `yellow` color:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `highlight` 设置为 `true`，则以 `yellow` 颜色渲染背景：
- en: '[PRE57]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Create a new `src/components/demo/useImperativeHandle/HighlightFocus.jsx` file.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `src/components/demo/useImperativeHandle/HighlightFocus.jsx` 文件。
- en: 'Inside it, import the `useRef` function and the `HighlightFocusInput` component:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中，导入 `useRef` 函数和 `HighlightFocusInput` 组件：
- en: '[PRE58]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, define a component and a Ref Hook:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定义一个组件和一个 Ref Hook：
- en: '[PRE59]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Render a button to trigger the `focus` function from the component, and then
    render the component and pass the `ref` to it:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染一个按钮以触发组件中的 `focus` 函数，然后渲染组件并将 `ref` 传递给它：
- en: '[PRE60]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Edit `src/pages/Demo.jsx` and import the `HighlightFocus` component:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `src/pages/Demo.jsx` 并导入 `HighlightFocus` 组件：
- en: '[PRE61]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Render the `HighlightFocus` component, as follows:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染 `HighlightFocus` 组件，如下所示：
- en: '[PRE62]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Now, go to the **Demo** page and click the **focus it** button. You will see
    the input field getting focused and highlighted!
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到 **Demo** 页面并点击 **focus it** 按钮。你会看到输入字段被聚焦并高亮显示！
- en: '![Figure 9.5 – The component focusing and highlighting the input field](img/B31327_09_05.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.5 – 组件聚焦并突出显示输入字段](img/B31327_09_05.png)'
- en: Figure 9.5 – The component focusing and highlighting the input field
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – 组件聚焦并突出显示输入字段
- en: As we can see, by using refs and the Imperative Handle Hook, we can access functions
    from other components. However, this should be used with caution, as it tightly
    couples components, which can become a problem when our app grows and we want
    to reuse the components somewhere else.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，通过使用 refs 和 Imperative Handle Hook，我们可以访问其他组件中的函数。然而，这应该谨慎使用，因为它紧密耦合了组件，当我们的应用增长并且我们想在其他地方重用组件时，可能会成为一个问题。
- en: useId
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: useId
- en: 'The **Id Hook** is used to generate unique IDs. This can be useful, for example,
    to provide IDs for elements for accessibility attributes (such as `aria-labelledby`
    or `aria-describedby`). The Id Hook has the following signature:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '**Id Hook** 用于生成唯一的 ID。这可以很有用，例如，为元素提供 IDs 以提供无障碍属性（如 `aria-labelledby` 或 `aria-describedby`）。Id
    Hook 具有以下签名：'
- en: '[PRE63]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Let’s try it out now by providing a label for a checkbox field:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过为复选框字段提供一个标签来尝试它：
- en: Create a new `src/components/demo/useId/` folder.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `src/components/demo/useId/` 文件夹。
- en: Inside it, create a new `src/components/demo/useId/AriaInput.jsx` file.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中，创建一个新的 `src/components/demo/useId/AriaInput.jsx` 文件。
- en: 'Import the `useId` function:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `useId` 函数：
- en: '[PRE64]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Then, define a component that uses the Id Hook to generate an ID for a label:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义一个使用 Id Hook 为标签生成 ID 的组件：
- en: '[PRE65]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Render a label with the `htmlFor` tag pointing to `inputId`:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染一个带有 `htmlFor` 标签指向 `inputId` 的标签：
- en: '[PRE66]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Render a `checkbox` field with the generated ID:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用生成的 ID 渲染一个 `checkbox` 字段：
- en: '[PRE67]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Edit `src/pages/Demo.jsx` and import the `AriaInput` component:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `src/pages/Demo.jsx` 并导入 `AriaInput` 组件：
- en: '[PRE68]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Then, render the component on the Demo page:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 Demo 页面上渲染该组件：
- en: '[PRE69]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now, go to the **Demo** page and open the inspector on the input field; you
    will see that React generated an `:r0:` ID for us:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到 **Demo** 页面并打开输入字段的检查器；你会看到 React 为我们生成了一个 `:r0:` ID：
- en: '![Figure 9.6 – A unique ID being generated automatically by React](img/B31327_09_06.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – A unique ID being generated automatically by React
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: In React 19.1, the format of IDs was changed from `:r123:` to `«r123»`, to ensure
    that they are valid CSS selectors.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: In addition to connecting the label to the input field for screen readers (improving
    accessibility), using a `<label>` element has the added advantage of allowing
    us to click on the label to check/uncheck the checkbox.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'While we could manually set an ID in this case, for example, `tos-check`, the
    ID needs to be unique across the whole page. So, if we wanted to render the same
    input field again, the ID would already be invalid, as it is reused. To prevent
    this issue, always prefer to use the Id Hook for these cases so that the component
    can be reused multiple times on the same page. If you have multiple input fields
    in a single component, it is best practice to only use a single Id Hook in the
    component and then extend IDs by adding tags to the generated ID – for example:
    `` `${id}-tos-check` `` and `` `${id}-username` ``.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: useSyncExternalStore
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Sync External Store Hook** is used to subscribe to external stores, such
    as state management libraries or browser APIs. Its signature looks as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'As we can see, the Sync External Store Hook accepts three parameters and returns
    the current snapshot of the store, which can be used to render information from
    it. The parameters are as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter, `subscribe`, is a function that takes a `callback` function
    as an argument and subscribes it to the store. When the store changes, the provided
    function should be called. The `subscribe` function should also return a function
    that cleans up the subscription.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second parameter, `getSnapshot`, is a function that returns a snapshot of
    the current state of the data in the store. If the store changes (the `callback`
    function in the `subscribe` function is called), React calls the `getSnapshot`
    function and checks whether the returned value is different. If it is, the component
    will re-render.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third parameter, `getServerSnapshot`, is an optional function that returns
    the initial snapshot of the current state of the data in the store. This function
    is only called during server rendering and used to hydrate server-rendered content
    on the client.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In most cases, you will be better off using State and Reducer Hooks instead
    of this Hook. Most state management libraries also provide their own Hooks. This
    Hook is mostly useful when integrating with existing non-React code, but it can
    also be useful when interacting with certain browser APIs, which is what we are
    going to try out now.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s implement an indicator that checks whether a network connection is available
    or not, by subscribing to a browser API via the Sync External Store Hook:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `src/components/demo/useSyncExternalStore/` folder.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside it, create a new `src/components/demo/useSyncExternalStore/OnlineIndicator.jsx`
    file.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `useSyncExternalStore` function:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Define a `subscribe` function that accepts a `callback` function as an argument:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Add event listeners for the `online` and `offline` events from the browser:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Return a function that will clean up those event listeners:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now, define a `getSnapshot` function that returns the current online status:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Then, define the component and a Sync External Store Hook:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Define the status based on the result from the browser API:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Render the status:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Edit `src/pages/Demo.jsx` and import the `OnlineIndicator` component:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Render the component on the Demo page:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Now, go to the **Demo** page and (if you are online) it should show **online**.
    Turn all network connections off to see it change to **offline**.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Detecting that the user has gone offline via an external store
    (browser APIs)](img/B31327_09_07.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – Detecting that the user has gone offline via an external store
    (browser APIs)
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: useDebugValue
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Debug Value Hook is useful for developing custom Hooks that are part of
    shared libraries. It can be used to show certain values for debugging in React
    DevTools. Its signature is as follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The first parameter, `value`, is the value or message that should be logged.
    The second, optional `format` parameter is used to provide a format function that
    will format the value before being shown.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s briefly try it out by defining a custom Hook for the `OnlineIndicator`
    component:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit `src/components/demo/useSyncExternalStore/OnlineIndicator.jsx` and import
    the `useDebugValue` function:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Then, define a new Hook function before the component is defined:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Add the Debug Value Hook, as follows:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Return the status from the Hook:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Adjust the component to use the custom Hook instead:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Now, go to the **Demo** page. If you haven’t already installed the **React Developer
    Tools** extension, please install it for your browser (follow the instructions
    at [https://react.dev/learn/react-developer-tools](https://react.dev/learn/react-developer-tools)).
    Go to the **Components** tab in the inspector of your browser and select the `OnlineIndicator`
    component.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see the debug value of the custom Hook being shown there:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8 – The status of our custom Hook being shown in the React Developer
    Tools](img/B31327_09_08.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – The status of our custom Hook being shown in the React Developer
    Tools
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: After learning about the various built-in utility Hooks that React provides,
    let’s move on to learning about using built-in Hooks for performance optimizations.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: Using Hooks for performance optimizations
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Certain Hooks can be used to optimize the performance of your app. Generally,
    the rule of thumb is to not optimize prematurely. This is especially true with
    the React Compiler, introduced in React 19\. Nowadays, the React Compiler optimizes
    most cases for us automatically. So, keep in mind to only use these Hooks when
    you have identified a specific performance problem with your app. Generally, the
    rule of thumb is to not optimize prematurely unless you know it will be an expensive
    computation.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 'The React Compiler is a Babel plugin that can be manually installed, and it
    also ships with certain frameworks, such as Next.js. For more information on the
    React Compiler, please read the following page in the React docs: [https://react.dev/learn/react-compiler](https://react.dev/learn/react-compiler).'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: useDeferredValue
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Deferred Value Hook** can be used to defer low-priority updates (such
    as filtering a list) so that higher-priority updates (such as updating the text
    entered in an input field) can be processed first.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you have a search where text can be entered to filter items,
    the Deferred Value Hook can be used to defer updates to the filter. Unlike debouncing,
    where we set a fixed time after which updates are persisted, deferring is dynamic
    and dependent on how fast the UI can be rendered. On faster machines, it will
    update more frequently, while on slower machines, updates will not slow down the
    rest of the UI.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 'The signature of the `useDeferredValue` function looks as follows:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The first parameter is a value to be deferred. For example, this value can be
    from a State Hook that handles user input.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: The second parameter is an optional initial value used for the initial render
    of the component. If no initial value is defined, the Hook will not defer during
    the initial render because there is no value that it can render until `value`
    gets set (for example, by the user typing into an input field).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a search without deferred values
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s first implement a search page where blog posts are searched, without
    using deferred values:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit `src/api.js` and define a function to produce an artificial delay, so
    that we can simulate the search operation being slow:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Next, define a `searchPosts` API function, which fetches all posts (featured
    and non-featured):'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Then, filter the posts using a simple search (making both the title and query
    lowercase and then checking whether the query is included in the title):'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Add an artificial delay of one second:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Then, return the filtered posts:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Create a new `src/components/post/PostSearchResults.jsx` file. Inside it, import
    the following:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Now, define a component that will display the search results for a given query
    using the Suspense Query Hook, our API function, and the `PostList` component:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Next, create a new `src/components/post/PostSearch.jsx` file. Inside it, import
    the following:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Define a `PostSearch` component that uses a State Hook and an input field to
    handle the query:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Define a `Suspense` boundary and, inside it, render the `PostSearchResults`
    component:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Create a new `src/pages/Search.jsx` file. Inside it, import the `PostSearch`
    component:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Render a page with the `PostSearch` component, as follows:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Edit `src/App.jsx` and import the `Search` page:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Add a link to the page, as follows:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Finally, define the route:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Now go to the **Search** page and enter a query into the search; you will see
    that it shows **loading…** for a second before showing the new results.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9 – Waiting for the new results to load](img/B31327_09_09.png)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – Waiting for the new results to load
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: While this search works, it’s not a great user experience to replace all results
    with a **loading…** message while the user is typing a query.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: Introducing deferred values
  id: totrans-389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the Deferred Value Hook, we can improve this behavior by showing the old
    query results while the new results are being fetched, and then seamlessly replace
    them with the new results once they are ready.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get started using the Deferred Value Hook now:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit `src/components/post/PostSearch.jsx` and import the `useDeferredValue`
    function:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Define the Deferred Value Hook inside the `PostSearch` component:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Now, replace the `query` for the `SearchResults` component with `deferredQuery`:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Go to the **Search** page and enter a query into the search input field; you
    will see that the previous results are shown until the new results come in. The
    **loading…** message is now only displayed initially before the first query is
    entered!
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.10 – Showing stale results while the new results are loading](img/B31327_09_10.png)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
- en: Figure 9.10 – Showing stale results while the new results are loading
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: useMemo
  id: totrans-401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Memo Hook** takes the result of a function and memoizes it. This means
    that it will not be recomputed every time. This Hook can be used for performance
    optimizations:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: In the previous example, `computeVal` is a performance-heavy function that computes
    a result from `a`, `b`, and `c`.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '`useMemo` runs during rendering, so make sure the computation function does
    not cause any side effects, such as resource requests. Side effects should be
    put into a `useEffect` Hook.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: The array passed as the second argument specifies the dependencies of the function.
    If any of these values change, the function will be recomputed; otherwise, the
    stored result will be used. If no array is provided, a new value will be computed
    on every render. If an empty array is passed, the value will only be computed
    once.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: Do not rely on `useMemo` to only compute things once. React may forget some
    previously memoized values if they are not used for a long time, for example,
    to free up memory. Use it only for performance optimizations.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: Since React 19, the React Compiler attempts to memoize values as much as possible
    automatically. In most cases, it should not be necessary to manually wrap values
    with `useMemo` anymore. Only use this Hook if you find a performance problem that
    the React Compiler does not memoize in a satisfying way. As a rule of thumb, try
    not to prematurely optimize your components, and do not use Memo Hooks unless
    you have a very good reason for doing so.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: useCallback
  id: totrans-409
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `useCallback` Hook works similarly to the `useMemo` Hook. However, it returns
    a memoized callback function instead of a value:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'The previous code is similar to the following `useMemo` Hook:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: The function returned will only be redefined if one of the values passed in
    the dependency array changes.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: Similarly to the Memo Hook, the Callback Hook should only be used if you have
    identified a specific performance problem that the React Compiler does not handle
    in a satisfying way, such as infinite re-render loops or too many renders.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have learned about using built-in Hooks for performance optimization,
    let’s briefly cover the final few built-in Hooks provided by React: advanced versions
    of the Effect Hook.'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: Using Hooks for advanced effects
  id: totrans-417
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two special versions of the Effect Hook: the **Layout Effect Hook**
    and the **Insertion Effect Hook**. These are only needed for very specific use
    cases, so we are only briefly covering them here.'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: useLayoutEffect
  id: totrans-419
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Layout** **Effect Hook** is identical to the Effect Hook, but it fires
    synchronously after all DOM mutations are completed and before the component is
    rendered in the browser. It can be used to read information from the DOM and adjust
    the appearance of components before rendering. Updates inside this Hook will be
    processed synchronously before the browser renders the component.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: Do not use this Hook unless it is really needed, which is only in certain edge
    cases. `useLayoutEffect` will block visual updates in the browser, and thus, is
    slower than `useEffect`.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: The rule here is to use `useEffect` first. If your mutation changes the appearance
    of the DOM node, which can cause it to flicker, you should use `useLayoutEffect`
    instead.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: useInsertionEffect
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Insertion Effect Hook** is similar to the Effect Hook, but it fires before
    any layout effects fire. This Hook is intended to be used only by CSS-in-JS library
    authors, so you will most likely not need it.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '**Example code**'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: The example code for this chapter can be found in the `Chapter09/Chapter09_1`
    folder. Check the `README.md` file inside the folder for instructions on how to
    set up and run the example.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-427
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about all Hooks provided by React as of version
    19.1\. We started by giving an overview of the built-in Hooks and then learned
    about various utility Hooks. Next, we moved on to learning about Hooks for performance
    optimization. Finally, we learned about advanced Effect Hooks.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: We now have an overview of all the different built-in Hooks that React provides.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在对所有不同的内置Hooks有了概述。
- en: In the next chapter, we are going to learn about using various Hooks developed
    by the React community, as well as where to find more of them.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将学习关于使用React社区开发的各类Hooks，以及如何找到更多这样的Hooks。
- en: Questions
  id: totrans-431
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'To recap what we have learned in this chapter, try to answer the following
    questions:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回顾本章所学内容，尝试回答以下问题：
- en: What are the different use cases of the Ref Hook?
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ref Hook的不同用例有哪些？
- en: Which functionality does the Imperative Handle Hook add?
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Imperative Handle Hook增加了哪些功能？
- en: When should we use the Id Hook?
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该在什么时候使用Id Hook？
- en: Which use case does the Sync External Store Hook cover?
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Sync External Store Hook覆盖了哪些用例？
- en: How can we use the Debug Value Hook?
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使用Debug Value Hook？
- en: What advantages does using the Deferred Value Hook give us?
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Deferred Value Hook给我们带来了哪些优势？
- en: When should we use Memo and Callback Hooks?
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该在什么时候使用Memo和Callback Hooks？
- en: In most cases, is it still necessary to use Memo and Callback Hooks?
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在大多数情况下，是否仍然有必要使用Memo和Callback Hooks？
- en: Further reading
  id: totrans-441
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'If you are interested in more information about the concepts that we have learned
    in this chapter, take a look at the following links:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对本章所学概念有更多信息的兴趣，请查看以下链接：
- en: 'The Built-in React Hooks section of the React docs: [https://react.dev/reference/react/hooks](https://react.dev/reference/react/hooks)'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React文档中的内置React Hooks部分：[https://react.dev/reference/react/hooks](https://react.dev/reference/react/hooks)
- en: 'More information about the React Compiler: [https://react.dev/learn/react-compiler](https://react.dev/learn/react-compiler)'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于React编译器的更多信息：[https://react.dev/learn/react-compiler](https://react.dev/learn/react-compiler)
- en: Learn more on Discord
  id: totrans-445
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Discord上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入这本书的Discord社区——在那里你可以分享反馈，向作者提问，并了解新版本——请扫描下面的二维码：
- en: '[https://packt.link/wnXT0](Chapter_09.xhtml)'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/wnXT0](Chapter_09.xhtml)'
- en: '![](img/image_%283%29.png)'
  id: totrans-448
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_%283%29.png)'
