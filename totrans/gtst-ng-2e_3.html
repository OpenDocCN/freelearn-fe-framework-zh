<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;TypeScript Crash Course"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. TypeScript Crash Course</h1></div></div></div><p>In this chapter, we will start working with TypeScript, the language Google recommends for using with Angular. All the features ECMAScript 2015 and ECMAScript 2016 provide, such as functions, classes, modules, and decorators, are already implemented in or added to the roadmap of TypeScript. Because of the extra type annotations, there are some syntactical additions compared to JavaScript.</p><p>For a smoother transition from the language which is fully supported by modern browsers at the time of writing, that is, ES5, we will start with some common features between ES2016 and TypeScript. Where there are differences between the ES2016 syntax and TypeScript, we'll explicitly mention it. In the second half of the chapter, we'll add the type annotations to everything we've learned until this point.</p><p>Later in this chapter, we will explain the extra features TypeScript provides, such as static typing and extra syntax. We will discuss the different consequences based on these features, which will help us to be more productive and less error-prone. Let's get going!</p><div class="section" title="Introduction to TypeScript"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Introduction to TypeScript</h1></div></div></div><p>TypeScript is an open source programming language that is developed and maintained by Microsoft. Its initial public release was in October 2012. TypeScript is a superset of ECMAScript, supporting all of the syntax and semantics of JavaScript with some extra features on top, such as static typing and richer syntax.</p><p>
<span class="emphasis"><em>Figure 1</em></span> shows the relationships among ES5, ES2015, ES2016, and TypeScript.</p><p>
</p><div class="mediaobject"><img alt="Introduction to TypeScript" src="graphics/5081_03_01.jpg"/></div><p>
</p><p>Figure 1</p><p>As TypeScript is statically typed, it can provide a number of benefits to us as JavaScript developers. Let's take a quick look at those benefits now.</p><div class="section" title="Compile-time type checking"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec23"/>Compile-time type checking</h2></div></div></div><p>One of the most common mistakes we make while writing JavaScript code is to misspell a property or a method name. Usually, we find out about the mistake when we get a runtime error. This can happen during development as well as during production. Hoping that we will know about the error before we deploy our code to the production environment isn't a comfortable feeling! However, this is not a problem specific to JavaScript; it is something common to all the dynamic languages. Even with lots of unit tests, these errors can slip by.</p><p>TypeScript provides a compiler, which takes care of such mistakes for us by using static code analysis. If we take advantage of static typing, TypeScript will be aware of the existing properties a given object has, and if we misspell any of them, the compiler will warn us with a compile-time error.</p><p>Another great benefit of TypeScript is that it allows large teams to collaborate since it provides formal, verifiable naming. This way, it allows us to write easy-to-understand code.</p></div><div class="section" title="Better support by text editors and IDEs"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec24"/>Better support by text editors and IDEs</h2></div></div></div><p>There are a number of tools, such as Tern, that are trying to bring better autocompletion support for JavaScript in text editors and IDEs. However, as JavaScript is a dynamic language, it is impossible for the IDEs and text editors to make sophisticated suggestions without any metadata. Google Closure Compiler, for instance, uses type annotations provided in the JSDoc in order to provide static typing to the language.</p><p>Annotating the code with such metadata is a built-in feature of TypeScript known as type annotations. Based on them, text editors and IDEs can perform a better static analysis on our code. This provides better refactoring tools and autocompletion, which increases our productivity and allows us to make fewer mistakes while writing the source code for our applications.</p></div><div class="section" title="There's even more to TypeScript"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec25"/>There's even more to TypeScript</h2></div></div></div><p>TypeScript by itself has a number of other benefits:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>It is a superset of JavaScript</strong></span>: All JavaScript programs (for example, ES5 and ES2015) are already valid TypeScript ones. In essence, you have already been writing TypeScript code. Since it is based on the latest version of the ECMAScript standard, it allows us to take advantage of the latest bleeding-edge syntax provided by the language.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Supports optional type checking</strong></span>: If, for any reason, we decide that we don't want to explicitly define the type of a variable or a method, we can just skip the type definition. However, we should be aware that this means we are no longer taking advantage of the static typing, so we are giving up on all the benefits mentioned earlier.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Developed and maintained by Microsoft</strong></span>: The quality of the implementation of the language is very high, and it is unlikely that support will be dropped unexpectedly. TypeScript is based on the work of some of the world's best experts in programming language development.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>It is open source</strong></span>: This allows the community to freely contribute to the language and suggest features, which are discussed in an open manner. The fact that TypeScript is open source makes the development of third-party extensions and tools easier. This extends the scope of its usage even further.</li></ul></div><p>Since modern browsers do not support TypeScript natively, there is a compiler that translates the TypeScript code we write into readable JavaScript in a predefined target version of ECMAScript. Once the code is compiled, all the type annotations are removed.</p></div></div></div>
<div class="section" title="Using TypeScript"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Using TypeScript</h1></div></div></div><p>Let's start writing some TypeScript!</p><p>In the following sections, we will take a look at different snippets showing some of the features of TypeScript. In order to be able to run the snippets and play with them yourself, you'll need to install the TypeScript compiler on your computer. Let's take a look at how to do this.</p><p>TypeScript is best installed using <span class="strong"><strong>Node Package Manager</strong></span> (<span class="strong"><strong>npm</strong></span>). I'd recommend that you use npm's version 3.0.0 or newer. If you don't have node.js and npm installed already, you can visit <a class="ulink" href="https://nodejs.org">https://nodejs.org </a>and follow the instructions there.</p><div class="section" title="Installing TypeScript with npm"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec26"/>Installing TypeScript with npm</h2></div></div></div><p>Once you have npm installed and running, verify that you have the latest version by opening your terminal window and running the following command:</p><pre class="programlisting">
<span class="strong"><strong>$ npm -v&#13;
</strong></span>
</pre><p>Use the following command in order to install TypeScript 2.1.0 or newer:</p><pre class="programlisting">
<span class="strong"><strong>$ npm install -g typescript@^2.1.0&#13;
</strong></span>
</pre><p>The preceding command will install the TypeScript compiler and add its executable (<code class="literal">tsc</code>) as global.</p><p>In order to verify that everything works properly, you can use the following command:</p><pre class="programlisting">
<span class="strong"><strong>$ tsc -v&#13;
Version 2.1.1&#13;
</strong></span>
</pre><p>The output should be similar to the preceding one, though possibly with a different version.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note7"/>Note</h3><p>Note that we install TypeScript by prefixing the version with caret. This means that <code class="literal">npm</code> will download any version in the range 2.x.x, but below 3.0.0.</p></div></div></div><div class="section" title="Running our first TypeScript program"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec27"/>Running our first TypeScript program</h2></div></div></div><p>Now, let's compile our first TypeScript program! Create a file called <code class="literal">hello.ts</code> and enter the following content:</p><pre class="programlisting">// ch3/hello-world/hello-world.ts&#13;
 &#13;
console.log('Hello world!'); &#13;
</pre><p>Since we've already installed the TypeScript compiler, you should have a global executable command called <code class="literal">tsc</code>. You can use it in order to compile the file:</p><pre class="programlisting">
<span class="strong"><strong>$ tsc hello.ts&#13;
</strong></span>
</pre><p>Now, you should see the file <code class="literal">hello.js</code> in the same directory where <code class="literal">hello.ts</code> is. <code class="literal">hello.js</code> is the output of the TypeScript compiler; it contains the JavaScript equivalent to the TypeScript you wrote. You can run this file using the following command:</p><pre class="programlisting">
<span class="strong"><strong>$ node hello.js&#13;
</strong></span>
</pre><p>Now, you'll see the string <span class="strong"><strong>Hello world!</strong></span> printed on the screen. In order to combine the process of compiling and running the program, you can use the <code class="literal">ts-node</code> package:</p><pre class="programlisting">
<span class="strong"><strong>$ npm install -g ts-node&#13;
</strong></span>
</pre><p>Now you can run:</p><pre class="programlisting">
<span class="strong"><strong>$ ts-node hello.ts&#13;
</strong></span>
</pre><p>You should see the same result, but without the <code class="literal">ts-node</code> file stored on the disk.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip8"/>Tip</h3><p>You can find the code for this book at <a class="ulink" href="https://github.com/mgechev/getting-started-with-angular">https://github.com/mgechev/getting-started-with-angular</a>. Most code snippets have a comment as the first line, which shows where you can find the complete example in the directory structure of the samples repository. Note that the paths are relative to the <code class="literal">app</code> directory.</p></div></div></div></div>
<div class="section" title="TypeScript syntax and features introduced by ES2015 and ES2016"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec23"/>TypeScript syntax and features introduced by ES2015 and ES2016</h1></div></div></div><p>As TypeScript is a superset of JavaScript, before we start learning about its syntax, it'll be easier to start by introducing some of the bigger changes in ES2015 and ES2016; to understand TypeScript, we first must understand ES2015 and ES2016. We will have a whistle-stop tour through these changes before diving into TypeScript properly later.</p><p>A detailed explanation of ES2015 and ES2016 is outside the scope of this book. In order to get familiar with all the new features and syntaxes, I strongly recommend that you take a look at <span class="emphasis"><em>Exploring ES6: Upgrade to the next version of JavaScript</em></span> by <span class="emphasis"><em>Dr. Axel Rauschmayer</em></span>.</p><p>The next couple of pages will introduce new standards and allow you to take advantage of most of the features you will need during the development of Angular applications.</p><div class="section" title="ES2015 arrow functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec28"/>ES2015 arrow functions</h2></div></div></div><p>JavaScript has first-class functions, which means that they can be passed around like any other value:</p><pre class="programlisting">// ch3/arrow-functions/simple-reduce.ts&#13;
 &#13;
var result = [1, 2, 3].reduce(function (total, current) { &#13;
  return total + current; &#13;
}, 0); // 6 &#13;
</pre><p>This syntax is great; however, it is a bit too verbose. ES2015 introduced a new syntax to define anonymous functions called the arrow function syntax. Using it, we can create anonymous functions, as seen in the following examples:</p><pre class="programlisting">// ch3/arrow-functions/arrow-functions.ts &#13;
 &#13;
// example 1 &#13;
var result = [1, 2, 3] &#13;
  .reduce((total, current) =&gt; total + current, 0); &#13;
 &#13;
console.log(result); // 6&#13;
&#13;
// example 2 &#13;
var even = [3, 1, 56, 7].filter(el =&gt; !(el % 2)); &#13;
 &#13;
console.log(even); // [56]&#13;
 &#13;
// example 3 &#13;
var sorted = data.sort((a, b) =&gt; { &#13;
  var diff = a.price - b.price; &#13;
  if (diff !== 0) { &#13;
    return diff; &#13;
  } &#13;
  return a.total - b.total; &#13;
}); &#13;
</pre><p>In the first example, we got the total sum of the elements in the array <code class="literal">[1, 2, 3]</code>. In the second example, we got all the even numbers inside the array <code class="literal">[3, 1, 56, 7]</code>. In the third example, we sorted an array by the properties' <code class="literal">price</code> and <code class="literal">total</code> in ascending order.</p><p>Arrow functions have a few more features that we need to look at. The most important feature is that they keep the context (<code class="literal">this</code>) from the surrounding code:</p><pre class="programlisting">// ch3/arrow-functions/context-demo.ts&#13;
 &#13;
function MyComponent() { &#13;
  this.age = 42; &#13;
  setTimeout(() =&gt; { &#13;
    this.age += 1; &#13;
    console.log(this.age); &#13;
  }, 100); &#13;
}&#13;
 &#13;
new MyComponent(); // 43 in 100ms. &#13;
</pre><p>For example, when we invoke the <code class="literal">MyComponent</code> function with the operator <code class="literal">new</code>; this will point to the new object instantiated by the call. The arrow function will keep the context (<code class="literal">this</code>), in the callback of <code class="literal">setTimeout</code>, and print <span class="strong"><strong>43</strong></span> on the screen.</p><p>This is extremely useful in Angular since the binding context for a given component is its instance (that is, its <code class="literal">this</code> instance). If we define <code class="literal">MyComponent</code> as an Angular component and we have a binding to the <code class="literal">age</code> property, the preceding code will be valid and all the bindings will work (note that we don't have the scope, neither do we have explicit calls to the <code class="literal">$digest</code> loop, although we have called <code class="literal">setTimeout</code> directly).</p></div><div class="section" title="Using the ES2015 and ES2016 classes"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec29"/>Using the ES2015 and ES2016 classes</h2></div></div></div><p>When developers new to JavaScript hear that the language empowers the <span class="strong"><strong>object-oriented</strong></span> (<span class="strong"><strong>OO</strong></span>) paradigm, they're normally confused when they discover that there's no syntax for the definition of classes. This perception was born by the fact that some of the most popular programming languages, such as Java, C#, and C++, have the concept of classes used for the construction of objects. However, JavaScript implements the OO paradigm differently. JavaScript has a prototype-based, object-oriented programming model, where we can instantiate objects using the object literal syntax or functions (also known as the constructor functions), and we can take advantage of the inheritance using the so-called prototype chain.</p><p>Although this is a valid way to implement the OO paradigm, and the semantics are similar to the one in the classical object-oriented model, it is confusing for inexperienced JavaScript developers who are not sure how to process this properly. This is one of the reasons TC39 decided to provide an alternative syntax to use the object-oriented paradigm in the language. Behind the scenes, the new syntax has the same semantics as the one we're used to, like using the constructor functions and the prototype-based inheritance. However, it provides a more convenient syntax to empower the OO paradigm's features with less boilerplate.</p><p>ES2016 adds some extra syntax to the ES2015 classes, such as static and instance property declaration.</p><p>Here is an example that demonstrates the syntax used to define the classes in ES2016:</p><pre class="programlisting">// ch3/es6-classes/sample-classes.ts &#13;
 &#13;
class Human { &#13;
  static totalPeople = 0; &#13;
  _name; // ES2016 property declaration syntax&#13;
 &#13;
  constructor(name) { &#13;
    this._name = name; &#13;
    Human.totalPeople += 1; &#13;
  }&#13;
 &#13;
  get name() { &#13;
    return this._name; &#13;
  }&#13;
 &#13;
  set name(val) { &#13;
    this._name = val; &#13;
  }&#13;
 &#13;
  talk() { &#13;
    return `Hi, I'm ${this.name}!`; &#13;
  } &#13;
} &#13;
 &#13;
class Developer extends Human { &#13;
  _languages; // ES2016 property declaration syntax&#13;
 &#13;
  constructor(name, languages) { &#13;
    super(name); &#13;
    this._languages = languages; &#13;
  }&#13;
 &#13;
  get languages() { &#13;
    return this._languages; &#13;
  }&#13;
 &#13;
  talk() { &#13;
    return `${super.talk()} And I know ${this.languages.join(',')}.`; &#13;
  } &#13;
} &#13;
</pre><p>In ES2015, the explicit declaration of the <code class="literal">_name</code> property is not required; however, since the TypeScript compiler should be aware during compile time of the existing properties of the instances of a given class, we would need to add the declaration of the property to the class declaration itself.</p><p>The preceding snippet is both a valid TypeScript and JavaScript code. In it, we defined a class called <code class="literal">Human</code>, which adds a single property to the objects instantiated by it. It does this by setting the property's value to the value of the parameter <code class="literal">name</code> passed to its constructor.</p><p>Now, open the <code class="literal">ch3/es6-classes/sample-classes.ts</code> file and play around with it! You can create different instances of the classes in the same way you create objects using constructor functions:</p><pre class="programlisting">var human = new Human('foobar'); &#13;
var dev = new Developer('bar', ['JavaScript']); &#13;
console.log(dev.talk()); &#13;
</pre><p>In order to execute the code, run the following command:</p><pre class="programlisting">
<span class="strong"><strong>$ ts-node sample-classes.ts&#13;
</strong></span>
</pre><p>Classes are commonly used in Angular. You can use them to define your components, directives, services, and pipes. However, you can also use the alternative ES5 syntax, which takes advantage of the constructor functions. Under the hood, once the TypeScript code is compiled, there would be no such significant difference between both the syntaxes, because the ES2015 classes are being transpiled to constructor functions anyway.</p></div><div class="section" title="Defining variables with block scope"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec30"/>Defining variables with block scope</h2></div></div></div><p>Another confusing point of JavaScript for developers with a different background is the variable scope in the language. In Java and C++, for example, we're used to the block lexical scope. This means that a given variable defined inside a specific block will be visible only inside that block and all of the nested blocks inside of it.</p><p>However, in JavaScript, things are a little bit different. ECMAScript defines a functional lexical scope that has similar semantics to the block lexical scope, but it uses functions instead of blocks. Lets take a look at the following code snippet:</p><pre class="programlisting">// ch3/let/var.ts &#13;
 &#13;
var fns = []; &#13;
for (var i = 0; i &lt; 5; i += 1) { &#13;
  fns.push(function() { &#13;
    console.log(i); &#13;
  });&#13;
} &#13;
fns.forEach(fn =&gt; fn()); &#13;
</pre><p>This has some weird implications. Once the code is executed, it will log five times the number <code class="literal">5</code>.</p><p>ES2015 added a new syntax to define variables with block scope visibility. The syntax is similar to the current one, however, instead of <code class="literal">var</code>, it uses the keyword <code class="literal">let</code>:</p><pre class="programlisting">// ch3/let/let.ts &#13;
 &#13;
var fns = []; &#13;
for (let i = 0; i &lt; 5; i += 1) { &#13;
  fns.push(function() { &#13;
    console.log(i); &#13;
  });&#13;
} &#13;
fns.forEach(fn =&gt; fn()); &#13;
</pre></div></div>
<div class="section" title="Meta-programming with ES2016 decorators"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Meta-programming with ES2016 decorators</h1></div></div></div><p>JavaScript is a dynamic language that allows us to easily modify and/or alter the behavior to suit the programs we write. Decorators are a proposal to ES2016, which according to the design document <a class="ulink" href="https://github.com/wycats/javascript-decorators">https://github.com/wycats/javascript-decorators</a>:</p><div class="blockquote"><blockquote class="blockquote"><p>
<span class="emphasis"><em>"...make it possible to annotate and modify classes and properties at design time."</em></span>
</p></blockquote></div><p>Their syntaxes are quite similar to the annotations in Java, and they are even closer to the decorators in Python. ES2016 decorators are used commonly in Angular to define components, directives, and pipes, and to take advantage of the dependency injection mechanism of the framework. Most use cases of decorators involve altering the behavior to a predefined logic or adding some metadata to different constructs.</p><p>ES2016 decorators allow us to do a lot of fancy things by changing the behavior of our programs. Typical use cases could be to annotate the given methods or properties as deprecated or read-only. A set of predefined decorators that can improve the readability of the code we produce can be found in a project by <span class="emphasis"><em>Jay Phelps</em></span> called <span class="emphasis"><em>core-decorators.js</em></span>. Another use case is taking advantage of the proxy-based, aspect-oriented programming using a declarative syntax. The library providing this functionality is <span class="emphasis"><em>aspect.js</em></span>.</p><p>In general, ES2016 decorators are just another syntax sugar, which translates to JavaScript code we're already familiar with from the previous versions of the language. Let's take a look at a simple example from the proposal's draft:</p><pre class="programlisting">// ch3/decorators/nonenumerable.ts &#13;
 &#13;
class Person { &#13;
  @nonenumerable &#13;
  get kidCount() { &#13;
    return 42; &#13;
  } &#13;
} &#13;
 &#13;
function nonenumerable(target, name, descriptor) { &#13;
  descriptor.enumerable = false; &#13;
  return descriptor; &#13;
} &#13;
 &#13;
var person = new Person(); &#13;
 &#13;
for (let prop in person) { &#13;
  console.log(prop); &#13;
} &#13;
</pre><p>In this case, we have an ES2015 class called <code class="literal">Person</code> with a single getter called <code class="literal">kidCount</code>. Over the <code class="literal">kidCount</code> getter, we have applied the <code class="literal">@nonenumerable</code> decorator. The decorator is a function that accepts a target (the <code class="literal">Person</code> class), the name of the target property we intend to decorate (<code class="literal">kidCount</code>), and the descriptor of the target property. After we change the descriptor, we need to return it in order to apply the modification. Basically, the decorator's application could be translated into ECMAScript 5 in the following way:</p><pre class="programlisting">descriptor = nonenumerable(Person.prototype, 'kidCount', descriptor) || descriptor; &#13;
Object.defineProperty(Person.prototype, 'kidCount', descriptor); &#13;
</pre><div class="section" title="Using configurable decorators"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec31"/>Using configurable decorators</h2></div></div></div><p>Here is an example of using the decorators defined by Angular:</p><pre class="programlisting">@Component({ &#13;
  selector: 'app', &#13;
  providers: [NamesList], &#13;
  templateUrl: './app.html', &#13;
}) &#13;
export class App {} &#13;
</pre><p>When decorators accept arguments (just like <code class="literal">Component</code> in the preceding example), they need to be defined as functions that accept arguments and return the actual decorator:</p><pre class="programlisting">function Component(config) { &#13;
  // validate properties &#13;
  return (componentCtrl) =&gt; { &#13;
    // apply decorator &#13;
  }; &#13;
} &#13;
</pre><p>In this example, we defined a function <code class="literal">Component</code> that accepts a single argument called <code class="literal">config</code> and returns a decorator.</p></div></div>
<div class="section" title="Writing modular code with ES2015"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Writing modular code with ES2015</h1></div></div></div><p>Another problem that JavaScript professionals have experienced over the years is the lack of a module system in the language. Initially, the community developed different patterns, aiming to enforce the modularity and the encapsulation of the software we produce. Such patterns included the module pattern, which takes advantage of the functional lexical scope and closures. Another example is the namespace pattern, which represents the different namespaces as nested objects. AngularJS introduced its own module system that unfortunately doesn't provide features, such as lazy module loading. However, these patterns were more like workarounds rather than real solutions.</p><p>
<span class="strong"><strong>CommonJS</strong></span> (used in node.js) and <span class="strong"><strong>AMD</strong></span> (<span class="strong"><strong>Asynchronous Module Definition</strong></span>) were later invented. They are still widely used today and provide features such as handling of circular dependencies, asynchronous module loading (in AMD), and so on.</p><p>TC39 took the best of the existing module systems and introduced this concept on a language level. ES2015 provides two APIs to define and consume modules. They are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Declarative API.</li><li class="listitem" style="list-style-type: disc">Imperative API using a module loader.</li></ul></div><p>Angular takes full advantage of the ES2015 module system, so let's dive into it! In this section, we will take a look at the syntax used for the declarative definition and consumption of modules. We will also take a peek at the module loader's API in order to see how we can programmatically load modules in an explicit asynchronous manner.</p><div class="section" title="Using the ES2015 module syntax"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec32"/>Using the ES2015 module syntax</h2></div></div></div><p>Let's take a look at an example:</p><pre class="programlisting">// ch3/modules/math.ts &#13;
 &#13;
export function square(x) { &#13;
  return Math.pow(x, 2); &#13;
};&#13;
 &#13;
export function log10(x) { &#13;
  return Math.log10(x); &#13;
};&#13;
 &#13;
export const PI = Math.PI; &#13;
</pre><p>In the preceding snippet, we defined a simple ES2015 module in the <code class="literal">math.ts</code> file. We can think of it as a sample math Angular utility module. Inside it, we define and export the <code class="literal">square</code> and <code class="literal">log10</code> functions and the constant <code class="literal">PI</code>. The <code class="literal">const</code> keyword is another keyword brought by ES2015 that is used to define constants. As you can see, what we do is nothing more than prefixing the function's definitions with the keyword <code class="literal">export</code>. If we want to export the entire functionality in the end and skip the duplicate explicit usage of <code class="literal">export</code>, we can use the following approach:</p><pre class="programlisting">// ch3/modules/math2.ts &#13;
 &#13;
function square(x) { &#13;
  return Math.pow(x, 2); &#13;
};&#13;
 &#13;
function log10(x) { &#13;
  return Math.log10(x); &#13;
};&#13;
 &#13;
const PI = Math.PI;&#13;
 &#13;
export { square, log10, PI }; &#13;
</pre><p>The syntax on the last line is nothing more than an enhanced object literal syntax, introduced by ES2015. Now, let's take a look at how we can consume this module:</p><pre class="programlisting">// ch3/modules/app.ts &#13;
 &#13;
import {square, log10} from './math';&#13;
 &#13;
console.log(square(2)); // 4 &#13;
console.log(log10(10)); // 1 &#13;
</pre><p>As an identifier of the module, we use its relative path to the current file. Using destructuring, we import the required functions – in this case, <code class="literal">square</code> and <code class="literal">log10</code>.</p></div><div class="section" title="Taking advantage of the modules' implicit asynchronous behavior"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec33"/>Taking advantage of the modules' implicit asynchronous behavior</h2></div></div></div><p>It is important to note that the ES2015 module syntax has implicit asynchronous behavior.</p><p>
</p><div class="mediaobject"><img alt="Taking advantage of the modules' implicit asynchronous behavior" src="graphics/2-1.jpg"/></div><p>
</p><p>Figure 2</p><p>In the preceding diagram, we have modules <code class="literal">A</code>, <code class="literal">B</code>, and <code class="literal">C</code>. Module <code class="literal">A</code> uses modules <code class="literal">B</code> and <code class="literal">C</code>, so it depends on them. Once the user requires module <code class="literal">A</code>, the JavaScript module loader would need to load modules <code class="literal">B</code> and <code class="literal">C</code> before being able to invoke any of the logic that resides in module <code class="literal">A</code> because of the dependencies they have. Modules <code class="literal">B</code> and <code class="literal">C</code> will be loaded asynchronously. Once they are loaded completely, the JavaScript virtual machine will be able to execute module <code class="literal">A</code>.</p></div><div class="section" title="Using aliases"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec34"/>Using aliases</h2></div></div></div><p>Another typical situation is when we want to use an alias for a given export. For example, if we use a third-party library, we may want to rename any of its exports in order to escape name collisions or just to have a more convenient naming:</p><pre class="programlisting">import {&#13;
  platformBrowserDynamic as platform&#13;
} from '@angular/platform-browser-dynamic';</pre></div><div class="section" title="Importing all the module exports"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec35"/>Importing all the module exports</h2></div></div></div><p>We can import the entire <code class="literal">math</code> module using the following syntax:</p><pre class="programlisting">// ch3/modules/app2.ts &#13;
 &#13;
import * as math from './math';&#13;
 &#13;
console.log(math.square(2)); // 4 &#13;
console.log(math.log10(10)); // 1 &#13;
console.log(math.PI); // 3.141592653589793 &#13;
</pre><p>The semantics behind this syntax is quite similar to CommonJS, although, in the browser, we have implicit asynchronous behavior.</p></div><div class="section" title="Default exports"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec36"/>Default exports</h2></div></div></div><p>If a given module defines an export, which would quite likely be used by any of its consumer modules, we can take advantage of the default export syntax:</p><pre class="programlisting">// ch3/modules/math3.ts &#13;
 &#13;
export default function cube(x) { &#13;
  return Math.pow(x, 3); &#13;
};&#13;
 &#13;
export function square(x) { &#13;
  return Math.pow(x, 2); &#13;
}; &#13;
</pre><p>In order to consume this module, we can use the following <code class="literal">app.ts</code> file:</p><pre class="programlisting">// ch3/modules/app3.ts &#13;
 &#13;
import cube from './math3';&#13;
 &#13;
console.log(cube(3)); // 27 &#13;
</pre><p>Alternatively, if we want to import the default export and perform some other exports, we can use:</p><pre class="programlisting">// ch3/modules/app4.ts &#13;
 &#13;
import cube, { square } from './math3';&#13;
 &#13;
console.log(square(2)); // 4 &#13;
console.log(cube(3)); // 27 &#13;
</pre><p>In general, the default export is nothing more than a named export named with the reserved word <code class="literal">default</code>:</p><pre class="programlisting">// ch3/modules/app5.ts &#13;
 &#13;
import { default as cube } from './math3';&#13;
 &#13;
console.log(cube(3)); // 27 &#13;
</pre></div></div>
<div class="section" title="ES2015 module loader"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec26"/>ES2015 module loader</h1></div></div></div><p>The new version of the standard defines a programmatic API to work with modules. This is the so-called module loader API. It allows us to define and import modules, or configure the module loading.</p><p>Let's suppose we have the following module definition in the file <code class="literal">app.js</code>:</p><pre class="programlisting">import { square } from './math';&#13;
 &#13;
export function main() { &#13;
  console.log(square(2)); // 4 &#13;
} &#13;
</pre><p>From the <code class="literal">init.js</code> file, we can programmatically load the <code class="literal">app</code> module and invoke its <code class="literal">main</code> function using:</p><pre class="programlisting">System.import('./app') &#13;
  .then(app =&gt; { &#13;
    app.main(); &#13;
  }) &#13;
  .catch(error =&gt; { &#13;
    console.log('Terrible error happened', error); &#13;
  }); &#13;
</pre><p>The global object <code class="literal">System</code> has a method called <code class="literal">import</code> that allows us to import modules using their identifier. In the preceding snippet, we import the module <code class="literal">app</code> defined in <code class="literal">app.js</code>. <code class="literal">System.import</code> returns a promise that could be resolved on success or rejected in case of an error. Once the promise is resolved as the first parameter of the callback passed to <code class="literal">then</code>, we will get the module instance. The first parameter of the callback registered in case of rejection is an object representing the error that happened.</p><p>The code from the last snippet does not exist in the GitHub repository since it requires some additional configuration. We will apply the module loader more explicitly in the Angular examples in the later chapters of the book.</p></div>
<div class="section" title="ES2015 and ES2016 recap"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec27"/>ES2015 and ES2016 recap</h1></div></div></div><p>Congratulations! We're more than halfway toward learning TypeScript. All the features we just saw are a part of TypeScript since it implements a superset of JavaScript; since all these features are an upgrade on top of the current syntax, they are easy for experienced JavaScript developers to grasp.</p><p>In the next sections, we will describe all the amazing features of TypeScript that are outside the intersection with ECMAScript.</p></div>
<div class="section" title="Taking advantage of static typing"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Taking advantage of static typing</h1></div></div></div><p>Static typing is what can provide better tooling for our development process. While writing JavaScript, the most that IDEs and text editors can do is syntax highlight and provide some basic autocompletion suggestions based on sophisticated static analysis of our code. This means that we can only verify that we haven't made any typos by running the code.</p><p>In the previous sections, we described only the new features provided by ECMAScript expected to be implemented by browsers in the near future. In this section, we will take a look at what TypeScript provides in order to help us be less error-prone and more productive. At the time of writing this book, there were no plans to implement built-in support for static typing in the browsers.</p><p>The TypeScript code goes through intermediate preprocessing that performs the type checking and drops all the type annotations in order to provide valid JavaScript supported by modern browsers.</p><div class="section" title="Using explicit type definitions"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec37"/>Using explicit type definitions</h2></div></div></div><p>Just like Java and C++, TypeScript allows us to explicitly declare the type of the given variable:</p><pre class="programlisting">let foo: number = 42; &#13;
</pre><p>The preceding line defines the variable <code class="literal">foo</code> in the current block using the <code class="literal">let</code> syntax. We explicitly declare that we want <code class="literal">foo</code> to be of the type <code class="literal">number</code> and we set the value of <code class="literal">foo</code> to <code class="literal">42</code>.</p><p>Now, let's try to change the value of <code class="literal">foo</code>:</p><pre class="programlisting">let foo: number = 42; &#13;
foo = '42'; &#13;
</pre><p>Here, after the declaration of <code class="literal">foo</code>, we will set its value to the string <code class="literal">'42'</code>. This is a perfectly valid JavaScript code; however, if we compile it using the TypeScript's compiler, we will get:</p><pre class="programlisting">
<span class="strong"><strong>$ tsc basic.ts &#13;
basic.ts(2,1): error TS2322: Type 'string' is not assignable to type 'number'.</strong></span>
</pre><p>Once <code class="literal">foo</code> is associated with the given type, we cannot assign it values belonging to different types. This is one of the reasons we can skip the explicit type definition in case we assign a value to the given variable:</p><pre class="programlisting">let foo = 42; &#13;
foo = '42'; &#13;
</pre><p>The semantics of this code will be the same as the one with the explicit type definition because of the type inference of TypeScript. We'll further take a look at it at the end of this chapter.</p><div class="section" title="The type any"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec2"/>The type any</h3></div></div></div><p>All the types in TypeScript are subtypes of a type called <code class="literal">any</code>. We can declare variables belonging to the <code class="literal">any</code> type using the <code class="literal">any</code> keyword. Such variables can hold the value of any type:</p><pre class="programlisting">let foo: any; &#13;
foo = {}; &#13;
foo = 'bar '; &#13;
foo += 42; &#13;
console.log(foo); // "bar 42" &#13;
</pre><p>The preceding code is a valid TypeScript, and it will not throw any error during compilation or runtime. If we use the type <code class="literal">any</code> for all of our variables, we will be basically writing the code with dynamic typing, which drops all the benefits of the TypeScript's compiler. That's why we have to be careful with <code class="literal">any</code> and use it only when it is necessary.</p><p>All the other types in TypeScript belong to one of the following categories:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Primitive types</strong></span>: These include Number, String, Boolean, Void, Null, Undefined, and Enum types.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Union types</strong></span>: These types are out of the scope of this book. You can take a look at them in the specification of TypeScript.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Object types</strong></span>: These include Function types, classes and interface type references, array types, tuple types, function types, and constructor types.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Type parameters</strong></span>: These include Generics that will be described in the <span class="emphasis"><em>Writing generic code by using type parameters</em></span> section.</li></ul></div></div></div><div class="section" title="Understanding the Primitive types"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec38"/>Understanding the Primitive types</h2></div></div></div><p>Most of the primitive types in TypeScript are the ones we are already familiar with in JavaScript: Number, String, Boolean, Null, and Undefined. So, we will skip their formal explanation here. Another set of types that is handy while developing Angular applications is the Enum types defined by users.</p><div class="section" title="The Enum types"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec3"/>The Enum types</h3></div></div></div><p>The Enum types are primitive user-defined types that, according to the specification, are subclasses of Number. The concept of enums exists in the Java, C++, and C# languages, and it has the same semantics in TypeScript-user-defined types consisting of sets of named values called elements. In TypeScript, we can define an enum using the following syntax:</p><pre class="programlisting">enum STATES { &#13;
  CONNECTING, &#13;
  CONNECTED, &#13;
  DISCONNECTING, &#13;
  WAITING, &#13;
  DISCONNECTED  &#13;
}; &#13;
</pre><p>This will be translated to the following JavaScript:</p><pre class="programlisting">var STATES; &#13;
(function (STATES) { &#13;
    STATES[STATES["CONNECTING"] = 0] = "CONNECTING"; &#13;
    STATES[STATES["CONNECTED"] = 1] = "CONNECTED"; &#13;
    STATES[STATES["DISCONNECTING"] = 2] = "DISCONNECTING"; &#13;
    STATES[STATES["WAITING"] = 3] = "WAITING"; &#13;
    STATES[STATES["DISCONNECTED"] = 4] = "DISCONNECTED"; &#13;
})(STATES || (STATES = {})); &#13;
</pre><p>We can use the enum type as follows:</p><pre class="programlisting">if (this.state === STATES.CONNECTING) { &#13;
  console.log('The system is connecting'); &#13;
} &#13;
</pre></div></div><div class="section" title="Understanding the Object types"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec39"/>Understanding the Object types</h2></div></div></div><p>In this section, we will take a look at the Array types and Function types, which belong to the more generic class of Object types. We will also explore how we can define classes and interfaces. Tuple types were introduced by TypeScript 1.3, and their main purpose is to allow the language to begin typing the new features introduced by ES2015, such as destructuring. We will not describe them in this book. For further reading, you can take a look at the language's specification at <a class="ulink" href="http://www.typescriptlang.org">http://www.typescriptlang.org</a>.</p><div class="section" title="The Array types"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec4"/>The Array types</h3></div></div></div><p>In TypeScript, arrays are JavaScript arrays with a common element type. This means that we cannot have elements from different types in a given array. We have different array types for all the built-in types in TypeScript, plus all the custom types that we define.</p><p>We can define an array of numbers as follows:</p><pre class="programlisting">let primes: number[] = []; &#13;
primes.push(2); &#13;
primes.push(3); &#13;
</pre><p>If we want to have an array, which seems heterogeneous, similar to the arrays in JavaScript, we can use the type reference to <code class="literal">any</code>:</p><pre class="programlisting">let randomItems: any[] = []; &#13;
randomItems.push(1); &#13;
randomItems.push('foo'); &#13;
randomItems.push([]); &#13;
randomItems.push({}); &#13;
</pre><p>This is possible since the types of all the values we're pushing to the array are subtypes of the <code class="literal">any</code> type and the array we've declared contains values of the type <code class="literal">any</code>.</p><p>We can use the array methods we're familiar with in JavaScript with all the TypeScript Array types:</p><pre class="programlisting">let randomItems: any[] = []; &#13;
randomItems.push('foo'); &#13;
randomItems.push('bar'); &#13;
randomItems.join(''); // foobar &#13;
randomItems.splice(1, 0, 'baz'); &#13;
randomItems.join(''); // foobazbar &#13;
</pre><p>We also have the square-brackets operator that gives us random access to the array's elements:</p><pre class="programlisting">let randomItems: any[] = []; &#13;
randomItems.push('foo'); &#13;
randomItems.push('bar'); &#13;
randomItems[0] === 'foo' &#13;
randomItems[1] === 'bar' &#13;
</pre></div><div class="section" title="The Function types"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec5"/>The Function types</h3></div></div></div><p>We're already familiar with how to define a new function in JavaScript. We can use function expression or function declaration:</p><pre class="programlisting">// function expression &#13;
var isPrime = function (n) { &#13;
  // body &#13;
};&#13;
 &#13;
// function declaration &#13;
function isPrime(n) { &#13;
  // body &#13;
}; &#13;
</pre><p>Alternatively, we can use the new arrow function syntax:</p><pre class="programlisting">var isPrime = n =&gt; { &#13;
  // body &#13;
}; &#13;
</pre><p>The only thing TypeScript alters is the feature to define the types of the function's arguments and the type of its return result (i.e. the function's signature). After the compiler of the language performs its type checking and transpilation, all the type annotations will be removed. If we use function expression and assign a function to a variable, we will be able to define the variable type in the following way:</p><pre class="programlisting">let variable: (arg1: type1, arg2: type2, ..., argn: typen) =&gt; returnType &#13;
</pre><p>Consider the following example:</p><pre class="programlisting">let isPrime: (n: number) =&gt; boolean = n =&gt; { &#13;
  // body &#13;
}; &#13;
</pre><p>If we want to define a method in an object literal, we can do it in the following way:</p><pre class="programlisting">let math = { &#13;
  squareRoot(n: number): number { &#13;
    // ... &#13;
  } &#13;
}; &#13;
</pre><p>In the preceding example, we defined an object literal with method called <code class="literal">squareRoot</code> using the ES2015 syntax.</p><p>In case we want to define a function that produces some side effects instead of returning a result, we can declare it's return type as <code class="literal">void</code>:</p><pre class="programlisting">let person = { &#13;
  _name: null, &#13;
  setName(name: string): void { &#13;
    this._name = name; &#13;
  } &#13;
}; &#13;
</pre></div></div><div class="section" title="Defining classes"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec40"/>Defining classes</h2></div></div></div><p>TypeScript classes are similar to what ES2015 offers. However, it alters the type declarations and adds more syntax sugar. For example, let's take the <code class="literal">Human</code> class we defined earlier and make it a valid TypeScript class:</p><pre class="programlisting">class Human { &#13;
  static totalPeople = 0; &#13;
  _name: string;&#13;
 &#13;
  constructor(name) { &#13;
    this._name = name; &#13;
    Human.totalPeople += 1; &#13;
  }&#13;
 &#13;
  get name() { &#13;
    return this._name; &#13;
  }&#13;
 &#13;
  set name(val) { &#13;
    this._name = val; &#13;
  }&#13;
 &#13;
  talk() { &#13;
    return `Hi, I'm ${this.name}!`; &#13;
  } &#13;
} &#13;
</pre><p>There is no difference between the current TypeScript definition with the one we already introduced; however, in this case, the declaration of the <code class="literal">_name</code> property is mandatory. Here is how we can use the class:</p><pre class="programlisting">let human = new Human('foo'); &#13;
console.log(human._name); &#13;
</pre></div><div class="section" title="Using access modifiers"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec41"/>Using access modifiers</h2></div></div></div><p>Similarly, for most conventional object-oriented languages that support classes, TypeScript allows a definition of access modifiers. In order to deny direct access to the <code class="literal">_name</code> property outside the class it is defined in, we can declare it as private:</p><pre class="programlisting">class Human { &#13;
  static totalPeople = 0; &#13;
  private _name: string; &#13;
  // ... &#13;
} &#13;
</pre><p>The supported access modifiers by TypeScript are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Public</strong></span>: All the properties and methods declared as public can be accessed from anywhere.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Private</strong></span>: All the properties and methods declared as private can be accessed only from inside the class' definition itself.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Protected</strong></span>: All the properties and methods declared as protected can be accessed from inside the class' definition or the definition of any other class extending the one that owns the property or the method.</li></ul></div><p>Access modifiers are a great way to implement Angular services with good encapsulation and a well-defined interface. In order to understand it better, let's take a look at an example using the class' hierarchy defined earlier, which is ported to TypeScript:</p><pre class="programlisting">class Human { &#13;
  static totalPeople = 0;&#13;
 &#13;
  constructor(protected name: string, private age: number) { &#13;
    Human.totalPeople += 1; &#13;
  }&#13;
 &#13;
  talk() { &#13;
    return `Hi, I'm ${this.name}!`; &#13;
  } &#13;
} &#13;
 &#13;
class Developer extends Human { &#13;
  constructor(name: string, private languages: string[], age: number) { &#13;
    super(name, age); &#13;
  }&#13;
 &#13;
  talk() { &#13;
    return `${super.talk()} And I know ${this.languages.join(', ')}.`; &#13;
  } &#13;
} &#13;
</pre><p>Just like ES2015, TypeScript supports the <code class="literal">extends</code> keyword and desugars it to the prototypal JavaScript inheritance.</p><p>In the preceding example, we set the access modifiers of the <code class="literal">name</code> and <code class="literal">age</code> properties directly inside the constructor function. The semantics behind this syntax differs from the one used in the previous example. It has the following meaning: define a protected property called <code class="literal">name</code> of the type <code class="literal">string</code> and assign the first value passed to the constructor call to it. It is the same for the private <code class="literal">age</code> property. This saves us from explicitly setting the value in the constructor itself. If we take a look at the constructor of the <code class="literal">Developer</code> class, we can see that we can use the mixture between these syntaxes. We can explicitly define the property in the constructor's signature, or we can only define that the constructor accepts a parameters of the given types.</p><p>Now, let's create a new instance of the <code class="literal">Developer</code> class:</p><pre class="programlisting">let dev = new Developer('foo', ['JavaScript', 'Go'], 42); &#13;
dev.languages = ['Java']; &#13;
</pre><p>During compilation, TypeScript will throw an error telling us that: <span class="strong"><strong>Property languages is private and only accessible inside the class "Developer"</strong></span>. Now, let's see what will happen if we create a new <code class="literal">Human</code> class and try to access its properties from outside its definition:</p><pre class="programlisting">let human = new Human('foo', 42); &#13;
human.age = 42; &#13;
human.name = 'bar'; &#13;
</pre><p>In this case, we'll get the following two errors:</p><p>
<span class="strong"><strong>Property age is private and is only accessible inside the class "Human"</strong></span>, and the <span class="strong"><strong>Property name is a protected and only accessible inside class "Human" and its subclasses</strong></span>.</p><p>However, if we try to access the <code class="literal">_name</code> property from inside the definition of <code class="literal">Developer</code>, the compiler won't throw any errors.</p><p>In order to get a better sense of what the TypeScript compiler will produce out of a type-annotated class, let's take a look at the JavaScript produced by the following definition:</p><pre class="programlisting">class Human { &#13;
  constructor(private name: string) {} &#13;
} &#13;
</pre><p>The resulting ECMAScript 5 will be as follows:</p><pre class="programlisting">var Human = (function () { &#13;
    function Human(name) { &#13;
        this.name = name; &#13;
    } &#13;
    return Human; &#13;
})(); &#13;
</pre><p>The defined property is added directly to the objects instantiated by calling the constructor function with the operator <code class="literal">new</code>. This means that once the code is compiled, we can directly access the private members of the created objects. In order to wrap this up, access modifiers are added in the language in order to help us enforce better encapsulation and get compile-time errors in case we violate it.</p></div><div class="section" title="Defining interfaces"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec42"/>Defining interfaces</h2></div></div></div><p>
<span class="strong"><strong>Subtyping</strong></span> in programming languages allows us to treat objects in the same way based on the observation that they are specialized versions of a generic object. This doesn't mean that they have to be instances of the same class of objects, or that they have a complete intersection between their interfaces. The objects might have only a few common properties and still be treated the same way in a specific context. In JavaScript, we usually use duck typing. We may invoke specific methods for all the objects passed to a function based on the assumption that these methods exist. However, all of us have experienced the <span class="emphasis"><em>
<span class="strong"><strong>undefined is not a function</strong></span>
</em></span> error thrown by the JavaScript interpreter.</p><p>Object-oriented programming and TypeScript come with a solution. They allow us to make sure that our objects have similar behavior if they implement interfaces that declare the subset of the properties they own.</p><p>For example, we can define our interface <code class="literal">Accountable</code>:</p><pre class="programlisting">interface Accountable { &#13;
  getIncome(): number; &#13;
} &#13;
</pre><p>Now, we can make sure that both <code class="literal">Individual</code> and <code class="literal">Firm</code> implement this interface by performing the following:</p><pre class="programlisting">class Firm implements Accountable { &#13;
  getIncome(): number { &#13;
    // ... &#13;
  } &#13;
}&#13;
 &#13;
class Individual implements Accountable { &#13;
  getIncome(): number { &#13;
    // ... &#13;
  } &#13;
} &#13;
</pre><p>In case we implement a given interface, we need to provide an implementation for all the methods defined inside it, otherwise, the TypeScript compiler will throw an error. The methods we implement must have the same signature as the ones declared in the interface definition.</p><p>TypeScript interfaces also support properties. In the <code class="literal">Accountable</code> interface, we can include a field called <code class="literal">accountNumber</code> with a type of string:</p><pre class="programlisting">interface Accountable { &#13;
  accountNumber: string; &#13;
  getIncome(): number; &#13;
} &#13;
</pre><p>We can define it in our class as a field or a getter.</p><div class="section" title="Interface inheritance"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec6"/>Interface inheritance</h3></div></div></div><p>Interfaces may also extend each other. For example, we may turn our <code class="literal">Individual</code> class into an interface that has a social security number:</p><pre class="programlisting">interface Accountable { &#13;
  accountNumber: string; &#13;
  getIncome(): number; &#13;
}&#13;
 &#13;
interface Individual extends Accountable { &#13;
  ssn: string; &#13;
} &#13;
</pre><p>Since interfaces support multiple inheritances, <code class="literal">Individual</code> may also extend the interface <code class="literal">Human</code> that has the <code class="literal">name</code> and <code class="literal">age</code> properties:</p><pre class="programlisting">interface Accountable { &#13;
  accountNumber: string; &#13;
  getIncome(): number; &#13;
}&#13;
 &#13;
interface Human { &#13;
  age: number; &#13;
  name: number; &#13;
}&#13;
 &#13;
interface Individual extends Accountable, Human { &#13;
  ssn: string; &#13;
} &#13;
</pre></div><div class="section" title="Implementing multiple interfaces"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec7"/>Implementing multiple interfaces</h3></div></div></div><p>In case the class's behavior is a union of the properties defined in a couple of interfaces, it may implement all of them:</p><pre class="programlisting">class Person implements Human, Accountable { &#13;
  age: number; &#13;
  name: string; &#13;
  accountNumber: string;&#13;
 &#13;
  getIncome(): number { &#13;
    // ... &#13;
  } &#13;
} &#13;
</pre><p>In this case, we need to provide the implementation of all the methods declared inside the interfaces our class implements, otherwise, the compiler will throw a compile-time error.</p></div></div></div>
<div class="section" title="Further expressiveness with TypeScript decorators"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec29"/>Further expressiveness with TypeScript decorators</h1></div></div></div><p>In ES2015, we are able to decorate only classes, properties, methods, getters, and setters. TypeScript takes this further by allowing us to decorate functions or method parameters:</p><pre class="programlisting">class Http { &#13;
  // ... &#13;
}&#13;
 &#13;
class GitHubApi { &#13;
  constructor(@Inject(Http) http) { &#13;
    // ... &#13;
  } &#13;
} &#13;
</pre><p>Keep in mind that the parameter decorators should not alter any additional behavior. Instead, they are used to generate metadata. The most typical use case of these decorators is the dependency injection mechanism of Angular.</p></div>
<div class="section" title="Writing generic code by using type parameters"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec30"/>Writing generic code by using type parameters</h1></div></div></div><p>In the beginning of the section on using static typing, we mentioned the type parameters. In order to get a better understanding of them, let's begin with an example. Let's suppose that we want to implement the classical data structure <code class="literal">BinarySearchTree</code>. Let's define its interface using a class without applying any method implementations:</p><pre class="programlisting">class Node { &#13;
  value: any; &#13;
  left: Node; &#13;
  right: Node; &#13;
} &#13;
 &#13;
class BinarySearchTree { &#13;
  private root: Node; &#13;
  insert(any: value): void { /* ... */ } &#13;
  remove(any: value): void { /* ... */ } &#13;
  exists(any: value): boolean { /* ... */ } &#13;
  inorder(callback: {(value: any): void}): void { /* ... */ } &#13;
} &#13;
</pre><p>In the preceding snippet, we defined a class called <code class="literal">Node</code>. The instances of this class represent the individual nodes in our tree. Each <code class="literal">node</code> has a left and a right child node and a value of the type <code class="literal">any</code>; we use <code class="literal">any</code> in order to be able to store data of any type inside our nodes and respectively inside <code class="literal">BinarySearchTree</code>.</p><p>Although the earlier implementation looks reasonable, we're giving up on using the most important feature that TypeScript provides, that is, static typing. Using <code class="literal">any</code> as a type of the value field inside the <code class="literal">Node</code> class, we can't take complete advantage of the compile-time type checking. This also limits the features that IDEs and text editors provide when we access the <code class="literal">value</code> property of the instances of the <code class="literal">Node</code> class.</p><p>TypeScript comes with an elegant solution that is already widely popular in the world of static typing-type parameters. Using generics, we can parameterize the classes we create with the type parameters. For example, we can turn our <code class="literal">Node</code> class into the following:</p><pre class="programlisting">class Node&lt;T&gt; { &#13;
  value: T; &#13;
  left: Node&lt;T&gt;; &#13;
  right: Node&lt;T&gt;; &#13;
} &#13;
</pre><p>
<code class="literal">Node&lt;T&gt;</code> indicates that this class has a single type parameter called <code class="literal">T</code> that is used somewhere inside the class's definition. We can use <code class="literal">Node</code> by performing the following snippet:</p><pre class="programlisting">let numberNode = new Node&lt;number&gt;(); &#13;
let stringNode = new Node&lt;string&gt;(); &#13;
numberNode.right = new Node&lt;number&gt;(); &#13;
numberNode.value = 42; &#13;
numberNode.value = '42'; // Type "string" is not assignable to type "number" &#13;
numberNode.left = stringNode; // Type Node&lt;string&gt; is not assignable to type Node&lt;number&gt; &#13;
</pre><p>In the preceding snippet, we created three nodes: <code class="literal">numberNode</code>, <code class="literal">stringNode</code>, and another node of the type <code class="literal">Node&lt;number&gt;</code>, assigning its value to the right child of <code class="literal">numberNode</code>. Note that since <code class="literal">numberNode</code> is of the type <code class="literal">Node&lt;number&gt;</code>, we can set its value to <code class="literal">42</code>, but we can't use the string <code class="literal">'42'</code>. The same is applicable to its left child. In the definition, we've explicitly declared that we want the left and right children to be of the type <code class="literal">Node&lt;number&gt;</code>. This means that we cannot assign values of the type <code class="literal">Node&lt;string&gt;</code> to them; that's why, we get the second compile-time error.</p><div class="section" title="Using generic functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec43"/>Using generic functions</h2></div></div></div><p>Another typical use of generics is for defining functions that operate over a set of types. For example, we may define an <code class="literal">identity</code> function that accepts an argument of type <code class="literal">T</code> and returns it:</p><pre class="programlisting">function identity&lt;T&gt;(arg: T) { &#13;
  return arg; &#13;
} &#13;
</pre><p>However, in some cases, we may want to use only the instances of the types that have some specific properties. For achieving this, we can use an extended syntax that allows us to declare that we want the types used as type parameters to be subtypes of given type:</p><pre class="programlisting">interface Comparable { &#13;
  compare(a: Comparable): number; &#13;
}&#13;
 &#13;
function sort&lt;T extends Comparable&gt;(arr: Comparable[]): Comparable[] { &#13;
  // ... &#13;
} &#13;
</pre><p>For example, here, we defined an interface called <code class="literal">Comparable</code>. It has a single operation called <code class="literal">compare</code>. The classes that implement the <code class="literal">Comparable</code> interface need to implement the <code class="literal">compare</code> operation. When <code class="literal">compare</code> is called with a given argument, it returns <code class="literal">1</code> if the target object is bigger than the passed argument, <code class="literal">0</code> if they are equal, and <code class="literal">-1</code> if the target object is smaller than the passed argument.</p></div><div class="section" title="Having multiple type parameters"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec44"/>Having multiple type parameters</h2></div></div></div><p>TypeScript allows us to use multiple type parameters:</p><pre class="programlisting">class Pair&lt;K, V&gt; { &#13;
  key: K; &#13;
  value: V; &#13;
} &#13;
</pre><p>In this case, we can create an instance of the class <code class="literal">Pair&lt;K, V&gt;</code> using the following syntax:</p><pre class="programlisting">let pair = new Pair&lt;string, number&gt;(); &#13;
pair.key = 'foo'; &#13;
pair.value = 42; &#13;
</pre></div></div>
<div class="section" title="Writing less verbose code with TypeScript's type inference"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec31"/>Writing less verbose code with TypeScript's type inference</h1></div></div></div><p>Static typing has a number of benefits; however, it makes us write a more verbose code by adding all the type annotations.</p><p>In some cases, the TypeScript's compiler is able to guess the types of expressions inside our code; let's consider this example, for instance:</p><pre class="programlisting">let answer = 42; &#13;
answer = '42'; // Type "string" is not assignable to type "number" &#13;
</pre><p>In the preceding example, we defined a variable <code class="literal">answer</code> and assigned the value <code class="literal">42</code> to it. Since TypeScript is statically typed and the type of a variable cannot change once declared, the compiler is smart enough to guess that the type of <code class="literal">answer</code> is <code class="literal">number</code>.</p><p>If we don't assign a value to a variable within its definition, the compiler will set its type to <code class="literal">any</code>:</p><pre class="programlisting">let answer; &#13;
answer = 42; &#13;
answer = '42'; &#13;
</pre><p>The preceding snippet will compile without any compile-time errors.</p><div class="section" title="Best common type"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec45"/>Best common type</h2></div></div></div><p>Sometimes, the type inference could be a result of several expressions. Such is the case when we assign a heterogeneous array to a variable:</p><pre class="programlisting">let x = ['42', 42]; &#13;
</pre><p>In this case, the type of <code class="literal">x</code> will be <code class="literal">any[]</code>. However, suppose we have the following:</p><pre class="programlisting">let x = [42, null, 32]; &#13;
</pre><p>The type of <code class="literal">x</code> will then be <code class="literal">number[]</code> since the type <code class="literal">Number</code> is a subtype of <code class="literal">Null</code>.</p></div><div class="section" title="Contextual type inference"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec46"/>Contextual type inference</h2></div></div></div><p>Contextual typing occurs when the type of an expression is implied from its location; let's take this example:</p><pre class="programlisting">document.body.addEventListener('mousedown', e =&gt; { &#13;
  e.foo(); // Property "foo" does not exists on a type "MouseEvent" &#13;
}, false); &#13;
</pre><p>In this case, the type of the argument of the callback <code class="literal">e</code> is <span class="emphasis"><em>guessed</em></span> by the compiler based on the context in which it is used. The compiler understands that the type of <code class="literal">e</code> is based on the call of <code class="literal">addEventListener</code> and the arguments passed to the method. In case we were using a keyboard event (<code class="literal">keydown</code>, for example), TypeScript would have been aware that <code class="literal">e</code> is of the type <code class="literal">KeyboardEvent</code>.</p><p>Type inference is a mechanism that allows us to write less verbose code by taking advantage of the static analysis performed by TypeScript. Based on the context, TypeScript's compiler is able to guess the type of a given expression without explicit definition.</p></div></div>
<div class="section" title="Using ambient type definitions"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec32"/>Using ambient type definitions</h1></div></div></div><p>Although static typing is amazing, most of the frontend libraries we use are built with JavaScript, which is dynamically typed. Since we'd want to use TypeScript in Angular, not having type definitions in the code that uses external JavaScript libraries is a big issue; it prevents us from taking advantage of the compile-time type checking.</p><p>TypeScript was built keeping these points in mind. In order to allow the TypeScript compiler to take care of what it does best, we can use the so-called ambient type definitions. They allow us to provide external type definitions of the existing JavaScript libraries. This way, they provide hints to the compiler.</p><div class="section" title="Using predefined ambient type definitions"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec47"/>Using predefined ambient type definitions</h2></div></div></div><p>Fortunately, we don't have to create ambient type definitions for all JavaScript libraries and frameworks we use. The community and/or the authors of these libraries have already published such definitions online; the biggest repository resides at <a class="ulink" href="https://github.com/DefinitelyTyped/DefinitelyTyped">https://github.com/DefinitelyTyped/DefinitelyTyped</a>. During the last couple of months, the community developed a few tools for managing ambient type definitions, such as <code class="literal">tsd</code> and<span class="strong"><strong> </strong></span>
<code class="literal">typings</code>.</p><p>Later, Microsoft introduced an official way to manage them, using <span class="strong"><strong>
<code class="literal">npm</code>
</strong></span> by providing an additional configuration in <code class="literal">tsconfig.json</code>. The type definitions are now distributed as scoped packages under the namespace <code class="literal">@types</code> and installed in <code class="literal">node_modules</code>.</p><p>Let's create a directory and add a <code class="literal">package.json</code> file to it:</p><pre class="programlisting">
<span class="strong"><strong>$ mkdir types-test &amp;&amp; cd types-test &amp;&amp; npm init</strong></span>
</pre><p>After we provide the default values for the questions that <code class="literal">npm</code> asks us, our <code class="literal">package.json</code> in the <code class="literal">types-test</code> directory should look something like this:</p><pre class="programlisting">{&#13;
  "name": "types-test",&#13;
  "version": "1.0.0",&#13;
  "description": "",&#13;
  "main": "index.js",&#13;
  "scripts": {&#13;
    "test": "echo "Error: no test specified" &amp;&amp; exit 1"&#13;
  },&#13;
  "author": "",&#13;
  "license": "ISC"&#13;
}</pre><p>We can install new type definition using:</p><pre class="programlisting">
<span class="strong"><strong>$ npm install @types/angular --save-dev</strong></span>
</pre><p>The preceding command will download the type definitions for AngularJS and save them in <code class="literal">node_modules/@types/angular</code>. Note that we provided the <code class="literal">--save-dev</code> flag to <code class="literal">npm</code> in order to save the type definition under <code class="literal">devDependencies</code> of <code class="literal">package.json</code>.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip9"/>Tip</h3><p>When installing ambient type definitions we would usually use <code class="literal">--save-dev</code> instead of <code class="literal">--save</code>, because the definitions are mostly used in development.</p></div></div><p>After running the preceding command, your <code class="literal">package.json</code> file should look similar to this:</p><pre class="programlisting">{&#13;
  "name": "types-test",&#13;
  "version": "1.0.0",&#13;
  "description": "",&#13;
  "main": "index.js",&#13;
  "scripts": {&#13;
    "test": "echo "Error: no test specified" &amp;&amp; exit 1"&#13;
  },&#13;
  "author": "",&#13;
  "license": "ISC",&#13;
  "devDependencies": {&#13;
    "@types/angular": "^1.5.20"&#13;
  }&#13;
}&#13;
</pre><p>Now, in order to use AngularJS with TypeScript, create <code class="literal">app.ts</code> and enter the following content:</p><pre class="programlisting">/// &lt;reference path="./node_modules/@types/angular/index.d.ts"/&gt; &#13;
 &#13;
var module = angular.module('module', []); &#13;
module.controller('MainCtrl', &#13;
  function MainCtrl($scope: angular.IScope) { &#13;
 &#13;
  }); &#13;
</pre><p>To compile <code class="literal">app.ts</code>, use:</p><pre class="programlisting">
<span class="strong"><strong>$ tsc app.ts</strong></span>
</pre><p>The TypeScript compiler will output the compiled content into <code class="literal">app.js</code>. In order to add extra automation and invoke the TypeScript compiler each time you change any of the files in your project, you can use a task runner, such as gulp or grunt, or pass the <code class="literal">-w</code> option to <code class="literal">tsc</code>.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note10"/>Note</h3><p>Since using the <code class="literal">reference</code> element for including type definitions is considered bad practice, we can use a <code class="literal">tsconfig.json</code> file instead. There, we can configure which directories need to be included in the compilation process by <code class="literal">tsc</code>. For more information, visit <a class="ulink" href="http://www.typescriptlang.org/docs/handbook/tsconfig-json.html">http://www.typescriptlang.org/docs/handbook/tsconfig-json.html</a>.</p></div></div><p>Now, let's create a file called <code class="literal">tsconfig.json</code> in the same directory, with the following content:</p><pre class="programlisting">{&#13;
  "compilerOptions": {&#13;
    "target": "es5",&#13;
    "module": "commonjs",&#13;
    "experimentalDecorators": true,&#13;
    "outDir": "./dist"&#13;
  },&#13;
  "files": [&#13;
    "./app.ts"&#13;
  ]&#13;
}</pre><p>In this configuration file, we provide the <code class="literal">compilerOptions</code> property so that we don't have to pass parameters, such as <code class="literal">outDir</code> and <code class="literal">module</code> formats, as flags to <code class="literal">tsc</code>. Note that in the <code class="literal">files</code> property, we also list the files that we want to be compiled. TypeScript will compile all of them plus all their transitive dependencies!</p><p>Now, let's modify our preceding simple snippet:</p><pre class="programlisting">var module = angular.module('module', []); &#13;
module.controller('MainCtrl', &#13;
  function MainCtrl($scope: angular.IScope) { &#13;
<span class="strong"><strong>    const set = new Set&lt;any&gt;();</strong></span>&#13;
  });</pre><p>The only change we made was to add the line where we declare and initialize a new constant with the returned result by the invocation of the <code class="literal">Set</code> constructor function, with <code class="literal">any</code> as the type parameter. By having <code class="literal">tsconfig.json</code> in the same directory where our <code class="literal">app.ts</code> file and <code class="literal">node_modules</code> are, we can compile the project by running:</p><pre class="programlisting">
<span class="strong"><strong>$ tsc</strong></span>
</pre><p>However, we'll get the following error:</p><p>
<span class="strong"><strong>demo.ts(4,22): error TS2304: Cannot find name 'Set'.</strong></span>
</p><p>
<code class="literal">Set</code> implements the set data structure and is part of the ES2015 standard. Since using the ambient type definitions for ES2015 is a very common practice in all TypeScript projects, Microsoft added them as part of TypeScript itself. To the <code class="literal">compilerOptions</code> property inside <code class="literal">tsconfig.json</code>, add the following <code class="literal">lib</code> property:</p><pre class="programlisting">{&#13;
 "compilerOptions": {&#13;
   "target": "es5",&#13;
   "module": "commonjs",&#13;
   "experimentalDecorators": true,&#13;
   "outDir": "./dist",&#13;
<span class="strong"><strong>   "lib": ["es2015", "dom"]</strong></span>&#13;
 },&#13;
 "files": [&#13;
   "./demo.ts"&#13;
 ]&#13;
}</pre><p>
<code class="literal">lib</code> has value an array, which includes both <code class="literal">"es2015"</code> and <code class="literal">"dom"</code> because we need ES2015 Set, and Angular's type definitions require the type definitions for the <span class="strong"><strong>Document Object Model</strong></span> (<span class="strong"><strong>DOM</strong></span>). Now when you run <code class="literal">tsc</code> in the directory where your <code class="literal">tsconfig.json</code> file is located, the compilation process should pass successfully and the output file should be located in <code class="literal">./dist/demo.js</code>.</p></div><div class="section" title="Custom ambient type definitions"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec48"/>Custom ambient type definitions</h2></div></div></div><p>To understand how everything works together, let's take a look at an example. Suppose we have the following interface of a JavaScript library:</p><pre class="programlisting">var DOM = { &#13;
  // Returns a set of elements which match the passed selector &#13;
  selectElements: function (selector) { &#13;
    // ... &#13;
  }, &#13;
  hide: function (element) { &#13;
    // ... &#13;
  }, &#13;
  show: function (element) { &#13;
    // ... &#13;
  } &#13;
}; &#13;
</pre><p>We have an object literal assigned to a variable called <code class="literal">DOM</code>. The object has the following methods:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">selectElements</code>: This accepts a single argument with type string and returns a set of <code class="literal">DOM</code> elements.</li><li class="listitem" style="list-style-type: disc"><code class="literal">hide</code>: This accepts a <code class="literal">DOM</code> node as an argument and returns nothing.</li><li class="listitem" style="list-style-type: disc"><code class="literal">show</code>: This accepts a <code class="literal">DOM</code> node as an argument and returns nothing.</li></ul></div><p>In TypeScript, the preceding definition would look as follows:</p><pre class="programlisting">var DOM = { &#13;
  // Returns a set of elements which match the passed selector &#13;
  selectElements: function (selector: string): HTMLElement[] { &#13;
    //...&#13;
    return []; &#13;
  }, &#13;
  hide: function (element: HTMLElement): void { &#13;
    element.hidden = true; &#13;
  }, &#13;
  show: function (element: HTMLElement): void { &#13;
    element.hidden = false; &#13;
  } &#13;
}; &#13;
</pre><p>This means that we can define our library's interface as follows:</p><pre class="programlisting">interface LibraryInterface { &#13;
  selectElements(selector: string): HTMLElement[] &#13;
  hide(element: HTMLElement): void &#13;
  show(element: HTMLElement): void &#13;
} &#13;
</pre><p>After we have the interface of our library, it will be easy to create the ambient type definition; we just have to create a file with an extension <code class="literal">d.ts</code> called <code class="literal">dom</code> and enter the following content:</p><pre class="programlisting">// inside "dom.d.ts" &#13;
 &#13;
interface DOMLibraryInterface { &#13;
  selectElements(selector: string): HTMLElement[] &#13;
  hide(element: HTMLElement): void &#13;
  show(element: HTMLElement): void &#13;
} &#13;
 &#13;
declare var DOM: DOMLibraryInterface; &#13;
</pre><p>In the preceding snippet, we defined the interface called <code class="literal">DOMLibraryInterface</code> and declared the <code class="literal">DOM</code> variable of the type <code class="literal">DOMLibraryInterface</code>.</p><p>The only thing left before being able to use static typing with our JavaScript library is including the external type definition in the script files we want to use our library in. We can do it as follows:</p><pre class="programlisting">/// &lt;reference path="dom.d.ts"/&gt; &#13;
</pre><p>The preceding snippet hints the compiler on where to find the ambient type definitions. An alternative, and better, way to provide a reference to the <code class="literal">d.ts</code> file is to use <code class="literal">tsconfig.json</code> as described above.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec33"/>Summary</h1></div></div></div><p>In this chapter, we peeked at the TypeScript language that is used for the implementation of Angular. Although we can develop our Angular applications using ECMAScript 5, Google's recommendation is to use TypeScript in order to take advantage of the static typing it provides.</p><p>While exploring the language, we looked at some of the core features of ES2015 and ES2016. We explained the ES2015 and ES2016 classes, arrow functions, block scope variable definitions, destructuring, and modules. Since Angular takes advantage of the ES2016 decorators, and more accurately their extension in TypeScript, a section was dedicated to them.</p><p>After this, we took a look at how we can take advantage of static typing using explicit type definitions. We described some of the built-in types in TypeScript and how we can define classes in the language by specifying access modifiers for their members. Our next stop was the interfaces. We ended our adventures in TypeScript by explaining the type parameters and the ambient type definitions.</p><p>In the next chapter, we will start exploring Angular in depth using the framework's components and directives.</p></div></body></html>