<html><head></head><body>
<div id="_idContainer062">
<h1 class="chapter-number" id="_idParaDest-231"><a id="_idTextAnchor230"/><span class="koboSpan" id="kobo.1.1">17</span></h1>
<h1 id="_idParaDest-232"><a id="_idTextAnchor231"/><span class="koboSpan" id="kobo.2.1">Migration and Upgrade Strategies</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Throughout this book, we’ve explored many aspects of web development with Remix. </span><span class="koboSpan" id="kobo.3.2">You learned how to use Remix to unlock the full potential of the web platform, and you thoroughly practiced developing full stack applications by building BeeRich. </span><span class="koboSpan" id="kobo.3.3">In this last chapter, we will talk about migration and </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">upgrade strategies.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">The chapter is split into </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">two sections:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">Migrating </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">to Remix</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">Keeping Remix apps up </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">to date</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.11.1">First, we will discuss how to migrate to Remix. </span><span class="koboSpan" id="kobo.11.2">Different applications may require different migration strategies with varying efforts. </span><span class="koboSpan" id="kobo.11.3">We will look at non-React, React, and React Router apps and create a migration strategy for each. </span><span class="koboSpan" id="kobo.11.4">Next, we will learn how major version upgrades are rolled out in Remix. </span><span class="koboSpan" id="kobo.11.5">We will introduce you to Remix’s future flags and discuss how future flags enable us to gradually upgrade </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">Remix apps.</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">After reading this chapter, you will know different migration strategies for Remix. </span><span class="koboSpan" id="kobo.13.2">You will understand how to run Remix side by side with an existing legacy application and how React Router can be used to prepare your code base for a migration. </span><span class="koboSpan" id="kobo.13.3">Further, you will know how Remix can be integrated within a wider system architecture. </span><span class="koboSpan" id="kobo.13.4">Finally, you will learn how to gradually upgrade your Remix application with </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">future flags.</span></span></p>
<h1 id="_idParaDest-233"><a id="_idTextAnchor232"/><span class="koboSpan" id="kobo.15.1">Migrating to Remix</span></h1>
<p><span class="koboSpan" id="kobo.16.1">Migrations </span><a id="_idIndexMarker599"/><span class="koboSpan" id="kobo.17.1">are never easy. </span><span class="koboSpan" id="kobo.17.2">Moving an existing code base to a new framework comes with difficulties and may involve a lot of refactoring. </span><span class="koboSpan" id="kobo.17.3">Remix is no exception, but some strategies may make a migration less painful, depending on the existing application architecture. </span><span class="koboSpan" id="kobo.17.4">In this section, we will discuss different migration strategies for Remix. </span><span class="koboSpan" id="kobo.17.5">Let’s start by reviewing a migration from a </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">non-React app.</span></span></p>
<h2 id="_idParaDest-234"><a id="_idTextAnchor233"/><span class="koboSpan" id="kobo.19.1">Migrating non-React apps to Remix</span></h2>
<p><span class="koboSpan" id="kobo.20.1">Migrating</span><a id="_idIndexMarker600"/><span class="koboSpan" id="kobo.21.1"> from a non-React app to Remix is a challenging task and may be very time-consuming, depending on the size of the existing application. </span><span class="koboSpan" id="kobo.21.2">The complexity of a migration usually increases with ongoing feature</span><a id="_idIndexMarker601"/><span class="koboSpan" id="kobo.22.1"> development. </span><span class="koboSpan" id="kobo.22.2">Most of the time, we may be unable to freeze feature development and bug fixes while migrating. </span><span class="koboSpan" id="kobo.22.3">This results in having to migrate existing code and features to Remix while also having to implement new features in both the old and </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">new applications.</span></span></p>
<p><span class="koboSpan" id="kobo.24.1">One solution may be to run the new and old applications side by side. </span><span class="koboSpan" id="kobo.24.2">By doing so, we can keep our legacy application alive while ramping up our Remix application. </span><span class="koboSpan" id="kobo.24.3">Step by step, we may be able to move more and more code </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">to Remix.</span></span></p>
<p><span class="koboSpan" id="kobo.26.1">For instance, we can host the new Remix application on a subdomain and implement new pages and flows in Remix. </span><span class="koboSpan" id="kobo.26.2">Using a subdomain, we can share existing cookies between the </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">two applications.</span></span></p>
<p><span class="koboSpan" id="kobo.28.1">The migration process could look </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">like this:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.30.1">Create a new </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">Remix application.</span></span></li>
<li><span class="koboSpan" id="kobo.32.1">Register the Remix application on a subdomain to </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">share cookies.</span></span></li>
<li><span class="koboSpan" id="kobo.34.1">Re-implement reusable components </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">in React.</span></span></li>
<li><span class="koboSpan" id="kobo.36.1">Recreate the page layout, footer, and navbar </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">in Remix.</span></span></li>
<li><span class="koboSpan" id="kobo.38.1">Develop new pages and flows </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">in Remix.</span></span></li>
<li><span class="koboSpan" id="kobo.40.1">Migrate existing pages incrementally </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">to Remix.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.42.1">By developing new pages in Remix, we avoid having to implement new features in both the old and new applications. </span><span class="koboSpan" id="kobo.42.2">Instead, we can route users back and forth between the two applications. </span><span class="koboSpan" id="kobo.42.3">We can use cookies and the URL to share </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">application states.</span></span></p>
<p><span class="koboSpan" id="kobo.44.1">Running both applications side by side still requires us to do some work up front, such as re-implementing reusable components and page layout in React, but we can avoid having to make a complete switch before being able to run Remix </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">in production.</span></span></p>
<p><span class="koboSpan" id="kobo.46.1">If we already use React, then the migration should </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">be easier.</span></span></p>
<h2 id="_idParaDest-235"><a id="_idTextAnchor234"/><span class="koboSpan" id="kobo.48.1">Migrating from a React app</span></h2>
<p><span class="koboSpan" id="kobo.49.1">We </span><a id="_idIndexMarker602"/><span class="koboSpan" id="kobo.50.1">can reuse bigger parts of our existing code base if we </span><a id="_idIndexMarker603"/><span class="koboSpan" id="kobo.51.1">maintain a React application. </span><span class="koboSpan" id="kobo.51.2">However, if we are currently using a different React framework, such as Gatsby or Next.js, then migrating may still require us to run the legacy app and Remix app side by side </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">in production.</span></span></p>
<h3><span class="koboSpan" id="kobo.53.1">Migrating from another React meta framework</span></h3>
<p><span class="koboSpan" id="kobo.54.1">Different</span><a id="_idIndexMarker604"/><span class="koboSpan" id="kobo.55.1"> React frameworks utilize different routing</span><a id="_idIndexMarker605"/><span class="koboSpan" id="kobo.56.1"> conventions, primitives, and component APIs. </span><span class="koboSpan" id="kobo.56.2">Migrating from another meta framework may allow us to reuse existing React components but may still </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">require refactoring.</span></span></p>
<p><span class="koboSpan" id="kobo.58.1">The migration process from a different React framework could look </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">like this:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.60.1">Create a new </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">Remix application.</span></span></li>
<li><span class="koboSpan" id="kobo.62.1">Register the Remix application on a subdomain to </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">share cookies.</span></span></li>
<li><span class="koboSpan" id="kobo.64.1">Copy, paste, and adapt </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">reusable components.</span></span></li>
<li><span class="koboSpan" id="kobo.66.1">Copy, paste, and adapt the page layout, footer, </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">and navbar.</span></span></li>
<li><span class="koboSpan" id="kobo.68.1">Develop new pages and flows </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">in Remix.</span></span></li>
<li><span class="koboSpan" id="kobo.70.1">Migrate existing pages incrementally </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">to Remix.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.72.1">We may need to refactor existing components to use Remix’s primitives and utilities. </span><span class="koboSpan" id="kobo.72.2">For instance, we want to refactor existing anchor tags to use Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">Link</span></strong><span class="koboSpan" id="kobo.74.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">NavLink</span></strong><span class="koboSpan" id="kobo.76.1"> components. </span><span class="koboSpan" id="kobo.76.2">Conclusively, it may be best to copy code to Remix and refactor it from there. </span><span class="koboSpan" id="kobo.76.3">This requires us to maintain duplicate code across the legacy and </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">Remix apps.</span></span></p>
<p><span class="koboSpan" id="kobo.78.1">It becomes easier if we run a client-side-only React application without a framework. </span><span class="koboSpan" id="kobo.78.2">Let’s review how to migrate a client-only React app </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">to Remix.</span></span></p>
<h3><span class="koboSpan" id="kobo.80.1">Migrating from a client-only React app</span></h3>
<p><span class="koboSpan" id="kobo.81.1">If we </span><a id="_idIndexMarker606"/><span class="koboSpan" id="kobo.82.1">maintain Create React App or a Vite React app (client-only), we might have an easier time </span><a id="_idIndexMarker607"/><span class="koboSpan" id="kobo.83.1">migrating to Remix, especially if the application already utilizes </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">React Router.</span></span></p>
<p><span class="koboSpan" id="kobo.85.1">On the client, Remix </span><a id="_idIndexMarker608"/><span class="koboSpan" id="kobo.86.1">runs a client-side React application, and most of the React code and client-side fetch requests will work the same way in Remix as they did before. </span><span class="koboSpan" id="kobo.86.2">Hence, we can run the existing app on the client side inside Remix. </span><span class="koboSpan" id="kobo.86.3">From there, we can incrementally refactor </span><a id="_idIndexMarker609"/><span class="koboSpan" id="kobo.87.1">pieces from the client-side-only app to </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">Remix routes.</span></span></p>
<p><span class="koboSpan" id="kobo.89.1">The migration process from a client-only React app could look </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">like this:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.91.1">Create a new </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">Remix application.</span></span></li>
<li><span class="koboSpan" id="kobo.93.1">Move the existing app inside the new </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">Remix app.</span></span></li>
<li><span class="koboSpan" id="kobo.95.1">Render the existing app in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">index</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.97.1"> route.</span></span></li>
<li><span class="koboSpan" id="kobo.98.1">Copy and adapt the page layout, footer, </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">and navbar.</span></span></li>
<li><span class="koboSpan" id="kobo.100.1">Develop new pages and flows </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">in Remix.</span></span></li>
<li><span class="koboSpan" id="kobo.102.1">Migrate existing pages incrementally </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">to Remix.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.104.1">We may still need to copy and paste existing components to create Remix-compatible versions. </span><span class="koboSpan" id="kobo.104.2">However, at least for now, we can do so in the same </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.106.1">Migrating becomes much easier if we use React Router as the client-side </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">routing solution.</span></span></p>
<h2 id="_idParaDest-236"><a id="_idTextAnchor235"/><span class="koboSpan" id="kobo.108.1">Migrating from React Router</span></h2>
<p><span class="koboSpan" id="kobo.109.1">Remix was</span><a id="_idIndexMarker610"/><span class="koboSpan" id="kobo.110.1"> created by Michael Jackson and Ryan Florence, the</span><a id="_idIndexMarker611"/><span class="koboSpan" id="kobo.111.1"> creators of React Router. </span><span class="koboSpan" id="kobo.111.2">Remix has been heavily inspired and influenced by the development and maintenance of React Router over </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">the years.</span></span></p>
<p><span class="koboSpan" id="kobo.113.1">React Router is a</span><a id="_idIndexMarker612"/><span class="koboSpan" id="kobo.114.1"> library for client-side routing in React. </span><span class="koboSpan" id="kobo.114.2">Since Remix’s development, the Remix team has also worked on releasing React Router version 6, which aligns React Router’s API with that of Remix. </span><span class="koboSpan" id="kobo.114.3">Remix and React Router have since been refactored to build upon the same baseline </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">router package.</span></span></p>
<p><span class="koboSpan" id="kobo.116.1">When looking through the API documentation of React Router version 6, you may notice many familiar concepts such as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">loader</span></strong><span class="koboSpan" id="kobo.118.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">action</span></strong><span class="koboSpan" id="kobo.120.1"> functions, many familiar hooks such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">useLoaderData</span></strong><span class="koboSpan" id="kobo.122.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">useActionData</span></strong><span class="koboSpan" id="kobo.124.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">useNavigation</span></strong><span class="koboSpan" id="kobo.126.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">useSearchParams</span></strong><span class="koboSpan" id="kobo.128.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">useFetcher</span></strong><span class="koboSpan" id="kobo.130.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">useLocation</span></strong><span class="koboSpan" id="kobo.132.1">, and familiar components such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">Form</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.134.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">Link</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.137.1">React Router’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">loader</span></strong><span class="koboSpan" id="kobo.139.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">action</span></strong><span class="koboSpan" id="kobo.141.1"> functions are executed on the client, not the server, as </span><a id="_idIndexMarker613"/><span class="koboSpan" id="kobo.142.1">React Router is a client-side routing solution. </span><span class="koboSpan" id="kobo.142.2">However, React Router uses the same navigation, data loading, and revalidation flow as Remix, which allows us to build React Router apps with the same mental model, conventions, and primitives. </span><span class="koboSpan" id="kobo.142.3">This makes migrating from React Router version 6 to </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">Remix easier.</span></span></p>
<p><span class="koboSpan" id="kobo.144.1">We can derive</span><a id="_idIndexMarker614"/><span class="koboSpan" id="kobo.145.1"> the following migration process for client-only </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">React applications:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.147.1">Migrate to React Router </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">version 6.</span></span></li>
<li><span class="koboSpan" id="kobo.149.1">Iteratively refactor code to use React Router’s primitives and conventions, most importantly the </span><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">loader</span></strong><span class="koboSpan" id="kobo.151.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">action</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.153.1"> functions.</span></span></li>
<li><span class="koboSpan" id="kobo.154.1">Migrate from React Router version 6 </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">to Remix.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.156.1">First, we need to migrate to React Router version 6. </span><span class="koboSpan" id="kobo.156.2">We can follow the existing migration guides on the React </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">Router documentation.</span></span></p>
<p><span class="koboSpan" id="kobo.158.1">Once we use React Router version 6, we can refactor the code iteratively over time. </span><span class="koboSpan" id="kobo.158.2">We will refactor existing fetch requests to React Router’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">loader</span></strong><span class="koboSpan" id="kobo.160.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">action</span></strong><span class="koboSpan" id="kobo.162.1"> functions and utilize React Router’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">Link</span></strong><span class="koboSpan" id="kobo.164.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">Form</span></strong><span class="koboSpan" id="kobo.166.1"> components to implement navigations and mutations – just like with Remix. </span><span class="koboSpan" id="kobo.166.2">This also allows us to utilize React Router’s life cycle hooks, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">useNavigation</span></strong><span class="koboSpan" id="kobo.168.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">useFetcher</span></strong><span class="koboSpan" id="kobo.170.1">, to implement pending states and </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">optimistic UI.</span></span></p>
<p><span class="koboSpan" id="kobo.172.1">In contrast to Remix, React Router does not use a file-based routing convention. </span><span class="koboSpan" id="kobo.172.2">If we want to utilize Remix’s file-based routing convention – or any other routing convention – then we might want to start defining it already in the client-side application. </span><span class="koboSpan" id="kobo.172.3">For instance, it may be helpful to move route components into a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">routes/</span></strong><span class="koboSpan" id="kobo.174.1"> folder and to co-locate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">loader</span></strong><span class="koboSpan" id="kobo.176.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">action</span></strong><span class="koboSpan" id="kobo.178.1"> functions together with the React Router route components, matching Remix’s route </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">file convention.</span></span></p>
<p><span class="koboSpan" id="kobo.180.1">At some point, we will have to make the switch and move the app over to Remix. </span><span class="koboSpan" id="kobo.180.2">The closer we bring the application to Remix’s routing convention and data flow, the better. </span><span class="koboSpan" id="kobo.180.3">However, there is </span><a id="_idIndexMarker615"/><span class="koboSpan" id="kobo.181.1">no need to refactor everything to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">loader</span></strong><span class="koboSpan" id="kobo.183.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">action</span></strong><span class="koboSpan" id="kobo.185.1"> functions before making the migration, even though it would </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">be helpful.</span></span></p>
<p><span class="koboSpan" id="kobo.187.1">We can render the client-side React Router routes within Remix, as discussed in the previous section. </span><span class="koboSpan" id="kobo.187.2">Naturally, this is not as effective as moving the routes over to Remix, but for bigger </span><a id="_idIndexMarker616"/><span class="koboSpan" id="kobo.188.1">applications, this may be a valid option to ensure a </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">timely migration.</span></span></p>
<p><span class="koboSpan" id="kobo.190.1">You can read more about an incremental migration from React Router version 6 to Remix in the </span><a id="_idIndexMarker617"/><span class="koboSpan" id="kobo.191.1">Remix </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">documentation: </span></span><a href="https://remix.run/docs/en/main/guides/migrating-react-router-app"><span class="No-Break"><span class="koboSpan" id="kobo.193.1">https://remix.run/docs/en/main/guides/migrating-react-router-app</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.194.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.195.1">Now that we have discussed a strategy to migrate the client-side code, let’s review the </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">backend code.</span></span></p>
<h2 id="_idParaDest-237"><a id="_idTextAnchor236"/><span class="koboSpan" id="kobo.197.1">Working with a backend application</span></h2>
<p><span class="koboSpan" id="kobo.198.1">Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">loader</span></strong><span class="koboSpan" id="kobo.200.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">action</span></strong><span class="koboSpan" id="kobo.202.1"> functions run on the server. </span><span class="koboSpan" id="kobo.202.2">We can use them to read and </span><a id="_idIndexMarker618"/><span class="koboSpan" id="kobo.203.1">write directly from and to a database </span><a id="_idIndexMarker619"/><span class="koboSpan" id="kobo.204.1">and implement webhooks and server-sent event endpoints with resource routes. </span><span class="koboSpan" id="kobo.204.2">We can use Remix to implement standalone full stack applications that do not require additional backend applications. </span><span class="koboSpan" id="kobo.204.3">In this section, we will discuss how Remix fits into a bigger system architecture and how we can utilize Remix when there are downstream </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">backend applications.</span></span></p>
<p><span class="koboSpan" id="kobo.206.1">In bigger application architectures, there might be more systems between a frontend application and a database. </span><span class="koboSpan" id="kobo.206.2">In this case, Remix will serve as the web server for </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">our frontend.</span></span></p>
<p><span class="koboSpan" id="kobo.208.1">Let’s review the code example from </span><a href="B17399_01.xhtml#_idTextAnchor013"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.209.1">Chapter 1</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.210.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.211.1">
export async function action({ request }) {  const userId = await </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">requireUserSession</span></strong><span class="koboSpan" id="kobo.213.1">(request);
  const form = await request.formData();
  const title = form.get("title");
  return </span><strong class="bold"><span class="koboSpan" id="kobo.214.1">createExpense({ userId, title });</span></strong><span class="koboSpan" id="kobo.215.1">
}
export async function loader({ request }) {
  const userId = await requireUserSession(request);
  return </span><strong class="bold"><span class="koboSpan" id="kobo.216.1">getExpenses(userId);</span></strong><span class="koboSpan" id="kobo.217.1">
}
export default function ExpensesPage() {
  const expenses = useLoaderData();
  const { state } = useTransition();
  const isSubmitting = state === "submitting";
return ( &lt;&gt;
      &lt;h1&gt;Expenses&lt;/h1&gt;
      {expenses.map((project) =&gt; (
        &lt;Link to={expense.id}&gt;{expense.title}&lt;/Link&gt;
      ))}
      &lt;h2&gt;Add expense&lt;/h2&gt;
      &lt;Form method="post"&gt;
        &lt;input name="title" /&gt;
        &lt;button type="submit" disabled={isSubmitting}&gt;
          {isSubmitting ? </span><span class="koboSpan" id="kobo.217.2">"Adding..." </span><span class="koboSpan" id="kobo.217.3">: "Add"}
        &lt;/button&gt;
&lt;/Form&gt; &lt;/&gt;
); }</span></pre>
<p><span class="koboSpan" id="kobo.218.1">On incoming</span><a id="_idIndexMarker620"/><span class="koboSpan" id="kobo.219.1"> requests, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">loader</span></strong><span class="koboSpan" id="kobo.221.1"> function fetches a list of expenses. </span><span class="koboSpan" id="kobo.221.2">The route component renders both an expense list and an expense form, which on submit posts to the same route’s </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">action</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.223.1"> function.</span></span></p>
<p><span class="koboSpan" id="kobo.224.1">Note how </span><a id="_idIndexMarker621"/><span class="koboSpan" id="kobo.225.1">we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">createExpense</span></strong><span class="koboSpan" id="kobo.227.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">getExpense</span></strong><span class="koboSpan" id="kobo.229.1"> helper functions in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">loader</span></strong><span class="koboSpan" id="kobo.231.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">action</span></strong><span class="koboSpan" id="kobo.233.1"> functions. </span><span class="koboSpan" id="kobo.233.2">We could implement these functions to read and write from and to a database. </span><span class="koboSpan" id="kobo.233.3">However, we could also implement the functions to </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">fetch</span></strong><span class="koboSpan" id="kobo.235.1"> from downstream </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">backend services.</span></span></p>
<p><span class="koboSpan" id="kobo.237.1">Similarly, we could implement </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">requireUserSession</span></strong><span class="koboSpan" id="kobo.239.1"> to send a request to a downstream</span><a id="_idIndexMarker622"/><span class="koboSpan" id="kobo.240.1"> authentication service, instead of implementing the authentication code within our Remix app. </span><span class="koboSpan" id="kobo.240.2">Conclusively, Remix can also be used to forward requests to</span><a id="_idIndexMarker623"/><span class="koboSpan" id="kobo.241.1"> backend applications and implement the </span><strong class="bold"><span class="koboSpan" id="kobo.242.1">Backend for Frontend</span></strong><span class="koboSpan" id="kobo.243.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.244.1">BFF</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">) pattern.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.246.1">Backend for Frontend</span></p>
<p class="callout"><span class="koboSpan" id="kobo.247.1">The BFF pattern </span><a id="_idIndexMarker624"/><span class="koboSpan" id="kobo.248.1">specifies a software architecture where each frontend has a dedicated backend that is used to tailor content for the specific needs of the frontend application. </span><span class="koboSpan" id="kobo.248.2">The backend then forwards or orchestrates requests to more generic </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">downstream services.</span></span></p>
<p><span class="koboSpan" id="kobo.250.1">We don’t need to migrate our backend application to Remix simultaneously with our frontend application. </span><span class="koboSpan" id="kobo.250.2">Instead, we can forward requests from the frontend to the legacy backend application. </span><span class="koboSpan" id="kobo.250.3">We can then gradually migrate the backend code into Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">loader</span></strong><span class="koboSpan" id="kobo.252.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">action</span></strong><span class="koboSpan" id="kobo.254.1"> functions. </span><span class="koboSpan" id="kobo.254.2">Alternatively, we can also maintain the backend application together with the Remix app. </span><span class="koboSpan" id="kobo.254.3">In bigger system architectures, it may be desirable to use Remix only as a web server and use generic backend services to implement REST APIs that can be reused across </span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">different clients.</span></span></p>
<p><span class="koboSpan" id="kobo.256.1">In this section, you learned how to migrate different applications to Remix. </span><span class="koboSpan" id="kobo.256.2">You now understand how to use Remix as a BFF. </span><span class="koboSpan" id="kobo.256.3">In the next section, you will learn how to keep your Remix app up </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">to date.</span></span></p>
<h1 id="_idParaDest-238"><a id="_idTextAnchor237"/><span class="koboSpan" id="kobo.258.1">Keeping Remix apps up to date</span></h1>
<p><span class="koboSpan" id="kobo.259.1">Remix, like </span><a id="_idIndexMarker625"/><span class="koboSpan" id="kobo.260.1">every framework, undergoes constant maintenance and development. </span><span class="koboSpan" id="kobo.260.2">Bigger updates are introduced as major releases that can include breaking changes. </span><span class="koboSpan" id="kobo.260.3">Upgrading to a newer major version can require refactoring, and especially for bigger applications, this can be a painful chore. </span><span class="koboSpan" id="kobo.260.4">Remix aims to make upgrading to major versions as painless as possible. </span><span class="koboSpan" id="kobo.260.5">In this section, we will see how we can gradually migrate to newer major versions </span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">in Remix.</span></span></p>
<p><span class="koboSpan" id="kobo.262.1">Like most open source projects, Remix uses semantic versioning to denote its patches and updates. </span><span class="koboSpan" id="kobo.262.2">Semantic versioning provides a way to document three different kinds of changes in a </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">definitive hierarchy:</span></span></p>
<ol>
<li> <strong class="source-inline"><span class="koboSpan" id="kobo.264.1">2.x.x</span></strong><span class="koboSpan" id="kobo.265.1">: Changes that increment the first digit are major releases that include </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">breaking changes</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">x.1.x</span></strong><span class="koboSpan" id="kobo.268.1">: Changes incrementing the middle digit are minor releases that introduce new features but </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">remain backward-compatible</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">x.x.1</span></strong><span class="koboSpan" id="kobo.271.1">: Changes that increment the last digit are bug fixes and dependency patches that </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">remain backward-compatible</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.273.1">A new major release breaks backward compatibility, meaning you must update existing code to upgrade to the major version. </span><span class="koboSpan" id="kobo.273.2">This can be a painful process. </span><span class="koboSpan" id="kobo.273.3">Luckily, the Remix team provides future flags to avoid all-at-once </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">upgrade processes.</span></span></p>
<p><span class="koboSpan" id="kobo.275.1">Future flags are Boolean flags that we can specify in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">remix.config.js</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.277.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.278.1">
/** @type {import('@remix-run/dev').AppConfig} */module.exports = {
</span><strong class="bold"><span class="koboSpan" id="kobo.279.1">  future: {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.280.1">    v2_errorBoundary: true,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.281.1">    v2_meta: true,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.282.1">    v2_routeConvention: true,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.283.1">  },</span></strong><span class="koboSpan" id="kobo.284.1">
};</span></pre>
<p><span class="koboSpan" id="kobo.285.1">Whenever the Remix team finalizes a feature of a new major version, it also releases the feature in the previous major version, hidden behind a future flag. </span><span class="koboSpan" id="kobo.285.2">This means we can start using the new features in the previous version before the next major version is released. </span><span class="koboSpan" id="kobo.285.3">By utilizing the future flags, we can gradually (feature by feature) refactor </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">our code.</span></span></p>
<p><span class="koboSpan" id="kobo.287.1">The Remix team distinguishes two kinds of </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">future flags:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.289.1">Unstable flags</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.290.1">Version flags</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.291.1">Unstable</span><a id="_idIndexMarker626"/><span class="koboSpan" id="kobo.292.1"> future flags (</span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">unstable_</span></strong><span class="koboSpan" id="kobo.294.1">) are used for features where the API is still under active development and may be up to change. </span><span class="koboSpan" id="kobo.294.2">These features are unstable, and the API might be removed or changed in </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">future releases.</span></span></p>
<p><span class="koboSpan" id="kobo.296.1">Once an unstable feature is stable, the feature may either be introduced in a minor version update or transformed into a version future flag (</span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">vX_</span></strong><span class="koboSpan" id="kobo.298.1">). </span><span class="koboSpan" id="kobo.298.2">Version-based feature flags enable stable API changes in the current Remix version. </span><span class="koboSpan" id="kobo.298.3">Enabling a version-based feature flag allows developers to prepare for the next major version update. </span><span class="koboSpan" id="kobo.298.4">For instance, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">v2_meta</span></strong><span class="koboSpan" id="kobo.300.1"> future flag is used to enable the updated meta-function API of Remix v2 in </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">Remix v1.</span></span></p>
<p><span class="koboSpan" id="kobo.302.1">Future flags allow the Remix team to iterate on Remix’s primitives and conventions and release new features, one by one, in the current major version. </span><span class="koboSpan" id="kobo.302.2">This also allows the team to receive early feedback and identify potential issues and bugs as early </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">as possible.</span></span></p>
<p><span class="koboSpan" id="kobo.304.1">Future flags do not remove the need to refactor existing code on existing changes, but they allow gradual refactoring that can be stretched out </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">over time.</span></span></p>
<h1 id="_idParaDest-239"><a id="_idTextAnchor238"/><span class="koboSpan" id="kobo.306.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.307.1">In this chapter, we discussed different migration strategies for Remix. </span><span class="koboSpan" id="kobo.307.2">You learned strategies to migrate a non-React, React, and React Router application </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">to Remix.</span></span></p>
<p><span class="koboSpan" id="kobo.309.1">For bigger migrations, you can run the new Remix app and the old legacy application side by side in production. </span><span class="koboSpan" id="kobo.309.2">You can build new pages in Remix while incrementally moving features from the old application to Remix. </span><span class="koboSpan" id="kobo.309.3">Using a subdomain for your new Remix app, you can share UI state </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">using cookies.</span></span></p>
<p><span class="koboSpan" id="kobo.311.1">You now understand that React Router and Remix use the same baseline routing implementation. </span><span class="koboSpan" id="kobo.311.2">Thus, migration from React Router applications to Remix is easier, as you can incrementally prepare your React Router app by taking advantage of the shared primitives and conventions. </span><span class="koboSpan" id="kobo.311.3">This allows you to reuse much of the code between a React Router and Remix app without </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">further refactoring.</span></span></p>
<p><span class="koboSpan" id="kobo.313.1">After reading this chapter, you now understand how to use Remix as a BFF to forward and orchestrate requests to downstream services. </span><span class="koboSpan" id="kobo.313.2">You know that Remix can be used independently and as a part of a wider system architecture. </span><span class="koboSpan" id="kobo.313.3">When migrating to Remix, you can focus on migrating your frontend code while forwarding all requests from Remix’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">action</span></strong><span class="koboSpan" id="kobo.315.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">loader</span></strong><span class="koboSpan" id="kobo.317.1"> functions to the existing </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">backend applications.</span></span></p>
<p><span class="koboSpan" id="kobo.319.1">Finally, you learned about Remix’s future flags system. </span><span class="koboSpan" id="kobo.319.2">Remix offers future flags to unlock features of upcoming major versions in the current ones. </span><span class="koboSpan" id="kobo.319.3">This allows gradual upgrades on a per-feature basis and avoids painful migrations that require updating all code </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">at once.</span></span></p>
<p><span class="koboSpan" id="kobo.321.1">Over the last 17 chapters, you studied many concepts to build full stack applications with Remix. </span><span class="koboSpan" id="kobo.321.2">As a React developer, Remix provides a lot of great primitives, conventions, and levers to let you unlock the full potential of the web platform. </span><span class="koboSpan" id="kobo.321.3">Due to Remix’s philosophy of embracing the web platform, you not only practiced how to work with Remix but also learned about many web standards and concepts, such as the web Fetch API, progressive enhancement, HTTP caching headers, and </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">HTTP cookies.</span></span></p>
<p><span class="koboSpan" id="kobo.323.1">Remix is truly a full stack framework for the web, and by following the exercises in this book, you were introduced to many aspects of full stack web development, such as request-response flows, user authentication, session management, data revalidation, and implementing progressive, optimistic, and real-time UIs. </span><span class="koboSpan" id="kobo.323.2">I am excited to see what you will build next. </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">Happy coding!</span></span></p>
<h1 id="_idParaDest-240"><a id="_idTextAnchor239"/><span class="koboSpan" id="kobo.325.1">Further reading</span></h1>
<p><span class="koboSpan" id="kobo.326.1">The Remix documentation includes a guide on how to migrate from React Router to </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">Remix: </span></span><a href="https://remix.run/docs/en/main/guides/migrating-react-router-app"><span class="No-Break"><span class="koboSpan" id="kobo.328.1">https://remix.run/docs/en/main/guides/migrating-react-router-app</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.329.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.330.1">The Remix documentation further includes an article by Pedro Cattori that documents how to migrate from webpack to </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">Remix: </span></span><a href="https://remix.run/blog/migrate-from-webpack"><span class="No-Break"><span class="koboSpan" id="kobo.332.1">https://remix.run/blog/migrate-from-webpack</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.333.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.334.1">Refer to Remix’s release log to stay up to date with Remix’s </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">releases: </span></span><a href="https://github.com/remix-run/remix/releases"><span class="No-Break"><span class="koboSpan" id="kobo.336.1">https://github.com/remix-run/remix/releases</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.337.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.338.1">Sergio Xalambrí wrote an article on how to run Next.js side by side with Remix for an incremental </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">migration: </span></span><a href="https://sergiodxa.com/articles/run-next-and-remix-on-the-same-server"><span class="No-Break"><span class="koboSpan" id="kobo.340.1">https://sergiodxa.com/articles/run-next-and-remix-on-the-same-server</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.341.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.342.1">You can find Remix’s roadmap on GitHub: </span><a href="https://github.com/orgs/remix-run/projects/5"><span class="koboSpan" id="kobo.343.1">https://github.com/orgs/remix-run/projects/5</span></a><span class="koboSpan" id="kobo.344.1">. </span><span class="koboSpan" id="kobo.344.2">You can also find roadmap planning meetings on </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">YouTube: </span></span><a href="https://www.youtube.com/c/Remix-Run/videos"><span class="No-Break"><span class="koboSpan" id="kobo.346.1">https://www.youtube.com/c/Remix-Run/videos</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.347.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.348.1">You can find more information about semantic versioning </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">here: </span></span><a href="https://semver.org/"><span class="No-Break"><span class="koboSpan" id="kobo.350.1">https://semver.org/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.351.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.352.1">Learn more about Remix’s future flag approach in this blog post by Matt </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">Brophy: </span></span><a href="https://remix.run/blog/future-flags"><span class="No-Break"><span class="koboSpan" id="kobo.354.1">https://remix.run/blog/future-flags</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.355.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.356.1">You can read more about Remix as a BFF in the Remix </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">documentation: </span></span><a href="https://remix.run/docs/en/main/guides/bff"><span class="No-Break"><span class="koboSpan" id="kobo.358.1">https://remix.run/docs/en/main/guides/bff</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.359.1">.</span></span></p>
</div>
</body></html>