- en: Chapter 3. Manipulating the DOM
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章。操作 DOM
- en: In the previous chapter, we learned how to use jQuery's selectors to find elements
    that we are looking for in the DOM. In this chapter, we will use this knowledge
    to first find elements and then modify them. We will learn the different methods
    that jQuery provides in order to help make our websites both beautiful and dynamic.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用 jQuery 的选择器来查找 DOM 中我们正在寻找的元素。在本章中，我们将利用这些知识首先找到元素，然后修改它们。我们将学习
    jQuery 提供的不同方法，以帮助我们的网站既美观又动态。
- en: 'jQuery has over three dozen methods that manipulate the DOM in some way, but
    don''t let that number scare you. All of the methods are readily broken down into
    just four different categories: dimensions and positions, classes and styles,
    attributes and properties, and content. Like most things in jQuery, once you dive
    in, you will quickly see the pattern of how the different groups of methods are
    related.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 有三十多个方法以某种方式操纵 DOM，但不要让这个数字吓到你。所有方法都可以轻松分为四个不同的类别：尺寸和位置、类和样式、属性和属性以及内容。就像
    jQuery 中的大多数事物一样，一旦你深入研究，你就会很快看到这些不同方法组之间的模式是如何相关的。
- en: 'Many of the methods operate in one of two modes: getter or setter. In the getter
    mode, the method retrieves or gets values from the element and returns them to
    the caller. In the setter mode, the caller passes values to the method so that
    it can modify the matched set of elements. I think we are now ready to begin with
    dimensions and positions.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 许多方法运行在两种模式之一：获取器或设置器。在获取器模式中，该方法从元素中检索或获取值，并将其返回给调用者。在设置器模式中，调用者向方法传递值，以便它可以修改匹配的元素集。我认为现在我们已经准备好开始处理尺寸和位置了。
- en: Many of the methods have two forms that only differ in the order of the selector
    and the content. One version will be in the more traditional form, which is the
    selector and then the content form, and the other will be in the content and then
    the selector form. The main reason for having the order reversed is chaining.
    When a method returns a jQuery object that contains the content we need for the
    next method in the chain, being able to use the content-first version gives us
    a method we can use.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 许多方法有两种形式，它们只在选择器和内容的顺序上有所不同。一种版本将采用更传统的形式，即选择器然后是内容形式，另一种将采用内容然后是选择器形式。顺序颠倒的主要原因是链式操作。当一个方法返回一个包含我们需要的内容的
    jQuery 对象时，能够使用内容优先版本给我们一个可以使用的方法。
- en: 'This chapter will cover a lot of material. Here are the topics we will delve
    into:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖大量内容。以下是我们将深入探讨的主题：
- en: Dimensions and positions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尺寸和位置
- en: Reading the size of the screen and elements
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取屏幕和元素的大小
- en: Classes and styles
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类和样式
- en: The JSON object
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON 对象
- en: Attributes and properties
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性和属性
- en: Keeping images proportional
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持图片的比例
- en: Removing attributes and properties
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除属性和属性
- en: Dimensions and positions
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尺寸和位置
- en: In web development, we usually tend to not want to deal with the specifics of
    element sizes, but occasionally, such information comes in handy. Before we get
    into the details of reading the size, you need to know a few things. First, only
    the size of the first element in the matched set is returned. Two, reading a size
    kills the jQuery chain, so you can't have any other methods after it. Finally,
    there is more than one way to read the size of an element. The kind of method
    you choose depends on what you want to know. Let's take reading the width as an
    example.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Web 开发中，我们通常倾向于不想处理元素大小的具体细节，但偶尔这样的信息会派上用场。在我们深入了解大小的细节之前，你需要知道一些事情。首先，只返回匹配集中第一个元素的大小。其次，读取大小会终止
    jQuery 链，因此你不能在其后使用任何其他方法。最后，读取元素大小的方法不止一种。你选择的方法种类取决于你想要知道什么。让我们以读取宽度为例。
- en: Examples
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 例子
- en: In the previous chapter, we began with an empty web page and added just enough
    HTML to explain what each method does. In the real world, we seldom get a blank
    canvas to work on. So in this chapter, we are going to use a more complete looking
    web page instead, and it will be based on the very popular Bootstrap Jumbotron
    template. Bootstrap is one of the most popular CSS frameworks around, and using
    it in our examples will help you get familiar with modern website designs since
    it is not too common to write all of your own CSS these days. We aren't going
    to talk much about Bootstrap or how it works, but there are lots of good books
    on it at the Packt Publishing website, including *Learning Bootstrap*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们从一个空白的网页开始，并添加了足够的HTML来解释每个方法的作用。在现实世界中，我们很少有一块空白的画布可以使用。所以在本章中，我们将使用一个看起来更完整的网页，它将基于非常受欢迎的Bootstrap
    Jumbotron模板。Bootstrap是最受欢迎的CSS框架之一，在我们的示例中使用它将帮助你熟悉现代网站设计，因为如今很少有人编写自己的CSS。我们不打算多谈Bootstrap或它的工作原理，但在Packt
    Publishing网站上有很多关于它的好书，包括*Learning Bootstrap*。
- en: '![Examples](img/00002.jpeg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![示例](img/00002.jpeg)'
- en: Developer tools
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发者工具
- en: Most modern browsers have a built-in set of developer tools. How you activate
    the tools varies with the browser. In Internet Explorer, pressing *F12* activates
    the developer tools. In Chrome and Firefox, *Ctrl + Shift + I* does the job. We
    will be using the developer tools in order to see the console log output. By writing
    information to the log instead of displaying it using the `alert()` method, we
    won't break the flow of the site or annoy you with popups that you must respond
    to before being allowed to continue.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代浏览器都有一组内置的开发者工具。如何激活这些工具因浏览器而异。在Internet Explorer中，按下*F12*会激活开发者工具。在Chrome和Firefox中，*Ctrl
    + Shift + I*可以完成这项工作。我们将使用开发者工具来查看控制台日志输出。通过将信息写入日志而不是使用`alert()`方法显示它，我们不会中断网站的流程，也不会在你在被允许继续之前被弹出窗口打扰。
- en: 'The console object of most modern browsers will have quite a few methods attached
    to it, but we are only concerned about one method, `log()`. We will use the `log()`
    method in its simplest form: to simply output strings. My hope is that the example
    code will run without any issue on any browser you run it on.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代浏览器的控制台对象将附有许多方法，但我们只关心一个方法，即`log()`。我们将以最简单的形式使用`log()`方法：简单地输出字符串。希望示例代码在你运行它的任何浏览器上都能顺利运行。
- en: Reading the size of the screen and elements
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取屏幕和元素的大小
- en: 'There are three methods to read the width: `.width()`, .`innerWidth()`, and
    `.outerWidth()`. The first method, `.width()`, returns only the width of the element.
    The next method, `.innerWidth()`, returns the width of the element and its border
    and padding. The final method, `.outerWidth()`, returns the width of the element
    plus the border and padding, and if you pass true, it will also include the width
    of its margins.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 读取宽度有三种方法：`.width()`、`.innerWidth()`和`.outerWidth()`。第一个方法`.width()`只返回元素的宽度。接下来的方法`.innerWidth()`返回元素及其边框和填充的宽度。最后一种方法`.outerWidth()`返回元素加上边框和填充的宽度，并且如果你传递true，它还会包括其外边距的宽度。
- en: For each method that deals with the elements' width, there is a matching method
    for the element's height. The methods are `.height()`, `.innerHeight()`, and `outerHeight()`.
    Each of these behaves similar to its width counterpart.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于处理元素高度的每个方法，都有一个对应的高度方法。这些方法是`.height()`、`.innerHeight()`和`outerHeight()`。每个与其宽度对应方法类似。
- en: 'In order to determine the size of the display, you call the `.width()` and
    `.height()` methods of the window:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定显示的大小，你可以调用窗口的`.width()`和`.height()`方法：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code retrieves a jQuery object pointing to the window element.
    The first line of code gets the width of the window and the second line gets its
    height.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码检索了一个指向窗口元素的jQuery对象。第一行代码获取了窗口的宽度，第二行获取了它的高度。
- en: Try not to get the window and the document confused. At times, they can give
    the same results, but keep in mind that the document can exceed the size of the
    window. When it does, scroll bars will appear. They are not equivalent.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量不要混淆窗口和文档。有时它们可能给出相同的结果，但要记住文档可以超出窗口的大小。当它超出时，将出现滚动条。它们不是等价的。
- en: Getting the dimensions of a screen element is nice, but sometimes, you need
    to know its position too. There is only one method that returns the position,
    and it is named `.position()`. Like the other value methods, it breaks the chain
    since it returns an object that contains the top and left values of the element's
    position relative to its parent.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 获取屏幕元素的尺寸是很好的，但有时候，你也需要知道它的位置。只有一个方法返回位置，它被命名为`.position()`。与其他值方法一样，它会打破链条，因为它返回一个对象，该对象包含相对于其父元素的位置的顶部和左侧值。
- en: 'There is a companion method to `.position()` called `.offset()`. The difference
    between them is important. The `.offset()`method returns the element''s position
    relative to the document and not to its parent. Using the `.offset()` method allows
    us, for example, to compare two elements that have different parents, which is
    something that would be almost meaningless with the `.position()` method. We won''t
    normally see the difference between the two methods unless we use either absolute
    or relative positioning instead of the browser default of static positioning:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 与`.position()`相对应的一个方法是`.offset()`。它们之间的区别很重要。`.offset()`方法返回相对于文档而不是其父元素的元素位置。使用`.offset()`方法允许我们比较具有不同父元素的两个元素，这是使用`.position()`方法几乎没有意义的事情。除非我们使用绝对或相对定位而不是浏览器默认的静态定位，否则我们通常看不到这两种方法之间的区别：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The final two methods in this group are `.scrollLeft()` and `.scrollTop()`.
    These two methods are different from the rest since they are both getters and
    setters. If passed an argument, `.scrollLeft()` uses it to set the horizontal
    position of the scroll bar. The `.scrollTop()` method does something similar,
    setting the vertical position of the scroll bar. Both methods will set the position
    of every element in the matched set.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 该组中的最后两个方法是`.scrollLeft()`和`.scrollTop()`。这两种方法与其他方法不同，因为它们既是获取器又是设置器。如果传递了参数，`.scrollLeft()`会使用它来设置滚动条的水平位置。`.scrollTop()`方法执行类似的操作，设置滚动条的垂直位置。这两种方法将设置匹配集中每个元素的位置。
- en: Classes and styles
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类和样式
- en: 'The first method in the classes and styles group is `.css()`. This method is
    very powerful and shows why jQuery is a required and useful library even in the
    age of HTML5 browsers. The `.css()` method operates as both a getter and a setter.
    As a getter, it returns the computed style property or properties. It takes as
    arguments either a single string that is the name of a CSS property you would
    like to retrieve or an array of strings representing all of the CSS properties:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 类和样式组中的第一个方法是`.css()`。这个方法非常强大，展示了为什么jQuery是HTML5浏览器时代的必需和有用的库。`.css()`方法既是获取器又是设置器。作为获取器，它返回计算出的样式属性或属性。它接受一个字符串作为参数，该字符串是要检索的CSS属性的名称，或者是表示所有CSS属性的字符串数组：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The results of the preceding code are as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的结果如下：
- en: '**Background Color = "rgb(51, 122, 183)"**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**背景颜色 = "rgb(51, 122, 183)"**'
- en: '**Colors = {"background-color":"rgb(51, 122, 183)","color":"rgb(255, 255, 255)"}**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**颜色 = {"background-color":"rgb(51, 122, 183)","color":"rgb(255, 255, 255)"}**'
- en: The JSON object
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON对象
- en: Most modern browsers include the JSON object. JSON, like XML, is a data interchange
    format. It is language-independent, lightweight, and easy to understand. The JSON
    object added to browsers has two important methods. The first method, `.parse()`,
    takes a string representing a JSON object and converts it into a JavaScript object.
    The second function, `.stringify()`, takes a JavaScript object and converts it
    into a JSON string. These methods are intended to be used to serialize and deserialize
    objects. But we can also use the methods in our example code. The `.stringify()`
    method can render JavaScript objects as strings, and we can send these strings
    to the console.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代浏览器都包含JSON对象。JSON，就像XML一样，是一种数据交换格式。它是与语言无关的，轻量级的，易于理解的。添加到浏览器的JSON对象具有两个重要方法。第一个方法`.parse()`接受一个表示JSON对象的字符串，并将其转换为JavaScript对象。第二个函数`.stringify()`接受一个JavaScript对象，并将其转换为JSON字符串。这些方法旨在用于序列化和反序列化对象。但我们也可以在我们的示例代码中使用这些方法。`.stringify()`方法可以将JavaScript对象呈现为字符串，我们可以将这些字符串发送到控制台。
- en: One of the things that make the `.css()` method powerful is that it understands
    which properties you are referencing in a variety of different formats. Take,
    for example, the CSS property, `margin-left`. The DOM refers to it as `marginLeft`;
    jQuery understands both terms as the same thing. Likewise, it understands the
    browser method used to actually access properties with which most browsers call
    `getComputedStyle()`, but different versions of Internet Explorer call either
    `currentStyle()` or `runtimeStyle()`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`.css()`方法的强大之处之一在于它可以理解多种不同格式中你引用的属性。举个例子，CSS属性`margin-left`，DOM将其称为`marginLeft`；jQuery理解这两个术语是相同的。同样，它理解用于实际访问属性的浏览器方法，大多数浏览器称之为`getComputedStyle()`，但不同版本的Internet
    Explorer称之为`currentStyle()`或者`runtimeStyle()`。
- en: 'The setter mode of the `.css()` method has several ways to set properties.
    The first and easiest way is to simply pass in a property name and its new value
    as arguments:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`.css()`方法的设置模式有几种设置属性的方式。最简单的方法是简单地将属性名和它的新值作为参数传递进去。'
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can also remove a property in the same fashion by setting the value to
    an empty string. The next way in which we can change properties is to pass them
    in as key-value pairs in an object:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过将值设置为空字符串来以相同的方式移除属性。我们可以改变属性的另一种方式是将它们作为键值对传递给对象：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The final way in which we can change properties is by passing in a property
    and a function. The return value of the function is used by jQuery to set the
    property. If the function either doesn''t return anything or returns "undefined,"
    then no change is made to the property''s value:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们改变属性的最后一种方法是传递一个属性和一个函数。函数的返回值由jQuery用于设置属性。如果函数既不返回任何内容，也不返回"undefined"，那么属性的值就不会发生变化：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first method of this group is `.addClass()`, which adds a class to an element.
    If you assigned a class using the DOM methods, you will have to make sure that
    the class isn't being duplicated, but with `.addClass()`, if the class is already
    assigned to the element, it is not assigned twice. You aren't limited to assigning
    only one class at a time. You can add as many as you'd like just so long as you
    make sure that you separate each one with a space.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组的第一种方法是`.addClass()`，它将一个类添加到一个元素中。如果你使用DOM方法分配了一个类，你必须确保该类不会被重复分配，但是使用`.addClass()`，如果类已经分配给元素，它不会被重复分配。你不只是限于一次只分配一个类。你可以添加任意多个，只要确保每个类之间用空格分隔。
- en: 'Like many other jQuery methods, `.addClass()` too has a really cool extra feature:
    it can accept a function as well. What''s so cool about this? Well, imagine that
    you have a set of buttons and you would like to give each one a different color
    class depending on its place in the set. You can easily write a function to handle
    this scenario. jQuery passes two parameters to the function. The first is the
    index of the element in the matched set. The second parameter is a string that
    has all of the currently applied classes, each separated by a space. Here''s an
    example:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 像许多其他的jQuery方法一样，`.addClass()`也有一个非常酷的额外功能：它也可以接受一个函数。这个有什么酷的呢？好吧，想象一下，你有一组按钮，你想根据它们在集合中的位置给每个按钮分配一个不同的颜色类。你可以很容易地编写一个函数来处理这种情况。jQuery向函数传递两个参数。第一个是匹配集合中元素的索引。第二个参数是一个字符串，其中包含所有当前应用的类，每个类由一个空格分隔。下面是一个例子：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Eventually, we are going to need to delete a class, which is why we use `.removeClass()`.
    Depending on the parameters you pass to it, its behavior changes. If you pass
    a single class name to it, it removes that class. If you pass multiple class names
    separated by spaces, it removes those classes. And if you pass no arguments, it
    removes all of the currently assigned classes. If a passed class name doesn't
    exist, there is no error.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们需要删除一个类，这就是为什么我们使用`.removeClass()`。取决于你传递给它的参数，它的行为会发生变化。如果你传递一个类名给它，它将删除该类。如果你传递多个由空格分隔的类名，它将删除这些类。如果不传递参数，它将删除所有当前分配的类。如果传递的类名不存在，就不会发生错误。
- en: Like `.addClass()`, `.removeClass()` can also accept a function. jQuery passes
    an index to your function and all of the currently assigned classes as a string.
    To remove classes, your function should return a string containing the names of
    all of the classes you would like to remove.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 像`.addClass()`一样，`.removeClass()`也可以接受一个函数。jQuery向函数传递一个索引和当前分配的所有类的字符串。要删除类，你的函数应该返回一个包含你想要删除的所有类名的字符串。
- en: 'The `.hasClass()`method returns `true` if any element in the matched set has
    the passed class. It returns false if none of them have the passed class. Keep
    in mind that if you pass it a matched set that has 100 `<div>` and only one of
    them has the passed class name, the method returns true:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`.hasClass()`方法返回`true`，如果匹配集中的任何元素具有传递的类，则返回`true`。如果没有任何元素具有传递的类，则返回false。请记住，如果你传递给它一个具有100个`<div>`的匹配集，只有一个具有传递的类名，该方法将返回true：'
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `.toggleClass()`method is a time-saving convenience feature. Often, we will
    find ourselves simply adding a class if it doesn't exist and removing it if it
    does. This is exactly the scenario that `.toggleClass()` was created to solve.
    You pass it one or more classes to toggle on or off.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`.toggleClass()`方法是一个节省时间的便利功能。通常，我们会发现自己只是添加一个类（如果不存在）并删除它（如果存在）。这正是`.toggleClass()`被创建解决的场景。你传递给它一个或多个要切换打开或关闭的类。'
- en: 'You can also pass `.toggleClass()` a second parameter, a boolean to indicate
    whether the class should be added or removed:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以传递`.toggleClass()`的第二个参数，一个布尔值，表示是否应该添加或删除类：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The advantage this has over simply calling `.removeClass()` is that you can
    pass in the boolean as a variable and decide whether you want to add or remove
    the class at runtime.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 它比简单调用`.removeClass()`的优势是，你可以将布尔值作为变量传递，并在运行时决定是否添加或删除类。
- en: Like its siblings, you can also pass a function to `.toggleClass()`. The function
    is passed an index that is the object's position in the matched set, the current
    class names, and the current state. It returns true to add the class and false
    to remove it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 像其兄弟一样，你也可以将一个函数传递给`.toggleClass()`。函数传递一个索引，该索引是匹配集中对象的位置，当前类名和当前状态。它返回true以添加类，false以删除类。
- en: Behavior classes
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行为类
- en: Normally, you add a class to an element in order to affect its appearance. Sometimes,
    you may want to add a class in order to affect how JavaScript processes the element.
    Why would you want to use a class for a behavior? This is because classes are
    booleans, and an element either has a given class or it doesn't. Properties, on
    the other hand, are key-value pairs, and you need to know whether property exists
    and what value it holds. This generally makes dealing with classes easier and,
    in some cases, syntactically cleaner than dealing with the equivalent property.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你添加一个类来影响其外观。有时，你可能想要添加一个类以影响JavaScript如何处理元素。为什么要为行为使用类？这是因为类是布尔值，一个元素要么具有给定的类，要么没有。另一方面，属性是键值对，你需要知道属性是否存在以及它持有什么值。这通常使处理类比处理等价的属性更容易，在某些情况下，语法上更清晰。
- en: Attributes and properties
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性和属性
- en: 'Before we get to the methods that deal with attributes and properties, we must
    first discuss a bigger issue: what''s the difference between an attribute and
    a property? They are different, but how?'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论处理属性和属性的方法之前，我们必须首先讨论一个更大的问题：属性和属性之间有什么区别？它们是不同的，但是怎么样？
- en: 'When the DOM is constructed from the HTML attributes, the key-value pairs that
    are included in the markup are built. Most of these attributes are translated
    into properties, which are placed onto the DOM element node. The important thing
    to understand is that once the element node is constructed, properties are used
    to keep track of the state of the node, not the attributes. Attributes are not
    updated as jQuery; if they are, JavaScript changes the DOM. They represent the
    state of the DOM when it was first loaded, and this is the problem. Think about
    a checkbox:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当DOM从HTML属性构建时，构建包含在标记中的键值对。这些属性大多被转换为属性，并放置到DOM元素节点上。要理解的重要一点是，一旦构建了元素节点，属性将用于跟踪节点的状态，而不是属性。如果使用jQuery更新属性，则不会更新属性；如果是，JavaScript会更改DOM。它们表示DOM在首次加载时的状态，这是个问题。想想复选框：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When the DOM parses this checkbox, it creates a checked property on the node
    for this element. It also creates a `defaultChecked` property in accordance with
    the rules laid out in the W3C specification. The difference between attributes
    and properties becomes clear. No matter how many times the user clicks on the
    checkbox, .`attr()` will always return `checked` because that was its state when
    the HTML was parsed. On the other hand, `.prop()` will alternate from "true" to
    "false" depending on the current actual state.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当 DOM 解析此复选框时，它会为此元素的节点创建一个已检查的属性。它还根据 W3C 规范中制定的规则创建一个 `defaultChecked` 属性。属性和属性之间的区别变得清晰起来。无论用户点击多少次复选框，`.attr()`
    总是返回 `checked`，因为这是它在解析 HTML 时的状态。另一方面，`.prop()` 将根据当前实际状态从 "true" 切换到 "false"。
- en: The .`attr()` method has been in jQuery since the beginning. It was originally
    used to both read and set the values of attributes and properties. This was a
    mistake; attributes and properties are different, but understanding the difference
    is difficult. In jQuery 1.6, the `.prop()` method was introduced and the scope
    of the `.attr()` method was limited to just attributes. This broke a lot of websites
    that had been using the `.attr()` method to set properties. This caused quite
    a furor among the jQuery community, which has since subsided. In general, if you
    want the current value of a property, use `.prop()` and not `.attr()`. Now that
    we understand the difference between attributes and properties, let's learn how
    to use the methods.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`.attr()` 方法从 jQuery 的一开始就存在。最初它被用来读取和设置属性和属性的值。这是一个错误；属性和属性是不同的，但理解这种区别是困难的。在
    jQuery 1.6 中，引入了 `.prop()` 方法，并且将 `.attr()` 方法的范围限制在只能是属性。这打破了很多使用 `.attr()` 方法来设置属性的网站。这在
    jQuery 社区引起了相当大的骚动，但现在已经平息。一般来说，如果你想要属性的当前值，请使用 `.prop()` 而不是 `.attr()`。现在我们理解了属性和属性之间的区别，让我们学习如何使用这些方法。'
- en: 'The `.attr()`method acts as both a getter and a setter of attributes. When
    used in the getter form, it will get the attribute of the first element in the
    matched set. It accepts only one parameter: the name of the attribute to be retrieved.
    When used in the setter form, it will set one or more attributes on all of the
    members of the matched set. You can call it in a few different ways. The first
    is with an attribute name in a string and its set value. The second is by passing
    it an object containing all of the attribute value pairs you wish to set. The
    final is with an attribute name and a function. The function will be passed an
    index and the old value of the attribute. It returns the desired set value. Here
    are some examples:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`.attr()` 方法既充当属性的获取器，也充当属性的设置器。当以获取器形式使用时，它将获取匹配集中第一个元素的属性。它只接受一个参数：要检索的属性的名称。当以设置器形式使用时，它将在匹配集中的所有成员上设置一个或多个属性。你可以以几种不同的方式调用它。第一种是用字符串中的属性名称和其设置值。第二种是通过传递一个包含你希望设置的所有属性值对的对象来调用它。最后一种是用属性名称和一个函数。函数将传递一个索引和属性的旧值。它返回所需的设置值。以下是一些示例：'
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `.prop()`method is called in both its getter and setter forms in the same
    way as the `.attr()` method. In general, when manipulating properties of an element,
    this is the preferred method.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`.prop()` 方法在其获取器和设置器形式中都以与 `.attr()` 方法相同的方式调用。一般来说，当操作元素的属性时，这是首选方法。'
- en: Keeping images proportional
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持图像比例
- en: Using the `.attr()` method, you can adjust the size of images by tweaking the
    height and width attributes. If you wish to keep the image size proportional without
    having to calculate the correct height for the width or vice versa, there is an
    easy cheat. Rather than changing both the width and height, remove the height
    attribute and only modify the width. The browser will then automatically adjust
    the height to proportionally match the width.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `.attr()` 方法，你可以通过调整高度和宽度属性来调整图像的大小。如果你希望保持图像大小的比例而不必计算正确的宽度对应的高度或反之亦然，有一个简单的方法。而不是同时更改宽度和高度，删除高度属性并只修改宽度。浏览器将自动调整高度以与宽度成比例。
- en: Removing attributes and properties
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除属性和属性
- en: In order to remove an attribute from an element, we use `.removeAttr()`. You
    call it with either a single attribute name or with the names of several attributes
    separated by spaces. It has the extra benefit of not leaking memory when removing
    the attribute.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从元素中删除一个属性，我们使用 `.removeAttr()`。你可以用单个属性名称或用以空格分隔的多个属性名称来调用它。它有一个额外的好处，即在删除属性时不会泄露内存。
- en: The `.removeProp()`method closely mirrors `.removeAttr()`. Keep in mind that
    you should only remove custom properties from an element, not native ones. If
    you remove native properties, such as checked, disabled, and so on, it can't be
    added back to the element. Instead of removing the property, you may want to set
    it to false using the `.prop()` method.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`.removeProp()`方法与`.removeAttr()`密切相关。请记住，您应该只从元素中删除自定义属性，而不是原生属性。如果您删除原生属性，比如checked、disabled等，它将无法添加回元素。您可能希望使用`.prop()`方法将属性设置为false，而不是删除属性。'
- en: 'The `.val()` method is mainly used to retrieve values from form elements. It
    gets the value of the first element in a matched set from the input, select, and
    `textarea method` elements:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`.val()` 方法主要用于从表单元素中检索值。它从匹配集的第一个元素中获取值，该集包括输入、选择和`textarea`方法元素：'
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It is easy to retrieve values from an input tag, as shown in the preceding code.
    The `.val()` method extracts the current string value of the element.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 从输入标记中检索值非常容易，就像前面的代码所示。`.val()`方法提取元素的当前字符串值。
- en: 'The type of data that''s returned varies depending on the type of element it
    retrieves the data from. If it gets data from an input tag, the return type is
    a string. If the tag is selected with multiple attributes, then the return type
    is null if no items are selected. If one or more items are selected, then the
    return type is an array of strings, and each item in the array is the value of
    a selected option:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的数据类型取决于它从中检索数据的元素类型。如果它从输入标记获取数据，则返回类型为字符串。如果使用多个属性选择标记，则如果未选择任何项目，则返回类型为null。如果选择了一个或多个项目，则返回类型为字符串数组，数组中的每个项都是所选选项的值。
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When used in its setter form, you can pass either a single string value, an
    array of strings, or a function to `.val()`. Passing a single string is the most
    typical use case. It does exactly what you''d expect: it sets the element''s value:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在其设置器形式中使用时，您可以将单个字符串值、字符串数组或函数传递给`.val()`。传递单个字符串是最典型的用例。它正是您所期望的：它设置元素的值：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When you pass in an array of strings to a select element with the multiple
    attribute set, it first clears any previously selected options, and then it selects
    all of the options whose values match those in the passed array:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将字符串数组传递给设置了多个属性的选择元素时，它首先会清除任何以前选择的选项，然后选择所有值与传递的数组中的值相匹配的选项：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Like the other two methods, `.attr()` and `.prop()`, you can also pass in a
    function. jQuery will send two parameters to the function: an integer representing
    the elements index in the matched set and a value representing the element''s
    current value. Your function should return a string that represents the element''s
    new value.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 像另外两种方法`.attr()`和`.prop()`一样，您也可以传递一个函数。jQuery将向函数发送两个参数：一个整数，表示匹配集中元素的索引，和一个表示元素当前值的值。您的函数应返回一个表示元素新值的字符串。
- en: 'To retrieve the HTML contents of an element, we use the `.html()` method. It
    returns the markup as a string:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索元素的HTML内容，我们使用`.html()`方法。它将标记作为字符串返回：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When `.html()` is passed a string, it sets all of the elements of the matched
    set to the new markup. You can also pass a function to `.html()`. The function
    is passed to these parameters: an index and a string to hold the old HTML. You
    return a string from the function that holds the new HTML:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当`.html()`传递一个字符串时，它会将匹配集的所有元素设置为新的标记。您也可以将一个函数传递给`.html()`。该函数传递给这两个参数：索引和保存旧HTML的字符串。您从函数中返回一个包含新HTML的字符串：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `.text()` method retrieves the text content of all of the elements in the
    matched set. It is important to note that this method operates very differently
    from other methods in this regard. Normally, getters only get the data from the
    first element in the set. This method will concatenate the text from all of the
    elements, which can be a surprising result if you weren''t expecting it:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`.text()`方法检索匹配集中所有元素的文本内容。需要注意的是，就这个方面，此方法的操作方式与其他方法非常不同。通常，getter仅从集合中的第一个元素获取数据。此方法将连接所有元素的文本，如果您没有预期到这一点，可能会产生令人惊讶的结果：'
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It is important to note that the `.text()` method is for text, not HTML. If
    you try to send the HTML markup to it, it will not be rendered. As an example,
    let''s try to send the same markup that we sent successfully to the `.html()`
    method:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，`.text()`方法用于文本，而不是HTML。如果您尝试将HTML标记发送给它，它将不会被呈现。例如，让我们尝试向`.html()`方法成功发送的相同标记：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we would like to add more HTML instead of replacing it, we can use the `.append()`
    and `.appendTo()` methods. They will both add the passed content to the end of
    the each element in the matched set. The difference between the two is readability,
    not functionality. With `.append()`, the selector comes first; then comes the
    new content. The `.appendTo()` method reverses this so that the new content comes
    before the selector:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要添加更多的 HTML 而不是替换它，我们可以使用`.append()`和`.appendTo()`方法。它们都会将传递的内容添加到匹配集中每个元素的末尾。两者之间的区别在于可读性，而不是功能性。使用`.append()`时，选择器先出现；然后是新内容。`.appendTo()`方法将此反转，使得新内容出现在选择器之前：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `.prepend()` and `.prependTo()`methods are just like `.append()` and `.appendTo()`,
    except that the content is placed at the beginning of each element instead of
    at the end:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`.prepend()`和`.prependTo()`方法与`.append()`和`.appendTo()`类似，只是内容放在每个元素的开头而不是结尾：'
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The previous methods make the new content a child of the parent. The next few
    methods make the new content a sibling of the parent. The `.after()` and `.insertAfter()`
    methods add the new content as the sibling after the parent. Like `.append()`
    and `.appendTo()`, the only difference between the two is the order of the content
    and the selector:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法使新内容成为父级的子级。接下来的几种方法使新内容成为父级的同级。`.after()`和`.insertAfter()`方法将新内容添加为父级后的同级。与`.append()`和`.appendTo()`一样，两者之间的唯一区别是内容和选择器的顺序：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `.before()` and `.insertBefore()` methods add the new content as the sibling
    before the parent element. Again, the only difference between them is the order
    of the content and the selector:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`.before()`和`.insertBefore()`方法将新内容添加为父元素之前的同级。同样，它们之间的唯一区别是内容和选择器的顺序：'
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `.wrap()` method allows you to surround each member of a matched set with
    a new element:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`.wrap()`方法允许您用新元素包围匹配集中的每个成员：'
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This method should not be confused with the `.wrapInner()`method. The difference
    between the two is that `.wrap()` takes each member of the matched set and wraps
    it with a new element. However, `.wrapInner()` takes each of the children of the
    matched set and wraps them with the new content. The difference between these
    two methods is extremely clear in the example code. The `.wrap()` method surrounds
    each of the buttons, `<a>` tags with `role=button`, with a dotted border. The
    `.wrapInner()` method on the other hand, surrounds the text of the buttons with
    dotted borders:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法不应与`.wrapInner()`方法混淆。两者之间的区别在于`.wrap()`将匹配集的每个成员用新元素包围起来。然而，`.wrapInner()`将匹配集的每个子元素用新内容包围起来。这两种方法的区别在示例代码中非常清晰。`.wrap()`方法用点线框包围每个按钮`<a>`标签。而`.wrapInner()`方法则将按钮的文本用点线框包围起来：
- en: '[PRE25]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `.wrapAll()` method surrounds all of the elements in the matched set with
    a new HTML element. Be careful with this method; it can radically change your
    web page. If the members of the set are widely separated, it can have a big and
    perhaps adverse effect. You definitely want to have the narrowest possible selector
    when using this method:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`.wrapAll()`方法会用新的 HTML 元素包围匹配集中的所有元素。要小心使用此方法；它可能会彻底改变您的网页。如果集合的成员相距甚远，可能会产生很大甚至负面的影响。在使用此方法时，一定要选择最狭窄的选择器：'
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The last member of this group of methods is `.unwrap()`. It removes the parents
    of a matched set. Essentially, it is the inverse of `.wrap()`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此组方法的最后一个成员是`.unwrap()`。它移除了匹配集的父元素。本质上，它是`.wrap()`的反向操作：
- en: '[PRE27]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Keeping with the theme of removing the markup, we have these methods: `.remove()`,
    `.empty()`, and `.detatch()`. The first of these methods, `.remove()`, deletes
    the matched set of elements from the DOM. The elements and all of their children
    are removed:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 保持删除标记的主题，我们有这些方法：`.remove()`、`.empty()`和`.detatch()`。这些方法中的第一个，`.remove()`，从
    DOM 中删除匹配的元素集。元素及其所有子元素都将被删除：
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The very closely related `.empty()` method also removes content from the DOM.
    The difference between the two is that `.empty()` deletes the children of the
    matched set, while `.remove()` deletes the matched elements themselves:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 与之密切相关的`.empty()`方法也会从 DOM 中删除内容。两者之间的区别在于`.empty()`删除匹配集的子元素，而`.remove()`删除匹配的元素本身：
- en: '[PRE29]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The final method of the group, `.detached()`, behaves like the `.remove()`method
    with one difference: the removed content is returned to the caller as a set of
    jQuery objects. If you ever need to move the markup from one part of the web page
    to another, this is your method. Don''t forget that you can use chaining on this
    method:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个方法`.detached()`，与`.remove()`方法的行为类似，只有一个区别：被移除的内容以一组 jQuery 对象的形式返回给调用者。如果你需要将网页中的标记从一个地方移动到另一个地方，这就是你的方法。不要忘记你可以在这个方法上使用链式调用：
- en: '[PRE30]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `.replaceAll()` and the closely related `.replaceWith()`methods each replace
    the matched set with the passed content. The only difference between the two is
    the order of the selector and the content. In the `.replaceWith()` method, the
    selector comes first; then comes the new content. In the `.replaceAll()` method,
    the new content comes first:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`.replaceAll()` 和与之密切相关的`.replaceWith()`方法分别用传递的内容替换匹配的集合。两者之间唯一的区别是选择器和内容的顺序。在`.replaceWith()`方法中，选择器首先出现；然后是新内容。在`.replaceAll()`方法中，新内容首先出现：'
- en: '[PRE31]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `.clone()` method makes a copy of the matched set of elements. It copies
    each element, and all of their children then return them to the caller as a jQuery
    object:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`.clone()` 方法复制匹配元素集合的副本。它复制每个元素及其所有子元素，然后将它们作为 jQuery 对象返回给调用者：'
- en: '[PRE32]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Summary
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter has been a pretty arduous journey, but hopefully, you've seen that
    jQuery's DOM manipulation methods are logically thought out. We learned how to
    add content to the page before and after the existing elements. We also learned
    how to remove content from the page and even how to move content from one location
    to another.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章节是一个相当艰难的旅程，但希望你已经看到了 jQuery 的 DOM 操作方法是经过合理思考的。我们学习了如何在现有元素之前和之后添加内容到页面。我们还学习了如何从页面中删除内容，甚至如何将内容从一个位置移动到另一个位置。
- en: We also learned that many jQuery methods have two different forms in order to
    provide us with a way to get the page content with one method and set it with
    another. There were also a couple of simple but handy bits of information on keeping
    our images proportional using the JSON object and determining the size of elements.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习到许多 jQuery 方法有两种不同的形式，以便为我们提供一种方法来使用一个方法获取页面内容并使用另一个方法设置页面内容。还有一些简单但方便的信息，可以使用
    JSON 对象保持图像的比例，并确定元素的大小。
- en: Even though we've learned a lot, our site is still static; after it executes
    its JavaScript, it doesn't do anything else. In the next chapter, we will change
    that. We will learn how to use events to allow our site to be interactive.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们学到了很多，我们的网站仍然是静态的；在执行完 JavaScript 后，它不会做任何其他事情。在下一章中，我们将改变这种情况。我们将学习如何使用事件使我们的网站可以交互。
