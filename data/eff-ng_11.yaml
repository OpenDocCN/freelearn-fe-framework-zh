- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Testing Angular Applications
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 Angular 应用程序
- en: Writing automated tests for your applications is just as important as writing
    the application code. Many developers don’t like to write tests or skip them altogether
    because they feel it’s too time-consuming, but as your applications and workspace
    grow, having automated tests becomes ever more critical. When working on an extensive
    application, the chances are significant that your changes will impact many things
    throughout the application. Small changes can affect many things, which becomes
    even more apparent when you’re making changes in a library used in many applications.
    You’ll often find yourself in a scenario where you make changes and don’t even
    know every application surface your changes will impact. Because you don’t want
    to break features, you don’t want to work on or manually test the entire workspace
    each time you make a change; you need automated tests that can test all affected
    code for you. Automated tests will help you look at your code differently; they
    can help you write better, more sturdy code. Automated tests will also catch bugs
    at an early stage and should give you the confidence to safely release code changes
    to production once all tests have successfully passed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为您的应用程序编写自动化测试与编写应用程序代码一样重要。许多开发者不喜欢编写测试或者完全跳过它们，因为他们觉得这太耗时了，但随着您的应用程序和工作空间的增长，拥有自动化测试变得越来越关键。当您在一个庞大的应用程序上工作时，您的更改可能会影响整个应用程序中的许多方面。小的更改可能会影响许多事物，当您在一个被许多应用程序使用的库中进行更改时，这一点尤为明显。您经常会发现自己处于这样的场景中：做出更改，甚至不知道您的更改会影响哪些应用程序的表面。因为您不想破坏功能，所以您不想每次更改时都手动处理或手动测试整个工作空间；您需要能够为您测试所有受影响代码的自动化测试。自动化测试将帮助您以不同的方式看待您的代码；它们可以帮助您编写更好、更坚固的代码。自动化测试还会在早期阶段捕捉到错误，并且应该让您有信心在所有测试成功通过后安全地将代码更改发布到生产环境。
- en: This chapter will dive into different types of automated tests and their purpose
    within your Angular applications. Next, you will dive deeper into the topic of
    unit testing and get some hands-on experience by writing unit tests for our Nx
    monorepo using Jest. Lastly, you will learn more about end-to-end testing and
    gain some experience writing end-to-end tests using Cypress. By the end of this
    chapter, you will understand why you need automated tests and how to write them
    for your Angular applications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将深入探讨不同类型的自动化测试以及它们在您的 Angular 应用程序中的目的。接下来，您将更深入地探讨单元测试的主题，并通过为我们的 Nx monorepo
    编写单元测试来获得一些实践经验。最后，您将了解更多关于端到端测试的知识，并获得一些使用 Cypress 编写端到端测试的经验。到本章结束时，您将了解为什么您需要自动化测试以及如何为您的
    Angular 应用程序编写它们。
- en: 'This chapter will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Different types of application testing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同类型的应用程序测试
- en: Unit testing of Angular applications using Jest
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Jest 对 Angular 应用程序进行单元测试
- en: End-to-end testing of Angular applications using Cypress
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Cypress 对 Angular 应用程序进行端到端测试
- en: Different types of application testing
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同类型的应用程序测试
- en: In a world where software plays an increasingly important role and the applications
    we build are growing more complex, automated testing is becoming more critical.
    Companies are constantly looking to improve their applications to give users a
    better experience. To achieve this, many companies aim for continuous delivery
    of their software, meaning their updates can be automatically released to production
    at any given time. To ensure you can safely release updates without breaking things
    in production, you need automated tests that can run in your build pipelines to
    automatically test your software before releasing changes to your testing, acceptance,
    and production environments.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件在日益重要的世界中扮演越来越重要角色，而我们构建的应用程序变得越来越复杂的情况下，自动化测试正变得越来越关键。公司不断寻求改进他们的应用程序，以给用户提供更好的体验。为了实现这一点，许多公司追求持续交付他们的软件，这意味着他们的更新可以在任何给定时间自动发布到生产环境。为了确保您可以在不破坏生产环境中的事物的情况下安全地发布更新，您需要能够在您的构建管道中运行的自动化测试，在将更改发布到您的测试、验收和生产环境之前自动测试您的软件。
- en: As applications become more complex, manually testing all changes becomes too
    time-consuming, and the chances of not testing something affected by your code
    changes increase significantly. Manual testing is also much slower, repetitive,
    and boring. Tasks that are time-consuming, tedious, and repetitive tend to get
    skipped and lead to mistakes. All that manual labor is also a considerable expense
    for the business, so having a sound automated testing system in place is a necessity.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序变得更加复杂，手动测试所有更改变得过于耗时，并且由于您的代码更改而未测试到的风险显著增加。手动测试也慢得多，重复且无聊。耗时、繁琐和重复的任务往往会被跳过，导致错误。所有这些人工劳动对于企业来说也是一笔相当大的开销，因此拥有一个健全的自动化测试系统是必需的。
- en: Besides speeding up the testing process and making it less error-prone, automated
    tests should give you the confidence that any code you merge will not break the
    existing application code. If you’ve ever merged a large code change in an environment
    without a good testing suite, you know what a nerve-wracking experience it is
    and that you never really feel confident that your changes didn’t break anything.
    If there are tests, they will catch bugs and help you think differently about
    how you implement your code, but having the ability to release changes confidently
    is the real goal we’re trying to achieve when writing automated tests.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 除了加快测试过程并减少错误率外，自动化测试还应让您有信心，合并的任何代码都不会破坏现有的应用程序代码。如果您曾在没有良好测试套件的环境中合并过大型代码更改，您就知道这是一次多么令人紧张的经历，并且您从未真正有信心您的更改没有破坏任何东西。如果有测试，它们会捕获错误并帮助您以不同的方式思考您的代码实现，但能够有信心地发布更改是我们编写自动化测试时试图实现的真实目标。
- en: 'When it comes to automated tests for your Angular applications, you can divide
    them into four major types:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到为您的 Angular 应用程序进行自动化测试时，您可以将其分为四大主要类型：
- en: Unit tests
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: End-to-end tests
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端到端测试
- en: Component tests
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件测试
- en: Integration tests
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试
- en: Let’s learn about these four types of tests, how they are used in Angular applications,
    and the differences between them.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解这四种测试类型，它们在 Angular 应用程序中的使用方式以及它们之间的区别。
- en: Understanding unit tests
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解单元测试
- en: One of the fundamental aspects of software testing is **unit testing**. Simply
    put, unit tests validate small units of code, commonly individual functions, properties,
    or methods. Unit tests are used to test the update behavior of properties and
    the implementation of functions under different scenarios. Given a specified input,
    you expect the function to return a specific value and update certain properties.
    Unit tests run in isolation from the rest of your application, so you can test
    small units of code without them being affected by other parts of the application
    code; that way, you can quickly identify whether the function works as intended
    based on its implementation.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 软件测试的基本方面之一是**单元测试**。简单来说，单元测试验证代码的小单元，通常是单个函数、属性或方法。单元测试用于测试属性在不同场景下的更新行为和函数的实现。给定一个特定的输入，您期望函数返回一个特定的值并更新某些属性。单元测试在与其他应用程序代码隔离的情况下运行，因此您可以在不受应用程序代码其他部分影响的情况下测试代码的小单元；这样，您可以根据其实现快速确定函数是否按预期工作。
- en: A common and popular technique for developing applications is **test-driven
    development** (**TDD**). In simple terms, when you use TDD to develop your applications,
    you first write the test scenarios and then the code implementations. Developing
    your code this way allows you to look at your code implementations from another
    perspective. Writing tests helps you to look at your code implementations differently
    in general. Still, when you first write all the possible test scenarios you want
    to cover and write the code implementation afterward, it changes your perspective.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 开发应用程序的一种常见且流行的技术是**测试驱动开发**（**TDD**）。简单来说，当您使用 TDD 来开发应用程序时，您首先编写测试场景，然后编写代码实现。以这种方式开发代码允许您从另一个角度审视您的代码实现。编写测试有助于您以不同的方式看待代码实现。尽管如此，当您首先编写所有想要覆盖的可能测试场景，然后编写代码实现之后，这会改变您的视角。
- en: In Angular applications, unit tests are commonly implemented using frameworks
    such as **Jest** or **Karma** and typically test specific Angular components,
    services, pipes, or directives. These tests are essential for verifying that each
    unit of code behaves as expected, adhering to its defined specifications and requirements.
    By isolating each unit of code, developers can identify and address bugs and issues
    early in development, promoting a more robust and stable application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 应用程序中，单元测试通常使用 **Jest** 或 **Karma** 等框架来实现，通常测试特定的 Angular 组件、服务、管道或指令。这些测试对于验证每个代码单元是否按预期行为，遵守其定义的规范和需求至关重要。通过隔离每个代码单元，开发者可以在开发早期识别并解决错误和问题，从而促进更健壮和稳定的应用程序。
- en: The primary purpose of unit tests in Angular applications is to give developers
    confidence in their code implementations, ensuring properties are updated and
    functions work as expected. By thoroughly testing individual units of code under
    different scenarios, developers can ensure that each line of code functions as
    intended, even as the codebase evolves and changes over time. This confidence
    is crucial to enabling developers to make changes and enhancements to the application
    with the assurance that existing functionalities remain intact.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 应用程序中，单元测试的主要目的是让开发者对其代码实现有信心，确保属性得到更新，函数按预期工作。通过在不同场景下彻底测试单个代码单元，开发者可以确保每一行代码都按预期工作，即使代码库随着时间的推移而演变和变化。这种信心对于开发者能够有信心地对应用程序进行更改和改进至关重要，同时确保现有功能保持完整。
- en: A characteristic of unit tests is that they are quick to run, allowing developers
    to run them multiple times during the development process, making it easy to identify
    unintended side effects and bugs early. Unit tests also aim to cover a specific
    percentage of the codebase. Typically, companies like to test between 80% and
    100% of the lines of code, functions, and branches (or paths) of the code; most
    unit test frameworks can enforce these thresholds, so you can’t merge the code
    if you don’t have enough testing coverage.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的一个特点是它们运行速度快，允许开发者在开发过程中多次运行它们，这使得早期识别意外的副作用和错误变得容易。单元测试还旨在覆盖代码库的特定百分比。通常，公司喜欢测试
    80% 到 100% 的代码行、函数和分支（或路径）；大多数单元测试框架可以强制执行这些阈值，所以如果你没有足够的测试覆盖率，就不能合并代码。
- en: To summarize, unit tests are used to test small units of code such as functions,
    methods, and properties. With unit tests, you test code implementations under
    different scenarios to give you confidence that the code behaves as expected given
    a specified input. Commonly, you try to achieve a code testing coverage of between
    80% and 100% for unit tests; so, compared to the other testing types (end-to-end,
    component, and integration), your unit tests will have the most test cases. Unit
    tests are fast to run and rarely fail because of your environment because they
    run in isolation.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，单元测试用于测试如函数、方法和属性等小的代码单元。通过单元测试，你可以在不同的场景下测试代码实现，以增强你对代码在给定特定输入时按预期行为的信心。通常，你试图实现
    80% 到 100% 的代码测试覆盖率；因此，与其他测试类型（端到端、组件和集成）相比，你的单元测试将拥有最多的测试用例。单元测试运行速度快，很少因为环境问题而失败，因为它们是在隔离状态下运行的。
- en: 'Now that you have a good idea of what unit tests are and why they are useful,
    let’s dive into the next type of tests: end-to-end tests.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你对单元测试有了很好的了解，知道它们为什么有用，那么让我们深入了解下一类测试：端到端测试。
- en: Understanding end-to-end tests
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解端到端测试
- en: '**End-to-end** (**e2e**) tests are an integral part of the testing strategy
    for Angular applications. They offer a comprehensive approach to validating the
    application’s behavior and functionality from the user’s perspective. Unlike unit
    tests, which focus on testing individual units of code in isolation, e2e tests
    simulate real user interactions with the application, spanning multiple components
    and services to ensure that the application functions correctly as a whole.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**端到端**（**e2e**）测试是 Angular 应用程序测试策略的一个关键部分。它们提供了一个全面的方法来验证应用程序从用户角度的行为和功能。与专注于测试独立代码单元的单元测试不同，端到端测试模拟了与应用程序的真实用户交互，跨越多个组件和服务，以确保应用程序作为一个整体正确运行。'
- en: In the context of Angular applications, e2e tests are commonly implemented using
    frameworks such as **Cypress**, **Playwright**, or **Protractor**. These frameworks
    provide helpful tools to automate browser interactions, allowing them to simulate
    user actions such as clicking buttons, entering text, and navigating between pages.
    By automating these interactions, developers can thoroughly test the application’s
    user interface and workflow, identifying and addressing issues that may arise
    during real-world usage.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular应用程序的背景下，端到端测试通常使用**Cypress**、**Playwright**或**Protractor**等框架来实现。这些框架提供了有助于自动化浏览器交互的有用工具，允许它们模拟用户操作，例如点击按钮、输入文本和在不同页面之间导航。通过自动化这些交互，开发者可以彻底测试应用程序的用户界面和工作流程，识别和解决在实际使用中可能出现的问题。
- en: The primary goal of e2e tests is verifying that the applications work as expected
    from the perspective of the user, encompassing the application’s functional and
    non-functional aspects. e2e tests serve and render the application (or specific
    libraries or modules of the application) in a real browser (you can also run them
    headless without opening a browser), visit a specific URL, and interact with the
    application as a user would. With e2e tests, you are testing whether components
    render correctly and whether features such as form submission, data retrieval
    and display, models, and error handling work as intended. By testing the application
    end-to-end, developers can ensure that multiple components and services work together
    seamlessly to deliver a cohesive user experience.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试的主要目标是验证应用程序从用户的角度来看是否按预期工作，包括应用程序的功能性和非功能性方面。端到端测试在真实浏览器中（你也可以在不打开浏览器的情况下运行它们）呈现应用程序（或应用程序的特定库或模块），访问特定的URL，并以用户的方式与之交互。通过端到端测试，你可以测试组件是否正确渲染，以及诸如表单提交、数据检索和显示、模型和错误处理等功能是否按预期工作。通过端到端测试应用程序，开发者可以确保多个组件和服务能够无缝协作，提供一致的用户体验。
- en: One of the main advantages of e2e tests is their ability to detect issues that
    may be absent when testing individual units of code in isolation. By exercising
    the entire application stack during the tests, including the frontend user interface,
    external dependencies, and (optionally) backend services, e2e tests can uncover
    issues related to data flow, communication between components, and interoperability
    with third-party services. This holistic approach to testing helps developers
    identify and address potential bottlenecks and failure points within the application,
    leading to a more robust and reliable software product.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试的主要优势之一是它们能够检测在单独测试代码单元时可能缺失的问题。通过在测试期间对整个应用程序堆栈进行操作，包括前端用户界面、外部依赖项以及（可选的）后端服务，端到端测试可以揭示与数据流、组件间的通信以及与第三方服务的互操作性相关的问题。这种全面的测试方法有助于开发者识别和解决应用程序中可能存在的瓶颈和故障点，从而产生更健壮和可靠的应用软件产品。
- en: However, while e2e tests offer many benefits, they also come with certain challenges
    and considerations that developers must address. The setup for e2e tests is more
    challenging than unit tests, and e2e tests are more prone to fail because of issues
    in the test environment. Nx already handles most of the setup for us, making starting
    with our e2e tests easier.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管端到端测试提供了许多好处，但它们也带来了一些挑战和开发者必须解决的问题。端到端测试的设置比单元测试更具挑战性，并且由于测试环境中的问题，端到端测试更容易失败。Nx已经为我们处理了大部分设置工作，这使得开始我们的端到端测试变得更加容易。
- en: With e2e tests, you also don’t have an easy way to detect code coverage, so
    they require more planning and coordination to ensure you’re testing everything
    within your application and handling different scenarios and use cases.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用端到端测试，你也没有简单的方法来检测代码覆盖率，因此它们需要更多的规划和协调，以确保测试了应用程序中的所有内容，并处理了不同的场景和用例。
- en: Furthermore, e2e tests can be more time-consuming and resource-intensive to
    execute than unit tests due to their reliance on browser automation and the need
    to simulate real user behavior. As a result, developers must strike a balance
    between the depth and scope of e2e test coverage and the practical constraints
    of test execution time and resources.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于端到端测试依赖于浏览器自动化和模拟真实用户行为的需求，因此它们的执行可能比单元测试更耗时和资源密集。因此，开发者必须在端到端测试覆盖的深度和范围与测试执行时间和资源等实际约束之间取得平衡。
- en: Despite these challenges, e2e tests play a crucial role in ensuring Angular
    applications’ overall quality and reliability, complementing other testing techniques
    such as unit tests and integration tests. By thoroughly testing the application
    from end to end, developers can gain confidence in its behavior and functionality,
    identify and address issues early in the development process, and ultimately deliver
    a high-quality user experience to their customers.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在这些挑战，端到端测试（e2e tests）在确保 Angular 应用程序的整体质量和可靠性方面发挥着至关重要的作用，它补充了其他测试技术，如单元测试和集成测试。通过彻底测试应用程序的每个环节，开发者可以对其行为和功能充满信心，在开发早期阶段识别并解决问题，最终向客户交付高质量的用户体验。
- en: To summarize, e2e tests are designed to test your application from the user’s
    perspective and interact with your application in a real browser. They ensure
    your application (or specific libraries or modules) works as a whole and responds
    in the intended way to user interactions. e2e tests, while more time-consuming
    to write and execute than unit tests, provide the assurance that the user can
    interact with your applications as you intended, fostering a stronger connection
    with your end users.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，端到端测试旨在从用户的角度测试你的应用程序，并在真实浏览器中与之交互。它们确保你的应用程序（或特定的库或模块）作为一个整体工作，并按预期对用户交互做出响应。虽然端到端测试在编写和执行方面比单元测试更耗时，但它们提供了用户可以按预期与你的应用程序交互的保证，从而与最终用户建立更强的联系。
- en: Now that you know what e2e tests are and how they differ from unit tests, I
    will briefly explain component and integration testing.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了端到端测试是什么以及它们与单元测试的不同之处，我将简要解释组件测试和集成测试。
- en: Understanding component tests
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解组件测试
- en: '**Component testing** is a relatively new concept compared to unit and e2e
    testing. In modern frontend frameworks such as Angular, we develop applications
    using **components**. Components can be simple components, such as buttons, or
    more complex ones, such as tables or forms.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**组件测试**与单元测试和端到端测试相比是一个相对较新的概念。在现代前端框架如 Angular 中，我们使用 **组件** 来开发应用程序。组件可以是简单的组件，如按钮，也可以是更复杂的组件，如表格或表单。'
- en: Using component tests, frameworks such as Cypress provide a new approach for
    testing component-based applications. Instead of visiting a URL and running the
    entire application, component tests mount individual components and test those
    components in isolation. Component testing is like unit testing of e2e testing.
    You still mount the component and show it in a browser to interact with the component
    like a user would, but you test it in isolation from the rest of your application.
    Testing components in isolation allows you to test the component from a user interaction
    perspective without worrying about the rest of the application.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用组件测试，例如 Cypress 这样的框架提供了一种测试基于组件的应用程序的新方法。而不是访问 URL 并运行整个应用程序，组件测试会挂载单个组件并在隔离状态下测试这些组件。组件测试类似于端到端测试的单元测试。你仍然挂载组件并在浏览器中显示它，以便像用户一样与之交互，但你是在与应用程序的其他部分隔离的情况下进行测试。在隔离状态下测试组件允许你从用户交互的角度测试组件，而不必担心应用程序的其他部分。
- en: One thing to keep in mind is that even if all your component tests are passing,
    it does not automatically mean your application is working as expected. Components
    can work in isolation but fail when they’re combined or have to interact with
    other components in your application. Compared to e2e tests, component tests don’t
    need the entire system to be executed, so they can run faster and rarely fail
    due to issues with your test environment.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的一点是，即使所有组件测试都通过，这也并不意味着你的应用程序按预期工作。组件可以独立工作，但在组合或需要与其他应用程序中的组件交互时可能会失败。与端到端测试相比，组件测试不需要执行整个系统，因此它们可以更快地运行，并且很少因为测试环境的问题而失败。
- en: If you and your team want to implement component tests, it is up to you; these
    tests can help reduce the number of e2e tests you need to write. I like to write
    more e2e tests as opposed to component tests. Component tests still need to be
    adopted as an industry standard; most companies only require unit, e2e, and integration
    tests.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你和你的团队想要实施组件测试，这取决于你；这些测试可以帮助减少你需要编写的端到端测试的数量。我更喜欢编写更多的端到端测试而不是组件测试。组件测试仍然需要被采纳为行业标准；大多数公司只需要单元测试、端到端测试和集成测试。
- en: To summarize, component tests test individual components from the user’s perspective.
    Component tests ensure a component works in isolation but don’t ensure the component
    works within the context of your entire application. Component tests are easier
    to set up than e2e tests as they don’t need to run the entire application. You
    can think of component testing as a mix between unit and e2e testing.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，组件测试从用户的角度测试单个组件。组件测试确保组件在隔离状态下可以工作，但并不确保组件在应用程序的整个上下文中也能工作。组件测试比端到端测试更容易设置，因为它们不需要运行整个应用程序。你可以将组件测试视为单元测试和端到端测试之间的混合体。
- en: Now that you know what component tests are and how they differ from e2e tests,
    we will finish this section on different testing types by explaining integration
    tests.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了组件测试是什么以及它们与端到端测试的不同，我们将通过解释集成测试来结束关于不同测试类型的这一部分。
- en: Understanding integration tests
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解集成测试
- en: '**Integration tests** are used to test whether different modules and elements
    of your software integrate without breaking. They are generally the final testing
    stage before you release your changes to production. So, unit tests focus on testing
    individual units of code in isolation, end-to-end tests simulate and test user
    interactions for specific application libraries and modules, and integration tests
    are used to test the interactions between various modules and elements within
    the application.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**集成测试**用于测试软件的不同模块和元素是否可以集成而不会出错。它们通常是你在将更改发布到生产之前进行的最终测试阶段。因此，单元测试专注于在隔离状态下测试单个代码单元，端到端测试模拟并测试特定应用程序库和模块的用户交互，而集成测试用于测试应用程序内各种模块和元素之间的交互。'
- en: Integration tests can be used and written for different integration levels within
    an application. For example, you can write functional tests comparable to unit
    tests. Still, instead of testing code implementations for an isolated component
    or service, you test whether your functionality and implementations work as expected
    for a group of components or services that work together. You can also write integration
    tests from the user’s perspective, similar to e2e tests. When you write integration
    tests from the user’s perspective, you can test whether your frontend works together
    with your API or whether your deployed application is composed of multiple Angular
    applications. You can also test whether the different applications can work together
    when everything is deployed.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试可以在应用程序的不同集成级别中使用和编写。例如，你可以编写与单元测试相当的功能测试。然而，你测试的不是孤立组件或服务的代码实现，而是测试你的功能实现是否按预期工作，对于一组协同工作的组件或服务。你也可以从用户的角度编写集成测试，类似于端到端测试。当你从用户的角度编写集成测试时，你可以测试你的前端是否与API协同工作，或者你的部署应用程序是否由多个Angular应用程序组成。你还可以测试当所有内容都部署时，不同的应用程序是否可以协同工作。
- en: When you create integration tests from the user’s perspective, you commonly
    run the tests in an environment that mirrors the production environment. You test
    with an actual deployed application with real APIs and data. By testing on a deployed
    system, you can test whether all elements of your software work together as expected
    without any boundaries.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从用户的角度创建集成测试时，你通常会在一个与生产环境相似的环境中运行测试。你使用实际部署的应用程序和真实的API以及数据进行测试。通过在部署的系统上进行测试，你可以测试你的软件的所有元素是否按预期协同工作，没有任何边界。
- en: Now you know about unit, e2e, component, and integration tests, it’s time to
    get our hands dirty and write some tests ourselves. We will skip the integration
    tests because we don’t have a large system or a deployed version with different
    elements that integrate. We will start by writing and running unit tests for our
    Angular application using the Jest testing framework. After writing our unit test,
    we will finish the chapter by writing e2e tests using the Cypress testing framework.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了单元测试、端到端测试、组件测试和集成测试，是时候动手编写一些测试了。我们将跳过集成测试，因为我们没有大型系统或包含不同集成元素的部署版本。我们将从使用Jest测试框架为我们的Angular应用程序编写和运行单元测试开始。编写完单元测试后，我们将使用Cypress测试框架编写端到端测试来结束本章。
- en: Unit testing of Angular applications using Jest
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jest对Angular应用程序进行单元测试
- en: When you add an Angular project to your Nx monorepo, the application is set
    up to use Jest as a test runner by default. Jest is a testing framework commonly
    used to write and run automated unit tests for JavaScript and TypeScript-based
    applications. This section will give you hands-on experience writing unit tests
    for your Angular application using Jest. Before you start writing tests, let’s
    expand upon the default configuration Nx provided to make your testing experience
    better.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将 Angular 项目添加到你的 Nx 单一代码仓库中时，应用程序默认设置为使用 Jest 作为测试运行器。Jest 是一个常用的测试框架，通常用于编写和运行基于
    JavaScript 和 TypeScript 的应用程序的自动化单元测试。本节将为你提供使用 Jest 为你的 Angular 应用程序编写单元测试的实践经验。在你开始编写测试之前，让我们扩展
    Nx 提供的默认配置，以使你的测试体验更佳。
- en: Setting the coverage threshold
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置覆盖率阈值
- en: 'The first thing you want to add in the Jest configuration is a coverage threshold
    for the minimum required percentage of lines, functions, and branches that unit
    tests should cover. A commonly used percentage is 80%, but you can set the coverage
    percentages to whatever you and your team deem enough to make you confident that
    new changes won’t break existing code. You can add the global configurations for
    testing coverage inside the `jest.preset.js` file in the root of your Nx monorepo.
    Additionally, you can set specific configurations for each project in the `jest.config.ts`
    file at the root of each project. I will only add the following configurations
    in `jest.preset.js` in the root of the Nx monorepo:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Jest 配置中，你首先想要添加的是单元测试应该覆盖的最小行、函数和分支的覆盖率阈值。常用的百分比是 80%，但你可以将覆盖率百分比设置为你和你的团队认为足够的任何值，以确保新的更改不会破坏现有代码。你可以在
    Nx 单一代码仓库根目录下的 `jest.preset.js` 文件中添加测试覆盖率的全局配置。此外，你还可以在每个项目的根目录下的 `jest.config.ts`
    文件中为每个项目设置特定的配置。我将在 Nx 单一代码仓库根目录下的 `jest.preset.js` 中添加以下配置：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding configuration ensures that all branches, functions, and lines
    have a minimum test coverage of 80%. The configuration also tells Jest to collect
    the coverage results and present you with a text-based coverage report. In the
    coverage report, you can see how much of your code is covered, what lines, functions,
    and branches are missing, and their respective page line numbers.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 上述配置确保所有分支、函数和行至少有 80% 的测试覆盖率。该配置还告诉 Jest 收集覆盖率结果并向你提供一个基于文本的覆盖率报告。在覆盖率报告中，你可以看到你的代码覆盖了多少，哪些行、函数和分支缺失，以及它们各自的页面行号。
- en: Now that you have configured your test coverage reports, it’s time to add a
    testing module for Transloco.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经配置了测试覆盖率报告，是时候为 Transloco 添加一个测试模块了。
- en: Adding additional configurations
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加额外的配置
- en: 'The testing module makes it easy to import the correct configuration to test
    components using Transloco. In the root of your `expenses-registration` project,
    you can create a `transloco-testing.module.ts` file and add the following content:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 测试模块使得导入正确的配置来测试使用 Transloco 的组件变得容易。在你的 `expenses-registration` 项目根目录下，你可以创建一个
    `transloco-testing.module.ts` 文件，并添加以下内容：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding example, we created a `getTranslocoModule()` function. This
    function will be used inside our unit test files to add the necessary Transloco
    configuration for the test setup. It’s simply a function returning the `TranslocoTestingModule`
    class provided by the `Transloco` library. At the top of the file, we import two
    JSON files containing our translations. If you want to import these two JSON files
    without trouble, you need to add the following configurations inside your `tsconfig.base.json`
    file:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了一个 `getTranslocoModule()` 函数。这个函数将在我们的单元测试文件中使用，为测试设置添加必要的 Transloco
    配置。它只是一个返回 `TranslocoTestingModule` 类的函数，该类由 `Transloco` 库提供。在文件顶部，我们导入包含我们翻译的两个
    JSON 文件。如果你想无障碍地导入这两个 JSON 文件，你需要在你的 `tsconfig.base.json` 文件中添加以下配置：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After adding the preceding configuration and the `transloco-testing.module.ts`
    file with the `getTranslocoModule()` function, we are almost done with our addition
    to the default Jest setup Nx provided us with. Lastly, we need to update the `transformIgnorePatterns`
    configuration inside our `jest.config.ts` files to the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加上述配置和包含 `getTranslocoModule()` 函数的 `transloco-testing.module.ts` 文件之后，我们几乎完成了对
    Nx 提供的默认 Jest 设置的补充。最后，我们需要更新 `jest.config.ts` 文件中的 `transformIgnorePatterns`
    配置，如下所示：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When you change the `transformIgnorePatterns` configuration, you ensure Jest
    will not start to complain about missing imports and packages inside your `node_modules`
    folder. There already are `transformIgnorePatterns` configurations inside each
    `jest.config.ts` file in your Nx monorepo, but in many cases, you need to adjust
    them or else your tests might fail based on things inside your `node_modules`
    folder.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当你更改 `transformIgnorePatterns` 配置时，你确保 Jest 不会开始抱怨 `node_modules` 文件夹中缺少导入和包。在你的
    Nx monorepo 中，每个 `jest.config.ts` 文件中已经存在 `transformIgnorePatterns` 配置，但在许多情况下，你需要调整它们，否则你的测试可能会因为
    `node_modules` 文件夹中的内容而失败。
- en: That is all the additional setup we will be doing. You can always add additional
    configurations as needed. You can find all additional Jest configurations in their
    official documentation at [https://jestjs.io/docs/configuration](https://jestjs.io/docs/configuration).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们将进行的所有额外设置。你总是可以根据需要添加额外的配置。你可以在他们的官方文档中找到所有额外的 Jest 配置：[https://jestjs.io/docs/configuration](https://jestjs.io/docs/configuration)。
- en: Now that you have added the configuration needed to test Transloco and obtained
    testing coverage reports, let’s start to write and run unit tests for our Angular
    application.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经添加了测试 Transloco 所需的配置并获得了测试覆盖率报告，让我们开始编写和运行我们的 Angular 应用程序的单元测试。
- en: Writing and running unit tests
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写和运行单元测试
- en: You write your unit tests inside `.spec.ts` file for the created resource. These
    `.spec.ts` files contain the default-generated unit tests.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你将单元测试写在为创建的资源创建的 `.spec.ts` 文件中。这些 `.spec.ts` 文件包含默认生成的单元测试。
- en: Let’s take the `expenses-registration` Angular application as our example. When
    you generated the application, Nx generated an `AppComponent` class for you and
    an `app.component.spec.ts` file where the default generated unit test for `AppComponent`
    resides. Additionally, we created `ExpensesOverviewPageComponent` and `ExpensesApprovalPageComponent`
    inside the *expenses-registration application*; for both these components, Nx
    also generated `.spec.ts` files. Let’s start with these files.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以 `expenses-registration` Angular 应用程序为例。当你生成应用程序时，Nx 为你生成了一个 `AppComponent`
    类和一个 `app.component.spec.ts` 文件，其中包含为 `AppComponent` 生成的默认单元测试。此外，我们在 *expenses-registration
    应用程序* 中创建了 `ExpensesOverviewPageComponent` 和 `ExpensesApprovalPageComponent`；对于这两个组件，Nx
    也生成了 `.spec.ts` 文件。让我们从这些文件开始。
- en: Fixing the generated spec files
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修复生成的 spec 文件
- en: 'If you currently run the tests inside these spec files, they will fail. The
    tests will fail because we haven’t touched the spec files since they have been
    generated, but we did adjust the component classes. So before we try to run the
    tests, let’s fix the spec files one by one. We will also write some new tests
    and explain what Nx generated for us. Starting with the `app.component.spec.ts`
    file, let’s see what Nx has generated inside the spec file:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在在这些 spec 文件中运行测试，它们将会失败。测试会失败，因为我们自生成以来还没有修改过 spec 文件，但我们确实调整了组件类。所以在我们尝试运行测试之前，让我们逐个修复
    spec 文件。我们还将编写一些新的测试并解释 Nx 为我们生成了什么。从 `app.component.spec.ts` 文件开始，让我们看看 Nx 在
    spec 文件中生成了什么：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Nx generated the preceding code for you. As you can see, there are `describe()`,
    `beforeEach()`, and two `it()` functions. All of these functions have some additional
    code inside their respective callback functions, but we will ignore that for now.
    Let’s first explain what `describe()`, `beforeEach()`, and `it()` functions are
    used for:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Nx 为你生成了前面的代码。正如你所见，有 `describe()`、`beforeEach()` 和两个 `it()` 函数。所有这些函数在其各自的回调函数中都有一些额外的代码，但我们现在将忽略这些代码。让我们首先解释
    `describe()`、`beforeEach()` 和 `it()` 函数的用途：
- en: '`describe()`: The `describe()` function is used to group multiple tests together
    and describe what element we are testing. You provide the `describe()` function
    with two parameters: a string with a description of what we’re writing tests for—in
    our example, `AppComponent`—and a callback function where we will write out specific
    test cases.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`describe()`: `describe()` 函数用于将多个测试组合在一起并描述我们正在测试的元素。你向 `describe()` 函数提供两个参数：一个字符串，描述我们正在为哪些内容编写测试——在我们的例子中是
    `AppComponent`——以及一个回调函数，我们将在这里编写具体的测试用例。'
- en: '`beforeEach()`: The `beforeEach()` function is used to perform specific steps
    before each test, commonly configurations such as setting up `TestBed`, creating
    the component, service, pipe, or directive we are testing, and any additional
    configuration we want to do before each test we run.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beforeEach()`: `beforeEach()` 函数用于在每个测试之前执行特定的步骤，通常包括配置，如设置 `TestBed`、创建我们正在测试的组件、服务、管道或指令，以及我们在每个测试运行之前想要进行的任何其他配置。'
- en: '`it()`: The `it()` functions define each test case. An `it()` function takes
    in two parameters: a string containing a description of the test case and a callback
    function containing the testing logic.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`it()`：`it()`函数定义了每个测试用例。一个`it()`函数接受两个参数：一个包含测试用例描述的字符串和一个包含测试逻辑的回调函数。'
- en: Now that you know what `describe()`, `beforeEach()`, and `it()` functions are,
    let’s replace the generated code of your `app.component.spec.ts` file with something
    that reflects the current state of the app component.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了`describe()`、`beforeEach()`和`it()`函数是什么，让我们用反映当前应用组件状态的代码替换`app.component.spec.ts`文件中生成的代码。
- en: Defining our test cases
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义我们的测试用例
- en: Before we start adjusting the code inside the spec file, let’s first clarify
    what we want to test.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始调整spec文件中的代码之前，让我们首先明确我们想要测试的内容。
- en: 'If you look inside your `AppComponent` class, you find two properties: a `translationService`
    and a `navItems` property. Additionally, inside the HTML template of your app
    component, you’ll find the navbar component with some inputs and an output for
    when the selected language changes. As we mentioned before, when writing unit
    tests, you want to test a single unit of code in isolation—in this case, our app
    component. So, what functionalities are related to the app component?'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看你的`AppComponent`类，你会找到两个属性：一个`translationService`和一个`navItems`属性。此外，在你的应用组件的HTML模板中，你会找到一个带有一些输入和当选择的语言改变时的输出的导航栏组件。正如我们之前提到的，在编写单元测试时，你想要单独测试单个代码单元——在这种情况下，我们的应用组件。那么，与应用组件相关的功能有哪些？
- en: Defining the component class properties.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义组件类属性。
- en: Calling the `setActiveLanguage` method on the `translationService` property
    of the navbar to emit a `languageChange` event.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在导航栏的`translationService`属性上调用`setActiveLanguage`方法以触发`languageChange`事件。
- en: 'The aforementioned points are the only component logic related to the app component;
    checking whether the navbar inputs are correctly handled and whether the navbar
    renders correctly is logic related to the navbar and should be tested in the spec
    file of the navbar component. If we were to check these things inside the spec
    file of the app component, we would be testing whether the navbar and app components
    integrate correctly. For the same reason, we do not check whether `TranslationService`
    actually adjusts the active language after we call the method. This would test
    the integration between the app component and `TranslationService`. From the perspective
    of the app component, we are only interested if the app component actually makes
    the function call. Now we know what we will be testing, let’s define what `it()`
    statements we will be creating inside our spec file:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 上述提到的点是与应用组件相关的唯一组件逻辑；检查导航栏输入是否被正确处理以及导航栏是否正确渲染的逻辑是与导航栏相关的，应该在导航栏组件的spec文件中进行测试。如果我们要在应用组件的spec文件中检查这些内容，我们就会在测试导航栏和应用组件是否正确集成。出于同样的原因，我们不会检查在调用方法后`TranslationService`是否实际上调整了活动语言。这将测试应用组件和`TranslationService`之间的集成。从应用组件的角度来看，我们只对应用组件是否实际上调用了该函数感兴趣。现在我们知道了我们将要测试的内容，让我们定义我们将在spec文件中创建的`it()`语句：
- en: They should create the component and set the component properties with the expected
    values.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们应该创建组件并使用预期值设置组件属性。
- en: They should call the `setActiveLanguage` method when the `languageChange` event
    is emitted.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`languageChange`事件被触发时，它们应该调用`setActiveLanguage`方法。
- en: Now that we have defined the `it()` statements we’re about to define inside
    the `app.component.spec.ts` file, let’s start to adjust the file step by step
    so we can actually test these statements successfully.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经定义了`app.component.spec.ts`文件中即将定义的`it()`语句，让我们一步一步地调整文件，以便我们能够成功测试这些语句。
- en: Adjusting the code inside the spec file
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调整spec文件中的代码
- en: We defined the test cases we wanted to write and learned about the three main
    functions inside the spec files. Now, let’s write our test cases and learn how
    to configure your testing modules, make assertions for your test cases, and actually
    run the tests.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了我们想要编写的测试用例，并了解了spec文件中的三个主要函数。现在，让我们编写我们的测试用例，并学习如何配置测试模块，为测试用例进行断言，并实际运行测试。
- en: The describe() function
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`describe()`函数'
- en: 'We will start by removing all the code inside the `describe()` function so
    we can start fresh. The `describe()` function itself can remain as it was generated
    for you. After you remove the generated code, start by defining three properties
    inside the `describe()` function:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先移除`describe()`函数内部的所有代码，这样我们就可以从头开始。`describe()`函数本身可以保持它为您生成的样子。在移除生成的代码后，首先在`describe()`函数内部定义三个属性：
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see in the preceding code snippet, we added `component`, `fixture`,
    and `mockTranslationService` properties inside the `describe()` function. The
    `component` variable will hold an instance of our `AppComponent` class, `fixture`
    will be an element containing a test harness that can be used to debug and interact
    with the app component (the class, native element, element ref, lifecycle methods,
    etc.), and `mockTranslationService` will be used as a value for the `TranslationService`
    injectable we use inside the app component. We use this mock version of `TranslationService`
    to simplify the setup we need to do inside our spec file. Because we don’t want
    to test the integration between our app component and `TranslationService`, we
    want to test the app component in isolation. After you have defined these three
    properties, it’s time to add the `beforeEach()` function.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的代码片段中所见，我们在`describe()`函数内部添加了`component`、`fixture`和`mockTranslationService`属性。`component`变量将保存我们`AppComponent`类的实例，`fixture`将是一个包含测试框架的元素，可以用来调试和与组件（类、原生元素、元素引用、生命周期方法等）交互，而`mockTranslationService`将作为我们在组件内部使用的`TranslationService`注入值的替代。我们使用这个`TranslationService`的模拟版本来简化我们在spec文件内部需要做的设置。因为我们不想测试组件和`TranslationService`之间的集成，我们希望单独测试组件。在定义了这三个属性之后，就是时候添加`beforeEach()`函数了。
- en: The beforeEach() function
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`beforeEach()`函数'
- en: 'The `beforeEach()` function will be added underneath the three properties we
    added just now and will be used to configure `TestBed` and assign our `component`
    and `fixture` properties before each test. Let’s start simply by defining the
    `beforeEach()` method itself:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`beforeEach()`函数将添加在我们刚才添加的三个属性下面，并用于在每次测试之前配置`TestBed`和分配我们的`component`和`fixture`属性。让我们简单地定义`beforeEach()`方法本身：'
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now inside the callback of the `beforeEach()` function, we start by configuring
    the testing module using the `TestBed.configureTestingModule()` method. The testing
    module requires everything needed to create our app component:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`beforeEach()`函数的回调内部，我们首先使用`TestBed.configureTestingModule()`方法配置测试模块。测试模块需要创建我们的组件所需的一切：
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see in the preceding code, we need to import three classes and define
    a provider to configure the testing module. You need to import the `AppComponent`
    class because `AppComponent` is a standalone component, `RouterTestingModule`
    because we use the `RouterOutlet` inside the app component template, and `TranslocoTestingModule`
    using the `getTranslocoModule()` function we defined in the *Adding additional
    configurations* section of this chapter. Besides the imports, you need to create
    a provider for `TranslationService` so that the app component uses `mockTranslationService`
    during the tests. At the end of the `configureTestingModule()` method, you need
    to call the `compileComponents()` methods so that Jest will compile everything
    we defined inside the testing module configuration.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在先前的代码中看到的那样，我们需要导入三个类并定义一个提供者来配置测试模块。您需要导入`AppComponent`类，因为`AppComponent`是一个独立组件，`RouterTestingModule`因为我们在组件模板内部使用了`RouterOutlet`，以及使用我们在本章的*添加额外配置*部分定义的`getTranslocoModule()`函数导入`TranslocoTestingModule`。除了导入之外，您还需要为`TranslationService`创建一个提供者，以便在测试期间组件使用`mockTranslationService`。在`configureTestingModule()`方法的末尾，您需要调用`compileComponents()`方法，这样Jest就会编译我们在测试模块配置内部定义的所有内容。
- en: 'After the `TestBed` testing module is configured, we will assign the `component`
    and `fixture` properties. The `fixture` property will be assigned using the `TestBed.createComponent()`
    method. Calling the `createComponent()` function on `TestBed` will freeze the
    current `TestBed` class, meaning you can’t call `TestBed` configuration methods
    anymore. It will also return a test harness that can be used to interact with
    the component created inside your test cases:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置好`TestBed`测试模块之后，我们将分配`component`和`fixture`属性。`fixture`属性将通过`TestBed.createComponent()`方法分配。在`TestBed`上调用`createComponent()`函数将冻结当前的`TestBed`类，这意味着您不能再调用`TestBed`配置方法了。它还将返回一个测试框架，可以用来与测试用例中创建的组件交互：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After assigning `fixture`, you assign the `component` variable using the `componentInstance`
    property of `fixture`. This `componentInstance` property is an object containing
    all the properties and functions of the component you’re testing—in our case,
    `AppComponent`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在分配`fixture`之后，您使用`fixture`的`componentInstance`属性来分配`component`变量。这个`componentInstance`属性是一个包含您正在测试的组件的所有属性和函数的对象——在我们的例子中是`AppComponent`：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Lastly, you need to call the `detectChanges()` method on `fixture` so that
    change detection will run for the created app component:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您需要在`fixture`上调用`detectChanges()`方法，以便为创建的应用组件运行变更检测：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now that you have defined the `beforeEach()` function and configured `TestBed`,
    we can start with our first `it()` function and define the first test case.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经定义了`beforeEach()`函数并配置了`TestBed`，我们可以开始我们的第一个`it()`函数并定义第一个测试用例。
- en: The first it() function and test case
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第一个`it()`函数和测试用例
- en: 'You can define your `it()` function underneath the `beforeEach()` function.
    In our case, the first test case should test whether the component is successfully
    created and the `navItems` and `translationService` properties are correctly assigned:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`beforeEach()`函数下方定义您的`it()`函数。在我们的例子中，第一个测试用例应该测试组件是否成功创建，以及`navItems`和`translationService`属性是否正确分配：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see in the preceding code, we start with the `it()` function and
    provide the function with a description. Then, in the callback function, we assess
    what we want to test using the `expect()` function combined with an assertion
    method. You provide the `expect()` method with the value you want to test and
    expect to be or not to be something. In our case, we first expect the component
    property (which is assigned without a component instance inside the `beforeEach()`
    function) to be defined. Next, we expect the `navItems` property of the component
    to equal the object we defined inside the component class for the `navItems` property.
    Lastly, we expect `translationService` to equal `mockTranslationService`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的代码中看到的，我们首先使用`it()`函数，并向该函数提供一个描述。然后，在回调函数中，我们使用`expect()`函数结合断言方法来评估我们想要测试的内容。您向`expect()`方法提供想要测试的值，并期望它为或不是某个值。在我们的例子中，我们首先期望组件属性（在`beforeEach()`函数内部没有分配组件实例）被定义。接下来，我们期望组件的`navItems`属性等于我们在组件类内部为`navItems`属性定义的对象。最后，我们期望`translationService`等于`mockTranslationService`。
- en: 'Now you have defined the `beforeEach()` function, configured `TestBed`, created
    the component inside the `beforeEach()` function, and written your first testing
    case. You can run the test inside the `app.component.spec.ts` file. You run unit
    tests by running the following command in the root of your Nx monorepo:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经定义了`beforeEach()`函数，配置了`TestBed`，在`beforeEach()`函数内部创建了组件，并编写了您的第一个测试用例。您可以在`app.component.spec.ts`文件中运行测试。您通过在Nx单仓库的根目录中运行以下命令来运行单元测试：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the preceding Terminal command, you need to replace the `<project-name>`
    placeholder with the actual name of the project you want to run tests for. You
    can find the project name inside the `project.json` file of each application or
    library within your Nx monorepo. To run the unit tests for a specific file, add
    the `–test-file` flag at the end of the command. For example, to run the unit
    tests for our `app.component.spec.ts` file, you run the following command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的终端命令中，您需要将`<project-name>`占位符替换为您想要运行测试的实际项目名称。您可以在每个应用程序或库的Nx单仓库中的`project.json`文件中找到项目名称。要为特定文件运行单元测试，请在命令末尾添加`–test-file`标志。例如，要为我们的`app.component.spec.ts`文件运行单元测试，您运行以下命令：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding command will run the tests inside the `app.component.spec.ts`
    file. After running the tests, you’ll notice that your test case is failing with
    the following error message: `NavbarComponent` and Jest doesn’t support signal
    inputs (at the time of writing).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将在`app.component.spec.ts`文件中运行测试。在运行测试后，您会注意到您的测试用例失败，并显示以下错误消息：`NavbarComponent`和Jest不支持信号输入（截至编写时）。
- en: 'As a workaround, you can create a simplified replica of `NavbarComponent` that
    is used for unit testing components that use `NavbarComponent` in their template.
    Such a replica is commonly named a `AppComponent` functionality in isolation instead
    of having it integrated with `NavbarComponent`. You create the navbar stub component
    in your `common-components` library inside the `navbar` folder by adding a `navbar.component.stub.ts`
    file with the following content:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种解决方案，你可以创建一个简化的`NavbarComponent`副本，用于单元测试在其模板中使用`NavbarComponent`的组件。这样的副本通常被称为`AppComponent`的功能，而不是将其与`NavbarComponent`集成。你可以在`common-components`库中的`navbar`文件夹内创建navbar占位组件，通过添加一个包含以下内容的`navbar.component.stub.ts`文件来实现：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After creating the stub component, export it in the `index.ts` file of your
    `common-components` library so you can access the stub component in your spec
    files. Now, inside the `beforeEach()` function of the `app.component.spec.ts`
    file, you can ensure the app component uses the stub navbar component during the
    tests instead of the regular navbar component. You can achieve this by changing
    the navbar component import for the stub navbar component using the `TestBed.overrideComponent()`
    method. You need to simply remove the `NavbarComponent` import and add the `StubNavbarComponent`
    import:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 创建占位组件后，在`common-components`库的`index.ts`文件中导出它，这样你就可以在spec文件中访问占位组件。现在，在`app.component.spec.ts`文件的`beforeEach()`函数中，你可以确保在测试期间app组件使用的是stub
    navbar组件而不是常规的navbar组件。你可以通过使用`TestBed.overrideComponent()`方法更改navbar组件的导入为stub
    navbar组件来实现这一点。你需要简单地移除`NavbarComponent`的导入并添加`StubNavbarComponent`的导入：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see in the preceding code, we remove the `NavbarComponent` import
    from `AppComponent` and add `StubNavbarComponent`. It’s important that you overwrite
    the component imports before you call the `TestBed.createComponent()` method and
    freeze `TestBed`; otherwise, your override will not be included in `TestBed`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，我们从`AppComponent`中移除了`NavbarComponent`的导入，并添加了`StubNavbarComponent`。在调用`TestBed.createComponent()`方法并冻结`TestBed`之前覆盖组件导入是很重要的；否则，你的覆盖将不会包含在`TestBed`中。
- en: Using stub components and services can be helpful in cases like this, where
    Jest still needs to add support for specific features. Additionally, stubs ensure
    that you’re not integration testing but focusing on units of code in isolation.
    If you want to unit test the navbar, for example, you should do so in the spec
    file of the navbar component and not in the spec file of the app component. Additionally,
    using stub components can simplify the setup you need in the `beforeEach()` method
    to ensure Jest can create the component or service you want to unit test.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用占位组件和服务可能会有所帮助，例如，Jest仍然需要添加对特定功能的支持。此外，占位确保你正在进行单元测试，而不是集成测试，专注于代码的独立单元。如果你想对navbar进行单元测试，例如，你应该在navbar组件的spec文件中进行，而不是在app组件的spec文件中进行。此外，使用占位组件可以简化你在`beforeEach()`方法中需要的设置，以确保Jest可以创建你想要进行单元测试的组件或服务。
- en: Suppose you rerun the app component unit tests after adding the stub navbar
    component. In that case, you’ll see that the test case we defined in the spec
    file is passing, meaning the test successfully creates `componentInstance`. Still,
    the test run fails because we don’t meet the configured coverage requirements
    of 80%. If you look at the coverage report in your terminal, you’ll see that the
    coverages of your `app.component.ts` and `app.component.html` files are 100%,
    but the coverage of your `translation.service.ts` file is 0%, bringing the total
    testing coverage under the required 80%.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在添加了stub navbar组件后重新运行app组件的单元测试。在这种情况下，你会看到我们在spec文件中定义的测试用例是通过的，这意味着测试成功创建了`componentInstance`。然而，测试运行失败，因为我们没有达到配置的80%覆盖率要求。如果你查看终端中的覆盖率报告，你会看到你的`app.component.ts`和`app.component.html`文件的覆盖率是100%，但你的`translation.service.ts`文件的覆盖率是0%，使得总测试覆盖率低于所需的80%。
- en: So, why is the testing coverage including `translation.service.ts`, and should
    you care? The `translation.service.ts` file is included in your coverage report
    because, by default, Jest (and other test runners) will consist of all files in
    the coverage report you import and use within the class you’re testing—in this
    case, the `AppComponent` class. Should you care, and do you need to fix this shortfall
    in your coverage percentage?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么测试覆盖率包括`translation.service.ts`，你应该关心吗？`translation.service.ts`文件被包含在你的覆盖率报告中，因为默认情况下，Jest（和其他测试运行器）将包括你测试类中导入和使用的所有文件——在这个例子中，是`AppComponent`类。你应该关心吗？你需要修复覆盖率百分比中的不足吗？
- en: The answer is it depends on how you run the tests. If you’re running the tests
    for a single file, as we are doing now, you shouldn’t care and should only focus
    on the files related to the unit you’re testing—in our case, the app component.
    After all, you want to write shallow unit tests that only test a single unit of
    code in isolation, so if you have a testing coverage of 80% or higher for the
    files related to the unit you’re testing, everything is good! However, if you’re
    running the unit test for an entire project by omitting the `–test-file` flag,
    you should care about the coverage percentage. For your entire project, you should
    have enough coverage. In this example, the code related to the `translation.service.ts`
    file should be tested in a `translation.service.spec.ts` file. If you run the
    unit tests for the entire project and you cover the logic of your `translation.service.ts`
    file inside the `translation.service.spec.ts` file, you will not have the shortfall
    in your coverage report and the test run will succeed. Now that we have clarified
    that, let’s add our second `it()` function for `app.component.spec.ts`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 答案取决于你如何运行测试。如果你正在为单个文件运行测试，就像我们现在这样，你不必关心，只需关注与你要测试的单元相关的文件——在我们的例子中，是应用组件。毕竟，你想要编写浅层单元测试，只测试单个代码单元，所以如果你对与你要测试的单元相关的文件有80%或更高的测试覆盖率，那就很好！然而，如果你通过省略`–test-file`标志来为整个项目运行单元测试，你应该关心覆盖率百分比。对于你的整个项目，你应该有足够的覆盖率。在这个例子中，与`translation.service.ts`文件相关的代码应该在`translation.service.spec.ts`文件中进行测试。如果你为整个项目运行单元测试，并在`translation.service.spec.ts`文件中覆盖了`translation.service.ts`文件的逻辑，你的覆盖率报告中就不会有缺口，测试运行将成功。现在我们已经澄清了这一点，让我们为`app.component.spec.ts`添加第二个`it()`函数。
- en: The second it() function
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第二个`it()`函数
- en: 'While we have 100% testing coverage for our app-component-related files, our
    test might not give us the confidence we need that everything works as expected.
    We don’t test whether the app component class calls the `setActiveLanguage` method
    when the navbar emits a `languageChange` event, so let’s add a test for this.
    You can add the following code to test whether the app component calls the `setActiveLanguage`
    method when it receives the `languageChange` event:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们对与我们的应用组件相关的文件实现了100%的测试覆盖率，但我们的测试可能无法给我们提供所需的对一切按预期工作的信心。我们没有测试当导航栏发出`languageChange`事件时，应用组件类是否调用`setActiveLanguage`方法，因此让我们为这个功能添加一个测试。你可以添加以下代码来测试当应用组件接收到`languageChange`事件时是否调用`setActiveLanguage`方法：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding code, quite a lot is happening, so let’s examine each line
    carefully.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，发生了很多事情，所以让我们仔细检查每一行。
- en: First, we define the `it()` function and provide it with a description of our
    test case. Inside the callback function, we start by creating a spy element.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义`it()`函数，并为其提供测试用例的描述。在回调函数内部，我们首先创建一个间谍元素。
- en: '`setActiveLanguage` method of the `translationService` property is called.
    Create the spy object by using the `jest.spyOn()` function. Inside the `jest.spyOn()`
    function, first provide the object containing the function you want to spy on
    and then, as a string, the function name you want to spy on.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`translationService`属性的`setActiveLanguage`方法被调用。通过使用`jest.spyOn()`函数创建间谍对象。在`jest.spyOn()`函数内部，首先提供包含你想要监视的函数的对象，然后，作为一个字符串，提供你想要监视的函数名。'
- en: After creating the spy object, we use `debugElement` of `fixture` to access
    `StubNavbarComponent` inside our HTML template and save it in a constant named
    `navBarElement`. Next, we use the `triggerEventHandler` method on `navBarElement`
    to trigger the `languageChange` event and provide `nl` as the event data.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 创建间谍对象后，我们使用`fixture`的`debugElement`来访问HTML模板中的`StubNavbarComponent`，并将其保存在名为`navBarElement`的常量中。接下来，我们在`navBarElement`上使用`triggerEventHandler`方法来触发`languageChange`事件，并提供`nl`作为事件数据。
- en: After triggering the `languageChange` event, we expect that `setActiveLanguage()`
    is called with the `nl` parameter. We check whether this is correct by providing
    the `expect()` function with the `setActiveLanguage` spy object and calling the
    `toHaveBeenCalledWith('nl')` assertion method on the `expect()` function.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 触发`languageChange`事件后，我们期望`setActiveLanguage()`方法使用`nl`参数被调用。我们通过向`expect()`函数提供`setActiveLanguage`间谍对象，并在`expect()`函数上调用`toHaveBeenCalledWith('nl')`断言方法来检查这是否正确。
- en: After adding your second testing case to the `app.component.spec.ts` file, you
    can run the tests again, and you’ll notice that both test cases are successful.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在将第二个测试用例添加到`app.component.spec.ts`文件后，你可以再次运行测试，你会注意到两个测试用例都成功了。
- en: To summarize, you learned that the `describe()` function is used to group test
    cases and the `beforeEach()` function is used to configure `TestBed` and define
    values before each test case runs. The `it()` functions are used to define your
    test cases, and inside the `it()` functions, you use the `expect()` function combined
    with assertion methods to perform your test statements. You can create and use
    spy objects to validate whether functions are called. When writing unit tests,
    you should write shallow unit tests that focus on a single unit of code instead
    of testing the integration of different components and services. You can write
    shallow unit tests and prevent issues with unsupported features by creating stub
    components and services, which are simplified replicas used within your unit tests.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，您了解到`describe()`函数用于分组测试用例，`beforeEach()`函数用于配置`TestBed`并在每个测试用例运行之前定义值。`it()`函数用于定义测试用例，在`it()`函数内部，您使用`expect()`函数结合断言方法来执行测试语句。您可以通过创建和使用间谍对象来验证函数是否被调用。在编写单元测试时，您应该编写浅层单元测试，专注于单个代码单元，而不是测试不同组件和服务的集成。您可以通过创建存根组件和服务来编写浅层单元测试，并防止因不支持的功能而产生问题，这些存根是用于单元测试中的简化副本。
- en: Now that you have a better understanding of unit tests and you’ve created your
    first tests, we will fix the additional spec files of the `expenses-registration`
    component so we can do a successful test run for the application. Additionally,
    you will learn how to run unit tests for multiple projects in your Nx monorepo.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您对单元测试有了更好的理解，并且已经创建了您的第一个测试，我们将修复`expenses-registration`组件的额外spec文件，以便我们可以成功运行应用测试。此外，您还将学习如何在Nx
    monorepo中运行多个项目的单元测试。
- en: Adding additional unit tests for the expenses-registration application
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为支出登记应用添加额外的单元测试
- en: We will now start writing some additional unit tests for the *expenses-registration
    application* so you can successfully run the unit tests for the entire application
    without specifying the `–test-file` flag. To start, we will remove the `expenses-approval-page.component.spec.ts`
    file because we haven’t added any code yet inside the expenses approval component.
    After removing `expenses-approval-page.component.spec.ts`, we will adjust the
    tests inside `expenses-overview-page.component.spec.ts`. We made quite some adjustments
    to the `ExpensesOverviewPageComponent` class, so fixing the related spec file
    will be a bit more work compared to the spec file for `AppComponent`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将开始编写一些额外的单元测试，以便您可以在不指定`–test-file`标志的情况下成功运行整个应用的单元测试。首先，我们将移除`expenses-approval-page.component.spec.ts`文件，因为我们还没有在支出审批组件中添加任何代码。在移除`expenses-approval-page.component.spec.ts`之后，我们将调整`expenses-overview-page.component.spec.ts`中的测试。我们对`ExpensesOverviewPageComponent`类进行了相当多的调整，因此修复相关的spec文件将比修复`AppComponent`的spec文件要费更多功夫。
- en: 'Let’s start by running the unit tests with the following command and see what
    pops up:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下命令开始运行单元测试，看看会出现什么情况：
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It might come as no surprise that the test run fails. Let’s fix the issues with
    the spec file one by one, starting with the import of `ExpensesOverviewPageComponent`
    inside the spec file.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 测试运行失败可能并不令人意外。让我们逐个修复spec文件中的问题，从spec文件中导入`ExpensesOverviewPageComponent`开始。
- en: Adjusting the code inside our other spec file
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调整其他spec文件中的代码
- en: 'Because we changed the export of `ExpensesOverviewPageComponent` to a default
    export, we also need to adjust the import inside the spec file:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将`ExpensesOverviewPageComponent`的导出更改为默认导出，我们还需要调整spec文件中的导入：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After changing the `import` statement, you need to adjust the spec file so
    `TestBed` can successfully create the `expenses-overview` component. Just like
    the app component, the `expenses-overview` component uses `TranslationService`,
    so we will make a mock object for this service (alternatively, you can create
    a stub service for it and also use that inside the spec file of the app component):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在更改`import`语句后，您需要调整spec文件，以便`TestBed`能够成功创建`expenses-overview`组件。就像app组件一样，`expenses-overview`组件使用`TranslationService`，因此我们将为这个服务创建一个模拟对象（或者，您也可以为它创建一个存根服务，并在app组件的spec文件中使用它）：
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you can see in the preceding code, `mockTranslationService` for this spec
    file differs from the `mockTranslationService` class we created for the spec file
    of the app component. The mock objects differ because we only include what we
    use inside the component we are about to test in the mock object; in this case,
    the `expenses-overview` component only uses the `translocoService` and `translationsLoaded`
    properties of the service. Besides `mockTranslationService`, we also need a stub
    for `ExpensesFacade`. You can copy `StubExpensesFacade` from the GitHub repository
    for this book. The `expenses.facade.stub.ts` file is located next to the regular
    `expenses.facade.ts` file inside the finance `data-access` library. After creating
    the mock and stub objects we need for our unit tests, we can create the `beforeEach()`
    function and set up `TestBed`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，此规格文件的`mockTranslationService`与为应用程序组件的规格文件创建的`mockTranslationService`类不同。模拟对象的不同是因为我们只在我们即将测试的组件中包含我们需要的部分在模拟对象中；在这种情况下，`expenses-overview`组件只使用服务的`translocoService`和`translationsLoaded`属性。除了`mockTranslationService`之外，我们还需要为`ExpensesFacade`提供一个存根。您可以从本书的GitHub仓库中复制`StubExpensesFacade`。`expenses.facade.stub.ts`文件位于finance
    `data-access`库中的常规`expenses.facade.ts`文件旁边。在创建了我们的单元测试所需的模拟和存根对象之后，我们可以创建`beforeEach()`函数并设置`TestBed`：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see in the preceding code, we import `ExpensesOverviewPageComponent`
    and `TranslocoTestingModule` using the `getTranslocoModule()` function. After
    the imports for the testing module, we added some providers that needed to configure
    the testing module. We provide `ExpensesFacade` and `TranslationService` with
    the mock and stub values, and we provide the `TranslocoLocale` configuration because
    we use the localization pipes inside the `expenses-overview` page. After configuring
    the imports and providers for the testing module, we created and assigned the
    `fixture` and `component` properties and called `detectChanges()` on `fixture`.
    Now we have configured everything needed to create the component inside `TestBed`,
    let’s remove all `it()` functions and write our own test cases.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，我们使用`getTranslocoModule()`函数导入了`ExpensesOverviewPageComponent`和`TranslocoTestingModule`。在测试模块的导入之后，我们添加了一些需要配置测试模块的提供者。我们使用模拟和存根值提供`ExpensesFacade`和`TranslationService`，并提供了`TranslocoLocale`配置，因为我们使用本地化管道在`expenses-overview`页面中。在配置了测试模块的导入和提供者之后，我们创建了`fixture`和`component`属性，并在`fixture`上调用`detectChanges()`。现在我们已经配置了在`TestBed`内部创建组件所需的所有内容，让我们移除所有`it()`函数并编写我们自己的测试用例。
- en: Writing the test cases
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写测试用例
- en: 'We will create the following test cases:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建以下测试用例：
- en: The test should create the component and initialize the properties correctly.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试应该正确创建组件并初始化属性。
- en: It should fetch expenses on `init`.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该在`init`时获取费用。
- en: It should translate the title if translations are loaded.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果已加载翻译，它应该翻译标题。
- en: It should change `summaryBtnText` if `onSummaryChange` is called.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果调用`onSummaryChange`，它应该更改`summaryBtnText`。
- en: It should call `addExpense` on the expenses facade with the correct values when
    `onAddExpense` is called.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当调用`onAddExpense`时，它应该在费用外观上使用正确的值调用`addExpense`。
- en: 'Now that we have defined our test cases, let’s create them one by one:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的测试用例，让我们逐个创建它们：
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As you can see in the preceding code, this test is really straightforward;
    we simply check whether the component variable is defined and whether each component
    property is initialized with the value we expect. As you may have noticed, we
    used some new assertion methods here, such as `toBeFalsy()` and `toBeInstanceOf()`.
    These assertion methods can be used to check whether a value is false in a Boolean
    context and whether an object is an instance of a specific class. Besides `toBeFalsy()`
    and `toBeInstanceOf()`, we did nothing new in this test, so let’s move on to our
    next test case:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，这个测试非常直接；我们只是简单地检查组件变量是否已定义，以及每个组件属性是否已用我们期望的值初始化。如您可能已注意到的，我们在这里使用了一些新的断言方法，例如`toBeFalsy()`和`toBeInstanceOf()`。这些断言方法可以用来检查在布尔上下文中一个值是否为假，以及一个对象是否是特定类的实例。除了`toBeFalsy()`和`toBeInstanceOf()`之外，在这个测试中我们没有做任何新的操作，所以让我们继续到下一个测试用例：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the preceding test, we create a spy object to spy on the `fetchExpenses()`
    function of `ExpensesFacade`. After that, we call `ngOnInit()` for the component
    we are testing—in this case, the `expenses-overview` page component—and at the
    end of our test, we use the `expect()` function to check whether the `fetchExpenses()`
    function is called. As you can see, calling a method declared in the component
    we are testing is super straightforward; you simply use the `component` variable
    and call the method you want to run. Now that we’ve also covered this test, let’s
    move on to the next test case we defined:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的测试中，我们创建了一个间谍对象来监视`ExpensesFacade`的`fetchExpenses()`函数。之后，我们调用我们正在测试的组件的`ngOnInit()`方法——在这种情况下，是`expenses-overview`页面组件——并在测试的末尾使用`expect()`函数来检查`fetchExpenses()`函数是否被调用。如您所见，调用我们正在测试的组件中声明的方法非常简单；您只需使用`component`变量并调用您想要运行的方法。现在我们已经覆盖了这个测试，让我们继续进行下一个测试用例：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding test, a bit more is going on, and we used some new techniques.
    Let’s explore what we do here in more detail. Because we are testing a signal
    effect in this test and signal effect are asynchronous, we wrapped the callback
    of our `it()` function inside a `fakeAsync()` function. Inside the `fakeAsync()`
    function, times are synchronous. You can manually execute microtasks by calling
    `flushMicroTasks()` and simulating time passing with the `tick()` function. After
    using the `fakeAsync()` function, we first define a spy object. Then, we check
    whether the `translationsLoaded` signal has a false value and that the `translate()`
    function that we use inside our signal effect isn’t called. Next, we set the value
    of the `translationsLoaded` signal to `true`. This should trigger the signal effect
    again, and this time, we should reach the part where we use the `translate()`
    function. Because the signal effect is asynchronous, we first call the `tick()`
    function to simulate the passing of time, and after that, we check whether our
    spy object is called with the correct translation key.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的测试中，发生了一些更多的事情，我们使用了一些新技术。让我们更详细地探索我们在这里做了什么。因为在这个测试中我们正在测试信号效果，而信号效果是异步的，所以我们把`it()`函数的回调包裹在`fakeAsync()`函数内部。在`fakeAsync()`函数内部，时间是同步的。你可以通过调用`flushMicroTasks()`手动执行微任务，并通过`tick()`函数模拟时间的流逝。在使用`fakeAsync()`函数之后，我们首先定义一个间谍对象。然后，我们检查`translationsLoaded`信号是否有假值，以及我们用于信号效果的`translate()`函数没有被调用。接下来，我们将`translationsLoaded`信号值设置为`true`。这应该会再次触发信号效果，这次我们应该到达使用`translate()`函数的部分。因为信号效果是异步的，我们首先调用`tick()`函数来模拟时间的流逝，然后检查我们的间谍对象是否被带有正确翻译键的调用。
- en: 'Now that we have explained the `fakeAsync()` and `tick()` functions used in
    our last test case, let’s continue and add the next test case:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解释了在上一个测试用例中使用的`fakeAsync()`和`tick()`函数，让我们继续并添加下一个测试用例：
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As you can see in the preceding code, this is a simple test. We first check
    whether the `showSummary` signal is false and the `summaryBtnText` computed signal
    returns `onSummaryChange()` function and check whether the `showSummary` signal
    and the `summaryBtnText` computed signal are adjusted correctly. After adding
    the preceding test, there is only one test case to add to our spec file:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的代码中所见，这是一个简单的测试。我们首先检查`showSummary`信号是否为假，以及`summaryBtnText`计算信号返回`onSummaryChange()`函数，并检查`showSummary`信号和`summaryBtnText`计算信号是否调整正确。在添加前面的测试之后，我们只需要将一个测试用例添加到我们的规范文件中：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding test, we first create a spy object to spy on the `addExpense()`
    function of `ExpensesFacade`. After creating the spy object, we create an `expense`
    object to provide to the `onAddExpense()` method. After creating `expense`, we
    call the `onAddExpense()` method and provide it with the `expenseToAdd` property.
    After we call the `onAddExpense()` method, the `addExpense()` function of the
    facade should be called with the `expenseToAdd` property as a function parameter.
    We verify that the `addExpense()` function is called with the correct parameter
    using the `toHaveBeenCalledWith()` assertion method. Lastly, we use the `toContainEqual()`
    assertion method to check whether `expense` is added to the `expenses` signal
    of the `expenses-overview` page component.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试中，我们首先创建了一个spy对象来监视`ExpensesFacade`的`addExpense()`函数。在创建spy对象后，我们创建了一个`expense`对象以提供给`onAddExpense()`方法。在创建`expense`后，我们调用`onAddExpense()`方法并向其提供`expenseToAdd`属性。在调用`onAddExpense()`方法后，门面中的`addExpense()`函数应该以`expenseToAdd`属性作为函数参数被调用。我们使用`toHaveBeenCalledWith()`断言方法验证`addExpense()`函数是否以正确的参数被调用。最后，我们使用`toContainEqual()`断言方法来检查`expense`是否被添加到`expenses-overview`页面组件的`expenses`信号中。
- en: 'After adding the last test case, you can run the tests again using the following
    command:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加最后一个测试用例后，你可以使用以下命令再次运行测试：
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: After you run the tests again, you’ll find that all tests are passing and you
    have 100% coverage for the files related to the `expenses-overview` component.
    You can write some additional tests to test the template, but this will also be
    covered with the e2e tests we will write in the next section. Now that you know
    how to run the unit tests for your individual spec file, let’s examine how to
    run unit tests for one or more projects within your Nx monorepo.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在再次运行测试后，你会发现所有测试都通过了，并且与`expenses-overview`组件相关的文件覆盖率达到了100%。你可以编写一些额外的测试来测试模板，但这也将在下一节中我们将编写的端到端测试中得到覆盖。现在你已经知道了如何运行单个spec文件的单元测试，让我们来看看如何在Nx单仓库中运行一个或多个项目的单元测试。
- en: Running unit tests for one or more projects
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行一个或多个项目的单元测试
- en: 'We ran the unit tests for the spec files one by one, so now let’s run them
    for the entire `finance-expenses-registration` project. When you run the unit
    tests for an entire project, it will run the tests in all spec files found inside
    that Nx project. Note that this will not include any library projects you use
    inside the project. For example, to run the test for all spec files inside the
    `finance-expenses-registration` project, you use the following Terminal command:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们逐个运行了spec文件的单元测试，所以现在让我们运行整个`finance-expenses-registration`项目的单元测试。当你为一个整个项目运行单元测试时，它将在该Nx项目中找到的所有spec文件中运行测试。请注意，这不会包括你在项目中使用的任何库项目。例如，要运行`finance-expenses-registration`项目中的所有spec文件的测试，你使用以下终端命令：
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When you run the preceding command, you’ll notice that the test run fails because
    we do not meet the coverage threshold of 80%. This is because we do not test the
    `translation.service.ts` file. As an exercise, you can create the spec file for
    `TranslationService` yourself; alternatively, you can lower the coverage threshold.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行前面的命令时，你会注意到测试运行失败，因为我们没有达到80%的覆盖率阈值。这是因为我们没有测试`translation.service.ts`文件。作为一个练习，你可以自己创建`TranslationService`的spec文件；或者，你也可以降低覆盖率阈值。
- en: 'Besides running the unit tests for a single project, you can also run unit
    tests for multiple projects at the same time using the `run-many` command. When
    using the `run-many` command without any additional parameters, you will run the
    unit tests for projects found in your entire Nx monorepo:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 除了为单个项目运行单元测试外，你还可以使用`run-many`命令同时运行多个项目的单元测试。当使用不带任何额外参数的`run-many`命令时，你将为在您的整个Nx单仓库中找到的项目运行单元测试：
- en: '[PRE28]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Furthermore, you can add specific project names at the end of the terminal
    command to only run the unit tests for specific projects:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以在终端命令的末尾添加特定的项目名称，以仅运行特定项目的单元测试：
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can also run the unit tests for all projects and exclude specific projects
    from the test run using the `–``exclude` flag:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`--exclude`标志运行所有项目的单元测试，并排除特定项目：
- en: '[PRE30]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Lastly, you can use the `affected` terminal command. The `affected` command
    can be used to run the unit tests for all projects affected by your changes. Nx
    will look at its cache and check what projects have changed since the last time
    the unit tests ran. Any project affected by changes made after the latest cached
    test run will be run when using the `affected` command. The `affected` command
    is particularly useful when you run your unit tests on a build pipeline and want
    to test your code each time you’re merging code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以使用 `affected` 终端命令。`affected` 命令可以用来运行受你更改影响的所有项目的单元测试。Nx 会查看其缓存并检查自上次运行单元测试以来哪些项目已更改。在最新缓存的测试运行之后所做的更改受影响的项目将在使用
    `affected` 命令时运行。当你在构建管道上运行单元测试并希望在每次合并代码时测试你的代码时，`affected` 命令特别有用：
- en: '[PRE31]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: To summarize, you can run tests for individual spec files, for one or more Nx
    projects, or for projects affected by your changes. Unit tests are meant to test
    isolated units and should make you confident that your changes will not break
    your existing code implementations. Unit tests consist of three main parts, the
    `describe()`, `beforeEach()` and `it()` functions, and inside your test cases,
    you assert them using the `expect()` function.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，你可以为单个 spec 文件、一个或多个 Nx 项目，或受你更改影响的项目运行测试。单元测试旨在测试隔离的单元，并应让你有信心你的更改不会破坏现有的代码实现。单元测试由三个主要部分组成，即
    `describe()`、`beforeEach()` 和 `it()` 函数，并在你的测试用例中使用 `expect()` 函数进行断言。
- en: Now that you know how to write and run unit tests, it’s time to dive deeper
    into the topic of e2e tests.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何编写和运行单元测试，是时候更深入地探讨 e2e 测试的话题了。
- en: End-to-end testing of Angular applications using Cypress
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Cypress 对 Angular 应用程序进行端到端测试
- en: 'When you create an application using the Nx CLI or Nx console, two projects
    are created for you: a regular application (in our case, an Angular application)
    and an e2e project configured to test the generated application project using
    the Cypress testing framework. For example, when we created the `expenses-registration`
    project, Nx also created an `expenses-registration-e2e` project. The folder for
    the `expenses-registration-e2e` project is located next to the `expenses-registration`
    project folder.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 Nx CLI 或 Nx 控制台创建应用程序时，为你创建了两个项目：一个常规应用程序（在我们的例子中是一个 Angular 应用程序）和一个配置为使用
    Cypress 测试框架测试生成应用程序项目的 e2e 项目。例如，当我们创建了 `expenses-registration` 项目时，Nx 也创建了一个
    `expenses-registration-e2e` 项目。`expenses-registration-e2e` 项目的文件夹位于 `expenses-registration`
    项目文件夹旁边。
- en: 'Before we start writing our own e2e tests, let’s see what Nx generated for
    us inside the `expenses-registration-e2e` folder. When you open the `expenses-registration-e2e`
    folder, you find some folders and four files. The `.eslintrc.json`, `cypress.config.ts`,
    `project.json`, and `tsconfig.json` files are all meant to configure Cypress and
    the e2e project. We want to adjust one small thing inside the `tsconfig.json`
    file; you can leave the rest of the files untouched. Inside this `tsconfig.json`
    file, you’ll find an `include` array; inside this `include` array, add the following
    string:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写自己的 e2e 测试之前，让我们看看 Nx 在 `expenses-registration-e2e` 文件夹内为我们生成了什么。当你打开
    `expenses-registration-e2e` 文件夹时，你会找到一些文件夹和四个文件。`.eslintrc.json`、`cypress.config.ts`、`project.json`
    和 `tsconfig.json` 文件都是用来配置 Cypress 和 e2e 项目的。我们想在 `tsconfig.json` 文件中调整一个小东西；你可以不修改其他文件。在这个
    `tsconfig.json` 文件中，你会找到一个 `include` 数组；在这个 `include` 数组中，添加以下字符串：
- en: '[PRE32]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Besides the configurations created by Nx, you also want to add one small thing
    inside the `.eslintrc.json` file at the root of your Nx monorepo. Inside the `.eslintrc.json`
    file at the root of your Nx monorepo, you’ll find a `project` array; inside this
    array, add the following value:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Nx 创建的配置之外，你还需要在 Nx monorepo 根目录下的 `.eslintrc.json` 文件中添加一个小东西。在你的 Nx monorepo
    根目录下的 `.eslintrc.json` 文件中，你会找到一个 `project` 数组；在这个数组中，添加以下值：
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Without the two aforementioned additions to your configuration, you will run
    into some ESLint parsing errors. After adding the additional configurations, let’s
    see what else Nx has generated inside the `expenses-registration-e2e` project.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有上述两个配置的添加，你将遇到一些 ESLint 解析错误。添加了额外的配置后，让我们看看 Nx 在 `expenses-registration-e2e`
    项目中又生成了什么。
- en: 'You’ll see a `cypress` folder and an `src` folder inside the `expenses-registration-e2e`
    folder. The `cypress` folder can be ignored; inside the `src` folder, you’ll find
    `e2e`, `fixtures`, and `support` folders that have the following purposes:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在 `expenses-registration-e2e` 文件夹内看到一个 `cypress` 文件夹和一个 `src` 文件夹。`cypress`
    文件夹可以忽略；在 `src` 文件夹内，你会找到 `e2e`、`fixtures` 和 `support` 文件夹，它们具有以下用途：
- en: '`e2e`: Inside the `e2e` folder, you’ll add the files containing your e2e tests.
    Nx already generated an `app.cy.ts` file inside this folder. As you can see, the
    file name ends with `cy.ts`. This is a naming convention for the files containing
    your Cypress e2e tests. The `cy` at the end of your file is short for Cypress.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`e2e`：在`e2e`文件夹中，您将添加包含您的端到端测试的文件。Nx已经在这个文件夹中为您生成了一个`app.cy.ts`文件。如您所见，文件名以`cy.ts`结尾。这是包含您的Cypress端到端测试的文件的命名约定。文件名末尾的`cy`是Cypress的简称。'
- en: '`fixtures`: Inside the `fixture` folder, you can add JSON files containing
    the mock data you want to use inside your e2e test. Using fixtures is useful when
    you want to use specific data for e2e tests. Additionally, you often won’t have
    an API or mocking service you can or want to use during your e2e tests. Adding
    mocking services or APIs in your e2e tests often requires a lot of additional
    setup in both your local environment and in your pipelines where you want to run
    the e2e tests. Besides additional setup, using a real API or the same mocking
    service as your development environment can lead to more instability for your
    e2e test.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fixtures`：在`fixture`文件夹中，您可以添加包含您在端到端测试中想要使用的模拟数据的JSON文件。使用固定数据在您想要为端到端测试使用特定数据时很有用。此外，您在端到端测试期间通常不会有API或模拟服务可以使用或想要使用。在端到端测试中添加模拟服务或API通常需要在您的本地环境中以及您想要运行端到端测试的管道中进行大量的额外设置。除了额外的设置外，使用真实的API或与您的开发环境相同的模拟服务可能会导致您的端到端测试更加不稳定。'
- en: '`support`: Inside the `support` folder, you’ll find everything you need to
    write and run your e2e tests. Some things you place inside the `support` folder
    are a file containing all the imports you use inside the e2e project, a file containing
    page objects used inside your `.cy.ts` files, additional setup files, or files
    with custom Cypress commands.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`support`：在`support`文件夹中，您将找到编写和运行您的端到端测试所需的一切。您放在`support`文件夹中的某些东西包括一个包含您在端到端项目中使用的所有导入的文件，一个包含在您的`.cy.ts`文件中使用的页面对象的文件，额外的设置文件或包含自定义Cypress命令的文件。'
- en: Now that you have an idea of what Nx generated for you and what the files and
    folders inside your e2e project are used for, let’s start to write and run e2e
    tests for the `expenses-registration` project.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了Nx为您生成的以及您端到端项目中文件和文件夹的用途，让我们开始为`expenses-registration`项目编写和运行端到端测试。
- en: Writing your first e2e test
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写您的第一个端到端测试
- en: 'Start by removing the `app.cy.ts` file and replacing it with an `expenses-registration.cy.ts`
    file. Inside this `expenses-registration.cy.ts` file, we will write the e2e tests
    that will test the *expenses-registration application*. As we did with the unit
    tests, we define a `describe()` function. You use the `describe()` function for
    grouping multiple e2e tests, similar to the `describe()` function we used for
    the unit tests. The `describe()` function takes two arguments: a description and
    a callback function:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，删除`app.cy.ts`文件，并用`expenses-registration.cy.ts`文件替换它。在这个`expenses-registration.cy.ts`文件中，我们将编写将要测试`*expenses-registration应用程序*`的端到端测试。就像我们处理单元测试一样，我们定义一个`describe()`函数。您使用`describe()`函数来分组多个端到端测试，类似于我们用于单元测试的`describe()`函数。`describe()`函数接受两个参数：一个描述和一个回调函数：
- en: '[PRE34]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, inside the callback function of the `describe()` function, we will add
    a `beforeEach()` function. Inside the `beforeEach()` function, you can define
    the steps you want to perform before each e2e test. Some common steps defined
    inside the `beforeEach()` function are visiting the URL of your application, setting
    up interceptors, logging in as a user, and closing the cookie consent message.
    In our case, we will only visit the URL of the application, and later, we will
    create an interceptor to demonstrate how you can use the fixtures to provide mocked
    data:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`describe()`函数的回调函数内部，我们将添加一个`beforeEach()`函数。在`beforeEach()`函数内部，您可以定义在每次端到端测试之前要执行的步骤。在`beforeEach()`函数内部定义的一些常见步骤包括访问应用程序的URL、设置拦截器、以用户身份登录以及关闭cookie同意消息。在我们的例子中，我们只访问应用程序的URL，稍后，我们将创建一个拦截器来演示您如何使用固定数据提供模拟数据：
- en: '[PRE35]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding code, we defined the `beforeEach()` function, and inside the
    callback, we visited the base URL of our application using the `visit()` method
    on the `cy` object. The `cy` object is a global helper object provided to you
    by the Cypress framework used for all sorts of things, such as visiting pages,
    accessing page and window objects, reacting to events, setting up interceptors,
    and waiting for requests. In the preceding example, we used the `visit()` method.
    We provided it with an empty string as a function parameter to indicate Cypress
    should visit the base URL of our application.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了`beforeEach()`函数，并在回调函数内部使用`cy`对象上的`visit()`方法访问了我们的应用程序的基本URL。`cy`对象是由Cypress框架提供的全局辅助对象，用于各种操作，例如访问页面、访问页面和窗口对象、响应事件、设置拦截器和等待请求。在前面的示例中，我们使用了`visit()`方法。我们向其提供了一个空字符串作为函数参数，以指示Cypress应访问我们应用程序的基本URL。
- en: 'After defining the `beforeEach()` function and visiting your application base
    URL, let’s add our first simple e2e test. As with unit tests, your test cases
    are defined using the `it()` function. Similar to the unit tests, your `it()`
    functions receive a description and a callback function. Inside the callback function,
    you write the code for your test cases. Let’s start simple and write an e2e test
    to check whether the application redirects to the `expenses-overview` route when
    we visit the base URL:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了`beforeEach()`函数并访问了应用程序的基本URL之后，让我们添加我们的第一个简单的端到端(e2e)测试。与单元测试一样，您的测试用例是通过`it()`函数定义的。与单元测试类似，您的`it()`函数接收一个描述和一个回调函数。在回调函数内部，您编写测试用例的代码。让我们从简单开始，编写一个端到端测试来检查当访问基本URL时，应用程序是否重定向到`expenses-overview`路由：
- en: '[PRE36]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can see in the preceding code, we describe the test case and then write
    the logic for our test case inside the callback of the `it()` function. For the
    prior test case, we only need one line of logic. The `beforeEach()` function will
    open the application on the base URL. When we open our app on the base URL, we
    should be redirected to the `expenses-overview` route, so when we reach the `it()`
    function, the application should be redirected to the `expenses-overview` route.
    In this test case, you only have to assert whether the current URL equals `http://localhost:4200/expenses-overview`.
    In your Cypress tests, you generally get a page or window element and interact
    with them or assert the text, CSS classes, or attributes; in this case, you get
    the browser URL and assert whether the URL equals the text you expect.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，我们描述了测试用例，然后在`it()`函数的回调函数内部编写了我们的测试用例逻辑。对于先前的测试用例，我们只需要一行逻辑。`beforeEach()`函数将在基本URL上打开应用程序。当我们打开基本URL上的应用程序时，我们应该被重定向到`expenses-overview`路由，因此当我们到达`it()`函数时，应用程序应该被重定向到`expenses-overview`路由。在这个测试用例中，您只需断言当前URL是否等于`http://localhost:4200/expenses-overview`。在您的Cypress测试中，您通常获取一个页面或窗口元素，并与它们交互或断言文本、CSS类或属性；在这种情况下，您获取浏览器URL并断言URL是否等于您期望的文本。
- en: The `cy` object exposes most window objects by default; if you want to access
    elements from within the HTML structure of your application, you can use the `.get()`
    method on the `cy` object. In our example, we are interested in the URL, which
    is located in the `location.href` property of the `window` object. The `cy` object
    exposes the `location.href` property by default using the `.``URL()` method.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`cy`对象默认暴露了大多数窗口对象；如果您想从应用程序的HTML结构中访问元素，您可以使用`cy`对象上的`.get()`方法。在我们的示例中，我们感兴趣的是URL，它位于`window`对象的`location.href`属性中。`cy`对象默认通过`.URL()`方法暴露了`location.href`属性。'
- en: 'After you get the element you want to assert, you can chain the `.should()`
    assertion method to make the assertion you want to make. The `.should()` method
    takes in two parameters: an assertion type and a value with which to perform the
    assertion. In our case, we provided the `.should()` method with the `equal` assertion
    type and provided the `http://localhost:4200/expenses-overview` value to check
    whether our provided value equals the element we want to assert—in this instance,
    the URL.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在您获取要断言的元素之后，您可以通过链式`.should()`断言方法来执行您想要的断言。`.should()`方法接受两个参数：一个断言类型和一个用于执行断言的值。在我们的情况下，我们向`.should()`方法提供了`equal`断言类型，并提供了`http://localhost:4200/expenses-overview`值来检查我们提供的值是否等于我们想要断言的元素——在这个例子中，是URL。
- en: 'You can find a list of all assertion types in the official Cypress documentation:
    [https://docs.cypress.io/guides/references/assertions](https://docs.cypress.io/guides/references/assertions).'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方 Cypress 文档中找到所有断言类型的列表：[https://docs.cypress.io/guides/references/assertions](https://docs.cypress.io/guides/references/assertions).
- en: 'Now that we’ve written the first e2e tests and explained how everything works,
    let’s run the e2e test and see whether the test will succeed. You can start your
    e2e tests by running the following terminal command at the root of your Nx monorepo:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了第一个端到端测试并解释了所有工作的原理，让我们运行端到端测试并看看测试是否会成功。您可以通过在您的 Nx 单一代码库的根目录下运行以下终端命令来开始您的端到端测试：
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the preceding command, you need to replace `<project-name>` with the name
    found in the `project.json` file of the e2e project you want to run. Just as with
    the unit tests, you can also run the e2e tests for multiple projects using the
    `run-many` command or for affected projects with the `affected` command.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，您需要将 `<项目名称>` 替换为 `project.json` 文件中找到的名称。就像单元测试一样，您也可以使用 `run-many`
    命令运行多个项目的端到端测试，或者使用 `affected` 命令运行受影响的项目。
- en: When running one of the aforementioned commands, the e2e tests will run headlessly,
    meaning no browser will be opened to execute your e2e tests. Running your e2e
    tests headlessly is ideal if you want to run your tests in a build pipeline or
    another environment where you don’t have access to a browser.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行上述命令之一时，端到端测试将以无头模式运行，这意味着不会打开浏览器来执行您的端到端测试。如果您想在构建管道或没有浏览器访问权限的其他环境中运行测试，无头模式运行端到端测试是理想的。
- en: 'It is nice to see Cypress executing the tests in a real browser during the
    development process. When Cypress executes the tests in a real live browser, you
    can better understand why tests are failing. There is a nice user interface allowing
    you to easily spot what tests are failing and navigate to the specific steps in
    which they’re failing. To run the e2e tests in a real live browser, you can use
    the following command:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中看到 Cypress 在真实浏览器中执行测试是非常好的。当 Cypress 在真实浏览器中执行测试时，您可以更好地理解测试失败的原因。有一个友好的用户界面，让您可以轻松地找到失败的测试，并导航到它们失败的具体步骤。要在一个真实浏览器中运行端到端测试，您可以使用以下命令：
- en: '[PRE38]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'So let’s change the `<project-name>` placeholder with `finance-expenses-registration-e2e`
    and run the test we created:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们将 `<项目名称>` 占位符更改为 `finance-expenses-registration-e2e` 并运行我们创建的测试：
- en: '[PRE39]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As shown in *Figure 11**.1*, the Cypress UI will be started and ask you to
    choose a browser when you run the preceding terminal command:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 11.1* 所示，当您运行前面的终端命令时，Cypress UI 将启动并提示您选择一个浏览器：
- en: '![Figure 11.1: Cypress UI start screen](img/B21625_11_001.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.1：Cypress UI 启动屏幕](img/B21625_11_001.jpg)'
- en: 'Figure 11.1: Cypress UI start screen'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1：Cypress UI 启动屏幕
- en: 'Select the `.cy.ts` files located inside the `e2e` folder of your e2e project;
    in our case, we only have one file, the `expenses-registration.cy.ts` file. When
    you click on the file name, Cypress will run the e2e tests for that specific file.
    In *Figure 11**.2*, you can see what the test run looks like for our `expenses-registration.cy.ts`
    file:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 选择位于您的 e2e 项目的 `e2e` 文件夹中的 `.cy.ts` 文件；在我们的例子中，我们只有一个文件，即 `expenses-registration.cy.ts`
    文件。当您点击文件名时，Cypress 将为该特定文件运行端到端测试。在 *图 11.2* 中，您可以查看 `expenses-registration.cy.ts`
    文件的测试运行情况：
- en: '![Figure 11.2: Cypress UI test run screen](img/B21625_11_002.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.2：Cypress UI 测试运行屏幕](img/B21625_11_002.jpg)'
- en: 'Figure 11.2: Cypress UI test run screen'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2：Cypress UI 测试运行屏幕
- en: As seen in *Figure 11**.2*, on the left side, you can see the tests that are
    being executed and whether they pass or fail, and on the right side, you can see
    the application and what Cypress is doing inside the application.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 11.2* 所示，在左侧，您可以查看正在执行的测试以及它们是否通过或失败，而在右侧，您可以查看应用程序以及 Cypress 在应用程序内部执行的操作。
- en: To summarize, Nx creates an e2e project for each application you generate using
    the Nx cli or Nx console. You create `.cy.ts` files inside the `e2e` folder to
    define your test cases. Test cases are grouped using the `describe()` function
    and the `beforeEach()` function, which can be used to execute logic before each
    e2e test. The test cases themselves are defined using the `it()` function, and
    inside the callback of your `it()` function, you define the test logic. You can
    get elements using the `cy` object and assert values using the `.should()` method
    combined with an assertion type and a value to assert. When you define your tests,
    you can execute them in a real browser or headlessly if you want to run them inside
    an environment where you don’t have access to a browser.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，Nx 使用 Nx cli 或 Nx 控制台为每个生成的应用程序创建一个端到端项目。你在`e2e`文件夹内创建`.cy.ts`文件来定义你的测试用例。测试用例使用`describe()`函数和`beforeEach()`函数分组，后者可以用来在每次端到端测试之前执行逻辑。测试用例本身使用`it()`函数定义，并在你的`it()`函数的回调中定义测试逻辑。你可以使用`cy`对象获取元素，并使用`.should()`方法结合断言类型和值来断言。当你定义测试时，你可以在真实浏览器中执行它们，或者如果你想在无法访问浏览器的环境中运行它们，可以选择无头模式。
- en: Now that you have learned the basics of e2e testing, created your first test,
    and run your test using the Cypress UI, let’s add some extra e2e tests to learn
    about additional concepts and patterns commonly used within e2e testing.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学习了端到端测试的基础，创建了你的第一个测试，并使用 Cypress UI 运行你的测试，让我们添加一些额外的端到端测试来了解在端到端测试中常用的额外概念和模式。
- en: Defining page objects for e2e testing
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义端到端测试的页面对象
- en: A common pattern in e2e testing is the **page object pattern**. When using the
    page object pattern, you abstract the selection of page elements away from the
    actual tests, resulting in more readable and maintainable tests. To demonstrate
    the page object pattern, let’s first create a new e2e test without using the page
    object pattern and then adjust the new test by using the page object pattern.
    The new test case will check whether the **Show summary** button is shown by default,
    and when we click the button, the summary will be shown. Additionally, the test
    checks whether the button text is changed to **Hide summary** and whether the
    summary disappears if we click on the button again.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在端到端测试中，**页面对象模式**是一个常见的模式。当使用页面对象模式时，你将页面元素的选取从实际测试中抽象出来，从而使得测试更加可读和易于维护。为了演示页面对象模式，我们首先创建一个不使用页面对象模式的新的端到端测试，然后通过使用页面对象模式来调整这个新的测试。新的测试用例将检查**显示摘要**按钮是否默认显示，以及当我们点击按钮时，摘要是否会显示。此外，测试还会检查按钮文本是否更改为**隐藏摘要**，以及如果我们再次点击按钮，摘要是否会消失。
- en: 'To create this test case, let’s start by defining the `it()` function and provide
    it with a description for the test case:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这个测试用例，让我们首先定义`it()`函数，并为测试用例提供描述：
- en: '[PRE40]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now that the `it()` function has been defined and we have provided a fitting
    description, we need to add the testing logic inside the callback of the `it()`
    function. First, we need to get the button we used to toggle the summary. As mentioned
    before, you can get elements from within your application using `cy.get()`. You
    provide the `.get()` method with a query selector; these selectors work identically
    to jQuery selectors:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经定义了`it()`函数，并提供了合适的描述，我们需要在`it()`函数的回调中添加测试逻辑。首先，我们需要获取用于切换摘要的按钮。如前所述，你可以使用`cy.get()`从你的应用程序中获取元素。你向`.get()`方法提供一个查询选择器；这些选择器与
    jQuery 选择器工作方式相同：
- en: '[PRE41]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the preceding code snippet, you can see we use `cy.get()` and provide it
    with the query selector to get the **Show summary** button. If you’re not familiar
    with jQuery selectors, you can alternatively copy the selector through the **DevTools**
    of the Chrome browser. Simply inspect the HTML page, find the element you want
    to use inside your Cypress test in your **DevTools**, right-click on the element,
    and select **Copy** | **Copy selector**. In *Figure 11**.3*, you can see where
    you can copy the selector:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，你可以看到我们使用了`cy.get()`并提供查询选择器来获取**显示摘要**按钮。如果你不熟悉 jQuery 选择器，你可以通过
    Chrome 浏览器的**DevTools**复制选择器。简单地检查 HTML 页面，找到你想要在 Cypress 测试中使用的元素，在**DevTools**中右键点击该元素，选择**复制**|**复制选择器**。在*图
    11*.*3*中，你可以看到你可以复制选择器的位置：
- en: '![Figure 11.3: DevTools Copy selector](img/B21625_11_003.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3：DevTools 复制选择器](img/B21625_11_003.jpg)'
- en: 'Figure 11.3: DevTools Copy selector'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3：DevTools 复制选择器
- en: 'The selectors copied using the **DevTools** always start at the root of your
    HTML document and can be simplified by removing the beginning of the selector.
    Now that you know how to select elements so you can use them within your tests,
    let’s write the rest of the test logic:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**DevTools**复制的选取器始终从HTML文档的根开始，可以通过删除选取器的前缀来简化。现在你知道了如何选择元素以便在测试中使用，让我们编写测试逻辑的其余部分：
- en: '[PRE42]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the preceding code, we first define two constants, one for `button` and one
    for `summary`. As you can see, we use a function that returns the `cy.get()` method.
    Directly assigning the return value of `cy.get()` to a variable is an anti-pattern
    because you can modify the return value during your tests. Commonly, when you
    get the button, you want to get it unmodified, so we create a function that returns
    the `cy.get()` function call and assign that to our variables.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先定义了两个常量，一个用于`button`，另一个用于`summary`。正如你所见，我们使用了一个返回`cy.get()`方法的函数。直接将`cy.get()`的返回值赋给变量是一种反模式，因为在测试过程中你可以修改返回值。通常，当你获取按钮时，你希望获取一个未经修改的按钮，所以我们创建了一个返回`cy.get()`函数调用的函数，并将其赋值给我们的变量。
- en: After defining the two constants, we check whether the button contains the **Show
    summary** text and whether the summary element doesn’t exist yet. Afterward, we
    click the button and check whether the button text is changed to **Hide summary**
    and whether the summary element exists. Lastly, we click the button again and
    see if everything is toggled back to its initial state.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了两个常量之后，我们检查按钮是否包含**显示摘要**文本，以及摘要元素是否尚未存在。之后，我们点击按钮，检查按钮文本是否更改为**隐藏摘要**，以及摘要元素是否存在。最后，我们再次点击按钮，看看是否一切都被切换回初始状态。
- en: 'If you run your e2e tests now, you’ll find that the test succeeds. While there
    is nothing wrong with this test, there are some things we can do to clean it up
    a bit. First, we can simplify the selectors by adding a `data-test-id` attribute
    on the HTML elements we want to select. The `data-test-id` attribute is a simple
    HTML attribute commonly added to elements you want to use in your e2e tests. So,
    let’s add the attribute to the button and summary element inside your `expenses-overview-page.component.html`
    file:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行你的e2e测试，你会发现测试成功。虽然这个测试没有问题，但我们还可以做一些事情来稍微清理一下。首先，我们可以通过在想要选择的HTML元素上添加`data-test-id`属性来简化选取器。`data-test-id`属性是一个简单的HTML属性，通常添加到你想要在e2e测试中使用的元素上。所以，让我们在`expenses-overview-page.component.html`文件中的按钮和摘要元素上添加这个属性：
- en: '[PRE43]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '<td data-test-id attributes, you can simplify the selectors used inside your
    e2e test. Instead of the long selector used to select the button and summary elements,
    you can use the following syntax:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`data-test-id`属性，你可以简化e2e测试内部使用的选取器。而不是使用用于选择按钮和摘要元素的长选取器，你可以使用以下语法：
- en: '[PRE44]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As you can see, this dramatically simplifies the selectors for your HTML elements.
    Besides simplifying the selectors by introducing the `data-test-id` attributes,
    you can create a function that checks the button text and checks whether the summary
    element exists. You don’t have to repeat it three times inside your test.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，这大大简化了HTML元素的选取器。除了通过引入`data-test-id`属性简化选取器外，你还可以创建一个函数来检查按钮文本，并检查是否存在摘要元素。你不需要在测试内部重复三次。
- en: 'Now that we have defined the logic for the test case, it’s time to improve
    it and move some logic to the page object file. Start by removing the `app.po.ts`
    file from the support folder and adding a `new expenses-overview.po.ts` file.
    As you might have figured out, the `.po.ts` is short for `.page-object.ts`. Inside
    the `expenses-overview.po.ts` file, you will define all the logic to get the elements
    needed for the e2e tests for the `expenses-overview` page. By abstracting the
    element selection to this page object file, you can easily reuse them, making
    your e2e tests smaller and easier to read, write, and maintain. Currently, we
    only have two elements we can move to the page object file—the summary button
    and the summary element:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了测试用例的逻辑，是时候改进它并将一些逻辑移动到页面对象文件中。首先，从支持文件夹中删除`app.po.ts`文件，并添加一个`new
    expenses-overview.po.ts`文件。正如你可能已经猜到的，`.po.ts`是`.page-object.ts`的简称。在`expenses-overview.po.ts`文件中，你将定义所有用于`expenses-overview`页面e2e测试所需的元素逻辑。通过将元素选择抽象到页面对象文件中，你可以轻松地重用它们，使你的e2e测试更小、更容易阅读、编写和维护。目前，我们只有两个元素可以移动到页面对象文件中——摘要按钮和摘要元素：
- en: '[PRE45]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the preceding code snippet, you can see that we moved the two constants defined
    inside the test case to the page object file and exported them so they can be
    accessed inside the e2e tests. We also gave the two constants a more descriptive
    name. Now, inside the `expenses-registration.cy.ts` file, import the two constants
    and adjust the e2e test to use the imported constants. If you now need the button
    or summary type in another e2e test, you can simply use the one defined inside
    the page object file instead of redefining the logic to get the element.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，您可以看到我们将测试用例内部定义的两个常量移动到了页面对象文件中，并导出它们以便在端到端测试中使用。我们还给这两个常量起了更具有描述性的名字。现在，在`expenses-registration.cy.ts`文件中，导入这两个常量，并调整端到端测试以使用导入的常量。如果您现在需要在另一个端到端测试中使用按钮或摘要类型，您可以直接使用页面对象文件中定义的，而不是重新定义获取元素的逻辑。
- en: 'Inside the page object file, we can also add the function to check the `toggle
    summary button` text and the visibility of the summary itself:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面对象文件中，我们还可以添加一个函数来检查`切换摘要按钮`文本和摘要本身的可见性：
- en: '[PRE46]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'After adding the preceding function, let’s update the e2e test to use the function
    and see the final result after adding the page object file:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加上述函数后，让我们更新端到端测试以使用该函数，并查看添加页面对象文件后的最终结果：
- en: '[PRE47]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As you can see in the preceding code, now that we use the page object pattern,
    the test is much easier to understand and needs fewer lines of code; besides that,
    the code is easier to reuse in new test cases.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的代码中看到的，现在我们使用了页面对象模式，测试变得更加容易理解，并且需要的代码行数更少；除此之外，代码在新的测试用例中更容易重用。
- en: To summarize, you select elements using the `cy.get()` method combined with
    selectors identical to jQuery selectors. To simplify your selectors, you can use
    `data-test-id` attributes, and by using the page object pattern, you can abstract
    the element selection logic away from your test cases, making your tests easier
    to read, write, and maintain. Now that you have a better grasp of how to select
    elements and how the page object pattern can help you write better e2e tests,
    let’s learn how to intercept requests and use mock data from your fixtures inside
    your e2e tests.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，您可以使用`cy.get()`方法和与jQuery选择器相同的选择器来选择元素。为了简化您的选择器，您可以使用`data-test-id`属性，并且通过使用页面对象模式，您可以将元素选择逻辑从测试用例中抽象出来，使测试更容易阅读、编写和维护。现在您已经更好地掌握了如何选择元素以及页面对象模式如何帮助您编写更好的端到端测试，让我们学习如何在端到端测试中拦截请求并使用固定数据中的模拟数据。
- en: Using fixtures in your e2e tests
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在端到端测试中使用固定数据
- en: Fixtures are used to provide your e2e tests with specific mock data. Using mock
    data for your e2e tests ensures that you have stable data with which to run your
    e2e tests. Often, you need to run your e2e tests in an environment where you don’t
    have access to an API or mocking service; in this case, you can use the data defined
    in your fixtures. Another common scenario is that you run your e2e tests in your
    test or acceptance environment, and the data on these environments isn’t always
    stable and might change over time, resulting in failing tests. So, depending on
    your environment, fixtures can provide you with additional stability, ensuring
    that your tests don’t fail based on the data but only fail if you actually break
    something within your application code.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 固定数据用于为您的端到端测试提供特定的模拟数据。使用模拟数据为您的端到端测试确保您有稳定的数据来运行测试。通常，您需要在没有访问API或模拟服务的环境中运行端到端测试；在这种情况下，您可以使用固定数据中定义的数据。另一个常见场景是您在测试或验收环境中运行端到端测试，而这些环境中的数据并不总是稳定的，可能会随时间变化，导致测试失败。因此，根据您的环境，固定数据可以为您提供额外的稳定性，确保测试不会因为数据而失败，而只会因为您实际上在应用程序代码中破坏了某些内容而失败。
- en: 'Let’s first run the e2e tests in production mode to demonstrate why you need
    fixtures. Our `mock.interceptor.ts` file will not return the mock data if we serve
    a production build of our application. You can use the following terminal command
    to run the e2e tests with a production build of the application:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先以生产模式运行端到端测试，以展示为什么您需要固定数据。如果我们提供应用的生产构建版本，我们的`mock.interceptor.ts`文件将不会返回模拟数据。您可以使用以下终端命令以应用的生产构建版本运行端到端测试：
- en: '[PRE48]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: After running the preceding command, you’ll notice the application doesn’t have
    any data to display during the e2e tests. For our current test cases, this is
    no issue, but when you have more tests, this will most likely result in some failing
    tests. Instead of relying on `mock.interceptor.ts`, we can use the fixtures to
    provide data during the e2e tests.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行前面的命令后，你会注意到在端到端测试期间应用程序没有数据可以显示。对于我们当前的测试用例，这没有问题，但当你有更多测试时，这很可能会导致一些测试失败。我们不必依赖于`mock.interceptor.ts`，可以使用固定装置在端到端测试期间提供数据。
- en: To use the data from your fixtures, you first need to add a file with mock data
    inside the `fixtures` folder. We will use the same mock data as we use for our
    mock interceptor, so start by copying the `expenses.json` file inside the `assets/api`
    folder from your *expenses-registration application* to the `fixtures` folder
    of your e2e project.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用固定装置中的数据，你首先需要在`fixtures`文件夹内添加一个包含模拟数据的文件。我们将使用与我们的模拟拦截器相同的模拟数据，所以首先将`assets/api`文件夹中的`expenses.json`文件从你的*费用注册应用程序*复制到端到端项目的`fixtures`文件夹。
- en: 'After copying the `expenses.json` file, you need to adjust the `beforeEach()`
    function inside the `expenses-registration.cy.ts` file. Inside the `beforeEach()`
    function, you need to set up an interceptor to intercept the API request we make
    to get the expenses and provide it with a file from your fixtures:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在复制`expenses.json`文件后，你需要调整`expenses-registration.cy.ts`文件中的`beforeEach()`函数。在`beforeEach()`函数内部，你需要设置一个拦截器来拦截我们获取费用的API请求，并向其提供一个来自你的固定装置的文件：
- en: '[PRE49]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the preceding code, you can see we set up the interceptor using the `cy.intercept()`
    method. The `cy.intercept()` method first takes a string to define what type of
    API request you want to intercept; in our case, we want to intercept a `GET` request.
    Next, you need to provide the API URL you want to intercept, and lastly, you need
    to provide an object with a fixture property assigned with the fixture file you
    want to use as a response for the intercepted request. At the end of the `cy.intercept()`
    method, we chain the `.as()` method and provide that with an alias for the interceptor;
    in this case, we used `getExpenses`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你可以看到我们使用`cy.intercept()`方法设置了拦截器。`cy.intercept()`方法首先接受一个字符串来定义你想要拦截的API请求类型；在我们的情况下，我们想要拦截一个`GET`请求。接下来，你需要提供你想要拦截的API
    URL，最后，你需要提供一个对象，其中包含一个固定属性，分配给你想要用作拦截请求响应的固定文件。在`cy.intercept()`方法的末尾，我们链式调用`.as()`方法，并为其提供一个拦截器的别名；在这种情况下，我们使用了`getExpenses`。
- en: After setting up the interceptor, we define the `cy.visit()` method to visit
    the application page, just like we did before. After the `cy.visit()` method,
    we define the `cy.wait()` method, indicating that Cypress must wait for the interceptor
    we set up. Then, provide the `cy.wait()` method with the interceptor alias prefixed
    with an `@` sign.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置拦截器之后，我们定义了`cy.visit()`方法来访问应用页面，就像我们之前做的那样。在`cy.visit()`方法之后，我们定义了`cy.wait()`方法，表示Cypress必须等待我们设置的拦截器。然后，向`cy.wait()`方法提供以`@`符号为前缀的拦截器别名。
- en: The preceding steps involve everything required to use the fixture file for
    your mock data during the e2e tests. If you need to set up the same interceptor
    and visit the same page for multiple testing files, you can abstract the logic
    away into a function and call that function inside the `beforeEach()` callback
    so that you don’t have to repeat yourself multiple times.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的步骤涉及在端到端测试中使用固定文件进行模拟数据所需的所有内容。如果你需要为多个测试文件设置相同的拦截器和访问相同的页面，你可以将逻辑抽象成一个函数，并在`beforeEach()`回调内部调用该函数，这样你就不必多次重复。
- en: 'You can test whether the interceptor and fixture work by running the e2e tests
    in production using the following command:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在生产环境中运行以下命令来测试拦截器和固定装置是否工作：
- en: '[PRE50]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: After running the preceding command, you’ll notice that the application shows
    data again when running the e2e tests.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行前面的命令后，你会注意到在运行端到端测试时应用程序再次显示数据。
- en: To summarize, you learned that fixtures can be used to provide mock data during
    your e2e tests. Using mock data can provide your tests with additional stability
    and help you run them in an environment where you don’t have access to an API
    or mocking service. You use fixtures by setting up an interceptor in the `beforeEach()`
    function of your tests and providing the interceptor with the fixture file.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，你了解到固定装置可以在端到端测试期间提供模拟数据。使用模拟数据可以为你的测试提供额外的稳定性，并帮助你在一个无法访问API或模拟服务的环境中运行测试。你通过在测试的`beforeEach()`函数中设置拦截器并提供固定文件来使用固定装置。
- en: Summary
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about automated application testing. You learned
    that unit tests are used to test small code units in isolation to ensure the code
    implantation works as expected. e2e testing tests applications from the user’s
    perspective and checks whether the correct values are displayed and user interactions
    are processed and rendered correctly in the application view. Component testing
    is a relatively new concept, comparable to e2e testing, but instead of compiling
    and testing an entire application, component testing focuses on testing a single
    component from the perspective of a user. Lastly, integration tests are used to
    check how different modules and elements of your software integrate together.
    Integration tests can be implemented on various levels, for example, to check
    whether code implementation remains working when you combine multiple components
    and services or whether your application still works when you combine and deploy
    various Angular applications and backend APIs as a single product for your customers.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了自动化应用程序测试。你了解到单元测试用于独立测试小的代码单元，以确保代码实现按预期工作。端到端测试从用户的角度测试应用程序，并检查是否正确显示了值，以及用户交互是否在应用程序视图中正确处理和渲染。组件测试是一个相对较新的概念，与端到端测试类似，但不同的是，组件测试不是编译和测试整个应用程序，而是从用户的角度测试单个组件。最后，集成测试用于检查软件的不同模块和元素如何集成在一起。集成测试可以在多个级别上实现，例如，检查在组合多个组件和服务时代码实现是否仍然工作，或者当将多个Angular应用程序和后端API作为单一产品提供给客户时，应用程序是否仍然工作。
- en: After learning about the different types of tests, you created your own unit
    and e2e tests. You learned about the `describe()`, `beforeEach()`, and `its()`
    functions and how they can be used for e2e and unit tests. You learned how to
    use mock data in e2e tests and stub components and services in your unit tests.
    Asserting values in unit tests is done using the `expect()` function, and in e2e
    tests, you use the `cy.should()` method.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了不同类型的测试之后，你创建了属于自己的单元测试和端到端测试。你学习了`describe()`、`beforeEach()`和`its()`函数，以及它们如何用于端到端和单元测试。你学习了如何在端到端测试中使用模拟数据，以及在单元测试中模拟组件和服务。在单元测试中，使用`expect()`函数断言值，而在端到端测试中，你使用`cy.should()`方法。
- en: Lastly, you learned about different terminal commands to run tests for individual
    files, single projects, multiple projects, or projects that are affected by your
    changes. In the next and final chapter of this book, you’ll add the finishing
    touches and learn about the different steps you need to take to deploy Angular
    applications in your Nx monorepo.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你学习了不同的终端命令来运行单个文件、单个项目、多个项目或受你更改影响的项目上的测试。在本书的下一章和最后一章中，你将添加最后的修饰，并学习部署Angular应用程序到你的Nx单仓库所需采取的不同步骤。
- en: '[PRE51]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
