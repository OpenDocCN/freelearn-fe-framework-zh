- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: RESTful APIs and Full-Stack Implementation
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RESTful API 和全栈实现
- en: In *Chapter 1*, *Introduction to Angular and Its Concepts*, I introduced you
    to the wider architecture in which web applications exist. The choices that are
    made in full-stack architecture can profoundly impact the success of your web
    application. You simply cannot afford to be ignorant of how the APIs you interact
    with are designed. In this chapter, we are going to cover how to implement a backend
    for your frontend using Node, Express, and Mongo. Combined with Angular, this
    stack of software is referred to as the MEAN stack.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第一章*，*Angular 简介及其概念* 中，我向你介绍了网络应用程序存在的更广泛的架构。在全栈架构中做出的选择可能会深刻影响你网络应用程序的成功。你绝对不能忽视你交互的
    API 是如何设计的。在本章中，我们将介绍如何使用 Node、Express 和 Mongo 为你的前端实现后端。结合 Angular，这个软件堆栈被称为
    MEAN 堆栈。
- en: My take on the MEAN stack is minimal MEAN, which prioritizes ease of use, happiness,
    and effectiveness, the main ingredients for a great **developer experience** (**DX**).
    To keep up with the theme, we'll implement the LemonMart server. This server will
    round out JWT auth from *Chapter 8*, *Designing Authentication and Authorization*.
    In addition, the server will support recipes that I am going to cover in *Chapter
    11*, *Recipes – Reusability, Routing, and Caching*, and *Chapter 12*, *Recipes
    – Master/Detail, Data Tables, and NgRx*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我对 MEAN 堆栈的看法是“最小化 MEAN”，它优先考虑易用性、幸福感和效率，这是优秀 **开发者体验**（**DX**）的主要成分。为了保持主题一致，我们将实现
    LemonMart 服务器。这个服务器将完善来自 *第 8 章*，*设计认证和授权* 的 JWT 认证。此外，服务器还将支持我在 *第 11 章*，*食谱
    – 可重用性、路由和缓存* 和 *第 12 章*，*食谱 – 主/详细、数据表和 NgRx* 中将要介绍的功能。
- en: This chapter covers a lot of ground. It is designed to serve as a roadmap to
    the GitHub repository ([https://github.com/duluca/lemon-mart-server](https://github.com/duluca/lemon-mart-server)).
    I cover the architecture, design, and major components of the implementation.
    I highlight important pieces of code to explain how the solution comes together.
    However, unlike prior chapters, you cannot solely rely on the code sample provided
    in the text to complete your implementation. For the purposes of this book, it
    is more important that you understand why we are implementing various functionality
    over having a strong grasp of the implementation details. So, for this chapter,
    I recommend that you read and understand the server code versus trying to recreate
    it on your own.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了大量的内容。它旨在作为 GitHub 仓库 ([https://github.com/duluca/lemon-mart-server](https://github.com/duluca/lemon-mart-server))
    的路线图。我涵盖了实现架构、设计和主要组件。我强调了一些重要的代码片段来解释解决方案是如何组合在一起的。然而，与前面的章节不同，你不能仅仅依靠文本中提供的代码示例来完成你的实现。对于本书的目的，理解我们为什么要实现各种功能比掌握实现细节更为重要。因此，对于这一章，我建议你阅读并理解服务器代码，而不是试图自己重新创建它。
- en: You will need to take action towards the end of the chapter to implement a custom
    auth provider in your Angular app to authenticate against **lemon-mart-server**
    and also leverage Postman to generate test data, which will be useful in later
    chapters.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在章节的末尾采取行动，在你的 Angular 应用中实现一个自定义认证提供者，以对 **lemon-mart-server** 进行认证，并利用
    Postman 生成测试数据，这在后面的章节中将会很有用。
- en: We begin by covering full-stack architecture, covering lemon-mart-server's monorepo
    design and how you can use Docker Compose to run a three-tier application with
    a web app, server, and a database. Then, we go over RESTful API design and documentation,
    leveraging the OpenAPI specification using [Swagger.io](http://Swagger.io), and
    implementation using Express.js. Then, we cover the implementation of a MongoDB
    **object document mapper** (**ODM**) using my DocumentTS library to store users
    with login credentials. We implement a token-based auth function and use it to
    secure our APIs. Finally, we leverage Postman to generate test data in our database
    using the APIs we have developed.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先介绍全栈架构，涵盖 lemon-mart-server 的单仓库设计以及如何使用 Docker Compose 运行一个包含 Web 应用、服务器和数据库的三层应用程序。然后，我们介绍
    RESTful API 设计和文档，利用 OpenAPI 规范通过 [Swagger.io](http://Swagger.io) 和使用 Express.js
    的实现。然后，我们介绍使用我的 DocumentTS 库实现 MongoDB 的 **对象文档映射器**（**ODM**），用于存储带有登录凭证的用户。我们实现了一个基于令牌的认证功能，并使用它来保护我们的
    API。最后，我们利用 Postman 使用我们开发的 API 在数据库中生成测试数据。
- en: 'In this chapter, you will learn about the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: Full-stack architecture
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全栈架构
- en: Docker Compose
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose
- en: RESTful APIs
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RESTful API
- en: MongoDB ODM with DocumentTS
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB ODM with DocumentTS
- en: Implementing JWT auth
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现JWT认证
- en: Generating users with Postman
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Postman生成用户
- en: The most up-to-date versions of the sample code for the book can be found on
    GitHub at the repository linked below. The repository contains the final and completed
    state of the code. This chapter requires Docker and Postman applications.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 书籍示例代码的最新版本可以在以下链接的GitHub仓库中找到。该仓库包含代码的最终和完成状态。本章需要Docker和Postman应用程序。
- en: It is critical that you get **lemon-mart-server** up and running on your development
    environment and have **lemon-mart** communicate with it. Refer to the instructions
    documented here or in the `README` on GitHub to get your server up and running.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的开发环境中运行**lemon-mart-server**并使其与**lemon-mart**通信是至关重要的。请参阅此处或GitHub上的`README`中的说明以启动您的服务器。
- en: 'In the case of this *chapter*:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的情况：
- en: 'Clone the **lemon-mart-server** repository using the `--recurse-submodules`
    option: `git clone --recurse-submodules` [https://github.com/duluca/lemon-mart-server](https://github.com/duluca/lemon-mart-server
    )'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`--recurse-submodules`选项克隆**lemon-mart-server**仓库：`git clone --recurse-submodules`
    [https://github.com/duluca/lemon-mart-server](https://github.com/duluca/lemon-mart-server)
- en: In the VS Code terminal, execute `cd web-app; git checkout master` to ensure
    that the submodule from [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)
    is on the master branch.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code终端中，执行`cd web-app; git checkout master`以确保来自[https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)的子模块位于master分支。
- en: Later, in the *Git submodules* section, you can configure the `web-app` folder
    to pull from your lemon-mart server.
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在后面的**Git子模块**部分，您可以配置`web-app`文件夹以从您的lemon-mart服务器拉取。
- en: Execute `npm install` on the root folder to install dependencies.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根目录下执行`npm install`以安装依赖项。
- en: Note that running the `npm install` command on the root folder triggers a script,
    which also installs dependencies under the `server` and `web-app` folders.
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，在根目录下运行`npm install`命令会触发一个脚本，该脚本还会在`server`和`web-app`文件夹下安装依赖项。
- en: Execute `npm run init:env` on the root folder to configure environment variables
    in `.env` files.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根目录下执行`npm run init:env`以配置`.env`文件中的环境变量。
- en: This command will create two `.env` files, one on the root folder and the other
    under the `server` folder, to contain your private configuration information.
    The initial files are generated based on the `example.env` file. You can modify
    these files later and set your own secure secrets.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令将在根目录和`server`文件夹下创建两个`.env`文件，用于包含您的私有配置信息。初始文件基于`example.env`文件生成。您可以在以后修改这些文件并设置自己的安全密钥。
- en: Execute `npm run build` on the root folder, which builds both the server and
    the web app.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根目录下执行`npm run build`以构建服务器和Web应用。
- en: Note that the web app is built using a new configuration named `--configuration=lemon-mart-server`,
    which uses `src/environments/environment.lemon-mart-server.ts`.
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，该Web应用是使用名为`--configuration=lemon-mart-server`的新配置构建的，它使用`src/environments/environment.lemon-mart-server.ts`。
- en: Execute `docker-compose up --build` to run containerized versions of the server,
    web app, and a MongoDB database.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`docker-compose up --build`以运行服务器、Web应用和MongoDB数据库的容器化版本。
- en: Note that the web app is containerized using a new file named `nginx.Dockerfile`.
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，Web应用使用名为`nginx.Dockerfile`的新文件进行容器化。
- en: Navigate to `http://localhost:8080` to view the web app.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`http://localhost:8080`以查看Web应用。
- en: To log in, click on the **Fill** button to populate the email and password fields
    with the default demo credentials.
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 登录时，单击**填写**按钮以使用默认的演示凭据填充电子邮件和密码字段。
- en: Navigate to `http://localhost:3000` to view the server landing page.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`http://localhost:3000`以查看服务器登录页面。
- en: Navigate to `http://localhost:3000/api-docs` to view interactive API documentation.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`http://localhost:3000/api-docs`以查看交互式API文档。
- en: You can use `npm run start:database` to only start the database, and `npm start`
    on the `server` folder for debugging.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用`npm run start:database`仅启动数据库，并在`server`文件夹下使用`npm start`进行调试。
- en: You can use `npm run start:backend` to only start the database and the server,
    and `npm start` on the `web-app` folder for debugging.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用`npm run start:backend`仅启动数据库和服务器，并在`web-app`文件夹下使用`npm start`进行调试。
- en: 'In the case of examples from this *chapter* that are based on **lemon-mart**:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章中基于**lemon-mart**的示例：
- en: 'Clone the repository: [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart
    )'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆仓库：[https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)
- en: Execute `npm install` on the root folder to install dependencies.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根目录下执行`npm install`以安装依赖项。
- en: 'The code sample for this chapter is available under the sub-folder:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此章节的代码示例位于子文件夹下：
- en: '[PRE0]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To run the Angular app for this chapter, execute the following command:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要为此章节运行Angular应用程序，请执行以下命令：
- en: '[PRE1]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To run Angular unit tests for this chapter, execute the following command:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要为此章节运行Angular单元测试，请执行以下命令：
- en: '[PRE2]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To run Angular e2e tests for this chapter, execute the following command:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要为此章节运行Angular e2e测试，请执行以下命令：
- en: '[PRE3]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To build a production-ready Angular app for this chapter, execute the following
    command:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要为此章节构建一个生产就绪的Angular应用程序，请执行以下命令：
- en: '[PRE4]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that the `dist/ch10` folder at the root of the repository will contain
    the compiled result.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，存储库根目录下的`dist/ch10`文件夹将包含编译结果。
- en: Beware that the source code in the book or on GitHub may not always match the
    code generated by the Angular CLI. There may also be slight differences in implementation
    between the code in the book and what's on GitHub because the ecosystem is ever-evolving.
    It is natural for the sample code to change over time. Also, on GitHub, expect
    to find corrections, fixes to support newer versions of libraries, or side-by-side
    implementations of multiple techniques for the reader to observe. The reader is
    only expected to implement the ideal solution recommended in the book. If you
    find errors or have questions, please create an issue or submit a pull request
    on GitHub for the benefit of all readers.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，书中或GitHub上的源代码可能并不总是与Angular CLI生成的代码匹配。由于生态系统不断演变，书中代码与GitHub上代码之间的实现也可能存在细微差异。随着时间的推移，示例代码发生变化是自然的。此外，在GitHub上，你可能会找到更正、修复以支持库的新版本，或者为读者观察而并排实现多种技术的示例。读者只需实现书中推荐的理想解决方案即可。如果你发现错误或有疑问，请为所有读者创建一个GitHub问题或提交一个pull
    request。
- en: You can read more about updating Angular in the *Appendix C*, *Keeping Angular
    and Tools Evergreen*. You can find this appendix online from [https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.pdf](https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.)
    or at [https://expertlysimple.io/stay-evergreen](https://expertlysimple.io/stay-evergreen).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在附录C“保持Angular和工具常青”中了解更多关于更新Angular的信息。你可以在网上从[https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.pdf](https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.)或[https://expertlysimple.io/stay-evergreen](https://expertlysimple.io/stay-evergreen)找到这个附录。
- en: With your LemonMart server up and running, we are ready to explore the architecture
    of the MEAN stack. By the end of this section, you should have your own version
    of LemonMart communicating with the server.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的LemonMart服务器运行起来后，我们就可以探索MEAN栈的架构了。到本节结束时，你应该有自己的LemonMart版本与服务器通信。
- en: Full-stack architecture
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全栈架构
- en: Full-stack refers to the entire stack of software that makes an application
    work, all the way from databases to servers, APIs, and the web and/or mobile apps
    that leverage them. The mythical full-stack developer is all-knowing and can comfortably
    operate in all verticals of the profession. It is next to impossible to specialize
    in all things software-related and to be considered an expert in relation to every
    given topic. However, to be considered an expert in a single topic, you must also
    be well-versed in related topics. When learning a new topic, it is very helpful
    to keep your tooling and language consistent so that you can absorb the new information
    without additional noise. For these reasons, I opted to introduce you to the MEAN
    stack over Spring Boot using Java or ASP.NET using C#. By sticking to familiar
    tools and languages such as TypeScript, VS Code, npm, GitHub, Jasmine, Docker,
    and CircleCI, you can better understand how a full-stack implementation comes
    together and become a better web developer as a result.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 全栈指的是使应用程序工作的整个软件栈，从数据库到服务器、API以及利用它们的Web和/或移动应用程序。传说中的全栈开发者无所不知，可以轻松地在职业的各个垂直领域操作。在所有与软件相关的事物中专业化，并被认为是每个给定主题的专家，几乎是不可能的。然而，要被认为是某个主题的专家，你也必须对相关主题有深入的了解。在学习新主题时，保持你的工具和语言一致非常有帮助，这样你就可以在没有额外噪音的情况下吸收新信息。因此，我选择用Java或C#使用ASP.NET介绍你使用MEAN栈而不是Spring
    Boot。通过坚持使用熟悉的工具和语言，如TypeScript、VS Code、npm、GitHub、Jasmine、Docker和CircleCI，你可以更好地理解全栈实现是如何结合在一起的，并因此成为一个更好的Web开发者。
- en: Minimal MEAN
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最小化MEAN
- en: 'Choosing the Correct-Stack™ for your project is difficult. First and foremost,
    your technical architecture should be adequate to meet business needs. For example,
    if you''re trying to deliver an artificial intelligence project with Node.js,
    you''re likely using the wrong stack. Our focus will be on delivering web applications,
    but beyond that, we have other parameters to consider, including the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的项目选择正确的-Stack™ 是困难的。首先，你的技术架构应该足够满足业务需求。例如，如果你试图使用 Node.js 实现人工智能项目，你很可能会选择错误的堆栈。我们的重点是交付网络应用，但除此之外，我们还有其他参数要考虑，包括以下内容：
- en: Ease of use
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易用性
- en: Happiness
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 幸福
- en: Effectiveness
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 效率
- en: If your development team will be working on your application for an extended
    period of time, then it is very important to consider factors beyond compatibility.
    Your stack, choice of tool, and coding style can have a significant impact if
    your code base is easy to use, keeps your developers happy, or makes them feel
    like effective contributors to the project.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的开发团队将长时间在你的应用程序上工作，那么考虑兼容性以外的因素非常重要。你的堆栈、工具选择和编码风格如果使代码库易于使用，让你的开发者感到快乐，或者让他们觉得自己是项目的有效贡献者，那么这些都会产生重大影响。
- en: A well configured stack is key for a great DX. This can be the difference between
    a towering stack of dried-out pancakes, or a delicious short stack with the right
    amount of butter and syrup over it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一个配置良好的堆栈对于优秀的开发体验至关重要。这可能是干燥的煎饼堆和带有适量黄油和糖浆的精美小堆之间的区别。
- en: By introducing too many libraries and dependencies, you can slow down your progress,
    make your code difficult to maintain, and find yourself in a feedback loop of
    introducing more libraries to resolve the issues of other libraries. The only
    way to win this game is to simply not play it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引入过多的库和依赖项，你可以减慢你的进度，使你的代码难以维护，并发现自己陷入引入更多库以解决其他库问题的反馈循环。赢得这场游戏的唯一方法就是简单地不玩。
- en: 'If you take your time to learn how to work with a few fundamental libraries,
    you can become a far more effective developer. In essence, you can do more with
    less. My advice would be to:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你花时间学习如何使用几个基本的库，你可以成为一个更有效的开发者。本质上，你可以用更少的资源做更多的事情。我的建议是：
- en: '**Think** before you write a single line of code, and apply the 80-20 rule.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在编写代码之前先思考**，并应用 80-20 规则。'
- en: '**Wait** for libraries and tools to mature, skipping the betas.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**等待库和工具成熟，跳过测试版**。'
- en: '**Fast** by reducing your gluttony for new packages and tools, mastering the
    fundamentals instead.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过减少对新包和工具的贪婪，掌握基础知识来实现快速**。'
- en: Watch my 2017 Ng conference talk entitled *Do More with Less JavaScript* on
    YouTube at [https://www.youtube.com/watch?v=Sd1aM8181kc](https://www.youtube.com/watch?v=Sd1aM8181kc).
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 YouTube 上观看我2017年 Ng 会议的演讲，标题为 *用更少的 JavaScript 做更多的事情*，链接为 [https://www.youtube.com/watch?v=Sd1aM8181kc](https://www.youtube.com/watch?v=Sd1aM8181kc)。
- en: 'This minimalist mindset is the design philosophy behind minimal MEAN. You can
    review a reference implementation on GitHub at [https://github.com/duluca/minimal-mean](https://github.com/duluca/minimal-mean).
    Refer to the following diagram for the overall architecture:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简约思维是 minimal MEAN 的设计哲学。你可以在 GitHub 上查看参考实现 [https://github.com/duluca/minimal-mean](https://github.com/duluca/minimal-mean)。参考以下图表了解整体架构：
- en: '![](img/B14094_10_01.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_10_01.png)'
- en: 'Figure 10.1: Minimal MEAN software stack and tooling'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1：Minimal MEAN 软件堆栈和工具
- en: Let's go over the components of the architecture one by one.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个介绍架构的组件。
- en: Angular
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Angular
- en: Angular is the presentation layer. Angular is a capable and reliable development
    platform. It is well understood and has a great community. You should definitely
    take the time to master the fundamentals of Angular before considering another
    option.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 是表现层。Angular 是一个能够和可靠的开发平台。它被广泛理解，拥有一个伟大的社区。在考虑其他选项之前，你绝对应该花时间掌握 Angular
    的基础知识。
- en: Libraries such as Angular Material, Angular Evergreen, and `angular-unit-test-helper`
    help you deliver optimal and great-looking solutions with minimal effort.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如 Angular Material、Angular Evergreen 和 `angular-unit-test-helper` 这样的库可以帮助你以最小的努力提供最佳和外观出色的解决方案。
- en: You may containerize your Angular (or any other web app) using the minimal Docker
    container, `duluca/minimal-nginx-web-server` or `duluca/minimal-node-web-server`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用最小的 Docker 容器 `duluca/minimal-nginx-web-server` 或 `duluca/minimal-node-web-server`
    来容器化你的 Angular（或任何其他网络应用）。
- en: Express
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Express
- en: 'Express.js will be our API layer. Express is a fast, unopinionated, and minimalist
    web framework for Node.js. Express has a vast plugin ecosystem that is almost
    guaranteed to meet every need. In minimal MEAN, we only leverage two packages:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Express.js将成为我们的API层。Express是一个快速、无偏见且极简的Node.js网络框架。Express拥有庞大的插件生态系统，几乎可以满足所有需求。在Minimal
    MEAN中，我们只利用了两个包：
- en: '`cors`: To configure cross-origin resource sharing settings'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cors`: 配置跨源资源共享设置'
- en: '`morgan`: To log HTTP requests'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`morgan`: 用于记录HTTP请求'
- en: In addition, we use express parsers to parse incoming HTTP requests in `req.body`
    and the `express.static` function to serve the content of the `public` folder.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们使用express解析器解析传入的HTTP请求中的`req.body`，并使用`express.static`函数来提供`public`文件夹的内容。
- en: You can read more about Express.js at [https://expressjs.com/](https://expressjs.com/).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://expressjs.com/](https://expressjs.com/)了解更多关于Express.js的信息。
- en: Node
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Node
- en: Express.js runs on Node.js. We will be implementing the business layer in Node.
    Node is a lightweight and efficient JavaScript runtime, using an event-driven,
    non-blocking I/O model that makes it suitable for high-performance and real-time
    applications. Node runs everywhere, from fridges to smart watches. You can increase
    the reliability of your Node applications by using TypeScript to develop your
    application.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Express.js运行在Node.js上。我们将使用Node实现业务层。Node是一个轻量级且高效的JavaScript运行时，使用事件驱动、非阻塞I/O模型，使其适用于高性能和实时应用。Node可以在任何地方运行，从冰箱到智能手表。你可以通过使用TypeScript开发应用程序来提高Node应用程序的可靠性。
- en: Refer to the blog post by Frank Rosner on non-blocking I/O for a more in-depth
    explanation of the topic at [https://blog.codecentric.de/en/2019/04/explain-non-blocking-i-o-like-im-five/](https://blog.codecentric.de/en/2019/04/explain-non-blocking-i-o-like-im-five/).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有关非阻塞I/O的更深入解释，请参阅Frank Rosner的博客文章[https://blog.codecentric.de/en/2019/04/explain-non-blocking-i-o-like-im-five/](https://blog.codecentric.de/en/2019/04/explain-non-blocking-i-o-like-im-five/)。
- en: Later in this chapter, you're going to learn how to configure Node projects
    using TypeScript.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，你将学习如何使用TypeScript配置Node项目。
- en: Mongo
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Mongo
- en: MongoDB represents the persistence layer. MongoDB is a document-oriented database
    with dynamic JSON-like schemas. The major benefit of using a JSON-based database
    is the fact that you don't need to transform your data from one format to another.
    You can retrieve, display, edit, and then update the data solely using JSON.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB代表持久层。MongoDB是一个面向文档的数据库，具有动态的类似JSON的架构。使用基于JSON的数据库的主要好处是你不需要将数据从一种格式转换为另一种格式。你可以仅使用JSON检索、显示、编辑和更新数据。
- en: In addition, the MongoDB native driver for Node is mature, performant, and capable.
    I have developed a library called `document-ts`, which aims to simplify interacting
    with MongoDB by introducing rich document objects that are easy to code. DocumentTS
    is a very thin TypeScript-based MongoDB helper with optional, rich ODM convenience
    features.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Node的MongoDB原生驱动程序成熟、性能良好且功能强大。我开发了一个名为`document-ts`的库，旨在通过引入易于编码的丰富文档对象来简化与MongoDB的交互。DocumentTS是一个非常薄的基于TypeScript的MongoDB辅助工具，具有可选的丰富ODM便利功能。
- en: You can read more about MongoDB at [https://www.mongodb.com/](https://www.mongodb.com/),
    and the DocumentTS library at [https://github.com/duluca/document-ts](https://github.com/duluca/document-ts).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://www.mongodb.com/](https://www.mongodb.com/)了解更多关于MongoDB的信息，以及DocumentTS库的[https://github.com/duluca/document-ts](https://github.com/duluca/document-ts)。
- en: Tooling
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工具
- en: 'The tooling that supports your development is as important as your choice of
    software stack. Minimal MEAN leverages the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 支持你开发的技术工具与你的软件栈选择一样重要。Minimal MEAN利用以下工具：
- en: '**VS Code**: Great extension support, lightweight, fast, and cross-platform'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VS Code**: 优秀的扩展支持，轻量级、快速且跨平台'
- en: '**TypeScript**: Fast and easy-to-use transpiler with great linting support
    using tslint'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TypeScript**: 快速且易于使用的转译器，具有使用tslint的出色lint支持'
- en: '**Npm**: Multi-platform scripting and dependency management with a rich ecosystem
    of packages'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Npm**: 多平台脚本和依赖管理，拥有丰富的包生态系统'
- en: '**GitHub**: Flexible, free, and well supported Git host. GitHub flow enables
    gated code check-ins in tandem with a CI server'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GitHub**: 灵活、免费且支持良好的Git托管服务。GitHub流程与CI服务器协同，实现门控代码检查'
- en: '**Docker**: Lightweight virtualization technology that encapsulates your environment
    configuration and settings'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker**: 一种轻量级虚拟化技术，封装了你的环境配置和设置'
- en: '**Continuous Integration (CI)**: Critical to ensuring the delivery of quality
    code'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续集成（CI）**: 确保代码交付质量的关键'
- en: '**Jasmine**: Batteries-included unit testing framework that works with nyc/istanbul.js
    to deliver code coverage metrics'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jasmine**：包含电池的单元测试框架，与nyc/istanbul.js一起工作以提供代码覆盖率指标'
- en: Note that the tooling and language of choice we are using is the same as the
    ones we use for Angular development. This enables developers to be able to switch
    between frontend and backend development with minimal context switching.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用的工具和选择的语言与用于Angular开发的工具和语言相同。这使得开发者能够在前端和后端开发之间进行最小化的上下文切换。
- en: Now that we have covered all major components and tooling for delivering a minimal
    MEAN stack app, let's start by creating a Git repository that can house our frontend
    and backend code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了交付最小MEAN堆栈应用的所有主要组件和工具，让我们首先创建一个Git仓库，用于存放我们的前端和后端代码。
- en: Configuring a monorepo
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置monorepo
- en: You can optimize your development experience by creating a monorepo, which contains
    your frontend and backend code. A monorepo allows developers to be able to jump
    between projects within the same IDE window. Developers can reference code more
    easily across projects, such as sharing TypeScript interfaces between the frontend
    and the backend, thereby ensuring that data objects line up every time. The CI
    server can build all projects at once to ensure that all components of the full-stack
    application remain in working order.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过创建包含您前端和后端代码的monorepo来优化您的开发体验。monorepo允许开发者能够在同一IDE窗口内跳转项目。开发者可以更容易地在项目之间引用代码，例如在前端和后端之间共享TypeScript接口，从而确保数据对象每次都保持一致。CI服务器可以一次性构建所有项目，以确保全栈应用的所有组件都处于正常工作状态。
- en: Note that a monorepo is different to multi-root workspaces in VS Code, where
    you can add multiple projects to show in the same IDE windows. A monorepo combines
    projects at the source control level. Read more about multi-root workspaces at
    [https://code.visualstudio.com/docs/editor/multi-root-workspaces](https://code.visualstudio.com/docs/editor/multi-root-workspaces).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，monorepo与VS Code中的多根工作区不同，在多根工作区中，您可以将多个项目添加到同一IDE窗口中。monorepo在源代码控制级别组合项目。有关多根工作区的更多信息，请参阅[https://code.visualstudio.com/docs/editor/multi-root-workspaces](https://code.visualstudio.com/docs/editor/multi-root-workspaces)。
- en: Let's take a quick tour of the code base.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速浏览一下代码库。
- en: Monorepo structure
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Monorepo结构
- en: 'Under the `lemon-mart-server` project, you are going to have three main folders,
    as shown here:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在`lemon-mart-server`项目中，您将拥有三个主要文件夹，如下所示：
- en: '[PRE5]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `bin` folder contains helper scripts or tools, the `web-app` folder represents
    your frontend, and `server` contains the source code for the backend. In our case,
    the `web-app` folder is the `lemon-mart` project. Instead of copying and pasting
    the code from the existing project, we leverage Git submodules to link two repositories
    together.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`bin`文件夹包含辅助脚本或工具，`web-app`文件夹代表您的前端，而`server`包含后端源代码。在我们的案例中，`web-app`文件夹是`lemon-mart`项目。我们不是复制粘贴现有项目的代码，而是利用Git子模块将两个仓库链接在一起。'
- en: Git submodules
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Git子模块
- en: Git submodules help you share code between multiple repositories, while keeping
    the commits separate. Frontend developers may choose to only work using the frontend
    repository, whereas full-stack developers will prefer access to all code. Git
    submodules also provide a convenient way for existing projects to be combined.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Git子模块帮助您在多个仓库之间共享代码，同时保持提交的分离。前端开发者可能选择仅使用前端仓库进行工作，而全栈开发者将更喜欢访问所有代码。Git子模块还为现有项目的组合提供了一个方便的方法。
- en: 'Let''s start by seeing how you can add your own `lemon-mart` project as a submodule
    of `lemon-mart-server`, leveraging the scripts that reside in the `package.json`
    file in the root folder of our monorepo:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看您如何将您自己的`lemon-mart`项目作为`lemon-mart-server`的子模块添加，利用位于我们monorepo根目录`package.json`文件中的脚本：
- en: I recommend that you perform this action on the version of **lemon-mart-server**
    that you cloned from GitHub. Otherwise, you will need to create a new project
    and execute `npm init -y` to get things started.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您在从GitHub克隆的**lemon-mart-server**版本上执行此操作。否则，您将需要创建一个新的项目并执行`npm init -y`以开始操作。
- en: 'Observe the following `package.json` scripts that assist in the initialization,
    updating, and cleaning up of Git submodules:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察以下`package.json`脚本，这些脚本有助于初始化、更新和清理Git子模块：
- en: '[PRE6]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Update `webAppGitUrl` with the URL to your own project.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`webAppGitUrl`更新为您自己的项目的URL。
- en: Execute `webapp:clean` to remove the existing `web-app` folder.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`webapp:clean`以删除现有的`web-app`文件夹。
- en: 'Finally, execute the `webapp:init` command to initialize your project in the
    `web-app` folder:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，执行 `webapp:init` 命令以在 `web-app` 文件夹中初始化你的项目：
- en: '[PRE7]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Going forward, execute the `modules:update` command to update the code in the
    submodule. To pull the submodules after cloning the repo in another environment,
    execute `npm modules:init`. If you ever need to reset the environment and restart,
    then execute `webapp:clean` to clean Git's cache and remove the folder.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，执行 `modules:update` 命令以更新子模块中的代码。在另一个环境中克隆仓库后，要拉取子模块，请执行 `npm modules:init`。如果你需要重置环境并重新启动，请执行
    `webapp:clean` 以清理 Git 缓存并删除文件夹。
- en: Note that you can have multiple submodules in your repository. The `modules:update`
    command will update all the submodules.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你的仓库中可以有多个子模块。`modules:update` 命令将更新所有子模块。
- en: 'Your web application code is now available in the folder named `web-app`. Additionally,
    you should be able to see both projects under VS Code''s **Source Control** pane,
    as shown:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 Web 应用程序代码现在位于名为 `web-app` 的文件夹中。此外，你应该能够在 VS Code 的 **源代码管理** 面板中看到这两个项目，如图所示：
- en: '![](img/B14094_10_02.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_10_02.png)'
- en: 'Figure 10.2: VS Code Source Control Providers'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2：VS Code 源代码管理提供者
- en: Using VS Code's source control, you can independently perform Git actions on
    either repository.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 VS Code 的源代码管理，你可以独立地对任一仓库执行 Git 操作。
- en: If things get messy with your submodule, simply `cd` into the submodule directory
    and execute `git pull` and then `git checkout master` to restore the master branch.
    Using this technique, you may checkout any branch from your project and submit
    PRs.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的子模块出现混乱，只需在子模块目录中执行 `cd` 并运行 `git pull`，然后执行 `git checkout master` 以恢复主分支。使用此技术，你可以从项目中的任何分支检出并提交
    PR。
- en: Now that we have our submodule ready, let's see how the server project is configured.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了子模块，让我们看看服务器项目是如何配置的。
- en: Configuring a Node project with TypeScript
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 TypeScript 配置 Node 项目
- en: 'To create a new Node.js application using TypeScript, perform the following
    steps:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 TypeScript 创建新的 Node.js 应用程序，请执行以下步骤：
- en: The following steps are only relevant if you are creating a new server project.
    I recommend that you use the one already provided in the `lemon-mart-server` project
    that you cloned from GitHub.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤仅适用于你正在创建新的服务器项目。我建议你使用从 GitHub 克隆的 `lemon-mart-server` 项目中提供的现有一个。
- en: 'Create a sub-folder `server`:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建子文件夹 `server`：
- en: '[PRE8]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Change your current directory to the `server` folder:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前目录更改为 `server` 文件夹：
- en: '[PRE9]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Initialize npm to set up `package.json` in the `server` folder:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化 npm 以在 `server` 文件夹中设置 `package.json`：
- en: '[PRE10]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that the top-level `package.json` will be utilized for scripts that are
    relevant to the full-stack project. `server/package.json` will contain scripts
    and dependencies for the backend project.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，顶级 `package.json` 将用于与全栈项目相关的脚本。`server/package.json` 将包含后端项目的脚本和依赖项。
- en: 'Configure your repository using `mrm-task-typescript-vscode`:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `mrm-task-typescript-vscode` 配置你的仓库：
- en: '[PRE11]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `mrm` task configures VS Code for an optimized TypeScript development experience,
    similar to the way we did using `mrm-task-angular-vscode` in *Chapter 2*, *Setting
    Up Your Development Environment*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`mrm` 任务配置 VS Code 以获得优化的 TypeScript 开发体验，类似于我们在 *第 2 章*，*设置开发环境* 中使用 `mrm-task-angular-vscode`
    所做的那样。'
- en: 'When the command has finished executing, the `project` folder appears as shown
    here:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 命令执行完毕后，`project` 文件夹将如所示出现：
- en: '[PRE12]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The task configures the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此任务配置以下内容：
- en: 'Common npm packages used for scripting: cross-conf-env ([https://www.npmjs.com/package/cross-conf-env](https://www.npmjs.com/package/cross-conf-env)),
    npm-run-all ([https://www.npmjs.com/package/npm-run-all](https://www.npmjs.com/package/npm-run-all)),
    dev-norms ([https://www.npmjs.com/package/dev-norms](https://www.npmjs.com/package/dev-norms)),
    and rimraf ([https://www.npmjs.com/package/rimraf](https://www.npmjs.com/package/rimraf))'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常用 npm 脚本包：cross-conf-env ([https://www.npmjs.com/package/cross-conf-env](https://www.npmjs.com/package/cross-conf-env))、npm-run-all
    ([https://www.npmjs.com/package/npm-run-all](https://www.npmjs.com/package/npm-run-all))、dev-norms
    ([https://www.npmjs.com/package/dev-norms](https://www.npmjs.com/package/dev-norms))
    和 rimraf ([https://www.npmjs.com/package/rimraf](https://www.npmjs.com/package/rimraf))
- en: 'Npm scripts for styling, linting, building, and testing:'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Npm 脚本用于样式、代码检查、构建和测试：
- en: '`style` and `lint`: Check compliance in code styling and linting errors. They
    are intended for CI server usage.'
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`style` 和 `lint`：检查代码样式和代码检查错误是否符合规范。它们主要用于 CI 服务器使用。'
- en: '`style:fix` and `lint:fix`: Apply code styling and linting rules to the code.
    Not all linting errors can be fixed automatically. You will need to address each
    error by hand.'
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`style:fix` 和 `lint:fix`: 将代码样式和检查规则应用到代码中。并非所有检查错误都可以自动修复。您需要手动解决每个错误。'
- en: '`build`: Transpiles the code into the `dist` folder.'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build`: 将代码转换为 `dist` 文件夹。'
- en: '`start`: Runs the transpiled code in Node.js.'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start`: 在 Node.js 中运行转换后的代码。'
- en: '`prepublishOnly` and `prepare` scripts are only relevant if you''re developing
    an npm package. In that case, you should also implement a `.npmignore` file, which
    excludes the `src` and `tests` folders.'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`prepublishOnly` 和 `prepare` 脚本仅在您开发 npm 包时相关。在这种情况下，您还应该实现一个 `.npmignore`
    文件，该文件排除了 `src` 和 `tests` 文件夹。'
- en: '`ImportSort`: Maintains the order of the `import` statements:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ImportSort`: 维护 `import` 语句的顺序：'
- en: Settings are added to `package.json`
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将设置添加到 `package.json`
- en: 'Supporting npm packages are installed: import-sort, import-sort-cli, import-sort-parser-typescript,
    and import-sort-style-module'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持的 npm 包已安装：import-sort、import-sort-cli、import-sort-parser-typescript 和 import-sort-style-module
- en: 'TypeScript with tslint:'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 TypeScript 和 tslint：
- en: '`tsconfig.json`: Common TypeScript settings'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tsconfig.json`: 常见的 TypeScript 设置'
- en: '`tsconfig.src.json`: Settings that are specific to the source code under the
    `src` folder'
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tsconfig.src.json`: 适用于 `src` 文件夹下源代码的特定设置'
- en: '`tslint.json`: Linting rules'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tslint.json`: 检查规则'
- en: 'The Prettier plugin, which automatically formats the styling of our code:'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动格式化我们代码样式的 Prettier 插件：
- en: '`.prettierrc`: Prettier settings'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.prettierrc`: Prettier 设置'
- en: '`.prettierignore`: Files to ignore'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.prettierignore`: 忽略的文件'
- en: 'Jasmine and nyc for unit testing and code coverage:'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jasmine 和 nyc 用于单元测试和代码覆盖率：
- en: '`jasmine.json`: Testing settings.'
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jasmine.json`: 测试设置。'
- en: '`.nycrc`: Code coverage settings.'
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.nycrc`: 代码覆盖率设置。'
- en: 'The `tests` folder: Contains `spec.ts` files, which include your tests and
    `tsconfig.spec.json`, which configures more relaxed settings that make it easier
    to write tests quickly.'
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tests` 文件夹：包含 `spec.ts` 文件，其中包含您的测试和 `tsconfig.spec.json`，它配置了更宽松的设置，使快速编写测试变得更容易。'
- en: 'In `package.json`: Test scripts are created to build your tests using `build:test`
    and execute them with `npm test`. The `test:ci` command is intended for CI servers
    and `test:nyc` provides the code coverage report.'
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `package.json` 中：创建测试脚本以使用 `build:test` 构建测试并使用 `npm test` 执行它们。`test:ci`
    命令旨在用于 CI 服务器，而 `test:nyc` 提供代码覆盖率报告。
- en: '`example.env`: Used to document required environment variables that would be
    present in your private `.env` file'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`example.env`：用于记录在您的私有 `.env` 文件中存在的必需环境变量'
- en: '`.env` is added to `.gitignore`'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.env` 已添加到 `.gitignore`'
- en: 'PR template: A pull request template that requests additional information from
    developers'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PR 模板：一个请求开发者提供额外信息的拉取请求模板
- en: 'VS Code extensions, settings, and debugging configurations, respectively, in three
    files:'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VS Code 扩展、设置和调试配置分别在三份文件中：
- en: '`.vscode/extensions.json`'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.vscode/extensions.json`'
- en: '`.vscode/settings.json`'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.vscode/settings.json`'
- en: '`.vscode/launch.json`'
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.vscode/launch.json`'
- en: Once you are comfortable with the changes introduced to your project, verify
    that your project is in working order.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您熟悉了项目引入的更改，请验证您的项目是否处于正常工作状态。
- en: 'Verify the project by executing the tests:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行测试来验证项目：
- en: '[PRE13]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Before the `test` command is run, `npm run build && npm run build:test` is
    executed to transpile our TypeScript code to JavaScript. The output is placed
    in the `dist` folder, as shown:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行 `test` 命令之前，执行 `npm run build && npm run build:test` 以将我们的 TypeScript 代码转换为
    JavaScript。输出放置在 `dist` 文件夹中，如下所示：
- en: '[PRE14]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that on your filesystem,`.js` and `.js.map` files are created alongside
    every `.ts` file. In `.vscode/settings.json`, we configure the `files.exclude`
    property to hide these files in the IDE so that they don't distract developers
    during development. Additionally, in `.gitignore`, we also ignore `.js` and `.js.map`
    files, so they don't get checked into our repository.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在您的文件系统中，`.js` 和 `.js.map` 文件与每个 `.ts` 文件一起创建。在 `.vscode/settings.json` 中，我们配置了
    `files.exclude` 属性，以在 IDE 中隐藏这些文件，这样它们就不会在开发期间分散开发者的注意力。此外，在 `.gitignore` 中，我们也忽略了
    `.js` 和 `.js.map` 文件，这样它们就不会被提交到我们的仓库中。
- en: Now that we have a barebones monorepo, we can configure our CI server.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了基本的单仓库，我们可以配置我们的持续集成服务器。
- en: CircleCI config
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CircleCI 配置
- en: 'One of the benefits of using Git submodules is that we can verify that our
    frontend and backend works in the same pipeline. We will implement two jobs:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Git 子模块的一个好处是我们可以验证我们的前端和后端是否在相同的管道中工作。我们将实现两个任务：
- en: '`build_server`'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`build_server`'
- en: '`build_webapp`'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`build_webapp`'
- en: 'These jobs will follow the workflow shown here:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这些任务将遵循此处显示的工作流程：
- en: '[PRE15]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The CI pipeline will build the server and the web app simultaneously, with
    an option to run the `deploy` job if the jobs succeed on the master branch. Refer
    to the `config.yml` file on GitHub on how to implement the `build_webapp` job,
    which is similar to the one you implemented in *Chapter 9*, *DevOps Using Docker*,
    but that includes a number of subtle differences to handle working with submodules
    and the folder structure changes. The pipeline for building the server is not
    too dissimilar to the web app one, as shown here:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: CI管道将同时构建服务器和Web应用程序，如果主分支上的作业成功，可以选择运行`deploy`作业。有关如何在GitHub上的`config.yml`文件中实现`build_webapp`作业的说明，请参阅*第9章*，*使用Docker的DevOps*，该作业与您在第9章中实现的类似，但包括一些细微的差异，以处理与子模块和文件夹结构变化的工作。构建服务器的管道与Web应用程序的管道不太相似，如下所示：
- en: '[PRE16]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The pipeline checks out the code, verifies the security of the packages we're
    using with `audit-ci`, installs dependencies, checks for styling and linting errors,
    runs tests, and checks for code coverage levels.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 管道会检出代码，使用`audit-ci`验证我们使用的软件包的安全性，安装依赖项，检查样式和linting错误，运行测试，并检查代码覆盖率水平。
- en: The test commands implicitly build the server code, which is stored under the
    `dist` folder. In the final step, we move the `dist` folder into the workspace
    so that we can use it at a later stage.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 测试命令隐式构建服务器代码，该代码存储在`dist`文件夹下。在最后一步，我们将`dist`文件夹移动到工作区，以便我们可以在以后使用它。
- en: Next, let's see how we can bring together all tiers of our app and run it using
    Docker Compose.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们如何将应用程序的所有层组合在一起，并使用Docker Compose运行它。
- en: Docker Compose
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker Compose
- en: Since we have a three-tiered architecture, we need a convenient way to set up
    the infrastructure for our full-stack application. You can create scripts to start
    various Docker containers individually, but there's a purpose-built tool that
    runs multi-container applications called Docker Compose. Compose uses a YAML file
    format, named `docker-compose.yml`, so you declaratively define the configuration
    of your application. Compose allows you to adhere to infrastructure-as-code principles.
    Compose will also allow us to conveniently start a database instance without having
    to install a permanent and always-on database solution in our development environments.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有一个三层架构，我们需要一种方便的方式来设置全栈应用程序的基础设施。您可以创建脚本来单独启动各种Docker容器，但有一个专门用于运行多容器应用程序的工具，称为Docker
    Compose。Compose使用名为`docker-compose.yml`的YAML文件格式，因此您可以声明性地定义应用程序的配置。Compose允许您遵循基础设施即代码的原则。Compose还将使我们能够方便地启动数据库实例，而无需在我们的开发环境中安装永久性和始终开启的数据库解决方案。
- en: You can use Compose to deploy your application on cloud services, scale the
    number of container instances you're running, and even run integration tests of your application
    on your CI server. Later in this section, we go over how you can run Docker Compose
    on CircleCI.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Compose在云服务上部署应用程序，调整您正在运行的容器实例数量，甚至可以在您的CI服务器上运行应用程序的集成测试。在本节后面的内容中，我们将介绍如何在CircleCI上运行Docker
    Compose。
- en: 'Consider the architecture of the following application with the communication
    port of each tier:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下应用程序的架构以及每一层的通信端口：
- en: '![](img/B14094_10_03.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_10_03.png)'
- en: 'Figure 10.3: Lemon Mart three-tier architecture'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3：Lemon Mart三层架构
- en: Using Docker Compose, we are able to describe the architecture shown here precisely.
    You can read more about Compose at [https://docs.docker.com/compose/](https://docs.docker.com/compose/).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker Compose，我们能够精确地描述这里显示的架构。您可以在[https://docs.docker.com/compose/](https://docs.docker.com/compose/)了解更多关于Compose的信息。
- en: Next, let's implement a more efficient web server for Lemon Mart.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们为Lemon Mart实现一个更高效的Web服务器。
- en: Using Nginx as the web server
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Nginx作为Web服务器
- en: Our web app is already containerized as covered in *Chapter 9*, *DevOps Using
    Docker*. For this exercise, we will use the nginx-based container.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Web应用程序已经在*第9章*，*使用Docker的DevOps*中进行了容器化。对于这个练习，我们将使用基于nginx的容器。
- en: 'Add a new Dockerfile named `nginx.Dockerfile` to the root of your `web-app`.
    This image will be smaller than the Node-based one we have, since we''re using
    nginx as the web server:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在`web-app`的根目录下添加一个名为`nginx.Dockerfile`的新Dockerfile。这个镜像将比我们已有的基于Node的镜像小，因为我们使用nginx作为Web服务器：
- en: '[PRE17]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, let's containerize our server.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将我们的服务器容器化。
- en: Containerizing the server
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器化服务器
- en: 'So far, we have been using mostly preconfigured Docker images to deploy our
    web app. The following is a more detailed implementation of a Node.js-based server:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要使用预配置的Docker镜像来部署我们的Web应用程序。以下是基于Node.js的服务器更详细实现的示例：
- en: If you need it, refer to the *Containerizing the app using Docker* section in
    *Chapter 9*, *DevOps Using Docker*, as a refresher on Docker.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要，可以参考*第9章*，*使用Docker的DevOps*中的*使用Docker容器化应用程序*部分，作为Docker的复习。
- en: 'Let''s begin by defining the `Dockerfile`:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先定义`Dockerfile`：
- en: '[PRE18]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that we ADD the `dist` folder to our server and then run it using nodes
    with CMD.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们将`dist`文件夹添加到我们的服务器中，然后使用nodes运行它。
- en: You can read more about how our server container is configured by checking out
    `README.md` on the similarly configured `minimal-node-web-server` repo at [https://github.com/duluca/minimal-node-web-server](https://github.com/duluca/minimal-node-web-server).
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以通过查看[https://github.com/duluca/minimal-node-web-server](https://github.com/duluca/minimal-node-web-server)上类似配置的`minimal-node-web-server`仓库中的`README.md`来了解更多关于我们服务器容器配置的信息。
- en: Now, set up the cross-environment, **npm scripts for Docker**, which works on
    Windows 10 and macOS for our server.
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，设置跨环境的**npm脚本用于Docker**，它适用于Windows 10和macOS上的我们的服务器。
- en: 'Install the npm scripts for the Docker task:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Docker任务的npm脚本：
- en: '[PRE19]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Apply the npm scripts for Docker configuration, making sure to execute the
    command in the `server` folder:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用Docker配置的npm脚本，确保在`server`文件夹中执行命令：
- en: '[PRE20]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Configure your `package.json` with the configuration parameters:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用配置参数配置你的`package.json`：
- en: '[PRE21]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Be sure to build your app before building your Docker container.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建Docker容器之前，请确保构建你的应用程序。
- en: Configuring environment variables with DotEnv
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用DotEnv配置环境变量
- en: DotEnv files are widely supported to store secrets conveniently in a `.env`
    file that is not checked in to your code repository. Docker and Compose natively
    support `.env` files.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: DotEnv文件广泛支持，方便地将密钥存储在未提交到代码仓库的`.env`文件中。Docker和Compose原生支持`.env`文件。
- en: 'Let''s start by understanding the environment variables at the heart of the
    monorepo:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们了解单一代码库核心的环境变量：
- en: 'Refer to the `example.env` file at the root of the project:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参考项目根目录下的`example.env`文件：
- en: '[PRE22]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Don't store any real secrets in `example.env`. Store them in the `.env` file.
    `example.env` is there to document the environment variables that are required
    for your project. In this case, I've populated my `example.env` file with sample
    values so that readers can run the example without having to configure all these
    parameters.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不要在`example.env`中存储任何真实密钥。将它们存储在`.env`文件中。`example.env`文件用于记录项目所需的环境变量。在这种情况下，我已经在我的`example.env`文件中填充了示例值，以便读者可以在不配置所有这些参数的情况下运行示例。
- en: 'Ensure that `init-dev-env` is installed in the root of the project by executing:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令确保`init-dev-env`已安装在项目根目录中：
- en: '[PRE23]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `npm run init:env` script generates `.env` files based on the `example.env`
    file using the `init-dev-env` package:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`npm run init:env`脚本使用`init-dev-env`包根据`example.env`文件生成`.env`文件：'
- en: In **lemon-mart-server** the `example.env` file for the server exists in two
    places. First in the root of the project as `server-example.env` and second under
    `server/example.env`. This is done to increase the visibility of the sample configuration
    settings.
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在**lemon-mart-server**中，服务器的`example.env`文件存在于两个地方。首先在项目根目录下作为`server-example.env`，其次在`server/example.env`下。这样做是为了增加示例配置设置的可见性。
- en: '[PRE24]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The second `.env` file is generated for the server as shown:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个`.env`文件是为服务器生成的，如下所示：
- en: '[PRE25]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note that this file contains the connection string to MongoDB, the secret we
    will use to encrypt our JWTs, and a seed user so that we can log in to the application.
    Normally, you wouldn't configure a password or a user ID for your seed users.
    These are only here to support repeatable demo code.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此文件包含连接到MongoDB的连接字符串、我们将用于加密JWT的密钥以及一个种子用户，以便我们可以登录到应用程序。通常，你不会为你的种子用户配置密码或用户ID。这些只在这里以支持可重复的演示代码。
- en: Now, we're ready to define the YAML file for Compose.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好定义Compose的YAML文件。
- en: Define Docker-Compose YAML
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义Docker-Compose YAML
- en: 'Let''s define a `docker-compose.yml` file in the root of the monorepo to reflect
    our architecture:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在单一代码库的根目录中定义一个`docker-compose.yml`文件，以反映我们的架构：
- en: '[PRE26]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: At the top, we build the `web-app` service using the nginx-based container.
    The `build` property automatically builds the `Dockerfile` for us. We are exposing
    the `web-app` on port `8080` and linking it to the `server` service. The `links`
    property creates an isolated Docker network to ensure that our containers can
    communicate with each other. By using the `depends_on` property, we ensure that
    the server is started before the `web-app` is started.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部，我们使用基于nginx的容器构建 `web-app` 服务。`build` 属性会自动为我们构建 `Dockerfile`。我们在端口 `8080`
    上公开 `web-app` 并将其链接到 `server` 服务。`links` 属性创建了一个隔离的Docker网络，以确保我们的容器可以相互通信。通过使用
    `depends_on` 属性，我们确保在启动 `web-app` 之前启动服务器。
- en: The `server` also uses the `build` property for an automatic `Dockerfile` build.
    It also uses the `env_file` property to load environment variables from the `.env`
    file under the `server` folder. Using the `environment` property, we override
    the `MONGO_URI` variable to use the internal Docker network name for the database
    container. The server both `links` and `depends_on` the database, which is named
    `lemondb`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`server` 也使用 `build` 属性来自动构建 `Dockerfile`。它还使用 `env_file` 属性从 `server` 文件夹下的
    `.env` 文件加载环境变量。使用 `environment` 属性，我们覆盖了 `MONGO_URI` 变量，以便使用数据库容器的内部Docker网络名称。服务器既
    `links` 也 `depends_on` 数据库，该数据库被命名为 `lemondb`。'
- en: The `database` service pulls the `duluca/minimal-mongo` image from Docker Hub.
    Using the `restart` property, we ensure that the database will automatically restart
    if it crashes. We use the setup parameters within the `.env` file to configure
    and password-protect the database. Using the `volumes` property, we mount the
    database's storage directory to a local directory so that your data can persist
    across container reboots.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`database` 服务从Docker Hub拉取 `duluca/minimal-mongo` 镜像。使用 `restart` 属性，我们确保数据库在崩溃时将自动重启。我们使用
    `.env` 文件中的设置参数来配置和密码保护数据库。使用 `volumes` 属性，我们将数据库的存储目录挂载到本地目录，以便你的数据可以在容器重启后持续存在。'
- en: In a cloud environment, you can mount the volume of your database to your cloud
    provider's persistence solution, including AWS **Elastic File System** (**EFS**)
    or Azure File Storage.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在云环境中，你可以将你的数据库卷挂载到云提供商的持久化解决方案上，包括AWS **弹性文件系统**（**EFS**）或Azure文件存储。
- en: Additionally, we define a Docker volume named `dbdata` for data storage.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们定义了一个名为 `dbdata` 的Docker卷用于数据存储。
- en: 'Occasionally, your database may stop working correctly. This can happen if
    you upgrade your container, use a different container, or use the same volume
    in another project. In this instance, you can reset the state of your Docker setup
    by executing the following command:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你的数据库可能无法正常工作。这可能发生在你升级容器、使用不同的容器或在不同项目中使用相同的卷时。在这种情况下，你可以通过执行以下命令来重置你的Docker设置的状态：
- en: '[PRE27]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: or
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE28]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: To run your infrastructure, you will be executing the `docker-compose up` command.
    You can also use the `-d` option to your infrastructure in detached mode. You
    stop it with the `down` command and remove the containers it creates by means
    of the `rm` command.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行你的基础设施，你将执行 `docker-compose up` 命令。你也可以使用 `-d` 选项以分离模式运行你的基础设施。你可以使用 `down`
    命令停止它，并通过 `rm` 命令删除它创建的容器。
- en: Before you can run your infrastructure, you will need to build your application,
    which is covered in the next section.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在你能够运行你的基础设施之前，你需要构建你的应用程序，这将在下一节中介绍。
- en: Orchestrating the Compose launch
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编排Compose启动
- en: 'Running `docker-compose up` is a convenient and simple way to start your infrastructure.
    However, you need your code to be built before building your containers. It is
    an easy step to overlook. Refer to some npm scripts that you can use to orchestrate
    the launch of your infrastructure:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `docker-compose up` 是启动你的基础设施的一种方便简单的方式。然而，在构建容器之前，你需要先构建你的代码。这是一个容易忽视的简单步骤。请参考以下npm脚本，你可以使用它们来编排你的基础设施启动：
- en: '[PRE29]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We implemented a `build` script that runs the `build` commands for the server
    and the web app. A `test` script can do the same for executing tests. We implemented
    an `npm start` command that can automatically run the `build` command and run
    `compose up`. As a bonus, we also implemented `start:backend` and `start:database`
    scripts that can run alternate `docker-compose` files to stand up just the server
    or the database. You may create these files by removing the unnecessary parts
    of the master `docker-compose.yml` file. Refer to the GitHub repo for examples.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了一个`build`脚本，该脚本运行服务器和web应用的`build`命令。一个`test`脚本可以执行相同的操作来执行测试。我们还实现了一个`npm
    start`命令，它可以自动运行`build`命令并运行`compose up`。作为额外的好处，我们还实现了`start:backend`和`start:database`脚本，可以运行不同的`docker-compose`文件来仅启动服务器或数据库。你可以通过删除主`docker-compose.yml`文件中的不必要的部分来创建这些文件。有关示例，请参阅GitHub仓库。
- en: When coding on the server, I normally execute `npm run start:database` to stand
    up the database and, in a separate terminal window, I launch the server using
    `npm start` from the `server` folder. This way, I can see logs being generated
    by both systems side by side.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器上编码时，我通常执行`npm run start:database`来启动数据库，并在单独的终端窗口中，从`server`文件夹使用`npm start`启动服务器。这样，我可以并排看到两个系统生成的日志。
- en: Execute `npm start` to verify that your `docker-compose` configuration is working.
    Hit *Ctrl* + *C* to stop the infrastructure.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`npm start`以验证你的`docker-compose`配置是否正常工作。按*Ctrl* + *C*停止基础设施。
- en: Compose on CircleCI
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在CircleCI上组合
- en: 'You can execute your Compose infrastructure on CircleCI to verify the correctness
    of your configuration and run a quick integration test. Refer to the following
    updated workflow:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在CircleCI上执行你的Compose基础设施以验证配置的正确性并运行快速集成测试。请参阅以下更新的工作流程：
- en: '[PRE30]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We ensure that both `server` and `web-app` are built before running a new job
    named `test_compose`, which checks out the code, initializes the submodule, and
    copies the `dist` folders of both builds, as shown here:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确保在运行名为`test_compose`的新任务之前，`server`和`web-app`都已构建，该任务检查代码、初始化子模块并复制两个构建的`dist`文件夹，如下所示：
- en: '[PRE31]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: After copying the `dist` files, the job then lays down the `.env` files from
    the CircleCI environment variables. Then, we run `docker-compose up` to stand
    up our server. Next, we test the `web-app` by running a `curl` command to retrieve
    its `index.html` file. We `run curl` after waiting for the server to become available
    using `dockerize -wait`. Similarly, we test the integration of our API server
    and the database by logging in using our demo user.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在复制`dist`文件后，该任务随后放置来自CircleCI环境变量的`.env`文件。然后，我们运行`docker-compose up`来启动我们的服务器。接下来，我们通过运行一个`curl`命令来检索其`index.html`文件来测试`web-app`。在等待服务器通过`dockerize
    -wait`变得可用后，我们运行`curl`。同样，我们通过使用我们的演示用户登录来测试我们的API服务器和数据库的集成。
- en: Congratulations! Now, you have a pretty good understanding of how our full stack
    architecture is pieced together at a high level. In the latter half of this chapter,
    we will go over how the API is implemented, how it integrates with the database,
    and see how JWT auth works in tandem with the API and database.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！现在，你对我们的全栈架构在高级别是如何拼接的有了相当好的理解。在本章的后半部分，我们将介绍API是如何实现的，它是如何与数据库集成的，以及我们将看到JWT身份验证是如何与API和数据库协同工作的。
- en: Let's continue by diving into API design.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续深入探讨API设计。
- en: RESTful APIs
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RESTful API
- en: 'In full stack development, nailing down the API design early on is important.
    The API design itself is closely correlated with how your data contract will look.
    You may create RESTful endpoints or use the next-gen GraphQL technology. In designing
    your API, frontend and backend developers should collaborate closely to achieve
    shared design goals. Some high-level goals are listed as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在全栈开发中，尽早确定API设计非常重要。API设计本身与你的数据合约的外观密切相关。你可以创建RESTful端点或使用下一代GraphQL技术。在设计你的API时，前端和后端开发者应紧密合作以实现共同的设计目标。以下是一些高级目标：
- en: Minimize data transmitted between the client and server
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化客户端和服务器之间传输的数据
- en: Stick to well-established design patterns (in other words, data pagination)
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循已建立的设计模式（换句话说，数据分页）
- en: Design to reduce business logic present in the client
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计以减少客户端中的业务逻辑
- en: Flatten data structures
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扁平化数据结构
- en: Do not expose database keys or relationships
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要暴露数据库键或关系
- en: Version endpoints from the get-go
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一开始就对端点进行版本控制
- en: Design around major data entities
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 围绕主要数据实体进行设计
- en: You should aim to implement the business logic in your RESTful API. Ideally,
    your frontend shouldn't contain anything more than presentation logic. Any `if`
    statement implemented by the frontend should also be verified in your backend.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该旨在在你的 RESTful API 中实现业务逻辑。理想情况下，你的前端不应该包含比展示逻辑更多的内容。任何由前端实现的 `if` 语句也应该在你的后端得到验证。
- en: As discussed in *Chapter 1*, *Introduction to Angular and Its Concepts*, it
    is critical to aim for a stateless design in both the backend and frontend. Every
    request should utilize non-blocking I/O methods and should not rely on any existing
    session. This is the key to infinitely scaling your web application using cloud
    hosting providers.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在 *第 1 章*，*Angular 简介及其概念* 中讨论的那样，在后台和前端实现无状态设计至关重要。每个请求都应使用非阻塞 I/O 方法，并且不应依赖于任何现有会话。这是使用云托管提供商无限扩展你的
    Web 应用程序的关键。
- en: Whenever you're implementing a project, it is important to limit, if not eliminate,
    experimentation. This is especially true in full stack projects. The downstream
    effect of missteps in API design can be profound and impossible to correct once
    your application goes live.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你在实施项目时，都应限制，如果可能的话，消除实验。这在全栈项目中尤其如此。一旦你的应用程序上线，API 设计中的失误的下游影响可能是深远的，并且无法纠正。
- en: Next, let's look into designing an API around major data entities. In this case,
    we'll review the implementation of an API surrounding users, including authentication.
    First we'll explore how we can define an endpoint using Swagger, so we can concretely
    communicate the intent of our design to team members.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何围绕主要数据实体设计 API。在这种情况下，我们将回顾围绕用户（包括身份验证）的 API 实现。首先，我们将探索如何使用 Swagger
    定义一个端点，这样我们就可以具体地向团队成员传达我们设计的意图。
- en: Remember that only significant pieces of code that are conceptually significant
    are covered in this chapter. While you may choose to implement this code from
    scratch, it is not necessary to get an understanding of how it works. If you choose
    to implement it from scratch, refer to the complete source code at [https://github.com/duluca/lemon-mart-server](https://github.com/duluca/lemon-mart-server)
    to follow along and bridge the gaps in your implementation.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，本章只涵盖了概念上重要的代码片段。虽然你可以选择从头开始实现这段代码，但理解其工作原理并不需要这样做。如果你选择从头开始实现，请参考 [https://github.com/duluca/lemon-mart-server](https://github.com/duluca/lemon-mart-server)
    上的完整源代码，以跟进并填补你实现中的空白。
- en: Later on, Swagger will become a documentation tool, reflecting the capability
    of our APIs.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在以后，Swagger 将成为文档工具，反映我们 API 的能力。
- en: API design with Swagger
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Swagger 进行 API 设计
- en: Swagger will allow you to design and document your web API. For teams, it can
    act as a great communication tool between frontend and backend developers, thereby
    reducing a lot of friction. Additionally, defining your API surface early on allows
    implementation to begin without worrying about late-stage integration challenges.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger 将允许你设计和记录你的 Web API。对于团队来说，它可以作为前端和后端开发者之间出色的沟通工具，从而减少很多摩擦。此外，尽早定义你的
    API 表面，可以让实现开始而不必担心后期集成挑战。
- en: We will implement a users API as we move on, so as to demonstrate how Swagger
    works.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续前进，我们将实现一个用户 API，以展示 Swagger 的工作原理。
- en: I highly recommend installing the Swagger Viewer VS Code extension, which allows
    us to preview the YAML file without running any additional tools.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈推荐安装 Swagger Viewer VS Code 扩展，它允许我们在不运行任何额外工具的情况下预览 YAML 文件。
- en: 'Let''s begin by exploring the `swagger.yaml` file at the root of the monorepo:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从探索单一代码库根目录下的 `swagger.yaml` 文件开始：
- en: Open `swagger.yaml` in VS Code.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中打开 `swagger.yaml`。
- en: Install the VS Code extension called Swagger Preview.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装名为 Swagger Preview 的 VS Code 扩展。
- en: Hit *Ctrl* + *Shift* + *P*, or ![](img/B14094_10_15.png)+![](img/B14094_10_16.png)+`P`,
    to bring up the command palette and run **Preview Swagger**.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 *Ctrl* + *Shift* + *P*，或者点击 ![](img/B14094_10_15.png)+![](img/B14094_10_16.png)+`P`，以打开命令面板并运行
    **预览 Swagger**。
- en: See the preview, as shown here:![](img/B14094_10_04.png)
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看看预览，如图所示：![](img/B14094_10_04.png)
- en: 'Figure 10.4: Swagger.yaml preview'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.4：Swagger.yaml 预览
- en: Using the Swagger UI view, you are going to be able to try out commands and
    execute them against your server environment.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Swagger UI 视图，你将能够尝试命令并在你的服务器环境中执行它们。
- en: Defining a Swagger YAML file
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义 Swagger YAML 文件
- en: 'We''ll use Swagger spec version `openapi: 3.0.1`, which implements the OpenAPI
    standard. Let''s go over the major components of the `swagger.yaml` file here:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将使用 Swagger 规范版本 `openapi: 3.0.1`，它实现了 OpenAPI 标准。让我们在这里回顾 `swagger.yaml`
    文件的主要组件：'
- en: For more information about how a Swagger file is defined, refer to [https://swagger.io/specification/](https://swagger.io/specification/).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Swagger文件定义的更多信息，请参阅[https://swagger.io/specification/](https://swagger.io/specification/)。
- en: 'The YAML file starts with general information and target servers:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: YAML文件以一般信息和目标服务器开始：
- en: '[PRE32]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Under `components`, we define common `securitySchemes` and responses, which
    define the authentication scheme we intend to implement and how the shape of our
    error message response will appear:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`components`下，我们定义常见的`securitySchemes`和响应，这些定义了我们打算实施的认证方案以及我们的错误消息响应的形状：
- en: '[PRE33]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note the usage of `$ref` to reuse repeating elements. You can see `ServerMessage`
    being defined here.
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到`$ref`的使用，以重复使用重复元素。您可以看到在这里定义了`ServerMessage`。
- en: 'Under `components`, we define shared data `schemas`, which declares the data
    entities that we either take in as input or return to the client:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`components`下，我们定义共享数据`schemas`，它声明了要么作为输入接收要么返回给客户端的数据实体：
- en: '[PRE34]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Under `components`, we add shared `parameters`, making it easy to reuse common
    patterns such as paginated endpoints:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`components`下，我们添加共享`parameters`，这使得重用常见的模式，如分页端点变得容易：
- en: '[PRE35]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Under `paths`, we begin defining REST endpoints, such as a `post` endpoint
    for the `/login` path:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`paths`下，我们开始定义REST端点，例如`/login`路径的`post`端点：
- en: '[PRE36]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note that `requestBody` defines input variables that are required with a type
    of `string`. Under `responses`, we can define how a successful `200` response
    and an unsuccessful `401` response to a request appear. In the former case, we
    return an `accessToken`, while in the latter case, we return an `UnauthorizedError`,
    as defined in Step 2.
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`requestBody`定义了类型为`string`的必需输入变量。在`responses`下，我们可以定义对请求成功返回的`200`响应和失败返回的`401`响应的外观。在前者的情况下，我们返回一个`accessToken`，而在后者的情况下，我们返回一个`UnauthorizedError`，如第二步中定义的那样。
- en: 'Under `paths`, we continue by adding the following paths:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`paths`下，我们继续添加以下路径：
- en: '[PRE37]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The OpenAPI spec is powerful, allowing you to define intricate requirements
    on how users should be able to interact with your API. The specification document
    at [https://swagger.io/docs/specification](https://swagger.io/docs/specification)
    is an invaluable resource while developing your own API definition.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAPI规范功能强大，允许您定义复杂的用户如何与您的API交互的要求。在[https://swagger.io/docs/specification](https://swagger.io/docs/specification)上的规范文档在开发您自己的API定义时是一个无价资源。
- en: Preview Swagger file
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 预览Swagger文件
- en: You can validate your Swagger file at [https://swaggerhub.com](https://swaggerhub.com)
    for free. After you sign up for a free account, create a new project and define
    your YAML file. SwaggerHub will highlight any errors you made. It will also give
    you a preview of the web view, which is the same one you get with the Swagger
    Preview VS Code extension.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以免费在[https://swaggerhub.com](https://swaggerhub.com)验证您的Swagger文件。在您注册免费账户后，创建一个新的项目并定义您的YAML文件。SwaggerHub将突出显示您所犯的错误。它还会为您提供网页预览，这与您在Swagger
    Preview VS Code扩展中获得的预览相同。
- en: 'Refer to the following screenshot to see how a valid Swagger YAML definition
    looks on SwaggerHub:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下截图，查看有效的Swagger YAML定义在SwaggerHub上的样子：
- en: '![](img/B14094_10_05.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_10_05.png)'
- en: 'Figure 10.5: Valid Swagger YAML definition on SwaggerHub'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5：SwaggerHub上的有效Swagger YAML定义
- en: Our goal is to integrate this interactive documentation with our Express.js
    APIs.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目的是将这种交互式文档与我们的Express.js API集成。
- en: Now, let's see how you can implement such an API.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看您如何实现这样的API。
- en: Implementing APIs with Express.js
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Express.js实现API
- en: Before we begin implementing our APIs, let's review the target file structure
    of our backend in sections, so we get an understanding of how the server is bootstrapped,
    how routing is configured for API endpoints, how public resources are served,
    and how services are configured. Minimal MEAN intentionally sticks to the basics,
    so you can learn more about the underlying technologies. While I have delivered
    production systems using minimal MEAN, you may not enjoy the barebones development
    experience as much as I do. In this case, you may consider Nest.js, which is a
    popular framework for implementing full stack Node.js apps. Nest.js has a rich
    feature set with an architecture and coding style that closely resemble Angular.
    I recommend using such a library after you have mastered the basics of the MEAN stack.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实现我们的 API 之前，让我们分节回顾我们后端的目标文件结构，以便我们了解服务器是如何启动的，API 端点的路由是如何配置的，公共资源是如何提供的，以及服务是如何配置的。Minimal
    MEAN 故意坚持基本原理，这样您就可以更多地了解底层技术。虽然我已经使用 Minimal MEAN 实现了生产系统，但您可能不会像我一样享受这种骨架式开发体验。在这种情况下，您可以考虑
    Nest.js，这是一个用于实现全栈 Node.js 应用程序的热门框架。Nest.js 具有丰富的功能集，其架构和编码风格与 Angular 非常相似。我建议在您掌握了
    MEAN 栈的基础之后使用此类库。
- en: Kudos to Kamil Mysliwiec and Mark Pieszak for creating a great tool and vibrant
    community around Nest.js. You can read more about Nest.js at [https://nestjs.com/](https://nestjs.com/)
    and solicit consulting services at [https://trilon.io/](https://trilon.io/).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 向 Kamil Mysliwiec 和 Mark Pieszak 表示祝贺，他们创建了一个出色的工具，并在 Nest.js 周围营造了一个充满活力的社区。您可以在
    [https://nestjs.com/](https://nestjs.com/) 上了解更多关于 Nest.js 的信息，并在 [https://trilon.io/](https://trilon.io/)
    获取咨询服务。
- en: 'Now, let''s review the file structure of our Express server:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾一下我们的 Express 服务器的文件结构：
- en: '[PRE38]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s review the purpose and the interaction between these files by looking
    at a component diagram, giving us an overview of the architecture and the dependency
    tree:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看组件图，我们可以回顾这些文件的目的和它们之间的交互，从而获得架构和依赖树的概览：
- en: '![](img/B14094_10_06.png)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_10_06.png)'
- en: 'Figure 10.6: Express server architecture'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6：Express 服务器架构
- en: '`index.ts` contains a `start` function, which bootstraps the application leveraging
    three major helpers:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.ts` 包含一个 `start` 函数，该函数利用三个主要助手启动应用程序：'
- en: '`config.ts`: Manages environment variables and settings.'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`config.ts`：管理环境变量和设置。'
- en: '`app.ts`: Configures Express.js, defines all API paths, and then routers implement
    the paths and leverage services that contain the business logic. Services use
    models, such as `user.ts`, to access the database.'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`app.ts`：配置 Express.js，定义所有 API 路径，然后路由实现路径并利用包含业务逻辑的服务。服务使用模型，如 `user.ts`，来访问数据库。'
- en: '`document-ts`: Establishes a connection to the database and configures it,
    and leverages `user.ts` to configure a seed user during startup.'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`document-ts`：建立与数据库的连接并对其进行配置，并在启动时利用 `user.ts` 配置种子用户。'
- en: You can see that the components at the top of the diagram are responsible for
    start up and configuration chores, including configuring API paths, which represent
    the **API** layer. The **Services** layer should contain most of the business
    logic for the app, while persistence is handled in the **Models** layer.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，图中顶部的组件负责启动和配置任务，包括配置 API 路径，这代表了 **API** 层。**服务**层应该包含应用程序的大部分业务逻辑，而持久性则在
    **模型** 层处理。
- en: 'Refer to the following implementation of `index.ts` without any database features:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下 `index.ts` 的实现，其中不包含任何数据库功能：
- en: '[PRE39]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note that the last line of code shown, `start()`, is the function call that
    triggers the initialization of the server.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，显示的最后一行代码 `start()` 是触发服务器初始化的函数调用。
- en: Now, let's look into how the Express server is set up.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 Express 服务器是如何设置的。
- en: Bootstrapping the server
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务器启动
- en: '`App.ts` configures Express.js, along with serving static assets, routing,
    and versioning. Express.js leverages middleware functions to integrate with libraries
    or your own code, such as an authenticate method:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`App.ts` 配置 Express.js，同时提供静态资源服务、路由和版本控制。Express.js 通过中间件函数与库或您自己的代码集成，例如一个认证方法：'
- en: '[PRE40]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the preceding code, note that configuring Express is straightforward with
    the `use()` method. First, we configure `cors`, and then express parsers and `logger`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，请注意配置 Express 使用 `use()` 方法非常简单。首先，我们配置 `cors`，然后是 express 解析器和 `logger`。
- en: 'Next, using the `express.static` function, we serve the `public` folder at
    the root''s route, `/`, so we can display some useful information about our server,
    as shown:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用`express.static`函数，我们在根路由`/`上提供`public`文件夹，这样我们就可以显示有关我们服务器的一些有用信息，如下所示：
- en: '![](img/B14094_10_07.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_10_07.png)'
- en: 'Figure 10.7: LemonMart server landing page'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7：LemonMart服务器登录页面
- en: We will cover how to configure the `/api-docs` endpoint, which is referenced
    above, in the next section.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中介绍如何配置上面提到的`/api-docs`端点。
- en: Finally, we configure the router, which is defined in `api.ts`.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们配置路由器，它在`api.ts`中定义。
- en: Routes and versioning
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路由和版本控制
- en: '`Api.ts` configures the Express router. Refer to the following implementation:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`Api.ts`配置了Express路由器。请参考以下实现：'
- en: '[PRE41]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this case, we have two child routes for `v1` and `v2`. It is critical to
    always version the APIs you implement. Once an API becomes public, it can be very
    tricky, even impossible sometimes, to simply phase out an API for a newer version.
    Even minor code changes or slight differences in the API can cause clients to
    break. You must pay careful attention to only making backward-compatible changes
    to your API.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有`v1`和`v2`的两个子路由。始终对您实现的API进行版本控制是至关重要的。一旦API公开，简单地逐步淘汰API以适应新版本可能会非常棘手，有时甚至不可能。即使是微小的代码更改或API的细微差异都可能导致客户端崩溃。您必须仔细注意，只为您的API做出向后兼容的更改。
- en: At some point, you will have a need to completely rewrite the endpoint to meet
    new requirements, performance, and business needs, at which point you can simply
    implement a `v2` version of your endpoint, while leaving the `v1` implementation
    unchanged. This allows you to innovate at the pace you need to, while keeping
    legacy consumers of your app functional.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，您可能需要完全重写端点以满足新的需求、性能和业务需求，此时您可以简单地实现端点的`v2`版本，同时保持`v1`实现不变。这允许您以您需要的速度进行创新，同时保持您的应用程序的旧版消费者功能。
- en: In short, you should version every API you create. By doing this, you force
    your consumers to version their HTTP calls to your API. As time goes on, you may
    transition, duplicate, and retire APIs under different versions. Consumers then
    have a choice to call whichever version of the API works for them.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，您应该为创建的每个API进行版本控制。通过这样做，您迫使您的消费者对您的API的HTTP调用进行版本控制。随着时间的推移，您可以在不同的版本下过渡、复制和淘汰API。消费者然后可以选择调用对他们有用的API版本。
- en: 'Configuring a route is trivial. Let''s see the configuration for `v2`, as shown:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 配置路由非常简单。让我们看看`v2`的配置，如下所示：
- en: '[PRE42]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The question mark at the end of `/users?` means that both `/user` and `/users`
    will work against operations implemented in `userRouter`. This is a great way
    to avoid typos, while allowing the developer to choose the plurality that makes
    sense for the operation.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`/users?`结尾的问号意味着`/user`和`/users`都将针对`userRouter`中实现的操作工作。这是一种避免拼写错误的好方法，同时允许开发者选择对操作有意义的复数形式。'
- en: 'In `userRouter`, you can then implement GET, POST, PUT, and DELETE operations.
    Refer to the following implementation:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在`userRouter`中，您可以实现GET、POST、PUT和DELETE操作。请参考以下实现：
- en: '[PRE43]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the preceding code, you can observe the use of route parameters. You can
    consume route parameters through a request object, such as `req.params.userId`.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，您可以观察到路由参数的使用。您可以通过请求对象，如`req.params.userId`，来消费路由参数。
- en: Note that all routes in the sample code are tagged as `async` because they will
    all be making a database call, which we are going to `await`. If your route is
    synchronous, then you don't require the `async` keyword.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，示例代码中的所有路由都被标记为`async`，因为它们都将进行数据库调用，我们将使用`await`。如果您的路由是同步的，那么您不需要`async`关键字。
- en: Next, let's look into services.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看服务。
- en: Services
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务
- en: We don't want to implement our business logic in the router files, which represents
    our API layer. The API layer should largely consist of transforming data and making
    calls to the business logic layer.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望在表示我们的API层的路由文件中实现业务逻辑。API层应该主要包含转换数据和调用业务逻辑层。
- en: You can implement services using Node.js and TypeScript features. No fancy dependency
    injection is necessary. The sample application implements two services – `authService`
    and `userService`.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Node.js和TypeScript功能来实现服务。不需要复杂的依赖注入。示例应用程序实现了两个服务 - `authService`和`userService`。
- en: 'For example, in `userService.ts`, you can implement a function called `createNewUser`:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在`userService.ts`中，您可以实现一个名为`createNewUser`的函数：
- en: '[PRE44]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '`createNewUser` accepts `userData` in the shape of `IUser` and, when it is
    done creating the user, it returns an instance of `User`. We can then use this
    function in our router as follows:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`createNewUser` 接受 `userData`，其形状为 `IUser`，当它完成用户创建后，返回一个 `User` 实例。然后我们可以将此函数用于我们的路由器，如下所示：'
- en: '[PRE45]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We can await the result of `createNewUser` and, if successful, return the created
    object as a response to the POST request.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以等待 `createNewUser` 的结果，如果成功，将创建的对象作为对 POST 请求的响应返回。
- en: Note that even though we are casting `req.body` as `IUser`, this is only a development
    time comfort feature. At runtime, the consumer may pass any number of properties
    to the body. Careless handling of request parameters is one of the primary ways
    in which your code can be maliciously exploited.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管我们将 `req.body` 转换为 `IUser` 类型，但这仅是一个开发时的便利功能。在运行时，消费者可以向主体传递任意数量的属性。粗心处理请求参数是您的代码可能被恶意利用的主要方式之一。
- en: Now that we have an understanding of the skeleton of our Express server, let's
    see how you can configure Swagger so that you can use it as a guide to implementation
    and create living documentation for your API.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Express 服务器的骨架结构，让我们看看如何配置 Swagger，以便您可以用它作为实现的指南并为您 API 创建活页文档。
- en: Configuring Swagger with Express
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 Swagger 与 Express
- en: Configuring Swagger with Express is a manual process. Forcing yourself to manually
    document the endpoints has a great side effect. By slowing down, you will get
    the opportunity to consider your implementation from the consumer's perspective
    as well as the implementor's perspective. This perspective will help you to resolve
    potential issues with your endpoints during development, thereby avoiding costly reworking.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 配置 Swagger 与 Express 是一个手动过程。强迫自己手动记录端点有一个很好的副作用。通过放慢速度，您将有机会从消费者和实现者的角度考虑您的实现。这种视角将帮助您在开发过程中解决端点可能存在的潜在问题，从而避免昂贵的返工。
- en: The major benefit of integrating Swagger with your server is that you will get
    the same interactive Swagger UI that was covered earlier in this chapter, so your
    testers and developers can discover or test your API directly from a web interface.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Swagger 集成到您的服务器中的主要好处是，您将获得本章前面提到的相同的交互式 Swagger UI，因此您的测试人员和开发者可以直接从网络界面发现或测试您的
    API。
- en: 'We are going to use two helper libraries to help us integrate Swagger into
    our server:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用两个辅助库来帮助我们集成 Swagger 到我们的服务器中：
- en: '`swagger-jsdoc`: This allows you to implement OpenAPI specs right on top of
    the relevant code by using the `@swagger` identifier in a `JSDoc` comment block,
    generating a `swagger.json` file as output.'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`swagger-jsdoc`：它允许您通过在 `JSDoc` 注释块中使用 `@swagger` 标识符在相关代码上实现 OpenAPI 规范，生成
    `swagger.json` 文件作为输出。'
- en: '`swagger-ui-express`: This consumes the `swagger.json` file to display the
    interactive Swagger UI web interface.'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`swagger-ui-express`：它消费 `swagger.json` 文件以显示交互式 Swagger UI 网络界面。'
- en: 'Let''s go over how Swagger is configured to work with Express.js:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 Swagger 如何配置与 Express.js 一起工作：
- en: 'The dependencies and type information for TypeScript are shown here:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TypeScript 的依赖项和类型信息如下所示：
- en: '[PRE46]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Let''s go over the `docs-config.ts` file, which configures the base OpenAPI
    definition:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们来看看 `docs-config.ts` 文件，它配置了基本的 OpenAPI 定义：
- en: '[PRE47]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Modify the `servers` property to include the location of your testing, staging,
    or production environments. This allows consumers of your API to test the API
    using the web interface without additional tooling. Note that the `apis` property
    informs the code files that `swaggerJsdoc` should parse when constructing the
    `swagger.json` file. This routine runs during the bootstrapping of the server,
    which is why we reference the transpiled `.js` files instead of `.ts` files.
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 修改 `servers` 属性以包含您的测试、预发布或生产环境的位置。这允许您的 API 消费者使用网络界面测试 API，而无需额外的工具。请注意，`apis`
    属性通知 `swaggerJsdoc` 在构建 `swagger.json` 文件时应解析的代码文件。此过程在服务器启动时运行，这就是为什么我们引用了转译的
    `.js` 文件而不是 `.ts` 文件。
- en: 'Bootstrap the swagger config in `app.ts`:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `app.ts` 中启动 Swagger 配置：
- en: '[PRE48]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Specs contain the content of the `swagger.json` file, which is then passed to
    `swaggerUi`. Then, using the server middleware, we can configure `swaggerUi` to
    host the web interface at `/api-docs`.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 规范包含 `swagger.json` 文件的内容，然后传递给 `swaggerUi`。然后，使用服务器中间件，我们可以配置 `swaggerUi` 在
    `/api-docs` 上托管网络界面。
- en: You already have the OpenAPI definitions that need to be used to complete the
    implementation of the application from the beginning of this chapter. Refer to
    the complete source code at [https://github.com/duluca/lemon-mart-server](https://github.com/duluca/lemon-mart-server)
    for additional help.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经拥有了从本章开始就需要用于完成应用程序实现的 OpenAPI 定义。有关更多信息，请参考完整的源代码 [https://github.com/duluca/lemon-mart-server](https://github.com/duluca/lemon-mart-server)。
- en: Congratulations! Now you have a good understanding of how our Express server
    works. Next, let's look at how to connect to MongoDB.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！现在您已经很好地理解了我们的 Express 服务器是如何工作的。接下来，让我们看看如何连接到 MongoDB。
- en: MongoDB ODM with DocumentTS
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB ODM 与 DocumentTS
- en: DocumentTS acts as an ODM, implementing a layer of models to enable rich and
    customizable interaction with database objects. ODM is the document-based database
    equivalent of an **Object Relational Mapper** (**ORM**) in relational databases.
    Think Hibernate or Entity Framework. If you're not familiar with these concepts,
    I recommend that you do further research before moving on.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: DocumentTS 作为 ODM，通过实现模型层来启用与数据库对象的丰富和可定制的交互。ODM 是文档数据库中与关系数据库中的 **对象关系映射器**（**ORM**）相对应的。想想
    Hibernate 或 Entity Framework。如果您不熟悉这些概念，我建议在继续之前进行进一步的研究。
- en: 'At its core, DocumentTS leverages the Node.js driver for MongoDB. This driver
    is implemented by the makers of MongoDB. It guarantees to offer the best performance
    and feature parity with new MongoDB releases, whereas third-party libraries often
    lag in supporting new features. Using the `database.getDbInstance` method, you
    can get access to the native driver directly. Otherwise, you will be accessing
    Mongo through models that you implement. Refer to the following diagram for an
    overview:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，DocumentTS 利用 MongoDB 的 Node.js 驱动程序。该驱动程序由 MongoDB 的制作者实现。它保证提供最佳性能并与新
    MongoDB 版本保持功能一致性，而第三方库通常在支持新功能方面落后。使用 `database.getDbInstance` 方法，您可以直接访问原生驱动程序。否则，您将通过您实现的模型访问
    Mongo。请参考以下图表以获取概述：
- en: '![](img/B14094_10_08.png)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14094_10_08.png)'
- en: 'Figure 10.8: DocumentTS overview'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8：DocumentTS 概述
- en: You can read more about MongoDB's Node.js driver at [https://mongodb.github.io/node-mongodb-native/](https://mongodb.github.io/node-mongodb-native/).
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://mongodb.github.io/node-mongodb-native/](https://mongodb.github.io/node-mongodb-native/)
    上了解更多关于 MongoDB Node.js 驱动程序的信息。
- en: About DocumentTS
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于 DocumentTS
- en: 'DocumentTS provides three major features:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: DocumentTS 提供了三个主要功能：
- en: '`connect()`: A MongoDB async connection harness'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`connect()`：一个 MongoDB 异步连接工具'
- en: '`Document` and `IDocument`: A base class and interface to help define your
    own models'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Document` 和 `IDocument`：一个基类和接口，帮助您定义自己的模型'
- en: '`CollectionFactory`: Defines collections, organizes indexes, and aggregates
    queries alongside collection implementations'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CollectionFactory`：定义集合，组织索引，并在集合实现中聚合查询'
- en: 'Here are the convenience features that a DocumentTS collection provides:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 DocumentTS 集合提供的便利功能：
- en: '`get collection` returns the native MongoDB collection, so you can operate
    on it directly:'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get collection` 返回原生 MongoDB 集合，因此您可以直接操作它：'
- en: '[PRE49]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '`aggregate` allows you to run a MongoDB aggregation pipeline:'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aggregate` 允许您运行 MongoDB 聚合管道：'
- en: '[PRE50]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '`findOne` and `findOneAndUpdate` simplify the operation of commonly used database
    functionality, automatically hydrating the models returned:'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`findOne` 和 `findOneAndUpdate` 简化了常用数据库功能的操作，自动填充返回的模型：'
- en: '[PRE51]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '`findWithPagination` is by far the best feature of DocumentTS, allowing you
    to filter, sort, and paginate large collections of data. This function is geared
    toward use with data tables, so you specify searchable properties, turn off hydration,
    and use a debug feature to fine-tune your queries:'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`findWithPagination` 是 DocumentTS 中迄今为止最好的功能，允许您过滤、排序和分页大量数据。此功能旨在与数据表一起使用，因此您指定可搜索属性，关闭填充，并使用调试功能来微调您的查询：'
- en: '[PRE52]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'DocumentTS aims to be reliable, optional, and convenient to use. DocumentTS
    directly exposes the developer to the native Node.js driver, so you learn how
    to work with MongoDB instead of some library. Developers can optionally leverage
    the library''s convenience features, including the following:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: DocumentTS 致力于成为可靠、可选且易于使用的工具。DocumentTS 直接将开发者暴露于原生 Node.js 驱动程序，因此您学习如何与 MongoDB
    交互，而不是使用某个库。开发者可以选择利用库的便利功能，包括以下内容：
- en: Define your own models through simple interfaces.
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过简单的接口定义您自己的模型。
- en: Choose fields that you want to automatically hydrate, such as child or related
    objects.
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择您想要自动填充的字段，例如子对象或相关对象。
- en: Serialize calculated fields with every request.
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次请求时序列化计算字段。
- en: Protect certain fields (such as passwords) from serialization so that they aren't
    accidently sent across the wire.
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护某些字段（如密码）免于序列化，以防止它们意外地通过网络发送。
- en: By being optional, DocumentTS allows developers to transition to new features
    in their own time. If performance becomes a concern, you can easily switch to
    native MongoDB calls to get the best performance. Using DocumentTS, you will spend
    more time reading MongoDB documentation than DocumentTS documentation.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 由于DocumentTS是可选的，因此开发人员可以按自己的时间表过渡到新功能。如果性能成为关注点，您可以轻松切换到原生MongoDB调用以获得最佳性能。使用DocumentTS，您将花费更多时间阅读MongoDB文档，而不是DocumentTS文档。
- en: Mongoose is a popular library for interacting with MongoDB. However, it is a
    wrapper around MongoDB, requiring a full buy-in. Furthermore, the library abstracts
    away the native driver, so it is very sensitive to changes and updates in the
    ecosystem. You can read more about Mongoose at [https://mongoosejs.com/](https://mongoosejs.com/).
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose是一个用于与MongoDB交互的流行库。然而，它是一个围绕MongoDB的包装器，需要全面采用。此外，该库抽象了原生驱动程序，因此它对生态系统中的更改和更新非常敏感。您可以在[https://mongoosejs.com/](https://mongoosejs.com/)上了解更多关于Mongoose的信息。
- en: 'Install MongoDB dependencies and type information for TypeScript with the following
    commands:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令安装MongoDB依赖项和TypeScript类型信息：
- en: '[PRE53]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Next, let's see how we connect to the database.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何连接到数据库。
- en: Connecting to the database
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接到数据库
- en: It can be a challenge to ensure that database connectivity exists when writing
    a fully async web application. `connect()` makes it easy to connect to a MongoDB
    instance and makes it safe to be called simultaneously from multiple threads starting
    up at the same time.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写完全异步的Web应用程序时，确保数据库连接存在可能是一个挑战。`connect()`函数使得连接到MongoDB实例变得简单，并且可以从多个同时启动的线程中安全地调用。
- en: 'Let''s start by configuring your environment variables:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先配置一下环境变量：
- en: 'Remember that the `MONGO_URI` connection string resides in `server/.env`:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记住`MONGO_URI`连接字符串位于`server/.env`中：
- en: '[PRE54]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In order to update the username, password, and database name, you''ll need
    to edit the following variables in the top level `.env` file:'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了更新用户名、密码和数据库名称，您需要编辑顶级`.env`文件中的以下变量：
- en: '[PRE55]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Remember that `.env` changes only take effect when you restart your servers.
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记住，`.env`更改只有在您重新启动服务器后才会生效。
- en: 'Let''s see how `document-ts` integrates with `index.ts`:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看`document-ts`如何与`index.ts`集成：
- en: '[PRE56]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We attempt to connect to the database using a `try/catch` block. Once the Express
    server is up and running, we call `createIndexes`, which, in turn, calls a function
    with the same name on `UserCollection`. Beyond performance considerations, MongoDB
    indexes are necessary to enable fields to become searchable.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试使用`try/catch`块连接到数据库。一旦Express服务器启动并运行，我们调用`createIndexes`，它反过来调用`UserCollection`上具有相同名称的函数。除了性能考虑之外，MongoDB索引对于使字段可搜索是必要的。
- en: Models with IDocument
  id: totrans-418
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 具有IDocument的模型
- en: 'You may implement an `IUser` interface similar to the one in LemonMart. However,
    this one will be extending the `IDocument` defined in DocumentTS:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以实施一个类似于LemonMart中的`IUser`接口。然而，这个接口将扩展DocumentTS中定义的`IDocument`：
- en: 'Here is the `IUser` interface:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是`IUser`接口：
- en: '[PRE57]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The interfaces and base classes provided by DocumentTS aim to help you develop
    your business logic and database queries in a consistent manner. I encourage you
    to explore the base classes and interfaces by `Ctrl` + clicking on them so that
    you can see the source code behind them.
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: DocumentTS提供的接口和基类旨在帮助您以一致的方式开发业务逻辑和数据库查询。我鼓励您通过`Ctrl` + 点击它们来探索基类和接口，以便您可以看到它们背后的源代码。
- en: 'Now, here is the `User` class extending `Document<T>` and implementing Swagger
    documentation:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，这里是一个扩展`Document<T>`并实现Swagger文档的`User`类：
- en: '[PRE58]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note the properties, `getCalculatedPropertiesToInclude` and `getPropertiesToExclude`.
    These define whether a field should be serialized by the client or allowed to
    be written to the database.
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意属性`getCalculatedPropertiesToInclude`和`getPropertiesToExclude`。这些属性定义了字段是否应该由客户端序列化或允许写入数据库。
- en: Serialization and deserialization of data is the concept of transforming data
    into a format that can be stored or transported. Refer to the *Further reading*
    section for links to articles regarding serialization and the JSON data format.
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数据的序列化和反序列化是将数据转换为可以存储或传输的格式的概念。请参阅*进一步阅读*部分，以获取有关序列化和JSON数据格式的文章链接。
- en: '`fullName` is a calculated property, so we don''t want to write this value
    to the database. However, `fullName` is useful for the client. On the other hand,
    the `password` property should never be transmitted back to the client, but obviously
    we need to be able to save it to the database for password comparison and changes.
    Upon saving, we pass in the `{ upsert }` object to instruct the database to update
    records even if partial information is provided.'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`fullName`是一个计算属性，因此我们不希望将此值写入数据库。然而，`fullName`对客户端很有用。另一方面，`password`属性永远不应该传回客户端，但显然我们需要能够将其保存到数据库中，以便进行密码比较和更改。在保存时，我们传递一个`{
    upsert }`对象来指示数据库即使在提供部分信息的情况下也要更新记录。'
- en: Remember to provide the complete Swagger definition.
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记得提供完整的Swagger定义。
- en: 'And finally, let''s go over `UserCollectionFactory`, which implements `CollectionFactory<T>`:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们回顾一下实现`CollectionFactory<T>`的`UserCollectionFactory`：
- en: '[PRE59]'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Here, we create a unique index, so another user with the same email won't be
    able to register. We also create a weighted index, which can assist in writing
    filter queries. We apply the indexes right after we connect to the database in
    `index.ts`.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个唯一索引，这样具有相同电子邮件地址的另一个用户将无法注册。我们还创建了一个加权索引，这有助于编写过滤查询。我们在连接到数据库后立即在`index.ts`中应用这些索引。
- en: '`userSearchQuery` is a somewhat contrived example to demonstrate aggregate
    queries in MongoDB. It is possible to execute far more sophisticated and high-performance
    queries using aggregation in MongoDB. You can read more about aggregation in MongoDB
    at [https://docs.mongodb.com/manual/aggregation](https://docs.mongodb.com/manual/aggregation).'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '`userSearchQuery`是一个有点牵强的例子，用于演示MongoDB中的聚合查询。使用MongoDB的聚合功能可以执行更复杂和高效的查询。你可以在[https://docs.mongodb.com/manual/aggregation](https://docs.mongodb.com/manual/aggregation)上了解更多关于聚合的信息。'
- en: 'At the bottom of the file, we instantiate a `UserCollection` and export it,
    so it can be referenced from anywhere in the application:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件底部，我们实例化一个`UserCollection`并将其导出，以便在应用程序的任何地方引用：
- en: '[PRE60]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Note that `UserCollectionFactory` is not exported, as it is only needed in the
    `user.ts` file.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`UserCollectionFactory`没有被导出，因为它只在`user.ts`文件中需要。
- en: Let's see how you can fetch data using the new user model.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用新的用户模型来获取数据。
- en: Implementing JWT auth
  id: totrans-437
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现JWT身份验证
- en: In *Chapter 8*, *Designing Authentication and Authorization*, we discussed how
    to implement a JWT-based authentication mechanism. In LemonMart, you implemented
    a base auth service that can be extended for custom authentication services.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在第8章“设计身份验证和授权”中，我们讨论了如何实现基于JWT的身份验证机制。在LemonMart中，你实现了一个基础认证服务，它可以扩展为自定义认证服务。
- en: 'We''ll leverage three packages for our implementation:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用三个包来实现我们的功能：
- en: '`jsonwebtoken`: Used to create and encode JWTs'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jsonwebtoken`：用于创建和编码JWT'
- en: '`bcryptjs`: Used to hash and salt a user''s password before saving it in the
    database, so we never store a user''s password in plain text'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bcryptjs`：用于在将用户的密码保存到数据库之前对其进行散列和加盐，所以我们永远不会以明文形式存储用户的密码'
- en: '`uuid`: A generated universally unique identifier that is useful when resetting
    a user''s password to a random value'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uuid`：生成一个全局唯一标识符，当需要将用户的密码重置为随机值时很有用'
- en: A hash function is a consistently repeatable, one-way encryption method, which
    means you get the same output every time you provide the same input, but even
    if you have access to the hashed value, you cannot readily figure out what information
    it stores. We can, however, compare whether the user has entered the correct password
    by hashing the user's input and comparing the hash of their input to that of the
    stored hash of their password.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数是一个一致可重复的单向加密方法，这意味着每次提供相同的输入时都会得到相同的输出，即使你有访问散列值的能力，也无法轻易地找出它存储的信息。然而，我们可以通过散列用户的输入并将其与存储的密码散列值进行比较，来比较用户是否输入了正确的密码。
- en: 'Let''s see the JWT auth-related dependencies and type information for TypeScript:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看JWT身份验证相关的依赖和TypeScript类型信息：
- en: '[PRE61]'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Observe the `User` model with password hashing functionality:'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察具有密码散列功能的`User`模型：
- en: '[PRE62]'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Using the `setPassword` method, you can hash the user-provided password and
    safely save it to the database. Later, we will use the `comparePassword` function
    to compare the user-provided value to the hashed password. We never store the
    user-provided value, so the system can never reproduce the user's password, making
    it a safe implementation.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `setPassword` 方法，你可以对用户提供的密码进行散列，并将其安全地保存到数据库中。稍后，我们将使用 `comparePassword`
    函数将用户提供的值与散列密码进行比较。我们从不存储用户提供的值，因此系统永远不会重新生成用户的密码，这使得它是一个安全的实现。
- en: Login API
  id: totrans-449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 登录 API
- en: 'The following is the login method implementation in `authService` for `lemon-mart-server`:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 `lemon-mart-server` 的 `authService` 中 `login` 方法的实现：
- en: '[PRE63]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The preceding code sample implements a `createJwt` function to create a JWT
    per user. We also defined canned responses for auth failures. Note the vagueness
    of the incorrect email/password message, meaning that bad actors cannot fish the
    system to exploit the authentication system.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例实现了一个 `createJwt` 函数来为每个用户创建 JWT。我们还为身份验证失败定义了预定义的响应。注意不正确的电子邮件/密码消息的模糊性，这意味着恶意行为者不能利用系统来利用身份验证系统。
- en: 'Let''s implement the login API at `/v1/auth/login`:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `/v1/auth/login` 上实现登录 API：
- en: '[PRE64]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Note that when retrieving a user by email, keep in mind that emails are case-insensitive.
    So, you should always convert the input to lowercase. You can improve this implementation
    further by validating the email, and stripping any white space, script tags, or
    even rogue Unicode characters. Consider using libraries such as `express-validator`
    or `express-sanitizer`.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当通过电子邮件检索用户时，请记住电子邮件是不区分大小写的。因此，你应该始终将输入转换为小写。你可以通过验证电子邮件、删除任何空白字符、脚本标签或甚至恶意
    Unicode 字符来进一步改进此实现。考虑使用 `express-validator` 或 `express-sanitizer` 等库。
- en: The `login` method leverages the `user.comparePassword` function to confirm
    the correctness of the password provided. The `createJwt` function then creates
    the `accessToken` to be returned to the client.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '`login` 方法利用 `user.comparePassword` 函数来确认提供的密码的正确性。然后 `createJwt` 函数创建要返回给客户端的
    `accessToken`。'
- en: Authenticating middleware
  id: totrans-457
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 身份验证中间件
- en: The `authenticate` function is a middleware that we can use in our API implementations
    to ensure that only authenticated users with appropriate permissions can access
    an endpoint. Remember that real security is achieved in your backend implementation
    and this authenticate function is your gate keeper.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '`authenticate` 函数是一个中间件，我们可以在我们的 API 实现中使用它来确保只有经过身份验证且具有适当权限的用户才能访问端点。请记住，真正的安全性是在你的后端实现中实现的，而这个
    `authenticate` 函数是你的守门人。'
- en: '`authenticate` takes an optional `options` object to verify the current user''s
    role with the `requiredRole` property, so if an API is configured as shown below,
    only a manager can access that API:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '`authenticate` 接收一个可选的 `options` 对象，用于使用 `requiredRole` 属性验证当前用户的角色，因此如果 API
    配置如下所示，则只有经理可以访问该 API：'
- en: '[PRE65]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In certain cases, we want a user to be able to update their own records, but
    also allow managers to update everyone else''s records. In this case, we leverage
    the `permitIfSelf` property, as shown:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们希望用户能够更新自己的记录，同时也允许经理更新其他人的记录。在这种情况下，我们利用 `permitIfSelf` 属性，如下所示：
- en: '[PRE66]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: In this case, if the `_id` of the record being updated matches the current user's
    `_id`, then the user can update their own record. Since, `requiredRoleCanOverride`
    is set to `true` a manager can update any record. If it were set to `false`, this
    wouldn't be allowed. By mixing and matching these properties you can cover a vast
    majority of your gate keeping needs.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果正在更新的记录的 `_id` 与当前用户的有效 `_id` 匹配，则用户可以更新自己的记录。由于 `requiredRoleCanOverride`
    设置为 `true`，经理可以更新任何记录。如果设置为 `false`，则不允许这样做。通过混合和匹配这些属性，你可以覆盖你大部分的守门人需求。
- en: Note that `idGetter` is a function delegate, so that you can specify how the
    `_id` property should be accessed, when the `authenticate` middleware executes.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`idGetter` 是一个函数委托，这样你就可以指定在 `authenticate` 中间件执行时如何访问 `_id` 属性。
- en: 'See the following implementation of `authenticate` and `authenticateHelper`:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅以下 `authenticate` 和 `authenticateHelper` 的实现：
- en: '[PRE67]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The `authenticate` method is implemented as an Express.js middleware. It can
    read the request header for an authorization token, verify the validity of the
    JWT provided, load the current user, and inject it into the response stream, so
    an authenticated API endpoint can conveniently access the current user's information.
    This will be demonstrated by the `me` API. If successful, the middleware calls
    the `next()` function to yield control back to Express. If unsuccessful, then
    the API can't be called.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '`authenticate` 方法作为 Express.js 中间件实现。它可以读取请求头中的授权令牌，验证提供的 JWT 的有效性，加载当前用户，并将其注入到响应流中，以便认证的
    API 端点可以方便地访问当前用户的信息。这将通过 `me` API 进行演示。如果成功，中间件调用 `next()` 函数将控制权交还给 Express。如果失败，则无法调用
    API。'
- en: Note that `authenticateHelper` returns useful error messages, so users aren't
    confused if they try to execute an action they're not permitted to execute.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`authenticateHelper` 返回有用的错误消息，所以如果用户尝试执行他们无权执行的操作，他们不会感到困惑。
- en: 'Consider the implementation of the me API, which returns the currently logged-in
    user to the client via `/v1/auth/me`, as shown here:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑 me API 的实现，它通过 `/v1/auth/me` 将当前登录用户返回给客户端，如下所示：
- en: '[PRE68]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Note that the `/v1/auth/me` method uses the `authenticate` middleware and simply
    returns the user who was loaded into the response stream.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`/v1/auth/me` 方法使用 `authenticate` 中间件，并简单地返回加载到响应流中的用户。
- en: Custom server auth provider
  id: totrans-472
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义服务器身份验证提供者
- en: 'Now that we have a functional auth implementation in our server, we can implement
    a custom auth provider in LemonMart, as covered in *Chapter 8*, *Designing Authentication
    and Authorization*:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在服务器中实现了功能性的身份验证实现，我们可以在 LemonMart 中实现自定义身份验证提供者，如第 8 章 *设计身份验证和授权* 中所述：
- en: You must implement this custom auth provider in your Angular app.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须在你的 Angular 应用程序中实现这个自定义身份验证提供者。
- en: The code sample for this section is in the `projects/ch10` folder on the **lemon-mart**
    repo. Note that the sample is also accessible under the `web-app` folder.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 本节代码示例位于 **lemon-mart** 仓库的 `projects/ch10` 文件夹中。请注意，该示例也位于 `web-app` 文件夹下。
- en: In `environment.ts` and `environment.prod.ts`, implement a `baseUrl` variable.
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `environment.ts` 和 `environment.prod.ts` 中实现一个 `baseUrl` 变量。
- en: 'Also select `authMode` as `AuthMode.CustomServer`:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还选择 `authMode` 为 `AuthMode.CustomServer`：
- en: '[PRE69]'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Install a helper library to programmatically access TypeScript enum values:'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装一个辅助库以编程方式访问 TypeScript 枚举值：
- en: '[PRE70]'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Implement the custom authentication provider as shown here:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照如下所示实现自定义身份验证提供者：
- en: '[PRE71]'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The `authProvider` method calls our `/v1/auth/login` method and `getCurrentUser`
    calls `/v1/auth/me` to retrieve the current user.
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`authProvider` 方法调用我们的 `/v1/auth/login` 方法，`getCurrentUser` 调用 `/v1/auth/me`
    以检索当前用户。'
- en: Ensure that calls to `login` methods always happen on HTTPS, otherwise you will
    be sending user credentials on the open internet. This is ripe for eavesdroppers
    on public Wi-Fi networks to steal user credentials.
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保对 `login` 方法的调用始终发生在 HTTPS 上，否则你将在开放的互联网上发送用户凭据。这对于在公共 Wi-Fi 网络上监听者窃取用户凭据来说是一个很好的机会。
- en: 'Update `authFactory` to return the new provider for the `AuthMode.CustomServer`
    option:'
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `authFactory` 以返回 `AuthMode.CustomServer` 选项的新提供者：
- en: '[PRE72]'
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'In `app.modules.ts`, update the `AuthService` provider''s `deps` property to
    inject `HttpClient` into `authFactory`:'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `app.modules.ts` 中，更新 `AuthService` 提供者的 `deps` 属性以将 `HttpClient` 注入到 `authFactory`：
- en: '[PRE73]'
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Start your web app to make sure that things are working.
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的 Web 应用程序以确保一切正常工作。
- en: Next, let's implement the get user endpoint, so our auth provider can get the
    current user.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们实现获取用户端点，以便我们的身份验证提供者可以获取当前用户。
- en: GET User by ID
  id: totrans-491
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过 ID 获取用户
- en: 'Let''s implement the GET User by ID API endpoint, at `/v2/users/{id}`, in `userRouter`:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `userRouter` 中实现通过 ID 获取用户的 GET API 端点，在 `/v2/users/{id}`：
- en: '[PRE74]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: In the preceding code sample, we query the database by user ID to find the record
    we're looking for. We import `UserCollection` and call the `findOne` method to
    get a `User` object back. Note that we are not leveraging the `userService`. Since
    we're only retrieving a single record and immediately sending the result back,
    the additional layer of abstraction is cumbersome. However, if you start adding
    any business logic to the retrieval of a user, then refactor the code to leverage
    `userService`.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们通过用户 ID 查询数据库以找到我们正在寻找的记录。我们导入 `UserCollection` 并调用 `findOne` 方法以获取一个
    `User` 对象。请注意，我们没有利用 `userService`。由于我们只检索单个记录并立即发送结果，额外的抽象层是繁琐的。然而，如果你开始向检索用户的操作中添加任何业务逻辑，那么请重构代码以利用
    `userService`。
- en: We secure the endpoint using the `authenticate` middleware, allowing users to
    retrieve their records and managers to retrieve any record.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`authenticate`中间件来保护端点，允许用户检索他们的记录，管理员可以检索任何记录。
- en: Generating users with Postman
  id: totrans-496
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Postman生成用户
- en: Earlier in this chapter, we covered how to create a POST method to create a
    new user in the *Services* subsection of the *Implementing APIs with* *Express.js*
    section. Using this POST endpoint and the Postman API client, we can quickly generate
    user records for testing purposes.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，我们介绍了如何在*Express.js*部分的*实现API*子部分的*服务*子部分中创建一个POST方法来创建新用户。使用这个POST端点和Postman
    API客户端，我们可以快速为测试目的生成用户记录。
- en: You must generate test data in **lemon-mart-server** following the instructions
    below, which will be required in later chapters.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须按照以下说明在**lemon-mart-server**中生成测试数据，这在后面的章节中将是必需的。
- en: Let's install and configure Postman.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们安装和配置Postman。
- en: Go to [https://www.getpostman.com](https://www.getpostman.com) to download and
    install Postman.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 前往[https://www.getpostman.com](https://www.getpostman.com)下载并安装Postman。
- en: Configuring Postman for authenticated calls
  id: totrans-501
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置Postman进行认证调用
- en: 'First, we need to configure Postman so that we can access our authenticated
    endpoints:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要配置Postman，以便我们可以访问我们的认证端点：
- en: Bring up your server and database using either `docker-compose up` or `npm run
    start:backend`. Remember, make sure that, first and foremost, you're able to execute
    the sample server provided on GitHub at [https://github.com/duluca/lemon-mart-server](https://github.com/duluca/lemon-mart-server).
    Getting your own version of the server going is a secondary goal.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`docker-compose up`或`npm run start:backend`启动你的服务器和数据库。记住，首先确保你能够执行GitHub上提供的示例服务器[https://github.com/duluca/lemon-mart-server](https://github.com/duluca/lemon-mart-server)。启动你自己的服务器版本是次要目标。
- en: Create a new collection named `LemonMart`.
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`LemonMart`的新集合。
- en: Add a POST request with the URL `http://localhost:3000/v1/auth/login`.
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个URL为`http://localhost:3000/v1/auth/login`的POST请求。
- en: 'In the headers, set the key-value pair, Content-Type: `application/json`.'
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在头部设置键值对，Content-Type: `application/json`。'
- en: 'In the body section, provide the email and password for the demo user login
    that we defined in the top-level `.env` file:'
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在正文部分，提供我们定义在顶级`.env`文件中的演示用户登录的电子邮件和密码：
- en: '[PRE75]'
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Hit **Send** to log in.
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**发送**以登录。
- en: Copy the `accessToken`, as shown here:![](img/B14094_10_09.png)
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制`accessToken`，如下所示![图B14094_10_09](img/B14094_10_09.png)
- en: 'Figure 10.9: Setting up Postman'
  id: totrans-511
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.9：设置Postman
- en: Click on the settings icon in the top-right corner to manage environments.
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击右上角的设置图标来管理环境。
- en: Add a new environment called LemonMart Server.
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为LemonMart Server的新环境。
- en: Create a variable named `token`.
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`token`的变量。
- en: Paste the `accessToken` value you have as the current value (no parentheses).
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`accessToken`值粘贴为当前值（不带括号）。
- en: Click on **Add**/**Update**.
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加**/**更新**。
- en: 'Going forward, when you add a new request in Postman, you must provide the
    token variable as an authorization header, as shown:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在起，当你添加Postman中的新请求时，你必须提供令牌变量作为授权头，如下所示：
- en: '![](img/B14094_10_10.png)'
  id: totrans-518
  prefs: []
  type: TYPE_IMG
  zh: '![图B14094_10_10](img/B14094_10_10.png)'
- en: 'Figure 10.10: Providing a token in Postman'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.10：在Postman中提供令牌](img/B14094_10_10.png)'
- en: When using Postman, always make sure that the correct environment is selected
    in the dropdown in the top-right corner.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Postman时，始终确保在右上角的下拉菜单中选择了正确的环境。
- en: Switch over to the **Authorization** tab.
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到**授权**选项卡。
- en: Select **Bearer Token** as the type.
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Bearer Token**作为类型。
- en: Provide the token variable as `{{token}}`.
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将令牌变量作为`{{token}}`提供。
- en: When you **Send** your request, you should see the results. Be mindful that
    when your token expires, you will need to repeat this process.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 当你**发送**你的请求时，你应该看到结果。请注意，当你的令牌过期时，你需要重复此过程。
- en: Postman automation
  id: totrans-525
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Postman自动化
- en: 'Using Postman, we can automate the execution of requests. In order to create
    sample users in our system, we can leverage this functionality:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Postman，我们可以自动化请求的执行。为了在我们的系统中创建示例用户，我们可以利用这个功能：
- en: Create a new POST request for `http://localhost:3000/v2/user` named **Create
    Users**.
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`http://localhost:3000/v2/user`创建一个新的名为**创建用户**的POST请求。
- en: Set the `token` in the **Authorization** tab
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**授权**选项卡中设置`token`。
- en: 'In the **Body** tab, provide a templated JSON object, as shown here:'
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**正文**选项卡中，提供一个模板化的JSON对象，如下所示：
- en: '[PRE76]'
  id: totrans-530
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: For the purposes of this example, I'm only templating the email and the first
    and last name fields. You may template all properties.
  id: totrans-531
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本例中，我仅对电子邮件和姓名字段进行模板化。你可以对所有属性进行模板化。
- en: 'Implement a Postman **Pre-request Script**, which executes arbitrary logic
    before sending a request. The script will define an array of people, and one by
    one set the current environment variable to be the next row as requests are executed:'
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个 Postman **Pre-request Script**，它在发送请求之前执行任意逻辑。该脚本将定义一个人员数组，并在请求执行时逐个设置当前环境变量：
- en: For more information on pre-request scripts, check out [https://learning.postman.com/docs/postman/scripts/pre-request-scripts/](https://learning.postman.com/docs/postman/scripts/pre-request-scripts/).
  id: totrans-533
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于预请求脚本的更多信息，请查看 [https://learning.postman.com/docs/postman/scripts/pre-request-scripts/](https://learning.postman.com/docs/postman/scripts/pre-request-scripts/)。
- en: 'Switch to the **Pre-request Script** tab and implement the script:'
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到 **Pre-request Script** 选项卡并实现脚本：
- en: '[PRE77]'
  id: totrans-535
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '`pm` is a global variable that stands for **P**ost**M**an.'
  id: totrans-536
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`pm` 是一个全局变量，代表 **P**ost**M**an。'
- en: In the first line, we get the `people` array from the environment. During the
    first request, this won't exist, which allows us to initialize the array with
    our test data. Next, we shift to the next record, and set the individual variables
    we used in our templated request body. Then, we save the current state of the
    array back to the environment, so, during the next execution, we can shift to
    the next record, until such time as we run out of records.
  id: totrans-537
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第一行，我们从环境中获取 `people` 数组。在第一次请求期间，它将不存在，这允许我们使用测试数据初始化数组。接下来，我们移动到下一个记录，并设置我们在模板请求体中使用的单个变量。然后，我们将当前数组的当前状态保存回环境，这样，在下次执行时，我们可以移动到下一个记录，直到我们用完记录。
- en: 'Implement a `test` script in the **Tests** tab:'
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Tests** 选项卡中实现一个 `test` 脚本：
- en: '[PRE78]'
  id: totrans-539
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Make sure to save your request.
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保保存您的请求。
- en: Here, we define a `test` script, which will continue to execute until `people.length`
    reaches zero. With each iteration, we call the **Create Users** request. When
    there are no people left, we call `null` to terminate the test.
  id: totrans-541
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们定义一个 `test` 脚本，该脚本将一直执行，直到 `people.length` 达到零。在每次迭代中，我们调用 **Create Users**
    请求。当没有剩下的人时，我们调用 `null` 来终止测试。
- en: As you may imagine, you can combine multiple requests and multiple environment
    variables to execute sophisticated tests.
  id: totrans-542
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所想象，您可以将多个请求和多个环境变量组合起来执行复杂的测试。
- en: Now, execute the script using **Runner**, located in the top-left corner of
    the screen:![](img/B14094_10_11.png)
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用屏幕左上角的 **Runner** 执行脚本：![图片](img/B14094_10_11.png)
- en: 'Figure 10.11: Runner button in the top-left corner of the Postman UI'
  id: totrans-544
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.11：Postman UI 左上角的运行器按钮
- en: Update your `login` token before moving on.
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续操作之前，请更新您的 `login` 令牌。
- en: Configure the runner as shown:![](img/B14094_10_12.png)
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下配置设置运行器：![图片](img/B14094_10_12.png)
- en: 'Figure 10.12: Collection Runner configuration'
  id: totrans-547
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.12：集合运行器配置
- en: Select the **LemonMart** collection.
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **LemonMart** 集合。
- en: Select the **LemonMart Server** environment, which contains the `token` variable.
  id: totrans-549
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选择包含 `token` 变量的 **LemonMart Server** 环境。
- en: Only select the **Create Users** request.
  id: totrans-550
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 只选择 **Create Users** 请求。
- en: Click on **Run LemonMart** to execute.
  id: totrans-551
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 点击 **Run LemonMart** 来执行。
- en: 'If your run succeeded, you should see the following output:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的运行成功，您应该看到以下输出：
- en: '![](img/B14094_10_13.png)'
  id: totrans-553
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_10_13.png)'
- en: 'Figure 10.13: Collection Runner results'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.13：集合运行器结果
- en: If you use Studio 3T as a MongoDB explorer, you can observe that all records
    have been created or you can check them out with Postman, when we implement the
    `/v2/users` endpoint.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 Studio 3T 作为 MongoDB 探索器，您可以看到所有记录都已创建，或者您可以使用 Postman 检查它们，当我们实现 `/v2/users`
    端点时。
- en: Note that since we have a unique email index, your run partially succeeds on
    the next run. POST requests for already created records will return a `400 Bad
    Request`.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于我们有一个唯一的电子邮件索引，您的下一次运行部分成功。对于已创建的记录的 POST 请求将返回 `400 Bad Request`。
- en: You can read more about Studio 3T at [https://studio3t.com/](https://studio3t.com/).
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://studio3t.com/](https://studio3t.com/) 上了解更多关于 Studio 3T 的信息。
- en: Put User
  id: totrans-558
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加用户
- en: 'We have already covered how to create a POST request in the *Services* section
    earlier in the chapter. Now, let''s see how you can update an existing user record:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在本章前面的 *Services* 部分介绍了如何创建 POST 请求。现在，让我们看看您如何更新现有的用户记录：
- en: '[PRE79]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: We set `userData` from the request body. We then `delete` the `_id` property
    that's in the body, since the URL parameter is the authoritative source of information.
    Additionally, this prevents a user's ID from being accidentally changed to a different value.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从请求体中设置 `userData`。然后我们 `delete` 请求体中的 `_id` 属性，因为 URL 参数是信息的权威来源。此外，这还可以防止用户的
    ID 被意外更改成不同的值。
- en: We then leverage the `findOneAndUpdate` method to locate and update the record.
    We query for the record using the ID. We update the record by using MongoDB's
    `$set` operator.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们利用`findOneAndUpdate`方法定位并更新记录。我们使用ID查询记录。通过使用MongoDB的`$set`运算符来更新记录。
- en: Finally, we load the saved record from the database and return it back to the
    client.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们从数据库中加载保存的记录并将其返回给客户端。
- en: POST and PUT methods should always respond with the updated state of the record.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: POST和PUT方法应始终响应记录的更新状态。
- en: For our last piece of implementation, let's review API endpoints that can support
    paginated data tables.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们最后的实现部分，让我们回顾一下可以支持分页数据表的API端点。
- en: Pagination and filtering with DocumentTS
  id: totrans-566
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用DocumentTS进行分页和过滤
- en: 'By far the most useful functionality of DocumentTS is `findWithPagination`,
    as mentioned in the *About DocumentTS* section. Let''s leverage `findWithPagination`
    to implement the `/v2/users` endpoint, which can return all users:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，DocumentTS最有用的功能是`findWithPagination`，如*关于DocumentTS*部分所述。让我们利用`findWithPagination`来实现`/v2/users`端点，它可以返回所有用户：
- en: '[PRE80]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: We copy all the parameters from the URL using the `req.query` object as local
    variables. We define an additional property named `projectionKeyOrList` to limit
    the properties of a record that can be returned to the client. In this case, only
    the `email`, `role`, `_id`, and `name` properties will be returned. This minimizes
    the amount of data that is sent over the wire.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`req.query`对象作为局部变量复制URL中的所有参数。我们定义了一个名为`projectionKeyOrList`的附加属性，以限制可以返回给客户端的记录属性。在这种情况下，仅返回`email`、`role`、`_id`和`name`属性。这最小化了通过网络发送的数据量。
- en: Finally, we simply pass the new `query` object to the `findWithPagination` function
    and return the results to the client.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只需将新的`query`对象传递给`findWithPagination`函数，并将结果返回给客户端。
- en: 'You can create a new request in Postman to verify the correct functionality
    of your new endpoint, as shown in the following screenshot:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Postman中创建一个新的请求来验证您的新端点的正确功能，如下面的截图所示：
- en: '![](img/B14094_10_14.png)'
  id: totrans-572
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14094_10_14.png)'
- en: 'Figure 10.14: Calling get users with Postman'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.14：使用Postman调用获取用户
- en: In *Chapter 12*, *Recipes – Master/Detail, Data Tables, and NgRx*, we will implement
    a paginated data table that takes advantage of the filtering, sorting, and data
    limiting features.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第12章*，*食谱 - 主/详细，数据表和NgRx*中，我们将实现一个利用过滤、排序和数据限制功能的分页数据表。
- en: Congratulations! You now have a grasp on how code works across the entire stack
    of software, from the database to the frontend and back.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您现在掌握了代码在整个软件栈中如何工作的知识，从数据库到前端和后端。
- en: Summary
  id: totrans-576
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered full-stack architecture. You learned about building
    a minimal MEAN stack. You now know how to create a monorepo for a full-stack application
    and configure a Node.js server with TypeScript. You containerized your Node.js
    server and declaratively defined your infrastructure with Docker Compose. Using
    Docker Compose with CircleCI, you verified your infrastructure in a CI environment.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了全栈架构。您学习了如何构建最小化的MEAN栈。您现在知道如何为全栈应用程序创建monorepo，并使用TypeScript配置Node.js服务器。您将Node.js服务器容器化，并使用Docker
    Compose声明性地定义了您的基础设施。使用Docker Compose与CircleCI，您在CI环境中验证了您的基础设施。
- en: You designed a RESTful API using Swagger and the OpenAPI spec, set up an Express.js
    app and configured it such that you can integrate your Swagger definition as documentation
    for your APIs. You configured MongoDB with the DocumentTS ODM so you can easily
    connect and query documents. You defined a user model with password hashing features.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用Swagger和OpenAPI规范设计了RESTful API，设置了Express.js应用程序，并配置了它，以便您可以将Swagger定义作为API的文档进行集成。您使用DocumentTS
    ODM配置MongoDB，以便您可以轻松连接和查询文档。您定义了一个具有密码散列功能的用户模型。
- en: You then implemented a JWT-based authentication service. You implemented an
    `authenticate` middleware to secure API endpoints and allow role-based access.
    You learned how to interact with RESTful APIs using Postman. Using Postman's automation
    features, you generated test data. Finally, you implemented RESTful APIs for authentication
    functions and CRUD operations for users.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您实现了基于JWT的认证服务。您实现了一个`authenticate`中间件来保护API端点并允许基于角色的访问。您学习了如何使用Postman与RESTful
    API交互。使用Postman的自动化功能，您生成了测试数据。最后，您实现了认证功能的RESTful API和用户的CRUD操作。
- en: In the next two chapters, we will go over Angular recipes to create forms and
    data tables. You will want your Lemon Mart Server up and running to verify the
    correct functionality of your forms and tables as you implement them.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两个章节中，我们将介绍Angular食谱来创建表单和数据表。当你实现它们时，你将希望Lemon Mart服务器运行起来，以验证表单和表格的正确功能。
- en: Exercise
  id: totrans-581
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: You secured your endpoints using the `authenticate` middleware. You configured
    Postman to send a valid token so that you can communicate with your secured endpoints.
    By way of an exercise, try removing the `authenticate` middleware and call the
    same endpoint with and without a valid token. Re-add the middleware and try the
    same thing again. Observe the different responses you get from the server.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用`authenticate`中间件来保护你的端点。你已配置Postman发送有效的令牌，以便你可以与受保护的端点通信。作为练习，尝试移除`authenticate`中间件，并使用和没有有效令牌的方式调用相同的端点。重新添加中间件，再次尝试相同的事情。观察你从服务器收到的不同响应。
- en: Further reading
  id: totrans-583
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*What is DX? (Developer Experience)*, Albert Cavalcante, 2019: [https://medium.com/@albertcavalcante/what-is-dx-developer-experience-401a0e44a9d9](https://medium.com/@albertcavalcante/what-is-dx-developer-experience-401a0e44a9d9
    )'
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*什么是DX？（开发者体验）*，Albert Cavalcante，2019：[https://medium.com/@albertcavalcante/what-is-dx-developer-experience-401a0e44a9d9](https://medium.com/@albertcavalcante/what-is-dx-developer-experience-401a0e44a9d9)'
- en: '*Overview of Blocking versus Non-Blocking*, 2020: [https://nodejs.org/en/docs/guides/blocking-vs-non-blocking/](https://nodejs.org/en/docs/guides/blocking-vs-non-blocking/
    )'
  id: totrans-585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*阻塞与非阻塞概述*，2020：[https://nodejs.org/en/docs/guides/blocking-vs-non-blocking/](https://nodejs.org/en/docs/guides/blocking-vs-non-blocking/)'
- en: '*Explain Non-Blocking I/O like I''m Five, Frank Rosner*, 2019: [https://blog.codecentric.de/en/2019/04/explain-non-blocking-i-o-like-im-five/](https://blog.codecentric.de/en/2019/04/explain-non-blocking-i-o-like-im-five/
    )'
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*像对我五岁孩子解释非阻塞I/O，Frank Rosner*，2019：[https://blog.codecentric.de/en/2019/04/explain-non-blocking-i-o-like-im-five/](https://blog.codecentric.de/en/2019/04/explain-non-blocking-i-o-like-im-five/)'
- en: '*OpenAPI Specification*, 2020: [https://swagger.io/docs/specification](https://swagger.io/docs/specification
    )'
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*OpenAPI规范*，2020：[https://swagger.io/docs/specification](https://swagger.io/docs/specification)'
- en: '*Serialization*, 2020: [https://en.wikipedia.org/wiki/Serialization](https://en.wikipedia.org/wiki/Serialization
    )'
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*序列化*，2020：[https://en.wikipedia.org/wiki/Serialization](https://en.wikipedia.org/wiki/Serialization)'
- en: '*JSON*, 2020: [https://en.wikipedia.org/wiki/JSON](https://en.wikipedia.org/wiki/JSON
    )'
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*JSON*，2020：[https://en.wikipedia.org/wiki/JSON](https://en.wikipedia.org/wiki/JSON)'
- en: '*Aggregation in MongoDB*, 2020: [https://docs.mongodb.com/manual/aggregation](https://docs.mongodb.com/manual/aggregation
    )'
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*MongoDB中的聚合*，2020：[https://docs.mongodb.com/manual/aggregation](https://docs.mongodb.com/manual/aggregation)'
- en: Questions
  id: totrans-591
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Answer the following questions as best as you can to ensure that you've understood
    the key concepts from this chapter without Googling. Do you need help answering
    the questions? See *Appendix D*, *Self-Assessment Answers* online at [https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf](https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf)
    or visit [https://expertlysimple.io/angular-self-assessment](https://expertlysimple.io/angular-self-assessment).
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能好地回答以下问题，以确保你在不使用Google的情况下理解了本章的关键概念。你需要帮助回答这些问题吗？请参阅*附录D*，*自我评估答案*，在线位于[https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf](https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf)或访问[https://expertlysimple.io/angular-self-assessment](https://expertlysimple.io/angular-self-assessment)。
- en: What are the main components that make for a great developer experience?
  id: totrans-593
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构成优秀开发者体验的主要组件有哪些？
- en: What is a `.env` file?
  id: totrans-594
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`.env`文件是什么？'
- en: What is the purpose of the `authenticate` middleware?
  id: totrans-595
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`authenticate`中间件的作用是什么？'
- en: How does Docker Compose differ from using the `Dockerfile`?
  id: totrans-596
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker Compose与使用`Dockerfile`有何不同？
- en: What is an ODM? How does it differ from an ORM?
  id: totrans-597
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是ODM？它与ORM有何不同？
- en: What is middleware?
  id: totrans-598
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 中间件是什么？
- en: What are the uses of Swagger?
  id: totrans-599
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Swagger的用途是什么？
- en: How would you refactor the code for the `/v2/users/{id} PUT` endpoint in `userRouter.ts`,
    so the code is reusable?
  id: totrans-600
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会如何重构`userRouter.ts`中`/v2/users/{id} PUT`端点的代码，以便代码可重用？
