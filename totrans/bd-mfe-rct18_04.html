<html><head></head><body>
		<div id="_idContainer023" class="calibre2">
			<h1 id="_idParaDest-47" class="chapter-number"><a id="_idTextAnchor046" class="pcalibre1 calibre6 pcalibre"/>3</h1>
			<h1 id="_idParaDest-48" class="calibre7"><a id="_idTextAnchor047" class="pcalibre1 calibre6 pcalibre"/>Monorepos versus Polyrepos for Microfrontends</h1>
			<p class="calibre3">Since the time engineers at Google and Facebook mentioned they have a single monorepo in their organization, the developer community – especially the frontend community – has been actively participating in debates and discussions on monorepos <span>versus polyrepos.</span></p>
			<p class="calibre3">We are seeing more and more teams leaning more toward monorepos for maintaining their frontend code. However, which should you choose between a polyrepo and a monorepo based on what the <span>community thinks?</span></p>
			<p class="calibre3">As we will learn in this chapter, the decision to go with a monorepo or a polyrepo is far deeper than just fancy technology or hype. We will see that, in fact, it is more to do with teams, and the culture we would like to establish <span>within teams.</span></p>
			<p class="calibre3">In this chapter, we start by understanding what polyrepos and monorepos are. We will see how each of them impacts how teams work and collaborate, then we will see why monorepos are more suited for microfrontends. Finally, we will set up our monorepo base application with the necessary permissions to work <span>in teams.</span></p>
			<p class="calibre3">In this chapter, we will cover the <span>following topics:</span></p>
			<ul class="calibre15">
				<li class="calibre14">Repo types and <span>their nuances</span></li>
				<li class="calibre14">Why Monorepos <span>for Microfrontends?</span></li>
				<li class="calibre14">Setting up our Monorepo with <span>Team permissions</span></li>
			</ul>
			<p class="calibre3">By the end of this chapter, you will have a deep understanding of the differences between and implications of choosing a polyrepo versus <span>a monorepo.</span></p>
			<p class="calibre3">We will also have our monorepo set up and ready for vertically sliced domain-driven teams to get started <span>with it.</span></p>
			<h1 id="_idParaDest-49" class="calibre7"><a id="_idTextAnchor048" class="pcalibre1 calibre6 pcalibre"/>Technical requirements</h1>
			<p class="calibre3">As we go through the code examples in this chapter, we will need <span>the following:</span></p>
			<ul class="calibre15">
				<li class="calibre14">A PC, Mac, or Linux desktop or laptop with at least 8 GB of RAM (16 <span>GB preferred)</span></li>
				<li class="calibre14">An Intel chipset i5+, AMD, or Mac M1 + <span>chipset</span></li>
				<li class="calibre14">At least 256 GB of free hard <span>disk storage</span></li>
			</ul>
			<p class="calibre3">You will also need the following software installed on <span>your computer:</span></p>
			<ul class="calibre15">
				<li class="calibre14">Node.js version 16+ (use <strong class="source-inline1">nvm</strong> to manage different versions of Node.js if you <span>have to)</span></li>
				<li class="calibre14">Terminal: iTerm2 with Oh My Zsh (you will thank <span>me later)</span></li>
				<li class="calibre14">IDE: We strongly recommend VS Code as we will be making use of some of the plugins that come with VS Code for an improved <span>developer experience</span></li>
				<li class="calibre14">npm, yarn, or pnpm – we recommend pnpm because it’s fast <span>and storage-efficient</span></li>
				<li class="calibre14">Browser: Chrome, Microsoft Edge, Brave, or Firefox (I <span>use Firefox)</span></li>
			</ul>
			<p class="calibre3">The code files for this chapter can be found <span>here: </span><a href="https://github.com/PacktPublishing/Building-Micro-Frontends-with-React" class="pcalibre1 calibre6 pcalibre"><span>https://github.com/PacktPublishing/Building-Micro-Frontends-with-React</span></a></p>
			<p class="calibre3">We also assume you have a basic working knowledge of Git, such as branching, committing code, and raising <span>pull requests.</span></p>
			<h1 id="_idParaDest-50" class="calibre7"><a id="_idTextAnchor049" class="pcalibre1 calibre6 pcalibre"/>Repo types and their nuances</h1>
			<p class="calibre3">In this section, we will learn exactly what a polyrepo and a <span>monorepo are.</span></p>
			<p class="calibre3">As most of you will already know by now, repo is short for repository and refers to storage for all the files for your project. It also keeps track of all the changes to those files. This means, at any time, we can easily go and see what lines of code were changed, by whom, and when. In most cases, we use Git for version control. Some teams may use other systems, such as Mercurial or some other distributed version <span>control system.</span></p>
			<p class="calibre3">There are two strategies <a id="_idIndexMarker072" class="pcalibre1 calibre6 pcalibre"/>that teams most commonly use for managing repos. They are commonly known as monorepos and polyrepos. There are other patterns, such <a id="_idIndexMarker073" class="pcalibre1 calibre6 pcalibre"/>as Git submodules or Git subtrees, but these are beyond the scope of this chapter. We will focus on monorepos <span>and polyrepos.</span></p>
			<h2 id="_idParaDest-51" class="calibre5"><a id="_idTextAnchor050" class="pcalibre1 calibre6 pcalibre"/>Monorepos</h2>
			<p class="calibre3">As the name suggests, mono means single and so the source code is managed in a single Git repo. This means <a id="_idIndexMarker074" class="pcalibre1 calibre6 pcalibre"/>that all team members work on a common single repository, and in most cases, the monorepo will consist of multiple applications. The following figure shows a <span>monorepo setup:</span></p>
			<div class="calibre2">
				<div id="_idContainer016" class="img---figure">
					<img src="image/Figure_3.01_B18987.jpg" alt="Figure 3.1 – Monorepo setup" class="calibre4"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Monorepo setup</p>
			<p class="calibre3">As you can see in <a id="_idIndexMarker075" class="pcalibre1 calibre6 pcalibre"/>the preceding diagram, we have a single repo that consists of multiple apps within it. All the apps use a shared set of tools for CI and CD and linting and a shared component library that is usually built from source each time an application is built. You will also notice that all the teams have access to all the items within <span>the repo.</span></p>
			<h2 id="_idParaDest-52" class="calibre5"><a id="_idTextAnchor051" class="pcalibre1 calibre6 pcalibre"/>Polyrepos</h2>
			<p class="calibre3">Polyrepos are where <a id="_idIndexMarker076" class="pcalibre1 calibre6 pcalibre"/>each app has its own repository. Teams generally work on multiple repos, switching repos as they work on <span>different apps.</span></p>
			<p class="calibre3">Most teams prefer going down the polyrepos route as they are a lot easier to manage and each team can <a id="_idIndexMarker077" class="pcalibre1 calibre6 pcalibre"/>define its own branching strategies and repo permissions. The following figure shows a <span>polyrepo setup:</span></p>
			<div class="calibre2">
				<div id="_idContainer017" class="img---figure">
					<img src="image/Figure_3.02_B18987.jpg" alt="Figure 3.2 – Polyrepo setup" class="calibre4"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.2 – Polyrepo setup</p>
			<p class="calibre3">In the polyrepo setup, you will notice multiple repositories, denoted by the dotted-line boxes. Each app generally has its own repository, and we have another repository for shared components and libraries. The shared components need to first be published to an artifact repository such as <strong class="source-inline">npm</strong> or Nexus before they can be consumed by the other repositories. We also notice that each repository has its own team, and generally, teams don’t have access to another team’s repository (unless you are an admin or a senior developer that looks after <span>multiple applications).</span></p>
			<h2 id="_idParaDest-53" class="calibre5"><a id="_idTextAnchor052" class="pcalibre1 calibre6 pcalibre"/>Differences between Polyrepos and Monorepos</h2>
			<p class="calibre3">As mentioned earlier, choosing between a polyrepo or a monorepo is not just about how code is <a id="_idIndexMarker078" class="pcalibre1 calibre6 pcalibre"/>organized but goes a lot deeper and has a huge impact <a id="_idIndexMarker079" class="pcalibre1 calibre6 pcalibre"/>on how teams collaborate, the culture within the teams, how your build tools are set up, and <span>so on.</span></p>
			<p class="calibre3">In this section, let us go a bit deeper into understanding the nuances of monorepos <span>and polyrepos.</span></p>
			<h3 class="calibre9">Team Collaboration</h3>
			<p class="calibre3">With polyrepos, teams create their own individual repositories and decide and define their own rules and <a id="_idIndexMarker080" class="pcalibre1 calibre6 pcalibre"/>guidelines on how the code is maintained. Obviously, this is the easiest and fastest way to get started, and teams become productive quite quickly. However, this pattern also has a few drawbacks. With polyrepos, teams tend to become more siloed as each team is just focused on its repo and doesn’t really have a lot of visibility of what other teams <span>are doing.</span></p>
			<p class="calibre3">Another drawback with polyrepos <a id="_idIndexMarker081" class="pcalibre1 calibre6 pcalibre"/>is the effort required to set up and maintain all the build pipelines, and precommit hooks and so on are duplicated for <span>each repo.</span></p>
			<p class="calibre3">With monorepos, teams are forced to collaborate as they need to agree on a common way for how the code will be maintained. In a monorepo setup, since everybody is able to see everybody else’s code, the chances of them working in silos are greatly reduced. Teams are naturally encouraged to collaborate by providing feedback on code and it also provides an opportunity for teams to replicate good code patterns that other teams may <span>have implemented.</span></p>
			<h3 class="calibre9">Build tools and Quality gates</h3>
			<p class="calibre3">With polyrepos, each team needs to implement its own build systems and quality gates such as <a id="_idIndexMarker082" class="pcalibre1 calibre6 pcalibre"/>precommit hooks. This results in duplication of effort and leads to higher maintenance costs. It also boils down to the engineering maturity of each team. Teams with strong leads will obviously have optimized build tools, while junior teams will struggle with not-very-optimized build tools and quality gates and will need intervention from <span>other teams.</span></p>
			<p class="calibre3">With a monorepo, all the build tools and quality gates can be centrally managed, reducing <a id="_idIndexMarker083" class="pcalibre1 calibre6 pcalibre"/>duplication of effort. In most cases, this is usually set up by the experts within one of the teams. This allows leveraging strengths and skillsets across all teams and teams immediately benefit from the knowledge within the <span>wider organization.</span></p>
			<h3 class="calibre9">Code Ownership</h3>
			<p class="calibre3">In a polyrepo, the <a id="_idIndexMarker084" class="pcalibre1 calibre6 pcalibre"/>permissions are set at a repo level in terms of who has permission to view the code in a repo or make changes <span>to it.</span></p>
			<p class="calibre3">In a monorepo, all team members have access to view and edit all the files in the code. The permissions and control in a monorepo are maintained via a <strong class="bold">CODEOWNERS</strong> file, which allows us <a id="_idIndexMarker085" class="pcalibre1 calibre6 pcalibre"/>to set granular permissions at a folder level within the monorepo. We will be learning more about the <strong class="source-inline">CODEOWNERS</strong> file later in <span>this chapter.</span></p>
			<p class="calibre3">The mental model with monorepos is everybody in the team can make changes to a file and raise a request to merge their changes; however, only the rightful owner defined in the <strong class="source-inline">CODEOWNERS</strong> file has the permission to accept or reject the changes being made by a <span>team member.</span></p>
			<h3 class="calibre9">Flexibility</h3>
			<p class="calibre3">As may be obvious by <a id="_idIndexMarker086" class="pcalibre1 calibre6 pcalibre"/>now, polyrepos provide the highest level of flexibility, in terms of how the code within each team <span>is managed.</span></p>
			<p class="calibre3">In a monorepo, this flexibility is intentionally restricted to ensure that all team members benefit from the best coding practices and tooling setup that the team <span>can offer.</span></p>
			<h3 class="calibre9">Refactoring Code</h3>
			<p class="calibre3">With polyrepos, refactoring code across multiple repos can be time-consuming as one will need to check out <a id="_idIndexMarker087" class="pcalibre1 calibre6 pcalibre"/>all the different repos and individually raise a merge request or pull request for <span>each repository.</span></p>
			<p class="calibre3">With monorepos, doing <a id="_idIndexMarker088" class="pcalibre1 calibre6 pcalibre"/>such large-scale refactoring is quite easy by making atomic commits where a single merge request can contain the necessary changes for all <span>the apps.</span></p>
			<h3 class="calibre9">Ownership of Upgrades</h3>
			<p class="calibre3">When the time <a id="_idIndexMarker089" class="pcalibre1 calibre6 pcalibre"/>comes to upgrade libraries or tooling is when the most interesting differences between a polyrepo and monorepo setup come <span>into play.</span></p>
			<p class="calibre3">In a polyrepo, the onus of upgrading shared libraries or tools lies with each of the teams, and the teams can choose to defer an upgrade if they have other priorities. This can be both good and bad. While it allows teams to upgrade at their own pace, there is always a risk that some teams may get far behind in upgrading their libraries. This becomes a serious issue if an outdated library has a serious security vulnerability, and teams have ignored upgrading it. Since each team is responsible for upgrading libraries, they are also responsible for fixing breaking changes, and this is often the primary trigger to <span>defer upgrades.</span></p>
			<p class="calibre3">With monorepos, if a shared library or tool is being upgraded, it is easy to make atomic commits across all the apps within the monorepo, which means all teams directly get the benefit of the latest versions. What’s interesting with monorepos (<em class="italic">that have the right build tools and quality gates in place</em>) is the ownership of fixing any breaking changes lies with the library owner or the person doing the upgrade, as the build pipelines will not allow you to merge the code unless it passes all the build steps and <span>quality gates.</span></p>
			<h3 class="calibre9">Code base Size</h3>
			<p class="calibre3">With polyrepos, your code base gradually increases over time; however, with a monorepo, you <a id="_idIndexMarker090" class="pcalibre1 calibre6 pcalibre"/>are dealing with a large code base right from day one, and the monorepo tends to grow exponentially as the <span>application grows.</span></p>
			<p class="calibre3">A large code base has a negative impact on productivity. Not only does checking out code take time but also, all the other activities, such as running build steps or running unit tests, take longer both on the local developer PC and also on the CI and <span>CD pipelines.</span></p>
			<p class="calibre3">Unless one makes use of features such as caching and building and testing only what has changed, monorepos can become very slow to <span>work with.</span></p>
			<p class="calibre3">As we reach the end of this section, we have learned about the differences between polyrepos and <a id="_idIndexMarker091" class="pcalibre1 calibre6 pcalibre"/>monorepos and have gone into the details of how they differ when it comes to things such as code refactoring and ownership, tooling team culture, collaboration, and <span>so on.</span></p>
			<p class="calibre3">In the next section, we will see which of the two is more suited for <span>building microfrontends.</span></p>
			<h1 id="_idParaDest-54" class="calibre7"><a id="_idTextAnchor053" class="pcalibre1 calibre6 pcalibre"/>Choosing Monorepos for Microfrontends</h1>
			<p class="calibre3">After going through the pros and cons of polyrepos and monorepos, which one would you choose to use <a id="_idIndexMarker092" class="pcalibre1 calibre6 pcalibre"/>for your project? Well, you can choose either one of them and build microfrontends. Like all things in programming, there are trade-offs for every decision you make, and you need to be clear about what trade-offs you are <span>comfortable with.</span></p>
			<p class="calibre3">For the rest <a id="_idIndexMarker093" class="pcalibre1 calibre6 pcalibre"/>of this book, we will choose to go with the monorepo setup for the <span>following reasons:</span></p>
			<ul class="calibre15">
				<li class="calibre14">With monorepos, team members are naturally encouraged to collaborate by learning and reviewing each <span>other’s code.</span></li>
				<li class="calibre14">It allows all teams to easily use a shared library of components. This ensures that each micro-app built as part of the overall app has the same look and feel and the overall user experience is consistent as the user interacts with the <span>different micro-apps.</span></li>
				<li class="calibre14">It also makes it easy for central platform teams, such as the DevOps team or admin team, to easily refactor code across all <span>the micro-apps.</span></li>
				<li class="calibre14">Some of the drawbacks of monorepos, such as the slower execution of quality gates on pipelines, can be overcome by making use of caching techniques, many of which are the default with most <span>monorepo tools.</span></li>
				<li class="calibre14">As your overall app grows, and new features get added, new micro-apps will keep getting added to your app. Now, if you have a polyrepo setup with each micro-app in its own repo, it will become quite difficult to manage the large number <span>of repos.</span></li>
				<li class="calibre14">In a microfrontend <a id="_idIndexMarker094" class="pcalibre1 calibre6 pcalibre"/>setup, most of the time, you would work on your individual micro-app; however, at times you would need to run all the micro-apps together to test out your app locally. This would be quite difficult to achieve if your micro apps are set up in <span>a polyrepo.</span></li>
			</ul>
			<p class="calibre3">In the following section, we will have a look at some of the popular open source monorepo tools out there, which will help you decide which would be the most suitable <span>for you.</span></p>
			<h2 id="_idParaDest-55" class="calibre5"><a id="_idTextAnchor054" class="pcalibre1 calibre6 pcalibre"/>Popular Monorepo tools</h2>
			<p class="calibre3">This section covers some of the most popular open source monorepo tools that you can choose when building <span>your microfrontends.</span></p>
			<h3 class="calibre9">Lerna</h3>
			<p class="calibre3">Lerna was probably the first <a id="_idIndexMarker095" class="pcalibre1 calibre6 pcalibre"/>and most widely used monorepo tool. It follows <a id="_idIndexMarker096" class="pcalibre1 calibre6 pcalibre"/>what is called the packages-based monorepo style. What this basically means is each app sits under the <strong class="source-inline">packages</strong> folder and has its own <strong class="source-inline">package.json</strong> file, so every app has its own set of dependencies and there is nothing common between <span>these apps.</span></p>
			<p class="calibre3">Lerna was recently adopted by the nrwl team who originally built the <span>Nx monorepo.</span></p>
			<h3 class="calibre9">Nx</h3>
			<p class="calibre3">Nx was the next monorepo to become very popular and is probably the most mature and feature-rich of all the monorepo tools out there. Nx started off as an integrated monorepo. What that <a id="_idIndexMarker097" class="pcalibre1 calibre6 pcalibre"/>means is, in Nx, there is a single <strong class="source-inline">package.json</strong> file on the root and all <a id="_idIndexMarker098" class="pcalibre1 calibre6 pcalibre"/>apps use the same version of the packages. Nx has now evolved to also support the package-based style <span>of monorepos.</span></p>
			<p class="calibre3">It comes with advanced local and distributed caching solutions and is ideal for managing large monorepo <span>code bases.</span></p>
			<h3 class="calibre9">Turborepo</h3>
			<p class="calibre3">Turborepo is the newest <a id="_idIndexMarker099" class="pcalibre1 calibre6 pcalibre"/>entrant in the monorepos war. It follows a <a id="_idIndexMarker100" class="pcalibre1 calibre6 pcalibre"/>package-based style and is very similar to how Lerna works. The main advantage of Turborepo is it supports a local and distributed caching system and is tightly integrated with Vercel’s product suite, including Next.js and Vercel <span>cloud hosting.</span></p>
			<p class="calibre3">As we come to the end of this section, we have learned about the pros and cons of polyorepos versus monorepos. We saw some of the reasons why we choose to use monorepos for <a id="_idIndexMarker101" class="pcalibre1 calibre6 pcalibre"/>microfrontends and we also learned about some of the popular monorepo tools that teams use. In the next section, we will get our hands dirty setting up <span>our monorepo.</span></p>
			<h1 id="_idParaDest-56" class="calibre7"><a id="_idTextAnchor055" class="pcalibre1 calibre6 pcalibre"/>Setting up our Monorepo</h1>
			<p class="calibre3">In this section, we are going to set up our monorepo, which will act as a base for our microfrontend apps. We will learn how to set up the right permissions and the necessary quality gates. Along the way, we will also learn about a couple of productivity tricks and plugins that improve the <span>developer experience.</span></p>
			<p class="calibre3">For this example and the rest of the chapters, we will use Nx as the monorepo to build our microfrontends as it allows you to build both a package-setup-style and an integrated-style monorepo. You can equally choose either Lerna or Turborepo to build <span>your microfrontends.</span></p>
			<p class="calibre3">Follow along with <a id="_idIndexMarker102" class="pcalibre1 calibre6 pcalibre"/>the step-by-step guide to set up an <span>Nx monorepo:</span></p>
			<ol class="calibre13">
				<li class="calibre14">Open up the terminal, <strong class="source-inline1">cd</strong> into the folder where you generally keep your projects, and run the <span>following command:</span><pre class="console">
<strong class="bold1">pnpx create-nx-workspace@14</strong></pre><p class="calibre3">The preceding command will install a couple of libraries and will then prompt you for the name of the workspace (e.g., <strong class="source-inline">org name</strong>). This will be the name of the folder within which your monorepo will be set up. We will call it <strong class="bold">my-mfe</strong> for the sake <span>of consistency.</span></p></li>				<li class="calibre14">Next, it will prompt you to select what kind of apps you would like to create. We will <span>choose </span><span><strong class="bold">react</strong></span><span>:</span></li>
			</ol>
			<div class="calibre2">
				<div id="_idContainer018" class="img---figure">
					<img src="image/Figure_3.03_B18987.jpg" alt="Figure 3.3 – Select a workspace with a single React application" class="calibre4"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.3 – Select a workspace with a single React application</p>
			<ol class="calibre13">
				<li value="3" class="calibre14">When prompted for the application name, enter <strong class="source-inline1">catalog</strong>, as this will be the catalog app within <span>our microfrontend.</span></li>
				<li class="calibre14">When prompted to select the stylesheet format, you can select the default, <strong class="bold">CSS</strong>, or any other format <span>you prefer.</span></li>
				<li class="calibre14">Next, it will prompt you to enable distributed caching. For this exercise, we will <span>say </span><span><strong class="bold">No</strong></span><span>.</span></li>
			</ol>
			<p class="callout-heading">Important note</p>
			<p class="callout">You can find complete details of setting up NX <span>here: </span><a href="https://nx.dev/getting-started/intro" class="pcalibre1 calibre6 pcalibre"><span>https://nx.dev/getting-started/intro</span></a></p>
			<p class="calibre3">It will then go <a id="_idIndexMarker103" class="pcalibre1 calibre6 pcalibre"/>on to install all the dependencies and, once successfully completed, you should have a folder structure similar to <span><em class="italic">Figure 3</em></span><span><em class="italic">.4</em></span><span>:</span></p>
			<div class="calibre2">
				<div id="_idContainer019" class="img---figure">
					<img src="image/Figure_3.04_B18987.jpg" alt="Figure 3.4 – Folder structure for our monorepo" class="calibre4"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.4 – Folder structure for our monorepo</p>
			<p class="calibre3"> You will notice it will have created a monorepo called <strong class="source-inline">my-mfe</strong> and an app called <strong class="source-inline">catalog</strong> within the <span><strong class="source-inline">apps</strong></span><span> folder.</span></p>
			<ol class="calibre13">
				<li value="6" class="calibre14">Go ahead and open up this folder in Visual Studio Code and, once you do that, you will get a <a id="_idIndexMarker104" class="pcalibre1 calibre6 pcalibre"/>prompt to install recommended plugins. Go ahead and install the <span>recommended plugins.</span></li>
			</ol>
			<p class="calibre3">Once all the plugins have been installed, you will notice a new icon on the VS Code pane, as <span>highlighted here:</span></p>
			<div class="calibre2">
				<div id="_idContainer020" class="img---figure">
					<img src="image/Figure_3.05_B18987.jpg" alt="Figure 3.5 – Nx Console installed on VS Code" class="calibre4"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.5 – Nx Console installed on VS Code</p>
			<p class="calibre3">Nx Console is one of the <a id="_idIndexMarker105" class="pcalibre1 calibre6 pcalibre"/>coolest features of using Nx and we will be extensively using it for the rest of <span>this book.</span></p>
			<p class="calibre3">For those curious about how this popup to install recommended plugins came up, the answer lies in the <span><strong class="source-inline">my-mfe/.vscode/extensions.json</strong></span><span> file.</span></p>
			<p class="calibre3">This is a VS Code feature and <a id="_idIndexMarker106" class="pcalibre1 calibre6 pcalibre"/>you can read about it <span>here: </span><a href="https://code.visualstudio.com/docs/editor/extension-marketplace#_workspace-recommended-extensions" class="pcalibre1 calibre6 pcalibre"><span>https://code.visualstudio.com/docs/editor/extension-marketplace#_workspace-recommended-extensions</span></a></p>
			<p class="calibre3">You can use this file to add your own list of recommended plugins that you would like your team members <span>to use.</span></p>
			<p class="calibre3">This is an easy way for teams to standardize plugins and help junior developers get productive faster <a id="_idIndexMarker107" class="pcalibre1 calibre6 pcalibre"/>without them having to learn things the <span>hard way.</span></p>
			<p class="calibre3">You will also notice that Nx has also created a few other files, such as <strong class="source-inline">eslintrc.json</strong>, <strong class="source-inline">.prettierrc</strong>, <strong class="source-inline">.editorconfig</strong>, and so on. All of these files help lay a good foundation for writing good code and ensuring consistency in how that code is written with regard to things such as indentation, the use of single versus double quotes, and <span>so on.</span></p>
			<h2 id="_idParaDest-57" class="calibre5"><a id="_idTextAnchor056" class="pcalibre1 calibre6 pcalibre"/>Running the app locally</h2>
			<p class="calibre3">To run the app locally, we <a id="_idIndexMarker108" class="pcalibre1 calibre6 pcalibre"/>could always run <a id="_idIndexMarker109" class="pcalibre1 calibre6 pcalibre"/>the terminal commands, but for a better developer experience, we will use the newly auto-added Nx Console extension we talked <span>about earlier.</span></p>
			<p class="calibre3">Click on the Nx Console icon and then, under <strong class="bold">GENERATE &amp; RUN TARGET</strong>, select <strong class="bold">serve</strong> and then, from the dropdown at the top, select the <strong class="bold">catalog</strong> app, then select <strong class="bold">Execute:nx  </strong><span><strong class="bold">run catalog:serve</strong></span></p>
			<div class="calibre2">
				<div id="_idContainer021" class="img---figure">
					<img src="image/Figure_3.06_B18987.jpg" alt="Figure 3.6 – Serving the catalog app using Nx Console" class="calibre4"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.6 – Serving the catalog app using Nx Console</p>
			<p class="calibre3">You will notice that it actually runs <strong class="source-inline">pnpm exec nx serve catalog</strong> in the terminal and, after a few seconds, you will have the catalog app running <span>at </span><span><strong class="source-inline">http://localhost:4200</strong></span><span>.</span></p>
			<p class="calibre3">Open the link in the browser and get a feel for the newly created <span>catalog app:</span></p>
			<div class="calibre2">
				<div id="_idContainer022" class="img---figure">
					<img src="image/Figure_3.07_B18987.jpg" alt="Figure 3.7 – Catalog app running on port 4200" class="calibre4"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.7 – Catalog app running on port 4200</p>
			<h2 id="_idParaDest-58" class="calibre5"><a id="_idTextAnchor057" class="pcalibre1 calibre6 pcalibre"/>Creating a new app with Nx Console</h2>
			<p class="calibre3">Next, let us <a id="_idIndexMarker110" class="pcalibre1 calibre6 pcalibre"/>create another new app. Follow <a id="_idIndexMarker111" class="pcalibre1 calibre6 pcalibre"/><span>these steps:</span></p>
			<ol class="calibre13">
				<li class="calibre14">Go to Nx Console and from <strong class="bold">GENERATE &amp; RUN TARGET</strong>, select the <strong class="bold">generate</strong> command. Then, from the dropdown, select <strong class="bold">Create React application</strong>. On the following screen, where it asks for the name of the application, <span>enter </span><span><strong class="source-inline1">checkout</strong></span><span>.</span></li>
				<li class="calibre14">As you scroll down the form for the section that says <strong class="bold">e2eTestRunner</strong>, select none. This will ensure the <strong class="source-inline1">checkout-e2e</strong> folder is <span>not created.</span></li>
			</ol>
			<p class="callout-heading">Important note</p>
			<p class="callout">Notice as you fill in the form fields that Nx is actually doing a dry run on the terminal to show what the output would <span>look like.</span></p>
			<ol class="calibre13">
				<li value="3" class="calibre14">Go ahead and click on the <strong class="bold">Generate</strong> button to generate our <span>checkout app.</span><p class="calibre3">Once done, you will notice the checkout app created within the <strong class="source-inline">apps</strong> folder of <span>the monorepo.</span></p></li>
				<li class="calibre14">Using Nx Console, go ahead and serve the checkout app. On the nx serve checkout screen, scroll down a bit and select <strong class="bold">port</strong> and type 4201 then select <strong class="bold">Execute:nx run checkout:serve –port=4201</strong> to run the checkout app on <span>port 4201.</span></li>
			</ol>
			<p class="calibre3">We can follow <a id="_idIndexMarker112" class="pcalibre1 calibre6 pcalibre"/>the same steps to create additional apps. Nx comes <a id="_idIndexMarker113" class="pcalibre1 calibre6 pcalibre"/>with a whole set of core and community plugins, which allows you to create apps in different frameworks, such as Angular, Next.js, Vue, and so on. You can view the full list of plugins available <span>here: </span><a href="https://nx.dev/community" class="pcalibre1 calibre6 pcalibre"><span>https://nx.dev/community</span></a><span>.</span></p>
			<h2 id="_idParaDest-59" class="calibre5"><a id="_idTextAnchor058" class="pcalibre1 calibre6 pcalibre"/>Setting permissions in your Monorepo</h2>
			<p class="calibre3">Now that we have <a id="_idIndexMarker114" class="pcalibre1 calibre6 pcalibre"/>multiple apps within the monorepo and we <a id="_idIndexMarker115" class="pcalibre1 calibre6 pcalibre"/>assume there are independent teams working on each of these apps, the next thing that arises is how we ensure the right permissions to ensure that teams don’t accidentally make changes to another <span>team’s code.</span></p>
			<p class="calibre3">As we saw earlier, the general thought process with monorepos is that everybody with access to the repo has access to all the apps and folders within the monorepo but they can’t merge code changes in apps they <span>don’t own.</span></p>
			<p class="calibre3">In monorepos, the permissions are set at a folder level and by making use of the <strong class="source-inline">CODEOWNERS</strong> file. You can <a id="_idIndexMarker116" class="pcalibre1 calibre6 pcalibre"/>read in detail about <strong class="source-inline">CODEOWNERS</strong> <span>here: </span><a href="https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners" class="pcalibre1 calibre6 pcalibre"><span>https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners</span></a><span>.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The <strong class="source-inline1">CODEOWNERS</strong> file works with GitHub and GitLab. If you are using Azure DevOps, this feature is implemented via the required approvers <span>feature: </span><a href="https://learn.microsoft.com/en-gb/azure/devops/repos/git/branch-policies?view=azure-devops&amp;tabs=browser#automatically-include-code-reviewers" class="pcalibre1 calibre6 pcalibre"><span>https://learn.microsoft.com/en-gb/azure/devops/repos/git/branch-policies?view=azure-devops&amp;tabs=browser#automatically-include-code-reviewers</span></a><span>.</span></p>
			<p class="calibre3">In short, the <strong class="source-inline">CODEOWNERS</strong> file allows us to ensure that an individual or a team is explicitly involved in the code review and approval of changes to files <span>they own.</span></p>
			<p class="calibre3">We can assign files in two ways: all files within a given folder or all files of a <span>certain type.</span></p>
			<p class="calibre3">Let’s see this <span>in action.</span></p>
			<p class="calibre3">In the root of our monorepo, let’s create a file <span>called </span><span><strong class="source-inline">CODEOWNERS</strong></span><span>:</span></p>
			<pre class="console">
/apps/catalog @my-org/catalog-team
/apps/checkout @my-org/checkout-team</pre>			<p class="calibre3">What this means is <a id="_idIndexMarker117" class="pcalibre1 calibre6 pcalibre"/>if any of the pull requests contain modifications <a id="_idIndexMarker118" class="pcalibre1 calibre6 pcalibre"/>to files within the <strong class="source-inline">apps/catalog</strong> folder, it will automatically add people from the catalog team as reviewers to the pull request, and without approval from that team, the pull request cannot <span>be merged.</span></p>
			<p class="calibre3">The same holds true for pull requests with modifications to files in the <strong class="source-inline">checkout</strong> folder. In this case, it will require an explicit approval from members of the <span>checkout team.</span></p>
			<p class="calibre3">We can also assign an individual in the <strong class="source-inline">CODEOWNERS</strong> file. Let’s say we want to ensure that any changes to files in the <strong class="source-inline">tools</strong> folder need approval from GitHub user <strong class="source-inline">@msadmin</strong>. Let’s also assume we have a CSS expert on our team and would like that person to review all CSS changes in the entire repo. We can add the following two rules to <span>enable this:</span></p>
			<pre class="console">
/tools @msadmin
*.css @cssexpert</pre>			<p class="calibre3">This way, we can ensure a fine-grained approval process for pull requests, ensuring that the right stakeholders are involved in the approval of all changes being made to the files they are responsible for. As you can see, this also allows you to set rules so that an individual’s expertise on a certain subject can be leveraged for the overall benefit of the <span>whole team.</span></p>
			<p class="calibre3">The following are a few points to keep in mind as you create entries in the <span><strong class="source-inline">CODEOWNERS</strong></span><span> file:</span></p>
			<ul class="calibre15">
				<li class="calibre14">File paths in the file <span>are case-sensitive</span></li>
				<li class="calibre14">The priority of the rules is from the bottom to the top of the <strong class="source-inline1">CODEOWNERS</strong> file; for example, if there are multiple matching rules, the bottom-most row gets the <span>highest priority</span></li>
				<li class="calibre14">If a row has a syntax error, it will be skipped, and GitHub will simply move on to the <span>next row</span></li>
			</ul>
			<p class="calibre3">To test this, push the <a id="_idIndexMarker119" class="pcalibre1 calibre6 pcalibre"/>code to GitHub with the entries <a id="_idIndexMarker120" class="pcalibre1 calibre6 pcalibre"/>in the <strong class="source-inline">CODEOWNERS</strong> file, make changes to the file, and raise a pull request to see the <strong class="source-inline">CODEOWNERS</strong> file come <span>into action.</span></p>
			<p class="calibre3">Having come to the end of this section, we have learned how to initialize a monorepo using Nx, how to create apps within our monorepo, and how to run them individually using NX Console. We also had a quick look at some of the tooling advantages we get with Nx, which offers a really good developer experience for beginners and also ensures a strong foundation for your application by automatically setting up some of the quality gates for your repo. Finally, we looked at the various way we can set up permissions on our repo to allow open collaboration and also leverage individual team members’ strengths for the benefit of the <span>whole team.</span></p>
			<h1 id="_idParaDest-60" class="calibre7"><a id="_idTextAnchor059" class="pcalibre1 calibre6 pcalibre"/>Summary</h1>
			<p class="calibre3">With this, we come to the end of this chapter, where we unpacked quite a bit. We saw how teams today are choosing between a monorepo and a polyrepo approach to version control their <span>code bases.</span></p>
			<p class="calibre3">We then went into the details of how the choice of a polyrepo or a monorepo impacts how your teams operate, how easy or difficult it is to refactor code, and who owns the responsibility of fixing breaking changes in <span>the repo.</span></p>
			<p class="calibre3">We then saw why choosing monorepos for microfrontends has more benefits, such as the ease of managing all the micro-apps within a single repo, especially when it comes to running multiple apps locally and managing the tooling centrally for all the apps within <span>the monorepo.</span></p>
			<p class="calibre3">Finally, we went about setting up our monorepo, where we saw the benefits of using a tool such as Nx, which provides us with prebaked quality gates such as ESLint and Prettier to ensure consistency and code quality. We also saw how to use Nx Console to easily create new micro-apps and run existing micro-apps. We then saw how to set up the <strong class="source-inline">CODEOWNERS</strong> file to ensure granular control over who can approve code changes for a <span>given micro-app.</span></p>
			<p class="calibre3">In the next chapter, we will take our current setup and go about creating a full-fledged multi-SPA <span>pattern microfrontend.</span></p>
		</div>
	</body></html>