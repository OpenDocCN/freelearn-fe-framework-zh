- en: Spaceship Dashboard
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 太空船仪表盘
- en: When I was a child, I loved to play spaceship pilot. I piled up old carton boxes
    and decorated the interiors to look like a spaceship cockpit. With a marker, I
    drew a spaceship dashboard on the inside of the boxes, and I remember playing
    in there for hours.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当我还是个孩子的时候，我喜欢玩太空船飞行员。我把一些旧的纸箱堆起来，并装饰内部使其看起来像太空船驾驶舱。我用记号笔在箱子的内侧画了一个太空船仪表盘，我记得我在那里玩了好几个小时。
- en: The thing that's special about the design of cockpits and spaceship dashboard
    is that they need to provide an overview and control over the whole spaceship,
    in very limited space. I think the same applies to application dashboards. A dashboard
    should provide the user with an overview and a sense of the overall status of
    what's going on.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 驾驶舱和太空船仪表盘的设计特别之处在于，它们需要在非常有限的空间内提供对整个太空船的概述和控制。我认为这同样适用于应用程序仪表盘。仪表盘应该为用户提供对整体状况的概述和感觉。
- en: 'In this chapter, we will create such a dashboard for our task management application.
    We will make use of the open source charting library Chartist to create good looking,
    responsive charts and provide an overview of open tasks and project statuses:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为我们的任务管理应用程序创建这样一个仪表盘。我们将利用开源图表库Chartist来创建外观美观、响应式的图表，并提供开放任务和项目状态的概述：
- en: '![](img/926c564d-4442-4162-9cce-752159eb7aff.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/926c564d-4442-4162-9cce-752159eb7aff.png)'
- en: A preview of the tasks chart that we will build in this chapter
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中构建的任务图表预览
- en: 'On a higher level, we will create the following components in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在更高层次上，在本章中我们将创建以下组件：
- en: '**Project summary**: This is the project summary that will provide a quick
    insight into the overall project status. By aggregating the efforts of all tasks
    in a project, we can provide a nice overall effort status, for which we have created
    the components in the previous chapter.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目摘要**：这是提供对整体项目状态快速洞察的项目摘要。通过汇总项目中所有任务的投入，我们可以提供一个很好的整体投入状态，为此我们在上一章中创建了组件。'
- en: '**Project activity chart**: Without any labels or scales, this bar chart will
    give a quick sense of the activity on projects in the last 24 hours.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目活动图表**：没有标签或刻度，这个柱状图将快速传达过去24小时内项目活动的感觉。'
- en: '**Project tasks chart**: This chart will provide an overview of the task progress
    on projects. Using a line chart, we will display the count of open tasks over
    a certain time period. Using the toggle component that we created in [Chapter
    2](11f96942-6e99-46c5-b152-1af3b2579d44.xhtml), *Ready, Set, Go!*, we''ll provide
    an easy way for the user to switch the timeframe displayed on the chart.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目任务图表**：这个图表将提供项目任务进度的概述。我们将使用折线图显示一定时间内的开放任务数量。通过我们在[第2章](11f96942-6e99-46c5-b152-1af3b2579d44.xhtml)“准备，出发！”中创建的切换组件，我们将为用户提供一个简单的方法来切换图表上显示的时间范围。'
- en: Introduction to Chartist
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Chartist简介
- en: In this chapter, we will create some components that will render charts, and
    we should look for some help in rendering them. Of course, we can follow a similar
    approach to what we used in [Chapter 6](2ba38f09-ef9f-4aee-952f-3ade56c99356.xhtml),
    *Keeping up with Activities*, when we drew our activity timeline. However, when
    it comes to more complex data visualization, it's better to rely on a library
    to do the heavy lifting.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一些组件来渲染图表，并且我们应该寻求一些帮助来渲染它们。当然，我们可以采用与我们在[第6章](2ba38f09-ef9f-4aee-952f-3ade56c99356.xhtml)“跟上活动”中所使用的类似方法，当时我们绘制了活动时间线。然而，当涉及到更复杂的数据可视化时，最好依赖于库来完成繁重的工作。
- en: It shouldn't be a surprise that we'll use a library called Chartist to fill
    this gap, because I've spent almost two years writing it. As the author of Chartist,
    I feel very lucky that we've found a perfect spot in this book to make use of
    it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个名为Chartist的库来填补这个空白，这并不令人惊讶，因为我几乎花了两年时间来编写它。作为Chartist的作者，我感到非常幸运，我们在这本书中找到了一个完美的位置来利用它。
- en: I'd like to take the opportunity to briefly introduce you to Chartist, before
    we dive into the implementation of the components for our dashboard.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入实现仪表盘组件之前，我想借此机会简要介绍一下Chartist。
- en: Chartist claims to provide simple responsive charts. Luckily, this is still
    the case after three years of existence. I can tell you that the hardest job of
    maintaining this library was probably protecting it from feature bloat. There
    are so many great movements, technologies, and ideas in the open source community,
    and to resist bloating the scope of the library and always stay focused on the
    initial claim wasn't easy.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Chartist 声称提供简单的响应式图表。幸运的是，在存在三年之后，这仍然是事实。我可以告诉你，维护这个库最困难的工作可能是保护它免受功能膨胀的影响。开源社区中有许多伟大的运动、技术和想法，要抵制库范围的膨胀并始终专注于初始声明并不容易。
- en: 'Let me show you a very basic example of how you can create a simple line chart,
    once you''ve included the Chartist scripts on your website:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我向您展示一个非常基础的例子，说明您如何在网站上包含 Chartist 脚本后创建简单的折线图：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The corresponding HTML markup that is required for this example looks as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为此示例所需的相应 HTML 标记如下所示：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following figure shows you the resulting chart that is rendered by Chartist:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了 Chartist 生成的图表：
- en: '![](img/3968c7cc-44ba-4d16-83b5-daf2edc809d9.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3968c7cc-44ba-4d16-83b5-daf2edc809d9.png)'
- en: A simple line chart rendered with Chartist
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Chartist 生成的简单折线图
- en: I believe that by saying we'll stick to being simple, we've not promised too
    much.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为，通过说我们将坚持简单，我们并没有承诺太多。
- en: Let's look at the second core concern of Chartist, which is to be perfectly
    responsive. Chartist tries to stick to a very clear separation of concerns wherever
    possible, which means that it uses CSS for its appearance, SVG for its basic graphical
    structure, and JavaScript for any behaviors. By following this principle, we've
    already enabled a lot of responsiveness. We can use CSS media queries to apply
    different styles to our charts on different media.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Chartist 的第二个核心关注点，即完美响应。Chartist 尽可能地坚持清晰的关注点分离，这意味着它使用 CSS 来控制外观，SVG
    来控制基本的图形结构，JavaScript 来控制任何行为。通过遵循这个原则，我们已经实现了很多响应性。我们可以使用 CSS 媒体查询在不同的媒体上为我们的图表应用不同的样式。
- en: While CSS is great for visual styles, there are plenty of elements in the process
    of rendering charts, which, unfortunately, can't be controlled by CSS. After all,
    that is the reason why we use a JavaScript library to render charts.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 CSS 对于视觉样式来说很棒，但在渲染图表的过程中有很多元素，遗憾的是，这些元素无法通过 CSS 控制。毕竟，这就是我们使用 JavaScript
    库来渲染图表的原因。
- en: So, how can we control how Chartist renders our charts on different media, if
    we don't have control over this in CSS? Well, Chartist provides something called
    **responsive configuration overrides**. Using the browser's `matchMedia` API,
    Chartist is able to provide a configuration mechanism that allows you to specify
    options that you want to use only on certain media (mobile, desktop etc.).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果我们无法在 CSS 中控制这一点，我们如何控制 Chartist 在不同媒体上渲染图表的方式呢？嗯，Chartist 提供了称为 **响应式配置覆盖**
    的功能。使用浏览器的 `matchMedia` API，Chartist 能够提供一个配置机制，允许您指定仅在特定媒体（移动、桌面等）上使用的选项。
- en: 'Let''s look at a simple example of how we can easily implement responsive behavior
    using a mobile-first approach:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用移动优先的方法轻松实现响应式行为的一个简单例子：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, the second parameter to the `Chartist.Line` constructor sets
    the initial options; we can provide overriding options, annotated with media queries
    in an array, as the third parameter of the constructor. In this example, we'll
    override the `showPoint` option for any media larger than 400 px in width. Media
    larger than 800 px in width will receive both the `showPoint` override and the
    `lineSmooth` override.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Chartist.Line` 构造函数的第二个参数设置初始选项；我们可以提供覆盖选项，以数组形式通过构造函数的第三个参数使用媒体查询进行注释。在这个例子中，我们将覆盖宽度大于
    400 像素的任何媒体的 `showPoint` 选项。宽度大于 800 像素的媒体将同时接收 `showPoint` 覆盖和 `lineSmooth` 覆盖。
- en: 'Not only can we specify real media queries to trigger setting changes, but
    we can also use an overriding mechanism that is very similar to CSS. This way,
    we can implement various approaches, such as ranged or exclusive media queries,
    mobile-first, or desktop-first. The responsive options mechanism can be used for
    all of the options available in Chartist:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅可以通过指定真实的媒体查询来触发设置更改，还可以使用与 CSS 非常相似的覆盖机制。这样，我们可以实现各种方法，如范围或排他性媒体查询、移动优先或桌面优先。响应式选项机制可以用于
    Chartist 中所有可用的选项：
- en: '![](img/8e4ec997-6217-4cf6-a2f7-f9a8c40b3e15.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e4ec997-6217-4cf6-a2f7-f9a8c40b3e15.png)'
- en: Displaying the previous chart on three different media, left to right, with
    a media with less than 400 px (A), less than 800 px (B), and more than 800 px
    (C)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在三种不同的媒体上显示前一个图表，从左到右，包括小于 400 像素的媒体（A）、小于 800 像素的媒体（B）和大于 800 像素的媒体（C）
- en: As you can see, implementing complex responsive behavior is a breeze with Chartist.
    Although our task management application was never meant to be a responsive web
    application, we can still benefit from this feature, in order to optimize our
    content.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，使用 Chartist 实现复杂的响应式行为非常简单。尽管我们的任务管理应用原本并不打算成为一个响应式网络应用，但我们仍然可以从中受益，以优化我们的内容。
- en: That's enough about Chartist to get you started. If you would like to know more
    about my library, I recommend that you check out the project's website at [http://gionkunz.github.io/chartist-js](http://gionkunz.github.io/chartist-js).
    On the website, you can also visit the live example page at [http://gionkunz.github.io/chartist-js/examples.html](http://gionkunz.github.io/chartist-js/examples.html),
    where you can hack some charts directly in the browser.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Chartist 的介绍就到这里，如果你想了解更多关于我的库的信息，我建议你查看项目的网站[http://gionkunz.github.io/chartist-js](http://gionkunz.github.io/chartist-js)。在网站上，你还可以访问实时示例页面[http://gionkunz.github.io/chartist-js/examples.html](http://gionkunz.github.io/chartist-js/examples.html)，在那里你可以直接在浏览器中修改一些图表。
- en: Projects dashboard
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目仪表板
- en: 'In this chapter, we''ll create a projects dashboard, which will consist of
    the following components:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个项目仪表板，它将包括以下组件：
- en: '**Projects dashboard**: This is the main component in the dashboard and represents
    our whole dashboard view. It''s a composition of the rest of the components.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目仪表板**：这是仪表板中的主要组件，代表了我们整个仪表板视图。它是其他组件的组合。'
- en: '**Project summary**: This is where we''ll display a summary of each project,
    where we will outline the most important facts. Our project summary component
    will also include an activity chart component that visualizes project activities.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目摘要**：这是我们展示每个项目摘要的地方，我们将概述最重要的信息。我们的项目摘要组件还将包括一个活动图表组件，用于可视化项目活动。'
- en: '**Projects dashboard container**: We also need to create a new container component,
    to expose our new component tree to the router and connect it to our database.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目仪表板容器**：我们还需要创建一个新的容器组件，以便将我们的新组件树暴露给路由器，并将其连接到我们的数据库。'
- en: '**Tasks chart**: This is where we''ll provide a visual overview of open tasks
    over time. All projects will be represented in a line chart that displays the
    progress of open tasks. We''ll also provide some user interaction, so that the
    user can choose between different timeframes.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务图表**：这是我们提供开放任务随时间视觉概述的地方。所有项目将以折线图的形式表示，显示开放任务的进度。我们还将提供一些用户交互功能，以便用户可以选择不同的时间段。'
- en: '**Activity chart**: This component visualizes activities in a bar chart over
    a timeframe of 24 hours. This will help our users to quickly identify overall
    project activities and peaks.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**活动图表**：此组件在 24 小时的时间范围内以条形图的形式可视化活动。这将帮助我们的用户快速识别整体项目活动和峰值。'
- en: Creating the projects dashboard component
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建项目仪表板组件
- en: Let's follow our established tradition and start by modelling our data, which
    we're going to use in our components. We'd like to create a new interface to summarize
    projects. This includes the project data, tasks, activities, and a short description.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们遵循我们确立的传统，首先建模我们将在组件中使用的数据。我们希望创建一个新的接口来总结项目。这包括项目数据、任务、活动和简短描述。
- en: 'Open our model file, located in `src/app/model.ts`, and add the following interface:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 打开位于 `src/app/model.ts` 的模型文件，并添加以下接口：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using this interface, we can aggregate all project relevant data into a single
    object, which simplifies our development a lot.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此界面，我们可以将所有与项目相关的数据聚合到一个单一的对象中，这极大地简化了我们的开发工作。
- en: Let's move ahead and create our main dashboard component. The projects dashboard
    component has the responsibility of composing the main dashboard layout, by including
    our dashboard sub-components. It holds together all of the pieces within our projects
    dashboard.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进，创建我们的主要仪表板组件。项目仪表板组件负责组合主要仪表板布局，通过包含我们的仪表板子组件。它将我们项目仪表板中的所有部件组合在一起。
- en: 'Let''s create our new projects dashboard component by using the Angular CLI
    tool:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Angular CLI 工具创建我们的新项目仪表板组件：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Open up the generated component class, located on the path `src/app/projects-dashboard/projects-dashboard/projects-dashboard.component.ts`,
    and replace the stub code with the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 打开位于路径`src/app/projects-dashboard/projects-dashboard/projects-dashboard.component.ts`的生成组件类，并用以下代码替换占位符代码：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Our dashboard component accepts a `projectSummaries` input, which is a list
    of project summary objects that conforms to the `ProjectSummary` interface that
    we just created within our `TypeScript` model file.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的仪表板组件接受一个`projectSummaries`输入，这是一个符合我们刚刚在`TypeScript`模型文件中创建的`ProjectSummary`接口的项目摘要对象列表。
- en: A user can activate a project by clicking on a project summary component. Our
    projects dashboard component uses the output `outActivateProject` to delegate
    the event to the container, which we'll create later.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以通过点击项目摘要组件来激活一个项目。我们的项目仪表板组件使用输出`outActivateProject`将事件委派给容器，这是我们稍后要创建的。
- en: 'Let''s take a look at the view of our component, and change the content within
    the file `src/app/projects-dashboard/projects-dashboard/projects-dashboard.component.html`
    to the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看组件的视图，并将文件`src/app/projects-dashboard/projects-dashboard/projects-dashboard.component.html`中的内容更改为以下内容：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For the moment, we only displayed the project title and the description that
    we'll compute on our project summary objects. In the next section, we will create
    a new project summary component that will deal with some more complex rendering.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只显示了项目标题和我们将计算的项目摘要对象中的描述。在下一节中，我们将创建一个新的项目摘要组件，该组件将处理一些更复杂的渲染。
- en: Project summary component
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目摘要组件
- en: In this section, we'll create a project summary component that will provide
    some overview information for projects. Within the container component of our
    projects dashboard component tree, we'll make sure that we aggregate all of the
    necessary information to summarize projects. Our project summary UI component
    renders the data provided in the project summary objects, to create nice looking
    project overview cards.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个项目摘要组件，该组件将为项目提供一些概述信息。在我们的项目仪表板组件树中的容器组件中，我们将确保汇总所有必要的信息来总结项目。我们的项目摘要UI组件渲染项目摘要对象中提供的数据，以创建看起来很棒的项目概览卡片。
- en: 'Let''s start building our component using the Angular CLI tool:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Angular CLI工具开始构建我们的组件：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s open the component class, located in `src/app/projects-dashboard/project-summary/project-summary.component.ts`,
    and replace its content with the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开位于`src/app/projects-dashboard/project-summary/project-summary.component.ts`的组件类，并用以下代码替换其内容：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `projectSummary` input allows for passing a project summary object into
    our new UI component. There, we have all of the necessary information for displaying
    an overview of the project.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`projectSummary`输入允许将项目摘要对象传递到我们的新UI组件中。在那里，我们有显示项目概览所需的所有必要信息。'
- en: If you remember from the previous chapter, [Chapter 8](43791ecf-9bd7-4439-ba76-8f34098d350a.xhtml),
    *Time Will Tell*, we've created a nice effort timeline component using SVG. Within
    our project summary, we would now like to reuse that component. However, we need
    to compute the total effort from the underlying tasks of our project.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得上一章，[第8章](43791ecf-9bd7-4439-ba76-8f34098d350a.xhtml)，《时间会证明》，我们已经使用SVG创建了一个不错的努力时间线组件。现在，在我们的项目摘要中，我们希望重用这个组件。然而，我们需要从我们项目的底层任务中计算总工作量。
- en: What we need to do is accumulate all task efforts into one overall effort. Using
    the `Array.prototype.reduce` function, we can accumulate all task efforts relatively
    easy. We're depending on the tasks present within our project summary object,
    which is passed to us with the input `projectSummary`. Since we'd like to recalculate
    the total effort when the project information changes, we can use the `OnChanges`
    life cycle hook and implement the method `ngOnChanges`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的是将所有任务工作量累积到一个总工作量中。使用`Array.prototype.reduce`函数，我们可以相对容易地累积所有任务工作量。我们依赖于项目摘要对象中存在的任务，该对象通过输入`projectSummary`传递给我们。由于我们希望在项目信息更改时重新计算总工作量，我们可以使用`OnChanges`生命周期钩子并实现`ngOnChanges`方法。
- en: 'Let''s create the template of our component, to see how we''re going to use
    the total efforts data to display our efforts timeline component. Open the file
    on the path `src/app/projects-dashboard/project-summary/project-summary.component.ts`,
    and amend it with the following content:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建组件的模板，看看我们将如何使用总工作量数据来显示我们的努力时间线组件。打开路径`src/app/projects-dashboard/project-summary/project-summary.component.ts`的文件，并添加以下内容：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: After displaying the project title and a description of the project summary,
    we included our efforts timeline component. We simply pass our computed `totalEfforts`
    into the `efforts` input, and the efforts timeline component will take care of
    the rendering. This timeline will now display the total aggregated amount of efforts
    logged on all tasks of a given project.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在显示项目标题和项目摘要的描述之后，我们包含了我们的努力时间线组件。我们只需将我们的计算出的 `totalEfforts` 传递到 `efforts`
    输入中，努力时间线组件就会负责渲染。这个时间线现在将显示在给定项目的所有任务上记录的总努力量。
- en: In addition to the timeline, we also rendered a formatted efforts text, like
    the one that we already rendered in the efforts component of the previous chapter.
    For this, we used the `formatEfforts` pipe.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 除了时间线之外，我们还渲染了格式化的努力文本，就像我们在上一章的努力组件中已经渲染的那样。为此，我们使用了 `formatEfforts` 管道。
- en: Now, we still need to integrate our project summary component into the projects
    dashboard component.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们仍然需要将我们的项目摘要组件集成到项目仪表板组件中。
- en: 'Let''s open the template of our projects dashboard, located in `src/app/projects-dashboard/projects-dashboard/projects-dashboard.component.html`,
    and modify the template to include our project summary component:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开位于 `src/app/projects-dashboard/projects-dashboard/projects-dashboard.component.html`
    的项目仪表板模板，并修改模板以包含我们的项目摘要组件：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can simply forward the project summary object to our newly created project
    summary component. Additionally, we''ve added a click event binding on project
    summary components, which will trigger our `activateProject` method on the projects
    dashboard component. This will allow us to implement a programmatic navigation
    within our container component, which is up next for implementation:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接将项目摘要对象转发到我们新创建的项目摘要组件。此外，我们在项目摘要组件上添加了一个点击事件绑定，这将触发项目仪表板组件上的 `activateProject`
    方法。这将允许我们在容器组件内实现程序化导航，这是接下来要实现的功能：
- en: '![](img/109ad064-df33-4643-bd5c-23cf44292389.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/109ad064-df33-4643-bd5c-23cf44292389.png)'
- en: A projects dashboard displaying two project summary components, with the aggregated
    total effort
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一个显示两个项目摘要组件的项目仪表板，包含汇总的总努力量
- en: Okay; so far, so good. We created two new UI components and reused our efforts
    timeline component to create an aggregated view of the total task efforts. Now,
    it's time to integrate our components by creating a new container component and
    configure the router of our application.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧；到目前为止，一切顺利。我们创建了两个新的 UI 组件，并重用了我们的努力时间线组件来创建总任务努力的汇总视图。现在，是时候通过创建一个新的容器组件并配置应用程序的路由来集成我们的组件了。
- en: Integrating the projects dashboard
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成项目仪表板
- en: We've created our initial projects dashboard components, and will now work on
    their integration into our application. We're going to need a new container component,
    which we'll also expose within the router configuration. We also need to update
    the navigation component of our application, in order to show a new navigation
    link to the dashboard view.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了初始的项目仪表板组件，并将开始将它们集成到我们的应用程序中。我们需要一个新的容器组件，我们也会在路由配置中公开它。我们还需要更新应用程序的导航组件，以便显示指向仪表板视图的新导航链接。
- en: 'Let''s start with our new container component and use the Angular CLI tool
    to create the stubs for it:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们的新容器组件开始，并使用 Angular CLI 工具为其创建占位符：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Open up the generated component class, located in `src/app/container/projects-dashboard-container/projects-dashboard-container.component.ts`,
    and replace its content with the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 打开位于 `src/app/container/projects-dashboard-container/projects-dashboard-container.component.ts`
    的生成组件类，并用以下代码替换其内容：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Our newly created container is responsible for gathering all information necessary
    to create a list of project summary objects. We're using RxJS observables to create
    a reactive stream of project summary objects. The RxJS utility `combineLatests`
    allows us to join projects, tasks, and activities into one single stream. Within
    this joined stream, we are using the `map` operator to create one project summary
    object for every project obtained from the project service.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新创建的容器负责收集创建项目摘要对象列表所需的所有信息。我们使用 RxJS 可观察对象创建一个反应性流的项目摘要对象。RxJS 工具 `combineLatests`
    允许我们将项目、任务和活动合并到一个单一流中。在这个合并流中，我们使用 `map` 操作符为从项目服务中获取的每个项目创建一个项目摘要对象。
- en: We're using our `limitWithEllipsis` helper function to convert the project description
    into a truncated (if necessary) version, which we're adding directly to our project
    summary object.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用我们的`limitWithEllipsis`辅助函数将项目描述转换为（如果需要）截断版本，并将其直接添加到我们的项目摘要对象中。
- en: We've also injected the router into our container component, and will use it
    to do a programmatic navigation to the project view. We've implemented a method,
    `activateProject`, for this purpose, which we're going to call from our view.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在我们的容器组件中注入路由，并使用它来进行程序性导航到项目视图。我们已经实现了一个名为`activateProject`的方法，我们将从我们的视图中调用它。
- en: 'Let''s also change the template of our container component where we want to
    render the projects dashboard UI component and create the necessary bindings to
    pass our project summary data into the UI component tree. Open the file `src/app/container/projects-dashboard-container/projects-dashboard-container.component.html`,
    and replace its content with the following code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也更改容器组件的模板，其中我们想要渲染项目仪表板UI组件，并创建必要的绑定来将我们的项目摘要数据传递到UI组件树中。打开文件`src/app/container/projects-dashboard-container/projects-dashboard-container.component.html`，并用以下代码替换其内容：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: All we need to do is render our projects dashboard UI component. We're passing
    our generated project summary objects down into the component input. Since we've
    implemented this using an observable stream, we need to use the `async` pipe.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的只是渲染我们的项目仪表板UI组件。我们将生成的项目摘要对象传递到组件输入中。由于我们使用可观察流实现了这一点，我们需要使用`async`管道。
- en: When a project gets activated within the projects dashboard UI component, we
    receive an `outActivateProject` output event, which we can then use to call our
    `activateProject` method. There, we're using the router to navigate to the given
    project view.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当项目在项目仪表板UI组件中被激活时，我们收到一个`outActivateProject`输出事件，然后我们可以使用它来调用我们的`activateProject`方法。在那里，我们使用路由导航到指定的项目视图。
- en: Alright; now, we have all of the components ready to render our projects dashboard.
    There are two things left to do. We need to configure our router to activate our
    newly created container component and create a new navigation item within our
    app root component.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 好的；现在，我们已经准备好了所有组件来渲染我们的项目仪表板。还有两件事要做。我们需要配置我们的路由来激活我们新创建的容器组件，并在我们的应用程序根组件中创建一个新的导航项。
- en: 'Let''s start with the route configuration. Open up the route configuration
    file, located in `src/app/routes.ts`, and apply the following changes:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从路由配置开始。打开位于`src/app/routes.ts`的路由配置文件，并应用以下更改：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We've added a new route configuration to activate our projects dashboard container
    component. In addition, we've changed our default redirect URL to redirect to
    our dashboard, instead of the first project detail view.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个新的路由配置来激活我们的项目仪表板容器组件。此外，我们将默认的重定向URL更改为重定向到我们的仪表板，而不是第一个项目详情视图。
- en: 'Okay; let''s move on and use our new route to create a navigation item within
    our app root component. Open up the app component template, located in `src/app/app.component.html`,
    and perform the following changes:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 好的；让我们继续前进，并使用我们的新路由在我们的应用程序根组件中创建一个导航项。打开位于`src/app/app.component.html`的应用组件模板，并执行以下更改：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Awesome! You've just completed all of the steps necessary for integrating our
    first set of projects dashboard components. You can now preview your changes in
    the browser. There should be a new navigation item available within the main navigation
    of the application. Also, when starting the application, you should automatically
    be redirected to the dashboard view.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！你已经完成了集成我们第一套项目仪表板组件所需的所有步骤。你现在可以在浏览器中预览你的更改。在应用程序的主要导航中应该有一个新的导航项可用。另外，当你启动应用程序时，你应该自动被重定向到仪表板视图。
- en: You can already play with the efforts aggregation and try to modify a new task
    effort of a project, to see how the summary will be affected.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以尝试玩转努力聚合，并尝试修改项目的新的任务努力，看看摘要会如何受到影响。
- en: In the next section, we will enrich our project summary component with a nice
    Chartist chart.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将用漂亮的Chartist图表丰富我们的项目摘要组件。
- en: Creating your first chart
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你的第一个图表
- en: In this section, we will create our first chart using Chartist, to provide a
    project activity overview over the past 24 hours. This bar chart will only provide
    some visual clues about the project activity, and our goal isn't to provide detailed
    information. For this reason, we will configure it to hide any labels, scales,
    and grid lines. The only visible part should be the bars of the bar chart.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用Chartist创建我们的第一个图表，以提供过去24小时的项目活动概述。这个条形图将只提供一些关于项目活动的视觉线索，我们的目标不是提供详细的信息。因此，我们将配置它隐藏任何标签、刻度和网格线。唯一可见的部分应该是条形图的条形。
- en: Processing activity data
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理活动数据
- en: Before we start creating the activity chart itself, we need to look at how we
    should transform and prepare our data for the charts.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始创建活动图本身之前，我们需要看看我们应该如何转换和准备我们的数据以供图表使用。
- en: Let's look at what data we already have in our system. As far as the activities
    go, they all have a timestamp stored in the `time` field. However, for our chart,
    a list of timestamps is not sufficient enough. What we're looking for is a chart
    that displays one bar for each hour of the past 24 hours. Each one hour bar should
    represent the count of activities during that time.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们系统中已有的数据。就活动而言，它们都在`time`字段中存储了一个时间戳。然而，对于我们的图表来说，一个时间戳列表是不够的。我们想要的是一个显示过去24小时内每小时一个条形的图表。每个小时的条形应该代表该时间段内的活动数量。
- en: 'The following illustration shows our source data, which is basically a time
    stream of activity events. On the lower arrow, we can see the data that we need
    to end up with for our chart:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的插图显示了我们的源数据，基本上是活动事件的时序流。在下面的箭头上，我们可以看到我们需要为我们的图表结束的数据：
- en: '![](img/26fd9766-7b21-4cf7-bb7d-5b33e092b85c.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/26fd9766-7b21-4cf7-bb7d-5b33e092b85c.png)'
- en: An illustration displaying activities as a time stream, where dots represent
    activities. By rasterizing the events into one-hour slices, we get something we
    call rasterized counts, as shown on the bottom arrow.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一幅显示活动作为时间流的插图，其中点代表活动。通过将事件光栅化到一小时的切片中，我们得到我们称之为光栅化计数的东西，如底部箭头所示。
- en: First of all, we're going to introduce a new interface within our application
    model. We would like to represent a data value within a list of values, which
    is getting rasterized.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在我们的应用程序模型中引入一个新的接口。我们希望在一个值列表中表示一个数据值，该值正在被光栅化。
- en: We use the term rasterization to describe the process of sampling underlying
    data into slices on a raster. This is very similar to how a digital camera would
    sample the photons of light rays and accumulate them on a raster which we call
    pixels.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用“光栅化”这个术语来描述将底层数据采样到光栅上的过程。这与数字相机如何采样光线的光子并将它们累积在称为像素的光栅上非常相似。
- en: 'Since we''d like to not only use a timestamp for rasterization, but also weigh
    data values differently, depending on situations, we will introduce the following
    interface to our model, located in `src/app/model.ts`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不仅想为光栅化使用时间戳，而且根据情况不同，对数据值进行不同的加权，因此我们将引入以下接口到我们的模型中，位于`src/app/model.ts`：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the previous figure, we counted all activities within a given hour and added
    up them up. However, we will need a more specific solution that allows us to incorporate
    weight while counting. This is especially useful if you want to make certain activities
    count more than others. By using a property called `weight` on data input to the
    rasterization process, we can accomplish a weighted count. In fact, we're no longer
    counting data values within a `timeframe`; we're adding up their weights to get
    a total weight for a given `timeframe`. This allows us to use negative weights,
    which will subtract from the total weight. This will be important for the second
    chart, which we're going to create at a later stage.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们计算了给定小时内所有的活动并将它们加起来。然而，我们需要一个更具体的解决方案，允许我们在计数时加入权重。这特别有用，如果你想使某些活动比其他活动更重要。通过在光栅化过程的数据输入上使用一个名为`weight`的属性，我们可以完成加权计数。实际上，我们不再在`timeframe`内计数数据值；我们正在将它们的权重加起来，以获得给定`timeframe`的总权重。这允许我们使用负权重，这将从总权重中减去。这对于我们将在稍后阶段创建的第二张图表将非常重要。
- en: 'Let''s implement the function that performs the outlined data transformation.
    We''ll add this function to our time utility module, located in `src/app/utilities/time-utilities.ts`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现执行概述数据转换的函数。我们将把这个函数添加到我们的时间实用模块中，位于`src/app/utilities/time-utilities.ts`：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s briefly look at the input parameters of our newly created function:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地看看我们新创建的函数的输入参数：
- en: '`timeData`: This parameter is expected to be an array of rasterization data
    objects that contains a `time` property set to the timestamp of the event that
    should be counted. The objects should also contain a `weight` property, which
    is used to count. Using this property, we can count one event as two, or even
    count minus values to decrease the count in a rasterized frame.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timeData`：此参数预期是一个包含一个`time`属性，设置为应计数的事件的戳记的光栅化数据对象数组。对象还应包含一个`weight`属性，用于计数。使用此属性，我们可以将一个事件计为两个，甚至可以计数负值以减少光栅化帧中的计数。'
- en: '`timeFrame`: This parameter specifies the time span of each rasterized frame,
    in milliseconds. If we want to have 24 rasterized frames, each consisting of one
    hour, this parameter needs to be set to 3,600,000 (*1 h = 60 min = 3,600 s = 3,600,000
    ms*).'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timeFrame`：此参数指定每个光栅化帧的时间跨度，以毫秒为单位。如果我们想有24个光栅化帧，每个帧包含一小时，则此参数需要设置为3,600,000（*1小时=60分钟=3,600秒=3,600,000毫秒*）。'
- en: '`quantity`: This parameter sets the amount of rasterized frames that should
    be present in the output array. In the case of 24 frames of one hour, this parameter
    should be set to 24.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quantity`：此参数设置输出数组中应存在的光栅化帧的数量。在每小时24帧的情况下，此参数应设置为24。'
- en: '`now`: This parameter should be set as the point in time when the rasterization
    process will start. The rasterization will always move backwards in time, so this
    time marks the end time of our rasterization. The `now` parameter should be a
    timestamp, in milliseconds.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`now`：此参数应设置为光栅化过程开始的时间点。光栅化将始终向后移动时间，因此这个时间标记了我们的光栅化结束时间。`now`参数应是一个以毫秒为单位的时间戳。'
- en: '`fill`: This is how we can specify how we''d like our rasterized output array
    to be initialized. In the case of our activity counts, we want this to be set
    to zero.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fill`：这是我们指定我们希望如何初始化我们的光栅化输出数组的方式。在我们的活动计数中，我们希望将其设置为零。'
- en: The function that we just created is necessary to create the activity chart.
    The transformation helps us to prepare project activities for the input data of
    the chart.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建的函数对于创建活动图表是必要的。转换帮助我们为图表的输入数据准备项目活动。
- en: Creating an activity chart
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建活动图表
- en: 'It''s time to create our first chart component using Chartist! However, before
    we get into our component, we need to make sure that Chartist is installed within
    our project. Let''s use npm to install Chartist as a dependency:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候使用Chartist创建我们的第一个图表组件了！然而，在我们进入组件之前，我们需要确保Chartist已安装在我们的项目中。让我们使用npm将Chartist作为依赖项安装：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Chartist is currently written in pure JavaScript. Luckily, the community created
    a very sophisticated type definition for Chartist, so you can benefit from typed
    interfaces when using Chartist with TypeScript.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Chartist目前是用纯JavaScript编写的。幸运的是，社区为Chartist创建了一个非常复杂的类型定义，因此您可以在使用TypeScript与Chartist一起使用时受益于类型化接口。
- en: 'Okay; that''s all it takes to get us going with Chartist. Now, let''s create
    our activity chart using the Angular CLI:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧；这就是我们开始使用Chartist所需的所有内容。现在，让我们使用Angular CLI创建我们的活动图表：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s open the generated template, located on the path `src/app/projects-dashboard/activity-chart/activity-chart.component.html`,
    and replace its content with the following code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开位于路径`src/app/projects-dashboard/activity-chart/activity-chart.component.html`上生成的模板，并用以下代码替换其内容：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As we leave all of the rendering up to Chartist, this is actually everything
    we need. Chartist needs an element as a container to create the chart in. We set
    a `chartContainer` local view reference, so that we can reference it from our
    component and pass it to Chartist.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将所有渲染工作都交给了Chartist，这实际上是我们所需要的全部。Chartist需要一个元素作为容器来创建图表。我们设置了一个`chartContainer`局部视图引用，这样我们就可以从我们的组件中引用它并将其传递给Chartist。
- en: 'Let''s move on with the chart creation. Open up the component class, located
    in `src/app/projects-dashboard/activity-chart/activity-chart.component.ts`, and
    add the following code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建图表。打开位于`src/app/projects-dashboard/activity-chart/activity-chart.component.ts`的组件类，并添加以下代码：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In addition to the imports from the Angular core module, we're also importing
    the Chartist namespace object, as well as the interface, `IChartistBarChart`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从Angular核心模块导入之外，我们还导入了Chartist命名空间对象以及接口`IChartistBarChart`。
- en: Our component takes a list of activities as input, which we're going to transform
    using our new rasterization function. This transformed data is then used with
    Chartist to visualize the data. We're using a member, chart, to store the Chartist
    instance, once created.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的组件接受一个活动列表作为输入，我们将使用我们新的光栅化函数对其进行转换。然后，使用Chartist可视化转换后的数据。我们使用一个成员，chart，来存储创建后的Chartist实例。
- en: Using the `ViewChild` decorator, we're obtaining the DOM element from our component
    view, which will be used as a container to create our chart.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ViewChild`装饰器，我们从组件视图中获取DOM元素，该元素将用作创建图表的容器。
- en: 'Let''s continue by adding a method to transform the activity list into something
    Chartist can work with. Within the same component class file, append the following
    method:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续通过添加一个方法将活动列表转换为Chartist可以处理的内容。在同一个组件类文件中，追加以下方法：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Within the `createChartData` method, we are first creating a list of rasterization
    data objects from the list of activities that we provided from our component input.
    We can use the activity time as a timestamp, and all of our activities currently
    count the same, so we use a fixed weight of `1`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在`createChartData`方法中，我们首先从我们的组件输入提供的活动列表创建一个光栅化数据对象列表。我们可以使用活动时间作为时间戳，并且我们所有的活动目前计数相同，所以我们使用固定的权重`1`。
- en: Now, we would like to extract the count of activities for every hour within
    the last 24 hours. We can use our `rasterize` function, with the necessary parameters,
    to transform our activities into exactly that format. The `rasterize` function
    will always return a list of numbers representing the count of activities within
    the desired timeframes. Together with the rasterization data, we pass the number
    of milliseconds for one hour, a total of 24 frames, and the current time as the
    starting point in time.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们希望提取过去24小时内每小时的活动数量。我们可以使用我们的`rasterize`函数，并带上必要的参数，将我们的活动转换为正好是那种格式的。`rasterize`函数将始终返回一个数字列表，表示在所需时间段内的活动数量。与光栅化数据一起，我们传递一个小时的毫秒数，总共24帧，以及当前时间作为时间起点。
- en: Our method returns an object of the type `IChartistData`, which contains the
    data that we want to visualize with Chartist. The output of our `rasterize` function
    has exactly the right format for representing a data series in Chartist.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的方法返回一个`IChartistData`类型的对象，其中包含我们想要使用Chartist可视化的数据。我们的`rasterize`函数的输出正好是表示Chartist中数据系列的正确格式。
- en: 'Let''s add the remaining code to complete our component class. Code changes
    are highlighted in bold, while the ellipsis character indicates irrelevant, hidden
    code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加剩余的代码以完成我们的组件类。代码更改以粗体显示，而省略号字符表示无关的、隐藏的代码：
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Let's look into the code in more detail and walk through it step by step.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地查看代码，并逐步进行。
- en: The `createChart` method creates a new chart instance with the data that is
    passed to the method. In order to create a new bar chart, we can use the `Chartist.Bar`
    constructor. As a first parameter, we pass the DOM element of our container view
    child. Chartist will create our chart in this container element. The second argument
    is our data, which we get from our method parameter. In the chart options, we'll
    set everything to achieve a very plain-looking chart, without any detailed information.
    We disable the grids, hide the labels, and remove any padding.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`createChart`方法使用传递给方法的数据创建一个新的图表实例。为了创建一个新的条形图，我们可以使用`Chartist.Bar`构造函数。作为第一个参数，我们传递容器视图子元素的DOM元素。Chartist将在该容器元素中创建我们的图表。第二个参数是我们的数据，它来自我们的方法参数。在图表选项中，我们将设置一切以实现一个非常简单的图表外观，没有任何详细的信息。我们禁用网格，隐藏标签，并移除任何填充。'
- en: Additionally, we're using the Chartist draw event to control how zero value
    bars are drawn. By default, Chartist won't draw a bar when the value for the bar
    is exactly zero. We can control and change this behavior by implementing our own
    custom draw event logic.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们使用Chartist的绘制事件来控制零值条形的绘制方式。默认情况下，Chartist在条形的值为零时不会绘制条形。我们可以通过实现自己的自定义绘制事件逻辑来控制并更改此行为。
- en: The `createOrUpdateChart` method checks whether the chart was already created,
    and only needs to be updated if we really need to create a new chart instance.
    This simplifies our handling a lot. As we get called from both the `AfterViewInit`
    and `OnChanges` life cycle hooks, we need to make sure that both the `chartContainer`
    view child and the `activities` input are ready before we continue.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`createOrUpdateChart` 方法检查图表是否已经创建，并且只有在我们需要创建新的图表实例时才需要更新。这大大简化了我们的处理。由于我们从
    `AfterViewInit` 和 `OnChanges` 生命周期钩子中被调用，我们需要确保在继续之前 `chartContainer` 视图子组件和 `activities`
    输入都已就绪。'
- en: If the `chart` member is already set to a chart that was previously created,
    we can use the `update` function on the Chartist instance to update it with the
    new data. If there's no chart object, we need to create a new chart. We can simply
    call our `createChart` method for that.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `chart` 成员已经设置为之前创建的图表，我们可以使用 Chartist 实例上的 `update` 函数来使用新数据更新它。如果没有图表对象，我们需要创建一个新的图表。我们可以简单地调用我们的
    `createChart` 方法。
- en: 'This is great! We''ve created our first chart component using Chartist! Now,
    we can go back to our project summary component and integrate the activity chart
    there, to provide an activity overview. Open up the template of the project summary
    component, located in the file `src/app/projects-dashboard/project-summary/project-summary.component.html`,
    and apply the following changes:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这太棒了！我们已经使用 Chartist 创建了我们的第一个图表组件！现在，我们可以回到我们的项目摘要组件，并在其中集成活动图表，以提供活动概述。打开位于文件
    `src/app/projects-dashboard/project-summary/project-summary.component.html` 的项目摘要组件模板，并应用以下更改：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We added our activity chart component at the bottom of the already existing
    template. We also created the necessary binding to pass our activities, which
    we already had available on our project summary object, into the component.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在现有模板的底部添加了我们的活动图表组件。我们还创建了必要的绑定，将我们已经在项目摘要对象上可用的活动传递到组件中。
- en: Congratulations! You've successfully integrated the Chartist library into your
    project, and have used it to visualize project activity on our project summary
    components.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已成功将 Chartist 库集成到您的项目中，并使用它在我们项目摘要组件中可视化项目活动。
- en: In the next section, we'll dive a bit deeper into the charting capabilities
    of Chartist, and will also provide some interactivity using Angular.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将更深入地探讨 Chartist 的图表功能，并使用 Angular 提供一些交互性。
- en: Visualizing open tasks
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视化开放任务
- en: In this section, we will create a line chart component using Chartist, which
    will display the open task progress of projects over time. To do this, we'll use
    a line chart with a specific interpolation that provides quantized steps, rather
    than lines with directly connected points.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 Chartist 创建一个折线图组件，该组件将显示项目随时间推移的开放任务进度。为此，我们将使用具有特定插值的折线图，它提供量化步骤，而不是直接连接点的线条。
- en: We will also provide some interactivity, so that the user will be able to switch
    the displayed timeframe by using a toggle button. This will allow us to reuse
    the toggle UI component that we created in [Chapter 2](11f96942-6e99-46c5-b152-1af3b2579d44.xhtml),
    *Ready, Set, Go!*
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将提供一些交互性，使用户能够通过切换按钮来切换显示的时间范围。这将允许我们重用我们在[第 2 章](11f96942-6e99-46c5-b152-1af3b2579d44.xhtml)，“准备，设置，出发！”中创建的切换
    UI 组件。
- en: Preparing task data
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备任务数据
- en: First, let's look at the data that we have available in our system, when it
    comes to project tasks. The `created` attribute is set to the timestamp at the
    moment when the task was created. If a task is marked as done, however, we currently
    don't save the timestamp of that moment. In order to produce the chart that we're
    looking for, we will need to know when a task was completed.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看我们系统中关于项目任务可用的数据。`created` 属性设置为任务创建时的戳记。然而，如果一个任务被标记为已完成，我们目前并不保存那一刻的戳记。为了生成我们想要的图表，我们需要知道任务何时完成。
- en: 'Let''s introduce a new property on our task model for this purpose. Open up
    the `model` file, located in `src/app/model.ts`, and apply the following changes:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在任务模型上引入一个新的属性来达到这个目的。打开位于 `src/app/model.ts` 的 `model` 文件，并应用以下更改：
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now we need to make sure to set the `completed` property at the right moment,
    whenever a task is completed. Let''s open the class of our task component, located
    in `src/app/tasks/task/task.component.ts`, and apply the following changes. Only
    modify the part in your code that is highlighted in the following code excerpt:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要确保在任务完成时在正确的时间设置`completed`属性。让我们打开位于`src/app/tasks/task/task.component.ts`的任务组件类，并应用以下更改。只修改以下代码摘录中突出显示的部分：
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Alright; to complete this exercise, we also want to update our initial data
    within the in-memory database, to reflect a more accurate scenario. Open the file
    `src/app/database.ts`, and apply the following changes. Again, only change the
    parts that are highlighted:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 好的；为了完成这个练习，我们还想更新内存数据库中的初始数据，以反映一个更准确的场景。打开文件`src/app/database.ts`，并应用以下更改。同样，只更改突出显示的部分：
- en: '[PRE27]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Modeling the problem
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题建模
- en: 'First, let''s think about the problem of showing open task counts over time.
    As we''re only interested in the number of open tasks at any given time, we can
    use a model where we put all tasks onto a single timeline, and where we are only
    concerned with the events of tasks being created or completed. Let''s look at
    the following illustration to get a better understanding of the problem:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们思考一下如何显示随时间变化的打开任务数量的问题。因为我们只对任何给定时间的打开任务数量感兴趣，我们可以使用一个模型，其中我们将所有任务放在一个单独的时间线上，并且我们只关心任务创建或完成的事件。让我们通过以下插图来更好地理解这个问题：
- en: '![](img/897d7898-90ee-4582-bfa6-e217d7bb03db.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/897d7898-90ee-4582-bfa6-e217d7bb03db.png)'
- en: An illustration that shows how we can represent all task timelines on a single
    timeline, using the created and completed events. The created events count as
    +1, while the completed events count as -1
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一幅插图展示了我们如何使用创建和完成的事件来表示所有任务的时间线，其中创建的事件计为+1，而完成的事件计为-1。
- en: The lower arrow is a representation of all tasks of the created and completed
    events on a timeline. We can now use this information as input to our `rasterize`
    function, in order to get the data that we need for our chart. As the rasterization
    data objects that are used as input for the function also support a `weight` property,
    we can use this to represent the created (`+1`) or completed (`-1`) events.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的箭头表示时间线上创建和完成事件的全部任务。我们现在可以使用这些信息作为输入到我们的`rasterize`函数中，以获取我们图表所需的数据。因为用作函数输入的栅格化数据对象也支持`weight`属性，我们可以使用它来表示创建（`+1`）或完成（`-1`）的事件。
- en: We need to make a slight modification to our `rasterize` function. So far, the
    `rasterize` function only counts events together in frames. However, for the open
    task counts, we will look into an accumulation over time. If the task count changes,
    we need to keep the value until it changes again. In the transformation of activities
    in the previous section, we didn't use this same logic. There, we only counted
    events inside frames, but there was no accumulation.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对我们的`rasterize`函数进行一些小的修改。到目前为止，`rasterize`函数只在帧中一起计算事件。然而，对于打开任务计数，我们将查看随时间的累积。如果任务计数发生变化，我们需要保持该值，直到它再次变化。在上一个章节中活动的转换中，我们没有使用这种相同的逻辑。在那里，我们只计算帧内的事件，但没有累积。
- en: 'Let''s look at the following illustration to see the differences, as compared
    to the rasterization that we applied when processing activities:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下插图来查看与我们在处理活动时应用的栅格化之间的差异：
- en: '![](img/ce0fe326-e7da-4517-8a78-4272ddaeb8cb.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ce0fe326-e7da-4517-8a78-4272ddaeb8cb.png)'
- en: An illustration that shows how we can accumulate the open task count over time
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一幅插图展示了我们如何随着时间的推移累积打开任务的数量。
- en: We can count each `weight` property of the rasterization data objects (events)
    together over time. If there's a change in the accumulated value, we will write
    the current accumulated value into the rasterized output array.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以随着时间的推移一起计算栅格化数据对象（事件）的每个`weight`属性。如果累积值发生变化，我们将当前累积值写入栅格化输出数组。
- en: 'Let''s implement this accumulation feature into our `rasterize` function. Open
    up the time utility module, on the path `src/app/utilities/time-utilities.ts`,
    and apply the following changes:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个累积功能实现到我们的`rasterize`函数中。打开时间实用模块，路径为`src/app/utilities/time-utilities.ts`，并应用以下更改：
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Let's walk through the changes that we applied to the `rasterize` function.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们对`rasterize`函数所做的更改。
- en: First of all, we add a new parameter to our function, with the name `accumulate`.
    We use ES6 default parameters to set the parameter to `false`, if no value was
    passed into the function when called.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们向我们的函数中添加一个新的参数，命名为 `accumulate`。我们使用 ES6 默认参数来设置参数为 `false`，如果函数被调用时没有传入任何值。
- en: We define a new `accumulatedValue` variable, which we initialize with zero.
    This variable is used to keep track of the sum of all `weight` values over time.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义一个新的 `accumulatedValue` 变量，并将其初始化为零。这个变量用于跟踪随时间累积的所有 `weight` 值的总和。
- en: The next bit of code is very important. If we want to accumulate the sum of
    all `weight` values over time, we need to make sure that these values come in
    sequence. In order to ensure this, we sort the `timeData` list by its items `time`
    attribute.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段非常重要。如果我们想要随时间累积所有 `weight` 值的总和，我们需要确保这些值按顺序到来。为了确保这一点，我们按 `timeData`
    列表的 `time` 属性对它进行排序。
- en: In the reduce callback, we increase the `accumulatedValue` variable by the `weight`
    value of the current `timeData` object.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `reduce` 回调中，我们将 `accumulatedValue` 变量增加当前 `timeData` 对象的 `weight` 值。
- en: If the `timeData` object falls into a rasterized frame, we do not increase this
    frame's count like we did before. In accumulation mode, we set the frames count
    to the current value in `accumulatedValue`. This will result in all changed accumulated
    values being reflected in the rasterized output array.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `timeData` 对象落入栅格化框架中，我们不会像之前那样增加这个框架的计数。在累积模式下，我们将框架计数设置为 `accumulatedValue`
    中的当前值。这将导致所有更改的累积值都反映在栅格化输出数组中。
- en: That's all the preparation we need to create our open tasks chart. We were able
    to refactor our `rasterize` function, which is now able to process time data and
    produce rasterized data series for various applications. With the use of a negative
    `weight` property, we can now create data series that increase and decrease, based
    on open tasks within a project.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们创建开放任务图表所需的所有准备工作。我们能够重构我们的 `rasterize` 函数，现在它能够处理时间数据并生成适用于各种应用的栅格化数据系列。通过使用负
    `weight` 属性，我们现在可以创建基于项目内开放任务的增加和减少的数据系列。
- en: Creating an open tasks chart
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建开放任务图表
- en: 'Let''s take a look at the line chart that we''re going to create:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们要创建的折线图：
- en: '![](img/4c89891c-8f39-4861-9e9b-8f49f03ff7e7.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4c89891c-8f39-4861-9e9b-8f49f03ff7e7.png)'
- en: Open tasks visualized with our tasks chart component, using Chartist's step
    interpolation
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的任务图表组件和 Chartist 的步进插值可视化开放任务
- en: We will utilize the refactored `rasterize` function of the previous topic, and
    will use the new accumulate mode to track open task counts over time.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用前一个主题中重构的 `rasterize` 函数，并使用新的累积模式来跟踪随时间变化的开放任务数量。
- en: 'Let''s use the Angular CLI tool to create our new tasks chart component:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Angular CLI 工具创建我们的新任务图表组件：
- en: '[PRE29]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s edit the component class, on the path `src/app/projects-dashboard/tasks-chart/tasks-chart.component.ts`,
    and change its content to the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编辑组件类，在路径 `src/app/projects-dashboard/tasks-chart/tasks-chart.component.ts`
    上，并将其内容更改为以下内容：
- en: '[PRE30]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The basic structure of the preceding code should already look familiar to you.
    We're using the same structure as in our previous chart. However, the line chart
    that we are going to create now contains much more detailed information. We will
    render both axis labels and some scales. The *x*-axis of our chart will be a timeline,
    and we will use the Moment.js library to format the timestamps to a human-readable
    format.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的基本结构应该已经让你很熟悉了。我们使用与之前图表相同的结构。然而，我们现在要创建的折线图包含更多详细的信息。我们将渲染轴标签和一些刻度。我们图表的
    *x* 轴将是一个时间线，我们将使用 Moment.js 库将时间戳格式化为可读格式。
- en: Let's take a closer look at the `createChartData` and `createChart` methods.
    There's quite a bit of code here! Let's walk through it, step by step, to gain
    a better understanding of what's going on.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看 `createChartData` 和 `createChart` 方法。这里有很多代码！让我们一步一步地走一遍，以便更好地理解正在发生的事情。
- en: We use the `projectSummaries` input as a base for our data visualization. We
    transform the tasks data using our updated `rasterize` function, in order to prepare
    the data for our line chart.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `projectSummaries` 输入作为数据可视化的基础。我们使用更新的 `rasterize` 函数转换任务数据，以便为我们的折线图准备数据。
- en: First, we need to create our transformed series data by mapping the project
    summary list. The series array should include one data array for each project.
    Each data array will contain the open project tasks over time.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要通过映射项目摘要列表来创建我们的转换后的系列数据。系列数组应该包括每个项目的数据数组。每个数据数组将包含随时间变化的开放项目任务。
- en: As the `rasterize` function expects a list of rasterization data objects, we
    need to first transform the projects task list into this format. We will make
    use of the weight feature of our `rasterize` function. We can simply create a
    rasterization data object with a weight of `1` for every event of a created task.
    For completed tasks, we create a rasterization data object with a weight of `-1`.
    This results in the desired input data for our `rasterize` function.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`rasterize`函数期望一个光栅化数据对象的列表，我们首先需要将项目任务列表转换成这种格式。我们将利用`rasterize`函数的权重功能。我们可以简单地为每个创建的任务创建一个权重为`1`的光栅化数据对象。对于完成的任务，我们创建一个权重为`-1`的光栅化数据对象。这为我们`rasterize`函数提供了所需输入数据。
- en: After preparing the data, we can call the `rasterize` function, in order to
    create a list of open tasks over a certain amount of rasterization frames. We
    use ten minute timeframes (600,000 ms) and rasterize with 144 frames. This makes
    a total of 24 hours. So, that's where those two magic numbers come from! However,
    this code will change a bit when we introduce the interactivity to our chart.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好数据后，我们可以调用`rasterize`函数，以创建一定数量的光栅化帧的开放任务列表。我们使用十分钟的时间框架（600,000毫秒）和144帧进行光栅化。这总共是24小时。所以，这就是那些两个神奇数字的来源！然而，当我们引入图表的交互性时，此代码将略有变化。
- en: Besides the series data, we also need labels for our chart. We create a new
    array and initialize this with 144 timestamps, all of which are set to the start
    of the 144 rasterized frames that we display on the chart.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 除了系列数据外，我们还需要为我们的图表添加标签。我们创建一个新的数组，并使用144个时间戳初始化它，所有这些时间戳都设置为我们在图表上显示的144个光栅化帧的开始。
- en: We now have the series data and the labels ready, and all that's left to do
    is render our chart. Within the `createChart` method, we're creating our line
    chart instance using the `Chartist.Line` constructor.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了系列数据和标签，接下来要做的就是渲染我们的图表。在`createChart`方法中，我们使用`Chartist.Line`构造函数创建我们的折线图实例。
- en: Using the `lineSmooth` configuration, we can specify a special kind of interpolation
    for our line chart. The step interpolation will not connect each point in our
    line chart directly, but will rather plot our data in discrete steps, to move
    from point to point. This is exactly what we're looking for to render the open
    task counts over time.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`lineSmooth`配置，我们可以为我们的折线图指定一种特殊的插值。步进插值不会直接连接我们折线图中的每个点，而是将我们的数据以离散的步骤绘制出来，从一个点到另一个点。这正是我们渲染随时间变化的开放任务计数所需要的效果。
- en: Setting the `fillHoles` option to `true` in the step interpolation is very important.
    Using this setting, we can actually tell Chartist that it should close any gaps
    in the data (actually null values) and connect the line to the next valid value.
    Without this setting, we'd see gaps on the chart between the task count changes
    in our data arrays.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤插值中设置`fillHoles`选项为`true`非常重要。使用此设置，我们实际上可以告诉Chartist它应该关闭数据中的任何间隙（实际上是空值）并将线连接到下一个有效值。如果没有此设置，我们会在图表中看到数据数组中任务计数变化之间的间隙。
- en: 'Okay; that''s all we need in our component class, for the moment. Let''s move
    on to the rather simple template for our tasks chart component. Open the file,
    located on the path `src/app/projects-dashboard/tasks-chart/tasks-chart.component.html`,
    and change its content to the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 好的；目前我们组件类中需要的就是这些。让我们继续到任务图表组件相对简单的模板。打开位于路径`src/app/projects-dashboard/tasks-chart/tasks-chart.component.html`的文件，并更改其内容如下：
- en: '[PRE31]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Similar to the activity chart component, we only create a simple chart container
    element, which we already reference in our component class using the view child
    decorator.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 与活动图表组件类似，我们只创建一个简单的图表容器元素，我们已经在组件类中使用视图子装饰器引用了它。
- en: 'Our tasks chart component is now ready to be integrated into our dashboard.
    We can achieve this with some small changes to the template of our projects dashboard
    component. Let''s open the file `src/app/projects-dashboard/projects-dashboard/projects-dashboard.component.html`,
    and apply the following changes:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务图表组件现在已准备好集成到我们的仪表板中。我们可以通过修改项目仪表板组件的模板来实现这一点。让我们打开位于路径`src/app/projects-dashboard/projects-dashboard/projects-dashboard.component.html`的文件，并应用以下更改：
- en: '[PRE32]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Good stuff! This is basically all that we need to make our newly created tasks
    chart appear on our dashboard. You've created a simple line chart to visualize
    open tasks over time.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 很好！这基本上就是我们需要的，让我们的新创建的任务图表出现在我们的仪表板上。你已经创建了一个简单的折线图来可视化随时间推移的开放任务。
- en: Let's further enhance our chart by rendering a chart legend and making the chart
    interactive for our users.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步增强我们的图表，通过渲染图例并使图表对用户交互化。
- en: Creating a chart legend
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建图表图例
- en: Currently, there's no way to tell exactly what line on our chart represents
    what project. We can see one colored line for each project, but we can't associate
    these colors. What we need is a simple legend that helps our users to associate
    line chart colors to projects.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们无法确切知道图表上的哪一行代表哪个项目。我们可以看到每个项目有一条彩色线，但我们无法将这些颜色关联起来。我们需要的是一个简单的图例，帮助我们的用户将折线图的颜色与项目关联起来。
- en: 'Let''s look at the required code changes to implement legends on our chart.
    Open our tasks chart component class, located on the path `src/app/projects-dashboard/tasks-chart/tasks-chart.component.ts`,
    and apply the following changes. Irrelevant parts of this change are hidden using
    the ellipsis character, while effective changes are marked in bold:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实现图表图例所需的代码更改。打开位于路径 `src/app/projects-dashboard/tasks-chart/tasks-chart.component.ts`
    的任务图表组件类，并应用以下更改。不相关的更改部分使用省略号字符隐藏，而有效的更改部分用粗体标出：
- en: '[PRE33]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We've added a local interface in our component module to represent individual
    legend items. The `title` property is going to be displayed for each item within
    our legend. The `class` property is used to set an appropriate CSS class, in order
    to render every legend item with the correct color, to match the colors of lines
    within our chart.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的组件模块中添加了一个本地接口来表示单个图例项。`title` 属性将在图例中的每个项中显示。`class` 属性用于设置适当的CSS类，以便以正确的颜色渲染每个图例项，以匹配图表中线条的颜色。
- en: In the `OnChanges` life cycle hook, we simply map the project summary objects
    to a list of legend objects. The template string `` `series-${index + 1}` `` will
    generate the necessary class names to render the right color into our legend.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `OnChanges` 生命周期钩子中，我们简单地将项目摘要对象映射到一个图例对象列表。模板字符串 `` `series-${index + 1}`
    `` 将生成必要的类名，以便在我们的图例中渲染正确的颜色。
- en: 'Using this legend information, we can now go ahead and implement the necessary
    template changes to render the legend in our tasks chart component. Open the template,
    located on the path `src/app/projects-dashboard/tasks-chart/tasks-chart.component.html`,
    and apply the following changes:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个图例信息，我们现在可以继续实施必要的模板更改，以在我们的任务图表组件中渲染图例。打开位于路径 `src/app/projects-dashboard/tasks-chart/tasks-chart.component.html`
    的模板，并应用以下更改：
- en: '[PRE34]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Well, that was a piece of cake, right? However, the result speaks for itself.
    We created a nice legend for the chart in just a couple of minutes:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这很简单，对吧？然而，结果证明了一切。我们仅用几分钟就为图表创建了一个漂亮的图例：
- en: '![](img/064e3c96-1945-4627-8eac-de28c663a376.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/064e3c96-1945-4627-8eac-de28c663a376.png)'
- en: Open tasks chart with our added legend
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 带有我们添加的图例的开放任务图表
- en: In the next topic, we're going to add some user interaction to our chart and
    let our users control the timeframe that we're using to render our data.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个主题中，我们将向我们的图表添加一些用户交互功能，并让我们的用户控制我们用来渲染数据的时段。
- en: Making the tasks chart interactive
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使任务图表交互化
- en: Currently, we hardcoded the timeframe of our open task chart to be 144 frames,
    each 10 minutes long, making a total of 24 hours displayed to the user. However,
    maybe our users will want to change this view.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们硬编码了开放任务图表的时段为144帧，每帧10分钟，总共显示给用户24小时。然而，也许我们的用户想要更改这个视图。
- en: In this topic, we will create a simple input control using our toggle component,
    which will allow our users to change the timeframe settings of the chart.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个主题中，我们将使用我们的切换组件创建一个简单的输入控制，这将允许我们的用户更改图表的时间段设置。
- en: 'We will provide the following views as options to choose from:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将提供以下视图作为选择选项：
- en: '**Day**: This view will rasterize into 144 frames, each consisting of 10 minutes,
    which makes a total of 24 hours'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日**：此视图将转换为144帧，每帧10分钟，总共24小时'
- en: '**Week**: This view will rasterize into 168 frames, each consisting of one
    hour, which makes a total of seven days'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**周**：此视图将转换为168帧，每帧一小时，总共七天'
- en: '**Year**: This view will rasterize into 360 frames, each representing a full
    day'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**年**：此视图将转换为360帧，每帧代表一天'
- en: 'Let''s start the implementation by modifying the tasks chart component `TypeScript`
    file, located on the path `src/app/projects-dashboard/tasks-chart/tasks-chart.component.ts`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从修改位于路径`src/app/projects-dashboard/tasks-chart/tasks-chart.component.ts`的任务图表组件的`TypeScript`文件开始实施：
- en: '[PRE35]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Let's briefly go over these changes. First, we added another local interface
    to represent the `timeframe` choices presented to the user. The `ChartTimeFrame`
    interface consists of a name property, which we'll use to present to the user.
    We also stored the `timeFrame` and `amount` properties for each chart `timeframe`
    object. These two properties represent the number of milliseconds for each frame
    and the frame count, respectively.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要回顾这些更改。首先，我们添加了另一个本地接口来表示用户所看到的`timeframe`选择。`ChartTimeFrame`接口包含一个名称属性，我们将使用它来向用户展示。我们还为每个图表`timeframe`对象存储了`timeFrame`和`amount`属性。这两个属性分别代表每个帧的毫秒数和帧计数。
- en: The new `timeFrames` member is set to an array of `timeframe` objects. These
    are the choices we'll present to the user, and they reflect the settings we discussed
    at the beginning of this section. The `timeFrameNames` member contains a list
    of timeframe names, which is directly derived from the `timeFrames` list. Finally,
    we have a `selectedTimeFrame` member, which simply points to the first available
    timeframe object to start with.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`timeFrames`成员被设置为`timeframe`对象数组。这些是我们将向用户展示的选择，它们反映了本节开头讨论的设置。`timeFrameNames`成员包含时间范围名称列表，这是直接从`timeFrames`列表派生出来的。最后，我们有一个`selectedTimeFrame`成员，它简单地指向第一个可用的时间范围对象以开始。
- en: In the `createOrUpdateChart` function, we no longer rely on hardcoded values
    for the task count rasterization, but we refer to the data in the `selectedTimeFrame`
    object. By changing this object reference and calling the `createOrUpdateChart`
    function again, we can now switch the view on the underlying data dynamically.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在`createOrUpdateChart`函数中，我们不再依赖于硬编码的值来进行任务栅格化，而是参考`selectedTimeFrame`对象中的数据。通过更改此对象引用并再次调用`createOrUpdateChart`函数，我们现在可以动态地切换底层数据的视图。
- en: Finally, we added a new `selectTimeFrame` method, which we will call from our
    component view to switch to a different timeframe.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加了一个新的`selectTimeFrame`方法，我们将从组件视图中调用它以切换到不同的时间范围。
- en: 'Let''s look at the necessary template changes to enable the switching of timeframes.
    We''re using our `toggle` UI component that we created at the very beginning of
    this book:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看启用时间范围切换所需的模板更改。我们使用我们在本书开头创建的`toggle` UI组件：
- en: '[PRE36]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: From the bindings to the `toggle` component, you can already tell that we rely
    on the `timeFrameNames` member of our component to represent all selectable timeframes.
    We also bind to the `activeButton` input property of the `toggle` component using
    the `selectedTimeFrame` property of our tasks chart component. When the user activates
    a toggle button, we call the `selectTimeFrame` function, where the timeframe is
    switched and the chart is updated.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 从对`toggle`组件的绑定中，你可以看出我们依赖于组件的`timeFrameNames`成员来表示所有可选择的时帧。我们还使用任务图表组件的`selectedTimeFrame`属性绑定到`toggle`组件的`activeButton`输入属性。当用户激活一个切换按钮时，我们调用`selectTimeFrame`函数，在那里时帧被切换，图表被更新。
- en: This is all that we need to enable switching the timeframe on our chart. The
    user can now choose between the year, week, and day views.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要的所有内容，以启用在图表上切换时间范围。现在，用户可以在年、周和日视图之间进行选择。
- en: 'Excellent work! You''ve added interactivity to the tasks chart by reusing the
    `toggle` UI component. Let''s take a look at the final result of our work:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 优秀的成果！你通过重用`toggle` UI组件为任务图表添加了交互性。让我们看看我们工作的最终结果：
- en: '![](img/32180d58-7013-4408-8ca4-a155f19fc90b.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/32180d58-7013-4408-8ca4-a155f19fc90b.png)'
- en: Final tasks chart, which is now rendered within our application dashboard
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的任务图表，现在在应用程序仪表板中渲染
- en: Summary
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about Chartist and how to use it in conjunction
    with Angular to create good looking and functional charts. We can leverage the
    power of both worlds to create reusable chart components that are nicely encapsulated.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了Chartist及其如何与Angular结合使用来创建外观美观且功能齐全的图表。我们可以利用这两个世界的力量来创建可重用的图表组件，这些组件封装得很好。
- en: Just like in most real cases, we always have a lot of data available. However,
    bringing that data into the right shape is sometimes tricky. In this chapter,
    we learned how we can transform existing data into a form that is optimized for
    visual representation.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在大多数实际案例中一样，我们总是有大量的数据可用。然而，将那些数据转换成正确的形状有时是有些棘手的。在这一章中，我们学习了如何将现有数据转换成适合视觉表示的优化形式。
- en: In the next chapter, we will look at building a plugin system in our application.
    This will allow us to develop portable functionality that is packaged into plugins.
    Our plugin system will render new plugins dynamically, and we will use it to develop
    a simple agile estimation plugin.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何在我们的应用程序中构建一个插件系统。这将使我们能够开发可移植的功能，并将其打包成插件。我们的插件系统将动态渲染新插件，我们将用它来开发一个简单的敏捷估算插件。
