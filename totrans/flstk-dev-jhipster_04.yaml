- en: Entity Modeling with JHipster Domain Language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we saw how we can use JHipster to generate a production-grade
    web application with a lot of awesome features, such as i18n, administration modules,
    account management, and so on. In this chapter, we will see how we can enrich
    that application with business entities and a model.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will learn about the following in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JHipster Domain Language **(**JDL**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JDL studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Entity and relationship modeling with JDL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Entity generation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to JDL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JDL ([http://www.jhipster.tech/jdl/](http://www.jhipster.tech/jdl/)) is used
    to create the domain model for a JHipster application. It provides a simple and
    user-friendly DSL to describe the entities and their relationships (for SQL databases
    only).
  prefs: []
  type: TYPE_NORMAL
- en: JDL is the recommended way to create entities for an application and can replace
    the entity generator provided by JHipster, which can be difficult to use when
    creating a lot of entities. The JDL is normally written in one or more files with
    a `.jh` extension.
  prefs: []
  type: TYPE_NORMAL
- en: Visit [http://www.jhipster.tech/jdl/](http://www.jhipster.tech/jdl/) for complete
    documentation on JDL.
  prefs: []
  type: TYPE_NORMAL
- en: If you prefer to work with UML and UML modeling tools, then check out JHipster-UML
    ([http://www.jhipster.tech/jhipster-uml/](http://www.jhipster.tech/jhipster-uml/)),
    a tool that can create entities from popular UML tools.
  prefs: []
  type: TYPE_NORMAL
- en: DSL grammar for JDL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s see the JDL grammar. At the time of writing, JDL supports generating
    complete entity models with relationships and options such as DTO, service layer,
    and so on. The grammar can be broken down into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Entity declaration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relationship declaration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Options declaration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following syntax, `[]` denotes optional and `*` denotes more than one
    can be specified.
  prefs: []
  type: TYPE_NORMAL
- en: Javadocs can be added to entity declarations and `/** */` Java comments can
    be added to fields and relationship declarations. JDL only comments can be added
    using `//` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to define numerical constants in JDL, for example, `DEFAULT_MIN_LENGTH
    = 1`.
  prefs: []
  type: TYPE_NORMAL
- en: Entity modeling with JDL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The entity declaration is done using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`<entity name>` is the name of the entity and will be used for class names
    and table names. Table names can be overridden using the optional `<table name>`
    parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: '`<field name>` is the name of the fields (attributes) you want for the entity
    and `<type>` is the field type, as in String, Integer, and so on. Refer to [http://www.jhipster.tech/jdl/#available-types-and-constraints](http://www.jhipster.tech/jdl/#available-types-and-constraints)
    for all supported field types. The ID field will be automatically created and
    hence need not be specified in JDL.'
  prefs: []
  type: TYPE_NORMAL
- en: '`<validation>` is optional and one or more `<validation>` for the fields can
    be specified depending on the validation supported by the field type. For validations
    such as max length and pattern, values can be specified in braces.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An example entity declaration would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Enumerations can also be declared using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Relationship management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The relationship between entities can be declared using this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `<type>` is one from `OneToMany`, `ManyToOne`, `OneToOne`, or `ManyToMany`
    and as the name suggests, declares the relationship type between `<from entity>`
    and `<to entity>`.
  prefs: []
  type: TYPE_NORMAL
- en: '`<from entity>` is the name of the owner entity of the relationship or the
    source. `<to entity>` is the destination of the relationship.'
  prefs: []
  type: TYPE_NORMAL
- en: '`<relationship name>` is optional and can be used to specify the field names
    to create for the relationship in the domain object. `<display field>` can be
    specified in braces to control the field of the entity to be shown in the drop-down
    menu on the generated web page, by default the ID field will be used. `<validation>`
    can be specified on the `<from entity>` or `<to entity>` and is optional. Currently,
    only required is supported.'
  prefs: []
  type: TYPE_NORMAL
- en: '`OneToMany` and `ManyToMany` relationships are always bidirectional in JHipster.
    In case of `ManyToOne` and `OneToOne` relationships, it is possible to create
    both bidirectional and unidirectional relationships. For unidirectional relationships,
    just skip the `<relationship name>` on the destination/to entity.'
  prefs: []
  type: TYPE_NORMAL
- en: Multiple relationships of the same type can be declared within the same block,
    separated by a comma.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example relationship declaration would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The user is an existing entity in JHipster and it is possible to have certain
    relationships with the user. Many-to-many and one-to-one relations can be declared,
    but the other entity must be the source or owner. Many-to-one relations are also
    possible with a user entity.
  prefs: []
  type: TYPE_NORMAL
- en: DTO, service, and pagination options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JDL also allows us to declare entity related options easily. Options currently
    supported are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`service`: By default, JHipster generates REST Resource classes that call the
    entity repositories directly. This is the simplest option, but in real-world scenarios,
    we might need a service layer to handle business logic. This option lets us create
    a service layer with a simple Spring service bean class or with a traditional
    interface and implementation for the service bean. Possible values are `serviceClass`
    and`serviceImpl`. Choosing the latter will create an interface and implementation,
    which is preferred by some people.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dto`:  By default, domain objects are directly used in the REST endpoints
    created, which may not be desirable in some situations and you might want to use
    an intermediatory **Data Transfer Object** (**DTO**) to have more control. JHipster
    lets us generate the DTO layer using Mapstruct ([http://mapstruct.org/](http://mapstruct.org/)),
    an annotation preprocessor library that automatically generates the DTO classes.
    It is advisable to use a service layer when using DTO. A possible value is `mapstruct`.
    For more info visit: [http://www.jhipster.tech/using-dtos/](http://www.jhipster.tech/using-dtos/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter`: This option lets us enable JPA based filtering capabilities for the
    entity. This works only when a service layer is used. For more details, visit: [http://www.jhipster.tech/entities-filtering/](http://www.jhipster.tech/entities-filtering/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`paginate`: This option lets us enable pagination for an entity. This enables
    pagination on the Resource layer and also implements a paging option on the client
    side. Possible values are pager, pagination, and infinite-scroll.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`noFluentMethod`: This lets us disable Fluent API style setters for the generated
    entity domain objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`skipClient`/`skipServer`: These options let us either skip the client-side
    code or server-side code during generation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`angularSuffix`: This option lets us specify a suffix for the folder and class
    names in the frontend code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The general syntax for option declaration is `<OPTION> <ENTITIES | * | all> [with
    <VALUE>] [except <ENTITIES>]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some possible options and different syntax in which they
    can be declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: JDL Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will be using JDL Studio ([https://start.jhipster.tech/jdl-studio/](https://start.jhipster.tech/jdl-studio/)) to
    create our JDL file. It is an online web application built by the JHipster team
    for creating JDL files in a visual editor. The tool shows a visual representation
    of the created entity model and also lets you import/export JDL and capture image
    snapshots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2759a4bc-38aa-48fc-a2ac-043b42be3fe1.png)'
  prefs: []
  type: TYPE_IMG
- en: The tool also provides features such as syntax highlighting, auto-completion,
    error reporting, and Sublime Text-style keyboard shortcuts.
  prefs: []
  type: TYPE_NORMAL
- en: Navigate your favorite browser to [https://start.jhipster.tech/jdl-studio/](https://start.jhipster.tech/jdl-studio/)
    to open the application.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that by default this application stores the JDL in your browser's
    local storage. You can create an account with JHipster online if you want to save
    your JDL files to the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Use case entity model with explanation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's look at our use case and the entity model. Before that, clear the
    default JDL in the JDL Studio editor.
  prefs: []
  type: TYPE_NORMAL
- en: Entities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by defining our entities:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the following snippet for `Product` and `ProductCategory` into the JDL
    Studio editor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `Product` entity is the core of the domain model; it holds product information
    such as `name`, `description`, `price`, `size`, and `image` which is a Blob. `name`,
    `price`, and `size` are required fields. `price` also has a min value validation.
    The `size` field is an enum with defined values.
  prefs: []
  type: TYPE_NORMAL
- en: The `ProductCategory` entity is used to group products together. It has `name`
    and `description` where `name` is a required field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following snippet for `Customer` into the JDL Studio editor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `Customer` entity holds details of the customers using the online shopping
    portal. Most of the fields are marked as required, the `email` field has regex
    pattern validation. The `gender` field is an `enum`. This entity is related to
    the system user which we will see in detail soon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following snippet for `ProductOrder` and `OrderItem` into the JDL Studio
    editor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `ProductOrder` and `OrderItem` entities are used to track product orders
    made by customers. `ProductOrder` holds the `placedDate` and `status`, and `code`
    of the order, which are all required fields, while `OrderItem` holds information
    about the `quantity`, `totalPrice`, and `status` of individual items. All fields
    are required and the `quantity` and `totalPrice` fields have min value validation.
    `OrderStatus` and `OrderItemStatus` are `enum` fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following snippet for `Invoice` and `Shipment` into the JDL Studio
    editor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `Invoice` and `Shipment` entities are used to track the invoice and shipping
    for the product orders, respectively. Most of the fields in `Invoice` are required
    and the `status` and `paymentMethod` fields are enums.
  prefs: []
  type: TYPE_NORMAL
- en: The enumerations are being used to contain the scope of certain fields, which
    gives more granular control over those fields.
  prefs: []
  type: TYPE_NORMAL
- en: Relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have defined our entities, let''s add relationships between them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following snippet for relationships into the JDL Studio editor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The first relationship declared is a unidirectional `OneToOne` between a `Customer`
    entity and the inbuilt `User` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: It means the `Customer` entity knows about the `User` and is the owner of the
    relationship but the `User` doesn't know about the `Customer` and hence we will
    not be able to obtain customers from a `User`. This lets us map customers to the
    `User` entity and use that for authorization purposes later ensuring one customer
    can be mapped only to one system user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this snippet for relationships into the JDL Studio editor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This one declares a unidirectional `ManyToOne` relationship from `OrderItem`
    to `Product`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It means the `OrderItem` knows their `Product` but `Product` does not know about
    `OrderItem`. This keeps the design clean as we don't want to know about orders
    from products for this use case. In the future, if we want to know the orders
    made for a product we could make this bi-directional.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following snippet for relationship into the JDL Studio editor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This declaration is interesting, as we have multiple `OneToMany` declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: They are all bidirectional, meaning both the source entity and destination entity
    know about each other.
  prefs: []
  type: TYPE_NORMAL
- en: We declare that a `Customer` can have multiple ProductOrders, `ProductOrder` can
    have multiple OrderItems and Invoices, `Invoice` can have many `Shipment`, and
    `ProductCategory` can have many Products. From the destination entity, the source
    entities are mapped as `ManyToOne`.
  prefs: []
  type: TYPE_NORMAL
- en: Options for entities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add the following snippet for options into the JDL Studio editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the options, we keep it simple and declare that we want a service class for
    all entities. We also enabled pagination for some of the entities that may get
    a lot of entries over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The diagram shows the complete model, with all the entities and their relationships
    as shown in JDL Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/383158ed-4758-42c6-8d8c-142ef607bdc3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s download this JDL file to our file system:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the download button in the upper-right-hand corner of the JDL Studio
    application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the file with the name `online-store.jh` inside the `online-store` directory
    where we created our application in the previous chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Entity generation with JHipster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, it's time to generate the domain model with our JDL. We will use the `import-jdl`
    command from JHipster for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your favorite Terminal application and navigate to the `online-store`
    folder where we created the application earlier. Then, execute the `import-jdl`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This will trigger the entity creation process and you will be asked to confirm
    the overwriting of existing files with changes. Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/73967f25-9074-43e2-9b36-4b9423d5728b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Enter *a* to confirm the overwrite of all files with changes. Once the files
    are generated, JHipster will trigger a `yarn webpack:build` step to rebuild the
    client side code. Once done you will see a success message like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4aafe021-078c-491f-b99b-7957d9e4a44a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Running `git status` on the Terminal shows us that five files were modified
    and a lot of new files added. Let''s commit the changes to Git. Execute the commands
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Generated code walkthrough
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's take a look at what has been generated. Let's open the application
    code in our favorite IDE/editor. Let's take a look at what has been generated
    for the `Product` entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that there is a `.jhipster` folder at the root of the
    project and if you look into it you will see a bunch of JSON files. Let''s look
    at `Product.json`. It holds metadata about the generated entity and is used by
    JHipster to regenerate and edit an entity when needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Server-side source code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's look at the server-side code generated.
  prefs: []
  type: TYPE_NORMAL
- en: Domain class for the entity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `src/main/java/com/mycompany/store/domain` folder, you will find the
    entity domain object. Open `Product.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The entity class defines the fields and relationships.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This annotation is used by Swagger to show useful documentation when the entity
    is used in an endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'These are JPA annotations declaring the POJO as an entity and mapping it to
    an SQL table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a Hibernate annotation, which lets us enable level 2 cache for this
    entity. In our case using Hazelcast:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `id` field is special and is mapped as a generated value field. Depending
    on the DB, this field will use a native generation technique or a sequence provided
    by Hibernate. Since we are using MySQL, it will use the native DB primary key
    generation technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This JPA annotation is used to map columns to fields and it can also be used
    to declare properties such as nullable, precision, scale, unique, and so on for
    the field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'These are Bean validation annotations enabling validation for the fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The image field is a Blob and it is marked by the Lob type since we are using
    MySQL. It also has an additional field to hold the content type information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The Enumerated annotation is used to map Enum fields. These are stored as simple varchar
    fields in the DB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The relationships are mapped using annotations such as `@ManyToOne`, `@OneToMany`,
    `@OneToOne`, and `@ManyToMany`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, `ProductCategory` is mapped as `ManyToOne`; on the other side of the
    relationship Product is mapped as `OneToMany` as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the relationship also specifies a cache for it. It tells Jackson
    to ignore the field while converting to JSON to avoid a circular reference since `ProductCategory`
    is already mapped in `Product` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a fluent setter generated by default along with the standard setter.
    This can be turned off by specifying the `noFluentMethod` for the entity in JDL.
    Fluent methods are handy as they let us chain setters as follows for more concise
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The corresponding table definitions and constraints are created using Liquibase
    and can be found in `src/main/resources/config/liquibase/changelog` with the file
    names `<timestamp>_added_entity_Product` and `<timestamp>_added_entity_constraints_Product.xml`,
    which automatically get applied to the database when we reload or start the application
    again.
  prefs: []
  type: TYPE_NORMAL
- en: Repository interface for the entity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `src/main/java/com/mycompany/store/repository` folder, you will find
    the entity repository service. Open `ProductRepository.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The repository service is just an empty interface that extends the `JpaRepository`
    class. Since it is a Spring Data repository, the implementation is automatically
    created, allowing us to do all CRUD actions using this simple interface declaration.
    Additional repository methods can be added here easily. We will see about that
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Service class for the entity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we opted to generate service classes for our entities, let''s look at
    one. In the `src/main/java/com/mycompany/store/service` folder, you will find
    the entity repository service. Open `ProductService.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The service uses constructor injection to get its dependencies, which are automatically
    injected by Spring during bean instantiation. The service is also marked as `@Transactional`
    to enable transaction management for data access. The service defines CRUD action
    methods. For example, the `findAll` method calls the equivalent repository method
    while adding a read-only transaction rule to it. You can see that the method already
    supports pagination and returns the results as `Page`. The `Page` and `Pageable`
    objects are provided by Spring and let us easily control pagination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Resource class for the entity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `src/main/java/com/mycompany/store/web/rest` folder you will find the
    entity resource service. Open `ProductResource.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The resource acts as the controller layer and in our case, it serves the REST
    endpoints to be used by our client-side code. The endpoint has a base mapping
    to `"/api"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: All the CRUD actions have equivalent mapping methods here, for example, the
    `getAllProducts` maps to the `findAll` from our service. The resource also handles
    pagination by adding appropriate headers for pagination.
  prefs: []
  type: TYPE_NORMAL
- en: Client side
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The client-side resources for the entity are created in the `src/main/webapp/app/entities`
    folder. Let's take a look at the code created for the `Product` entity in the
    `product` folder.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript model class for the entity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at the TypeScript model generated in `product.model.ts`. This maps
    directly to the domain object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The fields are all optional making it possible to create an object instance
    without any values. You will also see that the enums are also generated alongside
    the model in the file.
  prefs: []
  type: TYPE_NORMAL
- en: Angular services for the entity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ProductService` is an Angular service that interacts with our REST endpoints
    and created in `product.service.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the service has a constructor with dependencies injected following
    a similar pattern as our server-side code. There are methods mapping all the CRUD
    actions to the backend REST Resource. The HTTP calls make use of RxJS Observables
    to provide an asynchronous streaming API, which is much better than a Promise
    based API.
  prefs: []
  type: TYPE_NORMAL
- en: There is also `ProductPopupService` defined in `product-popup.service.ts`, a
    utility service to open popup dialogs for entity editing and deletion.
  prefs: []
  type: TYPE_NORMAL
- en: Angular components of the entity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For an entity, there are six component classes generated in four files and four
    HTML files that are used in the components.
  prefs: []
  type: TYPE_NORMAL
- en: '`ProductComponent`, defined in `product.component.ts` handles the main listing
    screen. It uses `product.component.html`, as the template. The component manages
    the view and their actions. It also calls multiple services to fetch data and
    to do other actions such as alerts and event broadcasts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '`product-dialog.component.ts` defines `ProductDialogComponent` and `ProductPopupComponent`,
    which handle the create/edit dialog page using `template product-dialog.component.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '`ProductDetailComponent` handles the detail view screen using `product-detail.component.html`
    as the template and is defined in `product-detail.component.ts`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`ProductDeleteDialogComponent` and `ProductDeletePopupComponent` defined in `product-delete-dialog.component.ts`
    manages the delete popup dialog using `product-delete-dialog.component.html` as
    the template.'
  prefs: []
  type: TYPE_NORMAL
- en: Angular route for the entity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need a route declaration so that we can access the entity pages. This is
    declared in `product.route.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this declares the detail view of the entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The data attribute is used to pass metadata such as allowed roles and page
    titles to the component. The `UserRouteAccessService` defined in the `canActivate` attribute
    decides whether a user has the authorization to view the page and uses the authorities
    metadata and authentication details to verify. Routes having a popup, declares
    the `outlet: ''popup''` attribute.'
  prefs: []
  type: TYPE_NORMAL
- en: Angular module for the entity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, we have a module for the entity. Angular modules can be used to consolidate
    all components, directives, pipes, and services of an entity so that they can
    be imported into other modules easily. The `StoreProductModule` module is defined
    in `product.module.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The module declares the components and registers services provided by it. The
    module also imports shared modules so that it can access shared services and components.
    The module is imported by the `StoreEntityModule` defined in `entity.module.ts`
    under `src/main/webapp/app/entities`.
  prefs: []
  type: TYPE_NORMAL
- en: Generated pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start the application to view the generated pages. In the Terminal,
    execute the Gradle command the follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This will start the server in development mode locally. Since the `import-jdl`
    step already compiled the frontend code, we don't have to run `yarn start` just
    to see the new pages, but please note that for further development it is better
    to use `yarn start` along with the preceding command. If you had the server already
    running while generating the entities, then no need to run this command, instead
    just compile the source again using the `./gradlew compileJava` command. Using
    your IDE and Spring devtools will hot reload the application for you. If you had
    `yarn start` running then a hot reload will take place on the client side as well,
    otherwise, it will just refresh the page. We will see more about hot reloading
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you see the following message, the server is ready and we can navigate
    to the URL `http://localhost:8080` in our favorite browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are not already logged in, sign in using the default admin user with
    the password `admin` by clicking on the Sign in link on the home page. Once logged
    in, click on the Entities link in the menu and you will see all our entities listed
    there:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8bfb4e57-74ce-4d6d-816b-4ba5702bb321.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the Product and you will see the Products listing screen. It doesn''t
    have any items yet as we haven''t created any:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/202a2acd-6872-49dd-94b6-1f84b625a5b0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s create an entity, click on the Create a new Product button on the screen
    and you will see the Create or edit a Product popup dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43c697e8-5b03-455d-9f97-80897e761feb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Enter `Name`, `Description`, `Price`, and `Size`. Choose an image by clicking
    on the Choose file button. Don''t worry about Product Category as we haven''t
    created any yet. Now click on Save and the popup will disappear and the listing
    screen will be refreshed with the success message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/117792dc-54ac-46cb-9a11-656c4191fec6.png)'
  prefs: []
  type: TYPE_IMG
- en: The Products screen now shows our new entity with buttons for View, Edit, and
    Delete. There are also pagination links on the bottom. Explore the View, Edit, and Delete
    buttons by clicking on each of them.
  prefs: []
  type: TYPE_NORMAL
- en: Running generated tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's run all the tests to make sure the generated test code works fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the server-side unit/integration tests, client-side Karma unit tests,
    and Protractor e2e tests using the command-line. In a new Terminal, navigate to
    the application source folder and execute these commands. They should finish with
    a success message. Make sure you have the application running, as e2e tests will
    need it. If the application is not running first start it by running `./gradlew`
    in a Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how to model and create entities using JDL. We also
    walked through important aspects of the created source code. We also browsed through
    the created entity modules and saw them in action. In the next chapter, we will
    see how we can utilize JHipster to further develop the application and include
    specific business logic and tweaks. We will also learn about some of the technologies
    used in more depth.
  prefs: []
  type: TYPE_NORMAL
