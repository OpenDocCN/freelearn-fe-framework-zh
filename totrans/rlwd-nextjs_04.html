<html><head></head><body>
		<div id="_idContainer013">
			<h1 id="_idParaDest-39"><em class="italic"><a id="_idTextAnchor038"/>Chapter 3</em>: Next.js Basics and Built-In Components</h1>
			<p>Next.js is not only about server-side rendering. It provides some incredibly useful built-in components and functions that we can use to create performant, dynamic, and modern websites.</p>
			<p>In this chapter, we're going to take a look at some concepts at the core of Next.js, such as routing systems, client-side navigation, serving optimized images, handling metadata, and more. These notions will be very beneficial once we move on to building some real-world applications with this framework.</p>
			<p>We will also take a closer look at the <strong class="source-inline">_app.js</strong> and <strong class="source-inline">_document.js</strong> pages, which will allow us to customize our web app behavior in several ways.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>How the routing system works, both on the client and server sides</li>
				<li>How to optimize navigation between pages</li>
				<li>How Next.js serves static assets</li>
				<li>How to optimize image serving via automatic image optimization and the new <strong class="source-inline">Image</strong> component</li>
				<li>How to dynamically handle HTML metadata from any component</li>
				<li>What are the <strong class="source-inline">_app.js</strong> and <strong class="source-inline">_document.js</strong> files and how can they be customized?</li>
			</ul>
			<h1 id="_idParaDest-40"><a id="_idTextAnchor039"/>Technical requirements</h1>
			<p>To run the code examples in this chapter, you need to have both Node.js and npm installed on your local machine.</p>
			<p>If you prefer, you can use an online IDE such as <a href="https://repl.it">https://repl.it</a> or <a href="https://codesandbox.io">https://codesandbox.io</a>; they both support Next.js, and you don't need to install any dependency on your computer.</p>
			<p>You can find the code for this chapter on the GitHub repository: <a href="https://github.com/PacktPublishing/Real-World-Next.js">https://github.com/PacktPublishing/Real-World-Next.js</a>.</p>
			<h1 id="_idParaDest-41"><a id="_idTextAnchor040"/>Routing system</h1>
			<p>If you're coming <a id="_idIndexMarker083"/>from client-side React, you might be familiar with libraries such as <em class="italic">React Router</em>, <em class="italic">Reach Router</em>, or <em class="italic">Wouter</em>. They allow you to create client-side routes only, meaning that all the pages will be created and rendered on the client side; no server-side rendering is involved.</p>
			<p>Next.js uses a different approach: filesystem-based pages and routes. As seen in Chapter 2, <em class="italic">Exploring Different Rendering Strategies</em>, a default Next.js project ships with a <strong class="source-inline">pages/</strong> directory. Every file inside that folder represents a new page/route for your application.</p>
			<p>Therefore, when talking about a page, we refer to a React component exported from any of the <strong class="source-inline">.js</strong>, <strong class="source-inline">.jsx</strong>, <strong class="source-inline">.ts</strong>, or <strong class="source-inline">.tsx</strong> files inside the <strong class="source-inline">pages/</strong> folder.</p>
			<p>To make things a bit clearer, let's say that we want to create a simple website with just two pages; the first one will be the home page, while the second one will be a simple contact page. To do that, we will only need to create two new files inside our <strong class="source-inline">pages/</strong> folder: <strong class="source-inline">index.js</strong> and <strong class="source-inline">contacts.js</strong>. Both files will need to export a function returning some JSX content; it will be rendered on the server side and sent to the browser as standard HTML.</p>
			<p>As we've just seen, a page must return valid JSX code, so let's make a very simple and concise <strong class="source-inline">index.js</strong> page:</p>
			<p class="source-code">function Homepage() {</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;div&gt; This is the homepage &lt;/div&gt;</p>
			<p class="source-code">  )</p>
			<p class="source-code">};</p>
			<p class="source-code">export default Homepage;</p>
			<p>If we run <strong class="source-inline">yarn dev</strong> or <strong class="source-inline">npm run dev</strong> in our terminal, then move to <a href="http://localhost:3000">http://localhost:3000</a> in our browser, we will only see the <strong class="bold">This is the homepage</strong> message appear on the screen. We've just made our first page!</p>
			<p>We can do the <a id="_idIndexMarker084"/>same with our contact page:</p>
			<p class="source-code">function ContactPage() {</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;div&gt;</p>
			<p class="source-code">      &lt;ul&gt;</p>
			<p class="source-code">        &lt;li&gt; Email: myemail@example.com&lt;/li&gt;</p>
			<p class="source-code">        &lt;li&gt; Twitter: @myusername &lt;/li&gt;</p>
			<p class="source-code">        &lt;li&gt; Instagram: myusername &lt;/li&gt;</p>
			<p class="source-code">      &lt;/ul&gt;</p>
			<p class="source-code">    &lt;/div&gt;</p>
			<p class="source-code">  )</p>
			<p class="source-code">};</p>
			<p class="source-code">export default ContactPage;</p>
			<p>Given that we've called our contact page <strong class="source-inline">contacts.js</strong>, we can navigate to http://localhost:3000/contacts and see the contacts list displayed on the browser. If we want to move that page to http://localhost:3000/contact-us, we can just rename our <strong class="source-inline">contacts.js</strong> file to <strong class="source-inline">contact-us.js</strong>, and Next.js will automatically rebuild the page using the new route name for us.</p>
			<p>Now, let's try to make things a bit harder. We're building a blog, so we want to create a route for each post. We also want to create a <strong class="source-inline">/posts</strong> page that will show every post present on the website.</p>
			<p>To do that, we will use a dynamic route as follows:</p>
			<p class="source-code">pages/</p>
			<p class="source-code">  - index.js</p>
			<p class="source-code">  - contact-us.js</p>
			<p class="source-code">  - posts/</p>
			<p class="source-code">      - index.js</p>
			<p class="source-code">      - [slug].js</p>
			<p>We haven't mentioned<a id="_idIndexMarker085"/> yet that we can create nested routes using folders inside our <strong class="source-inline">pages/</strong> directory. If we want to make a <strong class="source-inline">/posts</strong> route, we can create a new <strong class="source-inline">index.js</strong> file inside the <strong class="source-inline">pages/posts/</strong> folder, export a function containing some JSX code, and visit http://localhost:3000/posts.</p>
			<p>We then want to create a dynamic route for every blog post so that we don't have to manually create a new page every time we want to publish an article on our website. To do that, we can create a new file inside the <strong class="source-inline">pages/posts/</strong> folder, <strong class="source-inline">pages/posts/[slug].js</strong>, where <strong class="source-inline">[slug]</strong> identifies a route variable that can contain any value, depending on what the user types in the browser's address bar. In that case, we're creating a route containing a variable called <strong class="source-inline">slug</strong>, which can vary for every blog post. We can export a simple function returning some JSX code from that file and then browse to http://localhost:3000/posts/my-firstpost, http://localhost:3000/posts/foo-bar-baz, or any other http://localhost:3000/posts/* route. Whatever route you browse to, it will always render the same JSX code.</p>
			<p>We can also nest multiple dynamic routes inside the <strong class="source-inline">pages/</strong> folder; let's say that we want our post page structure to be as follows: <strong class="source-inline">/posts/[date]/[slug]</strong>. We can just add a new folder called <strong class="source-inline">[date]</strong> inside our <strong class="source-inline">pages/</strong> directory and move the <strong class="source-inline">slug.js</strong> file inside it:</p>
			<p class="source-code">pages/</p>
			<p class="source-code">  - index.js</p>
			<p class="source-code">  - contact-us.js</p>
			<p class="source-code">  - posts/</p>
			<p class="source-code">      - index.js</p>
			<p class="source-code">      - [date]/</p>
			<p class="source-code">          - [slug].js</p>
			<p>We can now visit <a href="http://localhost:3000/posts/2021-01-01/my-first-post">http://localhost:3000/posts/2021-01-01/my-first-post</a> and see the JSX content we've created previously. Once again, both the <strong class="source-inline">[date]</strong>and <strong class="source-inline">[slug]</strong> variables can represent whatever you want, so feel free to experiment by calling different routes on the browser.</p>
			<p>Until now, we have always used route variables to render the same page, but these variables are mainly meant for creating highly dynamic pages with different content depending on the<a id="_idIndexMarker086"/> route variables we're using. Let's see how to render different content depending on the variables in the next sections.</p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor041"/>Using route variables inside our pages</h2>
			<p>Route<a id="_idIndexMarker087"/> variables are incredibly useful for creating very dynamic page content.</p>
			<p>Let's take an easy example: a greetings page. Inside the project used in the previous section, let's create the following file: <strong class="source-inline">pages/greet/[name].js</strong>. We're going to use Next.js' built-in <strong class="source-inline">getServerSideProps</strong> function to dynamically get the <strong class="source-inline">[name]</strong> variable from the URL and greet the user:</p>
			<p class="source-code">export async function getServerSideProps({ params }) {</p>
			<p class="source-code">  const { name } = params;</p>
			<p class="source-code">  return {</p>
			<p class="source-code">    props: {</p>
			<p class="source-code">      name</p>
			<p class="source-code">    }</p>
			<p class="source-code">  } </p>
			<p class="source-code">}</p>
			<p class="source-code">function Greet(props) {</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;h1&gt; Hello, {props.name}! &lt;/h1&gt;</p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p class="source-code">export default Greet;</p>
			<p>Now, open your favorite browser and go to http://localhost:3000/greet/Mitch; you should see a "<strong class="bold">Hello, Mitch!</strong>" message appear on the screen. Remember that we're using a <strong class="source-inline">name</strong> variable, so feel free to try with some different names!</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">When using both the <strong class="source-inline">getServerSideProps</strong> and <strong class="source-inline">getStaticProps</strong> functions, remember that they <em class="italic">must</em> return an object. Also, if you want to pass any prop from one of those two functions to your page, make sure to pass them inside the returning object's <strong class="source-inline">props</strong> property.</p>
			<p>Being able to get data from the URL is fundamental for many reasons. In the previous code example, we made a simple greetings page, but we could have used the <strong class="source-inline">[name]</strong> variable for other purposes, such as getting that user data from a database to show their profile. We will take a closer look at data fetching in <a href="B16985_04_Final_SB_epub.xhtml#_idTextAnchor053"><em class="italic">Chapter 4</em></a>, <em class="italic">Organizing the Code Base and Fetching Data in Next.js</em>.</p>
			<p>There are times <a id="_idIndexMarker088"/>when you need to fetch route variables from your components rather than your pages. Next.js makes this effortless thanks to a React hook that we'll see in the next section.</p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor042"/>Using route variables inside components</h2>
			<p>In the previous<a id="_idIndexMarker089"/> section, we have learned how to use route variables inside our pages. Next.js does not allow us to use both <strong class="source-inline">getServerSideProps</strong> and <strong class="source-inline">getStaticProps</strong> functions outside of our pages, so how are we supposed to use them inside other components?</p>
			<p>Next.js makes this effortless thanks to the <strong class="source-inline">useRouter</strong> hook; we can import it from the <strong class="source-inline">next/router</strong> file:</p>
			<p class="source-code">import { useRouter } from 'next/router';</p>
			<p>It works just like any other React hook (a function that lets you interact with the React state and life cycle in function components), and we can instantiate it inside any component. Let's refactor the previous greetings page as follows:</p>
			<p class="source-code">import { useRouter } from 'next/router';</p>
			<p class="source-code">function Greet() {</p>
			<p class="source-code">  const { query } = useRouter();</p>
			<p class="source-code">  return &lt;h1&gt;Hello {query.name}!&lt;/h1&gt;;</p>
			<p class="source-code">}</p>
			<p class="source-code">export default Greet;</p>
			<p>As you can see, we are extracting the <strong class="source-inline">query</strong> parameter from the <strong class="source-inline">useRouter</strong> hook. It contains both our route variables (in this case, it only contains the <strong class="source-inline">name</strong> variable) and the parsed query string parameters.</p>
			<p>We can observe<a id="_idIndexMarker090"/> how Next.js passes both route variables and query strings via the <strong class="source-inline">useRouter</strong> hook by trying to append any query parameter to our URL and log the <strong class="source-inline">query</strong> variable inside our component:</p>
			<p class="source-code">import { useRouter } from 'next/router';</p>
			<p class="source-code">function Greet() {</p>
			<p class="source-code">  const { query } = useRouter();</p>
			<p class="source-code">  console.log(query);</p>
			<p class="source-code">  return &lt;h1&gt;Hello {query.name}!&lt;/h1&gt;;</p>
			<p class="source-code">}</p>
			<p class="source-code">export default Greet;</p>
			<p>If we now try to call the following URL, http://localhost:3000/greet/Mitch?learning_nextjs=true, we will see the following object logged inside our terminal:</p>
			<p class="source-code">{learning_nextjs: "true", name: "Mitch"}</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Next.js does not throw any error if you try to append a query parameter with the same key as your routing variable. You can easily try that by calling the following URL: http://localhost:3000/greet/Mitch?name=Christine. You will notice that Next.js will give precedence to<a id="_idIndexMarker091"/> your route variable, such that you will see <strong class="bold">Hello, Mitch!</strong> displayed on the page.</p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor043"/>Client-side navigation</h2>
			<p>As we have <a id="_idIndexMarker092"/>already<a id="_idIndexMarker093"/> seen so far, Next.js is not only about rendering React on the server. It provides several ways to optimize your website's performance, and one of these optimizations is how it handles client-side navigation.</p>
			<p>In fact, it supports the HTML standard <strong class="source-inline">&lt;a&gt;</strong> tags for linking pages, but it also provides a more optimized way for navigating between different routes: the <strong class="source-inline">Link</strong> component.</p>
			<p>We can import it as a standard React component and use it for linking different pages or sections of our website. Let's look at an easy example:</p>
			<p class="source-code">import Link from 'next/link';</p>
			<p class="source-code">function Navbar() {</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;div&gt;</p>
			<p class="source-code">      &lt;Link href='/about'&gt;Home&lt;/Link&gt;</p>
			<p class="source-code">      &lt;Link href='/about'&gt;About&lt;/Link&gt;</p>
			<p class="source-code">      &lt;Link href='/about'&gt;Contacts&lt;/Link&gt;</p>
			<p class="source-code">    &lt;/div&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p class="source-code">export default Navbar;</p>
			<p>By default, Next.js will preload every single <strong class="source-inline">Link</strong> found on the viewport, meaning that once we click on one of the links, the browser will already have all the data needed to render the page.</p>
			<p>You can disable<a id="_idIndexMarker094"/> this<a id="_idIndexMarker095"/> feature by passing the <strong class="source-inline">preload={false}</strong> prop to the <strong class="source-inline">Link</strong> component:</p>
			<p class="source-code">import Link from 'next/link';</p>
			<p class="source-code">function Navbar() {</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;div&gt;</p>
			<p class="source-code">      &lt;Link href='/about' preload={false}&gt;Home&lt;/Link&gt;</p>
			<p class="source-code">      &lt;Link href='/about' preload={false}&gt;About&lt;/Link&gt;</p>
			<p class="source-code">      &lt;Link href='/about' preload={false}&gt;Contacts&lt;/Link&gt; </p>
			<p class="source-code">    &lt;/div&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p class="source-code">export default Navbar;</p>
			<p>Starting with Next.js 10, we're also able to link pages with dynamic route variables with ease.</p>
			<p>Let's say that we want to link the following page: <strong class="source-inline">/blog/[date]/[slug].js</strong>. With previous versions of Next.js, we needed to add two different props:</p>
			<p class="source-code">&lt;Link href='/blog/[date]/[slug]'   as='/blog/2021-01-01/happy-new-year'&gt;</p>
			<p class="source-code">  Read post</p>
			<p class="source-code">&lt;/Link&gt;</p>
			<p>The <strong class="source-inline">href</strong> prop tells Next.js which page we want to render, and the <strong class="source-inline">as</strong> prop will tell how we want to display it in the browser's address bar.</p>
			<p>Thanks to the enhancements introduced in Next.js 10, we no longer need to use the <strong class="source-inline">as</strong> prop as the <strong class="source-inline">href</strong> prop is enough for setting both the page we want to render and the URL displayed in the browser's address bar. For instance, we can now write our links as follows:</p>
			<p class="source-code">&lt;Link <strong class="bold">href='/blog/2021-01-01/happy-new-year'</strong>&gt; Read post &lt;/Link&gt;</p>
			<p class="source-code">&lt;Link <strong class="bold">href='/blog/2021-03-05/match-update'</strong>&gt; Read post &lt;/Link&gt;</p>
			<p class="source-code">&lt;Link <strong class="bold">href='/blog/2021-04-23/i-love-nextjs'</strong>&gt; Read post &lt;/Link&gt;</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Although the legacy method for linking dynamic pages using the <strong class="source-inline">Link</strong> component is still working in Next.js &gt;10, the framework's newest version makes it way easier. If you have some experience with previous Next.js versions or you're willing to upgrade to version &gt;10, keep that new feature in mind as it will simplify the development of components, including dynamic links.</p>
			<p>If we are<a id="_idIndexMarker096"/> building <a id="_idIndexMarker097"/>complex URLs, we can also pass an object to the <strong class="source-inline">href</strong> prop:</p>
			<p class="source-code">&lt;Link</p>
			<p class="source-code">  href={{</p>
			<p class="source-code">    pathname: '/blog/[date]/[slug]'</p>
			<p class="source-code">    query: {</p>
			<p class="source-code">      date: '2020-01-01',</p>
			<p class="source-code">      slug: 'happy-new-year',</p>
			<p class="source-code">      foo: 'bar'</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }}</p>
			<p class="source-code">/&gt;</p>
			<p class="source-code">  Read post</p>
			<p class="source-code">&lt;/Link&gt;</p>
			<p>Once the user clicks<a id="_idIndexMarker098"/> that<a id="_idIndexMarker099"/> link, Next.js will redirect the browser to the following URL: http://localhost:3000/blog/2020-01-01/happy-new-year?foo=bar.</p>
			<h3>Using the router.push method</h3>
			<p>There is another <a id="_idIndexMarker100"/>way to move between your Next.js <a id="_idIndexMarker101"/>website pages: by using the <strong class="source-inline">useRouter</strong> hook.</p>
			<p>Let's pretend that we want to give access to a given page only to logged-in users, and we already have a <strong class="source-inline">useAuth</strong> hook for that. We can use the <strong class="source-inline">useRouter</strong> hook to dynamically redirect a user if, in this case, they're not logged in:</p>
			<p class="source-code">import { useEffect } from 'react';</p>
			<p class="source-code">import { useRouter } from 'next/router';</p>
			<p class="source-code">import PrivateComponent from '../components/Private';</p>
			<p class="source-code">import useAuth from '../hooks/auth';</p>
			<p class="source-code">function MyPage() {</p>
			<p class="source-code">  const router = useRouter();</p>
			<p class="source-code">  const { loggedIn } = useAuth();</p>
			<p class="source-code">  useEffect(() =&gt; {</p>
			<p class="source-code">    if (!loggedIn) {</p>
			<p class="source-code">      router.push('/login')</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }, [loggedIn]);</p>
			<p class="source-code">  return loggedIn</p>
			<p class="source-code">    ? &lt;PrivateComponent /&gt;</p>
			<p class="source-code">    : null;</p>
			<p class="source-code">}</p>
			<p class="source-code">export default MyPage;</p>
			<p>As you can see, we're using the <strong class="source-inline">useEffect</strong> hook to run the code on the client side only. In that case, if the user isn't logged in, we use the <strong class="source-inline">router.push</strong> method to redirect them to the login page.</p>
			<p>Just like with the <strong class="source-inline">Link</strong> component, we can create more complex page routes by passing<a id="_idIndexMarker102"/> an<a id="_idIndexMarker103"/> object to the <strong class="source-inline">push</strong> method:</p>
			<p class="source-code">router.push({</p>
			<p class="source-code">  pathname: '/blog/[date]/[slug]',</p>
			<p class="source-code">  query: {</p>
			<p class="source-code">    date: '2021-01-01',</p>
			<p class="source-code">    slug: 'happy-new-year',</p>
			<p class="source-code">    foo: 'bar'</p>
			<p class="source-code">  }</p>
			<p class="source-code">});</p>
			<p>Once the <strong class="source-inline">router.push</strong> function has been called, the browser will be redirected to http://localhost:3000/blog/2020-01-01/happy-new-year?foo=bar.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Next.js won't be able to prefetch all the linked pages as it does with the <strong class="source-inline">Link</strong> component.</p>
			<p class="callout">Using the <strong class="source-inline">router.push</strong> method is handy when you need to redirect a user on the client side after a certain action occurs, but it's not recommended to be used as a default way for handling client-side navigation.</p>
			<p>So far, we've seen how Next.js handles navigation through static and dynamic routes and how to force redirection and navigation on both the client and server sides programmatically.</p>
			<p>In the next section, we're going to look at how Next.js helps us to serve static assets and optimize<a id="_idIndexMarker104"/> images<a id="_idIndexMarker105"/> on the fly for improved performance and SEO scores. </p>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor044"/>Serving static assets</h1>
			<p>Using the <a id="_idIndexMarker106"/>term <strong class="bold">static asset</strong>, we refer to all of those non-dynamic files, such as images, fonts, icons, compiled CSS, and JS files.</p>
			<p>The easiest way to serve those assets is by using the default <strong class="source-inline">/public</strong> folder provided by Next.js. In fact, every file inside this folder will be considered and served as a static asset. We can prove that by creating a new file called <strong class="source-inline">index.txt</strong> and putting it inside the <strong class="source-inline">/public</strong> folder:</p>
			<p class="source-code">echo "Hello, world!" &gt;&gt; ./public/index.txt</p>
			<p>If we now try to launch the server, when we go to <a href="http://localhost:3000/index.txt">http://localhost:3000/index.txt</a>, we will see the text <strong class="bold">Hello, world!</strong> displayed in the browser.</p>
			<p>In <a href="B16985_04_Final_SB_epub.xhtml#_idTextAnchor053"><em class="italic">Chapter 4</em></a>, <em class="italic">Organizing the Code Base and Fetching Data in Next.js</em>, we will take a closer look at organizing the public folder for serving common CSS and JS files, images, icons, and all the other types of static files.</p>
			<p>Serving static assets is relatively easy. However, a specific type of file can critically affect your website performance (and SEO): the image file.</p>
			<p>Most of the time, serving non-optimized images will worsen your user experience, as they may take some time to load, and once they do, they'll move part of the layout after the rendering, which can cause many problems in terms of UX. When this occurs, we're talking <a id="_idIndexMarker107"/>about <strong class="bold">Cumulative Layout Shift (CLS)</strong>. Here is a simple representation of how CLS works:</p>
			<div>
				<div id="_idContainer008" class="IMG---Figure">
					<img src="image/B16985_03_01.jpg" alt="Figure 3.1 – Representation of how CLS works&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – Representation of how CLS works</p>
			<p>In the first browser tab, the image has not been loaded yet, so the two text areas look quite close to each other. After the image loads, it shifts the second text area down. If the user were reading the second text area, they would easily miss the mark.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">If you want to learn more about CLS, I'd recommend the following article: <a href="https://web.dev/cls">https://web.dev/cls</a>.</p>
			<p>Of course, Next.js <a id="_idIndexMarker108"/>makes it easy to avoid CLS, and it does so with a new built-in <strong class="source-inline">Image</strong> component. We will take a look at this in the next section.</p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor045"/>Next.js' automatic image optimization </h2>
			<p>Starting with Next.js 10, the framework introduced<a id="_idIndexMarker109"/> a new helpful <strong class="source-inline">Image</strong> component<a id="_idIndexMarker110"/> and automatic image optimization.</p>
			<p>Before Next.js introduced these two new features, we had to optimize every image using an external tool and then write down a complex <strong class="source-inline">srcset</strong> property for every HTML <strong class="source-inline">&lt;img&gt;</strong> tag to set responsive images for different screen sizes.</p>
			<p>Indeed, automatic image optimization will take care of serving your images using modern formats (such<a id="_idIndexMarker111"/> as <strong class="bold">WebP</strong>) to all those browsers that support it. But it will also be able to fall back on older image formats, such as <em class="italic">png</em> or <em class="italic">jpg</em>, in case the browser you're using doesn't support it. It also resizes your images to avoid serving heavy pictures to the client as it would negatively affect the asset's download speed.</p>
			<p>One great thing to keep in mind is that automatic image optimization works on-demand, as it optimizes, resizes, and renders the image only when the browser has requested it. This is important as it will work with any external data source (any CMS or image service, such as Unsplash or Pexels), and it won't slow down the build phase.</p>
			<p>We can try this feature on our local machine in a few minutes to see in person how it works. Let's say <a id="_idIndexMarker112"/>that we want to serve the<a id="_idIndexMarker113"/> following image:</p>
			<div>
				<div id="_idContainer009" class="IMG---Figure">
					<img src="image/B16985_03_02.jpg" alt="Figure 3.2 – Picture by Łukasz Rawa on Unsplash (https://unsplash.com/@lukasz_rawa)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – Picture by Łukasz Rawa on Unsplash (<a href="https://unsplash.com/@lukasz_rawa">https://unsplash.com/@lukasz_rawa</a>)</p>
			<p>Using standard HTML tags, we could just do the following:</p>
			<p class="source-code">&lt;img</p>
			<p class="source-code">  src='https://images.unsplash.com/photo-1605460375648-</p>
			<p class="source-code">  278bcbd579a6'</p>
			<p class="source-code">  alt='A beautiful English Setter'</p>
			<p class="source-code">/&gt;</p>
			<p>However, we may also want to use the <strong class="source-inline">srcset</strong> property for responsive images, so we'll actually need to optimize the picture for different screen resolutions, which involves some extra steps for serving our assets.</p>
			<p>Next.js makes it very easy by just configuring the <strong class="source-inline">next.config.js</strong> file and using the <strong class="source-inline">Image</strong> component. We just said that we want to serve images coming from Unsplash, so let's add that service hostname to our <strong class="source-inline">next.config.js</strong> file, under the <strong class="source-inline">images</strong> property:</p>
			<p class="source-code">module.exports = {</p>
			<p class="source-code">  images: {</p>
			<p class="source-code">    domains: ['images.unsplash.com']</p>
			<p class="source-code">  }</p>
			<p class="source-code">};</p>
			<p>That way, every <a id="_idIndexMarker114"/>time we use an image coming from that <a id="_idIndexMarker115"/>hostname inside an <strong class="source-inline">Image</strong> component, Next.js will automatically optimize it for us.</p>
			<p>Now, let's try to import that image inside a page:</p>
			<p class="source-code">import Image from 'next/image';</p>
			<p class="source-code">function IndexPage() {</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;div&gt;</p>
			<p class="source-code">      &lt;Image</p>
			<p class="source-code">        src='https://images.unsplash.com/photo-</p>
			<p class="source-code">         1605460375648-278bcbd579a6'</p>
			<p class="source-code">        width={500}</p>
			<p class="source-code">        height={200}</p>
			<p class="source-code">        alt='A beautiful English Setter'</p>
			<p class="source-code">      /&gt;</p>
			<p class="source-code">    &lt;/div&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p class="source-code">export default IndexPage;</p>
			<p>Opening the browser, you will notice that the image is stretched to fit both the <strong class="source-inline">width</strong> and <strong class="source-inline">height</strong> props <a id="_idIndexMarker116"/>specified in <a id="_idIndexMarker117"/>your <strong class="source-inline">Image</strong> component.</p>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<img src="image/B16985_03_03.jpg" alt="Figure 3.3 – Representation of the image component we just created&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.3 – Representation of the image component we just created</p>
			<p>We can crop our image to fit the desired dimensions using the optional <strong class="source-inline">layout</strong> prop. It accepts four different values: <strong class="source-inline">fixed</strong>, <strong class="source-inline">intrinsic</strong>, <strong class="source-inline">responsive</strong>, and <strong class="source-inline">fill</strong>. Let's look at these in more detail:</p>
			<ul>
				<li><strong class="source-inline">fixed</strong> works just like the <strong class="source-inline">img</strong> HTML tag. If we change the viewport size, it will keep the same size, meaning that it won't provide a responsive image for smaller (or bigger) screens.</li>
				<li><strong class="source-inline">responsive</strong> works in the opposite way to <strong class="source-inline">fixed</strong>; as we resize our viewport, it will serve differently optimized images for our screen size.</li>
				<li><strong class="source-inline">intrinsic</strong> is halfway between <strong class="source-inline">fixed</strong> and <strong class="source-inline">responsive</strong>; it will serve different image sizes as we resize down our viewport, but it will leave the largest image untouched on bigger screens.</li>
				<li><strong class="source-inline">fill</strong> will stretch the image according to its parent element's width and height; however, we can't use <strong class="source-inline">fill</strong> alongside the <strong class="source-inline">width</strong> and <strong class="source-inline">height</strong> props. You can use <strong class="source-inline">fill</strong> <em class="italic">or</em> <strong class="source-inline">width</strong> and <strong class="source-inline">height</strong>).</li>
			</ul>
			<p>So now, if we want to fix our English Setter image to display it properly on our screen, we can<a id="_idIndexMarker118"/> refactor our <strong class="source-inline">Image</strong> component as<a id="_idIndexMarker119"/> follows:</p>
			<p class="source-code">import Image from 'next/image';</p>
			<p class="source-code">function IndexPage() {</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;div&gt;</p>
			<p class="source-code">      &lt;div</p>
			<p class="source-code">        style={{ width: 500, height: 200, position: </p>
			<p class="source-code">         'relative' }}</p>
			<p class="source-code">      &gt;</p>
			<p class="source-code">        &lt;Image</p>
			<p class="source-code">          src='https://images.unsplash.com/photo-</p>
			<p class="source-code">           1605460375648-278bcbd579a6'</p>
			<p class="source-code">          layout='fill'</p>
			<p class="source-code">          objectFit='cover'</p>
			<p class="source-code">          alt='A beautiful English Setter'</p>
			<p class="source-code">        /&gt;</p>
			<p class="source-code">      &lt;/div&gt;</p>
			<p class="source-code">    &lt;/div&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p class="source-code">export default IndexPage;</p>
			<p>As you can see, we wrapped the <strong class="source-inline">Image</strong> component with a fixed size <strong class="source-inline">div</strong> and the CSS <strong class="source-inline">position</strong> property set to <strong class="source-inline">relative</strong>. We also removed both the <strong class="source-inline">width</strong> and <strong class="source-inline">height</strong> props from our <strong class="source-inline">Image</strong> component, as it will stretch following its parent <strong class="source-inline">div</strong> sizes.</p>
			<p>We also added the <strong class="source-inline">objectFit</strong> prop set to <strong class="source-inline">cover</strong> so that it will crop the image according to<a id="_idIndexMarker120"/> its parent <strong class="source-inline">div</strong> size, and that's the<a id="_idIndexMarker121"/> final result.</p>
			<div>
				<div id="_idContainer011" class="IMG---Figure">
					<img src="image/B16985_03_04.jpg" alt="Figure 3.4 – Representation of the image component with the layout prop set to &quot;fill&quot;&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.4 – Representation of the image component with the layout prop set to "fill"</p>
			<p>If we now try to inspect the resulting HTML on the browser, we will see that the <strong class="source-inline">Image</strong> component generated many different image sizes, which will be served using the <strong class="source-inline">srcset</strong> property of a standard <strong class="source-inline">img</strong> HTML tag:</p>
			<p class="source-code">&lt;div style="..."</p>
			<p class="source-code">&lt;img alt="A beautiful English Setter"src="/_next/image?url=https%3A%2F%2Fimages.unsplash.com%2Fphoto-1605460375648-278bcbd579a6&amp;w=3840&amp;q=75" decoding="async" <strong class="bold">sizes</strong>="<strong class="bold">100vw</strong>" <strong class="bold">srcset</strong>="/_next/image?url=https%3A%2F%2Fimages.unsplash.com%2Fphoto-1605460375648-278bcbd579a6&amp;w=<strong class="bold">640</strong>&amp;q=75 <strong class="bold">640w</strong>, /_next/image?url=https%3A%2F%2Fimages.unsplash.com%2Fphoto-1605460375648-278bcbd579a6&amp;w=<strong class="bold">750</strong>&amp;q=75 <strong class="bold">750w</strong>, /_next/image?url=https%3A%2F%2Fimages.unsplash.com%2Fphoto-1605460375648-278bcbd579a6&amp;w=<strong class="bold">828</strong>&amp;q=75 <strong class="bold">828w</strong>, /_next/image?url=https%3A%2F%2Fimages.unsplash.com%2Fphoto-1605460375648-278bcbd579a6&amp;w=<strong class="bold">1080</strong>&amp;q=75 <strong class="bold">1080w</strong>, /_next/image?url=https%3A%2F%2Fimages.unsplash.com%2Fphoto-1605460375648-278bcbd579a6&amp;w=<strong class="bold">1200</strong>&amp;q=75 <strong class="bold">1200w</strong>, /_next/image?url=https%3A%2F%2Fimages.unsplash.com%2Fphoto-1605460375648-278bcbd579a6&amp;w=<strong class="bold">1920</strong>&amp;q=75 <strong class="bold">1920w</strong>, /_next/image?url=https%3A%2F%2Fimages.unsplash.com%2Fphoto-1605460375648-278bcbd579a6&amp;w=<strong class="bold">2048</strong>&amp;q=75 <strong class="bold">2048w</strong>, /_next/image?url=https%3A%2F%2Fimages.unsplash.com%2Fphoto-1605460375648-278bcbd579a6&amp;w=<strong class="bold">3840</strong>&amp;q=75 <strong class="bold">3840w</strong>" style="..."</p>
			<p class="source-code">&lt;/div&gt;</p>
			<p>One last thing worth mentioning is that if we inspect the image format on Google Chrome or Firefox, we will see that it has been served as <strong class="source-inline">WebP</strong>, even if the original image served from Unsplash was a <strong class="source-inline">jpeg</strong>. If we now try to render the same page on iOS with Safari, Next.js will serve the original <strong class="source-inline">jpeg</strong> format, as (at the time of writing) that iOS browser does not yet support the <strong class="source-inline">WebP</strong> format.</p>
			<p>As said at the beginning of this section, Next.js runs automatic image optimization on-demand, meaning that if a given image is never requested, it will never be optimized.</p>
			<p>The whole <a id="_idIndexMarker122"/>optimization phase occurs on the <a id="_idIndexMarker123"/>server where Next.js is running. If you're running a web app containing tons of images, it could affect your server performance. In the next section, we'll see how to delegate the optimization phase to external services.</p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor046"/>Running automatic image optimization on external services</h2>
			<p>By default, automatic<a id="_idIndexMarker124"/> image optimization runs on the same server as Next.js. Of course, if you're running your website on a small server with low resources, this could potentially affect its performance. For that reason, Next.js allows you to run automatic image optimization on external services by setting the <strong class="source-inline">loader</strong> option inside your <strong class="source-inline">next.config.js</strong> file:</p>
			<p class="source-code">module.exports = {</p>
			<p class="source-code">  images: {</p>
			<p class="source-code">    loader: 'akamai',</p>
			<p class="source-code">    domains: ['images.unsplash.com']</p>
			<p class="source-code">  }</p>
			<p class="source-code">};</p>
			<p>If you're deploying your web app to Vercel, you don't actually need to set up any loader in your <strong class="source-inline">next.config.js</strong> file as Vercel will take care of optimizing and serving the image files for<a id="_idIndexMarker125"/> you. Otherwise, you <a id="_idIndexMarker126"/>can use the following<a id="_idIndexMarker127"/> external services:</p>
			<ul>
				<li>Akamai: <a href="https://www.akamai.com">https://www.akamai.com</a></li>
				<li>Imgix: <a href="https://www.imgix.com">https://www.imgix.com</a></li>
				<li>Cloudinary: <a href="https://cloudinary.com">https://cloudinary.com</a></li>
			</ul>
			<p>If you don't <a id="_idIndexMarker128"/>want to use any of these services, or you want to use your custom image optimization server, you can use the <strong class="source-inline">loader</strong> prop directly inside your component:</p>
			<p class="source-code">import Image from 'next/image'</p>
			<p class="source-code">const loader = ({src, width, quality}) =&gt; {</p>
			<p class="source-code">  return `https://example.com/${src}?w=${width}&amp;q=${quality </p>
			<p class="source-code">   || 75}`</p>
			<p class="source-code">}</p>
			<p class="source-code">function CustomImage() {</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;Image</p>
			<p class="source-code">      loader={loader}</p>
			<p class="source-code">      src="/myimage.png"</p>
			<p class="source-code">      alt="My image alt text"</p>
			<p class="source-code">      width={350}</p>
			<p class="source-code">      height={540}</p>
			<p class="source-code">    /&gt;</p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p>This way, you'll be able to serve images coming from any external service and this allows you to take advantage of custom image optimization servers or free, open source projects <a id="_idIndexMarker129"/>such as <em class="italic">Imgproxy</em> (<a href="https://github.com/imgproxy/imgproxy">https://github.com/imgproxy/imgproxy</a>) or <em class="italic">Thumbor</em> (https://github.com/thumbor/thumbor).</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">When you're using custom loaders, keep in mind that every service has its own APIs for resizing and serving images. For instance, to serve an image from <em class="italic">Imgproxy</em>, you would need to call it with the following URL: https://imgproxy.example.com/&lt;auth-key&gt;/fill/500/500/sm/0/plain/https://example.com/images/myImage.jpg. With <em class="italic">Thumbor</em>, you'd need to call it with a different URL schema: <a href="https://thumbor.example.com/500x500/smart/example.com/images/myImage.jpg">https://thumbor.example.com/500x500/smart/example.com/images/myImage.jpg</a>.</p>
			<p class="callout">Before creating a custom loader, read the documentation of your image optimization server.</p>
			<p>Correctly serving images has become more and more complex during the last years, but it is worth spending some time fine-tuning that process as it can affect our user experience in many critical ways. Thankfully, Next.js makes it quite effortless thanks to its built-in components and optimizations.</p>
			<p>However, we should also think of web scrapers, bots, and web spiders when we're building a web app! I'm referring to web technologies that will look at our web page's metadata for taking actions such as indexing, linking, and evaluation. We'll see how to handle metadata in the next section.</p>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor047"/>Handling metadata</h1>
			<p>Correctly handling<a id="_idIndexMarker130"/> metadata is a crucial part of modern web development. To keep it simple, let's think about when we share a link on Facebook or Twitter. If we share the React website (<a href="https://reactjs.org">https://reactjs.org</a>) on Facebook, we will see the following card appear inside our post:</p>
			<div>
				<div id="_idContainer012" class="IMG---Figure">
					<img src="image/B16985_03_05.jpg" alt="Figure 3.5 – Open Graph data of https://reactjs.org&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.5 – Open Graph data of <a href="https://reactjs.org&#13;">https://reactjs.org</a></p>
			<p>To know which data should be displayed inside the card, Facebook uses a protocol called <strong class="bold">Open Graph</strong> (<a href="https://ogp.me">https://ogp.me</a>). In<a id="_idIndexMarker131"/> order to give that information to any social network or website, we need to add some metadata to our pages.</p>
			<p>So far, we haven't yet talked about how to set open graph data, HTML titles, or HTML meta tags dynamically. While a website could technically work even without that data, search engines would penalize your pages, as they would miss important information. The user experience could also be negatively affected as these meta tags would help the browser create an optimized experience for our users.</p>
			<p>Once again, Next.js provides a great way of solving these problems: the built-in <strong class="source-inline">Head</strong> component. Indeed, this component allows us to update the <strong class="source-inline">&lt;head&gt;</strong> section of our HTML page from any component, meaning that we can dynamically change, add, or delete any metadata, link, or script at runtime depending on our user's navigation.</p>
			<p>We can start with one of the most common dynamic parts of our metadata: the HTML <strong class="source-inline">&lt;title&gt;</strong> tag. Let's set up a new Next.js project and then create two new pages.</p>
			<p>The first page we <a id="_idIndexMarker132"/>will create is <strong class="source-inline">index.js</strong>:</p>
			<p class="source-code">import Head from 'next/head';</p>
			<p class="source-code">import Link from 'next/link';</p>
			<p class="source-code">function IndexPage() {</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;&gt;</p>
			<p class="source-code"><strong class="bold">      &lt;Head&gt;</strong></p>
			<p class="source-code"><strong class="bold">        &lt;title&gt; Welcome to my Next.js website &lt;/title&gt;</strong></p>
			<p class="source-code"><strong class="bold">      &lt;/Head&gt;</strong></p>
			<p class="source-code">      &lt;div&gt;</p>
			<p class="source-code">        &lt;Link href='/about' passHref&gt;</p>
			<p class="source-code">          &lt;a&gt;About us&lt;/a&gt;</p>
			<p class="source-code">        &lt;/Link&gt;</p>
			<p class="source-code">      &lt;/div&gt;</p>
			<p class="source-code">   &lt;/&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p class="source-code">export default IndexPage;</p>
			<p>The second page is <strong class="source-inline">about.js</strong>:</p>
			<p class="source-code">import Head from 'next/head';</p>
			<p class="source-code">import Link from 'next/link';</p>
			<p class="source-code">function AboutPage() {</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;&gt;</p>
			<p class="source-code"><strong class="bold">      &lt;Head&gt;</strong></p>
			<p class="source-code"><strong class="bold">        &lt;title&gt; About this website &lt;/title&gt;</strong></p>
			<p class="source-code"><strong class="bold">      &lt;/Head&gt;</strong></p>
			<p class="source-code">      &lt;div&gt;</p>
			<p class="source-code">        &lt;Link href='/'passHref&gt;</p>
			<p class="source-code">          &lt;a&gt;Back to home&lt;/a&gt;</p>
			<p class="source-code">        &lt;/Link&gt;</p>
			<p class="source-code">      &lt;/div&gt;</p>
			<p class="source-code">    &lt;/&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p class="source-code">export default AboutPage;</p>
			<p>Running the server, you<a id="_idIndexMarker133"/> will be able to navigate between those two pages and see that the <strong class="source-inline">&lt;title&gt;</strong> content changes depending on the route you're visiting.</p>
			<p>Now, let's make things a bit more complex. We want to create a new component that only displays a button. Once we click on it, our page title will change depending on the page we're currently on; we can always roll back to the original title by clicking on the button again.</p>
			<p>Let's create a new folder, <strong class="source-inline">components/</strong>, in your project root and a new file, <strong class="source-inline">components/Widget.js</strong>, inside it:</p>
			<p class="source-code">import { useState } from 'react;</p>
			<p class="source-code">import Head from 'next/head';</p>
			<p class="source-code">function Widget({pageName}) {</p>
			<p class="source-code">  const [active, setActive] = useState(false);</p>
			<p class="source-code">  if (active) {</p>
			<p class="source-code">    return (</p>
			<p class="source-code">      &lt;&gt;</p>
			<p class="source-code">        &lt;Head&gt;</p>
			<p class="source-code">          &lt;title&gt; You're browsing the {pageName} page </p>
			<p class="source-code">          &lt;/title&gt;</p>
			<p class="source-code">        &lt;/Head&gt;</p>
			<p class="source-code">        &lt;div&gt;</p>
			<p class="source-code">          &lt;button onClick={() =&gt;setActive(false)}&gt;</p>
			<p class="source-code">            Restore original title</p>
			<p class="source-code">          &lt;/button&gt;</p>
			<p class="source-code">          Take a look at the title!</p>
			<p class="source-code">        &lt;/div&gt;</p>
			<p class="source-code">      &lt;/&gt;</p>
			<p class="source-code">    );</p>
			<p class="source-code">  }</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;&gt;</p>
			<p class="source-code">      &lt;button onClick={() =&gt;setActive(true)}&gt;</p>
			<p class="source-code">        Change page title</p>
			<p class="source-code">      &lt;/button&gt;</p>
			<p class="source-code">    &lt;/&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p class="source-code">export default Widget;</p>
			<p>Great! Now let's edit both our <strong class="source-inline">index.js</strong> and <strong class="source-inline">about.js</strong> pages to include that component.</p>
			<p>We'll start by opening the <strong class="source-inline">index.js</strong> file and importing the <strong class="source-inline">Widget</strong> component and then we're going<a id="_idIndexMarker134"/> to render it inside a new <strong class="source-inline">&lt;div&gt;</strong>:</p>
			<p class="source-code">import Head from 'next/head';</p>
			<p class="source-code">import Link from 'next/link';</p>
			<p class="source-code"><strong class="bold">import Widget from '../components/Widget';</strong></p>
			<p class="source-code">function IndexPage() {</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;&gt;</p>
			<p class="source-code">      &lt;Head&gt;</p>
			<p class="source-code">        &lt;title&gt; Welcome to my Next.js website &lt;/title&gt;</p>
			<p class="source-code">      &lt;/Head&gt;</p>
			<p class="source-code">      &lt;div&gt;</p>
			<p class="source-code">        &lt;Link href='/about' passHref&gt;</p>
			<p class="source-code">          &lt;a&gt;About us&lt;/a&gt;</p>
			<p class="source-code">        &lt;/Link&gt;</p>
			<p class="source-code">      &lt;/div&gt;</p>
			<p class="source-code"><strong class="bold">      &lt;div&gt;</strong></p>
			<p class="source-code"><strong class="bold">        &lt;Widget pageName='index' /&gt;</strong></p>
			<p class="source-code"><strong class="bold">      &lt;/div&gt;</strong></p>
			<p class="source-code">    &lt;/&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p class="source-code">export default IndexPage;</p>
			<p>Let's do the same thing with the <strong class="source-inline">about.js</strong> page:</p>
			<p class="source-code">import Head from 'next/head';</p>
			<p class="source-code">import Link from 'next/link';</p>
			<p class="source-code"><strong class="bold">import Widget from '../components/Widget';</strong></p>
			<p class="source-code">function AboutPage() {</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;&gt;</p>
			<p class="source-code">      &lt;Head&gt;</p>
			<p class="source-code">        &lt;title&gt; About this website &lt;/title&gt;</p>
			<p class="source-code">      &lt;/Head&gt;</p>
			<p class="source-code">      &lt;div&gt;</p>
			<p class="source-code">        &lt;Link href='/'passHref&gt;</p>
			<p class="source-code">          &lt;a&gt;Back to home&lt;/a&gt;</p>
			<p class="source-code">        &lt;/Link&gt;</p>
			<p class="source-code">      &lt;/div&gt;</p>
			<p class="source-code"><strong class="bold">      &lt;div&gt;</strong></p>
			<p class="source-code"><strong class="bold">        &lt;Widget pageName='about' /&gt;</strong></p>
			<p class="source-code"><strong class="bold">      &lt;/div&gt;</strong></p>
			<p class="source-code">    &lt;/&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p class="source-code">export default AboutPage;</p>
			<p>After this title is <a id="_idIndexMarker135"/>refactored, every time we click on <strong class="bold">Change page title</strong>, Next.js will update the HTML <strong class="source-inline">&lt;title&gt;</strong> element.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">If multiple components are trying to update the same meta tag, Next.js occasionally will duplicate the same tag but with different content. For instance, if we have two components editing the <strong class="source-inline">&lt;title&gt;</strong> tag, we could end up having two distinct <strong class="source-inline">&lt;title&gt;</strong> tags inside our <strong class="source-inline">&lt;head&gt;</strong>. We can avoid that by adding the <strong class="source-inline">key</strong> prop to our HTML tags: </p>
			<p class="callout"><strong class="source-inline">&lt;title key='htmlTitle'&gt;some content&lt;/title&gt;</strong>. This way, Next.js will look for every HTML tag with that specific key and update it instead of adding a new one.</p>
			<p>So far, we've seen how to handle metadata inside our pages and components, but there are cases where you want to use the same meta tags on different components. In those cases, you may not want to rewrite all the metadata from scratch for each component, so here comes the concept of grouping metadata by creating a whole component just for handling that<a id="_idIndexMarker136"/> kind of HTML tag. We'll take a closer look at this approach in the next section.</p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor048"/>Grouping common meta tags</h2>
			<p>At this point, we may <a id="_idIndexMarker137"/>want to add many other meta tags to our website to improve its SEO performance. The problem is that we could easily end up creating huge page components containing basically the same tags. For that reason, it is common practice to create one or more components (depending on your needs) to handle most of the common <strong class="source-inline">head</strong> meta tags.</p>
			<p>Let's say that we want to add a blog section to our website. We may want to add support for open graph data, Twitter cards, and other metadata for our blog posts, so we could easily group all this common data inside a <strong class="source-inline">PostHead</strong> component.</p>
			<p>Let's create a new file, <strong class="source-inline">components/PostHead.js</strong>, and add the following script:</p>
			<p class="source-code">import Head from 'next/head';</p>
			<p class="source-code">function PostMeta(props) {</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;Head&gt;</p>
			<p class="source-code">      &lt;title&gt; {props.title} &lt;/title&gt;</p>
			<p class="source-code">      &lt;meta name="description" content={props.subtitle} /&gt;</p>
			<p class="source-code">      {/* open-graph meta */}</p>
			<p class="source-code">      &lt;meta property="og:title" content={props.title} /&gt;</p>
			<p class="source-code">      &lt;meta property="og:description" </p>
			<p class="source-code">       content={props.subtitle} /&gt;</p>
			<p class="source-code">      &lt;meta property="og:image" content={props.image} /&gt;</p>
			<p class="source-code">      {/* twitter card meta */}</p>
			<p class="source-code">      &lt;meta name="twitter:card" content="summary" /&gt;</p>
			<p class="source-code">      &lt;meta name="twitter:title" content={props.title} /&gt;</p>
			<p class="source-code">      &lt;meta name="twitter:description" </p>
			<p class="source-code">       content={props.description} /&gt;</p>
			<p class="source-code">      &lt;meta name="twitter:image" content={props.image} /&gt;</p>
			<p class="source-code">    &lt;/Head&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p class="source-code">export default PostMeta;</p>
			<p>Now, let's create a <a id="_idIndexMarker138"/>mock for our posts. We will create a new folder called <strong class="source-inline">data</strong> and a file called <strong class="source-inline">posts.js</strong> inside it:</p>
			<p class="source-code">export default [</p>
			<p class="source-code">  {</p>
			<p class="source-code">    id: 'qWD3Pzce',</p>
			<p class="source-code">    slug: 'dog-of-the-day-the-english-setter',</p>
			<p class="source-code">    title: 'Dog of the day: the English Setter',</p>
			<p class="source-code">    subtitle:      'The English Setter dog breed was named </p>
			<p class="source-code">     for these dogs\' practice of "setting", or crouching </p>
			<p class="source-code">     low, when they found birds so hunters could throw </p>
			<p class="source-code">     their nets over them',</p>
			<p class="source-code">    image: 'https://images.unsplash.com/photo-</p>
			<p class="source-code">     1605460375648-278bcbd579a6'</p>
			<p class="source-code">  },</p>
			<p class="source-code">  {</p>
			<p class="source-code">    id: 'yI6BK404',</p>
			<p class="source-code">    slug: 'about-rottweiler',</p>
			<p class="source-code">    title: 'About Rottweiler',</p>
			<p class="source-code">    subtitle:</p>
			<p class="source-code">      "The Rottweiler is a breed of domestic dog, regarded </p>
			<p class="source-code">       as medium-to-large or large. The dogs were known in </p>
			<p class="source-code">       German as Rottweiler Metzgerhund, meaning Rottweil </p>
			<p class="source-code">       butchers' dogs, because their main use was to herd </p>
			<p class="source-code">       livestock and pull carts laden with butchered meat </p>
			<p class="source-code">       to market",</p>
			<p class="source-code">    image: 'https://images.unsplash.com/photo-</p>
			<p class="source-code">     1567752881298-894bb81f9379'</p>
			<p class="source-code">  },</p>
			<p class="source-code">  {</p>
			<p class="source-code">    id: 'VFOyZVyH',</p>
			<p class="source-code">    slug: 'running-free-with-collies',</p>
			<p class="source-code">    title: 'Running free with Collies',</p>
			<p class="source-code">    subtitle:</p>
			<p class="source-code">      'Collies form a distinctive type of herding dogs, </p>
			<p class="source-code">       including many related landraces and standardized </p>
			<p class="source-code">       breeds. The type originated in Scotland and Northern </p>
			<p class="source-code">       England. Collies are medium-sized, fairly lightly-</p>
			<p class="source-code">       built dogs, with pointed snouts. Many types have a </p>
			<p class="source-code">       distinctive white color over the shoulders',</p>
			<p class="source-code">    image: 'https://images.unsplash.com/photo-</p>
			<p class="source-code">     1517662613602-4b8e02886677'</p>
			<p class="source-code">  }</p>
			<p class="source-code">];</p>
			<p>Great! Now we only<a id="_idIndexMarker139"/> need to create a <strong class="source-inline">[slug]</strong> page to display our posts. The full route will be <strong class="source-inline">/blog/[slug]</strong>, so let's create a new file called <strong class="source-inline">[slug].js</strong> inside <strong class="source-inline">pages/blog/</strong> and add the following content:</p>
			<p class="source-code">import PostHead from '../../components/PostHead';</p>
			<p class="source-code">import posts from '../../data/posts';</p>
			<p class="source-code">export function getServerSideProps({ params }) {</p>
			<p class="source-code">  const { slug } = params;</p>
			<p class="source-code">  const post = posts.find((p) =&gt; p.slug === slug);</p>
			<p class="source-code">  return {</p>
			<p class="source-code">    props: {</p>
			<p class="source-code">      post</p>
			<p class="source-code">    }</p>
			<p class="source-code">  };</p>
			<p class="source-code">}</p>
			<p class="source-code">function Post({ post }) {</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;div&gt;</p>
			<p class="source-code">      &lt;PostHead {...post} /&gt;</p>
			<p class="source-code">        &lt;h1&gt;{post.title}&lt;/h1&gt;</p>
			<p class="source-code">        &lt;p&gt;{post.subtitle}&lt;/p&gt;</p>
			<p class="source-code">    &lt;/div&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p class="source-code">export default Post;</p>
			<p>If we now go to http://localhost:3000/blog/dog-of-the-day-the-english-setter and inspect the<a id="_idIndexMarker140"/> resulting HTML, we will see the following tags:</p>
			<p class="source-code">&lt;head&gt;</p>
			<p class="source-code">   ...</p>
			<p class="source-code">  &lt;title&gt; Dog of the day: the English Setter &lt;/title&gt;</p>
			<p class="source-code">  &lt;meta name="description" content="The English Setter dog </p>
			<p class="source-code">   breed was named for these dogs' practice of "setting", </p>
			<p class="source-code">   or crouching low, when they found birds so hunters could </p>
			<p class="source-code">   throw their nets over them"&gt;</p>
			<p class="source-code">  &lt;meta property="og:title" content="Dog of the day: the </p>
			<p class="source-code">   English Setter"&gt;</p>
			<p class="source-code">  &lt;meta property="og:description" content="The English </p>
			<p class="source-code">   Setter dog breed was named for these dogs' practice of </p>
			<p class="source-code">   "setting", or crouching low, when they found birds so </p>
			<p class="source-code">   hunters could throw their nets over them"&gt;</p>
			<p class="source-code">  &lt;meta property="og:image" content=</p>
			<p class="source-code">   "https://images.unsplash.com/photo-1605460375648-</p>
			<p class="source-code">   278bcbd579a6"&gt;</p>
			<p class="source-code">  &lt;meta name="twitter:card" content="summary"&gt;</p>
			<p class="source-code">  &lt;meta name="twitter:title" content="Dog of the day: the </p>
			<p class="source-code">   English Setter"&gt;</p>
			<p class="source-code">  &lt;meta name="twitter:description"&gt;</p>
			<p class="source-code">  &lt;meta name="twitter:image" content=</p>
			<p class="source-code">   "https://images.unsplash.com/photo-1605460375648-</p>
			<p class="source-code">   278bcbd579a6"&gt;</p>
			<p class="source-code">...</p>
			<p class="source-code">&lt;/head&gt;</p>
			<p>Now, try to browse other blog posts and see how the HTML content changes for each one of them.</p>
			<p>This approach is not mandatory, but it allows you to logically separate head-related components from other components, leading to a more organized code base.</p>
			<p>But what if we need the same meta tags (or, at least, some common basic data) on every page? We<a id="_idIndexMarker141"/> don't actually need to rewrite every single tag or import a common component on each page. We'll see in the next section how to avoid that by customizing our <strong class="source-inline">_app.js</strong> file.</p>
			<h1 id="_idParaDest-50"><a id="_idTextAnchor049"/>Customizing _app.js and _document.js pages</h1>
			<p>There are<a id="_idIndexMarker142"/> certain <a id="_idIndexMarker143"/>cases where you need to take control over page initialization, so that every time we render a page, Next.js will need to run certain operations before sending the resulting HTML to the client. To do that, the framework allows us to create two new files, called <strong class="source-inline">_app.js</strong> and <strong class="source-inline">_document.js</strong>, inside our <strong class="source-inline">pages/</strong> directory.</p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor050"/>The _app.js page</h2>
			<p>By default, Next.js ships with the following <a href="http://pages/_app.js">pages/_app.js</a> file:</p>
			<p class="source-code">import '../styles/globals.css'</p>
			<p class="source-code">function MyApp({ Component, pageProps }) {</p>
			<p class="source-code">  return &lt;Component {...pageProps} /&gt;</p>
			<p class="source-code">}</p>
			<p class="source-code">export default MyApp</p>
			<p>As you can see, the function is just returning the Next.js page component (the <strong class="source-inline">Component</strong> prop) and its props (<strong class="source-inline">pageProps</strong>). </p>
			<p>But now, let's say that we want to share a navigation bar between all the pages without manually importing that component on each page. We can start by creating the navbar inside <strong class="source-inline">components/Navbar.js</strong>:</p>
			<p class="source-code">import Link from 'next/link';</p>
			<p class="source-code">function Navbar() {</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;div</p>
			<p class="source-code">      style={{</p>
			<p class="source-code">        display: 'flex',</p>
			<p class="source-code">        flexDirection: 'row',</p>
			<p class="source-code">        justifyContent: 'space-between',</p>
			<p class="source-code">        marginBottom: 25</p>
			<p class="source-code">      }}</p>
			<p class="source-code">    &gt;</p>
			<p class="source-code">      &lt;div&gt;My Website&lt;/div&gt;</p>
			<p class="source-code">      &lt;div&gt;</p>
			<p class="source-code">        &lt;Link href="/"&gt;Home &lt;/Link&gt;</p>
			<p class="source-code">        &lt;Link href="/about"&gt;About &lt;/Link&gt;</p>
			<p class="source-code">        &lt;Link href="/contacts"&gt;Contacts &lt;/Link&gt;</p>
			<p class="source-code">      &lt;/div&gt;</p>
			<p class="source-code">    &lt;/div&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p class="source-code">export default Navbar;</p>
			<p>That is a really simple navigation bar with just three links that will allow us to navigate our website.</p>
			<p>Now, we need to <a id="_idIndexMarker144"/>import it inside our <strong class="source-inline">_app.js</strong> page as follows:</p>
			<p class="source-code">import Navbar from '../components/Navbar';</p>
			<p class="source-code">function MyApp({ Component, pageProps }) {</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;&gt;</p>
			<p class="source-code">        &lt;Navbar /&gt;</p>
			<p class="source-code">        &lt;Component {...pageProps} /&gt;</p>
			<p class="source-code">    &lt;/&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p class="source-code">export default MyApp;</p>
			<p>If we now create two more pages (<strong class="source-inline">about.js</strong> and <strong class="source-inline">contacts.js</strong>), we will see that the navbar component will be rendered on any page.</p>
			<p>Now, let's make it a bit more complex by adding support for both dark and light themes. We'll do that by creating a React context and wrapping the <strong class="source-inline">&lt;Component /&gt;</strong> component inside our <strong class="source-inline">_app.js</strong> file.</p>
			<p>Let's start by creating a context in <strong class="source-inline">components/themeContext.js</strong>:</p>
			<p class="source-code">import { createContext } from 'react';</p>
			<p class="source-code">const ThemeContext = createContext({</p>
			<p class="source-code">  theme: 'light',</p>
			<p class="source-code">  toggleTheme: () =&gt; null</p>
			<p class="source-code">});</p>
			<p class="source-code">export default ThemeContext;</p>
			<p>Now let's go back to our <strong class="source-inline">_app.js</strong> file and create the theme state, inline CSS styles, and wrap the page<a id="_idIndexMarker145"/> component in a context provider:</p>
			<p class="source-code"><strong class="bold">import { useState } from 'react';</strong></p>
			<p class="source-code"><strong class="bold">import ThemeContext from '../components/themeContext';</strong></p>
			<p class="source-code">import Navbar from '../components/Navbar';</p>
			<p class="source-code"><strong class="bold">const themes = {</strong></p>
			<p class="source-code"><strong class="bold">  dark: {</strong></p>
			<p class="source-code"><strong class="bold">    background: 'black',</strong></p>
			<p class="source-code"><strong class="bold">    color: 'white'</strong></p>
			<p class="source-code"><strong class="bold">  },</strong></p>
			<p class="source-code"><strong class="bold">  light: {</strong></p>
			<p class="source-code"><strong class="bold">    background: 'white',</strong></p>
			<p class="source-code"><strong class="bold">    color: 'black'</strong></p>
			<p class="source-code"><strong class="bold">  }</strong></p>
			<p class="source-code"><strong class="bold">};</strong></p>
			<p class="source-code">function MyApp({ Component, pageProps }) {</p>
			<p class="source-code"><strong class="bold">  const [theme, setTheme] = useState('light');</strong></p>
			<p class="source-code"><strong class="bold">  const toggleTheme = () =&gt; {</strong></p>
			<p class="source-code"><strong class="bold">    setTheme(theme === 'dark' ? 'light' : 'dark');</strong></p>
			<p class="source-code"><strong class="bold">  };</strong></p>
			<p class="source-code">  return (</p>
			<p class="source-code"><strong class="bold">    &lt;ThemeContext.Provider value={{ theme, toggleTheme }}&gt;</strong></p>
			<p class="source-code"><strong class="bold">      &lt;div</strong></p>
			<p class="source-code"><strong class="bold">        style={{</strong></p>
			<p class="source-code"><strong class="bold">          width: '100%',</strong></p>
			<p class="source-code"><strong class="bold">          minHeight: '100vh',</strong></p>
			<p class="source-code"><strong class="bold">          ...themes[theme]</strong></p>
			<p class="source-code"><strong class="bold">        }}</strong></p>
			<p class="source-code"><strong class="bold">      &gt;</strong></p>
			<p class="source-code">        &lt;Navbar /&gt;</p>
			<p class="source-code">        &lt;Component {...pageProps} /&gt;</p>
			<p class="source-code">      &lt;/div&gt;</p>
			<p class="source-code"><strong class="bold">    &lt;/ThemeContext.Provider&gt;</strong></p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p class="source-code">export default MyApp;</p>
			<p>Last but not least, we<a id="_idIndexMarker146"/> need to add a button for toggling dark/light themes. We're going to add it to our navigation bar, so let's open the <strong class="source-inline">components/Navbar.js</strong> file and add the following code:</p>
			<p class="source-code"><strong class="bold">import { useContext } from 'react';</strong></p>
			<p class="source-code">import Link from 'next/link';</p>
			<p class="source-code"><strong class="bold">import themeContext from '../components/themeContext';</strong></p>
			<p class="source-code">function Navbar() {</p>
			<p class="source-code"><strong class="bold">  const { toggleTheme, theme } = useContext(themeContext);</strong></p>
			<p class="source-code"><strong class="bold">  const newThemeName = theme === 'dark' ? 'light' : 'dark';</strong></p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;div</p>
			<p class="source-code">      style={{</p>
			<p class="source-code">        display: 'flex',</p>
			<p class="source-code">        flexDirection: 'row',</p>
			<p class="source-code">        justifyContent: 'space-between',</p>
			<p class="source-code">        marginBottom: 25</p>
			<p class="source-code">      }}</p>
			<p class="source-code">    &gt;</p>
			<p class="source-code">      &lt;div&gt;My Website&lt;/div&gt;</p>
			<p class="source-code">      &lt;div&gt;</p>
			<p class="source-code">        &lt;Link href="/"&gt;Home &lt;/Link&gt;</p>
			<p class="source-code">        &lt;Link href="/about"&gt;About &lt;/Link&gt;</p>
			<p class="source-code">        &lt;Link href="/contacts"&gt;Contacts &lt;/Link&gt;</p>
			<p class="source-code">        <strong class="bold">&lt;button onClick={toggleTheme}&gt;</strong></p>
			<p class="source-code"><strong class="bold">          Set {newThemeName} theme</strong></p>
			<p class="source-code">        <strong class="bold">&lt;/button&gt;</strong></p>
			<p class="source-code">      &lt;/div&gt;</p>
			<p class="source-code">    &lt;/div&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p class="source-code">export default Navbar;</p>
			<p>If you try to toggle the dark theme, and then navigate between all the website pages using the navigation bar, you will see that Next.js keeps the theme state consistent between every route.</p>
			<p>One important thing to remember when customizing the <strong class="source-inline">_app.js</strong> page is that it is not meant for running data fetching using <strong class="source-inline">getServerSideProps</strong> or <strong class="source-inline">getStaticProps</strong>, as other pages do. Its main use cases are maintaining state between pages during navigation (dark/light themes, items in a cart, and so on), adding global styles, handling page layouts, or adding additional data to the page props.</p>
			<p>If, for some reason, you absolutely need to fetch data on the server side every time you want to render a page, you can still use the built-in <strong class="source-inline">getInitialProps</strong> function, but it has a cost. You'll lose automatic static optimization in dynamic pages, as Next.js will need to perform server-side rendering for every single page.</p>
			<p>If that cost is <a id="_idIndexMarker147"/>acceptable for your web app, you can easily use that built-in method as follows:</p>
			<p class="source-code">import App from 'next/app'</p>
			<p class="source-code">function MyApp({ Component, pageProps }) {</p>
			<p class="source-code">  return &lt;Component {...pageProps} /&gt;</p>
			<p class="source-code">};</p>
			<p class="source-code">MyApp.getInitialProps = async (appContext) =&gt; {</p>
			<p class="source-code">  const appProps = await App.getInitialProps(appContext);</p>
			<p class="source-code">  const additionalProps = await fetch(...) </p>
			<p class="source-code">  return {</p>
			<p class="source-code">    ...appProps,</p>
			<p class="source-code">    ...additionalProps</p>
			<p class="source-code">  }</p>
			<p class="source-code">};</p>
			<p class="source-code">export default MyApp;</p>
			<p>While a custom <strong class="source-inline">_app.js</strong> file allows us to customize the way we render page components, there might be cases where it cannot help; for example, when we need to customize HTML <a id="_idIndexMarker148"/>tags such as <strong class="source-inline">&lt;html&gt; </strong>or <strong class="source-inline">&lt;body&gt;</strong>. We will learn how to do that right in the next section.</p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor051"/>The _document.js page</h2>
			<p>When we're<a id="_idIndexMarker149"/> writing Next.js page components, we don't need to define fundamental HTML tags, such as <strong class="source-inline">&lt;head&gt;</strong>, <strong class="source-inline">&lt;html&gt;</strong>, or <strong class="source-inline">&lt;body&gt;</strong>. We've already seen how to customize the <strong class="source-inline">&lt;head&gt;</strong> tag using the <strong class="source-inline">Head</strong> component, but we will need a change of approach for both <strong class="source-inline">&lt;html&gt;</strong> and <strong class="source-inline">&lt;body&gt;</strong>tags.</p>
			<p>In order to render those two essential tags, Next.js uses a built-in class called <strong class="source-inline">Document</strong>, and it allows us to extend it by creating a new file called <strong class="source-inline">_document.js</strong> inside our <strong class="source-inline">pages/</strong> directory, just like we do for our <strong class="source-inline">_app.js</strong> file:</p>
			<p class="source-code">import Document,{</p>
			<p class="source-code">    Html,</p>
			<p class="source-code">    Head,</p>
			<p class="source-code">    Main,</p>
			<p class="source-code">    NextScript</p>
			<p class="source-code">  } from 'next/document';</p>
			<p class="source-code">class MyDocument extends Document {</p>
			<p class="source-code">  static async getInitialProps(ctx) {</p>
			<p class="source-code">    const initialProps =</p>
			<p class="source-code">      await Document.getInitialProps(ctx);</p>
			<p class="source-code">    return { ...initialProps };</p>
			<p class="source-code">  }</p>
			<p class="source-code">  render() {</p>
			<p class="source-code">    return (</p>
			<p class="source-code">      &lt;Html&gt;</p>
			<p class="source-code">        &lt;Head /&gt;</p>
			<p class="source-code">        &lt;body&gt;</p>
			<p class="source-code">          &lt;Main /&gt;</p>
			<p class="source-code">          &lt;NextScript /&gt;</p>
			<p class="source-code">        &lt;/body&gt;</p>
			<p class="source-code">      &lt;/Html&gt;</p>
			<p class="source-code">    );</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">export default MyDocument;</p>
			<p>Let's break down<a id="_idIndexMarker150"/> the <strong class="source-inline">_document.js</strong> page we've just created. First, we start by importing the <strong class="source-inline">Document</strong> class, which we're going to extend to add our custom scripts. We then import four mandatory components in order for our Next.js application to work:</p>
			<ul>
				<li><strong class="source-inline">Html</strong>: The <strong class="source-inline">&lt;html&gt;</strong> tag for our Next.js application. We can pass any standard HTML property (such as <strong class="source-inline">lang</strong>) to it as a prop.</li>
				<li><strong class="source-inline">Head</strong>: We can use this component for all the tags common to all the application pages. This is <em class="italic">not</em> the <strong class="source-inline">Head</strong> component we've seen in the previous chapter. They behave similarly, but we should use it only for code that is common to all the website pages.</li>
				<li><strong class="source-inline">Main</strong>: This will be the place where Next.js renders our page components. The browser won't initialize every component outside <strong class="source-inline">&lt;Main&gt;</strong>, so if we need to share common components between our pages, we should place them inside the <strong class="source-inline">_app.js</strong> file. </li>
				<li><strong class="source-inline">NextScript</strong>: If you've tried to inspect an HTML page generated by Next.js, you may have noticed that it adds some custom JavaScript scripts to your markup. Inside those scripts, we can find all the code required to run client-side logic, React hydration, and so on.</li>
			</ul>
			<p>Removing any of the preceding four components will break our Next.js application, so make sure to import them before editing your <strong class="source-inline">_document.js</strong> page.</p>
			<p>Just like <strong class="source-inline">_app.js</strong>, <strong class="source-inline">_document.js</strong> does not support server-side data fetching methods such as <strong class="source-inline">getServerSideProps</strong> and <strong class="source-inline">getStaticProps</strong>. We still get access to the <strong class="source-inline">getInitialProps</strong> method, but we should avoid putting data fetching functions inside it as this would disable automatic site optimization, forcing the server to server-side render <a id="_idIndexMarker151"/>the page on each request.</p>
			<p>Summary</p>
			<p>In this chapter, we've covered many important concepts that make Next.js a great framework to work with. We now know how to serve images correctly and with minimum effort, navigate between pages by pre-fetching the destination page, dynamically create and delete custom metadata, and create dynamic routes to make the user experience even more dynamic. We've also taken a look at customizing the <strong class="source-inline">_app.js</strong> and <strong class="source-inline">_document.js</strong> files, which will allow us to keep our user interface consistent between all the application pages with minimum effort.</p>
			<p>So far, we've always avoided calling external REST APIs, as it introduces an extra layer of complexity for our application. We will cover this topic in the next chapter, understanding how to integrate <em class="italic">REST</em> and <em class="italic">GraphQL</em> APIs on both the client and server sides.</p>
		</div>
	</body></html>