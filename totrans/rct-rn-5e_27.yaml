- en: '25'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '25'
- en: Displaying Modal Screens
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示模态屏幕
- en: The goal of this chapter is to show you how to present information to the user
    in ways that don’t disrupt the current page. Pages use a `View` component and
    render it directly on the screen. There are times, however, when there’s important
    information that the user needs to see but you don’t necessarily want to kick
    them off the current page.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是向您展示如何以不干扰当前页面的方式向用户展示信息。页面使用`View`组件并将其直接渲染到屏幕上。然而，有时会有一些重要的信息用户需要看到，但你又不想让他们离开当前页面。
- en: 'You’ll start by learning how to display important information. By knowing what
    information is important and when to use it, you’ll learn how to get user acknowledgment:
    both for error and success scenarios. Then, you’ll implement passive notifications
    that show the user that something has happened. Finally, you’ll implement **modal
    views** that show that something is happening in the background.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从学习如何显示重要信息开始。通过了解哪些信息是重要的以及何时使用它，你将学习如何获取用户的确认：既适用于错误场景也适用于成功场景。然后，你将实现被动通知，向用户显示发生了某些事情。最后，你将实现**模态视图**，显示后台正在发生的事情。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Terminology definitions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 术语定义
- en: Getting user confirmation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取用户确认
- en: Passive notifications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被动通知
- en: Activity modals
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 活动模态
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter2](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter24)5.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章的代码文件，链接为[https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter2](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter24)。
- en: Terminology definitions
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 术语定义
- en: 'Before you dive into implementing alerts, notifications, and confirmations,
    let’s take a few minutes and think about what each of these items means. I think
    this is important because if you end up passively notifying the user about an
    error, it can easily get missed. Here are my definitions of the types of information
    that you’ll want to display:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始实现警告、通知和确认之前，让我们花几分钟时间思考一下每一项的含义。我认为这很重要，因为如果你只是被动地通知用户关于错误的信息，它很容易被忽略。以下是我对您希望显示的信息类型的定义：
- en: '**Alert**: Something important just happened, and you need to ensure that the
    user sees what’s going on. Possibly, the user needs to acknowledge the alert.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**警告**：刚刚发生了一些重要的事情，你需要确保用户能看到正在发生的情况。可能的话，用户需要确认这个警告。'
- en: '**Confirmation**: This is part of an alert. For example, if the user has just
    performed an action and then wants to make sure that it was successful before
    carrying on, they would have to confirm that they’ve seen the information in order
    to close the modal. A confirmation can also exist within an alert, warning the
    user about an action that they’re about to perform.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**确认**：这是警告的一部分。例如，如果用户刚刚执行了一个操作，然后想要在继续之前确保操作成功，他们必须确认他们已经看到了信息，以便关闭模态框。确认也可以存在于警告中，提醒用户即将执行的操作。'
- en: '**Notification**: Something happened but it’s not important enough to completely
    block what the user is doing. These typically go away on their own.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通知**：发生了一些事情，但并不足以完全阻止用户正在进行的活动。这些通常会在自己消失。'
- en: The trick is to try to use notifications where the information is good to know
    but not critical. Use confirmations only when the workflow of the feature cannot
    continue without the user acknowledging what’s going on. In the following sections,
    you’ll see examples of alerts and notifications that are used for different purposes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 技巧在于尝试在信息值得了解但不是关键的情况下使用通知。只有在功能的工作流程无法在没有用户确认正在发生的事情的情况下继续时，才使用确认。在接下来的章节中，你将看到用于不同目的的警告和通知的示例。
- en: Getting user confirmation
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取用户确认
- en: In this section, you’ll learn how to show modal views in order to get confirmation
    from the user. First, you’ll learn how to implement a successful scenario, where
    an action generates a successful outcome that you want the user to be aware of.
    Then, you’ll learn how to implement an error scenario where something went wrong
    and you don’t want the user to move forward without acknowledging the issue.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何显示模态视图以获取用户的确认。首先，你将学习如何实现一个成功的场景，其中操作产生了一个成功的成果，你希望用户意识到这一点。然后，你将学习如何实现一个错误场景，其中出了问题，你不想让用户在没有确认问题的情况下继续前进。
- en: Displaying a success confirmation
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示成功确认
- en: 'Let’s start by implementing a modal view that’s displayed as a result of the
    user successfully performing an action. Here’s the `Modal` component, which is
    used to show the user a **confirmation modal**:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从实现一个作为用户成功执行操作的结果显示的模态视图开始。这是`Modal`组件，用于向用户展示**确认模态**：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The properties that are passed to `ConfirmationModal` are forwarded to the
    React Native `Modal` component. You’ll see why in a moment. First, let’s see what
    this confirmation modal looks like:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`ConfirmationModal`的属性被转发到React Native的`Modal`组件。你很快就会明白原因。首先，让我们看看这个确认模态的外观：
- en: '![Picture 1](img/B19636_25_01.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片 1](img/B19636_25_01.png)'
- en: 'Figure 25.1: The confirmation modal'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图25.1：确认模态
- en: 'The modal that’s displayed once the user completes an action uses our own styling
    and confirmation message. It also has two actions, but it may only need one, depending
    on whether this confirmation is pre-action or post-action. Here are the styles
    that are being used for this modal:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 用户完成操作后显示的模态使用我们自己的样式和确认消息。它还有两个操作，但根据这个确认是预操作还是后操作，可能只需要一个。以下是用于此模态的样式：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With the React Native `Modal` component, it’s pretty much up to you how you
    want your confirmation modal view to look. Think of them as regular views, with
    the only difference being that they’re rendered on top of other views.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用React Native的`Modal`组件，你几乎可以随心所欲地设计你的确认模态视图的外观。把它们想象成常规视图，唯一的区别是它们是在其他视图之上渲染的。
- en: 'A lot of the time, you might not care to style your own modal views. For example,
    in web browsers, you can simply call the `alert()` function, which shows text
    in a window that’s styled by the browser. React Native has something similar:
    `Alert.alert()`. This is how we can open a native alert:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，你可能不会关心自己模态视图的样式。例如，在网页浏览器中，你可以简单地调用`alert()`函数，该函数在浏览器设置的窗口中显示文本。React
    Native有类似的东西：`Alert.alert()`。这就是我们如何打开原生警告框的方式：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here’s what the alert looks like on iOS:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这是iOS上警告的显示效果：
- en: '![Picture 2](img/B19636_25_02.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片 2](img/B19636_25_02.png)'
- en: 'Figure 25.2: A confirmation alert on iOS'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图25.2：iOS上的确认警告
- en: 'In terms of functionality, there’s nothing really different here. There is
    a title and text beneath it, but that’s something that can easily be added to
    a modal view if you wanted. The real difference is that this modal looks like
    an iOS modal instead of something that’s styled by the app. Let’s see how this
    alert appears on Android:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在功能方面，这里并没有什么真正的区别。这里有一个标题和其下的文本，但如果你想要的话，这些可以很容易地添加到模态视图中。真正的区别在于，这个模态看起来像iOS模态，而不是由应用设置的样式。让我们看看这个警告在Android上的显示效果：
- en: '![Picture 3](img/B19636_25_03.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片 3](img/B19636_25_03.png)'
- en: 'Figure 25.3: A confirmation alert on Android'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图25.3：Android上的确认警告
- en: This modal looks like an Android modal, and you didn’t have to style it. I think
    using alerts over modals is a better choice most of the time. It makes sense to
    have something styled to look like it’s part of iOS or Android. However, there
    are times when you need more control over how the modal looks, such as when displaying
    error confirmations.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模态看起来像Android模态，你不需要为其设置样式。我认为大多数情况下，使用警告框而不是模态框是更好的选择。让某些东西看起来像是iOS或Android的一部分是有意义的。然而，有时你需要更多控制模态的外观，例如在显示错误确认时。
- en: The approach to rendering modals is different from the approach to rendering
    alerts. However, they’re both still declarative components that change based on
    the changing property values.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染模态的方法与渲染警告的方法不同。然而，它们仍然是基于属性值变化的声明式组件。
- en: Error confirmation
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误确认
- en: 'All of the principles you learned about in the *Displaying a success confirmation*
    section are applicable when you need the user to acknowledge an error. If you
    need more control of the display, use a modal. For example, you might want the
    modal to be red and scary-looking, like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在*显示成功确认*部分学到的所有原则，在你需要用户确认错误时都是适用的。如果你需要更多控制显示方式，请使用模态框。例如，你可能想让模态框看起来是红色的，令人害怕的，就像这样：
- en: '![Picture 4](img/B19636_25_04.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片 4](img/B19636_25_04.png)'
- en: 'Figure 25.4: The error confirmation modal'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图25.4：错误确认模态
- en: 'Here are the styles that were used to create this look. Maybe you want something
    a bit more subtle, but the point is that you can make this look however you want:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建此外观所使用的样式。也许你想要更微妙一些，但重点是你可以按照自己的意愿来制作这个外观：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the `modalInner` style property, we’ve defined screen styles. Next, we’ll
    define modal styles:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在`modalInner`样式属性中，我们定义了屏幕样式。接下来，我们将定义模态样式：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The same modal styles that you used for the success confirmations are still
    here. That’s because the error confirmation modal needs many of the same style
    properties.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你用于成功确认的相同模态样式仍然在这里。这是因为错误确认模态需要许多相同的样式属性。
- en: 'Here’s how you apply both to the `Modal` component:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何将两者应用到`Modal`组件上：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The styles are combined as arrays before they’re passed to the `style` component
    property. The styles error always comes last, since conflicting style properties,
    such as `backgroundColor`, will be overridden by whatever comes later in the array.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 样式在传递给`style`组件属性之前被组合成数组。错误样式总是放在最后，因为如`backgroundColor`这样的冲突样式属性将被数组中后面的样式覆盖。
- en: 'In addition to styles in error confirmations, you can include whatever advanced
    controls you want. It really depends on how your application lets users cope with
    errors: for example, maybe there are several courses of action that can be taken.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 除了错误确认中的样式外，你还可以包括你想要的任何高级控件。这完全取决于你的应用程序如何让用户处理错误：例如，可能有一些可以采取的行动方案。
- en: 'However, the more common case is that something went wrong, and there’s nothing
    you can do about it besides making sure that the user is aware of the situation.
    In these cases, you can probably get away with just displaying an alert:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，更常见的情况是出了些问题，除了确保用户意识到这种情况外，你无能为力。在这些情况下，你可能只需显示一个警告：
- en: '![Picture 5](img/B19636_25_05.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片 5](img/B19636_25_05.png)'
- en: 'Figure 25.5: An error alert'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图25.5：错误警告
- en: Now that you’re able to display error notifications that require user engagement,
    it’s time to learn about less aggressive notifications that don’t disrupt what
    the user is currently doing.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经能够显示需要用户参与的错误通知了，是时候了解不那么激进的、不会打断用户当前操作的通知了。
- en: Passive notifications
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 被动通知
- en: The notifications you’ve examined so far in this chapter all have required input
    from the user. This is by design because it’s important information that you’re
    forcing the user to look at. However, you don’t want to overdo this. For notifications
    that are important but not life-altering if ignored, you can use **passive notifications**.
    These are displayed in a less obtrusive way than modals and don’t require any
    user action to dismiss them.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中你检查到的所有通知都需要用户的输入。这是出于设计考虑，因为这是重要的信息，你正在强迫用户查看。然而，你不想做得太过分。对于重要但忽略后不会改变生活的重要性的通知，你可以使用**被动通知**。这些通知以一种不那么引人注目的方式显示，并且不需要任何用户操作来关闭它们。
- en: In this section, you’ll create an app that uses the **Toast API** provided by
    the `react-native-root-toast` library. It’s called the Toast API because the information
    that’s displayed looks like a piece of toast popping up. `Toasts` is a common
    component in Android to show some basic information that does not require user
    response. Since there is no Toast API for iOS, we will use a library that implements
    a similar API that works well on both platforms.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将创建一个使用`react-native-root-toast`库提供的**Toast API**的应用程序。之所以称为Toast API，是因为显示的信息看起来像一块弹出的吐司。`Toast`是Android中显示一些不需要用户响应的基本信息的常用组件。由于iOS没有Toast
    API，我们将使用一个在两个平台上都运行良好的类似API的库。
- en: 'Here’s what the `App` component looks like:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`App`组件的样式：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: First we should wrap our app in the `RootSiblingParent` component and then we
    are ready to work with Toast API. To open a toast, we call the `Toast.show` method.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该将我们的应用程序包裹在`RootSiblingParent`组件中，然后我们就可以开始使用Toast API了。要打开一个Toast，我们调用`Toast.show`方法。
- en: 'Here’s what the Toast notification looks like:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是Toast通知的样式：
- en: '![](img/B19636_25_06.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片 B19636_25_06](img/B19636_25_06.png)'
- en: 'Figure 25.6: An Android toast'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图25.6：Android的Toast
- en: A notification stating **Something happened!** is displayed at the bottom of
    the screen and is removed after a short delay. The key is that the notification
    is unobtrusive.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕底部显示一条通知，内容为**发生了某些事情**！，并在短时间内消失。关键是通知不会太引人注目。
- en: 'Let’s take a look at how the same toasts look on an iOS device:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看相同的Toast在iOS设备上的样子：
- en: '![](img/B19636_25_07.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片 B19636_25_07](img/B19636_25_07.png)'
- en: 'Figure 25.7: An iOS notification'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图25.7：iOS的通知
- en: In the next section, you’ll learn about activity modals, which show the user
    that something is happening.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将了解活动模态，它向用户显示正在发生的事情。
- en: Activity modals
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动模态
- en: 'In this final section of this chapter, you’ll implement a modal that shows
    a progress indicator. The idea is to display the modal and then hide it when the
    promise resolves. Here’s the code for the generic `Activity` component, which
    shows a modal with `ActivityIndicator`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，您将实现一个显示进度指示器的模态框。想法是显示模态框，然后在promise解析时隐藏它。以下是通用`Activity`组件的代码，它显示带有`ActivityIndicator`的模态框：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You might be tempted to pass the promise to the component so that it automatically
    hides when the promise resolves. I don’t think this is a good idea because then
    you would have to introduce the state into this component. Furthermore, it would
    depend on a promise in order to function. With the way you’ve implemented this
    component, you can show or hide the modal based on the `visible` property alone.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想将promise传递给组件，以便它在promise解析时自动隐藏。我认为这不是一个好主意，因为那样您就必须将状态引入此组件。此外，它将依赖于promise才能运行。按照您实现此组件的方式，您可以根据`visible`属性单独显示或隐藏模态框。
- en: 'Here’s what the activity modal looks like on iOS:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是iOS上活动模态的显示效果：
- en: '![Picture 8](img/B19636_25_08.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片8](img/B19636_25_08.png)'
- en: 'Figure 25.8: An activity modal'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图25.8：活动模态
- en: 'There’s a semi-transparent background on the modal that’s placed over the main
    view with the **Fetch Stuff...** link. By clicking on this link, we will be shown
    the **activity loader**. Here’s how this effect is created in `styles.js`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在覆盖主视图的模态窗口上有一个半透明的背景，其中包含**Fetch Stuff...**链接。点击此链接，我们将看到**活动加载器**。以下是`styles.js`中创建此效果的方法：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Instead of setting the actual `Modal` component to transparent, you can set
    the transparency in `backgroundColor`, which gives the look of an overlay. Now,
    let’s take a look at the code that controls this component:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是将实际的`Modal`组件设置为透明，您可以在`backgroundColor`中设置透明度，这样看起来就像是一个覆盖层。现在，让我们看看控制此组件的代码：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When the fetch link is pressed, a new promise is created that simulates asynchronous
    network activity. Then, when the promise resolves, you can change the `fetching`
    state back to `false` so that the activity dialog is hidden.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当按下获取链接时，会创建一个新的promise来模拟异步网络活动。然后，当promise解析时，您可以更改`fetching`状态回`false`，以便隐藏活动对话框。
- en: Summary
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the need to show important information to
    mobile users. This sometimes involves explicit feedback from the user, even if
    that just means acknowledging the message. In other cases, passive notifications
    work better, since they’re less obtrusive than confirmation modals.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了向移动用户显示重要信息的需求。这有时需要用户的明确反馈，即使只是承认消息。在其他情况下，被动通知效果更好，因为它们比确认模态不那么侵扰。
- en: 'There are two tools that we can use to display messages to users: modals and
    alerts. Modals are more flexible because they’re just like regular views. Alerts
    are good for displaying plain text, and they take care of styling concerns for
    us. On Android, we have the `ToastAndroid` interface as well. We saw that it’s
    also possible to do this on iOS, but it just requires more work.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用两种工具向用户显示消息：模态框和警告框。模态框更灵活，因为它们就像常规视图一样。警告框适合显示纯文本，并且会为我们处理样式问题。在Android上，我们还有`ToastAndroid`接口。我们看到了在iOS上也可以这样做，但这需要更多的工作。
- en: In the next chapter, we’ll dig deeper into the gesture response system inside
    React Native, which makes for a better mobile experience than browsers can provide.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地探讨React Native内部的手势响应系统，这比浏览器能提供的移动体验更好。
