- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction to Advanced Vue.js Techniques – Slots, Lifecycle, and Template
    Refs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, we have learned about the basic features and techniques offered
    by Vue.js. Things such as properties and computed are the foundation of the Vue.js
    framework and will be used daily as you develop your next application with Vue.js.
    In this chapter, we are going to cover a few features that are what I call “advanced.”
    This is not described as “advanced” because of its complexity, but in the fact
    that you will be less likely to use this daily. Features such as slots and Template
    Refs are used to solve specific use cases and are not expected to be encountered
    during your average task but are more likely to be used for specific situations
    that occur less frequently during a project. What you will learn in this chapter
    may not be used for quite some time, so it would be good to remember its existence
    and make sure you come back to it if the need for any of these features arises
    in your task.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to add yet more features to our Companion App.
    We are first going to enhance our base button to introduce the notion of slots.
    Next, we will create a shared layout to be used in our static pages using named
    slots. Then, we will turn our attention to adding a new feature that will allow
    us to add new posts. While doing so, we are going to learn how to use Template
    Ref to access the `CreatePost.vue` component. To conclude the chapter, we are
    going to build a completely new feature that will allow us to expand and collapse
    our sidebar. While doing so, we are not only going to iterate over the Vue.js
    lifecycles hooks but we are also using this opportunity to go over previously
    learned techniques such as methods, dynamic classes, and directives.
  prefs: []
  type: TYPE_NORMAL
- en: 'The chapter will be divided into the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: The power of slots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing components elements with Template Refs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deep diving into the lifecycle of a real app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to use components that offer slots
    and develop components that expose one or multiple slots. You will also be able
    to access an element within a component with the use of Template Refs and finally
    be able to make better decisions when using lifecycles, to ensure that the application
    is free of bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, the branch is called `CH09`. To pull this branch, run the
    following command or use your GUI of choice to support you in this operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The code files for the chapter can be found at [https://github.com/PacktPublishing/Vue.js-3-for-Beginners](https://github.com/PacktPublishing/Vue.js-3-for-Beginners).
  prefs: []
  type: TYPE_NORMAL
- en: The power of slots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first few chapters of this book, we have learned how properties and events
    can be used for a parent and a child to communicate with each other. This method
    of communication is not very flexible, as the only way for a component to expose
    information is by creating a new property.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, the rigidity that properties provide is precisely what we want
    to make sure that our component renders correctly, but there are times when more
    flexibility is needed, and this is where slots come in.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider our base button component. Its look and feel are defined by its
    properties and so is its value, but what would happen if we wanted to create a
    button with an icon before its value?
  prefs: []
  type: TYPE_NORMAL
- en: With our current knowledge of Vue.js, we would resort to creating a new prop
    of icon (`prependIcon`) that accepts an icon. Then, a further requirement may
    need us to add an icon after the value, so we would again resort to a new property
    of icon (`appendIcon`). Each additional request may result in a new property making
    our component very hard to maintain. Luckily, all the preceding requirements can
    be solved using slots.
  prefs: []
  type: TYPE_NORMAL
- en: Slots turn your component into a wrapper, allowing people to pass any arbitrary
    HTML or components into it. Slots are nothing new; in fact, native HTML offers
    a very similar functionality that you have been using automatically without knowing
    it. `<div>` is just a wrapper to other elements, `<h1>` can include text but also
    other elements in its content, and the list can go on.
  prefs: []
  type: TYPE_NORMAL
- en: The same functionality that a native button, heading, or span offers is also
    offered by Vue.js slots.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider how we would use a button in HTML. We would open the element
    with `<button>` and then we would add something within its content – this could
    be simple text, another element, or both. Finally, we would close the element
    with `</button>`, just like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Well, the `My button` text and the `<icon>` element displayed in the previous
    code snippets are what we refer to in Vue.js as **slot content**. As previously
    mentioned, using properties is a great way to ensure that the values passed to
    the component are of a certain type, but this advantage can easily turn into a
    disadvantage that makes the component quite rigid.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how to use slots by modifying `TheButton.vue`. We are going to remove
    the property called value and replace it with a slot so that our button will act
    as a native HTML button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s modify our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: First, we removed the property called `value` from the `defineProps` object,
    and then we added a slot in our component template by adding a Vue.js element
    called `<slot>`. This element does not need to be imported as it is accessible
    globally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to find all the occurrences of `TheButton` and replace the syntax
    from the previous one that used the property value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to replace this with the new one that uses a slot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding change needs to happen in `CreatePost.vue`, `SocialPost.vue`,
    and `Sidebar.vue`.
  prefs: []
  type: TYPE_NORMAL
- en: Slots are more than just text
  prefs: []
  type: TYPE_NORMAL
- en: Remember that now our component value not only accepts text, but it can also
    accept other HTML elements and Vue components.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the basics of slots, let’s move on and learn about them in
    more detail, starting with the slot default value.
  prefs: []
  type: TYPE_NORMAL
- en: Adding default values to a slot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Vue.js slots not only allow us to replicate native functionalities, but they
    also offer some extra features, one of which is the ability to add default values
    to our slots. This could either be a dialog heading or the text shown in a form
    submit button; default values can help you keep your code clean.
  prefs: []
  type: TYPE_NORMAL
- en: Adding default values for your slot is very simple; all you need to do is add
    the value that you want directly within the `<slot>` declaration. This value is
    going to be used if no other alternative is passed to the component, otherwise,
    it is going to be removed and overridden from the slot received.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see a quick example to understand the declaration and usage of default
    slots.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we are going to add a default text of `Click Me` to `TheButton.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have added a default value, our button will automatically show the
    new text, in the case in which no content is passed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the default slot in action, we would have to call our button without
    any slot content, so the code would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This will render our default text.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1: Default button with a value of “Click me”](img/B21130_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: Default button with a value of “Click me”'
  prefs: []
  type: TYPE_NORMAL
- en: 'The text is there just as a fallback; in fact, adding a value within the slot
    will override the text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Just as we saw before, adding text in the slot will display it, just as you
    would expect in a native HTML element:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2: Default button with a value of “Show this”](img/B21130_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2: Default button with a value of “Show this”'
  prefs: []
  type: TYPE_NORMAL
- en: Slot versus property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we learn one more feature about slots, I want to write a few words to
    clarify why we need two methods (slots and properties) to achieve a very similar
    result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Slots and properties solve two different use cases, and both have advantages
    and disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Slots**: These are used mainly for components that require the values to
    be flexible. These are components that just provide a structure, for example,
    a dialog or end elements such as buttons or headings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Properties**: These are used for elements that require fine control of what
    is being passed to them. This could either be due to some style that would break
    with different content or because of the need to validate or format the value
    received.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use native HTML elements to emphasize the differences we just defined.
    In favor of slots, we have headings tags such as `<h1>` and `<h2>`. These are
    very generic elements that provide styles, mainly in the form of font size and
    spacing to its content. This element requires flexibility, and the use of slots
    is perfect for it. In fact, native heading elements wrap their content just like
    slots.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, we have the `<input>` element to prove the usefulness of
    attribute values (properties in Vue.js). The input element requires a specific
    attribute called `value`. The value offered by the input field only accepts a
    string or a number as its value. Offering a syntax that accepts an attribute,
    `<input value="text" />`, ensures that the value passed to the input field is
    validated.
  prefs: []
  type: TYPE_NORMAL
- en: Provide multiple slots with named slots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you have probably noticed, slots have lots of useful features and can be
    very handy for constructing complex components. In the previous section, we have
    seen how we can define a single slot, but Vue.js offers more than that.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, components in Vue.js can define more than one slot at a time. This
    is achieved using a functionality called **named slots**.
  prefs: []
  type: TYPE_NORMAL
- en: A common use of named slots is to define layouts. You can define a layout that
    accepts a sidebar, main content, and footer and then allow users to pass all the
    content that they see fit within the individual section. Another good example
    is a main hero component that offers a heading and a subheading, or a dialog component
    that offers a title and its content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a very basic layout for our static content. We are going to store
    our new component in a folder called `templates` and call it `StaticTemplate.vue`.
    The relative URL would be `src/components/templates/StaticTemplate.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Our layout is going to have some basic styles that are required to create the
    correct spacing and show the difference between the individual sections. The template
    also includes three different sections: a heading defined with `<h1>`, the main
    content defined with the `<main>` element, and finally, `<footer>`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now add the named slot to our templates. The syntax of the named slot
    is very similar to the normal slot, therefore defined using the `<slot>` element,
    but with the addition of a `name` attribute. Just to emphasize the previous learning
    material, we are going to provide a default value for the footer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: With the preceding code, the `StaticTemplate.vue` file can be called with the
    possibility to pass three different sections. Let’s go over the `AboutView.vue`
    page within the `Views` folder and try to use this new layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for the named slot is a little different than the default slot,
    as we need to define the actual name of the section that we are defining. To use
    a named slot, you use the `<template #``slotName></template>` syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try to apply this to our `AboutView` page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: First, we imported the new component in the script section and then we used
    the component just like we would use `<div>` or `<span>`. Last, we added content
    for our slot by defining a heading and default section. Because **About Page**
    does not require the overriding of the footer, we are leaving that out of our
    instance so that the default value can be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we access **About Page** at “[http://localhost:5173/about](http://localhost:5173/about)”,
    we should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3: About Page using the new layout](img/B21130_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.3: About Page using the new layout'
  prefs: []
  type: TYPE_NORMAL
- en: The page is displaying all three sections as we expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default slot does not require the <template #default> syntax'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to, we would have been able to call the default slot without the
    need to use `<template #default>`, but this is not a suggested approach as it
    would have produced a hard-to-read code with mixed methodology.'
  prefs: []
  type: TYPE_NORMAL
- en: There is one more feature offered by Vue.js slot implementation called the **scoped
    slot**. This is a very advanced technique that allows you to define slots that
    expose the child’s scope to its parents. Due to their complexity, these are not
    going to be tackled within this book.
  prefs: []
  type: TYPE_NORMAL
- en: Slots are a very powerful technique that helps us make our components easier
    to use, improve their readability, and offer enhanced flexibility. Just like every
    other feature, slots have their own advantages and disadvantages and should be
    used just when needed. The flexibility caused by the use of slots can produce
    unwanted side effects with the UI and it can be easier at times to control the
    layout of a component by imposing its values with the use of properties.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter so far, we have introduced the notion of slots by comparing
    them with existing features available within native HTML elements, and we then
    learned the syntax required to define and use default slots. After, we compared
    slots and properties and tried to distinguish the different scenarios in which
    one method may be preferred to another. Last, we learned how to define default
    values for a slot and the possibility of defining multiple slots with the named
    slot.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to continue the chapter with another advanced topic, introducing
    how we can access children’s components or HTML elements with the use of Template
    Ref.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing components elements with Template Refs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to improve the control of our components by learning
    how to access the DOM element.
  prefs: []
  type: TYPE_NORMAL
- en: When I first started to learn about Vue.js, I was astonished by how much could
    be accomplished without the need to access DOM elements. The Vue.js engine is
    structured in a way that we can accomplish all basic operations with the use of
    props, data, methods, and computed properties.
  prefs: []
  type: TYPE_NORMAL
- en: Just like everything else, there are times when we may need some extra control,
    and this can be achieved with the use of `Template Ref`. Using this feature exposes
    the DOM element in which the Ref was defined. This would be the same as using
    `querySelector` or `getElementById` offered by vanilla JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Same Refs different usage
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why we are learning about Refs if we already learned about
    it at the start of the book to define the private properties of a component. Well,
    this Refs is different. It is defined with the same syntax, but it is going to
    hold the value of an HTML element or component instead of primitive data such
    as strings and numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Refs can be used for two different scenarios. The first is accessing a native
    element to access its native APIs; one such thing could be to focus an element
    or trigger native validation for an input field. The next is to access another
    Vue component or package to expose methods or their inner information. A common
    scenario for this is the need to set or fetch the value of a WYSIWYG (What you
    see is what you get) or code editor. The second scenario is not common practice
    and should be used just in case of emergency. The reason why accessing a child
    component using Template Ref is not suggested is that it will couple the two elements
    together and this should always be avoided in component-based architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Focus an onMounted element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start to play with Template Refs by learning how to fetch the reference
    of an input field and focus it when the page loads. The focus feature could have
    been achieved with the `autofocus` attribute, but we will develop the feature
    manually to showcase the use of Refs.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to work in `CreatePost.vue` and autofocus the `textarea` used to
    write a new post.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to make three modifications to our component. First, we are going to
    define a `ref`, just like we learned throughout this book. Next, we are going
    to assign the Template Ref to `textarea` and we are going to access that element
    using the `onMounted` lifecycle and focus the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Working with Refs follows a specific order; we first create the `const textareaRef
    = ref(null)` Ref and, at this point, the Ref is going to be null. We then assign
    the ref to a specific element within our component; in our scenario, we add it
    to `textarea`. The Ref is still empty because the component is not rendered, and
    the element does not exist on the page yet. Finally, we trigger our logic within
    the `onMounted` lifecycle. Because the `onMounted` lifecycle is triggered after
    the component is fully rendered, the Ref will be fully defined and ready to use.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on, I want to focus on three more parts of the code block. First
    is a reminder that Refs in Vue.js require `.value` to be appended to them to be
    able to access their internal value. This applies to both normal refs, such as
    strings and numbers, and Template Refs which we are covering in this section of
    the book. Second, I want to emphasize the fact a Tempalte Ref associated with
    an element (in our case, `texareaRef`) is going to be null until `onMounted` is
    triggered. This means that if we ever use it in a computed property or method,
    we need to ensure that we check for null values to avoid errors. The last is about
    the naming convention. It is important for the name of the Template Ref and the
    one used in the HTML element to match for it to function. It is important for
    the name of the Template Ref variables (const textareaRef) and the one used in
    the HTML attribute (ref="textareaRef") to match for it to function successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Refs are just for exceptional cases
  prefs: []
  type: TYPE_NORMAL
- en: Vue.js provides us with mostly everything we need out of the box, so Refs should
    not be overused. The use of Refs should be saved for specific use cases and not
    become the norm. If you find yourself using this more than a handful of times
    in a project, you are probably misusing other Vue.js features.
  prefs: []
  type: TYPE_NORMAL
- en: Access from native validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section will focus on advanced topics; we are going to reiterate the topic
    we just introduced by implementing another example that uses Template Ref to access
    an element. We will continue to work on the code that handles the creation of
    a post by adding some validation using the native HTML validation offered by HTML
    form inputs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to continue our work in `CreatePost.vue`. First, we are going
    to add some specific validation within our `<``textarea>` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We made `textarea` required and defined a minimum character length of `10`.
    Next, we are going to create a new ref, and this time, we will gain access to
    the main `<form>` element within the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Just like in our previous example, the creation of a Ref requires two steps.
    First, we add an attribute of Ref to an element, and then we create a constant
    that has a name matching the Ref.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this last step, we are going to create a method that will be called when
    the form is submitted and use our newly created Template Ref to access the native
    form validation API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: To achieve this, we used our knowledge of events gained in [*Chapter 6*](B21130_06.xhtml#_idTextAnchor074)
    and triggered a method called `createPost` on form submission. Then, we created
    a method that prevented the native submit from triggering and used the `createPostForm`
    Ref to check the validity of the form with `createPostForm.value.reportValidity()`.
  prefs: []
  type: TYPE_NORMAL
- en: This method will return a Boolean (so `true` or `false`) depending on whether
    the form is valid and it will also display the native error message on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start our application and try to trigger the form with an empty input:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4: Native HTML validation error displayed on textarea](img/B21130_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.4: Native HTML validation error displayed on textarea'
  prefs: []
  type: TYPE_NORMAL
- en: We are going to leave this form as it is even if it is not fully functional
    as the code required to submit the form will be completed in [*Chapter 12*](B21130_12.xhtml#_idTextAnchor163).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have learned that Ref is not only used to define our component
    values but it is also used to hold values of HTML elements. We have applied this
    newly learned technique by developing the functionality and validation needed
    to create new posts in `CreatePost.vue`. Finally, we iterated on the flow in which
    Refs are defined and how it requires the mounted state to be completed for it
    to be accessible.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will add the ability to expand and minimize the sidebar
    of our application and iterate through the notion of the lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: Deep diving into the lifecycle of a real app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lifecycles are not a new notion and have been mentioned once or twice throughout
    this book, but due to their importance, it is a good idea to iterate through them
    by adding further functionality to our Companion App.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to add new functionality that will enable us to
    expand and minimize the left sidebar of our application and store the value in
    `localStorage` to ensure the user preferences are persistent on refresh. We are
    going to learn how having a better understanding of the lifecycle can improve
    the user experience provided by our application.
  prefs: []
  type: TYPE_NORMAL
- en: Before we jump into the code itself, let’s think about what steps would be required
    to achieve this new functionality. Thinking over a problem helps you memorize
    all the different aspects of the Vue.js framework that we have learned and supports
    you in realizing any lack of knowledge or misunderstanding that you may have.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the task of enabling the sidebar to collapse and expand, we would
    need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the UI required for the user to trigger this action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add some style to improve the look and feel of the sidebar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new value that will hold the state of the sidebar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the sidebar to have different renderings for the different states.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the logic to handle the sidebar state change and save the value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, read the user preferences on load and apply them to the component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The list may seem very long, but these are all small tasks that you should be
    able to accomplish without my aid. Let’s start our work by working on the new
    UI changes.
  prefs: []
  type: TYPE_NORMAL
- en: Adding conditional rendering to the sidebar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start by reiterating the Vue.js directive by using `v-if` and `v-else`
    to effectively display two different views. One will show the expanded sidebar,
    while the other will display a minimal layout with just the button required to
    expand the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the following developments will take place in the `SideBar.vue` file that
    holds the logic required for our sidebar. Before we make changes to its layout,
    we are going to import two new icons, `IconLeftArrow` and `IconRightArrow`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we are going to add the two layouts using the conditional logic provided
    by `v-if/v-else`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`<aside>` includes two different blocks, both delineated by the `<template>`
    element. The first block just contains the right arrow icon and will be used to
    display our collapsed layout, while the other layout includes the existing code
    that was present in the component before we started the modification, with the
    addition of the left arrow icon.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have looked closely at the preceding code, you may realize that something
    is missing, or incomplete. In fact, a conditional statement such as an if/else
    requires a hypothesis and this is currently missing in our code: `<template` `v-if=""
    >`.'
  prefs: []
  type: TYPE_NORMAL
- en: For the statement to work, we need to add a condition that will be evaluated
    by the Vue.js compiler to display the correct layout. We are going to create a
    R`ef` called `closed` that will hold a Boolean value. This variable will be used
    by our if/else statement to define which layout should be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To accomplish this, we first define the `ref` in our script section:'
  prefs: []
  type: TYPE_NORMAL
- en: <script setup>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we use this new variable within the `v-if` directive that we have previously
    defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Due to the value of `closed` being hardcoded to `false`, the sidebar will always
    display the expanded layout. In the next section, we will write the logic required
    to toggle the two layouts.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the logic to handle the sidebar states
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To be able to toggle between the two different views of our sidebar, we need
    to provide the user with the ability to change the value of `closed`. We will
    use the left arrow and right arrow icons added in the previous section to trigger
    a click event on user input. The event will initiate a method that we are going
    to call `toggleSidebar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To code this, we are first going to add the event handler to the two icons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we declare the `toggleSidebar` method in the `<script>` section of our
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The method accepts no argument and just redeclares the value of `closed` by
    making it equal to the opposite of the current value of `closed`. This generates
    a logic that toggles a Boolean value between `true` and `false`.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the application now, you should be able to toggle between two layouts.
    The next step involves adding some styles to the collapsed layout that is currently
    still showing a full-size sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add some styles to our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: To better style our two layouts, we declared two classes. The first is `sidebar__closed`,
    which is used to reduce the width of our sidebar. The second is `sidebar__icon`,
    which is used to define the size and position of the arrows.
  prefs: []
  type: TYPE_NORMAL
- en: '`sidebar__icon` is applied to both icons, while `sidebar__closed` is just assigned
    to `<aside>` if the value of `closed` is `true`. To do so, we used the `:class="{
    ''sidebar__closed'': closed}"` syntax. This syntax is useful as it allows you
    to create complex styles with the ability to easily apply classes when a specific
    condition is met.'
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, the sidebar not only works but it is also styled properly with
    a collapsed and expanded layout. What is left to do is to make the data *persistent*.
    In development, we describe data as persistent when its value remains consistent,
    even after a browser refresh.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5: Expanded sidebar](img/B21130_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.5: Expanded sidebar'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6: Collapsed sidebar](img/B21130_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.6: Collapsed sidebar'
  prefs: []
  type: TYPE_NORMAL
- en: Now that the sidebar’s look has been improved, it is time to make its value
    persist on refresh.
  prefs: []
  type: TYPE_NORMAL
- en: Save and read the user preference in localStorage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this stage, even if the sidebar logic is fully working, its data is not persistent
    yet. In fact, if you set the sidebar to its collapsed state and refresh the page,
    you will see that it will go back to the expanded view that was defined as its
    default state (the value that we used to initialize the `closed` ref was `false`).
  prefs: []
  type: TYPE_NORMAL
- en: To enable persistence, we are going to use `localStorage` to save our value
    and re-read it on page load.
  prefs: []
  type: TYPE_NORMAL
- en: Before we go through the code, we should try and define what the best method
    is for us to achieve this. In fact, this section was named after the Vue.js lifecycle,
    but up to this stage, we have not used them yet.
  prefs: []
  type: TYPE_NORMAL
- en: Why is the use of the correct lifecycle important?
  prefs: []
  type: TYPE_NORMAL
- en: Before moving forward, spend a few minutes to try and understand what the consequences
    would be of using the incorrect lifecycle to load our data from `localStorage`.
    Think about the different lifecycles, when they are triggered, and what could
    be the effect on the application.
  prefs: []
  type: TYPE_NORMAL
- en: As we learned in [*Chapter 2*](B21130_02.xhtml#_idTextAnchor028), there are
    different lifecycles that support different use cases. In our scenario, we are
    planning to use a lifecycle to read the value of our `closed` variable and apply
    it to the component. When making an operation like this one, you usually should
    ask yourself a couple of questions. The first is whether the data is asynchronous,
    and the second is whether the data is required before the application is rendered
    on screen.
  prefs: []
  type: TYPE_NORMAL
- en: Each lifecycle happens at different stages of the component life. Some such
    as `beforeCreate` is triggered before the component is even created, while others
    trigger after a component is fully mounted within the DOM like `onMounted`, and
    it is important to select the correct one for our specific scenario.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, the data is fetched from `localStorage` and is a synchronous operation;
    it is needed before the component is fully rendered or screened, also referred
    to as “before mounted.”.
  prefs: []
  type: TYPE_NORMAL
- en: The lifecycle that best fits our needs is `onBeforeMount`. This will trigger
    just before the component is rendered but after all the methods and Refs have
    been initialized.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add this logic to our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: To achieve persistence, we first imported the `onBeforeMount` method from the
    Vue package and then we saved the value of the `closed` Ref every time the `toggleSidebar`
    method was triggered. To achieve this, we used the `localStorage.setItem` method
    that is available in the `window` object. Lastly, we used `onBeforeMount` to read
    the value from localStorage and then assign it to the `closed` ref.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, our application will not only allow the user to toggle the sidebar,
    but its value will also be persistent on refresh.
  prefs: []
  type: TYPE_NORMAL
- en: Before we complete this chapter, I want to focus on why using the correct lifecycle
    is important. In fact, if we had used another lifecycle such as `onMounted`, the
    sidebar would have been fully rendered (incorrectly) before the value of `localStorage`
    would have been read and applied to the app. The main issue with bugs such as
    this one is that in development they may not reproduce or may be very hard to
    see.
  prefs: []
  type: TYPE_NORMAL
- en: It is very important when creating code that is going to alter the view of the
    component to ensure that you have used the correct lifecycle and, if working with
    asynchronous data, that the correct loading is defined, or the promise awaited
    before the rest of the component executes. This practice may seem hard to comprehend
    at first, but code practice and mistakes will help you improve your understanding
    of a Vue.js component and improve your skills.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered a couple of advanced topics such as slots,
    lifecycles, and refs. The aim of this chapter was not to provide you with all
    the information that you may need on these topics but to introduce you to these
    points so that you can practice them in your next development and continue to
    learn as you expand your knowledge of Vue.js.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned how to use slots to expand the flexibility of our components.
    Slots and named slots can be used for simple cases, such as `<button>`, style
    elements, such as `<div>`, or for more advanced techniques, such as defining a
    page layout with different areas.
  prefs: []
  type: TYPE_NORMAL
- en: We then moved on to Template `Ref`, a topic that we had partly introduced in
    an earlier chapter. We learned how Template `Ref` can be used to access a component
    DOM element. This is defined as an advanced technique because, with all the available
    features offered by Vue.js, it is uncommon that you would need to use Template
    `Ref` this way.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we went over lifecycles again. Vue.js lifecycles are very important,
    and they require lots of practice to help you understand their usage and, more
    importantly, their order of execution. We have added an extra feature to our Companion
    App so that we can understand one of its use cases and think over the possible
    result that a different lifecycle would have produced.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn how to define multiple routes with
    **vue-router**. Defining multiple pages is a required step for most applications
    and **vue-router** offers a very simple syntax that will help us achieve this
    functionality within our Companion App.
  prefs: []
  type: TYPE_NORMAL
