- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Best Practices in Unit Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about the concept of software testing. We
    learned what to test from an array of available components and methods. In addition,
    we learned about the best practices and industry-standard testing libraries and
    how to integrate them with Vue.js 3.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore everything related to unit testing. We will
    learn how to unit test a Vue.js 3 component and the component and page methods.
    We will also learn about unit testing tools such as Jest and Mocha and how to
    use them to effectively unit test an enterprise project.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following key topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is unit testing?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The importance of unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The benefits of unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices in unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing a basic Vue.js app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get started with this chapter, I recommend you read through [*Chapter 8*](B17237_08.xhtml#_idTextAnchor266),
    *Testing and What to Test in Vue.js 3*, first, where we explored the concept of
    software testing and what to test from an array of available components and methods.
    We will rely heavily on the knowledge from that chapter when learning about Vue.js
    3 enterprise unit testing in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: All the code files for this chapter can be found at [https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-9](https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-9).
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit testing is an important step in the development phase because it helps
    spot errors and defects at the development stage if done correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing is a method of software testing in which the smallest testable
    parts of the software under test, called units, are individually or independently
    tested for proper operation and to make sure the output corresponds with the required
    output.
  prefs: []
  type: TYPE_NORMAL
- en: The units can be said to be individual functions, objects, methods, procedures,
    or modules in the software under test.
  prefs: []
  type: TYPE_NORMAL
- en: This software testing approach is developed by software engineers to test the
    units of the program. It helps software engineers to know whether individual units
    of the code are working properly or not.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will examine the definition of unit testing and explore
    how developers can create and manage unit tests within their enterprise-ready
    Vue.js 3 applications.
  prefs: []
  type: TYPE_NORMAL
- en: What is unit testing?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unit testing is a method of verifying the smallest piece of testable code against
    its purpose or requirement. This method makes sure that the smallest part of your
    code base is tested and made to conform to the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: It is very important to discover and fix bugs during the development stage.
    Unit testing is the responsibility of developers because it is done in the development
    phase by the developers, and it is the developers that create unit tests for their
    production-ready code.
  prefs: []
  type: TYPE_NORMAL
- en: Software developers can approach unit testing in two different ways, either
    writing their code before writing unit tests or before writing their actual code,
    where the developer first creates a failing unit test. The second approach is
    called **Test-Driven** **Development** (**TDD**).
  prefs: []
  type: TYPE_NORMAL
- en: When exploring the **Software Development Life Cycle** (**SDLC**) for software
    engineering and development, unit testing comes under development since it is
    the responsibility of the developers and serves as the base and first level of
    testing to ensure bug-free and defect-free software.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – SDLC](img/Figure_9.01_B17237.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – SDLC
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will examine different best practices to create and
    manage unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: The importance and benefits of unit testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The importance of implementing unit testing in your development pipeline cannot
    be overemphasized. It has been proven to have tremendous benefits. It has also
    helped in detecting errors early in the development phase. We will go through
    some of the major benefits and the importance of unit testing in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing is used to design robust and enterprise-ready software components
    that help maintain code and eliminate issues in code units. Finding and fixing
    bugs during development is important compared to discovering them in production.
    Unit testing helps in fixing these errors early in the development phases.
  prefs: []
  type: TYPE_NORMAL
- en: It is an integral part of the agile software development process. During the
    build process and deployment, the unit test suite is automated to run and generate
    reports. If any of the unit tests fail, then the QA team should not accept that
    build for verification and it should be returned to the development team for more
    checking and validation.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing saves the QA and software testing teams a lot of time. If there
    is a proper standard and a well-configured, automated software testing pipeline
    for the enterprise application, errors and defects will be caught during development
    automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Developers may avoid writing unit tests due to time constraints and tight deadlines.
    In most cases, they may opt to write poor unit tests just to have a 100% pass
    rate. This is very bad practice; it is better to avoid writing any tests instead
    of writing bad unit tests just to pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the benefits of writing good unit test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Improved code quality**: The quality of code shipped to production is automatically
    improved if unit testing is strictly implemented into the development pipeline
    and it’s done right. Unit testing is the earliest form of testing; therefore,
    any bugs identified during this testing are fixed before they are sent to the
    integration testing phase. The result of this approach is a robust design and
    development as developers write test cases by understanding the specifications
    and tasks at hand first.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Detects bugs early**: Unit testing is the first level of testing in software
    development. Therefore, it helps in identifying and fixing bugs early. This includes
    flaws, missing parts in the software requirements and specifications, or bugs
    in the developers’ implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Saves development time**: Code completion takes time, especially if proper
    software development practices are in use. Therefore, when there are fewer bugs
    and errors in the system due to the effectiveness of unit testing, the overall
    development time is reduced.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy debugging process**: Unit testing helps in simplifying the testing and
    debugging process of an enterprise-ready application because if the test fails
    at any stage, the code needs to be debugged; otherwise, the process can continue
    without any obstacles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lower cost**: The cost of development, including development time, is drastically
    reduced when bugs are detected and resolved during development rather than during
    production. Without this testing, if the same bugs are detected at a later stage
    after the code integration, they become more difficult to trace and resolve, thereby
    making the development more costly and last longer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The benefits and importance of unit testing are endless. Therefore, it’s a good
    practice to adopt and implement it into your enterprise-ready Vue.js 3 application
    development pipeline. In the next section, we will explore the best practices
    for creating unit test cases.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices in unit test creation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When creating unit test cases, you should follow the best practices to produce
    consistent unit test cases to test every possible case properly. Consider the
    following points to create good test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arrange, Act, and** **Assert** (**AAA**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write deterministic tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write good test names and descriptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write tests before or during development (TDD)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leverage automated tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using mocks and stubs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s understand each of these points in more detail in the next subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Arrange, act, and assert
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When structuring your unit test suite for enterprise applications, following
    the AAA approach is recommended to improve readability and easy understanding
    of your unit test suite. It improves the test readability by giving it a logical
    flow. It can also be referred to as the **Given/When/Then** (**GWT**) strategy.
  prefs: []
  type: TYPE_NORMAL
- en: GWT is a semi-structured way of writing down test cases. These test cases can
    either be manually tested or automated using LambdaTest ([https://www.lambdatest.com/automation-testing?fp_ref=solomon26](https://www.lambdatest.com/automation-testing?fp_ref=solomon26)).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the AAA protocol to structure your unit test cases with the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arrange**: Arrange the setup and initialization for the test.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Act**: Act on the unit for a given test.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Assert**: Assert or verify the outcome.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code snippet shows a basic example of using the AAA style to
    create a simple unit test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet shows where to initialize variables and create the initial
    setup for the given test, then where we act on the given test, and lastly, where
    we assert the result of the acted-on test.
  prefs: []
  type: TYPE_NORMAL
- en: Write deterministic tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A unit test should have consistent output whenever and wherever tested to verify
    the desired function. A deterministic test should have a consistent behavior every
    time the test is run provided the test code hasn’t changed.
  prefs: []
  type: TYPE_NORMAL
- en: Inconsistencies in testing can be called flakiness in tests. If your test works
    or passes in development and fails with continuous integration or during QA testing,
    it hinders development and slows down progress.
  prefs: []
  type: TYPE_NORMAL
- en: Flakiness in tests can be avoided if deterministic test cases are written as
    it helps in understanding the output of every test case quickly and reduces hours
    of debugging for new team members.
  prefs: []
  type: TYPE_NORMAL
- en: Write good test names and descriptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In software engineering, one of the best practices for writing clean code is
    to always have a good naming ability. As a developer, your variables, functions,
    methods, or classes should have good and descriptive names.
  prefs: []
  type: TYPE_NORMAL
- en: This best practice is also extended to writing test case names. It is important
    to have a clean and clear description of your test case to capture exactly when
    the test is supposed to implemented and the desired output.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, your test case names should describe the purpose of your test
    cases, as shown in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Write tests before or during development (TDD)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a professional developer, you need to embed the concept of TDD into your
    development process and workflow.
  prefs: []
  type: TYPE_NORMAL
- en: TDD is a software development process that enhances our test cases and software
    code in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of TDD contradicts the traditional development process because in
    TDD, developers have to first write test code before writing the actual software
    code to pass the test case written. This approach ensures that when production
    code is written, it always complements the test code.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, **Behavior-Driven Development** (**BDD**) is another popular testing
    approach. This approach works well in rapid development settings and encourages
    more team collaboration to build a shared understanding of the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of what approach you decide to adopt in your project, you can still
    integrate continuous integration into your development pipeline to automate your
    software testing processes.
  prefs: []
  type: TYPE_NORMAL
- en: Using mocks and stubs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When creating test cases, you might be tempted to perform operations on the
    actual code. For instance, if you made an API call to an external API, you might
    want to make such calls during testing, to make sure everything works as planned.
    But that wouldn’t be considered best practice. What you can do is use the mock
    and stub features of any test framework.
  prefs: []
  type: TYPE_NORMAL
- en: A stub is a dummy piece of code that lets the test run without worrying about
    what happens to it, while a mock is a dummy piece of code that you verify is called
    correctly as part of the test. In short, they are substitutes for real, working
    code.
  prefs: []
  type: TYPE_NORMAL
- en: The beauty of this is that you can set them up and use them to test and verify
    your actual code works properly without making any expensive API calls or carrying
    out database manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: Leverage automation testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a developer, integrating automated testing into your workflow saves a lot
    of time when compared to manually executing your test case every time before deployment.
  prefs: []
  type: TYPE_NORMAL
- en: You can use different automated testing frameworks to set it up, but in this
    chapter, we will see how to automate unit testing with Selenium Cloud Grid ([https://www.lambdatest.com/selenium-grid-online?fp_ref=solomon26](https://www.lambdatest.com/selenium-grid-online?fp_ref=solomon26)).
  prefs: []
  type: TYPE_NORMAL
- en: Before we delve into automating our test cases, let’s explore how to write a
    clean and proper unit test with JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a developer, writing unit tests for your task is your responsibility. It
    should be part of your day-to-day activities as you code. In JavaScript, you can
    write unit tests the same way you write your real code with the use of different
    testing libraries.
  prefs: []
  type: TYPE_NORMAL
- en: With these testing libraries, testing the functionalities and features of your
    project becomes very easy because the libraries include different assertion methods
    to carry out your checks.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore some of the most popular JavaScript testing frameworks you can
    use to write your unit tests, integration tests, and even end-to-end tests.
  prefs: []
  type: TYPE_NORMAL
- en: Popular JavaScript testing frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Various frameworks are helpful for unit testing in JavaScript. They are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Jest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocha
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jasmine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cypress
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vitest.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s explore these frameworks in more detail in the next subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Jest
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Jest is one of the most popular testing frameworks for JavaScript. It was designed
    to mostly work with React and React Native-based applications. It is open source
    and easy to get started with. Jest reduces the extensive time-consuming configuration
    needed to run software testing in the frontend with JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: It is an assertion library for JavaScript that runs on Node.js and the browser.
    Jest can be configured to work with any test runner and unit testing framework,
    such as Mocha or Jasmine.
  prefs: []
  type: TYPE_NORMAL
- en: The growth statistics of the Jest library according to GitHub, as of the time
    of writing, include more than **40k GitHub stars** and about **6.3 million GitHub
    usage**, accumulating a total of **6.4 million** points, making Jest among the
    most popular testing frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Mocha
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Mocha is a server-side and client-side testing framework for JavaScript and
    Node.js. The key features of Mocha are simplicity, flexibility, and fun. It makes
    asynchronous testing in JavaScript easy and fun. Mocha is designed to run serially,
    allowing for flexible and accurate test reporting and coverage.
  prefs: []
  type: TYPE_NORMAL
- en: The growth statistics of the Mocha library according to GitHub, as of the time
    of writing, include more than **21.6k GitHub stars** and about **1.6 million GitHub
    usage**, accumulating a total of **1.66 million**, points, making Mocha a very
    popular testing framework.
  prefs: []
  type: TYPE_NORMAL
- en: Jasmine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Jasmine is a popular JavaScript BDD framework for unit testing JavaScript applications.
    It combines the power of speed and support for Node.js and the browser to become
    a robust testing framework for BDD.
  prefs: []
  type: TYPE_NORMAL
- en: The growth statistics of the Jasmine library according to GitHub, as of the
    time of writing, include more than **15.4k GitHub stars** and about **2.4 million
    GitHub usage**, accumulating a total of **2.5 million** points, making Jasmine
    among the most popular testing frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Cypress
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Cypress is an end-to-end JavaScript-based testing framework that changes the
    way developers approach software testing. It is built on top of Mocha, making
    asynchronous testing simple and convenient. In Cypress, unit tests can be configured
    to execute without even having to run the web server.
  prefs: []
  type: TYPE_NORMAL
- en: This feature makes Cypress the ideal tool for testing a JavaScript/TypeScript
    library that is meant to be used in the browser, and setting up automated testing
    in your enterprise project is a breeze.
  prefs: []
  type: TYPE_NORMAL
- en: The growth statistics of the Cypress library according to GitHub, as of the
    time of writing, include more than **40.2k GitHub stars** and about **535k GitHub
    usage**, accumulating a total of **575k** points, making Cypress among the most
    popular testing frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Vitest
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Vitest is a blazing-fast unit test framework powered by Vite. It is a Vite-native
    unit test framework comprising Vite reusable configs, transformers, resolvers,
    and plugins. It is also Jest compatible and uses ESM, TypeScript, and JSX out
    of the box.
  prefs: []
  type: TYPE_NORMAL
- en: It’s fairly new and has gained popularity among developers using Vue.js and
    the Vite CLI. The growth statistics of the Vitest library according to GitHub,
    as of the time of writing, include more than **6.4k GitHub stars** and about **24.3k
    GitHub usage**, accumulating a total of **30.7k** points.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore how to write your unit tests with JavaScript
    and how to run your tests manually. Additionally, we will explore how to automate
    your testing suite during the deployment pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing a Vue.js 3 app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we created a Pinterest application using Strapi for
    the backend and Vue.js 3 for the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Previously, we added internationalization, structured the project, and built
    out a complete Pinterest clone. In this section, we will continue by using the
    official project we created for this book to set up unit testing, resulting in
    a full-blown enterprise-ready Pinterest clone application.
  prefs: []
  type: TYPE_NORMAL
- en: You can clone the project from this repository, [https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications](https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications),
    to jump right in.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we set up basic unit testing using Vitest and demonstrated
    how to implement basic unit testing with a helper file.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore more advanced ways of testing the units of
    the Pinterest clone application we are using as the example throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: What to test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, we explored in detail what to test when setting up
    your testing suites. In this section, we will examine our demo software under
    test and specify what should be unit tested.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, there are two things we could test for in Vue.js components: presentation
    and (optionally) behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: Presentation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When fetching data using Apollo Client, components can be in either the `loading`,
    `success`, or `error` state. For each of these states, it’s a good idea to test
    that the presentation is what we intend it to be.
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider having a component that presents details about a specific
    photo (performs a `GET_PIN` query) from our Pinterest clone application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could have a simple component such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In this scenario, we will likely want to test the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Loading**: How the component renders when it’s fetching the pin (photo)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Success**: How the component renders after it’s successfully fetched the
    pin (photo)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error**: How the component renders if it was unable to fetch the pin (photo)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To demonstrate this, let’s implement a unit test against each of the states
    mentioned in the preceding points. We will be using the `Pin(Photo)` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Behavior (optional)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We may also choose to place behavior in our Vue.js components. In client-side
    architecture, we call this interaction logic—a form of decision-making logic executed
    after the user interacts with the page somehow—such as a key press or a button
    click.
  prefs: []
  type: TYPE_NORMAL
- en: You can also unit test the behaviors of a single component by testing different
    actions that are performed on the component and making sure the component reacts
    to it accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s test this `Photo` component’s `click` event to be sure it responds to
    the appropriate action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can follow the preceding sample code snippet to write unit tests for all
    the components you have created in your enterprise Vue.js 3 application.
  prefs: []
  type: TYPE_NORMAL
- en: In the repository of this chapter ([https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-9](https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-9)),
    we have created different components and also written the unit test for them.
    You can clone the repository here.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will run the unit testing manually and how to automate
    the process using LambdaTest Cloud Grid. ([https://www.lambdatest.com/automation-testing/?fp_ref=solomon26](https://www.lambdatest.com/automation-testing/?fp_ref=solomon26))
  prefs: []
  type: TYPE_NORMAL
- en: Running unit tests manually
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To run your test, type the following command into your root terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After successfully running the test, you should be greeted with green passes
    for your test, as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Unit test passing sample](img/Figure_9.02_B17237.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Unit test passing sample
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we explored best practices in unit testing a Vue.js 3 component.
    We discussed, most importantly, what to test and how to implement unit testing
    in Vue.js 3\. We demonstrated how to unit test a Vue.js app using Vitest ([https://vitest.dev/](https://vitest.dev/))
    and the Vue.js testing library. ([https://github.com/testing-library/vue-testing-library](https://github.com/testing-library/vue-testing-library))
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explored everything related to unit testing, including how to unit
    test a Vue.js 3 component and the component and page methods. We also learned
    about unit testing tools such as Jest, Mocha, and Vitest and how to use them to
    effectively unit test an enterprise project.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we explored the benefits, importance, and best practices in
    writing and executing effective unit testing strategies. We also learned how to
    write unit test cases based on the presentation and behavior of the different
    units of the software under test.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter shows you how to create, implement, and run your unit test cases
    manually during the build process and deployment.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore everything related to integration testing.
    We will cover in depth how to perform an integration test on a Vue.js 3 component
    and pages. We will also learn about integration testing tools such as Vue.js Testing
    Library and how to use them to test an enterprise project effectively.
  prefs: []
  type: TYPE_NORMAL
