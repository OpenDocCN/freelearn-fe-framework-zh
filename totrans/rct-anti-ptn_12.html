<html><head></head><body>
<section epub:type="frontmatter chapter" role="doc-chapter">
<h1 class="chapter-number" id="_idParaDest-176"><a id="_idTextAnchor323"/><span class="koboSpan" id="kobo.1.1">12</span></h1>
<h1 id="_idParaDest-177"><a id="_idTextAnchor324"/><span class="koboSpan" id="kobo.2.1">Implementing an End-To-End Project</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapters, we delved into a variety of topics, including testing, </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">test-driven development</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.6.1">TDD</span></strong><span class="koboSpan" id="kobo.7.1">), design patterns, and design principles. </span><span class="koboSpan" id="kobo.7.2">These concepts are invaluable as they pave the way toward a more resilient and maintainable codebase. </span><span class="koboSpan" id="kobo.7.3">Now, I’d like to embark on a journey of constructing an application from the ground up, applying the knowledge we’ve acquired to tackle an end-to-end scenario.</span></p>
<p><span class="koboSpan" id="kobo.8.1">The aim is to illustrate how we can dissect requirements into actionable tasks, and subsequently test and implement them. </span><span class="koboSpan" id="kobo.8.2">We’ll also explore how to stub network requests, thereby eliminating dependencies on remote systems during development, and how to confidently refactor code without fear of breaking existing functionality.</span></p>
<p><span class="koboSpan" id="kobo.9.1">We’ll venture into building a functional weather application from scratch, interfacing with a genuine weather API server to fetch and display a list of weather data. </span><span class="koboSpan" id="kobo.9.2">Along the way, we’ll implement accessibility features such as keyboard interactions, revisit the </span><strong class="bold"><span class="koboSpan" id="kobo.10.1">Anti-Corruption Layer</span></strong><span class="koboSpan" id="kobo.11.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.12.1">ACL</span></strong><span class="koboSpan" id="kobo.13.1">) and single responsibility principle, and much more.</span></p>
<p><span class="koboSpan" id="kobo.14.1">The overarching goal is to showcase the end-to-end process of crafting a functioning software solution, all while keeping the code in a maintainable, understandable, and extensible state.</span></p>
<p><span class="koboSpan" id="kobo.15.1">The following topics will be covered:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.16.1">Reviewing the requirements for the weather application</span></li>
<li><span class="koboSpan" id="kobo.17.1">Crafting our initial acceptance test</span></li>
<li><span class="koboSpan" id="kobo.18.1">Implementing the City Search feature</span></li>
<li><span class="koboSpan" id="kobo.19.1">Implementing an ACL</span></li>
<li><span class="koboSpan" id="kobo.20.1">Implementing an Add to Favorite feature</span></li>
<li><span class="koboSpan" id="kobo.21.1">Fetching previous weather data when the application relaunches</span></li>
</ul>
<h1 id="_idParaDest-178"><a id="_idTextAnchor325"/><span class="koboSpan" id="kobo.22.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.23.1">A GitHub repository has been created to host all the code we’ll discuss in this book. </span><span class="koboSpan" id="kobo.23.2">For this chapter, you can find the recommended structure at </span><a href="https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch12"><span class="koboSpan" id="kobo.24.1">https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch12</span></a><span class="koboSpan" id="kobo.25.1">.</span></p>
<p><span class="koboSpan" id="kobo.26.1">We need to complete a few more steps before we proceed. </span><span class="koboSpan" id="kobo.26.2">Please follow the next section to set up the necessary API keys.</span></p>
<h2 id="_idParaDest-179"><a id="_idTextAnchor326"/><span class="koboSpan" id="kobo.27.1">Getting the OpenWeatherMap API key</span></h2>
<p><span class="koboSpan" id="kobo.28.1">To utilize OpenWeatherMap, you’ll need </span><a id="_idIndexMarker570"/><span class="koboSpan" id="kobo.29.1">to create an account at </span><a href="https://openweathermap.org/"><span class="koboSpan" id="kobo.30.1">https://openweathermap.org/</span></a><span class="koboSpan" id="kobo.31.1">. </span><span class="koboSpan" id="kobo.31.2">Although various plans are available based on usage, the free plan suffices for our purposes. </span><span class="koboSpan" id="kobo.31.3">After registering, navigate to </span><strong class="bold"><span class="koboSpan" id="kobo.32.1">My API keys</span></strong><span class="koboSpan" id="kobo.33.1"> to find your API key, as displayed in </span><i class="italic"><span class="koboSpan" id="kobo.34.1">Figure 12</span></i><i class="italic"><span class="koboSpan" id="kobo.35.1">.1</span></i><span class="koboSpan" id="kobo.36.1">:</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer075">
<span class="koboSpan" id="kobo.37.1"><img alt="Figure 12.1: The OpenWeatherMap API key" src="image/B31103_12_01.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.38.1">Figure 12.1: The OpenWeatherMap API key</span></figcaption> </figure>
<p><span class="koboSpan" id="kobo.39.1">Keep a copy of this key handy as we’ll use it to make calls to the weather API so that we can fetch data.</span></p>
<h2 id="_idParaDest-180"><a id="_idTextAnchor327"/><span class="koboSpan" id="kobo.40.1">Preparing the project’s code base</span></h2>
<p><span class="koboSpan" id="kobo.41.1">If you</span><a id="_idIndexMarker571"/><span class="koboSpan" id="kobo.42.1"> prefer to follow along with me, you will need to install a few packages before we start. </span><span class="koboSpan" id="kobo.42.2">However, if you want to see the final results, they’re already in the repository mentioned earlier. </span><span class="koboSpan" id="kobo.42.3">I recommend that you follow along to see how we evolve our application into the final state.</span></p>
<p><span class="koboSpan" id="kobo.43.1">To kick things off, we’ll create a new React app using the following commands:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.44.1">
npx create-react-app weather-app --template typescript
cd weather-app
yarn add cypress jest-fetch-mock -D
yarn install</span></pre> <p><span class="koboSpan" id="kobo.45.1">These commands are used to set up a new React project with TypeScript and Cypress:</span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.46.1">npx create-react-app weather-app --template typescript</span></strong><span class="koboSpan" id="kobo.47.1">: This command utilizes </span><strong class="source-inline"><span class="koboSpan" id="kobo.48.1">npx</span></strong><span class="koboSpan" id="kobo.49.1"> to run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.50.1">create-react-app</span></strong><span class="koboSpan" id="kobo.51.1"> utility, which scaffolds out a new React application in a directory named </span><strong class="source-inline"><span class="koboSpan" id="kobo.52.1">weather-app</span></strong><span class="koboSpan" id="kobo.53.1">. </span><span class="koboSpan" id="kobo.53.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">--template typescript</span></strong><span class="koboSpan" id="kobo.55.1"> option specifies that this project should be configured to use TypeScript.</span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.56.1">yarn add cypress jest-fetch-mock -D</span></strong><span class="koboSpan" id="kobo.57.1">: This command installs Cypress, a testing framework, as a development dependency in the project, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">jest-fetch-mock</span></strong><span class="koboSpan" id="kobo.59.1">, for mocking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">fetch</span></strong><span class="koboSpan" id="kobo.61.1"> function in jest tests. </span><span class="koboSpan" id="kobo.61.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">-D</span></strong><span class="koboSpan" id="kobo.63.1"> flag indicates that this is a development dependency, meaning it’s not required for the production version of the application.</span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">yarn install</span></strong><span class="koboSpan" id="kobo.65.1">: This command installs all the dependencies listed in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.66.1">package.json</span></strong><span class="koboSpan" id="kobo.67.1"> file of the project, ensuring that all the necessary libraries and tools are available.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.68.1">Finally, we can start the template application by running the following command:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.69.1">
yarn start</span></pre> <p><span class="koboSpan" id="kobo.70.1">This will launch the application on port 3000. </span><span class="koboSpan" id="kobo.70.2">You can leave the application running on 3000 open and open another terminal window for running tests.</span><a id="_idTextAnchor328"/></p>
<h1 id="_idParaDest-181"><a id="_idTextAnchor329"/><span class="koboSpan" id="kobo.71.1">Reviewing the requirements for the weather application</span></h1>
<p><span class="koboSpan" id="kobo.72.1">Our envisioned</span><a id="_idIndexMarker572"/><span class="koboSpan" id="kobo.73.1"> weather application is designed to be a fully functional platform with the following capabilities:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.74.1">Enables users to search for cities of interest, be it their hometown, current residence, or a future travel destination</span></li>
<li><span class="koboSpan" id="kobo.75.1">Allows users to add cities to a favorite list, with the selection persisting locally for easy access during future visits</span></li>
<li><span class="koboSpan" id="kobo.76.1">Supports the addition of multiple cities to the user’s list</span></li>
<li><span class="koboSpan" id="kobo.77.1">Ensures the site is thoroughly navigable via keyboard, facilitating ease of access for all users</span></li>
</ul>
<p><span class="koboSpan" id="kobo.78.1">The result will resemble what’s illustrated in </span><i class="italic"><span class="koboSpan" id="kobo.79.1">Figure 12</span></i><i class="italic"><span class="koboSpan" id="kobo.80.1">.2</span></i><span class="koboSpan" id="kobo.81.1">:</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer076">
<span class="koboSpan" id="kobo.82.1"><img alt="Figure 12.2: The weather application" src="image/B31103_12_02.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.83.1">Figure 12.2: The weather application</span></figcaption> </figure>
<p><span class="koboSpan" id="kobo.84.1">While it’s not an overly complex application, it encompasses several intriguing elements. </span><span class="koboSpan" id="kobo.84.2">For instance, we’ll </span><a id="_idIndexMarker573"/><span class="koboSpan" id="kobo.85.1">navigate through the hurdles of applying TDD in a UI application, testing Hooks, and making informed decisions on when to employ user acceptance tests versus lower-level tests.</span></p>
<p><span class="koboSpan" id="kobo.86.1">We will commence with an initial acceptance test to ensure the application operates end-to-end, albeit it is merely verifying a single text element’s appearance</span><a id="_idTextAnchor330"/><span class="koboSpan" id="kobo.87.1">.</span></p>
<h1 id="_idParaDest-182"><a id="_idTextAnchor331"/><span class="koboSpan" id="kobo.88.1">Crafting our initial acceptance test</span></h1>
<p><a href="B21103_07.xhtml#_idTextAnchor176"><i class="italic"><span class="koboSpan" id="kobo.89.1">Chapter 7</span></i></a><span class="koboSpan" id="kobo.90.1"> familiarized </span><a id="_idIndexMarker574"/><span class="koboSpan" id="kobo.91.1">us with the notion of starting with an acceptance test – a test that’s approached from an end user’s standpoint, as opposed to a developer’s perspective. </span><span class="koboSpan" id="kobo.91.2">Essentially, we aim for our test to validate aspects a user would perceive or interact with on the web page, rather than technicalities such as function calls or class initializations.</span></p>
<p><span class="koboSpan" id="kobo.92.1">Within the folder you created in the </span><i class="italic"><span class="koboSpan" id="kobo.93.1">Technical requirements</span></i><span class="koboSpan" id="kobo.94.1"> section (that is, </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">weather-app</span></strong><span class="koboSpan" id="kobo.96.1">), create a Cypress test within </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">cypress/e2e/weather.spec.cy.ts</span></strong><span class="koboSpan" id="kobo.98.1">:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.99.1">
describe('weather application', () =&gt; {
  it('displays the application title', () =&gt; {
    cy.visit('http://localhost:3000/');
    cy.contains('Weather Application');
  });
});</span></pre> <p><span class="koboSpan" id="kobo.100.1">In this code snippet, we defined a test suite named </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">weather application</span></strong><span class="koboSpan" id="kobo.102.1">. </span><span class="koboSpan" id="kobo.102.2">It uses the describe function in the Cypress testing framework. </span><span class="koboSpan" id="kobo.102.3">This test case comprises two main actions: navigating to the local development server at http://localhost:3000/ using </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">cy.visit</span></strong><span class="koboSpan" id="kobo.104.1">, and then checking the page to ensure it contains the </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">Weather Application</span></strong><span class="koboSpan" id="kobo.106.1"> text using </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">cy.contains</span></strong><span class="koboSpan" id="kobo.108.1">. </span><span class="koboSpan" id="kobo.108.2">If </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">Weather Application</span></strong><span class="koboSpan" id="kobo.110.1"> is found on the page, the test will pass; if not, it will fail.</span></p>
<p><span class="koboSpan" id="kobo.111.1">Executing the test using </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">npx cypress run</span></strong><span class="koboSpan" id="kobo.113.1"> will, as expected, yield an error on the console due to our yet unmodified app:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.114.1">
  1) weather application
       displays the application title:
     AssertionError: Timed out retrying after 4000ms: Expected to find 
      content: 'Weather Application' but never did.
</span><span class="koboSpan" id="kobo.114.2">      at Context.eval (webpack://tdd-weather/./cypress/e2e/weather.
</span><span class="koboSpan" id="kobo.114.3">       spec.cy.ts:4:7)</span></pre> <p><span class="koboSpan" id="kobo.115.1">This error</span><a id="_idIndexMarker575"/><span class="koboSpan" id="kobo.116.1"> reveals that it was anticipating the </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">Weather Application</span></strong><span class="koboSpan" id="kobo.118.1"> text but didn’t locate it within the default 4-second timeout specified by Cypress. </span><span class="koboSpan" id="kobo.118.2">To rectify this, we’ll need to tweak </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">App.tsx</span></strong><span class="koboSpan" id="kobo.120.1"> so that it includes this text.</span></p>
<p><span class="koboSpan" id="kobo.121.1">After clearing the current content in </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">App.tsx</span></strong><span class="koboSpan" id="kobo.123.1"> (generated by </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">create-react-app</span></strong><span class="koboSpan" id="kobo.125.1">), we’ll insert a simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">h1</span></strong><span class="koboSpan" id="kobo.127.1"> tag to display the text:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.128.1">
import React from 'react';
function App() {
  return (
    &lt;div className="App"&gt;
      &lt;h1&gt;Weather Application&lt;/h1&gt;
    &lt;/div&gt;
  );
}</span></pre> <p><span class="koboSpan" id="kobo.129.1">This code defines a functional component named </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">App</span></strong><span class="koboSpan" id="kobo.131.1"> in React, which renders a </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">div</span></strong><span class="koboSpan" id="kobo.133.1"> element containing an </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">h1</span></strong><span class="koboSpan" id="kobo.135.1"> element with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">Weather Application</span></strong><span class="koboSpan" id="kobo.137.1"> text. </span><span class="koboSpan" id="kobo.137.2">With this heading defined, our Cypress test will pass.</span></p>
<p><span class="koboSpan" id="kobo.138.1">Now, let’s move on to the first meaningful feature – allowing users to search by a city na</span><a id="_idTextAnchor332"/><span class="koboSpan" id="kobo.139.1">me.</span></p>
<h1 id="_idParaDest-183"><a id="_idTextAnchor333"/><span class="koboSpan" id="kobo.140.1">Implementing a City Search feature</span></h1>
<p><span class="koboSpan" id="kobo.141.1">Let’s commence </span><a id="_idIndexMarker576"/><span class="koboSpan" id="kobo.142.1">the development of our first feature – City Search. </span><span class="koboSpan" id="kobo.142.2">Users will be able to enter a city name into a search box, which triggers a request to a remote server. </span><span class="koboSpan" id="kobo.142.3">Upon receiving the data, we’ll render it into a list for user selection. </span><span class="koboSpan" id="kobo.142.4">Throughout this chapter, we’ll utilize the OpenWeatherMap API for city searches as well as retrieving weather informat</span><a id="_idTextAnchor334"/><span class="koboSpan" id="kobo.143.1">ion.</span></p>
<h2 id="_idParaDest-184"><a id="_idTextAnchor335"/><span class="koboSpan" id="kobo.144.1">Introducing the OpenWeatherMap API</span></h2>
<p><span class="koboSpan" id="kobo.145.1">OpenWeatherMap</span><a id="_idIndexMarker577"/><span class="koboSpan" id="kobo.146.1"> is a service that offers global weather data via an API, allowing users to access current, forecasted, and historical weather data for any location worldwide. </span><span class="koboSpan" id="kobo.146.2">It’s a popular choice among developers for embedding real-time weather updates into apps and websites.</span></p>
<p><span class="koboSpan" id="kobo.147.1">We’re going to use two APIs in our weather application – one for searching the city by name and another for getting the actual real-time weather. </span><span class="koboSpan" id="kobo.147.2">To use the API, you’ll need the API key you received when following the instructions in the </span><i class="italic"><span class="koboSpan" id="kobo.148.1">Technical </span></i><i class="italic"><span class="koboSpan" id="kobo.149.1">requirements</span></i><span class="koboSpan" id="kobo.150.1"> section.</span></p>
<p><span class="koboSpan" id="kobo.151.1">You can try sending the request to OpenWeatherMap either in your browser or with a command-line tool such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">curl</span></strong><span class="koboSpan" id="kobo.153.1"> or http (from </span><a href="https://httpie.io/"><span class="koboSpan" id="kobo.154.1">https://httpie.io/</span></a><span class="koboSpan" id="kobo.155.1">):</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.156.1">
http https://api.openweathermap.org/geo/1.0/direct?q="Melbourne"&amp;limit=5&amp;appid=&lt;your-app-key&gt;</span></pre> <p><span class="koboSpan" id="kobo.157.1">This line utilizes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">http</span></strong><span class="koboSpan" id="kobo.159.1"> command to send an HTTP request to the OpenWeatherMap API, specifically to its geocoding endpoint (</span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">geo/1.0/direct</span></strong><span class="koboSpan" id="kobo.161.1">), looking up cities named </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">Melbourne</span></strong><span class="koboSpan" id="kobo.163.1">, with a limit of 5 results. </span><span class="koboSpan" id="kobo.163.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">appid</span></strong><span class="koboSpan" id="kobo.165.1"> (as specified in the preceding URL) parameter is where you need to insert </span><i class="italic"><span class="koboSpan" id="kobo.166.1">your</span></i><span class="koboSpan" id="kobo.167.1"> OpenWeatherMap API key to authenticate the request.</span></p>
<p><span class="koboSpan" id="kobo.168.1">So, the command fetches basic geocoding information about cities named Melbourne, which can later be used to get weather data for those locations. </span><span class="koboSpan" id="kobo.168.2">You will get the result in JSON format, like so:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.169.1">
[
    {
        "country": "AU",
        "lat": -37.8142176,
        "local_names": {},
        "lon": 144.9631608,
        "name": "Melbourne",
        "state": "Victoria"
    },
    {
        "country": "US",
        "lat": 28.106471,
        "local_names": {
        },
        "lon": -80.6371513,
        "name": "Melbourne",
        "state": "Florida"
    }
]</span></pre> <p><span class="koboSpan" id="kobo.170.1">Be aware that </span><a id="_idIndexMarker578"/><span class="koboSpan" id="kobo.171.1">the OpenWeatherMap free plan comes with a rate limit, restricting us to a maximum of 60 requests per minute and 1,000,000 requests per month. </span><span class="koboSpan" id="kobo.171.2">While these limits may seem high, the number of requests can accumulate quickly during development through testing and debugging. </span><span class="koboSpan" id="kobo.171.3">To conserve our request allowance, we’ll avoid making requests to the real server and instead stub these requests, returning predefined values. </span><span class="koboSpan" id="kobo.171.4">For a refresher on stubbing, refer to </span><a href="B21103_05.xhtml#_idTextAnchor124"><i class="italic"><span class="koboSpan" id="kobo.172.1">Chapter 5</span></i></a><span class="koboSpan" id="kobo.173.1">.</span></p>
<p><span class="koboSpan" id="kobo.174.1">Let’s save the resultant data into a text file named </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">search-results.json</span></strong><span class="koboSpan" id="kobo.176.1">, located under </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">cypress/fixtures/search-result</span><a id="_idTextAnchor336"/><span class="koboSpan" id="kobo.178.1">.json</span></strong><span class="koboSpan" id="kobo.179.1">.</span></p>
<h2 id="_idParaDest-185"><a id="_idTextAnchor337"/><span class="koboSpan" id="kobo.180.1">Stubbing the search results</span></h2>
<p><span class="koboSpan" id="kobo.181.1">With </span><a id="_idIndexMarker579"/><span class="koboSpan" id="kobo.182.1">the file in place, we can write a test for the </span><strong class="bold"><span class="koboSpan" id="kobo.183.1">Search city by name</span></strong><span class="koboSpan" id="kobo.184.1"> feature. </span><span class="koboSpan" id="kobo.184.2">As we don’t send the real request to OpenWeatherMap, we’ll intercept network requests that are sent to the API and return the file content we created previously – that is, </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">fixtures/search-result.json</span></strong><span class="koboSpan" id="kobo.186.1">:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.187.1">
import searchResults from '../fixtures/search-result.json';
describe('weather application', () =&gt; {
  //...
</span><span class="koboSpan" id="kobo.187.2">  it('searches for a city', () =&gt; {
    cy.intercept("GET", "https://api.openweathermap.org/geo/1.0/
     direct?q=*", {
      statusCode: 200,
      body: searchResults,
    });
    cy.visit('http://localhost:3000/');
    cy.get('[data-testid="search-input"]').type('Melbourne');
    cy.get('[data-testid="search-input"]').type('{enter}');
    cy.get('[data-testid="search-results"] .search-result')
      .should('have.length', 5);
  });
});</span></pre> <p><span class="koboSpan" id="kobo.188.1">Here, we created a test case called </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">'searches for a city'</span></strong><span class="koboSpan" id="kobo.190.1">. </span><span class="koboSpan" id="kobo.190.2">The test case does the following:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.191.1">First, it sets up an interception for a </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">GET</span></strong><span class="koboSpan" id="kobo.193.1"> request that goes to the OpenWeatherMap API for city searches. </span><span class="koboSpan" id="kobo.193.2">Whenever a request matching the criteria is made, it responds with a 200 status code and the body content from a predefined </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">searchResults</span></strong><span class="koboSpan" id="kobo.195.1"> file, essentially mocking the API response.</span></li>
<li><span class="koboSpan" id="kobo.196.1">Then, it navigates to the application running on </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">http://localhost:3000/</span></strong><span class="koboSpan" id="kobo.198.1">.</span></li>
<li><span class="koboSpan" id="kobo.199.1">Next, it simulates a user typing </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">Melbourne</span></strong><span class="koboSpan" id="kobo.201.1"> into an input field with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">data-testid</span></strong><span class="koboSpan" id="kobo.203.1"> value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">search-input</span></strong><span class="koboSpan" id="kobo.205.1"> and pressing the </span><i class="italic"><span class="koboSpan" id="kobo.206.1">Enter</span></i><span class="koboSpan" id="kobo.207.1"> key.</span></li>
<li><span class="koboSpan" id="kobo.208.1">Lastly, it checks that a container with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">data-testid</span></strong><span class="koboSpan" id="kobo.210.1"> value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">"search-results"</span></strong><span class="koboSpan" id="kobo.212.1"> contains exactly five elements with a class of </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">search-result</span></strong><span class="koboSpan" id="kobo.214.1">, which are the search results that are returned from the stubbed API request. </span><span class="koboSpan" id="kobo.214.2">This verifies that the application correctly displays the search results.</span></li>
</ol>
<p><span class="koboSpan" id="kobo.215.1">We’re in</span><a id="_idIndexMarker580"/><span class="koboSpan" id="kobo.216.1"> the red step in TDD (the first step, which indicates that a test is failing), so let’s go to our application code, </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">App.tsx</span></strong><span class="koboSpan" id="kobo.218.1">, to fix the test:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.219.1">
function App() {
  const [query, setQuery] = useState&lt;string&gt;("");
  const [searchResults, setSearchResults] = useState&lt;any[]&gt;([]);
  const handleKeyDown = (e: KeyboardEvent&lt;HTMLInputElement&gt;) =&gt; {
    if (e.key === "Enter") {
      fetchCities();
    }
  };
  const handleChange = (e: ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {
    setQuery(e.target.value);
  };
  const fetchCities = () =&gt; {
    fetch(
      `https://api.openweathermap.org/geo/1.0/direct?q=${query}&amp;limit=
       5&amp;appid=&lt;app-key&gt;`
    )
      .then((r) =&gt; r.json())
      .then((cities) =&gt; {
        setSearchResults(
          cities.map((city: any) =&gt; ({
            name: city.name,
          }))
        );
      });
  };
  return (
    &lt;div className="app"&gt;
      &lt;h1&gt;Weather Application&lt;/h1&gt;
      &lt;div className="search-bar"&gt;
        &lt;input
          type="text"
          data-testid="search-input"
          onKeyDown={handleKeyDown}
          onChange={handleChange}
          placeholder="Enter city name (e.g. </span><span class="koboSpan" id="kobo.219.2">Melbourne, New York)"
        /&gt;
      &lt;/div&gt;
      &lt;div className="search-results-popup"&gt;
        {searchResults.length &gt; 0 &amp;&amp; (
          &lt;ul data-testid="search-results"&gt;
            {searchResults.map((city, index) =&gt; (
              &lt;li key={index} className="search-result"&gt;
                {city.name}
              &lt;/li&gt;
            ))}
          &lt;/ul&gt;
        )}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</span></pre> <p><span class="koboSpan" id="kobo.220.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">App</span></strong><span class="koboSpan" id="kobo.222.1"> function in </span><a id="_idIndexMarker581"/><span class="koboSpan" id="kobo.223.1">this code sets up a simple weather application using React. </span><span class="koboSpan" id="kobo.223.2">It initializes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">query</span></strong><span class="koboSpan" id="kobo.225.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">searchResults</span></strong><span class="koboSpan" id="kobo.227.1"> state variables to handle user input and display search results, respectively. </span><span class="koboSpan" id="kobo.227.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">handleKeyDown</span></strong><span class="koboSpan" id="kobo.229.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">handleChange</span></strong><span class="koboSpan" id="kobo.231.1"> event handlers are set up to update the search query and trigger a city search when the user presses </span><i class="italic"><span class="koboSpan" id="kobo.232.1">Enter</span></i><span class="koboSpan" id="kobo.233.1">. </span><span class="koboSpan" id="kobo.233.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">fetchCities</span></strong><span class="koboSpan" id="kobo.235.1"> function sends a request to the OpenWeatherMap API, processes the response to extract the city names, and updates </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">searchResults</span></strong><span class="koboSpan" id="kobo.237.1">.</span></p>
<p><span class="koboSpan" id="kobo.238.1">In the TSX part, an</span><a id="_idIndexMarker582"/><span class="koboSpan" id="kobo.239.1"> input field is provided for the user to type a city name, and a list displays the search results whenever there are any available.</span></p>
<p><span class="koboSpan" id="kobo.240.1">The tests are now passing with these changes, and we can launch our browser to access the application. </span><span class="koboSpan" id="kobo.240.2">As depicted in </span><i class="italic"><span class="koboSpan" id="kobo.241.1">Figure 12</span></i><i class="italic"><span class="koboSpan" id="kobo.242.1">.3</span></i><span class="koboSpan" id="kobo.243.1">, our implementation now displays a drop-down list of cities upon conducting a search:</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer077">
<span class="koboSpan" id="kobo.244.1"><img alt="Figure 12.3: The search result dropdown" src="image/B31103_12_03.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.245.1">Figure 12.3: The search result dropdown</span></figcaption> </figure>
<p class="callout-heading"><span class="koboSpan" id="kobo.246.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.247.1">I’ve incorporated some CSS to enhance the visual appeal. </span><span class="koboSpan" id="kobo.247.2">However, to maintain focus on the core content, the CSS has not been included here. </span><span class="koboSpan" id="kobo.247.3">For a complete understanding, you can refer to the repository mentioned in the </span><i class="italic"><span class="koboSpan" id="kobo.248.1">Technical requirements</span></i><span class="koboSpan" id="kobo.249.1"> section to see the full implem</span><a id="_idTextAnchor338"/><span class="koboSpan" id="kobo.250.1">entation.</span></p>
<h2 id="_idParaDest-186"><a id="_idTextAnchor339"/><span class="koboSpan" id="kobo.251.1">Enhancing the search result list</span></h2>
<p><span class="koboSpan" id="kobo.252.1">As we </span><a id="_idIndexMarker583"/><span class="koboSpan" id="kobo.253.1">utilize city names for search queries, it’s common to encounter multiple matches in the search results. </span><span class="koboSpan" id="kobo.253.2">To refine this, we could enrich each item with additional details such as the state name, country name, or even coordinates to make the results more distinctive.</span></p>
<p><span class="koboSpan" id="kobo.254.1">Following the TDD approach, we’ll start with a test. </span><span class="koboSpan" id="kobo.254.2">Although a Cypress test could be crafted, detailing such aspects is better suited for lower-level tests such as unit tests. </span><span class="koboSpan" id="kobo.254.3">Cypress tests are end-to-end, encompassing all the parts – pages, network (even with interceptors) – and from its standpoint, it perceives no components, just HTML, CSS, and JavaScript. </span><span class="koboSpan" id="kobo.254.4">This makes them more costly to run, extending the feedback loop compared to lower-level tests, which generally operate in an in-memory browser and focus on isolated areas.</span></p>
<p><span class="koboSpan" id="kobo.255.1">For this enhancement, we’ll employ Jest tests, which are more lightweight, faster, and offer specificity in test case writing.</span></p>
<p><span class="koboSpan" id="kobo.256.1">In the following snippet, we aim to test if an item displays the city name:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.257.1">
it("shows a city name", () =&gt; {
  render(&lt;SearchResultItem item={{ city: "Melbourne" }} /&gt;);
  expect(screen.getByText("Melbourne")).toBeInTheDocument();
});</span></pre> <p><span class="koboSpan" id="kobo.258.1">Here, we invoke the </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">render</span></strong><span class="koboSpan" id="kobo.260.1"> method from the React Testing Library on a </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">SearchResultItem</span></strong><span class="koboSpan" id="kobo.262.1"> component, passing a prop item with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">city</span></strong><span class="koboSpan" id="kobo.264.1"> field. </span><span class="koboSpan" id="kobo.264.2">Then, we assert that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">Melbourne</span></strong><span class="koboSpan" id="kobo.266.1"> text is present in the document.</span></p>
<p><span class="koboSpan" id="kobo.267.1">At this point, we lack a </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">SearchResultItem</span></strong><span class="koboSpan" id="kobo.269.1"> component ready for testing. </span><span class="koboSpan" id="kobo.269.2">However, a slight refactoring can help us extract one. </span><span class="koboSpan" id="kobo.269.3">Let’s create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">SearchResultItem.tsx</span></strong><span class="koboSpan" id="kobo.271.1"> file and define the component as follows:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.272.1">
export const SearchResultItem = ({ item }: { item: { city: string } }) =&gt; {
  return &lt;li className="search-result"&gt;{item.city}&lt;/li&gt;;
};</span></pre> <p><span class="koboSpan" id="kobo.273.1">Now, integrate</span><a id="_idIndexMarker584"/><span class="koboSpan" id="kobo.274.1"> the component in </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">App.tsx</span></strong><span class="koboSpan" id="kobo.276.1">:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.277.1">
function App() {
  //...
</span><span class="koboSpan" id="kobo.277.2">  &lt;div className="search-results-popup"&gt;
    {searchResults.length &gt; 0 &amp;&amp; (
      &lt;ul data-testid="search-results" className="search-results"&gt;
        {searchResults.map((city, index) =&gt; (
          &lt;SearchResultItem key={index} item={{ city }} /&gt;
        ))}
      &lt;/ul&gt;
    )}
  &lt;/div&gt;
  //...
</span><span class="koboSpan" id="kobo.277.3">}</span></pre> <p><span class="koboSpan" id="kobo.278.1">In this part of </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">App.tsx</span></strong><span class="koboSpan" id="kobo.280.1">, we map through </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">searchResults</span></strong><span class="koboSpan" id="kobo.282.1">, rendering </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">SearchResultItem</span></strong><span class="koboSpan" id="kobo.284.1"> for each city, and passing the city data as a prop.</span></p>
<p><span class="koboSpan" id="kobo.285.1">Now, let’s extend our tests to check for the city name, state, and country:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.286.1">
it("shows a city name, the state, and the country", () =&gt; {
  render(
    &lt;SearchResultItem
      item={{ city: "Melbourne", state: "Victoria", country: 
       "Australia" }}
    /&gt;
  );
  expect(screen.getByText("Melbourne")).toBeInTheDocument();
  expect(screen.getByText("Victoria")).toBeInTheDocument();
  expect(screen.getByText("Australia")).toBeInTheDocument();
});</span></pre> <p><span class="koboSpan" id="kobo.287.1">Next, to</span><a id="_idIndexMarker585"/><span class="koboSpan" id="kobo.288.1"> accommodate these new fields, we’ll tweak the type definition of </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">SearchResultItem</span></strong><span class="koboSpan" id="kobo.290.1"> and render the passed props:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.291.1">
type SearchResultItemProps = {
  city: string;
  state: string;
  country: string;
};
export const SearchResultItem = ({ item }: { item: SearchResultItemProps }) =&gt; {
  return (
    &lt;li className="search-result"&gt;
      &lt;span&gt;{item.city}&lt;/span&gt;
      &lt;span&gt;{item.state}&lt;/span&gt;
      &lt;span&gt;{item.country}&lt;/span&gt;
    &lt;/li&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.292.1">Here, we define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">SearchResultItemProps</span></strong><span class="koboSpan" id="kobo.294.1"> type to specify the shape of the item prop, ensuring it contains the </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">city</span></strong><span class="koboSpan" id="kobo.296.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">state</span></strong><span class="koboSpan" id="kobo.298.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">country</span></strong><span class="koboSpan" id="kobo.300.1"> fields. </span><span class="koboSpan" id="kobo.300.2">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">SearchResultItem</span></strong><span class="koboSpan" id="kobo.302.1"> component then renders these fields within a list item, each in a separate </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">span</span></strong><span class="koboSpan" id="kobo.304.1"> element.</span></p>
<p><span class="koboSpan" id="kobo.305.1">As you can see, now, the</span><a id="_idIndexMarker586"/><span class="koboSpan" id="kobo.306.1"> list item provides more details to help users distinguish between the results:</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer078">
<span class="koboSpan" id="kobo.307.1"><img alt="Figure 12.4: Enhanced city drop-down list" src="image/B31103_12_04.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.308.1">Figure 12.4: Enhanced city drop-down list</span></figcaption> </figure>
<p><span class="koboSpan" id="kobo.309.1">Before we proceed to the next major feature, let’s tackle some housekeeping tasks. </span><span class="koboSpan" id="kobo.309.2">While we’ve been focused on delivering the feature, we haven’t given much attention to code quality so far, so le</span><a id="_idTextAnchor340"/><span class="koboSpan" id="kobo.310.1">t’s do that.</span></p>
<h1 id="_idParaDest-187"><a id="_idTextAnchor341"/><span class="koboSpan" id="kobo.311.1">Implementing an ACL</span></h1>
<p><span class="koboSpan" id="kobo.312.1">Within our</span><a id="_idIndexMarker587"/><span class="koboSpan" id="kobo.313.1"> application, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">SearchResultItem</span></strong><span class="koboSpan" id="kobo.315.1"> component serves its purpose well. </span><span class="koboSpan" id="kobo.315.2">However, the challenge arises from the discrepancy between the data shape we require and the data shape we receive from the remote server.</span></p>
<p><span class="koboSpan" id="kobo.316.1">Consider the server’s response:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.317.1">
[
    {
    "country": "US",
    "lat": 28.106471,
    "local_names": {
      "en": "Melbourne",
      "ja": "メルボーン",
      "ru": "Мельбурн",
      "uk": "Мелборн"
    },
    "lon": -80.6371513,
    "name": "Melbourne",
    "state": "Florida"
  }
]</span></pre> <p><span class="koboSpan" id="kobo.318.1">The server’s response includes many elements we don’t need. </span><span class="koboSpan" id="kobo.318.2">Moreover, we want to shield our </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">SearchResultItem</span></strong><span class="koboSpan" id="kobo.320.1"> component from any future changes to the data shape from the server.</span></p>
<p><span class="koboSpan" id="kobo.321.1">As we discussed in </span><a href="B21103_08.xhtml#_idTextAnchor212"><i class="italic"><span class="koboSpan" id="kobo.322.1">Chapter 8</span></i></a><span class="koboSpan" id="kobo.323.1">, we can employ an ACL to address this issue. </span><span class="koboSpan" id="kobo.323.2">Using this, we aim to map the city name and state directly, but for the country, we want to display its full name to avoid any ambiguity in the UI.</span></p>
<p><span class="koboSpan" id="kobo.324.1">To do this, first, we must define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">RemoteSearchResultItem</span></strong><span class="koboSpan" id="kobo.326.1"> type to represent the remote data shape:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.327.1">
interface RemoteSearchResultItem {
  city: string;
  state: string;
  country: string;
  lon: number;
  lat: number;
  local_names: {
    [key: string]: string
  }
}</span></pre> <p><span class="koboSpan" id="kobo.328.1">Next, we </span><a id="_idIndexMarker588"/><span class="koboSpan" id="kobo.329.1">must change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">SearchResultItemProps</span></strong><span class="koboSpan" id="kobo.331.1"> type to a class, enabling its initialization within the TypeScript code:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.332.1">
const countryMap = {
  "AU": "Australia",
  "US": "United States",
  "GB": "United Kingdom"
  //...
</span><span class="koboSpan" id="kobo.332.2">}
class SearchResultItemType {
  private readonly _city: string;
  private readonly _state: string;
  private readonly _country: string;
  constructor(item: RemoteSearchResultItem) {
    this._city = item.city;
    this._state = item.state;
    this._country = item.country
  }
  get city() {
    return this._city
  }
  get state() {
    return this._state
  }
  get country() {
    return countryMap[this._country] || this._country;
  }
}</span></pre> <p><span class="koboSpan" id="kobo.333.1">This segment </span><a id="_idIndexMarker589"/><span class="koboSpan" id="kobo.334.1">of code defines a class, </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">SearchResultItemType</span></strong><span class="koboSpan" id="kobo.336.1">, that accepts a </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">RemoteSearchResultItem</span></strong><span class="koboSpan" id="kobo.338.1"> object in its </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">constructor</span></strong><span class="koboSpan" id="kobo.340.1"> and initializes its properties accordingly. </span><span class="koboSpan" id="kobo.340.2">It also provides getter methods to access these properties, with a special handler for the country property to the map country code to its full name.</span></p>
<p><span class="koboSpan" id="kobo.341.1">Now, our </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">SearchResultItem</span></strong><span class="koboSpan" id="kobo.343.1"> component can utilize this newly defined class:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.344.1">
import React from "react";
import { SearchResultItemType } from "./models/SearchResultItemType";
export const SearchResultItem = ({ item }: { item: SearchResultItemType }) =&gt; {
  return (
    &lt;li className="search-result"&gt;
      &lt;span&gt;{item.city}&lt;/span&gt;
      &lt;span&gt;{item.state}&lt;/span&gt;
      &lt;span&gt;{item.country}&lt;/span&gt;
    &lt;/li&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.345.1">Note how we</span><a id="_idIndexMarker590"/><span class="koboSpan" id="kobo.346.1"> use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">item.city</span></strong><span class="koboSpan" id="kobo.348.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">item.state</span></strong><span class="koboSpan" id="kobo.350.1"> getter functions, just like a regular JavaScript object.</span></p>
<p><span class="koboSpan" id="kobo.351.1">Then, in our Jest tests, we can verify the transformation logic straightforwardly, as seen here:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.352.1">
it("converts the remote type to local", () =&gt; {
  const remote = {
    country: "US",
    lat: 28.106471,
    local_names: {
      en: "Melbourne",
      ja: "メルボーン",
      ru: "Мельбурн",
      uk: "Мелборн",
    },
    lon: -80.6371513,
    name: "Melbourne",
    state: "Florida",
  };
  const model = new SearchResultItemType(remote);
  expect(model.city).toEqual('Melbourne');
  expect(model.state).toEqual('Florida');
  expect(model.country).toEqual('United States');
});</span></pre> <p><span class="koboSpan" id="kobo.353.1">In this test, we</span><a id="_idIndexMarker591"/><span class="koboSpan" id="kobo.354.1"> create an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">SearchResultItemType</span></strong><span class="koboSpan" id="kobo.356.1"> using a mock </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">RemoteSearchResultItem</span></strong><span class="koboSpan" id="kobo.358.1"> object and verify that the transformation logic works as intended – the fields are correctly mapped and the country has its full name too.</span></p>
<p><span class="koboSpan" id="kobo.359.1">Once the tests confirm the expected behavior, we can apply this new class within our application code, as follows:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.360.1">
const fetchCities = () =&gt; {
  fetch(
    `https://api.openweathermap.org/geo/1.0/direct?q=${query}&amp;limit=5&amp;
     appid=&lt;api-key&gt;`
  )
    .then((r) =&gt; r.json())
    .then((cities) =&gt; {
      setSearchResults(
        cities.map(
          (item: RemoteSearchResultItem) =&gt; new 
           SearchResultItemType(item)
        )
      );
    });
};</span></pre> <p><span class="koboSpan" id="kobo.361.1">This function</span><a id="_idIndexMarker592"/><span class="koboSpan" id="kobo.362.1"> fetches city data from the remote server, transforms the received data into instances of </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">SearchResultItemType</span></strong><span class="koboSpan" id="kobo.364.1">, and then updates the </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">searchResults</span></strong><span class="koboSpan" id="kobo.366.1"> state.</span></p>
<p><span class="koboSpan" id="kobo.367.1">With enriched details in the dropdown, users can identify their desired city. </span><span class="koboSpan" id="kobo.367.2">Having achieved this, we can proceed to allow users to add cities to their favorite list, paving the way to display weather information for these selected cities.</span></p>
<p><span class="koboSpan" id="kobo.368.1">Given our Cypress feature tests, there’s a safeguard against inadvertently breaking functionality. </span><span class="koboSpan" id="kobo.368.2">Additionally, with the newly incorporated unit tests, any discrepancies between remote and local data shapes will be automatically detected. </span><span class="koboSpan" id="kobo.368.3">We are now well-positioned to embark on developing</span><a id="_idTextAnchor342"/><span class="koboSpan" id="kobo.369.1"> the next feature.</span></p>
<h1 id="_idParaDest-188"><a id="_idTextAnchor343"/><span class="koboSpan" id="kobo.370.1">Implementing an Add to Favorite feature</span></h1>
<p><span class="koboSpan" id="kobo.371.1">Let’s investigate</span><a id="_idIndexMarker593"/><span class="koboSpan" id="kobo.372.1"> implementing our next feature: </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">'adds city to favorite list'</span></strong><span class="koboSpan" id="kobo.374.1">. </span><span class="koboSpan" id="kobo.374.2">Because this is a feature that is critical in the weather application, we want to make sure users can see the city being added and that the dropdown is closed.</span></p>
<p><span class="koboSpan" id="kobo.375.1">First, we’ll start with another Cypress test:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.376.1">
it('adds city to favorite list', () =&gt; {
  cy.intercept("GET", "https://api.openweathermap.org/geo/1.0/direct?q=*", {
    statusCode: 200,
    body: searchResults,
  });
  cy.visit('http://localhost:3000/');
  cy.get('[data-testid="search-input"]').type('Melbourne');
  cy.get('[data-testid="search-input"]').type('{enter}');
  cy.get('[data-testid="search-results"] .search-result')
    .first()
    .click();
  cy.get('[data-testid="favorite-cities"] .city')
    .should('have.length', 1);
  cy.get('[data-testid="favorite-cities"] 
   .city:contains("Melbourne")').should('exist');
  cy.get('[data-testid="favorite-cities"] .city:contains("20°C")').
</span><span class="koboSpan" id="kobo.376.2">   should('exist');
})</span></pre> <p><span class="koboSpan" id="kobo.377.1">In the test, we </span><a id="_idIndexMarker594"/><span class="koboSpan" id="kobo.378.1">set up an intercept to mock a </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">GET</span></strong><span class="koboSpan" id="kobo.380.1"> request to the OpenWeatherMap API and then visit the app running on localhost. </span><span class="koboSpan" id="kobo.380.2">From here, it simulates typing </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">Melbourne</span></strong><span class="koboSpan" id="kobo.382.1"> into a search input and hitting </span><i class="italic"><span class="koboSpan" id="kobo.383.1">Enter</span></i><span class="koboSpan" id="kobo.384.1">. </span><span class="koboSpan" id="kobo.384.2">After that, it clicks on the first search result and checks if the favorite cities list now contains one city. </span><span class="koboSpan" id="kobo.384.3">Finally, it verifies that the favorite cities list contains a city element with </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">Melbourne</span></strong><span class="koboSpan" id="kobo.386.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">20°C</span></strong><span class="koboSpan" id="kobo.388.1">.</span></p>
<p><span class="koboSpan" id="kobo.389.1">Please note that there are a few things that need a bit more explanation in the last two lines:</span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">cy.get(selector)</span></strong><span class="koboSpan" id="kobo.391.1">: This Cypress command is used to query DOM elements on a page. </span><span class="koboSpan" id="kobo.391.2">It’s similar to </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">document.querySelector</span></strong><span class="koboSpan" id="kobo.393.1">. </span><span class="koboSpan" id="kobo.393.2">Here, it’s being used to select elements with specific text content inside a particular part of the DOM. </span><span class="koboSpan" id="kobo.393.3">Cypress supports not only the basic CSS selectors, such as class and ID selectors, but also advanced selectors such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">.city:contains("Melbourne")</span></strong><span class="koboSpan" id="kobo.395.1">, so we can use a selector for a more specific selection.</span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">.city:contains(text)</span></strong><span class="koboSpan" id="kobo.397.1">: This is a jQuery-style selector that Cypress supports. </span><span class="koboSpan" id="kobo.397.2">It allows you to select an element containing specific text. </span><span class="koboSpan" id="kobo.397.3">In this case, it’s being used to find elements within </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">[data-testid="favorite-cities"]</span></strong><span class="koboSpan" id="kobo.399.1"> that have a class of </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">city</span></strong><span class="koboSpan" id="kobo.401.1"> and contain </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">Melbourne</span></strong><span class="koboSpan" id="kobo.403.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">20°C</span></strong><span class="koboSpan" id="kobo.405.1">.</span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">.should('exist')</span></strong><span class="koboSpan" id="kobo.407.1">: This is a Cypress command that asserts that the selected elements should exist in the DOM. </span><span class="koboSpan" id="kobo.407.2">If the element does not exist, the test will fail.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.408.1">Now, to get the </span><a id="_idIndexMarker595"/><span class="koboSpan" id="kobo.409.1">weather for the city, we need another API endpoint:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.410.1">
http https://api.openweathermap.org/data/2.5/weather?lat=-37.8142176&amp;lon=144.9631608&amp;appid=&lt;api-key&gt;&amp;units=metric</span></pre> <p><span class="koboSpan" id="kobo.411.1">The API requires two parameters: the latitude and longitude.</span></p>
<p><span class="koboSpan" id="kobo.412.1">Then, it returns the current weather in this format:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.413.1">
{
  //...
</span><span class="koboSpan" id="kobo.413.2">  "main": {
      "feels_like": 20.75,
      "humidity": 56,
      "pressure": 1009,
      "temp": 20.00,
      "temp_max": 23.46,
      "temp_min": 18.71
  },
  "name": "Melbourne",
  "timezone": 39600,
  "visibility": 10000,
  "weather": [
      {
          "description": "clear sky",
          "icon": "01d",
          "id": 800,
          "main": "Clear"
      }
  ],
  //...
</span><span class="koboSpan" id="kobo.413.3">}</span></pre> <p><span class="koboSpan" id="kobo.414.1">There are many</span><a id="_idIndexMarker596"/><span class="koboSpan" id="kobo.415.1"> fields in the response but we only need some of them for now. </span><span class="koboSpan" id="kobo.415.2">We can intercept the request and serve the response in the Cypress test, just like we did for the city search API:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.416.1">
cy.intercept('GET', 'https://api.openweathermap.org/data/2.5/weather*', {
  fixture: 'melbourne.json'
}).as('getWeather')</span></pre> <p><span class="koboSpan" id="kobo.417.1">Transitioning to the implementation, we’ll weave an </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">onClick</span></strong><span class="koboSpan" id="kobo.419.1"> event handler into </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">SearchResultItem</span></strong><span class="koboSpan" id="kobo.421.1">; upon clicking an item, an API call will be triggered, followed by the addition of a city to a list designated for rendering:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.422.1">
export const SearchResultItem = ({
  item,
  onItemClick,
}: {
  item: SearchResultItemType;
  onItemClick: (item: SearchResultItemType) =&gt; void;
}) =&gt; {
  return (
    &lt;li className="search-result" onClick={() =&gt; onItemClick(item)}&gt;
    { /* JSX for rendering the item details */ }
    &lt;/li&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.423.1">Now, let’s dive into</span><a id="_idIndexMarker597"/><span class="koboSpan" id="kobo.424.1"> the application code to interlace the data-fetching logic:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.425.1">
const onItemClick = (item: SearchResultItemType) =&gt; {
  fetch(
    `http https://api.openweathermap.org/data/2.5/weather?lat=${item.latitude}&amp;lon=${item.longitude}&amp;appid=&lt;api-key&gt;&amp;units=metric`
  )
    .then((r) =&gt; r.json())
    .then((cityWeather) =&gt; {
      setCity({
        name: cityWeather.name,
        degree: cityWeather.main.temp,
      });
    });
};</span></pre> <p><span class="koboSpan" id="kobo.426.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">onItemClick</span></strong><span class="koboSpan" id="kobo.428.1"> function is triggered upon clicking a city item. </span><span class="koboSpan" id="kobo.428.2">It makes a network request to the OpenWeatherMap API using the item’s latitude and longitude, fetching the current </span><a id="_idIndexMarker598"/><span class="koboSpan" id="kobo.429.1">weather data for the selected city. </span><span class="koboSpan" id="kobo.429.2">Then, it parses the response to JSON, extracts the city name and temperature from the parsed data, and updates the city state using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">setCity</span></strong><span class="koboSpan" id="kobo.431.1"> function, which will cause the component to re-render and display the selected city’s name and current temperature.</span></p>
<p><span class="koboSpan" id="kobo.432.1">Note the </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">SearchResultItemType</span></strong><span class="koboSpan" id="kobo.434.1"> parameter in the previous snippet. </span><span class="koboSpan" id="kobo.434.2">We’ll need to extend this type so that it encompasses latitude and longitude. </span><span class="koboSpan" id="kobo.434.3">We can achieve this by revisiting the ACL layer in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">SearchResultItemType</span></strong><span class="koboSpan" id="kobo.436.1"> class:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.437.1">
class SearchResultItemType {
  //... </span><span class="koboSpan" id="kobo.437.2">the city, state, country as before
  private readonly _lat: number;
  private readonly _long: number;
  constructor(item: RemoteSearchResultItem) {
    //... </span><span class="koboSpan" id="kobo.437.3">the city, state, country as before
    this._lat = item.lat;
    this._long = item.lon;
  }
  get latitude() {
    return this._lat;
  }
  get longitude() {
    return this._long;
  }
}</span></pre> <p><span class="koboSpan" id="kobo.438.1">With that, we </span><a id="_idIndexMarker599"/><span class="koboSpan" id="kobo.439.1">have extended </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">SearchResultItemType</span></strong><span class="koboSpan" id="kobo.441.1"> with two new fields, </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">latitude</span></strong><span class="koboSpan" id="kobo.443.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">longitude</span></strong><span class="koboSpan" id="kobo.445.1">, which will be used in the API query.</span></p>
<p><span class="koboSpan" id="kobo.446.1">Finally, upon successfully retrieving the city data, it’s time for rendering:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.447.1">
function App() {
  const [city, setCity] = useState(undefined);
  const onItemClick = (item: SearchResultItemType) =&gt; {
    //...
</span><span class="koboSpan" id="kobo.447.2">  }
  return(
      &lt;div className="search-results-popup"&gt;
        {searchResults.length &gt; 0 &amp;&amp; (
          &lt;ul data-testid="search-results"&gt;
            {searchResults.map((item, index) =&gt; (
              &lt;SearchResultItem
                key={index}
                item={item}
                onItemClick={onItemClick}
              /&gt;
            ))}
          &lt;/ul&gt;
        )}
      &lt;/div&gt;
      &lt;div data-testid="favorite-cities"&gt;
        {city &amp;&amp; (
          &lt;div className="city"&gt;
            &lt;span&gt;{city.name}&lt;/span&gt;
            &lt;span&gt;{city.degree}°C&lt;/span&gt;
          &lt;/div&gt;
        )}
      &lt;/div&gt;
  );
}</span></pre> <p><span class="koboSpan" id="kobo.448.1">In this </span><a id="_idIndexMarker600"/><span class="koboSpan" id="kobo.449.1">block of code, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">onItemClick</span></strong><span class="koboSpan" id="kobo.451.1"> function is assigned as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">onClick</span></strong><span class="koboSpan" id="kobo.453.1"> event handler for each </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">SearchResultItem</span></strong><span class="koboSpan" id="kobo.455.1">. </span><span class="koboSpan" id="kobo.455.2">When a city is clicked, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">onItemClick</span></strong><span class="koboSpan" id="kobo.457.1"> function is invoked, triggering a fetch request to retrieve the weather data for the selected city. </span><span class="koboSpan" id="kobo.457.2">Once the data is obtained, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">setCity</span></strong><span class="koboSpan" id="kobo.459.1"> function updates the city state, which then triggers a re-render, displaying the selected city in the </span><strong class="bold"><span class="koboSpan" id="kobo.460.1">Favorite </span></strong><strong class="bold"><span class="koboSpan" id="kobo.461.1">Cities</span></strong><span class="koboSpan" id="kobo.462.1"> section.</span></p>
<p><span class="koboSpan" id="kobo.463.1">Now that all the tests have passed, it signifies that our implementation aligns with the expectations up to this point. </span><span class="koboSpan" id="kobo.463.2">However, before we proceed to the next enhancement, it’s essential to undertake some refactoring to ensure our code base remains robus</span><a id="_idTextAnchor344"/><span class="koboSpan" id="kobo.464.1">t and easily maintainable.</span></p>
<h2 id="_idParaDest-189"><a id="_idTextAnchor345"/><span class="koboSpan" id="kobo.465.1">Modeling the weather</span></h2>
<p><span class="koboSpan" id="kobo.466.1">Just as we</span><a id="_idIndexMarker601"/><span class="koboSpan" id="kobo.467.1"> modeled the city search result, it’s necessary to model the weather for similar reasons – to isolate our implementation from the remote data shape, and to centralize data shape conversion, fallback logic, and so on.</span></p>
<p><span class="koboSpan" id="kobo.468.1">Several areas require refinement. </span><span class="koboSpan" id="kobo.468.2">We must do the following:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.469.1">Ensure all the relevant data is typed</span></li>
<li><span class="koboSpan" id="kobo.470.1">Create a data model for the weather to centralize all formatting logic</span></li>
<li><span class="koboSpan" id="kobo.471.1">Utilize fallback values within the data model when certain data is unavailable</span></li>
</ul>
<p><span class="koboSpan" id="kobo.472.1">Let’s begin with</span><a id="_idIndexMarker602"/><span class="koboSpan" id="kobo.473.1"> the remote data type, </span><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">RemoteCityWeather</span></strong><span class="koboSpan" id="kobo.475.1">:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.476.1">
interface RemoteCityWeather {
  name: string;
  main: {
    temp: number;
    humidity: number;
  };
  weather: [{
    main: string;
    description: string;
  }];
  wind: {
    deg: number;
    speed: number;
  };
}
export type { RemoteCityWeather };</span></pre> <p><span class="koboSpan" id="kobo.477.1">Here, we defined a type called </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">RemoteCityWeather</span></strong><span class="koboSpan" id="kobo.479.1"> to reflect the remote data shape (and have also filtered out a few fields that we don’t use).</span></p>
<p><span class="koboSpan" id="kobo.480.1">Then, we must </span><a id="_idIndexMarker603"/><span class="koboSpan" id="kobo.481.1">define a new type called </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">CityWeather</span></strong><span class="koboSpan" id="kobo.483.1"> for our UI to use CityWeather:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.484.1">
import { RemoteCityWeather } from "./RemoteCityWeather";
export class CityWeather {
  private readonly _name: string;
  private readonly _main: string;
  private readonly _temp: number;
  constructor(weather: RemoteCityWeather) {
    this._name = weather.name;
    this._temp = weather.main.temp;
    this._main = weather.weather[0].main;
  }
  get name() {
    return this._name;
  }
  get degree() {
    return Math.ceil(this._temp);
  }
  get temperature() {
    if (this._temp == null) {
      return "-/-";
    }
    return `${Math.ceil(this._temp)}°C`;
  }
  get main() {
    return this._main.toLowerCase();
  }
}</span></pre> <p><span class="koboSpan" id="kobo.485.1">This code</span><a id="_idIndexMarker604"/><span class="koboSpan" id="kobo.486.1"> defines a </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">CityWeather</span></strong><span class="koboSpan" id="kobo.488.1"> class to model city weather data. </span><span class="koboSpan" id="kobo.488.2">It takes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">RemoteCityWeather</span></strong><span class="koboSpan" id="kobo.490.1"> object as a constructor argument and initializes private fields from it – that is, </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">_name</span></strong><span class="koboSpan" id="kobo.492.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">_temp</span></strong><span class="koboSpan" id="kobo.494.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">_main</span></strong><span class="koboSpan" id="kobo.496.1">. </span><span class="koboSpan" id="kobo.496.2">The class provides getter methods to access a city’s name, rounded temperature in degrees, formatted temperature string, and the weather description in lowercase.</span></p>
<p><span class="koboSpan" id="kobo.497.1">For the temperature’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">getter</span></strong><span class="koboSpan" id="kobo.499.1"> method, if </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">_temp</span></strong><span class="koboSpan" id="kobo.501.1"> is null or undefined, it returns a string, </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">-/-</span></strong><span class="koboSpan" id="kobo.503.1">. </span><span class="koboSpan" id="kobo.503.2">Otherwise, it proceeds to calculate the ceiling (rounding up to the nearest whole number) of </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">_temp</span></strong><span class="koboSpan" id="kobo.505.1"> using </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">Math.ceil(this._temp)</span></strong><span class="koboSpan" id="kobo.507.1">, appends a degree symbol to it, and returns this formatted string. </span><span class="koboSpan" id="kobo.507.2">This way, the method provides a fallback value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">-/-</span></strong><span class="koboSpan" id="kobo.509.1"> when </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">_temp</span></strong><span class="koboSpan" id="kobo.511.1"> is not set while formatting the temperature value when </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">_temp</span></strong><span class="koboSpan" id="kobo.513.1"> is set.</span></p>
<p><span class="koboSpan" id="kobo.514.1">Now, in </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">App</span></strong><span class="koboSpan" id="kobo.516.1">, we can use the calculated logic:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.517.1">
const onItemClick = (item: SearchResultItemType) =&gt; {
  fetch(
    `https://api.openweathermap.org/data/2.5/weather?lat=${item.latitude}&amp;lon=${item.longitude}&amp;appid=&lt;api-key&gt;&amp;units=metric`
  )
    .then((r) =&gt; r.json())
    .then((cityWeather: RemoteCityWeather) =&gt; {
      setCity(new CityWeather(cityWeather));
      setDropdownOpen(false);
    });
};</span></pre> <p><span class="koboSpan" id="kobo.518.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">onItemClick</span></strong><span class="koboSpan" id="kobo.520.1"> function</span><a id="_idIndexMarker605"/><span class="koboSpan" id="kobo.521.1"> is triggered when a city item is clicked. </span><span class="koboSpan" id="kobo.521.2">It makes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">fetch</span></strong><span class="koboSpan" id="kobo.523.1"> request to the OpenWeatherMap API using the latitude and longitude of the clicked city item. </span><span class="koboSpan" id="kobo.523.2">Upon receiving the response, it converts the response into JSON, then creates a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">CityWeather</span></strong><span class="koboSpan" id="kobo.525.1"> instance with the received data, and updates the city state using </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">setCity</span></strong><span class="koboSpan" id="kobo.527.1">.</span></p>
<p><span class="koboSpan" id="kobo.528.1">Additionally, it closes the drop-down menu by setting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">setDropdownOpen</span></strong><span class="koboSpan" id="kobo.530.1"> state to </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">false</span></strong><span class="koboSpan" id="kobo.532.1">. </span><span class="koboSpan" id="kobo.532.2">If we don’t close it off, the Cypress test will not be able to “see” the underlying weather information, which will cause the test to fail, as shown in the following screenshot:</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer079">
<span class="koboSpan" id="kobo.533.1"><img alt="Figure 12.5: The Cypress test failed because the weather is covered" src="image/B31103_12_05.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.534.1">Figure 12.5: The Cypress test failed because the weather is covered</span></figcaption> </figure>
<p><span class="koboSpan" id="kobo.535.1">Then, we must</span><a id="_idIndexMarker606"/><span class="koboSpan" id="kobo.536.1"> render the selected city details correspondingly:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.537.1">
&lt;div data-testid="favorite-cities"&gt;
  {city &amp;&amp; (
    &lt;div className="city"&gt;
      &lt;span&gt;{city.name}&lt;/span&gt;
      &lt;span&gt;{city.temperature}&lt;/span&gt;
    &lt;/div&gt;
  )}
&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.538.1">For rendering the city part, if the city state is defined (that is, a city has been selected), it displays a </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">div</span></strong><span class="koboSpan" id="kobo.540.1"> element with a class name of </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">city</span></strong><span class="koboSpan" id="kobo.542.1">. </span><span class="koboSpan" id="kobo.542.2">Inside this </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">div</span></strong><span class="koboSpan" id="kobo.544.1"> element, we can see the city’s name and temperature using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">city.name</span></strong><span class="koboSpan" id="kobo.546.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">city.temperature</span></strong><span class="koboSpan" id="kobo.548.1"> properties, respectively.</span></p>
<p><span class="koboSpan" id="kobo.549.1">Now, with some additional styling, our application looks like this:</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer080">
<span class="koboSpan" id="kobo.550.1"><img alt="Figure 12.6: Adding a city to the favorite list" src="image/B31103_12_06.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.551.1">Figure 12.6: Adding a city to the favorite list</span></figcaption> </figure>
<p><span class="koboSpan" id="kobo.552.1">We’ve done an excellent</span><a id="_idIndexMarker607"/><span class="koboSpan" id="kobo.553.1"> job with data modeling and have set up a solid ACL to bolster our UI’s robustness and ease of maintenance. </span><span class="koboSpan" id="kobo.553.2">Nonetheless, upon examining the root </span><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">App</span></strong><span class="koboSpan" id="kobo.555.1"> component, we’ll undoubtedly find </span><a id="_idTextAnchor346"/><span class="koboSpan" id="kobo.556.1">areas that require improvement.</span></p>
<h2 id="_idParaDest-190"><a id="_idTextAnchor347"/><span class="koboSpan" id="kobo.557.1">Refactoring the current implementation</span></h2>
<p><span class="koboSpan" id="kobo.558.1">Our current </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">App</span></strong><span class="koboSpan" id="kobo.560.1"> component </span><a id="_idIndexMarker608"/><span class="koboSpan" id="kobo.561.1">has grown too lengthy for easy readability and feature additions, indicating a need for some refactoring to tidy things up. </span><span class="koboSpan" id="kobo.561.2">It doesn’t adhere well to the single responsibility principle as it takes on multiple responsibilities: handling network requests for city search and weather queries, managing the state of the dropdown’s open and closed status, and several event handlers.</span></p>
<p><span class="koboSpan" id="kobo.562.1">One approach to realigning with better design principles is to break the UI into smaller components. </span><span class="koboSpan" id="kobo.562.2">Another is utilizing custom Hooks for state management. </span><span class="koboSpan" id="kobo.562.3">Given that a significant portion of the logic here revolves around managing the state for the city search dropdown, it’s sensible to start by isolating this part.</span></p>
<p><span class="koboSpan" id="kobo.563.1">Let’s start </span><a id="_idIndexMarker609"/><span class="koboSpan" id="kobo.564.1">by extracting all city search-related logic into a custom Hook:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.565.1">
const useSearchCity = () =&gt; {
  const [query, setQuery] = useState&lt;string&gt;("");
  const [searchResults, setSearchResults] = 
   useState&lt;SearchResultItemType[]&gt;(
    []
  );
  const [isDropdownOpen, setDropdownOpen] = useState&lt;boolean&gt;(false);
  const fetchCities = () =&gt; {
    fetch(
      `https://api.openweathermap.org/geo/1.0/direct?q=${query}&amp;limit=
       5&amp;appid=&lt;api-key&gt;`
    )
      .then((r) =&gt; r.json())
      .then((cities) =&gt; {
        setSearchResults(
          cities.map(
            (item: RemoteSearchResultItem) =&gt; new 
             SearchResultItemType(item)
          )
        );
        openDropdownList();
      });
  };
  const openDropdownList = () =&gt; setDropdownOpen(true);
  const closeDropdownList = () =&gt; setDropdownOpen(false);
  return {
    fetchCities,
    setQuery,
    searchResults,
    isDropdownOpen,
    openDropdownList,
    closeDropdownList,
  };
};
export { useSearchCity };</span></pre> <p><span class="koboSpan" id="kobo.566.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">useSearchCity</span></strong><span class="koboSpan" id="kobo.568.1"> Hook manages the city search functionality. </span><span class="koboSpan" id="kobo.568.2">It initializes states for query, search results, and dropdown open status using </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">useState</span></strong><span class="koboSpan" id="kobo.570.1">. </span><span class="koboSpan" id="kobo.570.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">fetchCities</span></strong><span class="koboSpan" id="kobo.572.1"> function</span><a id="_idIndexMarker610"/><span class="koboSpan" id="kobo.573.1"> triggers a network request to fetch cities based on the query, processes the response to create </span><strong class="source-inline"><span class="koboSpan" id="kobo.574.1">SearchResultItemType</span></strong><span class="koboSpan" id="kobo.575.1"> instances, updates the search results state, and opens the drop-down list. </span><span class="koboSpan" id="kobo.575.2">Two functions, </span><strong class="source-inline"><span class="koboSpan" id="kobo.576.1">openDropdownList</span></strong><span class="koboSpan" id="kobo.577.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">closeDropdownList</span></strong><span class="koboSpan" id="kobo.579.1">, are defined to toggle the dropdown’s open status. </span><span class="koboSpan" id="kobo.579.2">The Hook returns an object containing these functionalities, which can be used by components that import and invoke </span><strong class="source-inline"><span class="koboSpan" id="kobo.580.1">useSearchCity</span></strong><span class="koboSpan" id="kobo.581.1">.</span></p>
<p><span class="koboSpan" id="kobo.582.1">Next, we extract a component, </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">SearchCityInput</span></strong><span class="koboSpan" id="kobo.584.1">, to handle all the search input-related work: to handle the </span><i class="italic"><span class="koboSpan" id="kobo.585.1">Enter</span></i><span class="koboSpan" id="kobo.586.1"> key for performing the search, open the drop-down list, and </span><a id="_idIndexMarker611"/><span class="koboSpan" id="kobo.587.1">handle users clicking on each item:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.588.1">
export const SearchCityInput = ({
  onItemClick,
}: {
  onItemClick: (item: SearchResultItemType) =&gt; void;
}) =&gt; {
  const {
    fetchCities,
    setQuery,
    isDropdownOpen,
    closeDropdownList,
    searchResults,
  } = useSearchCity();
  const handleKeyDown = (e: KeyboardEvent&lt;HTMLInputElement&gt;) =&gt; {
    if (e.key === "Enter") {
      fetchCities();
    }
  };
  const handleChange = (e: ChangeEvent&lt;HTMLInputElement&gt;) =&gt;
    setQuery(e.target.value);
  const handleItemClick = (item: SearchResultItemType) =&gt; {
    onItemClick(item);
    closeDropdownList();
  };
  return (
    &lt;&gt;
      &lt;div className="search-bar"&gt;
        &lt;input
          type="text"
          data-testid="search-input"
          onKeyDown={handleKeyDown}
          onChange={handleChange}
          placeholder="Enter city name (e.g. </span><span class="koboSpan" id="kobo.588.2">Melbourne, New York)"
        /&gt;
      &lt;/div&gt;
      {isDropdownOpen &amp;&amp; (
        //... </span><span class="koboSpan" id="kobo.588.3">render the dropdown
      )}
    &lt;/&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.589.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">SearchCityInput</span></strong><span class="koboSpan" id="kobo.591.1"> component is responsible for rendering and managing the user input for searching cities, utilizing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">useSearchCity</span></strong><span class="koboSpan" id="kobo.593.1"> Hook to access search-related functionalities.</span></p>
<p><span class="koboSpan" id="kobo.594.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">handleKeyDown</span></strong><span class="koboSpan" id="kobo.596.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">handleChange</span></strong><span class="koboSpan" id="kobo.598.1"> functions are defined to handle user interactions, triggering a search upon pressing </span><i class="italic"><span class="koboSpan" id="kobo.599.1">Enter</span></i><span class="koboSpan" id="kobo.600.1"> and updating the query on input change, respectively. </span><span class="koboSpan" id="kobo.600.2">Then, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">handleItemClick</span></strong><span class="koboSpan" id="kobo.602.1"> function is defined to handle the action when</span><a id="_idIndexMarker612"/><span class="koboSpan" id="kobo.603.1"> a search result item is clicked, which triggers the </span><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">onItemClick</span></strong><span class="koboSpan" id="kobo.605.1"> prop function and closes the drop-down list.</span></p>
<p><span class="koboSpan" id="kobo.606.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">render</span></strong><span class="koboSpan" id="kobo.608.1"> method, an input field is provided for the user to type the search query, and the drop-down list is conditionally rendered based on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">isDropdownOpen</span></strong><span class="koboSpan" id="kobo.610.1"> state. </span><span class="koboSpan" id="kobo.610.2">If the dropdown is open and there are search results, a list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">SearchResultItem</span></strong><span class="koboSpan" id="kobo.612.1"> components is rendered, each being passed the current item data and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">handleItemClick</span></strong><span class="koboSpan" id="kobo.614.1"> function.</span></p>
<p><span class="koboSpan" id="kobo.615.1">For all the logic of the weather for a city, we can extract another Hook, </span><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">useCityWeather</span></strong><span class="koboSpan" id="kobo.617.1">:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.618.1">
const useFetchCityWeather = () =&gt; {
  const [cityWeather, setCityWeather] = useState&lt;CityWeather | 
   undefined&gt;(undefined);
  const fetchCityWeather = (item: SearchResultItemType) =&gt; {
    fetch(
      `https://api.openweathermap.org/data/2.5/weather?lat=${item.latitude}&amp;lon=${item.longitude}&amp;appid=&lt;api-key&gt;&amp;units=metric`
    )
      .then((r) =&gt; r.json())
      .then((cityWeather: RemoteCityWeather) =&gt; {
        setCityWeather(new CityWeather(cityWeather));
      });
  };
  return {
    cityWeather,
    fetchCityWeather,
  };
};</span></pre> <p><span class="koboSpan" id="kobo.619.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">useFetchCityWeather</span></strong><span class="koboSpan" id="kobo.621.1"> custom Hook is designed to manage the fetching and storing of </span><a id="_idIndexMarker613"/><span class="koboSpan" id="kobo.622.1">weather data for a specified city. </span><span class="koboSpan" id="kobo.622.2">It maintains a state, </span><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">cityWeather</span></strong><span class="koboSpan" id="kobo.624.1">, to hold the weather data. </span><span class="koboSpan" id="kobo.624.2">The Hook provides a function, </span><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">fetchCityWeather</span></strong><span class="koboSpan" id="kobo.626.1">, which takes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">SearchResultItemType</span></strong><span class="koboSpan" id="kobo.628.1"> object as an argument to get the </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">latitude</span></strong><span class="koboSpan" id="kobo.630.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.631.1">longitude</span></strong><span class="koboSpan" id="kobo.632.1"> values for the API call.</span></p>
<p><span class="koboSpan" id="kobo.633.1">Upon receiving the response, it processes the JSON data, creates a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">CityWeather</span></strong><span class="koboSpan" id="kobo.635.1"> object from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">RemoteCityWeather</span></strong><span class="koboSpan" id="kobo.637.1"> data, and updates the </span><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">cityWeather</span></strong><span class="koboSpan" id="kobo.639.1"> state with it. </span><span class="koboSpan" id="kobo.639.2">The Hook returns the </span><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">cityWeather</span></strong><span class="koboSpan" id="kobo.641.1"> state and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">fetchCityWeather</span></strong><span class="koboSpan" id="kobo.643.1"> function for use in other components (</span><strong class="source-inline"><span class="koboSpan" id="kobo.644.1">Weather</span></strong><span class="koboSpan" id="kobo.645.1">, for example).</span></p>
<p><span class="koboSpan" id="kobo.646.1">We could extract a </span><strong class="source-inline"><span class="koboSpan" id="kobo.647.1">Weather</span></strong><span class="koboSpan" id="kobo.648.1"> component to accept </span><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">cityWeather</span></strong><span class="koboSpan" id="kobo.650.1"> and render it:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.651.1">
const Weather = ({ cityWeather }: { cityWeather: CityWeather | undefined }) =&gt; {
  if (cityWeather) {
    return (
      &lt;div className="city"&gt;
        &lt;span&gt;{cityWeather.name}&lt;/span&gt;
        &lt;span&gt;{cityWeather.degree}°C&lt;/span&gt;
      &lt;/div&gt;
    );
  }
  return null;
};</span></pre> <p><span class="koboSpan" id="kobo.652.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.653.1">Weather</span></strong><span class="koboSpan" id="kobo.654.1"> component accepts a prop, </span><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">cityWeather</span></strong><span class="koboSpan" id="kobo.656.1">. </span><span class="koboSpan" id="kobo.656.2">If </span><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">cityWeather</span></strong><span class="koboSpan" id="kobo.658.1"> is defined, the component renders a </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">div</span></strong><span class="koboSpan" id="kobo.660.1"> element with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">city</span></strong><span class="koboSpan" id="kobo.662.1"> class name, displaying the city’s name and temperature in degrees Celsius. </span><span class="koboSpan" id="kobo.662.2">If </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">cityWeather</span></strong><span class="koboSpan" id="kobo.664.1"> is undefined, it returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">null</span></strong><span class="koboSpan" id="kobo.666.1">.</span></p>
<p><span class="koboSpan" id="kobo.667.1">With the </span><a id="_idIndexMarker614"/><span class="koboSpan" id="kobo.668.1">extracted Hook and component, our </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">App.tsx</span></strong><span class="koboSpan" id="kobo.670.1"> is simplified into something like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.671.1">
function App() {
  const { cityWeather, fetchCityWeather } = useFetchCityWeather();
  const onItemClick = (item: SearchResultItemType) =&gt; 
   fetchCityWeather(item);
  return (
    &lt;div className="app"&gt;
      &lt;h1&gt;Weather Application&lt;/h1&gt;
      &lt;SearchCityInput onItemClick={onItemClick} /&gt;
      &lt;div data-testid="favorite-cities"&gt;
        &lt;Weather cityWeather={cityWeather} /&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</span></pre> <p><span class="koboSpan" id="kobo.672.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">App</span></strong><span class="koboSpan" id="kobo.674.1"> function, we’re utilizing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">useFetchCityWeather</span></strong><span class="koboSpan" id="kobo.676.1"> custom Hook to obtain </span><strong class="source-inline"><span class="koboSpan" id="kobo.677.1">cityWeather</span></strong><span class="koboSpan" id="kobo.678.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.679.1">fetchCityWeather</span></strong><span class="koboSpan" id="kobo.680.1"> values. </span><span class="koboSpan" id="kobo.680.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.681.1">onItemClick</span></strong><span class="koboSpan" id="kobo.682.1"> function is defined to call </span><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">fetchCityWeather</span></strong><span class="koboSpan" id="kobo.684.1"> with an item of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">SearchResultItemType</span></strong><span class="koboSpan" id="kobo.686.1"> type. </span><span class="koboSpan" id="kobo.686.2">In the rendering part, we can now simply use the component and functions we extracted.</span></p>
<p><span class="koboSpan" id="kobo.687.1">If we open</span><a id="_idIndexMarker615"/><span class="koboSpan" id="kobo.688.1"> the project folder to examine the current folder structure, we will see that we have different elements defined in distinct modules:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.689.1">
src
├── App.tsx
├── index.tsx
├── models
│   ├── CityWeather.ts
│   ├── RemoteCityWeather.ts
│   ├── RemoteSearchResultItem.ts
│   ├── SearchResultItemType.test.ts
│   └── SearchResultItemType.ts
├── search
│   ├── SearchCityInput.tsx
│   ├── SearchResultItem.test.tsx
│   ├── SearchResultItem.tsx
│   └── useSearchCity.ts
└── weather
    ├── Weather.tsx
    ├── useFetchCityWeather.test.ts
    ├── useFetchCityWeather.ts
    └── weather.css</span></pre> <p><span class="koboSpan" id="kobo.690.1">Now, after all that work, each module possesses a clearer boundary and defined responsibility. </span><span class="koboSpan" id="kobo.690.2">If </span><a id="_idIndexMarker616"/><span class="koboSpan" id="kobo.691.1">you wish to delve into the search functionality, </span><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">SearchCityInput</span></strong><span class="koboSpan" id="kobo.693.1"> is your starting point. </span><span class="koboSpan" id="kobo.693.2">For insights on the actual search execution, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">useSearchCity</span></strong><span class="koboSpan" id="kobo.695.1"> Hook is where you’d look. </span><span class="koboSpan" id="kobo.695.2">Each level maintains its own abstraction and distinct responsibility, simplifying code comprehension and maintenance significantly.</span></p>
<p><span class="koboSpan" id="kobo.696.1">Since our code is in a great state and is ready for us to add more features on top of it, we can </span><a id="_idTextAnchor348"/><span class="koboSpan" id="kobo.697.1">look into enhancing the current feature.</span></p>
<h2 id="_idParaDest-191"><a id="_idTextAnchor349"/><span class="koboSpan" id="kobo.698.1">Enabling multiple cities in the favorite list</span></h2>
<p><span class="koboSpan" id="kobo.699.1">Now, let’s </span><a id="_idIndexMarker617"/><span class="koboSpan" id="kobo.700.1">examine a specific example to illustrate the ease with which we can expand the existing code with a simple feature upgrade. </span><span class="koboSpan" id="kobo.700.2">A user may have several cities they’re interested in, but at present, we can only display one city.</span></p>
<p><span class="koboSpan" id="kobo.701.1">To allow multiple cities in the favorite list, which component should we modify to implement this change? </span><span class="koboSpan" id="kobo.701.2">Correct – the </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">useFetchCityWeather</span></strong><span class="koboSpan" id="kobo.703.1"> Hook. </span><span class="koboSpan" id="kobo.703.2">To enable it so that it can manage a list of cities, we’ll need to display this list within </span><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">App</span></strong><span class="koboSpan" id="kobo.705.1">. </span><span class="koboSpan" id="kobo.705.2">There’s no need to delve into the city search-related files, indicating that this structure has halved the time we would spend sifting through files.</span></p>
<p><span class="koboSpan" id="kobo.706.1">As we’re performing TDD, let’s write a test for the Hook first:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.707.1">
const weatherAPIResponse = JSON.stringify({
  main: {
    temp: 20.0,
  },
  name: "Melbourne",
  weather: [
    {
      description: "clear sky",
      main: "Clear",
    },
  ],
});
const searchResultItem = new SearchResultItemType({
  country: "AU",
  lat: -37.8141705,
  lon: 144.9655616,
  name: "Melbourne",
  state: "Victoria",
});</span></pre> <p><span class="koboSpan" id="kobo.708.1">Firstly, let’s define</span><a id="_idIndexMarker618"/><span class="koboSpan" id="kobo.709.1"> some data we want to test against. </span><span class="koboSpan" id="kobo.709.2">We can initialize data with </span><strong class="source-inline"><span class="koboSpan" id="kobo.710.1">weatherAPIResponse</span></strong><span class="koboSpan" id="kobo.711.1">, which contains a mock response from a weather API in JSON string format, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.712.1">searchResultItem</span></strong><span class="koboSpan" id="kobo.713.1">, which holds an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">SearchResultItemType</span></strong><span class="koboSpan" id="kobo.715.1"> with location details for Melbourne, Australia.</span></p>
<p><span class="koboSpan" id="kobo.716.1">For the actual test case, we’ll need to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">fetchMock</span></strong><span class="koboSpan" id="kobo.718.1"> from </span><strong class="source-inline"><span class="koboSpan" id="kobo.719.1">jest-fetch-mock</span></strong><span class="koboSpan" id="kobo.720.1">; we installed it in the </span><i class="italic"><span class="koboSpan" id="kobo.721.1">Technical </span></i><i class="italic"><span class="koboSpan" id="kobo.722.1">requirements</span></i><span class="koboSpan" id="kobo.723.1"> section:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.724.1">
describe("fetchCityWeather function", () =&gt; {
  beforeEach(() =&gt; {
    fetchMock.resetMocks();
  });
  it("returns a list of cities", async () =&gt; {
    fetchMock.mockResponseOnce(weatherAPIResponse);
    const { result } = renderHook(() =&gt; useFetchCityWeather());
    await act(async () =&gt; {
      await result.current.fetchCityWeather(searchResultItem);
    });
    await waitFor(() =&gt; {
      expect(result.current.cities.length).toEqual(1);
      expect(result.current.cities[0].name).toEqual("Melbourne");
    });
  });
});</span></pre> <p><span class="koboSpan" id="kobo.725.1">The </span><a id="_idIndexMarker619"/><span class="koboSpan" id="kobo.726.1">preceding code sets up a test suite for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.727.1">fetchCityWeather</span></strong><span class="koboSpan" id="kobo.728.1"> function. </span><span class="koboSpan" id="kobo.728.2">Before each test, it resets any mocked fetch calls. </span><span class="koboSpan" id="kobo.728.3">The test case aims to verify that the function returns a list of cities. </span><span class="koboSpan" id="kobo.728.4">It mocks an API response using </span><strong class="source-inline"><span class="koboSpan" id="kobo.729.1">fetchMock.mockResponseOnce</span></strong><span class="koboSpan" id="kobo.730.1">, then invokes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.731.1">useFetchCityWeather</span></strong><span class="koboSpan" id="kobo.732.1"> custom Hook. </span><span class="koboSpan" id="kobo.732.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">fetchCityWeather</span></strong><span class="koboSpan" id="kobo.734.1"> function is called within an </span><strong class="source-inline"><span class="koboSpan" id="kobo.735.1">act</span></strong><span class="koboSpan" id="kobo.736.1"> block to handle state updates. </span><span class="koboSpan" id="kobo.736.2">Finally, the test asserts that the returned list of cities contains one city, </span><strong class="bold"><span class="koboSpan" id="kobo.737.1">Melbourne</span></strong><span class="koboSpan" id="kobo.738.1">.</span></p>
<p><span class="koboSpan" id="kobo.739.1">This setup helps test the </span><strong class="source-inline"><span class="koboSpan" id="kobo.740.1">fetchCityWeather</span></strong><span class="koboSpan" id="kobo.741.1"> function in isolation, ensuring it behaves as expected when provided with a specific input and when receiving a specific API response.</span></p>
<p><span class="koboSpan" id="kobo.742.1">Correspondingly, we need to update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.743.1">useFetchCityWeather</span></strong><span class="koboSpan" id="kobo.744.1"> Hook to enable multiple items:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.745.1">
const useFetchCityWeather = () =&gt; {
  const [cities, setCities] = useState&lt;CityWeather[]&gt;([]);
  const fetchCityWeather = (item: SearchResultItemType) =&gt; {
    //... </span><span class="koboSpan" id="kobo.745.2">fetch
      .then((cityWeather: RemoteCityWeather) =&gt; {
        setCities([new CityWeather(cityWeather), ...cities]);
      });
  };
  return {
    cities,
    fetchCityWeather,
  };
};</span></pre> <p><span class="koboSpan" id="kobo.746.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.747.1">useFetchCityWeather</span></strong><span class="koboSpan" id="kobo.748.1"> Hook now maintains a state of an array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.749.1">CityWeather</span></strong><span class="koboSpan" id="kobo.750.1"> objects called </span><strong class="source-inline"><span class="koboSpan" id="kobo.751.1">cities</span></strong><span class="koboSpan" id="kobo.752.1">. </span><span class="koboSpan" id="kobo.752.2">We still send requests to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.753.1">OpenWeatherMap</span></strong><span class="koboSpan" id="kobo.754.1"> API and then we make sure the new item is inserted at the start of the list</span><a id="_idIndexMarker620"/><span class="koboSpan" id="kobo.755.1"> when it’s fetched. </span><span class="koboSpan" id="kobo.755.2">It returns an object containing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.756.1">cities</span></strong><span class="koboSpan" id="kobo.757.1"> array to the calling place.</span></p>
<p><span class="koboSpan" id="kobo.758.1">Finally, in </span><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">App</span></strong><span class="koboSpan" id="kobo.760.1">, we can iterate over </span><strong class="source-inline"><span class="koboSpan" id="kobo.761.1">cities</span></strong><span class="koboSpan" id="kobo.762.1"> to generate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.763.1">Weather</span></strong><span class="koboSpan" id="kobo.764.1"> component for each one:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.765.1">
function App() {
  //...
</span><span class="koboSpan" id="kobo.765.2">  const { cities, fetchCityWeather } = useFetchCityWeather();
  return (
    &lt;div className="app"&gt;
      {/* other jsx */}
      &lt;div data-testid="favorite-cities"&gt;
        {cities.map((city) =&gt; (
          &lt;Weather key={city.name} cityWeather={city} /&gt;
        ))}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</span></pre> <p><span class="koboSpan" id="kobo.766.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.767.1">cities</span></strong><span class="koboSpan" id="kobo.768.1"> array is </span><a id="_idIndexMarker621"/><span class="koboSpan" id="kobo.769.1">mapped over, and for each </span><strong class="source-inline"><span class="koboSpan" id="kobo.770.1">CityWeather</span></strong><span class="koboSpan" id="kobo.771.1"> object in the array, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.772.1">Weather</span></strong><span class="koboSpan" id="kobo.773.1"> component is rendered. </span><span class="koboSpan" id="kobo.773.2">The key prop for each </span><strong class="source-inline"><span class="koboSpan" id="kobo.774.1">Weather</span></strong><span class="koboSpan" id="kobo.775.1"> component is set to the city’s name, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.776.1">cityWeather</span></strong><span class="koboSpan" id="kobo.777.1"> prop is set to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.778.1">CityWeather</span></strong><span class="koboSpan" id="kobo.779.1"> object itself, which will display the weather information for each city in the list.</span></p>
<p><span class="koboSpan" id="kobo.780.1">Now, we will be able to see something like this in the UI:</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer081">
<span class="koboSpan" id="kobo.781.1"><img alt="Figure 12.7: Showing multiple cities in the favorite list" src="image/B31103_12_07.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.782.1">Figure 12.7: Showing multiple cities in the favorite list</span></figcaption> </figure>
<p><span class="koboSpan" id="kobo.783.1">Before diving</span><a id="_idIndexMarker622"/><span class="koboSpan" id="kobo.784.1"> into our next and final feature, it’s essential to make one more straightforward improvement to the existing code – ensuring adhe</span><a id="_idTextAnchor350"/><span class="koboSpan" id="kobo.785.1">rence to the single responsibility principle.</span></p>
<h2 id="_idParaDest-192"><a id="_idTextAnchor351"/><span class="koboSpan" id="kobo.786.1">Refactoring the weather list</span></h2>
<p><span class="koboSpan" id="kobo.787.1">The</span><a id="_idIndexMarker623"/><span class="koboSpan" id="kobo.788.1"> functionality is operational and all tests have passed; the subsequent focus is on enhancing code quality. </span><span class="koboSpan" id="kobo.788.2">Keep the TDD approach in mind: tackle one task at a time and make incremental improvements. </span><span class="koboSpan" id="kobo.788.3">Then, we can extract a </span><strong class="source-inline"><span class="koboSpan" id="kobo.789.1">WeatherList</span></strong><span class="koboSpan" id="kobo.790.1"> component that renders the whole city list:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.791.1">
const WeatherList = ({ cities }: { cities: CityWeather[] }) =&gt; {
  return (
    &lt;div data-testid="favorite-cities" className="favorite-cities"&gt;
      {cities.map((city) =&gt; (
        &lt;Weather key={city.name} cityWeather={city} /&gt;
      ))}
    &lt;/div&gt;
  );
};</span></pre> <p><span class="koboSpan" id="kobo.792.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.793.1">WeatherList</span></strong><span class="koboSpan" id="kobo.794.1"> component</span><a id="_idIndexMarker624"/><span class="koboSpan" id="kobo.795.1"> receives a cities prop, which is an array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.796.1">CityWeather</span></strong><span class="koboSpan" id="kobo.797.1"> objects. </span><span class="koboSpan" id="kobo.797.2">It iterates through this array using </span><strong class="source-inline"><span class="koboSpan" id="kobo.798.1">map</span></strong><span class="koboSpan" id="kobo.799.1">, rendering a </span><strong class="source-inline"><span class="koboSpan" id="kobo.800.1">Weather</span></strong><span class="koboSpan" id="kobo.801.1"> component for each city.</span></p>
<p><span class="koboSpan" id="kobo.802.1">With the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.803.1">WeatherList</span></strong><span class="koboSpan" id="kobo.804.1"> component in place, </span><strong class="source-inline"><span class="koboSpan" id="kobo.805.1">App.tsx</span></strong><span class="koboSpan" id="kobo.806.1"> will be simplified to something like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.807.1">
function App() {
  const { cities, fetchCityWeather } = useFetchCityWeather();
  const onItemClick = (item: SearchResultItemType) =&gt; 
   fetchCityWeather(item);
  return (
    &lt;div className="app"&gt;
      &lt;h1&gt;Weather Application&lt;/h1&gt;
      &lt;SearchCityInput onItemClick={onItemClick} /&gt;
      &lt;WeatherList cities={cities} /&gt;
    &lt;/div&gt;
  );
}</span></pre> <p><span class="koboSpan" id="kobo.808.1">Fantastic! </span><span class="koboSpan" id="kobo.808.2">Now that our application structure is clean and each component has a single responsibility, this is an opportune time to dive into implementing a new (and the last one) feat</span><a id="_idTextAnchor352"/><span class="koboSpan" id="kobo.809.1">ure to enhance our weather application further.</span></p>
<h1 id="_idParaDest-193"><a id="_idTextAnchor353"/><span class="koboSpan" id="kobo.810.1">Fetching previous weather data when the application relaunches</span></h1>
<p><span class="koboSpan" id="kobo.811.1">For the</span><a id="_idIndexMarker625"/><span class="koboSpan" id="kobo.812.1"> final feature in our weather application, we aim to retain the user’s selections so that upon their next visit to the application, instead of encountering an empty list, they see the cities they selected previously. </span><span class="koboSpan" id="kobo.812.2">This feature is likely to be highly utilized – users will only need to add a few cities initially, and afterward, they may merely open the application to have the weather for their cities loaded automatically.</span></p>
<p><span class="koboSpan" id="kobo.813.1">So, let’s start the feature with a user acceptance test using Cypress:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.814.1">
const items = [
  {
    name: "Melbourne",
    lat: -37.8142,
    lon: 144.9632,
  },
];
it("fetches data when initializing when possible", () =&gt; {
  cy.window().then((window: any) =&gt; {
    window.localStorage.setItem(
      "favoriteItems",
      JSON.stringify(items, null, 2)
    );
  });
  cy.intercept("GET", "https://api.openweathermap.org/data/2.5/
   weather*", {
    fixture: "melbourne.json",
  }).as("getWeather");
  cy.visit("http://localhost:3000/");
  cy.get('[data-testid="favorite-cities"] .city').should("have.
</span><span class="koboSpan" id="kobo.814.2">   length", 1);
  cy.get(
    '[data-testid="favorite-cities"] .city:contains("Melbourne")'
  ).should("exist");
  cy.get('[data-testid="favorite-cities"] .city:contains("20°C")').
</span><span class="koboSpan" id="kobo.814.3">   should(
    "exist"
  );
});</span></pre> <p><span class="koboSpan" id="kobo.815.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.816.1">cy.window()</span></strong><span class="koboSpan" id="kobo.817.1"> command accesses the global window object and sets a </span><strong class="source-inline"><span class="koboSpan" id="kobo.818.1">favoriteItems</span></strong><span class="koboSpan" id="kobo.819.1"> item in </span><strong class="source-inline"><span class="koboSpan" id="kobo.820.1">localStorage</span></strong><span class="koboSpan" id="kobo.821.1"> with the items array. </span><span class="koboSpan" id="kobo.821.2">Following that, </span><strong class="source-inline"><span class="koboSpan" id="kobo.822.1">cy.intercept()</span></strong><span class="koboSpan" id="kobo.823.1"> stubs the network request to the OpenWeatherMap API, using a fixture file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.824.1">melbourne.json</span></strong><span class="koboSpan" id="kobo.825.1"> for the mock response. </span><span class="koboSpan" id="kobo.825.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.826.1">cy.visit()</span></strong><span class="koboSpan" id="kobo.827.1"> command </span><a id="_idIndexMarker626"/><span class="koboSpan" id="kobo.828.1">navigates to the application on </span><strong class="source-inline"><span class="koboSpan" id="kobo.829.1">http://localhost:3000/</span></strong><span class="koboSpan" id="kobo.830.1">. </span><span class="koboSpan" id="kobo.830.2">Once on the page, the test checks for one city item in the favorite cities list, verifies the presence of a city item for </span><strong class="source-inline"><span class="koboSpan" id="kobo.831.1">Melbourne</span></strong><span class="koboSpan" id="kobo.832.1">, and confirms it displays a temperature of </span><strong class="source-inline"><span class="koboSpan" id="kobo.833.1">20°C</span></strong><span class="koboSpan" id="kobo.834.1">.</span></p>
<p><span class="koboSpan" id="kobo.835.1">In other words, we set up one item in </span><strong class="source-inline"><span class="koboSpan" id="kobo.836.1">localStorage</span></strong><span class="koboSpan" id="kobo.837.1"> so that when the page loads, it can read </span><strong class="source-inline"><span class="koboSpan" id="kobo.838.1">localStorage</span></strong><span class="koboSpan" id="kobo.839.1"> and make a request to the remote server, just like what we do in </span><strong class="source-inline"><span class="koboSpan" id="kobo.840.1">onItemClick</span></strong><span class="koboSpan" id="kobo.841.1">.</span></p>
<p><span class="koboSpan" id="kobo.842.1">Next, we’ll need to extract a data fetching function within </span><strong class="source-inline"><span class="koboSpan" id="kobo.843.1">useFetchCityWeather</span></strong><span class="koboSpan" id="kobo.844.1">. </span><span class="koboSpan" id="kobo.844.2">Currently, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.845.1">fetchCityWeather</span></strong><span class="koboSpan" id="kobo.846.1"> function is handling two tasks – fetching data and updating the cities’ state. </span><span class="koboSpan" id="kobo.846.2">To adhere to the single responsibility principle, we should create a </span><a id="_idIndexMarker627"/><span class="koboSpan" id="kobo.847.1">new function solely for fetching data, leaving </span><strong class="source-inline"><span class="koboSpan" id="kobo.848.1">fetchCityWeather</span></strong><span class="koboSpan" id="kobo.849.1"> to handle updating the state:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.850.1">
export const fetchCityWeatherData = async (item: SearchResultItemType) =&gt; {
  const response = await fetch(
    `https://api.openweathermap.org/data/2.5/weather?lat=${item.latitude}&amp;lon=${item.longitude}&amp;appid=&lt;api-key&gt;&amp;units=metric`
  );
  const json = await response.json();
  return new CityWeather(json);
};</span></pre> <p><span class="koboSpan" id="kobo.851.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.852.1">fetchCityWeatherData</span></strong><span class="koboSpan" id="kobo.853.1"> function takes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.854.1">SearchResultItemType</span></strong><span class="koboSpan" id="kobo.855.1"> object as an argument, constructs a URL with the latitude and longitude of the item, and sends a </span><strong class="source-inline"><span class="koboSpan" id="kobo.856.1">fetch</span></strong><span class="koboSpan" id="kobo.857.1"> request to the OpenWeatherMap API. </span><span class="koboSpan" id="kobo.857.2">Upon receiving the response, it converts the response into JSON, creates a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.858.1">CityWeather</span></strong><span class="koboSpan" id="kobo.859.1"> object with the JSON data, and returns it.</span></p>
<p><span class="koboSpan" id="kobo.860.1">Now, </span><strong class="source-inline"><span class="koboSpan" id="kobo.861.1">fetchCityWeather</span></strong><span class="koboSpan" id="kobo.862.1"> can be updated as follows:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.863.1">
const useFetchCityWeather = () =&gt; {
  //...
</span><span class="koboSpan" id="kobo.863.2">  const fetchCityWeather = (item: SearchResultItemType) =&gt; {
    return fetchCityWeatherData(item).then((cityWeather) =&gt; {
      setCities([cityWeather, ...cities]);
    });
  };
  //...
</span><span class="koboSpan" id="kobo.863.3">}</span></pre> <p><span class="koboSpan" id="kobo.864.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.865.1">useFetchCityWeather</span></strong><span class="koboSpan" id="kobo.866.1"> Hook now contains a </span><strong class="source-inline"><span class="koboSpan" id="kobo.867.1">fetchCityWeather</span></strong><span class="koboSpan" id="kobo.868.1"> function that calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.869.1">fetchCityWeatherData</span></strong><span class="koboSpan" id="kobo.870.1"> with a given </span><strong class="source-inline"><span class="koboSpan" id="kobo.871.1">SearchResultItemType</span></strong><span class="koboSpan" id="kobo.872.1"> item. </span><span class="koboSpan" id="kobo.872.2">When the promise resolves, it receives a </span><strong class="source-inline"><span class="koboSpan" id="kobo.873.1">CityWeather</span></strong><span class="koboSpan" id="kobo.874.1"> object and then updates the state cities by adding the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.875.1">CityWeather</span></strong><span class="koboSpan" id="kobo.876.1"> object at the beginning of the existing cities array.</span></p>
<p><span class="koboSpan" id="kobo.877.1">Next, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.878.1">App</span></strong><span class="koboSpan" id="kobo.879.1"> component, we can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.880.1">useEffect</span></strong><span class="koboSpan" id="kobo.881.1"> to hydrate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.882.1">localStorage</span></strong><span class="koboSpan" id="kobo.883.1"> data and </span><a id="_idIndexMarker628"/><span class="koboSpan" id="kobo.884.1">send requests for the actual weather data:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.885.1">
useEffect(() =&gt; {
  const hydrate = async () =&gt; {
    const items = JSON.parse(localStorage.getItem("favoriteItems") || 
     "[]");
    const promises = items.map((item: any) =&gt; {
      const searchResultItem = new SearchResultItemType(item);
      return fetchCityWeatherData(searchResultItem);
    });
    const cities = await Promise.all(promises);
    setCities(cities);
  };
  hydrate();
}, []);</span></pre> <p><span class="koboSpan" id="kobo.886.1">In this code snippet, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.887.1">useEffect</span></strong><span class="koboSpan" id="kobo.888.1"> Hook triggers a function named </span><strong class="source-inline"><span class="koboSpan" id="kobo.889.1">hydrate</span></strong><span class="koboSpan" id="kobo.890.1"> when the component mounts thanks to the empty dependency array, </span><strong class="source-inline"><span class="koboSpan" id="kobo.891.1">[]</span></strong><span class="koboSpan" id="kobo.892.1">.</span></p>
<p><span class="koboSpan" id="kobo.893.1">Inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.894.1">hydrate</span></strong><span class="koboSpan" id="kobo.895.1">, firstly, it retrieves a stringified array from </span><strong class="source-inline"><span class="koboSpan" id="kobo.896.1">localStorage</span></strong><span class="koboSpan" id="kobo.897.1"> under the </span><strong class="source-inline"><span class="koboSpan" id="kobo.898.1">favoriteItems</span></strong><span class="koboSpan" id="kobo.899.1"> key, parsing it back to a JavaScript array, or defaulting to an empty array if the key doesn’t exist. </span><span class="koboSpan" id="kobo.899.2">Then, it maps through this items array, creating a new instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.900.1">SearchResultItemType</span></strong><span class="koboSpan" id="kobo.901.1"> for each item, which it passes to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.902.1">fetchCityWeatherData</span></strong><span class="koboSpan" id="kobo.903.1"> function. </span><span class="koboSpan" id="kobo.903.2">This function returns a promise, which is collected into an array of promises.</span></p>
<p><span class="koboSpan" id="kobo.904.1">Using </span><strong class="source-inline"><span class="koboSpan" id="kobo.905.1">Promise.all</span></strong><span class="koboSpan" id="kobo.906.1">, it </span><a id="_idIndexMarker629"/><span class="koboSpan" id="kobo.907.1">waits for all these promises to resolve before updating the state with </span><strong class="source-inline"><span class="koboSpan" id="kobo.908.1">setCities</span></strong><span class="koboSpan" id="kobo.909.1">, populating it with the fetched city weather data. </span><span class="koboSpan" id="kobo.909.2">Finally, </span><strong class="source-inline"><span class="koboSpan" id="kobo.910.1">hydrate</span></strong><span class="koboSpan" id="kobo.911.1"> is called within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.912.1">useEffect</span></strong><span class="koboSpan" id="kobo.913.1"> to execute this logic upon component mounting.</span></p>
<p><span class="koboSpan" id="kobo.914.1">Finally, to save an item in </span><strong class="source-inline"><span class="koboSpan" id="kobo.915.1">localStorage</span></strong><span class="koboSpan" id="kobo.916.1"> when a user clicks an item, we need a bit more code:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.917.1">
const onItemClick = (item: SearchResultItemType) =&gt; {
  setTimeout(() =&gt; {
    const items = JSON.parse(localStorage.getItem("favoriteItems") || "[]");
    const newItem = {
      name: item.city,
      lon: item.longitude,
      lat: item.latitude,
    };
    localStorage.setItem(
      "favoriteItems",
      JSON.stringify([newItem, ...items], null, 2)
    );
  }, 0);
  return fetchCityWeather(item);
};</span></pre> <p><span class="koboSpan" id="kobo.918.1">Here, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.919.1">onItemClick</span></strong><span class="koboSpan" id="kobo.920.1"> function accepts an argument item of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.921.1">SearchResultItemType</span></strong><span class="koboSpan" id="kobo.922.1"> type. </span><span class="koboSpan" id="kobo.922.2">Inside the function, </span><strong class="source-inline"><span class="koboSpan" id="kobo.923.1">setTimeout</span></strong><span class="koboSpan" id="kobo.924.1"> is utilized with a delay of </span><strong class="source-inline"><span class="koboSpan" id="kobo.925.1">0</span></strong><span class="koboSpan" id="kobo.926.1"> milliseconds, essentially deferring the execution of its contents until after the current call stack has cleared – so, the UI will not be blocked.</span></p>
<p><span class="koboSpan" id="kobo.927.1">Within this </span><a id="_idIndexMarker630"/><span class="koboSpan" id="kobo.928.1">deferred block, it retrieves a stringified array from </span><strong class="source-inline"><span class="koboSpan" id="kobo.929.1">localStorage</span></strong><span class="koboSpan" id="kobo.930.1"> under the </span><strong class="source-inline"><span class="koboSpan" id="kobo.931.1">favoriteItems</span></strong><span class="koboSpan" id="kobo.932.1"> key, parsing it back to a JavaScript array, or defaulting to an empty array if the key doesn’t exist. </span><span class="koboSpan" id="kobo.932.2">Then, it creates a new object, </span><strong class="source-inline"><span class="koboSpan" id="kobo.933.1">newItem</span></strong><span class="koboSpan" id="kobo.934.1">, from the item argument, extracting and renaming some properties.</span></p>
<p><span class="koboSpan" id="kobo.935.1">Following this, it updates the </span><strong class="source-inline"><span class="koboSpan" id="kobo.936.1">favoriteItems</span></strong><span class="koboSpan" id="kobo.937.1"> key in </span><strong class="source-inline"><span class="koboSpan" id="kobo.938.1">localStorage</span></strong><span class="koboSpan" id="kobo.939.1"> with a stringified array containing </span><strong class="source-inline"><span class="koboSpan" id="kobo.940.1">newItem</span></strong><span class="koboSpan" id="kobo.941.1"> at the beginning, followed by the previously stored items.</span></p>
<p><span class="koboSpan" id="kobo.942.1">Outside of </span><strong class="source-inline"><span class="koboSpan" id="kobo.943.1">setTimeout</span></strong><span class="koboSpan" id="kobo.944.1">, it calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.945.1">fetchCityWeather</span></strong><span class="koboSpan" id="kobo.946.1"> with the item argument, fetching weather data for the clicked city, and returns the result of this call from </span><strong class="source-inline"><span class="koboSpan" id="kobo.947.1">onItemClick</span></strong><span class="koboSpan" id="kobo.948.1">.</span></p>
<p><span class="koboSpan" id="kobo.949.1">Now, when we inspect </span><strong class="source-inline"><span class="koboSpan" id="kobo.950.1">localStorage</span></strong><span class="koboSpan" id="kobo.951.1"> in our browser, we will see that the objects are listed in JSON format and that the data will persist until users explicitly clean it:</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer082">
<span class="koboSpan" id="kobo.952.1"><img alt="Figure 12.8: Using data from local storage" src="image/B31103_12_08.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.953.1">Figure 12.8: Using data from local storage</span></figcaption> </figure>
<p><span class="koboSpan" id="kobo.954.1">Excellent job! </span><span class="koboSpan" id="kobo.954.2">Everything </span><a id="_idIndexMarker631"/><span class="koboSpan" id="kobo.955.1">is now functioning well, and the code is in a robust shape that’s easy to build upon. </span><span class="koboSpan" id="kobo.955.2">Moreover, the project structure is intuitive, facilitating easy navigation and file location whenever we need to implement changes.</span></p>
<p><span class="koboSpan" id="kobo.956.1">This chapter was quite extensive and was packed with insightful information, serving as a great recapitulation of the knowledge you’ve acquired thus far. </span><span class="koboSpan" id="kobo.956.2">While it would be engaging to continue adding more features together, I believe now is an opportune time for you to dive in and apply the concepts and techniques you’ve gleaned from this book. </span><span class="koboSpan" id="kobo.956.3">I’ll entrust the enhancement task to you, confident that you’ll make co</span><a id="_idTextAnchor354"/><span class="koboSpan" id="kobo.957.1">mmendable adjustments as you introduce more features.</span></p>
<h1 id="_idParaDest-194"><a id="_idTextAnchor355"/><span class="koboSpan" id="kobo.958.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.959.1">In this chapter, we embarked on creating a weather application from scratch, adhering to the TDD methodology. </span><span class="koboSpan" id="kobo.959.2">We employed Cypress for user acceptance tests and Jest for unit tests, progressively building out the application’s features. </span><span class="koboSpan" id="kobo.959.3">Key practices such as modeling domain objects, stubbing network requests, and applying the single responsibility principle during refactoring were also explored.</span></p>
<p><span class="koboSpan" id="kobo.960.1">While not exhaustive in covering all the techniques from previous chapters, this chapter underscored the importance of maintaining a disciplined pace during the development phase. </span><span class="koboSpan" id="kobo.960.2">It highlighted the value of being able to identify code “smells” and address them effectively, all while ensuring a solid test coverage to foster a robust and maintainable codebase. </span><span class="koboSpan" id="kobo.960.3">This chapter served as a practical synthesis, urging you to apply the acquired knowledge and techniques to enhance the application further.</span></p>
<p><span class="koboSpan" id="kobo.961.1">In the upcoming and concluding chapter, we’ll recap the anti-patterns we’ve explored, revisiting the design principles and practices we’ve examined, and also provide additional resources for further learning.</span></p>
</section>
</body></html>