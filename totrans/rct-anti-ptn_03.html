<html><head></head><body>
<section epub:type="frontmatter chapter" role="doc-chapter">
<h1 class="chapter-number" id="_idParaDest-46"><a id="_idTextAnchor070"/><span class="koboSpan" id="kobo.1.1">3</span></h1>
<h1 id="_idParaDest-47"><a id="_idTextAnchor071"/><span class="koboSpan" id="kobo.2.1">Organizing Your React Application</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Welcome to a chapter dedicated to unraveling the various strategies to structure a React project. </span><span class="koboSpan" id="kobo.3.2">Here, we’ll take a step beyond code and delve into the fascinating world of application architecture – an essential aspect of software development that often doesn’t receive as much attention in the frontend world as it should.</span></p>
<p><span class="koboSpan" id="kobo.4.1">In this chapter, you will learn about different React project structuring strategies – including the feature-based structure, component-based structure, atomic design structure, and </span><strong class="bold"><span class="koboSpan" id="kobo.5.1">Model-View-ViewModel</span></strong><span class="koboSpan" id="kobo.6.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.7.1">MVVM</span></strong><span class="koboSpan" id="kobo.8.1">) structure – and the unique advantages and potential pitfalls that each approach brings to the table. </span><span class="koboSpan" id="kobo.8.2">You’ll also be exposed to practical examples of these structures, gain insights into when to use one over another, and explore the trade-offs that come with each decision.</span></p>
<p><span class="koboSpan" id="kobo.9.1">But why should we care about project structure in the first place? </span><span class="koboSpan" id="kobo.9.2">A well-structured project can significantly enhance code maintainability, make it easier for new team members to understand the system and improve scalability, and even influence the overall success of the project. </span><span class="koboSpan" id="kobo.9.3">In contrast, an inefficient structure can lead to code smells and increased complexity, and it can become a source of technical debt.</span></p>
<p><span class="koboSpan" id="kobo.10.1">By understanding these structuring strategies, you’ll be better equipped to make decisions that can have a long-lasting impact on your project’s health and success. </span><span class="koboSpan" id="kobo.10.2">You’ll be able to assess your project’s specific needs and constraints and use these strategies as a guiding light, enabling you to create a structure that improves code quality, fosters a productive development environment, and ultimately leads to a successful project.</span></p>
<p><span class="koboSpan" id="kobo.11.1">In this chapter, we will cover the following topics:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.12.1">Understanding the problem of a less-structured project</span></li>
<li><span class="koboSpan" id="kobo.13.1">Understanding the complications of frontend applications</span></li>
<li><span class="koboSpan" id="kobo.14.1">Exploring common structures in React applications</span></li>
<li><span class="koboSpan" id="kobo.15.1">Keeping your project structure organized</span></li>
</ul>
<h1 id="_idParaDest-48"><a id="_idTextAnchor072"/><span class="koboSpan" id="kobo.16.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.17.1">A GitHub repository has been created to host all the code we’ll discuss in this book. </span><span class="koboSpan" id="kobo.17.2">For this chapter, you can find the recommended structure at </span><a href="https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch3"><span class="koboSpan" id="kobo.18.1">https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch3</span></a><span class="koboSpan" id="kobo.19.1">.</span></p>
<h1 id="_idParaDest-49"><a id="_idTextAnchor073"/><span class="koboSpan" id="kobo.20.1">Understanding the problem of a less-structured project</span></h1>
<p><span class="koboSpan" id="kobo.21.1">The rapid growth of a project </span><a id="_idIndexMarker122"/><span class="koboSpan" id="kobo.22.1">can be astonishing, leading to a sense of things spiraling out of control. </span><span class="koboSpan" id="kobo.22.2">Initializing a frontend project is typically straightforward, and for small-scale projects, there may be little concern regarding file structure since the number of files to manage is minimal. </span><span class="koboSpan" id="kobo.22.3">However, as the project expands, the need for proper file organization becomes apparent:</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer019">
<span class="koboSpan" id="kobo.23.1"><img alt="Figure 3.1: A simple project might not need a structure" src="image/B21103_03_01.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.24.1">Figure 3.1: A simple project might not need a structure</span></figcaption> </figure>
<p><span class="koboSpan" id="kobo.25.1">The problem with having a less-structured project is that it can lead to several challenges and difficulties in </span><a id="_idIndexMarker123"/><span class="koboSpan" id="kobo.26.1">managing and maintaining the code base effectively. </span><span class="koboSpan" id="kobo.26.2">Some of the key problems that arise from a lack of structure are as follows:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.27.1">Code disorganization</span></strong><span class="koboSpan" id="kobo.28.1">: Without a clear structure, it becomes harder to locate specific code files or components. </span><span class="koboSpan" id="kobo.28.2">This can result in wasted time and effort spent searching for relevant code, especially as the project becomes larger.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.29.1">Poor code reusability</span></strong><span class="koboSpan" id="kobo.30.1">: Without a proper structure, it becomes challenging to identify reusable components or functions. </span><span class="koboSpan" id="kobo.30.2">This can lead to code duplication and a lack of consistency, making it harder to maintain and update the code base in the long run.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.31.1">Difficulty in collaboration</span></strong><span class="koboSpan" id="kobo.32.1">: When team members are working on a less-structured project, it becomes harder to understand and navigate each other’s code. </span><span class="koboSpan" id="kobo.32.2">This can lead to communication gaps, slower development, and an increased risk of introducing bugs or conflicts.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.33.1">Scalability issues</span></strong><span class="koboSpan" id="kobo.34.1">: As the project expands and new features are added, the lack of structure can make it challenging to integrate new components seamlessly. </span><span class="koboSpan" id="kobo.34.2">This can result in a tangled code base that is difficult to extend or modify, leading to decreased productivity and increased development time.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.35.1">Maintenance complexity</span></strong><span class="koboSpan" id="kobo.36.1">: Without a clear organization, maintaining the code base becomes more complex. </span><span class="koboSpan" id="kobo.36.2">Making changes or fixing issues can become a time-consuming task as there may </span><a id="_idIndexMarker124"/><span class="koboSpan" id="kobo.37.1">be a lack of consistency in how code is structured or named.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.38.1">Before proposing a recommended project structure, let’s look at the typical components of a modern frontend project. </span><span class="koboSpan" id="kobo.38.2">Understanding these components will provide a foundation for designing an effective project structure</span><a id="_idTextAnchor074"/><span class="koboSpan" id="kobo.39.1">.</span></p>
<h1 id="_idParaDest-50"><a id="_idTextAnchor075"/><span class="koboSpan" id="kobo.40.1">Understanding the complications of frontend applications</span></h1>
<p><span class="koboSpan" id="kobo.41.1">In a medium-sized frontend project, you may be surprised by the multitude of components required for its successful implementation. </span><span class="koboSpan" id="kobo.41.2">Alongside the core features, numerous other elements contribute to the project’s functionality.</span></p>
<p><span class="koboSpan" id="kobo.42.1">The folder structure of a React project </span><a id="_idIndexMarker125"/><span class="koboSpan" id="kobo.43.1">provides a glimpse into the various aspects you’ll need to manage within a typical React code base:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.44.1">Source code</span></strong><span class="koboSpan" id="kobo.45.1">: This is the heart of your application and contains the JavaScript/TypeScript files that contain your application’s logic, HTML files for structure, and style files for appearance. </span><span class="koboSpan" id="kobo.45.2">Everything that defines the operation and user interface of your application is found here.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.46.1">Assets</span></strong><span class="koboSpan" id="kobo.47.1">: This category holds all the static files, such as images, videos, and fonts, that are utilized by your application. </span><span class="koboSpan" id="kobo.47.2">These files are essential in enhancing the visual experience and interaction of your application, contributing to its overall look and feel.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.48.1">Configuration</span></strong><span class="koboSpan" id="kobo.49.1">: These files hold important parameters that control various aspects of your application. </span><span class="koboSpan" id="kobo.49.2">From dependency information in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.50.1">package.json</span></strong><span class="koboSpan" id="kobo.51.1"> and environment-specific variables to the rules for building your project, these files are crucial for the operation and deployment of your application.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.52.1">Tests</span></strong><span class="koboSpan" id="kobo.53.1">: This category is dedicated to</span><a id="_idIndexMarker126"/><span class="koboSpan" id="kobo.54.1"> ensuring the correctness and stability of your application. </span><span class="koboSpan" id="kobo.54.2">It holds all the unit, integration, and </span><strong class="bold"><span class="koboSpan" id="kobo.55.1">end-to-end tests</span></strong><span class="koboSpan" id="kobo.56.1"> that simulate</span><a id="_idIndexMarker127"/><span class="koboSpan" id="kobo.57.1"> user behavior, validate interactions, and check the functionality of your application, helping to catch and prevent potential bugs.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.58.1">Documentation</span></strong><span class="koboSpan" id="kobo.59.1">: This is where all the informative documents of your application reside. </span><span class="koboSpan" id="kobo.59.2">From the </span><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">README</span></strong><span class="koboSpan" id="kobo.61.1"> file providing an overview of the project to the API documentation and the style guide for coding, these documents help maintain consistency, understanding, and ease of use for anyone interacting with the project.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.62.1">Build artifacts</span></strong><span class="koboSpan" id="kobo.63.1">: These are the outputs of the build process, including bundled and optimized JavaScript, CSS, and HTML files ready for deployment, and other temporary or diagnostic files that help debug build issues. </span><span class="koboSpan" id="kobo.63.2">They’re key to distributing your application to end users.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.64.1">Development tools and configurations</span></strong><span class="koboSpan" id="kobo.65.1">: This is the toolkit that enforces code quality, formatting, and version control and facilitates automated testing and deployment processes. </span><span class="koboSpan" id="kobo.65.2">They work in the background, ensuring a smooth, error-free, and efficient development process.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.66.1">Collectively, these diverse components form the foundation of a typical React code base, highlighting the complexity and breadth of considerations involved in medium-sized frontend proje</span><a id="_idTextAnchor076"/><span class="koboSpan" id="kobo.67.1">cts.</span></p>
<p><span class="koboSpan" id="kobo.68.1">Exploring each feature folder can be an enjoyable experience as it unravels a variety of elements:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.69.1">Common components, such as modal dialogs, navigation menus, buttons, and cards</span></li>
<li><span class="koboSpan" id="kobo.70.1">Dedicated components tailored to specific features, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">SpecialOffer</span></strong><span class="koboSpan" id="kobo.72.1"> for special offers that only display on the menu page or </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">PayWithApple</span></strong><span class="koboSpan" id="kobo.74.1"> for pay with ApplePay</span></li>
<li><span class="koboSpan" id="kobo.75.1">Style definitions using CSS-in-JS or SCSS/LESS code</span></li>
<li><span class="koboSpan" id="kobo.76.1">Various types of testing code, including</span><a id="_idIndexMarker128"/><span class="koboSpan" id="kobo.77.1"> unit tests and browser tests</span></li>
<li><span class="koboSpan" id="kobo.78.1">Calculation logic encapsulated within utility/helper functions</span></li>
<li><span class="koboSpan" id="kobo.79.1">Custom Hooks for reusable functionality</span></li>
<li><span class="koboSpan" id="kobo.80.1">Contexts for security, </span><strong class="bold"><span class="koboSpan" id="kobo.81.1">internationalization</span></strong><span class="koboSpan" id="kobo.82.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.83.1">i18n</span></strong><span class="koboSpan" id="kobo.84.1">), and other specific needs</span></li>
<li><span class="koboSpan" id="kobo.85.1">Additional configuration files such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.86.1">eslint config</span></strong><span class="koboSpan" id="kobo.87.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">jest config</span></strong><span class="koboSpan" id="kobo.89.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">webpack settings</span></strong><span class="koboSpan" id="kobo.91.1">, and more</span></li>
</ul>
<p><span class="koboSpan" id="kobo.92.1">Given the multitude of files, how can we arrange them in a manner that facilitates easy navigation and quick access for modifications? </span><span class="koboSpan" id="kobo.92.2">While there is no one-size-fits-all solution, consistently organizing the code base can greatly assist in this endeavor.</span></p>
<p><span class="koboSpan" id="kobo.93.1">Consistency is paramount when it comes to naming and structuring code elements. </span><span class="koboSpan" id="kobo.93.2">Regardless of the approach that’s chosen, it is crucial to maintain uniformity throughout the project. </span><span class="koboSpan" id="kobo.93.3">For example, if you decide to place style files alongside their respective components, it is essential to adhere to this convention across all components in the code base.</span></p>
<p><span class="koboSpan" id="kobo.94.1">Similarly, if a </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">tests</span></strong><span class="koboSpan" id="kobo.96.1"> folder is being used to house test files, ensure to maintain this convention consistently across the entire code base. </span><span class="koboSpan" id="kobo.96.2">For instance, other naming patterns such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">__tests__ </span></strong><span class="koboSpan" id="kobo.98.1">or </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">specs</span></strong><span class="koboSpan" id="kobo.100.1"> should be avoided to prevent confusion and maintain uniformity.</span></p>
<p><span class="koboSpan" id="kobo.101.1">Having grasped the complexity inherent in medium to large-sized projects, and acknowledging the challenges that a disorganized code base can pose, it’s time we explore some tried-and-tested approaches to structuring our code. </span><span class="koboSpan" id="kobo.101.2">These strategies aim to simplify the development process and make life easier for develo</span><a id="_idTextAnchor077"/><span class="koboSpan" id="kobo.102.1">pers.</span></p>
<h1 id="_idParaDest-51"><a id="_idTextAnchor078"/><span class="koboSpan" id="kobo.103.1">Exploring common structures in React applications</span></h1>
<p><span class="koboSpan" id="kobo.104.1">There are many different ways </span><a id="_idIndexMarker129"/><span class="koboSpan" id="kobo.105.1">of organizing a large React application. </span><span class="koboSpan" id="kobo.105.2">In the following subsections, we will discuss the four most common structures:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.106.1">Feature-based structure</span></li>
<li><span class="koboSpan" id="kobo.107.1">Component-based structure</span></li>
<li><span class="koboSpan" id="kobo.108.1">Atomic design structure</span></li>
<li><span class="koboSpan" id="kobo.109.1">MVVM structure</span></li>
</ul>
<p><span class="koboSpan" id="kobo.110.1">Each structure has its own set of benefits and drawbacks, and the choice depends on the specific requirements and complexity of the project. </span><span class="koboSpan" id="kobo.110.2">Sometimes, we might need to mix them in some way so that they fit our project-specific needs.</span></p>
<p><span class="koboSpan" id="kobo.111.1">To explore these different structure methods further, we’ll use an online shopping application as an example since it’s relatively complicated and you should have some familiarity with that domain already. </span><span class="koboSpan" id="kobo.111.2">The application also contains elements such as API calls, routers, and state manag</span><a id="_idTextAnchor079"/><span class="koboSpan" id="kobo.112.1">ement.</span></p>
<h2 id="_idParaDest-52"><a id="_idTextAnchor080"/><span class="koboSpan" id="kobo.113.1">Feature-based structure</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.114.1">Feature-based structure</span></strong><span class="koboSpan" id="kobo.115.1"> means the</span><a id="_idIndexMarker130"/><span class="koboSpan" id="kobo.116.1"> application is organized based on features or modules. </span><span class="koboSpan" id="kobo.116.2">Each feature contains its own set of components, views, API calls, and state management, allowing for clear separation </span><a id="_idIndexMarker131"/><span class="koboSpan" id="kobo.117.1">and encapsulation of functionality.</span></p>
<p><span class="koboSpan" id="kobo.118.1">With a feature-based architecture in the context of online shopping, you can organize your files and folders as follows:</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer020">
<span class="koboSpan" id="kobo.119.1"><img alt="Figure 3.2: Feature-based structure" src="image/B21103_03_02.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.120.1">Figure 3.2: Feature-based structure</span></figcaption> </figure>
<p><span class="koboSpan" id="kobo.121.1">Let’s take a closer look at this</span><a id="_idIndexMarker132"/><span class="koboSpan" id="kobo.122.1"> structure:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.123.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">features</span></strong><span class="koboSpan" id="kobo.125.1"> directory represents different features of the application, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">Home</span></strong><span class="koboSpan" id="kobo.127.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">Cart</span></strong><span class="koboSpan" id="kobo.129.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">ProductDetails</span></strong><span class="koboSpan" id="kobo.131.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">Checkout</span></strong><span class="koboSpan" id="kobo.133.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">Profile</span></strong><span class="koboSpan" id="kobo.135.1">, and more</span></li>
<li><span class="koboSpan" id="kobo.136.1">Each feature has a folder</span><a id="_idIndexMarker133"/><span class="koboSpan" id="kobo.137.1"> containing </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">components</span></strong><span class="koboSpan" id="kobo.139.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">containers</span></strong><span class="koboSpan" id="kobo.141.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">pages</span></strong><span class="koboSpan" id="kobo.143.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">services</span></strong><span class="koboSpan" id="kobo.145.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">types</span></strong><span class="koboSpan" id="kobo.147.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">utils</span></strong><span class="koboSpan" id="kobo.149.1"> related to that feature</span></li>
<li><span class="koboSpan" id="kobo.150.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">shared</span></strong><span class="koboSpan" id="kobo.152.1"> directory contains reusable </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">components</span></strong><span class="koboSpan" id="kobo.154.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">containers</span></strong><span class="koboSpan" id="kobo.156.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">services</span></strong><span class="koboSpan" id="kobo.158.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">types</span></strong><span class="koboSpan" id="kobo.160.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">utils</span></strong><span class="koboSpan" id="kobo.162.1"> that can be shared across multiple features</span></li>
<li><span class="koboSpan" id="kobo.163.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">api</span></strong><span class="koboSpan" id="kobo.165.1"> directory houses modules for making API calls</span></li>
<li><span class="koboSpan" id="kobo.166.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">store</span></strong><span class="koboSpan" id="kobo.168.1"> directory contains modules for state management (for example, Redux)</span></li>
<li><span class="koboSpan" id="kobo.169.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">router</span></strong><span class="koboSpan" id="kobo.171.1"> directory contains </span><a id="_idIndexMarker134"/><span class="koboSpan" id="kobo.172.1">the routing configuration and related components</span></li>
<li><span class="koboSpan" id="kobo.173.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">App.tsx</span></strong><span class="koboSpan" id="kobo.175.1"> file serves as the entry point of </span><a id="_idIndexMarker135"/><span class="koboSpan" id="kobo.176.1">the </span><a id="_idTextAnchor081"/><span class="koboSpan" id="kobo.177.1">application</span></li>
</ul>
<p><span class="koboSpan" id="kobo.178.1">This method has the following benefits:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.179.1">Clear separation of concerns</span></strong><span class="koboSpan" id="kobo.180.1">: Each </span><a id="_idIndexMarker136"/><span class="koboSpan" id="kobo.181.1">feature has a folder, making it easier to locate and modify related code</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.182.1">Modularity</span></strong><span class="koboSpan" id="kobo.183.1">: Features are self-contained, allowing for easier testing, maintenance, and reuse</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.184.1">Scalability</span></strong><span class="koboSpan" id="kobo.185.1">: New features can be added without directly impacting existing code</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.186.1">Team collaboration</span></strong><span class="koboSpan" id="kobo.187.1">: Developers can work on different features concurrently with minim</span><a id="_idTextAnchor082"/><span class="koboSpan" id="kobo.188.1">al conflicts</span></li>
</ul>
<p><span class="koboSpan" id="kobo.189.1">However, it has the following drawback:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.190.1">Potential duplication</span></strong><span class="koboSpan" id="kobo.191.1">: Features</span><a id="_idIndexMarker137"/><span class="koboSpan" id="kobo.192.1"> may share similar components or logic, leading to some duplication. </span><span class="koboSpan" id="kobo.192.2">Careful planning and refactoring can help m</span><a id="_idTextAnchor083"/><span class="koboSpan" id="kobo.193.1">itigate this.</span></li>
</ul>
<h2 id="_idParaDest-53"><a id="_idTextAnchor084"/><span class="koboSpan" id="kobo.194.1">Component-based structure</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.195.1">Component-based structure</span></strong><span class="koboSpan" id="kobo.196.1"> means the application is organized around reusable components. </span><span class="koboSpan" id="kobo.196.2">Components are categorized </span><a id="_idIndexMarker138"/><span class="koboSpan" id="kobo.197.1">based on their functionality and </span><a id="_idIndexMarker139"/><span class="koboSpan" id="kobo.198.1">can be composed together to build larger views.</span></p>
<p><span class="koboSpan" id="kobo.199.1">With a component-based architecture in the context of online shopping, you can organize your files and folders as follows:</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer021">
<span class="koboSpan" id="kobo.200.1"><img alt="Figure 3.3: Component-based structure" src="image/B21103_03_03.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.201.1">Figure 3.3: Component-based structure</span></figcaption> </figure>
<p><span class="koboSpan" id="kobo.202.1">Let’s take a closer look at this</span><a id="_idIndexMarker140"/><span class="koboSpan" id="kobo.203.1"> structure:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.204.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">components</span></strong><span class="koboSpan" id="kobo.206.1"> folder contains </span><a id="_idIndexMarker141"/><span class="koboSpan" id="kobo.207.1">individual components related to various features of the online shopping application. </span><span class="koboSpan" id="kobo.207.2">Each component is organized into a folder, which may contain child components as necessary.</span></li>
<li><span class="koboSpan" id="kobo.208.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">routes</span></strong><span class="koboSpan" id="kobo.210.1"> folder handles frontend routing in the application. </span><span class="koboSpan" id="kobo.210.2">It includes the main </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">AppRouter.tsx</span></strong><span class="koboSpan" id="kobo.212.1"> file, which configures the routing logic, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">routes.tsx</span></strong><span class="koboSpan" id="kobo.214.1"> file, which defines the individual routes and their corresponding components.</span></li>
<li><span class="koboSpan" id="kobo.215.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">api</span></strong><span class="koboSpan" id="kobo.217.1"> folder contains separate files for different API domains or functionalities. </span><span class="koboSpan" id="kobo.217.2">These files, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">products.ts</span></strong><span class="koboSpan" id="kobo.219.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">cart.ts</span></strong><span class="koboSpan" id="kobo.221.1">,</span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1"> auth.ts</span></strong><span class="koboSpan" id="kobo.223.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">payment.ts</span></strong><span class="koboSpan" id="kobo.225.1">, handle the API calls related to their respective domains.</span></li>
<li><span class="koboSpan" id="kobo.226.1">The example also assumes the use of a state management library such as Redux or React Context API for managing the global ap</span><a id="_idTextAnchor085"/><span class="koboSpan" id="kobo.227.1">plication state.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.228.1">This method has the following benefits:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.229.1">Modularity</span></strong><span class="koboSpan" id="kobo.230.1">: The component-based structure promotes modularity by organizing components into separate files and folders based on their functionality. </span><span class="koboSpan" id="kobo.230.2">This enhances </span><a id="_idIndexMarker142"/><span class="koboSpan" id="kobo.231.1">code maintainability and reusability.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.232.1">Separation of concerns</span></strong><span class="koboSpan" id="kobo.233.1">: Each component focuses on its specific functionality, leading to clearer code and easier debugging. </span><span class="koboSpan" id="kobo.233.2">The separation of concerns improves code readability and maintainability.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.234.1">Code reusability</span></strong><span class="koboSpan" id="kobo.235.1">: With components organized in a modular structure, it becomes easier to reuse</span><a id="_idIndexMarker143"/><span class="koboSpan" id="kobo.236.1"> components across the application or in future projects, leading to improved devel</span><a id="_idTextAnchor086"/><span class="koboSpan" id="kobo.237.1">opment efficiency.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.238.1">However, it has the following drawbacks:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.239.1">Project complexity</span></strong><span class="koboSpan" id="kobo.240.1">: As the project grows, maintaining a complex component structure can become challenging. </span><span class="koboSpan" id="kobo.240.2">It requires </span><a id="_idIndexMarker144"/><span class="koboSpan" id="kobo.241.1">careful planning and adherence to best practices to avoid component sprawl and keep the structure manageable.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.242.1">Learning curve</span></strong><span class="koboSpan" id="kobo.243.1">: The initial learning curve for component-based development and TypeScript may be steeper for developers who are new to these concepts. </span><span class="koboSpan" id="kobo.243.2">However, the benefits that are gained in terms of code organization and maintainability outweigh the initial learning.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.244.1">Potential duplication</span></strong><span class="koboSpan" id="kobo.245.1">: Within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">components</span></strong><span class="koboSpan" id="kobo.247.1"> folder, you may find smaller elements that are identical or closely resemble those in other component folders. </span><span class="koboSpan" id="kobo.247.2">The more you break down these components into finer parts, the greater the likelihood of identifying components that can be reused. </span><span class="koboSpan" id="kobo.247.3">When such reusable components emerge, it’s a good practice to place them in a “shared” folder, like what is shown in a featu</span><a id="_idTextAnchor087"/><span class="koboSpan" id="kobo.248.1">re-based structure.</span></li>
</ul>
<h2 id="_idParaDest-54"><a id="_idTextAnchor088"/><span class="koboSpan" id="kobo.249.1">Atomic design structure</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.250.1">Atomic design</span></strong><span class="koboSpan" id="kobo.251.1"> is a methodology for designing and organizing user interfaces. </span><span class="koboSpan" id="kobo.251.2">It emphasizes the construction of user interfaces by </span><a id="_idIndexMarker145"/><span class="koboSpan" id="kobo.252.1">breaking them down into small, reusable components called atoms, which are combined to form molecules, organisms, templates, and pages.</span></p>
<p><span class="koboSpan" id="kobo.253.1">The key idea behind atomic design is to </span><a id="_idIndexMarker146"/><span class="koboSpan" id="kobo.254.1">create a systematic approach to building UI components that encourages reusability, scalability, and maintainability. </span><span class="koboSpan" id="kobo.254.2">It provides a clear structure for organizing and naming components, making it easier to understand and navigate the UI code</span><a id="_idIndexMarker147"/><span class="koboSpan" id="kobo.255.1"> base.</span></p>
<p><span class="koboSpan" id="kobo.256.1">Here’s how the atomic design methodology categorizes UI components:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.257.1">Atoms</span></strong><span class="koboSpan" id="kobo.258.1">: Atoms are the smallest building blocks of a UI and represent individual elements such as buttons, inputs, icons, or labels. </span><span class="koboSpan" id="kobo.258.2">They are typically simple and self-contained.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.259.1">Molecules</span></strong><span class="koboSpan" id="kobo.260.1">: Molecules are combinations of atoms and represent more complex UI components. </span><span class="koboSpan" id="kobo.260.2">They encapsulate a </span><a id="_idIndexMarker148"/><span class="koboSpan" id="kobo.261.1">group of atoms working together to form a functional unit, such as a form field or a navigation bar.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.262.1">Organisms</span></strong><span class="koboSpan" id="kobo.263.1">: Organisms are larger components that combine molecules and/or atoms to create more significant sections of a UI. </span><span class="koboSpan" id="kobo.263.2">They represent distinct sections of a user interface, such as a header, sidebar, or card component.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.264.1">Templates</span></strong><span class="koboSpan" id="kobo.265.1">: Templates provide a layout structure for arranging organisms and/or molecules. </span><span class="koboSpan" id="kobo.265.2">They define the overall skeleton of a page or a specific section of a UI.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.266.1">Pages</span></strong><span class="koboSpan" id="kobo.267.1">: Pages represent complete user interface screens that are composed of templates, organisms, molecules, and atoms. </span><span class="koboSpan" id="kobo.267.2">They represent the final output visible to the user.</span><p class="list-inset"><span class="koboSpan" id="kobo.268.1">With an atomic design architecture in the context of online shopping, you can organize your files and folders as follows:</span></p></li>
</ul>
<figure>
<div class="IMG---Figure" id="_idContainer022">
<span class="koboSpan" id="kobo.269.1"><img alt="Figure 3.4: Atomic design structure" src="image/B21103_03_04.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.270.1">Figure 3.4: Atomic design structure</span></figcaption> </figure>
<p><span class="koboSpan" id="kobo.271.1">Let’s take a closer look </span><a id="_idIndexMarker149"/><span class="koboSpan" id="kobo.272.1">at this structure:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.273.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">atoms</span></strong><span class="koboSpan" id="kobo.275.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">molecules</span></strong><span class="koboSpan" id="kobo.277.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">organisms</span></strong><span class="koboSpan" id="kobo.279.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">templates</span></strong><span class="koboSpan" id="kobo.281.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">pages</span></strong><span class="koboSpan" id="kobo.283.1"> directories represent the different levels of component composition and abstraction</span></li>
<li><span class="koboSpan" id="kobo.284.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">api</span></strong><span class="koboSpan" id="kobo.286.1"> directory contains the API-related files for making API calls</span></li>
<li><span class="koboSpan" id="kobo.287.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">views</span></strong><span class="koboSpan" id="kobo.289.1"> directory</span><a id="_idIndexMarker150"/><span class="koboSpan" id="kobo.290.1"> contains the individual views that render the components</span></li>
<li><span class="koboSpan" id="kobo.291.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">routes</span></strong><span class="koboSpan" id="kobo.293.1"> directory handles t</span><a id="_idTextAnchor089"/><span class="koboSpan" id="kobo.294.1">he routing configuration</span></li>
</ul>
<p><span class="koboSpan" id="kobo.295.1">This method has the following benefits:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.296.1">Reusability</span></strong><span class="koboSpan" id="kobo.297.1">: Components can be easily reused across the application, promoting code efficiency</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.298.1">Consistency</span></strong><span class="koboSpan" id="kobo.299.1">: The structure encourages a consistent design language and UI pattern</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.300.1">Scalability</span></strong><span class="koboSpan" id="kobo.301.1">: The modular</span><a id="_idIndexMarker151"/><span class="koboSpan" id="kobo.302.1"> approach allows for easy scaling and the addition of new components</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.303.1">Maintainability</span></strong><span class="koboSpan" id="kobo.304.1">: Components are organized in a logical hierarchy, making them easier to locate and update</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.305.1">Collaboration</span></strong><span class="koboSpan" id="kobo.306.1">: The atomic design structure facilitates collaboration between designers and developers as it</span><a id="_idIndexMarker152"/><span class="koboSpan" id="kobo.307.1"> provides a common language fo</span><a id="_idTextAnchor090"/><span class="koboSpan" id="kobo.308.1">r discussing UI components</span></li>
</ul>
<p><span class="koboSpan" id="kobo.309.1">However, it has the following drawbacks:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.310.1">Learning curve</span></strong><span class="koboSpan" id="kobo.311.1">: It may require </span><a id="_idIndexMarker153"/><span class="koboSpan" id="kobo.312.1">some initial learning and adaptation to understand and implement the atomic design principles effectively</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.313.1">Complexity</span></strong><span class="koboSpan" id="kobo.314.1">: As the application grows, managing a large number of components and their relationships can become challenging</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.315.1">Overengineering</span></strong><span class="koboSpan" id="kobo.316.1">: It’s important to strike a balance between component reusability and overengineering as excessive abstraction can intro</span><a id="_idTextAnchor091"/><span class="koboSpan" id="kobo.317.1">duce unnecessary complexity</span></li>
</ul>
<h2 id="_idParaDest-55"><a id="_idTextAnchor092"/><span class="koboSpan" id="kobo.318.1">The MVVM structure</span></h2>
<p><span class="koboSpan" id="kobo.319.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.320.1">MVVM structure</span></strong><span class="koboSpan" id="kobo.321.1"> is a software </span><a id="_idIndexMarker154"/><span class="koboSpan" id="kobo.322.1">architectural pattern that’s primarily used in building user interfaces:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.323.1">The </span><i class="italic"><span class="koboSpan" id="kobo.324.1">Model</span></i><span class="koboSpan" id="kobo.325.1"> represents the actual data </span><a id="_idIndexMarker155"/><span class="koboSpan" id="kobo.326.1">and/or information we are dealing with. </span><span class="koboSpan" id="kobo.326.2">This could be a database, a file, a web service, or even a simple object.</span></li>
<li><span class="koboSpan" id="kobo.327.1">The </span><i class="italic"><span class="koboSpan" id="kobo.328.1">View</span></i><span class="koboSpan" id="kobo.329.1"> is what the user sees and interacts with. </span><span class="koboSpan" id="kobo.329.2">It’s the user interface that presents the Model to the user.</span></li>
<li><span class="koboSpan" id="kobo.330.1">The </span><i class="italic"><span class="koboSpan" id="kobo.331.1">ViewModel</span></i><span class="koboSpan" id="kobo.332.1"> is where most of the logic resides in this pattern. </span><span class="koboSpan" id="kobo.332.2">It is an abstraction of the View that exposes public properties and commands, bridging the gap between the View and the Model, and processes the data from the Model into a format that is easy for</span><a id="_idIndexMarker156"/><span class="koboSpan" id="kobo.333.1"> the View to handle. </span><span class="koboSpan" id="kobo.333.2">It can perform operations on the data and decide how it should be presented to the View.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.334.1">To structure a React application with the MVVM architecture in the context of online shopping, you can organize your files and folders as follows:</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer023">
<span class="koboSpan" id="kobo.335.1"><img alt="Figure 3.5: The MVVM structure" src="image/B21103_03_05.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.336.1">Figure 3.5: The MVVM structure</span></figcaption> </figure>
<p><span class="koboSpan" id="kobo.337.1">Let’s take a closer look </span><a id="_idIndexMarker157"/><span class="koboSpan" id="kobo.338.1">at this structure:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.339.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">components</span></strong><span class="koboSpan" id="kobo.341.1"> directory contains reusable UI components, organized by their respective features</span></li>
<li><span class="koboSpan" id="kobo.342.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">models</span></strong><span class="koboSpan" id="kobo.344.1"> directory includes the data models or entities representing the application’s domain objects, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">CartItemModel</span></strong><span class="koboSpan" id="kobo.346.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">ProductModel</span></strong></li>
<li><span class="koboSpan" id="kobo.348.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">viewmodels</span></strong><span class="koboSpan" id="kobo.350.1"> directory holds the Hooks responsible for managing the state, logic, and interactions of the views</span></li>
<li><span class="koboSpan" id="kobo.351.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">services</span></strong><span class="koboSpan" id="kobo.353.1"> directory contains modules for handling API calls and other external services</span></li>
<li><span class="koboSpan" id="kobo.354.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">views</span></strong><span class="koboSpan" id="kobo.356.1"> directory includes the view components that display the UI based on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">ViewModel</span></strong><span class="koboSpan" id="kobo.358.1"> state</span></li>
<li><span class="koboSpan" id="kobo.359.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">routers</span></strong><span class="koboSpan" id="kobo.361.1"> directory houses the</span><a id="_idIndexMarker158"/><span class="koboSpan" id="kobo.362.1"> routing configuration and components</span></li>
<li><span class="koboSpan" id="kobo.363.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">App.tsx</span></strong><span class="koboSpan" id="kobo.365.1"> file serves as the</span><a id="_idTextAnchor093"/><span class="koboSpan" id="kobo.366.1"> entry point of the application</span></li>
</ul>
<p><span class="koboSpan" id="kobo.367.1">This method has the following benefits:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.368.1">Separation of concerns</span></strong><span class="koboSpan" id="kobo.369.1">: The ViewModel </span><a id="_idIndexMarker159"/><span class="koboSpan" id="kobo.370.1">separates the business logic from the UI components, promoting </span><a id="_idIndexMarker160"/><span class="koboSpan" id="kobo.371.1">cleaner and more maintainable code</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.372.1">Testability</span></strong><span class="koboSpan" id="kobo.373.1">: The ViewModel can be easily unit tested without the need for the actual UI components</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.374.1">Reusability</span></strong><span class="koboSpan" id="kobo.375.1">: Components, models, and services can be reused across different features and views</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.376.1">Scalability</span></strong><span class="koboSpan" id="kobo.377.1">: New features and views can be added while reusing exist</span><a id="_idTextAnchor094"/><span class="koboSpan" id="kobo.378.1">ing ViewModel and service modules</span></li>
</ul>
<p><span class="koboSpan" id="kobo.379.1">However, it has the following </span><a id="_idIndexMarker161"/><span class="koboSpan" id="kobo.380.1">drawbacks:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.381.1">Complexity</span></strong><span class="koboSpan" id="kobo.382.1">: Implementing the MVVM pattern may introduce additional layers of abstraction and complexity to the application, especially for smaller projects</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.383.1">Learning curve</span></strong><span class="koboSpan" id="kobo.384.1">: Developers need to understand the concepts and principles of MVVM to effectively structure and manage the application</span></li>
</ul>
<p><span class="koboSpan" id="kobo.385.1">Now that we have explored these four popular structures, let’s delve into the continuous evolution of our application’s structure. </span><span class="koboSpan" id="kobo.385.2">This ongoing process ensures that the structure remains beneficial for developers in terms of easy navigation, seamless addition of new features, and the ability </span><a id="_idTextAnchor095"/><span class="koboSpan" id="kobo.386.1">to maintain scalability over time.</span></p>
<h1 id="_idParaDest-56"><a id="_idTextAnchor096"/><span class="koboSpan" id="kobo.387.1">Keeping your project structure organized</span></h1>
<p><span class="koboSpan" id="kobo.388.1">The feature-based structure is always a good starting point. </span><span class="koboSpan" id="kobo.388.2">As the project expands and patterns of duplication start to</span><a id="_idIndexMarker162"/><span class="koboSpan" id="kobo.389.1"> emerge, an additional layer can be introduced to eliminate redundancy.</span></p>
<p><span class="koboSpan" id="kobo.390.1">For instance, let’s use the online shopping application again. </span><span class="koboSpan" id="kobo.390.2">It contains various pages:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.391.1">Home page</span></li>
<li><span class="koboSpan" id="kobo.392.1">Log in/sign up</span></li>
<li><span class="koboSpan" id="kobo.393.1">Store address search</span></li>
<li><span class="koboSpan" id="kobo.394.1">Product list</span></li>
<li><span class="koboSpan" id="kobo.395.1">Shopping cart</span></li>
<li><span class="koboSpan" id="kobo.396.1">Order details</span></li>
<li><span class="koboSpan" id="kobo.397.1">Payment</span></li>
<li><span class="koboSpan" id="kobo.398.1">Profile</span></li>
<li><span class="koboSpan" id="kobo.399.1">Coupon</span></li>
</ul>
<p><span class="koboSpan" id="kobo.400.1">In the initial stages, organizing pages based on their features is a common approach. </span><span class="koboSpan" id="kobo.400.2">We can create a folder for each feature and put all the related components, st</span><a id="_idTextAnchor097"/><span class="koboSpan" id="kobo.401.1">yles, and tests inside that folder.</span></p>
<h2 id="_idParaDest-57"><a id="_idTextAnchor098"/><span class="koboSpan" id="kobo.402.1">Implementing the initial structure</span></h2>
<p><span class="koboSpan" id="kobo.403.1">The initial folder structure in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">src</span></strong><span class="koboSpan" id="kobo.405.1"> directory is </span><a id="_idIndexMarker163"/><span class="koboSpan" id="kobo.406.1">quite straightforward and follows a feature-based approach, with each page having its own folder:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.407.1">
├── Address
│   ├── AddressList
│   └── Store
├── Home
├── Login
├── Order
├── Payment
├── Product
├── Profile
│   └── Coupon
└── SignUp</span></pre> <p><span class="koboSpan" id="kobo.408.1">However, as the project evolves, you may encounter duplication of components or functionalities across different pages. </span><span class="koboSpan" id="kobo.408.2">To address this, it becomes necessary to introduce an additional layer of abstraction.</span></p>
<p><span class="koboSpan" id="kobo.409.1">For example, if both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">Login</span></strong><span class="koboSpan" id="kobo.411.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">Order</span></strong><span class="koboSpan" id="kobo.413.1"> pages require a </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">Button</span></strong><span class="koboSpan" id="kobo.415.1"> component, it would be impractical to have</span><a id="_idIndexMarker164"/><span class="koboSpan" id="kobo.416.1"> separate implementations of the button on each page. </span><span class="koboSpan" id="kobo.416.2">Instead, you can extract the </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">Button</span></strong><span class="koboSpan" id="kobo.418.1"> component into a separate layer, such as a components or shared folder. </span><span class="koboSpan" id="kobo.418.2">This way, </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">Button</span></strong><span class="koboSpan" id="kobo.420.1"> can be reused acros</span><a id="_idTextAnchor099"/><span class="koboSpan" id="kobo.421.1">s multiple pages without duplication.</span></p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor100"/><span class="koboSpan" id="kobo.422.1">Adding an extra layer to remove duplicates</span></h2>
<p><span class="koboSpan" id="kobo.423.1">By adding this extra layer, you </span><a id="_idIndexMarker165"/><span class="koboSpan" id="kobo.424.1">promote reusability and maintainability in your code base. </span><span class="koboSpan" id="kobo.424.2">It helps in eliminating redundancy, streamlining development efforts, and ensuring consistency throughout the application. </span><span class="koboSpan" id="kobo.424.3">As the project expands, this modular approach allows for easy management and scalability, making it easier to add new features or make changes without impacting the entire code base.</span></p>
<p><span class="koboSpan" id="kobo.425.1">So, you can create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">components</span></strong><span class="koboSpan" id="kobo.427.1"> folder for all the reusable components and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">pages</span></strong><span class="koboSpan" id="kobo.429.1"> folder for all the feature pages, like so:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.430.1">
├── components
│   ├── Accordion
│   ├── GenericCard
│   ├── Modal
│   ├── Offer
│   │   └── SpecialOffer
│   └── StackView
└── pages
    ├── Address
    │   ├── AddressList
    │   └── Store
    ├── Home
    ├── Login
    ├── Order
    ├── Payment
    ├── Product
    ├── Profile
    │   └── Coupon
    └── SignUp</span></pre> <p><span class="koboSpan" id="kobo.431.1">As the project expands, it becomes necessary to create a separate components folder to house reusable components that are shared across different pages. </span><span class="koboSpan" id="kobo.431.2">In this structure, each component is organized within</span><a id="_idIndexMarker166"/><span class="koboSpan" id="kobo.432.1"> its respective folder, promoting modularity and code reuse. </span><span class="koboSpan" id="kobo.432.2">Additionally, you can introduce nested folders to represent component hierarchies, such as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">Offer</span></strong><span class="koboSpan" id="kobo.434.1"> folder, which contains a specific component called </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">SpecialOffer</span></strong><span class="koboSpan" id="kobo.436.1">.</span></p>
<p><span class="koboSpan" id="kobo.437.1">Alongside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">components</span></strong><span class="koboSpan" id="kobo.439.1"> folder, you may need folders for other essential elements. </span><span class="koboSpan" id="kobo.439.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">pages</span></strong><span class="koboSpan" id="kobo.441.1"> folder contains feature-specific pages, while the </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">hooks</span></strong><span class="koboSpan" id="kobo.443.1"> folder houses React Hooks that provide reusable logic and functionality. </span><span class="koboSpan" id="kobo.443.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">context</span></strong><span class="koboSpan" id="kobo.445.1"> folder is used for managing the global state and provides different contexts that can be shared throughout the application.</span></p>
<p><span class="koboSpan" id="kobo.446.1">It’s important to note that not all components need to be moved to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">components</span></strong><span class="koboSpan" id="kobo.448.1"> folder. </span><span class="koboSpan" id="kobo.448.2">Only components that exhibit duplication across different pages should be lifted to the shared folder, ensuring that you maintain a balance between modularity and unnecessary complexity.</span></p>
<p><span class="koboSpan" id="kobo.449.1">This file structure allows for better organization, code reuse, and scalability as the project grows. </span><span class="koboSpan" id="kobo.449.2">It promotes maintainability by reducing redundancy and ensuring consistency across the </span><a id="_idIndexMarker167"/><span class="koboSpan" id="kobo.450.1">application. </span><span class="koboSpan" id="kobo.450.2">Additionally, having a separate folder for Hooks and contexts helps centralize related code and makes it easier to manage and m</span><a id="_idTextAnchor101"/><span class="koboSpan" id="kobo.451.1">aintain global state and reusable logic.</span></p>
<h2 id="_idParaDest-59"><a id="_idTextAnchor102"/><span class="koboSpan" id="kobo.452.1">Naming files</span></h2>
<p><span class="koboSpan" id="kobo.453.1">In an individual component, there are different approaches to naming files, and each approach has its advantages</span><a id="_idIndexMarker168"/><span class="koboSpan" id="kobo.454.1"> and cons</span><a id="_idTextAnchor103"/><span class="koboSpan" id="kobo.455.1">iderations. </span><span class="koboSpan" id="kobo.455.2">Let’s explore two approaches.</span></p>
<h3><span class="koboSpan" id="kobo.456.1">Naming files with index.tsx and explicit component names</span></h3>
<p><span class="koboSpan" id="kobo.457.1">In this approach, each file within the</span><a id="_idIndexMarker169"/><span class="koboSpan" id="kobo.458.1"> component folder has an explicit name that corresponds to the component it represents:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.459.1">
components/Button
├── Button.test.tsx
├── Button.tsx
├── index.tsx
└── style.css</span></pre> <p><span class="koboSpan" id="kobo.460.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">index.tsx</span></strong><span class="koboSpan" id="kobo.462.1"> file serves as the default export file, allowing you to import the component from the folder directly. </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">Button.tsx</span></strong><span class="koboSpan" id="kobo.464.1"> is the JSX for the component, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">Button.test.tsx</span></strong><span class="koboSpan" id="kobo.466.1"> is the corresponding test file, while </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">style.css</span></strong><span class="koboSpan" id="kobo.468.1"> defines CSS styles.</span></p>
<p><span class="koboSpan" id="kobo.469.1">This approach promotes clear and self-descriptive filenames, making it easier to understand the purpose and content of each file. </span><span class="koboSpan" id="kobo.469.2">However, it can result in a long list of index files when browsing or searching for</span><a id="_idTextAnchor104"/><a id="_idTextAnchor105"/><span class="koboSpan" id="kobo.470.1"> components in an editor or file explorer.</span></p>
<h3><span class="koboSpan" id="kobo.471.1">Naming files with kebab case</span></h3>
<p><span class="koboSpan" id="kobo.472.1">In this approach, the files within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">components</span></strong><span class="koboSpan" id="kobo.474.1"> folder are</span><a id="_idIndexMarker170"/><span class="koboSpan" id="kobo.475.1"> named using </span><strong class="bold"><span class="koboSpan" id="kobo.476.1">kebab case</span></strong><span class="koboSpan" id="kobo.477.1">, a naming convention where </span><a id="_idIndexMarker171"/><span class="koboSpan" id="kobo.478.1">words are lowercase and separated by hyphens. </span><span class="koboSpan" id="kobo.478.2">If there is only one word, simply use lowercase – this follows a consistent convention that’s used in the JavaScript community:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.479.1">
components
├── button.test.tsx
├── button.tsx
├── index.tsx
└── style.css</span></pre> <p><span class="koboSpan" id="kobo.480.1">The filename of the component is explicitly named using kebab case (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">button.tsx</span></strong><span class="koboSpan" id="kobo.482.1">) to match the component’s name.</span></p>
<p><span class="koboSpan" id="kobo.483.1">This approach maintains consistency with the convention of kebab case filenames and promotes a unified naming structure throughout the project. </span><span class="koboSpan" id="kobo.483.2">However, it may require specifying the filename explicitly when importing the component.</span></p>
<p><span class="koboSpan" id="kobo.484.1">Both approaches have their merits, and the choice depends on personal preference and the project’s requirements or team conventions. </span><span class="koboSpan" id="kobo.484.2">It is crucial to establish and maintain consistency within the project to enhance collaboration and understanding among team members.</span></p>
<p><span class="koboSpan" id="kobo.485.1">Either way, you can use ESlint and FolderLint to ensure your team has the same naming standard for files and folders. </span><span class="koboSpan" id="kobo.485.2">For example, the following screenshot shows that filenames should be in the kebab case and suggests changing </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">Button.tsx</span></strong><span class="koboSpan" id="kobo.487.1"> i</span><a id="_idTextAnchor106"/><span class="koboSpan" id="kobo.488.1">nto </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">button.tsx</span></strong><span class="koboSpan" id="kobo.490.1">:</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer024">
<span class="koboSpan" id="kobo.491.1"><img alt="Figure 3.6: ESlint c﻿hecks" src="image/B21103_03_06.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.492.1">Figure 3.6: ESlint c</span><a id="_idTextAnchor107"/><span class="koboSpan" id="kobo.493.1">hecks</span></figcaption> </figure>
<h2 id="_idParaDest-60"><a id="_idTextAnchor108"/><span class="koboSpan" id="kobo.494.1">Exploring a more customized structure</span></h2>
<p><span class="koboSpan" id="kobo.495.1">As your application grows and different types of abstractions are added, it becomes necessary to organize the </span><a id="_idIndexMarker172"/><span class="koboSpan" id="kobo.496.1">project structure accordingly. </span><span class="koboSpan" id="kobo.496.2">Relying solely on any previously discussed structure may not be ideal for your specific scenario. </span><span class="koboSpan" id="kobo.496.3">It’s often necessary to customize the structure so that it aligns well with your project’s needs. </span><span class="koboSpan" id="kobo.496.4">Remember, the primary goal of establishing a project structure is to simplify and streamline the development process for developers.</span></p>
<p><span class="koboSpan" id="kobo.497.1">Starting with the feature-based structure, we need to adjust our current folder structure to the following folder structure to reflect this evolution:</span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">api</span></strong><span class="koboSpan" id="kobo.499.1">: This folder represents the module or directory for managing API-related code, including functions for making network requests, handling responses, and interacting with the backend services.</span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">components</span></strong><span class="koboSpan" id="kobo.501.1">: This folder contains reusable UI components that can be used across different pages or features of the application. </span><span class="koboSpan" id="kobo.501.2">It includes components such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">Accordion</span></strong><span class="koboSpan" id="kobo.503.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">Button</span></strong><span class="koboSpan" id="kobo.505.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">GenericCard</span></strong><span class="koboSpan" id="kobo.507.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">Modal</span></strong><span class="koboSpan" id="kobo.509.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">Offer</span></strong><span class="koboSpan" id="kobo.511.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">StackView</span></strong><span class="koboSpan" id="kobo.513.1">. </span><span class="koboSpan" id="kobo.513.2">These components can be organized into subfolders based on their functionality or purpose.</span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">context</span></strong><span class="koboSpan" id="kobo.515.1">: This folder </span><a id="_idIndexMarker173"/><span class="koboSpan" id="kobo.516.1">represents the module or directory for managing React context, which allows for global state management and data sharing across components.</span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">hooks</span></strong><span class="koboSpan" id="kobo.518.1">: This folder contains custom React Hooks that encapsulate reusable logic and behavior. </span><span class="koboSpan" id="kobo.518.2">These Hooks can be shared across different parts of the application.</span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">mocks</span></strong><span class="koboSpan" id="kobo.520.1">: This folder holds mock data or mock implementations for testing purposes. </span><span class="koboSpan" id="kobo.520.2">It includes subfolders for </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">graphql</span></strong><span class="koboSpan" id="kobo.522.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">rest</span></strong><span class="koboSpan" id="kobo.524.1">, which represent mocks for GraphQL and REST APIs, respectively.</span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">pages</span></strong><span class="koboSpan" id="kobo.526.1">: This folder represents the different pages or features of the application. </span><span class="koboSpan" id="kobo.526.2">Each page or feature has a folder. </span><span class="koboSpan" id="kobo.526.3">The folders that are included are </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">Address</span></strong><span class="koboSpan" id="kobo.528.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">Home</span></strong><span class="koboSpan" id="kobo.530.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">Login</span></strong><span class="koboSpan" id="kobo.532.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">Order</span></strong><span class="koboSpan" id="kobo.534.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">Payment</span></strong><span class="koboSpan" id="kobo.536.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">Product</span></strong><span class="koboSpan" id="kobo.538.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">Profile</span></strong><span class="koboSpan" id="kobo.540.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">SignUp</span></strong><span class="koboSpan" id="kobo.542.1">, as well as their respective subfolders. </span><span class="koboSpan" id="kobo.542.2">The subfolders may contain additional components, Hooks, or context related to that specific page or feature.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.543.1">By structuring the project in this way, you can achieve a modular and organized code base that facilitates code reuse, separation of concerns, and scalability. </span><span class="koboSpan" id="kobo.543.2">Each directory represents a specific aspect of the application, making it easier to locate and manage code related to that particular functionality.</span></p>
<p><span class="koboSpan" id="kobo.544.1">You can see this in the following figure, where we are returning to our shopping example:</span></p>
<figure>
<div class="IMG---Figure" id="_idContainer025">
<span class="koboSpan" id="kobo.545.1"><img alt="Figure 3.7: A mixed structure for an online shopping application" src="image/B21103_03_07.jpg"/></span>
</div>
<figcaption class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.546.1">Figure 3.7: A mixed structure for an online shopping application</span></figcaption> </figure>
<p><span class="koboSpan" id="kobo.547.1">While this structure provides a solid foundation, it’s important to adapt it based on the specific needs and scale of your project. </span><span class="koboSpan" id="kobo.547.2">Regularly reviewing and refactoring the structure can help maintain its</span><a id="_idIndexMarker174"/><span class="koboSpan" id="kobo.548.1"> effectiveness and accommodate future changes.</span></p>
<p><span class="koboSpan" id="kobo.549.1">As the application becomes larger, it may be beneficial to extract the </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">components</span></strong><span class="koboSpan" id="kobo.551.1"> folder into a shared library that can be used across multiple projects or as an internal design system. </span><span class="koboSpan" id="kobo.551.2">This approach promotes code reuse, consistency, and maintainability. </span><span class="koboSpan" id="kobo.551.3">The shared library can be hosted on an internal registry or published to </span><i class="italic"><span class="koboSpan" id="kobo.552.1">npmjs Registry</span></i><span class="koboSpan" id="kobo.553.1"> (</span><a href="https://www.npmjs.com/"><span class="koboSpan" id="kobo.554.1">https://www.npmjs.com/</span></a><span class="koboSpan" id="kobo.555.1">) for easy distribution and consumption.</span></p>
<p><span class="koboSpan" id="kobo.556.1">Also, as your application evolves and new features are introduced, the existing structure may no longer fully meet your requirements. </span><span class="koboSpan" id="kobo.556.2">In such cases, it can be beneficial to incorporate architectural patterns such as MVVM, which follows a layered approach. </span><span class="koboSpan" id="kobo.556.3">This allows for better separation of concerns and facilitates the management of complex features and state in a more organized manner. </span><span class="koboSpan" id="kobo.556.4">We’ll have an in-depth discussion ab</span><a id="_idTextAnchor109"/><span class="koboSpan" id="kobo.557.1">out using layered architecture in </span><a href="B21103_11.xhtml#_idTextAnchor286"><i class="italic"><span class="koboSpan" id="kobo.558.1">Chapter 11</span></i></a><span class="koboSpan" id="kobo.559.1">.</span></p>
<h1 id="_idParaDest-61"><a id="_idTextAnchor110"/><span class="koboSpan" id="kobo.560.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.561.1">In this chapter, we explored the challenges that arise when managing a large React application and the importance of establishing a solid project structure. </span><span class="koboSpan" id="kobo.561.2">We discussed various styles of structuring a React application, including feature-based, component-based, MVVM, and atomic design. </span><span class="koboSpan" id="kobo.561.3">Each approach offers its benefits and considerations, allowing developers to choose the most suitable structure for their specific project requirements.</span></p>
<p><span class="koboSpan" id="kobo.562.1">Additionally, we proposed a continuously evolving approach to shaping the folder structure as the project grows. </span><span class="koboSpan" id="kobo.562.2">Starting with a simple initial structure, we emphasized the need to adapt and introduce new layers and abstractions to reduce duplication and maintain code organization. </span><span class="koboSpan" id="kobo.562.3">By continuously refining the structure and adhering to consistent conventions, developers can navigate, add new features, and maintain scalability effectively.</span></p>
<p><span class="koboSpan" id="kobo.563.1">Throughout this chapter, we highlighted the importance of keeping the project structure flexible and evolving to meet the changing needs of the application. </span><span class="koboSpan" id="kobo.563.2">By staying proactive in shaping the folder structure, developers can mitigate the challenges of managing a large React application and ensure maintainability and scalability in the long run.</span></p>
<p><span class="koboSpan" id="kobo.564.1">In the forthcoming chapter, we will delve into prevalent design patterns and strategies for component implementation. </span><span class="koboSpan" id="kobo.564.2">These techniques will allow us to craft code that is amenable to feature additions, intuitive to comprehend, and requires less maintenance effort.</span></p>
</section>
</body></html>