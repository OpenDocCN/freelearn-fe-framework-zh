["```js\n    Scenario: Presenter chooses to reset current state when sharing\n      Given the presenter navigated to the application page\n      And the presenter entered the following instructions at the prompt:\n        | forward 10 |\n        | right 90 |\n      And the presenter clicked the button 'startSharing'\n      When the presenter clicks the button 'reset'\n      And the observer navigates to the presenter's sharing link\n      Then the observer should see no lines\n      And the presenter should see no lines\n      And the observer should see the turtle at x = 0, y = 0, angle = 0\n      And the presenter should see the turtle at x = 0, y = 0, angle = 0\n    ```", "```js\n    When(\n      \"the presenter entered the following instructions at the prompt:\",\n      async function(dataTable) {\n        for (let instruction of dataTable.raw()) {\n          await this.getPage(\"presenter\").type(\n           \"textarea\",\n           `${instruction}\\n`\n          );\n          await this.getPage(\n            \"presenter\"\n          ).waitForTimeout(3500);\n        }\n      }\n    );\n    ```", "```js\n    When(\n      \"the presenter clicks the button {string}\",\n      function (string) {\n        // Write code here that turns the phrase above\n        // into concrete actions\n        return \"pending\";\n      }\n    );\n    ```", "```js\n    When(\n      \"the presenter clicks the button {string}\",\n      async function (\n        buttonId\n      ) {\n        await this.getPage(\n          \"presenter\"\n        ).waitForSelector(`button#${buttonId}`);\n        await this.getPage(\n          \"presenter\"\n        ).click(`button#${buttonId}`);\n      }\n    );\n    ```", "```js\n    Then(\"the observer should see no lines\", function () {\n      // Write code here that turns the phrase above\n      // into concrete actions\n      return \"pending\";\n    });\n    ```", "```js\n    Then(\n      \"the observer should see no lines\",\n      async function () {\n        const numLines = await this.getPage(\n          \"observer\"\n        ).$$eval(\"line\", lines => lines.length);\n        expect(numLines).toEqual(0);\n      }\n    );\n    ```", "```js\n    Then(\n      \"the presenter should see no lines\",\n      async function () {\n        const numLines = await this.getPage(\n          \"presenter\"\n        ).$$eval(\"line\", lines => lines.length);\n        expect(numLines).toEqual(0);\n      }\n    );\n    ```", "```js\n    ✖ And the presenter should see no lines\n       Error: expect(received).toEqual(expected)\n       Expected value to equal:\n       0\n       Received:\n       1\n    ```", "```js\n    Then(\n      \"the observer should see the turtle at x = {int}, y = {int}, angle = {int}\",\n      function (int, int2, int3) {\n        // Write code here that turns the phrase above\n        // into concrete actions\n        return \"pending\";\n    });\n    ```", "```js\n    <polygon\n      points=\"-5,5, 0,-7, 5,5\"\n      fill=\"green\"\n      stroke-width=\"2\"\n      stroke=\"black\"\n      transform=\"rotate(90, 0, 0)\" />\n    ```", "```js\nexport const calculateTurtleXYFromPoints = points => {\n  const firstComma = points.indexOf(\",\");\n  const secondComma = points.indexOf(\n    \",\",\n    firstComma + 1\n  );\n  return {\n    x:\n      parseFloat(\n        points.substring(0, firstComma)\n      ) + 5,\n    y:\n      parseFloat(\n        points.substring(firstComma + 1, secondComma)\n      ) - 5\n  };\n};\nexport const calculateTurtleAngleFromTransform = (\n  transform \n) => {\n  const firstParen = transform.indexOf(\"(\");\n  const firstComma = transform.indexOf(\",\");\n  return (\n    parseFloat(\n      transform.substring(\n        firstParen + 1, \n        firstComma\n      )\n    ) - 90\n  );\n}\n```", "```js\n    Then(\n      \"the observer should see the turtle at x = {int}, y = {int}, angle = {int}\",\n      async function (\n        expectedX, expectedY, expectedAngle\n      ) {\n        await this.getPage(\n          \"observer\"\n        ).waitForTimeout(4000);\n        const turtle = await this.getPage(\n          \"observer\"\n        ).$eval(\n          \"polygon\",\n          polygon => ({\n            points: polygon.getAttribute(\"points\"),\n            transform: polygon.getAttribute(\"transform\")\n          })\n        );\n        const position = calculateTurtleXYFromPoints(\n          turtle.points\n        );\n        const angle = calculateTurtleAngleFromTransform(\n          turtle.transform\n        );\n        expect(position.x).toBeCloseTo(expectedX);\n        expect(position.y).toBeCloseTo(expectedY);\n        expect(angle).toBeCloseTo(expectedAngle);\n      }\n    );\n    ```", "```js\n    Then(\n      \"the presenter should see the turtle at x = {int}, y = {int}, angle = {int}\",\n      async function (\n        expectedX, expectedY, expectedAngle\n      ) {\n        await this.getPage(\n          \"presenter\"\n        ).waitForTimeout(4000);\n        const turtle = await this.getPage(\n          \"presenter\"\n        ).$eval(\n          \"polygon\",\n          polygon => ({\n            points: polygon.getAttribute(\"points\"),\n            transform: polygon.getAttribute(\"transform\")\n          })\n        );\n        const position = calculateTurtleXYFromPoints(   \n          turtle.points\n        );\n        const angle = calculateTurtleAngleFromTransform(\n          turtle.transform\n        );\n        expect(position.x).toBeCloseTo(expectedX);\n        expect(position.y).toBeCloseTo(expectedY);\n        expect(angle).toBeCloseTo(expectedAngle);\n      }\n    );\n    ```", "```js\n      Then these lines should have been drawn for the observer:\n        | x1 | y1 | x2 | y2 |\n        | 0 | 0 | 10 | 0 |\n      And these lines should have been drawn for the presenter:\n        | x1 | y1 | x2 | y2 |\n        | 0 | 0 | 10 | 0 |\n    ```", "```js\nimport expect from \"expect\";\nexport const checkLinesFromDataTable = page =>\n  return async function (dataTable) {\n    await this.getPage(page).waitForTimeout(2000);\n    const lines = await this.getPage(page).$$eval(\n      \"line\",\n      lines =>\n        lines.map(line => ({\n          x1: parseFloat(line.getAttribute(\"x1\")),\n          y1: parseFloat(line.getAttribute(\"y1\")),\n          x2: parseFloat(line.getAttribute(\"x2\")),\n          y2: parseFloat(line.getAttribute(\"y2\"))\n        }))\n    );\n    for (let i = 0; i < lines.length; ++i) {\n      expect(lines[i].x1).toBeCloseTo(\n        parseInt(dataTable.hashes()[i].x1)\n      );\n      expect(lines[i].y1).toBeCloseTo(\n        parseInt(dataTable.hashes()[i].y1)\n      );\n      expect(lines[i].x2).toBeCloseTo(\n        parseInt(dataTable.hashes()[i].x2)\n      );\n      expect(lines[i].y2).toBeCloseTo(\n        parseInt(dataTable.hashes()[i].y2)\n      );\n    }\n  };\n```", "```js\n    import { checkLinesFromDataTable } from \"./svg\";\n    Then(\n      \"these lines should have been drawn:\",\n      checkLinesFromDataTable(\"user\")\n    );\n    ```", "```js\n    import { checkLinesFromDataTable } from \"./svg\";\n    Then(\n      \"these lines should have been drawn for the presenter:\",\n      checkLinesFromDataTable(\"presenter\")\n    );\n    Then(\n      \"these lines should have been drawn for the observer:\",\n      checkLinesFromDataTable(\"observer\")\n    );\n    ```", "```js\n    { type: \"START_SHARING\", reset: true }\n    ```", "```js\n    { type: \"START_SHARING\", reset: false }\n    ```", "```js\n    it.skip(\"dispatches an action of START_SHARING when start sharing is clicked\", () => {\n      ...\n    });\n    ```", "```js\n    import { Dialog } from \"../src/Dialog\";\n    jest.mock(\"../src/Dialog\", () => ({\n      Dialog: jest.fn(() => <div id=\"Dialog\" />),\n    });\n    ```", "```js\n    it(\"opens a dialog when start sharing is clicked\", () => {\n      renderWithStore(<MenuButtons />);\n      click(buttonWithLabel(\"Start sharing\"));\n      expect(Dialog).toBeCalled();\n    });\n    ```", "```js\n    import { Dialog } from \"./Dialog\";\n    export const MenuButtons = () => {\n      ...\n      return (\n        <>\n          ...\n         <Dialog />\n        </>\n      );\n    };\n    ```", "```js\n    it(\"prints a useful message in the sharing dialog\", () => {\n      renderWithStore(<MenuButtons />);\n      click(buttonWithLabel(\"Start sharing\"));\n      expect(propsOf(Dialog).message).toEqual(\n        \"Do you want to share your previous commands, or would you like to reset to a blank script?\"\n      );\n    });\n    ```", "```js\n    <Dialog\n      message=\"Do you want to share your previous commands, or would you like to reset to a blank script?\"\n    />\n    ```", "```js\n    it(\"does not initially show the dialog\", () => {\n      renderWithStore(<MenuButtons />);\n      expect(Dialog).not.toBeCalled();\n    });\n    ```", "```js\n    import React, { useState } from \"react\";\n    export const MenuButtons = () => {\n      const [\n        isSharingDialogOpen, setIsSharingDialogOpen\n      ] = useState(false);\n      const openSharingDialog = () =>\n       setIsSharingDialogOpen(true);\n      ...\n      return (\n        <>\n          ...\n          {environment.isSharing ? (\n            <button\n              id=\"stopSharing\"\n              onClick={() => dispatch(stopSharing())}\n            >\n              Stop sharing\n            </button>\n          ) : (\n            <button\n              id=\"startSharing\"\n              onClick={openSharingDialog}\n            >\n              Start sharing\n            </button>\n          )}\n          {isSharingDialogOpen ? (\n            <Dialog\n              message=\"...\"\n            />\n          ) : null}\n        </>\n      );\n    };\n    ```", "```js\n    it(\"passes Share and Reset buttons to the dialog\", () => {\n      renderWithStore(<MenuButtons />);\n      click(buttonWithLabel(\"Start sharing\"));\n      expect(propsOf(Dialog).buttons).toEqual([\n        { id: \"keep\", text: \"Share previous\" },\n        { id: \"reset\", text: \"Reset\" }\n      ]);\n    });\n    ```", "```js\n    {isSharingDialogOpen ? (\n      <Dialog\n        message=\"...\"\n        buttons={[\n         { id: \"keep\", text: \"Share previous\" },\n         { id: \"reset\", text: \"Reset\" }\n        ]}\n      />\n    ) : null}\n    ```", "```js\n    const closeDialog = () =>\n      act(() => propsOf(Dialog).onClose());\n    ```", "```js\n    it(\"closes the dialog when the onClose prop is called\", () => {\n      renderWithStore(<MenuButtons />);\n      click(buttonWithLabel(\"Start sharing\"));\n      closeDialog();\n      expect(element(\"#dialog\")).toBeNull();\n    });\n    ```", "```js\n    <Dialog\n      onClose={() => setIsSharingDialogOpen(false)}\n      ...\n    />\n    ```", "```js\n    const makeDialogChoice = button =>\n      act(() => propsOf(Dialog).onChoose(button));\n    it(\"dispatches an action of START_SHARING when dialog onChoose prop is invoked with reset\", () => {\n      renderWithStore(<MenuButtons />);\n      click(buttonWithLabel(\"Start sharing\"));\n      makeDialogChoice(\"reset\");\n      return expectRedux(store)\n        .toDispatchAnAction()\n        .matching({ type: \"START_SHARING\", reset: true });\n    });\n    ```", "```js\n    const startSharing = () => ({\n      type: \"START_SHARING\",\n      reset: true,\n    });\n    ```", "```js\n    return (\n      <>\n        ...\n        {isSharingDialogOpen ? (\n          <Dialog\n            onClose={() => setIsSharingDialogOpen(false)}\n            onChoose={() => dispatch(startSharing())}\n            ...\n          />\n        ) : null}\n      </>\n    );\n    ```", "```js\n    it(\"dispatches an action of START_SHARING when dialog onChoose prop is invoked with share\", () => {\n      renderWithStore(<MenuButtons />);\n      click(buttonWithLabel(\"Start sharing\"));\n      makeDialogChoice(\"share\");\n      return expectRedux(store)\n        .toDispatchAnAction()\n        .matching({\n          type: \"START_SHARING\",\n          reset: false\n        });\n    });\n    ```", "```js\n    const startSharing = (button) => ({\n      type: \"START_SHARING\",\n      reset: button === \"reset\",\n    });\n    ```", "```js\n    onChoose={(button) => dispatch(startSharing(button))}\n    ```", "```js\n    it(\"puts an action of RESET if reset is true\", async () => {\n      store.dispatch({\n        type: \"START_SHARING\",\n        reset: true,\n      });\n      await notifySocketOpened();\n      await sendSocketMessage({\n        type: \"UNKNOWN\",\n        id: 123,\n      });\n      return expectRedux(store)\n        .toDispatchAnAction()\n        .matching({ type: \"RESET\" });\n    });\n    ```", "```js\n    function* startSharing(action) {\n      ...\n      if (action.reset) {\n        yield put({ type: \"RESET\" });\n      }\n    }\n    ```", "```js\n    it(\"shares all existing actions if reset is false\", async () => {\n      const forward10 = {\n        type: \"SUBMIT_EDIT_LINE\",\n        text: \"forward 10\",\n      };\n      const right90 = {\n        type: \"SUBMIT_EDIT_LINE\",\n        text: \"right 90\"\n      };\n      store.dispatch(forward10);\n      store.dispatch(right90);\n      store.dispatch({\n        type: \"START_SHARING\",\n        reset: false,\n      });\n      await notifySocketOpened();\n      await sendSocketMessage({\n        type: \"UNKNOWN\",\n        id: 123,\n      });\n      expect(sendSpy).toBeCalledWith(\n        JSON.stringify({\n          type: \"NEW_ACTION\",\n          innerAction: forward10,\n        })\n      );\n      expect(sendSpy).toBeCalledWith(\n        JSON.stringify({\n          type: \"NEW_ACTION\",\n          innerAction: right90\n        })\n      );\n    });\n    ```", "```js\n    import {\n      call,\n      put,\n      takeLatest,\n      take,\n      all,\n      select\n    } from \"redux-saga/effects\";\n    import { eventChannel, END } from \"redux-saga\";\n    import { toInstructions } from \"../language/export\";\n    ```", "```js\n    if (action.reset) {\n      yield put({ type: \"RESET\" });\n    } else {\n      const state = yield select(state => state.script);\n      const instructions = toInstructions(state);\n      yield all(\n        instructions.map(instruction =>\n          call(shareNewAction, {\n            innerAction: {\n              type: \"SUBMIT_EDIT_LINE\",\n              text: instruction\n            }\n          })\n        )\n      );\n    }\n    ```", "```js\n    const startSharing = async () => {\n      store.dispatch({\n        type: \"START_SHARING\",\n        reset: true\n      });\n      ...\n    };\n    ```", "```js\nawait this.getPage(\"user\").waitForTimeout(3000);\n```", "```js\n    describe(\"isAnimating\", () => {\n      it(\"adds isAnimating class to viewport when animation begins\", () => {\n        renderWithStore(<Drawing />, {\n          script: { drawCommands: [horizontalLine] }\n        });\n        triggerRequestAnimationFrame(0);\n        expect(\n          element(\"#viewport\")\n        ).toHaveClass(\"isAnimating\");\n      });\n    });\n    ```", "```js\n    return (\n      <div\n        id=\"viewport\"\n        className=\"isAnimating\"\n      >\n        ...\n      </div>\n    );\n    ```", "```js\n    it(\"initially does not have the isAnimating class set\", () => {\n      renderWithStore(<Drawing />, {\n        script: { drawCommands: [] }\n      });\n      expect(\n        element(\"#viewport\")\n      ).not.toHaveClass(\"isAnimating\");\n    });\n    ```", "```js\n    className={commandToAnimate ? \"isAnimating\" : \"\"}>\n    ```", "```js\n    it(\"removes isAnimating class when animation is finished\", () => {\n      renderWithStore(<Drawing />, {\n        script: { drawCommands: [horizontalLine] },\n      });\n      triggerAnimationSequence([0, 500]);\n      expect(element(\"#viewport\")).not.toHaveClass(\n        \"isAnimating\"\n      );\n    });\n    ```", "```js\n    waitForAnimationToBegin(page) {\n      return this.getPage(page).waitForSelector(\n        \".isAnimating\"\n      );\n    }\n    waitForAnimationToEnd(page) {\n      return this.getPage(page).waitForSelector(\n        \".isAnimating\",\n       { hidden: true }\n      );\n    }\n    ```", "```js\n    When(\n      \"the user enters the following instructions at the prompt:\",\n      async function (dataTable) {\n        for (let instruction of dataTable.raw()) {\n          await this.getPage(\"user\").type(\n            \"textarea\",\n            `${instruction}\\n`\n          );\n          await this.waitForAnimationToEnd(\"user\");\n        }\n      }\n    );\n    ```", "```js\n    When(\n      \"the presenter entered the following instructions at the prompt:\",\n      async function(dataTable) {\n        for (let instruction of dataTable.raw()) {\n          await this.getPage(\"presenter\").type(\n            \"textarea\",\n            `${instruction}\\n`\n          );\n          await this.waitForAnimationToEnd(\"presenter\");\n        }\n      }\n    );\n    ```", "```js\n    Then(\n      \"the observer should see the turtle at x = {int}, y = {int}, angle = {int}\",\n      async function (\n        expectedX, expectedY, expectedAngle\n      ) {\n        await this.waitForAnimationToEnd(\"observer\");\n        ...\n      }\n    );\n    Then(\n      \"the presenter should see the turtle at x = {int}, y = {int}, angle = {int}\",\n      async function (\n        expectedX, expectedY, expectedAngle\n      ) {\n        await this.waitForAnimationToEnd(\"presenter\");\n        ...\n      }\n    );\n    ```", "```js\n    export const checkLinesFromDataTable = page => {\n      return async function (dataTable) {\n        await this.waitForAnimationToEnd(page);\n        ...\n      }\n    };\n    ```", "```js\n    When the presenter clicks the button 'keep'\n    And the observer navigates to the presenter's sharing link\n    And the observer waits for animations to finish\n    ```", "```js\n    When(\n      \"the observer waits for animations to finish\",\n      async function () {\n        await this.waitForAnimationToBegin(\"observer\");\n        await this.waitForAnimationToEnd(\"observer\");\n      }\n    );\n    ```"]