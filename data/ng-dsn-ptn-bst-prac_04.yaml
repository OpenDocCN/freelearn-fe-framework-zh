- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Components and Pages
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件和页面
- en: The main building blocks of an Angular application are the **components**. It
    is by using them that we assemble our user interfaces and define the flow of the
    experience. In Angular architecture, components organize an application into reusable
    parts, making it easy to maintain and scale.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 应用程序的主要构建块是 **组件**。正是通过使用它们，我们组装用户界面并定义体验的流程。在 Angular 架构中，组件将应用程序组织成可重用的部分，使其易于维护和扩展。
- en: In this chapter, we will explore the communication between components and thus
    assemble our pages using component composition, avoiding the anti-pattern of creating
    monolithic interfaces.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨组件之间的通信，并使用组件组合来组装我们的页面，避免创建单体界面的反模式。
- en: 'In this chapter, we’re going to cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建组件
- en: Communication between components – inputs and outputs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件之间的通信 – 输入和输出
- en: Best practice – using the `TrackBy` property
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最佳实践 – 使用 `TrackBy` 属性
- en: Separating responsibilities – smart and presentation components
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分离责任 – 智能组件和展示组件
- en: Communication from the child component – using `@Output`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子组件之间的通信 – 使用 `@Output`
- en: By the end of this chapter, you will be able to create reusable and easy-to-maintain
    components and pages, streamlining the development of your project and increasing
    your productivity and that of your team.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够创建可重用且易于维护的组件和页面，从而简化项目开发并提高你和你团队的生产力。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow the instructions in this chapter, you’ll need the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章中的说明，你需要以下内容：
- en: Visual Studio Code ([https://code.visualstudio.com/Download](https://code.visualstudio.com/Download))
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code ([https://code.visualstudio.com/Download](https://code.visualstudio.com/Download))
- en: Node.js 18 or higher ([https://nodejs.org/en/download/](https://nodejs.org/en/download/))
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 18 或更高版本 ([https://nodejs.org/en/download/](https://nodejs.org/en/download/))
- en: The code files for this chapter are available at [https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch4](https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch4).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可在 [https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch4](https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch4)
    找到。
- en: Creating components
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建组件
- en: Every interface created with Angular is a component in the architecture of the
    framework; therefore, theoretically, we could have our entire application in a
    single component.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Angular 创建的每个接口都是框架架构中的一个组件；因此，从理论上讲，我们可以在单个组件中拥有我们的整个应用程序。
- en: As we studied in [*Chapter 2*](B19562_02.xhtml#_idTextAnchor081), *Organizing
    Your Application*, it is best to separate your application into modules, and with
    components, we use the same reasoning by separating our interfaces into and composing
    them with different components, maximizing reuse and maintainability.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [*第 2 章*](B19562_02.xhtml#_idTextAnchor081) 中所研究的，*组织你的应用程序*，最好将你的应用程序分成模块，并且通过组件，我们通过将我们的接口分成不同的组件并使用不同的组件来组合它们，来使用相同的推理，以最大化重用性和可维护性。
- en: In this chapter, we will illustrate this with a gym diary application, as shown
    in the following figure – to focus on Angular, we will not use Angular Material,
    only HTML, CSS (in this case, Tailwind CSS), and TypeScript.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过以下健身日记应用程序来展示这一点，如图所示 – 为了专注于 Angular，我们不会使用 Angular Material，只使用
    HTML、CSS（在这种情况下，Tailwind CSS）和 TypeScript。
- en: '![Figure 4.1 – Gym diary application UI](img/B19562_04_1.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 健身日记应用程序 UI](img/B19562_04_1.jpg)'
- en: Figure 4.1 – Gym diary application UI
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 健身日记应用程序 UI
- en: 'In this initial example, we created a component with just the HTML template
    and the CSS and TypeScript files are as they were created by Angular CLI. Here’s
    the top of the page first:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个初始示例中，我们创建了一个仅包含 HTML 模板、CSS 和 TypeScript 文件的组件。以下是页面的顶部内容：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Using good HTML semantic practices, let’s create a `main` section:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用良好的 HTML 语义实践，让我们创建一个 `main` 部分：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can see that in the preceding example, the interface is designed and stylized,
    but it is not functional because the diary entries are fixed in HTML, and in our
    application, the user should be able to add as many entries as they want.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在前面的示例中，界面已经设计和样式化，但它不是功能性的，因为日记条目固定在 HTML 中，在我们的应用程序中，用户应该能够添加他们想要的任意数量的条目。
- en: 'We can identify here that this part of the diary entry could be a component
    for the page to use, so let’s create a component called `entry`. As we learned
    in [*Chapter 1*](B19562_01.xhtml#_idTextAnchor017), *Starting Projects the Right
    Way*, we are going to use the Angular CLI to create this new component in the
    module we need:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以识别出，这个日记条目的这部分可能是一个页面可以使用的组件，所以让我们创建一个名为`entry`的组件。正如我们在[*第一章*](B19562_01.xhtml#_idTextAnchor017)，“正确开始项目”中学到的，我们将使用Angular
    CLI在所需的模块中创建这个新组件：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With this command, the Angular CLI will create a folder with the following four
    files in addition to updating the `diary` module with the new component.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个命令，Angular CLI将创建一个包含以下四个文件的新文件夹，并更新`diary`模块以包含新组件。
- en: '`entry-item.component.css`: This file will contain the component’s style sheet.
    Angular manages to solve a big pain point of a web application, which is the CSS
    scope of each component. With this feature, we can specify the component’s styling
    without having to worry about whether it will affect an application’s CSS even
    using the same property or selector name.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entry-item.component.css`: 此文件将包含组件的样式表。Angular成功地解决了Web应用的一个大痛点，即每个组件的CSS作用域。有了这个特性，我们可以在不担心是否会影响到应用程序的CSS（即使使用相同的属性或选择器名称）的情况下指定组件的样式。'
- en: '`entry-item.component.html`: This file contains the component’s HTML template
    and, although the extension seems to indicate that we can only use HTML tags,
    in the template file, we can use Angular directives, as we will study in this
    chapter.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entry-item.component.html`: 此文件包含组件的HTML模板，尽管扩展名似乎表明我们只能使用HTML标签，但在模板文件中，我们可以使用Angular指令，正如我们将在本章学习的。'
- en: '`entry-item.component.spec.ts`: This file contains the unit test for the component,
    which we will detail in [*Chapter 10*](B19562_10.xhtml#_idTextAnchor264), *Design
    for Tests:* *Best Practices*.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entry-item.component.spec.ts`: 此文件包含组件的单元测试，我们将在[*第十章*](B19562_10.xhtml#_idTextAnchor264)“为测试而设计：最佳实践”中详细说明。'
- en: '`entry-item.component.ts`: This is the TypeScript file that represents the
    component itself. All other files are optional, making it possible for you to
    create a component with just this file, although this is not a practice widely
    applied in Angular projects and is only recommended for very small components.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entry-item.component.ts`: 这是代表组件本身的TypeScript文件。所有其他文件都是可选的，这使得你可以只使用这个文件来创建一个组件，尽管这并不是在Angular项目中广泛应用的实践，并且仅推荐用于非常小的组件。'
- en: 'In the `entry-item.component.ts` file, the Angular CLI created the following
    structure:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在`entry-item.component.ts`文件中，Angular CLI创建了以下结构：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With this example, we reinforce the definition that a component is a TypeScript
    class, and by using the `@Component` decorator, we indicate to Angular where the
    parts to assemble it are.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个示例，我们强化了组件是一个TypeScript类的定义，并通过使用`@Component`装饰器，我们向Angular指示了组装组件的部分在哪里。
- en: 'The main properties are as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 主要属性如下：
- en: '`selector`: This is an optional property that defines what the component’s
    selector will be if it is used in the template of another component. Components
    that represent a page do not need to have a selector defined as they are instantiated
    from a route. The Angular CLI suggests the selector based on your application’s
    prefix defined in the `prefix` property of the `angular.json` file, along with
    the name you defined in the `ng` `g` command.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selector`: 这是一个可选属性，定义了如果组件在另一个组件的模板中使用时，其选择器将是什么。代表页面的组件不需要定义选择器，因为它们是从路由中实例化的。Angular
    CLI根据在`angular.json`文件的`prefix`属性中定义的应用程序前缀以及你在`ng` `g`命令中定义的名称来建议选择器。'
- en: '`templateUrl`: This defines the path of the HTML file that contains the component’s
    template. Alternatively, we can use the `template` property to define a string
    with all the component’s HTML.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`templateUrl`: 这定义了包含组件模板的HTML文件的路径。或者，我们可以使用`template`属性来定义一个包含所有组件HTML的字符串。'
- en: '`styleUrls`: This defines the path of the CSS files that contain the component’s
    styling. A detail of this property is that it is an array, so it is possible to
    have more than one CSS file linked to the component. Alternatively, we can use
    the `style` property to define a string containing the component’s CSS.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`styleUrls`: 这定义了包含组件样式的CSS文件的路径。这个属性的细节是它是一个数组，因此可以链接多个CSS文件到组件。或者，我们可以使用`style`属性来定义一个包含组件CSS的字符串。'
- en: 'In the `entry-item.component.html` file, we will place the snippet that represents
    an item in a list of exercises in our gym diary:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在`entry-item.component.html`文件中，我们将放置代表我们健身房日记中练习列表中一个条目的片段：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we have the representation of an item, with the difference being that
    we are using the `<div>` element instead of `<li>` because we want our component
    to be as reusable as possible here – it may not necessarily be used within a list
    and within an `<``ul>` element.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有了一个条目的表示，区别在于我们使用 `<div>` 元素而不是 `<li>`，因为我们希望我们的组件尽可能可重用——它可能不一定在列表和
    `<ul>` 元素中使用。
- en: 'Let’s put our component to use. In the `diary.component` component, let’s refactor
    the `diary.component.html` file as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把我们的组件用起来。在 `diary.component` 组件中，让我们按照以下方式重构 `diary.component.html` 文件：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Using the `app-entry-item` selector, we are consuming our new component on the
    page. From version 15 of Angular, we can use self-closing tags for components,
    so we have used `<app-entry-item />` here, but if you prefer the previous way,
    `<app-entry-item>` `</app-entry- item>` also still works.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `app-entry-item` 选择器，我们在页面上使用了我们的新组件。从 Angular 的第 15 版开始，我们可以为组件使用自闭合标签，所以我们在这里使用了
    `<app-entry-item />`，但如果你更喜欢以前的方式，`<app-entry-item>` `<app-entry-item>` 仍然有效。
- en: Running our project, we can see that it continues to work. However, the data
    is the same in both items. We now need a way to pass information between components,
    and we’ll see how to do that in the next section.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 运行我们的项目，我们可以看到它仍然在正常工作。然而，两个条目中的数据是相同的。我们现在需要一种在组件之间传递信息的方法，我们将在下一节中看到如何做到这一点。
- en: Communication between components – inputs and outputs
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件之间的通信 – 输入和输出
- en: In our gym diary application, we now need the workout list page component, `DiaryComponent`,
    to communicate with the list item component, `EntryItemComponent`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的健身房日记应用程序中，我们现在需要一个锻炼列表页面组件 `DiaryComponent` 与列表项组件 `EntryItemComponent`
    进行通信。
- en: The simplest way to accomplish this communication is with Angular’s Property
    Binding concept. Despite the complicated name, in practice, we annotate a component
    object’s property with the `@Input` annotation, so Angular creates a custom HTML
    attribute on the component.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这种通信的最简单方式是使用 Angular 的属性绑定概念。尽管名字听起来复杂，但实际上，我们通过在组件对象的属性上添加 `@Input` 注解来标注，这样
    Angular 就会在组件上创建一个自定义的 HTML 属性。
- en: 'Let’s see this concept in practice; first, let’s create an interface that will
    represent an item in our diary:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个概念在实际中的应用；首先，让我们创建一个接口来表示我们日记中的一个条目：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With the preceding command, we create the file and, as an organized practice,
    we create a folder to store the module’s interfaces. In the generated file, we
    will define the object we want to communicate with:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的命令，我们创建了文件，并且作为一个有组织的实践，我们创建了一个文件夹来存储模块的接口。在生成的文件中，我们将定义我们想要通信的对象：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We create an interface defining the object and a type to define a list of exercises,
    improving the future readability of our implementation.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个接口来定义对象，并定义了一个类型来定义一系列锻炼，这提高了我们实现的可读性。
- en: 'Now, in the `entry-item.component.ts` file, let’s add the new property:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `entry-item.component.ts` 文件中，让我们添加新的属性：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here we create a property called `exerciseSet` of type `ExerciseSet` that we
    just defined. We use the `!` symbol in the type definition because we are going
    to define its value at runtime.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为 `exerciseSet` 的属性，其类型为 `ExerciseSet`，这是我们刚刚定义的。我们在类型定义中使用 `!`
    符号，因为我们将在运行时定义其值。
- en: The `@Input` annotation receives the `exercise-set` string as a parameter. With
    this, we define the name of the custom HTML attribute to be used in the template.
    This parameter is optional; if it's not used, the name of the attribute will be
    the name of the property. Here, it would be `exerciseSet`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Input` 注解接收 `exercise-set` 字符串作为参数。有了这个参数，我们定义了在模板中使用的自定义 HTML 属性的名称。这个参数是可选的；如果不使用它，属性名称将与属性名称相同。在这里，它将是
    `exerciseSet`。'
- en: 'Let’s now change our template to use this property:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更改我们的模板以使用这个属性：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To use the component’s properties inside the template, we use the `{{ }}` syntax.
    Here, we can see an advantage of using VS Code with the Angular Language Service
    extension enabled because we have type-checking in the HTML template, avoiding
    typos, for example.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要在模板中使用组件的属性，我们使用 `{{ }}` 语法。在这里，我们可以看到启用 Angular 语言服务扩展的 VS Code 的一个优点，因为我们可以在
    HTML 模板中进行类型检查，避免例如拼写错误等问题。
- en: Something to highlight in this example is the `Date` attribute. Here, we are
    using an Angular feature called `pipe`, which allows the formatting of a template
    element. In this case, we are formatting a date.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中需要强调的是 `Date` 属性。在这里，我们使用了一个名为 `pipe` 的 Angular 功能，它允许格式化模板元素。在这种情况下，我们正在格式化日期。
- en: 'Let’s now configure a list of exercises in the `diary.component.ts` file:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在 `diary.component.ts` 文件中配置一个锻炼列表：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For this example, we create a property called `exerciseListExample` and fill
    it with objects from the `ExerciseSet` interface. Now, let’s change the list template
    in the `diary.component.html` file:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们创建一个名为 `exerciseListExample` 的属性，并用来自 `ExerciseSet` 接口的对象填充它。现在，让我们在
    `diary.component.html` 文件中更改列表模板：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the template, we are using the `ngFor` directive, which has the function
    of iterating over a list and rendering the element we want to define in the template.
    For each list item, we are going to create a new `app-entry-item` component and
    now we want to assign an item to it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中，我们使用 `ngFor` 指令，它具有遍历列表并渲染我们在模板中想要定义的元素的功能。对于每个列表项，我们将创建一个新的 `app-entry-item`
    组件，现在我们想要将它分配给它。
- en: 'To do that, we use the `[exercise-set]` attribute to pass the item provided
    by `ngFor`. When we run our project, we have the list, as shown in the following
    figure:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们使用 `[exercise-set]` 属性来传递 `ngFor` 提供的项目。当我们运行我们的项目时，我们会看到以下图所示的列表：
- en: '![Figure 4.2 – Gym diary application UI after refactoring](img/B19562_04_2.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – 重构后的健身房日记应用程序 UI](img/B19562_04_2.jpg)'
- en: Figure 4.2 – Gym diary application UI after refactoring
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 重构后的健身房日记应用程序 UI
- en: With this, we understand how to pass information from one component to another,
    but we can improve this project by introducing a good performance practice, the
    `TrackBy` property.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们了解了如何从一个组件传递信息到另一个组件，但我们可以通过引入良好的性能实践，即 `TrackBy` 属性来改进这个项目。
- en: Best practice – using the TrackBy property
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践 – 使用 TrackBy 属性
- en: After the `*ngIf` directive, the `ngFor` directive will probably be the directive
    that you will use the most in your Angular projects. Although simple, this directive
    can hide a performance and perception problem in the frontend that will occur
    for your user.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `*ngIf` 指令之后，`ngFor` 指令很可能是你将在你的 Angular 项目中最常使用的指令。尽管简单，但这个指令可以隐藏前端可能发生的性能和感知问题，这些问题将影响你的用户。
- en: To demonstrate this, let’s add a new list button, simulating a list update coming
    from the backend.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，让我们添加一个新的列表按钮，模拟来自后端的一个列表更新。
- en: 'In the `diary.component.ts` file, add the following method:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `diary.component.ts` 文件中，添加以下方法：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This method replaces the array with this new array, which contains the same
    elements but with one more item.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法用这个新数组替换数组，该数组包含相同的元素，但多了一个项目。
- en: 'Let’s add the button to the list template:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在列表模板中添加按钮：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When we click on the **Server Sync** button, the entire item list is rendered,
    even though the new list is identical to the original except for the addition
    of a new item.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击 **服务器同步** 按钮时，整个项目列表都会被渲染，尽管新的列表与原始列表除了新增一个项目外完全相同。
- en: '![Figure 4.3 – Chrome DevTools](img/B19562_04_3.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3 – Chrome 开发者工具](img/B19562_04_3.jpg)'
- en: Figure 4.3 – Chrome DevTools
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – Chrome 开发者工具
- en: For a few items, this may not necessarily be a problem, but for a larger list,
    this unnecessary rendering may offend the performance perception our user will
    have of our application.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于少量项目，这可能不一定是问题，但对于较长的列表，这种不必要的渲染可能会冒犯用户对我们应用程序性能的感知。
- en: 'To improve this kind of case, the `ngFor` directive has the `TrackBy` option.
    Let’s refactor our code to demonstrate this option; first, let’s create a method
    for the exercise list component:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改进这类情况，`ngFor` 指令有 `TrackBy` 选项。让我们重构我们的代码来展示这个选项；首先，让我们为练习列表组件创建一个方法：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This method tells Angular how to identify the single element in a collection
    that it will iterate through the `*ngFor` directive. Think of it as the *primary
    key* of the collection.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法告诉 Angular 如何识别它将遍历 `*ngFor` 指令的集合中的单个元素。把它想象成集合的 *主键*。
- en: 'In the component’s template, let’s change the `ngFor` configuration:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件的模板中，让我们更改 `ngFor` 配置：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we are telling `ngFor` to render based on the `id` property of the object.
    Running it again in the browser with Chrome DevTools, we see that now only the
    item with the `id` attribute is rendered on the page.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们告诉 `ngFor` 根据对象的 `id` 属性进行渲染。再次在浏览器中使用 Chrome DevTools 运行它，我们看到现在只有具有
    `id` 属性的项目在页面上被渲染。
- en: 'The `TrackBy` attribute, in addition to avoiding unnecessary rendering, has
    the following advantages:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`TrackBy` 属性除了避免不必要的渲染外，还有以下优点：'
- en: Enables animations when removing and adding items from the collection
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在从集合中添加和删除项目时启用动画
- en: Retains any DOM-specific UI state, such as focus and text selection, when the
    collection changes
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当集合发生变化时，保留任何与DOM特定的UI状态，例如焦点和文本选择。
- en: Now that we’ve learned about the use of this `ngFor` property, let’s study how
    we can architect the composition of our components and pages.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了`ngFor`属性的使用，让我们研究如何构建我们组件和页面的架构。
- en: Separating responsibilities – Smart and Presentation components
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分离责任 – 智能和展示组件
- en: The information flow of a **single-page application** (**SPA**) can be quite
    complex and, if you don’t think about this flow from the beginning of your design,
    it can affect the productivity and quality of your project over time.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 单页应用（**SPA**）的信息流可能相当复杂，如果你在设计之初没有考虑这种流程，它可能会随着时间的推移影响你项目的生产力和质量。
- en: The simpler the better; therefore, a very common design pattern not only in
    Angular applications but also in SPAs in general is the composition of interfaces
    using Smart and Presentation components. In literature and in the community, you
    will also find this pattern under the name of **Smart** and **Dumb** components
    or **Container** and **Presentation** components.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 简单为佳；因此，在Angular应用中以及一般单页应用中，一个非常常见的模式是使用智能组件和展示组件来组合接口。在文献和社区中，你也会找到这个模式被称为**智能**和**愚笨**组件或**容器**和**展示**组件。
- en: A Smart component has the UI business rule; it is where we will have injected
    the services that will communicate with the backend and where the interface with
    the Presentation components will be composed.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 智能组件具有UI业务规则；这是我们注入将与后端通信的服务的地方，以及与展示组件的接口将被组合的地方。
- en: A Presentation component is a component that has the sole purpose of showing
    the data passed by the Smart component, normally via input. A Presentation component
    in turn can contain one or more components of the Presentation type.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 展示组件是一个仅用于展示智能组件通过输入传递的数据的组件。展示组件反过来可以包含一个或多个展示类型的组件。
- en: 'To illustrate this pattern, we will use the following diagram:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这个模式，我们将使用以下图表：
- en: '![Figure 4.4 – Smart and Presentation components](img/B19562_04_4.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图4.4 – 智能和展示组件](img/B19562_04_4.jpg)'
- en: Figure 4.4 – Smart and Presentation components
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 – 智能和展示组件
- en: Notice that we have a source of truth, which is the Smart component, and the
    communication occurs in only one direction, this is what we call a Unidirectional
    Data Flow. The purpose of this pattern is to isolate all states within a component
    and thereby simplify state management.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们有一个真相来源，即智能组件，通信只在一个方向上发生，这就是我们所说的单向数据流。这个模式的目的是将组件内的所有状态隔离开来，从而简化状态管理。
- en: 'Let’s refactor our project to fit this design pattern. Let’s create a new presentation
    component using the Angular CLI:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重构我们的项目以适应这个设计模式。让我们使用Angular CLI创建一个新的展示组件：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this new component, we are going to move the part that renders the list
    of diary entries into your template. In the `list-entries.component.html` file,
    add the following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新组件中，我们将把渲染日记条目列表的部分移动到模板中。在`list-entries.component.html`文件中，添加以下代码：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The list that will be displayed will come ready from the `DiaryComponent` component,
    so in the `list-entries.component.ts` file, we will add the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 将要显示的列表将直接从`DiaryComponent`组件中准备好，因此，在`list-entries.component.ts`文件中，我们将添加以下代码：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we move the `itemTrackBy` function into the component, as it will be its
    function to display the list, and we include the `exerciseList` attribute with
    the `@Input` decorator. In this example, we didn’t specify any parameters, so
    the name of the template’s attribute will be the same as the attribute of the
    `exerciseList` class.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`itemTrackBy`函数移动到组件中，因为这将是其显示列表的功能，并且我们包含带有`@Input`装饰器的`exerciseList`属性。在这个例子中，我们没有指定任何参数，所以模板属性的名称将与`exerciseList`类的属性名称相同。
- en: 'Let’s change the `Diary` template in the `diary.component.html` file to use
    the new presentation component we have created:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`diary.component.html`文件中更改`Diary`模板以使用我们创建的新展示组件：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `DiaryComponent` Smart component just passes the list to the `ListEntriesComponent`
    Presentation component, which iterates over the list by calling the `EntryItemComponent`
    Presentation component. With this structure, only the `DiaryComponent` component
    needs to worry about the list of exercises, respecting SOLID’s Single Responsibility
    concept.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`DiaryComponent`智能组件只是将列表传递给`ListEntriesComponent`展示组件，该组件通过调用`EntryItemComponent`展示组件来遍历列表。在这种结构下，只有`DiaryComponent`组件需要担心练习列表，遵循SOLID的单一职责概念。'
- en: We’ve studied how to structure our pages and components, but how do child components
    communicate with their parents? Let’s learn about the output attributes of Angular
    components next.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何构建我们的页面和组件，但子组件如何与父组件通信呢？让我们接下来学习Angular组件的输出属性。
- en: "Communication from the child component – using \L@Output"
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子组件的通信 - 使用@Output
- en: We studied how parent components, which can be either smart or presentational,
    can communicate with their child components by using attributes marked with the
    `@``Input` decorator.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了父组件，无论是智能组件还是展示组件，可以通过使用带有`@Input`装饰器的属性与子组件通信。
- en: However, when we need the opposite, the child component passes some information
    to the parent. As we saw in the previous section, business rule processing should
    ideally happen in the Smart component. For this type of communication, we mark
    attributes with the `@``Output` decorator.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们需要相反的情况时，子组件将一些信息传递给父组件。正如我们在上一节中看到的，业务规则处理理想情况下应该在智能组件中完成。对于这种类型的通信，我们使用`@Output`装饰器标记属性。
- en: 'Let’s create a button for adding an item to our diary. We’ll see the use of
    forms in [*Chapter 6*](B19562_06.xhtml#_idTextAnchor186), *Handling User Input:
    Forms*, but here we want to focus on the interaction between components.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的日记创建一个添加条目的按钮。我们将在[*第6章*](B19562_06.xhtml#_idTextAnchor186)中看到表单的使用，*处理用户输入：表单*，但在这里我们想要关注组件之间的交互。
- en: 'Using the Angular CLI, we will create the new component using this command:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Angular CLI，我们将使用以下命令创建新组件：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the new component’s template, let’s move the diary button template into
    the component:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在新组件的模板中，让我们将日记按钮模板移动到组件中：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the `new-item-button.component.ts` file, we will add the new attribute:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在`new-item-button.component.ts`文件中，我们将添加一个新的属性：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we first create the `newExerciseEvent` attribute and add the `@Output`
    decorator to define that it will be an attribute present in the component’s template.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先创建`newExerciseEvent`属性，并添加`@Output`装饰器来定义它将在组件的模板中作为一个属性存在。
- en: Here, there is a difference from the `@Input` attribute; in this case, we are
    already assigning an object of the `EventEmitter` class to the variable. This
    Angular class aims to emit events when a certain action takes place.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，与`@Input`属性有所不同；在这种情况下，我们已经在变量中分配了一个`EventEmitter`类的对象。这个Angular类旨在在发生某些操作时发出事件。
- en: This is necessary because, unlike `@Input`, the value of which is assigned when
    the component is structured and rendered, `@Output` communication can occur at
    any time, depending on the user’s action.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为，与`@Input`不同，其值在组件结构化和渲染时分配，`@Output`通信可以在任何时间发生，取决于用户的操作。
- en: The `EventEmitter` class uses TypeScript’s type-checking capability, making
    it possible for us to determine what type of object we are going to emit to the
    parent component.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventEmitter`类利用TypeScript的类型检查功能，使我们能够确定我们将要向父组件发出的对象类型。'
- en: In the `addNewExercise` method, we create an object of type `ExerciseSet`, and
    using the `emit` method of the `EventEmitter` class, we pass this object to the
    parent component.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在`addNewExercise`方法中，我们创建一个`ExerciseSet`类型的对象，并使用`EventEmitter`类的`emit`方法将此对象传递给父组件。
- en: 'Back to the template – let’s add the method call to the button’s `click` action:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 回到模板 - 让我们在按钮的`click`动作中添加方法调用：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now let’s refactor `DiaryComponent` to consume the new button:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重构`DiaryComponent`以使用新的按钮：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the template, we are using the `app-new-item-button` component to pass the
    `addExercise` function to the `newExerciseEvent` attribute.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中，我们使用`app-new-item-button`组件将`addExercise`函数传递给`newExerciseEvent`属性。
- en: Here, we can highlight that the binding of an `@Output` attribute must be done
    with parentheses – `( )` – and this `$event` parameter represents the object that
    the child component will emit. If you highlight this parameter in VS Code, we
    can verify that it is of type `ExerciseSet`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以强调，`@Output`属性的绑定必须使用括号——`( )`——并且这个`$event`参数代表子组件将要发出的对象。如果你在VS Code中突出显示此参数，我们可以验证它属于`ExerciseSet`类型。
- en: 'Finally, let’s create the `addExercise` method in the component:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们在组件中创建`addExercise`方法：
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Our method receives the emitted value and adds it to the `exercises` array.
    Running our project, we can see that the items are successfully added.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的方法接收发出的值并将其添加到`exercises`数组中。运行我们的项目，我们可以看到项目已成功添加。
- en: In this example, we can see in practice the whole flow of the design pattern
    of the Smart and presentation components. When clicking on the `Diary` Smart component
    receives the new exercise from the `NewItemButtonComponent` presentation component.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以看到设计模式中智能和展示组件的整个流程的实际应用。当点击`Diary`智能组件时，它会从`NewItemButtonComponent`展示组件接收新的练习。
- en: By updating the list, the list is automatically passed to the `ListEntriesComponent`
    component, which renders the list on the screen. Now we are going to implement
    actions for the items of the list of exercises – we will see how to emit events
    of these items and how to identify these elements.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更新列表，列表会自动传递到`ListEntriesComponent`组件，该组件在屏幕上渲染列表。现在我们将实现列表中练习项的动作——我们将看到如何发出这些项的事件以及如何识别这些元素。
- en: Propagating events from nested components
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从嵌套组件传播事件
- en: 'We will add the options to delete an item from the list and increase the number
    of repetitions to our diary. First, let’s add the buttons to the list item template.
    In the `entry-item.component.html` file, we will edit the template:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在日记中添加删除列表项和增加重复次数的选项。首先，让我们向列表项模板中添加按钮。在`entry-item.component.html`文件中，我们将编辑模板：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The challenge here is to ensure that the action that will happen on each item
    in the list if correctly identified to be applied correctly – that is, the `Diary`
    Smart component that handles the list will find the corresponding item and change
    it.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的挑战是确保正确识别列表中每个项目的动作，以便正确应用——也就是说，处理列表的`Diary`智能组件将找到相应的项目并更改它。
- en: 'For this, we will apply the Angular output feature to the item component:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将应用Angular输出功能到项目组件：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We create two outputs, each one for a different event that we want to emit,
    and we type them because we need different actions.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建两个输出，每个输出对应我们想要发出的不同事件，并且我们输入它们，因为我们需要不同的动作。
- en: We then create the `delete` method, which will emit the `id` value of the item
    we want to delete, and the `newRep` method, with which we will add repetitions
    to the item of the exercise that will be performed and emit that item.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建`delete`方法，该方法将发出我们想要删除的项目`id`值，以及`newRep`方法，我们将使用它为将要执行的运动项目添加重复次数并发出该项目。
- en: 'We will return to the template to associate the methods with the buttons created:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将回到模板，将方法与创建的按钮关联：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now let’s change the `list-entries.component` presentation component for creating
    the output, which here, for simplicity, will have the same name as the item’s
    output:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更改`list-entries.component`展示组件以创建输出，这里为了简单起见，它将具有与项目输出相同的名称：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To propagate the item’s events, we will change the list template:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了传播项目事件，我们将更改列表模板：
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We can see that we only emit the item’s event using the `emit` method of the
    outputs.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们只使用输出的`emit`方法发出项目事件。
- en: 'Finally, we will refactor the `DiaryComponent` Smart component to react to
    the item’s event. First, let’s see the template:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将重构`DiaryComponent`智能组件以响应项目事件。首先，让我们看看模板：
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As in the previous example, we used parentheses to associate it with a method,
    which will handle the event and receive the element emitted by the parameter of
    that method using the `$``event` variable.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，我们使用括号将其与一个方法关联，该方法将处理事件并使用`$event`变量接收该方法参数发出的元素。
- en: 'We will now refactor the component by creating two new methods – one to delete
    a journal entry and one to create a new repetition for an exercise:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将通过创建两个新方法来重构组件——一个用于删除日记条目，另一个用于为练习创建新的重复项：
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We are using the TypeScript array methods to simulate deleting and changing
    the array of items. We can see that the method already receives the deletion item
    or id automatically due to Angular’s event emission mechanism.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用TypeScript数组方法来模拟删除和更改项目数组。我们可以看到，由于Angular的事件发射机制，该方法已经自动接收删除项或id。
- en: We are taking advantage of the smart and presentation component pattern here
    to leverage its usage with a slightly more complex requirement.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里利用智能和展示组件模式，以适应稍微复杂一些的需求。
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we studied the elements responsible for rendering the interface
    of our project, the components. We saw how to create and organize the components
    in a granular way, resulting in our project being more maintainable.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了负责渲染我们项目界面的元素，即组件。我们看到了如何以细粒度创建和组织组件，从而使我们的项目更具可维护性。
- en: We also studied how to communicate between components using the `@Input` and
    `@Output` attributes, using the capabilities of Angular that facilitate this communication.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了如何使用`@Input`和`@Output`属性在组件之间进行通信，利用Angular提供的促进这种通信的能力。
- en: We saw the good practice of using `TrackBy` to iterate lists in templates using
    the `ngFor` directive, improving performance specifically for lists with many
    items.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了使用`TrackBy`在模板中通过`ngFor`指令迭代列表的良好实践，这特别提高了具有许多项目的列表的性能。
- en: Finally, we study the design pattern of the Smart and Presentation components,
    a way of organizing components and their interactions in order to simplify this
    orchestration with a unidirectional information flow.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们研究了智能和展示组件的设计模式，这是一种组织组件及其交互的方式，以便通过单向信息流简化这种编排。
- en: In the next chapter, we will study the Angular elements responsible for the
    business rules and interaction with the backend – the services.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将研究Angular中负责业务规则和与后端交互的元素——服务。
