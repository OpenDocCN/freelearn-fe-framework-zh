- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing Your Application’s State with Pinia
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building web applications is no simple task, not only because of the amount
    of knowledge required to write them but also because of the architectural complexity
    that a mature application can develop.
  prefs: []
  type: TYPE_NORMAL
- en: When we first started this book, we introduced simple topics such as the ability
    to replace text with string interpolation or hide an element with the `v-if` directive.
    These features are at the core of the Vue.js framework and are needed to build
    an application with this framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we progressed in the book, we started to introduce topics that are not always
    required at the very start of your project development – and in some cases not
    needed at all. In the previous chapter, we covered Vue Router, which was the first
    additional package to join the Vue.js core framework. We are going to continue
    the trend by introducing another core maintained package that is part of the Vue
    ecosystem: Pinia.'
  prefs: []
  type: TYPE_NORMAL
- en: Pinia is the official state management package for Vue.js. It is the descendant
    of the previous state management package, which was called Vuex.
  prefs: []
  type: TYPE_NORMAL
- en: Why two different names?
  prefs: []
  type: TYPE_NORMAL
- en: If both packages have been created and maintained by the same open source maintainer,
    why do they have different names? Pinia was supposed to be called Vuex 5, but
    during its development, they decided to give it a different name due to the two
    versions being majorly different from one another.
  prefs: []
  type: TYPE_NORMAL
- en: As I have already mentioned, some features are not always expected in every
    application, and state management is one of them. In fact, introducing state management
    on a very small site would probably be a sign of over-architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to explain what state management is and introduce
    Pinia as the official package of the Vue.js ecosystem. We will then discuss when
    an application is expected to include a state management system and cover the
    pros and cons of using one. We will then do some practice by including two stores
    within our application: one to handle the sidebar and one to handle our posts.
    While doing so, we will also add a couple of features to our app, such as the
    ability to toggle the sidebar from the header and the option to add new posts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The chapter has the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: When to use state management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about the structure of a Pinia store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Centralized sidebar state management with Pinia
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you should be familiar with the notion of state management
    and be able to define and use stores within your future applications.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, the branch we will use is called `CH11`. To pull this branch,
    run the following command or use your GUI of choice to support you in this operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The code files for the chapter can be found at [https://github.com/PacktPublishing/Vue.js-3-for-Beginners](https://github.com/PacktPublishing/Vue.js-3-for-Beginners).
  prefs: []
  type: TYPE_NORMAL
- en: When to use state management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first and most important part of this chapter is learning when it is appropriate
    to use Pinia in your application and when it is not.
  prefs: []
  type: TYPE_NORMAL
- en: All extra packages and features that are added to an application come with an
    extra cost. This cost is in the time that it takes to learn these new skills,
    the extra time that a new feature may take to build, the extra complexity that
    the overall architecture may add to the project, and finally the extra size that
    another package adds to your JavaScript bundle.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a state manager to your application falls into this category of possible
    features that may not always be needed. Luckily for us, adding and utilizing Pinia
    is simple and does not add as much overhead to the project as other counterparts
    such as React Redux.
  prefs: []
  type: TYPE_NORMAL
- en: The rule of thumb is that state management should only be added to a project
    if the project is complex enough and includes many layers of components, and if
    passing values across the application is complicated.
  prefs: []
  type: TYPE_NORMAL
- en: A good use case for Pinia is an application that is large, with properties being
    passed between many layers. Another use case would be a SPA that has very complex
    data that needs to be shared and manipulated by multiple parts of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main problem that state management solves is **prop drilling**. Therefore,
    the more complex and deep the application structure is, the better suited Pinia
    is for the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1: Properties are passed down to multiple layers of components](img/B21130_11_01_BW.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.1: Properties are passed down to multiple layers of components'
  prefs: []
  type: TYPE_NORMAL
- en: What is prop drilling?
  prefs: []
  type: TYPE_NORMAL
- en: The process of passing data from parents to children, especially multiple layers
    deep, is also referred to as prop drilling. It is a commonly used term when talking
    about state management and will also be used in the rest of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s analyze a few project examples and see whether we would need Pinia’s
    support to handle state management:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Brochure site**: A simple site with a couple of static pages, perfect for
    local businesses. The site may have a contact form. There is no real data that
    needs to be managed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Store* *not needed*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**A personal blog**: This site is a little more complex, with dynamic pages
    that render the blog pages as we learned about in the chapter on Vue Router. The
    data is passed to the pages, but it is not modified or needed in multiple parts
    of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Store* *not needed*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**An e-commerce site**: A commerce site used to sell products. This site will
    mostly be dynamic, with lots of interactivity offered throughout. Data needs to
    be passed and modified by many layers of the application, such as from the cart
    to the checkout.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Store needed*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**A social media site**: A site that is used to create and share posts. The
    site will also have pages filtered by user, tags, category, and so on. The same
    data can be reused in many parts of the application, and using a store can ensure
    the data is only fetched once and then reused.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Store needed*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Adding a state manager is not a must for all sites, but a requirement that is
    driven by the specific use case and needs of your SPA. It is true that as you
    progress in your career and get familiar with the tools and technology that the
    framework has to offer, you will find yourself over-architecting your application
    more often than not. However, at the very start of your career, it is important
    to stay lean and only choose the tools that you really need for your SPA.
  prefs: []
  type: TYPE_NORMAL
- en: Before moving on to the next section, we should say a few more words on the
    real benefits of using state management. We are going to do so by comparing two
    applications that have the same component structure but handle data differently.
    One uses prop drilling, while the other uses state management.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with the example shown in *Figure 11**.1*. That example is similar
    to our Companion App, and it shows the way the `post` property flows from the
    `App.vue` component all the way down to the last component to render the post
    on the screen. At this stage, the application is still quite simple. Even if there
    is some multi-layer prop drilling happening, the complexity is still acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now going to add the possibility for a user to edit a post. Since properties
    can simply be modified in the component in which they are defined, we will have
    to emit an “edit” event all the way up the component tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2: Props are passed down and events are passed up the component
    tree](img/B21130_11_02_BW.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.2: Props are passed down and events are passed up the component tree'
  prefs: []
  type: TYPE_NORMAL
- en: The situation here is starting to get more complicated. On top of prop drilling,
    we also have `Post` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to include a Pinia store and see what changes it brings to the
    table. Pinia is going to take ownership of the `post` property and provide it
    to the component that needs to read or modify it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3: A Pinia store managing the data](img/B21130_11_03_BW.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.3: A Pinia store managing the data'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a store has removed a lot of complexity in our application. When we edit
    posts, the only component that we re-render now will be **Post Body**. Furthermore,
    the store easily allows us to pass specific data down, such as **Recent post**
    in the sidebar. Doing so will also ensure that the sidebar will not be re-rendered
    unless the post that changed is included in it (this was also possible using props,
    but was not usually practiced).
  prefs: []
  type: TYPE_NORMAL
- en: In this short section, we defined when state management is needed and when it
    should be omitted from your application. Then, we defined when a store is needed
    in your application by describing a few example applications. Finally, we introduced
    the notion of state management and covered the benefits that it brings to your
    application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to learn about the structure of Pinia and
    how we can use it within our application.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about the structure of a Pinia store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to cover what makes up a Pinia store and how it
    can be used to support you in managing the data of your application. Pinia is
    built on the notion of multiple stores. Each individual store is going to manage
    a specific set of data or company logic that is not bound to a specific component.
    Your application could have a store for posts, a store for comments, and even
    a store to manage the state of the sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: Stores can talk with each other, but what matters the most is that you should
    be able to easily define what makes a single store. The stores’ data should be
    split well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each store is divided into three different sections: **state**, **getters**,
    and **actions**.'
  prefs: []
  type: TYPE_NORMAL
- en: These three sets of options that are available within a Pinia store can actually
    compare to existing features that we have learned about regarding Vue Single-File
    Components.
  prefs: []
  type: TYPE_NORMAL
- en: The **state** object defined in Pinia is comparable to Ref or Reactive used
    as private component data. The **getters** are comparable to computed properties,
    as they are used to create a modified version of the existing **state**. Lastly,
    we have **actions** that are like methods and are used to perform side effect
    on the store.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4: Comparison between Pinia’s options and a Vue component](img/B21130_11_04_BW.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.4: Comparison between Pinia’s options and a Vue component'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we first initialized the application, we opted for the `CLI` command to
    create a store for us. For this reason, the Companion App includes a very simple
    store example here: [src/stores/counter.js](https://src/stores/counter.js). Let’s
    see what it includes to learn more about the actual structure of a Pinia store:'
  prefs: []
  type: TYPE_NORMAL
- en: src/stores/sidebar.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first part of a store is its declaration. A store is declared using the
    `defineStore` method available within the `pinia` package. When creating a store,
    it is common for the exported method to follow the format of `counter` repository,
    we can expect the exported method to be named `useCounterStore`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have the `state` object. This is declared as a function that returns
    an object. The syntax may look familiar because it is the same as the syntax that
    we introduced in [*Chapter 2*](B21130_02.xhtml#_idTextAnchor028) when we spoke
    about Vue components being declared using Options API. The `state` object includes
    the values of the store at their initial state.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have getters, which are the equivalent of the computed properties available
    within a Vue component. Getters are used to create a derivative value using `state`
    or other getters. For example, in a post store, we may have getters for `visiblePost`
    that just return the posts that have a `visible` flag. Getters receive the state,
    as the first argument has shown in the previous code snippets within the getters
    doubleCount.
  prefs: []
  type: TYPE_NORMAL
- en: Last, we have actions. These are equivalent to methods and are used to trigger
    a side effect that can be used to modify one or more store entries. In our example,
    the action is called `increment`, and it is used to increase the value of the
    `count` state. Actions are asynchronous and can include external side effects
    such as calling an API or calling other store actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have learned how a store is structured, it is time to learn how
    to use a store within a component. To use a store within a component, we need
    to initialize it using the exported method generated using `definedStore`. In
    the instance of the counter store our initialization method would be `useCounterStore`
    that was defined in a previous code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then use it to access the state entries directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The same is then applied for the getters and actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In this section, we introduced the basic structure of a Pinia store. We learned
    how to declare it using `defineStore`, then explained the three different parts
    of a store: state, getters, and actions. Finally, we learned how to access a store
    from the component by using the counter store to learn the syntax required to
    access its state, getters, and actions.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will apply what we have learned so far by creating a
    few stores.
  prefs: []
  type: TYPE_NORMAL
- en: Centralized sidebar state management with Pinia
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we introduced the basic structure and syntax of Pinia.
    To better learn and understand state management, we are going to modify our Companion
    App by refactoring some of the existing data into its own store. We are going
    to implement two different stores. The first is going to be a very simple store
    that will manage the state of the sidebar, while the second is going to handle
    posts.
  prefs: []
  type: TYPE_NORMAL
- en: The store that handles the sidebar state is going to be quite small. It will
    be perfect for us to understand the basic syntax and usage of the store, while
    the one that handles posts is going to be a little more complex.
  prefs: []
  type: TYPE_NORMAL
- en: State management should not be used for all data, and its addition should be
    accompanied by a good reason that supports its use. So, is it right to add it
    on the sidebar?
  prefs: []
  type: TYPE_NORMAL
- en: Do your research
  prefs: []
  type: TYPE_NORMAL
- en: Go back to the code base and try to understand everything you can about the
    sidebar and how it functions. Exploratory knowledge is very useful in developing
    your tech skills.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sidebar currently offers these features:'
  prefs: []
  type: TYPE_NORMAL
- en: It can either be opened or closed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be toggled with the use of a button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It remembers its state using local storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the logic is included within the same component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our simple `Sidebar.vue` component makes our sidebar nice and interactive.
    But from the preceding list, one line should catch our eye: “All the logic is
    included within the same component.”'
  prefs: []
  type: TYPE_NORMAL
- en: If you jump back to the previous section, you may notice that we mentioned that
    the use of a store is usually associated with complex scenarios whereby data is
    passed between multiple components. However, in our case, all the data is stored
    in just one file and there is not much logic or computation. So why would we need
    to include a store? And is it a good idea to do so?
  prefs: []
  type: TYPE_NORMAL
- en: The short answer is no. In a scenario like this, a store is not actually needed.
    Even if I may handle sidebars with a store in my personal projects, I would not
    suggest that everyone should do so with all Vue projects.
  prefs: []
  type: TYPE_NORMAL
- en: In its current state, the sidebar is too simple for it to be moved into a Pinia
    store.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily for us, we have full control of the application, so we can simply add
    a requirement that would make the use of a store appropriate. In this situation,
    the new requirement is going to be to *add the ability to toggle the sidebar from
    the* *main header*.
  prefs: []
  type: TYPE_NORMAL
- en: Even if this requirement seems unreasonable, it is very common for the sidebar
    to be controlled by a different element. This scenario could become reality for
    your next project.
  prefs: []
  type: TYPE_NORMAL
- en: To accomplish this new requirement, we would need to perform some prop drilling
    and event bubbling for it to work without a store. However, with the use of a
    simple store, the logic is going to be abstracted from the component and easily
    accessible by the whole application.
  prefs: []
  type: TYPE_NORMAL
- en: The creation of our first store is going to require two steps. First, we are
    going to refactor our application by moving the existing methods and data into
    the store. Second, we are going to update the components to use the newly created
    store.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned before, all of the logic that handles the sidebar switching
    is currently stored in the `Sidebar.vue` component. Within this component, we
    can find the following code linked to the sidebar toggling:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declaration of the `closed` state:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Method to toggle the sidebar:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Life cycle to initialize the sidebar state:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let’s go and create our first store.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our first store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are now going to take the preceding code and move it into a new store named
    `sidebar.js`. Just like we mentioned before, the `Ref` variable is going to change
    into `State` and the methods are going to become Pinia actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by creating an empty structure for our store:'
  prefs: []
  type: TYPE_NORMAL
- en: src/stores/sidebar.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Our empty store includes the import of `defineStore` from the `pinia` package,
    the initialization of the store using the naming convention that we mentioned
    before (use + store name + Store) that creates `useSidebarStore`, and lastly three
    empty options for state, getters, and actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this stage, the store is ready to be filled with information. Let’s populate
    it with the sidebar logic:'
  prefs: []
  type: TYPE_NORMAL
- en: src/stores/sidebar.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we declared a new value in the state object called `closed`.
    This has been set to `true` initially. We have left the `getters` untouched for
    now, as it is going to be used later in the section. Next, we declared two actions.
    One was to toggle the sidebar and the other was to load the sidebar from the local
    storage using existing code from our previous methods.
  prefs: []
  type: TYPE_NORMAL
- en: If we compare the code within the actions with methods that existed in the component,
    you will notice that they are very similar. The main difference is in the way
    in which we can access the state. In fact, when these methods were in the component,
    we had to use `closed.value` to access the value of the ref, while in Pinia, the
    value of individual state entities can be accessed using the `this.closed` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Now that our store is complete, we just need to go back into the sidebar and
    replace the previous logic with the new store. Replacing the current logic with
    the store will require three steps. First, we need to load and initialize the
    store. Second, we need to replace the methods with Pinia actions, and finally,
    we need to modify the template to use the state from the store and not the ref.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by removing the previous ref and initialize the store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The store is initialized by importing and calling `useSidebarStore`. This is
    the exported method that we declared in the store. It is common to declare a constant
    called either just `store` or the name + `Store`.
  prefs: []
  type: TYPE_NORMAL
- en: Did you know?
  prefs: []
  type: TYPE_NORMAL
- en: Using specific names for the store such as `sidebarStore` rather than just calling
    it `Store` can be very beneficial when trying to search for all the usages of
    a specific store. Since using state management allows you to use this logic anywhere
    in the app, it is nice to be able to search for it quickly, so having a consistent
    naming convention is helpful.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next step, we are going to work on the methods. We will remove existing
    methods and replace them with the store actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Just like before, the preceding code includes two steps. It first removes the
    previous logic and then replaces it with the store implementation. We updated
    the content of the `onBeforeMount` life cycle by removing the logic that handles
    the retrieval of the sidebar from the state and replacing it with the `loadSidebarFromLocalStorage`
    action.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that we have not replaced the `toggleSidebar` method yet.
    This was not a mistake; in fact, we are going to be able to call the Pinia action
    directly from `<template>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see which changes are needed in the HTML of our component to complete
    our refactoring into a Pinia store:'
  prefs: []
  type: TYPE_NORMAL
- en: src/components/organisms/sidebar.vue
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Updating the HTML is the easiest change of all. In fact, the only requirement
    here is to prepend all states and actions with the `sidebarStore` store constant.
    Just like actions, state values can also be accessed directly as shown by `sidebarStore.closed`.
    This was used to access the `closed` state value.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, our refactoring of the sidebar is complete. All the logic that
    used to live within the component has been moved into a new store. The sidebar
    should work as expected, with the only difference being that its value and logic
    are stored in a store and not in the component itself.
  prefs: []
  type: TYPE_NORMAL
- en: To complete our task, we need to allow another part of the application to toggle
    the sidebar. This was the requirement that we added to justify our store creation
    and to learn about the store in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Expanding the sidebar into the header
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we are going to work in the header to complete our task by
    adding the ability to toggle the sidebar visibility from a different part of the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to do so by adding a simple button next to the settings icon in
    the header. Just like before, we are going to import and initialize the store
    and then use its actions directly. It is important to remember that this new button
    could have been placed anywhere within the application, since its action is owned
    and controlled by the store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go into `TheHeader.vue` and add the store:'
  prefs: []
  type: TYPE_NORMAL
- en: src/stores/TheHeader.vue
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: There is no difference between the code we just wrote in the header and the
    one that we previously defined in the sidebar. In fact, when using a store, we
    are able to use it anywhere we want in the application without having to define
    anything else. All instances of the store will work as one, allowing us to use
    and modify states from different parts of the application.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, our Companion App will have an added feature that will allow
    us to toggle the sidebar either by using the sidebar itself or from the header.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the notion of getters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we move to the next section in this chapter, we should introduce another
    feature of the store that was mentioned but not yet used in our Companion App:
    getters.'
  prefs: []
  type: TYPE_NORMAL
- en: Getters are comparable to computed properties. They allow you to create variables
    with the use of the store state. In our case, we are going to introduce a simple
    getter that will create a friendly `open` or `closed` label for our sidebar. Outside
    of this use case, getters can be used for translation purposes, to filter arrays,
    or to normalize data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go back to the `sidebar.js` file and add our `friendlyState` getter:'
  prefs: []
  type: TYPE_NORMAL
- en: src/stores/sidebar.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Creating a getter is very simple. You must declare a method within the getters
    object and then add the logic to create the value that is going to be returned
    by the getters. Just like computed properties, this is going to be cached. More
    importantly, it is not supposed to produce any side effects (e.g., calling an
    API or logging data).
  prefs: []
  type: TYPE_NORMAL
- en: The main point to raise about getters is that they automatically receive the
    state object as the first argument. So, to access the closed state, we would write
    `state.closed`. Just like computed properties, thanks to the Vue reactivity system,
    if the state value changes, the `friendlyState` value will also update automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our getter is in place, it is time to use it. We are going back to
    the headers and adding this string to be visible right below the user settings.
    We can reuse the store we previously imported to access the newly defined getter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed from the previous code snippets that we did not require
    any extra initialization or code and that we were able to use the existing store
    to print the `friendlyState` getters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The header should now display our string:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5: Companion App header with the sidebar state](img/B21130_11_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.5: Companion App header with the sidebar state'
  prefs: []
  type: TYPE_NORMAL
- en: This was a simple example that helped us learn how to refactor existing code,
    as well as how to define a store with states, getters, and actions. Lastly, it
    helped us learn how to use the store from one or more components within the app.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to continue our journey to learning about Pinia by introducing
    another store in our Companion App. In the next section, we are going to create
    a store that will handle our posts. This is going to be a little bit more complex
    than the previous one and will allow us to introduce a few more features offered
    by the state manager.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a post store with Pinia
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adding state management in an application is a never-ending task, as it continues
    to evolve as the application grows. What we have done so far in our application
    – refactoring the application by moving logic out of the component and into the
    store – is a common practice. As we mentioned before, moving the sidebar logic
    into a store was a bit too much and not expected in a real app, because the logic
    was small enough to live within the component (even with the prop drilling).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, the situation is different. We are going to refactor a vital
    part of the application into the store: the posts. Handling the data fetching
    and management of the posts is a vital part of the application and will probably
    grow in complexity as your application grows. Because of these points, moving
    the posts into the store is going to improve the overall application structure.'
  prefs: []
  type: TYPE_NORMAL
- en: Just like before, we are going to refactor the current code by first analyzing
    the code base to find all the code related to the post. We are then going to create
    a new store and move the code there. Finally, we are going to update the component
    to use the store.
  prefs: []
  type: TYPE_NORMAL
- en: Since this is the second time we are going through this exercise, I am going
    to jump past some steps and move directly into the creation of the store. Before
    you jump to the next section, I suggest you search for all the methods that are
    related to the post and compare them with the ones that we are going to write
    in our store. This exercise is going to be extremely valuable as it will provide
    you with insight into your current understanding of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Our new store is going to be called `posts.vue`. It will be saved in the `src/stores`
    folder just like our previous store.
  prefs: []
  type: TYPE_NORMAL
- en: 'This store is going to include a state with `posts` and `page` properties,
    as well as two different actions: `fetchPosts` and `removePosts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We initialized the store by utilizing the naming convention that we introduced
    before. This produced a named export called `usePostsStore`. Then we declared
    our state with an empty array for the `posts` variable and a value of `0` for
    with `{ posts: [], page: 0 }`. Next, we copied our methods and turned them into
    Pinia’s action. The main difference between the previous methods that lived within
    the component and the copy that we have added to our store is the way in which
    we access variables such as `page` and `posts`. In a Pinia store, the state values
    can be accessed using the `page.value`, we would change this to `this.page`.'
  prefs: []
  type: TYPE_NORMAL
- en: This is the only change that we are going to make for the methods, as the rest
    of the logic stays the same and will not require any modification.
  prefs: []
  type: TYPE_NORMAL
- en: Compared to the previous section, we have yet to introduce anything new, and
    the refactoring of the post store has followed a very similar flow as the sidebar
    store implementation. Refactoring logic into a store is usually going to be quite
    a simple exercise whereby we can lift and shift most of the logic like in our
    two examples.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the store is set, we will move our focus to the component to ensure
    it uses the store state and actions. While doing so, we are going to learn how
    to destructure a Pinia store to increase the readability of our component.
  prefs: []
  type: TYPE_NORMAL
- en: Destructing a store directly using syntax such as `const { test, test2 } = useTestStore()`
    is not possible, as it would break the reactivity of this state.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking the reactivity would mean that if the value changes within the store,
    the change will not propagate to the component anymore. To fix this limitation,
    Pinia exposes a `storeToRefs` method that will allow us to safely destructure
    the Pinia store.
  prefs: []
  type: TYPE_NORMAL
- en: Store or ref is a personal preference
  prefs: []
  type: TYPE_NORMAL
- en: Using the store directly like we did in our previous example or destructuring
    values to turn them into Refs is a completely personal preference. There is no
    right or wrong choice.
  prefs: []
  type: TYPE_NORMAL
- en: Using the store directly will clearly define what data is coming from the store,
    as it will prefix all data by the store name such as `myStore.firstName`. On the
    other hand, using Refs will generate a much cleaner component, as the state will
    not require the prefix, and accessing a state will just require the ref’s name
    such as `firstName`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s complete our store migration by changing the component to use the store
    and doing so using the `storeToRefs` method. Due to the file including many changes,
    we are going to break it down into multiple stages:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize the store:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the `private` state with the `store` state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace methods with a store action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Update the HTML.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Due to the fact that we have chosen to turn the store state into Refs, no changes
    are required within the HTML, as the names of the old Refs and the new Refs now
    match. The only change that we need to make is in the `watch` method. In fact,
    because we turned the posts array from a reactive to a ref, we now need to append
    the `.value` for it to function properly:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Before we move on, I want to bring your attention to step 3\. In fact, if you
    were careful, you may have noticed that we extracted the actions of the store
    directly without using `storeToRefs`. This is possible because actions are stateless
    and do not have any reactivity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete file will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Implementing an Add Post action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A few chapters ago, we introduced a component aimed at adding new posts to our
    state. This component was never fully implemented, as it is missing the main logic
    required to create a post. The reason why the component was left in this state
    was that adding the functionality without a store in place would have required
    a lot of prop drilling and event bubbling.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to the post store, this is not the case anymore. In fact, we are going
    to be able to generate the logic required to add a new post using store actions.
  prefs: []
  type: TYPE_NORMAL
- en: The store is the sole owner of the posts, so we do not have to worry about where
    the posts are used. We can simply create an action that adds a post knowing that
    the store will handle the propagation and handling of the state within the rest
    of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we are going to add an action in our `posts.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: src/stores/post.js
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `addPost` action is going to add a post by adding it at the start of the
    posts list. For the scope of our Companion App, adding a new post will just set
    the main body of the post, because other information such as ID and user information
    are going to be hardcoded and provided by a function called `generatePostStructure`..
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to initialize the store and attach this action to the `createPostHandler`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Using the new action follows the same syntax used before. First, we import the
    store. Second, we initialize it. Third, we destructure the actions that we want
    to use, and lastly, we use the action as if it were a simple method.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example uses the text area ref to get the `textarea` value. This
    is not the correct use of Vue.js and accessing values like this should be avoided.
    In fact, in the next chapter, we are going to refactor this file by introducing
    two-way binding with `v-model`.
  prefs: []
  type: TYPE_NORMAL
- en: Create your own store
  prefs: []
  type: TYPE_NORMAL
- en: Before moving on to the next chapter, you should try and create your own store.
    You can create a very similar store to the sidebar by creating a store that can
    handle the visibility of the `create post` component. You can use the button within
    the sidebar labeled `CreatePost.vue` visibility. You can see the full implementation
    in the `CH11-END` branch.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we continued learning about the Pinia store by refactoring
    the post data. We created a new store by defining its state and actions. We then
    converted the existing code to work within the Pinia store. Next, we introduced
    the `storeToRefs` method and learned how to destructure state and actions from
    a store. Finally, we made use of the new store by adding the ability for users
    to add a new post by simply creating a new action. What you learned here is not
    a complete list of features offered by Pinia, but a quick introduction to a great
    state management package. As you practice more, you will then learn about other
    features such as `$patch` and `$reset`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introducing state management into your application can really help you handle
    your data with ease. In the two examples that we shared in this chapter, we saw
    the benefit that state management can add to your application by avoiding prop
    drilling and event bubbling.
  prefs: []
  type: TYPE_NORMAL
- en: Before we conclude this chapter, I want to share one more benefit of using state
    management in your application. The refactor that we have accomplished in the
    previous two sections highlights the fact that using the Pinia store helped us
    remove lots of logic from the components to a single location within the store
    file.
  prefs: []
  type: TYPE_NORMAL
- en: This abstraction is not only good for a development experience but can also
    be used to choose which parts of our application can be unit tested. You may remember
    from [*Chapter 8*](B21130_08.xhtml#_idTextAnchor103) that choosing what to test
    is quite complicated, as there is a very fine line between testing too much and
    testing too little. I personally use state management to delineate which parts
    of the application I will unit test. I achieve this by always making sure all
    stores are thoroughly tested.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we first introduced the notion of state management and talked
    through the syntax and features that Pinia has to offer. We then started to put
    what we learned into practice by refactoring the sidebar into its own store. By
    doing so, we learned how to declare state, getters, and actions and how to use
    them within our components. Next, we continued our learning by refactoring one
    more piece of our application: the posts. We created a store and converted the
    methods into Pinia actions. Finally, we learned how to destructure state and the
    importance that state management can have in our application architecture.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn how to handle forms in our application
    by introducing two-way binding with `v-model` and client-side validation with
    **VeeValidate**.
  prefs: []
  type: TYPE_NORMAL
