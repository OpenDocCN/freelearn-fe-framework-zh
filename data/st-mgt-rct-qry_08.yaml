- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Testing React Query Hooks and Components
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试React Query钩子和组件
- en: You have almost mastered React Query! By now, you are well aware of how queries
    and mutations work and are ready to leverage React Query in a server-side, rendered
    project as well. Now, we’ll look at the last skill you need to be a full-on React
    Query hero – testing React Query using code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎已经掌握了React Query！到目前为止，你已经非常清楚查询和突变是如何工作的，并且准备好在服务器端渲染的项目中利用React Query。现在，我们将探讨你需要成为真正的React
    Query英雄的最后一种技能——使用代码测试React Query。
- en: This chapter will teach you how to test your `useQuery` and `useMutation` using
    components and hooks. But before that, you will get to know a super useful library
    to help you test your React Query code called Mock Service Worker.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将教你如何使用组件和钩子测试`useQuery`和`useMutation`。但在那之前，你将了解一个非常有用的库，它可以帮助你测试React Query代码，称为Mock
    Service Worker。
- en: You will then learn some restructuring tips and tricks you can leverage to make
    your React Query code more readable and reusable.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你将学习一些重构技巧和窍门，你可以利用它们使你的React Query代码更易于阅读和重用。
- en: With this knowledge, you can start testing your code. You will start with testing
    your components that leverage React Query and see what testing from a user-centric
    approach looks like for queries and mutations.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了这些知识之后，你就可以开始测试你的代码了。你将从测试利用React Query的组件开始，看看从以用户为中心的角度进行查询和突变测试是什么样的。
- en: Finally, we will dive into implementation details and see when and how we should
    test our hooks that use React Query.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将深入了解实现细节，看看我们应该何时以及如何测试使用React Query的钩子。
- en: 'In this chapter, we’ll be covering the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Configuring Mock Service Worker
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Mock Service Worker
- en: Organizing code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码组织
- en: Testing components that use React Query
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试使用React Query的组件
- en: Testing custom hooks that use React Query
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试使用React Query的自定义钩子
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_8](https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_8).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码示例都可以在GitHub上找到，地址为[https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_8](https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_8)。
- en: Configuring Mock Service Worker
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Mock Service Worker
- en: 'When testing React applications, one question often asked is how to test API
    calls. This question often leads to a follow-up question: “*How can I make sure
    my network requests return the data I expect so that my tests always receive the
    same data and don’t become flaky?*” There are many ways to answer these questions,
    and many implementations we can follow. The most common implementation often leveraged
    is mocking your data-fetching clients.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试React应用程序时，人们经常问的一个问题是如何测试API调用。这个问题通常会导致一个后续问题：“*我如何确保我的网络请求返回我期望的数据，以便我的测试总是接收到相同的数据，不会变得不可靠？*”有许多方法可以回答这些问题，我们可以遵循许多实现。最常用的实现通常是模拟你的数据获取客户端。
- en: While this approach works, one thing that I’ve seen often in all the projects
    that I have worked on that followed this method is that the more tests you write,
    the more unmaintainable they become. This is due to the fact that mocking things
    such as `fetch` or `axios` comes with a lot of boilerplate code to take care of
    things such as different routes being hit, different responses for the same route,
    and cleaning up your client mocks to avoid tests leaking on each other. Let us
    not forget that if we use GraphQL and REST in the same application, we must mock
    an extra client, depending on the component you are testing.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法可行，但我在我所参与的所有采用这种方法的项目中经常看到的一个问题是：你写的测试越多，它们就越难以维护。这是因为模拟像`fetch`或`axios`这样的东西需要大量的样板代码来处理不同路由被击中、同一路由的不同响应以及清理客户端模拟以避免测试相互泄漏等问题。我们不要忘记，如果我们在一个应用程序中使用GraphQL和REST，我们必须根据你正在测试的组件模拟额外的客户端。
- en: What if I told you there is an alternative you can use to intercept your network
    requests and return predefined data without having to mock any client? What if
    I told you this alternative supports REST and GraphQL? What if I told you that
    this alternative could also be used in your application to provide some dummy
    data for a route your backend team has not yet implemented? You can do all this
    with **Mock Service** **Worker** (**MSW**).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我告诉你有一个可以用来拦截你的网络请求并返回预定义数据而无需模拟任何客户端的替代方案，你会怎么想？如果我说这个替代方案支持 REST 和 GraphQL，你会怎么想？如果我说这个替代方案还可以用于你的应用程序，为你的后端团队尚未实现的某个路由提供一些模拟数据，你会怎么想？你可以用
    **Mock Service** **Worker** (**MSW**) 做到所有这些。
- en: 'As the MSW docs say: “*Mock Service Worker is an API mocking library that uses
    Service Worker API to intercept actual* *requests*” ([https://mswjs.io/docs/](https://mswjs.io/docs/)).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如 MSW 文档所述：“*Mock Service Worker 是一个使用 Service Worker API 来拦截实际* *请求* 的 API
    模拟库” ([https://mswjs.io/docs/](https://mswjs.io/docs/))。
- en: MSW leverages service workers to intercept requests on the network level and
    return some predefined data for that specific request. This means that just by
    having a defined API contract, you can return mocked data even before that endpoint
    exists. Also, leveraging this predefined data in your tests means you no longer
    need to mock `axios` or `fetch`. It is important to mention that service workers
    only work in the browser. In your tests, MSW uses a request interceptor library
    to allow you to reuse the same mock definitions you have in your browser.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: MSW 利用服务工作者在网络级别拦截请求，并为该特定请求返回一些预定义数据。这意味着，只要有一个定义好的 API 合同，你就可以在端点存在之前返回模拟数据。此外，利用这些预定义数据在你的测试中意味着你不再需要模拟
    `axios` 或 `fetch`。重要的是要提到，服务工作者仅在浏览器中工作。在你的测试中，MSW 使用请求拦截器库，允许你重用你在浏览器中已有的相同模拟定义。
- en: While leveraging MSW in the browser is super helpful, it sits outside this chapter’s
    scope. In this chapter, we will only use MSW in our tests.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 MSW 在浏览器中使用非常有帮助，但它超出了本章的范围。在本章中，我们只会使用 MSW 在我们的测试中。
- en: 'Here is how to add MSW to your project:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将 MSW 添加到你的项目的方法：
- en: 'If you are running npm in your project, run the following command:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在你的项目中运行 npm，请运行以下命令：
- en: '[PRE0]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you are using Yarn, run the following command:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用的是 Yarn，请运行以下命令：
- en: '[PRE1]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you are using pnpm, run the following command:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用的是 pnpm，请运行以下命令：
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once MSW is installed, we must create our request handlers and response resolvers.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 MSW 安装完成，我们必须创建我们的请求处理器和响应解析器。
- en: Request handlers allow you to specify the method, path, and response when handling
    a request. They are often paired with response resolvers. A response resolver
    is a function you pass to the request handler that allows you to specify the mocked
    response when intercepting a request.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 请求处理器允许你在处理请求时指定方法、路径和响应。它们通常与响应解析器配对。响应解析器是一个传递给请求处理器的函数，它允许你在拦截请求时指定模拟的响应。
- en: Let us now create some handlers to handle some routes. Here is what we have
    to do.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在创建一些处理器来处理一些路由。以下是我们要做的事情。
- en: Inside the `src/mocks` folder, create a `handlers.js` file.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `src/mocks` 文件夹中，创建一个 `handlers.js` 文件。
- en: 'In the `handlers.js` file, add the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `handlers.js` 文件中，添加以下代码：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding snippet, we do the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们做了以下操作：
- en: We import the `rest` namespace containing a set of request handlers to handle
    `REST` requests.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们导入包含一组请求处理器的 `rest` 命名空间，用于处理 `REST` 请求。
- en: We create a `handlers` array that will contain all of our request handlers.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个 `handlers` 数组，它将包含我们所有的请求处理器。
- en: The first mock we create is for a `GET` request to any route that contains `/api/`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的第一个模拟是一个针对包含 `/api/` 的任何路由的 `GET` 请求。
- en: When a request hits this request handler, it will return a response that will,
    in turn, return a `200 OK` response code with an object that, inside the `data`
    property, will include a `"value"` string .
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求击中这个请求处理器时，它将返回一个响应，该响应将返回一个包含 `"value"` 字符串的 `200 OK` 响应代码的对象。
- en: Now that we have created our `handlers`, we need to ensure that MSW will intercept
    our requests using our previously created `handlers`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们的 `handlers`，我们需要确保 MSW 将使用我们之前创建的 `handlers` 来拦截我们的请求。
- en: This is what we have to do.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要做的事情。
- en: Inside the `src/mocks` folder, create a `server.js` file.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `src/mocks` 文件夹中，创建一个 `server.js` 文件。
- en: 'In the `server.js` file, add the following code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `server.js` 文件中，添加以下代码：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding snippet, we leverage the `setupServer` function and our created
    `handlers` array to create an object responsible for intercepting our requests
    with our given `handlers`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们利用 `setupServer` 函数和我们的创建的 `handlers` 数组来创建一个对象，该对象负责拦截我们的请求并使用我们提供的
    `handlers`。
- en: 'Now that we have created our server file, we need to ensure `Jest` uses them.
    To do this, inside our `setupTests.js` file, add the following code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们的服务器文件，我们需要确保 `Jest` 使用它们。为此，在我们的 `setupTests.js` 文件中，添加以下代码：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is what we do in the preceding snippet:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们前面片段中所做的：
- en: We import our created `server` object.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们导入我们创建的 `server` 对象。
- en: We leverage the `beforeAll` global hook to ensure that MSW is intercepting our
    requests before any of our tests are executed.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们利用 `beforeAll` 全局钩子来确保 MSW 在我们的任何测试执行之前拦截我们的请求。
- en: We then leverage the `afterEach` global hook so that after every single test,
    we reset our handlers. This considers a scenario where we add a custom handler
    for one of our tests so that they don’t leak into another test.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们随后利用 `afterEach` 全局钩子，确保在每次测试之后重置我们的处理程序。这考虑了一种场景，即我们为我们的某个测试添加一个自定义处理程序，以防止它们泄漏到另一个测试中。
- en: Finally, we leverage the `afterAll` global hook so that after all our tests
    run, we clean up and stop intercepting requests.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们利用 `afterAll` 全局钩子，以确保在我们所有的测试运行之后，我们清理并停止拦截请求。
- en: Now, any API requests made by our tests will be intercepted by MSW.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的测试所做的任何 API 请求都将被 MSW 拦截。
- en: Before seeing how we can test our components and React Query using hooks, let
    us see a couple of patterns we can apply to make our code more structured and
    easier to test.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到我们如何使用挂钩测试我们的组件和 React Query 之前，让我们看看我们可以应用的一些模式，以使我们的代码更加结构化和易于测试。
- en: Organizing code
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织代码
- en: 'There are many ways you can organize your code. Now, one thing we need to be
    aware of is choosing patterns that save you some time and make your code better
    in the long run. This section will discuss three different patterns that we can
    leverage together or independently to make our code more structured, readable,
    and organized. Here’s what we will discuss in this section:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以以许多方式组织你的代码。现在，我们需要注意的一件事是选择可以节省你时间并使你的代码在长期内更好的模式。本节将讨论三种我们可以共同或独立利用的模式，以使我们的代码更加结构化、可读和组织。以下是本节我们将讨论的内容：
- en: Creating an API file
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 API 文件
- en: Leveraging query key factories
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用查询键工厂
- en: Creating a hooks folder
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 hooks 文件夹
- en: Creating an API file
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个 API 文件
- en: Creating an API file to contain all my requests for a specific domain is a pattern
    that I follow.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 API 文件来包含我对特定域的所有请求，这是我遵循的模式。
- en: In this file, I leverage my API client and create the functions responsible
    to make a request to a given route and return the request data.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我利用我的 API 客户端创建负责向给定路由发送请求并返回请求数据的函数。
- en: This is particularly useful because it avoids repeating the logic for the same
    request in your code and focuses all the domain-specific requests in the same
    file.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这特别有用，因为它避免了在代码中重复相同的请求逻辑，并将所有特定域的请求集中在同一个文件中。
- en: For all the requests made in the scope of this book, I would prefer to create
    a file for my user domain, given that the scope seems to be focused on users.
    So, inside our `api` folder, we will create a `userAPI.js` file.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书范围内所做的所有请求，我更愿意为我的用户域创建一个文件，因为范围似乎集中在用户上。所以，在我们的 `api` 文件夹中，我们将创建一个 `userAPI.js`
    文件。
- en: '![Figure 8.1 – Adding userAPI.js to our API folder](img/Figure_8.1_B18501.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1 – 将 userAPI.js 添加到我们的 API 文件夹](img/Figure_8.1_B18501.jpg)'
- en: Figure 8.1 – Adding userAPI.js to our API folder
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 将 userAPI.js 添加到我们的 API 文件夹
- en: 'Inside that file, we can now move all of our requests inside our code. This
    is how it might look:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个文件中，我们现在可以将所有请求移动到我们的代码中。这可能看起来是这样的：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding snippet, we can see an example of a `userAPI` file containing
    our `axios` client instance, a `getUser` function (to fetch data from a given
    user), and a `createUser` function (to create a user).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们可以看到一个 `userAPI` 文件的例子，其中包含我们的 `axios` 客户端实例、一个 `getUser` 函数（用于从给定用户获取数据）和一个
    `createUser` 函数（用于创建用户）。
- en: As you can see, this pattern improves the code reusability and readability in
    the components that end up using the functions from our API file.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这种模式提高了最终使用我们 API 文件中函数的组件的代码可重用性和可读性。
- en: One extra thing you can do that we didn’t do in the preceding snippet is add
    the specific logic from your query functions. This makes these functions more
    accessible in your application if you only use React Query. I prefer to keep my
    query functions and these API functions separated because I often use different
    query functions with the same API function. Still, it will improve your code readability
    if you choose to use it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以做的另一件事是我们之前片段中没有做的，那就是添加来自你的查询函数的特定逻辑。如果你只使用React Query，这将使这些函数在你的应用程序中更容易访问。我更喜欢将我的查询函数和这些API函数分开，因为我经常使用不同的查询函数与相同的API函数。不过，如果你选择使用它，这也会提高你的代码可读性。
- en: Leveraging query key factories
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用查询键工厂
- en: Managing query keys is often a nuisance. We forget which ones we have already
    used and need to go through most of our queries to remember them. This is where
    query key factories shine.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 管理查询键通常是一件麻烦事。我们忘记了我们已经使用了哪些，需要浏览我们的大部分查询来记住它们。这就是查询键工厂大放异彩的地方。
- en: A query key factory can be a single object that, inside each property, will
    include a function responsible for generating a query key. This way, you keep
    all your query keys in the same place and stop wasting time trying to remember
    them.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 查询键工厂可以是一个包含函数的对象，每个属性中都有一个负责生成查询键的函数。这样，你就可以将所有的查询键放在同一个地方，并停止浪费时间试图记住它们。
- en: 'This is what your query key factory can look like:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你的查询键工厂可能的样子：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see from the preceding snippet, we create a `userKey` object, which
    will be our query key factory. In each property, we have a function that will
    be responsible for returning our query key.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如前文片段所示，我们创建了一个`userKey`对象，它将成为我们的查询键工厂。在每一个属性中，我们都有一个负责返回我们的查询键的函数。
- en: Creating a hooks folder
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个钩子文件夹
- en: The name here also speaks for itself. One recommendation for organizing code
    I like to follow is creating a hooks folder.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的名字也足以说明一切。我喜欢的代码组织建议之一是创建一个钩子文件夹。
- en: I like to create custom hooks in this folder that contain some of the queries
    and mutations I often repeat, or ones that end up having too much logic and impact
    my code readability. This makes it easier for me to test a specific hook in isolation
    and make the components that use them more readable.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢在这个文件夹中创建自定义钩子，其中包含一些我经常重复的查询和突变，或者那些最终包含太多逻辑并影响我的代码可读性的钩子。这使得我可以更容易地在隔离状态下测试特定的钩子，并使使用它们的组件更具可读性。
- en: 'For instance, remember when we performed optimistic updates in [*Chapter 6*](B18501_06.xhtml#_idTextAnchor159)?
    The `useMutation` hook we created is a great candidate to move to a custom hook.
    I will create a `useOptimisticUpdateUserCreation` custom hook and move my code
    in there. This is what that hook will look like:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，还记得我们在[*第6章*](B18501_06.xhtml#_idTextAnchor159)中执行乐观更新吗？我们创建的`useMutation`钩子是一个很好的候选者，可以移动到自定义钩子。我将创建一个`useOptimisticUpdateUserCreation`自定义钩子，并将我的代码移到那里。这个钩子看起来是这样的：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding snippet, we create the `useOptimisticUpdateUserCreation` hook
    and move the code from our `OptimisticMutation` component there. As you can also
    see from the code, we already applied our API file and query factory pattern.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前文片段中，我们创建了`useOptimisticUpdateUserCreation`钩子，并将`OptimisticMutation`组件中的代码移到那里。从代码中，你也可以看到，我们已经应用了我们的API文件和查询工厂模式。
- en: 'In the component using our hook, all we have to do now is import the hook and
    use it like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用我们的钩子的组件中，我们现在只需要导入钩子并像这样使用它：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Applying all the patterns of this section, this is what your project structure
    can end up looking like:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 应用本节的所有模式，你的项目结构最终可能看起来是这样的：
- en: '![Figure 8.2 – What the project structure may look like after following these
    three patterns](img/Figure_8.2_B18501.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – 遵循这三个模式后项目结构可能的样子](img/Figure_8.2_B18501.jpg)'
- en: Figure 8.2 – What the project structure may look like after following these
    three patterns
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 遵循这三个模式后项目结构可能的样子
- en: Now that we’ve seen these patterns, let us finally move to start testing our
    code. We’ll start with one of the most recommended approaches – testing components
    using React Query hooks.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了这些模式，让我们最终开始测试我们的代码。我们将从一个最推荐的方法开始——使用React Query钩子测试组件。
- en: Testing components that use React Query
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试使用React Query的组件
- en: When the React Testing Library was first introduced, it was under a main guiding
    principle that changed how we wrote tests going forward. That guiding principle
    is, “*The more your tests resemble the way your software is used, the more confidence
    they can give* *you*” ([https://testing-library.com/docs/guiding-principles/](https://testing-library.com/docs/guiding-principles/)).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当 React Testing Library 首次推出时，它遵循一个主要指导原则，这个原则改变了我们编写测试的方式。这个指导原则是，“*你的测试越接近你的软件的使用方式，它们就能给你带来越多的信心*”
    ([https://testing-library.com/docs/guiding-principles/](https://testing-library.com/docs/guiding-principles/))。
- en: From that point on, many things changed in our tests. Focusing on a user-centric
    approach meant avoiding implementation details in our tests at all costs. This
    meant no more shallow rendering, no more state and prop references, and a more
    user-centric way of querying the DOM.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从那个点开始，我们的测试中发生了许多变化。专注于以用户为中心的方法意味着不惜一切代价避免在我们的测试中包含实现细节。这意味着不再有浅渲染，不再有状态和属性引用，以及更以用户为中心的查询
    DOM 的方式。
- en: Reading the last paragraph, you might be wondering how to test your components
    following a user-centric approach. Well, the answer is straightforward – a user
    doesn’t have to know the page they are using leverages React Query. If you write
    your tests like you are just using the page, this means that you will find issues
    that your user might find as well accidentally, and if for some reason you change
    your implementation, your tests won’t break.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读最后一部分，你可能想知道如何采用以用户为中心的方法来测试你的组件。嗯，答案很简单——用户不需要知道他们正在使用的页面是否使用了 React Query。如果你像使用页面一样编写测试，这意味着你可能会意外地发现用户可能会遇到的问题，并且如果由于某种原因你更改了实现，你的测试不会中断。
- en: There will be some scenarios where you might have to tie your tests to some
    implementation details to help you do some assertions, but we will try to avoid
    them at all costs in this section.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些场景中，你可能需要将你的测试与某些实现细节绑定，以帮助你进行断言，但我们将不惜一切代价避免在本节中这样做。
- en: Before we start writing our tests, we need to do some setting up.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写测试之前，我们需要做一些设置。
- en: Setting up testing utils
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置测试工具
- en: When testing components that leverage React Query, we must ensure we wrap up
    those components with our `QueryClientProvider`. Now, we could create a custom
    wrapper for each test and wrap our component with it when rendering, but remember
    that you will most likely end up with many components that will use React Query
    in some way.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试利用 React Query 的组件时，我们必须确保我们用 `QueryClientProvider` 包裹这些组件。现在，我们可以在每个测试中创建一个自定义包装器，并在渲染时用它来包裹我们的组件，但请记住，你很可能会得到许多以某种方式使用
    React Query 的组件。
- en: This is where setting up some testing utils will help you. A pattern that I
    really like to follow is overwriting the `render` function from the testing library
    and wrapping every component that is rendered, using this function automatically
    with our React Query `QueryClientProvider`. To do that, I create a `test-utils.js`
    file inside a `utils` folder.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是设置一些测试工具可以帮助你的地方。我非常喜欢遵循的一个模式是覆盖测试库中的 `render` 函数，并使用这个函数自动包裹渲染的每个组件，使用我们的
    React Query `QueryClientProvider`。为此，我在 `utils` 文件夹中创建了一个 `test-utils.js` 文件。
- en: 'This is what we can add to our `test-utils.js` file:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们可以在 `test-utils.js` 文件中添加的内容：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is what we do in the preceding snippet:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们前面片段中做的事情：
- en: We import the `render` function from the React Testing Library.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从 React Testing Library 导入 `render` 函数。
- en: We import our `QueryClient` and our `QueryClientProvider` from React Query.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从 React Query 导入我们的 `QueryClient` 和 `QueryClientProvider`。
- en: 'We create a custom `render` function (`customRender`):'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个自定义的 `render` 函数 (`customRender`)：
- en: This function will receive a `ui` parameter, which will be the component we
    want to render. It will also receive an `options` object, which we can forward
    to the `render` function.
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数将接收一个 `ui` 参数，它将是我们要渲染的组件。它还将接收一个 `options` 对象，我们可以将其转发给 `render` 函数。
- en: We create our `queryClient` instance. Here, we override our `logger` `error`
    property to avoid showing up errors from React Query. This is because we might
    want to test error scenarios, and we don’t want React Query to pollute our `console`
    with the errors we expect. We also define our queries to never attempt to retry
    a query after it fails, and we set our `cacheTime` to `Infinity` to avoid `Jest`
    error messages in scenarios where we manually set a `cacheTime` value.
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建我们的 `queryClient` 实例。在这里，我们覆盖了我们的 `logger` 的 `error` 属性，以避免显示来自 React Query
    的错误。这是因为我们可能想要测试错误场景，并且我们不希望 React Query 用我们预期的错误污染我们的 `console`。我们还定义我们的查询，在查询失败后永远不尝试重试查询，并将我们的
    `cacheTime` 设置为 `Infinity` 以避免在手动设置 `cacheTime` 值的场景中产生 `Jest` 错误信息。
- en: We create a `CombinedProviders` wrapper that will be responsible for wrapping
    our components with our `QueryClientProvider`.
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个 `CombinedProviders` 包装器，它将负责用 `QueryClientProvider` 包裹我们的组件。
- en: We call the React Testing Library `render` function, pass it the `ui` parameter,
    wrap it with our `CombinedProviders`, and send it the `options` we received.
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们调用 React Testing Library 的 `render` 函数，传递给它 `ui` 参数，并用我们的 `CombinedProviders`
    包裹它，然后发送我们接收到的 `options`。
- en: We export all of the React Testing Library and our `customRender` function,
    which will now be the main `render` function. This means we now import this file
    instead of the React Testing Library in our tests.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们导出所有的 React Testing Library 和我们的 `customRender` 函数，这将是现在的主 `render` 函数。这意味着我们现在在测试中导入这个文件而不是
    React Testing Library。
- en: Note in the snippet that we create our `queryClient` inside the `customRender`
    function instead of outside it. You can follow this approach if you want to avoid
    having to clean up the query cache between tests. If you want to have the same
    `QueryClient` between tests, you can create the `queryClient` instance outside
    the function.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在代码片段中，我们是在 `customRender` 函数内部创建我们的 `queryClient` 而不是外部。如果您想避免在测试之间清理查询缓存，可以采用这种方法。如果您想在测试之间使用相同的
    `QueryClient`，可以在函数外部创建 `queryClient` 实例。
- en: Now that our `render` function is ready to render React Query using components,
    we can start writing tests.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在既然我们的 `render` 函数已经准备好使用组件渲染 React Query，我们可以开始编写测试了。
- en: Testing queries
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试查询
- en: In the following subsections, we will see some common testing scenarios you
    might find in your day-to-day activities when using React Query.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下小节中，我们将看到一些在您日常使用 React Query 时可能会遇到的一些常见测试场景。
- en: Checking whether data is fetched
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查数据是否已获取
- en: 'One of the most common tests we have to write is ensuring that our data was
    fetched properly. Let us start with this scenario and revisit our parallel queries
    example from [*Chapter 5*](B18501_05.xhtml#_idTextAnchor140). We will also rewrite
    the code to adjust to some of the practices mentioned in this chapter. Let’s start
    by looking at our `ParallelQueries` component:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须编写的最常见的测试之一是确保我们的数据已被正确获取。让我们从这个场景开始，并重新审视我们来自 [*第5章*](B18501_05.xhtml#_idTextAnchor140)
    的并行查询示例。我们还将重写代码以适应本章中提到的一些实践。让我们先看看我们的 `ParallelQueries` 组件：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see from the preceding snippet, the code is pretty much the same
    as the one presented in [*Chapter 5*](B18501_05.xhtml#_idTextAnchor140)*,* with
    the exception of the part where we fetch our data. Here, we applied one of the
    patterns mentioned in this chapter and moved this logic to a custom hook inside
    our custom hooks folder.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的代码片段中看到的，代码基本上与第 [*5章*](B18501_05.xhtml#_idTextAnchor140) 中展示的相同，除了我们获取数据的那部分。在这里，我们应用了本章中提到的模式之一，并将这个逻辑移动到自定义钩子文件夹内的自定义钩子中。
- en: 'Let us now look at what sits inside our `useMultipleQueriesV2` hook file:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看 `useMultipleQueriesV2` 钩子文件内部的内容：
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As you can see from the preceding snippet, we basically just move what we had
    in our component to our `useMultipleQueriesV2` hook. Note also that we leverage
    the other two patterns we mentioned in this chapter:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的代码片段中看到的，我们基本上只是将组件中的内容移动到我们的 `useMultipleQueriesV2` 钩子中。注意，我们还利用了本章中提到的其他两个模式：
- en: We create an entry inside the `userKeys` factory and leverage it to set our
    `useQueries` hook, `queryKey`
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在 `userKeys` 工厂中创建一个条目，并利用它来设置我们的 `useQueries` 钩子，`queryKey`
- en: We create an API file to gather our user API functions and add our `getUser`
    function
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建一个 API 文件来收集我们的用户 API 函数，并添加我们的 `getUser` 函数
- en: 'This is what our `getUser` function looks like:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的 `getUser` 函数的样子：
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `getUser` function shown in this snippet is responsible for making a `GET`
    request for our given endpoint and aborting that request if our `signal` tells
    `axios` to do so.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中显示的`getUser`函数负责对我们的给定端点发起`GET`请求，并在我们的`signal`告诉`axios`这样做时取消该请求。
- en: Now that you are reacquainted with this component and how it works, let's start
    to test it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经重新熟悉了这个组件及其工作方式，让我们开始测试它。
- en: 'The first thing we need to do before we write our test is to make sure we have
    MSW intercepting the `GET` request and returning the data we want:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写测试之前，首先需要确保MSW正在拦截`GET`请求并返回我们想要的数据：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding snippet, we create a request handler to add to our `handlers`
    array, which does the following.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们创建了一个请求处理器并将其添加到我们的`handlers`数组中，该处理器执行以下操作。
- en: Whenever we intercept a `GET` request to an endpoint that includes the `/react-query-api/`
    path, we return a `200 OK` response that will be delayed by 500 milliseconds,
    and it will have in its body an object with a `hello` property that will contain
    the parameter in the second position of the request parameters.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们拦截到包含`/react-query-api/`路径的端点的`GET`请求时，我们返回一个将被延迟500毫秒的`200 OK`响应，其体中将包含一个具有`hello`属性的对象，该属性将包含请求参数的第二位参数。
- en: 'This means that a `GET` request for the [https://danieljcafonso.builtwithdark.com/react-query-api/userOne](https://danieljcafonso.builtwithdark.com/react-query-api/userOne)
    endpoint will return a `200 OK` response with the following object:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着对[https://danieljcafonso.builtwithdark.com/react-query-api/userOne](https://danieljcafonso.builtwithdark.com/react-query-api/userOne)端点的`GET`请求将返回一个包含以下对象的`200
    OK`响应：
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now that we are sure that our components will always receive the same data after
    a request, we can write our tests.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们确信我们的组件在请求后总是会接收到相同的数据，我们可以编写我们的测试。
- en: Now, I suggest you look at the `ParallelQueries` component from a user-centric
    perspective and consider the scenarios you might want to test. The rule of thumb
    here is to think, “*If I was a user interacting with this code, what would I interact
    with or expect* *to happen?*”
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我建议你从一个用户的角度来看`ParallelQueries`组件，并考虑你可能想要测试的场景。这里的经验法则是思考，“*如果我是与这段代码交互的用户，我会与什么交互或期望发生什么*？”
- en: 'Following the preceding analysis, I came up with two test scenarios:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的分析，我想出了两个测试场景：
- en: '`userOne`, `userTwo`, and `userThree`.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`userOne`、`userTwo`和`userThree`。'
- en: '`"Fetching data…"` message for each of our requests.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们每个请求显示`"Fetching data…"`消息。
- en: 'With those scenarios in mind, we can write our tests. Let us see what our test
    file would look like:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些场景，我们可以编写我们的测试。让我们看看我们的测试文件会是什么样子：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let us now review what we do in the preceding snippet:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在回顾一下前面代码片段中我们做了什么：
- en: We import our `ParallelQueries` component and, from our `test-utils`, our custom
    `render` function and the `screen` object.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们导入我们的`ParallelQueries`组件，以及从我们的`test-utils`中的自定义`render`函数和`screen`对象。
- en: 'We create our test suite and, inside it, our tests:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建我们的测试套件，并在其中创建我们的测试：
- en: 'For the `"component should fetch and render multiple data"` test, we do the
    following:'
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`"component should fetch and render multiple data"`测试，我们执行以下操作：
- en: Render our `ParallelQueries` component.
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染我们的`ParallelQueries`组件。
- en: Since we need to wait for the data to be fetched, we leverage an `async` query
    variant (`findBy`) from the React Testing Library and `await` until the `userOne`
    text shows up on the DOM.
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们需要等待数据被获取，我们利用React Testing Library中的`async`查询变体（`findBy`）和`await`，直到`userOne`文本出现在DOM上。
- en: Once our query finds the `userOne` text, we assert that it is in the DOM and
    repeat the same assertion for `userTwo` and `userThree`. In these last two examples
    (`userTwo` and `userThree`), we won’t need to leverage the `findBy` variant because
    the data will already be on the DOM, so we use the `getBy` variant instead.
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们的查询找到`userOne`文本，我们断言它在DOM中，并对`userTwo`和`userThree`重复相同的断言。在这些最后两个例子（`userTwo`和`userThree`）中，我们不需要利用`findBy`变体，因为数据已经存在于DOM上，所以我们使用`getBy`变体。
- en: 'For the `"component should show loading indicator for each query"` test, we
    do the following:'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`"component should show loading indicator for each query"`测试，我们执行以下操作：
- en: Render our `ParallelQueries` component.
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染我们的`ParallelQueries`组件。
- en: Due to the 500 millisecond delay we added to our mocked response, we won’t have
    our data immediately available to be rendered, so we should have our loading indicators
    showing up instead. Since we will have multiple indicators, we leverage the `getAllBy`
    variant to get an array of elements that match our query.
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们在模拟响应中添加了500毫秒的延迟，我们的数据不会立即可用以进行渲染，因此我们应该显示加载指示器。由于我们将有多个指示器，我们利用`getAllBy`变体来获取与我们的查询匹配的元素数组。
- en: We then assert that our array of elements has a length of `3` to ensure that
    we have a `"Fetching data…"` message for each query.
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们随后断言我们的元素数组长度为`3`，以确保每个查询都有一个`"Fetching data…"`消息。
- en: With these tests, we have followed an approach that reflects our user behavior
    when interacting with our component and, at the same time, got 100% coverage on
    our `ParallelQueries` component and our `useMultipleQueriesV2` custom hook.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些测试，我们遵循了一种反映我们与组件交互时用户行为的方法，同时也在我们的`ParallelQueries`组件和`useMultipleQueriesV2`自定义钩子上实现了100%的覆盖率。
- en: In most scenarios, to deal with data-fetching scenarios, you only need to wait
    for the data you fetch to be rendered on the DOM. Got a single query? Wait for
    the data to be displayed on the DOM. Got some parallel queries? Wait for the data
    to be displayed on the DOM. Got some dependent queries? Wait for the first query
    data to be displayed on the DOM. Then, repeat this step for the following queries.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，为了处理数据获取场景，你只需要等待你获取的数据在DOM上被渲染。只有一个查询？等待数据在DOM上显示。有多个并行查询？等待数据在DOM上显示。有依赖查询？等待第一个查询的数据在DOM上显示。然后，为后续查询重复此步骤。
- en: Now, in some scenarios, you will have to fire some actions to get to your test
    assertion. Some of those scenarios might even involve query invalidation or query
    cancelation. Due to the similarity of these scenarios, let us now see what we
    can test with query invalidation.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在某些场景中，您将不得不执行一些操作以到达您的测试断言。其中一些场景甚至可能涉及查询无效化或查询取消。由于这些场景的相似性，让我们现在看看我们可以使用查询无效化进行哪些测试。
- en: Checking whether a query was invalidated
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查查询是否被无效化
- en: As you should remember from [*Chapter 5*](B18501_05.xhtml#_idTextAnchor140),
    query invalidation is when you manually mark your query as stale so that React
    Query can refetch it if it is being rendered.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您应该从[*第五章*](B18501_05.xhtml#_idTextAnchor140)中记住的，查询无效化是指您手动标记您的查询为过时，以便React
    Query可以在渲染时重新获取它。
- en: 'Let us review the `QueryInvalidation` component we saw in [*Chapter 5*](B18501_05.xhtml#_idTextAnchor140):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下在[*第五章*](B18501_05.xhtml#_idTextAnchor140)中看到的`QueryInvalidation`组件：
- en: '[PRE17]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see from the preceding snippet, the code is still very similar to
    the one from [*Chapter 5*](B18501_05.xhtml#_idTextAnchor140). The only changes
    we made here were to apply the API file pattern and leverage the `getUser` function
    we saw previously in this chapter and change our query key to leverage the query
    key factory pattern.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的代码片段中看到的，代码仍然非常类似于[*第五章*](B18501_05.xhtml#_idTextAnchor140)中的代码。我们在这里所做的唯一改变是应用API文件模式，并利用本章之前看到的`getUser`函数，以及将我们的查询键更改为利用查询键工厂模式。
- en: Now that you are reacquainted with this component and how it works, let us start
    to test it.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经重新熟悉了这个组件及其工作方式，让我们开始对其进行测试。
- en: As we are leveraging our `getUser` function, we don’t need to create a new request
    handler in MSW due to the fact we are using the same endpoint.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在利用`getUser`函数，我们不需要在MSW中创建一个新的请求处理器，因为我们正在使用相同的端点。
- en: 'Now, looking at the `QueryInvalidation` component from a user-centric perspective,
    here are the three test scenarios that you might identify:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从以用户为中心的角度来看`QueryInvalidation`组件，以下是您可能识别出的三个测试场景：
- en: '`userOne`.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`userOne`。'
- en: '`"``Loading…"` message.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"``Loading…"`消息。'
- en: '**As a user, I want my query to be refetched when I click the Invalidate Query
    button**: In this scenario, we want our component to be rendered, and we wait
    for it to render a hello message, click the **Invalidate Query** button, wait
    for the hello message to disappear, wait for the loading indicator to disappear,
    and wait for the hello message to reappear. This way, we are sure our query was
    invalidated.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作为用户，我希望点击无效查询按钮时重新获取我的查询**：在这种情况下，我们希望我们的组件被渲染，并等待它渲染一个问候消息，点击**无效查询**按钮，等待问候消息消失，等待加载指示器消失，并等待问候消息再次出现。这样，我们就能确保我们的查询已被无效化。'
- en: 'With those scenarios in mind, we can write our tests for our `QueryInvalidation`
    component. Let us see what our test file would look like:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些场景，我们可以为我们的`QueryInvalidation`组件编写测试。让我们看看我们的测试文件会是什么样子：
- en: '[PRE18]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let us now review what we are doing in the preceding snippet:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾一下前面代码片段中我们在做什么：
- en: We import our `QueryInvalidation` component, and from our `test-utils`, we import
    our custom `render` function, the `screen` object, the `fireEvent` util, and the
    `waitFor` function.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们导入我们的`QueryInvalidation`组件，并从我们的`test-utils`中导入我们的自定义`render`函数、`screen`对象、`fireEvent`实用工具和`waitFor`函数。
- en: 'We create our test suite, and inside it, our tests:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建我们的测试套件，并在其中编写我们的测试：
- en: 'For the `"component should display fetched data"` test, we do the following:'
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`"component should display fetched data"`测试，我们做以下操作：
- en: Render our `QueryInvalidation` component.
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染我们的`QueryInvalidation`组件。
- en: Since we need to wait for the data to be fetched, we leverage an `async` query
    variant (`findBy`) from the React Testing Library and `await` until the `userOne`
    text shows up on the DOM.
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们需要等待数据被获取，我们利用React Testing Library中的`async`查询变体（`findBy`）和`await`，直到`userOne`文本出现在DOM上。
- en: Once our query finds the `userOne` text, we assert it is in the DOM.
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们的查询找到`userOne`文本，我们断言它出现在DOM中。
- en: 'For the `"component should show a loading indicator"` test, we do the following:'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`"component should show a loading indicator"`测试，我们做以下操作：
- en: Render our `QueryInvalidation` component.
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染我们的`QueryInvalidation`组件。
- en: Due to the 500 millisecond delay we added to our mocked response, we won’t have
    our data immediately available to be rendered, so we should have our loading indicators
    showing up instead. We then leverage a `getBy` query variant to help assert that
    the `"Loading…"` text is in the DOM.
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们添加了500毫秒的延迟到模拟响应中，我们的数据不会立即可用以进行渲染，因此我们应该看到加载指示器出现。然后我们利用`getBy`查询变体来帮助断言`"Loading…"`文本出现在DOM中。
- en: 'For the `"component should invalidate query"` test, we do the following:'
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`"component should invalidate query"`测试，我们做以下操作：
- en: Render our `QueryInvalidation` component.
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染我们的`QueryInvalidation`组件。
- en: We wait for our data to be fetched and consequently assert it is on the DOM.
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们等待数据被获取，并相应地断言它出现在DOM上。
- en: We find our `getByRole` query that will help us find the button with the `Invalidate`
    `Query` text.
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们找到了我们的`getByRole`查询，这将帮助我们找到带有`Invalidate` `Query`文本的按钮。
- en: We then leverage the `fireEvent` util to fire a `click` event on our button.
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们利用`fireEvent`实用工具在按钮上触发一个`click`事件。
- en: We then leverage the `waitFor` function to wait until an assertion evaluates
    to `true`. In this scenario, we wait for our query data to disappear from the
    DOM.
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们利用`waitFor`函数等待断言评估为`true`。在这种情况下，我们等待我们的查询数据从DOM中消失。
- en: We then leverage the `waitFor` function once again, this time to wait for the
    loading indicator to disappear from the DOM.
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们再次利用`waitFor`函数，这次是为了等待加载指示器从DOM中消失。
- en: Finally, we assert that our query has finished refetching by checking whether
    our data is back on the DOM again.
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们通过检查数据是否再次出现在DOM上来断言我们的查询已完成重新获取。
- en: 'Now, we have checked how we can test query invalidation. You might be wondering
    how query cancelation differs from query invalidation. At the end of the day,
    testing query cancelation would differ on the following things:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经检查了如何测试查询无效化。你可能想知道查询取消与查询无效化有何不同。最终，测试查询取消会在以下方面有所不同：
- en: Our query function would need to receive the `AbortController` signal and forward
    it to our `getUser` function.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的查询函数需要接收`AbortController`信号并将其转发到我们的`getUser`函数。
- en: Instead of calling the `invalidateQuery` function from `queryClient`, we call
    `cancelQueries`.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与从`queryClient`调用`invalidateQuery`函数不同，我们调用`cancelQueries`。
- en: In our tests, the first two scenarios are exactly the same. In the third scenario,
    we immediately click the **cancel** button after rendering the component. After
    doing this, the DOM should not show either the data or the loading indicator.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的测试中，前两个场景完全相同。在第三个场景中，我们在渲染组件后立即点击**取消**按钮。完成此操作后，DOM不应显示数据或加载指示器。
- en: Now that you know how to test most scenarios in a user-centric approach, let's
    put this knowledge to the test and see how we would test a paginated scenario.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何以用户为中心的方法测试大多数场景，让我们将这个知识付诸实践，看看我们如何测试一个分页场景。
- en: Testing paginated queries
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试分页查询
- en: In [*Chapter 5*](B18501_05.xhtml#_idTextAnchor140), we learned how `useQuery`
    allowed us to create paginated queries and consequently used it to build a paginated
    UI component.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第5章*](B18501_05.xhtml#_idTextAnchor140) 中，我们学习了 `useQuery` 如何允许我们创建分页查询，并随后用它来构建分页
    UI 组件。
- en: 'Let us review the `PaginatedQuery` component we saw in [*Chapter 5*](B18501_05.xhtml#_idTextAnchor140):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下在 [*第5章*](B18501_05.xhtml#_idTextAnchor140) 中看到的 `PaginatedQuery` 组件：
- en: '[PRE19]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you can see from the preceding snippet, it is pretty much the same as what
    we saw in [*Chapter 5*](B18501_05.xhtml#_idTextAnchor140). Note also that we leveraged
    two patterns we mentioned in this chapter:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如前文片段所示，它与我们在 [*第5章*](B18501_05.xhtml#_idTextAnchor140) 中看到的内容几乎相同。注意，我们还利用了本章中提到的两种模式：
- en: We created an entry into our `userKeys` factory and leveraged it to set our
    `useQuery` hook, `queryKey`
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在 `userKeys` 工厂中创建了一个条目，并利用它来设置我们的 `useQuery` 钩子，`queryKey`
- en: We created an API file to gather our user API functions and added our `getPaginatedData`
    function
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个 API 文件来收集我们的用户 API 函数，并添加了我们的 `getPaginatedData` 函数
- en: 'This is what our `getPaginatedData` function looks like:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的 `getPaginatedData` 函数的样子：
- en: '[PRE20]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `getPaginatedData` function shown in the preceding snippet is responsible
    for making a `GET` request for our given endpoint for a given page.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 前文片段中显示的 `getPaginatedData` 函数负责为给定页面向我们的指定端点发起 `GET` 请求。
- en: Now that you are reacquainted with this component and how it works, let's test
    it.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经重新熟悉了这个组件及其工作原理，让我们来测试它。
- en: 'We will start by creating our MSW request handler:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建我们的 MSW 请求处理器：
- en: '[PRE21]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding snippet, we create a request handler to add to our `handlers`
    array, which does the following.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在前文片段中，我们创建了一个请求处理器并将其添加到我们的 `handlers` 数组中，它执行以下操作。
- en: Whenever we intercept a `GET` request to an endpoint that includes the `/react-query-paginated`
    path, we get the `page` query parameter to help us define what data we will return.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们拦截到包含 `/react-query-paginated` 路径的端点的 `GET` 请求时，我们得到 `page` 查询参数以帮助我们定义我们将返回哪些数据。
- en: We return a `200 OK` response that will have in its body an object with the
    data for page one or page two, depending on the received page query parameter.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们返回一个包含第一页或第二页数据的 `200 OK` 响应，具体取决于接收到的页面查询参数。
- en: This means that a `GET` request for the [https://danieljcafonso.builtwithdark.com/react-query-paginated?page=0&results=10](https://danieljcafonso.builtwithdark.com/react-query-paginated?page=0&results=10)
    endpoint will return a `200 OK` response with the `pageOneData` object, while
    a `GET` request for the [https://danieljcafonso.builtwithdark.com/react-query-paginated?page=1&results=10](https://danieljcafonso.builtwithdark.com/react-query-paginated?page=1&results=10)
    endpoint will return a `200 OK` response with the `pageTwoData` object.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着对 [https://danieljcafonso.builtwithdark.com/react-query-paginated?page=0&results=10](https://danieljcafonso.builtwithdark.com/react-query-paginated?page=0&results=10)
    端点的 `GET` 请求将返回一个包含 `pageOneData` 对象的 `200 OK` 响应，而对 [https://danieljcafonso.builtwithdark.com/react-query-paginated?page=1&results=10](https://danieljcafonso.builtwithdark.com/react-query-paginated?page=1&results=10)
    端点的 `GET` 请求将返回一个包含 `pageTwoData` 对象的 `200 OK` 响应。
- en: 'Now that we are sure that our components will always receive the same data
    after a request, we can write our tests and look at the `PaginatedQuery` component
    from a user-centric perspective; here are the test scenarios that you might identify:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们确信我们的组件在请求后总是会接收到相同的数据，我们可以编写我们的测试，并从以用户为中心的角度查看 `PaginatedQuery` 组件；以下是你可能识别出的测试场景：
- en: '**As a user, I want to see that my data has loaded after opening the page**:
    In this scenario, we want our component to be rendered and check whether the initial
    loading data message shows up.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作为用户，我希望在打开页面后看到我的数据已加载**：在这种情况下，我们希望我们的组件被渲染并检查是否显示了初始加载数据消息。'
- en: '**As a user, I want to see an error message if my data fails to load**: In
    this scenario, we want our component to render and see whether it shows the error
    message when the request fails.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作为用户，我希望在数据加载失败时看到错误消息**：在这种情况下，我们希望我们的组件渲染并查看请求失败时是否显示了错误消息。'
- en: '**As a user, I want to see the initially fetched data**: In this scenario,
    we want our component to render and wait until the data of the first page is fetched.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作为用户，我希望看到最初获取的数据**：在这种情况下，我们希望我们的组件渲染并等待第一页的数据被获取。'
- en: '**As a user, I want to click on the** **Next Page** **button and see the data
    from the next page**: In this scenario, we want our component to be rendered,
    ensure we have the initial data, and after clicking on the **Next Page** button,
    wait until the data of the second page is fetched.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作为用户，我希望点击** **下一页** **按钮并看到下一页的数据**：在这种情况下，我们希望组件被渲染，确保我们有初始数据，并在点击 **下一页**
    按钮后，等待直到获取第二页的数据。'
- en: '**As a user, I want to see a fetching indicator while fetching new data**:
    In this scenario, we want our component to be rendered, ensure we have the initial
    data, and after clicking on the **Next Page** button, ensure that the fetching
    indicator is rendered.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作为用户，我希望在获取新数据时看到获取指示器**：在这种情况下，我们希望组件被渲染，确保我们有初始数据，并在点击 **下一页** 按钮后，确保获取指示器被渲染。'
- en: '**As a user, I want my data to show up while clicking on** **Next Page** **and**
    **Previous Page**: In this scenario, we want our component to be rendered, ensure
    we have the initial data, and after clicking on the **Next Page** button, ensure
    the second page shows up. We then click on the **Previous Page** button and ensure
    that the data of the first page is rendered again.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作为用户，我希望在点击** **下一页** **和** **上一页** **时看到数据**：在这种情况下，我们希望组件被渲染，确保我们有初始数据，并在点击
    **下一页** 按钮后，确保第二页显示出来。然后我们点击 **上一页** 按钮并确保第一页的数据再次被渲染。'
- en: '**As a user, I want my** **Previous Page** **button to be disabled when I’m
    on the first page**: In this scenario, we want our component to be rendered and
    ensure we have the initial data. Since we are on the first page, we want our **Previous
    Page** button to be disabled.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作为用户，我希望在第一页时我的** **上一页** **按钮被禁用**：在这种情况下，我们希望组件被渲染并确保我们有初始数据。由于我们处于第一页，我们希望
    **上一页** 按钮被禁用。'
- en: '**As a user, I want my** **Next Page** **button to be disabled while waiting
    for new data to show up**: In this scenario, we want our component to render and
    ensure we have the initial data. After clicking the **Next Page** button, we need
    to ensure that this button is disabled.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作为用户，我希望我的** **下一页** **按钮在等待新数据出现时被禁用**：在这种情况下，我们希望组件渲染并确保我们有初始数据。在点击 **下一页**
    按钮后，我们需要确保此按钮被禁用。'
- en: 'With these scenarios in mind, this is the code we would write to test the `PaginatedQuery`
    component:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些场景，这是我们将编写的测试 `PaginatedQuery` 组件的代码：
- en: '[PRE22]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We start by doing the necessary imports:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先进行必要的导入：
- en: Our `PaginatedQuery` component.
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的 `PaginatedQuery` 组件。
- en: Our `render` and `screen` utils from `test-utils`.
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的 `render` 和 `screen` 工具来自 `test-utils`。
- en: The `userEvent` util from the `user-event` companion from the testing library.
    One thing to be aware of here is that we are using a user-event version before
    v14.
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 来自测试库的 `user-event` 伴侣的 `userEvent` 工具。在这里需要注意的一点是我们使用的是 v14 之前的用户事件版本。
- en: Our MSW `server` so that we can create a custom response mock for one of our
    test scenarios.
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的 MSW `server`，以便我们可以为我们的测试场景之一创建自定义响应模拟。
- en: The MSW `rest` namespace to create relevant request handlers for one of our
    test scenarios.
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: MSW `rest` 命名空间，为我们的测试场景之一创建相关的请求处理器。
- en: 'We create our test suite and, inside it, our tests:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建我们的测试套件，并在其中创建我们的测试：
- en: 'For the `"should render loading indicator on start"` test, we do the following:'
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 `"should render loading indicator on start"` 测试，我们执行以下操作：
- en: Render our `PaginatedQuery` component.
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染我们的 `PaginatedQuery` 组件。
- en: Leverage the `getByText` query to assert that the `"Loading initial data…"`
    message is on the DOM.
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 利用 `getByText` 查询断言 `"Loading initial data…"` 消息在 DOM 上。
- en: 'For the `"should render error on failed fetching"` test, we do the following:'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 `"should render error on failed fetching"` 测试，我们执行以下操作：
- en: Leverage our `server` `use` function to add a request handler to our current
    server instance. In this scenario, we add a handler that will catch every `GET`
    request (`"*"` indicates that this handler will match every route) and return
    `403 Forbidden` so that our request fails. Don’t worry about this leaking into
    other tests because we made sure to call the `resetHandlers` function in our `setupTests`
    file. This will ensure that this custom request handler will only be used on this
    test.
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 利用我们的 `server` `use` 函数向当前的服务器实例添加一个请求处理器。在这种情况下，我们添加一个处理器来捕获每个 `GET` 请求（`"*"`
    表示此处理器将匹配每个路由）并返回 `403 Forbidden`，以便我们的请求失败。不用担心这会影响到其他测试，因为我们确保在 `setupTests`
    文件中调用了 `resetHandlers` 函数。这将确保此自定义请求处理器只会用于此测试。
- en: Render our `PaginatedQuery` component.
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染我们的 `PaginatedQuery` 组件。
- en: Leverage the `findByText` query to `await` until the error message shows up
    on the DOM.
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 利用`findByText`查询`await`直到错误消息出现在DOM上。
- en: 'For the `"should render first page data"` test, we do the following:'
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于“应渲染第一页数据”测试，我们执行以下操作：
- en: Render our `PaginatedQuery` component.
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染我们的`PaginatedQuery`组件。
- en: Wait until the data from the first name property from the first page shows up
    on the DOM.
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待直到第一页的姓名属性数据出现在DOM上。
- en: Assert that the last name property also shows up on the DOM.
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 断言姓氏属性也出现在DOM上。
- en: 'For the `"should render second page data"` test, we do the following:'
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于“应渲染第二页数据”测试，我们执行以下操作：
- en: Render our `PaginatedQuery` component.
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染我们的`PaginatedQuery`组件。
- en: Wait until the data from the first page shows up on the DOM.
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待直到第一页的数据出现在DOM上。
- en: 'Leverage the `getByRole` query to get a button with the text `"should show
    fetching indicator while fetching data"` test, we do the following:'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 利用`getByRole`查询获取带有文本“应在加载数据时显示获取指示器”测试，我们执行以下操作：
- en: Render our `PaginatedQuery` component.
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染我们的`PaginatedQuery`组件。
- en: Wait until the data from the first page shows up on the DOM.
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待直到第一页的数据出现在DOM上。
- en: Leverage the `getByRole` query to get a button with the text `getByText` query
    to check whether the `"Loading…"` indicator shows up on the DOM.
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 利用`getByRole`查询获取带有文本`getByText`的按钮，使用`getByText`查询来检查“加载中…”指示器是否出现在DOM上。
- en: 'For the `"should change pages back and forth and render expected data"` test,
    we do the following:'
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于“应来回切换页面并渲染预期数据”测试，我们执行以下操作：
- en: Render our `PaginatedQuery` component.
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染我们的`PaginatedQuery`组件。
- en: Wait until the data from the first page shows up on the DOM and assert that
    it is there.
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待直到第一页的数据出现在DOM上，并断言它在那里。
- en: 'Leverage the `getByRole` query to get a button with the text `getByRole` query
    to get a button with the text `"should have previous page button disabled on first
    page"` test, we do the following:'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 利用`getByRole`查询获取带有文本`getByRole`的按钮，用于获取带有文本“在第一页应禁用上一页按钮”测试，我们执行以下操作：
- en: Render our `PaginatedQuery` component.
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染我们的`PaginatedQuery`组件。
- en: 'Leverage the `findByRole` query to wait until the `"should have next page button
    disabled while changing pages"` test, we do the following:'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 利用`findByRole`查询等待直到“在切换页面时应禁用下一页按钮”测试，我们执行以下操作：
- en: Render our `PaginatedQuery` component.
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染我们的`PaginatedQuery`组件。
- en: Leverage the `findByRole` query to wait until the **Next Page** button shows
    up on the DOM and click on it.
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 利用`findByRole`查询等待直到“下一页”按钮出现在DOM上，并点击它。
- en: Assert that the **Next Page** button is now disabled.
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 断言“下一页”按钮现在是禁用的。
- en: As you can see, we can test our queries in a fully user-centric approach and
    forget the implementation details. Now, let’s move into the mutation section and
    see how it gets a bit harder to follow a user-centric approach.
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，我们可以以完全以用户为中心的方法测试我们的查询，并忘记实现细节。现在，让我们进入突变部分，看看它如何变得稍微难以采用以用户为中心的方法。
- en: Testing mutations
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试突变
- en: 'You can definitely follow a user-centric approach with mutations, although,
    in some scenarios, this might be harder. Let us review a component we wrote in
    [*Chapter 6*](B18501_06.xhtml#_idTextAnchor159) and see how it might be harder
    for us to test it following a user-centric approach:'
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你当然可以采用以用户为中心的方法进行突变，尽管在某些场景中这可能更困难。让我们回顾一下我们在[*第6章*](B18501_06.xhtml#_idTextAnchor159)中编写的组件，看看它可能为什么以用户为中心的方法测试更困难：
- en: '[PRE23]'
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the preceding snippet, we can see our `SimpleMutation` component. Now, let
    us try to do our user-centric approach exercise and understand which test scenarios
    we could write:'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们可以看到我们的`SimpleMutation`组件。现在，让我们尝试进行以用户为中心的方法练习，并了解我们可以编写哪些测试场景：
- en: '**As a user, I want to see a paused indicator when my mutation enters the paused
    state**: In this scenario, we want to render our component and, when we attempt
    to perform our mutation, the paused indicator message to appear.'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作为用户，我想在突变进入暂停状态时看到暂停指示器**：在这个场景中，我们想要渲染我们的组件，当我们尝试执行我们的突变时，暂停指示器消息应该出现。'
- en: '**As a user, I want to create data on the server**: In this scenario, we want
    to render our component, fill out the form, and then perform our mutation. But
    wait – how does our user assert this?'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作为用户，我想在服务器上创建数据**：在这个场景中，我们想要渲染我们的组件，填写表单，然后执行我们的突变。但是等等——我们的用户如何断言这一点？'
- en: As you can see, the last scenario had an issue – a lack of information from
    the UI that our mutation was performed successfully.
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，最后一个场景有一个问题——UI中缺乏我们的突变已成功执行的信息。
- en: 'Usually, an issue of this sort would be fixed by adding a notification for
    a user, informing them that the mutation was performed successfully. Letting the
    user know the mutation succeeded is always a good practice. Following this approach,
    our test would resemble something like this:'
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通常，这类问题可以通过添加一个通知来解决，通知用户突变已成功执行。让用户知道突变成功始终是一个好的做法。按照这种方法，我们的测试将类似于以下内容：
- en: '**As a user, I want to create data on the server successfully**: In this scenario,
    we want to render our component, fill out the form, press the **Add** button,
    and wait for a success message to appear'
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作为用户，我想在服务器上成功创建数据**：在这个场景中，我们想要渲染我们的组件，填写表单，按下 **添加** 按钮，并等待成功消息出现'
- en: 'As you can see, now we have a user-centric way to test our mutation. However,
    for some reason, let us assume that we cannot perform changes to our `SimpleMutation`
    component. How would we ensure that our mutation was performed? We would have
    to resort to implementation details. Our test scenario would resemble something
    like this:'
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如你所见，我们现在有一种以用户为中心的方式来测试我们的突变。然而，出于某种原因，让我们假设我们无法对我们的 `SimpleMutation` 组件进行更改。我们如何确保我们的突变被执行？我们不得不求助于实现细节。我们的测试场景将类似于以下内容：
- en: '**As a user, I want to perform a mutation**: In this scenario, we want to render
    our component, fill out the form, press the **Add** button, and assert that our
    mutation was triggered'
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作为用户，我想执行一个突变**：在这个场景中，我们想要渲染我们的组件，填写表单，按下 **添加** 按钮，并断言我们的突变已被触发'
- en: In this section, we will show you how to write tests for instances where the
    ideal (user-centric) approach is not something we can employ.
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您展示如何编写在理想（以用户为中心）的方法不可行时的测试。
- en: 'The first thing we need to do before we write our test is to make sure MSW
    intercepts our request and is successful:'
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们编写测试之前，我们首先需要确保 MSW 请求被拦截并且成功：
- en: '[PRE24]'
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding snippet, we create a request handler to add to our `handlers`
    array, which does the following.
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们创建了一个请求处理器，并将其添加到我们的 `handlers` 数组中，该处理器执行以下操作。
- en: Whenever we intercept a `POST` request to an endpoint that includes the `/name-api/`
    path, we return a `201 Created` response that will have an object in its body,
    with a `hello` property containing a string.
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每当我们拦截到包含 `/name-api/` 路径的端点的 `POST` 请求时，我们返回一个包含在主体中的 `201 Created` 响应，该响应包含一个具有
    `hello` 属性的字符串对象。
- en: 'We can now write our tests for our `SimpleMutation` component. Just to recap,
    here are the tests we will be performing:'
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在可以为我们 `SimpleMutation` 组件编写测试。为了回顾，以下是我们将要执行的测试：
- en: As a user, I want to see a paused indicator when my mutation enters the paused
    state
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为用户，我想在我突变进入暂停状态时看到暂停指示器
- en: As a user, I want to perform a mutation
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为用户，我想执行一个突变
- en: 'Let us now see our created test file:'
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们看看我们创建的测试文件：
- en: '[PRE25]'
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let us now review what we are doing in the preceding snippet:'
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们现在回顾一下前面代码片段中我们在做什么：
- en: We import our `axiosInstance` from our API file, as well as the `SimpleMutation`
    component we saw in [*Chapter 6*](B18501_06.xhtml#_idTextAnchor159), our custom
    `render` function, the `screen` object, and the `waitFor` function from our `test-utils`.
    Finally, we import the `userEvent` util from the `user-event` companion in the
    testing library.
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从我们的 API 文件中导入 `axiosInstance`，以及我们在 [*第 6 章*](B18501_06.xhtml#_idTextAnchor159)
    中看到的 `SimpleMutation` 组件，我们的自定义 `render` 函数，`screen` 对象，以及来自 `test-utils` 的 `waitFor`
    函数。最后，我们从测试库的 `user-event` 伴侣中导入 `userEvent` 工具。
- en: One thing to be aware of here is that we are using a user-event version before
    v14.
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里需要注意的一点是我们使用的是 v14 之前的用户事件版本。
- en: Since we will tie one of our tests to implementation details, we create `jest`
    `spy` over the `post` function of our `axiosInstance`. This means we can check
    whether our `post` function was called without replacing its implementation.
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将其中一个测试与实现细节绑定，我们在 `axiosInstance` 的 `post` 函数上创建了一个 `jest` `spy`。这意味着我们可以检查
    `post` 函数是否被调用，而不替换其实现。
- en: 'We create our test suite, and inside it, our tests:'
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建我们的测试套件，并在其中创建我们的测试：
- en: 'For the `"data should be sent to the server"` test, we do the following:'
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 `"数据应该发送到服务器"` 测试，我们执行以下操作：
- en: Create a variable to hold the name we will use in our mutation.
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个变量来保存我们将要在突变中使用的名称。
- en: Render our `SimpleMutation` component.
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染我们的 `SimpleMutation` 组件。
- en: Leverage a `getByRole` query to get our name input.
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 利用 `getByRole` 查询来获取我们的名称输入。
- en: Leverage the `type` event from `userEvent` and type our name inside our input.
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 利用 `userEvent` 的 `type` 事件并在我们的输入中键入我们的名称。
- en: Leverage the `click` event from `userEvent` and click on the `post` function
    of our `axiosInstance` is called with the data from our mutation.
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 利用来自 `userEvent` 的 `click` 事件并点击我们的 `axiosInstance` 的 `post` 函数，该函数使用我们的突变数据被调用。
- en: 'For the `"on no network should display paused information"` test, we do the
    following:'
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 `"on no network should display paused information"` 测试，我们做以下操作：
- en: Since we want to make sure that we simulate being offline, we leverage the `mockReturnValue`
    function from the `spyOn` function to make sure we force our `navigator` `onLine`
    property to return `false`. This will make sure that our code is aware of being
    offline.
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们想确保模拟离线状态，我们利用 `spyOn` 函数中的 `mockReturnValue` 函数来确保我们的 `navigator` `onLine`
    属性返回 `false`。这将确保我们的代码知道它处于离线状态。
- en: Render our `SimpleMutation` component.
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染我们的 `SimpleMutation` 组件。
- en: Leverage the `click` event from the `userEvent` and click on the `isPaused`
    property is `true`. Therefore, we wait until the `"Waiting for network to come
    back"` message appears. We then assert it is on the DOM.
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 利用来自 `userEvent` 的 `click` 事件并点击 `isPaused` 属性为 `true`。因此，我们等待直到出现 `"Waiting
    for network to come back"` 消息。然后我们断言它已经在 DOM 上。
- en: From the previous test, we learned that we can leverage `Jest` spies to check
    whether our function was called and make sure our mutation is performed. This
    doesn’t guarantee how our component will behave when our mutation is successful
    because we don’t have anything rendered in there to let us know. In the first
    case scenario, always ensure you have all the information your user needs so they
    can know that your mutation was successful. If you do this, you can test it in
    a user-centric way and avoid implementation details.
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从之前的测试中，我们了解到我们可以利用 `Jest` 间谍来检查我们的函数是否被调用，并确保我们的突变被执行。但这并不保证我们的组件在突变成功时的行为，因为我们没有渲染任何内容来让我们知道。在第一种情况下，始终确保你有用户所需的所有信息，这样他们就可以知道你的突变是成功的。如果你这样做，你可以从用户中心的角度进行测试，并避免实现细节。
- en: One mutation case that might be relevant for testing is when we perform an optimistic
    update. However, since we applied one of the aforementioned patterns in this chapter
    to it, we will be able to test it with the **React Hooks Testing Library** in
    the next section.
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个可能与测试相关的突变案例是在我们执行乐观更新时。然而，由于我们在本章中应用了上述模式之一，我们将在下一节中使用 **React Hooks Testing
    Library** 来测试它。
- en: Testing custom hooks that use React Query
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试使用 React Query 的自定义钩子
- en: During development, there will be times when your custom hooks are too complex
    to test alongside the component that leverages them. This can be due to the size
    of the hook, complex logic, or just too many scenarios that would increase your
    test complexity if you focused on a user-centric approach. To fix this issue,
    the React Hooks Testing Library was created.
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在开发过程中，有时你的自定义钩子可能太复杂，无法与使用它们的组件一起测试。这可能是由于钩子的大小、复杂的逻辑，或者太多的场景，如果专注于用户中心的方法，会增加你的测试复杂性。为了解决这个问题，创建了
    React Hooks Testing Library。
- en: Now, it might be very tempting to go ahead and use this everywhere, but don’t
    forget that a user-centric approach will ultimately help you to find issues faster
    and save time if you decide to refactor the way your hooks work. Either way, if
    your hook is not used alongside a component or is too complex, the React Hooks
    Testing Library is definitely something to consider.
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，可能会非常诱人去到处使用这个，但别忘了，以用户为中心的方法最终会帮助你更快地找到问题并节省时间，如果你决定重构你的钩子工作方式。无论如何，如果你的钩子没有与组件一起使用或太复杂，React
    Hooks Testing Library 确实是值得考虑的。
- en: 'Here is how to add the React Hooks Testing Library to your project:'
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是将 React Hooks Testing Library 添加到你的项目的步骤：
- en: 'If you are running npm in your project, run the following command:'
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在你的项目中运行 npm，请运行以下命令：
- en: '[PRE26]'
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you are using Yarn, run the following command:'
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在使用 Yarn，请运行以下命令：
- en: '[PRE27]'
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If you are using pnpm, run the following command:'
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在使用 pnpm，请运行以下命令：
- en: '[PRE28]'
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If you are using React from version 18 and above, there is something to be aware
    of here. You don’t need to install the React Hooks Testing Library, as from version
    13.1.0 onward, the React Testing Library includes `renderHook`, which works similarly
    to the one from the React Hooks Testing Library.
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你正在使用 React 18 版本及以上，这里有一些需要注意的事情。你不需要安装 React Hooks Testing Library，因为从 13.1.0
    版本开始，React Testing Library 包含 `renderHook`，它的工作方式与 React Hooks Testing Library
    类似。
- en: As mentioned at the end of the last section, we will see how to test optimistic
    updates. Before we write our tests, let us see how our code looks after applying
    the patterns mentioned in this chapter.
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如上一节末所述，我们将看到如何测试乐观更新。在我们编写测试之前，让我们看看应用本章中提到的模式后我们的代码看起来如何。
- en: 'To do this, we will leverage the `useOptimisticUpdateUserCreation` hook shown
    previously:'
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要做到这一点，我们将利用之前显示的`useOptimisticUpdateUserCreation`钩子：
- en: '[PRE29]'
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Considering we already have the route leveraged in this hook handled by MSW,
    we can start considering our tests.
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 考虑到我们已经在MSW中处理了此钩子中的路由，我们可以开始考虑我们的测试。
- en: 'These are the scenarios we will be considering:'
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些是我们将考虑的场景：
- en: '**I want to perform an optimistic update right after triggering my mutation**:
    In this scenario, we render our hook, trigger our mutation, and wait until the
    query data affected by our mutation is updated.'
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我想在触发我的变更后立即执行乐观更新**：在这种情况下，我们渲染我们的钩子，触发我们的变更，并等待直到受我们的变更影响的查询数据已更新。'
- en: '**I want my optimistic update data to be reverted after my mutation fails**:
    In this scenario, we render our hook and trigger our mutation, and when our mutation
    fails, our query data must stay the same as before the mutation was triggered.'
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我想在我变更失败后撤销我的乐观更新数据**：在这种情况下，我们渲染我们的钩子并触发我们的变更，当我们的变更失败时，我们的查询数据必须与触发变更之前保持相同。'
- en: '**I want my query to be invalidated after my mutation settles**: In this scenario,
    we render our hook and trigger our mutation. Once our mutation settles, we check
    whether our query was invalidated.'
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我想在我变更稳定后使我的查询失效**：在这种情况下，我们渲染我们的钩子并触发我们的变更。一旦我们的变更稳定，我们检查查询是否已失效。'
- en: 'With these scenarios in mind, we can create our tests. This is what our test
    file would look like:'
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 考虑到这些场景，我们可以创建我们的测试。这是我们的测试文件可能的样子：
- en: '[PRE30]'
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let us now review what we do in the preceding snippet:'
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们现在回顾一下我们在前面的代码片段中做了什么：
- en: 'We start by doing the necessary imports:'
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先进行必要的导入：
- en: Our `useOptimisticUpdateUserCreation` custom hook.
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`useOptimisticUpdateUserCreation`自定义钩子。
- en: Our `QueryClient` and `QueryClientProvider`. Remember that we won’t use the
    previously created `customRender`, so we must create a new wrapper here.
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`QueryClient`和`QueryClientProvider`。记住，我们不会使用之前创建的`customRender`，所以我们必须在这里创建一个新的包装器。
- en: '`renderHook` from the React Hooks Testing Library. If you use `renderHook`
    from the React Testing Library, import it there instead.'
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从React Hooks Testing Library导入`renderHook`。如果您使用React Testing Library中的`renderHook`，请在那里导入它。
- en: Our `userKeys` factory.
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`userKeys`工厂。
- en: Our MSW `server` so that we can create a custom response mock for one of our
    test scenarios.
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的MSW `server`，这样我们就可以为我们的测试场景之一创建一个自定义响应模拟。
- en: The MSW `rest` namespace to create relevant request handlers for one of our
    test scenarios.
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: MSW的`rest`命名空间来为我们的测试场景之一创建相关的请求处理器。
- en: We create our `QueryClient` instance and pass it to our `wrapper`. This will
    be used to wrap our hook to use React Query.
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建我们的`QueryClient`实例并将其传递给我们的`wrapper`。这将用于包装我们的钩子以使用React Query。
- en: 'We create our test suite and, inside it, our tests:'
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建我们的测试套件，并在其中创建我们的测试：
- en: 'For the `"should perform optimistic update"` test, we do the following:'
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`"should perform optimistic update"`测试，我们做以下操作：
- en: Ensure our cached query data for the query key under the `userKeys.all()` key
    is an empty array.
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在`userKeys.all()`键下的查询键的缓存查询数据是一个空数组。
- en: Create the `name` and `age` variables to avoid magic numbers in our test.
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`name`和`age`变量以避免在测试中使用魔法数字。
- en: Render our hook and destructure the `waitFor` function and the `result` object
    from it.
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染我们的钩子，并从其中解构`waitFor`函数和`result`对象。
- en: We leverage our `result` object to access our `mutate` function and perform
    our mutation.
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们利用我们的`result`对象来访问我们的`mutate`函数并执行我们的变更操作。
- en: We use the `waitFor` function to loop our assertion until it evaluates to `true`.
    In this scenario, we wait until the query cache has the optimistically updated
    data cached under the `userKeys.all()` query key.
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`waitFor`函数循环我们的断言，直到它评估为`true`。在这种情况下，我们等待直到查询缓存已经根据`userKeys.all()`查询键缓存了乐观更新的数据。
- en: 'For the `"should revert optimistic update"` test, we do the following:'
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`"should revert optimistic update"`测试，我们做以下操作：
- en: Ensure our cached query data for the query key under the `userKeys.all()` key
    is an empty array.
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在`userKeys.all()`键下的查询键的缓存查询数据是一个空数组。
- en: Leverage our `server use` function to add a request handler to our current server
    instance. In this scenario, we add a handler that will catch every `POST` request
    (`"*"` indicates that this handler will match every route) and return a `403 Forbidden`
    so that our request fails. Don’t worry about this leaking into other tests because
    we made sure to call the `resetHandlers` function in our `setupTests` file. This
    will ensure that this custom request handler will only be used on this test.
  id: totrans-329
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 利用我们的`server use`函数向我们的当前服务器实例添加一个请求处理器。在这种情况下，我们添加一个将捕获每个`POST`请求（`"*"`表示此处理器将匹配每个路由）并返回`403
    Forbidden`以使请求失败的处理程序。不用担心这会泄漏到其他测试中，因为我们确保在`setupTests`文件中调用了`resetHandlers`函数。这将确保此自定义请求处理器只会用于此测试。
- en: Create the `name` and `age` variables to avoid magic numbers in our test.
  id: totrans-330
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次创建`name`和`age`变量以避免测试中的魔法数字。
- en: Render our hook and destructure the `waitFor` function and the `result` object
    from it.
  id: totrans-331
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染我们的钩子并从其中解构`waitFor`函数和`result`对象。
- en: Leverage our `result` object to access our `mutate` function and perform our
    mutation.
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 利用我们的`result`对象来访问我们的`mutate`函数并执行我们的变异。
- en: Use the `waitFor` function to wait until our hook’s `isError` property is `true`.
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`waitFor`函数等待直到我们的钩子的`isError`属性为`true`。
- en: Once we are sure our mutation has failed, we again leverage the `waitFor` function
    to wait until the query data cached under the `userKeys.all()` key is the empty
    array we had before our mutation.
  id: totrans-334
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们确认我们的变异失败，我们再次利用`waitFor`函数等待，直到在`userKeys.all()`键下缓存的查询数据是我们变异之前的空数组。
- en: 'For the `"should invalidate query on settled"` test, we do the following:'
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`"should invalidate query on settled"`测试，我们做以下操作：
- en: Ensure our cached query data for the query key under the `userKeys.all()` key
    is an empty array.
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在`userKeys.all()`键下的查询键的缓存查询数据是一个空数组。
- en: Since we are not rendering a query to make sure it is updating after our mutation,
    we create `invalidateQueriesSpy` over our `queryClient` `invalidateQueries` method.
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们没有渲染查询以确保它在变异后更新，我们在`queryClient`的`invalidateQueries`方法上创建`invalidateQueriesSpy`。
- en: Create the `name` and `age` variables to avoid magic numbers in our test.
  id: totrans-338
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`name`和`age`变量以避免测试中的魔法数字。
- en: Render our hook and destructure the `waitFor` function and the `result` object
    from it.
  id: totrans-339
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染我们的钩子并从其中解构`waitFor`函数和`result`对象。
- en: Leverage our `result` object to access our `mutate` function and perform our
    mutation.
  id: totrans-340
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 利用我们的`result`对象来访问我们的`mutate`函数并执行我们的变异。
- en: Wait until our `isSuccess` is `true`. This means our mutation was successful.
  id: totrans-341
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待直到我们的`isSuccess`为`true`。这意味着我们的变异是成功的。
- en: If our mutation is successful, we can assert that `invalidateQueriesSpy` was
    called with the `userKeys.all()`. This means that our `onSettled` function was
    called, and our query would be invalidated afterward.
  id: totrans-342
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们的变异成功，我们可以断言`invalidateQueriesSpy`被调用时带有`userKeys.all()`。这意味着我们的`onSettled`函数被调用，并且查询将在之后被无效化。
- en: We have now handled how to test custom hooks with React Hooks Testing Library.
    It is all about rendering your hook and leveraging its result to access what your
    hook returns to perform your actions and assertions.
  id: totrans-343
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经处理了如何使用React Hooks Testing Library测试自定义钩子的方法。这全部关于渲染你的钩子并利用其结果来访问你的钩子返回的内容以执行你的操作和断言。
- en: Just for the sake of convenience and so that you can see a scenario where we
    test a query, let us see how we would test the `useMultipleQueriesV2` hook we
    saw in the *Checking whether data is* *fetched* section.
  id: totrans-344
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 只为了方便，并且让你看到我们测试查询的场景，让我们看看我们如何测试在*检查数据是否* *已获取*部分中看到的`useMultipleQueriesV2`钩子。
- en: 'For this hook, we would only need a single test scenario:'
  id: totrans-345
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于这个钩子，我们只需要一个测试场景：
- en: '**I want my parallel queries to fetch data**: In this scenario, we render our
    hook and wait until it returns the data for the three queries it fetches'
  id: totrans-346
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我希望我的并行查询能够获取数据**：在这种情况下，我们渲染我们的钩子并等待它返回它获取的三个查询的数据。'
- en: Like the previous hook, we have already set up our MSW request handlers previously,
    so we don’t need to worry about them.
  id: totrans-347
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 像之前的钩子一样，我们之前已经设置了我们的MSW请求处理器，所以我们不需要担心它们。
- en: 'Let us look at the test file for our `useMultipleQueriesV2` hook:'
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们看看我们的`useMultipleQueriesV2`钩子的测试文件：
- en: '[PRE31]'
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let us now review what we are doing in the preceding snippet:'
  id: totrans-350
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们现在回顾一下前面片段中我们在做什么：
- en: 'We start by doing the necessary imports:'
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先进行必要的导入：
- en: Our `useMultipleQueriesV2` custom hook.
  id: totrans-352
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`useMultipleQueriesV2`自定义钩子。
- en: Our `QueryClient` and `QueryClientProvider`.
  id: totrans-353
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`QueryClient`和`QueryClientProvider`。
- en: '`renderHook` from the React Hooks Testing Library. If you are using `renderHook`
    from the React Testing Library, import it from there instead.'
  id: totrans-354
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 来自React Hooks Testing Library的`renderHook`。如果您正在使用React Testing Library中的`renderHook`，请从那里导入。
- en: We create our `QueryClient` instance and pass it to our `wrapper`. This will
    be used to wrap our hook to use React Query.
  id: totrans-355
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建我们的`QueryClient`实例，并将其传递给我们的`wrapper`。这将用于包装我们的钩子以使用React Query。
- en: 'We create our test suite and, inside it, our test:'
  id: totrans-356
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建我们的测试套件，并在其中创建我们的测试：
- en: 'For the `"should fetch all data"` test, we do the following:'
  id: totrans-357
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`"should fetch all data"`测试，我们做以下操作：
- en: Render our hook with the `renderHook` function and destructure the `result`
    object and the `waitFor` function from it.
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`renderHook`函数渲染我们的钩子，并从其中解构`result`对象和`waitFor`函数。
- en: Wait until the data for the first query is defined.
  id: totrans-359
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待第一个查询的数据定义。
- en: Given that the data is now defined, we assert that the `hello` property from
    the returned object on the first query has `userOne`.
  id: totrans-360
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于数据现在已定义，我们断言第一个查询返回的对象上的`hello`属性具有`userOne`。
- en: We also assert that the `hello` property from the returned object on the second
    query has `userTwo`.
  id: totrans-361
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还断言第二个查询返回的对象上的`hello`属性具有`userTwo`。
- en: We also assert that the `hello` property from the returned object on the third
    query has `userThree`.
  id: totrans-362
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还断言第三个查询返回的对象上的`hello`属性具有`userThree`。
- en: As you can see, testing hooks and leveraging queries is much simpler, as it
    mostly only involves rendering and asserting. This a test example, where I did
    not test the hook because testing the component using it is much easier. Just
    check the test we did for it in the *Checking whether data is* *fetched* section.
  id: totrans-363
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，测试钩子和利用查询要简单得多，因为它主要只涉及渲染和断言。这是一个测试示例，我没有测试这个钩子，因为使用该组件进行测试要容易得多。只需检查我们在*检查数据是否*
    *已获取*部分所做的测试即可。
- en: With all this knowledge in mind, you should be able to write your code and then
    sleep amazingly well at night because you also wrote valuable tests, ensuring
    that nothing will break.
  id: totrans-364
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在考虑到所有这些知识后，您应该能够编写代码，然后在夜间睡得非常香，因为您还编写了有价值的测试，确保没有任何东西会出错。
- en: Summary
  id: totrans-365
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to test our components and hooks that leverage
    React Query. Congratulations! Thanks to this chapter, you have become a full-on
    React Query master!
  id: totrans-366
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何测试利用React Query的组件和钩子。恭喜！感谢本章，您已经成为了一名全栈的React Query大师！
- en: You learned how MSW can save you a lot of time developing and testing your React
    Query code by having a couple of request handlers.
  id: totrans-367
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您了解到MSW可以通过拥有几个请求处理程序来节省您在开发和测试React Query代码时的大量时间。
- en: You got to meet the three patterns you can apply to make your code more readable
    and reusable (creating an API file, leveraging query key factories, and creating
    a hooks folder) and saw how valuable they were in adapting the code we saw in
    previous chapters.
  id: totrans-368
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您遇到了三种可以使您的代码更易于阅读和重用的模式（创建API文件、利用查询键工厂和创建钩子文件夹），并看到了它们在适应我们之前章节中看到的代码时的价值。
- en: Finally, you learned when to use the React Testing Library and the React Hooks
    Testing Library to test your queries and mutations, and you will keep the user-centric
    approach at the forefront of your mind when writing tests from now on.
  id: totrans-369
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，您学习了何时使用React Testing Library和React Hooks Testing Library来测试您的查询和突变，并且您将在编写测试时始终将以用户为中心的方法放在首位。
- en: Once again, congratulations! You should now be able to leverage React Query
    in every scenario and sleep better at night because you can write valuable tests
    for it. Now, run with this knowledge, and go ahead and convince your teammates
    about the value of the amazing TanStack Query and how its React Adapter, called
    React Query, will make their server state management much easier.
  id: totrans-370
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次恭喜！现在您应该能够在任何场景下利用React Query，并在夜间睡得更好，因为您可以为它编写有价值的测试。现在，运用这些知识，去说服您的队友关于惊人的TanStack
    Query的价值，以及其React适配器，即React Query，将使他们的服务器状态管理变得容易得多。
