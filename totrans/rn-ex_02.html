<html><head></head><body>
        <section>

            <header>
                <h1 class="header-title">Advanced Functionality and Styling the To-Do List App</h1>
            </header>

            <article>
                
<p>Having built an MVP for <kbd>Tasks</kbd>, our to-do list app, it's time to delve into building out advanced functionality, and styling the application to make it look nice. This chapter will explore the following topics:</p>
<ul>
<li>Utilizing the <kbd>NavigatorIOS</kbd> component to build an edit screen to add details to a task</li>
<li>Taking in a date and time for tasks to be due with <kbd>DatePickerIOS</kbd></li>
<li>Creating a custom collapsible component for our app and utilizing <kbd>LayoutAnimation</kbd> to give us fluid transitions</li>
<li>Building a <kbd>Button</kbd> component for our UI to clear a to-do item's due date</li>
<li>Saving the data of an edited task and rendering a due date, if applicable</li>
<li>Porting the application over to Android, swapping out <kbd>DatePickerIOS</kbd> for <kbd>DatePickerAndroid</kbd> and <kbd>TimePickerAndroid</kbd> and <kbd>NavigatorIOS</kbd> for <kbd>Navigator</kbd>, and exploring the control flow in deciding which component is used</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Navigator and NavigatorIOS</h1>
            </header>

            <article>
                
<p>Implementing navigation in a mobile application helps us control how our users interact with and experience our apps. It lets us assign context to situations that would otherwise not have any--for example, in <kbd>Tasks</kbd>, it will not make sense to show a user an edit view for a task that they haven't selected; only showing this to the user when they select a task to edit builds situational context and awareness.</p>
<p>React Native's <kbd>Navigator</kbd> component handles the transitions between different views in your application. Glancing at the documentation, you may note that there's both a <kbd>Navigator</kbd> and <kbd>NavigatorIOS</kbd> component. <kbd>Navigator</kbd> is available on iOS and Android and implemented with JavaScript. On the other hand, <kbd>NavigatorIOS</kbd> is specifically available for iOS and is a wrapper around iOS's native <kbd>UINavigationController</kbd>, animating it and behaving the way you would expect from any iOS application.</p>
<p>Later in this chapter, we will take a closer look at the Navigator.</p>
<div class="packt_tip"><span class="packt_screen">An important note about NavigatorIOS<br/></span>While <kbd>NavigatorIOS</kbd> supports UIKit animations and is a great choice for building the iOS version of <kbd>Tasks</kbd>, one thing to keep in mind is that <kbd>NavigatorIOS</kbd> happens to be a community-driven component of the React Native SDK. Facebook has openly stated from the beginning that it utilizes <kbd>Navigator</kbd> heavily in its own applications, but all support for future improvements and additions to the <kbd>NavigatorIOS</kbd> component will come directly from open source contributions.</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Looking at NavigatorIOS</h1>
            </header>

            <article>
                
<p>The <kbd>NavigatorIOS</kbd> component is set up at the top level of your React Native app. We'll provide at least one object, identified as <kbd>routes</kbd>, in order to identify each view in our app. Additionally, <kbd>NavigatorIOS</kbd> looks for a <kbd>renderScene</kbd> method, which is responsible for rendering each scene in our app. Here's an example of how you can render a basic scene with <kbd>NavigatorIOS</kbd>:</p>
<pre>
import React, { Component } from 'react'; <br/>import { <br/>  NavigatorIOS, <br/>  Text <br/>} from 'react-native'; <br/><br/>export default class ExampleNavigation extends Component { <br/>  render () { <br/>    return ( <br/>      &lt;NavigatorIOS <br/>        initialRoute={{ <br/>          component: TasksList, <br/>          title: 'Tasks' <br/>        }} <br/>        style={ styles.container } <br/>      /&gt; <br/> ); <br/>  } <br/>} 
</pre>
<p>This is just a rudimentary example. All we're doing is initializing the <kbd>NavigatorIOS</kbd> component and rendering it as a basic route with a simple <kbd>text</kbd> component. What we're really interested in doing is switching between <kbd>routes</kbd> to edit a task. Let's break down this goal into a number of subtasks that are easier to tackle:</p>
<ul>
<li>Create a new <kbd>EditTask</kbd> component. It can start off as a simple screen with some filler info on it.</li>
<li>Set up <kbd>NavigatorIOS</kbd> to route to <kbd>EditTask</kbd> when a task is long-pressed.</li>
<li>Build logic for <kbd>EditTask</kbd> to accept the exact task as a prop in the component to render task-specific data. Add appropriate input fields to allow this component to be marked as complete from the edit screen as well as for it to have the ability to set a due date and tag.</li>
<li>When edits are saved, add logic to save the edited data to <kbd>AsyncStorage</kbd>.</li>
</ul>
<p>We'll take some time to complete each step and go over them when necessary. Take a few minutes to build a simple <kbd>EditTask</kbd> component, and then refer to how I built mine.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">A simple EditTasks component</h1>
            </header>

            <article>
                
<p>In my application folder structure, my <kbd>EditTasks</kbd> component is nested as such:</p>
<pre>
|Tasks <br/>|__android <br/>|__app <br/>|____components <br/>|______EditTask <br/>|______TasksList <br/>|______TasksListCell <br/>|__ios <br/>|__node_modules <br/>|__... 
</pre>
<p>Here is a basic component just to have something appear on the screen:</p>
<pre>
// Tasks/app/components/EditTask/index.js <br/><br/>import React, { Component } from 'react'; <br/><br/>import { <br/>  Text, <br/>  View <br/>} from 'react-native'; <br/><br/>import styles from './styles'; <br/><br/>export default class EditTask extends Component { <br/>  render () { <br/>    return ( <br/>      &lt;View style={ styles.editTaskContainer }&gt; <br/>        &lt;Text style={ styles.editTaskText }&gt;Editing Task&lt;/Text&gt; <br/>      &lt;/View&gt; <br/>    ); <br/>  } <br/>} 
</pre>
<p>The preceding code returns text to render to the screen for now.</p>
<p>Now comes the fun part. Let's set up <kbd>NavigatorIOS</kbd> to play nicely with <kbd>TasksList</kbd>:</p>
<pre>
// Tasks/app/components/EditTask/styles.js <br/><br/>import { Navigator, StyleSheet } from 'react-native'; <br/><br/>const styles = StyleSheet.create({ <br/>  editTaskContainer: { <br/>    flex: 1, <br/>    paddingTop: Navigator.NavigationBar.Styles.General.TotalNavHeight <br/>  }, <br/>  editTaskText: { <br/>    fontSize: 36 <br/>  } <br/>}) <br/><br/>export default styles; 
</pre>
<p> First, we should modify <kbd>TasksList</kbd> so that it:</p>
<ul>
<li>Adds a function, called <kbd>_editTask</kbd>, to push the <kbd>EditTask</kbd> component to the Navigator</li>
<li>Passes the <kbd>_editTask</kbd> function into <kbd>TasksListCell</kbd> as a prop, titled <kbd>onLongPress</kbd></li>
</ul>
<p>Then, we should modify <kbd>EditTask</kbd> so that the <kbd>TouchableHighlight</kbd> component in its <kbd>render</kbd> method calls this prop during its own <kbd>onLongPress</kbd> callback:</p>
<pre>
// Tasks/app/components/TasksList/index.js <br/><br/>... <br/>import EditTask from '../EditTask'; <br/>... <br/>export default class TasksList extends Component { <br/>  ... <br/>  render () { <br/>    ... <br/>    return ( <br/>      &lt;View style={ styles.container }&gt; <br/>        ... <br/>        &lt;ListView <br/>          ... <br/>          automaticallyAdjustContentInsets={ false } <br/>          style={ styles.listView } <br/>        /&gt; <br/>      &lt;/View&gt; <br/>    ); <br/>  } 
</pre>
<p>We added a Boolean set to disable the automatic adjustment of content insets. With this defaulting to <kbd>true</kbd>, we saw an inset of <kbd>~55px</kbd> between our <kbd>Input</kbd> and <kbd>ListView</kbd> components. In our styling for both this component and <kbd>EditTask</kbd>, we started importing the <kbd>Navigator</kbd> component.</p>
<p>This is so that we can set the <kbd>paddingTop</kbd> property of our container to take into consideration the height of the navigation bar so that content is not left tucked behind the navigation bar. The reason this happens is because the navigation bar is rendered over our components after they are done loading.</p>
<p>Call the <kbd>push</kbd> method of <kbd>NavigatorIOS</kbd>, rendering the <kbd>EditTask</kbd> component that we just imported:</p>
<pre>
  ... <br/>  _editTask (rowData) { <br/>    this.props.navigator.push({ <br/>      component: EditTask, <br/>      title: 'Edit' <br/>    }); <br/>  } 
</pre>
<p>Assign <kbd>TasksListCell</kbd> a callback, titled <kbd>onLongPress</kbd>, that executes the <kbd>_editTask</kbd> method we just defined:</p>
<pre>
  _renderRowData (rowData, rowID) { <br/>    return ( <br/>      &lt;TasksListCell <br/>        ... <br/>        onLongPress={ () =&gt; this._editTask() } <br/>      /&gt; <br/>    ) <br/>  } <br/>  ... <br/>} 
</pre>
<p>Setting the <kbd>paddingTop</kbd> property to the height of the Navigator solves the issue of our navigation bar hiding the content of our app behind it:</p>
<pre>
// Tasks/app/components/TasksList/styles.js <br/><br/>import { Navigator, StyleSheet } from 'react-native'; <br/><br/>const styles = StyleSheet.create({ <br/>  container: { <br/>    ... <br/>    paddingTop: Navigator.NavigationBar.Styles.General.TotalNavHeight <br/>... <br/>}); <br/><br/>export default styles; 
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Using DatePickerIOS</h1>
            </header>

            <article>
                
<p>A key feature in <kbd>Tasks</kbd> is the ability to set a reminder for when a task is due. Ideally, our users can set a day as well as a time for when a task should be completed so that they can be reminded of the due date. To accomplish this, we'll use an iOS component named <kbd>DatePickerIOS</kbd>. This is a component that renders a date and time selector that we can utilize in our application.</p>
<p>Listed here are the two props that we will be using with our <kbd>DatePickerIOS</kbd> component. Other props exist in the React Native documentation in case you are interested:</p>
<ul>
<li><kbd>date</kbd>: This is one of the two required props that track the current selected date. Ideally, this information is stored within the state of the component that renders <kbd>DatePickerIOS</kbd>. The <kbd>date</kbd> should be an instance of the <kbd>Date</kbd> object in JavaScript.</li>
<li><kbd>onDateChange</kbd>: This is the other required prop and is fired when a user changes the <kbd>date</kbd> or <kbd>time</kbd> in the component. It accepts one argument, which is the <kbd>Date</kbd> object representing the new date and time.</li>
</ul>
<p>Here's how a simple <kbd>DatePicker</kbd> component looks:</p>
<pre>
// Tasks/app/components/EditTask/index.js <br/><br/>... <br/>import { <br/>  DatePickerIOS, <br/>  ... <br/>} from 'react-native';  <br/>...  <br/>export default class EditTask extends Component { <br/>  constructor (props) { <br/>    super (props); <br/><br/>    this.state = { <br/>      date: new Date() <br/>    } <br/>  } 
</pre>
<p>It creates a new instance of the JavaScript <kbd>Date</kbd> object and saves it to state.</p>
<pre>
  render () { <br/>    return ( <br/>      &lt;View style={ styles.editTaskContainer }&gt; <br/>        &lt;DatePickerIOS <br/>          date={ this.state.date } <br/>          onDateChange={ (date) =&gt; this._onDateChange(date) } <br/>          style={ styles.datePicker } <br/>        /&gt; <br/>      &lt;/View&gt; <br/>    ); <br/>  } 
</pre>
<p>This results in rendering a <kbd>DatePickerIOS</kbd> component using the <kbd>date</kbd> value in the component state as its prop of the same name.</p>
<p>The callback to change the <kbd>date</kbd> in the component state when the user interacts with the <kbd>DatePickerIOS</kbd> component:</p>
<pre>
  _onDateChange (date) { <br/>    this.setState({ <br/>      date <br/>    }); <br/>  } <br/>} 
</pre>
<p>This is how the <kbd>DatePicker</kbd>, when rendered, will look:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1428 image-border" height="342" src="assets/image_02_001-1.png" width="196"/></div>
<p>This leaves a lot to be desired. For one, the <kbd>DatePickerIOS</kbd> component is always visible! Normally, when we interact with this type of selector in iOS applications, it is collapsed and only expands when tapped on. What we want is to replicate that exact experience, that is, render a touchable row that either displays the current set due date or something along the lines of <em>No Due Date Set</em>, animating the expansion of <kbd>DatePickerIOS</kbd> when the row is tapped on.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Writing a collapsible component</h1>
            </header>

            <article>
                
<p>Our collapsible component should accomplish the following goals:</p>
<ul>
<li>It should show and hide other components passed to it when tapped on</li>
<li>An animation will accompany this component, adding to the user experience of our app</li>
<li>The component should not make any assumptions about the type of data it is showing and hiding; it should not be strictly specific to <kbd>DatePickerIOS</kbd> in case we want to reuse the component for other purposes in the future</li>
</ul>
<p>We'll need to take advantage of React Native's fantastic <kbd>LayoutAnimation</kbd> API, which is designed to let us create fluid and meaningful animations.</p>
<p>To begin, I've created an <kbd>ExpandableCell</kbd> component within the <kbd>components</kbd> folder of our project, like this:</p>
<pre>
|Tasks <br/>|__android <br/>|__app <br/>|____EditTask <br/>|____ExpandableCell <br/>|____TasksList <br/>|____TasksListCell <br/>|__ios <br/>|__... 
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">The LayoutAnimation API</h1>
            </header>

            <article>
                
<p>Our goal is to tap on the <kbd>date</kbd>/<kbd>time</kbd> component in <kbd>EditTask</kbd> and then have it expand downward to reveal the hidden <kbd>DatePickerIOS</kbd> component. React Native has an API, called <kbd>LayoutAnimation</kbd>, that allows us to create automatically animating layouts.</p>
<p><kbd>LayoutAnimation</kbd> comes with three methods representing default animation curves: <kbd>easeInEaseOut</kbd>, <kbd>linear</kbd>, and <kbd>spring</kbd>. These dictate how the animation behaves throughout its transition. You can simply call one of the three methods under the <kbd>componentWillUpdate</kbd> life cycle method and, should a change in your component's state trigger a rerender, <kbd>LayoutAnimation</kbd> will add its animation to your changes.</p>
<p>To hide and show the children components passed to <kbd>ExpandableCell</kbd>, I can manipulate its <kbd>maxHeight</kbd> style based on whether or not the component should be shown or hidden. Additionally, I can hide the component when not needed by setting its <kbd>overflow</kbd> property to <kbd>hidden</kbd>.</p>
<p>Take some time to hide the children components passed into <kbd>ExpandableCell</kbd> and set up some logic to show and hide this content as needed. When you're ready, look at my implementation.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Basic ExpandableCell implementation</h1>
            </header>

            <article>
                
<p>This is how we can start building <kbd>ExpandableCell</kbd>:</p>
<pre>
// Tasks/app/components/ExpandableCell/index.js <br/><br/>import React, { Component, PropTypes } from 'react'; <br/><br/>import { <br/>  LayoutAnimation, <br/>  Text, <br/>  TouchableHighlight, <br/>  View <br/>} from 'react-native'; <br/><br/>import styles from './styles'; <br/><br/>export default class ExpandableCell extends Component {
</pre>
<p>This sets the <kbd>title</kbd> as an expected string <kbd>PropTypes</kbd> for the component:</p>
<pre>
  static propTypes = { <br/>    title: PropTypes.string.isRequired <br/>  } 
</pre>
<p>Now we track a Boolean named <kbd>expanded</kbd> in the component <kbd>state</kbd>. By default, our child components should not be visible:</p>
<pre>
  constructor (props) { <br/>    super (props); <br/><br/>    this.state = { <br/>      expanded: false <br/>    } <br/>  } 
</pre>
<p>Set the <kbd>LayoutAnimation</kbd> style for whenever this component changes:</p>
<pre>
  componentWillUpdate () { <br/>    LayoutAnimation.linear(); <br/>  } 
</pre>
<p>Wrap a <kbd>TouchableHighlight</kbd> component around the <kbd>Text</kbd> of the <kbd>ExpandableCell</kbd>. It calls <kbd>_onExpand</kbd> when pressed:</p>
<pre>
  render () { <br/>    return ( <br/>      &lt;View style={ styles.expandableCellContainer }&gt; <br/>        &lt;View&gt; <br/>          &lt;TouchableHighlight <br/>            onPress={ () =&gt; this._expandCell() } <br/>            underlayColor={ '#D3D3D3' } <br/>          &gt; 
</pre>
<p>Add a ternary operator to add a <kbd>maxHeight</kbd> property to the styling of this <kbd>View</kbd> in the event that the component is not expanded:</p>
<pre>
            &lt;Text style={ styles.visibleContent }&gt;<br/>            { this.props.title}&lt;/Text&gt; <br/>          &lt;/TouchableHighlight&gt; <br/>        &lt;/View&gt; <br/>        &lt;View style={ [styles.hiddenContent, <br/>        this.state.expanded ? {} : {maxHeight: 0}]}&gt; 
</pre>
<p>This renders any children nested within the component itself:</p>
<pre>
          { this.props.children } <br/>        &lt;/View&gt; <br/>      &lt;/View&gt; <br/>    ) <br/>  }
</pre>
<p>The following is a callback to toggle the <kbd>expanded</kbd> Boolean in the component state:</p>
<pre>
  _expandCell () { <br/>    this.setState({ <br/>      expanded: !this.state.expanded <br/>    }); <br/>  } <br/>} 
</pre>
<p>This is the styling for <kbd>ExpandableCell</kbd>:</p>
<pre>
// Tasks/app/components/ExpandableCell/styles.js <br/><br/>import { StyleSheet } from 'react-native'; <br/><br/>const styles = StyleSheet.create({ <br/>  expandableCellContainer: { <br/>    flex: 1, <br/>    padding: 10, <br/>    paddingTop: 0 <br/>  }, <br/>  hiddenContent: { <br/>    overflow: 'hidden' <br/>  }, <br/>  visibleContent: { <br/>    fontSize: 24 <br/>  } <br/>}) 
</pre>
<p>A basic implementation of this in <kbd>EditTask</kbd> will look like this:</p>
<pre>
// Tasks/app/components/EditTask/index.js <br/><br/>... <br/>import ExpandableCell from '../ExpandableCell'; <br/><br/>export default class EditTask extends Component { <br/>  ... 
</pre>
<p>Render an ExpandableCell component with a title:</p>
<pre>
render () { <br/>    return ( <br/>      &lt;View style={ styles.editTaskContainer }&gt; <br/>        &lt;ExpandableCell title={ 'Due On' }&gt; 
</pre>
<p>Nest <kbd>DatePickerIOS</kbd> within <kbd>ExpandableCell</kbd> so that it initially stays hidden:</p>
<pre>
          &lt;DatePickerIOS <br/>            ... <br/>          /&gt; 
</pre>
<pre>
        &lt;/ExpandableCell&gt; <br/>      &lt;/View&gt; <br/>    ); <br/>  } <br/>  ... <br/>} 
</pre>
<p>Ideally, this component will show one of the following:</p>
<ul>
<li>The due date of the selected task, if it exists</li>
<li>A blank placeholder to select a date if a due date does not exist</li>
</ul>
<p>We'll worry about things such as clearing the due date later but, for now, we should modify <kbd>EditTask</kbd> so that the <kbd>title</kbd> prop it passes to <kbd>ExpandableCell</kbd> is dependent on whether the task has a due date assigned to it or not. This is how the component should currently look:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1425 image-border" height="286" src="assets/image_02_002-1.png" width="155"/></div>
<p>Here is how I solved the problem. The only file changed since the last example is the <kbd>EditTask</kbd> component:</p>
<pre>
// Tasks/app/components/EditTask/index.js <br/><br/>... <br/>import moment from 'moment'; <br/>... <br/>export default class EditTask extends Component { <br/>  ...  <br/>  render () { <br/> const noDueDateTitle = 'Set Reminder'; <br/>    const dueDateSetTitle = 'Due On ' + this.state.formattedDate; 
</pre>
<p>Set two strings to show the <kbd>title</kbd> prop for <kbd>ExpandableCell</kbd>.</p>
<pre>
return ( <br/>      &lt;View style={ styles.editTaskContainer }&gt; <br/>        &lt;ExpandableCell <br/>          title={ this.state.dateSelected ? <br/>          dueDateSetTitle : noDueDateTitle }&gt; 
</pre>
<p>Use a ternary operator to decide which string to pass in to <kbd>ExpandableCell</kbd>.</p>
<pre>
          ... <br/>        &lt;/ExpandableCell&gt; <br/>      &lt;/View&gt; <br/>    ); <br/>  } <br/><br/>  _formatDate (date) { <br/>    return moment(date).format('lll'); <br/>  } 
</pre>
<p>I also imported <kbd>moment</kbd> from <kbd>npm</kbd> to use its powerful date formatting capabilities. Moment is a very popular, widely-used library that allows us to manipulate dates with JavaScript. Installing it was as simple as opening the Terminal to the project's root folder and typing as follows:</p>
<pre>
<strong>npm install --save moment     </strong> 
</pre>
<p>The MomentJS library is well documented and its main page, found at <a href="https://www.momentjs.com">https:// momentjs.com</a>, will show you all the ways you can utilize it. For this file, I used Moment's the format method and set the formatting to show an abbreviated month name, followed by the day and year in numbers and the time.</p>
<p>A sample Moment date formatted with the <kbd>'lll'</kbd> flag will appear like this:</p>
<pre>
Dec 25, 2016 12:01 AM 
</pre>
<p>There are different ways to format your dates with Moment, and I would encourage you to play around with the library to find a date format that works best for you.</p>
<p>Set <kbd>dateSelected</kbd> to <kbd>true</kbd> and add the Moment-formatted version of the date to state, which in turn fires the <kbd>render</kbd> method of this component again to update the <kbd>title</kbd> string passed into <kbd>ExpandableCell</kbd>:</p>
<pre>
  _onDateChange (date) { <br/>    this.setState({ <br/>      ... <br/>      dateSelected: true, <br/>      formattedDate: this._formatDate(date) <br/>    }); <br/>  } <br/>} 
</pre>
<p>By the end of this section, your app should look something like the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1426 image-border" height="277" src="assets/image_02_003-1.png" width="170"/></div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Using onLayout</h1>
            </header>

            <article>
                
<p>In our preceding example, we don't need to specify the height of the <kbd>DatePickerIOS</kbd> component when expanded. However, there may be scenarios in which you may need to manually get the dimensions of a component.</p>
<p>To calculate a component's height, we can utilize its <kbd>onLayout</kbd> property to fire a callback and then use that callback to save properties passed to the callback. The <kbd>onLayout</kbd> property is an event that is invoked on mount and layout changes, giving the event object a <kbd>nativeEvent</kbd> object that nests the component's layout properties. Using <kbd>DatePickerIOS</kbd> as an example, you can pass a callback to its <kbd>onLayout</kbd> prop like this:</p>
<pre>
&lt;DatePickerIOS <br/>  date={ this.state.date } <br/>  onDateChange={ (date) =&gt; this._onDateChange(date) } <br/>  onLayout={ (event) =&gt; this._getComponentDimensions(event) } <br/>  style={ styles.datePicker }  <br/>/&gt; 
</pre>
<p>The <kbd>event</kbd> from <kbd>onLayout</kbd> gives access to the following property:</p>
<pre>
event: { <br/>  nativeEvent: { <br/>    layout: { <br/>      x: //some number <br/>      y: //some number <br/>      width: //some number <br/>      height: //some number <br/>    } <br/>  } <br/>} 
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Button</h1>
            </header>

            <article>
                
<p>Let's build a <em>clear due date</em> button for the <kbd>EditTask</kbd> component and only selectively enable it if a due date has been selected for the to-do item. The <kbd>Button</kbd> component in React Native should help us render one quickly.</p>
<p>The <kbd>Button</kbd> component accepts a couple of props; the following four will be used in our application:</p>
<ul>
<li><kbd>color</kbd>: This is a string (or stringified hex) that sets either the text color on iOS or the background color on Android</li>
<li><kbd>disabled</kbd>: This is a Boolean that disables the button if set to <kbd>true</kbd>; it defaults to <kbd>false</kbd></li>
<li><kbd>onPress</kbd>: This is a callback that is fired when a button is pressed</li>
<li><kbd>title</kbd>: This is the text to display within the button</li>
</ul>
<p>A sample <kbd>Button</kbd> component can be rendered like this:</p>
<pre>
&lt;Button <br/>  color={ 'blue' } <br/>  disabled={ this.state.buttonDisabled } <br/>  onPress={ () =&gt; alert('Submit button pressed') } <br/>  title={ 'Submit' }  <br/>/&gt; 
</pre>
<p>Modify <kbd>EditTask</kbd> so that it has the following features:</p>
<ul>
<li>It contains a Boolean, titled <kbd>expanded</kbd>, in its state to control the open/closed status of the <kbd>ExpandableCell</kbd>.</li>
<li>It modifies the rendering of <kbd>ExpandableCell</kbd> to accept the <kbd>expanded</kbd> and <kbd>onPress</kbd> props. The <kbd>expanded</kbd> prop should point to the <kbd>expanded</kbd> Boolean in <kbd>EditTask's</kbd> state and the <kbd>onPress</kbd> prop should fire a method that flips the <kbd>expanded</kbd> Boolean.</li>
<li>Add an <kbd>onLayout</kbd> callback to <kbd>DatePickerIOS</kbd> to calculate its height, saving it to state.</li>
<li>Include a <kbd>Button</kbd> component with a <kbd>title</kbd> prop that prompts the user to clear the due date. Give it an <kbd>onPress</kbd> prop that will clear the <kbd>dateSelected</kbd> Boolean in state. Also, selectively disable it if the <kbd>dateSelected</kbd> Boolean is set to <kbd>false</kbd>.</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Clearing due date example</h1>
            </header>

            <article>
                
<p>Here's what I did to get the button to clear a selected date and expand/collapse our cells to play nicely:</p>
<pre>
// Tasks/app/components/EditTask/index.js <br/><br/>... <br/>import { <br/>  Button, <br/>  ... <br/>} from 'react-native'; <br/>... <br/>export default class EditTask extends Component { <br/>  constructor (props) { <br/>    ... <br/>    this.state = { <br/>      ... <br/>      expanded: false <br/>    } <br/>  } <br/><br/>  render () { <br/>    ... <br/>    return ( <br/>      &lt;View style={ styles.editTaskContainer }&gt; <br/>        &lt;View style={ [styles.expandableCellContainer,<br/>        { maxHeight: this.state.expanded ? <br/>        this.state.datePickerHeight : 40 }]}&gt; 
</pre>
<p>I wrapped a new <kbd>View</kbd> around <kbd>ExpandableCell</kbd>. Its styling is modified based on the expanded <kbd>Boolean</kbd> in the state of <kbd>EditTask</kbd>. If the component is expanded, then its <kbd>maxHeight</kbd> property is set to the height of its child component. Otherwise, it is set to <kbd>40</kbd> pixels.</p>
<p>Then, pass in the <kbd>expanded</kbd> and <kbd>onPress</kbd> props to this component:</p>
<pre>
          &lt;ExpandableCell <br/>            ... <br/>            expanded={ this.state.expanded } <br/>            onPress={ () =&gt; this._onExpand() } <br/>          &gt; 
</pre>
<p>Call <kbd>_getDatePickerHeight</kbd> during the <kbd>onLayout</kbd> event:</p>
<pre>
            &lt;DatePickerIOS <br/>              ... <br/>              onLayout={ (event) =&gt; this._getDatePickerHeight(event) } <br/>            /&gt; <br/>          &lt;/ExpandableCell&gt; <br/>        &lt;/View&gt;
</pre>
<p>The <kbd>Button</kbd> component is also encapsulated in its own <kbd>View</kbd>. This is so that the <kbd>Button</kbd> and <kbd>ExpandableCell</kbd> stack on top of each other:</p>
<pre>
        &lt;View style={ styles.clearDateButtonContainer }&gt; <br/>          &lt;Button <br/>            color={ '#B44743' } <br/>            disabled={ this.state.dateSelected ? false : true } <br/>            onPress={ () =&gt; this._clearDate() } <br/>            title={ 'Clear Date' } <br/>          /&gt; <br/>        &lt;/View&gt; <br/>      &lt;/View&gt; <br/>    ); <br/>  } 
</pre>
<p>Set the <kbd>dateSelected</kbd> Boolean in state to <kbd>false</kbd>, changing the <kbd>title</kbd> that <kbd>ExpandableCell</kbd> is passed:</p>
<pre>
  _clearDate () { <br/>    this.setState({ <br/>      dateSelected: false <br/>    }); <br/>  } 
</pre>
<p>This saves the width of the <kbd>DatePickerIOS</kbd> component to state:</p>
<pre>
  _getDatePickerHeight (event) { <br/>    this.setState({ <br/>      datePickerHeight: event.nativeEvent.layout.width <br/>    }); <br/>  } <br/><br/>  _onExpand () { <br/>    this.setState({ <br/>      expanded: !this.state.expanded <br/>    }); <br/>  } <br/>} 
</pre>
<p>I added a <kbd>clearDateButtonContainer</kbd> style to this component's <kbd>StyleSheet</kbd>:</p>
<pre>
// Tasks/app/components/EditTask/styles.js <br/><br/>import { Navigator, StyleSheet } from 'react-native'; <br/><br/>const styles = StyleSheet.create({ <br/>  ... <br/>  clearDateButtonContainer: { <br/>    flex: 1 <br/>  } <br/>}) <br/><br/>export default styles; 
</pre>
<p>Let's continue working on this and build a couple more features into this screen. Next up, we should have a field to edit the name of the task at the very top followed by a <kbd>Switch</kbd> component to toggle a complete or an incomplete state for the task.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Switch</h1>
            </header>

            <article>
                
<p>Switch is a component that renders a Boolean input and allows the user to toggle back and forth.</p>
<p>With <kbd>Switch</kbd>, these are the props that we will use:</p>
<ul>
<li><kbd>onValueChange</kbd>: This is a callback that is invoked with the new value of the switch when the value changes</li>
<li><kbd>value</kbd>: This is a Boolean that determines whether the switch is set to its 'on' position or not; it defaults to <kbd>false</kbd></li>
</ul>
<p>A simple <kbd>Switch</kbd> component can look like this:</p>
<pre>
&lt;Switch <br/>  onValueChange={ (value) =? this.setState({ toggled: value })} <br/>  value={ this.state.toggled } <br/>/&gt; 
</pre>
<p>As stated earlier, <kbd>Switch</kbd> has two props that are required: its <kbd>value</kbd> and a callback to change its value when toggled.</p>
<p>Using this knowledge, let's make changes to the <kbd>TasksList</kbd> component so that it passes the <kbd>completed</kbd>, <kbd>due</kbd>, <kbd>formattedDate</kbd>, and <kbd>text</kbd> properties of each row to the <kbd>EditTask</kbd> component for use.</p>
<p>Then, make additions to the <kbd>EditTask</kbd> component so that it:</p>
<ul>
<li>Expects the <kbd>completed</kbd>, <kbd>due</kbd>, <kbd>formattedDate</kbd>, and <kbd>text</kbd> props as part of its <kbd>propTypes</kbd> declaration.</li>
<li>Contains a <kbd>TextInput</kbd> field that is preloaded with the name of the to-do list item and allows the user to edit the name.</li>
<li>Adds a <kbd>Switch</kbd> component that is preloaded with the completion status of the to-do list item. When toggled, its completion status should change.</li>
</ul>
<p>This is the solution that I came up with:</p>
<pre>
// Tasks/app/components/TasksList/index.js <br/><br/>...  <br/>export default class TasksList extends Component { <br/>  ... <br/>  _editTask (rowData) { <br/>    this.props.navigator.push({ <br/>      ... <br/>      passProps: { <br/>        completed: rowData.completed, <br/>        due: rowData.due, <br/>        formattedDate: rowData.formattedDate, <br/>        text: rowData.text <br/>      }, <br/>      ... <br/>    }); <br/>  } <br/>  ... <br/>} 
</pre>
<p>Pass in the four required fields for <kbd>EditTask</kbd> so that the view has access to rendering a to-do list item's existing details. If the row does not contain one or more of these fields, it will pass in <kbd>undefined</kbd>.</p>
<p>Declare the four <kbd>propTypes</kbd> that this component expects. Since <kbd>completed</kbd> and <kbd>text</kbd> are the only two that are set when a to-do list item is created by the app, they are marked as the required props.</p>
<pre>
// Tasks/app/components/EditTask/index.js <br/><br/>import React, { Component, PropTypes } from 'react'; <br/>... <br/>import { <br/>  ... <br/>  Switch, <br/>  TextInput, <br/>  ... <br/>} from 'react-native'; <br/>... <br/>export default class EditTask extends Component { <br/>  static propTypes = { <br/>    completed: PropTypes.bool.isRequired, <br/>    due: PropTypes.string, <br/>    formattedDate: PropTypes.string, <br/>    text: PropTypes.string.isRequired <br/>  } 
</pre>
<pre>
  constructor (props) { <br/>    super (props); <br/><br/>    this.state = { <br/>      completed: this.props.completed, <br/>      date: new Date(this.props.due), <br/>      expanded: false, <br/>      text: this.props.text <br/>    } <br/>  } 
</pre>
<p>Using <kbd>props</kbd> in state is considered an anti-pattern, but we have them here for good reason since we will be modifying these as part of the component.</p>
<p>In the next section, we will also create a Save button that lets us save the to-do item's updated details, and so we need a locally available copy of that data in state to reflect the <kbd>EditTask</kbd> component's changes.</p>
<p>Render a <kbd>TextInput</kbd> component to handle changing a to-do list item's name:</p>
<pre>
  render () { <br/>    ... <br/>    return ( <br/>      &lt;View style={ styles.editTaskContainer }&gt; <br/>        &lt;View&gt; <br/>          &lt;TextInput <br/>            autoCorrect={ false } <br/>            onChangeText={ (text) =&gt; this._changeTextInputValue(text) } <br/>            returnKeyType={ 'done' } <br/>            style={ styles.textInput } <br/>            value={ this.state.text } <br/>          /&gt; <br/>        &lt;/View&gt; 
</pre>
<p>Render the <kbd>Switch</kbd> below <kbd>ExpandableCell</kbd> but above the clear due date <kbd>Button</kbd>:</p>
<pre>
        ... <br/>        &lt;View style={ styles.switchContainer } &gt; <br/>          &lt;Text style={ styles.switchText } &gt; <br/>            Completed <br/>          &lt;/Text&gt; <br/>          &lt;Switch <br/>            onValueChange={ (value) =&gt; this._onSwitchToggle(value) } <br/>            value={ this.state.completed } <br/>          /&gt; <br/>        &lt;/View&gt; <br/>        ... <br/>      &lt;/View&gt; <br/>    ); <br/>  } 
</pre>
<p>The following callback methods change the values of <kbd>TextInput</kbd> and <kbd>Switch</kbd>:</p>
<pre>
  _changeTextInputValue (text) { <br/>    this.setState({ <br/>      text <br/>    }); <br/>  } <br/>  ...  <br/>  _onSwitchToggle (completed) { <br/>    this.setState({ <br/>      completed <br/>    }); <br/>  } <br/>} 
</pre>
<p>A few styling additions for the new components:</p>
<pre>
// Tasks/app/components/EditTask/styles.js <br/><br/>import { Navigator, StyleSheet } from 'react-native'; <br/><br/>const styles = StyleSheet.create({ <br/>  ... <br/>  switchContainer: { <br/>    flex: 1, <br/>    flexDirection: 'row', <br/>    justifyContent: 'space-between', <br/>    maxHeight: 50, <br/>    padding: 10 <br/>  }, <br/>  switchText: { <br/>    fontSize: 16 <br/>  }, <br/>  textInput: { <br/>    borderColor: 'gray', <br/>    borderWidth: 1, <br/>    height: 40, <br/>    margin: 10, <br/>    padding: 10 <br/>  } <br/>}) <br/><br/>export default styles; 
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Save button</h1>
            </header>

            <article>
                
<p>In this section, we will create a button in the upper-right corner of the navigation bar that is labeled as <kbd>Save</kbd>. When it is tapped on, the following two things must happen:</p>
<ul>
<li>The changes the user made to the to-do item (such as its name, completion status, and due date) must be saved to <kbd>AsyncStorage</kbd>, overwriting its previous details</li>
<li>The <kbd>TasksList</kbd> must be updated so that the user visually sees the changes they made right away</li>
</ul>
<p>Rendering the <kbd>Save</kbd> button is easy with React Native. The object that gets pushed to <kbd>NavigatorIOS</kbd> needs to receive the following two key/value pairs:</p>
<ul>
<li><kbd>rightButtonTitle</kbd>: This is a string that renders the text shown in that area</li>
<li><kbd>onRightButtonPress</kbd>: This is a callback that is fired when that button is pressed</li>
</ul>
<p>At face value, this looks simple. However, we can't pass any information to the <kbd>onRightButtonPress</kbd> method of <kbd>NavigatorIOS</kbd> from a rendered child. Instead, we have to keep a copy of the changes we make inside our <kbd>TasksList</kbd> component as well, and update them as the <kbd>DatePickerIOS</kbd>, <kbd>TextInput</kbd>, and <kbd>Switch</kbd> components within <kbd>EditTask</kbd> are updated.</p>
<pre>
// Tasks/app/components/TasksList/index.js <br/><br/>... <br/>export default class TasksList extends Component { <br/>  constructor (props) { <br/>    ... <br/>    this.state = { <br/>      currentEditedTaskObject: undefined, <br/>      ... <br/>    }; <br/>  } <br/>  ... <br/>  _completeTask (rowID) { <br/>    const singleUpdatedTask = { <br/>      ...this.state.listOfTasks[rowID], <br/>      completed: !this.state.listOfTasks[rowID].completed <br/>    }; <br/><br/>    this._saveAndUpdateSelectedTask(singleUpdatedTask, rowID); <br/>  } 
</pre>
<p>This is no longer an asynchronous function. The part of the function that took advantage of <kbd>async</kbd>/<kbd>await</kbd> is broken off into <kbd>_saveAndUpdateSelectedTask</kbd>.</p>
<p>Set the currently edited task object to state:</p>
<pre>
  _editTask (rowData, rowID) { <br/>    this.setState({ <br/>      currentEditedTaskObject: rowData <br/>    }); 
</pre>
<p>Add an <kbd>onRightButtonPress</kbd> callback and string for the right button's title:</p>
<pre>
    this.props.navigator.push({ <br/>      ... <br/>      onRightButtonPress: () =&gt; this._saveCurrentEditedTask(rowID), <br/>      rightButtonTitle: 'Save', 
</pre>
<p>Pass in four new functions to <kbd>EditTask</kbd> that deal with the item's details:</p>
<pre>
      passProps: { <br/>        changeTaskCompletionStatus: (status) =&gt;<br/>        this._updateCurrentEditedTaskObject('completed', status), <br/>        changeTaskDueDate: (date, formattedDate) =&gt; <br/>        this._updateCurrentEditedTaskDueDate<br/>        (date, formattedDate), <br/>        changeTaskName: (name) =&gt; <br/>        this._updateCurrentEditedTaskObject('text', name), <br/>        clearTaskDueDate: () =&gt; <br/>        this._updateCurrentEditedTaskDueDate(undefined, undefined), <br/>      } <br/>    }); <br/>  } 
</pre>
<p>Add arguments for <kbd>_editTask</kbd> to accept:</p>
<pre>
  _renderRowData (rowData, rowID) { <br/>    return ( <br/>      &lt;TasksListCell <br/>        ... <br/>        onLongPress={ () =&gt; this._editTask(rowData, rowID) } <br/>        ... <br/>      /&gt; <br/>    ) <br/>  } 
</pre>
<p>This is the logic previously found in <kbd>componentDidMount</kbd>. It was broken into its own function since <kbd>_saveCurrentEditedTask</kbd> needs to call it:</p>
<pre>
  async _saveAndUpdateSelectedTask (newTaskObject, rowID) { <br/>    const listOfTasks = this.state.listOfTasks.slice(); <br/>    listOfTasks[rowID] = newTaskObject; <br/><br/>    await AsyncStorage.setItem('listOfTasks', <br/>    JSON.stringify(listOfTasks)); <br/><br/>    this._updateList(); <br/>  } 
</pre>
<p>To save the current edited task, we pass the object and <kbd>rowID</kbd> to <kbd>_saveAndUpdateSelectedtask</kbd>, and then call <kbd>pop</kbd> on the navigator:</p>
<pre>
_saveCurrentEditedTask (rowID) { <br/>this._saveAndUpdateSelectedTask(this.state.currentEditedTaskObject,<br/>rowID); <br/>  this.props.navigator.pop(); <br/>} 
</pre>
<p>This function updates the <kbd>date</kbd> and <kbd>formattedDate</kbd> of the current edited task object:</p>
<pre>
  _updateCurrentEditedTaskDueDate (date, formattedDate) { <br/>    this._updateCurrentEditedTaskObject ('due', date); <br/>    this._updateCurrentEditedTaskObject ('formattedDate', <br/>    formattedDate); <br/>  } 
</pre>
<p>The following function accepts a key and value, creates a clone of <kbd>currentEditedTaskObject</kbd> with the new value, and sets it in state:</p>
<pre>
  _updateCurrentEditedTaskObject (key, value) { <br/>    let newTaskObject = Object.assign({}, <br/>    this.state.currentEditedTaskObject); <br/><br/>    newTaskObject[key] = value; <br/><br/>    this.setState({ <br/>      currentEditedTaskObject: newTaskObject <br/>    }); <br/>  } <br/>  ... <br/>} 
</pre>
<p>The last two functions' purpose is to update the <kbd>TasksList</kbd> local state copy of the object being edited. This is done for two reasons:</p>
<ul>
<li>Any updates we make to <kbd>EditTask</kbd>, such as changing the name, completion status, and due date, currently do not propagate up to its parent</li>
<li>Additionally, we can't just point the values in <kbd>EditTask</kbd> to what gets passed in as props since the <kbd>EditTask</kbd> component does not rerender whenever the props being passed to it change</li>
</ul>
<p><kbd>EditTask</kbd> gets a couple of changes including new <kbd>propTypes</kbd> for the component to expect:</p>
<pre>
// Tasks/app/components/EditTask/index.js <br/><br/>... <br/>export default class EditTask extends Component { <br/>  static propTypes = { <br/>    changeTaskCompletionStatus: PropTypes.func.isRequired, <br/>    changeTaskDueDate: PropTypes.func.isRequired, <br/>    changeTaskName: PropTypes.func.isRequired, <br/>    clearTaskDueDate: PropTypes.func.isRequired, <br/>    ... <br/>  } 
</pre>
<p>The changes that <kbd>EditTask</kbd> receives involve calling the functions that are passed to it as props to update the parent component's data for saving:</p>
<pre>
  ... <br/>  render () { <br/>    ... <br/>        const dueDateSetTitle = 'Due On ' + <br/>        this.state.formattedDate || this.props.formattedDate;<br/>    ... <br/>  } <br/><br/>  _changeTextInputValue (text) { <br/>    ...  <br/>    this.props.changeTaskName(text); <br/>  } <br/><br/>  _clearDate () { <br/>    ...  <br/>    this.props.clearTaskDueDate(); <br/>  } <br/>  ... <br/>  _onDateChange (date) { <br/>    ...  <br/>    this.props.changeTaskDueDate(date, formattedDate); <br/>  } <br/>  ... <br/>  _onSwitchToggle (completed) { <br/>    ...  <br/>    this.props.changeTaskCompletionStatus(completed); <br/>  } <br/>} 
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">TasksListCell modifications</h1>
            </header>

            <article>
                
<p>Finally, we want to edit each row rendered by our <kbd>ListView</kbd> to display the due date, if one exists.</p>
<p>To do this, we will have to write some conditional logic to show the formatted date, if one is assigned to the to-do item we are rendering. This is also a good time to create a custom <kbd>styles</kbd> folder for this component as we will be needing it.</p>
<p>Spend some time creating your version of this feature. My solution is as follows:</p>
<pre>
// Tasks/app/components/TasksListCell/index.js <br/><br/>... <br/>import styles from './styles'; 
</pre>
<p>You might notice from the above import statement that <kbd>TasksListCell</kbd> now imports its <kbd>StyleSheet</kbd>.</p>
<p>Add <kbd>formattedDate</kbd> to <kbd>propTypes</kbd> as an optional string:</p>
<pre>
export default class TasksListCell extends Component { <br/>  static propTypes = { <br/>    ... <br/>    formattedDate: PropTypes.string, <br/>  } 
</pre>
<pre>
... <br/>  render () { <br/>    ... <br/>    return ( <br/>      &lt;View style={ styles.tasksListCellContainer }&gt; <br/>        &lt;TouchableHighlight <br/>          ... <br/>        &gt; <br/>          &lt;View style={ styles.tasksListCellTextRow }&gt; <br/>            &lt;Text style={ [styles.taskNameText, <br/>            { textDecorationLine: isCompleted }] }&gt; <br/>              { this.props.text } <br/>            &lt;/Text&gt;
</pre>
<p>Call <kbd>_getDueDate</kbd> to render a string for the due date, if it exists:</p>
<pre>
            &lt;Text style={ styles.dueDateText }&gt; <br/>              { this._getDueDate() } <br/>            &lt;/Text&gt; <br/>          &lt;/View&gt; <br/>        &lt;/TouchableHighlight&gt; <br/>      &lt;/View&gt; <br/>    ) <br/>  } 
</pre>
<pre>
_getDueDate () { <br/>    if (this.props.formattedDate &amp;&amp; !this.props.completed) { <br/>      return 'Due ' + this.props.formattedDate; <br/>    } <br/><br/>    return ''; <br/>  } <br/>} 
</pre>
<p>This component has been modified to support a second line of text to show a due date, but only if it exists.</p>
<p>The logic is set to only display the due date should the task not be marked as completed, so that a user won't be confused if they see a due date on a task they've already checked off.</p>
<p>Additionally, styling's been added to make the two lines appear on the same row:</p>
<pre>
// Tasks/app/components/TasksListCell/styles.js <br/><br/>import { StyleSheet } from 'react-native'; <br/><br/>const styles = StyleSheet.create({ <br/>  dueDateText: { <br/>    color: 'red', <br/>    flex: 1, <br/>    fontSize: 12, <br/>    paddingTop: 0, <br/>    textAlign: 'right' <br/>  }, <br/>  taskNameText: { <br/>    fontSize: 20 <br/>  }, <br/>  tasksListCellContainer: { <br/>    flex: 1 <br/>  }, <br/>  tasksListCellTextRow: { <br/>    flex: 1 <br/>  } <br/>}); <br/><br/>export default styles;  
</pre>
<p>Here's a screenshot of how this looks:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1429 image-border" height="289" src="assets/image_02_005-1.png" width="156"/></div>
<p>This is a pretty neat application at this point, and you will be able to make more enhancements to it with the skills you'll pick up in our next project. As we wind down this project, I want to turn your attention to a question I often receive:</p>
<div class="packt_infobox"><span class="packt_screen">How would we do it on Android?</span><br/>
It's a great question and one that we will explore at the end of each project in this book. I will assume that you have already set up your development environment to work on Android apps in React Native. If not, go do that before proceeding further. If developing for Android is not of any interest to you, feel free to skip this portion and move on to the next chapter!</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Modifying tasks for Android</h1>
            </header>

            <article>
                
<p>First, we need to point to the Android SDK directory in our app's <kbd>Android</kbd> folder under a new <kbd>local.properties</kbd> file that you will create. Add the following line, where <kbd>USERNAME</kbd> is your machine's username:</p>
<pre>
// Tasks/android/local.properties <br/><br/>sdk.dir = /Users/USERNAME/Library/Android/sdk 
</pre>
<div class="packt_tip">If your Android SDK is installed in a different location from the preceding example, you will need to modify this file to point to the right place.</div>
<p>Then, launch an <strong>Android Virtual Device</strong> (<strong>AVD</strong>) and execute the <kbd>react-native run-android</kbd> command in your project's root folder. You will see the following screen, which looks just like the default template when we first built <kbd>Tasks</kbd> for iOS:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1430 image-border" height="358" src="assets/image_02_006-1.png" width="207"/></div>
<div class="packt_tip">When working in Android, press <kbd>RR</kbd> to reload the app and <em>Command</em> + <em>M</em> to enter the Developer menu.<br/>
You may find that, with remote JS debugging turned on, animations from simple things, such as <kbd>TouchableHighlight</kbd> shadows and navigation, can be painfully slow. At the time of writing, some technical solutions are being proposed to address this issue but, for the time being, it's strongly recommended that you enable and disable remote JS debugging as necessary.</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Navigator</h1>
            </header>

            <article>
                
<p>The <kbd>Navigator</kbd> component works a bit differently from its native iOS component, but it's still very powerful to work with. One of the changes with using <kbd>Navigator</kbd> is that your routes should be explicitly defined. We can do this by setting up an array of routes and rendering a specific scene based on which route we're accessing. Here's a sample:</p>
<pre>
export default class Tasks extends Component { <br/>  render () { <br/>    const routes = [ <br/>      { title: 'First Component', index: 0 }, <br/>      { title: 'Second Component', index: 1 } <br/>    ]; 
</pre>
<p>Create a <kbd>routes</kbd> array, as shown in the preceding code.</p>
<p>You might notice that we are explicitly defining our routes from the beginning, setting up an initial route and then passing in props to each route's component here:</p>
<pre>
    return ( <br/>      &lt;Navigator <br/>        initialRoute={{ index: 0 }} <br/>        renderScene={ (routes, navigator) =&gt; <br/>        this._renderScene(routes, navigator) } /&gt; <br/>    ) <br/>  } 
</pre>
<p>The route object passed in to <kbd>_renderScene</kbd> contains a <kbd>passProps</kbd> object, which we can set when pushing the navigator.</p>
<p>Instead of passing our component when pushing into the <kbd>Navigator</kbd>, we pass it an <kbd>index</kbd>; this is where the <kbd>_renderScene</kbd> method of <kbd>Navigator</kbd> identifies which scene to show the user. Here is how pushing to the <kbd>Navigator</kbd> looks:</p>
<pre>
    _renderScene (route, navigator) { <br/>      if (route.index === 0) { <br/>        return ( <br/>          &lt;FirstComponent <br/>            title={ route.title } <br/>            navigator={ navigator } /&gt; <br/>        ) <br/>    } <br/><br/>    if (route.index === 1) { <br/>      return ( <br/>        &lt;SecondComponent <br/>         navigator={ navigator } <br/>         details={ route.passProps.details } /&gt; <br/>      ) <br/>    } <br/>  } <br/>} 
</pre>
<p>This is how we would use the Navigator component to push different routes. Notice that instead of passing a component like in in <kbd>NavigatorIOS</kbd>, we are passing the index of the route:</p>
<pre>
  _renderAndroidNavigatorView () { <br/>    this.props.navigator.push({ <br/>      index: 1, <br/>      passProps: { <br/>        greeting: 'Hello World' <br/>      } <br/>    }); <br/>  } 
</pre>
<p>If you're comparing this to how we rendered <kbd>EditTask</kbd> in iOS, you'll note that we're not setting up our navigation bar at all. Android apps typically handle navigation through a combination of <kbd>Drawer</kbd> and <kbd>ToolbarAndroid</kbd> components that we will address in a later project. This will help our app by making it look and feel the way any Android app should.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Navigator example</h1>
            </header>

            <article>
                
<p>The following code is an example for Navigator:</p>
<pre>
// index.android.js<br/><br/>import React, { Component } from 'react'; <br/>import { <br/>  AppRegistry, <br/>  Navigator, <br/>} from 'react-native'; <br/><br/>import TasksList from './app/components/TasksList'; <br/>import EditTask from './app/components/EditTask'; <br/><br/>class Tasks extends Component { <br/><br/>  render () { <br/>    const routes = [ <br/>      { title: 'Tasks', index: 0 }, <br/>      { title: 'Edit Task', index: 1 } <br/>    ]; 
</pre>
<p>Again, establish routes for our app.</p>
<pre>
    return ( <br/>      &lt;Navigator <br/>        initialRoute={{ index: 0}} <br/>        renderScene={ (routes, navigator) =&gt;<br/>        this._renderScene(routes, navigator) }/&gt; <br/>    ); <br/>  } 
</pre>
<p>Import the <kbd>Navigator</kbd> component and render it for the user. It starts at <kbd>index:</kbd><kbd>0</kbd>, which returns the <kbd>TasksList</kbd> component.</p>
<p>It returns <kbd>TasksList</kbd> if the index is <kbd>0</kbd>. This is the default <kbd>route</kbd>:</p>
<pre>
  _renderScene (route, navigator) { <br/>    if (route.index === 0) { <br/>      return ( <br/>        &lt;TasksList <br/>          title={ route.title } <br/>          navigator={ navigator } /&gt; <br/>      ) <br/>    } 
</pre>
<p>If the route index is 1, return <kbd>EditTask</kbd>. It will receive the aforementioned props via the <kbd>passProps</kbd> method:</p>
<pre>
    if (route.index === 1) { <br/>      return ( <br/>        &lt;EditTask <br/>          navigator={ navigator } <br/>          route={ route } <br/>          changeTaskCompletionStatus={ <br/>          route.passProps.changeTaskCompletionStatus } <br/>          changeTaskDueDate={ route.passProps.changeTaskDueDate } <br/>          changeTaskName={ route.passProps.changeTaskName } <br/>          completed={ route.passProps.completed } <br/>          due={ route.passProps.due } <br/>          formattedDate={ route.passProps.formattedDate } <br/>          text={ route.passProps.text } <br/>        /&gt; <br/>      ) <br/>    } <br/>  } <br/>} 
</pre>
<pre>
AppRegistry.registerComponent('Tasks', () =&gt; Tasks); 
</pre>
<p>At this stage, without making further modifications, we can create new to-do items and mark them as completed. However, because the <kbd>Navigator</kbd> component's push method accepts different arguments than the push method of iOS, we will need to create some conditional logic in the <kbd>TasksList</kbd> file to accommodate it.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Platform</h1>
            </header>

            <article>
                
<p>When your files have such little variance in the differences between their iOS and Android functionalities, it's okay to use the same file. Utilizing the <kbd>Platform</kbd> API, we can identify the type of mobile device the user is on and conditionally send them down a specific path.</p>
<p>Import the <kbd>Platform</kbd> API along with the rest of your React Native components:</p>
<pre>
import { Platform } from 'react-native';  
</pre>
<p>Then call its <kbd>OS</kbd> property within a component:</p>
<pre>
  _platformConditional () { <br/>    if (Platform.OS === 'ios') { <br/>      doSomething(); <br/>    } <br/><br/>    if (Platform.OS === 'android') { <br/>      doSomethingElse(); <br/>    } <br/>  } 
</pre>
<p>This lets us control the path our app takes and allows for a little bit of code reuse.</p>
<div class="packt_tip"><span class="packt_screen">Android-specific files</span> <strong><br/></strong>If we need to create a file that is supposed to only run on Android devices, simply name it <kbd>&lt;FILENAME&gt;.android.js</kbd>, just like the two index files. React Native will know exactly which file to build with, and this lets us create components that are platform-specific when we need to add a lot of logic that one universal <kbd>index.js</kbd> file shouldn't handle. Name files <kbd>&lt;FILENAME&gt;.ios.js</kbd> to set iOS-specific files too.</div>
<p>Using the <kbd>Platform</kbd> API, we can create conditional logic to decide how the <kbd>Navigator</kbd> should push the next component depending on the user's platform. Import the <kbd>Platform</kbd> API:</p>
<pre>
// Tasks/app/components/TasksList/index.js <br/><br/>... <br/>import { <br/>  ... <br/>  Platform, <br/>  ... <br/>} from 'react-native'; 
</pre>
<p>Modify the styling of <kbd>TextInput</kbd> based on the user's platform so that it has a design language that resonates with its platform. On Android, it is usually displayed as a single underline without any border; so, we eliminate the border in the Android-specific styling of this component:</p>
<pre>
... <br/>export default class TasksList extends Component { <br/>  ... <br/>  render () { <br/>  ... <br/>    return ( <br/>      &lt;View style={ styles.container }&gt; <br/>        &lt;TextInput <br/>          ... <br/>          style={ Platform.os === 'IOS' ? styles.textInput :<br/>          styles.androidTextInput } <br/>          ... <br/>        /&gt; <br/>        ... <br/>      &lt;/View&gt; <br/>    ); <br/>  } 
</pre>
<p>I changed the <kbd>_editTask</kbd> function to run conditional logic. If our platform is iOS, we call <kbd>_renderIOSEditTaskComponent</kbd>; otherwise, our platform must be Android and we call <kbd>_renderAndroidEditTaskComponent</kbd> instead:</p>
<pre>
  _editTask (rowData, rowID) { <br/>    ...  <br/>    if (Platform.OS === 'ios') { <br/>      return this._renderIOSEditTaskComponent(rowID); <br/>    } <br/><br/>    return this._renderAndroidEditTaskComponent(rowID); <br/>  } 
</pre>
<pre>
  _renderAndroidEditTaskComponent (rowID) { <br/>    this.props.navigator.push({ <br/>      index: 1, <br/>      passProps: { <br/>        changeTaskCompletionStatus: (status) =&gt; <br/>        this._updateCurrentEditedTaskObject('completed', status), <br/>        changeTaskDueDate: (date, formattedDate) =&gt;<br/>        this._updateCurrentEditedTaskDueDate(date, formattedDate), <br/>        changeTaskName: (name) =&gt; <br/>        this._updateCurrentEditedTaskObject('text', name), <br/>        clearTaskDueDate: () =&gt; <br/>        this._updateCurrentEditedTaskDueDate(undefined, undefined), <br/>        completed: this.state.currentEditedTaskObject.completed, <br/>        due: this.state.currentEditedTaskObject.due, <br/>        formattedDate: <br/>        this.state.currentEditedTaskObject.formattedDate, <br/>        text: this.state.currentEditedTaskObject.text <br/>      } <br/>    }) <br/>  } 
</pre>
<p>The preceding code pushes the <kbd>index</kbd> of <kbd>EditTask</kbd> to the Navigator. It passes the same props that the iOS version of the app previously passed.</p>
<p>The contents of <kbd>_renderIOSEditTaskComponent</kbd> are the same as those that <kbd>_editTask</kbd> previously contained:</p>
<pre>
  _renderIOSEditTaskComponent (rowID) { <br/>    this.props.navigator.push({ <br/>      ... <br/>    }); <br/>  } <br/>  ... <br/>} 
</pre>
<p>In the following code we added a custom Android style for <kbd>TextInput</kbd>, omitting the border:</p>
<pre>
// Tasks/app/components/EditTask/styles.js <br/><br/>... <br/>const styles = StyleSheet.create({ <br/>  androidTextInput: { <br/>    height: 40, <br/>    margin: 10, <br/>    padding: 10 <br/>  }, <br/>  ... <br/>}); 
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">DatePickerAndroid and TimePickerAndroid</h1>
            </header>

            <article>
                
<p>Setting a time and date on Android is much different from iOS. With iOS, you have a <kbd>DatePickerIOS</kbd> component that includes both the date and time. On Android, this is split into two native modals, <kbd>DatePickerAndroid</kbd> for the date and <kbd>TimePickerAndroid</kbd> for the time. It's not a component to render either, it's an asynchronous function that opens the modal and waits for a natural conclusion before applying logic to it.</p>
<p>To open one of these, wrap an asynchronous function around it:</p>
<pre>
async renderDatePicker () { <br/>  const { action, year, month, day } = await DatePickerAndroid.open({ <br/>    date: new Date() <br/>  }); <br/><br/>  if (action === DatePickerAndroid.dismissedAction) { <br/>    return; <br/>  } <br/><br/>  // do something with the year, month, and day here <br/>} 
</pre>
<p>Both the <kbd>DatePickerAndroid</kbd> and <kbd>TimePickerAndroid</kbd> components return an object, and we can grab the properties of each object by using ES6 destructuring assignment, as shown in the preceding snippet.</p>
<p>As these components will render as modals by default, we also don't have any use for the <kbd>ExpandableCell</kbd> component that we built for the iOS version of the app. To implement Android-specific date and time pickers, we should create an Android-specific <kbd>EditTask</kbd> component to handle it.</p>
<p>Rather than an expanding cell, we should create another <kbd>Button</kbd> component to open and close the dialog boxes.</p>
<p>In the example given in the following section, I cloned the iOS <kbd>index.js</kbd> file for <kbd>EditTask</kbd> and renamed it <kbd>index.android.js</kbd> before making changes to it. Any code that has not changed from the iOS version has been omitted. Anything that has been deleted has also been noted.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">DatePickerAndroid and TimePickerAndroid example</h1>
            </header>

            <article>
                
<p>Remove <kbd>DatePickerIOS</kbd> and <kbd>ExpandableCell</kbd> from the import statements:</p>
<pre>
// Tasks/app/components/EditTask/index.android.js <br/><br/>... <br/>import { <br/>  ... <br/>  DatePickerAndroid, <br/>  TimePickerAndroid, <br/>} from 'react-native'; <br/>... 
</pre>
<p>I removed the <kbd>expanded</kbd> Boolean from state in this component's <kbd>constructor</kbd> function:</p>
<pre>
export default class EditTask extends Component { <br/>  ... 
</pre>
<p>This new <kbd>Button</kbd> for <kbd>DatePicker</kbd> calls <kbd>_showAndroidDatePicker</kbd> when pressed. It is placed right below <kbd>TextInput</kbd> and replaces <kbd>ExpandableCell</kbd>:</p>
<pre>
  render () { <br/>    ... <br/>    return ( <br/>      &lt;View style={ styles.editTaskContainer }&gt; <br/>        ... <br/>        &lt;View style={ styles.androidButtonContainer }&gt; <br/>          &lt;Button <br/>            color={ '#80B546' } <br/>            title={ this.state.dateSelected ? dueDateSetTitle : <br/>            noDueDateTitle } <br/>            onPress={ () =&gt; this._showAndroidDatePicker() } <br/>          /&gt; <br/>        &lt;/View&gt; 
</pre>
<p>There have been no changes to the clear due date <kbd>Button</kbd>, but its styling has changed:</p>
<pre>
        &lt;View style={ styles.androidButtonContainer }&gt; 
</pre>
<pre>
        &lt;/View&gt; <br/>      &lt;/View&gt; <br/>    ); <br/>  }
</pre>
<p>An asynchronous function that calls <kbd>open</kbd> on <kbd>DatePickerAndroid</kbd> extracts the <kbd>action</kbd>, <kbd>year</kbd>, <kbd>month</kbd>, and <kbd>day</kbd>, sets them to state, and then calls <kbd>_showAndroidTimePicker</kbd>:</p>
<pre>
  async _showAndroidDatePicker () { <br/>    const options = { <br/>      date: this.state.date <br/>    }; <br/><br/>    const { action, year, month, day } = await <br/>    DatePickerAndroid.open(options); <br/><br/>    if (action === DatePickerAndroid.dismissedAction) { <br/>      return; <br/>    } <br/><br/>    this.setState({ <br/>      day, <br/>      month, <br/>      year <br/>    }); <br/><br/>    this._showAndroidTimePicker(); <br/>  } 
</pre>
<p>The following is the same strategy we used with <kbd>_showAndroidDatePicker</kbd> before, but calls <kbd>_onDateChange</kbd> at the end:</p>
<pre>
  async _showAndroidTimePicker () { <br/>    const { action, minute, hour } = await TimePickerAndroid.open(); <br/><br/>    if (action === TimePickerAndroid.dismissedAction) { <br/>      return; <br/>    } <br/><br/>    this.setState({ <br/>      hour, <br/>      minute <br/>    }); <br/><br/>    this._onDateChange(); <br/>  } 
</pre>
<p>Create a new instance of the <kbd>Date</kbd> object using the five combined values that <kbd>DatePickerAndroid</kbd> and <kbd>TimePickerAndroid</kbd> return:</p>
<pre>
  ... <br/>  _onDateChange () { <br/>    const date = new Date(this.state.year, this.state.month, <br/>    this.state.day, this.state.hour, this.state.minute); <br/>    ... <br/>  }<br/>  ... <br/>} 
</pre>
<p>I removed <kbd>_getDatePickerHeight</kbd> and <kbd>_onExpand</kbd> since they pertain to parts of <kbd>EditTask</kbd> that are not available in the <kbd>Android</kbd> version of the app. I added some styling changes to this component as well:</p>
<pre>
// Tasks/app/components/EditTask/styles.js <br/><br/>... <br/>const styles = StyleSheet.create({ <br/>  androidButtonContainer: { <br/>    flex: 1, <br/>    maxHeight: 60, <br/>    margin: 10 <br/>  }, <br/>  ... <br/>  textInput: { <br/>    height: 40, <br/>    margin: 10, <br/>    padding: 10 <br/>  } <br/>}); 
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Saving updates</h1>
            </header>

            <article>
                
<p>As we aren't using a navigation bar with the Android version of the app, we should create a Save button that handles the same save logic.</p>
<p>First, we should modify <kbd>index.android.js</kbd> to pass a <kbd>saveCurrentEditedTask</kbd> prop to <kbd>EditTask</kbd> from the <kbd>TasksList</kbd> component:</p>
<pre>
// index.android.js<br/><br/>... <br/>class Tasks extends Component { <br/>  ... <br/>  _renderScene (route, navigator) { <br/>    ... <br/>    if (route.index === 1) { <br/>      return ( <br/>        &lt;EditTask <br/>          ... <br/>          saveCurrentEditedTask={ route.passProps<br/>          .saveCurrentEditedTask } <br/>          ... <br/>        /&gt; <br/>      ) <br/>    } <br/>  } <br/>} 
</pre>
<p>Then, modify <kbd>TasksList</kbd> to pass the <kbd>_saveCurrentEditedTask</kbd> method to <kbd>EditTask</kbd> in <kbd>_renderAndroidEditTaskComponent</kbd>:</p>
<pre>
// Tasks/app/components/TasksList/index.js <br/><br/>... <br/>export default class TasksList extends Component { <br/>  ... <br/>  _renderAndroidEditTaskComponent (rowID) { <br/>    this.props.navigator.push({ <br/>      ... <br/>      passProps: { <br/>        ... <br/>        saveCurrentEditedTask: () =&gt; <br/>        this._saveCurrentEditedTask(rowID), <br/>        ... <br/>      } <br/>    }) <br/>  } <br/>  ... <br/>} 
</pre>
<p>After this, modify the Android version of <kbd>EditTask</kbd> to contain a new <kbd>Button</kbd> that calls its <kbd>saveCurrentEditedTask</kbd> when pressed:</p>
<pre>
// Tasks/app/components/EditTask/index.android.js <br/><br/>... <br/>export default class EditTask extends Component { <br/>  static propTypes = { <br/>    ... <br/>    saveCurrentEditedTask: PropTypes.func.isRequired, <br/>    ... <br/>  } <br/><br/>  render () { <br/>    ... <br/>    return ( <br/>      &lt;View style={ styles.editTaskContainer }&gt; <br/>        ... <br/>        &lt;View style={ styles.saveButton }&gt; <br/>          &lt;Button <br/>            color={ '#4E92B5' } <br/>            onPress={ () =&gt; this.props.saveCurrentEditedTask() } <br/>            title={ 'Save Task' } <br/>          /&gt; <br/>        &lt;/View&gt; <br/>      &lt;/View&gt; <br/>    ); <br/>  } <br/>  ... <br/>} 
</pre>
<p>Finally, add some styling with a new <kbd>saveButton</kbd> property:</p>
<pre>
// Tasks/app/components/EditTask/styles.js <br/><br/>import { Navigator, StyleSheet } from 'react-native'; <br/><br/>const styles = StyleSheet.create({ <br/>  ... <br/>  saveButton: { <br/>    flex: 1, <br/>    marginTop: 20, <br/>    maxHeight: 70, <br/>  }, <br/>  ... <br/>}); 
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">BackAndroid</h1>
            </header>

            <article>
                
<p>The last thing we need to handle is the back button. A universal back button, either a hardware or software implementation, is found on each Android device. We will need to use the <kbd>BackAndroid</kbd> API to detect back button presses and set our own custom functionality. If we don't do this, the back button will automatically close the app each time it is pressed.</p>
<p>To use it, we can add an event listener during the <kbd>componentWillMount</kbd> life cycle event that will pop the navigator when a back button press is detected. We can also remove the listener when the component is unmounted.</p>
<p>During <kbd>componentWillMount</kbd>, add an event listener to the <kbd>BackAndroid</kbd> API for a <kbd>hardwareButtonPress</kbd> event, firing <kbd>_backButtonPress</kbd> when triggered:</p>
<pre>
// Tasks/app/components/EditTask/index.android.js <br/><br/>... <br/>import { <br/>  BackAndroid, <br/>  ... <br/>} from 'react-native'; <br/>... <br/>export default class EditTask extends Component { <br/>  ... <br/>  componentWillMount () { <br/>    BackAndroid.addEventListener('hardwareButtonPress', () =&gt; <br/>    this._backButtonPress()); <br/>  } 
</pre>
<p>Remove the same listener if the component is unmounted:</p>
<pre>
  componentWillUnmount () { <br/>    BackAndroid.removeEventListener('hardwareButtonPress', () =&gt; <br/>    this._backButtonPress()) <br/>  } 
</pre>
<p>Call <kbd>pop</kbd> on the navigator with <kbd>_backButtonPress</kbd>:</p>
<pre>
  ... <br/>  _backButtonPress () { <br/>    this.props.navigator.pop(); <br/>    return true; <br/>  } <br/>  ... <br/>} 
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Summary</h1>
            </header>

            <article>
                
<p>This was a long chapter! We accomplished a lot of things. First, we used <kbd>NavigatorIOS</kbd> to establish custom routes and created a component to edit a to-do item's details, including marking it as completed and adding a due date.</p>
<p>Then, we built a custom, reusable component with fluid animations to expand and collapse a child component, allowing <kbd>DatePickerIOS</kbd> to expand and collapse as needed. Afterward, we implemented logic to save the changes we make to a task using the navigation bar.</p>
<p>We also ported our app to support the Android operating system! We started by swapping out <kbd>NavigatorIOS</kbd> for <kbd>Navigator</kbd>, using the <kbd>Platform</kbd> API to trigger conditional logic depending on the type of mobile device our user is on, and creating iOS-and Android-specific components by appending <kbd>.android</kbd> and <kbd>.ios</kbd> to each index file.</p>
<p>We finished up the port to Android by rendering date and time pickers on Android, which are two separate popups, and creating a save button within our Android-specific <kbd>EditTask</kbd> component so that our users can save the changes they made. Finally, listening for back button presses with the <kbd>BackAndroid</kbd> API allowed our users to go back from editing a to-do item to the to-do list screen instead of leaving the app entirely.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </body></html>