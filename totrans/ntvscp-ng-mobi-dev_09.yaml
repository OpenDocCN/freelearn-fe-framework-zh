- en: Empowering Your Views
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The combination of Angular and NativeScript is fun to develop with and powerful
    beyond measure for mobile development. Whether you need to provide services to
    engage with a mobile device's hardware capabilities, such as audio recording or
    enrich your app's usability with engaging views, NativeScript for Angular provides
    exciting opportunities.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue with several concepts we developed in the preceding chapter to
    provide an alternate rich view of our tracks while reusing everything we've covered
    so far, in addition to a few new tips/tricks.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Using multiple item row templates with `ListView` and `templateSelector`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling row template changes with `ListView` and when/how to refresh them
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `ngModel` data binding via `NativeScriptFormsModule`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging a shared singleton service for sharing state across multiple modules
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serializing data before storing and hydrating upon retrieval from a persisted
    state
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging and reusing Angular directives to enrich the NativeScript Slider
    with more unique characteristics
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple item templates with NativeScript's ListView
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All throughout [Chapter 8](part0101.html#30A8Q0-289fe2426d594f99a90e4363b2c9c34d),
    *Building an audio recorder*, we designed a dual-purpose custom NativeScript Waveform
    view, which taps into various native libraries for iOS and Android, specifically
    to enrich our composition's track listing view. Let's proceed by reusing our versatile
    Waveform view for our track listing view. This will also give us a way to display
    mixing slider controls (often referred to in audio production and sound engineering
    as a Fader) alongside our tracks to allow the user to mix each track's volume
    level in the overall composition. Let's set up our `ListView` of `TrackListComponent` with
    the ability to provide the user with two different ways to view and work with
    their tracks, each with their own unique utility. While we're at it, we'll also
    take this opportunity to finally wire up the `mute` switch on our tracks.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make the following modifications to `app/modules/player/components/track-list/track-list.component.html`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There''s a lot of interesting things happening here. First of all, `[itemTemplateSelector]="templateSelector"`
    provides the ability to change our `ListView` item rows on the fly. The result
    of the `templateSelector` function should be a string, which matches the value
    provided on any ng-template''s `ngTemplateKey` attribute. To make all this work,
    we will need several things in place, starting with the `Component` that has access
    to the `ListView` via `#listview` and `ViewChild`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We set up a `ViewChild` to retain a reference to our `ListView` which we will
    use later to call `this._listview.refresh()` . This is required in Angular when
    we need the `ListView` to update the display after changes. The first surprise
    will likely be the injection of `PlayerService`, and the second might be the `this.templateSelector
    = this._templateSelector.bind(this)`. The `templateSelector` binding is not scope
    bound, and since we need it to return a property reference from our `this.playerService`
    on the `Component`, we ensure that it is properly bound to the scope of the `Component` by
    binding a `Function` reference. We will use `PlayerService` as a conduit at this
    point to help communicate the state from the `ActionBarComponent` that lives in
    the `MixerModule`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: This example shows how services can help communicate the state throughout your
    app. However, this practice can be greatly improved by utilizing `ngrx` to help
    lessen interwoven dependencies and unlock a purely reactive setup with Redux-style
    architecture. @ngrx enhancements will be covered in [Chapter 10](part0121.html#3JCK20-289fe2426d594f99a90e4363b2c9c34d),
    *@ngrx/store + @ngrx/effects for State Management*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Our View Toggle button will be in the `ActionBar` (in the `MixerModule`), and
    we will want to tap there to switch our `ListView`, which lives inside our `PlayerModule`.
    The `PlayerService` is a singleton at the moment (provided by `CoreModule`) and
    is shared across the entire app, so it''s a perfect candidate to aid here. Let''s
    take a look at our `ActionBarComponent` changes first in `app/modules/mixer/components/action-bar/action-bar.component.ios.html`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, we''ll take a look at the changes in `app/modules/mixer/components/action-bar/action-bar.component.android.html`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We''ll also take a look at the changes in the `Component`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you can see, we added a button to the `ActionBar`, which will use the label
    `Waveform` or `Default`, depending on its state. Then, we used `PlayerService`
    to modify a new setter, `**this.playerService.trackListViewType** **=** **type**`.
    Let''s take a look at `app/modules/player/services/player.service.ts` now:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This gets the job done**.**
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, we will improve this setup in the next chapter with ngrx, which
    is all about polishing and simplifying the way we handle our app's state.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple more things that we will need to do to ensure that all our
    new additions work. For starters, the `[(ngModel)]` bindings will *not* work at
    all without the `NativeScriptFormsModule`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: If you use the `ngModel` bindings in your component's view, you must ensure
    that the module that declares your `Component` imports the `NativeScriptFormsModule`.
    If it uses a `SharedModule`, ensure that the `SharedModule` imports and exports
    the `NativeScriptFormsModule`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the module mentioned in the preceding tip to our `SharedModule`
    so that all of our modules can use `ngModel` wherever needed:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We will now need each track''s mute and volume property changes to notify our
    audio player. This involves changing our `TrackModel` slightly to account for
    this new functionality; to do that, open `app/modules/shared/models/track.model.ts`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We now want to modify our `TrackPlayerModel` to work in tandem with these new
    features. Earlier, we used to retain just the `trackId`; however, with this new
    addition, it would be helpful to keep a reference to the entire `TrackModel` object,
    so open `app/modules/shared/models/track-player.model.ts` and make the following
    changes:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Our audio player can now react to volume changes made via data binding from
    each track by observing the `volume$` subject observable. Since mute essentially
    just requires the modification of the player's volume, we ensure that we update
    the volume accordingly and maintain the original volume if toggling mute on/off,
    so any custom volume set will be retained.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Our new enriched view of our tracks includes our reusable Waveform view but
    this time with `type="file"`, since this will engage the audio file static Waveform
    to be rendered so that we can *see* our audio. We also provide the ability to
    adjust each track's volume (mixing control) and float a label off to the top-left
    corner so that the user still knows what is what. This is all done by utilizing
    an `AbsoluteLayout` container, which allows us to overlap components and manually
    position them on top of each other.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Serializing data for persistence and hydrating it back upon retrieval
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This all works really nicely, however, we have introduced a problem. Our `MixerService`
    provides the ability to save these compositions with all their tracks. However
    the tracks now contain complex objects such as Observables and even private references
    with getters and setters.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: When persisting data, you will often want to use `JSON.stringify` to serialize
    objects when storing them so that they can be retrieved later and hydrated into
    more complex models if needed.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, if you were to attempt to process our `TrackModel` with `JSON.stringify`
    now, it would fail because you cannot stringify certain structures. So, we now
    need a way to serialize our data before storing it, as well as a way to hydrate
    that data when retrieving to restore our more sophisticated models. Let''s make
    a few changes to our `MixerService` to account for this. Open `app/modules/mixer/services/mixer.service.ts`and
    make the following changes:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We will now ensure that any time our composition is saved, it's properly serialized
    into a safe and more simplified form, which can be processed by `JSON.stringify`.
    Then, when retrieving data out of our persistent store (in this case, via NativeScript's
    application-settings module being used under the hood of our `DatabaseService`;
    this is covered in [Chapter 2](part0037.html#1394Q0-289fe2426d594f99a90e4363b2c9c34d),
    *Feature Modules*, we hydrate the data back into our models, which will enrich
    the data with our observable properties.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging Angular directives to enrich the NativeScript Slider with more unique
    characteristics
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For each track fader (also known as our mixing/volume control), it''d be nice
    to actually render a fader-looking control knob so that it''s clear that these
    Sliders are mixing knobs and are not mistaken for shuttling playback of that track,
    for instance. We can create a graphic to be used for these Sliders, which will
    look like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00042.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
- en: 'For iOS, we will also want a down/highlighted state, so usability feels good
    when the user presses down on the fader:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00043.jpeg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
- en: 'We can now create two versions of each of these files and drop them in `app/App_Resources/iOS`;
    the original will be 100x48 for standard resolution, then for iPhone Plus and
    above, we will have a @3x version at 150x72 (basically, 24 plus the standard 48
    height):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '`fader-down.png`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fader-down@3x.png`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fader.png`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fader@3x.png`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can now reuse our `SlimSliderDirective` (currently being used to customize
    the look of the shuttle slider) and provide an input so that we can provide the
    name of a file from our app's resources to use for the thumb.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `app/modules/player/directives/slider.directive.ios.ts` and make the following
    modifications:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This allows us to specify the filename to be used as the `Slider` thumb on
    the component itself:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With this in place, we now have these neat fader controls for iOS when the
    track mixing view toggle is engaged:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00044.jpeg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
- en: Graphic and resource handling for Android
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s handle this for Android as well. We start by taking our standard
    48 height fader graphic and copying it into app/App_Resources/Android/drawable-hdpi
    folder. We can then create appropriate resolutions of this graphic and copy into
    the various resolution dependent folders. The one thing to keep in mind with Android
    is it does ***not*** use the "@3x" suffix identifiers like iOS does so we just
    name all of these "fader.png". Here''s a view of our graphic in one of the resolution
    dependent (in this case **hdpi** which handles "high density" screen resolutions)
    folders:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00045.jpeg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
- en: 'We can now customize our Android slider directive with thumb image handling,
    open `app/modules/player/directives/slider.directive.android.ts`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'One of the most unusual and perhaps surprising aspects of the Android implementation
    above is this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Normally you can reuse and extend controls in NativeScript quite easily. However,
    this is one of those exception cases where the default NativeScript setter on
    the slider control is actually going to cause us problems **only on Android**.
    The default setter will attempt to set the color of the thumb to blue along with
    a method to blend it. When it sets this flag on the slider, any graphic shape
    we then set gets the shape set to all blue. So for our version of the slider class
    to handle a custom graphic we have to eliminate the default slider thumb color
    setter on the control. We take control of this by attaching a new "color" setter
    that does absolutely nothing. This way when the NativeScript framework tries to
    setup the default color while initializing or resetting the control, nothing will
    happen allowing us to completely control what happens. As a precaution at the
    end of the `_addThumbImg` method we also call `seekBar.getThumb().clearColorFilter();` for
    good measure to make sure any potential sets to the colorFilter are undone before
    we were able to silence the default color setter.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly we can customize the colors used in the audio waveform shown for each
    track when our track listing view is toggled to mixer mode. Since the waveform
    plugin for Android utilizes the color resources of the app, we can add the proper
    named attributes found in the plugin''s documentation in app/App_Resources/Android/values/colors.xml
    and the same colors should also be copied into app/App_Resources/Android/values-v21/colors.xml:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00046.jpeg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
- en: 'This now gives us a custom style for Android''s file waveform display in mixing
    mode:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00047.jpeg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
- en: Summary
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We wanted to provide some extra goodies to go along with all the rich content
    you've been learning about throughout Part 3; we hope that you enjoyed it! Using
    multiple item row templates with `ListView` can be handy in many situations, but
    hopefully, this will give you the tools to know how to make it work for you and
    your app.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Special considerations with data persistence is an important factor to any engaging
    app, so we looked at serializing data before storing and hydrating the data when
    restoring it out of a persisted state.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we looked at further enriching our view components with more Angular
    directive goodness. With Part 3 completed, we have now completed the core competency
    and feature set of our app for the book. However, we are far from done with the
    app. The development workflow and process presented in this book are the typical
    development cycle we bring to any app we build. We will cover improving our architecture
    and further polishing our app to prepare for a public release via Google Play
    and App Store in [Chapter 14](part0154.html#4IRMK0-289fe2426d594f99a90e4363b2c9c34d),
    *Deployment Preparation with webpack Bundling*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Let's now move on to improving the state handling of our app with `ngrx` integration
    in [Chapter 10](part0121.html#3JCK20-289fe2426d594f99a90e4363b2c9c34d), *@ngrx/store
    + @ngrx/effects for State Management*. It's worth mentioning that using a Redux style
    architecture is a decision better made *before* building out your app as we have
    done here. However, it's not necessarily critical nor is it mandatory, therefore,
    we wanted to build the app excluding it to show that the app fundamentally works
    just fine. Now, we will move on to working it in to show off the various advantages you
    can gain with it.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续前进，通过在[第10章](part0121.html#3JCK20-289fe2426d594f99a90e4363b2c9c34d)中使用`ngrx`集成来改进我们应用的状态处理，即使用`@ngrx/store
    + @ngrx/effects`进行状态管理。值得一提的是，使用类似Redux的架构是一个更好的决定，最好在构建应用之前就做出，正如我们在这里所做的那样。然而，这并不是必需的，也不是强制性的，因此，我们希望在不包含它的前提下构建应用，以展示该应用在本质上运行得很好。现在，我们将继续将其整合进来，以展示您可以通过它获得的各项优势。
