- en: 13\. End-to-End Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13. 端到端测试
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we will look at how to create an **End-to-End** (**E2E**) test
    suite for a Vue.js application with Cypress. In order to write robust tests, we'll
    look at common pitfalls and best practices such as intercepting HTTP requests
    and waiting for elements to appear without timeouts.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何使用Cypress为Vue.js应用程序创建一个端到端（E2E）测试套件。为了编写健壮的测试，我们将探讨常见的陷阱和最佳实践，例如拦截HTTP请求和等待元素出现而不设置超时。
- en: As we proceed, you will gain an understanding of E2E testing and its use cases.
    You will see how Cypress can be configured to test a Vue.js application and also
    interact with and inspect a user interface using it. Throughout the course of
    the chapter, you will gain familiarity with the pitfalls of arbitrary timeouts
    and how to avoid them with Cypress' waiting functionality. Toward the end of the
    chapter, you will also learn when, why, and how to intercept HTTP requests with
    Cypress.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续前进，你将了解端到端测试及其用例。你将看到如何配置Cypress以测试Vue.js应用程序，并使用它与之交互和检查用户界面。在整个章节中，你将熟悉任意超时的陷阱以及如何使用Cypress的等待功能来避免它们。在章节的末尾，你还将学习何时、为什么以及如何使用Cypress拦截HTTP请求。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, we'll write E2E tests for a highly asynchronous application.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为高度异步的应用程序编写端到端测试。
- en: In previous chapters, we've seen how to build complex Vue.js applications and
    how to write unit tests for them. This chapter will cover how to use Cypress to
    write E2E tests for a Vue.js application that is highly interactive and uses an
    HTTP API. We'll see how E2E testing gives you a high level of confidence that
    an application will work as designed by automating user flows.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了如何构建复杂的Vue.js应用程序以及如何为它们编写单元测试。本章将介绍如何使用Cypress为高度交互式且使用HTTP API的Vue.js应用程序编写端到端测试。我们将看到端到端测试如何通过自动化用户流程，为你提供应用程序按设计工作的信心水平。
- en: Understanding E2E Testing and Its Use Cases
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解端到端测试及其用例
- en: 'Most developers will have seen a version of the testing pyramid shown in the
    following figure:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发者都曾见过以下图中展示的测试金字塔版本：
- en: '![Figure 13.1: A diagram of the testing pyramid'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.1：测试金字塔图解'
- en: '](img/B15218_13_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_13_01.jpg)'
- en: 'Figure 13.1: A diagram of the testing pyramid'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1：测试金字塔图解
- en: E2E tests fall under the **User Interface** (**UI**) testing category. The type
    of test we'll be looking at in this chapter is automated E2E tests using Cypress.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试属于**用户界面**（**UI**）测试类别。在本章中，我们将探讨的是使用Cypress进行的自动化端到端测试。
- en: E2E and UI tests provide a level of confidence higher than unit or integration
    tests. They're testing the application as used by the end user. The end user doesn't
    care why or where a bug is happening, just that there is a bug. The *where and
    why* of a bug tends to be the concern of unit and system-level tests. Unit and
    system-level tests check that the internals of a system work as the specification
    or code describes them. UI-level tests validate that application flows are working
    as expected.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: E2E和UI测试提供的信心水平高于单元或集成测试。它们测试的是终端用户使用的应用程序。终端用户不关心错误发生的原因或地点，只关心存在错误。错误的原因和地点往往是单元和系统级测试关注的焦点。单元和系统级测试检查系统的内部是否按照规范或代码描述的方式工作。UI级测试验证应用程序流程是否按预期工作。
- en: A strong E2E test suite that runs fast, has few false negatives (where a test
    fails but the application works), and even fewer false positives (where all tests
    pass but the application is broken) enables **Continuous Deployment** (**CD**).
    CD, as its name entails, involves deploying a project or application continually.
    In this kind of setup, an application version is validated by the E2E suite and
    is then automatically deployed to production.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一个运行速度快、假阴性（测试失败但应用程序工作）少、假阳性（所有测试通过但应用程序损坏）更少的强大端到端测试套件，可以启用**持续部署**（**CD**）。持续部署，正如其名所暗示的，涉及持续部署项目或应用程序。在这种设置中，应用程序版本由端到端套件验证，然后自动部署到生产环境。
- en: Configuring Cypress for a Vue.js Application
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Vue.js应用程序配置Cypress
- en: '**Cypress** is a JavaScript E2E testing framework. It''s designed to solve
    the very specific need of writing E2E tests using JavaScript. This is in contrast
    to other fully fledged **browser automation** solutions such as **WebDriverIO**
    ([https://webdriver.io/](https://webdriver.io/)), **Selenium Webdriver** ([https://www.selenium.dev/](https://www.selenium.dev/)),
    **Puppeteer** ([https://developers.google.com/web/tools/puppeteer/](https://developers.google.com/web/tools/puppeteer/)),
    and **Playwright** ([https://github.com/microsoft/playwright](https://github.com/microsoft/playwright)),
    which are commonly used to write E2E tests.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**Cypress** 是一个 JavaScript E2E 测试框架。它旨在解决使用 JavaScript 编写 E2E 测试的非常具体的需求。这与其他完整的
    **浏览器自动化** 解决方案（如 **WebDriverIO** ([https://webdriver.io/](https://webdriver.io/))）、**Selenium
    WebDriver** ([https://www.selenium.dev/](https://www.selenium.dev/))）、**Puppeteer**
    ([https://developers.google.com/web/tools/puppeteer/](https://developers.google.com/web/tools/puppeteer/))
    和 **Playwright** ([https://github.com/microsoft/playwright](https://github.com/microsoft/playwright)）形成对比，这些解决方案通常用于编写
    E2E 测试。'
- en: The big difference with Cypress compared to these other solutions is its singular
    focus on writing E2E tests (as opposed to generic browser automation). Tests can
    only be written using JavaScript (Selenium supports other languages), and up until
    recently, it only supported Chrome (Cypress 4.0 now has support for Firefox and
    Microsoft Edge as per [https://www.cypress.io/blog/2020/02/06/introducing-firefox-and-edge-support-in-cypress-4-0/](https://www.cypress.io/blog/2020/02/06/introducing-firefox-and-edge-support-in-cypress-4-0/)).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他解决方案相比，Cypress 的一个显著区别是它专注于编写 E2E 测试（而不是通用的浏览器自动化）。测试只能使用 JavaScript 编写（Selenium
    支持其他语言），并且直到最近，它只支持 Chrome（Cypress 4.0 现在支持 Firefox 和 Microsoft Edge，请参阅 [https://www.cypress.io/blog/2020/02/06/introducing-firefox-and-edge-support-in-cypress-4-0/](https://www.cypress.io/blog/2020/02/06/introducing-firefox-and-edge-support-in-cypress-4-0/)）。
- en: Cypress has a **Graphical User Interface** (**GUI**) to run and debug tests
    locally and comes with built-in assertion and stubbing/mocking libraries.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Cypress 拥有一个用于本地运行和调试测试的 **图形用户界面 (GUI**)，并附带内置的断言和存根/模拟库。
- en: 'To add Cypress to a project using the Vue CLI, we can use the `e2e-cypress`
    plugin ([https://cli.vuejs.org/core-plugins/e2e-cypress.html](https://cli.vuejs.org/core-plugins/e2e-cypress.html)),
    whose install instructions guide us to run the following command at the command
    line. As part of adding the plugin, Cypress and its supporting packages are downloaded
    and unpacked, so it might take a while to complete:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Vue CLI 将 Cypress 添加到项目中，我们可以使用 `e2e-cypress` 插件 ([https://cli.vuejs.org/core-plugins/e2e-cypress.html](https://cli.vuejs.org/core-plugins/e2e-cypress.html))，其安装说明指导我们在命令行中运行以下命令。作为添加插件的一部分，Cypress
    及其支持包将被下载并解压，因此可能需要一段时间才能完成：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The plugin adds a `test:e2e` script that we can run using the following command.
    This command takes a while to start since it needs to run a production build of
    the application and then start the Cypress app:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 插件添加了一个 `test:e2e` 脚本，我们可以使用以下命令运行它。此命令需要一段时间才能启动，因为它需要运行应用程序的生产构建并启动 Cypress
    应用：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Eventually, we''ll see the Cypress GUI as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们将看到以下 Cypress GUI：
- en: '![Figure 13.2: The Cypress GUI after plugin installation and the run test:e2e
    command'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.2：插件安装和运行 test:e2e 命令后的 Cypress 图形用户界面 (GUI)]'
- en: '](img/B15218_13_02.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_13_02.jpg)'
- en: 'Figure 13.2: The Cypress GUI after plugin installation and the run test:e2e
    command'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2：插件安装和运行 test:e2e 命令后的 Cypress GUI
- en: 'The plugin creates a default `test.js` file for us. The contents are as follows
    by default. The test goes to the application root (`/`) and checks that the `h1`
    on the page contains `Welcome to Your Vue.js App`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 插件为我们创建了一个默认的 `test.js` 文件。默认内容如下。测试会访问应用程序根目录 (`/`) 并检查页面上的 `h1` 是否包含 `Welcome
    to Your Vue.js App`：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This works in an empty Vue CLI project.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这在空 Vue CLI 项目中是有效的。
- en: 'We can try visiting `google.com` using `cy.visit(url)` and check that the `input`
    element that''s synonymous with the Google home page is there by first selecting
    the input elements on the page with `cy.get(''input'')` and then using the `.should(''exist'')`
    assertion:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试使用 `cy.visit(url)` 访问 `google.com`，并通过首先使用 `cy.get('input')` 选择页面上的输入元素，然后使用
    `.should('exist')` 断言来检查与 Google 主页同义的 `input` 元素是否存在：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can run the test by clicking on `test.js` in the Cypress UI (when `npm run
    test:e2e` is running) as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在 Cypress UI 中单击 `test.js` 来运行测试（当 `npm run test:e2e` 正在运行时）如下所示：
- en: '![Figure 13.3: The Cypress UI running test.js'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.3：运行 test.js 的 Cypress UI]'
- en: '](img/B15218_13_03.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_13_03.jpg)'
- en: 'Figure 13.3: The Cypress UI running test.js'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.3：运行 test.js 的 Cypress UI
- en: 'When Cypress is running tests, a browser window is opened to run them:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Cypress 运行测试时，会打开一个浏览器窗口来运行它们：
- en: '![Figure 13.4: Cypress tests running in Chrome while visiting the Google home
    page'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.4：在访问 Google 主页时在 Chrome 中运行的 Cypress 测试'
- en: '](img/B15218_13_04.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_13_04.jpg)'
- en: 'Figure 13.4: Cypress tests running in Chrome while visiting the Google home
    page'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.4：在访问 Google 主页时在 Chrome 中运行的 Cypress 测试
- en: We've now seen how to install and use Cypress to visit web pages.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何安装和使用 Cypress 访问网页。
- en: In the next section, we'll see how Cypress can be used to interact with and
    inspect a UI.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何使用 Cypress 与 UI 交互和检查。
- en: Using Cypress to Interact with and Inspect a Vue.js UI
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Cypress 与 Vue.js UI 交互和检查
- en: 'In order to E2E test the `h2`) with the name of the application. In the `App.vue`
    file, we''ll have the following code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了端到端测试具有应用程序名称的 `h2`)，在 `App.vue` 文件中，我们将有如下代码：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In order to test this with Cypress, we can change the `tests/e2e/specs/test.js`
    file with the following code. We''ll go to the running application using `cy.visit(''/'')`
    and then check that the `h2` on the page contains `cy.contains(''h2'', ''Commentator
    Pro'')`. The `cy.contains` function is overloaded and can be used with one parameter
    (the text to match against) or two parameters (the selector for the container
    and the text to match against):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 Cypress 进行测试，我们可以使用以下代码更改 `tests/e2e/specs/test.js` 文件。我们将使用 `cy.visit('/')`
    访问运行中的应用程序，然后检查页面上的 `h2` 是否包含 `cy.contains('h2', 'Commentator Pro')`。`cy.contains`
    函数是重载的，可以用一个参数（要匹配的文本）或两个参数（容器的选择器和要匹配的文本）使用：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can then run `test.js` using the Cypress UI as seen in the following screenshot:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下截图所示的 Cypress UI 运行 `test.js`：
- en: '![Figure 13.5: Heading content test running successfully in Chrome'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.5：在 Chrome 中成功运行的标题内容测试'
- en: '](img/B15218_13_05.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_13_05.jpg)'
- en: 'Figure 13.5: Heading content test running successfully in Chrome'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.5：标题内容测试在 Chrome 中成功运行
- en: Now that we've seen how to visit a page and assert on its content, we'll see
    how we can use Cypress to automate tests for a new feature in a Vue.js application.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何访问页面并对其内容进行断言，我们将看到如何使用 Cypress 自动化 Vue.js 应用程序中新功能的测试。
- en: 'Exercise 13.01: Adding a "New Comment" Button and Corresponding E2E Test'
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 13.01：添加“新评论”按钮和相应的端到端测试
- en: In order for the `Add a new comment` button to allow users to add comments.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使“添加新评论”按钮允许用户添加评论。
- en: We will add a blue jumbo button with the text `Add a New Comment` and write
    the corresponding E2E test with Cypress.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个带有文本“添加新评论”的蓝色巨型按钮，并使用 Cypress 编写相应的端到端测试。
- en: To access the code files for this exercise, refer to [https://packt.live/36PefjJ](https://packt.live/36PefjJ).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅 [https://packt.live/36PefjJ](https://packt.live/36PefjJ)。
- en: 'To do this, perform the following steps:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，请执行以下步骤：
- en: 'To add a button in the app, we''ll add a `button` element with some `TailwindCSS`
    classes in `src/App.vue`:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在应用程序中添加按钮，我们将在 `src/App.vue` 中添加一个带有一些 `TailwindCSS` 类的 `button` 元素：
- en: '[PRE6]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output should show as follows:'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 13.6: Commentator Pro application with the "Add a New Comment" button'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 13.6：带有“添加新评论”按钮的 Commentator Pro 应用程序'
- en: '](img/B15218_13_06.jpg)'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_13_06.jpg)'
- en: 'Figure 13.6: Commentator Pro application with the "Add a New Comment" button'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 13.6：带有“添加新评论”按钮的 Commentator Pro 应用程序
- en: 'Next, we''ll create a new E2E test at `tests/e2e/specs/add-new-comment.js`.
    We''ll set the name of the suite and description of the test to `Adding a New
    Comment` and `the homepage should have a button with the right text` respectively:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在 `tests/e2e/specs/add-new-comment.js` 创建一个新的端到端测试。我们将设置测试套件的名称和测试的描述分别为“添加新评论”和“主页应该有一个带有正确文本的按钮”：
- en: '[PRE7]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In order to test the home page, we''ll have to navigate to it using `cy.visit(''/'')`:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试主页，我们必须使用 `cy.visit('/')` 导航到它：
- en: '[PRE8]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, we can write the assertion that a `button` instance containing the
    text `Add a New Comment` is on the page:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以编写断言，页面中有一个包含文本“添加新评论”的 `button` 实例：
- en: '[PRE9]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can run this test using the Cypress UI (get it running using `npm run test:e2e`):![Figure
    13.7: The "add-new-comment.js" test displaying in the Cypress UI'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用 Cypress UI 运行此测试（使用 `npm run test:e2e` 运行）：![图 13.7：“add-new-comment.js”测试在
    Cypress UI 中显示
- en: '](img/B15218_13_07.jpg)'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_13_07.jpg)'
- en: 'Figure 13.7: The "add-new-comment.js" test displaying in the Cypress UI'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 13.7：“add-new-comment.js”测试在 Cypress UI 中显示
- en: 'When we run the test, we''ll get the following output in Chrome. The test passes
    since there is a button with the relevant text on the home page:![Figure 13.8:
    Cypress running our "add-new-comment" test in Chrome'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们运行测试时，我们将在Chrome中得到以下输出。测试通过，因为主页上有一个带有相关文本的按钮：![图 13.8：Cypress 在 Chrome
    中运行我们的 "add-new-comment" 测试
- en: '](img/B15218_13_08.jpg)'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 13.8](img/B15218_13_08.jpg)'
- en: 'Figure 13.8: Cypress running our "add-new-comment" test in Chrome'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.8：Cypress 在 Chrome 中运行我们的 "add-new-comment" 测试
- en: We've now seen how to visit pages and assert against their content.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何访问页面并对其内容进行断言。
- en: In the next section, we will look at using Cypress to test interactive behavior.
    Cypress has automatic selector retries, which make it a great fit for testing
    highly interactive Vue.js applications. We'll see how to use Cypress to interact
    with the UI and assert on the effect of our interactions.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何使用 Cypress 来测试交互行为。Cypress 具有自动选择器重试功能，这使得它非常适合测试高度交互的 Vue.js 应用程序。我们将看到如何使用
    Cypress 与 UI 交互并断言我们交互的效果。
- en: Triggering and Waiting for UI Updates with Cypress
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Cypress 触发和等待 UI 更新
- en: The tests we've written up until now are quite simple and only check that the
    application isn't crashing on load in the browser.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止编写的测试相当简单，仅检查应用程序在浏览器加载时不会崩溃。
- en: One of the strengths of E2E tests is testing with high fidelity that the UI
    behaves as expected when a user interacts with it. We'll use Cypress' selection
    (the `.get()` function), event triggering (the `.click()` function), and assertion
    (the `.should()` function) functionality to test a Vue.js application in this
    section. Cypress' automatic retries on DOM selection will allow us to write E2E
    tests without explicit wait/timeout conditions. Waits and timeouts are a staple
    of other E2E testing systems and tend to be a source of flakiness in tests.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: E2E 测试的一个优势是，当用户与之交互时，可以以高保真度测试 UI 的行为是否符合预期。在本节中，我们将使用 Cypress 的选择（`.get()`
    函数）、事件触发（`.click()` 函数）和断言（`.should()` 函数）功能来测试 Vue.js 应用程序。Cypress 在 DOM 选择上的自动重试将允许我们编写无需显式等待/超时条件的
    E2E 测试。等待和超时是其他 E2E 测试系统的基本要素，并且往往是测试不稳定的原因。
- en: To begin with, we will add a comment editor to our `textarea`) will be toggled
    by clicking on the `Add a New Comment` button.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将向我们的`textarea`添加一个评论编辑器，点击`添加新评论`按钮将切换它。
- en: 'In order to keep writing tests without wrangling complicated and brittle selectors,
    we''ll start adding `data-test-id` attributes; to begin with, we can add one to
    the `Add a New Comment` button in the `App.vue` file:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在不处理复杂且脆弱的选择器的情况下继续编写测试，我们将开始添加`data-test-id`属性；首先，我们可以在`App.vue`文件中的`添加新评论`按钮上添加一个：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we''ll add a `showEditor` property to the Vue.js `data()` method on the
    `App` component. We''ll use this expression in the `v-if` for the editor. We can
    also set the new comment button to toggle this instance property:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在`App`组件的Vue.js `data()`方法中添加一个`showEditor`属性。我们将在编辑器的`v-if`中使用这个表达式。我们还可以设置新的评论按钮来切换这个实例属性：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can add our editor with the `new-comment-editor` `data-test-id` that is
    toggled by `showEditor`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`new-comment-editor` `data-test-id`来添加我们的编辑器，该`data-test-id`可以通过`showEditor`来切换：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In order to test the toggling, we can add a test that opens that app and checks
    that the comment editor is not initially shown, as well as checking whether or
    not it shows depending on how many clicks are triggered on the `new-comment-button`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试切换功能，我们可以添加一个测试，打开该应用程序并检查评论编辑器最初不会显示，以及根据在`new-comment-button`上触发的点击次数来检查它是否显示：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding code will generate the following result:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将生成以下结果：
- en: '![Figure 13.9: Cypress running "add-new-comment" tests, including'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.9：Cypress 运行 "add-new-comment" 测试，包括'
- en: the new editor-toggling test
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 新的编辑器切换测试
- en: '](img/B15218_13_09.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 13.9](img/B15218_13_09.jpg)'
- en: 'Figure 13.9: Cypress running "add-new-comment" tests, including the new editor-toggling
    test'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.9：Cypress 运行 "add-new-comment" 测试，包括新的编辑器切换测试'
- en: We've now seen how to write Cypress tests that select and assert over DOM elements.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何编写选择和断言 DOM 元素的 Cypress 测试。
- en: Note
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`data-test-id` instances, as a convention, are a way to decouple tests from
    application and styling-specific selectors. This is especially useful if the people
    writing the tests aren''t always the ones writing the code. In that situation,
    using `data-test-id` allows the markup structure and classes to change, but the
    tests will keep passing as long as the `test-id` instances remain on the correct
    element.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`data-test-id`实例，作为一种约定，是使测试与应用程序和样式特定的选择器解耦的一种方式。如果编写测试的人不总是编写代码的人，这特别有用。在这种情况下，使用`data-test-id`允许标记结构和类发生变化，但只要`test-id`实例保持在正确的元素上，测试就会继续通过。'
- en: 'Exercise 13.02: Adding New Comment Editor Input and Submit Functionality'
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13.02：添加新评论编辑器输入和提交功能
- en: To be able to send the new comment text to an API, we will need to store the
    text in a Vue.js state. The other prerequisite to adding a comment is to have
    a dummy "`submit`" button.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够将新的评论文本发送到API，我们需要将文本存储在Vue.js状态中。添加评论的另一个先决条件是拥有一个虚拟的"`提交`"按钮。
- en: To access the code files for this exercise, refer to [https://packt.live/2HaWanh](https://packt.live/2HaWanh).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅[https://packt.live/2HaWanh](https://packt.live/2HaWanh)。
- en: 'To add these features and their corresponding tests, perform the following
    steps:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这些功能和相应的测试，请执行以下步骤：
- en: 'To store the `textarea` (editor) content in-memory, we''ll use `v-model`. We''ll
    create a new data (state) variable, `newComment`, that gets initialized to `""`.
    Now, `v-model` will two-way bind the `textarea` content and `newComment`:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将`textarea`（编辑器）内容存储在内存中，我们将使用`v-model`。我们将创建一个新的数据（状态）变量`newComment`，它被初始化为`""`。现在，`v-model`将双向绑定`textarea`内容和`newComment`：
- en: '[PRE14]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We''ll add a `submit` button inside the editor, which should only show when
    the editor is toggled on. We also make sure to include a `data-test-id="new-comment-submit"`
    attribute in order to be able to select it with Cypress later:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在编辑器内部添加一个`提交`按钮，它应该只在编辑器开启时显示。我们还确保包含一个`data-test-id="new-comment-submit"`属性，以便稍后用Cypress选择它：
- en: '[PRE15]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'It''s now time to add an E2E test to test that `new-comment-editor` works as
    expected when we type text into it. In order to achieve this, we need to load
    up the application and click the `new comment` button so that the editor is displayed.
    We can then select `new-comment-editor` (by `data-test-id`) and use the Cypress
    `.type` function to add some text. We can chain `.should(''have.value'', ''Just
    saying...'')` to validate that our interaction with `textarea` was successful:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候添加一个端到端测试来测试当我们向其中输入文本时`new-comment-editor`是否按预期工作。为了实现这一点，我们需要加载应用程序并点击`新评论`按钮，以便显示编辑器。然后我们可以选择`new-comment-editor`（通过`data-test-id`）并使用Cypress的`.type`函数添加一些文本。我们可以将`.should('have.value',
    'Just saying...')`链接起来以验证我们对`textarea`的交互是否成功：
- en: '[PRE16]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When run using the Cypress UI, this `add-new-comment` test suite should yield
    the following result:'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当使用Cypress UI运行时，这个`添加新评论`测试套件应该产生以下结果：
- en: '![Figure 13.10: Cypress running "add-new-comment" tests, including'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图13.10：Cypress运行"添加新评论"测试，包括'
- en: the new editor text input test
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 新的编辑器文本输入测试
- en: '](img/B15218_13_10.jpg)'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_13_10.jpg)'
- en: 'Figure 13.10: Cypress running "add-new-comment" tests, including the new editor
    text input test'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图13.10：Cypress运行"添加新评论"测试，包括新的编辑器文本输入测试
- en: 'Finally, we can add an `E2E test` to check that the `submit` button does not
    appear by default but does appear when we click the `new comment` button. We can
    also check the text content of the `new-comment-submit` button:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以添加一个`端到端测试`来检查`提交`按钮默认情况下不会显示，但当我们点击`新评论`按钮时会出现。我们还可以检查`new-comment-submit`按钮的文本内容：
- en: '[PRE17]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When this test is run through the Cypress UI, we see the following result:'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当这个测试通过Cypress UI运行时，我们看到以下结果：
- en: '![Figure 13.11: Cypress running "add-new-comment" tests, including'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图13.11：Cypress运行"添加新评论"测试，包括'
- en: the new submit button test
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 新的提交按钮测试
- en: '](img/B15218_13_11.jpg)'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_13_11.jpg)'
- en: 'Figure 13.11: Cypress running "add-new-comment" tests, including the new submit
    button test'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图13.11：Cypress运行"添加新评论"测试，包括新的提交按钮测试
- en: 'One more feature we can add is to make the `submit` button disabled until there''s
    text in the text editor. To do this, we can bind `:disabled` to `!newComment`
    on the `new comment submit` button. We''ll make the button look disabled using
    reduced opacity. As an aside, one of the big reasons we added a two-way binding
    between `newComment` and `textarea` is to enable UI validations like this one:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以添加的一个功能是，在文本编辑器中有文本之前，使 `submit` 按钮处于禁用状态。为此，我们可以在 `new comment submit`
    按钮上绑定 `:disabled` 到 `!newComment`。我们将使用降低的不透明度使按钮看起来被禁用。顺便说一下，我们添加 `newComment`
    和 `textarea` 之间的双向绑定的一大原因是为了启用此类 UI 验证：
- en: '[PRE18]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The relevant test will look at whether or not the `new-comment-submit` button
    is disabled when the text editor content is empty using Cypress'' `should(''be.disabled'')`
    and `should(''not.be.disabled'')` assertions:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相关测试将检查当文本编辑器内容为空时，`new-comment-submit` 按钮是否被禁用，使用 Cypress 的 `should('be.disabled')`
    和 `should('not.be.disabled')` 断言：
- en: '[PRE19]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This yields the following output when run through Cypress UI and Chrome automation:'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当通过 Cypress UI 和 Chrome 自动化运行时，会产生以下输出：
- en: '![Figure 13.12: Cypress running "add-new-comment" tests, including'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 13.12：Cypress 运行 "add-new-comment" 测试，包括'
- en: the new comment submit button disabled test
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 新的评论提交按钮禁用测试
- en: '](img/B15218_13_12.jpg)'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_13_12.jpg)'
- en: 'Figure 13.12: Cypress running "add-new-comment" tests, including the new comment
    submit button disabled test'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.12：Cypress 运行 "add-new-comment" 测试，包括新的评论提交按钮禁用测试
- en: We've now seen how to use Cypress to select, click, and input text. We've also
    seen approaches to check element visibility, text content, input values, and disabled
    states.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用 Cypress 来选择、点击和输入文本。我们还看到了检查元素可见性、文本内容、输入值和禁用状态的方法。
- en: Anyone familiar with other automation frameworks will have noticed that in Cypress
    tests, there are no explicit waits or retries. This is because Cypress waits and
    retries assertions and selections automatically. Most of the tests we've written
    don't showcase this in a major way, but the next exercise, where we bring asynchronicity
    into the mix, will.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉其他自动化框架的任何人都会注意到，在 Cypress 测试中，没有显式的等待或重试。这是因为 Cypress 会自动等待和重试断言和选择。我们编写的大多数测试都没有以这种方式展示这一点，但下一个练习，我们将引入异步性，将会展示这一点。
- en: 'Exercise 13.03: Adding a Submitting State to the New Comment Editor'
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 13.03：向新评论编辑器添加提交状态
- en: In order to showcase Cypress's impressive automatic retry/wait capability, we
    will look at adding and testing a `submitting` state for the new comment editor.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示 Cypress 令人印象深刻的自动重试/等待能力，我们将查看为新的评论编辑器添加和测试 `submitting` 状态。
- en: In effect, we'll be reacting to a click on the `submit` button and showing a
    spinner for `2.5s` to simulate a reasonably slow HTTP request to a backend API.
    This is an example that showcases Cypress' ability to automatically wait and retry
    selections. This feature reduces the need for arbitrary waits and that flakiness
    associated with them.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们将对 `submit` 按钮的点击做出反应，并显示一个持续 `2.5s` 的加载指示器来模拟对后端 API 的合理慢速 HTTP 请求。这是一个展示
    Cypress 自动等待和重试选择能力的示例。这个功能减少了任意等待的需要以及与之相关的易变性。
- en: 'To access the code files for this exercise, refer to [https://packt.live/2UzsYJU](https://packt.live/2UzsYJU):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅[https://packt.live/2UzsYJU](https://packt.live/2UzsYJU)：
- en: 'In order to show the spinner, we add the `tailwindcss-spinner` package to the
    project:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了显示加载指示器，我们将 `tailwindcss-spinner` 包添加到项目中：
- en: '[PRE20]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We will need to configure it in the Tailwind config file (`tailwind.js`). It
    needs to be imported using `require(''tailwindcss-spinner'')`, added as a plugin,
    and the relevant variables need to be set in `theme`. Our spinner will be `gray`
    in color, use a Tailwind spacing of size `4`, and have a border width of `2px`
    and a duration of `500ms`:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在 Tailwind 配置文件（`tailwind.js`）中进行配置。它需要使用 `require('tailwindcss-spinner')`
    导入，添加为插件，并在 `theme` 中设置相关变量。我们的加载指示器将是 `灰色`，使用 Tailwind 间距大小 `4`，边框宽度为 `2px`，持续时间为
    `500ms`：
- en: '[PRE21]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we need to add an `isSubmitting` state to the Vue.js application in `data()`,
    which will allow us to toggle the state for the `submit` button. We will initialize
    it to `false` since we are not submitting anything until the user clicks the `submit`
    button:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要在 Vue.js 应用程序的 `data()` 中添加一个 `isSubmitting` 状态，这将允许我们切换 `submit` 按钮的状态。我们将将其初始化为
    `false`，因为我们还没有在用户点击 `submit` 按钮之前提交任何内容：
- en: '[PRE22]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we will add a click handler for the `submit` button (as `methods.submitNewComment`).
    It will simulate a `2.5s` load time using `setTimeout`:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将为 `submit` 按钮添加一个点击处理程序（作为 `methods.submitNewComment`）。它将使用 `setTimeout`
    模拟 `2.5s` 的加载时间：
- en: '[PRE23]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now that we''ve got a `fake submit` handler, we should bind it to click events
    on the `new-comment-submit` button:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经有一个 `fake submit` 处理器，我们应该将其绑定到 `new-comment-submit` 按钮的点击事件上：
- en: '[PRE24]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now comes the part where we need to react to the submit button. We''ll be showing
    the spinner when `isSubmitting` is true. In order to do this, we simply need to
    set the `spinner` class to be added when `isSubmitting` is true. In addition to
    this, we''ll set the button to be disabled when `isSubmitting` is true:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是我们要对提交按钮做出反应的部分。当 `isSubmitting` 为真时，我们将显示旋转器。为了做到这一点，我们只需将 `spinner` 类设置为在
    `isSubmitting` 为真时添加。除此之外，我们还将设置按钮在 `isSubmitting` 为真时被禁用：
- en: '[PRE25]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, we can add a test to check that the loading spinner appears when the
    `submit` button is clicked. To begin with, we''ll need to set up the text editor
    so that when clicking the `add new comment` button and setting a text value for
    the comment, the text editor is shown and enabled. Next, we can click the enabled
    `new-comment-submit` button and check that it is disabled and has the `spinner`
    class (using the `should()` function). After that, we should write another assertion
    that the button is not disabled anymore and does not show the spinner:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以添加一个测试来检查当点击 `submit` 按钮时加载旋转器是否出现。首先，我们需要设置文本编辑器，以便在点击 `add new comment`
    按钮并设置评论的文本值时，文本编辑器显示并启用。接下来，我们可以点击已启用的 `new-comment-submit` 按钮并检查它是否被禁用并具有 `spinner`
    类（使用 `should()` 函数）。之后，我们应该编写另一个断言，按钮不再被禁用且不显示旋转器：
- en: '[PRE26]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Despite the `2.5s` during which the spinner shows, this test still passes due
    to Cypress'' automatic retry/wait functionality:'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尽管旋转器显示的时间为 `2.5s`，但由于 Cypress 的自动重试/等待功能，这个测试仍然通过：
- en: '![Figure 13.13: Cypress running "add-new-comment" tests, including the comment
    submission loading state test'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 13.13：Cypress 运行 "添加新评论" 测试，包括评论提交加载状态测试](img/B15218_13_13.jpg)'
- en: '](img/B15218_13_13.jpg)'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ']'
- en: 'Figure 13.13: Cypress running "add-new-comment" tests, including the comment
    submission loading state test'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.13：Cypress 运行 "添加新评论" 测试，包括评论提交加载状态测试
- en: We've now seen how Cypress allows us to seamlessly work around asynchronicity
    in the application by automatically waiting/retrying where an assertion or selection
    would fail.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到 Cypress 如何通过自动等待/重试来允许我们在应用程序中无缝处理异步性，当断言或选择失败时。
- en: Intercepting HTTP Requests
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 截获 HTTP 请求
- en: As mentioned in previous sections, Cypress is designed as a JavaScript E2E testing
    solution. This means that it comes with built-ins such as assertions, automatic
    wait/retries, sane defaults for running the application, and extensive mocking
    functionality.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几节所述，Cypress 被设计为 JavaScript 端到端测试解决方案。这意味着它自带断言、自动等待/重试、运行应用程序的合理默认值以及广泛的模拟功能。
- en: HTTP requests can be slow and tend to introduce flaky behavior to tests. What's
    meant by flaky is intermittent false negatives, that is, failures that are not
    caused by an application issue but rather by connectivity issues (for example,
    between the server running the tests and the backend hosts).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 请求可能会很慢，并且倾向于给测试引入不稳定的（flaky）行为。所谓的 flaky 指的是间歇性的假阴性，即不是由应用程序问题引起的失败，而是由连接问题（例如，测试运行的服务器和后端主机之间的连接）引起的。
- en: We would also be testing the implementation of the backend system. When using
    **Continuous Integration** (**CI**), this would mean having to run the backend
    systems in whichever CI pipeline step needs to run E2E tests.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将测试后端系统的实现。当使用**持续集成**（**CI**）时，这意味着需要在任何需要运行端到端测试的 CI 管道步骤中运行后端系统。
- en: Usually, when the backend requests are intercepted and a mock response is sent,
    we also say that the HTTP requests are **stubbed**, in order to avoid tests flaking
    (meaning intermittent failures not linked to application changes).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当拦截后端请求并发送模拟响应时，我们也说 HTTP 请求被**模拟**，以避免测试不稳定（意味着间歇性失败与应用程序更改无关）。
- en: Seeing that the requests do not go all the way through the stack (including
    the backend API), this is technically not a full E2E test of the system anymore.
    We can, however, consider it an E2E test of the frontend application since the
    whole application is made up of separate exercises and is not implementation-specific.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 由于请求并没有完全通过堆栈（包括后端 API），这在技术上不再是系统的完整端到端测试。然而，我们可以将其视为前端应用程序的端到端测试，因为整个应用程序由独立的练习组成，并且不是特定于实现的。
- en: In order to mock requests in Cypress, we'll need to use `cy.server()` and `cy.route()`.
    The Cypress documentation also lets us know that in order to use the HTTP interception
    functionality, we currently need a client that uses `XMLHttpRequest` (and not
    the `fetch` API).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Cypress中模拟请求，我们需要使用`cy.server()`和`cy.route()`。Cypress文档还让我们知道，为了使用HTTP拦截功能，我们目前需要一个使用`XMLHttpRequest`（而不是`fetch`
    API）的客户端。
- en: Note
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: There is work underway to support HTTP-level interception (which means `fetch`,
    **XHR**, and more will be supported eventually).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 目前正在进行支持HTTP级拦截（这意味着`fetch`、**XHR**等最终都将得到支持）的工作。
- en: 'We''ll use the `unfetch` library, which implements the `fetch` interface on
    top of `XMLHttpRequest`. We can install it using the following command:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`unfetch`库，该库在`XMLHttpRequest`之上实现了`fetch`接口。我们可以使用以下命令安装它：
- en: '[PRE27]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We can then import it into `src/App.vue` as follows.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以按照以下方式将其导入到`src/App.vue`中。
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To showcase HTTP interception, we''ll fetch a list of comments from `JSONPlaceholder`
    and store them under a `comments` reactive instance variable. We can use `fetch`
    (the name under which we imported `unfetch`) to do this in the `mounted()` life
    cycle event as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示HTTP拦截，我们将从`JSONPlaceholder`获取评论列表并将它们存储在`comments`响应式实例变量下。我们可以使用`fetch`（我们导入`unfetch`时使用的名称）在`mounted()`生命周期事件中这样做，如下所示：
- en: '[PRE29]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: A sample comment includes an ID, a body, and an email, among other properties.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例评论包括ID、正文和电子邮件等属性。
- en: That means we can render the comments by creating a `ul` container, which only
    shows if there are comments (`comments.length > 0)`. Inside the `ul` container,
    we can render a list of `li` elements with a card layout using `v-for`. Each card
    will render the body of the comment and the author's email inside a `mailto:`
    link.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以通过创建一个`ul`容器来渲染评论，该容器仅在存在评论时显示（`comments.length > 0`）。在`ul`容器内部，我们可以使用`v-for`渲染一个具有卡片布局的`li`元素列表。每个卡片将渲染评论的正文和作者的电子邮件，并在`mailto:`链接内显示。
- en: 'Note how we set `comments-list` and `comment-card` `data-test-ids` for the
    list container and the list items respectively:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何为列表容器和列表项分别设置`comments-list`和`comment-card`的`data-test-ids`：
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If we were to test this without HTTP interception, we would have to keep the
    assertions quite generic. For example, we can check that `comments-list` is visible
    and that there is a number (greater than 0) of `comment-card` instances in a new
    E2E test file:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不使用HTTP拦截来测试，我们必须保持断言相当通用。例如，我们可以在新的端到端测试文件中检查`comments-list`是否可见，以及是否有（大于0）个`comment-card`实例：
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The following test run using the Cypress GUI passes but the tests are quite
    generic. We can''t make any assertions about the specific number of comments or
    their content:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Cypress GUI运行的以下测试通过，但测试相当通用。我们无法对特定评论数量或其内容做出任何断言：
- en: '![Figure 13.14: Cypress running "load-comments" tests, including'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.14：Cypress运行“load-comments”测试，包括'
- en: a generic load and display test
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 通用的加载和显示测试
- en: '](img/B15218_13_14.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_13_14.jpg)'
- en: 'Figure 13.14: Cypress running "load-comments" tests, including a generic load
    and display test'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.14：Cypress运行“load-comments”测试，包括通用的加载和显示测试
- en: 'To intercept the request, we have to initialize the Cypress mock server with
    `cy.server()`. We can then intercept specific requests using `cy.route()`, which
    yields the following new test. `cy.route`, when used with two parameters, takes
    the URL followed by the stub response, in our case an array of comments. We''ll
    use a fictitious email address in our stubs:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了拦截请求，我们必须使用`cy.server()`初始化Cypress模拟服务器。然后我们可以使用`cy.route()`拦截特定的请求，从而产生以下新的测试。当`cy.route`与两个参数一起使用时，它接受URL后跟存根响应，在我们的例子中是一个评论数组。我们将在存根中使用一个虚构的电子邮件地址：
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Once we''ve got our stub route set up, we can visit the page and wait for the
    comment fetching to finish using `cy.wait(''@getComments'')`, since we''ve previously
    set the alias of the comments fetch route to `getComments` with `.as(''getComments'')`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了存根路由，我们就可以访问页面并使用`cy.wait('@getComments')`等待评论获取完成，因为我们之前已经使用`.as('getComments')`将评论获取路由的别名设置为`getComments`：
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can then start asserting, first off, that `comments-list` is visible, and
    then assert on the number of `comment-card` cards:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们首先可以断言`comments-list`是可见的，然后对`comment-card`卡片数量进行断言：
- en: '[PRE34]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can also assert on the specific contents of the cards using the `.contains()` function:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`.contains()`函数对卡片的特定内容进行断言：
- en: '[PRE35]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can then run the suite with the Cypress GUI and see it passing:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用Cypress GUI运行测试套件并看到它通过：
- en: '![Figure 13.15: Cypress running "load-comments" tests, including our stubbed
    comments test'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.15：Cypress运行“load-comments”测试，包括我们的模拟评论测试]'
- en: '](img/B15218_13_15.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_13_15.jpg)'
- en: 'Figure 13.15: Cypress running "load-comments" tests, including our stubbed
    comments test'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.15：Cypress运行“load-comments”测试，包括我们的模拟评论测试
- en: We've now seen how and why we might stub HTTP requests using Cypress.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何以及为什么我们可能会使用Cypress来模拟HTTP请求。
- en: 'Exercise 13.04: POST Comment to API on Submission'
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13.04：提交时将评论POST到API
- en: The `new comment` submit button currently only sets a loading state for a few
    seconds and then resets – the comment is not actually being sent anywhere.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当前`new comment`提交按钮仅设置几秒钟的加载状态然后重置 - 实际上评论并没有被发送到任何地方。
- en: Let's use the `JSONPlaceholder` API as the place to send our new comment.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`JSONPlaceholder` API作为发送我们新评论的地方。
- en: When the POST request to the API succeeds, we'll add the comment to the top
    of the comments list.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当向API的POST请求成功时，我们将评论添加到评论列表的顶部。
- en: To access the code files for this exercise, refer to [https://packt.live/2IIWY3g](https://packt.live/2IIWY3g).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅[https://packt.live/2IIWY3g](https://packt.live/2IIWY3g)。
- en: 'To complete the exercise, we will perform the following steps:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成练习，我们将执行以下步骤：
- en: 'Start by making the `submitNewComment` method actually post data to `c` using
    `fetch` (which is actually `unfetch`):'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让`submitNewComment`方法实际上使用`fetch`（实际上是`unfetch`）向`c`发送数据：
- en: '[PRE36]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Unfortunately, the `fetch()` call by itself doesn''t update the data or come
    out of the loading state. In order to do so, we need to chain some `.then()` function
    calls to handle the response, and a `.catch` function call in case we have an
    error. On success (`.then`), we should get the JSON output of the request and
    add it to the front of a copy of the `comments` array. We should also reset `isSubmitting`,
    `newComment`, and `showEditor`. On error (`.catch`), we will just reset the loading
    state, `isSubmitting`, to false; we won''t clear the editor or close it since
    the user might want to try to submit it again:'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不幸的是，`fetch()`调用本身不会更新数据或退出加载状态。为了做到这一点，我们需要链式调用一些`.then()`函数来处理响应，以及一个`.catch`函数来处理错误。在成功（`.then`）的情况下，我们应该获取请求的JSON输出并将其添加到`comments`数组的副本的前面。我们还应该重置`isSubmitting`、`newComment`和`showEditor`。在错误（`.catch`）的情况下，我们只需将加载状态`isSubmitting`重置为false；我们不会清除编辑器或关闭它，因为用户可能想要再次尝试提交：
- en: '[PRE37]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We should now add new tests to the `tests/e2e/specs/add-new-comment.js` test
    suite.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在应该将新的测试添加到`tests/e2e/specs/add-new-comment.js`测试套件中。
- en: 'First of all, to be good users of `JSONPlaceholder`, we''ll stub out all the
    `GET` requests to `/comments` for the `add-new-comment` suite. In order to achieve
    this, we''ll use a `beforeEach` hook that will start the Cypress stub server (`cy.server()`)
    and stub out `GET` requests to any URL matching the `**/comments` glob with the
    `[]` response (`cy.route(''GET'', ''**/comments'', [])`):'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，为了成为好的`JSONPlaceholder`用户，我们将模拟`add-new-comment`套件中所有对`/comments`的`GET`请求。为了实现这一点，我们将使用`beforeEach`钩子来启动Cypress模拟服务器（`cy.server()`）并模拟匹配`**/comments`通配符的任何URL的`GET`请求，使用`[]`作为响应（`cy.route('GET',
    '**/comments', [])`）：
- en: '[PRE38]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can then proceed to update the `the new comment editor should show a spinner
    on submit` test since we''re not using a `setTimeout` anymore but an HTTP request.
    To start with, we need to stub out the `/comments` POST request, for which we''ll
    use the configuration object syntax for `cy.route` in order to introduce some
    delay in the HTTP request so that it doesn''t respond immediately. We alias this
    request with `.as(''newComment'')`:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以继续更新`the new comment editor should show a spinner on submit`测试，因为我们不再使用`setTimeout`，而是使用HTTP请求。首先，我们需要模拟`/comments`
    POST请求，我们将使用`cy.route`的配置对象语法来引入HTTP请求中的延迟，以便它不会立即响应。我们使用`.as('newComment')`来别名此请求：
- en: '[PRE39]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Instead of `// eventually, the spinner should stop showing`, we can now use
    `cy.wait()` to wait for the `newComment` HTTP request to complete before the check
    that the spinner is gone:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 而不是`// 最终，旋转器应该停止显示`，我们现在可以使用`cy.wait()`等待`newComment` HTTP请求完成，然后再检查旋转器是否消失：
- en: '[PRE40]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We''ve added new functionality to close the editor when the `submit` operation
    completes successfully, so we should add the relevant test. We''ll use a similar
    skeleton to the updated `loading state` test with the setup of the POST comments
    route stubbing `cy.route(''POST'', ''**/comments'', {}`, aliased as `.as(''newComment'')`.
    We can then get the new comment editor to display, add some text, and submit the
    form. We''ll then proceed to wait for the `POST` request to complete before checking
    that the editor and submit button are not visible anymore:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了新的功能，在 `submit` 操作成功完成后关闭编辑器，因此我们应该添加相关的测试。我们将使用与更新后的 `loading state` 测试类似的骨架，设置
    POST 评论路由的模拟 `cy.route('POST', '**/comments', {}', 别名为 `.as('newComment')`）。然后我们可以获取新的评论编辑器以显示，添加一些文本，并提交表单。然后我们将等待
    `POST` 请求完成，然后再检查编辑器和提交按钮是否不再可见：
- en: '[PRE41]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This test can now be run with the Cypress GUI and will pass:'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在可以使用 Cypress GUI 运行此测试，并且会通过：
- en: '![Figure 13.16: Cypress running "add-new-comment" tests, including'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 13.16：Cypress 运行 "add-new-comment" 测试，包括'
- en: the editor closing on submission test
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提交时编辑器关闭的测试
- en: '](img/B15218_13_16.jpg)'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_13_16.jpg)'
- en: 'Figure 13.16: Cypress running "add-new-comment" tests, including the editor
    closing on submission test'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 13.16：Cypress 运行 "add-new-comment" 测试，包括编辑器关闭的测试
- en: 'The second bit of functionality that we''ve added is that on completion of
    the HTTP request the new case is added to the front of the comments list. To test
    this, it''s better to change the response of the comments'' `GET` request to have
    at least one element (so that we can check that the new comment is added to the
    top of the list):'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加的第二项功能是在 HTTP 请求完成后，将新的用例添加到评论列表的前面。为了测试这一点，最好将评论的 `GET` 请求的响应改为至少包含一个元素（这样我们就可以检查新评论是否被添加到列表的顶部）：
- en: '[PRE42]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can then stub the `POST` request with some mock data, add text to the editor,
    and submit the form:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以使用一些模拟数据模拟 `POST` 请求，向编辑器添加文本，并提交表单：
- en: '[PRE43]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, we can assert on the fact that the first comment is the newly added
    comment using a combination of `cy.get()`, `.first()`, and `.contains()`:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以通过组合使用 `cy.get()`、`.first()` 和 `.contains()` 来断言第一个评论是新添加的评论：
- en: '[PRE44]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'When running the `add-new-comment` suite with the Cypress GUI, we can see the
    new test passing:'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当使用 Cypress GUI 运行 `add-new-comment` 测试套件时，我们可以看到新的测试通过：
- en: '![Figure 13.17: Cypress running "add-new-comment" tests, including'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 13.17：Cypress 运行 "add-new-comment" 测试，包括'
- en: the new comment added to the top of the list test
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 新评论添加到列表顶部的测试
- en: '](img/B15218_13_17.jpg)'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B15218_13_17.jpg)'
- en: 'Figure 13.17: Cypress running "add-new-comment" tests, including the new comment
    added to the top of the list test'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.17：Cypress 运行 "add-new-comment" 测试，包括新评论添加到列表顶部的测试
- en: We've now seen how to use Cypress to intercept HTTP requests, so in the next
    section, we'll look at some of the reporting tools Cypress provides around visual
    regression (snapshot) testing.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用 Cypress 来拦截 HTTP 请求，所以在下一节中，我们将探讨 Cypress 提供的一些关于视觉回归（快照）测试的报表工具。
- en: Visual Regression Testing with Cypress Snapshots
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Cypress 快照进行视觉回归测试
- en: The types of tests we've written with Cypress up to now have been functional
    tests, for the most part.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止使用 Cypress 编写的测试类型主要是功能测试。
- en: Functional tests check that the application *behaves* as expected. Visual tests
    check that the application *looks* as expected.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 功能测试检查应用程序是否按预期 *行为*。视觉测试检查应用程序是否按预期 *外观*。
- en: There are ways to inspect the rendered CSS, but that approach tends to be quite
    tedious and prone to breakage when the markup or styling is refactored (that is,
    the same visual output but with different rules or markup).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 有方法可以检查渲染的 CSS，但这种方法通常相当繁琐，并且在标记或样式重构时容易出错（即，相同的视觉输出，但有不同的规则或标记）。
- en: 'Fortunately, Cypress, with the `cypress-plugin-snapshots` plugin, allows us
    to take and compare snapshots of an application. First, it needs to be installed
    using the following command:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Cypress 通过 `cypress-plugin-snapshots` 插件允许我们获取并比较应用程序的快照。首先，需要使用以下命令进行安装：
- en: '[PRE45]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The plugin adds the `.toMatchImageSnapshot` method on Cypress selections. For
    it to work, we need to register it in the plugin's initialization file.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 插件在 Cypress 选择上添加了 `.toMatchImageSnapshot` 方法。为了使其工作，我们需要在插件的初始化文件中注册它。
- en: 'We should import `cypress-plugin-snapshots/plugin` and run its export `initPlugin`
    with the plugin initialization data:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该导入 `cypress-plugin-snapshots/plugin` 并使用插件初始化数据运行其 `initPlugin` 导出：
- en: '[PRE46]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We also need to register the relevant command from `cypress-plugin-snapshots/commands`,
    which can be done in the `commands.js` file:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要从`cypress-plugin-snapshots/commands`注册相关命令，这可以在`commands.js`文件中完成：
- en: '[PRE47]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We''ll also need to add some config for `cypress-plugin-snapshots` to `cypress.json`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在`cypress.json`中为`cypress-plugin-snapshots`添加一些配置：
- en: '[PRE48]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Finally, we can add a snapshot test in the `test.js` file.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在`test.js`文件中添加一个快照测试。
- en: 'First, we''ll clean up the file and stub out the `/comments` API call (this
    will be particularly useful for the snapshot test):'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将清理文件并模拟`/comments` API调用（这对于快照测试将特别有用）：
- en: '[PRE49]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, we can add the visual regression test. We''ll get the editor open to
    maximize the single snapshot test, get the whole `app` using `#app`, and snapshot
    that:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以添加视觉回归测试。我们将打开编辑器以最大化单个快照测试，使用`#app`获取整个`app`，并对其进行快照：
- en: '[PRE50]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'When running the tests with the Cypress UI, we see the following output:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Cypress UI运行测试时，我们看到以下输出：
- en: '![Figure 13.18: Cypress running tests, including the visual regression test'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.18：Cypress运行测试，包括视觉回归测试'
- en: '](img/B15218_13_18.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_13_18.jpg)'
- en: 'Figure 13.18: Cypress running tests, including the visual regression test'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.18：Cypress运行测试，包括视觉回归测试
- en: 'We can show the snapshots failing by changing the button color to red (from
    `bg-blue-500` to `bg-red-500`) in the `App.vue` file:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在`App.vue`文件中将按钮颜色改为红色（从`bg-blue-500`变为`bg-red-500`）来显示失败的快照：
- en: '[PRE51]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'When we run the relevant set of tests, they''re now failing (because, as we
    can see, the button is red instead of blue):'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行相关测试集时，它们现在失败了（因为我们可以看到，按钮是红色而不是蓝色）：
- en: '![Figure 13.19: Cypress running tests, with a failing visual regression test'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.19：Cypress运行测试，包含失败的视觉回归测试'
- en: '](img/B15218_13_19.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_13_19.jpg)'
- en: 'Figure 13.19: Cypress running tests, with a failing visual regression test'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.19：Cypress运行测试，包含失败的视觉回归测试
- en: 'By clicking on `COMPARE SNAPSHOT`, we get a visual diff view, which allows
    us to update the snapshot:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击`比较快照`，我们得到一个视觉差异视图，这允许我们更新快照：
- en: '![Figure 13.20: Cypress'' failing visual regression test diff view'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.20：Cypress的失败的视觉回归测试差异视图'
- en: '](img/B15218_13_20.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15218_13_20.jpg)'
- en: 'Figure 13.20: Cypress'' failing visual regression test diff view'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.20：Cypress的失败的视觉回归测试差异视图
- en: We've now seen how Cypress can be used to do visual regression testing.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何使用Cypress进行视觉回归测试。
- en: We'll now look at adding a new feature and all the relevant tests for it.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将查看添加新功能及其所有相关测试。
- en: 'Activity 13.01: Adding the Ability to Set a User''s Email and Tests'
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动13.01：添加设置用户电子邮件和测试的能力
- en: 'You''ll remember that we''ve hardcoded `evan@vuejs.org` as the email for any
    comments. What we''ll do in this activity is add an email input that will set
    the `email` property on comments. We''ll add the relevant tests in a new `tests/e2e/specs/enter-email.js`
    suite:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 你会记得我们将`evan@vuejs.org`硬编码为任何评论的电子邮件。在这个活动中，我们将添加一个电子邮件输入，它将设置评论上的`email`属性。我们将在新的`tests/e2e/specs/enter-email.js`测试套件中添加相关测试：
- en: In order to keep track of the email, we'll set it as a piece of reactive state
    in `data()` and add an email type input to the page, which will be two-way bound
    to `email` using `v-model`. We also add a label and corresponding markup. Note that
    we'll have a `data-test-id` attribute on the email input set to `email-input`.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了跟踪电子邮件，我们将它在`data()`中设置为一个响应式状态，并在页面上添加一个电子邮件类型输入，它将使用`v-model`双向绑定到`email`。我们还添加了一个标签和相应的标记。注意，我们将在电子邮件输入上设置一个`data-test-id`属性，设置为`email-input`。
- en: We'll now add a `beforeEach` hook to set up the Cypress mock server and stub
    out the `GET` comments (list) request. The comments list request should be aliased
    as `getComments`.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将添加一个`beforeEach`钩子来设置Cypress模拟服务器并模拟`GET`评论（列表）请求。评论列表请求应别名为`getComments`。
- en: We'll add our first test that checks whether typing into the email input works
    correctly. We'll go to the app, type an email, and check that what we typed is
    now the input value.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将添加第一个测试，检查是否在电子邮件输入中键入工作正确。我们将进入应用，输入电子邮件，并检查我们输入的内容现在是否是输入值。
- en: 'When run using the Cypress UI, we should get the following passing test:'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当使用Cypress UI运行时，我们应该得到以下通过测试：
- en: '![Figure 13.21: Cypress running "enter-email" tests, with the email input test'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图13.21：Cypress运行"enter-email"测试，包含电子邮件输入测试'
- en: '](img/B15218_13_21.jpg)'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B15218_13_21.jpg)'
- en: 'Figure 13.21: Cypress running "enter-email" tests, with the email input test'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图13.21：Cypress运行"enter-email"测试，包含电子邮件输入测试
- en: Having the `email` property is a pre-requisite to adding comments, so we'll
    disable the `Add a New Comment` button while `email` is empty (`!email`). We'll
    bind to the `disabled` attribute and toggle some classes based on whether or not
    the `email` field is populated.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拥有 `email` 属性是添加评论的先决条件，因此当 `email` 为空时（`!email`），我们将禁用 `添加新评论` 按钮。我们将绑定到 `disabled`
    属性，并根据 `email` 字段是否已填充来切换一些类。
- en: With this new `disable add new comment button while email is empty` functionality,
    we should add a new E2E test. We'll load up the page and on initial load, we'll
    check that the email input is empty and that the `Add a New Comment` button is
    disabled. We'll then type an email into the email input field and check that the
    `Add a New Comment` button is now *not* disabled, which means it is enabled.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这个新的 `当 email 为空时禁用添加新评论按钮` 功能，我们应该添加一个新的端到端测试。我们将加载页面，并在初始加载时检查电子邮件输入是否为空，以及
    `添加新评论` 按钮是否被禁用。然后我们将在电子邮件输入字段中输入电子邮件，并检查 `添加新评论` 按钮现在是否 *未* 禁用，这意味着它已被启用。
- en: 'When run using the Cypress UI, we should see the new test passing with the
    following output:'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当使用 Cypress UI 运行时，我们应该看到新的测试通过，输出如下：
- en: '![Figure 13.22: Cypress running "enter-email" tests, with the disabled'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 13.22：Cypress 运行 "enter-email" 测试，禁用添加评论按钮测试]'
- en: add comment button test
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加评论按钮测试
- en: '](img/B15218_13_22.jpg)'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 13.22](img/B15218_13_22.jpg)'
- en: 'Figure 13.22: Cypress running "enter-email" tests, with the disabled add comment
    button test'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 13.22：Cypress 运行 "enter-email" 测试，禁用添加评论按钮测试
- en: Now that we've got a way to capture the email, we should pass it to the backend
    API when making the POST comments call (that is, when submitting a new comment).
    In order to do this, we should modify the spot in `methods.submitNewComment` where
    `email` is hardcoded as `evan@vuejs.org`.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了捕获电子邮件的方法，我们应该在调用 POST 评论时将其传递给后端 API（即提交新评论时）。为了做到这一点，我们应该修改 `methods.submitNewComment`
    中将 `email` 固定为 `evan@vuejs.org` 的位置。
- en: Now that we're using the email that's been input by the user, we should write
    an E2E test to check that it's being sent. We'll stub out the POST request, alias
    it to `newComment`, and send back an arbitrary value. We can then visit the page,
    fill out the email input, open the comment editor, fill that out, and submit it.
    We'll then wait on the `newComment` request and assert on the request body that
    the body and email are as they were when we completed them.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们正在使用用户输入的电子邮件，我们应该编写一个端到端测试来检查它是否被发送。我们将模拟 POST 请求，将其别名为 `newComment`，并返回一个任意值。然后我们可以访问页面，填写电子邮件输入，打开评论编辑器，填写内容，并提交。然后我们将等待
    `newComment` 请求，并断言请求体中的内容和电子邮件与我们完成它们时相同。
- en: Note
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: We could also opt to not stub out the `POST` request and instead check that
    the new comment card inserted on the page contains the right email and body.
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们也可以选择不模拟 `POST` 请求，而是检查新插入页面上的评论卡片是否包含正确的电子邮件和内容。
- en: 'When run using the Cypress UI, we get the following test run output:'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当使用 Cypress UI 运行时，我们得到以下测试运行输出：
- en: '![Figure 13.23: Cypress running "enter-email" tests, with the email input test'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 13.23：Cypress 运行 "enter-email" 测试，电子邮件输入测试]'
- en: '](img/B15218_13_23.jpg)'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 13.22](img/B15218_13_23.jpg)'
- en: 'Figure 13.23: Cypress running "enter-email" tests, with the email input test'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.23：Cypress 运行 "enter-email" 测试，电子邮件输入测试
- en: Note
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found via [this link](B15218_Solution_Final_SZ_ePub.xhtml#_idTextAnchor408).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以通过[此链接](B15218_Solution_Final_SZ_ePub.xhtml#_idTextAnchor408)找到。
- en: Summary
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Throughout this chapter, we've looked at leveraging Cypress to test Vue.js applications
    from end to end.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何利用 Cypress 从端到端测试 Vue.js 应用程序。
- en: E2E tests in general are useful to give us a high level of confidence that tested
    flows will work as expected, as opposed to unit or integration tests, which validate
    that our code works as expected at a much lower overhead.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试通常非常有用，可以给我们一个高度信心，即测试的流程将按预期工作，而不是单元或集成测试，后者以更低的开销验证我们的代码是否按预期工作。
- en: We've seen how to use Cypress to inspect, interact with, and assert against
    a UI. We've also shown how Cypress' default wait/retry functionality is a great
    advantage while writing robust tests.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了如何使用 Cypress 来检查、交互和断言 UI。我们还展示了 Cypress 的默认等待/重试功能在编写健壮测试时的巨大优势。
- en: We leveraged Cypress' HTTP interception library to stub out HTTP requests and
    make tests more predictable and faster.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用 Cypress 的 HTTP 请求拦截库来模拟 HTTP 请求，使测试更加可预测和快速。
- en: Finally, we looked at how to set up visual regression testing with Cypress.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了如何使用 Cypress 设置视觉回归测试。
- en: In the next chapter, we'll look at how to deploy a Vue.js application to the
    web.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何将 Vue.js 应用程序部署到网页上。
