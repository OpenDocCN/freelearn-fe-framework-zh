<html><head></head><body>
		<div id="_idContainer032" class="calibre2">
			<h1 id="_idParaDest-62" class="chapter-number"><a id="_idTextAnchor061" class="pcalibre1 calibre6 pcalibre"/>4</h1>
			<h1 id="_idParaDest-63" class="calibre7"><a id="_idTextAnchor062" class="pcalibre1 calibre6 pcalibre"/>Implementing the Multi-SPA Pattern for Microfrontends</h1>
			<p class="calibre3">Imagine you are an architect tasked with building the frontend for a large government ePortal that has and provides numerous online services for individuals and businesses. These services include registering for health benefits, submitting accounts for income tax, registering a small business, and paying vehicle road tax, in addition to publishing a whole bunch of <span>informational content.</span></p>
			<p class="calibre3">Or, scenario two, imagine you have been tasked to build a banking portal that provides multiple online services, from managing saving accounts to buying insurance, to investment opportunities, loans, mortgages, credit cards, and <span>so on.</span></p>
			<p class="calibre3">How would you go about planning not just your architecture but also the team that will be responsible for building it? Naturally, the first level of thinking would be to break down the large portal into multiple smaller modules or mini-apps and have each team focus on one of <span>these mini-apps.</span></p>
			<p class="calibre3">This would be the right approach, and this is also what we refer to as the multi-SPA pattern for <span>building microfrontends.</span></p>
			<p class="calibre3">In this chapter, we will go about building our multi-SPA pattern microfrontend, where we will look at <span>the following:</span></p>
			<ul class="calibre15">
				<li class="calibre14">The high-level architecture of the <span>multi-SPA microfrontend</span></li>
				<li class="calibre14">Establishing routing <span>between multi-SPAs</span></li>
				<li class="calibre14">Using a shared <span>component library</span></li>
				<li class="calibre14">Setting up a persistent state to share state between <span>mini apps</span></li>
			</ul>
			<h1 id="_idParaDest-64" class="calibre7"><a id="_idTextAnchor063" class="pcalibre1 calibre6 pcalibre"/>Technical requirements</h1>
			<p class="calibre3">As we go through the code examples in this chapter, we will need <span>the following:</span></p>
			<ul class="calibre15">
				<li class="calibre14">A PC, Mac, or Linux desktop or laptop with at least 8 GB of RAM (16 <span>GB preferred)</span></li>
				<li class="calibre14">An Intel chipset i5+ or Mac <span>M1+ chipset</span></li>
				<li class="calibre14">At least 256 GB of free hard <span>disk storage</span></li>
			</ul>
			<p class="calibre3">You will also need the following software installed on <span>your computer:</span></p>
			<ul class="calibre15">
				<li class="calibre14">Node.js version 16+ (use <strong class="source-inline1">nvm</strong> to manage different versions of Node.js if you <span>have to)</span></li>
				<li class="calibre14">Terminal: iTerm2 with OhMyZsh (you will thank <span>me later)</span></li>
				<li class="calibre14">IDE: We strongly recommend VS Code as we will be making use of some of the plugins that come with VS Code for an improved <span>developer experience</span></li>
				<li class="calibre14">npm, yarn, or pnpm – we recommend pnpm because it’s fast <span>and storage-efficient</span></li>
				<li class="calibre14">Browser: Chrome, Microsoft Edge, or Firefox (I <span>use Firefox)</span></li>
				<li class="calibre14">A basic understanding of Nx.dev monorepos and a basic understanding of using the NX Console plugin in <span>VS Code</span></li>
				<li class="calibre14">Working knowledge <span>of React</span></li>
			</ul>
			<p class="calibre3">The code files for this chapter can be found <span>here: </span><a href="https://github.com/PacktPublishing/Building-Micro-Frontends-with-React" class="pcalibre1 calibre6 pcalibre"><span>https://github.com/PacktPublishing/Building-Micro-Frontends-with-React</span></a></p>
			<p class="calibre3">We also assume you have a basic working knowledge of Git, such as branching, committing code, and raising <span>pull requests.</span></p>
			<h1 id="_idParaDest-65" class="calibre7"><a id="_idTextAnchor064" class="pcalibre1 calibre6 pcalibre"/>Understanding the multi-SPA architecture</h1>
			<p class="calibre3">The multi-SPA architecture <a id="_idIndexMarker121" class="pcalibre1 calibre6 pcalibre"/>pattern is one of the most common patterns for building large-scale applications. As the name suggests, in this pattern, we have a collection of SPAs that together form a large application. In this pattern, each SPA behaves as its own independent feature or module that can be directly accessed via a URL namespaced and mapped to the app. These SPAs also share a very thin layer of shared components and global state to ensure coherency and consistency between <span>the apps.</span></p>
			<div class="calibre2">
				<div id="_idContainer026" class="img---figure">
					<img src="image/Figure_4.01_B18987.jpg" alt="Figure 4.1 – The multi-SPA architecture" class="calibre4"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.1 – The multi-SPA architecture</p>
			<p class="calibre3">As you can<a id="_idIndexMarker122" class="pcalibre1 calibre6 pcalibre"/> see in <span><em class="italic">Figure 4</em></span><em class="italic">.1</em>, we have four SPAs: a catalog, which will hold pages such as product listings, product details, search, and so on; a checkout SPA containing pages such as shopping cart, payments, and so on; the MyAccounts SPA; and the Seller/Admin SPA. You will also notice that this pattern allows us to easily add additional SPAs as the <span>application grows.</span></p>
			<p class="calibre3">Each of these SPAs is mapped to a unique primary URL, such that users clicking the <strong class="source-inline">/catalog</strong> URL will be redirected to the catalog app, while users clicking the <strong class="source-inline">/checkout</strong> URL will go to the <span>checkout app.</span></p>
			<h1 id="_idParaDest-66" class="calibre7"><a id="_idTextAnchor065" class="pcalibre1 calibre6 pcalibre"/>Building our Multi-SPA Microfrontend</h1>
			<p class="calibre3">Building a multi-SPA <a id="_idIndexMarker123" class="pcalibre1 calibre6 pcalibre"/>microfrontend essentially consists of three broad areas: breaking down the app into logical mini-apps, then we need to set up the routing between these mini-apps, and finally, we set up a global state the different mini-apps can read and write data to. Let us look at each of them in the <span>subsequent sections.</span></p>
			<h2 id="_idParaDest-67" class="calibre5"><a id="_idTextAnchor066" class="pcalibre1 calibre6 pcalibre"/>Setting up our mini-apps</h2>
			<p class="calibre3">We will start <a id="_idIndexMarker124" class="pcalibre1 calibre6 pcalibre"/>with where we left off in the <a id="_idIndexMarker125" class="pcalibre1 calibre6 pcalibre"/><span>previous chapter.</span></p>
			<p class="calibre3">In case you skipped the previous chapter and are directly jumping in here, you can start by cloning the repo <span>from </span><a href="https://github.com/PacktPublishing/Building-Micro-Frontends-with-React/tree/main/ch3/my-mfe" class="pcalibre1 calibre6 pcalibre"><span>https://github.com/PacktPublishing/Building-Micro-Frontends-with-React/tree/main/ch3/my-mfe</span></a><span>.</span></p>
			<p class="calibre3">Let us quickly run <strong class="source-inline">pnpm install</strong> (if you haven’t already done so) and serve the respective apps to make sure that they are <span>running properly.</span></p>
			<p class="calibre3">Since we are going to build an e-commerce application, let us call our app <em class="italic">eBuy</em>. Feel free to rename your app folder <span>to </span><span><strong class="source-inline">ebuy</strong></span><span>.</span></p>
			<p class="calibre3">During active development, we would ideally be working on our own respective mini-app and you could easily use the NX Console to serve your <span>respective app.</span></p>
			<p class="calibre3">However, periodically you may want to test the entire end-to-end app flow across the different mini-apps and for that, it is important that you are able to run all the mini-apps locally. This is exactly what we are going to <span>do next.</span></p>
			<p class="calibre3">We first need to ensure that each mini-app runs on its own unique port. To do this, we need to first locate the <strong class="source-inline">project.json</strong> file located in the <strong class="source-inline">apps/catalog</strong> folder. You will notice it basically contains all the commands and configuration needed to run the various tasks on <span>your app.</span></p>
			<p class="calibre3">We navigate to the <strong class="source-inline">"serve":</strong> section and under <strong class="source-inline">"options"</strong>, add the line <strong class="source-inline">"</strong><span><strong class="source-inline">port": 4200</strong></span><span>:</span></p>
			<pre class="source-code">
    "serve": {
      "executor": "@nrwl/web:dev-server",
      "defaultConfiguration": "development",
      "options": {
        "buildTarget": "catalog:build",
        "hmr": true,
        <strong class="bold1">"port": 4200</strong>
      },
      "configurations": {
        "development": {
          "buildTarget": "catalog:build:development",
        },
        "production": {
          "buildTarget": "catalog:build:production",
          "hmr": false
        }
      }
    },</pre>			<p class="calibre3">We do the exact <a id="_idIndexMarker126" class="pcalibre1 calibre6 pcalibre"/>same thing in the <strong class="source-inline">project.json</strong> file <a id="_idIndexMarker127" class="pcalibre1 calibre6 pcalibre"/>located in the <strong class="source-inline">apps/checkout</strong> folder, but this time we will ensure this runs on <strong class="source-inline">"port": 4201</strong> <span>like so:</span></p>
			<pre class="source-code">
      "options": {
        "buildTarget": "checkout:build",
        "hmr": true,
        <strong class="bold1">"port": 4201</strong>
      },</pre>			<p class="calibre3">This will ensure that, by default, the catalog will run on port <strong class="source-inline">4200</strong> while the checkout app runs on <span>port </span><span><strong class="source-inline">4201</strong></span><span>.</span></p>
			<p class="calibre3">Thanks to inheritance, we will be able to run the app in development and production mode from the <span>same ports.</span></p>
			<p class="calibre3">Next, we will create a script command that will allow us to run all the apps in parallel on their <span>respective ports.</span></p>
			<p class="calibre3">For this, we go into the <strong class="source-inline">package.json</strong> file located at the root of the project and add a script called <strong class="source-inline">"serve:all": "nx </strong><span><strong class="source-inline">run-many --target=serve"</strong></span><span>:</span></p>
			<pre class="source-code">
  "scripts": {
    "start": "nx serve",
    "build": "nx build",
    "test": "nx test",
    <strong class="bold1">"serve:all": "nx run-many --target=serve"</strong>
  },</pre>			<p class="calibre3">Now, in your terminal, run the <span>following command:</span></p>
			<pre class="console">
pnpm serve:all</pre>			<p class="calibre3">You will see <strong class="source-inline">nx</strong> is starting up the webpack development server and is launching the <span>two apps.</span></p>
			<p class="calibre3">Verify it by visiting these two URLs in <span>the browser:</span></p>
			<ul class="calibre15">
				<li class="calibre14">Catalog <span>app: </span><span><strong class="source-inline1">http://localhost:4200</strong></span></li>
				<li class="calibre14">Checkout <span>app: </span><span><strong class="source-inline1">http://localhost:4201</strong></span></li>
			</ul>
			<p class="calibre3">With microfrontends, it is important that each SPA follows the same brand guidelines and look and<a id="_idIndexMarker128" class="pcalibre1 calibre6 pcalibre"/> feel. We ensure this by building a<a id="_idIndexMarker129" class="pcalibre1 calibre6 pcalibre"/> shared set of UI components that both apps make use of. In the next section, we will see how to create a shared <span>component library.</span></p>
			<h2 id="_idParaDest-68" class="calibre5"><a id="_idTextAnchor067" class="pcalibre1 calibre6 pcalibre"/>Using a shared component library</h2>
			<p class="calibre3">As you are<a id="_idIndexMarker130" class="pcalibre1 calibre6 pcalibre"/> building a series of <a id="_idIndexMarker131" class="pcalibre1 calibre6 pcalibre"/>mini-apps as part of your overall bigger app, we want to ensure that all these mini-apps have a consistent design – things such as having a consistent header and footer and a consistent way for the various components to behave. What is equally important is, when we make a change to some of these core elements, we need to ensure that it can be updated across all the different apps without too much trouble. This is where the <strong class="source-inline">libs</strong> folder comes <span>into play.</span></p>
			<p class="calibre3">This would also be a good time to define an NPM scope so that all these shared components can be imported via their <span>scope names.</span></p>
			<p class="calibre3">To define an NPM scope, we open up the <strong class="source-inline">nx.json</strong> file located at the root of the monorepo. We are going to name our scope <strong class="source-inline">ebuy</strong> but in reality, it could be anything – the name of your team, the name you have for your component library, and <span>so on.</span></p>
			<p class="calibre3">Locate the <strong class="source-inline">npmScope</strong> property in the <strong class="source-inline">nx.json</strong> file and update it <span>as follows:</span></p>
			<pre class="source-code">
  "npmScope": "ebuy",</pre>			<p class="calibre3">Let us use our trustworthy Nx Console to create a library. From Nx Console, select <strong class="source-inline">generate</strong> and then select <strong class="source-inline">@nrwl/react – library </strong><span><strong class="source-inline">React Library</strong></span><span>.</span></p>
			<p class="calibre3">Select the <strong class="bold">Show all options</strong> and provide/modify the following details and leave the rest as <span>the default:</span></p>
			<pre class="console">
Library name   : ui
Generate a default component    : No
importPath : @ebuy/ui</pre>			<p class="calibre3">We can leave the rest as the default and click the run button to generate the <strong class="source-inline">ui</strong> folder <span>within </span><span><strong class="source-inline">libs</strong></span><span>.</span></p>
			<p class="calibre3">In addition to <a id="_idIndexMarker132" class="pcalibre1 calibre6 pcalibre"/>creating the <strong class="source-inline">ui</strong> folder <a id="_idIndexMarker133" class="pcalibre1 calibre6 pcalibre"/>within <strong class="source-inline">libs</strong>, you will notice Nx has also added an entry into the <strong class="source-inline">paths</strong> object of <strong class="source-inline">tsconfig.base.json</strong> <span>as follows:</span></p>
			<pre class="source-code">
    "paths": {
      "@ebuy/ui": ["libs/ui/src/index.ts"]
    }</pre>			<p class="calibre3">It is this setting that will allow us to import our UI components via the scoped name instead of a long <span>folder path.</span></p>
			<p class="calibre3">Next, let’s create a couple of <span>UI components.</span></p>
			<p class="calibre3">We will use the awesome Semantic-UI React component library to build out our UI components. You can also use any other component library, such as Chakra UI, MUI React-Bootstrap, and <span>so on:</span></p>
			<ol class="calibre13">
				<li class="calibre14">Let’s install it on the root of the monorepo using the <span>following command:</span><pre class="source-code">
<strong class="bold1">pnpm install semantic-ui-react semantic-ui-css</strong></pre></li>				<li class="calibre14">Remember you can always use <strong class="source-inline1">npm</strong> or <strong class="source-inline1">yarn</strong> to install npm packages <span>as follows:</span><pre class="source-code">
yarn add semantic-ui-react semantic-ui-css
npm install semantic-ui-react semantic-ui-css</pre><p class="calibre3">Now let’s create a couple of our common components in the <span><strong class="source-inline">libs/ui</strong></span><span> folder.</span></p></li>				<li class="calibre14">Let us use Nx Console and create a <span>new component:</span><p class="calibre3"><strong class="bold">Nx</strong> | <strong class="bold">Generate</strong> |<strong class="bold"> Create a </strong><span><strong class="bold">react component</strong></span></p></li>
				<li class="calibre14">Use the following information to create <span>the component:</span><ul class="calibre16"><li class="calibre14"><span><strong class="bold">Name</strong></span><span>: </span><span><strong class="source-inline1">header</strong></span></li><li class="calibre14"><span><strong class="bold">Project</strong></span><span>: </span><span><strong class="source-inline1">ui</strong></span></li><li class="calibre14"><strong class="bold">Flat</strong>: Select the checkbox to ensure we have a flatter folder <span>structure within</span></li></ul></li>
				<li class="calibre14">Hit the run<a id="_idIndexMarker134" class="pcalibre1 calibre6 pcalibre"/> button and<a id="_idIndexMarker135" class="pcalibre1 calibre6 pcalibre"/> verify the <strong class="source-inline1">header.tsx</strong> file is created within the <span><strong class="source-inline1">libs/ui/src/lib</strong></span><span> folder.</span></li>
				<li class="calibre14">Open the <strong class="source-inline1">header.tsx</strong> file and replace the contents of it with simple markup for our <span>header component:</span><pre class="source-code">
import { Menu, Container, Icon, Label } from 'semantic-ui-react';
export function Header() {
  return (
    &lt;Menu fixed="top" inverted&gt;
      &lt;Container&gt;
        &lt;Menu.Item as="a" header&gt;
          eBuy.com
        &lt;/Menu.Item&gt;
        &lt;MenuItems /&gt;
        &lt;Menu.Item position="right"&gt;
          &lt;Label&gt;
            &lt;Icon name="shopping cart" /&gt;
            00
          &lt;/Label&gt;
        &lt;/Menu.Item&gt;
      &lt;/Container&gt;
    &lt;/Menu&gt;
  );
}
const MenuItems = () =&gt; {
  return (
    &lt;&gt;
      {NAV_ITEMS.map((navItem, index) =&gt; (
        &lt;Menu.Item key={index}&gt;
          &lt;a href={navItem.href ?? '#'}&gt;{navItem.label}&lt;/a&gt;
        &lt;/Menu.Item&gt;
      ))}
    &lt;/&gt;
  );
};
interface NavItem {
  label: string;
  href?: string;
}
const NAV_ITEMS: Array&lt;NavItem&gt; = [
  {
    label: 'Catalog',
    href: '/',
  },
  {
    label: 'Checkout',
    href: '/checkout',
  },
];
export default Header;</pre><p class="calibre3">This is simple React component code that will display the header with navigation<a id="_idIndexMarker136" class="pcalibre1 calibre6 pcalibre"/> for the<a id="_idIndexMarker137" class="pcalibre1 calibre6 pcalibre"/> catalog <span>and checkout.</span></p></li>				<li class="calibre14">The next step is to export it out it from the <strong class="source-inline1">ui</strong>. Locate the <strong class="source-inline1">/libs/ui/src/index.ts</strong> file and add an entry <span>as follows:</span><pre class="source-code">
export * from './lib/header';</pre><p class="calibre3">This will allow our header component to be importable via our shorter import path. Now let us import it into our catalog and <span>checkout apps.</span></p></li>				<li class="calibre14">Open the <strong class="source-inline1">apps/catalog/src/spp/app.tsx</strong> file and import the header component <span>as follows:</span><pre class="source-code">
import { Header } from '@ebuy/ui';</pre></li>				<li class="calibre14">Let us clean up some of the boilerplate code. Remove the imports for <strong class="source-inline1">styles</strong> and <strong class="source-inline1">NxWelcome</strong> and add the <strong class="source-inline1">Header</strong> component in the JSX. You can also delete the <strong class="source-inline1">nx-welcome.tsx</strong> file in the <strong class="source-inline1">catalog</strong> folder. Your final code should look <span>like this:</span><pre class="source-code">
import { Header } from '@ebuy/ui';
import { Container, Header as Text } from 'semantic-ui-react';
import 'semantic-ui-css/semantic.min.css';
export function App() {
  return (
    &lt;Container style={{ marginTop: '5rem' }}&gt;
      &lt;Header /&gt;
      &lt;Text size="huge"&gt;Catalog App&lt;/Text&gt;
    &lt;/Container&gt;
  );
}
export default App;</pre><p class="calibre3">In <a id="_idIndexMarker138" class="pcalibre1 calibre6 pcalibre"/>the <a id="_idIndexMarker139" class="pcalibre1 calibre6 pcalibre"/>preceding code, we import the semantic-ui’s css file and include our <strong class="source-inline">Header</strong> component and text that displays the name of <span>the app.</span></p><p class="calibre3">When running in the browser, the catalog app will look something <span>like this:</span></p></li>			</ol>
			<div class="calibre2">
				<div id="_idContainer027" class="img---figure">
					<img src="image/Figure_4.02_B18987.jpg" alt="Figure 4.2 – Catalog app with the common header menu bar" class="calibre4"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.2 – Catalog app with the common header menu bar</p>
			<ol class="calibre13">
				<li value="10" class="calibre14">We will make the same changes to the <strong class="source-inline1">apps/checkout/src/app/app.tsx</strong> file within the <span>checkout app.</span></li>
				<li class="calibre14">Let us test out our code. Run <strong class="source-inline1">pnpm serve:all</strong> and refresh your browser on <strong class="source-inline1">http://localhost:4200</strong> to see our <span>latest changes.</span></li>
			</ol>
			<p class="calibre3">Try clicking on <a id="_idIndexMarker140" class="pcalibre1 calibre6 pcalibre"/>the navigation <a id="_idIndexMarker141" class="pcalibre1 calibre6 pcalibre"/>links for the catalog or checkout and notice it doesn’t do anything. That is because we haven’t set up routing between our apps, which is exactly what we will be <span>doing next.</span></p>
			<h2 id="_idParaDest-69" class="calibre5"><a id="_idTextAnchor068" class="pcalibre1 calibre6 pcalibre"/>Setting up Routing</h2>
			<p class="calibre3">As we discussed <a id="_idIndexMarker142" class="pcalibre1 calibre6 pcalibre"/>earlier, from time to time, we<a id="_idIndexMarker143" class="pcalibre1 calibre6 pcalibre"/> would like to test our end-to-end app functionality, and although we are able to run apps in parallel on different ports, there are some challenges with testing <span>end-to-end functionality:</span></p>
			<ul class="calibre15">
				<li class="calibre14">We need to ensure a consistent navigation structure for our apps both on localhost and <span>on production.</span></li>
				<li class="calibre14">Apps running on different ports are treated as apps on different domains and hence it will not be possible to share cookies, session states, and <span>so on</span></li>
			</ul>
			<p class="calibre3">To overcome these problems, we need to make the browser think the apps are running on the same port. We do this by setting up a reverse proxy. The way we will set up routing is each mini-app will have its own namespaced primary route, <span>for example:</span></p>
			<ul class="calibre15">
				<li class="calibre14"><strong class="source-inline1">eBuy.com</strong>: Home <span>page app</span></li>
				<li class="calibre14"><strong class="source-inline1">eBuy.com/catalog</strong>: <span>Catalog app</span></li>
				<li class="calibre14"><strong class="source-inline1">eBuy.com/checkout</strong>: <span>Checkout app</span></li>
			</ul>
			<p class="calibre3">The secondary routes are generally set up within the mini-apps themselves. For example, the product details page for, say, apples would <span>be </span><span><strong class="source-inline">eBuy.com/catalog/apples</strong></span><span>.</span></p>
			<p class="calibre3">Webpack development servers and Nx come with easy-to-use proxy support that we can take <span>advantage of.</span></p>
			<p class="calibre3">At the root of<a id="_idIndexMarker144" class="pcalibre1 calibre6 pcalibre"/> the catalog app, <strong class="source-inline">/apps/catalog</strong>, let us <a id="_idIndexMarker145" class="pcalibre1 calibre6 pcalibre"/>create a new file called <strong class="source-inline">proxy.conf.json</strong> with the <span>following entries:</span></p>
			<pre class="source-code">
{
  "/catalog": {
    "target": "http://localhost:4200"
  },
  "/checkout": {
    "target": "http://localhost:4201"
  }
}</pre>			<p class="calibre3">Next, we need to tell the catalog app to use this file for its <span>proxy configuration.</span></p>
			<p class="calibre3">We do this by adding the <strong class="source-inline">proxyConfig</strong> property to the development configuration under the serve object in the <strong class="source-inline">apps/catalog/project.json</strong> file <span>as follows:</span></p>
			<pre class="source-code">
    "options": {
        "buildTarget": "catalog:build",
        "hmr": true,
        "port": 4200,
<strong class="bold1">        "proxyConfig": "apps/catalog/proxy.conf.json"</strong>
      },</pre>			<p class="calibre3">Let us quickly test it out. We will need to restart our development servers to pick up the latest <span>proxy configurations.</span></p>
			<p class="calibre3">Run the <strong class="source-inline">serve:all</strong> command and try clicking on the <strong class="bold">Checkout</strong> and <strong class="bold">Catalog</strong> navigation links… Erm… It didn’t work and the same catalog app shows up when you click on the <strong class="bold">Checkout</strong> link... But wait – the title tag on the browser tab does <span>show </span><span><strong class="bold">Checkout</strong></span><span>:</span></p>
			<div class="calibre2">
				<div id="_idContainer028" class="img---figure">
					<img src="image/Figure_4.03_B18987.jpg" alt="Figure 4.3 – Checkout app in the title but loading the catalog bundle" class="calibre4"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.3 – Checkout app in the title but loading the catalog bundle</p>
			<p class="calibre3">So, what’s <a id="_idIndexMarker146" class="pcalibre1 calibre6 pcalibre"/>happening here? If you look at the <a id="_idIndexMarker147" class="pcalibre1 calibre6 pcalibre"/>development tools, the problem becomes quite obvious. What’s happening here is the proxy has correctly redirected us to the checkout app and that’s why we see the correct <strong class="source-inline">index.html</strong> file served via the checkout app, however, the script’s <strong class="source-inline">src</strong> tags loading the <strong class="source-inline">js</strong> bundles point to the root and hence they are actually loading the <strong class="source-inline">js</strong> bundles from the <span>catalog app.</span></p>
			<p class="calibre3">Fixing this problem is relatively easy again thanks <span>to Nx.</span></p>
			<p class="calibre3">We simply need to define the <strong class="source-inline">baseRef</strong> for the checkout app. We do this by adding <strong class="source-inline">"baseHref": "/checkout/"</strong> to the <strong class="source-inline">/</strong><span><strong class="source-inline">apps/checkout/project.json</strong></span><span> file.</span></p>
			<p class="calibre3">This is what your development object under the parent serve object should <span>look like:</span></p>
			<pre class="source-code">
     "options": {
          "buildTarget": "checkout:build:development",
          "port": 4201,
          "baseHref": "/checkout/"
        },</pre>			<p class="calibre3">Restart the development servers and now you will be able to navigate between the two applications and have the right JS bundles load in. In the next section, we will work toward adding a <a id="_idIndexMarker148" class="pcalibre1 calibre6 pcalibre"/>product list response to<a id="_idIndexMarker149" class="pcalibre1 calibre6 pcalibre"/> simulate the mocked response from a product list <span>API call.</span></p>
			<h2 id="_idParaDest-70" class="calibre5"><a id="_idTextAnchor069" class="pcalibre1 calibre6 pcalibre"/>Setting up a mocked product list</h2>
			<p class="calibre3">A common practice <a id="_idIndexMarker150" class="pcalibre1 calibre6 pcalibre"/>with all web<a id="_idIndexMarker151" class="pcalibre1 calibre6 pcalibre"/> development activities is to set up a mock server or a mocked set of API responses that the frontend apps can consume until the actual APIs are ready. Since our e-commerce app requires a list of products that will be required across all the other mini-apps, we create a shared library to hold <span>our mocks.</span></p>
			<p class="calibre3">So again, using our favorite, Nx Console, let us create another React library, let us call it <strong class="source-inline">mocks</strong>, and we will use the scope <span>name </span><span><strong class="source-inline">@ebuy/mocks</strong></span><span>.</span></p>
			<p class="calibre3">Within the <strong class="source-inline">mocks</strong> library at <strong class="source-inline">libs/mocks/src/lib</strong>, let us create our file called <strong class="source-inline">product-list-mocks.tsx</strong> with the <span>following code:</span></p>
			<pre class="source-code">
interface productListItem {
  id: string;
  title: string;
  image: string;
  price: number;
}
export const PRODUCT_LIST_MOCKS: Array&lt;productListItem&gt; = [
  {
    id: '1',
    title: 'Apples',
    image: '/assets/apple.jpg',
    price: 1.99,
  },
  {
    id: '2',
    title: 'Oranges',
    image: '/assets/orange.jpg',
    price: 2.5,
  },
  {
    id: '3',
    title: 'Bananas',
    image: '/assets/banana.jpg',
    price: 0.7,
  },
];
export default PRODUCT_LIST_MOCKS;</pre>			<p class="calibre3">Let us not forget to export it out from the <strong class="source-inline">/libs/mocks/src/index.ts</strong> file with the following line <span>of code:</span></p>
			<pre class="source-code">
export * from './lib/product-list-mocks';</pre>			<p class="calibre3">Also, don’t <a id="_idIndexMarker152" class="pcalibre1 calibre6 pcalibre"/>forget to place the <a id="_idIndexMarker153" class="pcalibre1 calibre6 pcalibre"/>product images in the <strong class="source-inline">catalog</strong> app’s <strong class="source-inline">src/assets</strong> folder. You can find the images <span>here </span><a href="https://github.com/PacktPublishing/Building-Micro-Frontends-with-React-18/tree/main/ch4/ebuy/apps/catalog/src/assets" class="pcalibre1 calibre6 pcalibre"><span>https://github.com/PacktPublishing/Building-Micro-Frontends-with-React-18/tree/main/ch4/ebuy/apps/catalog/src/assets</span></a><span>.</span></p>
			<p class="calibre3">We will now look to use this across our apps, wherever we need data from the <span>product list.</span></p>
			<h2 id="_idParaDest-71" class="calibre5"><a id="_idTextAnchor070" class="pcalibre1 calibre6 pcalibre"/>Adding the product grid and checkout components</h2>
			<p class="calibre3">Now we have <a id="_idIndexMarker154" class="pcalibre1 calibre6 pcalibre"/>a decent-looking header and an<a id="_idIndexMarker155" class="pcalibre1 calibre6 pcalibre"/> app where we <a id="_idIndexMarker156" class="pcalibre1 calibre6 pcalibre"/>can <a id="_idIndexMarker157" class="pcalibre1 calibre6 pcalibre"/>navigate from one mini-app to the other. However, the rest of the app doesn’t do much, so let’s add a product list component to the catalog app and a shopping basket component to the <span>checkout app.</span></p>
			<p class="calibre3">We will start by creating the <strong class="source-inline">ProductList</strong> component within our <strong class="source-inline">/apps/catalog/src/app</strong> folder. We will name the file <strong class="source-inline">product-list.tsx</strong>. We will start by creating an empty <span>shell component:</span></p>
			<pre class="source-code">
import { Card } from 'semantic-ui-react';
import ProductCard from './product-card';
import { PRODUCT_LIST_MOCKS } from '@ebuy/mocks';
export function ProductList() {
  return (
    &lt;Card.Group&gt;
      {PRODUCT_LIST_MOCKS.map((product) =&gt; (
        &lt;ProductCard key={product.id} product={product} /&gt;
      ))}
    &lt;/Card.Group&gt;
  );
}
export default ProductList;</pre>			<p class="calibre3">We will get an error for the missing <strong class="source-inline">ProductCard</strong> component. Don’t worry – we will create that component in the next step. Next, we need to create our <strong class="source-inline">ProductCard</strong> component. We will name the <span>file </span><span><strong class="source-inline">product-card.tsx</strong></span><span>.</span></p>
			<p class="calibre3">We start by defining the skeleton of our <span><strong class="source-inline">ProductCard</strong></span><span> component:</span></p>
			<pre class="source-code">
import { Button, Card, Image } from 'semantic-ui-react';
export function ProductCard(productData: any) {
  const { product } = productData;
  return (
    &lt;Card&gt;
      &lt;Card.Content&gt;
        &lt;Image alt={product.title} src={product.image} /&gt;
        &lt;Card.Header&gt;{product.title}&lt;/Card.Header&gt;
        &lt;Card.Description&gt;{product.description}&lt;/Card.Description&gt;
        &lt;Card.Header&gt;${product.price}&lt;/Card.Header&gt;
      &lt;/Card.Content&gt;
      &lt;Card.Content extra&gt;
        &lt;div className="ui three buttons"&gt;
          &lt;Button basic color="red"&gt;
            Remove
          &lt;/Button&gt;
          &lt;Button basic color="blue"&gt;
            {0}
          &lt;/Button&gt;
          &lt;Button basic color="green"&gt;
            Add
          &lt;/Button&gt;
        &lt;/div&gt;
      &lt;/Card.Content&gt;
    &lt;/Card&gt;
  );
}
export default ProductCard;</pre>			<p class="calibre3">Next, let us import the <strong class="source-inline">ProductList app.tsx</strong> file of the catalog app located <span>at </span><span><strong class="source-inline">/apps/catalog/src/app/app.tsx</strong></span><span>.</span></p>
			<p class="calibre3">Your <strong class="source-inline">app.tsx</strong> code <a id="_idIndexMarker158" class="pcalibre1 calibre6 pcalibre"/>should <a id="_idIndexMarker159" class="pcalibre1 calibre6 pcalibre"/>now look <a id="_idIndexMarker160" class="pcalibre1 calibre6 pcalibre"/><span>like</span><span><a id="_idIndexMarker161" class="pcalibre1 calibre6 pcalibre"/></span><span> this:</span></p>
			<pre class="source-code">
import { Header } from '@ebuy/ui';
import { Container, Header as Text } from 'semantic-ui-react';
import 'semantic-ui-css/semantic.min.css';
import ProductList from './product-list';
export function App() {
  return (
    &lt;Container style={{ marginTop: '5rem' }}&gt;
      &lt;Header /&gt;
      &lt;Text size="huge"&gt;Catalog App&lt;/Text&gt;
      &lt;ProductList /&gt;
    &lt;/Container&gt;
  );
}
export default App;</pre>			<p class="calibre3">If your catalog app looks like the following screenshot, that means you are on the <span>right path:</span></p>
			<div class="calibre2">
				<div id="_idContainer029" class="img---figure">
					<img src="image/Figure_4.04_B18987.jpg" alt="Figure 4.4 – Catalog app with a header and product list component" class="calibre4"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.4 – Catalog app with a header and product list component</p>
			<p class="calibre3">Next, we are going to create our shopping basket component. So, in our <strong class="source-inline">app.tsx</strong> checkout <a id="_idIndexMarker162" class="pcalibre1 calibre6 pcalibre"/>file <a id="_idIndexMarker163" class="pcalibre1 calibre6 pcalibre"/>located<a id="_idIndexMarker164" class="pcalibre1 calibre6 pcalibre"/> in the <strong class="source-inline">/apps/checkout/src/app</strong> folder, let <a id="_idIndexMarker165" class="pcalibre1 calibre6 pcalibre"/>us create a basic skeleton with the <span>following code:</span></p>
			<pre class="source-code">
import { Header } from '@ebuy/ui';
import { Container, Header as Text } from 'semantic-ui-react';
import 'semantic-ui-css/semantic.min.css';
import ShoppingBasket from './basket';
import { PRODUCT_LIST_MOCKS } from '@ebuy/mocks';
export function App() {
  return (
    &lt;Container style={{ marginTop: '5rem' }}&gt;
      &lt;Header /&gt;
      &lt;Text size="huge"&gt;Checkout&lt;/Text&gt;
      &lt;ShoppingBasket basketList={PRODUCT_LIST_MOCKS} /&gt;
    &lt;/Container&gt;
  );
}
export default App;</pre>			<p class="calibre3">This code should start looking familiar now. As you can see, we have a <strong class="source-inline">ShoppingBasket</strong> component and, for the time being, we are passing <strong class="source-inline">PRODUCT_LIST_MOCKS</strong> to it for the purpose <span>of mocking.</span></p>
			<p class="calibre3">Next up is to <a id="_idIndexMarker166" class="pcalibre1 calibre6 pcalibre"/>create<a id="_idIndexMarker167" class="pcalibre1 calibre6 pcalibre"/> that <strong class="source-inline">ShoppingBasket</strong> component, which<a id="_idIndexMarker168" class="pcalibre1 calibre6 pcalibre"/> is <a id="_idIndexMarker169" class="pcalibre1 calibre6 pcalibre"/>throwing an error at <span>the moment.</span></p>
			<p class="calibre3">So let us create a <strong class="source-inline">basket.tsx</strong> file in the <strong class="source-inline">/apps/checkout/src/</strong> <span>app folder:</span></p>
			<pre class="source-code">
import { Table, Image, Container } from 'semantic-ui-react';
export function ShoppingBasket(basketListData: any) {
  const { basketList } = basketListData;
  return (
    &lt;Container textAlign="center"&gt;
      <strong class="bold1">&lt;Table basic="very" rowed&gt;</strong>
        &lt;Table.Header&gt;
          &lt;Table.Row&gt;
            &lt;Table.HeaderCell&gt;Items&lt;/Table.HeaderCell&gt;
            &lt;Table.HeaderCell&gt;Amount&lt;/Table.HeaderCell&gt;
            &lt;Table.HeaderCell&gt;Quantity&lt;/Table.HeaderCell&gt;
            &lt;Table.HeaderCell&gt;Price&lt;/Table.HeaderCell&gt;
          &lt;/Table.Row&gt;
        &lt;/Table.Header&gt;
        &lt;Table.Body&gt;
          {basketList.map((basketItem: any) =&gt; (
            &lt;Table.Row key={basketItem.id}
&gt;
              &lt;Table.Cell&gt;
                &lt;Image src={basketItem.image} rounded size="mini" /&gt;
              &lt;/Table.Cell&gt;
              &lt;Table.Cell&gt; {basketItem.title}&lt;/Table.Cell&gt;
              &lt;Table.Cell&gt;{basketItem.quantity || 0}&lt;/Table.Cell&gt;
              &lt;Table.Cell&gt;${basketItem.price * basketItem.quantity}&lt;/Table.Cell&gt;
            &lt;/Table.Row&gt;
          ))}
        &lt;/Table.Body&gt;
      &lt;/Table&gt;
    &lt;/Container&gt;
  );
}
export default ShoppingBasket;</pre>			<p class="calibre3">This is all self-explanatory dummy markup content that at the moment doesn’t do much. In the following sections, we are going to make this all <span>work together.</span></p>
			<p class="calibre3">Your running checkout app should now look <span>like this:</span></p>
			<div class="calibre2">
				<div id="_idContainer030" class="img---figure">
					<img src="image/Figure_4.05_B18987.jpg" alt="Figure 4.5 – Mocked up checkout app" class="calibre4"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.5 – Mocked up checkout app</p>
			<p class="calibre3">With <a id="_idIndexMarker170" class="pcalibre1 calibre6 pcalibre"/>this, we <a id="_idIndexMarker171" class="pcalibre1 calibre6 pcalibre"/>have <a id="_idIndexMarker172" class="pcalibre1 calibre6 pcalibre"/>our <a id="_idIndexMarker173" class="pcalibre1 calibre6 pcalibre"/>two apps working well and displaying the right data, however, they are not “talking” to each other yet. The checkout app has no idea what items the user has added to the cart in the catalog app. In the next section, we will set up a global shared state that both the mini-apps can talk to and <span>read from.</span></p>
			<p class="calibre3">Before we proceed to the next section, let us quickly go through a checklist of things we’ve done <span>so far:</span></p>
			<ul class="calibre15">
				<li class="calibre14">Ensured we have the catalog and checkout apps running on <span>different ports</span></li>
				<li class="calibre14">Ensured we have the URL routing setup in the <span><strong class="source-inline1">proxy.conf.json</strong></span><span> file</span></li>
				<li class="calibre14">We have both apps reading data from the mocked <span>product list</span></li>
			</ul>
			<h2 id="_idParaDest-72" class="calibre5"><a id="_idTextAnchor071" class="pcalibre1 calibre6 pcalibre"/>Setting up a Global Shared State</h2>
			<p class="calibre3">Now that we are <a id="_idIndexMarker174" class="pcalibre1 calibre6 pcalibre"/>able to navigate <a id="_idIndexMarker175" class="pcalibre1 calibre6 pcalibre"/>between our two mini-apps, the next thing to tackle is setting up a shared state between these two different apps. Because these are two independent apps, the usual state management solutions such as the Context API, Redux, MobX, and so on will not work. This is because these libraries store the state as an object within the app and when you refresh the page or navigate to another app, this state is lost state. Hence, to overcome this problem, we resort to using some of the browser’s native features, such as local storage, session storage, <span>or Index-db.</span></p>
			<p class="calibre3">For this example, we will be using session storage. We will set up a simple custom hook to persist state in <strong class="source-inline">sessionStorage</strong> and have both our mini-apps read and write to <span>this state.</span></p>
			<p class="calibre3">In any large-scale app, there will be a lot of similar custom hooks that teams can reuse. This is also a good opportunity for us to set up another library for these <span>custom hooks.</span></p>
			<p class="calibre3">It is important to remember that this global state should be used sparingly only when we need to share information between the different mini-apps. To manage the states within each micro app, we should use a regular state management tool such as the Context API or Redux, and <span>so on.</span></p>
			<p class="calibre3">Let us use Nx Console to create another library <span>called </span><span><strong class="source-inline">custom-hooks</strong></span><span>:</span></p>
			<pre class="console">
Nx Console &gt; generate &gt; Create a React Library</pre>			<p class="calibre3">Then, we’ll fill use the following information in <span>the form:</span></p>
			<ul class="calibre15">
				<li class="calibre14"><span><strong class="bold">Name</strong></span><span>: </span><span><strong class="source-inline1">custom-hooks</strong></span></li>
				<li class="calibre14"><strong class="bold">Component</strong>: <strong class="source-inline1">off</strong> (Generate a <span>default component)</span></li>
				<li class="calibre14"><span><strong class="bold">importPath</strong></span><span>: </span><span><strong class="source-inline1">@ebuy/custom-hooks</strong></span></li>
			</ul>
			<p class="calibre3">Verify that the <strong class="source-inline">custom-hooks</strong> folder is created under <strong class="source-inline">libs</strong> and also make sure it has been added to the <strong class="source-inline">tsconfig.base.json</strong> file at the root of the monorepo, which should now look something <span>like this:</span></p>
			<pre class="source-code">
    "paths": {
<strong class="bold1">      "@ebuy/custom-hooks": ["libs/custom-hooks/src/index.ts"],</strong>
      "@ebuy/mocks": ["libs/mocks/src/index.ts"],
      "@ebuy/ui": ["libs/ui/src/index.ts"],
      "@ebuy/utils": ["libs/utils/src/index.ts"]
    }</pre>			<p class="calibre3">Let us now create our custom hook. Use the <strong class="source-inline">generate</strong> command to create a React component with the <span>following information:</span></p>
			<ul class="calibre15">
				<li class="calibre14"><strong class="bold">Name of the </strong><span><strong class="bold">component</strong></span><span>: </span><span><strong class="source-inline1">useSessionStorage</strong></span></li>
				<li class="calibre14"><span><strong class="bold">Project</strong></span><span>: </span><span><strong class="source-inline1">custom-hooks</strong></span></li>
				<li class="calibre14"><span><strong class="bold">fileName</strong></span><span>: </span><span><strong class="source-inline1">use-session-storage</strong></span></li>
				<li class="calibre14"><strong class="bold">flat</strong>: <strong class="source-inline1">Selected</strong> (generate flat <span>file structure)</span></li>
			</ul>
			<p class="calibre3">In the newly created <strong class="source-inline">use-session-storage.tsx</strong> component file, let’s replace the boilerplate<a id="_idIndexMarker176" class="pcalibre1 calibre6 pcalibre"/> code<a id="_idIndexMarker177" class="pcalibre1 calibre6 pcalibre"/> with <span>the following:</span></p>
			<pre class="source-code">
import {
  Dispatch,
  SetStateAction,
  useCallback,
  useEffect,
  useState,
} from 'react';
import { useEventCallback, useEventListener } from 'usehooks-ts';
declare global {
  interface WindowEventMap {
    'session-storage': CustomEvent;
  }
}
type SetValue&lt;T&gt; = Dispatch&lt;SetStateAction&lt;T&gt;&gt;;
export function useSessionStorage&lt;T&gt;(key: string, initialValue: T): [T, SetValue&lt;T&gt;] {
  // Get from session storage then
  // parse stored json or return initialValue
  const readValue = useCallback((): T =&gt; {
    // Prevent build error "window is undefined" but keep working
    if (typeof window === 'undefined') {
      return initialValue;
    }
    try {
      const item = window.sessionStorage.getItem(key);
      return item ? (parseJSON(item) as T) : initialValue;
    } catch (error) {
      console.warn(`Error reading sessionStorage key "${key}":`, error);
      return initialValue;
    }
  }, [initialValue, key]);
  // State to store our value
  // Pass initial state function to useState so logic is only executed once
  const [storedValue, setStoredValue] = useState&lt;T&gt;(readValue);
  // Return a wrapped version of useState's setter function that ...
  // ... persists the new value to sessionStorage.
  const setValue: SetValue&lt;T&gt; = useEventCallback((value) =&gt; {
    // Prevent build error "window is undefined" but keeps working
    if (typeof window === 'undefined') {
      console.warn(
        `Tried setting sessionStorage key "${key}" even though environment is not a client`
      );
    }
    try {
      // Allow value to be a function so we have the same API as useState
      const newValue = value instanceof Function ? value(storedValue) : value;
      // Save to session storage
      window.sessionStorage.setItem(key, JSON.stringify(newValue));
      // Save state
      setStoredValue(newValue);
      // We dispatch a custom event so every useSessionStorage hook are notified
      window.dispatchEvent(new Event('session-storage'));
    } catch (error) {
      console.warn(`Error setting sessionStorage key "${key}":`, error);
    }
  });
  useEffect(() =&gt; {
    setStoredValue(readValue());
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  const handleStorageChange = useCallback(
    (event: StorageEvent | CustomEvent) =&gt; {
      if ((event as StorageEvent)?.key &amp;&amp; (event as StorageEvent).key !== key) {
        return;
      }
      setStoredValue(readValue());
    },
    [key, readValue]
  );
  // this only works for other documents, not the current one
  useEventListener('storage', handleStorageChange);
  // this is a custom event, triggered in writeValueTosessionStorage
  // See: useSessionStorage()
  useEventListener('session-storage', handleStorageChange);
  return [storedValue, setValue];
}
export default useSessionStorage;
// A wrapper for "JSON.parse() to support "undefined" value
function parseJSON&lt;T&gt;(value: string | null): T | undefined {
  try {
    return value === 'undefined' ? undefined : JSON.parse(value ?? '');
  } catch {
    console.log('parsing error on', { value });
    return undefined;
  }
}</pre>			<p class="calibre3">This custom hook code is part of the <strong class="source-inline">usehooks-ts</strong> library and is available <span>here: </span><a href="https://usehooks-ts.com/react-hook/use-session-storage" class="pcalibre1 calibre6 pcalibre"><span>https://usehooks-ts.com/react-hook/use-session-storage</span></a></p>
			<p class="calibre3">Since this custom hook makes use of the <strong class="source-inline">usehook-ts</strong> library, we will install that <span>npm module:</span></p>
			<pre class="source-code">
pnpn i usehook-ts</pre>			<p class="calibre3">Next, we need to export it so that it can be imported via the scoped path. We do this in the <strong class="source-inline">/libs/custom-hooks/src/index.ts</strong> file by adding the <span>following line:</span></p>
			<pre class="source-code">
export * from './lib/use-session-storage'</pre>			<p class="calibre3">Next, we will use our newly created custom-hook in the <strong class="source-inline">product-card</strong> component such that every time the user adds products to or removes products from the shopping cart, it will <a id="_idIndexMarker178" class="pcalibre1 calibre6 pcalibre"/>store <a id="_idIndexMarker179" class="pcalibre1 calibre6 pcalibre"/>it as an array <span>in </span><span><strong class="source-inline">sessionStorage</strong></span><span>.</span></p>
			<p class="calibre3">In the <strong class="source-inline">/apps/catalog/src/app/productcard.tsx</strong> file, we will start by importing the <span><strong class="source-inline">useSessionStorage</strong></span><span> hook:</span></p>
			<pre class="source-code">
import { useSessionStorage } from '@ebuy/custom-hooks;</pre>			<p class="calibre3">Then, within the product card component, we make use of the <strong class="source-inline">useSessionStorage</strong> hook and add the functions to add and remove items from the basket with the <span>following code:</span></p>
			<pre class="source-code">
const [basket, setBasket]: any = useSessionStorage('shoppingBasket', {});
  const addItem = (id: string) =&gt; {
    basket[id] = basket[id] ? basket[id] + 1 : 1;
    setBasket(basket);
  };
 const removeItem = (id: string) =&gt; {
    basket[id] = basket[id] &lt;= 1 ? 0 : basket[id] - 1;
    setBasket(basket);</pre>			<p class="calibre3">Next, we update the <strong class="bold">Add</strong> and <strong class="bold">Remove</strong> button on-click events <span>as follows:</span></p>
			<pre class="source-code">
&lt;div className="ui three buttons"&gt;
          &lt;Button basic color="red" <strong class="bold1">onClick={() =&gt; removeItem(product.id)}&gt;</strong>
            Remove
          &lt;/Button&gt;
          &lt;Button basic color="blue"&gt;
            {basket[product.id] || 0}
          &lt;/Button&gt;
          &lt;Button basic color="green" <strong class="bold1">onClick={() =&gt; addItem(product.id)}&gt;</strong>
            Add
          &lt;/Button&gt;
        &lt;/div&gt;</pre>			<p class="calibre3">Let’s test this <a id="_idIndexMarker180" class="pcalibre1 calibre6 pcalibre"/>out by running the <a id="_idIndexMarker181" class="pcalibre1 calibre6 pcalibre"/><span>following command:</span></p>
			<pre class="source-code">
pnpm serve:all</pre>			<p class="calibre3">Click on the <strong class="bold">Add</strong> and <strong class="bold">Remove</strong> buttons for some of the products and see the product <span>counts work.</span></p>
			<p class="calibre3">Let’s open up the development tools and have a look at the <strong class="source-inline">sessionStorage</strong> under the <span><strong class="bold">Application</strong></span><span> tab:</span></p>
			<div class="calibre2">
				<div id="_idContainer031" class="img---figure">
					<img src="image/Figure_4.06_B18987.jpg" alt="Figure 4.6 – Shopping basket stored in Session Storage" class="calibre4"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.6 – Shopping basket stored in Session Storage</p>
			<p class="calibre3">Once the state is present in <strong class="bold">Session Storage</strong>, we will need to read it from multiple places across different components. It is best to create it as a utility function that can be reused <span>as needed.</span></p>
			<p class="calibre3">We will create another library using Nx Console, but this time instead of creating a React library, we<a id="_idIndexMarker182" class="pcalibre1 calibre6 pcalibre"/> will <a id="_idIndexMarker183" class="pcalibre1 calibre6 pcalibre"/>use the <strong class="source-inline">@nrwl/workspace – library</strong> template to generate our generic <strong class="source-inline">utils</strong> library and use the import scope <span>called </span><span><strong class="source-inline">@ebuy/utils</strong></span><span>.</span></p>
			<p class="calibre3">The information we fill in during the <strong class="source-inline">Nx Console &gt; generate</strong> step is <span>as follows:</span></p>
			<ul class="calibre15">
				<li class="calibre14"><strong class="bold">@</strong><span><strong class="bold">nwrl/workspace</strong></span><span>: </span><span><strong class="source-inline1">library</strong></span></li>
				<li class="calibre14"><span><strong class="bold">Name</strong></span><span>: </span><span><strong class="source-inline1">utils</strong></span></li>
				<li class="calibre14"><span><strong class="bold">importScope</strong></span><span>: </span><span><strong class="source-inline1">@ebuy/utils</strong></span></li>
			</ul>
			<p class="calibre3">Running this command will generate the <strong class="source-inline">utils</strong> folder and also create the <strong class="source-inline">utils.ts</strong> file. Let us rename it <span>to </span><span><strong class="source-inline">get-session-storage.ts</strong></span><span>.</span></p>
			<p class="calibre3">Add the following code to read the values of a <span>given key:</span></p>
			<pre class="source-code">
export function getSessionStorage(key: any) {
  const sessionStorageValue = JSON.parse(
    window.sessionStorage.getItem(key) || '{}'
  );
  return sessionStoragevalue;
}
export default getSessionStorage;</pre>			<p class="calibre3">As you can see, this is a very simple function that accepts a key and returns the values from session storage for the <span>given key.</span></p>
			<p class="calibre3">Next, we will get the mini basket in the header hooked up to show the total items in the shopping basket. In the <strong class="source-inline">header.tsx</strong> file, let us add the necessary code to read and total up the items in the <span>shopping basket.</span></p>
			<p class="calibre3">Let us import the <span>necessary functions:</span></p>
			<pre class="source-code">
import { useEffect, useState } from 'react';
import { useEventListener } from 'usehooks-ts';
import { getSessionStorage } from '@ebuy/utils';</pre>			<p class="calibre3">We will <a id="_idIndexMarker184" class="pcalibre1 calibre6 pcalibre"/>create <a id="_idIndexMarker185" class="pcalibre1 calibre6 pcalibre"/>our function to calculate the total count <span>like so:</span></p>
			<pre class="source-code">
const getTotalBasketCount = (basket: any): any =&gt; {
  return Object.values(basket).reduce((a: any, b: any) =&gt; a + b, 0);
};</pre>			<p class="calibre3">Next, within the <strong class="source-inline">Header</strong> component, we will use a combination of <strong class="source-inline">useEffects</strong> and <strong class="source-inline">eventListeners</strong> to ensure that the mini basket updates every time items are added to or removed from <span>the cart:</span></p>
			<pre class="source-code">
const [miniBasketCount, setMiniBasketCount] = useState(null);
  useEffect(() =&gt; {
    const basket: any = getSessionStorage('shoppingBasket');
    const totalCount: any = getTotalBasketCount(basket);
    setMiniBasketCount(totalCount);
  }, []);
  useEventListener('session-storage', () =&gt; {
    const basket: any = getSessionStorage('shoppingBasket');
    const totalCount: any = getTotalBasketCount(basket);
    setMiniBasketCount(totalCount);
  });</pre>			<p class="calibre3">Finally, we will update the shopping cart icon to display <strong class="source-inline">{miniBasketCount}</strong> <span>like so:</span></p>
			<pre class="source-code">
&lt;Menu.Item position="right"&gt;
          &lt;Label&gt;
            &lt;Icon name="shopping cart" /&gt;
            <strong class="bold1">{miniBasketCount}</strong>
          &lt;/Label&gt;
        &lt;/Menu.Item&gt;</pre>			<p class="calibre3">Run the apps <a id="_idIndexMarker186" class="pcalibre1 calibre6 pcalibre"/>and<a id="_idIndexMarker187" class="pcalibre1 calibre6 pcalibre"/> try adding and removing items using the <strong class="bold">Add</strong> and <strong class="bold">Remove</strong> buttons, and see how the <span>counts update.</span></p>
			<p class="calibre3">The last part of this chapter is where we will complete the shopping cart component in the <span>checkout app.</span></p>
			<p class="calibre3">What we need to do is fetch the data for the <strong class="source-inline">shoppingBasket</strong> key in <strong class="source-inline">sessionStorage</strong> and display the products and the quantity added to <span>the cart.</span></p>
			<p class="calibre3">We open the <strong class="source-inline">app.tsx</strong> checkout file located in the <strong class="source-inline">apps/checkout/src/app/app.tsx</strong> file and follow these steps to get the data <span>from </span><span><strong class="source-inline">sessionStorage</strong></span><span>:</span></p>
			<p class="calibre3">First we import <strong class="source-inline">getSessionStorage</strong> <span>like so:</span></p>
			<pre class="source-code">
import { getSessionStorage } from '@ebuy/utils';</pre>			<p class="calibre3">Then within the <strong class="source-inline">App</strong> function we add <span>the following:</span></p>
			<pre class="source-code">
const basketFromStorage: any = getSessionStorage('shoppingBasket');
    console.log('Basket: ', basketFromStorage);</pre>			<p class="calibre3">When we run the app and have a look at the console, we will be able to see the array of items <span>from </span><span><strong class="source-inline">shoppingBasket</strong></span><span>.</span></p>
			<p class="calibre3">Since <strong class="source-inline">shoppingBasket</strong> only stored the product IDs and their quantity we will need to map the product IDs to the product names so that we can display names in the <span>shopping basket.</span></p>
			<p class="calibre3">Let us create <a id="_idIndexMarker188" class="pcalibre1 calibre6 pcalibre"/>another function to do<a id="_idIndexMarker189" class="pcalibre1 calibre6 pcalibre"/> that. We will call <span>it </span><span><strong class="source-inline">createCompleteBasket</strong></span><span>:</span></p>
			<pre class="source-code">
const createCompleteBasket = (allItems: any, quantities: any) =&gt; {
  return allItems
    .filter((item: any) =&gt; quantities[item.id])
    .map((item: any) =&gt; {
      return {
        ...item,
        quantity: quantities[item.id],
      };
    });
};</pre>			<p class="calibre3">And then, finally, within our app’s component's function, we create <strong class="source-inline">completeBasket</strong> by filtering and mapping the values from the product list to <strong class="source-inline">shoppingbasket</strong> <span>like so:</span></p>
			<pre class="source-code">
  const completeBasket = createCompleteBasket(
    PRODUCT_LIST_MOCKS,
    basketFromStorage
  );</pre>			<p class="calibre3">Now we update the <strong class="source-inline">ShoppingBasket</strong> component to pass in this new prop <span>like so:</span></p>
			<pre class="source-code">
 &lt;ShoppingBasket basketList={completeBasket} /&gt;</pre>			<p class="calibre3">Test your app in the browser and give it a play. Add and remove items to and from the basket in the catalog app and then navigate to the checkout app to see the shopping basket all synced up and displaying the correct list <span>of items.</span></p>
			<p class="callout-heading">A note on the coding samples</p>
			<p class="callout">As you must have seen, in numerous places we have used the ‘<strong class="source-inline1">any'</strong> type definition and have skipped a few details (including unit tests). This is intentional to avoid overcomplicating the examples so that we stay focused on the core aspects of this chapter, such as routing between apps and sharing state. When building an app for production, we would encourage you to define the correct types and interfaces to take advantage of the full power of TypeScript and write <span>relevant tests.</span></p>
			<p class="calibre3">With this, we come to the end of this rather intense section... Take a break. <span>Well done!</span></p>
			<p class="calibre3">We covered a lot here. We picked up from where we had left off in the previous chapter and added a shared header component to our apps. We then set up routing via a proxy so that we could navigate between the two different apps, but as if they were part of the same domain and port.  We also saw how to share state between the two mini-apps using session<a id="_idIndexMarker190" class="pcalibre1 calibre6 pcalibre"/> storage. We then created a <a id="_idIndexMarker191" class="pcalibre1 calibre6 pcalibre"/>common custom hook to store and retrieve data from session storage, and while doing so we built up the bare bones of an e-commerce app, adding items to the cart and updating the cart information on the checkout app and the mini cart on <span>the header.</span></p>
			<h1 id="_idParaDest-73" class="calibre7"><a id="_idTextAnchor072" class="pcalibre1 calibre6 pcalibre"/>Summary</h1>
			<p class="calibre3">This was a long chapter, so well done for staying with us until the end. We started off by looking at what the multi-SPA pattern looks like. We saw how this pattern would be most suitable for very large applications such as a banking portal, a government portal, or an e-commerce site. We saw the architecture pattern where all these different mini-apps can take advantage of a shared common library of components and utilities to ensure the consistency of the <span>different apps.</span></p>
			<p class="calibre3">We then took a deep dive into code and went about setting up our two mini-apps within the Nx monorepo, after which we went about creating our shared UI header component and used Semantic UI to build out our catalog and checkout apps. This was also a good opportunity for us to see how to use scoped names, which makes our import paths look clean <span>and simple.</span></p>
			<p class="calibre3">Then we went about setting up the routing so that we could navigate between the two different apps, and finally, we set up a custom hook to store our app state in session storage and saw how to have it synced between the <span>two mini-apps.</span></p>
			<p class="calibre3">In the next chapter, we will look at the micro-apps pattern where we will have multiple micro-apps loaded within the <span>same page.</span></p>
		</div>
	</body></html>