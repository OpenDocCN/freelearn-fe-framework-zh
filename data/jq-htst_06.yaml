- en: Chapter 6. Extending Chrome with jQuery
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章。使用jQuery扩展Chrome
- en: Building an extension for Chrome (or any other browser that can be extended
    with plugins and extensions) is an easy way to create custom behavior or additional
    tools to enhance our browsing experience.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 为Chrome（或任何可以通过插件和扩展进行扩展的其他浏览器）构建一个扩展是创建自定义行为或附加工具以增强我们的浏览体验的简单方法。
- en: Chrome allows us to leverage our web development skills to extend its browser
    interface, using technologies we're already familiar with such as HTML, CSS, and
    JavaScript, and where you can use JavaScript you can usually use jQuery.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome允许我们利用我们的Web开发技能扩展其浏览器界面，使用我们已经熟悉的技术，如HTML、CSS和JavaScript，以及您可以使用JavaScript的地方通常也可以使用jQuery。
- en: Mission Briefing
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务简报
- en: In this project we'll build a Chrome extension that highlights elements on the
    page that are marked up with `Schema.org` **microdata**. Microdata is a way of
    specifying descriptive information about a variety of different entities, such
    as businesses, locations, or people using standard HTML attributes, and is rumored
    to become an important factor in Google's ranking algorithms.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将构建一个Chrome扩展，突出显示页面上用`Schema.org` **微数据**标记的元素。微数据是一种用于指定有关各种不同实体（如企业、位置或人员）的描述性信息的方式，使用标准HTML属性，并据传言将成为Google排名算法中的重要因素。
- en: Whenever we visit a page containing elements described as contact details, we
    can grab them from the page and store them in our extension, allowing us to slowly
    build up a directory of contact information for people that are using or making
    stuff we love.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们访问包含联系方式描述的页面时，我们可以从页面中获取它们并将其存储在我们的扩展中，这样我们就可以逐渐建立起一个人们使用或制作我们喜爱的东西的联系信息目录。
- en: 'We can also use templating in this project to make creating a repeated group
    of elements much more efficient, as well as easier to maintain. We used JsRender
    in the previous project, so we can use it again, but this time we''ll need to
    use it slightly differently than before. Once completed, our extension will look
    something like that shown in the following screenshot:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们还可以使用模板化使创建重复的元素组更加高效，以及更易于维护。我们在上一个项目中使用了JsRender，所以我们可以再次使用它，但这次我们需要以稍微不同的方式使用它。完成后，我们的扩展将类似于以下截图所示：
- en: '![Mission Briefing](img/9106OS_06_01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![任务简报](img/9106OS_06_01.jpg)'
- en: Why Is It Awesome?
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么很棒？
- en: Microdata is used to describe the information contained within web pages in
    order to promote better interoperability between autonomous systems, such as search
    engine spiders and HTML documents.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 微数据用于描述网页中包含的信息，以促进搜索引擎蜘蛛和HTML文档之间的更好互操作性。
- en: When different elements on the page are described as being a company, a person,
    a product, or a movie, it allows things such as search engines to better understand
    the information contained on the page.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当页面上的不同元素被描述为公司、人员、产品或电影时，它允许诸如搜索引擎之类的东西更好地理解页面上包含的信息。
- en: Microdata is rapidly becoming more commonplace on the Web and is set to take
    an ever increasingly important role in the results generated by Google for search
    results, so there has never been a better time to exploit it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 微数据在Web上迅速变得更加普遍，并且在Google为搜索结果生成的结果中扮演着越来越重要的角色，因此现在是利用它的绝佳时机。
- en: Your Hotshot Objectives
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你的热门目标
- en: 'The tasks this project is broken down into are as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目分解成的任务如下：
- en: Setting up the basic extension structure
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置基本扩展结构
- en: Adding a manifest and installing the extension
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个清单并安装扩展
- en: Adding a sandboxed JsRender template
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个沙箱JsRender模板
- en: Posting a message to the sandbox
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将消息发布到沙盒
- en: Adding a content script
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加内容脚本
- en: Scraping the page for microdata
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为微数据抓取页面
- en: Adding a mechanism for saving the microdata
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加保存微数据的机制
- en: Setting up the basic extension structure
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置基本扩展结构
- en: In this task we'll create the underlying files required by the extension. All
    files used by an extension need to reside in the same directory, so we'll set
    that up and make sure it contains all the files we need.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们将创建扩展所需的基础文件。扩展使用的所有文件都需要位于同一个目录中，因此我们将设置它并确保它包含我们需要的所有文件。
- en: Prepare for Lift Off
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为起飞做准备
- en: One thing I should point out, although hopefully you'll already have realized
    – we're going to require the Chrome browser for the duration of this project.
    If you don't have it installed, which as a web developer you really ought to,
    if only for testing purposes, get it and install it immediately.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有一件事我应该指出，尽管希望你已经意识到 - 在该项目期间，我们将需要 Chrome 浏览器。如果你尚未安装它，作为一个网页开发人员，你真的应该安装它，至少是为了测试目的，立即下载并安装。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The latest version of Chrome can be downloaded from [https://www.google.com/intl/en/chrome/browser/](https://www.google.com/intl/en/chrome/browser/).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome 的最新版本可以从[https://www.google.com/intl/en/chrome/browser/](https://www.google.com/intl/en/chrome/browser/)下载。
- en: We'll keep all of the files for this project in a single directory, so set one
    up in the project folder now and call it `chrome-extension`. The extension will
    be built from the same base code files as most of the other projects that we've
    created have been built from; the only difference is that all files will need
    to be local to the extension.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个项目的所有文件保存在一个单独的目录中，所以现在在项目文件夹中建立一个目录，命名为`chrome-extension`。扩展将从与大多数其他项目使用的基本代码文件构建;
    唯一的区别是所有文件都需要是扩展本地的。
- en: We're going to need a copy of JsRender, so we should also download a copy of
    that and place it in the `chrome-extension` directory. Last time we used JsRender
    we linked to the live hosted version. This time we'll download it.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个 JsRender 的副本，所以我们也应该下载一个副本，并将其放在`chrome-extension`目录中。上次我们使用 JsRender
    时我们链接到了在线托管的版本。这次我们将下载它。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The latest version of JsRender can be downloaded from [https://github.com/BorisMoore/jsrender/](https://github.com/BorisMoore/jsrender/).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: JsRender 的最新版本可以从[https://github.com/BorisMoore/jsrender/](https://github.com/BorisMoore/jsrender/)下载。
- en: We can use the template file that we've started the other projects with, but
    we should make sure the paths to jQuery, the JavaScript file, and the style sheets
    all point to files in the same directory. All of the files used by a Chrome extension
    must be in the same folder, which is why we download the scripts instead of linking
    to online versions.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用用于启动其他项目的模板文件，但是我们应该确保指向 jQuery、JavaScript 文件和样式表的路径都指向同一个目录中的文件。Chrome
    扩展使用的所有文件都必须在同一个文件夹中，这就是为什么我们下载脚本而不是链接到在线版本。
- en: We should place copies of jQuery, JsRender, and the `common.css` style sheet
    into the new directory. We also need to create a new JavaScript file called `popup.js`
    and a new style sheet called `popup.css` and save these files into the new directory
    also.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该将 jQuery、JsRender 和`common.css`样式表的副本放入新目录中。我们还需要创建一个名为`popup.js`的新 JavaScript
    文件和一个名为`popup.css`的新样式表，并将这些文件也保存到新目录中。
- en: 'Lastly, we can create a new HTML page called `popup.html`. This file should
    also be saved in the `chrome-extension` directory, and should contain the following
    code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以创建一个名为`popup.html`的新 HTML 页面。这个文件也应该保存在`chrome-extension`目录中，并且应该包含以下代码：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Engage Thrusters
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: The HTML file we just created will be used as the extension's popup. This is
    the page that is displayed as a popup when the extension's icon is clicked in
    the toolbar. In this project we'll be creating a type of extension known as a
    **browser action**, which automatically adds a button to Chrome's toolbar which
    is used to open the popup.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建的 HTML 文件将被用作扩展的弹出窗口。这是当单击工具栏中扩展图标时显示为弹出窗口的页面。在这个项目中，我们将创建一种称为**浏览器操作**的扩展类型，它会自动向
    Chrome 的工具栏添加一个按钮，用于打开弹出窗口。
- en: The popup will display a button used to trigger a scan of the current page for
    microdata and display any previously saved contacts. Any previously stored contacts
    will be retrieved using the localStorage API, and we can use a template to render
    them.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 弹出窗口将显示一个按钮，用于触发对当前页面的微数据进行扫描，并显示任何先前保存的联系人。任何先前存储的联系人都将使用 localStorage API
    检索，并且我们可以使用模板来渲染它们。
- en: 'First we can add the general markup to the page; in `popup.html` add the following
    code to the `<body>` of the page:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以向页面添加一般的标记; 在`popup.html`中，将以下代码添加到页面的`<body>`中：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can also add some basic styling for these elements. In `popup.css`, add
    the following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以为这些元素添加一些基本样式。在 `popup.css` 中，添加以下代码：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Objective Complete - Mini Debriefing
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 小结
- en: Chrome extensions are built using the same files that as web developers we're
    used to working with – HTML, CSS, and JavaScript. The extension will add a button
    to the toolbar and when this button is clicked, it will display a popup. The HTML
    page that we added in this task is the basis of this popup.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome扩展使用与我们习惯使用的相同文件构建 - HTML、CSS和JavaScript。该扩展将在工具栏中添加一个按钮，当单击此按钮时，将显示一个弹出窗口。我们在此任务中添加的HTML页面是此弹出窗口的基础。
- en: We create the page like we would create any other standard HTML5 page. We linked
    to the CSS and JavaScript files as usual, and then added a small `<section>` container
    which will be used as a container for any previously saved contacts. Initially
    there won't be any, and when there are, we'll render them using a template.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建页面的方式与创建任何其他标准HTML5页面的方式相同。我们像往常一样链接到CSS和JavaScript文件，然后添加一个小的`<section>`容器，它将用作任何先前保存的联系人的容器。最初不会有任何联系人，当有联系人时，我们将使用模板来呈现它们。
- en: We've added a `<header>` containing a `<h1>` to give the saved contacts a title,
    and have added an empty`<ul>` element that we'll populate shortly with a script.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经添加了一个包含`<h1>`的`<header>`，为保存的联系人添加了一个标题，并添加了一个空的`<ul>`元素，我们将很快用脚本填充它。
- en: Lastly we added an `<iframe>` to the page, which will be hidden from view. We'll
    use this to communicate with another part of the extension a little later on.
    The `src` attribute of the element is set to the page we want to send messages
    to.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在页面中添加了一个`<iframe>`，它将被隐藏。稍后我们将使用这个来与扩展的另一部分通信。元素的`src`属性设置为我们想要发送消息的页面。
- en: The CSS we added was purely for presentation and just laid out the initial elements
    in a simple layout. We're also linking to the common CSS file that each of the
    other projects have also used, but don't forget, all files used by the extension
    must be in the extension's directory.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的CSS纯粹是为了演示，并仅以简单的布局放置了初始元素。我们还链接到每个其他项目都使用的公共CSS文件，但不要忘记，扩展使用的所有文件都必须在扩展的目录中。
- en: Classified Intel
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机密情报
- en: As we are creating a browser action we'll get a new button added to Chrome's
    toolbar which will be visible as long as the unpacked extension is loaded. By
    default it will have the standard extension icon – a puzzle piece, but we can
    replace this with an icon of our own creation.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们正在创建浏览器操作，所以我们将在Chrome的工具栏中添加一个新按钮，只要加载了未打包的扩展，它就可见。默认情况下，它将具有标准扩展图标 - 一个拼图块，但我们可以用我们自己创建的图标替换它。
- en: We can also create other types of extension which don't add a button to the
    toolbar. We could create a page action instead of a browser action, which adds
    an icon to the address bar instead of the toolbar.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建其他类型的扩展，这些扩展不会将按钮添加到工具栏。我们可以创建页面操作而不是浏览器操作，该操作将在地址栏中添加一个图标而不是工具栏。
- en: Whether this icon is visible on all pages or not will depend on how the extension
    behaves. For example, if we wanted to run our extension every time a page was
    loaded in the browser, but only display the icon if it found `Schema.org` microdata
    on the page, we could use a page action.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 该图标是否在所有页面上可见取决于扩展的行为方式。例如，如果我们想要在每次页面在浏览器中加载时运行我们的扩展，但只在页面上找到`Schema.org`微数据时显示图标，我们可以使用页面操作。
- en: A browser action, such as we'll create here, is accessible all of the time,
    regardless of the page being viewed. We're using a browser action instead of a
    page action because the users of our extension will probably want to be able to
    see contacts they have previously found and saved, so a browser action is perfect
    for facilitating an always-available button to display any data stored by the
    extension.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器操作，例如我们将在此创建的操作，在查看的页面不受影响时始终可访问。我们使用浏览器操作而不是页面操作，因为我们扩展的用户可能希望能够查看他们以前发现并保存的联系人，因此浏览器操作非常适合通过扩展存储的任何数据。
- en: Adding a manifest and installing the extension
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加清单并安装扩展
- en: In order to actually install our extension and see the fruits of our labor so
    far, we'll need to create a manifest file. This special file, saved in JSON format,
    controls certain aspects of the extension such as the pages it uses, and the content
    scripts it can run.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实际安装我们的扩展并看到我们迄今为止的劳动成果，我们需要创建一个清单文件。这个特殊的文件以JSON格式保存，控制扩展的某些方面，例如它使用的页面以及它可以运行的内容脚本。
- en: Prepare for Lift Off
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备起飞
- en: 'In a new file add the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在新文件中添加以下代码：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Save this file in the `chrome-extension` directory that we created at the start
    of the task within our main project directory as `manifest.json`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存在我们在任务开始时在主项目目录中创建的`chrome-extension`目录中，文件名为`manifest.json`。
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the text editor you're using doesn't show **.json** in the **Save as type:**
    (or equivalent) drop-down, select the **All types (*)** option and type the full
    filename `manifest.json` in the **File name:** input field.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的文本编辑器在**另存为类型：**（或相似）下没有显示**.json**，请选择**所有类型 (*)**选项，并在**文件名：**输入字段中键入完整的文件名`manifest.json`。
- en: Engage Thrusters
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: In order to view the extension as it currently exists, it will need to be loaded
    in Chrome as an extension. To do this, you should go to **Settings** | **Tools**
    | **Extensions**.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看当前的扩展程序，需要将其加载到 Chrome 中作为扩展程序。为此，您应该转到**设置** | **工具** | **扩展程序**。
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In recent versions of Chrome, the **Settings** menu is accessed by clicking
    on the button that has three stripes as its icon, which is situated at the top-right
    of the browser window.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在最近的 Chrome 版本中，通过点击具有三条杠图标的按钮（位于浏览器窗口右上角）来访问**设置**菜单。
- en: When the extensions page loads, there should be a button to **Load unpacked
    extension…**. If there isn't, tick the **Developer mode** checkbox and the button
    will appear.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当扩展程序页面加载时，应该会有一个按钮来**加载未打包的扩展程序…**。如果没有，请选中**开发者模式**复选框，然后该按钮将出现。
- en: Hit the button and select the `chrome-extension` folder as the extension directory.
    This should install the extension and add the browser action button to the toolbar
    for us.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 点击按钮，然后选择`chrome-extension`文件夹作为扩展目录。这样应该会安装扩展程序，并为我们添加浏览器操作按钮到工具栏。
- en: Objective Complete - Mini Debriefing
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 迷你总结
- en: The simple manifest file is required by the extension before it can be loaded
    in the browser. Only manifests of at least Version 2 are allowed by the current
    version of Chrome. The manifest is required and the extension will not run without
    it. It is a simple text file, in JSON format, that is used to tell the browser
    some of the basic information about the extension, such as its name, who authored
    it, and the current version.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在扩展程序加载到浏览器之前，需要一个简单的清单文件。当前版本的 Chrome 仅允许至少为 Version 2 的清单。扩展程序必须具有清单，否则将无法运行。这是一个简单的文本文件，以
    JSON 格式编写，用于向浏览器提供有关扩展程序的一些基本信息，例如名称、作者和当前版本。
- en: We can specify that our extension is a browser action, which adds a button for
    the extension to Chrome's toolbar. We can also specify the page that will be displayed
    in the popup using the manifest.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以指定我们的扩展程序是一个浏览器操作，它将一个按钮添加到 Chrome 的工具栏上。我们还可以使用清单指定在弹出窗口中显示的页面。
- en: 'When the new button for our extension is clicked, the HTML page (`popup.html`)
    we added in the previous task will be displayed in the extension popup, as shown
    in the following screenshot:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 单击我们扩展的新按钮时，将会在扩展程序弹出窗口中显示我们在上一个任务中添加的 HTML 页面（`popup.html`），如下面的屏幕截图所示：
- en: '![Objective Complete - Mini Debriefing](img/9106OS_06_02.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![目标完成 - 迷你总结](img/9106OS_06_02.jpg)'
- en: Adding a sandboxed JsRender template
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个沙盒化的 JsRender 模板
- en: In this task we can add the template that JsRender will use to display the saved
    contacts. At this point we don't have any saved, but we can still wire it up ready,
    and then when we do have some contacts, they'll be rendered into the popup without
    any fuss.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们可以添加 JsRender 将用于显示已保存联系人的模板。此时，我们还没有保存任何联系人，但我们仍然可以准备好它，并且当我们有了一些联系人时，它们将被渲染到弹出窗口中，而无需任何麻烦。
- en: Prepare for Lift Off
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备起飞
- en: Chrome uses a **Content Security Policy** (**CSP**) in order to prevent a large
    number of common **cross-site scripting** (**XSS**) attacks, and because of this
    we are not allowed to execute any scripts that use either `eval()` or `new Function()`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome 使用**内容安全策略**（**CSP**）来防止大量常见的**跨站脚本**（**XSS**）攻击，因此我们不允许执行使用`eval()`或`new
    Function()`的任何脚本。
- en: 'The JsRender templating library, like many other popular libraries and frameworks,
    uses `new Function()` when compiling templates and therefore is not allowed to
    run directly inside the extension. There are two ways we can overcome this problem:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 像许多其他流行库和框架一样，JsRender 模板库在编译模板时使用`new Function()`，因此不允许直接在扩展程序内部运行。我们可以通过两种方式解决这个问题：
- en: We could switch to a templating library that offers a pre-compilation of templates,
    such as the popular `Dust.js`. We could then compile our template outside of the
    extension in a browser and link to a JavaScript file containing the function that
    the template is compiled into from within the extension. The function that would
    be created with `new Function()` would then already have been created prior to
    the extension even being installed, and the template could then be rendered inside
    the extension, interpolated with any data made available within the extension.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以转换到一个提供模板预编译的模板库，比如流行的 `Dust.js`。然后我们可以在浏览器外部编译我们的模板，并在扩展内部链接到包含模板编译成的函数的
    JavaScript 文件。使用 `new Function()` 创建的函数甚至在扩展安装之前就已经被创建了，然后模板可以在扩展内部呈现，并与扩展内部提供的任何数据插值。
- en: Or, Chrome's extension system allows us to use certain files inside a specified
    sandbox. Unsafe string-to-function features such as `eval()` or `new Function()`
    are allowed to run in the sandbox because the code is insulated from the extension's
    data and API access within the browser.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，Chrome 的扩展系统允许我们在指定的沙盒内部使用某些文件。由于代码与浏览器中的扩展数据和 API 访问隔离，因此允许在沙盒中运行不安全的字符串到函数特性，例如
    `eval()` 或 `new Function()`。
- en: We'll use the sandboxing feature in this example, so that we can continue using
    JsRender.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用沙盒功能，以便我们可以继续使用 JsRender。
- en: Engage Thrusters
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'First of all we have to set up the sandbox, which is done by specifying which
    pages to sandbox using the manifest file that we created earlier. Add the following
    code to `manifest.json`, directly before the final closing curly bracket:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须设置沙盒，这是通过使用我们之前创建的清单文件指定要沙盒化的页面来完成的。将以下代码直接添加到 `manifest.json` 中，直接在最终闭合大括号之前：
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Tip
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Don't forget to add a comma directly after the closing curly bracket of the
    `browser_action` property.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在 `browser_action` 属性的最终闭合大括号之后直接添加逗号。
- en: 'We''ve specified `template.html` as the page to sandbox. Create a new file
    called `template.html` and save it in the `chrome-extension` directory. It should
    contain the following code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将 `template.html` 指定为沙盒页面。创建一个名为 `template.html` 的新文件，并将其保存在 `chrome-extension`
    目录中。它应包含以下代码：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The template page also references the `template.js` script file. We should
    create this file in the `chrome-extension` directory and add the following code
    to it:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 模板页面还引用了 `template.js` 脚本文件。我们应该在 `chrome-extension` 目录中创建此文件，并将以下代码添加到其中：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Objective Complete - Mini Debriefing
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成目标 - 迷你总结
- en: We started out by adding a new HTML page to the extension. The page called `template.html`
    is like a regular web page except that it doesn't have a `<body>`, just a `<head>`
    that links to some JavaScript resources, and a `<script>` element containing the
    template we'll be using.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先向扩展添加了一个新的 HTML 页面。名为 `template.html` 的页面类似于常规网页，只是没有 `<body>`，只有一个 `<head>`，它链接到一些
    JavaScript 资源，并包含我们将使用的模板的 `<script>` 元素。
- en: Tip
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Usually in a Chrome extension, the CSP prevents us from running any inline scripts
    – all scripts should reside within external files. Using a non-standard `type`
    attribute on the `<script>` element allows us to circumvent this so that we can
    store our template inside the page instead of having another external file.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在 Chrome 扩展中，CSP 阻止我们运行任何内联脚本 - 所有脚本都应驻留在外部文件中。在 `<script>` 元素上使用非标准的 `type`
    属性允许我们规避这一点，以便我们可以将我们的模板存储在页面内，而不是使用另一个外部文件。
- en: The bulk of the new page is the template itself. `Schema.org` microdata allows
    people to add a lot of additional information to describe the elements on the
    page, so there are a range of different bits of information that may be stored
    in the extension.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 新页面的主体是模板本身。`Schema.org` 微数据允许人们添加大量附加信息以描述页面上的元素，因此扩展中可能存储各种不同的信息。
- en: Our template therefore makes use of a lot of conditionals to display things
    if they are present. The extension should always display the name, but aside from
    that it may display an image, a job title and company, an address, or various
    contact methods, or any combination thereof.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的模板利用了很多条件来显示如果它们存在的东西。扩展程序应始终显示名称，但除此之外，它可能显示图像、工作标题和公司、地址或各种联系方式，或者它们的任何组合。
- en: The most complex part of the template is the `getMembers()` helper function.
    We'll call this helper function for each object in the `contactMethods` object
    using JsRender's `{{for}}` tag, which calls the helper function using the tilde
    (~) character. Inside the loop we'll have access to the values returned by the
    helper and can insert these into the relevant elements.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 模板中最复杂的部分是`getMembers()`辅助函数。我们将使用JsRender的`{{for}}`标记为`contactMethods`对象中的每个对象调用此辅助函数，该标记使用波浪号（~）字符调用辅助函数。在循环内，我们将能够访问辅助函数返回的值，并将这些值插入到相关元素中。
- en: 'Next we added the `template.js` script file. At this point all we need to add
    to this script file is the helper method used by the template to render any contact
    methods. These will be in the format `{ email: me@me.com }`.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，我们添加了`template.js`脚本文件。此时，我们需要添加到此脚本文件的所有内容只是模板用于呈现任何联系方式的辅助方法。这些将采用`{
    email: me@me.com }`的格式。'
- en: The helper is registered using JsRender's `helpers()` method. This method is
    passed an object where the name of the helper is specified as the key and the
    function that should be invoked is the value.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JsRender的`helpers()`方法注册辅助程序。此方法接受一个对象，其中指定辅助程序的名称为键，应调用的函数为值。
- en: The function receives an object. We first create an empty array and then iterate
    the object using a standard `for in` loop. We first check that the property being
    iterated belongs to the object and is not inherited from the prototype using JavaScript's
    `hasOwnProperty()` function.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 函数接收一个对象。我们首先创建一个空数组，然后使用标准的`for in`循环迭代对象。我们首先使用JavaScript的`hasOwnProperty()`函数检查正在迭代的属性是否属于对象，且不是从原型继承的。
- en: We then just create a new object and set the key as a property called `key`,
    and the value as a property called `val`. These are the template variables that
    we use in the `<dl>` in our template.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们只需创建一个新对象，并将键设置为名为`key`的属性，将值设置为名为`val`的属性。这些是我们在模板中使用的模板变量，用于在我们的模板中的`<dl>`中插入。
- en: This new object is then pushed into the array we created, and once the object
    passed to the helper has been iterated, we return the array to the template for
    the `{{for}}` loop to iterate.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将此新对象推送到我们创建的数组中，并且一旦对传递给辅助函数的对象进行了迭代，我们将该数组返回给模板，以便`{{for}}`循环进行迭代。
- en: Posting a message to the sandbox
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在沙盒中发布消息
- en: In this task we'll set up the communication between our popup and the sandboxed
    template page to see how we can get the template to render when the popup is opened.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在此任务中，我们将建立我们的弹出窗口与沙盒模板页面之间的通信，以查看如何在打开弹出窗口时让模板进行呈现。
- en: Engage Thrusters
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'First of all we can add the code that sends the message to the sandboxed page
    requesting the template to render. In `popup.js`, add the following code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以添加将消息发送到沙盒页面以请求模板进行呈现的代码。在`popup.js`中，添加以下代码：
- en: '[PRE7]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next we need to add the code that will respond to the initial message. Add
    the following code to `template.js` directly after the helper method we added
    in the last task:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加响应初始消息的代码。将以下代码直接添加到`template.js`中，放在我们上一个任务中添加的辅助方法之后：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Objective Complete - Mini Debriefing
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 小型总结
- en: First of all we set up the initial messaging in `popup.js`. We cached the `<iframe>`
    element from the popup in a variable and then composed a message. The message
    is in the form of an object literal with a `command` property and a `context`
    property.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '首先，我们在`popup.js`中设置了初始消息传递。我们在变量中缓存了来自弹出窗口的`<iframe>`元素，然后编写了一条消息。消息是以对象文字的形式，具有`command`属性和`context`属性。 '
- en: The `command` property tells the code running in the `<iframe>` what to do,
    while the `context` contains the data to be rendered into a template. The data
    that we'll render will be stored in localStorage under the `webContacts` key,
    and the data will be in JSON format so we need to convert it back to a JavaScript
    object using `JSON.parse()`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`command`属性告诉在`<iframe>`中运行的代码要执行什么操作，而`context`包含要渲染到模板中的数据。我们将要渲染的数据存储在localStorage的`webContacts`键下，并且数据将以JSON格式存储，因此我们需要使用`JSON.parse()`将其转换回JavaScript对象。'
- en: We then add a load handler to the `<iframe>` element using jQuery's `on()` method.
    The code contained in the anonymous function passed to `on()` will be executed
    when the contents of the `<iframe>` have loaded.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用jQuery的`on()`方法为`<iframe>`元素添加加载处理程序。传递给`on()`的匿名函数中包含的代码将在`<iframe>`的内容加载完成后执行。
- en: Once this occurs, we check whether the `context` property of the `message` object
    has a truthy value. If it does, we post the `message` object to the `<iframe>`
    using the `postMessage()` function of the iframe's `contentWindow` property.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦发生这种情况，我们检查 `message` 对象的 `context` 属性是否具有真值。如果是，我们使用 `<iframe>` 的 `contentWindow`
    属性的 `postMessage()` 函数将 `message` 对象发布到 `<iframe>`。
- en: The `postMessage()` function takes two arguments – the first is what to post,
    which in this case is our `message` object, and the second argument specifies
    which files can receive the message. We set this to a wildcard `*` so that any
    files can subscribe to our message.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`postMessage()` 函数接受两个参数 - 第一个是要发布的内容，在这种情况下是我们的 `message` 对象，第二个参数指定哪些文件可以接收此消息。我们将其设置为通配符
    `*`，这样任何文件都可以订阅我们的消息。'
- en: If there aren't any stored contacts, the `context` property of our `message`
    object will have the falsey value `null`. In this case we simply create a new
    `<li>` element with a text message advising that there are no saved contacts and
    append this directly to the empty `<ul>` hardcoded into `popup.html`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有存储的联系人，则我们 `message` 对象的 `context` 属性将具有假值 `null`。在这种情况下，我们只需创建一个新的 `<li>`
    元素，其中包含一条文本消息，说明没有保存的联系人，并将其直接附加到 `popup.html` 中硬编码的空 `<ul>` 中。
- en: Our script file `popup.js` will also need to receive messages. We use the standard
    JavaScript `addEventListener()` function to attach a listener for `message` events
    to the `window`. By default jQuery does not handle `message` events.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的脚本文件 `popup.js` 也需要接收消息。我们使用标准的 JavaScript `addEventListener()` 函数将一个监听器附加到
    `window` 上的 `message` 事件上。默认情况下，jQuery 不处理 `message` 事件。
- en: The messages received by `popup.js` will be the response from the sandboxed
    page containing the HTML markup to render. The markup will be contained in a property
    called `markup`, which will be contained in the `data` property of the event object.
    We simply select the `<ul>` element in `popup.html` and append the markup we receive.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`popup.js` 收到的消息将是包含要渲染的 HTML 标记的沙盒页面的响应。标记将包含在事件对象的 `data` 属性中的名为 `markup`
    的属性中。我们简单地选择 `popup.html` 中的 `<ul>` 元素，并附加我们收到的标记。'
- en: We also added some code to `template.js`, the script file referenced by the
    page inside our `<iframe>`. We used the `addEventListener()` function here to
    subscribe to message events again.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在 `template.js` 中添加了一些代码，该脚本文件被我们 `<iframe>` 内的页面引用。我们在这里再次使用 `addEventListener()`
    函数来订阅消息事件。
- en: This time we first check whether the `command` property of the object sent as
    the message is equal to `issueTemplate`. If it is, we then create and render the
    data into our JsRender template and compose a new `message` object containing
    the rendered template markup.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们首先检查发送消息的对象的 `command` 属性是否等于 `issueTemplate`。如果是，然后我们创建并渲染数据到我们的 JsRender
    模板中，并构建一个包含渲染模板标记的新 `message` 对象。
- en: Once the message object has been created we post it back to `popup.js`. We can
    get the `window` object to send the message using the `source` property of the
    event object, and we can specify which files can receive the message using the
    `origin` property of the event object.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了消息对象后，我们将其发布回 `popup.js`。我们可以使用事件对象的 `source` 属性获取 `window` 对象发送消息，并且可以使用事件对象的
    `origin` 属性指定哪些文件可以接收消息。
- en: These two properties are very similar except that `source` contains a `window`
    object and `origin` contains a filename. The filename will be a special chrome
    extension name. At this point we should be able to launch the popup and see the
    **No contacts** message as we don't have any saved contacts yet.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个属性非常相似，除了 `source` 包含一个 `window` 对象，而 `origin` 包含一个文件名。文件名将是一个特殊的 Chrome
    扩展名。在这一点上，我们应该能够启动弹出窗口，并看到**没有联系人**消息，因为我们还没有保存任何联系人。
- en: Adding a content script
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个内容脚本
- en: We're now at the stage where everything is in place to display stored contacts,
    so we can focus on actually getting some contacts. In order to interact with pages
    that the user navigates to in their browser, we need to add a content script.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一切都已准备就绪以显示存储的联系人，因此我们可以专注于实际获取一些联系人。为了与用户在浏览器中导航的页面交互，我们需要添加一个内容脚本。
- en: A content script is just like a regular script, except that it interacts with
    the page being displayed in the browser instead of with the files that make up
    the extension. We'll see that we can post messages between these different areas
    (the page in the browser and the extension) in a similar way that we posted a
    message to our sandbox.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 内容脚本就像一个常规脚本一样，只是它与浏览器中显示的页面进行交互，而不是与组成扩展的文件进行交互。我们会发现，我们可以在这些不同区域之间（浏览器中的页面和扩展）发送消息，方法与我们发送消息到我们的沙盒类似。
- en: Engage Thrusters
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'First we''ll need to add some new files to the `chrome-extension` directory.
    We''ll need a JavaScript file called `content.js` and a style sheet called `content.css`.
    We need to tell our extension to use these files, so we should also add a new
    section to the manifest file (`manifest.json`) we created earlier in the project:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要向 `chrome-extension` 目录中添加一些新文件。我们需要一个名为 `content.js` 的 JavaScript 文件和一个名为
    `content.css` 的样式表。我们需要告诉我们的扩展使用这些文件，因此我们还应该在此项目之前创建的清单文件（`manifest.json`）中添加一个新部分：
- en: '[PRE9]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This new section should be added directly after the sandbox section that we
    added earlier (as before, don't forget to add the trailing comma after the `sandbox`
    property).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的部分应该直接添加到我们之前添加的沙盒部分之后（像以前一样，在`sandbox`属性后别忘了添加逗号）。
- en: 'Next we can add the required behavior to `content.js`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以向 `content.js` 添加所需的行为：
- en: '[PRE10]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can also add some basic styling that highlights any elements that contain
    microdata attributes using the `content.css` style sheet. Update this file now
    so that it contains the following code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以添加一些基本样式，用 `content.css` 样式表突出显示包含微数据属性的任何元素。现在更新此文件，使其包含以下代码：
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Objective Complete - Mini Debriefing
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 迷你总结
- en: First of all we updated our manifest file to include a content script. As I
    mentioned, content scripts are used to interact with the visible page being displayed
    in the browser instead of any files used by the extension.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们更新了清单文件以包括内容脚本。正如我之前提到的，内容脚本用于与浏览器中显示的可见页面进行交互，而不是与扩展使用的任何文件进行交互。
- en: We can enable a content script using the `content_script` rule in the manifest.
    We need to specify which pages the content script should be loaded into. We use
    a wildcard (`*`) for the `protocol`, `host`, and `path` portions of URLs so that
    the script is loaded when any page is visited.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用清单中的 `content_script` 规则来启用内容脚本。我们需要指定内容脚本应加载到哪些页面中。我们在 URL 的 `protocol`、`host`
    和 `path` 部分使用通配符（`*`）以便在访问任何页面时加载脚本。
- en: When using `Schema.org` microdata to describe people, the different bits of
    information that are present are placed within a container (usually a `<div>`
    element although any element can be used) that has the special attribute `itemtype`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Schema.org` 微数据来描述人物时，存在的不同信息被放置在一个容器内（通常是一个 `<div>` 元素，尽管任何元素都可以被使用），该容器具有特殊属性
    `itemtype`。
- en: The value of this attribute is a URL that specifies what the data the elements
    it contains describe. So to describe a person, this container would have the URL
    [http://schema.org/Person](http://schema.org/Person). This means that the elements
    the container has in it may have additional attributes that describe a specific
    piece of data, such as a name, or a job title. These additional attributes on
    the elements within the container will be `itemprop`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性的值是一个 URL，指定了它包含的元素描述的数据。所以，要描述一个人，这个容器将具有 URL [http://schema.org/Person](http://schema.org/Person)。这意味着容器中的元素可能有描述特定数据的附加属性，比如姓名或职务。容器内的元素上的这些附加属性将是
    `itemprop`。
- en: In this case we're using a jQuery attribute-contains selector (`*=`) to attempt
    to select elements containing this attribute from the page. If the array the attribute
    selector returns has length (and is therefore not empty), we know that at least
    one of these elements exists on the page and so can process the element further.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用了一个 jQuery 属性包含选择器（`*=`）来尝试从页面中选择包含此属性的元素。如果属性选择器返回的数组长度（因此不为空），我们就知道页面上至少存在一个这样的元素，因此可以进一步处理该元素。
- en: The collection of elements with this attribute are stored in a variable called
    `people`. We also create an empty array in the variable `peopleData` ready to
    store all of the information about all of the people found on the page.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 具有此属性的元素集合存储在名为 `people` 的变量中。我们还在变量 `peopleData` 中创建了一个空数组，准备存储页面上找到的所有人的所有信息。
- en: We then use jQuery's `each()` method to iterate the elements selected from the
    page. Instead of using `$(this)` inside our `each()` loop, we can use the collection
    of elements that we've already selected from the page, in conjunction with jQuery's
    `eq()` method along with the current index of the loop in order to reference each
    element, which we store in a variable called `person`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用jQuery的`each()`方法来迭代从页面选择的元素。在我们的`each()`循环中，不使用`$(this)`，我们可以使用我们已经从页面中选择的元素集合，与当前循环的索引一起使用jQuery的`eq()`方法来引用每个元素，我们将其存储在名为`person`的变量中。
- en: We also create an empty object and store it in a variable called `data` ready
    to store the microdata for each person, and an empty object called `contactMethods`
    as any microdata for a telephone number or e-mail address needs to be added to
    a subobject for our template to consume.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建一个空对象并将其存储在名为`data`的变量中，准备存储每个人的微数据，以及一个名为`contactMethods`的空对象，因为任何电话号码或电子邮件地址的微数据都需要添加到我们的模板可消耗的子对象中。
- en: All we do at this point is add a new class name to the container element. We
    can then use the `content.css` style sheet to add some very basic styling to the
    element so that it is brought to the user's attention.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此时我们所做的就是向容器元素添加一个新的类名。然后，我们可以使用`content.css`样式表向元素添加一些非常基本的样式，以引起用户的注意。
- en: Scraping the page for microdata
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抓取页面的微数据
- en: Now that we've got our content script in place, we can interact with any web
    page that the user of the extension visits and check whether it has any microdata
    attributes.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经安装好了我们的内容脚本，我们可以与扩展程序的用户访问的任何网页进行交互，并检查它是否具有任何微数据属性。
- en: At this point, any element containing microdata is highlighted to the user,
    so we need to add the functionality that will allow the user to view the microdata
    and save it if he/she wishes, which is what we'll be covering in this task.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，任何包含微数据的元素都会被用户突出显示，因此我们需要添加功能，允许用户查看微数据并在愿意的情况下保存，这就是我们将在此任务中介绍的内容。
- en: Engage Thrusters
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'Directly after where we add a class name to each element that has an `itemtype`
    attribute in `content.js`, add the following code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在`content.js`中为每个具有`itemtype`属性的元素容器添加类名之后，添加以下代码：
- en: '[PRE12]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Objective Complete - Mini Debriefing
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 小结
- en: In the last task we added a class name to each container of elements marked
    up with microdata. In this task we're still in the context of the `each()` loop
    that processed each container.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个任务中，我们为每个标记了微数据的元素容器添加了一个类名。在此任务中，我们仍处于处理每个容器的`each()`循环的上下文中。
- en: So in the code we added in this task we first call `each()` again, this time
    on the direct children of the container element; we can get these easily using
    jQuery's `children()` method.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个任务中添加的代码中，我们首先再次调用`each()`，这次是在容器元素的直接子元素上；我们可以使用jQuery的`children()`方法轻松获取这些子元素。
- en: Inside this `each()` loop we first get the current item from the existing cached
    `person` variable using the loop counter passed to our iteration function (`j`)
    as an argument for jQuery's `eq()` method. This avoids creating a brand new jQuery
    object inside our loop.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`each()`循环中，我们首先使用传递给我们迭代函数的循环计数器（`j`）作为jQuery的`eq()`方法的参数来获取现有缓存的`person`变量中的当前项目。这样可以避免在我们的循环中创建一个全新的jQuery对象。
- en: We also store the value of the current element's `itemprop` attribute in a variable
    called `iProp` because we'll need to refer to it a number of times and using a
    nice short variable means less typing for us.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将当前元素的`itemprop`属性的值存储在一个名为`iProp`的变量中，因为我们需要多次引用它，并且使用一个漂亮的短变量意味着我们需要输入更少的内容。
- en: At this point we don't know whether we're dealing with a regular element, or
    an element containing microdata, so we use an `if` statement that checks whether
    the `iProp` variable we just set has a truthy value. If the element doesn't have
    an `itemprop` attribute this variable will hold an empty string, which is falsey
    and stops the code progressing further if the element is just a regular element.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此时我们不知道我们是否正在处理常规元素还是包含微数据的元素，因此我们使用一个`if`语句来检查我们刚刚设置的`iProp`变量是否具有真值。如果元素没有`itemprop`属性，则此变量将保存一个空字符串，该空字符串为假值，如果元素只是常规元素，则停止代码进一步进行。
- en: Inside this conditional we know we're dealing with an element containing microdata,
    but there are different formats that the data may take. If the element contains
    an address for example, it won't have any content directly, but will have child
    elements of its own containing the data instead. In this case, the element will
    have an `itemscope` attribute. First we want to process the elements that don't
    contain an `itemscope` attribute so the first branch of our nested conditional
    checks the value returned by selecting the `itemscope` attribute is not an empty
    string.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在此条件语句内部，我们知道我们正在处理包含微数据的元素，但数据可能采用不同的格式。例如，如果元素包含地址，它将不直接包含任何内容，而是将包含数据的自己的子元素。在这种情况下，元素将具有一个`itemscope`属性。首先，我们希望处理不包含`itemscope`属性的元素，因此我们嵌套条件的第一个分支检查通过选择`itemscope`属性返回的值是否不是空字符串。
- en: If you remember our template, we set up a helper function that displayed contact
    information using an object. In order to create this new object instead of creating
    a new property of the `data` object, we use another nested `if` statement to check
    whether the `iProp` variable contains an e-mail or telephone number.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果记得我们的模板，我们设置了一个帮助函数，使用对象显示联系信息。为了创建这个新对象而不是创建`data`对象的新属性，我们使用另一个嵌套的`if`语句来检查`iProp`变量是否包含电子邮件或电话号码。
- en: If it does, we add the value of the `iProp` variable as the key of the `contactMethods`
    object, and the text of the element as the value. If the `iProp` variable doesn't
    contain an e-mail address or a telephone number, we set the `iProp` variable as
    a key of the `data` object, and its value as the element's content.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样，我们将`iProp`变量的值作为`contactMethods`对象的键，元素的文本作为值添加。如果`iProp`变量不包含电子邮件地址或电话号码，我们将`iProp`变量设置为`data`对象的键，并将其值设置为元素的内容。
- en: The next branch of the second nested `if` statement is for elements that do
    have an `itemscope` attribute. In this case, we first define an empty array and
    store it in a variable called `content`. We then iterate over the child elements
    using jQuery's `each()` method and push the text content of each element into
    the `content` array.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个嵌套`if`语句的下一个分支是对具有`itemscope`属性的元素的。在这种情况下，我们首先定义一个空数组，并将其存储在名为`content`的变量中。然后，我们使用jQuery的`each()`方法迭代子元素，并将每个元素的文本内容推入`content`数组。
- en: Once we have iterated over the child elements and populated the array, we can
    then add the current `iProp` variable and the data in the `content` array to our
    `data` object. Any element that has an `itemscope` attribute should still have
    an `itemprop` attribute, so this should still work.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们遍历了子元素并填充了数组，我们就可以将当前的`iProp`变量和`content`数组中的数据添加到我们的`data`对象中。任何具有`itemscope`属性的元素仍应该具有`itemprop`属性，因此这应该仍然有效。
- en: So at this point our data object should be an accurate representation of the
    microdata set on elements inside our main container. Before we do anything with
    them however, we need to check whether the `contentMethods` object has been populated,
    and if so add it to our `data` object.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这一点上，我们的数据对象应该是对我们主容器内部元素设置的微数据的准确表示。但在对它们进行任何操作之前，我们需要检查`contentMethods`对象是否已填充，并且如果已填充，则将其添加到我们的`data`对象中。
- en: We can use the `hasProps()` function to check whether an object has its own
    properties. The function will receive the object to test as an argument. Inside
    the function we first define the `hasData` variable, which we set to `false`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`hasProps()`函数来检查对象是否具有自己的属性。该函数将接收要测试的对象作为参数。在函数内部，我们首先定义`hasData`变量，将其设置为`false`。
- en: We then use a `for in` loop to iterate over each property of the object. For
    each property we check whether the property actually exists on the object and
    was not inherited using JavaScript's `hasOwnProperty()` function. If the property
    does belong to the object, we set the `hasData` to `true` and then break out of
    the loop using `break`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`for in`循环来迭代对象的每个属性。对于每个属性，我们检查该属性是否实际存在于对象上，并且未使用JavaScript的`hasOwnProperty()`函数继承。如果属性确实属于对象，我们将`hasData`设置为`true`，然后使用`break`退出循环。
- en: We then check whether the `contactMethods` object has any properties by passing
    it to our `hasProps()` function, and if it does we add it to the `data` object.
    Finally, once all this processing has been done, we add the `data` object to the
    `peopleData` array we defined at the start of our code.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过将其传递给我们的`hasProps()`函数来检查`contactMethods`对象是否有任何属性，如果有，我们将其添加到`data`对象中。最后，一旦所有这些处理都完成，我们将`data`对象添加到我们在代码开头定义的`peopleData`数组中。
- en: Adding a mechanism for saving the microdata
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个保存微数据的机制
- en: At this point, if the page being displayed in Chrome contains any person microdata,
    we'll have an array containing one or more objects that contain the microdata
    and the text it describes. In this task we'll allow the user to store that data
    if he/she wishes.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，如果 Chrome 中显示的页面包含任何个人微数据，我们将有一个包含一个或多个包含微数据和描述其文本的对象的数组。在此任务中，我们将允许用户存储该数据（如果他/她愿意）。
- en: Because our content script runs in the context of a web page and not our extension,
    we'll need to use messaging once again to pass any gathered data back to the extension
    for storage.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的内容脚本在网页的上下文中运行而不是在我们的扩展中，所以我们需要再次使用消息传递来将任何收集到的数据传递回扩展以进行存储。
- en: Prepare for Lift Off
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备升空
- en: In order to set up messaging between our content script and the extension, we'll
    need to add a background page. A background page runs continuously while the extension
    is installed and enabled and will allow us to set up handlers to listen and respond
    to messages sent from the content script.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的内容脚本和扩展之间设置消息传递，我们需要添加一个背景页。背景页在扩展被安装和启用时持续运行，这将允许我们设置处理程序来监听并响应从内容脚本发送的消息。
- en: 'Background pages may be HTML or JavaScript. In this project we''ll use the
    JavaScript version. Create a new file now and save it in the `chrome-extension`
    directory as `background.js`. We also need to register this file as a background
    script by adding a new `background` section to the `manifest.json` file:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 背景页面可以是 HTML 或 JavaScript。在本项目中，我们将使用 JavaScript 版本。现在创建一个新文件，并将其保存在 `chrome-extension`
    目录中为 `background.js`。我们还需要通过向 `manifest.json` 文件中添加一个新的 `background` 部分来将此文件注册为背景脚本：
- en: '[PRE13]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This code should come directly after the array listing the `content_scripts`.
    Again, don't forget the trailing comma after the array.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码应该直接放在列出 `content_scripts` 的数组之后。再次提醒，不要忘记数组后面的逗号。
- en: Engage Thrusters
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'First we''ll add the required behavior to our background page. In `background.js`,
    add the following code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将向我们的背景页面添加所需的行为。在 `background.js` 中，添加以下代码：
- en: '[PRE14]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, in `content.js`, directly after where we pushed a `data` object into
    the `peopleData` array, add the following code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `content.js` 中，在我们将 `data` 对象推入 `peopleData` 数组之后，直接添加以下代码：
- en: '[PRE15]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we can add a little styling for the new save link that we just added.
    In `content.css`, add the following code at the bottom of the file:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以为我们刚刚添加的新保存链接添加一些样式。在 `content.css` 中，在文件底部添加以下代码：
- en: '[PRE16]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Objective Complete - Mini Debriefing
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 小型简报
- en: We added quite a lot of code in this task as there were a number of different
    files that we updated in order to get the different parts of the extension communicating.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们添加了相当多的代码，因为我们更新了几个不同的文件，以使扩展的不同部分进行通信。
- en: Adding the communication module
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加通信模块
- en: First of all we updated the behavior page that we added at the start of the
    task. We'll be using localStorage to store saved contacts gathered by the extension,
    but the content script that runs in the context of web pages viewed by the user
    of the extension only has access to the localStorage area for any given page,
    but we need access to the localStorage area for the extension itself.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们更新了我们在任务开始时添加的行为页面。我们将使用 localStorage 来存储扩展收集的保存的联系人，但是只有运行在用户查看的网页上下文中的内容脚本才能访问给定页面的
    localStorage 区域，但我们需要访问扩展本身的 localStorage 区域。
- en: To achieve this, our `background.js` file will act as a mediator that will access
    the extension's localStorage area and pass data back and forth between the content
    script and the extension.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们的 `background.js` 文件将充当一个中介，它将访问扩展的 localStorage 区域，并在内容脚本和扩展之间传递数据。
- en: First we added a listener to the `onConnect` event, which we can access via
    Chrome's `extension` utility module. When a content script makes a connection
    to the extension, a port will be opened automatically by the browser. An object
    representing this port will be passed to our handler function automatically.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们添加了一个监听器到 `onConnect` 事件，我们可以通过 Chrome 的 `extension` 实用模块访问。当内容脚本与扩展建立连接时，浏览器将自动打开一个端口。表示此端口的对象将自动传递给我们的处理程序函数。
- en: We can use the port to add an event handler for message events. As with our
    simple `<iframe>` messaging from earlier in the project, this handler function
    will automatically be passed the message that triggers the event.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用端口来添加一个消息事件的处理程序。与项目早期的简单 `<iframe>` 通信一样，此处理程序函数将自动传递触发事件的消息。
- en: Inside the message handler, we check whether the message's `command` property
    is equal to `getData`. If it is, we first create a `contacts` object, which will
    consist of either the contacts obtained from the localStorage `getItem()`method,
    or a very simple JSON object that simply contains the message `no contacts`, which
    we can create manually.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在消息处理程序内部，我们检查消息的`command`属性是否等于`getData`。如果是，我们首先创建一个`contacts`对象，该对象将由localStorage
    `getItem()`方法获取的联系人或者仅包含消息`no contacts`的非常简单的JSON对象组成，我们可以手动创建。
- en: Once we have either of these JSON objects, we can then parse it into a proper
    JavaScript object using Chrome's native JSON `parse()` method. We can then pass
    this object back to the port using the `postMessage()` method. A new port will
    be opened whenever a new connection is made, so messages will automatically be
    passed back to the correct port without additional configuration by us.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这两个JSON对象之一，我们就可以使用Chrome的原生JSON `parse()`方法将其解析为一个真正的JavaScript对象。然后，我们可以使用`postMessage()`方法将此对象传回端口。每当建立一个新的连接时，一个新的端口将被打开，所以消息将自动传回到正确的端口，无需我们进行额外的配置。
- en: If the `command` property of the `msg` object does not equal `getData`, it may
    equal `setData` instead. If it does, we want to store one or more new contacts
    to localStorage. In this case we'll pass the contacts to store as an object contained
    in the `contacts` property of the `msg` object, so we can simply use the `stringify()`
    method on the object in this property as the second argument to the `setItem()`
    method.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`msg`对象的`command`属性不等于`getData`，它可能会等于`setData`。如果是，我们想要将一个或多个新的联系人存储到localStorage。在这种情况下，我们将要存储的联系人作为`msg`对象的`contacts`属性中的对象传递，所以我们可以简单地在这个属性的对象上使用`stringify()`方法作为`setItem()`方法的第二个参数。
- en: We can then pass back a short message confirming that saving the data has been
    a success using the `port` object's `postMessage()` method once more.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们再次使用`port`对象的`postMessage()`方法传回一条简短的消息，确认数据保存成功。
- en: Updating the content script
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新内容脚本
- en: Secondly we updated the `content.js` file in order to harvest and store any
    contact information found on the web page being viewed by the visitor.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们更新了`content.js`文件，以便收集和存储访问者在网页上找到的任何联系信息。
- en: We started out by adding a new `<a>` element that will be used as a button to
    save contact information and which will be added to any element containing microdata.
    We added a simple `# href` attribute to the new element, a class name for styling
    purposes, and the text `Save`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先添加一个新的`<a>`元素，该元素将用作保存联系信息的按钮，并且将添加到包含微数据的任何元素中。我们为新元素添加了一个简单的`# href`属性，一个用于样式目的的类名，以及文本`保存`。
- en: Most of the new functionality is contained in a click event handler attached
    directly to each new `<a>` element when it is created using jQuery's `on()` method.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数新功能都包含在使用jQuery的`on()`方法创建新的`<a>`元素时直接附加到每个元素上的单击事件处理程序中。
- en: Within this event handler we first stop the default behavior of the browser
    using `preventDefault()`, as we usually do when attaching event handlers to `<a>`
    elements. We then cache a reference to the current `<a>` element by storing `$(this)`
    in a variable called `el`. We also open up a new port to handle our communication
    needs using the `extension` module's `connect()` method. A `contacts` variable
    is declared but not defined straight away.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个事件处理程序中，我们首先使用`preventDefault()`停止浏览器的默认行为，就像我们通常在将事件处理程序附加到`<a>`元素时一样。然后，我们通过将`$(this)`存储在一个名为`el`的变量中来缓存对当前`<a>`元素的引用。还使用`extension`模块的`connect()`方法打开一个新的端口来处理我们的通信需求。声明了一个名为`contacts`的变量，但没有立即定义。
- en: The rest of the code resides within an `if` conditional that checks the element
    does not already have the class name `app-saved`, which will help prevent duplicate
    entries for the same person on a single page being saved to localStorage.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其余部分位于一个条件语句内，该条件语句检查元素是否已经具有类名`app-saved`，这将有助于防止同一页面上同一人的重复条目被保存到本地存储中。
- en: In the conditional we first need to get any previously stored contacts, so we
    request the saved contacts from the behavior page by posting a message to the
    port we opened a moment ago. We send an object as the message which has a `command`
    property set to `getData`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在条件语句中，我们首先需要获取先前存储的联系人，因此我们通过向我们刚刚打开的端口发送消息来请求行为页面上的保存联系人。我们将一个具有`command`属性设置为`getData`的对象作为消息发送。
- en: We then add a handler for the response to this message using the `addListener()`
    method on the `onMessage` event. The rest of our code is within this handler,
    which consists of another conditional that reacts differently depending on the
    response message.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`addListener()`方法对此消息的响应添加了一个处理程序，该方法在`onMessage`事件上。我们的其余代码位于此处理程序中，其中包含根据响应消息不同而有不同反应的另一个条件语句。
- en: The first branch of the conditional deals with when the `message` property of
    the response `msg` contains the string `no contacts`. In this case we create a
    new array which contains the contact information harvested from the person for
    whichever save link was clicked. We already have this information in the `peopleData`
    array and as we're still inside the loop that updates each person, we can use
    the `i` variable to store the correct person.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句的第一个分支处理响应`msg`的`message`属性包含字符串`no contacts`的情况。在这种情况下，我们创建一个新数组，其中包含从点击的保存链接中收集的联系人信息。我们已经在`peopleData`数组中有这些信息，并且由于我们仍处于更新每个人的循环中，因此我们可以使用`i`变量来存储正确的人员。
- en: We can then send this array to the behavior page for permanent storage in the
    extension's localStorage area.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将此数组发送到行为页面，以永久存储在扩展程序的本地存储区域中。
- en: If the `msg` object doesn't have a `message` property it may have a `contacts`
    property instead. This property will contain the array of previously stored contacts
    so we can save the array to a variable, and add the new contact to this array
    before posting the updated array back to the behavior page for permanent storage.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`msg`对象没有`message`属性，可能有`contacts`属性。此属性将包含先前存储的联系人数组，因此我们可以将数组保存到变量中，并在将更新后的数组发送回行为页面进行永久存储之前将新联系人添加到此数组中。
- en: The final branch of the conditional deals with a successful save of the contact.
    In this case the `message` property of the `msg` object will contain the `success`
    string. In this case we add the class name `app-saved` to the `<a>` element and
    change the text to `Contact information saved`. As the port is no longer required
    we can close it using the `disconnect()` method of the `port` object.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句的最后一个分支处理了联系人成功保存的情况。在这种情况下，`msg`对象的`message`属性将包含`success`字符串。在这种情况下，我们将类名`app-saved`添加到`<a>`元素，并将文本更改为`联系信息已保存`。由于不再需要端口，我们可以使用`port`对象的`disconnect()`方法关闭它。
- en: Adding the simple styling
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加简单的样式
- en: Lastly we added some very simple styling for the save links. It's important
    to show feedback once the operation that the user initiates has completed.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们为保存链接添加了一些非常简单的样式。一旦用户发起的操作完成，显示反馈非常重要。
- en: In this example, we do that by changing the text of the link simply making it
    more opaque using CSS to make it look as if it is no longer clickable, which is
    the case because of the `if` statement we used in the script.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们通过改变链接的文本简单地使用CSS使其更加不透明，使其看起来好像不再可点击，这是因为我们在脚本中使用的`if`语句的情况。
- en: At this point we should now be able to browse to a page that contains microdata
    and save contact information. When the browser action button is clicked, we'll
    see the popup, which should display the saved contact, as shown in the screenshot
    at the start of the project.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该能够浏览到包含微数据并保存联系信息的页面。当单击浏览器操作按钮时，我们将看到弹出窗口，其中应显示保存的联系人，如项目开始时的屏幕截图所示。
- en: Classified Intel
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机密情报
- en: When testing content scripts, it's important to realize that whenever any of
    the content files change, which in this case means either the JavaScript file
    or the style sheet, the extension must be reloaded.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试内容脚本时，重要的是要意识到每当内容文件更改时，这在本例中意味着JavaScript文件或样式表，都必须重新加载扩展程序。
- en: To reload the extension, there's a **Reload** (*Ctrl* + *R*) link below the
    extension listed on Chrome's **Extensions** page. We'll need to click on this
    link to apply changes made to any of the content files. Other parts of the extension,
    such as the popup files for example, do not require that the extension be reloaded.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要重新加载扩展程序，在Chrome的**扩展程序**页面中列出的扩展程序下方有一个**重新加载**（*Ctrl* + *R*）链接。我们需要点击此链接以应用对任何内容文件所做的更改。扩展程序的其他部分，例如弹出窗口文件，不需要重新加载扩展程序。
- en: Another useful tool for extension programmers is the developer tool, which can
    be opened specifically to monitor the code in the background page. This can be
    useful for troubleshooting errors and script debugging when using a background
    page.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展程序员的另一个有用工具是开发者工具，它可以专门打开以监视后台页面中的代码。在使用后台页面时，进行故障排除和脚本调试时，这可能非常有用。
- en: Mission Accomplished
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务完成
- en: In this project we've covered most of the basics of building a Chrome extension.
    We covered creating a browser action that triggers a popup when it is clicked
    in order to display saved contacts.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们涵盖了构建Chrome扩展的大部分基础知识。我们介绍了创建一个浏览器操作，当点击它时触发弹出窗口，以显示保存的联系人。
- en: We also saw how we can safely sandbox pages that need to run dangerous code
    such as `eval()` or `new Function` in order to protect our extension from XSS
    attacks, and how we can use the simple messaging API to send messages and receive
    responses to an `<iframe>` element containing the sandboxed page.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解了如何安全地对需要运行危险代码（如`eval()`或`new Function`）的页面进行沙盒化，以保护我们的扩展不受XSS攻击的影响，并且我们如何使用简单的消息传递API向包含沙盒化页面的`<iframe>`元素发送消息并接收响应。
- en: We saw that as well as defining scripts that run in the context of the extension,
    we can also add content scripts that run in the context of the web page being
    displayed in the browser. We also learned how to use the `manifest.json` file
    to specify these different areas of our extension.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，除了定义在扩展上下文中运行的脚本之外，还可以添加在浏览器中显示的网页上下文中运行的内容脚本。我们还学会了如何使用`manifest.json`文件来指定扩展的这些不同区域。
- en: We also saw that we can use a much more advanced messaging system that allows
    us to open ports that allow for more than simple one-way messages. Communicating
    via ports allows us to send as many messages back and forth from different areas
    of our extension as we need to in order to complete a given task such as saving
    data to the extension's localStorage area.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到可以使用更高级的消息传递系统，允许我们打开允许进行更复杂双向消息传递的端口。通过端口通信，我们可以从扩展的不同区域发送并接收尽可能多的消息，以完成保存数据到扩展localStorage区域等特定任务。
- en: We also learned about the type of data that can be described using `Schema.org`
    microdata, and the HTML attributes that can be added to elements in order to do
    the describing. As well as being able to describe people, there are also `Schema.org`
    formats for describing places, companies, movies, and much more.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解了可以使用`Schema.org`微数据描述的数据类型，以及可以添加到元素中进行描述的HTML属性。除了能描述人以外，还有用于描述地点、公司、电影等等的`Schema.org`格式。
- en: We've learned a lot about creating extensions in Chrome, but we've also used
    a ton of jQuery methods in order to simplify the scripts that we've written to
    power the extension.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学到了很多关于在Chrome中创建扩展，但是我们还使用了大量jQuery方法，以简化我们编写的脚本，以驱动扩展程序。
- en: You Ready To Go Gung HO? A Hotshot Challenge
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你准备好全力以赴了吗？一个热门挑战
- en: When our extension saves new contacts, the highlighted elements representing
    the elements containing microdata are given a new CSS class name and have some
    very minimal additional styling added to them.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的扩展保存新联系人时，包含微数据的突出显示元素将被赋予新的CSS类名，并且会对它们进行一些非常简约的额外样式修改。
- en: This is ok, but a better way of confirming success would be to make use of Chrome's
    desktop notification system to generate growl-style pop-up notifications that
    confirm success instead.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做是可以的，但确认成功的更好方法是利用Chrome的桌面通知系统，生成类似Growl风格的弹出式通知来确认成功。
- en: Check out the notification documentation at [http://developer.chrome.com/extensions/notifications.html](http://developer.chrome.com/extensions/notifications.html)
    and see if you can update the extension to include this feature.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 访问[http://developer.chrome.com/extensions/notifications.html](http://developer.chrome.com/extensions/notifications.html)查看通知文档，并查看是否可以更新扩展以包括此功能。
