- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: What Is State and How Do We Manage It?
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态是什么以及我们如何管理它？
- en: '**State** is a mutable data source that can be used to store data in a **React**
    application and can change over time and be used to determine how your component
    renders.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**状态**是一个可变的数据源，可以用于在 **React** 应用程序中存储数据，并且可以随时间变化，并可用于确定你的组件如何渲染。'
- en: This chapter will refresh your existing knowledge about state in the React ecosystem.
    We will review what it is and why it is needed, and understand how it helps you
    build React applications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将更新你对 React 生态系统中的状态的现有知识。我们将回顾它是什么以及为什么需要它，并了解它是如何帮助你构建 React 应用的。
- en: We’ll also review how you can manage state natively in React by using the **useState**
    hook, the **useReducer** hook, and **React Context**.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将回顾如何通过使用 **useState** 钩子、**useReducer** 钩子和 **React Context** 原生地管理状态。
- en: Finally, we’ll offer brief descriptions of the common state management solutions
    such as **Redux**, **Zustand**, and **MobX** and understand why they have been
    created and the main common concept they all share.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将简要介绍常见的状态管理解决方案，如 **Redux**、**Zustand** 和 **MobX**，并了解它们为什么被创建以及它们共有的主要概念。
- en: 'By the end of this chapter, you will have either learned or remembered everything
    about state necessary to proceed in this book. You will also notice a pattern
    in how state is managed between different state management solutions and meet
    or get reacquainted with a familiar term. Spoiler alert: it is global state.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将学习或记住关于状态的所有必要知识，以便继续阅读本书。你还会注意到不同状态管理解决方案之间状态管理的方式存在一种模式，或者重新认识一个熟悉的术语。剧透一下：它是全局状态。
- en: 'In this chapter, we’ll be covering the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is state in React?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 中的状态是什么？
- en: Managing state in React
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 React 中管理状态
- en: What do different state management libraries have in common?
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的状态管理库有什么共同之处？
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this book, you are going to see some code snippets. If you want to try them
    out, you are going to need the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，你将看到一些代码片段。如果你想尝试它们，你需要以下工具：
- en: An **integrated development environment** (**IDE**) such as Visual Studio Code.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种**集成开发环境**（**IDE**）如 Visual Studio Code。
- en: A web browser (Google Chrome, Firefox, or Edge).
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个网络浏览器（Google Chrome、Firefox 或 Edge）。
- en: Node.js. All the code in this book was written with the current LTS version
    installed (16.16.0).
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js。本书中的所有代码都是使用当前 LTS 版本编写的（16.16.0）。
- en: A package manager (npm, Yarn, or pnpm).
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包管理器（npm、Yarn 或 pnpm）。
- en: 'A React project. If you don’t have one, you can create one with Create React
    App by running the following command in your terminal:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 React 项目。如果你没有，你可以在终端中运行以下命令来创建一个：
- en: '[PRE0]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_1](https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_1).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码示例都可以在 GitHub 上找到：[https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_1](https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_1)。
- en: What is state in React?
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React 中的状态是什么？
- en: State is the heart of your React application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 状态是你的 React 应用的核心。
- en: I challenge you to try to build a React application without any type of state.
    You’d probably be able to do something, but you would soon conclude that props
    cannot do everything for you and get stuck.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我挑战你尝试构建一个没有任何类型状态的 React 应用程序。你可能能够做些什么，但很快你就会得出结论，props 不能为你做所有事情，然后陷入困境。
- en: As mentioned in the introduction, state is a mutable data source used to store
    your data.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如介绍中所述，状态是一个可变的数据源，用于存储你的数据。
- en: State is mutable, which means that it can be changed over time. When a state
    variable changes, your React component will re-render to reflect any changes that
    the state causes to your UI.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 状态是可变的，这意味着它可以随时间变化。当状态变量发生变化时，你的 React 组件将重新渲染以反映状态对 UI 造成的任何更改。
- en: 'Okay, now, you might be wondering, “*What will I store in my state?*” Well,
    the rule of thumb that I follow is that if your data fits into any of the following
    points, then it’s not state:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在，你可能想知道，“*我在状态中会存储什么？*”嗯，我遵循的一个经验法则是，如果你的数据符合以下任何一点，那么它就不是状态：
- en: Props
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Props
- en: Data that will always be the same
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是相同的 数据
- en: Data that can be derived from other state variables or props
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以从其他状态变量或 props 推导出的数据
- en: Anything that doesn’t fit this list can be stored in state. This means things
    such as data you just fetched through a request, the light or dark mode option
    of a UI, and a list of errors that you got from filling a form in the UI are all
    examples of what can be state.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 任何不符合此列表的内容都可以存储在状态中。这意味着像通过请求获取的数据、UI 的浅色或深色模式选项以及从 UI 表单中填写错误得到的错误列表等都是状态的例子。
- en: 'Let’s look at the following example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we have a component called `NotState`. Let’s look at the values we have
    in there and use our rule of thumb.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有一个名为 `NotState` 的组件。让我们看看里面的值，并使用我们的经验法则。
- en: The `aList` variable is a component prop. Since our component will receive this,
    it doesn’t need to be state.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`aList` 变量是一个组件属性。由于我们的组件将接收这个属性，因此它不需要是状态。'
- en: Our `value` variable is assigned a string value. Since this value will always
    be *constant*, then it doesn’t need to be state.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `value` 变量被分配了一个字符串值。由于这个值始终是 *常量*，因此它不需要是状态。
- en: Finally, the `filteredList` variable is something that can be derived from our
    `aList` prop; therefore, it doesn’t need to be state.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`filteredList` 变量是从我们的 `aList` 属性中派生出来的；因此，它不需要是状态。
- en: Now that you are familiar with the concept of state, let’s get our hands dirty
    and understand how can we manage it in React.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了状态的概念，让我们动手了解如何在 React 中管理它。
- en: Managing state in React
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 React 中管理状态
- en: Before diving into some examples, it is important to mention that in this book,
    *all the examples shown are in a React version after 16.8*. This is because **React
    Hooks** were introduced in this version. Hooks changed the way we write React
    code and allowed for the appearance of libraries such as React Query, so it makes
    sense that any examples shown leverage them.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入一些示例之前，重要的是要提到，在这本书中，*所有展示的示例都是 React 16.8 版本之后的版本*。这是因为 **React Hooks**
    是在这个版本中引入的。Hooks 改变了我们编写 React 代码的方式，并允许出现像 React Query 这样的库，因此任何展示的示例都利用了它们。
- en: What is React Query?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是 React Query？
- en: React Query is a protocol-agnostic collection of hooks for fetching, caching,
    and updating server state in React.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: React Query 是一个用于在 React 中获取、缓存和更新服务器状态的协议无关的钩子集合。
- en: In this section, I’ll show you how React allows us to handle state in a component
    and what we should do if we need to share state between components.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将向您展示 React 如何在组件中处理状态，以及如果我们需要在组件之间共享状态时应该做什么。
- en: Let’s consider the following scenario.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下场景。
- en: 'I want to build an application that allows me to count something. In this application,
    I want to be able to do the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我想构建一个允许我计数的应用程序。在这个应用程序中，我想能够做以下事情：
- en: See the current counter value
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看当前计数器值
- en: Increment my counter
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加我的计数器
- en: Decrement my counter
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少我的计数器
- en: Reset the counter
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重置计数器
- en: 'Let’s imagine that we have a React component called `App`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象我们有一个名为 `App` 的 React 组件：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This app provides the UI needed to handle our counter needs, such as a `div`
    that we should use to display our `count` and three buttons with an `onClick`
    event waiting for a callback function to perform each of the following actions
    needed.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序提供了处理我们的计数器需求所需的 UI，例如一个 `div`，我们应该用它来显示我们的 `count`，以及三个带有 `onClick` 事件的按钮，等待回调函数执行以下所需的每个动作。
- en: 'We are just missing the heart of this component, which is the state. Natively,
    React gives us two ways to hold state in our applications: `useState` and `useReducer`.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是缺少这个组件的核心，即状态。React 本地为我们提供了两种在应用程序中保存状态的方法：`useState` 和 `useReducer`。
- en: Let’s start by looking at `useState`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看 `useState` 开始。
- en: Managing state with useState
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `useState` 管理状态
- en: '`useState` is a React Hook that allows you to hold a stateful value. When calling
    this hook, it will return the stateful value and a function to update it.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`useState` 是一个 React 钩子，允许你保存一个有状态值。当你调用这个钩子时，它将返回一个有状态值和一个用于更新它的函数。'
- en: 'Let’s look at an example of how to leverage `useState` to build the counter
    application:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何利用 `useState` 构建计数器应用的示例：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding snippet leverages the `useState` hook to hold our counter state.
    When we first call `useState`, two things are done:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段利用 `useState` 钩子来保存我们的计数器状态。当我们第一次调用 `useState` 时，会做两件事：
- en: The state value is initiated as 0
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态值初始化为 0
- en: The `count` state variable is destructured; then, the same is done to the state
    updater function, called `setCount`
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count` 状态变量被解构；然后，对状态更新函数，称为 `setCount`，也做了同样的处理'
- en: After this, we declare functions where we use the state updater function, `setCount`,
    to either increment, decrement, or reset our state variable.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们声明函数，在其中我们使用状态更新函数`setCount`来增加、减少或重置我们的状态变量。
- en: Finally, we assign our state variable to the respective UI section and pass
    the callbacks to our buttons’ `onClick` events.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将状态变量分配给相应的UI部分，并将回调传递给按钮的`onClick`事件。
- en: With that, we have built a simple counter application. Our application will
    start rendering our count as 0\. Every time we click on the buttons, it will execute
    the respective state update, re-render our application, and display the new count
    value.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经构建了一个简单的计数器应用。我们的应用将开始渲染计数为0。每次我们点击按钮时，它将执行相应的状态更新，重新渲染我们的应用，并显示新的计数值。
- en: '`useState` is the answer most of the time when you need any state in your React
    applications. Just don’t forget to apply the “*what will I store in my state?*”
    rule of thumb before!'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`useState`是你在React应用中需要任何状态时最常用的答案。但别忘了在应用之前先应用“*我在状态中要存储什么？*”的经验法则！'
- en: Now, let’s see an example of how to manage state and build the same counter
    application by using the `useReducer` hook.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用`useReducer`钩子来管理状态并构建相同的计数器应用的例子。
- en: Managing state with useReducer
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用useReducer管理状态
- en: '`useReducer` is the preferred option when we have a more complex state. Before
    using the hook, we need to do some setup so that we have everything we need to
    send to our `useReducer` hook:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个更复杂的状态时，`useReducer`是首选选项。在使用钩子之前，我们需要做一些设置，以便我们有发送到`useReducer`钩子所需的一切：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the preceding snippet, we created three things:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，我们创建了三件事：
- en: An `initialState` object. This object has a property count with `0` as its value.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`initialState`对象。该对象有一个属性count，其值为`0`。
- en: A `types` object that describes all the action types we will support.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个描述我们将支持的所有操作类型的`types`对象。
- en: A **reducer**. This reducer is responsible for receiving our state and action.
    By matching that action with the expected type, we’ll be able to update the state.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**reducer**。这个reducer负责接收我们的状态和操作。通过匹配该操作与预期的类型，我们将能够更新状态。
- en: 'Now that the setup is done, let’s create our counter:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在设置完成，让我们创建我们的计数器：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding snippet leverages the `useReducer` hook to hold our counter state.
    When we first call `useReducer`, three things are done:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段利用`useReducer`钩子来保存我们的计数器状态。当我们第一次调用`useReducer`时，会做三件事：
- en: We indicate to our hook what `reducer` should be used
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们向我们的钩子指示应该使用哪个`reducer`。
- en: We initialize our state with the `initialState` object
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`initialState`对象初始化我们的状态。
- en: We destructure the `state` object and then the `dispatch` function, which allows
    us to dispatch an action from the `useReducer` hook
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们解构`state`对象和`dispatch`函数，这使得我们可以从`useReducer`钩子中分发操作。
- en: After this, we create the functions that will be responsible for calling the
    `dispatch` function with the expected action.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们创建负责调用带有预期操作的`dispatch`函数的函数。
- en: Finally, we assign our state variable to the respective UI section and pass
    the callbacks to our buttons’ `onClick` events.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将状态变量分配给相应的UI部分，并将回调传递给按钮的`onClick`事件。
- en: With these two *hooks* under your belt, you now know how to manage state in
    your components.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经掌握了这两个*钩子*，你现在知道如何在组件中管理状态。
- en: 'Now, let’s picture the following scenario: what if you need your counter state
    to be accessible in other components?'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们设想以下场景：如果你需要你的计数器状态在其他组件中可访问怎么办？
- en: You could pass them by props. But what if this state needs to be sent to five
    other components and different levels on the tree? Would you be prop-drilling
    it and passing it to every component?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过props传递它们。但如果这个状态需要发送到树上的五个其他组件和不同级别呢？你会进行prop-drilling并将它传递给每个组件吗？
- en: To deal with this scenario and improve your code readability, **React Context**
    was created.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这种场景并提高代码的可读性，**React Context**被创建出来。
- en: Sharing state with React Context
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用React Context共享状态
- en: 'Context allows you to natively share values between components without having
    to prop drill them. Let’s learn how to build a context to handle our counter:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Context允许你在不进行prop-drilling的情况下在组件之间原生地共享值。让我们学习如何构建一个上下文来处理我们的计数器：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the preceding snippet, we are doing three things:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，我们做了三件事：
- en: Using the `createContext` function to create our context.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`createContext`函数创建我们的上下文。
- en: Creating a `useState` hook. At the end of the store, we return an object that
    contains the functions to do the state updates and create our state variable.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`useState`钩子。在存储的末尾，我们返回一个包含执行状态更新和创建我们的状态变量的函数的对象。
- en: Creating a `CountProvider`. This provider is responsible for creating a provider
    that will be used to wrap a component. This will allow every component that is
    inside of that provider to access our `CountStore` values.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`CountProvider`。这个提供者负责创建一个将用于包裹组件的提供者。这将允许该提供者内部的每个组件都能访问我们的`CountStore`值。
- en: 'Once this setup has been done, we need to make sure our components can access
    our context:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成这个设置，我们需要确保我们的组件可以访问我们的上下文：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding snippet leverages `CountProvider`, which we created in the *previous
    snippet*, to wrap up our `App` component. This allows every component inside `App`
    to consume our context:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段利用了我们在*前面的代码片段*中创建的`CountProvider`来包裹我们的`App`组件。这允许`App`内部的每个组件都能消费我们的上下文：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Finally, in this snippet, we leverage the `useContext` hook to consume our `CountContext`.
    Since our component is rendered inside our custom provider, we can access the
    state held inside our context.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在这个代码片段中，我们利用了`useContext`钩子来消费我们的`CountContext`。由于我们的组件是在我们的自定义提供者中渲染的，因此我们可以访问上下文中的状态。
- en: Every time the state updates inside of our context, React will make sure that
    every component that is consuming our context will re-render, as well as receive
    the state updates. This can often lead to unnecessary re-renders because if you
    are consuming only a variable from the state and for some reason another variable
    changes, then the context will force all consumers to re-render.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 每当上下文中的状态更新时，React将确保所有消费我们的上下文的组件都会重新渲染，并接收状态更新。这往往会导致不必要的重新渲染，因为如果你只消费状态中的一个变量，而由于某种原因另一个变量发生了变化，那么上下文将迫使所有消费者重新渲染。
- en: One of the downsides of context is that often, unrelated logic tends to get
    grouped. As you can see from the preceding snippets, it comes at the cost of a
    bit of boilerplate code.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文的一个缺点是，通常，无关的逻辑会聚集在一起。正如你可以从前面的代码片段中看到的那样，这会以牺牲一些样板代码为代价。
- en: Now, Context is still great, and it’s how React enables you to share state between
    components. However, it was not always around, so the community had to come up
    with ideas on how to enable state sharing. To do so, state management libraries
    were created.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，上下文仍然很强大，这是React如何让你在组件之间共享状态的方式。然而，它并非一直存在，因此社区不得不想出如何实现状态共享的方法。为此，创建了状态管理库。
- en: What do different state management libraries have in common?
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同的状态管理库有什么共同之处？
- en: One of the freedoms React offers you is that it does not impose any standards
    or practices for your development. While this is great, it also leads to different
    practices and implementations.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: React为你提供的一个自由是，它不对你的开发强加任何标准或实践。虽然这很好，但它也导致了不同的实践和实现。
- en: 'To make this easier and give developers some structure, state management libraries
    were created:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这更容易，并为开发者提供一些结构，创建了状态管理库：
- en: '**Redux** promotes an approach focused on stores, reducers, and selectors.
    This leads to needing to learn specific concepts and filling your project with
    a bunch of boilerplate code that might impact the code’s readability and increase
    code complexity.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Redux**提倡一个以存储、reducer和选择器为重点的方法。这导致需要学习特定的概念，并在项目中填充大量可能影响代码可读性和增加代码复杂性的样板代码。'
- en: '**Zustand** promotes a custom hook approach where each hook holds your state.
    This is by far the simplest solution and currently my favorite one. It synergizes
    with React and fully embraces hooks.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Zustand**提倡使用自定义钩子方法，其中每个钩子都持有你的状态。这是迄今为止最简单的解决方案，也是我最喜欢的解决方案。它与React协同工作，并完全拥抱钩子。'
- en: '**MobX** doesn’t impose an architecture but focuses on a functional reactive
    approach. This leads to more specific concepts, and the diversity of practices
    can lead the developer to run into the same struggles of code structure that they
    might already suffer from with React.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MobX**不强制架构，而是关注于函数式响应式方法。这导致了一些更具体的概念，实践方式的多样性可能导致开发者遇到与React中可能已经遇到的相同的代码结构问题。'
- en: 'One common thing in all these libraries is that all of them are trying to solve
    the same type of issues that we tried to solve with React Context: *a way to manage
    our* *shared state*.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些库中有一个共同点，那就是它们都在尝试解决我们尝试用React Context解决的问题：*管理我们的* *共享状态* *的方法*。
- en: The state that is accessible to multiple components inside a React tree is often
    called global state. Now, global state is often misunderstood, which leads to
    the addition of unnecessary complexity to your code and often needing to resort
    to the libraries mentioned in this section.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在React树内部可访问多个组件的状态通常被称为全局状态。现在，全局状态常常被误解，这导致你的代码中增加了不必要的复杂性，并且常常需要求助于本节中提到的库。
- en: At the end of the day, each developer and team have their preferences and choices.
    Considering React gives you the freedom to handle your state however you want,
    you must consider all the advantages and disadvantages of each solution before
    making your choice. Migrating from one to another can take a lot of time and completely
    change the paradigm of how state is handled in your application, so choose wisely
    and take your time.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，每个开发者和团队都有自己的偏好和选择。考虑到React给你提供了处理状态的自由，你必须考虑每个解决方案的所有优缺点，在做出选择之前。从一个迁移到另一个可能需要大量时间，并完全改变你应用程序中处理状态的模式，所以请明智地选择，并留出足够的时间。
- en: While global state is not the reason why React Query was built, it has an impact
    on its creation. The way global state is often composed led to the need to manage
    a specific part of it that has many challenges. This specific part is called server
    state and the way it was historically handled paved the way to motivate Tanner
    Linsley to create React Query.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然全局状态不是React Query被构建的原因，但它对其创建有影响。全局状态通常的组成方式导致了管理其特定部分的需要，这部分有许多挑战。这个特定部分被称为服务器状态，而它历史上的处理方式为激励Tanner
    Linsley创建React Query铺平了道路。
- en: Summary
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we became familiar with the concept of state. By now, you should
    understand the importance of state as the heart of React applications and know
    how you can manage it natively with the help of `useState` and `useReducer`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们熟悉了状态的概念。到目前为止，你应该理解状态作为React应用程序核心的重要性，并知道如何借助`useState`和`useReducer`原生化地管理它。
- en: You learned that sometimes, you need to share your state with multiple components
    and that you can do it with Context or by leveraging a third-party state management
    library. Each of these solutions has its pros and cons, and at the end of the
    day, it will be a question of developer preference.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你了解到有时你需要与多个组件共享状态，你可以通过Context或利用第三方状态管理库来实现。每种解决方案都有其优缺点，最终将取决于开发者的个人偏好。
- en: In [*Chapter 2*](B18501_02.xhtml#_idTextAnchor049), *Server State versus Client
    State*, you will understand more about global state, and you find out that often,
    our global state is a combination of both server and client state. You will learn
    what these terms mean, how to identify these states, and what the common challenges
    associated with them are.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第二章*](B18501_02.xhtml#_idTextAnchor049)《服务器状态与客户端状态》中，你将更深入地了解全局状态，并发现我们的全局状态通常是服务器和客户端状态的组合。你将学习这些术语的含义，如何识别这些状态，以及与它们相关的常见挑战。
