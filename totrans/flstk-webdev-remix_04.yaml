- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Routing in Remix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: “Routing is possibly the most important concept to understand in Remix.”
  prefs: []
  type: TYPE_NORMAL
- en: – Remix documentation
  prefs: []
  type: TYPE_NORMAL
- en: Michael Jackson and Ryan Florence spent years building React Router. It is not
    a surprise that routing plays an integral role in Remix. One core idea that Michael
    and Ryan brought over from React Router to Remix is nested routing. Nested routing
    is a powerful feature that enables the composition of route components.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about routing in Remix. We’ll cover the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with Remix's route module API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composing pages from nested routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using route parameters for dynamic routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing layouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling navigations in Remix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will dive into nested routing and cover Remix’s route convention.
    We will start by creating standalone pages and reviewing Remix’s route module
    exports. Next, we will review nested, index, dynamic, and (pathless) layout routes.
    Finally, we will learn how to transition between routes and learn about the global
    navigation object.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand the core principles behind Remix’s
    routing solution. You will have practiced creating new route modules and know
    which exports Remix supports. You will understand the advantages of nested routing
    and layout routes. You will also practice how to work with route parameters. Finally,
    you will know how to work with Remix’s global navigation object.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will add a login and a signup page to the BeeRich application.
    We will further create a dashboard route with nested expenses and income child
    routes. Then, we will create a shared layout for the index, login, and signup
    pages. Finally, we will animate page transitions using the global navigation object.
    Let’s jump right into it and create our first routes in Remix.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B17399_03.xhtml#_idTextAnchor043), *Deployment Targets, Adapters,
    and Stacks*, we set up the demo application for this book. If you haven’t already,
    make sure to follow the instructions of [*Chapter 3*](B17399_03.xhtml#_idTextAnchor043),
    as we will continue working with BeeRich in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the solution code and additional information to this chapter on
    GitHub: [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/04-routing-in-remix](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/04-routing-in-remix).'
  prefs: []
  type: TYPE_NORMAL
- en: Working with Remix's route module API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remix takes on the responsibilities of a compiler, a runtime, and a router.
    In Remix, you create routes (route modules) as part of a hierarchy. Among other
    things, Remix’s router determines which route modules to match and render on a
    request.
  prefs: []
  type: TYPE_NORMAL
- en: This section will walk you through the creation of route modules in Remix. You
    will learn how to create standalone pages and understand how routes tie back to
    the `root.tsx` file. You will further understand how index routes fit into the
    picture (or, I should say, on a screen). Finally, the section will introduce you
    to the different available exports that route modules can expose.
  prefs: []
  type: TYPE_NORMAL
- en: Route file-naming conventions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we get started, note that Remix switched to a new route file-naming convention
    with Remix v2\. This book follows that convention.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are new to Remix, then this chapter will get you started with Remix’s
    latest convention. If you have prior experience with Remix’s v1 filesystem route
    convention, you can refer to this guide to learn what has changed: [https://remix.run/docs/en/1.19.3/file-conventions/route-files-v2](https://remix.run/docs/en/1.19.3/file-conventions/route-files-v2).'
  prefs: []
  type: TYPE_NORMAL
- en: Working with file-based routing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We start by inspecting the current route structure of BeeRich. We will continue
    with the BeeRich code from the previous chapter. Alternatively, you can find the
    start code for this chapter here: [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/03-deployment-targets-adapters-and-stacks/bee-rich](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/03-deployment-targets-adapters-and-stacks/bee-rich).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s review the current route hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command in a terminal at the root of your Remix project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let’s run our application locally by executing `npm run dev` in a terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the application in your browser by navigating to [http://localhost:3000/](http://localhost:3000/).
    This routes us to the `/`path of the application. Welcome (again) to BeeRich!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Back in your editor, open the `app/routes/_index.tsx` file. The file contains
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, let’s visit the `/demo` page. Add `demo` to the URL in the address bar
    of your browser. The demo page showcases available reusable components that we
    can use to build our BeeRich application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `app/routes/demo.tsx` file. Note that we again export a React component
    as the default export of the module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is some magic at play here. We didn’t need to specify the routes hierarchy
    to Remix explicitly through code. No configuration file maps components to pathnames.
    This is the power of `routes` folder’s hierarchy. It creates an **asset manifest**
    that includes the route hierarchy of the application.
  prefs: []
  type: TYPE_NORMAL
- en: When visiting a page, Remix knows which route components to render. Exporting
    the route component as the default export is a convention so that Remix can find
    your code.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dive into the conventions of Remix’s file-based routing and create some
    standalone pages.
  prefs: []
  type: TYPE_NORMAL
- en: Creating route modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [*Chapter 8*](B17399_08.xhtml#_idTextAnchor119), *Session Management*, we
    will add a signup and login authentication flow to BeeRich. In this chapter, we
    will set up the general route structure to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file in the `routes` folder and name it `login.tsx`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, use the address bar of your browser to navigate to the newly created page
    ([http://localhost:3000/login](http://localhost:3000/login)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will see the following error pop up on the screen:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: A UI route must export a React component as its default export. This is part
    of the conventions of Remix’s file-based routing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove the error from the screen, switch to your editor and add a React
    component to the newly created `login.tsx` file. The following code should suffice
    for now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that we use `H1`, a reusable component from the `app/components` folder,
    to avoid rewriting a bunch of custom styling.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Also, note that the import path starts with a tilde symbol (`~`). This is a
    neat TypeScript feature. We map the `app` folder to `~` in our `tsconfig.json`
    path configuration. This allows us to use the tilde symbol as a shorthand to target
    any file or folder in the `app` folder.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Refresh the browser window. The `/login` page should now render correctly. Awesome!
    You just created your first standalone page with Remix!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, create a `signup.tsx` file in the `routes` folder. Then, copy and paste
    the code from the login page and adapt the code to better fit the signup page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the address bar of your browser to navigate to the newly created page ([http://localhost:3000/signup](http://localhost:3000/signup)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s run the `remix routes` command again to see how the routes hierarchy
    grew. Execute the following command in your terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This yields the following route hierarchy:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As expected, the routes hierarchy grew by two leave routes. Each leaf route
    represents a page in the application. Our application now handles the following
    four pathnames:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/``demo`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/``login`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/``signup`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So far, all our route modules in the `routes` folder are document/UI routes
    that render React components as part of the route hierarchy to the page. In the
    following section, we will provide a short overview of available route module
    exports and discuss the differences between UI and resource routes.
  prefs: []
  type: TYPE_NORMAL
- en: Available route module exports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Remix, we distinguish between resource routes and UI routes. Each UI route
    must export a React component as the default export. Resource routes do not export
    a React component as the default export. Instead, resource routes must export
    an `action` and/or a `loader` function. Among other things, resource routes can
    expose API endpoints, handle Webhooks, or create assets on the fly. We will create
    our first resource route later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remix inspects the exported functions of a route module to determine whether
    it is a UI or a resource route. While resource routes only support exporting an
    `action` or a `loader` function, UI routes can export the following named exports:'
  prefs: []
  type: TYPE_NORMAL
- en: '`action`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ErrorBoundary`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handle`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`headers`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`links`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loader`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`meta`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shouldRevalidate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will learn more about the role of these exports in the following chapters.
    For now, let’s focus on how Remix uses the route module exports. Remix compiles
    the route hierarchy during build time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your file explorer, navigate to `public/build/` and open the `manifest-*.js`
    file. The manifest file is created after building the application (`npm run build`
    or `npm run dev`) and includes a routes section. The routes section contains an
    entry for every route module in the app. The entry for the `demo.tsx` route looks
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the code, Remix keeps track of the exported functions via Boolean
    flags. The Boolean flags are set to `false`, since our demo route does not export
    `action`, `loader`, or `ErrorBoundary`.
  prefs: []
  type: TYPE_NORMAL
- en: Remix’s route module exports are part of the file-based route convention. Remix
    compiles the content of the route folder and generates a manifest file. This is
    how Remix lets us avoid a route hierarchy configuration in code and instead promotes
    a convention-based route hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we created two new route modules and learned about the supported
    named exports of route modules in Remix. We also used the `remix routes` command
    to visualize our routes hierarchy. In the following section, we will dive into
    nested routing.
  prefs: []
  type: TYPE_NORMAL
- en: Composing pages from nested routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: BeeRich is a personal bookkeeping application. Users should be able to view
    their expenses and sources of income. In this section, we will create a hierarchy
    of nested routes to compose the dashboard pages of BeeRich.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have seen `Outlet` being used in the `root.tsx` file. The `Outlet`
    component declares the location of the child route inside the markup of the parent
    route. The `Outlet` component in `root.tsx` is rendered inside the HTML `body`.
    Hence, all child routes are wrapped inside the `body` element. This is the power
    of nested routing. With nested routing, you can compose pages out of several route
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use nested routing and the `Outlet` component to construct our dashboard.
    The two routes, `/dashboard/expenses` and `/dashboard/income`, will serve as our
    overview pages:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add two files inside the `routes` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`dashboard.expenses.tsx`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dashboard.income.tsx`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that we use dot delimiters (`.`) to separate path segments (`/`) in the
    URL.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add a simple route component to both files. Review `login.tsx` for reference.
    In both files, export the component as the default export.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, run the application (`npm run dev`), and review the changes in a browser
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The goal is to list all expenses and sources of income (invoices), respectively.
    For now, we will mock the data and focus on setting up the route hierarchy.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following code to the `dashboard.expenses.tsx` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The provided code renders a hardcoded list of expenses to the page.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can also find the final code for this chapter on GitHub: [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/04-routing-in-remix/bee-rich/solution](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/04-routing-in-remix/bee-rich/solution).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Similarly, we want to render a list of all sources of income on the `/dashboard/income`
    page. Copy the code from the `dashboard.expenses.tsx` file, and adapt it to render
    hardcoded invoices instead of expenses in `dashboard.income.tsx`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As shown in *Figure 4**.1*, both pages now render a list of items. In the future,
    users should also be able to edit an expense or invoice. For that, we will now
    create a nested details view.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.1 – A screenshot of the expenses overview page](img/Figure_4.01_B17399.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – A screenshot of the expenses overview page
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have navigated between pages by changing the URL in the address
    bar of the browser. Now, it’s time to add anchor tags. A user should be able to
    click on a list item in the expenses overview to view the details view of the
    expense. Let’s wrap the content of the hardcoded list items with anchor tags.
    The first list item might look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure to wrap each item with an anchor tag.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Each list item now links to a unique URL that includes the mock identifier of
    the expense. In the following section, we will learn more about dynamic routes
    with parameters. For now, let’s work with made-up mock identifiers to focus on
    the route structure.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In your browser window, click on one of the list items. A click on an item should
    navigate you to a **404 Not Found** page. That’s expected, considering we did
    not create the associated route module yet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s add a hardcoded details page for the expense with the identifier `1`.
    Create a `dashboard.expenses.1.tsx` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to `dashboard.expenses.1.tsx`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The newly created details route is dedicated to the expense with the identifier
    `1`. By clicking on a list item in the expenses overview, we should be redirected
    to the details view of the list item.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let’s test our implementation. Use the address bar to navigate back to the `/dashboard/expenses/`
    page. Then, click on the list item with the identifier `1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Snap! Something is wrong! We can see that the URL changes as expected. A click
    on the list item updates the pathname of the URL to `/dashboard/expenses/1`. However,
    the content of the page does not update. We still see the content of the expenses
    overview page. What’s wrong?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We created a nested `dashboard.expenses.1.tsx` file within the `/expenses` path.
    But why is the content of the file not appearing on the page? Remix only seems
    to render the `dashboard.expenses.tsx` file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The issue is that `dashboard.expenses.tsx` and `dashboard.expenses.1.tsx` both
    match the same path (`/dashboard/expenses/`). By doing so, we promoted the `dashboard.expenses.tsx`
    file to be a parent layout route module (such as `root.tsx`). If we want to display
    either the content of the `dashboard.expenses.tsx` file or the content of the
    `dashboard.expenses.1.tsx` file, then we need to make `dashboard.expenses.tsx`
    a sibling instead of a parent route.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You learned earlier that index routes are used as the default child routes of
    a URL path segment. Let’s try to fix the issue by adding an index route.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Rename the `dashboard.expenses.tsx` file to `dashboard.expenses._index.tsx`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By doing so, we declare the two route modules in the `expenses` path as siblings.
    Sibling route modules always match different pathnames.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In your browser window, navigate back to the `/dashboard/expenses/` page. Now,
    click on the list item to navigate to `/dashboard/expenses/1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The UI now updates as expected between the two pages. By declaring the two route
    modules as siblings, we either show the overview or the details page content.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Remix’s route hierarchy distinguishes parent and sibling routes of a specific
    URL path. `dashboard.expenses.tsx` is a `/``expenses` path.
  prefs: []
  type: TYPE_NORMAL
- en: A parent route utilizes the `Outlet` component to declare where its child components
    should be rendered alongside its own layout. `root.tsx` is the top-level parent
    route.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try it out:'
  prefs: []
  type: TYPE_NORMAL
- en: Undo your changes. Rename the `dashboard.expenses._index.tsx` file back to `dashboard.expenses.tsx`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, import the `Outlet` component from Remix, and add it below the **All**
    **expenses** section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Refresh your browser window. You should now see the expenses overview and the
    details view side by side when visiting `/dashboard/expenses/1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.2 – A screenshot of the expenses overview page with the nested details
    view](img/Figure_4.02_B17399.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – A screenshot of the expenses overview page with the nested details
    view
  prefs: []
  type: TYPE_NORMAL
- en: Awesome! We created our first layout route to compose a page from different
    route modules. By using nested routing, we map different segments of the URL to
    different route modules. This creates a hierarchically nested structure. Parent
    routes utilize the `Outlet` component to declare where the child route should
    be rendered on the page.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `/dashboard` path is not accompanied by a `dashboard.tsx` file.
    This should tell us that layout route modules are optional. We can use layout
    routes to share a common layout across all child routes or create complex pages
    that are made up of different route modules. However, if they're not needed, they
    can be omitted.
  prefs: []
  type: TYPE_NORMAL
- en: For BeeRich, we want to use a parent layout route instead of an index route
    to render the overview page. With this page architecture, a user can see all expense-related
    information on one page.
  prefs: []
  type: TYPE_NORMAL
- en: To practice working with parent layout routes, make sure to update the income
    pages and add the `Outlet` component to the `dashboard.income.tsx` file.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how you can compose a page out of different route
    modules. Remix maps segments of the URL to different route modules in the routes
    hierarchy. With parent layout routes, we can nest and render child routes inside
    parent routes. Each page is then made up of code from different nested route modules.
    Next, we will refactor the hardcoded parameter routes and utilize parameterized
    path segments to create dynamic expense details pages.
  prefs: []
  type: TYPE_NORMAL
- en: Using route parameters for dynamic routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: URLs often include parameters such as identifiers to specify associated resources.
    This allows the application to retrieve the right data for the request. In this
    section, you will learn how to work with URL parameters in Remix.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have created a route module for a hardcoded expenses details page
    (`/dashboard.expenses.1.tsx`). The number `1` in the URL refers to the expense
    with the expense identifier `1`. However, the goal is to create a dynamic route
    module capable of handling variable identifiers. Luckily, Remix provides a convention
    for how to define a parameterized route segment.
  prefs: []
  type: TYPE_NORMAL
- en: Parameterized route segments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Remix, dynamic segments of the URL are referred to as parameterized segments.
    We use the `$` symbol to declare a route parameter. This turns the URL segment
    into a parameter that we can access and use to fetch data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how we can use a parameterized segment in BeeRich for the expenses
    details route:'
  prefs: []
  type: TYPE_NORMAL
- en: Rename `dashboard.expenses.1.tsx` to `dashboard.expenses.$id.tsx`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `$` symbol is part of Remix’s routing convention and declares a parameter
    for a dynamic route segment.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, update the code inside the file and add the following mock data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The mock data acts as our data source for now. We will add a real database in
    [*Chapter 5*](B17399_05.xhtml#_idTextAnchor078), *Fetching and* *Mutating Data*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After that, add a `loader` function with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the file’s route component, we can access the loader response data with
    the `useLoaderData` hook. Update the existing component code as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure to test the implementation. Use the anchor tags of the expenses list
    to navigate between the different expenses details routes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As visible in the code, the `loader` function throws a `Response` if no expense
    identifier matches the route parameter. If you see an error, double-check that
    the identifier exists in the mock expenses array. And yes, you can throw `Response`
    objects with Remix – something we will explore in the next section.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once you have tested your implementation, create a similar experience for the
    income page. This will help you practice what you have learned so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you haven’t already, wrap each list element in the `dashboard.income.tsx`
    file with an anchor element. Then, create the `dashboard.income.$id.tsx` file
    and implement the `loader` function. In case you get stuck, review the implementation
    of the expenses details route and apply it to `dashboard.income.$id.tsx`. You
    can also refer to the troubleshooting process from [*Chapter 2*](B17399_02.xhtml#_idTextAnchor030),
    *Creating a New Remix App*. Finally, you can find the final solution for this
    chapter here: [https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/04-routing-in-remix/bee-rich](https://github.com/PacktPublishing/Full-Stack-Web-Development-with-Remix/tree/main/04-routing-in-remix/bee-rich).'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to work with dynamic route segments and how
    to declare route parameters. You also got a short introduction to Remix’s `loader`
    function and the `useLoaderData` hook. In the following section, we will utilize
    shared layouts to improve our application’s look and feel.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nested routing enables us to compose a page from a nested route hierarchy. In
    this section, we will utilize parent routes to reuse layouts between nested child
    routes. We will also learn how to share code between routes without creating new
    segments in the URL, with pathless layout routes.
  prefs: []
  type: TYPE_NORMAL
- en: Using parent layout routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s improve the look and feel of the BeeRich dashboard. Ideally, a user should
    be able to quickly switch between the income and expenses overview pages. It’s
    time to add a navigation bar.
  prefs: []
  type: TYPE_NORMAL
- en: We already utilized parent layout routes for the `dashboard/expenses` and `dashboard/income`
    pages. By rendering the list of expenses and income in a parent route (`dashboard.expenses.tsx`
    and `dashboard.income.tsx`, respectively), we nested the content of the child
    routes on the same page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will take advantage of nested routing again to add a shared navigation
    bar to all dashboard pages. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `dashboard.tsx` file inside the `routes` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since the `dashboard.tsx` route module matches the `dashboard` path segment,
    it acts as the parent route for the segment’s nested route modules.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following code to `dashboard.tsx`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The code adds a navigation bar inside an HTML `header` element and renders Remix’s
    `Outlet` component inside a `main` element.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run the app (`npm run dev`), and visit `/dashboard/expenses` in your browser
    window to review the changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As visible in *Figure 4**.3*, by adding a parent route module, we wrap every
    child route of `dashboard` with the markup rendered inside `dashboard.tsx`. Layout
    routes provide a great way to wrap all child routes in a common layout.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.3 – A screenshot of the expenses page with a shared dashboard layout](img/Figure_4.03_B17399.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – A screenshot of the expenses page with a shared dashboard layout
  prefs: []
  type: TYPE_NORMAL
- en: Let’s also add a navigation bar to our login, signup, and home (`_index.tsx`)
    pages. We could again use a parent layout route to share a common layout. However,
    this would add a new route segment to the path. It turns out that adding a parent
    route is not what we want. A parent route would alter the URL, but the home page
    should be located at the `/`path. Likewise, we want the login page to be located
    at `/login` and signup at `/signup`. Instead, let’s see how we can make a layout
    route pathless.
  prefs: []
  type: TYPE_NORMAL
- en: Using pathless layout routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Luckily, Remix has a way of declaring `$` symbol declares a parameterized route
    module, using an underscore prefix (`_`) declares a pathless layout route. Pathless
    routes behave just like parent layout routes but do not add segments to the URL
    path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a pathless layout route to share a layout between the login, signup,
    and home pages:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `_layout.tsx` file in the `routes` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The underscore tells Remix to treat the route module as pathless. The route
    module’s name will not be added to the URL. You already know the underscore prefix
    from index routes, which serves a similar purpose.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that the chosen name, `layout`, is not part of the convention – you can
    name the route module as you like.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, add the following code to the `routes/_layout.tsx` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The code adds a navigation bar and renders `Outlet` in a styled `main` element.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Rename the `_index.tsx`, `login.tsx`, and `signup.tsx` route modules `_layout._index.tsx`,
    `_layout.login.tsx`, and `_layout.signup.tsx`, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the `main` HTML tag from the `_index.tsx` JSX code, as it is now already
    rendered by the `__layout.tsx` module. That is the power of composition and nested
    routing. We can reduce code duplication and reuse layouts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As always, make sure to test your changes before moving on. Run the application,
    and visit the `/`, `/login`, and `/signup` pages by trying out the new navigation
    bar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this section, you learned how to utilize layout routes to add common structure
    and styling to nested child routes. You were also introduced to pathless layout
    routes to share a layout without adding route segments to the URL path. In the
    following section, we will learn more about page navigations in Remix.
  prefs: []
  type: TYPE_NORMAL
- en: Handling navigations in Remix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have used anchor tags to navigate between pages. You might have noticed
    that every navigation – using an anchor tag – triggers a full-page reload. This
    is the browser’s default behavior when navigating between pages. However, Remix
    also offers primitives for client-side navigations.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will introduce you to Remix’s link components and Remix’s
    global navigation object. We will practice utilizing the navigation object to
    indicate page loads and learn more about server-side redirects with Remix.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating with Remix’s link components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, a page navigation triggers a document request to the web server
    of the resource. The web server forwards the request to Remix (our HTTP request
    handler). Remix then renders a new document on the server to fulfill the request
    and responds with the rendered HTML document (or any other HTTP response).
  prefs: []
  type: TYPE_NORMAL
- en: 'When utilizing Remix’s link components, Remix prevents the browser’s default
    behavior from making full-page requests. Instead, Remix executes fetch requests
    using the web''s Fetch API to fetch the required data for the requested URL. We
    avoid a full-page reload and instead execute a client-side navigation. Let''s
    replace the anchor tags in BeeRich with Remix’s links components – `Link` and
    `NavLink`. You can find styled example implementations for both link components
    in `/app/components/links.tsx`. For more information about the two components,
    visit the React Router documentation: [https://reactrouter.com/en/6.15.0/components/nav-link](https://reactrouter.com/en/6.15.0/components/nav-link):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fiirst, replace the anchor tags in `routes/_layout.tsx` with. Update the code
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Instead of using Remix's NavLink component directly, we use a styled wrapper
    component.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, run the application (`npm run dev`) and open it in a browser window. Navigate
    to the home page of the app. The navigation bar should now show three decently
    styled links.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the home page, click on either the **Log in** or **Sign up** link. You should
    see that the favicon in the tab of the browser window no longer indicates a full-page
    reload. Instead, Remix now fetches the required data and assets using JavaScript’s
    Fetch API, performing a client-side navigation. With these changes, our Remix
    app feels much more like an SPA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let’s refactor the code of the `dashboard.tsx` parent route. Import the
    `Container` and `NavLink` components from the `components` folder, import `Link`
    from Remix, and apply the following changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, refactor the `dashboard.expenses.tsx` route module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Also, replace the anchor tags in `dashboard.income.tsx` with the `ListLinkItem`
    component. Use the `dashboard.expenses.tsx` file for reference.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the application locally, and visit a browser window. Test the links on the
    expenses and income overview pages. Note how Remix no longer executes full-page
    reloads to navigate between the pages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Opting for Remix’s link components avoids page reloads. With full-page reloads,
    we must re-fetch all data on every navigation. When using Remix’s link components,
    Remix only fetches the data required for newly added route modules. However, we
    can also see that Remix works just fine when using anchor tags. Remix enhances
    the experience with JavaScript where possible but can fall back to a browser’s
    default behavior if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, when we attempt to enhance the experience with JavaScript, we might
    accidentally degrade the experience instead. By default, a browser replaces the
    tab's favicon with a loading indicator during page load. Without a full-page reload,
    we lose any indication that a page transition is happening. This is especially
    frustrating for users with slower internet connections. In the following section,
    we will utilize Remix’s global transition object to re-add page loading indicators.
  prefs: []
  type: TYPE_NORMAL
- en: Indicating page transitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You might ask yourself why we would need page load indicators. Navigations
    are so fast on `localhost` that you barely notice them. However, they can feel
    brutally long on **slow 3G** connections. Let’s prove that page transitions are
    necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: Run BeeRich by executing `npm run dev` in the project’s `root` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the application in your browser by visiting [http://localhost:3000](http://localhost:3000).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the developer tools of your browser, and navigate to the **Network** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for the throttling functionality, and select **Slow 3G** from the provided
    dropdown.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, check the **Disable cache** checkbox to simulate a user’s first visit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All popular browsers offer similar settings. Search on Google if you can’t find
    the described throttle and cache functionalities.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Make sure to reload the browser window to reset the browser cache.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, navigate between the different pages of your app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.4 – A screenshot of the Network tab of the Chrome DevTools](img/Figure_4.04_B17399.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – A screenshot of the Network tab of the Chrome DevTools
  prefs: []
  type: TYPE_NORMAL
- en: How is the experience? Using a slow internet connection shows how important
    loading indicators are. By removing the browser’s default behavior (the loading
    spinner on the browser window tab), we robbed the user of a clear loading indication.
    We degraded the user experience. Luckily, Remix provides a global navigation object,
    which we can use to re-add loading indicators with JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s add a loading indicator to the expense and income detail views:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `/routes/dashboard.expenses.tsx` file, and import the `useNavigation`
    hook from Remix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call the hook inside the route component to access the global navigation object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let’s see for ourselves! Open a browser window, and navigate to the `expenses`
    page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **Console** tab in the browser’s developer tools.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the different expenses in the expenses list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`navigation.state` is set to `idle` if there is no page navigation. On `GET`
    requests, `navigation.state` is set to `loading`. On form submissions, the state
    is set to `submitting` and then `loading` (as every submission also involves a
    page navigation).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With Remix, we can easily display pending UIs by checking the `navigation.state`
    value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s add a simple CSS animation to `dashboard.expenses.tsx`. First, import
    `clsx` to manage the Tailwind CSS classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, wrap the existing `Outlet` component by a styled section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Ensure that your browser window is still throttling the network bandwidth. Click
    on the expense items in the expenses overview list, and note that the details
    view pulses when page navigations are in progress.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the same animation to`dashboard.income.tsx` to practice working with Remix's
    navigation object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s also add a global progress bar to the application:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `root.tsx` file in your editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import `PageTransitionProgressBar` from the `components` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, render the `PageTransitionProgressBar` component inside the root component.
    This ensures that the component is rendered across all routes and pages of our
    application. We place the component inside the body above the `Outlet` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the `components/progress` file in your editor, and review the implementation
    of the `PageTransitionProgressBar` component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this section, you learned how to utilize the navigation object and the `useNavigation`
    hook to indicate loading states to a user. Now, we will wrap up the chapter by
    introducing server-side redirects.
  prefs: []
  type: TYPE_NORMAL
- en: Redirecting a user from the server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, the right place to trigger a navigation is on the server. In Remix,
    `loader` functions are a great place to check whether the requested resources
    exist and whether the user can access it. In this section, you will learn more
    about server-side redirects in Remix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Review the `dashboard.expenses.$id.tsx` route file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the `loader` function, we access the route parameter to find the matching
    expense in the mock data. If we cannot find an expense that matches the `id` parameter,
    we throw a `Response`. Throwing responses is a great way to stop the execution
    early and return an error response. We will learn more about how to handle thrown
    `Response` objects in [*Chapter 7*](B17399_07.xhtml#_idTextAnchor105), *Error
    Handling* *in Remix*.
  prefs: []
  type: TYPE_NORMAL
- en: For now, let's focus on Remix's `request/response` flow. It's important to understand
    that Remix operates both a frontend and a backend, following the client/server
    model of the web. Our frontend app runs in the browser and makes requests to the
    web server (backend). The backend application handles incoming HTTP requests and
    answers with HTTP responses.
  prefs: []
  type: TYPE_NORMAL
- en: 'The great thing about Remix''s request/response model is that instead of being
    custom, it follows the web''s Fetch API standard. In `loader` functions, we return
    `Response` objects, following the Fetch API''s `Response` specification: [https://developer.mozilla.org/en-US/docs/Web/API/Response](https://developer.mozilla.org/en-US/docs/Web/API/Response).'
  prefs: []
  type: TYPE_NORMAL
- en: 'On top of that, Remix provides primitives to create `Response` objects. Instead
    of creating `Response` objects ourselves, we can also use the following three
    helper functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`defer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`json`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`redirect`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have already used the `json` helper in our `loader` function. The helper
    returns a `Response` object, with the `Content-Type` HTTP header to `application/json`.
    The `redirect` helper creates `Response` with a `302` status code. `defer` is
    an advanced helper for streaming responses. We will practice working with defer
    in [*Chapter 13*](B17399_13.xhtml#_idTextAnchor194)*, Deferring* *Loader Data*.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use `redirect` to fix a bug in our app. Have you noticed what happens
    if you directly navigate to [http://localhost:300/dashboard](http://localhost:300/dashboard)?
    We render an empty dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: Can you think of a reason for that behavior? The `/dashboard` path segment currently
    has no default child (a nested index route module). Conclusively, the `/dashboard`
    path matches with neither of the child routes when visiting the `/dashboard` path.
    When visiting [http://localhost:300/dashboard](http://localhost:300/dashboard),
    `Outlet` in `dashboard.tsx` returns `null`, and our dashboard remains empty.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, not having a default child route is not an issue. On the `/dashboard/expenses`
    and `/dashboard/income` overview pages, the `Outlet` also returns `null` when
    no identifier is added to the URL. Displaying an overview list without rendering
    a details view seems fine.
  prefs: []
  type: TYPE_NORMAL
- en: For `/dashboard`, we should think of a better solution than rendering an empty
    dashboard. For instance, we could create a `dashboard._index.tsx` file and export
    a route component that renders a simple welcome message. Or we redirect the user
    to another page!
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `dashboard._index.tsx` file in the `routes` folder, and add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: With these simple four lines of code, we create our first resource route. A
    resource route does not export a route component (otherwise, it would be a UI
    route). Instead, a resource route exports a `loader` function and/or `action`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we use a `loader` function to immediately redirect the user to the expenses
    overview page. If a user enters [http://localhost:3000/dashboard](http://localhost:3000/dashboard)
    into the address bar, then the `loader` function returns a `Response` with the
    `30x` status code – a redirect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try it out by navigating to [http://localhost:3000/dashboard](http://localhost:3000/dashboard).
    In your terminal, the server logs should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: On navigation to `/dashboard`, we redirect (the `302` status code) to the `/dashboard/expenses`
    route, which is then served (the `200` status code).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that `redirect` is just a helper function to create a redirect `Response`
    object. It is nothing more than a simple wrapper for convenience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Remix provides full access to the web platform. You can create and return `Response`
    objects with varying status codes, instance properties, caching headers, and much
    more. All you need to do is follow the MDN Web Docs ([https://developer.mozilla.org/en-US/docs/Web/API/Response](https://developer.mozilla.org/en-US/docs/Web/API/Response)).
    Later in this book, we will implement real-time functionality, add caching headers,
    and elegantly handle authentication errors, all by using the web platform’s `Response`
    API.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned about server-side redirects. You now understand
    that Remix executes `loader` functions on the server and that `loader` functions
    must return a `Response` object (or something that Remix can parse into a `Response`
    object). You also practiced redirecting a user from a resource route to a UI route.
    Now, let’s reflect on what you learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remix provides a convention-based file-based router. Arguably the most powerful
    feature of Remix’s router is nested routing. In Remix, you create routes (route
    modules) as part of a hierarchy. Remix’s router maps the pathname of the URL to
    a set of matching route modules. Route modules make up the pages of your Remix
    application.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you created your first routes in Remix. We started off by creating
    two standalone pages. You learned about the special role of index routes as the
    default children of their parent routes. You were also introduced to the exports
    available in Remix’s route modules.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we created a nested route hierarchy for our dashboard. We used parent
    layout routes and the `Outlet` component to reuse styling and content across different
    child routes.
  prefs: []
  type: TYPE_NORMAL
- en: We also used a `loader` function and a route parameter to create routes for
    our income and expenses details views. You learned how to declare parameterized
    route modules using the `$` syntax. You also used Remix’s `userLoaderData` hook
    to access JSON data returned from a `loader` function.
  prefs: []
  type: TYPE_NORMAL
- en: Thereafter, we used pathless layout routes to share layouts across different
    child routes without adding a path segment to a URL. You created a pathless route
    that wraps the login, signup, and home pages of BeeRich.
  prefs: []
  type: TYPE_NORMAL
- en: You also learned about navigations and transitions in Remix. We replaced the
    HTML anchor tags with Remix’s `Link` and `NavLink` components. Now, you understand
    the benefits of avoiding full-page reloads and know that Remix fetches required
    scripts and data on each page request.
  prefs: []
  type: TYPE_NORMAL
- en: You further learned about the `useNavigation` hook and Remix’s navigation object.
    You practiced adding loading indicators to a page by using the state property
    of the navigation object. Finally, you learned more about the `Request`/`Response`
    model in Remix and how to redirect a user from the server.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, you will learn about data loading and mutations in
    Remix. We will use Remix’s `action` and `loader` functions to implement the UI
    necessary to manage our expenses and income data in BeeRich.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned about the key concepts of Remix’s routing solution.
    You can find more concepts, such as optional route modules, in Remix’s route documentation:
    [https://remix.run/docs/en/2/file-conventions/routes](https://remix.run/docs/en/2/file-conventions/routes).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Read about Remix’s `Link` and `NavLink` components in the Remix documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://remix.run/docs/en/2/components/link](https://remix.run/docs/en/2/components/link)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://remix.run/docs/en/2/components/nav-link](https://remix.run/docs/en/2/components/nav-link)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can read more about the `Request`/`Response` model of the Fetch API here:
    [https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).'
  prefs: []
  type: TYPE_NORMAL
- en: Part 2 – Working with Remix and the Web Platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, you will gain hands-on experience with Remix’s primitives, conventions,
    and levers and build a full stack web application from start to finish. You will
    gain a deep understanding of Remix’s request-response flow, progressive enhancement,
    and how to build robust user experiences with error and session management in
    mind. Finally, you will practice working with web assets and file uploads in Remix.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B17399_05.xhtml#_idTextAnchor078), *Fetching and Mutating Data*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B17399_06.xhtml#_idTextAnchor090), *Enhancing the User Experience*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B17399_07.xhtml#_idTextAnchor105), *Error Handling in Remix*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B17399_08.xhtml#_idTextAnchor119), *Session Management*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B17399_09.xhtml#_idTextAnchor137), *Assets and Metadata Handling*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B17399_10.xhtml#_idTextAnchor154), *Working with File Uploads*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
