- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: What are React and React Native?
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是React和React Native？
- en: Welcome to the magical world of **React** and **React Native**. I hope to make
    you feel at home here. It’s okay if this is your very first contact with these
    frameworks, or you may have played around with them a little bit already. This
    book will focus on **managing state** in **React Native apps**, but we will start
    by going over the basics.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到**React**和**React Native**的神奇世界。希望您在这里能感到宾至如归。如果您是第一次接触这些框架，或者您已经稍微尝试过它们，那都没关系。本书将专注于**管理React
    Native应用的状态**，但我们将从基础知识开始讲起。
- en: If React and React Native were people, the first one would be the parent of
    the second one. You can focus on the child framework, but you will find great
    benefits in getting to know the “parent” of React Native – **ReactJS**.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果React和React Native是人的话，第一个将是第二个的父亲。您可以专注于子框架，但您会发现了解React Native的“父亲”——**ReactJS**有很大的好处。
- en: We will start this journey by going over the history of ReactJS and specifically,
    why it was created. We will then continue our study of ReactJS by looking into
    what it means to *think in React* or to have the *React mindset*. Once we’re familiar
    with ReactJS, we will try to understand what **cross-platform software development**
    means and what place React Native holds in the cross-platform development ecosystem.
    For understanding the ecosystem, we will concentrate on React Native itself, its
    brief history, and its current state. We will finish our tour with a handful of
    examples of native apps written in React Native.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始这段旅程，先回顾ReactJS的历史，特别是它为什么被创造出来。然后，我们将继续研究ReactJS，探讨*React思维模式*或拥有*React心态*的含义。熟悉ReactJS后，我们将尝试理解**跨平台软件开发**的含义以及React
    Native在跨平台开发生态系统中的位置。为了理解这个生态系统，我们将专注于React Native本身，它的简要历史和当前状态。我们将通过一些用React
    Native编写的原生应用示例结束我们的旅程。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding the history of ReactJS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解ReactJS的历史
- en: Thinking in React (the React mindset)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React思维模式（React心态）
- en: Understanding cross-platform software development
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解跨平台软件开发
- en: Going over the history of React Native
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解React Native的历史
- en: Reviewing examples of popular apps using React Native
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看使用React Native的流行应用的示例
- en: By the end of this chapter, you will have high-level knowledge of React and
    React Native. You will also understand their place in the software development
    ecosystem.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将具备React和React Native的高级知识。您还将了解它们在软件开发生态系统中的位置。
- en: Understanding the history of ReactJS
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解ReactJS的历史
- en: In this section, we will briefly look into the history of ReactJS. If you’re
    not interested in this particular topic, feel free to skip this section and go
    straight to *Thinking in React*. Knowing the history of a framework is not compulsory
    for using it. If you prefer condensed knowledge served in a YouTube pill, I highly
    recommend watching a 10-minute video called *The Story of React*, published on
    YouTube by *uidotdev*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简要回顾ReactJS的历史。如果您对这个特定主题不感兴趣，请随意跳过本节，直接进入*React思维模式*。了解一个框架的历史对于使用它并不是强制性的。如果您更喜欢YouTube上的浓缩知识，我强烈推荐观看由*uidotdev*发布的10分钟视频，名为*React的故事*。
- en: The predecessors
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前驱者
- en: 'Did you know that the first website ever created is still live? You can find
    it here: [http://info.cern.ch/hypertext/WWW/TheProject.html](http://info.cern.ch/hypertext/WWW/TheProject.html).
    It was created in 1991! A lot has changed since then. For starters, web developers
    wanted to change their websites’ appearance, hence CSS was created. A few years
    later those same web developers wanted to see more interactivity on their now
    beautiful websites. This is when **JavaScript** found its place on the internet.
    But as we know, the web never stops evolving. Heavy usage of JavaScript led to
    the creation of libraries such as jQuery, BackboneJS, and Ember. Each library’s
    creators learned lessons from their competitors. They made decisions that led
    to creating very different developer experiences. The developers had their preferences
    and little wars over which library is better.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道吗，第一个创建的网站至今仍然存在？你可以在这里找到它：[http://info.cern.ch/hypertext/WWW/TheProject.html](http://info.cern.ch/hypertext/WWW/TheProject.html)。它是在1991年创建的！从那时起，发生了许多变化。首先，网页开发者们想要改变他们网站的样式，因此CSS被创造出来。几年后，同样的开发者们希望在他们的美丽网站上看到更多的互动性。这就是**JavaScript**在互联网上找到其位置的时候。但正如我们所知，网络永远不会停止发展。JavaScript的过度使用导致了像jQuery、BackboneJS和Ember这样的库的创建。每个库的创造者都从他们的竞争对手那里吸取了教训。他们做出了导致创建非常不同的开发者体验的决定。开发者们有自己的偏好，并且就哪个库更好展开了小规模的战争。
- en: There is no right answer to this question. What is certain, however, is that
    user experience on websites evolved, no matter which library was used behind the
    scenes. Websites became much more interactive and adaptable to the user’s screen
    size. For example, it is common practice today to create separate menus for mobile
    views and desktop views. This can be achieved with JavaScript, or CSS alone. This
    user experience shift could not take place without the evolution of JavaScript
    **open** **source** libraries.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问题没有正确答案。然而，可以肯定的是，无论幕后使用的是哪个库，网站的用户体验都发生了演变。网站变得更加互动，能够适应用户的屏幕大小。例如，今天为移动视图和桌面视图创建单独菜单是一种常见的做法。这可以通过JavaScript或CSS单独实现。这种用户体验的转变没有JavaScript**开源**库的演变是不可能发生的。
- en: After a few years of adding more and more separate bits of JavaScript to websites,
    it was time for a more holistic solution. The first breakthrough came from Google,
    with **AngularJS**. AngularJS, officially released in 2010, was different from
    other solutions on the market at that time. This was not just another library;
    this was a framework. Developers were able to create complex interactions quickly,
    and they were no longer afraid that any change to their JavaScript files could
    break the entire page. I don’t want to go into the implementational details of
    AngularJS. After all, that is not the focus of this book. In broad strokes, AngularJS
    introduced special HTML attributes that were observed by the framework running
    in the background. As you may imagine, when JavaScript is observing dozens or
    even hundreds of elements and events, it will slow down. So, the user experience
    is suffering, and the world is ready for another JavaScript revolution. Google
    thought they would remain king of the hill with their Angular version 2, but in
    2013, Facebook developers announced the release of ReactJS.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 几年后，随着越来越多的JavaScript代码片段被添加到网站上，是时候需要一个更全面的解决方案了。第一个突破来自谷歌，推出了**AngularJS**。AngularJS于2010年正式发布，与当时市场上的其他解决方案不同。这不仅仅是一个库；这是一个框架。开发者们能够快速创建复杂的交互，他们不再害怕对JavaScript文件的任何更改都会破坏整个页面。我不想深入探讨AngularJS的实现细节。毕竟，这不是本书的重点。总的来说，AngularJS引入了后台运行的框架观察到的特殊HTML属性。正如你可能想象的那样，当JavaScript观察数十个甚至数百个元素和事件时，它会减慢速度。因此，用户体验正在受到影响，世界正准备迎接另一场JavaScript革命。谷歌认为他们的Angular版本2将保持领先地位，但到了2013年，Facebook的开发者宣布了ReactJS的发布。
- en: And then there was React
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 然后出现了React
- en: ReactJS was presented specifically as a **user interface** (**UI**) library.
    It was conceived to be used for end user interactions on websites. It also used
    **JSX** – an extension to JavaScript created for React. Many developers reacted,
    pun intended, angrily to this new syntax. I would say though, that angry reactions
    are not unexpected in the world of tech. Any new technological solution has to
    weather the storm of angry Reddit posts saying that it’s ugly, useless, or simply
    terrible. Luckily for us, ReactJS developers did not stop working on their open
    source framework because of this initial negative reaction. Furthermore, developers
    who got to know ReactJS became its advocates. Why, you may ask, did ReactJS stand
    the test of time, while Angular hasn’t? I believe it has to do with the high-level
    mindset of the framework. ReactJS proposes elegant, simple solutions while staying
    completely configurable to any needs. I will go further into this mindset idea
    in the next section.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ReactJS被特别定位为一个**用户界面**（**UI**）库。它被构思用于网站上的最终用户交互。它还使用了**JSX**——为React创建的JavaScript扩展。许多开发者对这个新语法表示愤怒，这并不令人意外。不过，我要说的是，在科技界，愤怒的反应并不意外。任何新的技术解决方案都必须经受住愤怒的Reddit帖子，这些帖子说它丑陋、无用，或者简单地说，很糟糕。幸运的是，ReactJS的开发者并没有因为这种最初的负面反应而停止工作。此外，了解ReactJS的开发者成为了它的倡导者。你可能会问，为什么ReactJS能够经受住时间的考验，而Angular却没有？我认为这与框架的高级思维模式有关。ReactJS提出了优雅、简单的解决方案，同时完全可配置以满足任何需求。我将在下一节进一步探讨这种思维模式。
- en: Going back to our history lesson! We’re in 2013, and ReactJS has entered the
    scene with a bang. Many people hate it, but others use it for more and more complex
    websites. And it turns out, unfortunately, that ReactJS does not scale well. Your
    React components use state and props. If the parent creates a state, which needs
    to be read four to five components lower in the hierarchy, you encounter something
    that is dubbed **prop drilling**. Prop drilling means that the developer has to
    pass the necessary prop through many parent components in order to get to the
    final child that needs to read it. This process is irritating and boring, at the
    same time! This is when the first state management library was created – **Redux**.
    We will talk in detail about Redux and other state management libraries in the
    next chapters.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的历史课程！我们回到了2013年，ReactJS以一种震撼的方式进入舞台。许多人讨厌它，但其他人用它来构建越来越复杂的网站。不幸的是，ReactJS的扩展性并不好。你的React组件使用状态和属性。如果父组件创建了一个状态，这个状态需要被层级较低的四个或五个组件读取，你将遇到被称作**属性钻取**的问题。属性钻取意味着开发者必须通过许多父组件传递必要的属性，以便到达最终需要读取它的子组件。这个过程既令人烦恼又无聊！这就是第一个状态管理库——**Redux**诞生的时刻。我们将在下一章详细讨论Redux和其他状态管理库。
- en: As of writing this book, ReactJS is one of the most popular JavaScript libraries.
    It evolves constantly, and its maintainers are open to public discussions and
    suggestions. In 2019, they introduced hooks and context. These two React utilities
    can cover a lot of your state management needs. They were created because the
    React team realized that developers using React needed an improvement in the state
    management area.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写这本书的时候，ReactJS是最受欢迎的JavaScript库之一。它不断进化，其维护者对公众讨论和建议持开放态度。2019年，他们引入了hooks和context。这两个React实用工具可以满足你大部分的状态管理需求。它们之所以被创建，是因为React团队意识到使用React的开发者需要在状态管理方面得到改进。
- en: A few years before the introduction of hooks and context, specifically in 2015,
    Facebook developers released React Native. The true hero of this book! But let’s
    not get ahead of ourselves. At this moment, it is important that you understand
    the basic concepts of React. Let’s move on to the React mindset.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在hooks和context引入之前几年，具体是在2015年，Facebook开发者发布了React Native。这本书的真正英雄！但让我们不要走得太远。在这个时候，了解React的基本概念非常重要。让我们继续探讨React思维模式。
- en: Thinking in React (the React mindset)
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React思维（React思维模式）
- en: 'The official ReactJS docs include a chapter called *Thinking in* *React*: https://reactjs.org/docs/getting-started.html#thinking-in-react.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 官方ReactJS文档中包含一个名为 *React思维* 的章节：https://reactjs.org/docs/getting-started.html#thinking-in-react.
- en: Important note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Many React users credit reading *Thinking in React* ([https://reactjs.org/docs/thinking-in-react.html](https://reactjs.org/docs/thinking-in-react.html))
    as the moment React finally clicked for them. It’s probably the oldest React walk-through
    but it’s still just as relevant.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 许多React用户认为阅读*React思维*([https://reactjs.org/docs/thinking-in-react.html](https://reactjs.org/docs/thinking-in-react.html))是他们理解React的关键时刻。这可能是最古老的React教程，但它仍然同样相关。
- en: Let’s try and capture the most important, and still relevant, parts of that
    article.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试捕捉那篇文章中最重要且仍然相关的部分。
- en: First of all, when we create a website with ReactJS, we need to think about
    how we will construct our components. Not HTML blocks, not DOM elements, but components.
    Ideally, each component will be a separate entity, which either creates a state
    or consumes props, or sometimes both. The component is the smallest part of our
    app, just like atoms are the smallest parts of our world.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，当我们用ReactJS创建一个网站时，我们需要考虑我们将如何构建我们的组件。不是HTML块，不是DOM元素，而是组件。理想情况下，每个组件都将是一个独立的实体，它要么创建状态，要么消费属性，有时两者都有。组件是我们应用程序的最小部分，就像原子是我们世界的最小部分一样。
- en: Okay, I realize atoms can be further divided into neutrons, protons, and electrons.
    And **ReactJS components** can be divided into parts that handle the logic and
    the actual rendering. However, both atoms and ReactJS components are the basic
    building blocks in their respective realms.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我意识到原子可以进一步分为中子、质子和电子。**ReactJS组件**也可以分为处理逻辑和实际渲染的部分。然而，原子和ReactJS组件都是它们各自领域的基本构建块。
- en: 'Now that we have our components imagined, we need to know how they should interact
    with each other. Let’s go back to the ReactJS docs, where we will find a great
    chapter, *Composition vs.* *Inheritance*: [https://reactjs.org/docs/composition-vs-inheritance.html](https://reactjs.org/docs/composition-vs-inheritance.html).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经想象出了我们的组件，我们需要知道它们应该如何相互交互。让我们回到ReactJS文档，在那里我们将找到一个很好的章节，*组合与继承*：[https://reactjs.org/docs/composition-vs-inheritance.html](https://reactjs.org/docs/composition-vs-inheritance.html)。
- en: This article is very clear in stating that ReactJS components should be composed,
    and not stacked in a strict hierarchy. This basically means that any child component
    should be created in a way that it could be reused by other parent components
    throughout the app. This promotes the high reusability of atomic components, and
    at the same time, reduces the amount of code needed to create an application.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这篇文章非常明确地指出，ReactJS组件应该是组合的，而不是严格分层堆叠的。这基本上意味着任何子组件都应该以可以被应用程序中的其他父组件重用的方式创建。这促进了原子组件的高可重用性，同时，减少了创建应用程序所需的代码量。
- en: Now that we have the theory down, let’s move on to specifics. How do we compose
    ReactJS components in practice? By using state and props. What are those, you
    may ask? Well, I’ll be glad to explain!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了理论，让我们继续探讨具体实践。我们如何在实践中组合ReactJS组件？通过使用状态和属性。你可能想知道那些是什么？好吧，我很乐意解释！
- en: 'Both **state** and **props** (short for properties) are plain JavaScript objects.
    The big difference between them is that props are read-only, while state can be
    changed within the component that manages it. State is the source of truth, while
    props are the representations of the current state of the application. Let’s take
    a look at a minimal code example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**状态**和**属性**（简称属性）都是普通的JavaScript对象。它们之间最大的区别在于属性是只读的，而状态可以在管理它的组件内部进行更改。状态是真相的来源，而属性是应用程序当前状态的表示。让我们看看一个最小化的代码示例：'
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can play with this sample code online thanks to this CodeSandbox: [https://codesandbox.io/s/admiring-fire-68k94x?file=/src/App.js](https://codesandbox.io/s/admiring-fire-68k94x?file=/src/App.js).'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过这个CodeSandbox在线尝试这段示例代码：[https://codesandbox.io/s/admiring-fire-68k94x?file=/src/App.js](https://codesandbox.io/s/admiring-fire-68k94x?file=/src/App.js)。
- en: From the preceding code example, you can see that the `App` component creates
    the counter state, and the function responsible for updating it. `PrettyButton`
    consumes this state in the form of props. `PrettyButton` cannot change the value
    of `counter` or `updateCounter` directly.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码示例中，你可以看到`App`组件创建了计数器状态，以及负责更新它的函数。`PrettyButton`以属性的形式消费这个状态。`PrettyButton`不能直接更改`counter`或`updateCounter`的值。
- en: If we were to write another parent component that needed to use `PrettyButton`,
    it would need to create its own `counter` and `updateCounter` states. And thanks
    to that, every instance of `PrettyButton` we may want to use in our web app will
    be independent of the others.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要编写另一个需要使用`PrettyButton`的父组件，它将需要创建自己的`counter`和`updateCounter`状态。正因为如此，我们可能想要在我们的web应用中使用`PrettyButton`的每一个实例都将独立于其他实例。
- en: We may also find ourselves importing multiple child components in the main `App`
    component. This is totally natural. We may have an app with a button, a text,
    and a modal, all of which need to display the number of times the button was clicked.
    All we need to do is add the necessary components to the parent and pass the `counter`
    prop. The state is mutated *only* in the parent and then fed to the children.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可能在主`App`组件中导入多个子组件。这是完全自然的。我们可能有一个带有按钮、文本和模态框的应用，所有这些都需要显示按钮被点击的次数。我们只需要将必要的组件添加到父组件中，并传递`counter`属性。状态仅在父组件中更改，然后传递给子组件。
- en: 'Now we arrive at the moment where we need to decide which component should
    handle the state change. In our simple code example, the answer is obvious: we
    have only one parent. In the real world, this question may be much more difficult
    to answer. Luckily for us, we will look at state management strategies throughout
    this entire book. I hope, after reading this book, that you will be well equipped
    to choose the best place to store and manage your application state in your React
    Native app.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来到了需要决定哪个组件应该处理状态变化的时候。在我们的简单代码示例中，答案很明显：我们只有一个父组件。在现实世界中，这个问题可能要难得多。幸运的是，我们将在整本书中探讨状态管理策略。我希望，在阅读这本书之后，你将准备好在你的React
    Native应用中选择最佳位置来存储和管理你的应用状态。
- en: In the previous section, we went over high-level aspects of writing code in
    ReactJS. It’s good to keep in mind the patterns we looked at, as they are just
    as useful in React Native development. And since we’re familiar with ReactJS,
    we are ready to dive into the world of native apps written in JavaScript.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了在ReactJS中编写代码的高级方面。记住我们查看的模式是很有用的，因为它们在React Native开发中同样有用。而且由于我们已经熟悉了ReactJS，我们准备好深入到用JavaScript编写的原生应用的世界。
- en: Understanding cross-platform software development
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解跨平台软件开发
- en: Before talking about React Native, we need to go over the landscape of mobile
    app development.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈论React Native之前，我们需要回顾一下移动应用开发的格局。
- en: It is quite obvious that mobile apps can be created using native platform programming
    languages. The ones considered most modern are Swift, for iOS development, and
    Kotlin, for Android development. Many developers still use Objective-C and Java,
    respectively. However, when the market of mobile phones settled down with the
    two giants, Apple and Google, it was tempting to create solutions that could be
    written once for both platforms. Similarly, for websites, which can be opened
    in any browser, why can’t we have apps that can be run on any device?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，可以使用原生平台编程语言来创建移动应用。被认为最现代的是用于iOS开发的Swift和用于Android开发的Kotlin。许多开发者仍然使用Objective-C和Java。然而，当手机市场在苹果和谷歌两大巨头之间稳定下来时，创建一次编写即可用于两个平台的解决方案是非常诱人的。同样，对于可以在任何浏览器中打开的网站，为什么我们不能有可以在任何设备上运行的应用呢？
- en: Looking for this mythical cross-platform solution was enticing to many companies.
    They were hiring separate teams from iOS and Android to end up with apps that
    do not look and feel the same.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找这种神话般的跨平台解决方案对许多公司来说极具吸引力。他们分别从iOS和Android团队中招聘了不同的团队，最终得到的app在外观和感觉上并不相同。
- en: The software development world is vast, and we can find many solutions to a
    single problem. Cross-platform development is not an exception to this rule. If
    you google `cross-platform apps`, you will find a solution from Microsoft, called
    **Xamarin**. You will also find **Flutter**, written in a language called **Dart**.
    And finally, you will find many solutions based on JavaScript. One of the first
    meaningful players was **Ionic**. Ionic is a framework, built in 2013, for development
    in AngularJS, and it uses **Apache Cordova** behind the scenes. Ionic developers
    build their apps using the exact same syntax they would use to create a website.
    At build time, a native app **wrapper** with a single WebView is created. The
    Ionic code is run inside this WebView. Given this structure, many people call
    Ionic apps **hybrid apps** to differentiate them from **cross-platform** apps.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发的世界非常广阔，我们可以找到许多针对单个问题的解决方案。跨平台开发也不例外。如果你搜索“跨平台应用”，你会找到一个由微软提供的解决方案，名为**Xamarin**。你还会找到一个名为**Flutter**的解决方案，它使用一种名为**Dart**的语言编写。最后，你还会发现许多基于JavaScript的解决方案。其中第一个有意义的参与者是**Ionic**。Ionic是一个框架，建于2013年，用于AngularJS的开发，并在幕后使用**Apache
    Cordova**。Ionic开发者使用与创建网站相同的语法来构建他们的应用。在构建时，创建一个包含单个WebView的原生应用**包装器**。Ionic代码在这个WebView中运行。鉴于这种结构，许多人将Ionic应用称为**混合应用**，以区分它们与**跨平台**应用。
- en: React Native is a completely different solution. In its case, code is compiled
    into a complete native app. JavaScript code runs in the app and communicates with
    the phone’s native modules through a **bridge**. But where did React Native come
    from, you may ask?
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: React Native是一个完全不同的解决方案。在这种情况下，代码被编译成一个完整的原生应用。JavaScript代码在应用中运行，并通过一个**桥接器**与手机的本地模块进行通信。但你可能会问，React
    Native是从哪里来的呢？
- en: Let’s dive into that topic in our next section.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节深入探讨这个话题。
- en: Going over the history of React Native
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索React Native的历史
- en: Back in 2012, Facebook announced they were becoming a *mobile-first company*.
    Facebook realized its users spend more time on their phones than on computers.
    They needed to have their websites and apps working seamlessly on smart devices.
    However, the majority of Facebook engineers were web developers. The company started
    researching options to reuse the knowledge of those web developers for mobile
    development. After trying out a few different ideas, they didn’t want to follow
    in the footsteps of Ionic, enclosing the apps inside WebViews. They needed something
    new.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 回到2012年，Facebook宣布他们正在成为一个**移动优先**的公司。Facebook意识到用户在手机上花费的时间比在电脑上多。他们需要确保他们的网站和应用在智能设备上无缝工作。然而，Facebook的大多数工程师都是网页开发者。公司开始研究如何利用这些网页开发者的知识来开发移动应用。在尝试了几种不同的想法后，他们不想跟随Ionic的脚步，将应用封装在WebView中。他们需要一些新的东西。
- en: That is when a developer named *Christopher Chedeau* made his mark on the history
    of software development. He teamed up with *Jordan Walke*, *Ashwin Bharambe*,
    and *Lin He* for an internal Facebook hackathon. Basing their work on the first
    attempts done by Jordan – who, by this time, had been able to generate *UILabel*
    in iOS from JavaScript – they created a working prototype that could generate
    native UI elements from JavaScript on the user device. And it took them only 2
    days!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 就在这个时候，一位名叫*克里斯托弗·切德欧*的开发者在软件开发的历史上留下了自己的印记。他与*乔丹·沃尔克*、*阿什温·布拉姆贝*和*林·何*一起参加了一个Facebook内部的黑客马拉松。基于乔丹最初的努力——此时他已经能够从JavaScript生成iOS的*UILabel*——他们创建了一个工作原型，可以在用户设备上从JavaScript生成原生UI元素。而且他们只用了2天时间！
- en: 'The history of React Native: Facebook’s Open Source App Development Framework'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: React Native的历史：Facebook的开源应用开发框架
- en: 'You can read the article here: [https://www.techaheadcorp.com/blog/history-of-react-native/](https://www.techaheadcorp.com/blog/history-of-react-native/).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里阅读文章：[https://www.techaheadcorp.com/blog/history-of-react-native/](https://www.techaheadcorp.com/blog/history-of-react-native/)。
- en: After this initial success, Jordan and Christopher were able to continue working
    on their new product, named React Native, with an entire team of engineers.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次初步成功之后，乔丹和克里斯托弗能够继续他们名为React Native的新产品开发工作，这个产品拥有一个由工程师组成的完整团队。
- en: After 3 years, they were ready to present what they had to the world. The official
    announcement for React Native took place at ReactJS Conf in 2015\. This was the
    first ReactJS Conf, and React Native was presented during the keynote! That’s
    how much faith Facebook had in this framework. I encourage you to check out the
    talk; you can find a link in the official ReactJS docs at [https://reactjs.org/blog/2015/02/18/react-conf-roundup-2015.html](https://reactjs.org/blog/2015/02/18/react-conf-roundup-2015.html).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 经过3年的努力，他们终于准备好向世界展示他们的成果。React Native的官方发布是在2015年的ReactJS Conf上进行的。这是第一届ReactJS
    Conf，React Native在主题演讲中被介绍！这显示了Facebook对这个框架的信心。我鼓励你查看这个演讲；你可以在官方ReactJS文档中找到链接：[https://reactjs.org/blog/2015/02/18/react-conf-roundup-2015.html](https://reactjs.org/blog/2015/02/18/react-conf-roundup-2015.html)。
- en: 'Since 2015, React Native has grown and changed a lot. Some changes, such as
    the introduction of hooks and context, were simple follow-ups to changes happening
    in ReactJS. In other cases, changes were motivated by the community or proposed
    by the maintainers of the framework. React Native on [github.com](http://github.com)
    has a whole section called *Discussions and Proposals* (https://github.com/react-native-community/discussions-and-proposals).
    Everyone is welcome to add anything they would like to discuss on the topic of
    React Native implementations, ecosystems, and so on. This board is a great resource
    for what is currently going on and what may be expected to happen in the future.
    One of the first issues on this board, the sixth issue to be exact, was a proposition
    for a *Lean Core*. By this time, React Native has been in the wild for at least
    3 years and it has grown a lot. The framework has included implementations of
    UI details such as Switch, or native functionalities such as push notifications.
    One of the core maintainers of the repo proposed that all code that is not absolutely
    necessary be removed from the main package. You can read more details on *Lean
    Core* here: [https://github.com/react-native-community/discussions-and-proposals/issues/6](https://github.com/react-native-community/discussions-and-proposals/issues/6).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 自2015年以来，React Native经历了很大的成长和变化。一些变化，如hooks和context的引入，是ReactJS中发生变化的简单后续。在其他情况下，变化是由社区推动或由框架的维护者提出的。React
    Native在[github.com](http://github.com)上有一个名为*讨论和提案*（[https://github.com/react-native-community/discussions-and-proposals](https://github.com/react-native-community/discussions-and-proposals)）的整个部分。每个人都可以添加他们想讨论的关于React
    Native实现、生态系统等主题的内容。这个论坛是了解当前正在进行的事情以及未来可能发生的事情的一个极好的资源。这个论坛上的第一个问题，确切地说，是第六个问题，是一个关于*精益核心*的提案。到那时，React
    Native已经在野外至少3年了，并且已经成长了很多。这个框架已经包括了UI细节的实现，如开关，或原生功能，如推送通知。该仓库的核心维护者之一提议，所有非绝对必要的代码都应该从主包中移除。你可以在*精益核心*这里了解更多细节：[https://github.com/react-native-community/discussions-and-proposals/issues/6](https://github.com/react-native-community/discussions-and-proposals/issues/6)。
- en: Of course, answering the question of “what is necessary” and “what isn’t” is
    not easy. The *Lean Core* took a few months of discussions and breaking changes.
    The shape of the main React Native package today represents the results of this
    effort.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，回答“什么是必要的”和“什么不是”的问题并不容易。*精益核心*经过了几个月的讨论和重大变更。今天主React Native包的形状代表了这一努力的成果。
- en: 'In the meantime, the *Lean Core initiative* energized the community to go ahead
    and create their own libraries, which could be useful for React Native apps. As
    of writing this book, there are hundreds of libraries to choose from when you
    decide to create a React Native app. There are UI libraries, navigation libraries,
    async storage management libraries, and many more. This is a blessing and a curse
    because not every library is well-written and maintained correctly. You can, unfortunately,
    happen to use something that may break your app in the future. So before running
    to your terminal and typing `yarn add`, you may want to use the React Native directory:
    [https://reactnative.directory](https://reactnative.directory). This website provides
    metrics on open source libraries, which are very helpful when you want to add
    a good dependency to your project.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，*精益核心计划*激发了社区的热情，让他们继续创建自己的库，这些库对React Native应用可能很有用。截至撰写本书时，当你决定创建一个React
    Native应用时，可以选择的库有数百个。这里有UI库、导航库、异步存储管理库等等。这既是福也是祸，因为并非每个库都写得很好且维护得当。不幸的是，你可能会用到一些可能在将来破坏你应用的库。所以，在你跑到终端并输入`yarn
    add`之前，你可能想使用React Native目录：[https://reactnative.directory](https://reactnative.directory)。这个网站提供了开源库的指标，当你想为你的项目添加一个好的依赖项时，这些指标非常有帮助。
- en: There are a few libraries that stand out so much, and they are considered to
    be *recommended* for React Native projects. Those libraries are usually pretty
    mature and well-maintained. One example is **React Navigation**, the go-to library
    for apps that need anything more than one screen. **React Native Testing Library**
    is a library officially coupled with Kent C. Dodd’s **React Testing Library**.
    **Reanimated** is an animation library, which achieves better performance than
    any of its competitors.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个库非常突出，它们被认为是React Native项目的*推荐*库。这些库通常非常成熟且维护良好。一个例子是**React Navigation**，这是需要多于一个屏幕的应用的首选库。**React
    Native Testing Library**是与Kent C. Dodd的**React Testing Library**官方结合的库。**Reanimated**是一个动画库，其性能优于任何竞争对手。
- en: 'An important part of the React Native ecosystem is **Expo**: [https://expo.dev/](https://expo.dev/).
    Expo is both a framework and a platform for React Native applications. It offers
    its users a set of tools useful for developing, building, and deploying apps.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: React Native生态系统的一个重要部分是**Expo**：[https://expo.dev/](https://expo.dev/). Expo既是React
    Native应用的框架，也是平台。它为用户提供了一套用于开发、构建和部署应用的工具。
- en: 'What does that mean specifically? Expo is a thin layer on top of React Native,
    aimed at making the life of developers easier. If writing an app in React Native
    was like eating a grilled steak with your hands, Expo would be like eating Filet
    Mignon with a baked potato and a side of Caesar salad. In a fancy restaurant.
    You may very well prefer the former, but you cannot deny the obvious advantages
    of the latter. If you decide to use Expo, you will find local environment setup
    instructions in the official React Native docs: [https://reactnative.dev/docs/environment-setup](https://reactnative.dev/docs/environment-setup).
    Once the app is set up, you will be able to take advantage of the many components
    created and maintained by the Expo team. This way, you may save yourself a few
    headaches and performance problems. When you’re ready to show your app to the
    world, you can upload your app bundle to the Expo website and use it for testing
    and deployment. As you can see, Expo is a very versatile tool.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这具体意味着什么？Expo是React Native之上的一层薄层，旨在让开发者的生活更轻松。如果你在React Native中编写应用就像用手吃烤牛排一样，那么Expo就像是带着烤土豆和凯撒沙拉一起吃菲力牛排。在一家高档餐厅。你可能非常偏好前者，但无法否认后者明显的优势。如果你决定使用Expo，你将在官方React
    Native文档中找到本地环境设置说明：[https://reactnative.dev/docs/environment-setup](https://reactnative.dev/docs/environment-setup)。一旦应用设置完成，你将能够利用Expo团队创建和维护的许多组件。这样，你可能会节省一些头痛和性能问题。当你准备好向世界展示你的应用时，你可以将你的应用包上传到Expo网站，并用于测试和部署。正如你所见，Expo是一个非常通用的工具。
- en: Now that we’re up to speed with the history and the current state of React Native,
    let’s move on to looking at some real-world apps that use it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了React Native的历史和当前状态，让我们继续看看一些实际使用它的应用。
- en: Reviewing examples of popular apps using React Native
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查使用React Native的流行应用的示例
- en: Now that we know a little bit about React Native, it’s time to get excited about
    it. A great way to get excited about a new technology is to look at what that
    technology has already been used for. This is also a good strategy when you must
    decide to use a particular technology.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对React Native有了一些了解，是时候对其感到兴奋了。了解一项新技术的一个好方法就是看看这项技术已经被用于什么。当你必须决定使用特定技术时，这也是一个好的策略。
- en: The obvious example comes from **Meta** – the birthplace of React Native. The
    very first implementations of ReactJS took place in Facebook Ads. It is fitting
    that React Native is used for that same feature on mobile devices. Facebook’s
    mobile app is not entirely created with React Native, but some parts of it use
    it. That means the Facebook app is a React Native *brownfield* app. The opposite
    of that is apps written in React Native alone, and that sort of app is called
    *greenfield*.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 显而易见的例子来自**Meta**——React Native的诞生地。ReactJS的最初实现发生在Facebook Ads中。React Native在移动设备上用于相同的功能是合适的。Facebook的移动应用并非完全使用React
    Native创建，但其中一些部分使用了它。这意味着Facebook应用是一个React Native的*棕色地带*应用。与之相反的是仅使用React Native编写的应用，这类应用被称为*绿色地带*。
- en: While we’re in the Metaverse, I will mention that the Instagram app uses React
    Native, as does the Oculus app.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在元宇宙中时，我会提到Instagram应用使用React Native，Oculus应用也是如此。
- en: Don’t worry, Meta is not the only notable company using React Native. Discord
    not only uses React Native for their app, but they also write blog posts about
    how they maintain their app. In this Medium article, [https://blog.discord.com/how-discord-achieves-native-ios-performance-with-react-native-390c84dcd502](https://blog.discord.com/how-discord-achieves-native-ios-performance-with-react-native-390c84dcd502),
    the Discord team states that they adopted React Native as soon as it was open
    sourced, and they are still happy with their decision years later.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 别担心，Meta并不是唯一一家使用React Native的知名公司。Discord不仅使用React Native来开发他们的应用，还撰写了关于他们如何维护应用的博客文章。在这篇Medium文章中，[https://blog.discord.com/how-discord-achieves-native-ios-performance-with-react-native-390c84dcd502](https://blog.discord.com/how-discord-achieves-native-ios-performance-with-react-native-390c84dcd502)，Discord团队表示，他们一开源就采用了React
    Native，并且几年后仍然对他们的决定感到满意。
- en: 'Shopify is another big player in the React Native ecosystem. They have an article
    on their blog entitled *React Native is the Future of Mobile at Shopify*: https://shopify.engineering/react-native-future-mobile-shopify.
    Shopify engineers also write more technical articles, for example, about accessibility:
    [https://www.shopify.com/partners/blog/react-native-accessibility](https://www.shopify.com/partners/blog/react-native-accessibility).'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Shopify是React Native生态系统中的另一大重要玩家。他们在博客上有一篇文章，标题为《React Native是Shopify移动未来的未来》：[https://shopify.engineering/react-native-future-mobile-shopify](https://shopify.engineering/react-native-future-mobile-shopify)。Shopify工程师还撰写了更多技术文章，例如关于无障碍的：[https://www.shopify.com/partners/blog/react-native-accessibility](https://www.shopify.com/partners/blog/react-native-accessibility)。
- en: 'The website-builder giant **Wix** is also active in the React Native world.
    They have also written about their adventure with React Native (https://medium.com/wix-engineering/react-native-at-wix-the-architecture-db6361764da6)
    but they also create open source libraries, for example, this UI kit: [https://github.com/wix/react-native-ui-lib.](https://github.com/wix/react-native-ui-lib)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 网站构建巨头**Wix**也在React Native领域非常活跃。他们也写了一些关于他们与React Native冒险经历的文章（https://medium.com/wix-engineering/react-native-at-wix-the-architecture-db6361764da6），但他们还创建了开源库，例如这个UI库：[https://github.com/wix/react-native-ui-lib.](https://github.com/wix/react-native-ui-lib)
- en: 'Circling back to listing specific apps built with React Native, I have to mention
    **Coinbase**. Managing users’ finances in a reliable manner is the top priority
    for this crypto market leader. They analyzed, iterated, and landed on using React
    Native as their main mobile technology. You can read their article about the transition
    from native technologies on their blog: [https://blog.coinbase.com/announcing-coinbases-successful-transition-to-react-native-af4c591df971](https://blog.coinbase.com/announcing-coinbases-successful-transition-to-react-native-af4c591df971).'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 回到使用React Native构建的具体应用列表，我必须提到**Coinbase**。以可靠的方式管理用户的财务是这家加密市场领先者的首要任务。他们分析了、迭代了，并最终选择了React
    Native作为他们的主要移动技术。你可以在他们的博客上阅读他们关于从原生技术过渡到React Native的文章：[https://blog.coinbase.com/announcing-coinbases-successful-transition-to-react-native-af4c591df971](https://blog.coinbase.com/announcing-coinbases-successful-transition-to-react-native-af4c591df971)。
- en: 'You may have heard of companies such as Tesla, Walmart, Salesforce, Bloomberg,
    and Vogue. You may have used apps such as Uber Eats, Artsy, Words with Friends,
    and SoundCloud Pulse. What do they have in common? Surprise! (Not really.) They
    all use React Native. You can find even more examples with links to articles in
    the React Native showcase: [https://reactnative.dev/showcase](https://reactnative.dev/showcase).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能听说过像特斯拉、沃尔玛、Salesforce、彭博社和《Vogue》这样的公司。你可能也使用过像Uber Eats、Artsy、Words with
    Friends和SoundCloud Pulse这样的应用。它们有什么共同点？惊喜！（其实不是。）它们都使用了React Native。你可以在React
    Native展示区找到更多例子和文章链接：[https://reactnative.dev/showcase](https://reactnative.dev/showcase)。
- en: 'Not all React Native stories are success stories, though. One famous case (by
    *famous*, I mean it was tweeted about for a few days) is Airbnb. Airbnb’s website
    uses ReactJS, so it was logical for them to try React Native for their mobile
    app. After a few years of development, they hit development roadblocks and performance
    issues. Their app consists of a very big map that needs to work perfectly. The
    developers working on the app often needed help from React Native developers,
    which was a bottleneck for this web-technology-focused company. They announced
    their divorce from React Native in 2018: [https://medium.com/airbnb-engineering/sunsetting-react-native-1868ba28e30a](https://medium.com/airbnb-engineering/sunsetting-react-native-1868ba28e30a).
    Luckily, they still develop their amazing animation library, **Lottie** (http://airbnb.io/lottie/#/),
    which can be used in React Native apps.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有 React Native 的故事都是成功的。有一个著名的案例（我所说的“著名”是指它在推特上讨论了好几天）是 Airbnb。Airbnb 的网站使用
    ReactJS，因此他们尝试为他们的移动应用使用 React Native 是合乎逻辑的。经过几年的开发，他们遇到了开发瓶颈和性能问题。他们的应用包含一个非常大的地图，需要完美运行。负责该应用的开发者经常需要
    React Native 开发者的帮助，这对这家以网络技术为重点的公司来说是一个瓶颈。他们在 2018 年宣布与 React Native 分手：[https://medium.com/airbnb-engineering/sunsetting-react-native-1868ba28e30a](https://medium.com/airbnb-engineering/sunsetting-react-native-1868ba28e30a)。幸运的是，他们仍然在开发他们惊人的动画库
    **Lottie**（http://airbnb.io/lottie/#/），它可以在 React Native 应用中使用。
- en: Summary
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Oof! That was a lot of theory for a programming book, right? However, even
    if you found it a little dry, I strongly believe this theoretical knowledge will
    be very useful for the next chapter. We have learned a little bit about the history
    of web development and about the motivations of the creators of both ReactJS and
    React Native. Knowing all of this will let us understand the ideas behind different
    state management solutions. In the next chapter, we will jump into the most basic
    way of managing state in a React Native app: with hooks and context.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呦！对于一本编程书来说，理论内容确实挺多的，对吧？然而，即使你觉得有点枯燥，我坚信这些理论知识对于下一章将非常有用。我们已经了解了一些关于网络开发的历史，以及
    ReactJS 和 React Native 的创造者的动机。了解这些将使我们能够理解不同状态管理解决方案背后的理念。在下一章中，我们将探讨在 React
    Native 应用中管理状态的最基本方式：使用 hooks 和 context。
