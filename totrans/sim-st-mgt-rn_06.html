<html><head></head><body>
<div id="_idContainer035">
<h1 class="chapter-number" id="_idParaDest-71"><a id="_idTextAnchor072"/><span class="koboSpan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-72"><a id="_idTextAnchor073"/><span class="koboSpan" id="kobo.2.1">Using MobX as a State Manager in a React Native App</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapter, we had a chance to try the most popular state management solution in the </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">React</span></strong><span class="koboSpan" id="kobo.5.1"> ecosystem – </span><strong class="bold"><span class="koboSpan" id="kobo.6.1">Redux</span></strong><span class="koboSpan" id="kobo.7.1">. </span><span class="koboSpan" id="kobo.7.2">We looked in detail at replacing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.8.1">FavoritedImages</span></strong><span class="koboSpan" id="kobo.9.1"> context </span><a id="_idIndexMarker259"/><span class="koboSpan" id="kobo.10.1">with </span><strong class="bold"><span class="koboSpan" id="kobo.11.1">Redux</span></strong><span class="koboSpan" id="kobo.12.1">. </span><span class="koboSpan" id="kobo.12.2">You can go back at any time to check what exactly was changed in the code in the GitHub repo’s folder for </span><a href="B18396_05.xhtml#_idTextAnchor056"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.13.1">Chapter </span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.14.1">5</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.15.1">: </span></span><a href="https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-5"><span class="No-Break"><span class="koboSpan" id="kobo.16.1">https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-5</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.17.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.18.1">If you’re curious to see the entire app fully migrated to Redux, please go to another </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">folder: </span></span><a href="https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-5-complete"><span class="No-Break"><span class="koboSpan" id="kobo.20.1">https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-5-complete</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.21.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.22.1">We’ve had a steep hill to climb so far. </span><span class="koboSpan" id="kobo.22.2">We talked about </span><strong class="bold"><span class="koboSpan" id="kobo.23.1">ReactJS</span></strong><span class="koboSpan" id="kobo.24.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.25.1">React Native</span></strong><span class="koboSpan" id="kobo.26.1">, and managing state </span><a id="_idIndexMarker260"/><span class="koboSpan" id="kobo.27.1">without additional libraries, and finally, we looked at </span><strong class="bold"><span class="koboSpan" id="kobo.28.1">Redux</span></strong><span class="koboSpan" id="kobo.29.1">. </span><span class="koboSpan" id="kobo.29.2">I can assure you, my dear reader, that if you were able to internalize the first five chapters of this </span><a id="_idIndexMarker261"/><span class="koboSpan" id="kobo.30.1">book, the rest will be a breeze! </span><span class="koboSpan" id="kobo.30.2">All we will do now is the same exercise: replacing </span><strong class="bold"><span class="koboSpan" id="kobo.31.1">ReactJS</span></strong><span class="koboSpan" id="kobo.32.1"> context for </span><strong class="source-inline"><span class="koboSpan" id="kobo.33.1">FavoritedImages</span></strong><span class="koboSpan" id="kobo.34.1"> with a state management library. </span><span class="koboSpan" id="kobo.34.2">In this chapter, we will talk</span><a id="_idIndexMarker262"/><span class="koboSpan" id="kobo.35.1"> about </span><strong class="bold"><span class="koboSpan" id="kobo.36.1">MobX</span></strong><span class="koboSpan" id="kobo.37.1">. </span><span class="koboSpan" id="kobo.37.2">We will start by taking a brief look at the history of MobX and learning about the concepts of MobX at a high level. </span><span class="koboSpan" id="kobo.37.3">After that, we will move on to configuring MobX in the Funbook app. </span><span class="koboSpan" id="kobo.37.4">Once we have the library set up in our project, we will move on to re-writing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.38.1">FavoritedImages</span></strong><span class="koboSpan" id="kobo.39.1"> context with a MobX state, models, </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">and actions.</span></span></p>
<p><span class="koboSpan" id="kobo.41.1"> Here’s what this chapter </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">will include:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.43.1">Going over </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.44.1">MobX</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.45.1"> concepts</span></span></li>
<li><span class="koboSpan" id="kobo.46.1">Configuring </span><strong class="bold"><span class="koboSpan" id="kobo.47.1">MobX</span></strong><span class="koboSpan" id="kobo.48.1"> in the </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">Funbook app</span></span></li>
<li><span class="koboSpan" id="kobo.50.1">Using </span><strong class="bold"><span class="koboSpan" id="kobo.51.1">MobX</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.52.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.53.1">FavoritedImages</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.54.1">By the end of this chapter, you should feel comfortable using </span><strong class="bold"><span class="koboSpan" id="kobo.55.1">MobX</span></strong><span class="koboSpan" id="kobo.56.1">. </span><span class="koboSpan" id="kobo.56.2">Not only will you know what </span><strong class="bold"><span class="koboSpan" id="kobo.57.1">MobX</span></strong><span class="koboSpan" id="kobo.58.1"> models, snapshots, and stores are but you will also know whether you prefer them over </span><strong class="bold"><span class="koboSpan" id="kobo.59.1">Redux</span></strong><span class="koboSpan" id="kobo.60.1">! </span><span class="koboSpan" id="kobo.60.2">And that’s what this book is really about: getting to know different solutions so you can pick whichever you prefer for your </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">future projects.</span></span></p>
<h1 id="_idParaDest-73"><a id="_idTextAnchor074"/><span class="koboSpan" id="kobo.62.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.63.1">In order to follow along with this chapter, you will need some knowledge of </span><strong class="bold"><span class="koboSpan" id="kobo.64.1">JavaScript</span></strong><span class="koboSpan" id="kobo.65.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.66.1">ReactJS</span></strong><span class="koboSpan" id="kobo.67.1">. </span><span class="koboSpan" id="kobo.67.2">If you have followed at least </span><em class="italic"><span class="koboSpan" id="kobo.68.1">Chapters 1 </span></em><span class="koboSpan" id="kobo.69.1">to</span><em class="italic"><span class="koboSpan" id="kobo.70.1"> 4</span></em><span class="koboSpan" id="kobo.71.1"> of this book, you should be able to go forward without </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">any issues.</span></span></p>
<p><span class="koboSpan" id="kobo.73.1">Feel free to use an IDE of your choice, as React Native does not need any specific functionality. </span><span class="koboSpan" id="kobo.73.2">Currently, the most popular IDEs for frontend developers are Microsoft’s VSCode, Atom, Sublime Text, </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">and WebStorm.</span></span></p>
<p><span class="koboSpan" id="kobo.75.1">The code snippets provided in this chapter are there to illustrate what we should be doing with the code. </span><span class="koboSpan" id="kobo.75.2">They do not provide the whole picture. </span><span class="koboSpan" id="kobo.75.3">To code along easier, please open the GitHub repo in your IDE and look at the files in there. </span><span class="koboSpan" id="kobo.75.4">You can either start with the file in the folder named </span><strong class="source-inline"><span class="koboSpan" id="kobo.76.1">example-app-full</span></strong><span class="koboSpan" id="kobo.77.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.78.1">chapter-6</span></strong><span class="koboSpan" id="kobo.79.1">. </span><span class="koboSpan" id="kobo.79.2">If you start with </span><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">example-app-full</span></strong><span class="koboSpan" id="kobo.81.1">, you will be responsible for implementing the solutions described in this chapter. </span><span class="koboSpan" id="kobo.81.2">If you choose to look at </span><strong class="source-inline"><span class="koboSpan" id="kobo.82.1">chapter-6</span></strong><span class="koboSpan" id="kobo.83.1">, you will see the entire solution implemented </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">by me.</span></span></p>
<p><span class="koboSpan" id="kobo.85.1">If you get stuck or lost, you can check the code in the GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">repo: </span></span><a href="https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-6"><span class="No-Break"><span class="koboSpan" id="kobo.87.1">https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-6</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.88.1">.</span></span></p>
<h1 id="_idParaDest-74"><a id="_idTextAnchor075"/><span class="koboSpan" id="kobo.89.1">Going over MobX concepts</span></h1>
<p><span class="koboSpan" id="kobo.90.1">As you may </span><a id="_idIndexMarker263"/><span class="koboSpan" id="kobo.91.1">have noticed, my dear reader, I like to start every big section with a little bit of history about the piece of software that we are going to examine. </span><span class="koboSpan" id="kobo.91.2">It so happens that MobX has a very calm presence in the React community. </span><span class="koboSpan" id="kobo.91.3">There isn’t really any drama surrounding its conception or development. </span><span class="koboSpan" id="kobo.91.4">It was announced in 2015 as a solution on the blog of the company Mendix, where the creator of MobX, </span><em class="italic"><span class="koboSpan" id="kobo.92.1">Michel Weststrate</span></em><span class="koboSpan" id="kobo.93.1">, used to work. </span><span class="koboSpan" id="kobo.93.2">The blog post details the reasons for creating this library, namely the fact that a pure ReactJS app in 2015 was not very good at managing complex states. </span><span class="koboSpan" id="kobo.93.3">Since then, MobX has been developed as an OSS library on GitHub. </span><span class="koboSpan" id="kobo.93.4">In 2016, it was </span><a id="_idIndexMarker264"/><span class="koboSpan" id="kobo.94.1">joined by </span><strong class="bold"><span class="koboSpan" id="kobo.95.1">MobX-State-Tree</span></strong><span class="koboSpan" id="kobo.96.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.97.1">MST</span></strong><span class="koboSpan" id="kobo.98.1">), a state container system for MobX. </span><span class="koboSpan" id="kobo.98.2">MST is to MobX what Redux Toolkit is to Redux. </span><span class="koboSpan" id="kobo.98.3">It’s an additional tool made for a </span><a id="_idIndexMarker265"/><span class="koboSpan" id="kobo.99.1">better </span><strong class="bold"><span class="koboSpan" id="kobo.100.1">developer experience</span></strong><span class="koboSpan" id="kobo.101.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.102.1">DX</span></strong><span class="koboSpan" id="kobo.103.1">), but it’s not required. </span><span class="koboSpan" id="kobo.103.2">I personally like to make my life easier, so in this book, we will </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">use MST.</span></span></p>
<p><span class="koboSpan" id="kobo.105.1">I exchanged </span><a id="_idIndexMarker266"/><span class="koboSpan" id="kobo.106.1">a few messages with </span><em class="italic"><span class="koboSpan" id="kobo.107.1">Jamon Holmgren</span></em><span class="koboSpan" id="kobo.108.1">, who is the CTO of Infinite Red, one of the most renowned software houses specializing in React Native, and the maintainer of </span><strong class="bold"><span class="koboSpan" id="kobo.109.1">MST</span></strong><span class="koboSpan" id="kobo.110.1">. </span><span class="koboSpan" id="kobo.110.2">He said he found out about </span><strong class="bold"><span class="koboSpan" id="kobo.111.1">MobX</span></strong><span class="koboSpan" id="kobo.112.1"> around 5 years ago when his teammates were looking for alternatives to Redux. </span><span class="koboSpan" id="kobo.112.2">After doing a trial project, they really liked it and they’ve been using it ever since. </span><span class="koboSpan" id="kobo.112.3">It’s even integrated into </span><strong class="bold"><span class="koboSpan" id="kobo.113.1">Ignite</span></strong><span class="koboSpan" id="kobo.114.1">, the </span><strong class="bold"><span class="koboSpan" id="kobo.115.1">React Native</span></strong><span class="koboSpan" id="kobo.116.1"> boilerplate</span><a id="_idIndexMarker267"/><span class="koboSpan" id="kobo.117.1"> by Infinite Red. </span><span class="koboSpan" id="kobo.117.2">Jamon says that “</span><strong class="bold"><span class="koboSpan" id="kobo.118.1">MST’s</span></strong><span class="koboSpan" id="kobo.119.1"> main advantage is that you get the central store feel of Redux without having to touch four or five different files for every change. </span><span class="koboSpan" id="kobo.119.2">You also get granular re-renders without having to write a single selector and a very natural JavaScript-y feel. </span><span class="koboSpan" id="kobo.119.3">Developers at Infinite Red used MST on apps with hundreds of screens and millions of daily active users with little issue, so it’s a proven state management system that works really well with React and React Native.” </span><span class="koboSpan" id="kobo.119.4">In cases where developers have to work with less structured data, over which they need more control, </span><strong class="bold"><span class="koboSpan" id="kobo.120.1">MobX</span></strong><span class="koboSpan" id="kobo.121.1"> could be the better solution </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">over </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.123.1">MST</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.125.1">“</span><strong class="bold"><span class="koboSpan" id="kobo.126.1">MobX</span></strong><span class="koboSpan" id="kobo.127.1"> still brings the observability (granular, targeted re-renders) and natural updates that MST has, but is much lighter weight," </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">Jamon added.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.129.1">MobX</span></strong><span class="koboSpan" id="kobo.130.1"> was created around 7 years ago, but it has stayed relevant over the years. </span><span class="koboSpan" id="kobo.130.2">Jamon says he would like to </span><a id="_idIndexMarker268"/><span class="koboSpan" id="kobo.131.1">improve the </span><strong class="bold"><span class="koboSpan" id="kobo.132.1">TypeScript</span></strong><span class="koboSpan" id="kobo.133.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.134.1">TS</span></strong><span class="koboSpan" id="kobo.135.1">) types of the library, but overall, he thinks the library is holding up very well thanks to its author’s, Michel Westrate’s, </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">excellent engineering.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.137.1">MobX</span></strong><span class="koboSpan" id="kobo.138.1"> is currently one of the most popular state management libraries for </span><strong class="bold"><span class="koboSpan" id="kobo.139.1">React</span></strong><span class="koboSpan" id="kobo.140.1"> apps. </span><span class="koboSpan" id="kobo.140.2">The documentation states that it’s one of the most popular </span><strong class="bold"><span class="koboSpan" id="kobo.141.1">Redux</span></strong><span class="koboSpan" id="kobo.142.1"> alternatives. </span><span class="koboSpan" id="kobo.142.2">If you read the docs closely enough, you may find a few places where the authors allude to </span><strong class="bold"><span class="koboSpan" id="kobo.143.1">MobX</span></strong><span class="koboSpan" id="kobo.144.1"> being better than </span><strong class="bold"><span class="koboSpan" id="kobo.145.1">Redux</span></strong><span class="koboSpan" id="kobo.146.1">. </span><span class="koboSpan" id="kobo.146.2">When I asked Jamon about this rivalry, he said, “It’s always fun to have other great communities to banter with. </span><span class="koboSpan" id="kobo.146.3">The reality is that the </span><strong class="bold"><span class="koboSpan" id="kobo.147.1">MobX</span></strong><span class="koboSpan" id="kobo.148.1"> community respects the </span><strong class="bold"><span class="koboSpan" id="kobo.149.1">Redux</span></strong><span class="koboSpan" id="kobo.150.1"> community a ton. </span><span class="koboSpan" id="kobo.150.2">Their community pushes ours to be better and improve. </span><span class="koboSpan" id="kobo.150.3">They make different trade-off decisions and one or the other might not be your particular style, so it’s great to </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">have options.”</span></span></p>
<p><span class="koboSpan" id="kobo.152.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.153.1">MobX</span></strong><span class="koboSpan" id="kobo.154.1"> maintainers have, of course, the full right to think the solution they are working on is better. </span><span class="koboSpan" id="kobo.154.2">Now, let’s see what you think, my </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">dear reader!</span></span></p>
<p><span class="koboSpan" id="kobo.156.1">As far as </span><strong class="bold"><span class="koboSpan" id="kobo.157.1">MobX</span></strong><span class="koboSpan" id="kobo.158.1"> concepts and high-level ideas are concerned, there is one very important sentence underlined in </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">the documentation:</span></span></p>
<p class="author-quote"><span class="koboSpan" id="kobo.160.1">Anything that can be derived from the application state, should be. </span><span class="koboSpan" id="kobo.160.2">Automatically.</span></p>
<p class="author-quote"><span class="koboSpan" id="kobo.161.1">- The MobX Motto</span></p>
<p><span class="koboSpan" id="kobo.162.1">This is a new </span><a id="_idIndexMarker269"/><span class="koboSpan" id="kobo.163.1">concept! </span><span class="koboSpan" id="kobo.163.2">Anything that can be derived, should be derived automatically. </span><span class="koboSpan" id="kobo.163.3">Have we derived anything from our app state automatically before? </span><span class="koboSpan" id="kobo.163.4">Not really. </span><span class="koboSpan" id="kobo.163.5">At first, we created </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">useState</span></strong><span class="koboSpan" id="kobo.165.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">useEffect</span></strong><span class="koboSpan" id="kobo.167.1"> hooks, coupled with </span><strong class="bold"><span class="koboSpan" id="kobo.168.1">React</span></strong><span class="koboSpan" id="kobo.169.1"> context. </span><span class="koboSpan" id="kobo.169.2">We</span><a id="_idIndexMarker270"/><span class="koboSpan" id="kobo.170.1"> had to manually update all the necessary pieces of the state whenever the user interacted with our app. </span><span class="koboSpan" id="kobo.170.2">In Redux, we wrote out actions and they passed the information on state updates to the reducers. </span><span class="koboSpan" id="kobo.170.3">We may say the state update happened automatically; we didn’t have to perform any additional tasks after passing the actions. </span><span class="koboSpan" id="kobo.170.4">We did, however, create the action and call it manually. </span><span class="koboSpan" id="kobo.170.5">We also know that </span><strong class="bold"><span class="koboSpan" id="kobo.171.1">Redux</span></strong><span class="koboSpan" id="kobo.172.1"> does not promote deriving values from the application state specifically. </span><span class="koboSpan" id="kobo.172.2">The </span><strong class="bold"><span class="koboSpan" id="kobo.173.1">Redux</span></strong><span class="koboSpan" id="kobo.174.1"> documentation </span><a id="_idIndexMarker271"/><span class="koboSpan" id="kobo.175.1">concentrates more on immutability, the state being the single source of truth, and using </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">plain functions.</span></span></p>
<p><span class="koboSpan" id="kobo.177.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.178.1">MobX</span></strong><span class="koboSpan" id="kobo.179.1"> documentation states that this library is based on transparent functional programming – a concept further explained in the book </span><em class="italic"><span class="koboSpan" id="kobo.180.1">MobX Quick Start Guide</span></em><span class="koboSpan" id="kobo.181.1">, published by </span><strong class="bold"><span class="koboSpan" id="kobo.182.1">Packt Publishing</span></strong><span class="koboSpan" id="kobo.183.1">. </span><span class="koboSpan" id="kobo.183.2">The</span><a id="_idIndexMarker272"/><span class="koboSpan" id="kobo.184.1"> philosophy of </span><strong class="bold"><span class="koboSpan" id="kobo.185.1">MobX</span></strong><span class="koboSpan" id="kobo.186.1"> is to be </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">the following:</span></span></p>
<ol>
<li><strong class="bold"><span class="koboSpan" id="kobo.188.1">Straightforward</span></strong><span class="koboSpan" id="kobo.189.1"> – write minimalistic code and the reactivity system will automatically detect all changes without adding special tools </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">or boilerplate.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.191.1">Effortlessly optimal</span></strong><span class="koboSpan" id="kobo.192.1"> – data changes are tracked at runtime, which means the computations run only when needed and we avoid unnecessary </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">component re-renders.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.194.1">Unopinionated</span></strong><span class="koboSpan" id="kobo.195.1"> – </span><strong class="bold"><span class="koboSpan" id="kobo.196.1">MobX</span></strong><span class="koboSpan" id="kobo.197.1"> can be used with any UI framework, which makes your code decoupled, portable, and </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">easily testable.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.199.1">One more interesting concept in </span><strong class="bold"><span class="koboSpan" id="kobo.200.1">MobX</span></strong><span class="koboSpan" id="kobo.201.1">-land is snapshots. </span><span class="koboSpan" id="kobo.201.2">If you have ever written tests for JavaScript applications, you may have heard the term “snapshot.” </span><strong class="bold"><span class="koboSpan" id="kobo.202.1">MobX</span></strong><span class="koboSpan" id="kobo.203.1"> snapshots are similar to test snapshots. </span><span class="koboSpan" id="kobo.203.2">They save the state of the state tree at a given moment in time. </span><span class="koboSpan" id="kobo.203.3">Looking at </span><strong class="bold"><span class="koboSpan" id="kobo.204.1">MobX</span></strong><span class="koboSpan" id="kobo.205.1"> snapshots can be very handy during debugging or for making performant state updates after fetching data from the server. </span><span class="koboSpan" id="kobo.205.2">If you want to learn more about snapshots and debugging </span><strong class="bold"><span class="koboSpan" id="kobo.206.1">MobX</span></strong><span class="koboSpan" id="kobo.207.1"> states, I invite you to take a look at the </span><a href="http://Egghead.io"><span class="koboSpan" id="kobo.208.1">Egghead.io</span></a><span class="koboSpan" id="kobo.209.1"> course created by </span><em class="italic"><span class="koboSpan" id="kobo.210.1">Michel Westrate</span></em><span class="koboSpan" id="kobo.211.1">, the creator of </span><strong class="bold"><span class="koboSpan" id="kobo.212.1">MobX</span></strong><span class="koboSpan" id="kobo.213.1">; you can find the link in the </span><em class="italic"><span class="koboSpan" id="kobo.214.1">Further reading</span></em><span class="koboSpan" id="kobo.215.1"> section. </span><span class="koboSpan" id="kobo.215.2">As for fetching data from the server, we will look into that in this chapter, in the </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">last section.</span></span></p>
<p><span class="koboSpan" id="kobo.217.1">Now, we have a very theoretical hang on the main concepts of </span><strong class="bold"><span class="koboSpan" id="kobo.218.1">MobX</span></strong><span class="koboSpan" id="kobo.219.1">. </span><span class="koboSpan" id="kobo.219.2">We know it’s different </span><a id="_idIndexMarker273"/><span class="koboSpan" id="kobo.220.1">from </span><strong class="bold"><span class="koboSpan" id="kobo.221.1">Redux</span></strong><span class="koboSpan" id="kobo.222.1">, but you would probably like, my dear reader, to see some code! </span><span class="koboSpan" id="kobo.222.2">Let’s move on</span><a id="_idIndexMarker274"/><span class="koboSpan" id="kobo.223.1"> to configuring </span><strong class="bold"><span class="koboSpan" id="kobo.224.1">MobX</span></strong><span class="koboSpan" id="kobo.225.1"> in the </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">Funbook app.</span></span></p>
<h1 id="_idParaDest-75"><a id="_idTextAnchor076"/><span class="koboSpan" id="kobo.227.1">Configuring MobX in the Funbook app</span></h1>
<p><span class="koboSpan" id="kobo.228.1">As </span><a id="_idIndexMarker275"/><span class="koboSpan" id="kobo.229.1">promised by the </span><strong class="bold"><span class="koboSpan" id="kobo.230.1">MobX</span></strong><span class="koboSpan" id="kobo.231.1"> authors, the boilerplate</span><a id="_idIndexMarker276"/><span class="koboSpan" id="kobo.232.1"> for this library is minimal. </span><span class="koboSpan" id="kobo.232.2">We will have to add three dependencies and a couple of files for everything to work correctly. </span><span class="koboSpan" id="kobo.232.3">Let’s start by adding the necessary dependencies by running the following command in </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">the terminal:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.234.1">
npm install mobx mobx-state-tree –save</span></pre>
<p><span class="koboSpan" id="kobo.235.1">This command will install both </span><strong class="bold"><span class="koboSpan" id="kobo.236.1">MobX</span></strong><span class="koboSpan" id="kobo.237.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.238.1">MobX</span></strong><span class="koboSpan" id="kobo.239.1">-State-Tree. </span><strong class="bold"><span class="koboSpan" id="kobo.240.1">MobX</span></strong><span class="koboSpan" id="kobo.241.1"> is unopinionated about the UI library we want to use it with. </span><span class="koboSpan" id="kobo.241.2">This means that when we decide to use a specific UI library, we will have to find a way to get it to cooperate with </span><strong class="bold"><span class="koboSpan" id="kobo.242.1">MobX</span></strong><span class="koboSpan" id="kobo.243.1">. </span><span class="koboSpan" id="kobo.243.2">It so happens that we have</span><a id="_idIndexMarker277"/><span class="koboSpan" id="kobo.244.1"> chosen </span><strong class="bold"><span class="koboSpan" id="kobo.245.1">React Native</span></strong><span class="koboSpan" id="kobo.246.1"> as our UI library, so we need to add an additional dependency that will make </span><strong class="bold"><span class="koboSpan" id="kobo.247.1">MobX</span></strong><span class="koboSpan" id="kobo.248.1"> cooperate smoothly with React. </span><span class="koboSpan" id="kobo.248.2">Let’s run the </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.250.1">
npm install mobx-react-lite –save</span></pre>
<p><span class="koboSpan" id="kobo.251.1">Now that we have our dependencies, let’s run the </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.253.1">
expo start</span></pre>
<p><span class="koboSpan" id="kobo.254.1">It’s a good idea to check frequently whether our app is still running correctly. </span><span class="koboSpan" id="kobo.254.2">Something as innocent as installing dependencies can sometimes break the app, and we want to know about any issues as soon as </span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">they arise.</span></span></p>
<p><span class="koboSpan" id="kobo.256.1">Assuming everything is working as expected, we can move on to implementing </span><strong class="bold"><span class="koboSpan" id="kobo.257.1">MobX</span></strong><span class="koboSpan" id="kobo.258.1"> instead of </span><strong class="bold"><span class="koboSpan" id="kobo.259.1">React</span></strong><span class="koboSpan" id="kobo.260.1">’s context in the </span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">Funbook app.</span></span></p>
<p><span class="koboSpan" id="kobo.262.1">A little reminder, my dear reader, about the code: the code related to this chapter can be found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">chapter-6</span></strong><span class="koboSpan" id="kobo.264.1"> folder of this book's repository: </span><a href="https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-6"><span class="koboSpan" id="kobo.265.1">https://github.com/PacktPublishing/Simplifying-State-Management-in-React-Native/tree/main/chapter-6</span></a><span class="koboSpan" id="kobo.266.1">. </span><span class="koboSpan" id="kobo.266.2">If you prefer to follow along on your own, please copy the </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">example-app-full</span></strong><span class="koboSpan" id="kobo.268.1"> folder and start working </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">from there.</span></span></p>
<h1 id="_idParaDest-76"><a id="_idTextAnchor077"/><span class="koboSpan" id="kobo.270.1">Using MobX for FavoritedImages</span></h1>
<p><span class="koboSpan" id="kobo.271.1">At the </span><a id="_idIndexMarker278"/><span class="koboSpan" id="kobo.272.1">beginning of this book, I made a choice, my dear reader, to write all </span><a id="_idIndexMarker279"/><span class="koboSpan" id="kobo.273.1">examples in </span><strong class="bold"><span class="koboSpan" id="kobo.274.1">JavaScript</span></strong><span class="koboSpan" id="kobo.275.1">. </span><span class="koboSpan" id="kobo.275.2">I have come to regret that</span><a id="_idIndexMarker280"/><span class="koboSpan" id="kobo.276.1"> decision while working on the examples with </span><strong class="bold"><span class="koboSpan" id="kobo.277.1">MobX</span></strong><span class="koboSpan" id="kobo.278.1">. </span><strong class="bold"><span class="koboSpan" id="kobo.279.1">MobX</span></strong><span class="koboSpan" id="kobo.280.1"> documentation uses </span><strong class="bold"><span class="koboSpan" id="kobo.281.1">TS</span></strong><span class="koboSpan" id="kobo.282.1">, a </span><strong class="bold"><span class="koboSpan" id="kobo.283.1">JavaScript</span></strong><span class="koboSpan" id="kobo.284.1"> superset, which brings many advantages. </span><span class="koboSpan" id="kobo.284.2">I encourage you my dear reader to learn about </span><strong class="bold"><span class="koboSpan" id="kobo.285.1">TS</span></strong><span class="koboSpan" id="kobo.286.1">. </span><span class="koboSpan" id="kobo.286.2">I will not spend any more time on this topic as there are hundreds of hugely valuable TS resources both online and in book form, but I wanted to let you know, in case you read the </span><strong class="bold"><span class="koboSpan" id="kobo.287.1">MobX</span></strong><span class="koboSpan" id="kobo.288.1"> documentation, that the examples look a little different from the code in </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">this book.</span></span></p>
<p><span class="koboSpan" id="kobo.290.1">Now that we have all of this out of the way, let’s get to coding! </span><span class="koboSpan" id="kobo.290.2">We will create a new folder called </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">models</span></strong><span class="koboSpan" id="kobo.292.1"> where we will store data models for our app. </span><span class="koboSpan" id="kobo.292.2">The term “data models” may sound very serious to you, but don’t worry. </span><strong class="bold"><span class="koboSpan" id="kobo.293.1">MobX</span></strong><span class="koboSpan" id="kobo.294.1"> data models are nothing more than </span><strong class="bold"><span class="koboSpan" id="kobo.295.1">JavaScript</span></strong><span class="koboSpan" id="kobo.296.1"> objects with superpowers – by which I mean to say, they look like simple </span><strong class="bold"><span class="koboSpan" id="kobo.297.1">JavaScript</span></strong><span class="koboSpan" id="kobo.298.1"> objects, but they are capable of doing </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">much more!</span></span></p>
<p><span class="koboSpan" id="kobo.300.1">When we have a couple of models ready, we will create one more file for our global </span><strong class="bold"><span class="koboSpan" id="kobo.301.1">MobX</span></strong><span class="koboSpan" id="kobo.302.1">-managed state. </span><span class="koboSpan" id="kobo.302.2">We will call this file </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">store.js</span></strong><span class="koboSpan" id="kobo.304.1"> and we will place all the logic for fetching and managing liked images in </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">this file.</span></span></p>
<p><span class="koboSpan" id="kobo.306.1">Let’s start by creating the simplest model: for the user. </span><span class="koboSpan" id="kobo.306.2">We won’t be implementing actual user state changes, but we’ll just take a quick look at what </span><strong class="bold"><span class="koboSpan" id="kobo.307.1">MobX</span></strong><span class="koboSpan" id="kobo.308.1"> models look like in </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">real-world implementation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.310.1">
// ./models/User.js
import { types } from "mobx-state-tree"
export const User = types.model({
    name: types.string,
    loggedIn: types.boolean,
})</span></pre>
<p><span class="koboSpan" id="kobo.311.1">We only need to import one item: types from </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">mobx-state-tree</span></strong><span class="koboSpan" id="kobo.313.1">. </span><span class="koboSpan" id="kobo.313.2">These types are very powerful tools in </span><strong class="bold"><span class="koboSpan" id="kobo.314.1">MobX</span></strong><span class="koboSpan" id="kobo.315.1">. </span><span class="koboSpan" id="kobo.315.2">You can declare very simple types, such as the ones here – a string and a Boolean – but you can also declare that these values are optional, </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.317.1">
name: types.optional(types.string, "")</span></pre>
<p><span class="koboSpan" id="kobo.318.1">You </span><a id="_idIndexMarker281"/><span class="koboSpan" id="kobo.319.1">can also tell </span><strong class="bold"><span class="koboSpan" id="kobo.320.1">MobX</span></strong><span class="koboSpan" id="kobo.321.1"> what the default values are (that’s what the </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">""</span></strong><span class="koboSpan" id="kobo.323.1"> symbols after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">types.string</span></strong><span class="koboSpan" id="kobo.325.1"> definition in the preceding example signify), or that a given value may be undefined, </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.327.1">
name: types.maybe(types.string)</span></pre>
<p><span class="koboSpan" id="kobo.328.1">There are many more types out there, but we won’t be covering all of them. </span><span class="koboSpan" id="kobo.328.2">However, the MST documentation has a very thorough section on types, and you can find a link to this in the </span><em class="italic"><span class="koboSpan" id="kobo.329.1">Further </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.330.1">reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.331.1"> section.</span></span></p>
<p><span class="koboSpan" id="kobo.332.1">You may have noticed that </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">types.model</span></strong><span class="koboSpan" id="kobo.334.1"> is also at the very beginning of the declaration. </span><span class="koboSpan" id="kobo.334.2">This is what indicates to </span><strong class="bold"><span class="koboSpan" id="kobo.335.1">MobX</span></strong><span class="koboSpan" id="kobo.336.1"> that we are describing the shape of </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">our data.</span></span></p>
<p><span class="koboSpan" id="kobo.338.1">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">Users</span></strong><span class="koboSpan" id="kobo.340.1"> model is very simple. </span><span class="koboSpan" id="kobo.340.2">We used it to get a first glance at </span><strong class="bold"><span class="koboSpan" id="kobo.341.1">MobX</span></strong><span class="koboSpan" id="kobo.342.1"> data models. </span><span class="koboSpan" id="kobo.342.2">Now, it’s time to dig into something more interesting: the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">LikedImages</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.344.1"> model.</span></span></p>
<p><span class="koboSpan" id="kobo.345.1">We start again by importing </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">types</span></strong><span class="koboSpan" id="kobo.347.1"> from </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">mobx-state-tree</span></strong><span class="koboSpan" id="kobo.349.1"> and declaring the shape of a single </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">LikedImage</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.351.1"> item:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.352.1">
// ./models/LikedImages
import { types } from "mobx-state-tree"
const LikedImageItem = types
    .model({
        itemId: types.number,
        authorId: types.number,
        timeStamp: types.string,
        url: types.string,
        likes: types.string,
        conversations: types.string,
    })</span></pre>
<p><span class="koboSpan" id="kobo.353.1">We added a few properties to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">LikedImageItem</span></strong><span class="koboSpan" id="kobo.355.1"> model. </span><span class="koboSpan" id="kobo.355.2">We will use those properties in the future to display the necessary data on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">Favorited</span></strong><span class="koboSpan" id="kobo.357.1"> surface. </span><span class="koboSpan" id="kobo.357.2">It just so happens that these properties are present in the image items fetched from </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">the server.</span></span></p>
<p><span class="koboSpan" id="kobo.359.1">Now </span><a id="_idIndexMarker282"/><span class="koboSpan" id="kobo.360.1">that the single image model has been described, we can move on to setting up the array of identical images and the actions related to </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">this array:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.362.1">
export const LikedImages = types
    .model({
          imageList: types.optional             (types.array(LikedImageItem), []),
    })
    .actions(self =&gt; ({
        addLikedImage(newImage) {
            // will add images here
        },
        removeLikedImage(imageToRemove) {
            // will remove images here
        },
    }))</span></pre>
<p><span class="koboSpan" id="kobo.363.1">Starting from the top, you will notice that we are declaring an object called </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">imageList</span></strong><span class="koboSpan" id="kobo.365.1">, which will store an array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">LikedImageItems</span></strong><span class="koboSpan" id="kobo.367.1">, and will be instantiated with the default value of an </span><span class="No-Break"><span class="koboSpan" id="kobo.368.1">empty array.</span></span></p>
<p><span class="koboSpan" id="kobo.369.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">LikedImageItem</span></strong><span class="koboSpan" id="kobo.371.1"> model doesn’t do anything interesting, so let’s move on to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">LikedImages</span></strong><span class="koboSpan" id="kobo.373.1"> array. </span><span class="koboSpan" id="kobo.373.2">We have to add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">types.model</span></strong><span class="koboSpan" id="kobo.375.1">, where we tell our state manager that this piece of state will be an array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">LikedImageItems</span></strong><span class="koboSpan" id="kobo.377.1"> – and then we add placeholders for the two functions that need to be created: adding and removing </span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">liked images.</span></span></p>
<p><span class="koboSpan" id="kobo.379.1">We can </span><a id="_idIndexMarker283"/><span class="koboSpan" id="kobo.380.1">now continue setting up </span><strong class="bold"><span class="koboSpan" id="kobo.381.1">MobX</span></strong><span class="koboSpan" id="kobo.382.1"> in our app. </span><span class="koboSpan" id="kobo.382.2">First of all, we will set up a store – similarly to </span><strong class="bold"><span class="koboSpan" id="kobo.383.1">Redux</span></strong><span class="koboSpan" id="kobo.384.1">-managed apps, this will be the source of truth for the app. </span><span class="koboSpan" id="kobo.384.2">We will then fetch data from the server and pass it to the app. </span><span class="koboSpan" id="kobo.384.3">Once we have all of that ready, we will look at </span><strong class="bold"><span class="koboSpan" id="kobo.385.1">MobX</span></strong><span class="koboSpan" id="kobo.386.1"> actions – events to which our models will need to respond. </span><span class="koboSpan" id="kobo.386.2">Last, but not least, we’ll learn about deriving data from </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">the state.</span></span></p>
<h2 id="_idParaDest-77"><a id="_idTextAnchor078"/><span class="koboSpan" id="kobo.388.1">Creating the store</span></h2>
<p><span class="koboSpan" id="kobo.389.1">Before </span><a id="_idIndexMarker284"/><span class="koboSpan" id="kobo.390.1">adding and removing images, there’s one more step we need to take. </span><span class="koboSpan" id="kobo.390.2">What do you think, my dear reader? </span><span class="koboSpan" id="kobo.390.3">Yes, we need to hook up </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">the store!</span></span></p>
<p><span class="koboSpan" id="kobo.392.1">Let’s go to our </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">store.js</span></strong><span class="koboSpan" id="kobo.394.1"> file and tell it to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">User</span></strong><span class="koboSpan" id="kobo.396.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">LikedImages</span></strong><span class="koboSpan" id="kobo.398.1"> models. </span><span class="koboSpan" id="kobo.398.2">We’ll start by importing all the necessary files and creating an </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">empty store:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.400.1">
import { types, flow, applySnapshot } from "mobx-state-tree"
import { LikedImages } from "./src/models/LikedImages";
import { User } from './src/models/User';
const RootStore = types
    .model({
        users: User,
        likedImages: LikedImages
    })
export const store = RootStore.create({
    users: {},
    likedImages: {}
})</span></pre>
<p><span class="koboSpan" id="kobo.401.1">As you </span><a id="_idIndexMarker285"/><span class="koboSpan" id="kobo.402.1">may remember, my dear reader, </span><strong class="bold"><span class="koboSpan" id="kobo.403.1">MobX</span></strong><span class="koboSpan" id="kobo.404.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.405.1">MST</span></strong><span class="koboSpan" id="kobo.406.1"> are unopinionated as far as the UI is concerned. </span><span class="koboSpan" id="kobo.406.2">This means we need to look for detailed instructions on how to best integrate </span><strong class="bold"><span class="koboSpan" id="kobo.407.1">MST</span></strong><span class="koboSpan" id="kobo.408.1"> with our </span><strong class="bold"><span class="koboSpan" id="kobo.409.1">React Native</span></strong><span class="koboSpan" id="kobo.410.1"> app. </span><span class="koboSpan" id="kobo.410.2">It just so happens that the documentation recommends using </span><strong class="bold"><span class="koboSpan" id="kobo.411.1">React</span></strong><span class="koboSpan" id="kobo.412.1">’s context to share trees between components. </span><span class="koboSpan" id="kobo.412.2">Our example is small so far and we will concentrate on one tree (the favorited images); however, it’s good to get set up correctly for our app to scale. </span><span class="koboSpan" id="kobo.412.3">And also: we understand context very well from the previous chapters, right? </span><span class="koboSpan" id="kobo.412.4">So, this is going to be a piece </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">of cake:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.414.1">
const RootStoreContext = React.createContext(null);
export const Provider = RootStoreContext.Provider;
export function useMst() {
    const store = useContext(RootStoreContext);
  if (store === null) {
      throw new Error("Store cannot be null,        please add a context provider");
  }
  return store;
}</span></pre>
<p><span class="koboSpan" id="kobo.415.1">In the preceding code, we are creating a very simple context, which will be the vessel for </span><strong class="bold"><span class="koboSpan" id="kobo.416.1">MobX</span></strong><span class="koboSpan" id="kobo.417.1"> state. </span><span class="koboSpan" id="kobo.417.2">We also added a </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">useMst</span></strong><span class="koboSpan" id="kobo.419.1"> hook (as in, “use </span><strong class="bold"><span class="koboSpan" id="kobo.420.1">MobX</span></strong><span class="koboSpan" id="kobo.421.1">-</span><strong class="bold"><span class="koboSpan" id="kobo.422.1">State</span></strong><span class="koboSpan" id="kobo.423.1">-</span><strong class="bold"><span class="koboSpan" id="kobo.424.1">Tree</span></strong><span class="koboSpan" id="kobo.425.1">”) to consume data from the </span><strong class="bold"><span class="koboSpan" id="kobo.426.1">React</span></strong><span class="koboSpan" id="kobo.427.1"> context. </span><span class="koboSpan" id="kobo.427.2">We also added a handy error message in case anything goes wrong. </span><span class="koboSpan" id="kobo.427.3">We start with a context with a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">null</span></strong><span class="koboSpan" id="kobo.429.1"> and we will pass the real store when we add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">&lt;Provider&gt;</span></strong><span class="koboSpan" id="kobo.431.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">our app:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.433.1">
// App.js
//…
Import { Provider, store } from "./store.js"
//…
export default function App() {
//…
  return (
    &lt;SafeAreaProvider&gt;
      //…
          &lt;Provider value={store}&gt;</span></pre>
<p><span class="koboSpan" id="kobo.434.1">Remember</span><a id="_idIndexMarker286"/><span class="koboSpan" id="kobo.435.1"> to wrap your app in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">Provide</span></strong><span class="koboSpan" id="kobo.437.1">r created for the </span><strong class="bold"><span class="koboSpan" id="kobo.438.1">MobX</span></strong><span class="koboSpan" id="kobo.439.1"> state. </span><span class="koboSpan" id="kobo.439.2">This is what is shown in the preceding </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">code snippet.</span></span></p>
<p><span class="koboSpan" id="kobo.441.1">Now that we’ve declared the store and our models, wrapped the app in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">Provider</span></strong><span class="koboSpan" id="kobo.443.1">, and passed the store to this </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">Provider</span></strong><span class="koboSpan" id="kobo.445.1">, we need to pull in the data from </span><strong class="bold"><span class="koboSpan" id="kobo.446.1">MobX</span></strong><span class="koboSpan" id="kobo.447.1"> in the component. </span><span class="koboSpan" id="kobo.447.2">Let’s go to </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">ListOfFavorited.js</span></strong><span class="koboSpan" id="kobo.449.1"> and replace the pure </span><strong class="bold"><span class="koboSpan" id="kobo.450.1">React</span></strong><span class="koboSpan" id="kobo.451.1"> context used previously with </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.452.1">MobX</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.453.1"> data:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.454.1">
import { useMst } from '../../store';
export const ListOfFavorites = ({ navigation }) =&gt; {
  const { likedImages } = useMst();
  //…
  return (
    //…
    &gt;
      &lt;FlatList
        data={likedImages.imageList}
        //…</span></pre>
<p><span class="koboSpan" id="kobo.455.1">This is </span><a id="_idIndexMarker287"/><span class="koboSpan" id="kobo.456.1">going pretty nicely, don’t you think? </span><span class="koboSpan" id="kobo.456.2">We have our </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">ListOfFavoritedImages</span></strong><span class="koboSpan" id="kobo.458.1"> component ready! </span><span class="koboSpan" id="kobo.458.2">Yes? </span><span class="koboSpan" id="kobo.458.3">Let’s check in </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">the app:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer034">
<span class="koboSpan" id="kobo.460.1"><img alt="Figure 6.1 – Favorited surface with no images " src="image/Figure_6.01_B18396.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.461.1">Figure 6.1 – Favorited surface with no images</span></p>
<p><span class="koboSpan" id="kobo.462.1">All we see is a blank screen on the </span><strong class="bold"><span class="koboSpan" id="kobo.463.1">Favorited</span></strong><span class="koboSpan" id="kobo.464.1"> surface. </span><span class="koboSpan" id="kobo.464.2">What happened? </span><span class="koboSpan" id="kobo.464.3">We forgot to fetch the images! </span><span class="koboSpan" id="kobo.464.4">Let’s see how to do that in the </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">next section.</span></span></p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor079"/><span class="koboSpan" id="kobo.466.1">Fetching data</span></h2>
<p><span class="koboSpan" id="kobo.467.1">We </span><a id="_idIndexMarker288"/><span class="koboSpan" id="kobo.468.1">have our image list stored on the server. </span><strong class="bold"><span class="koboSpan" id="kobo.469.1">MobX</span></strong><span class="koboSpan" id="kobo.470.1">-</span><strong class="bold"><span class="koboSpan" id="kobo.471.1">State</span></strong><span class="koboSpan" id="kobo.472.1">-</span><strong class="bold"><span class="koboSpan" id="kobo.473.1">Tree</span></strong><span class="koboSpan" id="kobo.474.1"> proposes</span><a id="_idIndexMarker289"/><span class="koboSpan" id="kobo.475.1"> two ways of fetching asynchronous data, but both are actions. </span><span class="koboSpan" id="kobo.475.2">Let’s create an action in </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">the store:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.477.1">
// ./store.js
const RootStore = types
    .model({
        users: User,
        likedImages: LikedImages
    })
    .actions(self =&gt; ({
        async fetchImages() {
               const response = await fetch(requestBase + "/                 john_doe/likedImages.json");
             const data = await response.json();
             return data;
        }
    }))</span></pre>
<p><span class="koboSpan" id="kobo.478.1">We need an asynchronous function that will do the fetching – we have called it </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">fetchImages</span></strong><span class="koboSpan" id="kobo.480.1">. </span><span class="koboSpan" id="kobo.480.2">This function uses JavaScript’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">fetch</span></strong><span class="koboSpan" id="kobo.482.1"> function and returns data from the server. </span><span class="koboSpan" id="kobo.482.2">Now that we have the data, we need to pass it into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">LikedImages</span></strong><span class="koboSpan" id="kobo.484.1"> model. </span><span class="koboSpan" id="kobo.484.2">Let’s add a function that will do </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">just that:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.486.1">
// ./store.js
const RootStore = types
    //…
    .actions(self =&gt; ({
        setLikedImages(newImages) {
            store.likedImages.imageList.replace(newImages)
        },
        async fetchImages() {
               const response = await fetch(requestBase + "/                 john_doe/likedImages.json");
             const data = await response.json();
             store.setLikedImages(data);
        }
    }))</span></pre>
<p><span class="koboSpan" id="kobo.487.1">The</span><a id="_idIndexMarker290"/><span class="koboSpan" id="kobo.488.1"> newly added </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">setLikedImages</span></strong><span class="koboSpan" id="kobo.490.1"> function takes care of replacing the entire array of images with anything that’s passed to it. </span><span class="koboSpan" id="kobo.490.2">We also adjusted the </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">fetchImages</span></strong><span class="koboSpan" id="kobo.492.1"> function, to pass the result of the fetch </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">into </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">setLikedImages</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.496.1">Now that we have told our app where to get the data from and where to put it, we only need to add WHEN. </span><span class="koboSpan" id="kobo.496.2">We could call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">store.fetchImages()</span></strong><span class="koboSpan" id="kobo.498.1"> function directly from the app when it’s rendered. </span><span class="koboSpan" id="kobo.498.2">However, there is a more elegant solution: using the life cycle hooks provided by </span><strong class="bold"><span class="koboSpan" id="kobo.499.1">MobX</span></strong><span class="koboSpan" id="kobo.500.1">. </span><span class="koboSpan" id="kobo.500.2">One of those hooks is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">afterCreate</span></strong><span class="koboSpan" id="kobo.502.1">, and it’s called, as you may expect, after a given store is created. </span><span class="koboSpan" id="kobo.502.2">Let’s add this hook to the list of actions in </span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">our store:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.504.1">
// ./store.js
const RootStore = types
    //…
    .actions(self =&gt; ({
        afterCreate() {
            self.fetchImages();
        },
        //…
    }))</span></pre>
<p><span class="koboSpan" id="kobo.505.1">Ta-da! </span><span class="koboSpan" id="kobo.505.2">Our app will know what to fetch (the data from the server), where to put it once it’s fetched (in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">LikedImages</span></strong><span class="koboSpan" id="kobo.507.1"> array), and when to do so (when the store is created). </span><span class="koboSpan" id="kobo.507.2">If you check the app now, you should see the list of images </span><span class="No-Break"><span class="koboSpan" id="kobo.508.1">rendered correctly.</span></span></p>
<p><span class="koboSpan" id="kobo.509.1">The </span><a id="_idIndexMarker291"/><span class="koboSpan" id="kobo.510.1">code we wrote works fine, but we can improve it further. </span><strong class="bold"><span class="koboSpan" id="kobo.511.1">MobX</span></strong><span class="koboSpan" id="kobo.512.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.513.1">MST</span></strong><span class="koboSpan" id="kobo.514.1"> offer us optimized solutions for writing async logic. </span><span class="koboSpan" id="kobo.514.2">Their solution is called generator functions. </span><span class="koboSpan" id="kobo.514.3">This may sound scary at first, but don’t worry. </span><span class="koboSpan" id="kobo.514.4">All we need to do is import a couple of utilities from MST and change the syntax of our </span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">function slightly:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.516.1">
// ./store.js
 import { types, flow, applySnapshot } from "mobx-state-tree"
//…
    .actions(self =&gt; ({
        afterCreate() {
            self.fetchImages();
        },
        fetchImages: flow(function* fetchImages() {
              const response = yield fetch(requestBase + "/                john_doe/likedImages.json");
              applySnapshot(self.likedImages.imageList,                yield response.json());
        })</span></pre>
<p><span class="koboSpan" id="kobo.517.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">fetchImages</span></strong><span class="koboSpan" id="kobo.519.1"> function in this version uses a generator. </span><span class="koboSpan" id="kobo.519.2">For </span><strong class="bold"><span class="koboSpan" id="kobo.520.1">MobX</span></strong><span class="koboSpan" id="kobo.521.1"> to understand that this is a generator, we wrap it with </span><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">flow</span></strong><span class="koboSpan" id="kobo.523.1"> and use </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">*</span></strong><span class="koboSpan" id="kobo.525.1"> with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">function</span></strong><span class="koboSpan" id="kobo.527.1"> keyword. </span><span class="koboSpan" id="kobo.527.2">Then, we replace </span><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">async</span></strong><span class="koboSpan" id="kobo.529.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">await</span></strong><span class="koboSpan" id="kobo.531.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">yield</span></strong><span class="koboSpan" id="kobo.533.1">, which pauses the function and returns </span><span class="No-Break"><span class="koboSpan" id="kobo.534.1">a </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">Promise</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.537.1">As you may have noticed, we removed the </span><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">setLikedImages</span></strong><span class="koboSpan" id="kobo.539.1"> action in this version of the code. </span><span class="koboSpan" id="kobo.539.2">It is not needed anymore, as we’re using another </span><strong class="bold"><span class="koboSpan" id="kobo.540.1">MST</span></strong><span class="koboSpan" id="kobo.541.1"> utility called </span><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">applySnapshot</span></strong><span class="koboSpan" id="kobo.543.1">. </span><span class="koboSpan" id="kobo.543.2">I’ve mentioned briefly before what snapshots in </span><strong class="bold"><span class="koboSpan" id="kobo.544.1">MobX</span></strong><span class="koboSpan" id="kobo.545.1"> are: they are </span><strong class="bold"><span class="koboSpan" id="kobo.546.1">JavaScript</span></strong><span class="koboSpan" id="kobo.547.1"> objects representing the state tree at any given moment. </span><span class="koboSpan" id="kobo.547.2">Using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">applySnapshot</span></strong><span class="koboSpan" id="kobo.549.1"> utility here, we are making sure the update is optimized, as only the necessary data </span><span class="No-Break"><span class="koboSpan" id="kobo.550.1">is updated.</span></span></p>
<p><span class="koboSpan" id="kobo.551.1">This version </span><a id="_idIndexMarker292"/><span class="koboSpan" id="kobo.552.1">of the code produces the same result as the previous one. </span><span class="koboSpan" id="kobo.552.2">However, it is written in fewer lines of code and uses practices recommended by the authors of </span><strong class="bold"><span class="koboSpan" id="kobo.553.1">MobX</span></strong><span class="koboSpan" id="kobo.554.1">. </span><span class="koboSpan" id="kobo.554.2">It’s a good idea to write code in the recommended way – it helps us avoid bugs and performance issues. </span><span class="koboSpan" id="kobo.554.3">We surely know less about </span><strong class="bold"><span class="koboSpan" id="kobo.555.1">MobX</span></strong><span class="koboSpan" id="kobo.556.1"> than its author and maintainers, so let’s follow </span><span class="No-Break"><span class="koboSpan" id="kobo.557.1">their lead.</span></span></p>
<p><span class="koboSpan" id="kobo.558.1">Okay – we’re making great progress here. </span><span class="koboSpan" id="kobo.558.2">We have the data models and we have wired them up into a store. </span><span class="koboSpan" id="kobo.558.3">We passed the store into our app thanks to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">Provider</span></strong><span class="koboSpan" id="kobo.560.1">, and we fetched the initial data. </span><span class="koboSpan" id="kobo.560.2">The only thing left is to add actions and make this app </span><span class="No-Break"><span class="koboSpan" id="kobo.561.1">come alive!</span></span></p>
<h2 id="_idParaDest-79"><a id="_idTextAnchor080"/><span class="koboSpan" id="kobo.562.1">Adding actions</span></h2>
<p><span class="koboSpan" id="kobo.563.1">Let’s go</span><a id="_idIndexMarker293"/><span class="koboSpan" id="kobo.564.1"> back to our </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">LikedImages</span></strong><span class="koboSpan" id="kobo.566.1"> model and add some real code for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">addImages</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.568.1"> action:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.569.1">
.actions(self =&gt; ({
        addLikedImage(newImage) {
            self.imageList.unshift(newImage)
        },</span></pre>
<p><span class="koboSpan" id="kobo.570.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">actions</span></strong><span class="koboSpan" id="kobo.572.1"> function itself holds a reference to the entire array of liked images – this is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">self</span></strong><span class="koboSpan" id="kobo.574.1"> keyword. </span><span class="koboSpan" id="kobo.574.2">In the first iteration of the </span><strong class="bold"><span class="koboSpan" id="kobo.575.1">MobX</span></strong><span class="koboSpan" id="kobo.576.1"> library, you could find uses of a known </span><strong class="bold"><span class="koboSpan" id="kobo.577.1">JavaScript</span></strong><span class="koboSpan" id="kobo.578.1"> keyword: </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">this</span></strong><span class="koboSpan" id="kobo.580.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">this</span></strong><span class="koboSpan" id="kobo.582.1"> can unfortunately be confusing for many developers, which is why </span><strong class="bold"><span class="koboSpan" id="kobo.583.1">MobX</span></strong><span class="koboSpan" id="kobo.584.1"> introduced </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">self</span></strong><span class="koboSpan" id="kobo.586.1">. </span><span class="koboSpan" id="kobo.586.2">Plus, </span><strong class="bold"><span class="koboSpan" id="kobo.587.1">MobX</span></strong><span class="koboSpan" id="kobo.588.1"> realizes that if you’re doing an action on a model, you probably need access to that model, so it serves us what </span><span class="No-Break"><span class="koboSpan" id="kobo.589.1">we need!</span></span></p>
<p><span class="koboSpan" id="kobo.590.1">Now that we have a reference to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.591.1">LikedImages</span></strong><span class="koboSpan" id="kobo.592.1"> array, we want to add a new item to that array. </span><span class="koboSpan" id="kobo.592.2">We could use </span><strong class="source-inline"><span class="koboSpan" id="kobo.593.1">.push()</span></strong><span class="koboSpan" id="kobo.594.1">, but I chose to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">.unshift()</span></strong><span class="koboSpan" id="kobo.596.1">, which will push the new item to the top of the array and effectively display it at the top of the list of images on the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">Favorites</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.598.1"> surface.</span></span></p>
<p><span class="koboSpan" id="kobo.599.1">The </span><a id="_idIndexMarker294"/><span class="koboSpan" id="kobo.600.1">place where we would like to call this action is </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">ImageDetailsModal</span></strong><span class="koboSpan" id="kobo.602.1">, because we can “like” images from within this modal. </span><span class="koboSpan" id="kobo.602.2">This modal has a heart button. </span><span class="koboSpan" id="kobo.602.3">When it’s tapped, we would like the image to be added to our user’s array of </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">liked images:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.604.1">
// ./surfaces/ImageDetailsModal.js
export const ImageDetailsModal = ({ navigation, route }) =&gt; {
  const { likedImages } = useMst();
//…
&lt;Pressable
        onPress={() =&gt; {
            likedImages.addLikedImage(route.params.imageItem)
        }}
      &gt;</span></pre>
<p><span class="koboSpan" id="kobo.605.1">Beautiful! </span><span class="koboSpan" id="kobo.605.2">Now, when we tap this pressable heart icon on an image from the main feed, we should see the image added on the Favorited surface, right? </span><span class="koboSpan" id="kobo.605.3">Unfortunately, not yet. </span><strong class="bold"><span class="koboSpan" id="kobo.606.1">MobX</span></strong><span class="koboSpan" id="kobo.607.1"> doesn’t have a lot of boilerplate, but we do need to tell it what data to observe. </span><span class="koboSpan" id="kobo.607.2">We have to add an </span><strong class="source-inline"><span class="koboSpan" id="kobo.608.1">observer</span></strong><span class="koboSpan" id="kobo.609.1"> wrapper to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">ListOfFavorited</span></strong><span class="koboSpan" id="kobo.611.1"> component. </span><span class="koboSpan" id="kobo.611.2">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">observer</span></strong><span class="koboSpan" id="kobo.613.1"> wrapper will re-render our component when it detects a change in the </span><span class="No-Break"><span class="koboSpan" id="kobo.614.1">data models:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.615.1">
// ./components/ListOfFavorited
import { useMst } from '../../store';
import { observer } from "mobx-react-lite"
export const ListOfFavorites = observer(({ navigation }) =&gt; {
  const { likedImages } = useMst();</span></pre>
<p><span class="koboSpan" id="kobo.616.1">And </span><a id="_idIndexMarker295"/><span class="koboSpan" id="kobo.617.1">now we’re almost done! </span><span class="koboSpan" id="kobo.617.2">There’s only one small catch left. </span><span class="koboSpan" id="kobo.617.3">When you like an image and then go back to the Favorited surface, you probably won’t see the new image until you start scrolling. </span><span class="koboSpan" id="kobo.617.4">This is not the functionality we’re looking for. </span><span class="koboSpan" id="kobo.617.5">We would like to see the newly liked image appear immediately. </span><span class="koboSpan" id="kobo.617.6">The issue here is </span><strong class="bold"><span class="koboSpan" id="kobo.618.1">React Native</span></strong><span class="koboSpan" id="kobo.619.1">’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">FlatList</span></strong><span class="koboSpan" id="kobo.621.1"> component, which accepts simple arrays, but we’re trying to pass a special sort of array from our </span><strong class="bold"><span class="koboSpan" id="kobo.622.1">MobX</span></strong><span class="koboSpan" id="kobo.623.1"> model: an </span><span class="No-Break"><span class="koboSpan" id="kobo.624.1">observable array.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.625.1">Making FlatList play nice with MobX</span></p>
<p class="callout"><span class="koboSpan" id="kobo.626.1">In order for our </span><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">FlatList</span></strong><span class="koboSpan" id="kobo.628.1"> to</span><a id="_idIndexMarker296"/><span class="koboSpan" id="kobo.629.1"> render the updated data correctly, we need to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">values</span></strong><span class="koboSpan" id="kobo.631.1"> utility provided </span><span class="No-Break"><span class="koboSpan" id="kobo.632.1">by MobX.</span></span></p>
<p><span class="koboSpan" id="kobo.633.1">Here’s the code of </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">FlatList</span></strong><span class="koboSpan" id="kobo.635.1"> in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">ListOfFavorited</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.637.1"> component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.638.1">
Import { values } from "mobx"
&lt;FlatList
        data={values(likedImages.imageList)}</span></pre>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">Values</span></strong><span class="koboSpan" id="kobo.640.1"> is a </span><a id="_idIndexMarker297"/><span class="koboSpan" id="kobo.641.1">collection utility provided by the MST library that returns all values in the collection as an array, which is exactly what </span><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">FlatList</span></strong><span class="koboSpan" id="kobo.643.1"> is expecting. </span><span class="koboSpan" id="kobo.643.2">You can read more about collection utilities in </span><strong class="bold"><span class="koboSpan" id="kobo.644.1">MobX</span></strong><span class="koboSpan" id="kobo.645.1"> in their documentation, and you can find a link in the </span><em class="italic"><span class="koboSpan" id="kobo.646.1">Further </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.647.1">reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.648.1"> section.</span></span></p>
<p><span class="koboSpan" id="kobo.649.1">Now, everything should be working as expected. </span><span class="koboSpan" id="kobo.649.2">Make sure to check your phone or phone simulator frequently. </span><span class="koboSpan" id="kobo.649.3">The sooner you discover errors and issues, the easier they are </span><span class="No-Break"><span class="koboSpan" id="kobo.650.1">to debug.</span></span></p>
<h2 id="_idParaDest-80"><a id="_idTextAnchor081"/><span class="koboSpan" id="kobo.651.1">Deriving data from state</span></h2>
<p><span class="koboSpan" id="kobo.652.1">I’ve </span><a id="_idIndexMarker298"/><span class="koboSpan" id="kobo.653.1">mentioned the fact that </span><strong class="bold"><span class="koboSpan" id="kobo.654.1">MobX</span></strong><span class="koboSpan" id="kobo.655.1">’s authors state that anything that can be derived from state should be. </span><span class="koboSpan" id="kobo.655.2">We’ll get a chance to derive some </span><span class="No-Break"><span class="koboSpan" id="kobo.656.1">data now.</span></span></p>
<p><span class="koboSpan" id="kobo.657.1">We would like to know which images are liked and which are not so that we can successfully add them to the list of liked images or avoid duplicating them. </span><span class="koboSpan" id="kobo.657.2">Deriving data from the state is done on the data models </span><a id="_idIndexMarker299"/><span class="koboSpan" id="kobo.658.1">through </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">views</span></strong><span class="koboSpan" id="kobo.660.1">. </span><span class="koboSpan" id="kobo.660.2">I’ve decided to add this following view to the store because we are working in a constrained environment, and I want to keep things simple. </span><span class="koboSpan" id="kobo.660.3">Here’s the </span><strong class="bold"><span class="koboSpan" id="kobo.661.1">view</span></strong><span class="koboSpan" id="kobo.662.1"> that I have added to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">RootStore</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.664.1"> model:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.665.1">
const RootStore = types
 //…
    .views(self =&gt; ({
        getIsImageLiked(itemId) {
            return values(self.likedImages?.imageList).filter(
                      (favoritedImg) =&gt; favoritedImg.itemId ===                        itemId
                  ).length &gt; 0;
        }
    }))</span></pre>
<p><span class="koboSpan" id="kobo.666.1">As with </span><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">actions</span></strong><span class="koboSpan" id="kobo.668.1">, you will notice the </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">self</span></strong><span class="koboSpan" id="kobo.670.1"> keyword here. </span><span class="koboSpan" id="kobo.670.2">It holds a reference to the current data model for </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">easy access.</span></span></p>
<p><span class="koboSpan" id="kobo.672.1">I created a </span><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">getIsImageLiked</span></strong><span class="koboSpan" id="kobo.674.1"> function by passing it an image ID. </span><span class="koboSpan" id="kobo.674.2">We then filter over the entire liked images array to check whether that image </span><span class="No-Break"><span class="koboSpan" id="kobo.675.1">ID exists.</span></span></p>
<p><span class="koboSpan" id="kobo.676.1">Sure, this is not the most efficient way to check a user’s liked images in a social media app, which could potentially be hundreds upon hundreds of images – but we do want to see what these views are about, and this is a great chance to </span><span class="No-Break"><span class="koboSpan" id="kobo.677.1">do so.</span></span></p>
<p><span class="koboSpan" id="kobo.678.1">Let’s go back to </span><strong class="source-inline"><span class="koboSpan" id="kobo.679.1">ImageDetailsModal</span></strong><span class="koboSpan" id="kobo.680.1">, where we would like to check whether a given image is liked or not and then display the appropriate icon (an empty heart for images that are not liked and a filled-in heart for liked images) and pass the appropriate function (either adding or removing it from the liked </span><span class="No-Break"><span class="koboSpan" id="kobo.681.1">images array).</span></span></p>
<p><span class="koboSpan" id="kobo.682.1">If you </span><a id="_idIndexMarker300"/><span class="koboSpan" id="kobo.683.1">copied your code from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.684.1">example-app-full</span></strong><span class="koboSpan" id="kobo.685.1"> folder, you’ll find </span><strong class="source-inline"><span class="koboSpan" id="kobo.686.1">useEffect</span></strong><span class="koboSpan" id="kobo.687.1"> in this component, which takes care of checking this exact thing. </span><span class="koboSpan" id="kobo.687.2">Let’s try simply replacing the old React context values with the new values from the </span><strong class="bold"><span class="koboSpan" id="kobo.688.1">MobX</span></strong><span class="koboSpan" id="kobo.689.1"> store. </span><span class="koboSpan" id="kobo.689.2">Does the code work? </span><span class="koboSpan" id="kobo.689.3">Go ahead and check, I’ll be waiting </span><span class="No-Break"><span class="koboSpan" id="kobo.690.1">right here.</span></span></p>
<p><span class="koboSpan" id="kobo.691.1">Something is not quite right, right? </span><span class="koboSpan" id="kobo.691.2">The code does not work as expected. </span><span class="koboSpan" id="kobo.691.3">To be honest, it does not work at all. </span><span class="koboSpan" id="kobo.691.4">If you tried to work out step by step what was happening, and what should be happening between </span><strong class="bold"><span class="koboSpan" id="kobo.692.1">MobX</span></strong><span class="koboSpan" id="kobo.693.1"> tree updates and </span><strong class="bold"><span class="koboSpan" id="kobo.694.1">React’s</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.695.1">useEffect</span></strong><span class="koboSpan" id="kobo.696.1"> changes, you may have found that it’s not that simple to figure out. </span><span class="koboSpan" id="kobo.696.2">The precedence of side effects can be very complicated, and it gets even more complicated in bigger apps – and that is why we use </span><strong class="bold"><span class="koboSpan" id="kobo.697.1">MobX’s</span></strong><span class="koboSpan" id="kobo.698.1"> dedicated </span><span class="No-Break"><span class="koboSpan" id="kobo.699.1">tools: views.</span></span></p>
<p><span class="koboSpan" id="kobo.700.1">Going back to our code, we can go ahead and remove </span><strong class="source-inline"><span class="koboSpan" id="kobo.701.1">useEffect</span></strong><span class="koboSpan" id="kobo.702.1"> completely. </span><span class="koboSpan" id="kobo.702.2">We’re taking care of the filtering in </span><strong class="source-inline"><span class="koboSpan" id="kobo.703.1">views</span></strong><span class="koboSpan" id="kobo.704.1">, which is added to the store. </span><span class="koboSpan" id="kobo.704.2">Let’s use </span><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">import</span></strong><span class="koboSpan" id="kobo.706.1"> from the context hook and use the values provided </span><span class="No-Break"><span class="koboSpan" id="kobo.707.1">by </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.708.1">MobX</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.709.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.710.1">
  export const ImageDetailsModal = observer(({ navigation,    route }) =&gt; {
  const { likedImages, getIsImageLiked } = useMst();
    const isCurrentImageLiked = getIsImageLiked       (route.params.imageItem.itemId)</span></pre>
<p><span class="koboSpan" id="kobo.711.1">Don’t forget to add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.712.1">observer</span></strong><span class="koboSpan" id="kobo.713.1"> wrapper for our component to observe changes </span><span class="No-Break"><span class="koboSpan" id="kobo.714.1">in data!</span></span></p>
<p><span class="koboSpan" id="kobo.715.1">The heart icon is working as expected now – it looks filled in when an image has been liked on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.716.1">Favorited</span></strong><span class="koboSpan" id="kobo.717.1"> surface and gets filled in when an un-liked image is </span><span class="No-Break"><span class="koboSpan" id="kobo.718.1">newly liked.</span></span></p>
<p><span class="koboSpan" id="kobo.719.1">We have gone over creating data models and setting up the store, actions, and views in our </span><strong class="bold"><span class="koboSpan" id="kobo.720.1">MobX</span></strong><span class="koboSpan" id="kobo.721.1">-managed version of the Funbook app. </span><span class="koboSpan" id="kobo.721.2">By now, we have an app with </span><strong class="bold"><span class="koboSpan" id="kobo.722.1">MobX</span></strong><span class="koboSpan" id="kobo.723.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.724.1">MobX</span></strong><span class="koboSpan" id="kobo.725.1">-</span><strong class="bold"><span class="koboSpan" id="kobo.726.1">State</span></strong><span class="koboSpan" id="kobo.727.1">-</span><strong class="bold"><span class="koboSpan" id="kobo.728.1">Tree</span></strong><span class="koboSpan" id="kobo.729.1"> as state managers. </span><span class="koboSpan" id="kobo.729.2">We’re fetching and mutating data; we are even deriving data from our state! </span><span class="koboSpan" id="kobo.729.3">There is still a lot to do in order to convert all of the states and functionalities of the app to </span><strong class="bold"><span class="koboSpan" id="kobo.730.1">MobX</span></strong><span class="koboSpan" id="kobo.731.1">. </span><span class="koboSpan" id="kobo.731.2">Feel free to play around on your own, or check out the </span><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">chapter-6-complete</span></strong><span class="koboSpan" id="kobo.733.1"> folder if you would just like to see the </span><span class="No-Break"><span class="koboSpan" id="kobo.734.1">complete app.</span></span></p>
<h1 id="_idParaDest-81"><a id="_idTextAnchor082"/><span class="koboSpan" id="kobo.735.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.736.1">We have just gone over the main ideas and the implementation of </span><strong class="bold"><span class="koboSpan" id="kobo.737.1">MobX</span></strong><span class="koboSpan" id="kobo.738.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.739.1">MobX</span></strong><span class="koboSpan" id="kobo.740.1">-</span><strong class="bold"><span class="koboSpan" id="kobo.741.1">State</span></strong><span class="koboSpan" id="kobo.742.1">-</span><strong class="bold"><span class="koboSpan" id="kobo.743.1">Tree</span></strong><span class="koboSpan" id="kobo.744.1"> in the Funbook app. </span><strong class="bold"><span class="koboSpan" id="kobo.745.1">MobX</span></strong><span class="koboSpan" id="kobo.746.1"> may not be as popular as </span><strong class="bold"><span class="koboSpan" id="kobo.747.1">Redux</span></strong><span class="koboSpan" id="kobo.748.1"> in the </span><strong class="bold"><span class="koboSpan" id="kobo.749.1">React</span></strong><span class="koboSpan" id="kobo.750.1"> ecosystem, but it does hold a very important place, nonetheless. </span><strong class="bold"><span class="koboSpan" id="kobo.751.1">MobX</span></strong><span class="koboSpan" id="kobo.752.1"> presents a different way of looking at the state than Redux does and a very different way of managing it. </span><span class="koboSpan" id="kobo.752.2">We created data models and attached actions to them. </span><span class="koboSpan" id="kobo.752.3">If you are a developer trying to understand an existing app for the first time, having the data and actions in one place may be very helpful to understand what is going on more quickly. </span><strong class="bold"><span class="koboSpan" id="kobo.753.1">MobX</span></strong><span class="koboSpan" id="kobo.754.1"> takes this state centralization one step further by introducing views. </span><span class="koboSpan" id="kobo.754.2">We have all the tools necessary for creating and managing a state accessibly from the very same place where we declare the shape of the state. </span><span class="koboSpan" id="kobo.754.3">The last step is to add </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">observer</span></strong><span class="koboSpan" id="kobo.756.1"> wrappers to the components that need to be aware of state changes and then we have a very nice </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.757.1">MobX</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.758.1">-managed app.</span></span></p>
<p><span class="koboSpan" id="kobo.759.1">It’s great to know how you can manage states in a </span><strong class="bold"><span class="koboSpan" id="kobo.760.1">React Native</span></strong><span class="koboSpan" id="kobo.761.1"> app. </span><span class="koboSpan" id="kobo.761.2">It’s even better to know a few different ways to do so – and if you like different options, you’ll be happy to know that we will talk about </span><strong class="bold"><span class="koboSpan" id="kobo.762.1">XState</span></strong><span class="koboSpan" id="kobo.763.1"> in the </span><span class="No-Break"><span class="koboSpan" id="kobo.764.1">next chapter!</span></span></p>
<h1 id="_idParaDest-82"><a id="_idTextAnchor083"/><span class="koboSpan" id="kobo.765.1">Further reading</span></h1>
<ul>
<li><a href="https://mobx.js.org/README.html"><span class="koboSpan" id="kobo.766.1">https://mobx.js.org/README.html</span></a><span class="koboSpan" id="kobo.767.1">: </span><span class="No-Break"><span class="koboSpan" id="kobo.768.1">MobX documentation.</span></span></li>
<li><a href="https://mobx-state-tree.js.org/intro/welcome"><span class="No-Break"><span class="koboSpan" id="kobo.769.1">https://mobx-state-tree.js.org/intro/welcome</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.770.1">: MobX-State-Tree.</span></span></li>
<li><a href="https://egghead.io/courses/manage-application-state-with-mobx-state-tree"><span class="koboSpan" id="kobo.771.1">https://egghead.io/courses/manage-application-state-with-mobx-state-tree</span></a><span class="koboSpan" id="kobo.772.1">: </span><em class="italic"><span class="koboSpan" id="kobo.773.1">Manage Application State </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.774.1">with Mobx-state-tree.</span></em></span></li>
<li><a href="https://www.packtpub.com/product/mobx-quick-start-guide/9781789344837"><span class="koboSpan" id="kobo.775.1">https://www.packtpub.com/product/mobx-quick-start-guide/9781789344837</span></a><span class="koboSpan" id="kobo.776.1">: </span><em class="italic"><span class="koboSpan" id="kobo.777.1">MobX Quick </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.778.1">Start Guide</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.779.1">.</span></span></li>
<li><a href="https://github.com/infinitered/ignite"><span class="koboSpan" id="kobo.780.1">https://github.com/infinitered/ignite</span></a><span class="koboSpan" id="kobo.781.1">: Ignite – React Native boilerplate by </span><span class="No-Break"><span class="koboSpan" id="kobo.782.1">Infinite Red.</span></span></li>
<li><a href="https://reactnativeradio.com/episodes/rnr-241-redux-toolkit-vs-mobx-state-tree-showdown"><span class="koboSpan" id="kobo.783.1">https://reactnativeradio.com/episodes/rnr-241-redux-toolkit-vs-mobx-state-tree-showdown</span></a><span class="koboSpan" id="kobo.784.1">: Redux Toolkit </span><span class="No-Break"><span class="koboSpan" id="kobo.785.1">versus MobX-State-Tree.</span></span></li>
<li><a href="https://www.loom.com/share/9e3afe0547824e42bada06191e891ae1"><span class="koboSpan" id="kobo.786.1">https://www.loom.com/share/9e3afe0547824e42bada06191e891ae1</span></a><span class="koboSpan" id="kobo.787.1">: </span><em class="italic"><span class="koboSpan" id="kobo.788.1">Intro to MobX-State-Tree and MobX-React</span></em><span class="koboSpan" id="kobo.789.1"> by </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.790.1">Jamon Holmgren</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.791.1">.</span></span></li>
<li><a href="https://mobx-state-tree.js.org/overview/types"><span class="koboSpan" id="kobo.792.1">https://mobx-state-tree.js.org/overview/types</span></a><span class="koboSpan" id="kobo.793.1">: </span><span class="No-Break"><span class="koboSpan" id="kobo.794.1">MST types.</span></span></li>
<li><a href="https://mobx.js.org/collection-utilities.html"><span class="koboSpan" id="kobo.795.1">https://mobx.js.org/collection-utilities.html</span></a><span class="koboSpan" id="kobo.796.1">: MobX </span><span class="No-Break"><span class="koboSpan" id="kobo.797.1">collection utilities.</span></span></li>
</ul>
</div>
</body></html>