- en: RxJS Advanced
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RxJS 高级
- en: We finished the last chapter that taught us more about what operators exist
    and how to utilize them effectively. Armed with this knowledge, we will now go
    into this subject in more depth. We will go from learning about what parts exist,
    to actually understanding the nature of RxJS. Knowing the nature of RxJS involves
    understanding more about what makes it tick. To uncover this, we need to cover
    topics such as what the differences are between hot, warm, and cold Observables;
    knowing about Subjects and what they are good for; and the sometimes ignored topic
    of Schedulers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了上一章，更多地教会了我们存在哪些操作符以及如何有效利用它们。拥有了这些知识，我们现在将更深入地涉足这个主题。我们将从了解存在哪些各个部分，到真正理解
    RxJS 的本质。了解 RxJS 的本质就意味着更多地了解其运作机制。为了揭示这一点，我们需要涵盖诸如热、温和和冷 Observables 之间的区别是什么；了解
    Subjects 以及它们适用的场景；以及有时被忽视的调度器等主题。
- en: There are also other aspects of working with Observables that we want to cover,
    namely, how to deal with errors and how to test your Observables.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有其他与处理 Observables 相关的方面要讨论，即，如何处理错误以及如何测试你的 Observables。
- en: 'In this chapter, you will learn about:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你将学到：
- en: Hot, cold, and warm Observables
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 热、冷和温和的 Observables
- en: 'Subjects: how they differ from Observables, and when to use them'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Subject：它们与 Observables 的区别以及何时使用它们
- en: Pipeable operators, a recent addition to the RxJS library, and how they affect
    how you compose Observables
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可管道的操作符，RxJS 库的最新添加，以及它们对组合 Observables 的影响
- en: Marble testing, the testing machinery in place that helps you with testing your
    Observables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弹珠测试，有助于测试你的 Observables 的测试机制
- en: Hot, cold, and warm Observables
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 热、冷和温和的 Observables
- en: 'There are hot, cold, and warm Observables. What do we actually mean by that?
    For starters, let''s say that most things you will deal with are cold Observables.
    Not helping? If we say that cold Observables are lazy, does that help? No? OK,
    let''s talk about Promises for a second. Promises are hot. They are hot because
    when we execute their code, it happens straight away. Let''s see an example of
    that:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 有热、冷和温和的 Observables。我们到底是什么意思呢？首先，让我们说你将处理的大多数事情都是冷 Observables。还是不明白？如果我们说冷
    Observables 是懒惰的，这样有帮助吗？不？好吧，让我们先来谈谈 Promise。Promise 是热的。当我们执行它们的代码时，它们立刻就会执行。让我们来看一个例子：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you come from a non-RxJS background, you will most likely, at this point,
    think: OK, yes, that''s what I expected. This is the point we are trying to make,
    though: Calling `getData()` makes your code run straight away. This differs from
    RxJS in the sense that similar RxJS code will actually not run until there is
    a listener/subscriber that cares about the result. RxJS answers the old philosophical
    question: Does a tree make a sound when it falls in the forest if no one is there
    to listen? In the case of Promises, it does. In the case of an Observable, it
    doesn''t. Let''s clarify what we just said with a similar code example using RxJS
    and Observables:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自非 RxJS 背景，你可能在这一点上会想：好吧，是的，这是我预期的。尽管如此，我们要说明的是：调用 `getData()` 会使你的代码立即运行。这与
    RxJS 不同，因为类似的 RxJS 代码实际上不会运行，直到有一个关心结果的监听器/订阅者。RxJS 回答了一个古老的哲学问题：如果有人不在那里听，树在森林中倒下时会不会发出声音？在
    Promise 的情况下，会。在 Observable 的情况下，不会。让我们用一个类似的 RxJS 和 Observables 的代码例子来澄清我们刚才说的话：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In RxJS, code like this is considered cold, or lazy. We need a subscriber for
    something to actually happen. We can add a subscriber like so:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RxJS 中，像这样的代码被认为是冷，或者懒的。我们需要一个订阅者才能真正发生一些事情。我们可以像这样添加一个订阅者：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This is a major difference in how Observables behave versus Promises, and it''s
    important to know. This is a cold Observable; so, what is a hot Observable? It
    would be easy to think, at this point, that a hot Observable is something that
    executes straight away; there is more to it than that, however. One of the official
    explanations of what a hot Observable is, is that anything that subscribes to
    it will share the Producer with other Subscribers. The Producer is what spouts
    out values internally inside the Observable. This means that the data is shared.
    Let''s look at a cold Observable subscription scenario and contrast that with
    a hot Observable subscription scenario. We will start with the cold scenario:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Observable与Promises的行为差异的一个重大区别，这一点非常重要。这是一个冷Observable；那么，什么是热Observable呢？此时很容易认为，热Observable是立即执行的东西；然而，实际情况并非如此。关于热Observable的一个官方解释是，任何订阅它的东西都将与其他订阅者分享生产者。生产者就是在Observable内部内部喷出值的东西。这意味着数据被共享。让我们来看看冷Observable订阅方案，并将其与热Observable订阅方案进行对比。我们将从冷情况开始：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, we have three different subscribers that receive their
    own copy of emitted values. The values start from the beginning, every time we
    add a new subscriber. That might be expected when looking at the two first subscribers.
    As for the third one, it is added as a subscriber after two seconds. Yes, even
    that subscriber receives its own set of values. The explanation is that each subscriber
    receives its own Producer upon subscription.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们有三个不同的订阅者，它们各自接收到发出的值的副本。每次添加新的订阅者时，值都从头开始。当我们看前两个订阅者时可能会预料到这一点。至于第三个订阅者，它是在两秒后添加的。是的，即使该订阅者也会收到自己的一组值。解释是每个订阅者在订阅时都会收到自己的生产者。
- en: 'With hot Observables, there is just one producer, which means the scenario
    above will play out differently. Let''s write down the code for a hot Observable
    scenario:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于热Observable，只有一个生产者，这意味着上述情况会有所不同。让我们写一个热Observable场景的代码：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The reason the third subscriber is outputting only the value `2` is that the
    other values have been emitted already. The third subscriber wasn't around to
    see that happen. On the third value emit, it is around, and that is the reason
    it receives the value `2`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个订阅者仅输出值`2`的原因是其他值已经被发出。第三个订阅者并没有看到这一情况发生。在第三个值发出时，它出现了，这就是它收到值`2`的原因。
- en: Making a stream hot
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使一个流变热
- en: 'This `hotStream$`, how can it be created? You did say that most of the streams
    being created are cold? We have an operator for doing just that, or two operators,
    in reality. We can make a stream go from cold to hot by using the operators `publish()` and `connect()`.
    Let''s start with a cold Observable and add the mentioned operators, like so:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`hotStream$`，它是如何创建的呢？你曾经说过大多数流都是冷的？实际上，我们有一个操作符来做到这一点，或者说实际上有两个操作符。我们可以使用操作符`publish()`和`connect()`使流从冷变热。让我们从冷Observable开始，然后添加上述操作符，就像这样：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can see from the preceding code that we create our Observable and instruct
    it to emit values, one value per second. Furthermore, it should stop after five
    emitted values. We then call the operator `publish()`. This puts us in ready mode.
    We then set up a few subscriptions to happen after two seconds and three seconds,
    respectively. This is followed by us calling `connect()` on the stream. This will
    make the stream go from hot to cold. Thereby, our stream starts emitting values,
    and any subscriber, whenever it starts subscribing, will share a producer with
    any future subscriber. Lastly, we add a subscriber to happen straight after the
    call to `connect()`. Let''s show what the output becomes with the following screenshot:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述代码中我们可以看到，我们创建了Observable，并指示其发出值，每秒一个值。此外，应该在发出五个值后停止。然后我们调用操作符`publish()`。这将使我们处于就绪模式。然后我们设置了几个订阅分别在两秒后和三秒后发生。接着我们在流上调用`connect()`。这将使流从热到冷。因此，我们的流开始发出值，每当它开始订阅时，任何订阅者将与任何未来的订阅者共享一个生产者。最后，我们在调用`connect()`后立即添加了一个订阅者。让我们看看以下屏幕截图的输出：
- en: '![](img/a082e1cf-166a-438d-b3ee-2e08ec543b11.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a082e1cf-166a-438d-b3ee-2e08ec543b11.png)'
- en: Our first subscriber is emitting values after one second. Our second subscriber
    kicks in after yet another second. This time its value is `1`; it has missed out
    on the first value. After yet another second, the third subscriber has been attached.
    The first value that subscriber emits is `2`; it missed out on the two first values.
    We clearly see how the operators `publish()` and `connect()` help to create our
    hot Observable, but also how it matters when you start subscribing to a hot Observable.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个订阅者在一秒后开始发出数值。第二个订阅者又在另一秒后开始发出数值。这时它的值是`1`；它错过了第一个值。又过了一秒，第三个订阅者被添加了进来。这个订阅者发出的第一个值是`2`；它错过了前两个值。我们清楚地看到了`publish()`和`connect()`操作符是如何帮助我们创建热
    Observable 的，以及订阅热 Observable 的时间是多么重要。
- en: Why on earth would I want a hot Observable? What's the area for application?
    Well, imagine you have a live stream, a football game that you stream to many
    subscribers/viewers. They wouldn't want to see what happens from the first minute
    of the game when they arrive late, but, rather, where the match is right now,
    at the time of subscription (when they park themselves in front of the television).
    So, there definitely exist cases where hot Observables are the way to go.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 到底为什么我想要一个热 Observable？应用领域是什么？嗯，想象一下你有一个直播流，一个足球比赛，你把它流到很多订阅者/观众那里。他们不想看到比赛的第一分钟发生了什么，因为他们来晚了，而是想要看到比赛现在的情况，也就是订阅时的情况（当他们坐在电视机前）。所以，肯定存在热
    Observable 适用的情况。
- en: Warm streams
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 温和的流
- en: 'So far, we have been describing and discussing cold Observables and hot Observables,
    but there is a third kind: the warm Observable. A warm Observable can be thought
    of as being created as a cold Observable, but turning into a hot Observable under
    certain conditions. Let''s look at such a case by introducing the `refCount()` operator:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止，我们一直在描述和讨论冷 Observable 和热 Observable，但还有第三种：温和的 Observable。温 Observable
    可以被认为是作为冷 Observable 创建的，但在某些条件下变成了热 Observable。让我们通过介绍`refCount()`操作符来看一个这样的案例：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'OK, so we started to use the operator `publish()`, and it looks like we are
    about to use our `connect()` operator and that we have a hot Observable, right?
    Well, yes, but instead of calling `connect()`, we call `refCount()`. This operator
    will warm our Observable up so that when the first subscriber arrives, it will
    act like a cold Observable. OK? That just sounds like a cold Observable, right?
    Let''s have a look at the output first:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 好，所以我们开始使用操作符`publish()`，看起来我们即将使用`connect()`操作符并且我们有了热 Observable，对吗？是的，但是我们没有调用`connect()`，而是调用了`refCount()`。这个操作符会让我们的
    Observable 变得温和，这样当第一个订阅者到来时，它将表现得像一个冷 Observable。明白吗？那听起来就像一个冷 Observable，对吗？让我们先看一下输出：
- en: '![](img/36b34610-a52e-40ab-af36-aa2922f4d198.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/36b34610-a52e-40ab-af36-aa2922f4d198.png)'
- en: 'To answer the preceding question, yes, it''s correct that it just behaves like
    a cold Observable; we aren''t missing out on any emitted values. The interesting
    thing happens when we get a second subscriber. Let''s add that second subscriber
    and see what the effects are:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 回答前面的问题，是的，它确实就像一个冷 Observable；我们不会错过任何已发出的数值。有趣的是当我们加入第二个订阅者时会发生什么。我们来添加第二个订阅者，并看看效果如何：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Our second subscriber is added; now, let''s have a look at what the result
    is:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了第二个订阅者；现在，我们来看一下结果：
- en: '![](img/ba5c64f7-982a-4e83-9d58-f52164b99678.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ba5c64f7-982a-4e83-9d58-f52164b99678.png)'
- en: What we can see from the results above is that the first subscriber is alone
    in receiving the number `0`. When the second subscriber arrives, its first value
    is `1`, which proves the stream has gone from acting like a cold Observable to
    a hot Observable.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的结果中，我们可以看到第一个订阅者独自接收了数值`0`。当第二个订阅者到来时，它的第一个值是`1`，证明了这个流已经从表现得像冷 Observable
    变成了热 Observable。
- en: 'There is another way we can do warm Observables, and that is through using
    the `share()` operator. The `share()` operator can be seen as more of a smart
    operator that allows our Observable to go from cold to hot, depending on the situation.
    That can be a really great idea sometimes. So, there are the following situations
    for Observables:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种方式可以创建温和的 Observable，那就是使用`share()`操作符。`share()`操作符可以被看作是一个更加智能的操作符，根据情况允许我们的
    Observable 从冷到热转变。在某些情况下，这可能是一个非常好的主意。所以，观察到以下关于 Observable 的情况：
- en: Created as a hot Observable; the stream hasn't completed, and none of the subscribers
    are more than one
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为热 Observable 创建；流没有完成，且没有订阅者超过一个
- en: Falls back into being a cold Observable; any previous subscription has had time
    to end before a new subscription arrives
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回退为冷 Observable；在新的订阅到来之前，任何先前的订阅都已经结束
- en: Created as a cold Observable; the Observable itself has had time to complete
    before the subscription happens
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一个冷 Observable 创建；Observable 本身在订阅发生之前已经完成
- en: 'Let''s try to show in code how the first bullet can happen:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试用代码展示第一个要点是如何发生的：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding code describes a situation where we defined a stream with a subscription
    that happens straight away. The second subscription happens after one second.
    Now, according to the definition of the `share()` operator, this means that the
    stream will be created as a cold Observable, but will, at the time of the second
    subscriber, be turned into a hot Observable, as there is a pre-existing subscriber
    and the stream has yet to complete. Let''s inspect our output to verify that this
    is the case:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码描述了这样一种情况：我们定义了一个立即发生订阅的流。第二个订阅将在一秒之后发生。现在，根据 `share()` 操作符的定义，这意味着该流将被创建为冷
    Observable，但在第二个订阅者出现时，将成为热 Observable，因为存在先前的订阅者，且流尚未完成。让我们检查我们的输出，验证是否是这种情况：
- en: '![](img/0c775f85-2d7d-4277-baee-b245cf676176.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0c775f85-2d7d-4277-baee-b245cf676176.png)'
- en: The first subscriber seems to be clearly alone in the values it gets. When the
    second subscriber arrives, it seems to share the producer, as it doesn't start
    from zero, but, rather, it starts listening where the first subscriber is.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个订阅者似乎显然独自获取值。当第二个订阅者到来时，它似乎与生产者共享，因为它不是从零开始，而是从第一个订阅者开始监听。
- en: Subjects
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主题
- en: 'We are used to using Observables in a certain way. We construct them from something
    and we start listening to values that they emit. There is usually very little
    we can do to affect what is being emitted after the point of creation. Sure, we
    can change it and filter it, but it is next to impossible to add more to our `Observable`
    unless we merge it with another stream. Let''s have a look at when we are really
    in control of what is being emitted when it comes to Observables, using the `create()` operator:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们习惯以某种方式使用 Observable。我们从某处构造它们并开始监听它们发出的值。通常我们几乎无法在创建之后影响正在发出的数据。当然，我们可以更改和过滤它，但除非与另一个流合并，否则在
    Observable 中几乎不可能添加更多内容。让我们看看当我们真正控制正在发出的内容时，使用 `create()` 操作符何时适用于 Observable：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We see the Observable acting as a wrapper around the thing that really emits
    our values, the Observer. In our Observer instance, the Observer is calling `next()`,
    with a parameter to emit values – values that we listen to in our `subscribe()` method.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到 Observable 充当着一个包装器，围绕着真正发出值的对象 Observer。在我们的 Observer 实例中，Observer 调用
    `next()`，带着一个参数来发出值，这些值我们在 `subscribe()` 方法中监听到。
- en: 'This section is about the Subject. The Subject differs from the Observable
    in that it can affect the content of the stream after its creation. Let''s have
    a look at just that with the following piece of code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 本节是关于 Subject 的。Subject 与 Observable 的不同之处在于它可以在创建后影响流的内容。让我们用下面这段代码具体看一下：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The first thing we notice is how we just call the constructor instead of using
    a factory method like `create()` or `from()` or similar, as we do on an Observable.
    The second thing we notice is how we subscribe to it on the second line, and only
    on the last line do we emit values by calling `next()`. Why is the code written
    in this order? Well, if we didn''t write it this way and have the `next()` call
    happen as the second thing, our subscription wouldn''t be there, and the value
    would have been emitted straight away. We know two things for sure, though: we
    are calling `next()`, and we are calling `subscribe()`, which makes `Subject`
    a double nature. We did mention another thing the `Subject` was capable of: changing
    the stream after creation. Our call to `next()` is literally doing that. Let''s
    add a few more calls so we ensure we really get the idea:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到的第一件事是，我们只需调用构造函数，而不是像在 Observable 中那样使用工厂方法如 `create()` 或 `from()` 或类似的方法。我们注意到的第二件事是我们在第二行订阅它，并且只有在最后一行调用
    `next()` 才会发出值。为什么代码要按照这个顺序编写呢？嗯，如果我们不按照这种方式编写代码，并且在第二个调用 `next()` 的时候发生，我们的订阅变量将不存在，值会立即被发出。尽管我们确定了两件事：我们调用了
    `next()`，我们调用了 `subscribe()`，这使 `Subject` 具有双重性质。我们确实提到了 `Subject` 能够完成另一件事情：在创建后改变流。我们的调用
    `next()` 就是在做这件事。让我们再增加一些调用，以确保我们真正理解这个概念：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As we stated before, all the calls we make to the `next()` method enable us
    to affect the stream; we see in our `subscribe()` method that every call to `next()` leads
    to the `subscribe()` being hit, or, technically, the first function we pass into
    it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所述，我们对`next()`方法的所有调用都使我们能够影响流；在我们的`subscribe()`方法中，我们看到对`next()`的每次调用都会导致`subscribe()`被调用，或者说，技术上来说，我们传递给它的第一个函数被调用。
- en: Using Subject for cascading lists
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用主题（Subject）来进行级联列表操作
- en: 'So, what''s the point? Why should we use Subjects over Observables? That''s
    actually a quite deep question. There are many ways of solving most streaming-related
    problems; problems where it is tempting to use a Subject can often be solved through
    some other way. Let''s have a look at what you could be using it for, though.
    Let''s talk about cascading drop-down lists. What we mean by that is that we want
    to know what restaurants exist in a city. Imagine, therefore, that we have a drop-down
    list that allows us to select what country we are interested in. Once we select
    a country, we should select the city we are interested in from a drop-down list
    of cities. Thereafter, we get to select from a list of restaurants, and, finally,
    pick the restaurant that interests us. In the markup, it most likely looks like
    this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，问题是什么？为什么我们应该使用主题而不是可观察对象？这实际上是一个相当深奥的问题。对于大多数与流相关的问题，有许多解决方法；那些诱人使用主题的问题通常可以通过其他方式解决。不过，让我们看看你可以使用它来做什么。让我们谈谈级联下拉列表。我们所说的是，我们想知道一个城市中存在哪些餐馆。因此，想象一下，我们有一个下拉列表，允许我们选择我们感兴趣的国家。一旦我们选择了一个国家，我们应该从城市下拉列表中选择我们感兴趣的城市。此后，我们可以从餐馆列表中选择，并最终选择我们感兴趣的餐馆。在标记中，它很可能看起来像这样：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'At the start of the application, we haven''t selected anything, and the only
    drop-down list that is selected is the first one, and it is filled with countries.
    Imagine that we therefore set up the following code in JavaScript:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序开始时，我们还没有选择任何内容，唯一被选择的下拉列表是第一个，其中填充了国家。假设我们因此在JavaScript中设置了以下代码：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'At this point, we have established that we want to listen to the selected events
    of each drop-down list, and we want, in the cases of countries or cities droplist,
    filter the upcoming droplist. Say we select a specific country then we want to
    repopulate/filter the cities droplist so that it only shows cities for the selected
    country. For the restaurant drop-down list, we want to perform a booking based
    on our restaurant selection. Sounds pretty simple, right? We need some subscribers.
    The cities drop-down list needs to listen to changes in the countries drop-down
    list. So we add that to our code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已经确定我们想要监听每个下拉列表的选定事件，并且在国家或城市下拉列表的情况下，我们想要筛选即将出现的下拉列表。假设我们选择了一个特定的国家，那么我们想要重新填充/筛选城市下拉列表，以便它只显示选定国家的城市。对于餐厅下拉列表，我们想要根据我们选择的餐厅进行预订。听起来相当简单，对吧？我们需要一些订阅者。城市下拉列表需要监听国家下拉列表的变化。因此，我们将其添加到我们的代码中：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: So, here, we have a behavior of performing an AJAX request when we select a
    country; we get a filtered list of cities, and we introduce the new subject instance `cities$`. 
    We call the `next()` method on it with our filtered cities as a parameter. Finally,
    we listen to changes to the `cities$` stream by calling the `subscribe()` method
    on the stream. As you can see, when data arrives, we rebuild our cities drop-down
    list there.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这里，我们有一个在选择国家时执行AJAX请求的行为；我们获得一个经过筛选的城市列表，并引入新的主题实例`cities$`。我们对其调用`next()`方法，并将我们筛选后的城市作为参数传递。最后，通过在流上调用`subscribe()`方法来监听对`cities$`流的更改。正如你所见，当数据到达时，我们在那里重建我们的城市下拉列表。
- en: 'We realize that our next step is to react to changes from us doing a selection
    in the cities drop-down list. So, let''s set that up:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们意识到我们的下一步是要对我们在城市下拉列表中进行选择的变化做出反应。所以，让我们设置好：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding code, we added some code to react to a selection being made
    in our cities drop-down list. We also added some code to listen to changes in
    the `restaurants$` stream, which finally led to our restaurants drop-down list
    being repopulated. The last step is to listen to changes on us selecting a restaurant
    in the restaurants drop-down list. What should happen here is up to you, dear
    reader. A suggestion is that we query some API for the selected restaurant''s
    opening hours, or its menu. Use your creativity. We will leave you with some final
    subscription code, though:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们添加了一些代码来反应我们在城市下拉列表中做出选择。我们还添加了一些代码来监听`restaurants$`流的变化，最终导致我们的餐馆下拉列表重新填充。最后一步是监听我们在餐馆下拉列表中选择餐馆时的变化。在这里应该发生的事情由你来决定，亲爱的读者。建议是我们为所选餐厅的营业时间或菜单查询一些API。发挥你的创造力。不过，我们将留给你一些最终的订阅代码：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This became a quite long code example, and it should be said that this is not
    the best way of solving a problem like this, but it does demonstrate how a Subject
    works: it can add value to the stream when it wants, and it can be subscribed
    to.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这变成了一个相当长的代码示例，应该说这不是解决这个问题的最佳方式，但它确实演示了Subject的工作原理：它可以在需要时向流中添加值，并且可以被订阅。
- en: BehaviorSubject
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BehaviorSubject
- en: 'So far, we have been looking at the default type of Subject, and we have uncovered
    a little of its secrets. However, there are many more types of Subjects. One such
    interesting type of Subject is the `BehaviorSubject`. So, why do we need a `BehaviorSubject`,
    and for what? Well, when dealing with a default Subject, we are able to add values
    to the stream, as well as subscribe to the stream. The `BehaviorSubject` gives
    us some added capabilities, in the form of:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在研究默认类型的Subject，并揭示了一点它的秘密。然而，还有许多种类型的Subject。其中一种有趣的类型是`BehaviorSubject`。所以，我们为什么需要`BehaviorSubject`，以及用来做什么呢？嗯，当处理默认的Subject时，我们能够向流中添加值，并且订阅该流。`BehaviorSubject`在形式上给了我们一些额外的能力，例如：
- en: A starter value, which is great if we are able to show something to the UI while
    waiting for an AJAX call to finish
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个初始值，如果我们能够在等待AJAX调用完成时向UI展示一些内容，那就太棒了
- en: We can query on the latest value; in some situations, it is interesting to know
    what the last emitted value was
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以查询最新的数值；在某些情况下，了解上次发出的值是很有意思的。
- en: 'To address the first bullet, let''s write some code and showcase this capability:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决第一点，让我们写一些代码来展示这种能力：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ReplaySubject
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ReplaySubject
- en: 'With a normal Subject, it matters when we start subscribing. If we start emitting
    values before our subscription is set up, those values are simply lost. If we
    have a `BehaviorSubject`, we have a somewhat better scenario. Even if we are late
    in subscribing, so a value has already been emitted, the very last emitted value
    is still possible to gain access to. Then the following question arises: What
    if two or more values are emitted before a subscription happens and we care about
    those values – what then?'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于普通的Subject，我们订阅开始的时机很重要。如果我们在设置订阅之前开始发出值，那些值就会被简单地丢失。如果我们有`BehaviorSubject`，情况会稍微好一些。即使我们在订阅之后才开始发出值，最后发出的值仍然可以获取。然后，接下来的问题是：如果在订阅之前发出了两个或更多个值，并且我们关心这些值
    - 那么怎么办呢？
- en: 'Let''s illustrate this scenario and see what happens with a Subject and `BehaviorSubject`,
    respectively:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来说明这种情况，并分别看看Subject和`BehaviorSubject`会发生什么：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'What we can see from the preceding code is that Subject is not a good candidate
    if we care about values prior to us subscribing. The `BehaviorSubject` constructors
    are slightly better for that scenario, but if we really care about prior values,
    and a lot of them, then we should have a look at the `ReplaySubject`.  The `ReplaySubject`
    has the ability to specify two things: a buffer size and a window size. A buffer
    size is simply the amount of values it should remember from the past, and the
    window size specifies for how long it should remember them for. Let us demonstrate
    this in code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述代码中可以看到，如果我们关心订阅之前的值，Subject并不是一个好的选择。`BehaviorSubject`构造函数在这种情况下略微好一些，但如果我们真的关心之前的值，并且有很多值，那么我们应该看看`ReplaySubject`。`ReplaySubject`有能力指定两件事：缓冲区大小和窗口大小。缓冲区大小简单地表示它应该记住过去的值的数量，窗口大小指定它应该记住它们多久。让我们在代码中演示一下：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the preceding code, we can see how we emit `2` and `3`, that is, the two
    latest emitted values. This is due to the fact that we specify the buffer size
    in the `ReplaySubject` constructor to be 2\. The only value we loose out on is
    1\. Had we, on the other hand, specified a 3 in our constructor, all three values
    would have reached the subscriber. So much for the buffer size and how that works;
    what about the window size property? Let''s illustrate how that works with the
    following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们发出了`2`和`3`，也就是最近发出的两个值。这是因为我们在`ReplaySubject`构造函数中指定了缓冲区大小为
    2。我们唯一丢失的值是`1`。反之，如果我们在构造函数中指定了一个 3，所有三个值都将到达订阅者。这就是缓冲区大小及其工作方式；那么窗口大小属性又是如何工作的呢？让我们用以下代码来说明它的工作方式：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we specify the window size as 2,000 milliseconds; that is how long the
    values should be held in the buffer. We can see below that we delay the creation
    of our subscription to occur after 2,010 milliseconds. The end result of this
    is that no values will be emitted, as the buffer will have been emptied before
    the subscription has time to occur. A higher value of the window size would have
    fixed this issue.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将窗口大小指定为 2,000 毫秒；这就是值应该保留在缓冲区中的时间。我们可以看到在 2,010 毫秒后我们延迟了订阅的创建。这样做的最终结果是在订阅发生之前不会发出任何值，因为缓冲区在订阅发生之前就已经被清空了。增加窗口大小的值会解决这个问题。
- en: AsyncSubject
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AsyncSubject
- en: 'The `AsyncSubject` has a capacity of one, which means we can emit a ton of
    values, but only the latest one is something that is stored. It isn''t really
    lost, either, but you won''t see it unless you complete the stream. Let''s look
    at a piece of code that illustrates just this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncSubject` 的容量为 1，这意味着我们可以发出大量的值，但只有最新的值是被存储的。它并不是真的丢失了，但除非您完成流，否则您看不到它。让我们看一个说明这种情况的代码片段：'
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Earlier, we had fours values being emitted, but nothing seems to reach the
    subscriber. At this point, we don''t know whether this is because it just acts
    like a subject and throws away all emitted values that happen before a subscription
    or not. Let''s therefore call the `complete()` method and see how that plays out:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，我们发出了四个值，但似乎没有到达订阅者。在这一点上，我们不知道这是因为它只是像一个主题一样丢弃在订阅之前发出的所有值，还是因为其他原因。因此，让我们调用`complete()`方法并看看它的表现是如何的：
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This will emit a `4` due to the fact that `AsyncSubject` only remembers the
    last value and we are calling the `complete()` method, thereby signaling the completion
    of the stream.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这将会发出一个`4`，因为`AsyncSubject`只会记住最后一个值，并且我们调用了`complete()`方法，从而表示流的结束。
- en: Error handling
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理
- en: Error handling is a very big topic. It is an area that is easy to underestimate.
    Normally, when coding, we could be led to believe we just need to do certain things,
    such as ensure we don't have syntax errors or runtime errors. With streams, we
    mostly think of runtime errors. The question is, how should we act when an error
    occurs? Should we pretend like it rains and just throw the error away? Should
    we hope for a different outcome if we try the same code some time in the future,
    or should we maybe just give up when a certain type of error exists? Let's try
    to collect our thoughts and look at the different error approaches that exist
    within RxJS.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理是一个非常重要的话题。这是一个容易被忽视的领域。通常在编码时，我们可能会认为我们只需要做一些事情，比如确保我们没有语法错误或运行时错误。对于流，我们大多数时候会考虑运行时错误。问题是，当出现错误时我们应该如何处理呢？我们是应该假装像下雨一样把错误抛开吗？还是我们应该希望在未来的某个时候尝试相同的代码会得到不同的结果，或者当某种类型的错误存在时我们应该放弃？让我们试着集中我们的思想，并看看在
    RxJS 中存在的不同错误处理方法。
- en: Catch and continue
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获并继续
- en: 'Sooner or later, we will have a stream that will throw an error. Let''s see
    what that can look like:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 迟早会有一个流会抛出一个错误。让我们看看可能是什么样子：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the preceding code, we set up a scenario where we first emit a value, followed
    by emitting an error. The first value is captured in our first callback in our
    subscribe method. The second emitted thing, the error, is captured by our error
    callback. The third emitted value does not get emitted to our subscriber because
    our stream has been interrupted by the error. There is something we can do here,
    and that is to use the `catch()` operator. Let''s apply that to our stream and
    see what happens:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们设置了一个场景，我们首先发出一个值，然后发出一个错误。第一个值被我们的订阅方法的第一个回调捕获了。第二个发出的东西，也就是错误，被我们的错误回调捕获了。第三个发出的值没有传递给我们的订阅者，因为我们的流已经被错误中断。在这里我们可以做一些事情，那就是使用`catch()`运算符。让我们将它应用到我们的流上并看看会发生什么：
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, we capture our error with the `catch()` operator. In the `catch()` operator,
    we take our error and emit it as a normal Observable using the `of()` operator.
    What happens to the `2` we emit, though? Still no luck with that one. The `catch()` operator
    is able to take our error and turn it into a normal emitted value; instead of
    an error, we don't get all the values from the stream.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们用 `catch()` 运算符捕获了我们的错误。在 `catch()` 运算符中，我们获取我们的错误并使用 `of()` 运算符将其作为普通
    Observable 发出。然而我们发出的 `2` 发生了什么？对于这个，还是没有运气。`catch()` 运算符能够获取我们的错误并将其转换为正常发出的值；而不是一个错误，我们从流中并未获取到所有的值。
- en: 'Let''s have a look at a scenario when we are dealing with multiple streams:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个处理多个流的场景：
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the scenario above, we merge three streams. The first stream emits the number
    `1` and nothing else gets emitted. This is due to our second stream tearing everything
    down, as it emits an error. Let''s try to apply our newfound `catch()` operator
    and see what happens:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的场景中，我们合并了三个流。第一个流发出数字`1`，没有其他内容被发出。这是因为我们的第二个流将所有内容破坏，因为它发出了一个错误。让我们尝试应用我们新发现的
    `catch()` 运算符并看看会发生什么：
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We run the above code and we notice that the `1` is emitted, the error is emitted
    as a normal value, and, finally, even the `2` is emitted. Our conclusion here
    is that it is a good idea to apply a `catch()` operator to a stream before it
    is being merged with our streams.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行上面的代码，注意到 `1` 被发出，错误被作为正常值发出，最后，甚至 `2` 也被发出了。我们的结论是在将我们的流与其他流合并之前，应用 `catch()`
    运算符是一个好主意。
- en: As before, we can also conclude that the `catch()` operator is able to stop
    the stream from just erroring out, but that other values that would have been
    emitted after the error are effectively lost.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，我们也可以得出结论，`catch()` 运算符能够阻止流仅仅出错，但是在错误之后会发出的其他值实际上是丢失的。
- en: Ignoring the error
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 忽略错误
- en: 'As we saw in the former section, the `catch()` operator does a good job of
    ensuring that a stream that errors out doesn''t cause any problems when being
    merged with another stream. The `catch()` operator enables us to take the error,
    investigate it, and create a new Observable that will emit a value as though nothing
    happened. Sometimes, however, you don''t want to even deal with streams that error
    out. For such a scenario, there is a different operator, called `onErrorResumeNext()`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的部分看到的，`catch()` 运算符很好地确保了出错的流在与另一个流合并时不会造成任何问题。`catch()` 运算符使我们能够获取错误，调查它，并创建一个新的
    Observable ，它将发出一个值，就好像什么都没发生一样。然而，有时候，您甚至不想使用出错的流。对于这种情况，有一个名为 `onErrorResumeNext()`
    的不同运算符：
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The implication of using the `onErrorResumeNext()` operator is that the second
    stream, the one that emits an error, gets completely ignored, and the values `1`
    and `2` get emitted. This is a very nice operator to use if your scenario is only
    about caring for the streams that do not error out.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`onErrorResumeNext()` 运算符的含义是第二个流，即发出错误的流，完全被忽略，发出值`1`和`2`。如果您的场景仅涉及不出错的流，这是一个非常好的运算符。
- en: Retry
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重试
- en: 'There are different reasons why you would want to retry a stream. It''s easier
    to imagine why you would want to if your stream is dealing with AJAX calls. Network
    connections may be unreliable at times with the local network you are on, or the
    service you are trying to hit may be temporarily down for some reason. Regardless
    of the reason, you have a situation where hitting that endpoint will some of the
    time reply with an answer, and some of the time return a 401 error. What we are
    describing here is the business case for adding retry logic to your streams. Let''s
    have a look at a stream designed to fail:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的原因，你会想要重试一个流。如果您的流处理 AJAX 调用，你就更容易想象为什么要这样做。有时候，局域网上的网络连接可能不可靠，或者您尝试访问的服务可能因某些原因暂时不可用。无论原因如何，您都会遇到这样一种情况，即
    hitting 那个端点有时候会回答一个答案，有时候会返回一个 401 错误。我们在这里描述的是向您的流添加重试逻辑的业务场景。让我们看一个设计为失败的流：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output of the code above is the value `1` being emitted four times, followed
    by our error. What happens is that our streams'' values are retried three times
    before the error callback is hit in the subscribe. Using the `retry()` operator
    delays when the error is actually treated as an error. The preceding example doesn''t
    make sense to retry, though, as the error will always occur. Therefore, let''s
    take a better example – an AJAX call where the network connection may come and
    go:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以上代码的输出是值`1`被发出了四次，然后是我们的错误。发生的情况是我们的流值在订阅中错误回调被命中之前重试了三次。使用`retry()`操作符延迟了什么时候错误实际被视为错误。然而，上面的例子不合理的地方在于重试是没有意义的，因为错误总是会发生。因此，让我们举个更好的例子
    – 一个网络连接可能出现忽然消失的AJAX调用：
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here, we are attempting an AJAX request towards a file that doesn''t seem to
    exist. Having a look at the console, we are faced with the following result:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在尝试向一个似乎不存在的文件发送一个AJAX请求。看看控制台，我们面临以下结果：
- en: '![](img/e4df4109-8dd2-41ee-bbf7-5a7a99832bd4.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e4df4109-8dd2-41ee-bbf7-5a7a99832bd4.png)'
- en: 'What we see in the above logging are four failed AJAX requests that lead to
    an error. We have essentially just switched our simple stream to a more credible
    AJAX request stream, with the same behavior. Should the file suddenly start to
    exist, we may have a scenario with two failed attempts and one successful attempt.
    Our approach has a flaw, though: we retry our AJAX attempts far too often. If
    we are actually dealing with an intermittent network connection, we need to have
    some kind of delay between attempts. It is reasonable to set a delay between attempts
    of at least 30 seconds or more. We can accomplish that by using a slightly different
    retry operator that takes milliseconds rather than a number of attempts as an
    argument. It looks like the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述日志中我们看到了四次失败的AJAX请求，导致了一个错误。我们基本上仅仅是将我们的简单流切换为了一个更可信的AJAX请求流，具有相同的行为。如果文件突然开始存在，可能会出现两次失败尝试和一次成功尝试的情况。然而，我们的方法有一个缺陷：我们进行AJAX尝试的次数太多了。如果我们实际上正在处理间歇性的网络连接，我们需要在尝试之间设置一定的延迟。合理的做法是在尝试之间设置至少30秒或更长的延迟。我们可以通过使用一种稍微不同的重试操作符来实现这一点，它以毫秒而不是尝试次数作为参数。它看起来像下面这样：
- en: '[PRE30]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: What we do here is use the operator `retryWhen()`. The `retryWhen()` operator's
    mission in life is to return a stream. At this point, you can manipulate the stream
    it returns by appending a `.delay()` operator that takes a number of milliseconds.
    The result from doing so is that it will retry the AJAX call for all eternity,
    which may not be what you want.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用了操作符`retryWhen()`。`retryWhen()`操作符的使命是返回一个流。在这一点上，你可以通过添加一个`.delay()`操作符来延迟它返回的流，以便能够操纵它。这样做的结果是，它将永远重试AJAX调用，这可能不是你想要的。
- en: Advanced Retry
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级重试
- en: 'What we most likely want is to combine the delay between retry attempts with
    being able to specify how many times we want to retry the stream. Let''s have
    a look at how we can accomplish that:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最有可能想要的是将重试尝试之间的延迟与能够指定我们想要重试流的次数结合起来。让我们看看如何实现这一点：
- en: '[PRE31]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The interesting part here is that we use the operator `.take()`. We specify
    the number of emitted values we want from this inner Observable. We have now accomplished
    a nice approach in which we are able to control the number of retries and the
    delay between retries. There is an aspect to this that we haven''t tried, namely,
    how we want all the retries to end when it finally gives up. In the preceding
    code, the stream just completes after the stream is retried after *x* number of
    times with no successful result. However, we may want the stream to error out
    instead. We can accomplish this by just adding an operator to the code, like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有趣的部分是我们使用了操作符`.take()`。我们指定了我们想要从这个内部Observable中发出的值的数量。我们现在实现了一种不错的方法，可以控制重试次数和重试之间的延迟。还有一个方面我们还没有尝试到，即当最终放弃时我们想要重试全部重试的方式。在之前的代码中，当流在尝试了*x*次后没有成功结果时，流就会直接完成。然而，我们可能希望流出现错误。我们只需在代码中添加一个操作符，就可以实现这一点，像这样：
- en: '[PRE32]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, we are adding a `concat()` operator that adds a stream that just fails.
    So we are guaranteed, after three failed attempts, to have an error happen. This
    is usually a better approach than having the stream silently complete after *x*
    number of failed attempts.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个`concat()`操作符，它将一个仅仅会失败的流添加进来。因此，在三次失败尝试之后一定会发生一个错误。这通常比在*x*次失败尝试之后默默地完成流更好。
- en: This isn't a perfect approach, though; imagine that you want to investigate
    what type of error you get back. In the case of AJAX requests being made, it matters
    whether we get a 400-something error or a 500-something error back as HTTP status
    code. They mean different things.  With 500 errors, something is very wrong on
    the backend, and we probably want to give up straight away. With a 404 error,
    however, this implies the resource isn't there, but in the case with an intermittent
    network connection, this means the resource can't be reached due to our connection
    being offline. For that reason, a 404 error might be worth retrying. To solve
    that in code, we need to inspect the value being emitted to determine what to
    do. We can inspect values using the `do()` operator.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 不过这并不是一个完美的方法；想象一下你想调查你得到了什么类型的错误。对于进行的 AJAX 请求的情况来说，获得一个以400开头的错误和以500开头的错误作为HTTP状态码是有关系的。它们有不同的含义。500错误意味着后端出了非常严重的问题，我们可能要立即放弃。然而，404错误意味着资源不存在，但在与断断续续的网络连接的情况下，这意味着由于我们的连接离线而无法到达资源。因此，重新尝试404错误可能是值得的。为了在代码中解决这个问题，我们需要检查发出的值以确定要做什么。我们可以使用`do()`操作符来检查值。
- en: 'In the following code, we investigate the type of HTTP status of the response
    and determine how to handle it:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们调查响应的HTTP状态类型并确定如何处理它：
- en: '[PRE33]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Marble testing
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大理石测试
- en: Testing asynchronous code can be challenging. For one, we have the time factor.
    The way we specify what operators to use for our crafted algorithm leads to the
    algorithm taking anywhere from 2 seconds to 30 minutes to execute. Therefore,
    it will at first feel like there is no point in testing it, because it can't be
    done within a reasonable time. We have a way to test RxJS, though; it is called
    Marble testing and it allows us to control how fast time passes so we have a test
    that can execute it in milliseconds.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 测试异步代码可能是具有挑战性的。首先，我们有时间因素。我们指定用于我们精心设计的算法的操作符的方式导致算法执行的时间从2秒到30分钟不等。因此，一开始会感觉没有必要进行测试，因为在合理的时间内无法完成。不过，我们有一种测试
    RxJS 的方法；它被称为大理石测试，它允许我们控制时间的流逝速度，这样我们就可以在毫秒内执行测试。
- en: The idea of a Marble is known to us. We can represent one or many streams and
    the effect an operator has one two or more streams. We do this by drawing the
    streams as a line and values as circles on the lines. The operator is shown as
    verb below the input streams. Following operator is a third stream, the result
    of taking the input streams and applying the operator, a so - called marble diagram.
    The line represents a continuous timeline. We take this concept and bring it to
    testing. What this means is that we can express our incoming values as a graphical
    representation and apply our algorithm to it and assert on the result.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 大理石的概念为我们所知。我们可以表示一个或多个流以及操作符对两个或多个流产生的影响。我们通过在线上画出流并将值表示为线上的圆圈来做到这一点。操作符显示为输入流下面的动词。操作符后面是第三个流，这是取得输入流并应用操作符得到的结果，即所谓的大理石图。线表示一个连续的时间线。我们将这个概念带到测试中。这意味着我们可以将我们的传入值表示为一个图形表达，并对其应用我们的算法，然后对结果进行断言。
- en: Set up
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置
- en: 'Let''s set up our environment correctly so we can write marble tests. We need
    the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们正确设置环境，以便我们可以编写大理石测试。我们需要以下内容：
- en: The NPM library jasmine-marbles
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NPM库jasmine-marbles
- en: A scaffolded Angular application
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个已经脚手架化的Angular应用
- en: 'With that we scaffold our Angular project, like so:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们脚手架化我们的Angular项目，就像这样：
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'After the project has been scaffolded, it''s time to add our NPM library, like
    so:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 项目脚手架完成后，现在是时候添加我们的 NPM 库了，就像这样：
- en: '[PRE35]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now we have finished the setup, so the time has come to write tests.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了设置，所以是时候编写测试了。
- en: Writing your first marble test
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写你的第一个大理石测试
- en: 'Let''s create a new file `marble-testing.spec.ts`. It should look like the
    following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的文件`marble-testing.spec.ts`。它应该看起来像这样：
- en: '[PRE36]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'A lot of interesting things are happening here. We import the function `cold()` from
    the NPM library marble-testing. Thereafter we set up a test suite by calling `describe()`,
    followed by a test specification, by calling `it()`. Then we call our `cold()` function
    and provide it a string. Let''s have a close look at that function call:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了很多有趣的事情。我们从NPM库marble-testing中导入`cold()`函数。然后我们通过调用`describe()`来设置一个测试套件，接着通过调用`it()`来设置一个测试规范。然后我们调用我们的`cold()`函数并提供一个字符串。让我们仔细看看那个函数调用：
- en: '[PRE37]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The above code set up a stream that expects to values to be emitted followed
    by the stream ending. How do we know that? It's time to explain what `x-x|` means.
    `x` is just any value, the hyphen `-` means time has passed. The pipe `|` means
    our stream has ended. The second argument in the cold function is a mapping object
    that tells us what the x means. In this case, it has come to mean the value 1.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码设置了一个流，期望在流结束前发出两个值。我们怎么知道呢？现在该解释`x-x|`的含义了。`x`只是任意值，短横线`-`表示时间过去了。竖线`|`表示我们的流已结束。冷函数中的第二个参数是一个映射对象，告诉我们x代表什么。在这种情况下，它意味着值是1。
- en: 'Moving on, let''s have a look at the next line:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一下下一行：
- en: '[PRE38]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The preceding code applies the operator `.map()` and increased the value with
    one for each value emitted in the stream. Thereafter, we call the `.toBeObservable()` helper
    method and verify it against an expected condition,
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码应用了`.map()`运算符，并且对流中发出的每个值加了一。然后，我们调用了`.toBeObservable()`辅助方法并根据预期条件进行验证，
- en: '[PRE39]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The previous condition states that we expect the stream to should emit two values,
    but that the values should now have the number 2\. This makes sense, as our `map()` function
    performs just that.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的条件说明我们期望流应该发出两个值，但这些值应该有数字2。这是有道理的，因为我们的`map()`函数就是做这个。
- en: Fleshing out with more tests
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 补充更多测试
- en: 'Let''s write one more test. This time we will be testing the `filter()` operator.
    This one is interesting, as it filters away values that does not fulfill a certain
    condition. Our test file should now look like the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再写一个测试。这次我们将测试`filter()`运算符。这个很有意思，因为它过滤掉不满足特定条件的值。我们的测试文件现在应该看起来像这样：
- en: '[PRE40]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This test is set up in pretty much the same way as our first test. This time
    we use the `filter()` operator but what stands out is our expected stream:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试设置方式几乎和我们的第一个测试一样。这次我们使用`filter()`运算符，但值得注意的是我们的预期流：
- en: '[PRE41]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`--y`, means that our first values is removed. Based on how the filter condition
    is defined, we are not surprised. The reason for the double hyphen, `-`, though,
    is that time still passes, but instead of an emitted value a hyphen takes its
    place.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`--y`，表示我们的第一个值被移除了。根据过滤条件的定义，我们不感到意外。然而，双短横线`-`的原因是时间仍在流逝，但是一个短横线取代了一个发出的值。'
- en: To learn more about Marble testing, have a look at the following link from the
    official documentation, [https://github.com/ReactiveX/rxjs/blob/master/doc/writing-marble-tests.md](https://github.com/ReactiveX/rxjs/blob/master/doc/writing-marble-tests.md)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于Marble测试的信息，请查看官方文档中的以下链接，[https://github.com/ReactiveX/rxjs/blob/master/doc/writing-marble-tests.md](https://github.com/ReactiveX/rxjs/blob/master/doc/writing-marble-tests.md)
- en: Pipeable operators
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可管道的运算符
- en: 'We haven''t mentioned it much so far, but the RxJS library weighs in quite
    heavily when used in an app. In today''s world of mobile first, every kilobyte
    counts when it comes to libraries that you include in your app. They count because
    the user may be on a 3G connection, and if it takes too long to load, your user
    may leave, or just may end up not liking your app, as it feels slow to load, and
    this may cause you to have bad reviews or lose users. So far, we have used two
    different ways of importing RxJS:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们没有提及太多，但是当在应用中使用RxJS库时，它会占据相当大的空间。在如今的移动优先世界中，每个库在你的应用中包含的千字节都很重要。这很重要，因为用户可能在3G连接上，如果加载时间过长，用户可能离开，或者可能不喜欢你的应用，因为它感觉加载很慢，这可能导致你得到不好的评论或失去用户。到目前为止，我们已经使用了两种不同的导入RxJS的方式：
- en: Importing the whole library; this one is quite costly in terms of size
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入整个库；这在体积上是相当昂贵的
- en: Importing only the operators we need; this ensures that the bundle decreases
    significantly
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只导入我们需要的运算符；这可以显著减少捆绑包的大小
- en: 'The different options have looked like this, for importing the whole library
    and all its operators:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的选项看起来像这样，导入整个库和所有它的运算符：
- en: '[PRE42]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Or like this, to only import what we need:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 或者这样，只导入我们需要的内容：
- en: '[PRE43]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'That looks good, right? Well, yes, but it is a flawed approach. Let''s explain
    what happens when you type:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来不错，是吗？是的，但这是一个有缺陷的方法。让我们解释一下当你输入时会发生什么：
- en: '[PRE44]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'By typing the preceding, we add to the prototype of the `Observable`. Looking
    in the source code for RxJS, it looks like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入上述内容，我们会添加到`Observable`的原型中。查看RxJS的源代码，它是这样的：
- en: '[PRE45]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'As you can see from the preceding code, we import the `Observable` as well
    as the operator in question and we add the operator to the prototype by assigning
    it to a `map` property on the prototype. What''s flawed with that, you might wonder?
    The problem is tree shaking, a process we use to get rid of unused code. Tree
    shaking has a hard time determining what you use and don''t use, respectively.
    You may actually import a `map()` operator and it gets added to the Observable.
    As the code changes over time, you may end up not using it anymore. You may argue
    that you should remove the import at that point, but you might have a lot of code,
    and it is easy to overlook. It would be better if only used operators were included
    in the final bundle. It is, as we mentioned before, hard for the tree-shaking
    process to know what is used and what is not, with the current approach. For that
    reason, a big rewrite has happened in RxJS, adding something called pipeable operators,
    which help us with the above problem. There is also another downside to patching
    the prototype, and that is the fact that it creates a dependency. If the library
    changes and the operator is no longer added when we patch it (calling the import),
    then we have a problem. We won''t detect the problem until runtime. We would rather
    be told that the operator has gone through us importing and explicitly using it,
    like so:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的代码中可以看出，我们导入了`Observable`以及相关的操作符，并且通过将它们分配到原型的`map`属性上，将操作符添加到了原型上。你可能会想这有什么毛病？问题在于摇树优化，这是我们用来摆脱未使用代码的过程。摇树优化在确定你使用和不使用的代码时会出现问题。事实上，你可能导入了一个`map()`操作符并将其添加到
    Observable 上。随着代码随着时间的推移而改变，你可能最终不再使用它。你可能会争辩说此刻应该移除导入，但你可能的代码量很大，很容易忽略。最好的方式应该是只有使用的操作符包含在最终的包中。正如我们之前提到的，摇树优化的过程很难知道当前方法中使用了什么，没有使用什么。因此，在
    RxJS 中进行了一次大规模的重写，添加了一种称为可管道化操作符的东西，它帮助我们解决了上述问题。对原型进行补丁还有另一个不足之处，那就是它创建了一个依赖。如果库发生改变并且我们在进行补丁时不再添加操作符（调用导入），那么我们就有了一个问题。我们只有在运行时才会发现这个问题。我们宁愿得到一个消息，告诉我们操作符已经过我们导入和明确使用，就像这样：
- en: '[PRE46]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Creating reusable operators with let()
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `let()` 创建可重用的操作符
- en: 'The `let()` operator lets you have the whole operator and operate on it, rather
    than just manipulating the values as you would do with the `map()` operator, for
    example. Using the `let()` operator could look like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`let()`操作符允许你拥有整个操作符并对其进行操作，而不仅仅像`map()`操作符那样操作值。使用`let()`操作符可能像这样：'
- en: '[PRE47]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In the preceding example, we were able to define a group of operators such as `addAndFilter` and `sub3` and
    use them on the stream with the `let()` operator. This enables us to create composable
    and reusable operators. It is with this very knowledge that we now move on to
    the concept of pipeable operators.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们能够定义一组操作符，比如`addAndFilter`和`sub3`，并且使用`let()`操作符在流上使用它们。这使我们能够创建可组合和可重用的操作符。正是基于这种知识，我们现在转向可管道化操作符的概念。
- en: Shifting to pipeable operators
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转向可管道化操作符
- en: 'As we mentioned already, pipeable operators are here, and you can find them
    by importing the respective operators from the `rxjs/operators` directory, like
    so:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，可管道化操作符已经出现了，通过从`rxjs/operators`目录中导入相应的操作符，你就能找到它们，就像这样：
- en: '[PRE48]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To use it, we are now relying on the `pipe()` operator that we use as the parent
    operator, if you will. Using the preceding operators will, therefore, look like
    this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，我们现在依赖于`pipe()`操作符，它就像父操作符一样。因此，使用上述操作符将如下所示：
- en: '[PRE49]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter has taken us deep into RxJS by covering topics such as hot, cold,
    and warm Observables, and what that generally means in terms of when to subscribe
    to a stream and how they share their Producer under certain conditions. Next up,
    we covered Subjects, and the fact that Observable isn't the only thing you can
    subscribe to. Subjects also allow as to append values to the stream whenever we
    want, and we also learned that there exist different types of Subjects, depending
    on the situation at hand.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容深入介绍了 RxJS，涉及了诸如热、冷、温暖的 Observables 等主题，并且解释了在何时订阅流以及在特定条件下它们如何共享生产者的含义。接下来，我们介绍了
    Subject，并且 Observable 并不是你唯一可以订阅的东西。Subject 也允许我们随时向流中添加值，并且我们也了解到根据具体情况存在不同类型的
    Subject。
- en: We ventured deeper into an important topic, testing, and tried to explain the
    difficulty in testing asynchronous code. We talked about the current state of
    the testing situation and what libraries to use here and now for your testing
    scenarios. Lastly, we covered pipeable operators, and our new preferred way of
    importing and composing operators to ensure we end up with the smallest possible
    bundle size.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们深入探讨了一个重要的主题，测试，并试图解释测试异步代码的困难。我们谈到了测试情况的当前状态，以及在这里和现在用什么库进行测试场景。最后，我们介绍了管道操作符，以及我们新的首选导入和组合操作符的方式，以确保我们最终得到尽可能小的捆绑包大小。
- en: In the next chapter, you will leverage Kanban using Waffle, build a simple web
    app with a full-stack architecture in mind, and get introduced to reactive programming
    with RxJS.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将利用Waffle使用看板，按照全栈架构构建一个简单的Web应用，并了解使用RxJS进行响应式编程。
