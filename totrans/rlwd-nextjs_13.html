<html><head></head><body>
		<div id="_idContainer044">
			<h1 id="_idParaDest-114"><em class="italic"><a id="_idTextAnchor113"/>Chapter 11</em>: Different Deployment Platforms</h1>
			<p>In the previous chapters, we saw how Next.js works, how to optimize it for SEO, how to deal with performance, how to adopt UI frameworks, and how to fetch data on both the client and server sides, eventually being able to create a fantastic web application. But then, we have a problem: how should we ship it to production? There are many different hosting providers, cloud platforms, and even <strong class="bold">Platform as a Service</strong> (<strong class="bold">PaaS</strong>) solutions out there; how do we pick one?</p>
			<p>In this chapter, we will see how to choose the right deployment platform.</p>
			<p>We will look at the following in detail:</p>
			<ul>
				<li>How choosing the right deployment platform could affect performance</li>
				<li>How to decide between different cloud solutions</li>
				<li>What are the most popular alternatives for hosting a Next.js app?</li>
			</ul>
			<p>By the end of this chapter, you'll be able to deploy any Next.js application to any host, knowing how to choose the right provider from the most popular hosting solutions.</p>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor114"/>Technical requirements</h1>
			<p>To run the code examples in this chapter, you need to have both Node.js and npm installed on your local machine.</p>
			<p>If you prefer, you can use an online IDE, such as <a href="https://repl.it">https://repl.it</a> or <a href="https://codesandbox.io">https://codesandbox.io</a>; they both support Next.js, and you don't need to install any dependency on your computer. As with the other chapters, you can find the code base for this chapter on GitHub: https://github.com/PacktPublishing/Real-World-Next.js.</p>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor115"/>A brief introduction to different deployment platforms</h1>
			<p>While<a id="_idIndexMarker574"/> thinking about a new web application, we have many things to consider. For example, how do we want to render its pages, which styling method do we want to adopt, where does data come from, how do we manage the application state, and where do we want to deploy the application itself?</p>
			<p>Focusing on that last part, we could split one problem into two: <em class="italic">where</em> do we want to deploy our application and <em class="italic">how</em> do we want to do it?</p>
			<p>In fact, most of the time, choosing a deployment platform also means selecting a slightly different deployment method. There are specific cloud platforms, such as Vercel, Netlify, and Heroku, where the deployment process is standardized and incredibly simplified to be accessible for everyone. With other cloud providers, such as AWS, Azure, and DigitalOcean, you have complete control over the whole deployment process. Unfortunately, in many cases, you have to implement this process on your own or use third-party software.</p>
			<p>The number of cloud infrastructures has drastically increased over the last few years, and the competition has brought some great innovation to this sector. Even though there are many alternatives, we will be focusing on the most popular ones, as we're more likely to find more documentation and support for them.</p>
			<p>In the next section, we will discuss the most prominent platform to deploy a Next.js application to: <em class="italic">Vercel</em>.</p>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor116"/>Deploying to the Vercel platform</h1>
			<p><em class="italic">Develop, preview, ship</em> is <a id="_idIndexMarker575"/>not just a motto. It's the <a id="_idIndexMarker576"/>perfect description of the company that developed Next.js (alongside many other open source libraries) and an excellent cloud infrastructure for<a id="_idIndexMarker577"/> deploying and serving web applications.</p>
			<p>With Vercel, you almost don't need to configure anything. You can deploy your web application from the command line using their CLI tool, or create an automatic deployment after a push to the main Git branch.</p>
			<p>One thing to know before getting started with Vercel is that the platform is built specifically for static sites and frontend frameworks. Unfortunately, that means that <em class="italic">custom Node.js servers are not supported</em>.</p>
			<p>But at this<a id="_idIndexMarker578"/> point, you might be wondering whether only statically generated or client-side-rendered Next.js websites are supported. The short answer is <em class="italic">no</em>. In fact, Vercel supports server-side-rendered pages by serving them via <em class="italic">serverless functions</em>.</p>
			<p class="callout-heading">What Does "Serverless Function" Mean?</p>
			<p class="callout">When talking about "serverless functions," we <a id="_idIndexMarker579"/>refer to a single function (written in any programming language) that gets invoked on a managed infrastructure. In fact, it's called "serverless" because we just have to write the function without really thinking about the server executing it. Unlike traditional servers, where we typically pay an hourly rate (for example, we could pay $1 for every hour, even when the server is not processing any data), serverless functions have a different pricing model: we pay them a fraction of a cent for each execution, depending on the execution duration, memory usage, and other similar metrics. For example, at the time of writing, AWS Lambda (the most popular serverless environment) costs <em class="italic">$0.20 for every million requests</em> and $0.0000000021 for every millisecond of duration (when allocated 128 MB of memory). As you can imagine, this pricing model can be really attractive compared to more traditional alternatives, as you only pay for what you actually use.</p>
			<p>Vercel does an incredible job of setting up serverless functions for us when deploying a Next.js application, so <a id="_idIndexMarker580"/>we don't have to worry about them; we just have to concentrate on the web application we're building.</p>
			<p>Deploying an application to Vercel is pretty straightforward. We can proceed in two different ways:</p>
			<ul>
				<li><em class="italic">By linking our GitHub, GitLab, or Bitbucket repository to Vercel</em>. Every time we create a pull request, Vercel will deploy a preview application to test the features we just developed before publishing them to production. Once we merge or push to our main branch, Vercel will automatically deploy the application to production.</li>
				<li><em class="italic">We can do everything manually from the command line</em>. For example, we can decide to create a preview application, preview it locally, or publish it to production directly from our terminal using the Vercel CLI tool, where typing <strong class="source-inline">vercel --prod</strong> is enough to promote the app to production.</li>
			</ul>
			<p>Either way, the <a id="_idIndexMarker581"/>developer experience is outstanding, so feel free to test both deployment strategies and find your favorite one.</p>
			<p>Among all <a id="_idIndexMarker582"/>the possible alternatives for deploying and serving Next.js applications, Vercel is probably one of the easiest ones. Also, it allows you to gain access to the analytics module (do you remember we talked about it in <a href="B16985_10_Final_SB_epub.xhtml#_idTextAnchor102"><em class="italic">Chapter 10</em></a>, <em class="italic">Working with SEO and Managing Performance?</em>), which can be incredibly useful to measure frontend performances over time. That will help us keep an eye on frontend optimization, which other platforms don't do (also, it's something fundamental!).</p>
			<p>If you're looking for something comparable to Vercel, a good alternative you may consider is Netlify. The whole deployment workflow is quite similar to Vercel's one, and the developer experience is just as phenomenal. However, I'd encourage you to consider the pricing model differences before deciding on either platform.</p>
			<p>Both Vercel and Netlify also work incredibly well when deploying a static website. But there, the competition with other platforms will grow; we'll see some alternatives in the next section.</p>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor117"/>Deploying a static site to a CDN</h1>
			<p>When talking<a id="_idIndexMarker583"/> about a <strong class="bold">CDN</strong> (short for <strong class="bold">content delivery network</strong>), we <a id="_idIndexMarker584"/>refer to a geographically distributed network of data centers used to achieve high availability and performance when<a id="_idIndexMarker585"/> serving content to users in any part of the world.</p>
			<p>To keep it<a id="_idIndexMarker586"/> simple, let's give an example. I currently live near Milan, Italy, and I want my web application to be used in potentially any part of the world. So, where should I host it from a geographical point of view?</p>
			<p>Certain providers, such as Amazon AWS, DigitalOcean, and Microsoft Azure (and many more), will let you choose a specific data center to serve your application from. For example, I could select AWS <em class="italic">eu-south-1</em> (Milan, Italy), <em class="italic">ap-northeast-2</em> (Seoul, South Korea), or <em class="italic">sa-east-1</em> (São Paulo, Brazil). If I choose to serve my web application from Milan, Italian users will notice a very low latency when trying to reach the web application; it is<a id="_idIndexMarker587"/> geographically located very close to them. The same could happen for French, Swiss, and German users, but for people living in Asia, Africa, or the Americas, it will be the opposite. The further <a id="_idIndexMarker588"/>you are from the data center, the greater the latency, leading to lousy performance, poor client-to-server request latency, and so on. If we think of static assets, such as images, CSS, or JavaScript files, this will be even clearer.</p>
			<p>Heavy file size + data center distance = bad download performance. It's quite easy, isn't it?</p>
			<p>CDNs solve <a id="_idIndexMarker589"/>this specific problem by providing a whole infrastructure distributed in (almost) every continent. Once you deploy your static asset to a CDN, it will be replicated across all the regions in the network, making it available closer to your users in any part of the world.</p>
			<p>If you look at Next.js' statically generated websites, you will quickly notice that there is no need for a server to render the pages at request time. Instead, the website is entirely generated and statically rendered at build time, so we eventually end up with a collection of static HTML, CSS, and JavaScript files that can be deployed to a CDN.</p>
			<p>If we're in that situation, then we're in luck. We're about to achieve the best possible performances by serving static HTML pages from a CDN. But which CDN should I choose? We'll find it out in the next section.</p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor118"/>Choosing a CDN</h1>
			<p>When<a id="_idIndexMarker590"/> looking for a CDN to deploy our web application, we will find many different alternatives. Prominent players in this area are (but are not limited to) <em class="italic">Amazon AWS</em>, <em class="italic">Microsoft Azure CDN</em>, and <em class="italic">Cloudflare</em>. Of course, there are many other alternatives, but these are the ones I've tried and had great experiences with, so I feel confident recommending them to you.</p>
			<p>The CDN deployment adds some configuration steps, but spending a bit more time to achieve the best possible performance might be worth it.</p>
			<p>Talking about AWS, for instance, the procedure won't be as straightforward as the Vercel one. We would need to build a pipeline (with either GitHub Actions or GitLab Pipelines, and so on) to statically generate the web application, then to <a id="_idIndexMarker591"/>push it to <strong class="bold">AWS S3</strong> (a service used for storing static assets), and eventually use a <strong class="bold">CloudFront</strong> (AWS CDN) distribution<a id="_idIndexMarker592"/> to let users reach these static assets over HTTP requests. We would also need to link our CloudFront distribution to a domain name, and we can do that <a id="_idIndexMarker593"/>using <strong class="bold">AWS Route 53</strong> (an AWS proprietary DNS service).</p>
			<p>Cloudflare, in<a id="_idIndexMarker594"/> comparison, makes things a bit easier. It has<a id="_idIndexMarker595"/> a more straightforward UI, called Cloudflare Pages, that can help us link our project to a Git repository and automatically deploy a new website version every time we push new code to any branch. Of course, every time we push some code to the main branch, it will be published in production; if we want to preview some features living on feature branches, we can just push our code there and wait for Cloudflare to publish a preview deployment, just like Vercel does.</p>
			<p>Microsoft Azure<a id="_idIndexMarker596"/> provides another exciting approach. We can enter the Azure portal (the Azure administration dashboard), create a new resource, select "static web app" as the resource type, and enter the required data to configure it. After that, we can link our GitHub account, making automatic deployments available just like we did on Cloudflare and Vercel. Azure will create a GitHub workflow file for us so the build phase will run on GitHub and push the content to Azure as soon as it succeeds.</p>
			<p>Now, you might be wondering how to choose the best CDN among the ones listed previously. Well, they're all excellent, but there's a way to determine which one best suits our needs.</p>
			<p>AWS, for instance, might look like the most complicated one. But if we already have an AWS infrastructure, it would make things easier for us to set up a deployment there. The same applies to Microsoft Azure, where we might already have existing projects running on this platform, and we don't want to move just one web application outside of it.</p>
			<p>Cloudflare, instead, can <a id="_idIndexMarker597"/>be the perfect solution for all static websites that don't need to rely on other services, except for <a id="_idIndexMarker598"/>serverless functions (Cloudflare offers a serverless function service called Cloudflare Workers) and other similar services that you can find at https://developers.cloudflare.com.</p>
			<p>Even though there are ways to execute serverless functions decoupled from the static website (by using AWS Lambda, Azure Functions, Cloudflare Workers, and so on), there are times when we need to create dozens or even hundreds of serverless functions. Organizing such deployments can be challenging, especially if we're working in a small team without support from someone who's really into DevOps.</p>
			<p>Other times, we<a id="_idIndexMarker599"/> just need server-side rendering alongside statically generated pages, and we need to deploy an application where we can use Node.js code at runtime. One interesting approach is to deploy the website in a completely serverless fashion.</p>
			<p>There is an <a id="_idIndexMarker600"/>open source project called <strong class="bold">serverless-next.js</strong> (<a href="https://github.com/serverless-nextjs/serverless-next.js">https://github.com/serverless-nextjs/serverless-next.js</a>) that can help us achieve that result. It <a id="_idIndexMarker601"/>works as a "<em class="italic">Serverless component</em>" (in that case, <em class="italic">Serverless</em> is the name of an npm library used to deploy code to any serverless platform) that <a id="_idIndexMarker602"/>will configure a deployment on AWS by adapting it to the following rules:</p>
			<ul>
				<li>SSR pages and API routes will be deployed and served by AWS Lambda (serverless functions).</li>
				<li>Static pages, client assets, and public files will be deployed to S3 and automatically served by CloudFront.</li>
			</ul>
			<p>This approach will lead to a kind of hybrid deployment where we always try to achieve the best possible performances of each type of request. SSR and API pages (which need a Node.js runtime) will be served by a serverless function, everything else from a CDN.</p>
			<p>Don't worry if that sounds complex because it isn't. But if you feel like it would be an over-engineered part of your application life cycle (and you still need server-side rendering and API routes), you may want to consider other approaches. We will discuss how to deploy an SSR Next.js application to any platform correctly in the next section.</p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor119"/>Deploying Next.js on any server</h1>
			<p>So far, we've seen <a id="_idIndexMarker603"/>some alternatives for deploying our Next.js application to CDNs and managed infrastructures, such as Vercel and Netlify. Still, there is another alternative that we haven't considered yet; what if we want to deploy our application to our private server?</p>
			<p>Even though this is a common situation, it is also the most complex one by far. While platforms such as Vercel, Netlify, and Heroku manage the server for us, sometimes we may want to host our application on a private server where we have to control everything independently.</p>
			<p>Let's have a quick recap of what the previously mentioned managed platforms can do for us:</p>
			<ul>
				<li>Automatic deployments</li>
				<li>Rollback to previous deployments</li>
				<li>Automatic deployments for feature branches</li>
				<li>Automatic server configuration (Node.js runtime, reverse proxy, and so on)</li>
				<li>Built-in scaling capabilities</li>
			</ul>
			<p>By choosing a <a id="_idIndexMarker604"/>custom server, we have to implement all these features on our own. But is it worth it? Well, it depends. When working in a large company that already has a significant infrastructure up and running on a given cloud provider (be it Amazon AWS, Google Cloud, Microsoft Azure, and so on), it might make sense for us to identify the best solution for deploying our Next.js application in the same infrastructure.</p>
			<p>If we're working on a side project or a small business website or starting a new web application from scratch, we could consider alternatives, such as managed platforms or CDNs, but we've already talked about that.</p>
			<p>Let's pretend for a moment that the choice has been made, and we have to deploy our application to either Amazon AWS, Google Cloud, or Microsoft Azure. How do we approach deployment and hosting from there?</p>
			<p>The first thing to consider is how we want to serve our application. Starting with an empty server means <a id="_idIndexMarker605"/>that we have to manually set up a bunch of stuff to make it ready to serve a Node.js application. That includes (but is not limited to) the following:</p>
			<ul>
				<li><em class="italic">The Node.js runtime</em>: Node.js is not pre-installed on every operating system, so we'll need to install it to serve API and server-side-rendered pages.</li>
				<li><em class="italic">A process manager</em>: If you have already worked with Node.js in the past, you may know that if the main process crashes, the entire application will stay down until we manually restart it. That is due to the Node.js single-threaded architecture, and it's unlikely to change in the future, so we need to be prepared for this possibility. A popular approach to solving that problem is using a process manager such as<a id="_idIndexMarker606"/> PM2 (<a href="https://github.com/Unitech/pm2">https://github.com/Unitech/pm2</a>), which monitors the Node.js <a id="_idIndexMarker607"/>processes and manages them to keep the application up and running. It also provides many other additional features for handling any Node.js program, so if you're interested in that, I'd recommend you read the official documentation at <a href="https://pm2.keymetrics.io">https://pm2.keymetrics.io</a>.</li>
				<li><em class="italic">A reverse proxy</em>: Even <a id="_idIndexMarker608"/>though we could easily set up any Node.js application to manage incoming HTTP requests, it is a best practice to put it behind a reverse proxy such as NGINX, Caddy, or Envoy. This adds an extra layer of security, other than valuable features we don't want to compromise on, but also means we have to maintain a reverse proxy on our server.</li>
				<li><em class="italic">Setting up firewall rules</em>: We need to open the firewall to accept incoming HTTP requests to the <strong class="source-inline">:443</strong> and <strong class="source-inline">:80</strong> ports.</li>
				<li><em class="italic">Setting up an efficient deployment pipeline</em>: We could use Jenkins, CircleCI, or even GitHub Actions. But this is another thing to take care of.</li>
			</ul>
			<p>Once we're <a id="_idIndexMarker609"/>done setting up the whole environment, we should also consider that we may need to replicate that same environment on another server as soon as we need to scale our infrastructure to accept more and more incoming requests. It might be pretty easy to replicate it on a new server, but what if we need to scale on dozens of new machines? And what if we need to upgrade the Node.js runtime or the reverse proxy on all of them? Things are getting more complicated and time-consuming, so we may want to look for an alternative approach, and that's what we're going to talk about in the next section: how to deploy our Next.js application to any server by using Docker.</p>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor120"/>Running Next.js in a Docker container</h1>
			<p>Docker, and <a id="_idIndexMarker610"/>virtualization in general, has changed forever the way we build and deploy our applications. It <a id="_idIndexMarker611"/>provides a set of useful utilities, commands, and configurations to make our build reproducible on any server, making our application available on almost every operating system by creating a virtual machine running our program (or web application).</p>
			<p class="callout-heading">In Case You Are New to Docker</p>
			<p class="callout">Docker is an important tool to consider when building and deploying any computer program (a web application, database, or anything else). If you're new to this technology, I highly recommend reading the official Docker documentation at <a href="https://www.docker.com">https://www.docker.com</a> before<a id="_idIndexMarker612"/> starting to use it. If you're interested in a hands-on approach to learning Docker, I'd also recommend you read <em class="italic">Mastering Docker – Fourth Edition</em> by Russ McKendrick (<a href="https://www.packtpub.com/product/mastering-docker-fourth-edition/9781839216572">https://www.packtpub.com/product/mastering-docker-fourth-edition/9781839216572</a>); it provides a complete guide to getting started and understanding Docker.</p>
			<p>Running Next.js in Docker is relatively straightforward. A very basic Dockerfile is composed of the following commands:</p>
			<p class="source-code">FROM node:16-alpine</p>
			<p class="source-code">RUN mkdir -p /app</p>
			<p class="source-code">WORKDIR /app</p>
			<p class="source-code">COPY . /app/</p>
			<p class="source-code">RUN npm install</p>
			<p class="source-code">RUN npm run build</p>
			<p class="source-code">EXPOSE 3000</p>
			<p class="source-code">CMD npm run start</p>
			<p>It's almost <a id="_idIndexMarker613"/>effortless, isn't it? Let's break it down into small steps:</p>
			<ol>
				<li>First, declare which image we want to run our server in. In this case, we're choosing <strong class="source-inline">node:14-alpine</strong>.</li>
				<li>It is a best practice to create a new working directory, so as a first step, create it and name it <strong class="source-inline">/app</strong>.</li>
				<li>Choose <strong class="source-inline">/app</strong> as our working directory.</li>
				<li>Copy all the content of our local directory into the Docker working directory.</li>
				<li>Install all the required dependencies.</li>
				<li>Build Next.js inside the container's working directory.</li>
				<li>Expose port <strong class="source-inline">3000</strong> to be reached from outside the container.</li>
				<li>Run the start script for booting the Next.js built-in server.</li>
			</ol>
			<p>We can test <a id="_idIndexMarker614"/>the previous Dockerfile by creating a new, empty Next.js app running the following command in a new directory:</p>
			<p class="source-code">npx create-next-app my-first-dockerized-nextjs-app</p>
			<p>Let's create a Dockerfile with the content we just discussed. We should also create a <strong class="source-inline">.dockerignore</strong> file containing <strong class="source-inline">node_modules</strong> and the Next.js output directory so that we won't be copying them into the container:</p>
			<p class="source-code">.next</p>
			<p class="source-code">node_modules</p>
			<p>We can now proceed by building the Docker container:</p>
			<p class="source-code">docker build -t my-first-dockerized-nextjs-app .</p>
			<p>We're tagging it with a custom name, in this case, <strong class="source-inline">my-first-dockerized-nextjs-app</strong>.</p>
			<p>Once the build succeeds, we can run the container as follows:</p>
			<p class="source-code">docker run -p 3000:3000  my-first-dockerized-nextjs-app</p>
			<p>We are<a id="_idIndexMarker615"/> finally able to reach our web application at http://localhost:3000!</p>
			<p>Starting <a id="_idIndexMarker616"/>from that simple configuration, we will be able to deploy our application to any managed container service (such as AWS ECS or Google Cloud Run), any Kubernetes cluster, or any machine with Docker installed.</p>
			<p>Using containers in production has many benefits, as we only need a very simple configuration file for setting up the virtualization of a Linux machine to run our application in. Whenever we need to duplicate, scale, or reproduce our build, we can simply do that by sharing the Dockerfile and executing it, making the whole process incredibly straightforward, scalable, and easy to maintain.</p>
			<p>That said, do we always need Docker? Let's discuss this in the summary for this chapter, right in the next section.</p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor121"/>Summary</h1>
			<p>In this chapter, we've seen different deployment platforms for our Next.js application. There's no perfect solution for building and deploying Next.js apps, as it depends on the specific use case and challenges that every project brings.</p>
			<p>Vercel, Netlify, and Heroku (just to quote some) are all excellent alternatives for quickly deploying a Next.js application to production. On the other hand, Cloudflare Pages, AWS S3 and AWS CloudFront, and Microsoft Azure CDN can really provide excellent performance for our static sites, which competes with all the other great solutions we've seen in this chapter when it comes to serving a statically generated website.</p>
			<p>Docker is probably one of the most flexible solutions. It allows us to deploy our application everywhere, making it easy to replicate the production environment on every machine.</p>
			<p>Again, there's no "perfect" solution for deploying a Next.js application, as the competition in this field is extremely strong, and many companies provide excellent solutions to simplify our lives as developers and make our browsing experience always better as users.</p>
			<p>The best suggestion I can give when deciding where to deploy a Next.js application is to consider the following aspect: how big is the team I'm working in? While solutions such as Vercel, Netlify, Heroku, and Cloudflare are well suited for both little and big teams, there are other providers where the required knowledge, skillset, and capacity are way higher. Setting up an AWS EC2 instance or a custom machine on DigitalOcean or Google Cloud gives us much more control over the whole application life cycle, but the cost (in terms of configuration, setup, and required time) is considerable.</p>
			<p>On the other hand, when working in big companies where there's a dedicated DevOps team that can take care of the release process for the application, they might prefer to adopt custom solutions where they have more and more control.</p>
			<p>But even if we're working alone, we can choose to deploy our applications to a custom cloud infrastructure. If we're doing that, we should make sure we're not unintentionally reinventing the wheel by recreating infrastructures that Vercel, Netlify, Cloudflare, and so on can provide even on a free plan.</p>
			<p>We've made some significant progress so far. We learned the basics of the framework and how to integrate it with different libraries and data sources, and now we also know how to choose a deployment platform for any need.</p>
			<p>Starting from the next chapter, we will build some real-world applications that will allow us to understand the real-world challenges we will face when creating production-ready web applications in Next.js.</p>
		</div>
	</body></html>