- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Implementing an End-To-End Project
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现端到端项目
- en: In the previous chapters, we delved into a variety of topics, including testing,
    **test-driven development** (**TDD**), design patterns, and design principles.
    These concepts are invaluable as they pave the way toward a more resilient and
    maintainable codebase. Now, I’d like to embark on a journey of constructing an
    application from the ground up, applying the knowledge we’ve acquired to tackle
    an end-to-end scenario.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们深入探讨了各种主题，包括测试、**测试驱动开发（TDD**）、设计模式和设计原则。这些概念非常有价值，因为它们为构建更健壮和可维护的代码库铺平了道路。现在，我想开始一段从零开始构建应用程序的旅程，将我们所学知识应用于解决端到端场景。
- en: The aim is to illustrate how we can dissect requirements into actionable tasks,
    and subsequently test and implement them. We’ll also explore how to stub network
    requests, thereby eliminating dependencies on remote systems during development,
    and how to confidently refactor code without fear of breaking existing functionality.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是展示我们如何将需求分解为可执行的任务，然后进行测试和实现。我们还将探讨如何模拟网络请求，从而在开发过程中消除对远程系统的依赖，以及如何在没有担心破坏现有功能的情况下自信地重构代码。
- en: We’ll venture into building a functional weather application from scratch, interfacing
    with a genuine weather API server to fetch and display a list of weather data.
    Along the way, we’ll implement accessibility features such as keyboard interactions,
    revisit the **Anti-Corruption Layer** (**ACL**) and single responsibility principle,
    and much more.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从头开始构建一个功能性的天气应用程序，与真实的天气API服务器接口以获取和显示天气数据列表。在这个过程中，我们将实现诸如键盘交互等无障碍功能，回顾**反腐败层（ACL**）和单一职责原则，以及更多内容。
- en: The overarching goal is to showcase the end-to-end process of crafting a functioning
    software solution, all while keeping the code in a maintainable, understandable,
    and extensible state.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 总体目标是展示构建一个功能软件解决方案的端到端过程，同时保持代码的可维护性、可理解性和可扩展性。
- en: 'The following topics will be covered:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 将涵盖以下主题：
- en: Reviewing the requirements for the weather application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查天气应用程序的要求
- en: Crafting our initial acceptance test
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写我们的初始验收测试
- en: Implementing the City Search feature
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现城市搜索功能
- en: Implementing an ACL
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现ACL
- en: Implementing an Add to Favorite feature
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现添加到收藏夹功能
- en: Fetching previous weather data when the application relaunches
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当应用程序重新启动时获取以前的天气数据
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: A GitHub repository has been created to host all the code we’ll discuss in this
    book. For this chapter, you can find the recommended structure at [https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch12](https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch12).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 已创建一个GitHub仓库来托管本书中将要讨论的所有代码。对于本章，您可以在[https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch12](https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch12)找到推荐的架构。
- en: We need to complete a few more steps before we proceed. Please follow the next
    section to set up the necessary API keys.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们需要完成几个步骤。请遵循下一节以设置必要的API密钥。
- en: Getting the OpenWeatherMap API key
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取OpenWeatherMap API密钥
- en: 'To utilize OpenWeatherMap, you’ll need to create an account at [https://openweathermap.org/](https://openweathermap.org/).
    Although various plans are available based on usage, the free plan suffices for
    our purposes. After registering, navigate to **My API keys** to find your API
    key, as displayed in *Figure 12**.1*:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用OpenWeatherMap，您需要在[https://openweathermap.org/](https://openweathermap.org/)创建一个账户。尽管根据使用情况有多种计划可供选择，但免费计划足以满足我们的需求。注册后，导航到**我的API密钥**以找到您的API密钥，如图*图12.1*所示：
- en: '![Figure 12.1: The OpenWeatherMap API key](img/B31103_12_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1：OpenWeatherMap API密钥](img/B31103_12_01.jpg)'
- en: 'Figure 12.1: The OpenWeatherMap API key'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1：OpenWeatherMap API密钥
- en: Keep a copy of this key handy as we’ll use it to make calls to the weather API
    so that we can fetch data.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 请将此密钥随身携带，因为我们将会用它来调用天气API以获取数据。
- en: Preparing the project’s code base
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备项目的代码库
- en: If you prefer to follow along with me, you will need to install a few packages
    before we start. However, if you want to see the final results, they’re already
    in the repository mentioned earlier. I recommend that you follow along to see
    how we evolve our application into the final state.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想跟我一起做，在我们开始之前，您需要安装几个包。然而，如果您想看到最终结果，它们已经在前面提到的仓库中。我建议您跟随操作，看看我们如何将应用程序逐步发展到最终状态。
- en: 'To kick things off, we’ll create a new React app using the following commands:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，我们将使用以下命令创建一个新的React应用程序：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'These commands are used to set up a new React project with TypeScript and Cypress:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令用于设置一个新的React项目，使用TypeScript和Cypress：
- en: '`npx create-react-app weather-app --template typescript`: This command utilizes
    `npx` to run the `create-react-app` utility, which scaffolds out a new React application
    in a directory named `weather-app`. The `--template typescript` option specifies
    that this project should be configured to use TypeScript.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npx create-react-app weather-app --template typescript`：此命令使用`npx`运行`create-react-app`实用程序，在名为`weather-app`的目录中构建一个新的React应用程序。`--template
    typescript`选项指定该项目应配置为使用TypeScript。'
- en: '`yarn add cypress jest-fetch-mock -D`: This command installs Cypress, a testing
    framework, as a development dependency in the project, and `jest-fetch-mock`,
    for mocking the `fetch` function in jest tests. The `-D` flag indicates that this
    is a development dependency, meaning it’s not required for the production version
    of the application.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yarn add cypress jest-fetch-mock -D`：此命令将Cypress（一个测试框架）作为开发依赖项安装到项目中，并将`jest-fetch-mock`用于在jest测试中模拟`fetch`函数。`-D`标志表示这是一个开发依赖项，这意味着它不是应用程序生产版本所必需的。'
- en: '`yarn install`: This command installs all the dependencies listed in the `package.json`
    file of the project, ensuring that all the necessary libraries and tools are available.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yarn install`：此命令安装项目`package.json`文件中列出的所有依赖项，确保所有必要的库和工具都可用。'
- en: 'Finally, we can start the template application by running the following command:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过运行以下命令启动模板应用程序：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will launch the application on port 3000\. You can leave the application
    running on 3000 open and open another terminal window for running tests.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在端口3000上启动应用程序。您可以将应用程序在端口3000上运行并保持打开状态，然后在另一个终端窗口中运行测试。
- en: Reviewing the requirements for the weather application
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审查天气应用程序的要求
- en: 'Our envisioned weather application is designed to be a fully functional platform
    with the following capabilities:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构想的天气应用程序旨在成为一个功能齐全的平台，具有以下功能：
- en: Enables users to search for cities of interest, be it their hometown, current
    residence, or a future travel destination
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用户能够搜索感兴趣的城市，无论是他们的家乡、当前居住地还是未来的旅行目的地
- en: Allows users to add cities to a favorite list, with the selection persisting
    locally for easy access during future visits
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户将城市添加到收藏夹中，选择将持久化本地，以便在未来的访问中轻松访问
- en: Supports the addition of multiple cities to the user’s list
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持向用户的列表中添加多个城市
- en: Ensures the site is thoroughly navigable via keyboard, facilitating ease of
    access for all users
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保网站可以通过键盘完全导航，从而方便所有用户访问
- en: 'The result will resemble what’s illustrated in *Figure 12**.2*:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将类似于*图12**.2*中所示：
- en: '![Figure 12.2: The weather application](img/B31103_12_02.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图12.2：天气应用程序](img/B31103_12_02.jpg)'
- en: 'Figure 12.2: The weather application'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2：天气应用程序
- en: While it’s not an overly complex application, it encompasses several intriguing
    elements. For instance, we’ll navigate through the hurdles of applying TDD in
    a UI application, testing Hooks, and making informed decisions on when to employ
    user acceptance tests versus lower-level tests.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这不是一个过于复杂的应用程序，但它包含了几个有趣元素。例如，我们将克服在UI应用程序中应用TDD的障碍，测试Hooks，并在何时使用用户验收测试与较低级别的测试之间做出明智的决定。
- en: We will commence with an initial acceptance test to ensure the application operates
    end-to-end, albeit it is merely verifying a single text element’s appearance.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始一个初始验收测试，以确保应用程序端到端运行，尽管它只是验证单个文本元素的外观。
- en: Crafting our initial acceptance test
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的初始验收测试
- en: '[*Chapter 7*](B21103_07.xhtml#_idTextAnchor176) familiarized us with the notion
    of starting with an acceptance test – a test that’s approached from an end user’s
    standpoint, as opposed to a developer’s perspective. Essentially, we aim for our
    test to validate aspects a user would perceive or interact with on the web page,
    rather than technicalities such as function calls or class initializations.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第7章*](B21103_07.xhtml#_idTextAnchor176) 使我们熟悉了从验收测试开始的概念——这种测试是从最终用户的角度出发的，而不是从开发者的角度。本质上，我们旨在让我们的测试验证用户在网页上会感知或与之交互的方面，而不是像函数调用或类初始化这样的技术细节。'
- en: 'Within the folder you created in the *Technical requirements* section (that
    is, `weather-app`), create a Cypress test within `cypress/e2e/weather.spec.cy.ts`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在您在*技术要求*部分创建的文件夹中（即`weather-app`），在`cypress/e2e/weather.spec.cy.ts`中创建一个Cypress测试：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this code snippet, we defined a test suite named `weather application`.
    It uses the describe function in the Cypress testing framework. This test case
    comprises two main actions: navigating to the local development server at http://localhost:3000/
    using `cy.visit`, and then checking the page to ensure it contains the `Weather
    Application` text using `cy.contains`. If `Weather Application` is found on the
    page, the test will pass; if not, it will fail.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中，我们定义了一个名为`weather application`的测试套件。它使用Cypress测试框架中的describe函数。此测试用例包括两个主要操作：使用`cy.visit`导航到本地开发服务器http://localhost:3000/，然后使用`cy.contains`检查页面以确保它包含`Weather
    Application`文本。如果找到`Weather Application`，则测试将通过；如果没有找到，则测试将失败。
- en: 'Executing the test using `npx cypress run` will, as expected, yield an error
    on the console due to our yet unmodified app:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`npx cypress run`执行测试时，正如预期的那样，由于我们的应用程序尚未修改，控制台将显示错误：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This error reveals that it was anticipating the `Weather Application` text but
    didn’t locate it within the default 4-second timeout specified by Cypress. To
    rectify this, we’ll need to tweak `App.tsx` so that it includes this text.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此错误表明它预期会找到`Weather Application`文本，但未在Cypress指定的默认4秒超时时间内找到它。为了纠正这一点，我们需要调整`App.tsx`，使其包含此文本。
- en: 'After clearing the current content in `App.tsx` (generated by `create-react-app`),
    we’ll insert a simple `h1` tag to display the text:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在清除`App.tsx`中的当前内容（由`create-react-app`生成）后，我们将插入一个简单的`h1`标签以显示文本：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code defines a functional component named `App` in React, which renders
    a `div` element containing an `h1` element with the `Weather Application` text.
    With this heading defined, our Cypress test will pass.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码在React中定义了一个名为`App`的功能组件，它渲染一个包含`Weather Application`文本的`div`元素。有了这个标题的定义，我们的Cypress测试将通过。
- en: Now, let’s move on to the first meaningful feature – allowing users to search
    by a city name.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续到第一个有意义的特性——允许用户按城市名称搜索。
- en: Implementing a City Search feature
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现城市搜索功能
- en: Let’s commence the development of our first feature – City Search. Users will
    be able to enter a city name into a search box, which triggers a request to a
    remote server. Upon receiving the data, we’ll render it into a list for user selection.
    Throughout this chapter, we’ll utilize the OpenWeatherMap API for city searches
    as well as retrieving weather information.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始开发我们的第一个特性——城市搜索。用户将能够将城市名称输入到搜索框中，这将触发对远程服务器的请求。在接收到数据后，我们将将其渲染成列表供用户选择。在整个章节中，我们将使用OpenWeatherMap
    API进行城市搜索以及获取天气信息。
- en: Introducing the OpenWeatherMap API
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍OpenWeatherMap API
- en: OpenWeatherMap is a service that offers global weather data via an API, allowing
    users to access current, forecasted, and historical weather data for any location
    worldwide. It’s a popular choice among developers for embedding real-time weather
    updates into apps and websites.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: OpenWeatherMap是一个通过API提供全球天气数据的服务，允许用户访问任何地点的当前、预测和历史天气数据。它是开发人员在应用程序和网站上嵌入实时天气更新的流行选择。
- en: We’re going to use two APIs in our weather application – one for searching the
    city by name and another for getting the actual real-time weather. To use the
    API, you’ll need the API key you received when following the instructions in the
    *Technical* *requirements* section.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的天气应用程序中，我们将使用两个API：一个用于按名称搜索城市，另一个用于获取实际实时天气。要使用API，您需要按照*技术* *要求*部分中的说明获得的API密钥。
- en: 'You can try sending the request to OpenWeatherMap either in your browser or
    with a command-line tool such as `curl` or http (from [https://httpie.io/](https://httpie.io/)):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以尝试使用浏览器或命令行工具（如`curl`或http [https://httpie.io/](https://httpie.io/)）向OpenWeatherMap发送请求：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This line utilizes the `http` command to send an HTTP request to the OpenWeatherMap
    API, specifically to its geocoding endpoint (`geo/1.0/direct`), looking up cities
    named `Melbourne`, with a limit of 5 results. The `appid` (as specified in the
    preceding URL) parameter is where you need to insert *your* OpenWeatherMap API
    key to authenticate the request.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码使用`http`命令向OpenWeatherMap API发送HTTP请求，特别是其地理编码端点（`geo/1.0/direct`），查找名为`Melbourne`的城市，结果限制为5个。`appid`（如前述URL中指定）参数是您需要插入*您的*
    OpenWeatherMap API密钥以验证请求的地方。
- en: 'So, the command fetches basic geocoding information about cities named Melbourne,
    which can later be used to get weather data for those locations. You will get
    the result in JSON format, like so:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，该命令检索名为墨尔本的城市的基本地理编码信息，这些信息可以稍后用于获取这些位置的天气数据。您将得到如下所示的JSON格式的结果：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Be aware that the OpenWeatherMap free plan comes with a rate limit, restricting
    us to a maximum of 60 requests per minute and 1,000,000 requests per month. While
    these limits may seem high, the number of requests can accumulate quickly during
    development through testing and debugging. To conserve our request allowance,
    we’ll avoid making requests to the real server and instead stub these requests,
    returning predefined values. For a refresher on stubbing, refer to [*Chapter 5*](B21103_05.xhtml#_idTextAnchor124).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，OpenWeatherMap免费计划附带一个速率限制，限制我们每分钟最多60个请求和每月最多1,000,000个请求。虽然这些限制看起来很高，但在开发和测试调试过程中，请求的数量可以迅速累积。为了节省我们的请求配额，我们将避免向真实服务器发送请求，而是模拟这些请求，返回预定义的值。有关模拟的复习，请参阅[*第5章*](B21103_05.xhtml#_idTextAnchor124)。
- en: Let’s save the resultant data into a text file named `search-results.json`,
    located under `cypress/fixtures/search-result.json`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将结果数据保存到名为`search-results.json`的文本文件中，该文件位于`cypress/fixtures/search-result.json`下。
- en: Stubbing the search results
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟搜索结果
- en: 'With the file in place, we can write a test for the `fixtures/search-result.json`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 文件就绪后，我们可以为`fixtures/search-result.json`编写一个测试：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, we created a test case called `''searches for a city''`. The test case
    does the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为`'searches for a city'`的测试用例。该测试用例执行以下操作：
- en: First, it sets up an interception for a `GET` request that goes to the OpenWeatherMap
    API for city searches. Whenever a request matching the criteria is made, it responds
    with a 200 status code and the body content from a predefined `searchResults`
    file, essentially mocking the API response.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它设置了一个拦截针对OpenWeatherMap API城市搜索的`GET`请求。每当有符合标准的请求时，它以200状态码和来自预定义的`searchResults`文件的正文内容作为响应，实际上模拟了API响应。
- en: Then, it navigates to the application running on `http://localhost:3000/`.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它导航到运行在`http://localhost:3000/`的应用程序。
- en: Next, it simulates a user typing `Melbourne` into an input field with a `data-testid`
    value of `search-input` and pressing the *Enter* key.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，它模拟用户在一个具有`data-testid`值为`search-input`的输入字段中输入`Melbourne`，并按下*Enter*键。
- en: Lastly, it checks that a container with a `data-testid` value of `"search-results"`
    contains exactly five elements with a class of `search-result`, which are the
    search results that are returned from the stubbed API request. This verifies that
    the application correctly displays the search results.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，它检查一个具有`data-testid`值为`"search-results"`的容器是否包含恰好五个具有`search-result`类的元素，这些元素是从模拟的API请求返回的搜索结果。这验证了应用程序正确显示了搜索结果。
- en: 'We’re in the red step in TDD (the first step, which indicates that a test is
    failing), so let’s go to our application code, `App.tsx`, to fix the test:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在处于TDD的红色步骤（第一个步骤，表示测试失败），所以让我们进入我们的应用程序代码`App.tsx`来修复测试：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `App` function in this code sets up a simple weather application using React.
    It initializes the `query` and `searchResults` state variables to handle user
    input and display search results, respectively. The `handleKeyDown` and `handleChange`
    event handlers are set up to update the search query and trigger a city search
    when the user presses *Enter*. The `fetchCities` function sends a request to the
    OpenWeatherMap API, processes the response to extract the city names, and updates
    `searchResults`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的`App`函数使用React设置了一个简单的天气应用程序。它初始化`query`和`searchResults`状态变量来处理用户输入和显示搜索结果。`handleKeyDown`和`handleChange`事件处理器被设置来更新搜索查询并在用户按下*Enter*时触发城市搜索。`fetchCities`函数向OpenWeatherMap
    API发送请求，处理响应以提取城市名称，并更新`searchResults`。
- en: In the TSX part, an input field is provided for the user to type a city name,
    and a list displays the search results whenever there are any available.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在TSX部分，提供了一个输入字段供用户输入城市名称，并且每当有可用的搜索结果时，都会显示一个列表。
- en: 'The tests are now passing with these changes, and we can launch our browser
    to access the application. As depicted in *Figure 12**.3*, our implementation
    now displays a drop-down list of cities upon conducting a search:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改后，测试现在通过，我们可以启动浏览器来访问应用程序。如图*图12**.3所示，我们的实现现在在执行搜索后显示城市下拉列表：
- en: '![Figure 12.3: The search result dropdown](img/B31103_12_03.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图12.3：搜索结果下拉菜单](img/B31103_12_03.jpg)'
- en: 'Figure 12.3: The search result dropdown'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3：搜索结果下拉菜单
- en: Note
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: I’ve incorporated some CSS to enhance the visual appeal. However, to maintain
    focus on the core content, the CSS has not been included here. For a complete
    understanding, you can refer to the repository mentioned in the *Technical requirements*
    section to see the full implementation.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经加入了一些CSS来增强视觉效果。然而，为了保持对核心内容的关注，CSS在此处并未包含。为了全面理解，您可以参考*技术要求*部分中提到的仓库，以查看完整的实现。
- en: Enhancing the search result list
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增强搜索结果列表
- en: As we utilize city names for search queries, it’s common to encounter multiple
    matches in the search results. To refine this, we could enrich each item with
    additional details such as the state name, country name, or even coordinates to
    make the results more distinctive.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用城市名称进行搜索查询，在搜索结果中遇到多个匹配项是很常见的。为了细化这一点，我们可以为每个项目添加额外的详细信息，例如州名、国家名，甚至坐标，以使结果更加独特。
- en: Following the TDD approach, we’ll start with a test. Although a Cypress test
    could be crafted, detailing such aspects is better suited for lower-level tests
    such as unit tests. Cypress tests are end-to-end, encompassing all the parts –
    pages, network (even with interceptors) – and from its standpoint, it perceives
    no components, just HTML, CSS, and JavaScript. This makes them more costly to
    run, extending the feedback loop compared to lower-level tests, which generally
    operate in an in-memory browser and focus on isolated areas.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 按照TDD（测试驱动开发）方法，我们将从一个测试开始。虽然可以构建一个Cypress测试，但详细说明这些方面更适合于单元测试等低级测试。Cypress测试是端到端的，包括所有部分——页面、网络（甚至带有拦截器）——并且从其角度来看，它感知不到组件，只有HTML、CSS和JavaScript。这使得它们运行成本更高，与低级测试相比，低级测试通常在内存浏览器中运行，并关注隔离的区域。
- en: For this enhancement, we’ll employ Jest tests, which are more lightweight, faster,
    and offer specificity in test case writing.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这次增强，我们将使用Jest测试，它们更轻量级、更快，并且在测试用例编写中提供特异性。
- en: 'In the following snippet, we aim to test if an item displays the city name:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，我们旨在测试一个项目是否显示城市名称：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we invoke the `render` method from the React Testing Library on a `SearchResultItem`
    component, passing a prop item with a `city` field. Then, we assert that the `Melbourne`
    text is present in the document.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用React Testing Library中的`render`方法，对一个带有`city`字段的`SearchResultItem`组件进行传递属性。然后，我们断言文档中存在`Melbourne`文本。
- en: 'At this point, we lack a `SearchResultItem` component ready for testing. However,
    a slight refactoring can help us extract one. Let’s create a `SearchResultItem.tsx`
    file and define the component as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有准备好用于测试的`SearchResultItem`组件。然而，一点重构可以帮助我们提取一个。让我们创建一个`SearchResultItem.tsx`文件，并按如下定义组件：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, integrate the component in `App.tsx`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将组件集成到`App.tsx`中：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this part of `App.tsx`, we map through `searchResults`, rendering `SearchResultItem`
    for each city, and passing the city data as a prop.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在`App.tsx`的这一部分，我们遍历`searchResults`，为每个城市渲染`SearchResultItem`，并将城市数据作为属性传递。
- en: 'Now, let’s extend our tests to check for the city name, state, and country:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们扩展我们的测试，以检查城市名称、州和国家：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, to accommodate these new fields, we’ll tweak the type definition of `SearchResultItem`
    and render the passed props:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了适应这些新字段，我们将调整`SearchResultItem`的类型定义，并渲染传递的属性：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we define a `SearchResultItemProps` type to specify the shape of the item
    prop, ensuring it contains the `city`, `state`, and `country` fields. Our `SearchResultItem`
    component then renders these fields within a list item, each in a separate `span`
    element.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义一个`SearchResultItemProps`类型，以指定项目属性的结构，确保它包含`city`、`state`和`country`字段。然后，我们的`SearchResultItem`组件将这些字段在列表项中渲染，每个字段都在一个单独的`span`元素中。
- en: 'As you can see, now, the list item provides more details to help users distinguish
    between the results:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，现在，列表项提供了更多细节，以帮助用户区分结果：
- en: '![Figure 12.4: Enhanced city drop-down list](img/B31103_12_04.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图12.4：增强的城市下拉列表](img/B31103_12_04.jpg)'
- en: 'Figure 12.4: Enhanced city drop-down list'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4：增强的城市下拉列表
- en: Before we proceed to the next major feature, let’s tackle some housekeeping
    tasks. While we’ve been focused on delivering the feature, we haven’t given much
    attention to code quality so far, so let’s do that.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续到下一个主要功能之前，让我们先处理一些日常维护任务。虽然我们一直专注于交付功能，但到目前为止，我们并没有太多关注代码质量，所以让我们来做这件事。
- en: Implementing an ACL
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现访问控制列表（ACL）
- en: Within our application, the `SearchResultItem` component serves its purpose
    well. However, the challenge arises from the discrepancy between the data shape
    we require and the data shape we receive from the remote server.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，`SearchResultItem` 组件很好地完成了其任务。然而，挑战来自于我们所需要的数据形状与我们从远程服务器接收到的数据形状之间的差异。
- en: 'Consider the server’s response:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑服务器的响应：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The server’s response includes many elements we don’t need. Moreover, we want
    to shield our `SearchResultItem` component from any future changes to the data
    shape from the server.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器响应中包含许多我们不需要的元素。此外，我们希望保护我们的 `SearchResultItem` 组件免受服务器数据形状未来更改的影响。
- en: As we discussed in [*Chapter 8*](B21103_08.xhtml#_idTextAnchor212), we can employ
    an ACL to address this issue. Using this, we aim to map the city name and state
    directly, but for the country, we want to display its full name to avoid any ambiguity
    in the UI.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第8章*](B21103_08.xhtml#_idTextAnchor212)中讨论的那样，我们可以使用访问控制列表（ACL）来解决这个问题。使用它，我们旨在直接映射城市名称和州，但对于国家，我们希望显示其全名，以避免在用户界面中产生任何歧义。
- en: 'To do this, first, we must define a `RemoteSearchResultItem` type to represent
    the remote data shape:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，首先，我们必须定义一个 `RemoteSearchResultItem` 类型来表示远程数据形状：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we must change the `SearchResultItemProps` type to a class, enabling
    its initialization within the TypeScript code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须将 `SearchResultItemProps` 类型更改为类，使其可以在 TypeScript 代码中初始化：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This segment of code defines a class, `SearchResultItemType`, that accepts a
    `RemoteSearchResultItem` object in its `constructor` and initializes its properties
    accordingly. It also provides getter methods to access these properties, with
    a special handler for the country property to the map country code to its full
    name.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码定义了一个类，`SearchResultItemType`，它在 `constructor` 中接受一个 `RemoteSearchResultItem`
    对象，并相应地初始化其属性。它还提供了获取器方法来访问这些属性，对于国家属性，有一个特殊处理程序将国家代码映射到其全名。
- en: 'Now, our `SearchResultItem` component can utilize this newly defined class:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的 `SearchResultItem` 组件可以利用这个新定义的类：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note how we use the `item.city` and `item.state` getter functions, just like
    a regular JavaScript object.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何使用 `item.city` 和 `item.state` 获取器函数，就像一个常规的 JavaScript 对象一样。
- en: 'Then, in our Jest tests, we can verify the transformation logic straightforwardly,
    as seen here:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的 Jest 测试中，我们可以直接验证转换逻辑，如下所示：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this test, we create an instance of `SearchResultItemType` using a mock `RemoteSearchResultItem`
    object and verify that the transformation logic works as intended – the fields
    are correctly mapped and the country has its full name too.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们使用模拟的 `RemoteSearchResultItem` 对象创建一个 `SearchResultItemType` 实例，并验证转换逻辑是否按预期工作——字段被正确映射，并且国家也有其全名。
- en: 'Once the tests confirm the expected behavior, we can apply this new class within
    our application code, as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦测试确认了预期的行为，我们就可以在我们的应用程序代码中应用这个新类，如下所示：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This function fetches city data from the remote server, transforms the received
    data into instances of `SearchResultItemType`, and then updates the `searchResults`
    state.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数从远程服务器获取城市数据，将接收到的数据转换为 `SearchResultItemType` 实例，然后更新 `searchResults` 状态。
- en: With enriched details in the dropdown, users can identify their desired city.
    Having achieved this, we can proceed to allow users to add cities to their favorite
    list, paving the way to display weather information for these selected cities.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在下拉菜单中添加丰富详情后，用户可以识别他们想要的城镇。在实现这一点后，我们可以继续允许用户将城市添加到他们的收藏列表中，为显示这些选定城市的天气信息铺平道路。
- en: Given our Cypress feature tests, there’s a safeguard against inadvertently breaking
    functionality. Additionally, with the newly incorporated unit tests, any discrepancies
    between remote and local data shapes will be automatically detected. We are now
    well-positioned to embark on developing the next feature.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Cypress 功能测试提供了一个保障，以防止意外破坏功能。此外，随着新引入的单元测试，远程和本地数据形状之间的任何差异都将自动检测。我们现在已经准备好开始开发下一个功能。
- en: Implementing an Add to Favorite feature
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现添加到收藏功能
- en: 'Let’s investigate implementing our next feature: `''adds city to favorite list''`.
    Because this is a feature that is critical in the weather application, we want
    to make sure users can see the city being added and that the dropdown is closed.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调查实现下一个功能：`'添加城市到收藏列表'`。因为这个功能在天气应用中至关重要，我们想要确保用户可以看到添加的城市，并且下拉菜单已经关闭。
- en: 'First, we’ll start with another Cypress test:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将开始另一个 Cypress 测试：
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the test, we set up an intercept to mock a `GET` request to the OpenWeatherMap
    API and then visit the app running on localhost. From here, it simulates typing
    `Melbourne` into a search input and hitting *Enter*. After that, it clicks on
    the first search result and checks if the favorite cities list now contains one
    city. Finally, it verifies that the favorite cities list contains a city element
    with `Melbourne` and `20°C`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中，我们设置了一个拦截来模拟对 OpenWeatherMap API 的 `GET` 请求，然后访问运行在本地的应用程序。从这里，它模拟在搜索输入中键入
    `Melbourne` 并按 *Enter*。之后，它点击第一个搜索结果并检查收藏城市列表是否现在包含一个城市。最后，它验证收藏城市列表是否包含一个具有 `Melbourne`
    和 `20°C` 的城市元素。
- en: 'Please note that there are a few things that need a bit more explanation in
    the last two lines:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在最后两行中，有一些事情需要更多的解释：
- en: '`cy.get(selector)`: This Cypress command is used to query DOM elements on a
    page. It’s similar to `document.querySelector`. Here, it’s being used to select
    elements with specific text content inside a particular part of the DOM. Cypress
    supports not only the basic CSS selectors, such as class and ID selectors, but
    also advanced selectors such as `.city:contains("Melbourne")`, so we can use a
    selector for a more specific selection.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cy.get(selector)`: 这是一个 Cypress 命令，用于查询页面上的 DOM 元素。它与 `document.querySelector`
    类似。在这里，它被用来选择 DOM 特定部分内具有特定文本内容的元素。Cypress 不仅支持基本的 CSS 选择器，如类和 ID 选择器，还支持高级选择器，如
    `.city:contains("Melbourne")`，因此我们可以使用更具体的选择器。'
- en: '`.city:contains(text)`: This is a jQuery-style selector that Cypress supports.
    It allows you to select an element containing specific text. In this case, it’s
    being used to find elements within `[data-testid="favorite-cities"]` that have
    a class of `city` and contain `Melbourne` or `20°C`.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.city:contains(text)`: 这是一个 Cypress 支持的 jQuery 风格的选择器。它允许您选择包含特定文本的元素。在这种情况下，它被用来查找
    `[data-testid="favorite-cities"]` 中具有 `city` 类并包含 `Melbourne` 或 `20°C` 的元素。'
- en: '`.should(''exist'')`: This is a Cypress command that asserts that the selected
    elements should exist in the DOM. If the element does not exist, the test will
    fail.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.should(''exist'')`: 这是一个 Cypress 命令，用于断言选定的元素应该存在于 DOM 中。如果元素不存在，测试将失败。'
- en: 'Now, to get the weather for the city, we need another API endpoint:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了获取城市的天气，我们需要另一个 API 端点：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The API requires two parameters: the latitude and longitude.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: API 需要两个参数：纬度和经度。
- en: 'Then, it returns the current weather in this format:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它以这种格式返回当前的天气：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'There are many fields in the response but we only need some of them for now.
    We can intercept the request and serve the response in the Cypress test, just
    like we did for the city search API:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 响应中有许多字段，但我们目前只需要其中的一些。我们可以拦截请求并在 Cypress 测试中提供响应，就像我们对城市搜索 API 所做的那样：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Transitioning to the implementation, we’ll weave an `onClick` event handler
    into `SearchResultItem`; upon clicking an item, an API call will be triggered,
    followed by the addition of a city to a list designated for rendering:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 转到实现方面，我们将在 `SearchResultItem` 中编织一个 `onClick` 事件处理程序；在点击项目时，将触发 API 调用，然后向用于渲染的列表中添加一个城市。
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, let’s dive into the application code to interlace the data-fetching logic:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入应用程序代码，将数据获取逻辑交织在一起：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `onItemClick` function is triggered upon clicking a city item. It makes
    a network request to the OpenWeatherMap API using the item’s latitude and longitude,
    fetching the current weather data for the selected city. Then, it parses the response
    to JSON, extracts the city name and temperature from the parsed data, and updates
    the city state using the `setCity` function, which will cause the component to
    re-render and display the selected city’s name and current temperature.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`onItemClick` 函数在点击城市项目时触发。它使用项目的纬度和经度向 OpenWeatherMap API 发起网络请求，获取所选城市的当前天气数据。然后，它将响应解析为
    JSON，从解析的数据中提取城市名称和温度，并使用 `setCity` 函数更新城市状态，这将导致组件重新渲染并显示所选城市名称和当前温度。'
- en: 'Note the `SearchResultItemType` parameter in the previous snippet. We’ll need
    to extend this type so that it encompasses latitude and longitude. We can achieve
    this by revisiting the ACL layer in the `SearchResultItemType` class:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意前面片段中的 `SearchResultItemType` 参数。我们需要扩展此类型，使其包含纬度和经度。我们可以通过重新访问 `SearchResultItemType`
    类中的 ACL 层来实现这一点：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: With that, we have extended `SearchResultItemType` with two new fields, `latitude`
    and `longitude`, which will be used in the API query.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们已经将 `SearchResultItemType` 扩展为两个新字段，`latitude` 和 `longitude`，这些字段将在 API
    查询中使用。
- en: 'Finally, upon successfully retrieving the city data, it’s time for rendering:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在成功检索到城市数据后，是时候进行渲染了：
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this block of code, the `onItemClick` function is assigned as the `onClick`
    event handler for each `SearchResultItem`. When a city is clicked, the `onItemClick`
    function is invoked, triggering a fetch request to retrieve the weather data for
    the selected city. Once the data is obtained, the `setCity` function updates the
    city state, which then triggers a re-render, displaying the selected city in the
    **Favorite** **Cities** section.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码块中，将`onItemClick`函数分配为每个`SearchResultItem`的`onClick`事件处理器。当点击城市时，会调用`onItemClick`函数，触发一个获取选定城市天气数据的fetch请求。一旦获得数据，`setCity`函数更新城市状态，然后触发重新渲染，显示在**收藏****城市**部分选定的城市。
- en: Now that all the tests have passed, it signifies that our implementation aligns
    with the expectations up to this point. However, before we proceed to the next
    enhancement, it’s essential to undertake some refactoring to ensure our code base
    remains robust and easily maintainable.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有测试都通过了，这意味着我们的实现与到目前为止的预期相符。然而，在我们进行下一个增强之前，进行一些重构以确保我们的代码库保持健壮和易于维护是非常重要的。
- en: Modeling the weather
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟天气
- en: Just as we modeled the city search result, it’s necessary to model the weather
    for similar reasons – to isolate our implementation from the remote data shape,
    and to centralize data shape conversion, fallback logic, and so on.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们模拟了城市搜索结果一样，出于类似的原因——为了使我们的实现与远程数据形状隔离，以及集中数据形状转换、回退逻辑等。
- en: 'Several areas require refinement. We must do the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 几个区域需要改进。我们必须做以下几件事：
- en: Ensure all the relevant data is typed
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保所有相关数据都已类型化
- en: Create a data model for the weather to centralize all formatting logic
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个天气数据模型以集中所有格式化逻辑
- en: Utilize fallback values within the data model when certain data is unavailable
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数据模型中使用回退值，当某些数据不可用时。
- en: 'Let’s begin with the remote data type, `RemoteCityWeather`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从远程数据类型`RemoteCityWeather`开始：
- en: '[PRE28]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we defined a type called `RemoteCityWeather` to reflect the remote data
    shape (and have also filtered out a few fields that we don’t use).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个名为`RemoteCityWeather`的类型来反映远程数据形状（并且也已经过滤掉了一些我们不使用的字段）。
- en: 'Then, we must define a new type called `CityWeather` for our UI to use CityWeather:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须定义一个新的类型`CityWeather`供我们的UI使用CityWeather：
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This code defines a `CityWeather` class to model city weather data. It takes
    a `RemoteCityWeather` object as a constructor argument and initializes private
    fields from it – that is, `_name`, `_temp`, and `_main`. The class provides getter
    methods to access a city’s name, rounded temperature in degrees, formatted temperature
    string, and the weather description in lowercase.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码定义了一个`CityWeather`类来模拟城市天气数据。它接受一个`RemoteCityWeather`对象作为构造函数参数，并从它初始化私有字段——即`_name`、`_temp`和`_main`。该类提供了获取城市名称、四舍五入的温度（以摄氏度为单位）、格式化的温度字符串以及小写形式的天气描述的getter方法。
- en: For the temperature’s `getter` method, if `_temp` is null or undefined, it returns
    a string, `-/-`. Otherwise, it proceeds to calculate the ceiling (rounding up
    to the nearest whole number) of `_temp` using `Math.ceil(this._temp)`, appends
    a degree symbol to it, and returns this formatted string. This way, the method
    provides a fallback value of `-/-` when `_temp` is not set while formatting the
    temperature value when `_temp` is set.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 对于温度的`getter`方法，如果`_temp`为null或undefined，它返回一个字符串`-/-`。否则，它将使用`Math.ceil(this._temp)`计算`_temp`的向上取整（四舍五入到最接近的整数），并在其后面附加一个度符号，然后返回这个格式化的字符串。这样，当`_temp`未设置时，该方法提供回退值`-/-`，而当`_temp`设置时，格式化温度值。
- en: 'Now, in `App`, we can use the calculated logic:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`App`中，我们可以使用计算出的逻辑：
- en: '[PRE30]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `onItemClick` function is triggered when a city item is clicked. It makes
    a `fetch` request to the OpenWeatherMap API using the latitude and longitude of
    the clicked city item. Upon receiving the response, it converts the response into
    JSON, then creates a new `CityWeather` instance with the received data, and updates
    the city state using `setCity`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击城市项目时，会触发`onItemClick`函数。它使用点击的城市项目的经纬度向OpenWeatherMap API发起一个`fetch`请求。在收到响应后，它将响应转换为JSON格式，然后使用接收到的数据创建一个新的`CityWeather`实例，并使用`setCity`更新城市状态。
- en: 'Additionally, it closes the drop-down menu by setting the `setDropdownOpen`
    state to `false`. If we don’t close it off, the Cypress test will not be able
    to “see” the underlying weather information, which will cause the test to fail,
    as shown in the following screenshot:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它通过将`setDropdownOpen`状态设置为`false`来关闭下拉菜单。如果我们不关闭它，Cypress测试将无法“看到”底层的天气信息，这将导致测试失败，如下面的截图所示：
- en: '![Figure 12.5: The Cypress test failed because the weather is covered](img/B31103_12_05.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图12.5：Cypress测试失败，因为天气被遮挡](img/B31103_12_05.jpg)'
- en: 'Figure 12.5: The Cypress test failed because the weather is covered'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5：Cypress测试失败，因为天气被遮挡
- en: 'Then, we must render the selected city details correspondingly:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须相应地渲染所选城市的详细信息：
- en: '[PRE31]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: For rendering the city part, if the city state is defined (that is, a city has
    been selected), it displays a `div` element with a class name of `city`. Inside
    this `div` element, we can see the city’s name and temperature using the `city.name`
    and `city.temperature` properties, respectively.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于渲染城市部分，如果城市状态已定义（即已选择城市），它将显示一个具有`city`类名的`div`元素。在这个`div`元素内部，我们可以使用`city.name`和`city.temperature`属性分别看到城市的名称和温度。
- en: 'Now, with some additional styling, our application looks like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过一些额外的样式，我们的应用程序看起来是这样的：
- en: '![Figure 12.6: Adding a city to the favorite list](img/B31103_12_06.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图12.6：将城市添加到收藏夹](img/B31103_12_06.jpg)'
- en: 'Figure 12.6: Adding a city to the favorite list'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6：将城市添加到收藏夹
- en: We’ve done an excellent job with data modeling and have set up a solid ACL to
    bolster our UI’s robustness and ease of maintenance. Nonetheless, upon examining
    the root `App` component, we’ll undoubtedly find areas that require improvement.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在数据建模方面做得很好，并建立了一个坚实的访问控制列表（ACL）来增强我们UI的健壮性和易于维护性。然而，在检查根`App`组件时，我们无疑会发现需要改进的地方。
- en: Refactoring the current implementation
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构当前实现
- en: 'Our current `App` component has grown too lengthy for easy readability and
    feature additions, indicating a need for some refactoring to tidy things up. It
    doesn’t adhere well to the single responsibility principle as it takes on multiple
    responsibilities: handling network requests for city search and weather queries,
    managing the state of the dropdown’s open and closed status, and several event
    handlers.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的`App`组件已经变得过长，难以阅读和添加功能，这表明需要进行一些重构以整理代码。它并没有很好地遵循单一职责原则，因为它承担了多个职责：处理城市搜索和天气查询的网络请求，管理下拉列表的打开和关闭状态，以及多个事件处理器。
- en: One approach to realigning with better design principles is to break the UI
    into smaller components. Another is utilizing custom Hooks for state management.
    Given that a significant portion of the logic here revolves around managing the
    state for the city search dropdown, it’s sensible to start by isolating this part.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一种与更好的设计原则重新对齐的方法是将UI分解成更小的组件。另一种方法是利用自定义钩子进行状态管理。鉴于这里的大部分逻辑都围绕着管理城市搜索下拉列表的状态，因此开始时隔离这部分是合理的。
- en: 'Let’s start by extracting all city search-related logic into a custom Hook:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先提取所有与城市搜索相关的逻辑到一个自定义钩子中：
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `useSearchCity` Hook manages the city search functionality. It initializes
    states for query, search results, and dropdown open status using `useState`. The
    `fetchCities` function triggers a network request to fetch cities based on the
    query, processes the response to create `SearchResultItemType` instances, updates
    the search results state, and opens the drop-down list. Two functions, `openDropdownList`
    and `closeDropdownList`, are defined to toggle the dropdown’s open status. The
    Hook returns an object containing these functionalities, which can be used by
    components that import and invoke `useSearchCity`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`useSearchCity`钩子管理城市搜索功能。它使用`useState`初始化查询、搜索结果和下拉列表打开状态。`fetchCities`函数触发网络请求以根据查询获取城市，处理响应以创建`SearchResultItemType`实例，更新搜索结果状态，并打开下拉列表。定义了两个函数，`openDropdownList`和`closeDropdownList`，用于切换下拉列表的打开状态。钩子返回一个包含这些功能的对象，这些功能可以被导入和调用`useSearchCity`的组件使用。'
- en: 'Next, we extract a component, `SearchCityInput`, to handle all the search input-related
    work: to handle the *Enter* key for performing the search, open the drop-down
    list, and handle users clicking on each item:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们提取一个组件，`SearchCityInput`，来处理所有与搜索输入相关的工作：处理*Enter*键以执行搜索，打开下拉列表，以及处理用户点击每个项：
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `SearchCityInput` component is responsible for rendering and managing the
    user input for searching cities, utilizing the `useSearchCity` Hook to access
    search-related functionalities.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`SearchCityInput` 组件负责渲染和管理用户用于搜索城市的输入，利用 `useSearchCity` 钩子访问搜索相关功能。'
- en: The `handleKeyDown` and `handleChange` functions are defined to handle user
    interactions, triggering a search upon pressing *Enter* and updating the query
    on input change, respectively. Then, the `handleItemClick` function is defined
    to handle the action when a search result item is clicked, which triggers the
    `onItemClick` prop function and closes the drop-down list.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了 `handleKeyDown` 和 `handleChange` 函数来处理用户交互，在按下 *Enter* 键时触发搜索，并在输入更改时更新查询。然后，定义了
    `handleItemClick` 函数来处理搜索结果项被点击时的动作，这会触发 `onItemClick` 属性函数并关闭下拉列表。
- en: In the `render` method, an input field is provided for the user to type the
    search query, and the drop-down list is conditionally rendered based on the `isDropdownOpen`
    state. If the dropdown is open and there are search results, a list of `SearchResultItem`
    components is rendered, each being passed the current item data and the `handleItemClick`
    function.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `render` 方法中，提供了一个输入字段供用户输入搜索查询，并根据 `isDropdownOpen` 状态条件性地渲染下拉列表。如果下拉列表打开且有搜索结果，则渲染一个
    `SearchResultItem` 组件列表，每个组件都传递了当前项目数据和 `handleItemClick` 函数。
- en: 'For all the logic of the weather for a city, we can extract another Hook, `useCityWeather`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个城市的所有天气逻辑，我们可以提取另一个钩子 `useCityWeather`：
- en: '[PRE34]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `useFetchCityWeather` custom Hook is designed to manage the fetching and
    storing of weather data for a specified city. It maintains a state, `cityWeather`,
    to hold the weather data. The Hook provides a function, `fetchCityWeather`, which
    takes a `SearchResultItemType` object as an argument to get the `latitude` and
    `longitude` values for the API call.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`useFetchCityWeather` 自定义钩子旨在管理为指定城市获取和存储天气数据。它维护一个状态 `cityWeather` 来保存天气数据。钩子提供了一个函数
    `fetchCityWeather`，它接受一个 `SearchResultItemType` 对象作为参数，以获取 API 调用的 `latitude`
    和 `longitude` 值。'
- en: Upon receiving the response, it processes the JSON data, creates a new `CityWeather`
    object from the `RemoteCityWeather` data, and updates the `cityWeather` state
    with it. The Hook returns the `cityWeather` state and the `fetchCityWeather` function
    for use in other components (`Weather`, for example).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在收到响应后，它处理 JSON 数据，从 `RemoteCityWeather` 数据创建一个新的 `CityWeather` 对象，并使用它更新 `cityWeather`
    状态。钩子返回 `cityWeather` 状态和 `fetchCityWeather` 函数，以便在其他组件（例如 `Weather`）中使用。
- en: 'We could extract a `Weather` component to accept `cityWeather` and render it:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 `Weather` 组件提取出来，接受 `cityWeather` 并进行渲染：
- en: '[PRE35]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `Weather` component accepts a prop, `cityWeather`. If `cityWeather` is defined,
    the component renders a `div` element with the `city` class name, displaying the
    city’s name and temperature in degrees Celsius. If `cityWeather` is undefined,
    it returns `null`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`Weather` 组件接受一个属性 `cityWeather`。如果 `cityWeather` 被定义，组件将渲染一个带有 `city` 类名的
    `div` 元素，显示城市的名称和摄氏度温度。如果 `cityWeather` 未定义，它将返回 `null`。'
- en: 'With the extracted Hook and component, our `App.tsx` is simplified into something
    like this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提取钩子和组件，我们的 `App.tsx` 被简化成如下形式：
- en: '[PRE36]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the `App` function, we’re utilizing the `useFetchCityWeather` custom Hook
    to obtain `cityWeather` and `fetchCityWeather` values. The `onItemClick` function
    is defined to call `fetchCityWeather` with an item of the `SearchResultItemType`
    type. In the rendering part, we can now simply use the component and functions
    we extracted.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `App` 函数中，我们使用 `useFetchCityWeather` 自定义钩子来获取 `cityWeather` 和 `fetchCityWeather`
    值。定义了 `onItemClick` 函数，用于调用 `fetchCityWeather` 并传递 `SearchResultItemType` 类型的项目。在渲染部分，我们现在可以简单地使用我们提取的组件和函数。
- en: 'If we open the project folder to examine the current folder structure, we will
    see that we have different elements defined in distinct modules:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打开项目文件夹来检查当前的文件夹结构，我们会看到我们在不同的模块中定义了不同的元素：
- en: '[PRE37]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now, after all that work, each module possesses a clearer boundary and defined
    responsibility. If you wish to delve into the search functionality, `SearchCityInput`
    is your starting point. For insights on the actual search execution, the `useSearchCity`
    Hook is where you’d look. Each level maintains its own abstraction and distinct
    responsibility, simplifying code comprehension and maintenance significantly.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，经过所有这些工作，每个模块都拥有更清晰的边界和明确的职责。如果你想要深入了解搜索功能，`SearchCityInput` 就是你的起点。对于实际搜索执行的了解，你应该查看
    `useSearchCity` 钩子。每个层级都保持自己的抽象和独特的职责，这显著简化了代码的理解和维护。
- en: Since our code is in a great state and is ready for us to add more features
    on top of it, we can look into enhancing the current feature.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的代码状态良好，并且已经准备好添加更多功能，我们可以考虑增强当前的功能。
- en: Enabling multiple cities in the favorite list
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用收藏夹列表中的多个城市
- en: Now, let’s examine a specific example to illustrate the ease with which we can
    expand the existing code with a simple feature upgrade. A user may have several
    cities they’re interested in, but at present, we can only display one city.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过一个具体的例子来展示我们如何轻松地通过简单的功能升级来扩展现有的代码。用户可能有几个他们感兴趣的城市，但到目前为止，我们只能显示一个城市。
- en: To allow multiple cities in the favorite list, which component should we modify
    to implement this change? Correct – the `useFetchCityWeather` Hook. To enable
    it so that it can manage a list of cities, we’ll need to display this list within
    `App`. There’s no need to delve into the city search-related files, indicating
    that this structure has halved the time we would spend sifting through files.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要允许在收藏夹列表中包含多个城市，我们应该修改哪个组件来实现这一变化？正确——`useFetchCityWeather`钩子。为了使其能够管理城市列表，我们需要在`App`中显示这个列表。没有必要深入研究与城市搜索相关的文件，这表明这种结构将我们筛选文件所需的时间减半。
- en: 'As we’re performing TDD, let’s write a test for the Hook first:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在进行TDD，让我们首先为钩子编写一个测试：
- en: '[PRE38]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Firstly, let’s define some data we want to test against. We can initialize data
    with `weatherAPIResponse`, which contains a mock response from a weather API in
    JSON string format, and `searchResultItem`, which holds an instance of `SearchResultItemType`
    with location details for Melbourne, Australia.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义一些我们想要测试的数据。我们可以使用`weatherAPIResponse`初始化数据，它包含一个来自天气API的模拟响应的JSON字符串格式，以及`searchResultItem`，它包含一个`SearchResultItemType`实例，其中包含澳大利亚墨尔本的位置详情。
- en: 'For the actual test case, we’ll need to use `fetchMock` from `jest-fetch-mock`;
    we installed it in the *Technical* *requirements* section:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实际的测试用例，我们需要使用来自`jest-fetch-mock`的`fetchMock`；我们在*技术要求*部分安装了它：
- en: '[PRE39]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The preceding code sets up a test suite for the `fetchCityWeather` function.
    Before each test, it resets any mocked fetch calls. The test case aims to verify
    that the function returns a list of cities. It mocks an API response using `fetchMock.mockResponseOnce`,
    then invokes the `useFetchCityWeather` custom Hook. The `fetchCityWeather` function
    is called within an `act` block to handle state updates. Finally, the test asserts
    that the returned list of cities contains one city, **Melbourne**.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码为`fetchCityWeather`函数设置了一个测试套件。在每次测试之前，它会重置任何模拟的获取调用。测试用例旨在验证该函数返回一个城市列表。它使用`fetchMock.mockResponseOnce`模拟API响应，然后调用`useFetchCityWeather`自定义钩子。`fetchCityWeather`函数在`act`块内被调用以处理状态更新。最后，测试断言返回的城市列表中包含一个城市，**墨尔本**。
- en: This setup helps test the `fetchCityWeather` function in isolation, ensuring
    it behaves as expected when provided with a specific input and when receiving
    a specific API response.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设置有助于在隔离状态下测试`fetchCityWeather`函数，确保它在提供特定输入并接收到特定API响应时表现如预期。
- en: 'Correspondingly, we need to update the `useFetchCityWeather` Hook to enable
    multiple items:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 相应地，我们需要更新`useFetchCityWeather`钩子以启用多个项目：
- en: '[PRE40]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `useFetchCityWeather` Hook now maintains a state of an array of `CityWeather`
    objects called `cities`. We still send requests to the `OpenWeatherMap` API and
    then we make sure the new item is inserted at the start of the list when it’s
    fetched. It returns an object containing the `cities` array to the calling place.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`useFetchCityWeather`钩子现在维护一个名为`cities`的`CityWeather`对象数组的状态。我们仍然向`OpenWeatherMap`
    API发送请求，并确保在获取新项目时将其插入列表的开头。它返回一个包含`cities`数组的对象，并将其返回到调用位置。'
- en: 'Finally, in `App`, we can iterate over `cities` to generate the `Weather` component
    for each one:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`App`中，我们可以遍历`cities`来为每个城市生成`Weather`组件：
- en: '[PRE41]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `cities` array is mapped over, and for each `CityWeather` object in the
    array, a `Weather` component is rendered. The key prop for each `Weather` component
    is set to the city’s name, and the `cityWeather` prop is set to the `CityWeather`
    object itself, which will display the weather information for each city in the
    list.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`cities`数组被映射，对于数组中的每个`CityWeather`对象，都会渲染一个`Weather`组件。每个`Weather`组件的关键属性被设置为城市的名称，`cityWeather`属性被设置为`CityWeather`对象本身，它将显示列表中每个城市的天气信息。'
- en: 'Now, we will be able to see something like this in the UI:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在UI中看到类似以下内容：
- en: '![Figure 12.7: Showing multiple cities in the favorite list](img/B31103_12_07.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图12.7：显示收藏夹列表中的多个城市](img/B31103_12_07.jpg)'
- en: 'Figure 12.7: Showing multiple cities in the favorite list'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.7：显示收藏列表中的多个城市
- en: Before diving into our next and final feature, it’s essential to make one more
    straightforward improvement to the existing code – ensuring adherence to the single
    responsibility principle.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨我们下一个也是最后一个特性之前，对现有代码进行一次更直接的改进至关重要——确保遵循单一职责原则。
- en: Refactoring the weather list
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构天气列表
- en: 'The functionality is operational and all tests have passed; the subsequent
    focus is on enhancing code quality. Keep the TDD approach in mind: tackle one
    task at a time and make incremental improvements. Then, we can extract a `WeatherList`
    component that renders the whole city list:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 功能已正常运行，所有测试都已通过；接下来的重点是提升代码质量。请记住 TDD 方法：一次处理一个任务，逐步改进。然后，我们可以提取一个 `WeatherList`
    组件来渲染整个城市列表：
- en: '[PRE42]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `WeatherList` component receives a cities prop, which is an array of `CityWeather`
    objects. It iterates through this array using `map`, rendering a `Weather` component
    for each city.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`WeatherList` 组件接收一个 `cities` 属性，它是一个 `CityWeather` 对象的数组。它使用 `map` 方法遍历这个数组，为每个城市渲染一个
    `Weather` 组件。'
- en: 'With the new `WeatherList` component in place, `App.tsx` will be simplified
    to something like this:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的 `WeatherList` 组件到位后，`App.tsx` 将简化为如下所示：
- en: '[PRE43]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Fantastic! Now that our application structure is clean and each component has
    a single responsibility, this is an opportune time to dive into implementing a
    new (and the last one) feature to enhance our weather application further.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在我们的应用程序结构已经整洁，每个组件都拥有单一职责，这正是我们深入实现一个新特性（也是最后一个）以进一步增强我们的天气应用程序的好时机。
- en: Fetching previous weather data when the application relaunches
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序重新启动时获取以前的天气数据
- en: For the final feature in our weather application, we aim to retain the user’s
    selections so that upon their next visit to the application, instead of encountering
    an empty list, they see the cities they selected previously. This feature is likely
    to be highly utilized – users will only need to add a few cities initially, and
    afterward, they may merely open the application to have the weather for their
    cities loaded automatically.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的天气应用程序的最后一个特性中，我们旨在保留用户的选取，以便在他们下次访问应用程序时，而不是遇到一个空列表，他们能看到之前选择的那些城市。这个特性可能会被高度使用——用户最初只需要添加几个城市，之后他们只需打开应用程序，他们的城市天气就会自动加载。
- en: 'So, let’s start the feature with a user acceptance test using Cypress:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们使用 Cypress 开始这个特性的用户验收测试：
- en: '[PRE44]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `cy.window()` command accesses the global window object and sets a `favoriteItems`
    item in `localStorage` with the items array. Following that, `cy.intercept()`
    stubs the network request to the OpenWeatherMap API, using a fixture file called
    `melbourne.json` for the mock response. The `cy.visit()` command navigates to
    the application on `http://localhost:3000/`. Once on the page, the test checks
    for one city item in the favorite cities list, verifies the presence of a city
    item for `Melbourne`, and confirms it displays a temperature of `20°C`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`cy.window()` 命令访问全局窗口对象，并在 `localStorage` 中设置一个 `favoriteItems` 项，该项包含项目数组。随后，`cy.intercept()`
    模拟对 OpenWeatherMap API 的网络请求，使用名为 `melbourne.json` 的固定文件作为模拟响应。`cy.visit()` 命令导航到
    `http://localhost:3000/` 上的应用程序。一旦进入页面，测试将检查收藏城市列表中的一个城市项，验证 `Melbourne` 城市项的存在，并确认它显示的温度为
    `20°C`。'
- en: In other words, we set up one item in `localStorage` so that when the page loads,
    it can read `localStorage` and make a request to the remote server, just like
    what we do in `onItemClick`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们在 `localStorage` 中设置了一个项目，以便在页面加载时，它可以读取 `localStorage` 并向远程服务器发送请求，就像我们在
    `onItemClick` 中做的那样。
- en: 'Next, we’ll need to extract a data fetching function within `useFetchCityWeather`.
    Currently, the `fetchCityWeather` function is handling two tasks – fetching data
    and updating the cities’ state. To adhere to the single responsibility principle,
    we should create a new function solely for fetching data, leaving `fetchCityWeather`
    to handle updating the state:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在 `useFetchCityWeather` 中提取一个数据获取函数。目前，`fetchCityWeather` 函数正在处理两个任务——获取数据和更新城市状态。为了遵循单一职责原则，我们应该创建一个新的仅用于获取数据的函数，让
    `fetchCityWeather` 处理更新状态：
- en: '[PRE45]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `fetchCityWeatherData` function takes a `SearchResultItemType` object as
    an argument, constructs a URL with the latitude and longitude of the item, and
    sends a `fetch` request to the OpenWeatherMap API. Upon receiving the response,
    it converts the response into JSON, creates a new `CityWeather` object with the
    JSON data, and returns it.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetchCityWeatherData` 函数接受一个 `SearchResultItemType` 对象作为参数，使用该对象的纬度和经度构建一个
    URL，并向 OpenWeatherMap API 发送一个 `fetch` 请求。在收到响应后，它将响应转换为 JSON 格式，使用 JSON 数据创建一个新的
    `CityWeather` 对象，并将其返回。'
- en: 'Now, `fetchCityWeather` can be updated as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`fetchCityWeather` 可以更新如下：
- en: '[PRE46]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `useFetchCityWeather` Hook now contains a `fetchCityWeather` function that
    calls `fetchCityWeatherData` with a given `SearchResultItemType` item. When the
    promise resolves, it receives a `CityWeather` object and then updates the state
    cities by adding the new `CityWeather` object at the beginning of the existing
    cities array.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`useFetchCityWeather` 钩子现在包含一个 `fetchCityWeather` 函数，该函数使用给定的 `SearchResultItemType`
    项目调用 `fetchCityWeatherData`。当承诺解决时，它接收一个 `CityWeather` 对象，然后通过在现有城市数组开头添加新的 `CityWeather`
    对象来更新状态中的城市。'
- en: 'Next, in the `App` component, we can use `useEffect` to hydrate the `localStorage`
    data and send requests for the actual weather data:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `App` 组件中，我们可以使用 `useEffect` 来填充 `localStorage` 数据并发送实际天气数据的请求：
- en: '[PRE47]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In this code snippet, a `useEffect` Hook triggers a function named `hydrate`
    when the component mounts thanks to the empty dependency array, `[]`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中，一个 `useEffect` 钩子通过空依赖数组 `[]` 触发名为 `hydrate` 的函数，当组件挂载时。
- en: Inside `hydrate`, firstly, it retrieves a stringified array from `localStorage`
    under the `favoriteItems` key, parsing it back to a JavaScript array, or defaulting
    to an empty array if the key doesn’t exist. Then, it maps through this items array,
    creating a new instance of `SearchResultItemType` for each item, which it passes
    to the `fetchCityWeatherData` function. This function returns a promise, which
    is collected into an array of promises.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `hydrate` 内部，首先，它从 `localStorage` 中的 `favoriteItems` 键检索一个字符串化的数组，将其解析回 JavaScript
    数组，如果该键不存在，则默认为空数组。然后，它遍历这个项目数组，为每个项目创建一个新的 `SearchResultItemType` 实例，并将其传递给 `fetchCityWeatherData`
    函数。此函数返回一个承诺，该承诺被收集到一个承诺数组中。
- en: Using `Promise.all`, it waits for all these promises to resolve before updating
    the state with `setCities`, populating it with the fetched city weather data.
    Finally, `hydrate` is called within the `useEffect` to execute this logic upon
    component mounting.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Promise.all`，它在更新状态之前等待所有这些承诺解决，使用 `setCities` 填充获取的城市天气数据。最后，在组件挂载时，在 `useEffect`
    中调用 `hydrate` 来执行此逻辑。
- en: 'Finally, to save an item in `localStorage` when a user clicks an item, we need
    a bit more code:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了在用户点击项目时在 `localStorage` 中保存项目，我们需要更多的代码：
- en: '[PRE48]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Here, the `onItemClick` function accepts an argument item of the `SearchResultItemType`
    type. Inside the function, `setTimeout` is utilized with a delay of `0` milliseconds,
    essentially deferring the execution of its contents until after the current call
    stack has cleared – so, the UI will not be blocked.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`onItemClick` 函数接受一个 `SearchResultItemType` 类型的参数。在函数内部，使用 `setTimeout`
    并设置延迟为 `0` 毫秒，实际上是将其内容的执行推迟到当前调用栈清除之后——因此，UI 不会被阻塞。
- en: Within this deferred block, it retrieves a stringified array from `localStorage`
    under the `favoriteItems` key, parsing it back to a JavaScript array, or defaulting
    to an empty array if the key doesn’t exist. Then, it creates a new object, `newItem`,
    from the item argument, extracting and renaming some properties.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在此延迟块中，它从 `localStorage` 中的 `favoriteItems` 键检索一个字符串化的数组，将其解析回 JavaScript 数组，如果该键不存在，则默认为空数组。然后，它从参数项中提取并重命名一些属性，创建一个新的对象
    `newItem`。
- en: Following this, it updates the `favoriteItems` key in `localStorage` with a
    stringified array containing `newItem` at the beginning, followed by the previously
    stored items.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，它使用包含 `newItem` 在开头，后跟先前存储的项目字符串化的数组更新 `localStorage` 中的 `favoriteItems`
    键。
- en: Outside of `setTimeout`, it calls `fetchCityWeather` with the item argument,
    fetching weather data for the clicked city, and returns the result of this call
    from `onItemClick`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `setTimeout` 之外，它使用项目参数调用 `fetchCityWeather`，获取点击城市的天气数据，并从 `onItemClick`
    返回此调用的结果。
- en: 'Now, when we inspect `localStorage` in our browser, we will see that the objects
    are listed in JSON format and that the data will persist until users explicitly
    clean it:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们检查浏览器中的 `localStorage` 时，我们将看到对象以 JSON 格式列出，并且数据将一直持续到用户明确清理它：
- en: '![Figure 12.8: Using data from local storage](img/B31103_12_08.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图12.8：使用本地存储的数据](img/B31103_12_08.jpg)'
- en: 'Figure 12.8: Using data from local storage'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8：使用本地存储的数据
- en: Excellent job! Everything is now functioning well, and the code is in a robust
    shape that’s easy to build upon. Moreover, the project structure is intuitive,
    facilitating easy navigation and file location whenever we need to implement changes.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！现在一切都在良好运行，代码处于一个易于构建的健壮状态。此外，项目结构直观，便于我们在需要实施更改时轻松导航和定位文件。
- en: This chapter was quite extensive and was packed with insightful information,
    serving as a great recapitulation of the knowledge you’ve acquired thus far. While
    it would be engaging to continue adding more features together, I believe now
    is an opportune time for you to dive in and apply the concepts and techniques
    you’ve gleaned from this book. I’ll entrust the enhancement task to you, confident
    that you’ll make commendable adjustments as you introduce more features.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容相当丰富，充满了有见地的信息，是对你迄今为止所学知识的良好总结。虽然继续添加更多功能会很有趣，但我相信现在是时候让你深入应用从本书中学到的概念和技术了。我将增强任务委托给你，相信你会在引入更多功能时做出值得称赞的调整。
- en: Summary
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we embarked on creating a weather application from scratch,
    adhering to the TDD methodology. We employed Cypress for user acceptance tests
    and Jest for unit tests, progressively building out the application’s features.
    Key practices such as modeling domain objects, stubbing network requests, and
    applying the single responsibility principle during refactoring were also explored.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从零开始创建了一个天气应用程序，遵循TDD方法。我们使用了Cypress进行用户验收测试和Jest进行单元测试，逐步构建应用程序的功能。在重构过程中，我们还探讨了诸如建模领域对象、模拟网络请求以及应用单一职责原则等关键实践。
- en: While not exhaustive in covering all the techniques from previous chapters,
    this chapter underscored the importance of maintaining a disciplined pace during
    the development phase. It highlighted the value of being able to identify code
    “smells” and address them effectively, all while ensuring a solid test coverage
    to foster a robust and maintainable codebase. This chapter served as a practical
    synthesis, urging you to apply the acquired knowledge and techniques to enhance
    the application further.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本章并未涵盖前几章中所有技术，但它强调了在开发阶段保持纪律性步伐的重要性。它突出了能够识别代码“异味”并有效解决它们的价值，同时确保有坚实的测试覆盖率，以促进构建一个健壮且易于维护的代码库。本章作为一个实用的综合，敦促你将所学知识和技能应用于进一步增强应用程序。
- en: In the upcoming and concluding chapter, we’ll recap the anti-patterns we’ve
    explored, revisiting the design principles and practices we’ve examined, and also
    provide additional resources for further learning.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在即将到来的最后一章中，我们将回顾我们探索的反模式，重新审视我们考察的设计原则和实践，并提供额外的资源以供进一步学习。
