- en: Advanced Ajax
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级 Ajax
- en: Many web applications require frequent network communication. Using jQuery,
    our web pages can exchange information with the server without requiring new pages
    to be loaded in the browser.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Web 应用程序需要频繁的网络通信。使用 jQuery，我们的网页可以与服务器交换信息，而无需在浏览器中加载新页面。
- en: 'In [Chapter 6](3a5a790f-4c0a-4b63-bb00-cc38e78309c6.xhtml), *Sending Data with
    Ajax*, you learned simple ways to interact with the server asynchronously. In
    this more advanced chapter, we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 6 章](3a5a790f-4c0a-4b63-bb00-cc38e78309c6.xhtml) *使用 Ajax 发送数据* 中，你学会了与服务器异步交互的简单方法。在这一更高级的章节中，我们将包括：
- en: Error-handling techniques for dealing with network interruptions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理网络中断的错误处理技术
- en: The interactions between Ajax and the jQuery deferred object system
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ajax 和 jQuery 延迟对象系统之间的交互
- en: Caching and throttling techniques for reducing network traffic
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用缓存和节流技术来减少网络流量
- en: Ways to extend the inner workings of the Ajax system using transports, prefilters,
    and data type converters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用传输器、预过滤器和数据类型转换器扩展 Ajax 系统的内部工作方式的方法
- en: Implementing progressive enhancement with Ajax
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Ajax 实现渐进增强
- en: Throughout this book, we encountered the concept of *progressive enhancement*.
    To reiterate, this philosophy ensures a positive user experience for all users
    by mandating that a working product be put in place first before additional embellishments
    are added for users with modern browsers.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们遇到了 *渐进增强* 的概念。重申一下，这一理念确保所有用户都能获得积极的用户体验，要先确保有一个可用的产品，然后再为使用现代浏览器的用户添加额外的装饰。
- en: 'As an example, we''ll build a form that searches GitHub repositories:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，我们将构建一个搜索 GitHub 代码库的表单：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Getting the example code
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 获取示例代码
- en: You can access the example code from the following GitHub repository: [https://github.com/PacktPublishing/Learning-jQuery-3](https://github.com/PacktPublishing/Learning-jQuery-3).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从以下 GitHub 代码库访问示例代码：[https://github.com/PacktPublishing/Learning-jQuery-3](https://github.com/PacktPublishing/Learning-jQuery-3)。
- en: 'The search form is a normal form element with a text input and a submit button
    labeled as Request:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索表单是一个普通的表单元素，包括一个文本输入和一个标有请求的提交按钮：
- en: '![](img/Screen-Shot-2017-04-13-at-10.35.47-AM.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Screen-Shot-2017-04-13-at-10.35.47-AM.png)'
- en: 'When the Request button of this form is clicked on, the form submits as normal;
    the user''s browser is directed to [https://github.com/search](https://github.com/search) and
    the results are displayed:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击该表单的请求按钮时，表单会像平常一样提交；用户的浏览器会被重定向到[https://github.com/search](https://github.com/search)，并显示结果：
- en: '![](img/Screen-Shot-2017-03-27-at-4.46.23-PM.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Screen-Shot-2017-03-27-at-4.46.23-PM.png)'
- en: 'However, we want to load this content into the `#response` container of our
    search page rather than leaving the page. If the data was stored on the same server
    as our search form, we could harvest the relevant portion of the page using the
    `.load()` method:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们希望将这些内容加载到我们搜索页面的 `#response` 容器中，而不是离开页面。如果数据存储在与我们的搜索表单相同的服务器上，我们可以使用
    `.load()` 方法提取页面的相关部分：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Listing 13.1
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.1
- en: However, since GitHub is under a different hostname, the default cross-domain
    policy of the browser will not allow this request to happen.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于 GitHub 在不同的主机名下，浏览器的默认跨域策略将阻止这个请求的发生。
- en: Harvesting JSONP data
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取 JSONP 数据
- en: In [Chapter 6](3a5a790f-4c0a-4b63-bb00-cc38e78309c6.xhtml), *Sending Data with
    Ajax*, we saw that JSONP is simply JSON with an added layer of server behavior
    allowing requests to be made from a different site. When a request is made for
    JSONP data, a special query string parameter is provided that allows the requesting
    script to process the data. This parameter can be called anything the JSONP server
    wishes; in the case of the GitHub API, the parameter uses the default name, `callback`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 6 章](3a5a790f-4c0a-4b63-bb00-cc38e78309c6.xhtml) *使用 Ajax 发送数据* 中，我们看到 JSONP
    只是 JSON 加上了允许从不同站点进行请求的服务器行为的一个附加层。当请求 JSONP 数据时，提供了一个特殊的查询字符串参数，允许请求脚本处理数据。这个参数可以被
    JSONP 服务器命名任何名称；在 GitHub API 的情况下，该参数使用默认名称 `callback`。
- en: 'Because the default `callback` name is used, the only setup required to make
    a JSONP request is to declare to jQuery that `jsonp` is the data type we are expecting:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因为使用了默认的 `callback` 名称，使得要进行 JSONP 请求唯一需要的设置就是告诉 jQuery `jsonp` 是我们期望的数据类型：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Listing 13.2
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.2
- en: 'Now, we can inspect the JSON data in the console. The data in this case is
    an array of objects, each describing a GitHub repository:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在控制台中检查 JSON 数据。在这种情况下，数据是一个对象数组，每个对象描述一个 GitHub 代码库：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'All of the data we need to display about a repository is included in this object.
    We simply need to format it appropriately for display. Creating the HTML for an
    item is somewhat involved, so we''ll break that step out into its own helper function:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 关于一个仓库的所有我们需要显示的数据都包含在这个对象中。我们只需要适当地对其进行格式化以进行显示。为一个项目创建 HTML 有点复杂，所以我们将这一步拆分成自己的辅助函数：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Listing 13.3
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 第13.3节
- en: The `buildItem()` function converts the JSON object into an HTML list item. This
    includes a link to the main GitHub repository page followed by the description.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`buildItem()`函数将 JSON 对象转换为 HTML 列表项。这包括一个指向主 GitHub 仓库页面的链接，后跟描述。'
- en: 'At this point, we have a function that creates the HTML for a single item.
    When our Ajax call completes, we''ll need to call this function on every returned
    object and display all of the results:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们有一个函数来为单个项目创建 HTML。当我们的 Ajax 调用完成时，我们需要在每个返回的对象上调用此函数，并显示所有结果：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Listing 13.4
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第13.4节
- en: 'Now that we have a functional `success` handler, performing a search nicely
    presents the results in a column next to our form:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个功能性的`success`处理程序，在搜索时，会将结果很好地显示在我们表单旁边的一列中：
- en: '![](img/Screen-Shot-2017-03-28-at-12.32.43-AM.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Screen-Shot-2017-03-28-at-12.32.43-AM.png)'
- en: Handling Ajax errors
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理 Ajax 错误
- en: Introducing any kind of network interaction into an application brings along
    some degree of uncertainty. The user's connection could drop in the middle of
    an operation or a temporary server issue could interrupt communications. Because
    of these reliability concerns, we should always plan for the worst case and prepare
    for error scenarios.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 将任何类型的网络交互引入应用程序都会带来一定程度的不确定性。用户的连接可能会在操作过程中断开，或者临时服务器问题可能会中断通信。由于这些可靠性问题，我们应该始终为最坏的情况做准备，并准备好处理错误情况。
- en: 'The `$.ajax()` function can take a callback function named `error` to be called
    in these situations. In this callback, we should provide some kind of feedback
    to the user indicating that an error has occurred:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`$.ajax()`函数可以接受一个名为`error`的回调函数，在这些情况下调用。在这个回调中，我们应该向用户提供某种反馈，指示发生了错误：'
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Listing 13.5
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第13.5节
- en: 'The error callback can be triggered for a number of reasons. Among these are:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 错误回调可能由多种原因触发。其中包括：
- en: The server returned an error status code, such as 403 Forbidden, 404 Not Found,
    or 500 Internal Server Error.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器返回了错误状态码，例如403 Forbidden、404 Not Found或500 Internal Server Error。
- en: The server returned a redirection status code, such as 301 Moved Permanently.
    An exception is 304 Not Modified, which does not trigger an error because the
    browser can handle this condition correctly.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器返回了重定向状态码，例如301 Moved Permanently。一个例外是304 Not Modified，它不会触发错误，因为浏览器可以正确处理这种情况。
- en: The data returned by the server could not be parsed as specified (for example,
    it is not valid JSON data when `dataType` is `json`).
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器返回的数据无法按照指定的方式解析（例如，在`dataType`为`json`时，它不是有效的JSON数据）。
- en: The `.abort()` method is called on the `XMLHttpRequest` object.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`XMLHttpRequest`对象上调用了`.abort()`方法。
- en: Detecting and responding to these conditions is important in providing the best
    possible user experience. We saw in [Chapter 6](3a5a790f-4c0a-4b63-bb00-cc38e78309c6.xhtml),
    *Sending Data with Ajax*, that the error code, if any, is provided to us in the
    `.status` property of the `jqXHR` object that is passed to the error callback.
    We can use the value of `jqXHR.status` to react differently to different kinds
    of errors, if that is appropriate.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 检测和响应这些条件对提供最佳用户体验非常重要。我们在[第6章](3a5a790f-4c0a-4b63-bb00-cc38e78309c6.xhtml)中看到，*通过
    Ajax 发送数据*，如果有的话，错误代码是通过传递给错误回调的`jqXHR`对象的`.status`属性提供给我们的。如果合适的话，我们可以使用`jqXHR.status`的值对不同类型的错误做出不同的反应。
- en: However, the server errors are only useful when they are actually observed.
    Some errors are immediately detected, but other conditions can cause a long delay
    between the request and eventual error response.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，服务器错误只有在实际观察到时才有用。有些错误会立即被检测到，但其他情况可能导致请求和最终错误响应之间的长时间延迟。
- en: 'When a reliable server timeout mechanism is not available, we can enforce our
    own client-side request timeout. By providing a time in milliseconds to the timeout
    option, we tell `$.ajax()` to trigger `.abort()` on its own if that amount of
    time elapses before a response is received:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当可靠的服务器超时机制不可用时，我们可以强制执行自己的客户端请求超时。通过向超时选项提供以毫秒为单位的时间，我们告诉`$.ajax()`在收到响应之前超过该时间量时自行触发`.abort()`：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Listing 13.6
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 第13.6节
- en: With the timeout in place, we can be assured that within 10 seconds either the
    data will be loaded or the user will receive an error message.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有了超时设置，我们可以确保在10秒内要么加载数据，要么用户会收到错误消息。
- en: Using the jqXHR object
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用jqXHR对象
- en: When an Ajax request is made, jQuery determines the best mechanism available
    for retrieving the data. This transport could be the standard `XMLHttpRequest`
    object, the Microsoft ActiveX `XMLHTTP` object, or a `<script>` tag.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当发出Ajax请求时，jQuery会确定获取数据的最佳机制。这个传输可以是标准的`XMLHttpRequest`对象，Microsoft ActiveX的`XMLHTTP`对象或者`<script>`标签。
- en: 'Because the transport used can vary from request to request, we need a common
    interface in order to interact with the communication. The `jqXHR` object provides
    this interface for us. It is a wrapper for the `XMLHttpRequest` object when that
    transport is used, and in other cases, it simulates `XMLHttpRequest` as best it
    can. Among the properties and methods it exposes are:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因为使用的传输方式可能会因请求而异，所以我们需要一个通用接口来与通信进行交互。`jqXHR`对象为我们提供了这个接口。当使用该传输方式时，它是`XMLHttpRequest`对象的包装器，在其他情况下，它会尽可能模拟`XMLHttpRequest`。它暴露的属性和方法包括：
- en: '`.responseText` or `.responseXML`, containing the returned data'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.responseText`或`.responseXML`，包含返回的数据'
- en: '`.status` and `.statusText`, containing a status code and description'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.status`和`.statusText`，包含状态代码和描述'
- en: '`.setRequestHeader()` to manipulate the HTTP headers sent with the request'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.setRequestHeader()`以操作与请求一起发送的HTTP头部。'
- en: '`.abort()` to prematurely halt the transaction'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.abort()`以过早终止事务'
- en: This `jqXHR` object is returned from all of jQuery's Ajax methods, so we can
    store the result if we need access to any of these properties or methods.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 所有jQuery的Ajax方法都会返回这个`jqXHR`对象，因此，如果我们需要访问这些属性或方法，我们可以存储结果。
- en: Ajax promises
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ajax promises
- en: Perhaps a more important aspect of `jqXHR` than the `XMLHttpRequest` interface,
    however, is that it also acts as a promise. In [Chapter 11](18ed1c5d-dfac-4361-b647-0cb63f5dd58b.xhtml),
    *Advanced Effects*, you learned about deferred objects, which allow us to set
    callbacks to be fired when certain operations are complete. An Ajax call is an
    example of such operation, and the `jqXHR` object provides the methods we expect
    from a deferred object's promise.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，比`XMLHttpRequest`接口更重要的是，`jqXHR`还充当了一个promise。在[第11章](18ed1c5d-dfac-4361-b647-0cb63f5dd58b.xhtml)的*高级特效*中，你了解了deferred对象，它允许我们设置在某些操作完成时触发回调。Ajax调用就是这样一种操作的示例，`jqXHR`对象提供了我们从deferred对象的promise中期望的方法。
- en: 'Using the promise''s methods, we can rewrite our `$.ajax()` call to replace
    the success and error callbacks with an alternate syntax:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用promise的方法，我们可以重写我们的`$.ajax()`调用，以替换成功和错误回调的替代语法：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Listing 13.7
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.7
- en: At first glance, calling `.then()` and `.catch()` doesn't seem any more useful
    than the callback syntax we used previously. However, the promise methods offer
    several advantages. First, the methods can be called multiple times to add more
    than one handler if desired. Second, if we store the result of the `$.ajax()`
    call in a constant, we can attach the handlers later if that makes our code structure
    more readable. Third, the handlers will be invoked immediately if the Ajax operation
    is already complete when they are attached. Finally, we should not discount the
    readability advantage of using a syntax that is consistent with other parts of
    the jQuery library, and with native JavaScript promises.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，调用`.then()`和`.catch()`似乎并不比我们之前使用的回调语法更有用。然而，promise方法提供了几个优点。首先，这些方法可以被多次调用以添加更多的处理程序（handlers）（如果需要的话）。其次，如果我们将`$.ajax()`调用的结果存储在一个常量中，我们可以稍后调用处理程序，如果这样做能够使我们的代码结构更易读。第三，如果在附加处理程序时Ajax操作已经完成，处理程序将立即被调用。最后，我们不应忽视使用与jQuery库其他部分和本机JavaScript
    promises一致的语法的可读性优势。
- en: 'As another example of using the promise methods, we can add a loading indicator
    when a request is made. Since we want to hide the indicator when the request completes,
    successfully or otherwise, the `.always()` method will come in handy:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个使用promise方法的例子，我们可以在发出请求时添加一个加载指示器。由于我们希望在请求完成时隐藏指示器，无论成功与否，`.always()`方法将非常有用：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Listing 13.8
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.8
- en: Before we issue the `$.ajax()` call, we add the `loading` class to the response
    container. Once the loading is complete, we remove it again. By doing so, we have
    further enhanced the user experience because there is now a visual indicator that
    something is happening in the background.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在发出 `$.ajax()` 调用之前，我们将 `loading` 类添加到响应容器中。加载完成后，我们再次将其删除。通过这样做，我们进一步增强了用户体验，因为现在有一个视觉指示器表明后台正在发生某事。
- en: To really get a grasp of how the promise behavior can help us, though, we need
    to look at what we can do if we store the result of our `$.ajax()` call for later
    use.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正掌握 promise 行为如何帮助我们，我们需要看看如果将 `$.ajax()` 调用的结果存储起来供以后使用时我们可以做什么。
- en: Caching responses
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存响应
- en: If we need to use the same piece of data repeatedly, it is wasteful to make
    an Ajax request each time. To prevent this, we can cache the returned data in
    a variable. When we need to use some data, we can check to see whether the data
    is already in the cache. If so, we act on this data. If not, we need to make an
    Ajax request, and in its `.done()` handler, we store the data in the cache and
    act on the returned data.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要重复使用相同的数据片段，每次都进行 Ajax 请求是低效的。为了防止这种情况，我们可以将返回的数据缓存在一个变量中。当我们需要使用某些数据时，我们可以检查数据是否已经在缓存中。如果是，我们就对这些数据采取行动。如果没有，我们需要进行
    Ajax 请求，在其 `.done()` 处理程序中，我们将数据存储在缓存中并对返回的数据进行操作。
- en: 'If we exploit the properties of promises, it can be quite simple:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们利用 promise 的特性，事情会变得相当简单：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Listing 13.9
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.9
- en: We've introduced a new `Map` constant named `cache` to hold the `jqXHR` promises
    that we create. The keys of this map correspond to the searches being performed.
    When the form is submitted, we look to see whether there is already a `jqXHR` promise
    stored for that key. If not, we perform the query as before, storing the resulting
    object inside `api`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入了一个名为 `cache` 的新的 `Map` 常量，用于保存我们创建的 `jqXHR` promises。这个映射的键对应于正在执行的搜索。当提交表单时，我们会查看是否已经为该键存储了一个
    `jqXHR` promise。如果没有，我们像以前一样执行查询，将结果对象存储在 `api` 中。
- en: The `.then()`, `.catch()`, and `.always()` handlers are then attached to the
    `jqXHR` promise. Note that this happens regardless of whether an Ajax request
    was made. There are two possible situations to consider here.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`.then()`、`.catch()` 和 `.always()` 处理程序然后附加到 `jqXHR` promise。请注意，无论是否进行了 Ajax
    请求，这都会发生。这里有两种可能的情况需要考虑。'
- en: 'First, the Ajax request might be sent if it hasn''t been before. This is just
    like the previous behavior: the request is issued and we use the promise methods
    to attach handlers to the `jqXHR` object. When a response comes back from the
    server, the appropriate callbacks are fired and the result is printed to the screen.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果之前还没有发送过 Ajax 请求，就会发送 Ajax 请求。这与以前的行为完全一样：发出请求，然后我们使用 promise 方法将处理程序附加到
    `jqXHR` 对象上。当服务器返回响应时，会触发适当的回调，并将结果打印到屏幕上。
- en: On the other hand, if we have performed this search in the past, the `jqXHR` promise
    is already stored in `cache`. In this case, no new search is performed, but we
    still call the promise methods on the stored object. This attaches new handlers
    to the object, but since the deferred object has already been resolved, the relevant
    handlers are fired immediately.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们过去执行过此搜索，则 `cache` 中已经存储了 `jqXHR` promise。在这种情况下，不会执行新的搜索，但我们仍然在存储的对象上调用
    promise 方法。这会将新的处理程序附加到对象上，但由于延迟对象已经解决，因此相关的处理程序会立即触发。
- en: The jQuery deferred object system handles all the hard work for us. With a couple
    of lines of code, we have eliminated duplicate network requests from the application.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 延迟对象系统为我们处理了所有繁重的工作。几行代码，我们就消除了应用程序中的重复网络请求。
- en: Throttling Ajax requests
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制 Ajax 请求速率
- en: 'A common feature of searches is to display a dynamic list of results as the
    user is typing. We can emulate this "live search" feature for our jQuery API search
    by binding a handler to the `keyup` event:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索的常见功能是在用户输入时显示动态结果列表。我们可以通过将处理程序绑定到 `keyup` 事件来模拟这个“实时搜索”功能，用于我们的 jQuery API
    搜索：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Listing 13.10
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.10
- en: Here, we simply trigger the form's submit handler whenever the user types something
    in the Search field. This could have the effect of sending many requests across
    the network in rapid succession, depending on the speed at which the user types.
    This behavior could bog down JavaScript's performance; it could clog the network
    connection, and the server might not be able to handle that kind of demand.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只需在用户在搜索字段中键入任何内容时触发表单的提交处理程序。这可能导致快速连续发送许多请求到网络，这取决于用户输入的速度。这种行为可能会降低
    JavaScript 的性能；它可能会堵塞网络连接，而服务器可能无法处理这种需求。
- en: 'We''re already limiting the number of requests with the request caching that
    we''ve just put in place. We can further ease the burden on the server, however,
    by throttling the requests. In [Chapter 10](d150ca06-e7dc-4100-8c91-060f0272ff67.xhtml),
    *Advanced Events*, we introduced the concept of throttling when we created a special
    `throttledScroll` event to reduce the number of times the native scroll event
    is fired. In this case, we want to make a similar reduction in activity; this
    time with the `keyup` event:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经通过刚刚实施的请求缓存来限制请求的数量。然而，我们可以通过对请求进行限速来进一步减轻服务器的负担。在[第 10 章](d150ca06-e7dc-4100-8c91-060f0272ff67.xhtml)中，*高级事件*，我们介绍了当我们创建一个特殊的
    `throttledScroll` 事件以减少原生滚动事件触发的次数时，引入了节流的概念。在这种情况下，我们希望类似地减少活动; 这次是使用 `keyup`
    事件：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Listing 13.11
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.11
- en: Our technique here, sometimes referred to as debouncing, is a bit different
    from the one we used in [Chapter 10](d150ca06-e7dc-4100-8c91-060f0272ff67.xhtml),
    *Advanced Events*. Whereas in that example we needed our `scroll` handler to take
    effect multiple times as scrolling continued, here we only need the `keyup` behavior
    to happen one time after typing has ceased. To do this, we keep track of a JavaScript
    timer that starts whenever the user presses a key. Each keystroke resets that
    timer, so only once the user stops typing for the designated amount of time (300
    milliseconds) does the `submit` handler get triggered and the Ajax request is
    performed.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的技术有时被称为防抖动，与我们在[第 10 章](d150ca06-e7dc-4100-8c91-060f0272ff67.xhtml)中使用的技术有所不同。在那个例子中，我们需要我们的
    `scroll` 处理程序在滚动继续时多次生效，而在这里，我们只需要在输入停止后一次发生 `keyup` 行为。为了实现这一点，我们跟踪一个 JavaScript
    计时器，该计时器在用户按键时启动。每次按键都会重置该计时器，因此只有当用户停止输入指定的时间（300 毫秒）后，`submit` 处理程序才会被触发，然后执行
    Ajax 请求。
- en: Extending Ajax capabilities
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展 Ajax 功能
- en: The jQuery Ajax framework is powerful, as we've seen, but even so there are
    times when we might want to change the way it behaves. Unsurprisingly, it offers
    multiple hooks that can be used by plugins to give the framework brand new capabilities.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery Ajax 框架是强大的，正如我们所见，但即使如此，有时我们可能想要改变它的行为方式。毫不奇怪，它提供了多个钩子，可以被插件使用，为框架提供全新的功能。
- en: Data type converters
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类型转换器
- en: In [Chapter 6](3a5a790f-4c0a-4b63-bb00-cc38e78309c6.xhtml), *Sending Data with
    Ajax*, we saw that the `$.ajaxSetup()` function allows us to change the defaults
    used by `$.ajax()`, thus potentially affecting many Ajax operations with a single
    statement. This same function can also be used to add to the range of data types
    that `$.ajax()` can request and interpret.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 6 章](3a5a790f-4c0a-4b63-bb00-cc38e78309c6.xhtml)中，*使用 Ajax 发送数据*，我们看到 `$.ajaxSetup()`
    函数允许我们更改 `$.ajax()` 使用的默认值，从而可能影响许多 Ajax 操作只需一次语句。这个相同的函数也可以用于扩展 `$.ajax()` 可以请求和解释的数据类型范围。
- en: As an example, we can add a converter that understands the YAML data format.
    YAML ([http://www.yaml.org/](http://www.yaml.org/)) is a popular data representation
    with implementations in many programming languages. If our code needs to interact
    with an alternative format such as this, jQuery allows us to build compatibility
    for it into the native Ajax functions.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，我们可以添加一个理解 YAML 数据格式的转换器。YAML（[http://www.yaml.org/](http://www.yaml.org/)）是一种流行的数据表示，许多编程语言都有实现。如果我们的代码需要与这样的替代格式交互，jQuery
    允许我们将其兼容性构建到本地 Ajax 函数中。
- en: 'A simple YAML file containing GitHub repository search criteria:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 包含 GitHub 仓库搜索条件的简单 YAML 文件：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We can wrap jQuery around an existing YAML parser such as Diogo Costa's ([http://code.google.com/p/javascript-yaml-parser/](http://code.google.com/p/javascript-yaml-parser/))
    to make `$.ajax()` speak this language as well.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 jQuery 与现有的 YAML 解析器（如 Diogo Costa 的 [http://code.google.com/p/javascript-yaml-parser/](http://code.google.com/p/javascript-yaml-parser/)）结合起来，使
    `$.ajax()` 也能够使用这种语言。
- en: 'Defining a new Ajax data type involves passing three properties to `$.ajaxSetup()`:
    `accepts`, `contents`, and `converters`. The `accepts` property adds headers to
    be sent to the server, declaring to the server that particular MIME types are
    understood by our script. The `contents` property handles the other side of the
    transaction, providing a regular expression that is matched against the response
    MIME type to attempt to autodetect the data type from this metadata. Finally,
    `converters` contains the actual functions that parse the returned data:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个新的 Ajax 数据类型涉及将三个属性传递给`$.ajaxSetup()`：`accepts`、`contents`和`converters`。`accepts`属性添加要发送到服务器的头，声明服务器理解我们的脚本的特定
    MIME 类型。`contents`属性处理交易的另一侧，提供一个与响应 MIME 类型匹配的正则表达式，尝试从此元数据中自动检测数据类型。最后，`converters`包含解析返回数据的实际函数：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Listing 13.12
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.12
- en: The partial implementation in *Listing 13.12* uses `$.ajax()` to read in the
    YAML file, and declares its data type as `yaml`. Because the incoming data is
    parsed as `text`, jQuery needs a way to convert one data type to the other. The
    `converters` key of `'text yaml'` tells jQuery that this conversion function will
    accept data that has been received as `text` and reinterpret it as `yaml`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 13.12*中的部分实现使用`$.ajax()`来读取 YAML 文件，并将其数据类型声明为`yaml`。因为传入的数据被解析为`text`，jQuery
    需要一种方法将一个数据类型转换为另一个。`''text yaml''`的`converters`键告诉 jQuery，此转换函数将接受作为`text`接收的数据，并将其重新解释为`yaml`。'
- en: 'Inside the conversion function, we are simply logging the contents of the text
    to ensure that the function is called correctly. To actually perform the conversion,
    we need to load the third-party YAML parsing library (`yaml.js`) and call its
    methods:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在转换函数内部，我们只是记录文本内容以确保函数被正确调用。要执行转换，我们需要加载第三方 YAML 解析库（`yaml.js`）并调用其方法：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Listing 13.13
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.13
- en: 'The `yaml.js` file includes an object named `YAML` with an `.eval()` method.
    We use this method to parse the incoming text and return the result, which is
    a JavaScript object containing all of the `categories.yml` file''s data in an
    easily traversable structure. Since the file we''re loading contains GitHub repo
    search fields, we use the parsed structure to print out the top-level fields and
    later will allow the user to filter their search results by clicking on them:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`yaml.js`文件包含一个名为`YAML`的对象，带有一个`.eval()`方法。我们使用这个方法来解析传入的文本并返回结果，这是一个包含`categories.yml`文件所有数据的
    JavaScript 对象，以便轻松遍历结构。由于我们正在加载的文件包含 GitHub 仓库搜索字段，我们使用解析后的结构打印出顶级字段，稍后将允许用户通过点击它们来过滤其搜索结果：'
- en: '![](img/Screen-Shot-2017-03-28-at-4.27.45-PM.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Screen-Shot-2017-03-28-at-4.27.45-PM.png)'
- en: The Ajax operations may run immediately, without access to the DOM, but once
    we have a result from them, we need to wait until the DOM is available before
    proceeding. Structuring our code to use `Promise.all()` allows the network call to
    be performed as early as possible, improving the user's perception of the page's
    loading time.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Ajax 操作可能会立即运行，而无需访问 DOM，但一旦我们从中获得结果，我们需要等待 DOM 可用才能继续。将代码结构化为使用`Promise.all()`允许尽早执行网络调用，提高用户对页面加载时间的感知。
- en: 'Next, we need to handle clicks on the category links:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要处理类别链接的点击：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Listing 13.14
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.14
- en: By binding our `click` handler to `document` and relying on event delegation,
    we avoid some costly repetition and we also can run the code right away, without
    concerning ourselves with waiting for the Ajax call to complete.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将我们的`click`处理程序绑定到`document`并依赖事件委托，我们避免了一些昂贵的重复工作，而且我们也可以立即运行代码，而不必担心等待 Ajax
    调用完成。
- en: 'Inside the handler, we make sure the right category is highlighted and then
    trigger the `submit` handler on the form. We haven''t yet made the form understand
    our category list, but the highlighting works already:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理程序中，我们确保正确的类别被突出显示，然后触发表单上的`submit`处理程序。我们还没有让表单理解我们的类别列表，但高亮显示已经起作用：
- en: '![](img/Screen-Shot-2017-03-30-at-12.05.37-PM.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Screen-Shot-2017-03-30-at-12.05.37-PM.png)'
- en: 'Finally, we need to update the form''s `submit` handler to respect the active
    category if there is one:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要更新表单的`submit`处理程序以尊重活动类别（如果有的话）：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Listing 13.15
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.15
- en: Instead of simply fetching the value of the search field, now we retrieve the
    text of the active language or star count as well, passing both pieces of information
    on through the Ajax call. We use a `Map` instance to map the link text to the
    appropriate GitHub API syntax.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不仅仅获取搜索字段的值，还获取活动语言或星星数量的文本，通过 Ajax 调用传递这两个信息。我们使用`Map`实例将链接文本映射到适当的 GitHub
    API 语法。
- en: 'We can now view repositories by their primary language, or by their star count.
    Once we''ve applied these filters, we can further refine what''s displayed by
    typing in the search box:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以按主要语言或按星星数量查看仓库。一旦我们应用了这些过滤器，我们可以通过在搜索框中输入来进一步细化显示的内容：
- en: '![](img/Screen-Shot-2017-03-30-at-12.29.13-PM.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Screen-Shot-2017-03-30-at-12.29.13-PM.png)'
- en: Anytime we have the need to support new data types not already handled by jQuery,
    we can define them in a similar fashion to this YAML example. We can thus shape
    jQuery's Ajax library to our specific project's needs.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们需要支持 jQuery 尚未处理的新数据类型时，我们可以以类似于此 YAML 示例的方式定义它们。因此，我们可以根据我们的项目特定需求来塑造 jQuery
    的 Ajax 库。
- en: Adding Ajax prefilters
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加 Ajax 预过滤器
- en: The `$.ajaxPrefilter()` function can add prefilters, which are callback functions
    that allow us to manipulate requests before they are sent. Prefilters are invoked
    before `$.ajax()` changes or uses any of its options, so they are a good place
    to change the options or act on new custom options.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`$.ajaxPrefilter()`函数可以添加预过滤器，这是回调函数，允许我们在发送请求之前对其进行操作。预过滤器在`$.ajax()`更改或使用任何选项之前调用，因此它们是更改选项或对新的自定义选项进行操作的好地方。'
- en: 'Prefilters can also manipulate the data type of the request by simply returning
    the name of the new data type to use. In our YAML example, we specified `yaml`
    as the data type because we didn''t want to rely on the server supplying the correct
    MIME type for the response. We could, though, provide a prefilter that ensures
    the data type is `yaml` if the corresponding file extension ( `.yml`) is in the
    URL we request:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 预过滤器还可以通过简单地返回要使用的新数据类型的名称来操作请求的数据类型。在我们的 YAML 示例中，我们指定了`yaml`作为数据类型，因为我们不希望依赖服务器提供正确的响应
    MIME 类型。但是，我们可以提供一个预过滤器，如果 URL 中包含相应的文件扩展名（`.yml`），则确保数据类型为`yaml`：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Listing 13.16
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.16
- en: A short regular expression tests whether `.yml` is at the end of `options.url`
    and, if so, defines the data type as `yaml`. With this prefilter in place, our
    Ajax call to fetch the YAML document no longer needs to explicitly define its
    data type.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简短的正则表达式测试`options.url`末尾是否是`.yml`，如果是，则将数据类型定义为`yaml`。有了这个预过滤器，我们用于获取 YAML
    文档的 Ajax 调用不再需要明确地定义其数据类型。
- en: Defining alternate transports
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义替代传输
- en: We've seen that jQuery uses `XMLHttpRequest`, `ActiveX`, or `<script>` tags
    as appropriate to handle Ajax transactions. If we wish, we can further extend
    this arsenal with new transports.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到 jQuery 使用`XMLHttpRequest`、`ActiveX`或`<script>`标签来适当处理 Ajax 事务。如果愿意，我们可以通过新的传输进一步扩展这个工具库。
- en: A **transport** is an object that handles the actual transmission of Ajax data.
    New transports are defined as factory functions that return an object with the
    `.send()` and `.abort()` methods. The `.send()` method is responsible for issuing
    the request, handling the response, and sending the data back through a callback
    function. The `.abort()` method should stop the request immediately.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**传输**是一个处理实际 Ajax 数据传输的对象。新的传输被定义为工厂函数，返回一个包含`.send()`和`.abort()`方法的对象。`.send()`方法负责发出请求，处理响应，并通过回调函数将数据发送回来。`.abort()`方法应立即停止请求。'
- en: 'A custom transport can, for example, use `<img>` elements to fetch external
    data. This allows image loading to be handled in the same way as other Ajax requests,
    which can help make our code more internally consistent. The JavaScript required
    to create such a transport is a little involved, so we will look at the finished
    product and then discuss its components:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义传输可以，例如，使用`<img>`元素来获取外部数据。这使得图像加载可以像其他 Ajax 请求一样处理，这有助于使我们的代码在内部更一致。创建这样一个传输所需的
    JavaScript 代码有点复杂，所以我们将先看一下最终的产品，然后再讨论它的组成部分：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Listing 13.17
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.17
- en: When defining a transport, we first pass a data type name into `$.ajaxTransport()`.
    This tells jQuery when to use our transport rather than the built-in mechanisms.
    Then, we provide a function that returns the new transport object containing the
    appropriate `.send()` and `.abort()` methods.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义传输时，我们首先将数据类型名称传递给`$.ajaxTransport()`。这告诉 jQuery 何时使用我们的传输而不是内置机制。然后，我们提供一个返回包含适当的`.send()`和`.abort()`方法的新传输对象的函数。
- en: For our `img` transport, the `.send()` method needs to create a new `<img>`
    element, which we give a `src` attribute. The value of this attribute comes from
    `url`, which jQuery passes along from the `$.ajax()` call. The browser will react
    to the creation of this `<img>` element by loading the referenced image file,
    so we just need to detect when this load has completed and fire the completion
    callback.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的`img`传输，`.send()`方法需要创建一个新的`<img>`元素，我们给它一个`src`属性。这个属性的值来自于jQuery从`$.ajax()`调用中传递过来的`url`。浏览器将通过加载引用的图像文件的`<img>`元素的创建做出反应，所以我们只需检测这个加载何时完成并触发完成回调。
- en: Correctly detecting the completion of an image load is tricky if we want to
    handle a wide variety of browsers and versions. In some browsers, we can simply
    attach `load` and `error` event handlers to the image element. In others, though,
    when the image is cached, `load` and `error` are not triggered as expected.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望处理各种浏览器和版本的图像加载完成的情况，正确检测图像加载完成就会变得棘手。在某些浏览器中，我们可以简单地将`load`和`error`事件处理程序附加到图像元素上。但在其他浏览器中，当图像被缓存时，`load`和`error`不会按预期触发。
- en: Our code in *Listing 13.17* handles these unusual browser behaviors by examining
    the values of the `.complete`, `.width`, and `.naturalWidth` properties as appropriate
    for each browser. Once we have detected that the image load has either successfully
    completed or failed, we call the `callback()` function, which in turn calls the
    `complete()` function that was passed to `.send()`. This allows `$.ajax()` to
    react to the image load.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 *清单13.17* 中的代码处理了这些不同的浏览器行为，通过检查`.complete`、`.width`和`.naturalWidth`属性的值，适当地处理每个浏览器的情况。一旦我们检测到图像加载已经成功完成或失败，我们调用`callback()`函数，该函数反过来调用`.send()`传递的`complete()`函数。这允许`$.ajax()`对图像加载做出反应。
- en: Handling aborted loads is much simpler. Our `.abort()` method simply needs to
    clean up after `.send()` by removing the `<img>` element if it has been created.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 处理中止加载要简单得多。我们的`.abort()`方法只需通过移除已创建的`<img>`元素来清理`send()`后的情况。
- en: 'Next, we need to write the `$.ajax()` call that uses our new transport:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要编写使用新传输的`$.ajax()`调用：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Listing 13.18
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 清单13.18
- en: To use a particular transport, `$.ajax()` needs to be given a corresponding
    `dataType` value. Then, the success and failure handlers need to take into account
    the kind of data that is passed to them. Our `img` transport returns an `<img>`
    DOM element when it is successful, so our `.done()` handler uses this element
    as the HTML contents of a newly created `<div>` element that is inserted into
    the document.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用特定的传输，`$.ajax()`需要给出相应的`dataType`值。然后，成功和失败处理程序需要考虑到传递给它们的数据类型。我们的`img`传输在成功时返回一个`<img>`DOM元素，因此我们的`.done()`处理程序将使用该元素作为新创建的`<div>`元素的HTML内容，该元素将插入到文档中。
- en: 'However, in this case, the specified image file (`missing.jpg`) does not actually
    exist. We take into account such a possibility with an appropriate `.catch()`
    handler, which inserts an error message into the `<div>` where the image would
    otherwise go:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然而在这种情况下，指定的图像文件（`missing.jpg`）实际上不存在。我们通过适当的`.catch()`处理程序考虑了此种可能性，它将错误消息插入`<div>`，在这个`<div>`中原本应该放置图像：
- en: '![](img/5297_13_07.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_13_07.png)'
- en: 'We can correct this error by referencing an image that does exist:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过引用存在的图像来纠正这个错误：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Listing 13.19
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 清单13.19
- en: 'Now, our transport is able to successfully load the image and we see this result
    on the page:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的传输已成功加载图像，我们在页面上看到了这个结果：
- en: '![](img/5297_13_08.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5297_13_08.png)'
- en: Creating a new transport is uncommon, but even in this case, jQuery's Ajax functionality
    can be bent to our needs. For example, the ability to treat image loading as a
    promise means that we could use this Ajax call to synchronize with other asynchronous
    behavior using `Promise.all()`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新传输是不常见的，但即使在这种情况下，jQuery的Ajax功能也可以满足我们的需求。例如，将图像加载视为一个promise的能力意味着我们可以使用这个Ajax调用来与其他异步行为同步，使用`Promise.all()`。
- en: Summary
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this final chapter, we have taken an in-depth look at jQuery's Ajax framework.
    We can now craft a seamless user experience on a single page, fetching external
    resources when needed with proper attention to error handling, caching, and throttling.
    We explored details of the inner operations of the Ajax framework, including promises,
    transports, prefilters, and converters. You also learned how to extend these mechanisms
    to serve the needs of our scripts.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后，我们深入了解了jQuery的Ajax框架。现在我们可以在单个页面上打造无缝的用户体验，在需要时获取外部资源，并且注意到错误处理、缓存和节流的相关问题。我们探讨了Ajax框架的内部运作细节，包括promises，transports，prefilters和converters。你还学会了如何扩展这些机制来满足我们脚本的需求。
- en: Further reading
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: A complete list of *Ajax methods* is available in [Appendix B](d9485d2d-4300-48c1-825b-1c26c9b57a66.xhtml),
    *Quick Reference*, of this book or in the official jQuery documentation at [http://api.jquery.com/](http://api.jquery.com/).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的*Ajax方法*列表可以在本书的 [附录B](d9485d2d-4300-48c1-825b-1c26c9b57a66.xhtml) *快速参考*
    中找到，或者在官方jQuery文档 [http://api.jquery.com/](http://api.jquery.com/) 上找到。
- en: Exercises
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'The challenge exercises may require the use of the official jQuery documentation
    at [http://api.jquery.com/](http://api.jquery.com/):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战练习可能需要使用官方jQuery文档 [http://api.jquery.com/](http://api.jquery.com/) ：
- en: Alter the `buildItem()` function so that it includes the long description of
    each jQuery method it displays.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`buildItem()`函数，使其包含每个jQuery方法的长描述。
- en: Here's a challenge for you. Add a form to the page that points to a Flickr public
    photo search ([http://www.flickr.com/search/](http://www.flickr.com/search/))
    and make sure it has `<input name="q">` and a submit button. Use progressive enhancement
    to retrieve the photos from Flickr's JSONP feed service at [http://api.flickr.com/services/feeds/photos_public.gne](http://api.flickr.com/services/feeds/photos_public.gne)
    instead and insert them into the content area of the page. When sending data to
    this service, use `tags` instead of `q` and set `format` to `json`. Also note
    that rather than `callback`, the service expects the JSONP callback name to be
    `jsoncallback`.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里有一个挑战给你。向页面添加指向Flickr公共照片搜索([http://www.flickr.com/search/](http://www.flickr.com/search/))的表单，并确保它具有`<input
    name="q">`和一个提交按钮。使用渐进增强从Flickr的JSONP反馈服务 [http://api.flickr.com/services/feeds/photos_public.gne](http://api.flickr.com/services/feeds/photos_public.gne)
    检索照片，然后将它们插入页面的内容区域。向这个服务发送数据时，使用`tags`而不是`q`，并将`format`设置为`json`。还要注意，该服务希望JSONP回调名称为`jsoncallback`，而不是`callback`。
- en: Here's another challenge for you. Add error handling for the Flickr request
    in case it results in `parsererror`. Test it by setting the JSONP callback name
    back to `callback`.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里有另一个挑战给你。在Flickr请求产生`parsererror`时为其添加错误处理。通过将JSONP回调名称设置回`callback`来测试它。
