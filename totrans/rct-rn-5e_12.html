<html><head></head><body>
  <div id="_idContainer104" class="Basic-Text-Frame">
    <h1 class="chapterNumber">11</h1>
    <h1 id="_idParaDest-164" class="chapterTitle">Fetching Data from a Server</h1>
    <p class="normal">The evolution of web technologies has made the interaction of browsers with servers and the processing of server data an integral part of web development. Today, it’s challenging to draw a clear line between traditional web pages and full-fledged web applications. At the heart of this evolution is the ability of JavaScript in the browser to make requests to the server, efficiently process the received data, and dynamically display it on the page. This process has become the foundation for creating the interactive and responsive web applications we see today. In this chapter, we will explore various approaches and methods used to fetch data from the server, discuss their impact on the architecture of web applications, and acquaint ourselves with modern practices in this area.</p>
    <p class="normal">So, in this chapter, we will cover the following topics:</p>
    <ul>
      <li class="bulletList">Working with remote data </li>
      <li class="bulletList">Using the <strong class="keyWord">Fetch API</strong></li>
      <li class="bulletList">Using <strong class="keyWord">Axios</strong></li>
      <li class="bulletList">Using <strong class="keyWord">TanStack Query</strong></li>
      <li class="bulletList">Using <strong class="keyWord">GraphQL</strong></li>
    </ul>
    <h1 id="_idParaDest-165" class="heading-1">Technical requirements</h1>
    <p class="normal">You can find the code files for this chapter on GitHub at <a href="https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter11"><span class="url">https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter11</span></a>.</p>
    <h1 id="_idParaDest-166" class="heading-1">Working with remote data</h1>
    <p class="normal">In the<a id="_idIndexMarker383"/> realm of web development, the journey of fetching data from servers has seen remarkable transformations. In the early 90s, the web’s infancy <a id="_idIndexMarker384"/>with <strong class="keyWord">HTTP 1.0</strong> marked the beginning of server communication. Web pages were static, and HTTP requests were basic, fetching whole pages or static assets. Every request meant establishing a new connection, and interactivity was minimal, mostly limited to HTML forms. Security was also basic, reflecting the nascent state of the web.</p>
    <p class="normal">The turn of the millennium witnessed a significant shift with the rise of <strong class="keyWord">Asynchronous JavaScript and XML</strong> (<strong class="keyWord">AJAX</strong>). This <a id="_idIndexMarker385"/>brought an era of enhanced interactivity, allowing web applications to communicate with the server in the background without reloading the whole page. It was powered by the <code class="inlineCode">XMLHttpRequest</code> object. Here’s a simple example of using <code class="inlineCode">XMLHttpRequest</code> to fetch data:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title">XMLHttpRequest</span>();
xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>() {
  <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> == <span class="hljs-title">XMLHttpRequest</span>.<span class="hljs-property">DONE</span>) {
    <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) {
      <span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(xhr.<span class="hljs-property">responseText</span>);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-variable">console</span>.<span class="hljs-title">error</span>(<span class="hljs-string">'Error fetching data'</span>);
    }
  }
};
xhr.<span class="hljs-title">open</span>(<span class="hljs-string">'GET'</span>, <span class="hljs-string">'http://example.com'</span>, <span class="hljs-literal">true</span>);
xhr.<span class="hljs-title">send</span>();
</code></pre>
    <p class="normal">This example illustrates <a id="_idIndexMarker386"/>a typical <strong class="keyWord">XHR request</strong>. Success and error responses are managed with callback functions. This reflects the time when asynchronous code relied heavily on callbacks.</p>
    <p class="normal">As we <a id="_idIndexMarker387"/>progressed, HTTP evolved to version <strong class="keyWord">1.1</strong>, enhancing efficiency with persistent connections and<a id="_idIndexMarker388"/> standardizing <strong class="keyWord">RESTful APIs</strong>. These APIs used standard HTTP methods and were designed around identifiable resources, greatly improving scalability and developer productivity.</p>
    <p class="normal">The advent of the <strong class="keyWord">Fetch API</strong> provided<a id="_idIndexMarker389"/> a modern, promise-based mechanism to make network requests. Fetch is more powerful and flexible compared to <code class="inlineCode">XMLHttpRequest</code>. Here’s an example of using Fetch:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-title">fetch</span>(<span class="hljs-string">'http://example.com/data'</span>)
  .<span class="hljs-title">then</span>(<span class="hljs-params">response</span><span class="hljs-function"> =&gt;</span> response.<span class="hljs-title">json</span>())
  .<span class="hljs-title">then</span>(<span class="hljs-params">data</span><span class="hljs-function"> =&gt;</span> <span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(data))
  .<span class="hljs-title">catch</span>(<span class="hljs-params">error</span><span class="hljs-function"> =&gt;</span> <span class="hljs-variable">console</span>.<span class="hljs-title">error</span>(<span class="hljs-string">'Error:'</span>, error));
</code></pre>
    <p class="normal">Moreover, there<a id="_idIndexMarker390"/> are a lot of tools based on top of the Fetch API and XHR, developed by the community. For example, Axios, GraphQL, and React Query have further simplified server communication and data fetching, enhancing developer experiences.</p>
    <p class="normal"><strong class="keyWord">Axios</strong>, a modern <a id="_idIndexMarker391"/>HTTP client library, further simplified fetching data with its promise-based API and a host of useful features, such as intercepting requests and responses. Here’s how you can use Axios to <a id="_idIndexMarker392"/>make a <strong class="keyWord">GET</strong> request:</p>
    <pre class="programlisting code"><code class="hljs-code">axios.<span class="hljs-title">get</span>(<span class="hljs-string">'http://example.com/data'</span>)
  .<span class="hljs-title">then</span>(<span class="hljs-params">response</span><span class="hljs-function"> =&gt;</span> <span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(response.<span class="hljs-property">data</span>))
  .<span class="hljs-title">catch</span>(<span class="hljs-params">error</span><span class="hljs-function"> =&gt;</span> <span class="hljs-variable">console</span>.<span class="hljs-title">error</span>(<span class="hljs-string">'Error:'</span>, error));
</code></pre>
    <p class="normal">The example might look identical to the <strong class="keyWord">Fetch</strong> API, but in real projects where you set up interceptors, it becomes a game-changer that saves a lot of time with less code. <strong class="keyWord">Interceptors</strong> allow <a id="_idIndexMarker393"/>you to intercept and modify requests before they are sent and responses before they are handled. A common use case is to refresh access tokens when they expire. Interceptors can add the new token to all subsequent requests. By using a library like Axios, a lot of the low-level networking code is abstracted away, allowing you to focus on making requests and handling responses. Interceptors, error handling, and other features help address cross-cutting concerns in a reusable way, leading to cleaner code.</p>
    <p class="normal">Next is <strong class="keyWord">GraphQL</strong>, which <a id="_idIndexMarker394"/>revolutionized data fetching by allowing clients to request exactly the data they need, eliminating over-fetching and under-fetching issues. It offers a flexible and efficient way to retrieve data from servers. Instead of predefined endpoints, clients specify their data requirements, and servers respond with precisely the requested data. This reduces network load and enhances application performance.</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { <span class="hljs-title">GraphQLClient</span>, gql } <span class="hljs-keyword">from</span> <span class="hljs-string">'graphql-request'</span>;
<span class="hljs-keyword">const</span> endpoint = <span class="hljs-string">'http://example.com/graphql'</span>;
<span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> <span class="hljs-title">GraphQLClient</span>(endpoint);
<span class="hljs-keyword">const</span> query = gql'
  <span class="hljs-keyword">query</span> <span class="hljs-punctuation">{</span>
    user<span class="hljs-punctuation">(</span><span class="hljs-symbol">id</span><span class="hljs-punctuation">:</span> <span class="hljs-number">123</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">{</span>
      name
      email
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">}</span>
';
client.<span class="hljs-title">request</span>(query)
  .<span class="hljs-title">then</span>(<span class="hljs-params">data</span><span class="hljs-function"> =&gt;</span> <span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(data))
  .<span class="hljs-title">catch</span>(<span class="hljs-params">error</span><span class="hljs-function"> =&gt;</span> <span class="hljs-variable">console</span>.<span class="hljs-title">error</span>(<span class="hljs-string">'Error:'</span>, error));
</code></pre>
    <p class="normal">Here, we <a id="_idIndexMarker395"/>request the user by <code class="inlineCode">ID</code>, specifying only two fields: <code class="inlineCode">name</code> and <code class="inlineCode">email</code>. Regardless of the user object’s size, the GraphQL server efficiently handles it, sending only the requested data to the client.</p>
    <p class="normal">One more tool I would like to<a id="_idIndexMarker396"/> explore is <strong class="keyWord">React Query</strong>. The library is designed to simplify data fetching and state management in React applications. It abstracts away the complexities of fetching and caching data, handles background updates, and provides Hooks for easy integration with components. React Query enhances the development process by making it straightforward to work with server data in a highly efficient and maintainable manner.</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { useQuery } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-query'</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title">UserProfile</span>(<span class="hljs-params">{ userId }</span>) {
  <span class="hljs-keyword">const</span> { data, error, isLoading } = <span class="hljs-title">useQuery</span>(userId, fetchUser);
  <span class="hljs-keyword">if</span> (isLoading) <span class="hljs-keyword">return</span> <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>Loading...<span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>;
  <span class="hljs-keyword">if</span> (error) <span class="hljs-keyword">return</span> <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>Error: {error.message}<span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>;
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>{data.name}<span class="hljs-tag">&lt;/</span><span class="hljs-name">h1</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>Email: {data.email}<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
  );
}
</code></pre>
    <p class="normal">As you can see, we don’t even need to handle errors or set up and update the loading state manually. Everything is provided by one Hook. </p>
    <p class="normal">Another remarkable development in server <a id="_idIndexMarker397"/>communication is <strong class="keyWord">WebSockets</strong>, enabling real-time, bidirectional communication. This is a game-changer for applications requiring live data updates, like chat apps or trading platforms. Below is a basic example of using WebSockets:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> socket = <span class="hljs-keyword">new</span> <span class="hljs-title">WebSocket</span>(<span class="hljs-string">'ws://example.com'</span>);
socket.<span class="hljs-property">onopen</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) {
  <span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(<span class="hljs-string">'Connection established'</span>);
};
socket.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) {
  <span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(<span class="hljs-string">'Message from server '</span>, event.<span class="hljs-property">data</span>);
};
socket.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) {
  <span class="hljs-variable">console</span>.<span class="hljs-title">error</span>(<span class="hljs-string">'</span><span class="hljs-string">WebSocket Error '</span>, error);
};
</code></pre>
    <p class="normal">Here, we <a id="_idIndexMarker398"/>are still using the callback approach due to the mental model of bidirectional communication. </p>
    <p class="normal">In conclusion, the evolution of server communication in web development has been pivotal in enhancing user experiences and developer productivity. From the rudimentary stages of <strong class="keyWord">HTTP 1.0</strong> to the sophisticated tools of today, we have witnessed a significant transformation. The introduction of technologies like Ajax, the Fetch API, Axios, GraphQL, and React Query not only streamlined server interactions but also standardized asynchronous behavior in applications. These advancements have been critical in efficiently managing states like loading, errors, and offline scenarios. The integration of these tools in modern web applications signifies a leap forward in building more responsive, robust, and user-friendly interfaces. It’s a testament to the ever-evolving nature of technology and its profound impact on both the creation and consumption of web content.</p>
    <p class="normal">In the next section, we will explore real examples of how to fetch data from a server using the Fetch API.</p>
    <h1 id="_idParaDest-167" class="heading-1">Using the Fetch API</h1>
    <p class="normal">Let’s explore how we<a id="_idIndexMarker399"/> can retrieve data from a server in practice. We’ll start with the <strong class="keyWord">Fetch API</strong>, the most common and fundamental approach provided by web browsers. </p>
    <p class="normal">Before we begin, let’s create a small application that fetches user data from GitHub and displays their avatar and basic information on the screen. To do this, we’ll need an empty <strong class="keyWord">Vite</strong> project with React. You <a id="_idIndexMarker400"/>can create it with the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">npm create vite@latest
</code></pre>
    <p class="normal">Since we’re using <strong class="keyWord">TypeScript</strong> in <a id="_idIndexMarker401"/>our examples, let’s start by defining the <code class="inlineCode">GitHubUser</code> interface and all the necessary parameters. </p>
    <p class="normal">To find out what <a id="_idIndexMarker402"/>data the server returns, we often need to refer to the documentation, usually provided by backend developers. In our case, since we’re using the GitHub REST API, we can find user information in the official GitHub documentation at this link: <a href="https://docs.github.com/en/rest/users/users?apiVersion=2022-11-28"><span class="url">https://docs.github.com/en/rest/users/users?apiVersion=2022-11-28</span></a>.</p>
    <p class="normal">Let’s create the <code class="inlineCode">GitHubUser</code> interface as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">export</span> interface <span class="hljs-title">GitHubUser</span> {
  <span class="hljs-attr">login</span>: string;
  <span class="hljs-attr">id</span>: number;
  <span class="hljs-attr">avatar_url</span>: string;
  <span class="hljs-attr">html_url</span>: string;
  <span class="hljs-attr">gists_url</span>: string;
  <span class="hljs-attr">repos_url</span>: string;
  <span class="hljs-attr">name</span>: string;
  <span class="hljs-attr">company</span>: string | <span class="hljs-literal">null</span>;
  <span class="hljs-attr">location</span>: string | <span class="hljs-literal">null</span>;
  <span class="hljs-attr">bio</span>: string | <span class="hljs-literal">null</span>;
  <span class="hljs-attr">public_repos</span>: number;
  <span class="hljs-attr">public_gists</span>: number;
  <span class="hljs-attr">followers</span>: number;
  <span class="hljs-attr">following</span>: number;
}
</code></pre>
    <p class="normal">These are the essential fields we will use in our application. In reality, there are more fields in the <code class="inlineCode">user</code> object, but I’ve included the ones we’ll use.</p>
    <p class="normal">Now that we know the fields the user will have, let’s create a component that will display the user data on the screen:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">UserInfo</span> = (<span class="hljs-params">{ user }: GitHubUserProps</span>) =&gt; {
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">img</span><span class="hljs-tag"> </span><span class="hljs-attr">src</span><span class="hljs-tag">=</span><span class="hljs-string">{user.avatar_url}</span><span class="hljs-tag"> </span><span class="hljs-attr">alt</span><span class="hljs-tag">=</span><span class="hljs-string">{user.login}</span><span class="hljs-tag"> </span><span class="hljs-attr">width</span><span class="hljs-tag">=</span><span class="hljs-string">"100"</span><span class="hljs-tag"> </span><span class="hljs-attr">height</span><span class="hljs-tag">=</span><span class="hljs-string">"100"</span><span class="hljs-tag"> /&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">h2</span><span class="hljs-tag">&gt;</span>{user.name || user.login}<span class="hljs-tag">&lt;/</span><span class="hljs-name">h2</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>{user.bio}<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>Location: {user.location || "Not specified"}<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>Company: {user.company || "Not specified"}<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>Followers: {user.followers}<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>Following: {user.following}<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>Public Repos: {user.public_repos}<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>Public Gists: {user.public_gists}<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
        GitHub Profile:{" "}
        <span class="hljs-tag">&lt;</span><span class="hljs-name">a</span><span class="hljs-tag"> </span><span class="hljs-attr">href</span><span class="hljs-tag">=</span><span class="hljs-string">{user.html_url}</span><span class="hljs-tag"> </span><span class="hljs-attr">target</span><span class="hljs-tag">=</span><span class="hljs-string">"_blank"</span><span class="hljs-tag"> </span><span class="hljs-attr">rel</span><span class="hljs-tag">=</span><span class="hljs-string">"noopener noreferrer"</span><span class="hljs-tag">&gt;</span>
          {user.login}
        <span class="hljs-tag">&lt;/</span><span class="hljs-name">a</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
  );
};
</code></pre>
    <p class="normal">Here, we <a id="_idIndexMarker403"/>render their avatar and some useful information about the user together with a link to open their GitHub profile page.</p>
    <p class="normal">Let’s now take a look at the <code class="inlineCode">App</code> component, where we handle the server data retrieval logic:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>() {
  <span class="hljs-keyword">const</span> [user, setUser] = useState&lt;<span class="hljs-title">GitHubUser</span>&gt;();
  <span class="hljs-keyword">const</span> [loading, setLoading] = <span class="hljs-title">useState</span>(<span class="hljs-literal">true</span>);
  <span class="hljs-title">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title">setLoading</span>(<span class="hljs-literal">true</span>);
    <span class="hljs-title">fetch</span>(<span class="hljs-string">"https://api.github.com/users/sakhnyuk"</span>)
      .<span class="hljs-title">then</span>(<span class="hljs-function">(</span><span class="hljs-params">response</span><span class="hljs-function">) =&gt;</span> response.<span class="hljs-title">json</span>())
      .<span class="hljs-title">then</span>(<span class="hljs-function">(</span><span class="hljs-params">data</span><span class="hljs-function">) =&gt;</span> <span class="hljs-title">setUser</span>(data))
      .<span class="hljs-title">catch</span>(<span class="hljs-function">(</span><span class="hljs-params">error</span><span class="hljs-function">) =&gt;</span> <span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(error))
      .<span class="hljs-title">finally</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title">setLoading</span>(<span class="hljs-literal">false</span>));
  }, []);
</code></pre>
    <p class="normal">We use the <code class="inlineCode">useState</code> hook to store <code class="inlineCode">user</code> data and loading state. In the <code class="inlineCode">useEffect</code>, we make a Fetch API request to fetch data from the GitHub API. As you can see, the <code class="inlineCode">fetch</code> function takes a URL as <a id="_idIndexMarker404"/>an argument. We process the response, save it in the state, handle errors with the <code class="inlineCode">catch</code> block, and finally, turn off the loading process with the <code class="inlineCode">finally</code> block.</p>
    <p class="normal">To complete the application, we display the retrieved user data:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
      {loading &amp;&amp; <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>Loading...<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>}
      {!loading &amp;&amp; !user &amp;&amp; <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>No user found.<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>}
      {user &amp;&amp; <span class="hljs-tag">&lt;</span><span class="hljs-name">UserInfo</span><span class="hljs-tag"> </span><span class="hljs-attr">user</span><span class="hljs-tag">=</span><span class="hljs-string">{user}</span><span class="hljs-tag"> /&gt;</span>}
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
  );
}
</code></pre>
    <p class="Normal--PACKT-">You can run your application using the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">npm run dev
</code></pre>
    <p class="normal">Open the link that will appear in the terminal and you’ll see:</p>
    <figure class="mediaobject"><img src="../Images/B19636_11_01.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 11.1: GitHub user requested by the Fetch API</p>
    <p class="normal">Now you know<a id="_idIndexMarker405"/> how to fetch data using the Fetch API. Let’s explore the implementation of a similar application where we request data using other tools.</p>
    <h1 id="_idParaDest-168" class="heading-1">Using Axios</h1>
    <p class="normal">In this section, we <a id="_idIndexMarker406"/>will explore one of the most popular libraries for working with the server, called <strong class="keyWord">Axios</strong>. This library is similar to the Fetch API but also provides additional features that make it a powerful tool for handling requests.</p>
    <p class="normal">Let’s take our<a id="_idIndexMarker407"/> previous project and make some changes to it. First, let’s install Axios as a dependency:</p>
    <pre class="programlisting con"><code class="hljs-con">npm install axios
</code></pre>
    <p class="normal">One of Axios’s features is the ability to create instances with specific configurations, such as headers, base URLs, interceptors, and more. This allows us to have a preconfigured instance<a id="_idIndexMarker408"/> tailored to our needs, reducing code repetition and making it more scalable. </p>
    <p class="normal">Let’s create an API class that encapsulates all the necessary logic for working with the server:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span> <span class="hljs-title">API</span> {
  private <span class="hljs-attr">apiInstance</span>: <span class="hljs-title">AxiosInstance</span>;
  <span class="hljs-title">constructor</span>() {
    <span class="hljs-variable">this</span>.<span class="hljs-property">apiInstance</span> = axios.<span class="hljs-title">create</span>({
      <span class="hljs-attr">baseURL</span>: <span class="hljs-string">"https://api.github.com"</span>,
    });
    <span class="hljs-variable">this</span>.<span class="hljs-property">apiInstance</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title">use</span>(<span class="hljs-function">(</span><span class="hljs-params">config</span><span class="hljs-function">) =&gt;</span> {
      <span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(<span class="hljs-string">"Request:"</span>, <span class="hljs-string">'</span><span class="hljs-subst">${config.method?.toUpperCase()}</span><span class="hljs-string"> </span><span class="hljs-subst">${config.url}</span><span class="hljs-string">'</span>);
      <span class="hljs-keyword">return</span> config;
    });
    <span class="hljs-variable">this</span>.<span class="hljs-property">apiInstance</span>.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title">use</span>(
      <span class="hljs-function">(</span><span class="hljs-params">response</span><span class="hljs-function">) =&gt;</span> {
        <span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(<span class="hljs-string">"Response:"</span>, response.<span class="hljs-property">data</span>);
        <span class="hljs-keyword">return</span> response;
      },
      <span class="hljs-function">(</span><span class="hljs-params">error</span><span class="hljs-function">) =&gt;</span> {
        <span class="hljs-variable">console</span>.<span class="hljs-title">log</span>(<span class="hljs-string">"Error:"</span>, error);
        <span class="hljs-keyword">return</span> <span class="hljs-title">Promise</span>.<span class="hljs-title">reject</span>(error);
      }
    );
  }
  <span class="hljs-title">getProfile</span>(<span class="hljs-params">username: string</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable">this</span>.<span class="hljs-property">apiInstance</span>.<span class="hljs-property">get</span>&lt;<span class="hljs-title">GitHubUser</span>&gt;(<span class="hljs-string">'/users/</span><span class="hljs-subst">${username}</span><span class="hljs-string">'</span>);
  }
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title">API</span>();
</code></pre>
    <p class="normal">In the constructor of this class, we create and store an Axios instance and set the base URL, eliminating the need to repeat this domain in future requests. Next, we configure interceptors for each request and response. This is done for demonstration purposes, so when we run the application, we can see all the requests and responses in the console logs:</p>
    <figure class="mediaobject"><img src="../Images/B19636_11_02.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 11.2: Axios interceptor logs</p>
    <p class="normal">Now, let’s see how the <code class="inlineCode">App</code> component, which uses our new API class, will look:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>() {
  <span class="hljs-keyword">const</span> [user, setUser] = useState&lt;<span class="hljs-title">GitHubUser</span>&gt;();
  <span class="hljs-keyword">const</span> [loading, setLoading] = <span class="hljs-title">useState</span>(<span class="hljs-literal">true</span>);
  <span class="hljs-title">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title">setLoading</span>(<span class="hljs-literal">true</span>);
    api
      .<span class="hljs-title">getProfile</span>(<span class="hljs-string">"sakhnyuk"</span>)
      .<span class="hljs-title">then</span>(<span class="hljs-function">(</span><span class="hljs-params">res</span><span class="hljs-function">) =&gt;</span> <span class="hljs-title">setUser</span>(res.<span class="hljs-property">data</span>))
      .<span class="hljs-title">finally</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title">setLoading</span>(<span class="hljs-literal">false</span>));
  }, []);
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
      {loading &amp;&amp; <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>Loading...<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>}
      {!loading &amp;&amp; !user &amp;&amp; <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>No user found.<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>}
      {user &amp;&amp; <span class="hljs-tag">&lt;</span><span class="hljs-name">UserInfo</span><span class="hljs-tag"> </span><span class="hljs-attr">user</span><span class="hljs-tag">=</span><span class="hljs-string">{user}</span><span class="hljs-tag"> /&gt;</span>}
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
  );
}
</code></pre>
    <p class="normal">As mentioned <a id="_idIndexMarker409"/>earlier, Axios is not significantly different from the Fetch API, but it offers more powerful functionality, making it easy to create more complex solutions for working with server data.</p>
    <p class="normal">In the next section, we will explore the same application implemented using TanStack Query.</p>
    <h1 id="_idParaDest-169" class="heading-1">Using TanStack Query</h1>
    <p class="normal"><strong class="keyWord">TanStack Query</strong>, more<a id="_idIndexMarker410"/> commonly <a id="_idIndexMarker411"/>known as <strong class="keyWord">React Query</strong>, is a library that has taken server interaction to a new level. This library allows us to request data and cache it. As a result, we can call the same <code class="inlineCode">useQuery</code> hook a lot of times during one rendering, but only one request will be sent to the server. The library also includes built-in loading and error states, simplifying the <a id="_idIndexMarker412"/>handling of request states. </p>
    <p class="normal">To get started, let’s install the library as a dependency for our project:</p>
    <pre class="programlisting con"><code class="hljs-con">npm install @tanstack/react-query
</code></pre>
    <p class="normal">Next, we need to configure the library by adding the <code class="inlineCode">QueryClientProvider</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> queryClient = <span class="hljs-keyword">new</span> <span class="hljs-title">QueryClient</span>();
<span class="hljs-title">ReactDOM</span>.<span class="hljs-title">createRoot</span>(<span class="hljs-variable">document</span>.<span class="hljs-title">getElementById</span>(<span class="hljs-string">"root"</span>)!).<span class="hljs-title">render</span>(
  <span class="hljs-tag">&lt;</span><span class="hljs-name">QueryClientProvider</span><span class="hljs-tag"> </span><span class="hljs-attr">client</span><span class="hljs-tag">=</span><span class="hljs-string">{queryClient}</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">App</span><span class="hljs-tag"> /&gt;</span>
  <span class="hljs-tag">&lt;/</span><span class="hljs-name">QueryClientProvider</span><span class="hljs-tag">&gt;</span>
);
</code></pre>
    <p class="normal">After this setup, we can start working on the app. One of the unique features of this library is that it is agnostic to the tool you use for data fetching. You just need to provide a promise function that returns the data. Let’s create such a function using the Fetch API:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-title">userFetcher</span> = (<span class="hljs-params">username: string</span>) =&gt;
  <span class="hljs-title">fetch</span>(<span class="hljs-string">"https://api.github.com/users/sakhnyuk"</span>)
  .<span class="hljs-title">then</span>(<span class="hljs-function">(</span><span class="hljs-params">response</span><span class="hljs-function">) =&gt;</span> response.<span class="hljs-title">json</span>());
</code></pre>
    <p class="normal">Now, let’s take a look at how simple our <code class="inlineCode">App</code> component has become:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>() {
  <span class="hljs-keyword">const</span> {
    <span class="hljs-attr">data</span>: user,
    isPending,
    isError,
  } = <span class="hljs-title">useQuery</span>({
    <span class="hljs-attr">queryKey</span>: [<span class="hljs-string">"githubUser"</span>],
    <span class="hljs-attr">queryFn</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title">userFetcher</span>(<span class="hljs-string">"sakhnyuk"</span>),
  });
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
      {isPending &amp;&amp; <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>Loading...<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>}
      {isError &amp;&amp; <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>Error fetching data<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>}
      {user &amp;&amp; <span class="hljs-tag">&lt;</span><span class="hljs-name">UserInfo</span><span class="hljs-tag"> </span><span class="hljs-attr">user</span><span class="hljs-tag">=</span><span class="hljs-string">{user}</span><span class="hljs-tag"> /&gt;</span>}
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
  );
}
</code></pre>
    <p class="normal">Now, all the logic <a id="_idIndexMarker413"/>for making the request and handling loading and error states is contained within a single <code class="inlineCode">useQuery</code> hook. </p>
    <p class="normal">In the next section, we will explore an even more powerful tool for data fetching using GraphQL.</p>
    <h1 id="_idParaDest-170" class="heading-1">Using GraphQL</h1>
    <p class="normal">Earlier in this chapter, we discussed what <strong class="keyWord">GraphQL</strong> is<a id="_idIndexMarker414"/> and how it allows us to specify the exact data we want from the server, reducing the amount of transferred data and speeding up data fetching.</p>
    <p class="normal">In this example, we will<a id="_idIndexMarker415"/> explore GraphQL in conjunction with the <code class="inlineCode">@apollo/client</code> library, which provides similar functionality to React Query but works with GraphQL queries.</p>
    <p class="normal">To begin, let’s install the necessary dependencies using the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">npm install @apollo/client graphql
</code></pre>
    <p class="normal">Next, we need to add a provider to our application:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> <span class="hljs-title">ApolloClient</span>({
  <span class="hljs-attr">uri</span>: <span class="hljs-string">"https://api.github.com/graphql"</span>,
  <span class="hljs-attr">cache</span>: <span class="hljs-keyword">new</span> <span class="hljs-title">InMemoryCache</span>(),
  <span class="hljs-attr">headers</span>: {
    <span class="hljs-title">Authorization</span>: <span class="hljs-string">'Bearer YOUR_PAT'</span>, <span class="hljs-comment">// Put your GitHub personal access token here</span>
  },
});
<span class="hljs-title">ReactDOM</span>.<span class="hljs-title">createRoot</span>(<span class="hljs-variable">document</span>.<span class="hljs-title">getElementById</span>(<span class="hljs-string">"root"</span>)!).<span class="hljs-title">render</span>(
  <span class="hljs-tag">&lt;</span><span class="hljs-name">ApolloProvider</span><span class="hljs-tag"> </span><span class="hljs-attr">client</span><span class="hljs-tag">=</span><span class="hljs-string">{client}</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">App</span><span class="hljs-tag"> /&gt;</span>
  <span class="hljs-tag">&lt;/</span><span class="hljs-name">ApolloProvider</span><span class="hljs-tag">&gt;</span>
);
</code></pre>
    <p class="normal">At this stage, during the client setup, we specify the server URL we want to work with, caching settings, and authentication. In earlier examples, we used the public GitHub API, but GitHub also supports GraphQL. For this, we need to<a id="_idIndexMarker416"/> provide a <strong class="keyWord">GitHub personal access token</strong>, which you can obtain in your GitHub profile settings.</p>
    <p class="normal">For our example, to demonstrate how we can select only the necessary fields we need, let’s trim down the user data. Here’s how our GraphQL query in the component will look:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> <span class="hljs-variable">GET_GITHUB_USER</span> = gql'
  <span class="hljs-keyword">query</span> GetGithubUser<span class="hljs-punctuation">(</span><span class="hljs-variable">$username</span>: String<span class="hljs-punctuation">!)</span> <span class="hljs-punctuation">{</span>
    user<span class="hljs-punctuation">(</span><span class="hljs-symbol">login</span><span class="hljs-punctuation">:</span> <span class="hljs-variable">$username</span>) <span class="hljs-punctuation">{</span>
      login
      id
      avatarUrl
      bio
      name
      company
      location
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">}</span>
'; 
</code></pre>
    <p class="normal">Now that <a id="_idIndexMarker417"/>everything is set up, let’s see what the <code class="inlineCode">App</code> component will look like:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>() {
  <span class="hljs-keyword">const</span> { data, loading, error } = <span class="hljs-title">useQuery</span>(<span class="hljs-variable">GET_GITHUB_USER</span>, {
    <span class="hljs-attr">variables</span>: { <span class="hljs-attr">username</span>: <span class="hljs-string">"sakhnyuk"</span> },
  });  
  <span class="hljs-keyword">if</span> (loading) <span class="hljs-keyword">return</span> <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>Loading...<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>;
  <span class="hljs-keyword">if</span> (error) <span class="hljs-keyword">return</span> <span class="hljs-tag">&lt;</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>Error fetching data<span class="hljs-tag">&lt;/</span><span class="hljs-name">p</span><span class="hljs-tag">&gt;</span>;
  <span class="hljs-keyword">const</span> user = data.<span class="hljs-property">user</span>;
  <span class="hljs-keyword">return</span> (
    <span class="hljs-tag">&lt;</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
      <span class="hljs-tag">&lt;</span><span class="hljs-name">UserInfo</span><span class="hljs-tag"> </span><span class="hljs-attr">user</span><span class="hljs-tag">=</span><span class="hljs-string">{user}</span><span class="hljs-tag"> /&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">div</span><span class="hljs-tag">&gt;</span>
  );
}
</code></pre>
    <p class="normal">Similar to React Query, we <a id="_idIndexMarker418"/>have access to the loading state, errors, and the actual data. When we open the application, we will see the result:</p>
    <figure class="mediaobject"><img src="../Images/B19636_11_03.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 11.3: GiHub user requested by GraphQL</p>
    <p class="normal">To ensure that the server returns exactly the data we requested, we can open Chrome Dev Tools, go to the <strong class="screenText">Network</strong> tab, and inspect our request:</p>
    <figure class="mediaobject"><img src="../Images/B19636_11_04.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 11.4: GraphQL request</p>
    <p class="normal">As <a id="_idIndexMarker419"/>shown in <em class="italic">Figure 11.4</em>, the server sent us precisely the data we specified in the query. You can experiment with query parameters to see the difference.</p>
    <h1 id="_idParaDest-171" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we explored how to fetch data from the server. We began by briefly reviewing the history of client-server communication and highlighting the primary methods of interacting with servers. Next, we built an application to retrieve GitHub user data using the Fetch API, Axios, TanStack Query, and Apollo GraphQL.</p>
    <p class="normal">The techniques you learned in this chapter will enable you to significantly expand the capabilities of your own web applications. By efficiently fetching data from the server, you can create dynamic, data-driven experiences for your users. Whether you are building a social media app that displays real-time feeds, an e-commerce site with up-to-date product information, or a dashboard that visualizes live data, the skills you gained will prove invaluable.</p>
    <p class="normal">In the next chapter, we will delve into managing the application state using state management libraries.</p>
  </div>
</body></html>