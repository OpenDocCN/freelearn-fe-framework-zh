- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Performing Data Mutations with React Query
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building applications, you won’t always need to fetch data. Sometimes,
    you will want to create, update, or delete it. When doing these actions, your
    server state will have to change.
  prefs: []
  type: TYPE_NORMAL
- en: React Query allows you to change your server state by using mutations. To perform
    mutations, you can leverage another of React Query’s custom hooks, called `useMutation`.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will be introduced to the `useMutation` hook and understand
    how React Query allows you to create, update, and delete your server state. Similar
    to [*Chapter 4*](B18501_04.xhtml#_idTextAnchor091), during this process, you will
    learn about all the defaults used in your mutations. You will also be introduced
    to some options you can use to improve your `useMutation` experience.
  prefs: []
  type: TYPE_NORMAL
- en: Once you are familiar with `useMutation`, you will get to know how you can leverage
    some of its options to perform some side-effect patterns, such as manually updating
    your data or forcing a query to update after performing a mutation.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of this chapter, we will put together all we have learned so far
    and apply it to do something that might improve your user experience considerably:
    optimistic updates.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is `useMutation` and how does it work?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing side-effect patterns after mutations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing optimistic updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_6](https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_6).
  prefs: []
  type: TYPE_NORMAL
- en: What is useMutation and how does it work?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You must be aware by now that mutations allow you to perform updates to your
    server state. These updates can be things such as creating data, removing data,
    or editing your data.
  prefs: []
  type: TYPE_NORMAL
- en: To allow you to perform mutations on your server data, React Query created a
    hook called `useMutation`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, unlike `useQuery`, which under the default circumstances runs your query
    automatically as soon as the component using it renders or some dependencies of
    it change, `useMutation` will only run your mutation when you call one of the
    functions it returns from the hook instantiation called `mutate`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the `useMutation` hook, you have to import it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once it is imported, you can use it to define your mutation. Here is the `useMutation`
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding snippet, the `useMutation` hook only needs
    one required parameter for it to work, the mutation function.
  prefs: []
  type: TYPE_NORMAL
- en: What is the mutation function?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The mutation function is a function that returns a promise responsible for performing
    an asynchronous task. In this scenario, this asynchronous task will be our mutation.
  prefs: []
  type: TYPE_NORMAL
- en: The same principle we previously saw with the query function also applies to
    the mutation function. This means that, as we saw with query functions, since
    this function only needs to return a promise, it allows us again to use any asynchronous
    client of our choice. This means that REST and GraphQL are still supported, so
    you can use both options simultaneously if you desire.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now look at an example of a mutation function using GraphQL and another
    using REST. These mutation functions will be leveraged to create a new user on
    our server state:'
  prefs: []
  type: TYPE_NORMAL
- en: Mutation with GraphQL
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding snippet shows an example of using React Query to create a mutation
    with GraphQL. Here is what we are doing:'
  prefs: []
  type: TYPE_NORMAL
- en: We start by creating our GraphQL mutation and assigning it to our `customQuery`
    variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then create the `createUserGQL` function, which will be our mutation function.
    This function will also receive as a parameter the `user` data to be used by our
    mutation to create the data on the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our `useMutation` hook, we pass our `createUserGQL` function as the mutation
    function to the hook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let us now see how to do this using REST:'
  prefs: []
  type: TYPE_NORMAL
- en: Mutation with REST
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we can see an example of using React Query to create
    a mutation with REST. Here is what we are doing:'
  prefs: []
  type: TYPE_NORMAL
- en: We start by creating the `createUser` function, which will be our mutation function.
    This function will receive as a parameter the `user` data used by our mutation
    to create the data on the server. Here, we know we are going to be creating data
    on the server due to the use of the `POST` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our `useMutation` hook, we pass to the hook our `createUser` function as
    the mutation function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the preceding example, we used `axios`, but if you prefer using `fetch`
    over `axios`, all you have to do is inside the `createUser` function, replace
    `axios` with `fetch` and apply the required changes for `fetch` to work. Here
    is an example of what you would need to do to use `fetch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we can see an example of our `createUser` function
    shown previously, but this time, we used `fetch` instead of `axios`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are familiar with the mutation function, we need to understand how
    the `useMutation` hook leverages this function to allow us to perform our mutations.
    In the next section, we will learn about how the `mutate` function enables us
    to do this, as well as other things `useMutation` returns.
  prefs: []
  type: TYPE_NORMAL
- en: What does useMutation return?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like `useQuery`, when using the `useMutation` hook, it returns a couple of values.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned throughout this chapter so far, to perform mutations, we need to
    leverage `mutate`. Now, `mutate` is not the only way to perform mutations and
    is also not the only thing `useMutation` returns.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we’ll review the following returns of the `useMutation` hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mutate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mutateAsync`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`error`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reset`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`status`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isPaused`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: mutate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After creating your mutation with your `useMutation` hook, you need a way to
    trigger it. `mutate` is the function you will need almost every time to do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how you can use `mutate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In this snippet, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We destructure our `mutate` function from our `useMutation` hook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We call the `mutate` function with the variables our mutation function is expecting
    to receive to perform our mutation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That’s it; that is how you can perform mutations with React Query. You create
    your mutation function, pass it to your `useMutation` hook, destructure `mutate`
    from it, and call it with the required parameters to perform your mutation whenever
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the preceding snippet serves to show how you can trigger mutations by
    using `mutate` but isn’t a very practical example. To help you create a mental
    model of how you can use `mutate` to perform mutations, you can refer to the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we can see an example of a simple form using a controlled
    component. This is what is happening in the preceding snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: We create the `createUser` mutation function, which will receive a `user` object
    with some data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside this function, we return the invocation of the `axios` client’s `post`
    method, which will return the promise that `useMutation` expects to receive for
    its mutation function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside our `SimpleMutation` component, we do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a state variable to control the state of our input.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We create our mutation using the `createUser` function as the mutation function
    and destructure `mutate` from it.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a `submitForm` function. This function will receive the event from
    the form and prevent it from propagating so your page is not refreshed. After
    handling the event, it triggers the mutation and passes it the `name` state variable
    as part of the `user` object by calling `mutate`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside our form, we create our input to handle our `name` and have React control
    its state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a button with an `onClick` event to fire our `submitForm` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you should understand from the preceding explanation and code, whenever we
    click on the `POST` request to our URL with the current value of our input.
  prefs: []
  type: TYPE_NORMAL
- en: One thing you’ll also see while proceeding with this chapter is that `mutate`
    can also receive some options to perform side effects if you desire to. But let’s
    leave these details for later.
  prefs: []
  type: TYPE_NORMAL
- en: 'While `mutate` is the staple for performing mutations in React Query, there
    is also another function you can use if you so desire: `mutateAsync`.'
  prefs: []
  type: TYPE_NORMAL
- en: mutateAsync
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While in most scenarios you will use `mutate`, sometimes you might want to access
    the promise that contains the result of your mutation. In these scenarios, you
    can use `mutateAsync`.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to keep in mind while using `mutateAsync` is that you need to handle
    the promise yourself. This means that in an error scenario, you need to catch
    the error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how you can use the `mutateAsync` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we destructure the `mutateAsync` function from the
    `useMutation` hook:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to handle potential error scenarios, so we wrap our `mutateAsync` call
    with a `try-catch` statement. Since this is an asynchronous function, we must
    wait for the data to be returned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is an error, we catch it and show an error in our console.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding snippet shows how you can trigger mutations by using `mutateAsync`;
    as we showed in `mutate`, it doesn’t seem to be a very practical example. To help
    you create a mental model of how you can use `mutateAsync` to perform mutations,
    you can see the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we can see an example of a simple form using a controlled
    component where we leverage `mutateAsync` to perform concurrent mutations. This
    is what is happening in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: We create a state variable to control the state of our input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create our first mutation using the `createUser` function as the mutation
    function and destructure `mutateAsync` as `mutateAsyncOne` from it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create our second mutation using the `registerUser` function as the mutation
    function and destructure `mutateAsync` as `mutateAsyncTwo` from it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We create a `submitForm` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This function will receive the event from the form and prevent it from propagating
    so your page is not refreshed.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We assign the promise returned from the call of `mutationAsyncOne` with `name`
    as a parameter to our `mutationOne` variable.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We assign the promise returned from the call of `mutationAsyncTwo` with `name`
    as a parameter to our `mutationTwo` variable.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We leverage the `Promise.all` method and pass it to our `mutationOne` and `mutationTwo`
    promises so they can be performed concurrently.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside our form, we create our input to handle our name and have React control
    its state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a button with an `onClick` event to fire our `submitForm` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that you are familiar with how you can perform mutations, let’s review a
    variable that is impacted by the success of a mutation, `data`.
  prefs: []
  type: TYPE_NORMAL
- en: data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This variable is the last successfully resolved `data` of the mutation returned
    from your mutation function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how you can use the `data` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this snippet, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We destructure our `data` variable from our `useMutation` hook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On our component return, we check whether we already have `data` from our mutation.
    If we do, we render it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the hook renders initially, this `data` will be undefined. Once the mutation
    triggers and finishes executing, and the promise returned from the mutation function
    successfully resolves our data, we will have access to the `data`. If for some
    reason our mutation function promise rejects, we can use the next variable, the
    `error` one.
  prefs: []
  type: TYPE_NORMAL
- en: error
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `error` variable lets you access the `error` object returned from your mutation
    function after failing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how you can use the `error` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We destructure our `error` variable from our `useQuery` hook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On our component return, we check whether we have any errors. If we do, we render
    the error message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the hook renders initially, the `error` value will be null. If, after a
    mutation, for some reason the mutation function rejects and throws an error, then
    this error will be assigned to our `error` variable. It is important to mention
    here that this only applies if you are using `mutate`. If you use `mutateAsync`,
    you must catch the error and handle it yourself.
  prefs: []
  type: TYPE_NORMAL
- en: When using the `error` variable, there will be times for the sake of user experience
    when you want to clear your errors. In those scenarios, the `reset` function will
    be your best friend.
  prefs: []
  type: TYPE_NORMAL
- en: reset
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `reset` function allows you to reset `error` and `data` to their initial
    state.
  prefs: []
  type: TYPE_NORMAL
- en: This function is useful if you need to clear the current value of data or errors
    after running a mutation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how you can use the `reset` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In this snippet, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We destructure our `data` and `error` variables and the `reset` function from
    our `useMutation` hook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On our component return, we check whether we already have data or errors from
    our mutation. When and if we do, we render them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also render a button with an `onClick` event. When clicked, this button will
    trigger our `reset` function to clear our `data` and `error` values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, to use the `error` and `data` variables, we just check in the code whether
    they are defined to allow us to render them. To make this easier and once again
    help you craft a better user experience in your application, you can resort to
    using the `status` variable.
  prefs: []
  type: TYPE_NORMAL
- en: status
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like queries, when performing a mutation, the mutation can go through several
    states. These states help you to give more feedback to your users. For you to
    know what the current state of your mutation is, the `status` variable was created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the states that the `status` variable can have:'
  prefs: []
  type: TYPE_NORMAL
- en: '`idle`: This is the initial status of your mutation before being executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loading`: This indicates if your mutation is currently executing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`error`: This indicates that there was an error while performing the last mutation.
    Whenever this is the status, the `error` property will receive the error returned
    from the mutation function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`success`: Your last mutation was successful, and it has returned data. Whenever
    this is the status, the `data` property will receive the successful data from
    the mutation function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is how you can use the `status` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we are leveraging the `status` variable to create
    a better user experience for our users. Here is what we are doing:'
  prefs: []
  type: TYPE_NORMAL
- en: We create a state variable to handle our controlled form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create our mutation and destructure `status` from the `useMutation` hook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create a `submitForm` function to handle our mutation submission.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We leverage our `status` variables to do the following in our component return:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `status` is `idle`, we render a message letting the user know our mutation
    hasn’t run.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If `status` equals `error`, we must destructure our `error` variable and display
    the error message.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If `status` equals `success`, we must destructure our `data` variable and display
    it to our user.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If `status` equals `loading`, it means we are executing a mutation, so we use
    this to make sure we disable our **Add** button and avoid the user clicking it
    again while the mutation runs.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, you know how to use the `status` variable. For convenience, React Query
    also introduced some Boolean variants to help identify each state. They are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`isIdle`: Your `status` variable is in the idle state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isLoading`: Your `status` variable is in the loading state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isError`: Your `status` variable is in the error state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isSuccess`: Your `status` variable is in the success state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s now rewrite our previous snippet leveraging our `status` Boolean variants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the code is similar. All we had to do was replace our `status`
    variable with `isLoading`, `isError`, `isSuccess`, and `isIdle` in the destructuring
    part and then use these variables in the respective status check.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike queries, mutations don’t have a `fetchStatus` variable. Now, this doesn’t
    mean that your mutation cannot suffer from a sudden loss of internet connection.
    To give more feedback to your users, the `isPaused` variable was created.
  prefs: []
  type: TYPE_NORMAL
- en: isPaused
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you should remember from [*Chapter 4*](B18501_04.xhtml#_idTextAnchor091),
    React Query introduced a new property called `networkMode`. When used in online
    mode, you can access a new variable in your `useMutation` hook called `isPaused`.
  prefs: []
  type: TYPE_NORMAL
- en: This Boolean variable identifies whether your mutation is currently paused due
    to a lost connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see how to use the `isPaused` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we leverage the `isPaused` variable to craft a better
    user experience in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: We destructure our `isPaused` variable from our `useMutation` hook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our component return, we check whether `isPaused` is `true`. If so, we render
    a message to let our users know. We also assign it to disable our **Add** button
    to avoid the user accidentally triggering another mutation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we know some of the values our `useMutation` hook returns, let’s see
    how we can customize this hook with some options.
  prefs: []
  type: TYPE_NORMAL
- en: Commonly used mutation options explained
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like the `useQuery` hook, more options can be passed into our `useMutation`
    hook than just its mutation function. These options will also help us craft a
    better developer and user experience.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll see some options that are more common and very important
    for you to be aware of.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the options we’ll look at:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cacheTime`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mutationKey`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`retry`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`retryDelay`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onMutate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onSuccess`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onError`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onSettled`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: cacheTime
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `cacheTime` option is the duration in milliseconds that the data in your
    cache that is inactive remains in memory. Once this time passes, the data will
    be garbage collected. Note that this does not work the same way as it does with
    queries. If you perform a mutation, the returned data is cached, but if you perform
    the same mutation again while this mutation is pending, `useMutation` won’t return
    the previous mutation data. In mutations, this option is mostly useful for preventing
    previous mutation data from being held in `MutationCache` indefinitely.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how to use the `cacheTime` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, we define that after our mutation is inactive for one minute,
    the data will be garbage collected.
  prefs: []
  type: TYPE_NORMAL
- en: mutationKey
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes you will want to set some defaults for all your mutations by leveraging
    your `queryClient` `setMutationDefaults`.
  prefs: []
  type: TYPE_NORMAL
- en: The `mutationKey` option allows React Query to know whether it needs to apply
    previously configured defaults to this mutation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how to use the `mutationKey` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we create a mutation with `["myUserMutation"]` as
    the mutation key. If any defaults were configured to be applied to any mutation
    with `["myUserMutation"]` as the mutation key, they would now be applied.
  prefs: []
  type: TYPE_NORMAL
- en: retry
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `retry` option is a value that indicates whether your mutation will retry
    or not when it fails. When `true`, it will retry until it succeeds. When `false`,
    it won’t retry.
  prefs: []
  type: TYPE_NORMAL
- en: This property can also be a number. When it is a number, the mutation will retry
    that specified number of times.
  prefs: []
  type: TYPE_NORMAL
- en: '*By default, React Query will not retry a mutation* *on error.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how to use the `retry` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the snippet, we set the `retry` option to `2`. This means that when failing
    to perform a mutation, this hook will retry performing the mutation two times.
  prefs: []
  type: TYPE_NORMAL
- en: retryDelay
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `retryDelay` option is the delay to apply before the next retry attempt
    in milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: By default, React Query uses an exponential backoff delay algorithm to define
    the retry timing between retries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how to use the `retryDelay` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the snippet, we define a linear backoff function as our `retryDelay` option.
    Every time there is a retry, this function receives the attempt number and multiplies
    it by 2,000\. This means that the time between every retry will be two seconds
    longer.
  prefs: []
  type: TYPE_NORMAL
- en: onMutate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `onMutate` option is a function that will be triggered before your mutation
    function is fired. This function also receives the variables your mutation function
    will receive.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can return values from this function that will be passed to your `onError`
    and `onSettled` callback functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, we pass an arrow function to our `onMutate` option. When our
    mutation is triggered, this function assigned to the `onMutate` option will be
    called with the variables your mutation function will receive. We then use these
    variables to show a notification to the user about the pending mutation.
  prefs: []
  type: TYPE_NORMAL
- en: onSuccess
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `onSuccess` option is a function that will be triggered when your mutation
    is successful.
  prefs: []
  type: TYPE_NORMAL
- en: If a promise is returned from this function, it will be awaited and resolved.
    This means your mutation status will be in a loading state until the promise resolves.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how to use the `onSuccess` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the snippet, we pass an arrow function to our `onSuccess` option. When our
    mutation performs successfully, this function assigned to the `onSuccess` option
    will be called with our data. We then use this data to log a message to our console.
  prefs: []
  type: TYPE_NORMAL
- en: onError
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `onError` option is a function that will be triggered when your mutation
    fails.
  prefs: []
  type: TYPE_NORMAL
- en: If a promise is returned from this function, it will be awaited and resolved.
    This means your mutation status will be in a loading state until the promise resolves.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how to use the `onError` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the snippet, we pass an arrow function to our `onError` option. When the
    mutation fails, this function assigned to the `onError` option will be called
    with the thrown error. We then log the error in our console.
  prefs: []
  type: TYPE_NORMAL
- en: onSettled
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `onSettled` option is a function that will be triggered when your mutation
    is either successful or fails.
  prefs: []
  type: TYPE_NORMAL
- en: If a promise is returned from this function, it will be awaited and resolved.
    This means your mutation status will be in a loading state until the promise resolves.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how to use the `onSettled` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the snippet, we pass an arrow function to our `onSettled` option. When the
    mutation fails or succeeds, this function assigned to the `onSettled` option will
    be called with the thrown error or the resolved data. We then log a message in
    our console.
  prefs: []
  type: TYPE_NORMAL
- en: By now, you should be familiar with how the `useMutation` hook works and should
    be able to start using it to create, update, or delete your server state data.
    Now, let us see how we can leverage this hook and some of its options to perform
    some common side-effect patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Performing side-effect patterns after mutations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you read this section title, you might have been wondering whether you’ve
    seen how to perform side effects after your mutations previously. The answer is
    yes, you already did. To perform side effects after a mutation, you can leverage
    any of these options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onMutate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onSuccess`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onError`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onSettled`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, what you haven’t seen is how you can leverage these side effects to do
    some amazing things that might improve your user experience, such as performing
    multiple side effects, refetching a query, or even updating your query data after
    a mutation.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will review some ways we leverage the callback functions
    of our `useMutation` hook and more to perform the previously mentioned side effects.
  prefs: []
  type: TYPE_NORMAL
- en: How to perform an additional side effect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During development, a scenario may come up where it would be useful if you could
    perform two `onSuccess` callbacks. Now, you can definitely add as much logic as
    you want to your `useMutation` hook callback, but what if you wanted to split
    the logic or only execute this specific logic on one single mutation? This would
    indeed be useful because you could separate the concerns and logic. Well, you
    can definitely do it!
  prefs: []
  type: TYPE_NORMAL
- en: The `mutate` function allows you to create your own callback functions that
    will execute after your `useMutation` callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: You just need to be aware that your `useMutation` callbacks run first, and then
    your `mutate` function callbacks. This is important to know because sometimes
    if you do something that causes your hook to unmount on your `useMutation` callback,
    your `mutate` function callbacks might not be called after.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how to use the `mutate` callback functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we leverage the `mutate` callback functions to perform
    some extra side effects. Here is what we are doing:'
  prefs: []
  type: TYPE_NORMAL
- en: We create our mutation with `useMutation`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside this mutation, we leverage the `onSuccess` callback, which will receive
    the resolved data and display a toast to the user to let them know that data was
    created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then create a `submitForm` function that will be given to an `onSubmit` event
    later on in our code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When triggered, this function will prevent the received event from propagating.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This function will also trigger our mutation by calling `mutate`. In this `mutate`,
    we leverage its `onSuccess` callback to trigger a route change.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we know how to use the `mutate` callback functions to perform some
    extra side effects, let’s see how we can retrigger a query after performing a
    mutation.
  prefs: []
  type: TYPE_NORMAL
- en: How to retrigger a query refetch after mutation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When performing mutations that will change the data of a query you are currently
    displaying to your users, it is recommended that you refetch that query. This
    is because, at this time, you know that this data has changed, but if your query
    is still marked as fresh internally, React Query won’t refetch it; therefore,
    you must do it yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Having read the previous two chapters, when you read this section title, something
    must have come to your mind, and that is query invalidation!
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how you can leverage the `onSuccess` callback to retrigger a query
    refetch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we leverage our `onSuccess` callback to retrigger
    a query after a successful mutation. Here is what we are doing:'
  prefs: []
  type: TYPE_NORMAL
- en: We get access to `queryClient`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create our query with `["allUsers"]` as a query key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create our mutation. In this mutation `onSuccess` callback, we leverage our
    `queryClient` `invalidateQueries` method to trigger a refetch of our query with
    `["allUsers"]` as the query key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As mentioned at the beginning of this section, this is a recommended practice,
    and you should do it every time you are mutating data your user sees on the page.
    Now, you might be thinking: if our mutation was successful, it might have returned
    the new data, so can’t we just manually update our query data and avoid an extra
    request?'
  prefs: []
  type: TYPE_NORMAL
- en: How to perform an update to our query data after a mutation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can definitely manually update your query data. All you need is access to
    `queryClient` and the query key of the query you want to update.
  prefs: []
  type: TYPE_NORMAL
- en: While this might be a practice that might save some bandwidth on the user side,
    it doesn’t guarantee that the data you end up displaying to your user is accurate.
    What if someone else using the same application changes your data?
  prefs: []
  type: TYPE_NORMAL
- en: Now, if there are guarantees that there is no one else able to update this server
    state, then feel free to try. Just be sure that your query refetches somewhere
    in between to guarantee that all the data is up to date.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how you can perform an update to your query data after a successful
    mutation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous snippet, we leverage our `onSuccess` callback to update our
    query data and avoid refetching it. Here is what we are doing:'
  prefs: []
  type: TYPE_NORMAL
- en: We get access to `queryClient`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create our query with `["allUsers"]` as a query key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create our mutation. In this mutation `onSuccess` callback, we leverage our
    `queryClient` `setQueryData` function to manually update the data of the query
    with `["allUsers"]` as the query key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this update, we create a new array that combines our created data and our
    previous data to create the new query data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As you can see, there are a couple of patterns you can apply to improve your
    user experience after performing mutations. Now, when speaking about mutations
    often, one topic shows up every time, which is the topic that will close this
    chapter: optimistic updates!'
  prefs: []
  type: TYPE_NORMAL
- en: Performing optimistic updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in [*Chapter 2*](B18501_02.xhtml#_idTextAnchor049), an optimistic
    update is a pattern used during an ongoing mutation where we update our UI to
    show how it will look after our mutation is finished, although our mutation is
    still not confirmed as complete.
  prefs: []
  type: TYPE_NORMAL
- en: Well, React Query allows you to perform optimistic updates, and it makes it
    extremely simple. All you need is to use the callback functions we saw in the
    previous sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how to perform an optimist update using the `useMutation` hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we put our gained knowledge about mutations into
    practice to create a better user experience for our users using optimistic updates.
    Here is what we are doing:'
  prefs: []
  type: TYPE_NORMAL
- en: We define the needed imports for our code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `fetchAllData` query function. This function will trigger a `GET`
    request to our endpoint to fetch the user data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `createUser` mutation function. This function will receive the user
    and perform a `POST` request to our endpoint to create it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside our `Mutation` component, we do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We get access to `queryClient`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Create state variables and respective setters for the name and age inputs.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Create our query using `["allUsers"]` as the query key and `fetchAllData` as
    the query function.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create our mutation using `createUser` as the mutation function. Inside this
    mutation, we define some callbacks:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the `onMutate` callback, we do our optimistic update:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We make sure we cancel any ongoing queries for our query with `["allUsers"]`
    as the query key. To do this, we use our `queryClient` `cancelQueries` method.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We save our previous data cached under the `["allUsers"]` query key just in
    case we need to roll back. To do this, we leverage our `queryClient` `getQueryData`
    function.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We perform our optimistic update by merging our new data with our previous data
    and updating the data cached under the `["allUsers"]` query key. To do this, we
    leverage our `queryClient` `setQueryData` function.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We return our `previousUsers` data in case we need to roll back.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the `onError` callback, in case of an error, we need to roll back our data:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: As a good practice, we let our users know something went wrong with our mutation.
    In this scenario, we are displaying a toast notification.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To do the rollback, we access our context parameter and leverage the `previousUsers`
    data returned from the `onMutate` callback. We then use this variable to override
    the cached data under the `["allUsers"]` query key. To do this, we use our `queryClient`
    `setQueryData` function.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the `onSettled` callback, when our mutation settles, we need to refetch
    our data:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To refetch our data, we leverage our `queryClient` `invalidateQueries` and invalidate
    the query with `["allUsers"]` as the query key.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our component return, we create a `div` element with the following:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We use the `data` variable from our query to display our users’ data.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We create our controlled form with our name and age inputs.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We also create a button that, when pressed, fires its `onClick` event and consequentially
    triggers our mutation with our name and age values.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Having seen how you build an optimistic update, here is the flow of our created
    optimistic update:'
  prefs: []
  type: TYPE_NORMAL
- en: Our component renders, and our query fetches our data and caches it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we click on the **Add** button, the data returned from the query is automatically
    updated to include the new user and reflects this change on the UI immediately.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there is an error, we roll back to our previous data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When our mutation settles, we refetch the data for the query we just performed
    the optimistic update on to ensure our query is updated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With this knowledge under your belt, you now have all the knowledge you need
    to take your mutation game to the next level with the help of your new ally: `useMutation`!'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how React Query allows us to perform mutations by
    using the `useMutation` hook. By now, you should be able to create, delete, or
    update your server state. To make these changes, you resort to the mutation function,
    which, like your query function, supports any client and allows you to use GraphQL
    or REST as long it returns a promise.
  prefs: []
  type: TYPE_NORMAL
- en: You learned about some things the `useMutation` hook returns, such as the `mutate`
    and `mutateAsync` functions. Similar to `useQuery`, `useMutation` also returns
    the mutation `data` and `error` variables and gives you access to some statuses
    you can use to craft a better user experience. For your convenience, `useMutation`
    also returns a `reset` function to clear your state and an `isPaused` variable
    in case your mutation enters a paused state.
  prefs: []
  type: TYPE_NORMAL
- en: For you to customize your developer experience, you learned about some commonly
    used options that allow you to customize your `useMutation` hook experience. We
    then leveraged four of these options to teach you how to perform some side effects
    after your mutation runs.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you used some of the knowledge you learned to perform optimistic updates
    and craft a better experience for your application users.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 7*](B18501_07.xhtml#_idTextAnchor173), *Server-Side Rendering with
    Next.js or Remix*, we’ll understand how we can leverage React Query even in a
    scenario where we are using a server-side framework. You will learn how you can
    fetch your data in the server and provision React Query on your client side to
    make it work and craft a better experience.
  prefs: []
  type: TYPE_NORMAL
