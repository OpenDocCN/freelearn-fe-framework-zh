- en: Chapter 7. Rendering on the Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, you learned how to render different sections of our CMS
    without reloading the page. We even created a way to see the public pages of our
    website, using the same routing techniques.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we did everything in the browser. We stored pages in local storage.
    We used the website and CMS as if they were hosted on the Internet, but we're
    the only ones who can see it. If we want to share our creations with others, we
    need some kind of server-side technology.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will take a brief look at some aspects of server-side JavaScript
    and React programming. We'll see how React works outside of the browser, and how
    we can persist and share data with many people in real-time.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering components to strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the beautiful things about React is that it works in many places. It
    is aimed at rendering interfaces efficiently, but those interfaces can extend
    outside of the DOM and the browser.
  prefs: []
  type: TYPE_NORMAL
- en: You can use React to render native mobile interfaces ([https://facebook.github.io/react-native](https://facebook.github.io/react-native)),
    or even plain HTML strings. This becomes useful when we want to reuse the component
    code in different places.
  prefs: []
  type: TYPE_NORMAL
- en: We can, for instance, build an intricate data table component for our CMS. We
    can ship that component to an iPad application or even render it from the web
    server as a way of minimizing page load time.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s the latter example that we will try in this chapter. To begin, we need
    to install the source versions of React and React DOM libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve already seen examples of the React libraries, but these new ones (from
    BabelJS) will give us a way of using ES6 and JSX on the server. They even provide
    an alternative to running our code directly through Node.js. Normally, we would
    run server-side JavaScript code using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'But, we can now use a BabelJS version, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to tell BabelJS which code presets to apply to our code. By default,
    it will apply a select few ES6 transformations, but not all of them. It also won''t
    handle JSX, unless we load that preset as well. We do this by creating a file
    called `.babelrc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We're used to seeing ES6 `import` statements, but perhaps not the RequireJS
    `require` statements. These are similar in function, and Node.js uses them as
    a means of importing code from external scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also require a file called `hello-world.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s something new again! We have loaded a new React library, called `ReactDOMServer`
    and render a string from a `div` component. Usually we would use something like
    `React.render(component, element)` in the browser. But, here we''re only interested
    in the HTML string the component generates. Consider running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the preceding command, we will see something resembling this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Perhaps not exactly what we expect, but it looks like valid HTML. We can use
    this!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we can render components to HTML strings, it would serve us better
    to have a way to respond to HTTP requests with HTML responses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, Node.js also includes a neat little HTTP server library. We can
    use the following code, in the `server.js` file, to respond to HTTP requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: To use the HTTP server library, we need to require/import it. We create a new
    server, and in the callback parameter, respond to individual HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: For each request, we set a content type and respond with the HTML value of our
    `hello-world.js` file. The server listens on port `3000`, which means you'll need
    to open `http://127.0.0.1:3000` to see this message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can do that, we also need to adjust `hello-world.js` slightly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `module.exports = ...` statement is the RequireJS equivalent of the `export
    default ...` statement that we're used to seeing. The result is that this file
    will return the component HTML string whenever it is required by another.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we open the URL (`http://127.0.0.1:3000`) in the browser, we should see
    a `hello world` message, and inspecting it will show similar React HTML for the
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a simple server](img/5268_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can learn more about the Node.js HTTP server at [https://nodejs.org/api/http.html](https://nodejs.org/api/http.html).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a server backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the things our CMS is still missing is public, persistent pages. So far,
    we stored them in local storage, and that's OK while we build up our CMS components.
    But a time will come when we would want to share our data with the world.
  prefs: []
  type: TYPE_NORMAL
- en: For this to work, we need some storage mechanism. Even if that storage is only
    in memory for as long as the server is running. Sure, we could use a relational
    database or an object store to persist our CMS pages. For now, let's keep things
    simple. An in-memory store (pages variable) should do for now.
  prefs: []
  type: TYPE_NORMAL
- en: So, how should we structure this data store? Whatever storage medium we choose,
    the interface will need to reach out to the server to store and retrieve data.
    There are two mainstream options I want to explore...
  prefs: []
  type: TYPE_NORMAL
- en: Communicating through Ajax requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ajax is a loaded word. For the purposes of this chapter, I want you to think
    of it only as a means to fetch data from a server and send data to it using HTTP
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: We've just seen how we can respond to HTTP requests, so we're half-way there!
    At this point, we can inspect requests to determine the URL and method of each
    HTTP request. A browser may be requesting something like `GET http://127.0.0.1:3000/pages`
    to get all the pages. So, if the method matches `POST` and the path matches `/pages`,
    then we can respond with the appropriate pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily for us, others have been down this path before. Projects such as ExpressJS
    have sprung up to provide some scaffolding for us. Let''s install ExpressJS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can convert our simple HTTP server to be based on ExpressJS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that you'll need to restart the `node server.js` command after each
    change to these JavaScript files.
  prefs: []
  type: TYPE_NORMAL
- en: 'This should render exactly the same in a browser. However, it''s a lot easier
    to define application endpoints for new things:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `JSON.stringify` statement converts a JavaScript variable to a string representation,
    which is a useful format for communicating over a network.
  prefs: []
  type: TYPE_NORMAL
- en: We also have access to methods such as `app.post` for handling `POST` requests.
    It's really easy to start designing HTTP endpoints for our backend data.
  prefs: []
  type: TYPE_NORMAL
- en: Then, in the browser, we need a way to make these requests. One common solution
    is to use a library such as jQuery. Sometimes that's a good idea, but usually
    only when you need more than just the Ajax functionality jQuery provides.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re looking for a lean solution, try something such as SuperAgent ([https://github.com/visionmedia/superagent](https://github.com/visionmedia/superagent))
    or even the new Fetch API ([https://developer.mozilla.org/en/docs/Web/API/Fetch_API](https://developer.mozilla.org/en/docs/Web/API/Fetch_API)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Using this approach, we can slowly replace the local storage parts of our backend
    with calls to the server. There, we can store page data in an array, a relational
    database, or an object store.
  prefs: []
  type: TYPE_NORMAL
- en: Ajax is a time-tested approach to communicate between the browser and the server.
    It's a well-supported technique with many kinds of shims for older browsers (from
    iframes to flash).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can learn more about ExpressJS at [http://expressjs.com](http://expressjs.com).
  prefs: []
  type: TYPE_NORMAL
- en: Communicating through web sockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, it's better to have fast, bi-directional communication between the
    browser and the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'At such a time, you can try web sockets. They''re an upgrade to the traditional
    HTTP communication seen in Ajax. To work with them easily, we need the help of
    Socket.IO:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can access a new object, which we''ll call `io`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `"message"` can be anything. You can send messages of different types simply
    by changing this to something else. If you send a message with `"chat message"`
    or `"page command"`, then you need to add event listeners for the same message
    type.
  prefs: []
  type: TYPE_NORMAL
- en: We create a new `io` instance with a reference to the HTTP server. Web socket
    connections begin with an HTTP request, so that's a good place to listen for them.
  prefs: []
  type: TYPE_NORMAL
- en: 'When new web socket connections are made, we can start to listen for messages.
    For now, we can just send the messages back. Socket.IO provides the web socket
    client script, but we do still need to connect and send messages. Let''s update
    `hello-world.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two important things to note in this block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: We can use multiline strings as part of the ES6 syntax. Instead of single or
    double quotes, we can use backticks for strings that we want to span over multiple
    lines.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can set the innerHTML (which is something we need to do to get JavaScript
    to render on the browser through this HTTP response) via the `dangerouslySetInnerHTML`
    attribute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You can learn more about `dangerouslySetInnerHTML` at [https://facebook.github.io/react/tips/dangerously-set-inner-html.html](https://facebook.github.io/react/tips/dangerously-set-inner-html.html).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In our web socket examples, the flow of data resembles the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An HTTP and web socket server listen on `http://127.0.0.1:3000`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Requests to `/` return some browser scripts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These scripts begin a connection request to the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server picks up these connection requests and adds event listeners for new
    messages after the connections are successfully opened.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The browser scripts add event listeners for new messages and immediately a send
    message to the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server's event listeners are triggered and the messages are re-sent to all
    open sockets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The browser's event listeners are triggered and the messages are written to
    the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: In this example, we broadcast the messages (from the server) to all open sockets.
    You can limit the messages to specific socket connections using something such
    as `socket.emit("message", message)`. Check the Socket.IO documentation for examples.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You should see the `hello world` message in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Communicating through web sockets](img/5268_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can learn more about Socket.IO at [http://socket.io](http://socket.io).
  prefs: []
  type: TYPE_NORMAL
- en: Structuring server-side applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to HTTP and web socket servers, it's usually a good idea to separate
    the endpoint code from the server initialization code. Some folks like to create
    separate routes files, which can then be required by the `server.js` file. Still
    others like to have each endpoint as a separate file and define routes as glue
    between `server.js` and these "handler" files.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps that's enough for the kinds of applications you will build, or perhaps
    you like a more prescriptive structure to your applications, something such as
    AdonisJS ([http://adonisjs.com](http://adonisjs.com)), for example.
  prefs: []
  type: TYPE_NORMAL
- en: Adonis is a beautifully structured MVC framework for Node.js applications. It
    uses many cool tricks (such as generators) to enable a clean API for defining
    templates, request handlers, and database code.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical request can be handled in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You would define this class in a file called `app/Http/Controllers/HomeController.js`.
    To have this file rendered, when browsers go to the home page of your website,
    you can define a route in `app/Http/routes.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You can couple this with some persistent, relational database storage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: All in all, AdonisJS provides a lot of structure to an otherwise open and interpretive
    landscape. It reminds me a lot of the popular PHP framework—Laravel, which itself
    draws queues from the popular Ruby on Rails framework.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can learn more about AdonisJS at [http://adonisjs.com](http://adonisjs.com).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to render components on the server. We created
    a simple HTTP server and then upgraded it to allow multiple endpoints and web
    sockets. Finally, we looked briefly at how we can structure our server-side code
    and quickly looked at the AdonisJS MVC framework.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about some popular React design patterns
    that you can apply to your components and interfaces.
  prefs: []
  type: TYPE_NORMAL
