- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More Data-Fetching Challenges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you must be familiar with how React Query enables you to fetch data
    with the help of `useQuery`. You even learned how to deal with some common challenges
    that the server state brings you.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to deal with some more server state challenges.
    You will understand how you can perform parallel queries and, in the process,
    get to know a variant of your `useQuery` hook that makes it easier, called `useQueries`.
  prefs: []
  type: TYPE_NORMAL
- en: You will again leverage `QueryClient` to deal with data prefetching, query invalidation,
    and query cancelation. You will even learn how to customize the methods you use
    to do these things by using some filters.
  prefs: []
  type: TYPE_NORMAL
- en: '`useQuery` and even meeting another variant called `useInfiniteQuery`.'
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will use the Devtools once again to look inside
    your queries and enhance your debugging of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Building parallel queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging `QueryClient`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating paginated queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating infinite queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging your queries with Devtools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_5](https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_5).
  prefs: []
  type: TYPE_NORMAL
- en: Building parallel queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A typical pattern that we often find the need to use is parallel queries. Parallel
    queries are queries that are executed at the same time to avoid having sequential
    network requests, often called network waterfalls.
  prefs: []
  type: TYPE_NORMAL
- en: Parallel queries help you avoid network waterfalls by firing all the requests
    simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: 'React Query allows us to perform parallel queries in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Manually
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manual parallel queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This would probably be how you would do parallel queries if I asked you to do
    it right now. It involves just writing any number of `useQuery` hooks side by
    side.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern is great when you have a fixed number of parallel queries you want
    to execute. This means that the number of queries you will perform will always
    be the same and not change.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how you can write parallel queries following this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we create three different queries by adding different
    query keys to all of them. These queries will all be fetched in parallel, and
    once the query function is resolved, we will have access to their data. We then
    use this data to render their `hello` property inside `p` tags.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic parallel queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While manual parallel queries fit most scenarios, if your query number varies,
    you won’t be able to use it without breaking the rules of hooks. To deal with
    this issue, React Query created a custom hook called **useQueries**.
  prefs: []
  type: TYPE_NORMAL
- en: '`useQueries` allows you to dynamically call as many queries as you want. Here
    is its syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding snippet, the `useQueries` hook receives an
    array of queries in its `queries` property. These queries can even receive options
    if you want, so the mental model you should have here is that these queries can
    be customized the same way as a `useQuery` hook.
  prefs: []
  type: TYPE_NORMAL
- en: The `useQueries` hook will return an array with all your query results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you are aware of how `useQueries` works, let’s put it to practice
    in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We create a `usernameList` string array to help us create some dynamic queries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside our `useQueries` hook, for each instance inside `usernameList`, we create
    a respective query with its query key and query function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use the result of our `useQueries` hook; for each item inside of it, we leverage
    `isFetching` to display to the user that we are fetching data. If it is not fetching
    data, then we assume we already did our request, and we show the fetched data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that you know how to leverage `useQuery` and `useQueries` to perform parallel
    queries, let us see how you can leverage `QueryClient` to solve some more server-state
    challenges.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging QueryClient
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you are aware, `QueryClient` allows you to interact with your cache.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we saw how `QueryClient` could be leveraged to trigger
    refetching a query. What we haven’t seen yet is how `QueryClient` can be used
    for much more things.
  prefs: []
  type: TYPE_NORMAL
- en: To use `QueryClient` in your components, you can leverage the `useQueryClient`
    hook to access it. Then, all you have to do is call the method you need.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we’ll see how you can use `QueryClient` to solve more server
    state challenges such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Query invalidation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prefetching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query cancelation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we start query invalidation, one thing to be aware of is that some of
    these methods, namely the ones we are going to see, can receive certain query
    filters to help you match with the right queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous chapter, we saw the following example for query refetching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet is an example of where we can provide a filter to the
    `refetchQueries` method. In this scenario, we are trying to refetch all the queries
    that either match or start with the query key, `["api"]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can use more filters other than the query key. The filters that are
    used in the `QueryClient` methods, typically called `QueryFilters`, support filtering
    by things such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Query key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether the query is stale or fresh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fetchStatus`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A predicate function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here are some examples of using `QueryFilters`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we use the `type` filter with the `active` value
    to refetch all the queries that are currently active:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, we use the `stale` filter with `true` as a value
    to refetch all the queries whose `staleTime` has elapsed and are now considered
    stale:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, we use the `fetchStatus` filter with `idle` as a
    value to refetch all the queries that are currently not fetching anything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the following example, we use the `predicate` property and pass an anonymous
    function to it. This function will receive the query being verified and access
    its current status; if this status is an error, then the function will return
    `true`. This means that all queries whose status is currently an error will refetch.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you don’t need to pass only one filter. You can send a combination of
    filters as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we refetch all stale queries whose query key begins
    with `["api"]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t want to pass any filter and want the method to apply to all queries,
    you can opt not to pass any filters like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This example will refetch all the queries.
  prefs: []
  type: TYPE_NORMAL
- en: You are now familiar with `QueryFilters` and can see some of the server-state
    challenges involved. Let’s start with query invalidation.
  prefs: []
  type: TYPE_NORMAL
- en: Query invalidation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, independent of your configured `staleTime`, your data will become
    stale. Why, you ask? Well, sometimes, it might be because of mutations you have
    performed; other times, it might be because another user somewhere interacted
    with your server state.
  prefs: []
  type: TYPE_NORMAL
- en: When this happens, you can leverage your `QueryClient` **invalidateQueries**
    method to mark your queries as stale.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `invalidateQueries` method syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: By calling `invalidateQueries`, every query that matches or starts with `["api"]`
    will be marked as `stale`, overriding its `staleTime` if configured. If your query
    is active because a `useQuery` hook rendered is using it, then React Query will
    take care of refetching that query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now put this into practice with the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we have an example of invalidating a query. This
    is what we are doing:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a query identified by the `[{ queryIdentifier: "api", username: "userOne"
    }]` query key'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting access to `queryClient`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Rendering our query data and button for which `onClick` will invalidate all
    queries that match or contain `[{ queryIdentifier: "api" }]` as part of its query
    key'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When the user clicks on the `[{ queryIdentifier: "api" }]` as part of its query
    key, that query data will be marked immediately as `stale`. Since this query is
    being rendered now, it will automatically be refetched in the background.'
  prefs: []
  type: TYPE_NORMAL
- en: Prefetching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want your user experience to be the best possible one. This sometimes involves
    understanding what the users want even before they do. This is where prefetching
    can help you.
  prefs: []
  type: TYPE_NORMAL
- en: When you can predict that your user might want to do something that inevitably
    triggers a query, you can leverage that knowledge and prefetch your query to save
    some future time for your users.
  prefs: []
  type: TYPE_NORMAL
- en: '`QueryClient` allows you to access a method called **prefetchQuery** to prefetch
    your data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `prefetchQuery` method syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`prefetchQuery` requires a query key and query function. This method will try
    to fetch your data and cache it under the given query key. *This is an asynchronous
    method*; therefore, you will need to wait for it to complete.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now see a practical example of when we can prefetch our data with our
    `ExamplePrefetching` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we create our `ExamplePrefetching` component. Here
    is what it does:'
  prefs: []
  type: TYPE_NORMAL
- en: It creates a state variable that will be used to allow us to render `PrefetchedDataComponent`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It gets access to `queryClient`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It creates a function called `prefetchData` where we call the `prefetchQuery`
    method and cache the returned data under the `[{ queryIdentifier: "api", username:
    "userOne" }]` query key. We also give it a `staleTime` of 1 minute, so after calling
    this query, the data will be considered fresh for 1 minute.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a button that, when clicked, will change our state variable to allow
    us to render `PrefetchedDataComponent`. This button also has an `onMouseEnter`
    event that will trigger our data prefetching.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let us now look at our `PrefetchedDataComponent` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we can see `PrefetchedDataComponent`. This component
    has a query that is identified by the `[{ queryIdentifier: "api", username: "userOne"
    }]` query key. When this data exists, it will be rendered inside `div`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s review the flow of these two components for a user:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ExamplePrefetching` is rendered.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user will see a button saying **Render Component**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The user puts their mouse over the button to click on it. At this time, we
    predict that the user will click on the button, so we trigger the data prefetching.
    Once the data has been prefetched, it is cached under the `[{ queryIdentifier:
    "api", username: "userOne" }]` query key.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user clicks on the button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PrefetchedDataComponent` is rendered.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `useQuery` hook that is identified by the `[{ queryIdentifier: "api", username:
    "userOne" }]` query key will already have the data cached and marked as fresh
    for one minute, so it doesn’t need to trigger data-fetching.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user sees the prefetched data rendered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Query cancelation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There will be times when your `useQuery` hook will unmount while it is doing
    a query. By default, once your promise has been resolved, this query data will
    still be received and cached. But, for some reason, you might want to cancel your
    queries if your hook unmounts in the middle of data-fetching requests. React Query
    can take care of this by automatically canceling your query if you desire. You
    can even cancel your queries manually if you want.
  prefs: []
  type: TYPE_NORMAL
- en: To allow you to cancel your queries, React Query uses a signal that can communicate
    with DOM requests and abort them. This signal is the **AbortSignal** object, which
    belongs to the **AbortController** Web API.
  prefs: []
  type: TYPE_NORMAL
- en: The `AbortSignal` signal is injected into our query function by `QueryFunctionContext`,
    and then it should be consumed by our data-fetching client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how we can leverage `AbortSignal` with `axios`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we receive `signal` from `QueryFunctionContext` and
    pass it as an option in our `axios` client while doing a `get` request.
  prefs: []
  type: TYPE_NORMAL
- en: If you use an alternative to `axios` such as `fetch` or `graphql-request` in
    a scenario in which you use GraphQL, you also need to pass `AbortSignal` to your
    client.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how you can do it using `fetch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we receive `signal` from `QueryFunctionContext` and
    pass it as an option to our `fetch` call.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using a GraphQL client such as `graphql-request`, this is how you
    can do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we also receive `signal` from `QueryFunctionContext`
    and pass it as an option in our client request.
  prefs: []
  type: TYPE_NORMAL
- en: Passing the signal to our clients is only the first step in allowing them to
    cancel queries. You need to trigger an automatic query cancelation or a manual
    one.
  prefs: []
  type: TYPE_NORMAL
- en: Manual cancelation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For manually canceling a query, `QueryClient` gives you access to the **cancelQueries**
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `cancelQueries` method syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: By calling `cancelQueries`, every query that matches or starts with `["api"]`
    that is currently fetching and that has received `AbortSignal` will be aborted.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic cancelation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a component using your hook unmounts and your query is currently fetching,
    if you pass `AbortSignal` to your client, React Query will abort your query by
    canceling the promise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see how React Query leverages `AbortSignal` to cancel your query with
    the next examples. First, we start by configuring our query function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we create a `fetchData` function that will receive
    `QueryContextObject`. From it, we get access to `signal` and pass it to our `axios`
    client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us see our components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we have a component called `ExampleQueryCancelation`.
    This component will render and unmount a component called `QueryCancelation` wherever
    a user clicks on a button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now see the `QueryCancelation` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The snippet shows us the `QueryCancelation` component. In this component, we
    are doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a query identified by the `[{ queryIdentifier: "api", username: "userOne"
    }]` query key.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We get access to `QueryClient`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We render our `data` from the query.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We render a button that, when clicked, will use `QueryClient` to cancel all
    the queries that either match or include `[{ queryIdentifier: "api" }]` in their
    keys.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let us now review these components’ lifetimes and how the query cancelation
    can work out:'
  prefs: []
  type: TYPE_NORMAL
- en: We render the `ExampleQueryCancelation` component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We click the button to render the `QueryCancelation` component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`QueryCancelation` is rendered and its `useQuery` hook will trigger a request
    to fetch its data.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: During this request, we click right back on the button to render `QueryCancelation`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since our request hasn’t been resolved yet and our component is unmounted, React
    Query will abort our signal, which will cancel our request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We click the button to render the `QueryCancelation` component again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`QueryCancelation` is rendered, and its `useQuery` hook will trigger a request
    to fetch its data.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: During this request, we click on the button to cancel our query. This will force
    React Query to abort our signal and cancel our request once again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have thus seen how `QueryClient` and some of its methods can help us solve
    some of our common server state challenges.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll see how React Query allows us to build a common UI
    pattern, that is, paginated queries.
  prefs: []
  type: TYPE_NORMAL
- en: Creating paginated queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building an API to deal with large datasets, to avoid having your frontend
    deal with everything at once, you don’t want to send all the available data in
    one request. A pattern often used to make this easier is API pagination.
  prefs: []
  type: TYPE_NORMAL
- en: If your API is paginated, you want to apply the same pattern to your application.
  prefs: []
  type: TYPE_NORMAL
- en: The good thing is that you only need to use `useQuery` and one of its options,
    `keepPreviousData`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the next examples and then understand how pagination and React
    Query work. First, we start with our query function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we create the function that will be used as our query
    function. Since this is a paginated API, we will need the `page` to fetch our
    data. As we established in the last chapter, if a variable is a dependency of
    our query, it needs to be added to the query key. We then destructure the `page`
    from our query key in our query function. Then, all we need to do is fetch our
    data and return it when the promise resolves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now see how we can build a component for displaying and fetching paginated
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s recap in order what is happening in the preceding code block:'
  prefs: []
  type: TYPE_NORMAL
- en: We create a state variable to hold our current selected `page`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We create our query, which has the `[{ queryIdentifier: "api", page }]` query
    key, our `fetchData` function as the query function, and set `keepPreviousData`
    to `true`. We set this option as `true` because, by default, whenever our query
    key changes, so will the query data; now, because we have a paginated API, we
    want to keep showing our data even if we change pages.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then destructure `isLoading`, `isError`, `error`, `data`, `isFetching`, and
    `isPreviousData`. `isPreviousData` is used to indicate whether the data currently
    being shown is the previous version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then have two `if` statements to show when our query is loading, or when
    there is an error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we have data, we display it and two buttons to move to the next and the previous
    page. The button to move to the next page leverages `isPreviousData` to make sure
    it is disabled after we click it and move to the following query. We also display
    a fetching indicator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have seen how the code is structured, let’s see how it behaves
    when interacted with:'
  prefs: []
  type: TYPE_NORMAL
- en: Our component is rendered, and the first page starts to be fetched.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `isLoading` property is set as `true`, so we render `Loading` `initial data`.
  prefs: []
  type: TYPE_NORMAL
- en: The data for the first page is resolved, so we display it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We click on the `page` value is incremented.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The query key changes, so the following query starts fetching.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we have `keepPreviousData` as `true`, we will still display the old data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we are displaying old data, `isPreviousData` is set to `true`, and the
    `Loading`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We get the new data and display it.*   We click on the `Loading`.*   The new
    data is received and displayed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, all you need is a new option and the same old `useQuery` hook
    to enable you to build an application using pagination.
  prefs: []
  type: TYPE_NORMAL
- en: For the next section, let’s see now how we can build infinite queries.
  prefs: []
  type: TYPE_NORMAL
- en: Creating infinite queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another very common UI pattern is building an infinite scroll component. In
    this pattern, we are presented with a list that allows us to load more data as
    we scroll down.
  prefs: []
  type: TYPE_NORMAL
- en: To deal with these types of lists, React Query has an alternative to the `useQuery`
    hook, which is another custom hook called **useInfiniteQuery**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `useInfiniteQuery` hook has many similarities to the `useQuery` one,
    but some things differ that we need to be aware of:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your data is now an object that contains the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fetched pages
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `page` parameters that were used to fetch the pages
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A function called `fetchNextPage` to fetch the next page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function called `fetchPreviousPage` to fetch the previous page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Boolean state called `isFetchingNextPage` to indicate that the next page is
    being fetched
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Boolean state called `isFetchingPreviousPage` to indicate that the next page
    is being fetched
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Boolean state called `hasNextPage` to indicate whether the list has a next
    page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Boolean state called `hasPreviousPage` to indicate whether the list has a
    previous page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These last two Boolean values depend on two options that can be passed to the
    hook. Respectively, they are `getNextPageParam` and `getPreviousPageParam`. The
    functions will be responsible for picking the last or first page in the cache
    and checking whether its data indicates the next or previous page to be fetched.
    If these values exist, then the respective Boolean values will be `true`. If they
    return undefined, then the Boolean values will be `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the `useInfiniteQuery` hook, you need to import it this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us now see an example of how to use the `useInfiniteQuery` hook to build
    an infinite list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we set up the function to be used as the infinite
    query function. The hook will pass `pageParam` in `QueryFunctionContext` so that
    we can leverage it to fetch our data. Like the query function in the `useQuery`
    hook, this query function needs to either resolve the data or throw an error,
    so all the same principles learned previously apply.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next snippet will show us our `InfiniteScroll` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we have a component that renders an infinite list.
    This is what we are doing in the component:'
  prefs: []
  type: TYPE_NORMAL
- en: We create `useInfiniteQuery`, which has `["api"]` as the query key and `fetchData`
    as the query function. It also receives an anonymous function in the `getNextPageParam`
    option to check whether there is still more data to be loaded on the next page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also destructure from the hook some variables needed to build our application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then have two `if` statements to show when our query is loading, or when
    there is an error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we have data, we map the content inside its `page` properties to render
    our list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We also render a button that will be disabled if we don’t have the next page
    or when we are currently fetching the next page. When clicked, this button will
    fetch more data. This button message will also depend on some constraints:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we are fetching, the next page will show a `Loading` message
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If we have the next page, it will show `Load more` so the user can click it
    to start fetching
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is no more data to fetch, it will show a message letting the user know
    there is no more data
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we just reviewed how the component is built, let us see how it will work
    when interacting with it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our component renders, and the first page of the list is automatically fetched:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `isLoading` property is set to `true`, so we render `Loading` `initial data`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The data for the first page of the list is resolved, so we display it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the same time, the `getNextPageParam` function checks whether we have more
    data on the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there is no more data, the `hasNextPage` property is set to `false` and the
    button for fetching more data is disabled and displays **You have no** **more
    data**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there is more data, the `hasNextPage` property is set to `true`, and the
    user can click the button to fetch more data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the user clicks the button, we see the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next page starts fetching.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `isFetchingNextPage` value becomes `true`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The button is disabled and displays the loading message.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The data is resolved, and our data `pages` property length increases as it has
    the data for the new page. *Steps 3, 4,* and *5* are repeated.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: With this, we just saw how the `useQuery` variant called `useInfiniteQuery`
    allows us to build an infinite list straightforwardly.
  prefs: []
  type: TYPE_NORMAL
- en: Before we wrap up this chapter, let’s finally see how we can use the React Query
    Devtools to help us debug our code and see how our queries behave.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging your queries with Devtools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B18501_03.xhtml#_idTextAnchor062), you learned about React
    Query Devtools. At that point, you didn’t know how to use queries yet, so we could
    not see it working. Well, now we can.
  prefs: []
  type: TYPE_NORMAL
- en: For the images you are going to see next, we are going to leverage the code
    we wrote when showing you the `useQueries` hook example in the *Dynamic parallel*
    *queries* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'So that you remember, here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'When using that code and checking our page, this is what the Devtools will
    present us with:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – React Query Devtools after parallel queries are executed](img/Figure_5.1_B18501.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – React Query Devtools after parallel queries are executed
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding figure, we can see the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: We have three queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each one of the queries is identified by the respective query key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the queries are currently stale
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have selected the query identified with the `[{ queryIdentifier: "api",
    username: "userThree" }]` query key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we select a query, we can see the query details in our **Query** **Details**
    tab.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, we can see that this query is identified by its query
    key and its status.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scrolling down on the **Query Details** tab, we are also able to see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – React Query Devtools Query Details tab displaying Actions and
    Data Explorer](img/Figure_5.2_B18501.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – React Query Devtools Query Details tab displaying Actions and Data
    Explorer
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, we can see that we can perform several actions for
    the selected query, such as refetching, invalidating, resetting, and removing
    it.
  prefs: []
  type: TYPE_NORMAL
- en: We are also able to see the current data of this query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scrolling even further down our **Query Details** tab, we can also check **Query
    Explorer**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – React Query Devtools Query Details tab displaying Query Explorer](img/Figure_5.3_B18501.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – React Query Devtools Query Details tab displaying Query Explorer
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, we can see `cacheTime` of `300000`.
  prefs: []
  type: TYPE_NORMAL
- en: You are now aware of what you can see in the Devtools for each selected query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before wrapping up this section, let’s just see what happens when we click
    on one of the buttons available in the **Query** **Details** actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – React Query Devtools currently fetching a query](img/Figure_5.4_B18501.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – React Query Devtools currently fetching a query
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding figure, we clicked on the `[{ queryIdentifier: "api", username:
    "userTwo" }]` query key.'
  prefs: []
  type: TYPE_NORMAL
- en: As you remember from learning about query invalidation, when we invalidate a
    query, it is automatically marked as `stale`, and if the query is currently being
    rendered, it will automatically be refetched. As you can see from the figure,
    this is what happened. Our query was already stale, so there was no need to mark
    it as `stale` again, but as it was currently being rendered on our page, React
    Query took care of refetching it, and we can see that in the figure.
  prefs: []
  type: TYPE_NORMAL
- en: As you saw from this section, the Devtools can save you a lot of time debugging
    your queries. By looking inside your queries, you can check what their data looks
    like if you have configured the right options, and even trigger some actions if
    you so desire.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned more about using the `useQuery` hook to solve some
    common challenges we are presented with when dealing with the server state. By
    now, you can handle all your data fetching needs and do it easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'You learned about parallel queries and learned you could manually build these
    queries with `useQuery`. You were also introduced to one alternative of the `useQuery`
    hook: `useQueries`. With it, you learned how to build dynamic parallel queries.'
  prefs: []
  type: TYPE_NORMAL
- en: You got to learn more about some methods of `QueryClient` that allow you to
    prefetch, cancel, and invalidate queries and also understood how you can leverage
    `QueryFilters` to customize the query matching used in these methods.
  prefs: []
  type: TYPE_NORMAL
- en: Pagination is a typical UI pattern, and now you know that you can easily build
    a paginated component with the help of `useQuery` and one of its options.
  prefs: []
  type: TYPE_NORMAL
- en: Another typical UI pattern is infinite scrolling. With the help of another `useQuery`
    variant called `useInfiniteQuery`, you learned how React Query enables you to
    build an application with an infinite list.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you looked inside your queries with the React Query Devtools and understood
    how it allows you to debug them and improve your development process.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 6*](B18501_06.xhtml#_idTextAnchor159), *Performing Data Mutations
    with React Query*, we’ll leave data fetching behind and move on to mutations.
    You’ll understand how React Query enables you to perform mutations with the help
    of one of its custom hooks called `useMutation`. You will also leverage this hook
    to deal with more common server-state challenges you find in your applications
    and start building a better user experience in your apps by using optimistic updates.
  prefs: []
  type: TYPE_NORMAL
