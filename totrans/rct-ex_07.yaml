- en: Chapter 7. React Addons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned to use React on the server side. We understood
    pre-rendering of the React components and changes in the component life cycle
    when using React on server. We also saw how to use server-side API of React using
    Express.js.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at React addons—utility packages that are not
    a part of React core, however, they make development process fun and enjoyable.
    We will learn to use immutability helpers, cloning of components, and test utilities
    in this chapter. We will not be covering other addons such as `Animation`, `Perf`,
    and `PureRenderMixin`. These addons will be covered in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with React addons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immutability helpers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloning React components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test helpers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with Addons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After completing the previous project about using React on server side, Mike's
    team got some free time before starting the next project. Mike decided to utilize
    this time by learning about React addons.
  prefs: []
  type: TYPE_NORMAL
- en: '"Shawn, we got some free time. Let''s use it to get started with React addons."'
  prefs: []
  type: TYPE_NORMAL
- en: '"What are React addons? Are they related to React core library?" Shawn asked.'
  prefs: []
  type: TYPE_NORMAL
- en: '"React addons are utility modules that are not a part of the React core library.
    However, they are blessed by the React team. In future, some of them might be
    included in the React core. These libraries provide helpers for writing immutable
    code, utilities for testing React apps, and ways to measure and improve the performance
    of React apps." explained Mike.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Each addon has its own npm package, making it to simple to use. For example,
    to use the Update addon, we need to install and require its npm package."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Immutability helpers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '"Shawn, as we are learning about addons, let''s add the sorting feature to
    our app so that the users can sort the books by their titles. I have already added
    the required markup for it."'
  prefs: []
  type: TYPE_NORMAL
- en: '![Immutability helpers](img/4730_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '"Can you try writing the code for sorting when a user clicks on the **Title**
    heading?" Mark asked.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Here it is. I introduced the sorting state to indicate the direction of sorting—ascending
    or descending."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '"When the user clicks on **Title**, it will sort the books stored in the existing
    state in ascending or descending order using the sort-by npm package and update
    the state with the sorted books."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '"Shawn, this is functional; however, it''s not following the React way. React
    assumes that the state object is immutable. Here we are using reference to the
    books from the existing state when we are assigning value to `unsortedBooks`."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '"Later, we are mutating `unsortedBooks` into `sortedBooks`; however, as a side-effect,
    we are also mutating the current value of `this.state`."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![Immutability helpers](img/4730_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '"As you can see, even if we commented call to this.`setState`, our current
    state is still mutated." Mark explained.'
  prefs: []
  type: TYPE_NORMAL
- en: '"This can be easily fixed using `Object.assign` from ES6\. We can simply create
    a new array and copy the current value of `this.state.books` in it. We can then
    sort the new array and call `setState` with the new sorted array." informed Shawn.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Object.assign` method copies the values of all the enumerable properties
    from multiple source objects in a target. More details can be found at the following:
    [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![Immutability helpers](img/4730_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '"Yes. This works. But the `Object.assign` method will make a shallow copy of
    `this.state.books`. It will create a new `unsortedBooks` object, however, it will
    still use the same references from `this.state.books` in `unsortedBooks`. Let''s
    say, for some reason, we want the titles of all books in uppercase letters, then
    we may accidently mutate `this.state` too," Mike explained.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![Immutability helpers](img/4730_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '"As you can see, even after using `Object.assign`, `this.state.books` was still
    mutated. Actually, this has nothing to do with React as such. It is due to the
    way JavaScript passes references of arrays and objects around. However, due to
    this, if we have arrays and objects in our deeply nested state, it becomes hard
    to prevent mutations." Mike further explained.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Do we always have to perform a deep copy of the state object to be on the
    safer side?" Shawn asked.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Well, deep copies can be expensive and sometimes hard to achieve with deeply
    nested state. Fortunately, React provides the Update addon with immutability helpers,
    which we can use to solve this issue." added Mike.'
  prefs: []
  type: TYPE_NORMAL
- en: '"While using immutability helpers, we need to answer the following three questions:"'
  prefs: []
  type: TYPE_NORMAL
- en: What needs to be changed?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where it needs to be changed?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it needs to be changed?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"In this case, we need to change the `this.state` to display the sorted books."'
  prefs: []
  type: TYPE_NORMAL
- en: '"The second question is that where should the mutation happen inside `this.state`?
    The mutation should happen in `this.state.books`."'
  prefs: []
  type: TYPE_NORMAL
- en: '"The third question is that how should the mutation happen? Are we going to
    delete something or add any new element or restructure existing elements? In this
    case, we want to sort the elements as per some criterion."'
  prefs: []
  type: TYPE_NORMAL
- en: '"The Update addon accepts two parameters. The first parameter is the object
    that we want to mutate. The second parameter tells us where and how should the
    mutation take place in the first parameter. In this case, we want to mutate `this.state`.
    In `this.state`, we want to update the books with the sorted books. Therefore,
    our code will look similar to the following:"'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Available commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Update addon provides different commands to perform the mutations in arrays
    and objects. The syntax of these commands is inspired by MongoDB's query language.
  prefs: []
  type: TYPE_NORMAL
- en: '"Most of these commands operate on array objects allowing us to push in an
    array or unshift an element from the array. It also supports replacing the target
    entirely using the set command. Other than this, it also provides the merge command
    to merge new keys with an existing object." Mike explained.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Shawn, my favorite command provided by this addon is apply. It takes a function
    and applies that function to the current value of the target that we want to modify.
    It gives more flexibility to make changes in the complex data structures. It''s
    also a hint for your next task. Try to use it to sort the books by title without
    mutating." Mike challenged.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Sure. Here you go," said Shawn.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![Available commands](img/4730_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '"Perfect, Shawn. Using the Update addon makes it very easy to manage complex
    state without actually mutating it."'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Check [https://facebook.github.io/immutable-js/docs/](https://facebook.github.io/immutable-js/docs/)
    for a complete solution for using immutable data structures in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Cloning components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Shawn, props are also immutable in React. In most of the cases, the child
    component just uses props passed by the parent component. However, sometimes we
    want to extend the incoming props with some new data before rendering the child
    component. It''s a typical use case to update styles and CSS classes. React provides
    an addon to clone a component and extending its props. It''s called the **cloneWithProps**
    addon." said Mike.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Mike, that addon is deprecated. I had looked at it in the past and React has
    deprecated it. It also has lot of issues related to refs of the child component
    not getting passed to the newly-cloned child components," Shawn informed.'
  prefs: []
  type: TYPE_NORMAL
- en: '"True. However, React also has a top-level `React.cloneElement` API method,
    which allows us to clone and extend a component. It has a very simple API and
    it can be used instead of the cloneWithProps addon." Mike explained.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '"This method can be used to clone the given element and merge the new props
    with existing props. It replaces existing children with new children. Therefore,
    we have to keep this in mind while dealing with the child components."'
  prefs: []
  type: TYPE_NORMAL
- en: '"The `cloneElement` function also passes ref of the old child component to
    the newly-cloned component. Therefore, if we have any callbacks based on refs,
    they will continue to work even after cloning."'
  prefs: []
  type: TYPE_NORMAL
- en: '"Shawn, here is your next challenge. We show listing of books in our app. In
    fact, in all of our apps, we show the listing of other things such as products,
    items, and so on. We want to show the rows with alternate colors in all of these
    listings instead of just white background. As the code for this feature will be
    the same across all the apps, I am thinking about creating a separate component
    that will accept rows as input and render them with alternate colors. Such components
    can be used in all of our apps. I think that you can make use of `React.cloneElement`
    for this." Mike explained the next task.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Sounds like a good idea to extract this as a separate component. We need it
    in almost all the apps. Our QA was complaining about the lack of colors in our
    search app yesterday." Shawn remembered.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Let''s add some alternate colors then." Mike chuckled.'
  prefs: []
  type: TYPE_NORMAL
- en: '"First, let''s see how we are displaying books currently."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '"The `BookList` component just renders the rows passed to it as it is using
    `this.props.children`."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '"Mike, I am naming the component `RowAlternator`. The `RowAlternator` component
    will get the dynamic array of children rows and it will render them with alternate
    colors. We can pass multiple colors to `RowAlternator` too. In this way, the client
    code using this component can control the colors that they want to use as alternate
    colors."'
  prefs: []
  type: TYPE_NORMAL
- en: '"Sounds good, Shawn. I think this much API is enough for now."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '"As we don''t know how many children elements we will get in `RowAlternator`,
    we will just iterate over all of them and set style with alternate colors. We
    are also using `React.cloneElement` here to clone the passed child and extend
    its style prop with appropriate background color."'
  prefs: []
  type: TYPE_NORMAL
- en: '"Let''s change our `BookList` component now in order to use `RowAlternator`."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '"We are all set. The listing now shows alternate colors as we wanted, as shown
    in the following image:"'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cloning components](img/4730_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '"Perfect, Shawn. As you already noticed, using `React.cloneElement` makes sense
    when we are building a component with dynamic children, where we don''t have control
    on the render method of these children, but want to extend their props based on
    some criteria." Mike was happy.'
  prefs: []
  type: TYPE_NORMAL
- en: Helpers for testing React apps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '"Shawn, we have not added any tests for our app yet, however, the time has
    come to start slowly adding test coverage. With the Jest library and Test Utilities
    addon, it becomes very easy to set up and start testing the React apps." Mark
    explained the next task.'
  prefs: []
  type: TYPE_NORMAL
- en: '"I have heard about Jest. Isn''t it a testing library by Facebook?" Shawn asked.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Jest
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '"Yes. It''s built on top of Jasmine. It''s very easy to set up. First, we have
    to install the `jest-cli` and `babel-jest` packages."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '"After that, we need to configure `package.json`, as follows:"'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '"By default, Jest mocks all modules, however, here we are telling Jest not
    to mock React and the related libraries. We are also specifying the extensions
    for our test file that will be identified by Jest as test files."'
  prefs: []
  type: TYPE_NORMAL
- en: '"Create a `__test__` folder, where we will be adding our tests. Jest will run
    the tests from files in this folder. Let''s add an empty file too. We have to
    make sure that the file should end with `-test.js` so that Jest will pick up it
    to run the tests." Mike explained.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '"Now let''s verify that we can run the tests from the command line."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should see an output that is similar to the preceding output. It may change
    based on the Jest version. Consult [https://facebook.github.io/jest/docs/getting-started.html](https://facebook.github.io/jest/docs/getting-started.html)
    to set up Jest, in case of any issues.
  prefs: []
  type: TYPE_NORMAL
- en: '"Shawn, we are all set with Jest. It''s time to start writing the tests now.
    We will test whether the top-level `App` component gets mounted correctly. However,
    first, we need to understand a bit more about using Jest," said Mike.'
  prefs: []
  type: TYPE_NORMAL
- en: '"By default, Jest mocks all the modules that are required in a test file. Jest
    does this to isolate the module that is under test from all the other modules.
    In this case, we want to test the `App` component. If we just require it, then
    Jest will provide a mocked version of `App`."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '"As we we want to test the `App` component itself, we need to specify Jest
    not to mock it. Jest provides the `jest.dontmock()` function for this purpose."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Check [https://facebook.github.io/jest/docs/automatic-mocking.html](https://facebook.github.io/jest/docs/automatic-mocking.html)
    for more details about automatic mocking feature of Jest.
  prefs: []
  type: TYPE_NORMAL
- en: '"Next up, we will add imports for the React and TestUtils addon."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '"The TestUtils addon provides utility functions to render the components, finding
    sub-components in rendered components and mimicking events on the rendered component.
    It helps in testing both the structure and behavior of the React components."
    Mike added.'
  prefs: []
  type: TYPE_NORMAL
- en: Testing structure of React components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '"We will start with the `renderIntoDocument` function. This function renders
    the given component into a detached DOM node in the document. It returns `ReactComponent`,
    which can be used for further testing."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '"We rendered the `App` component in DOM and asserted that initially books and
    searching state are being set correctly." Mike explained.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Mike, this is awesome. We are not testing real DOM, but testing the React
    components instead."'
  prefs: []
  type: TYPE_NORMAL
- en: '"Yes. The TestUtils addon comes with finder methods that can be used to find
    the child components in a given component tree. They are useful to find the child
    components such as input box and submit button and simulate click events or change
    events."'
  prefs: []
  type: TYPE_NORMAL
- en: '`findAllInRenderedTree(tree, predicate function)`: This is useful for finding
    all the components in a given tree that returns the truth value for the predicate
    function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scryRenderedDOMComponentsWithClass(tree, className)`: This is useful for finding
    all the DOM components with a given class name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`findRenderedDOMComponentWithClass(tree, className)`: Instead of finding all
    the DOM components with a given class, this method expects that only one such
    component is present. It throws an exception if there are multiple components
    with a given class name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scryRenderedDOMComponentsWithTag(tree, tagName)`: It''s similar to finding
    the DOM components with the class name, however, instead of class name, it finds
    the components based on a given tag name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`findRenderedDOMComponentWithTag(tree, tagName)`: Instead of finding all the
    components with a given tag, it expects that only one such component is present.
    It also throws exception when more than one such components exists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scryRenderedComponentsWithType(tree, componentType)`: This method finds all
    the components with a given type. It''s useful to find all the composite components
    created by the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`findRenderedComponentWithType (tree, componentType)`: This is similar to all
    the previous finder methods. It raises exception if more than one component with
    a given type is present.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing behavior of React components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '"Let''s use these functions to assert that the search for books starts when
    a user enters a search term and clicks the **Submit** button. We will simulate
    the event of entering search term by the user." said Mike.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '"We render the `App` component, find the input node, set the value of the input
    node to the search term, and simulate the change event using `TestUtils.Simulate()`.
    This function simulates the given event dispatch on a DOM node. The `Simulate`
    function has a method for every event that React understands. Therefore, we can
    simulate all events such as change, click, and so on. We can test the user behavior
    using this method," Mike explained.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Got it. Therefore, after changing the search term, we click the submit button
    and verify that the state gets updated as per our expectations," informed Shawn.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Yes, Shawn. Now, can you check whether the Spinner is shown once the user
    clicks the **Submit** button? You can use one of the finder method that we discussed
    earlier." Mike explained the next task.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Yes. Once the component state changes after clicking the **Submit** button,
    we can search the rendered component tree to see whether the Spinner component
    is present or not."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '"We are using `TestUtils.findRenderedComponentWithType` here to check whether
    Spinner is present in the tree rendered by the `App` component or not. However,
    before adding this assertion, we need to import the Spinner component at the top
    of the test file as `findRenderedComponentWithType` expects a second argument
    to be a React component."'
  prefs: []
  type: TYPE_NORMAL
- en: '"Excellent, Shawn. As you can see, the testing behavior of the React component
    becomes very easy with the `TestUtils.Simulate` and `finder` methods." Mike explained.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we have not added a test to asynchronously load the books from Open
    Library API as it is out of the scope of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Shallow rendering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '"Shawn, TestUtils also provides one more way to test the components in an isolated
    fashion using the Shallow rendering. Shallow rendering allows us render the top-level
    component and assert the facts about the return value of it''s render method.
    It does not render children components or instantiate them. Therefore, our tests
    are not affected by the behavior of the children components. Shallow rendering
    also does not require a DOM, unlike the previous methods, where we rendered the
    component in a detached DOM," Mike explained.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '"This creates a shallow renderer object, in which we will render the component
    that we want to test. Shallow renderer has a render method similar to `ReactDOM.render`,
    which can be used to render the component."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '"After render method is called, we should call `renderer.getRenderedOutput`,
    which returns the shallowly rendered output of rendering the component. We can
    start asserting facts about the component on the output of `getRenderedOutput`."'
  prefs: []
  type: TYPE_NORMAL
- en: '"Let''s see the output we get from `getRenderedOutput`."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '"As you can see, based on the rendered output, we can assert the facts about
    props of the current component. However, if we want to test anything about children
    component, we need to explicitly reach out to them through `this.props.children[0].props.children[1].props.children`."'
  prefs: []
  type: TYPE_NORMAL
- en: '"This makes it hard to test the behavior of the children components using shallow
    rendering. However, it''s useful for testing small components in an isolated way
    as it does not get affected by children component due to shallow rendering," said
    Mike.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started with understanding the React addons and how to use
    them. We used immutability helpers and test utility functions provided by the
    addons. We also looked into how to clone the components.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will make our React app more performant. You will be
    learning about addons that will improve the performance of the React apps. Specifically,
    you will learn how to measure the performance of our apps and how React can make
    faster updates without changing most of the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Let's make our React apps faster!
  prefs: []
  type: TYPE_NORMAL
