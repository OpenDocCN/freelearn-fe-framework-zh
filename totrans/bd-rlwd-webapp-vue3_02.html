<html><head></head><body>
<div id="_idContainer031">
<h1 class="chapter-number" id="_idParaDest-29"><a id="_idTextAnchor028"/><span class="koboSpan" id="kobo.1.1">2</span></h1>
<h1 id="_idParaDest-30"><a id="_idTextAnchor029"/><span class="koboSpan" id="kobo.2.1">Creating a Todo List App</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Now that we have a development environment set up, we will get started with writing a small first application. </span><span class="koboSpan" id="kobo.3.2">In this chapter, we will create a Todo list app, which will teach us how the reactivity of Vue.js and the virtual DOM works. </span><span class="koboSpan" id="kobo.3.3">You can use the Todo list app as a guide to track progress in </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">this book!</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">Let’s make it an assignment with some </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">practical requirements:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">We will make sure that you see a list </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">of items</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">Each item will have </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">a checkbox</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">The list will be sorted by unchecked items first and checked </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">items second</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">The status of an item should be preserved by the browser on </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">future visits</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.15.1">There are different ways of writing a valid Vue.js component. </span><span class="koboSpan" id="kobo.15.2">Currently, the Composition API is preferred over the Options API. </span><span class="koboSpan" id="kobo.15.3">The Options API uses an object-oriented approach, while the Composition API allows for a more reusable way of writing and organizing </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">your code.</span></span></p>
<p><span class="koboSpan" id="kobo.17.1">In this book, we will use the Composition API notation with shorthand for the setup function unless noted otherwise. </span><span class="koboSpan" id="kobo.17.2">This way of writing code removes lots of noise and repetitive operations from your components and is a very efficient way of working. </span><span class="koboSpan" id="kobo.17.3">We’ll also use the TypeScript variant since it is supported out of the box and offers a better </span><strong class="bold"><span class="koboSpan" id="kobo.18.1">Developer eXperience</span></strong><span class="koboSpan" id="kobo.19.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.20.1">DX</span></strong><span class="koboSpan" id="kobo.21.1">) by facilitating </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">strict typing.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.23.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.24.1">You can read more about the syntax here: </span><a href="https://vuejs.org/api/sfc-script-setup.html#script-setup"><span class="koboSpan" id="kobo.25.1">https://vuejs.org/api/sfc-script-setup.html#script-setup</span></a><span class="koboSpan" id="kobo.26.1">. </span><span class="koboSpan" id="kobo.26.2">More about defining components using TypeScript can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">here: </span></span><a href="https://vuejs.org/guide/typescript/composition-api.html#using-script-setup"><span class="No-Break"><span class="koboSpan" id="kobo.28.1">https://vuejs.org/guide/typescript/composition-api.html#using-script-setup</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.29.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.30.1">We will cover the following topics in </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.32.1">Using the CLI tool to create a custom environment for </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">an app</span></span></li>
<li><span class="koboSpan" id="kobo.34.1">Vue.js </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">reactivity concept</span></span></li>
<li><span class="koboSpan" id="kobo.36.1">Styling </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">with CSS</span></span></li>
<li><span class="koboSpan" id="kobo.38.1">First glance at </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">Vue.js DevTools</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.40.1">We have no technical requirements other than what we’ve covered in the previous chapter, so we can get started </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">right away!</span></span></p>
<h1 id="_idParaDest-31"><a id="_idTextAnchor030"/><span class="koboSpan" id="kobo.42.1">A new project</span></h1>
<p><span class="koboSpan" id="kobo.43.1">Let’s start by </span><a id="_idIndexMarker029"/><span class="koboSpan" id="kobo.44.1">scaffolding out a new project, using the CLI commands from the previous chapter. </span><span class="koboSpan" id="kobo.44.2">Open a Terminal window in your </span><strong class="source-inline"><span class="koboSpan" id="kobo.45.1">projects</span></strong><span class="koboSpan" id="kobo.46.1"> folder and use the </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">following instructions:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.48.1">
npm init vue@latest</span></pre> <p><span class="koboSpan" id="kobo.49.1">Hit </span><em class="italic"><span class="koboSpan" id="kobo.50.1">y</span></em><span class="koboSpan" id="kobo.51.1"> to proceed, use </span><strong class="source-inline"><span class="koboSpan" id="kobo.52.1">vue-todo-list</span></strong><span class="koboSpan" id="kobo.53.1"> as the project name, and select the options shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer020">
<span class="koboSpan" id="kobo.55.1"><img alt="Figure 2.1 – The setup configuration for the Todo list app" src="image/B19563_02_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.56.1">Figure 2.1 – The setup configuration for the Todo list app</span></p>
<p><span class="koboSpan" id="kobo.57.1">Go ahead and follow the given instructions to install the dependencies and open your favorite IDE to </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">get started.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.59.1">Tip</span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">npm</span></strong><span class="koboSpan" id="kobo.61.1"> offers a shorthand</span><a id="_idIndexMarker030"/><span class="koboSpan" id="kobo.62.1"> for installing, by typing </span><strong class="source-inline"><span class="koboSpan" id="kobo.63.1">npm i</span></strong><span class="koboSpan" id="kobo.64.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">npm install</span></strong><span class="koboSpan" id="kobo.66.1">. </span><span class="koboSpan" id="kobo.66.2">Read more about </span><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">npm</span></strong><span class="koboSpan" id="kobo.68.1"> commands </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">here: </span></span><a href="https://docs.npmjs.com/cli/v6/commands"><span class="No-Break"><span class="koboSpan" id="kobo.70.1">https://docs.npmjs.com/cli/v6/commands</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.71.1">.</span></span><a id="_idTextAnchor031"/></p>
<h2 id="_idParaDest-32"><a id="_idTextAnchor032"/><span class="koboSpan" id="kobo.72.1">Cleaning up the default installation</span></h2>
<p><span class="koboSpan" id="kobo.73.1">Let’s first clean up the </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">components</span></strong><span class="koboSpan" id="kobo.75.1"> folder </span><a id="_idIndexMarker031"/><span class="koboSpan" id="kobo.76.1">by removing </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">HelloWorld.vue</span></strong><span class="koboSpan" id="kobo.78.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">TheWelcome.vue</span></strong><span class="koboSpan" id="kobo.80.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">WelcomeItem.vue</span></strong><span class="koboSpan" id="kobo.82.1">, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">icons</span></strong><span class="koboSpan" id="kobo.84.1"> folder. </span><span class="koboSpan" id="kobo.84.2">Then we’ll remove the references from </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">App.vue</span></strong><span class="koboSpan" id="kobo.86.1"> and clean up </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">the template.</span></span></p>
<p><span class="koboSpan" id="kobo.88.1">You will see a </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">__tests__</span></strong><span class="koboSpan" id="kobo.90.1"> folder in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">components</span></strong><span class="koboSpan" id="kobo.92.1"> folder, which is added by installing Vitest. </span><span class="koboSpan" id="kobo.92.2">You can ignore it for now. </span><span class="koboSpan" id="kobo.92.3">Otherwise, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">components</span></strong><span class="koboSpan" id="kobo.94.1"> folder should </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">be empty.</span></span></p>
<p><span class="koboSpan" id="kobo.96.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">App.vue</span></strong><span class="koboSpan" id="kobo.98.1"> file should look </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.100.1">
&lt;script setup lang="ts"&gt;&lt;/script&gt;
&lt;template&gt;
&lt;/template&gt;
&lt;style scoped&gt;
… (truncated, unchanged)
&lt;/style&gt;</span></pre>
<p><span class="koboSpan" id="kobo.101.1">The changes will result in a blank page since we’ve removed all the default elements! </span><span class="koboSpan" id="kobo.101.2">Now we can start to build our own application from the </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">ground up.</span></span><a id="_idTextAnchor033"/></p>
<h1 id="_idParaDest-33"><a id="_idTextAnchor034"/><span class="koboSpan" id="kobo.103.1">Building up the app</span></h1>
<p><span class="koboSpan" id="kobo.104.1">In this chapter, we will </span><a id="_idIndexMarker032"/><span class="koboSpan" id="kobo.105.1">add a couple of components and compose the Todo app to follow the requirements, as listed at the beginning of this chapter (see </span><em class="italic"><span class="koboSpan" id="kobo.106.1">Technical requirements</span></em><span class="koboSpan" id="kobo.107.1">). </span><span class="koboSpan" id="kobo.107.2">We’ll add the features step </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">by step.</span></span></p>
<p><span class="koboSpan" id="kobo.109.1">Let’s start simply, with an </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">AppHeader</span></strong><span class="koboSpan" id="kobo.111.1"> component. </span><span class="koboSpan" id="kobo.111.2">Create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">AppHeader.vue</span></strong><span class="koboSpan" id="kobo.113.1"> (remember: Vue.js recommends a filename that consists of at least two camel-cased words) file in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">components</span></strong><span class="koboSpan" id="kobo.115.1"> folder. </span><span class="koboSpan" id="kobo.115.2">This will just be a static component with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">template</span></strong><span class="koboSpan" id="kobo.117.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">css</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.119.1"> block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.120.1">
&lt;template&gt;  &lt;header&gt;
    &lt;h1&gt;&lt;span class="icon" aria-hidden="true"&gt;✅&lt;/span&gt; To do&lt;/h1&gt;
    &lt;p&gt;Building Real-world Web Applications with Vue.js 3&lt;/p&gt;
  &lt;/header&gt;
&lt;/template&gt;
&lt;style scoped&gt;
header {
  border-bottom: #333 1px solid;
  background-color: #fff;
}
header::after {
  content: "";
  display: block;
  height: 1px;
  box-shadow: 0px 0px 10px 0px rgba(0, 0, 0, 0.75);
}
h1 {
  font-size: 2rem;
}
h1 .icon {
  font-size: 1rem;
  vertical-align: middle;
}
&lt;/style&gt;</span></pre>
<p><span class="koboSpan" id="kobo.121.1">A Vue component usually consists of template, script, and style blocks. </span><span class="koboSpan" id="kobo.121.2">Not all are mandatory (we’re not adding any scripts to this component), but between those three, we can define every</span><a id="_idIndexMarker033"/><span class="koboSpan" id="kobo.122.1"> aspect of our component. </span><span class="koboSpan" id="kobo.122.2">In this book, we’ll see numerous examples of this pattern </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">in practice.</span></span></p>
<p><span class="koboSpan" id="kobo.124.1">The template is just a title representation, and we’ll use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">scoped</span></strong><span class="koboSpan" id="kobo.126.1"> style block to apply CSS rules to the markup. </span><span class="koboSpan" id="kobo.126.2">Note the </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">scoped</span></strong><span class="koboSpan" id="kobo.128.1"> attribute, which makes sure that our CSS doesn’t affect other components in </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.130.1">Using scoped CSS, we can write clean, readable rules. </span><span class="koboSpan" id="kobo.130.2">For single file components, this approach should be </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">the default.</span></span></p>
<p><span class="koboSpan" id="kobo.132.1">Let’s continue building our app by creating a </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">list compone</span><a id="_idTextAnchor035"/><span class="koboSpan" id="kobo.134.1">nt.</span></span></p>
<h2 id="_idParaDest-34"><a id="_idTextAnchor036"/><span class="koboSpan" id="kobo.135.1">Creating the ListItem component</span></h2>
<p><span class="koboSpan" id="kobo.136.1">We’ll create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">ListItem.vue</span></strong><span class="koboSpan" id="kobo.138.1"> component in</span><a id="_idIndexMarker034"/><span class="koboSpan" id="kobo.139.1"> the same folder. </span><span class="koboSpan" id="kobo.139.2">It will be the representation of an individual item on the list, and it looks </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.141.1">
&lt;script lang="ts" setup&gt;defineProps&lt;{
  isChecked?: boolean | false
}&gt;()
&lt;/script&gt;
&lt;template&gt;
  &lt;label :class="{ 'checked': isChecked }"&gt;
    &lt;input type="checkbox" :checked="isChecked" /&gt;
    &lt;slot&gt;&lt;/slot&gt;
  &lt;/label&gt;
&lt;/template&gt;
&lt;style scoped&gt;
label {
  cursor: pointer;
}
.checked {
  text-decoration: line-through;
}
&lt;/style</span><a id="_idTextAnchor037"/><span class="koboSpan" id="kobo.142.1">&gt;</span></pre>
<p><span class="koboSpan" id="kobo.143.1">We define the props </span><a id="_idIndexMarker035"/><span class="koboSpan" id="kobo.144.1">that will be passed to the component. </span><span class="koboSpan" id="kobo.144.2">Props are the properties that can be controlled from outside of the component. </span><span class="koboSpan" id="kobo.144.3">These are usually values that are being processed by the component and determine the unique characteristics of the component in that state. </span><span class="koboSpan" id="kobo.144.4">In rare cases, you could pass down a function </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.146.1">By using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">defineProps</span></strong><span class="koboSpan" id="kobo.148.1"> method, we’re using the Vue.js API to declare our </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">props properly.</span></span></p>
<p><span class="koboSpan" id="kobo.150.1">The second bit is the way that the component should render HTML to the virtual DOM. </span><span class="koboSpan" id="kobo.150.2">Vue.js uses a syntax that is HTML-based. </span><span class="koboSpan" id="kobo.150.3">You can read more about it </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">here: </span></span><a href="https://vuejs.org/guide/essentials/template-syntax.html#template-syntax"><span class="No-Break"><span class="koboSpan" id="kobo.152.1">https://vuejs.org/guide/essentials/template-syntax.html#template-syntax</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.153.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.154.1">We’re marking up an HTML </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">&lt;label&gt;</span></strong><span class="koboSpan" id="kobo.156.1"> tag with a dynamic class name: it will render as </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">class="checked"</span></strong><span class="koboSpan" id="kobo.158.1"> when </span><a id="_idIndexMarker036"/><span class="koboSpan" id="kobo.159.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">isChecked</span></strong><span class="koboSpan" id="kobo.161.1"> property evaluates as </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">true</span></strong><span class="koboSpan" id="kobo.163.1">. </span><span class="koboSpan" id="kobo.163.2">In the label, we’ll add a checkbox that has a dynamic </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">checked</span></strong><span class="koboSpan" id="kobo.165.1"> attribute: it too is connected to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">isChecked</span></strong><span class="koboSpan" id="kobo.167.1"> prop. </span><span class="koboSpan" id="kobo.167.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">&lt;slot&gt;&lt;/slot&gt;</span></strong><span class="koboSpan" id="kobo.169.1"> tag is Vue.js-specific and it allows us to put any content in that spot, from the </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">parent component.</span></span></p>
<p><span class="koboSpan" id="kobo.171.1">Lastly, we define the CSS rules for this component, similar to what we did </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">AppHeade</span><a id="_idTextAnchor038"/><span class="koboSpan" id="kobo.174.1">r.vue</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">.</span></span></p>
<h2 id="_idParaDest-35"><a id="_idTextAnchor039"/><span class="koboSpan" id="kobo.176.1">Creating the list</span></h2>
<p><span class="koboSpan" id="kobo.177.1">With the </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">ListItem</span></strong><span class="koboSpan" id="kobo.179.1"> component</span><a id="_idIndexMarker037"/><span class="koboSpan" id="kobo.180.1"> available to us, we can start generating the list. </span><span class="koboSpan" id="kobo.180.2">We’ll create a new component for this, which will hold the list information and use it to render all the individual items on the list as well as to provide the </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">interactive features:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.182.1">Let’s create a simple file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">TodoList.vue</span></strong><span class="koboSpan" id="kobo.184.1">, with the </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">following contents:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.186.1">
&lt;script lang="ts" setup&gt;import ListItem from './ListItem.vue'&lt;/script&gt;&lt;template&gt;&lt;ul&gt;  &lt;ListItem :is-checked="false"&gt;This is the slotted content&lt;/ListItem&gt;&lt;/ul&gt;&lt;/template&gt;</span></pre></li> <li><span class="koboSpan" id="kobo.187.1">Before we continue, we want to be able to display our app while we’re working on it. </span><span class="koboSpan" id="kobo.187.2">So, on</span><a id="_idIndexMarker038"/><span class="koboSpan" id="kobo.188.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">App.vue</span></strong><span class="koboSpan" id="kobo.190.1"> file, follow a similar approach of importing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">AppHeader.vue</span></strong><span class="koboSpan" id="kobo.192.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">TodoList.vue</span></strong><span class="koboSpan" id="kobo.194.1"> files and adding the components to </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">the template:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.196.1">
&lt;script setup lang="ts"&gt;</span><strong class="bold"><span class="koboSpan" id="kobo.197.1">import AppHeader from './components/AppHeader.vue';</span></strong><strong class="bold"><span class="koboSpan" id="kobo.198.1">import TodoList from './components/TodoList.vue';</span></strong><span class="koboSpan" id="kobo.199.1">&lt;/script&gt;&lt;template&gt;</span><strong class="bold"><span class="koboSpan" id="kobo.200.1">  &lt;AppHeader /&gt;</span></strong><strong class="bold"><span class="koboSpan" id="kobo.201.1">  &lt;TodoList /&gt;</span></strong><span class="koboSpan" id="kobo.202.1">&lt;/template&gt;&lt;style scoped&gt;… (truncated)&lt;/style&gt;</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.203.1">Now that we can see what we’re doing, it is a good time to start the development server. </span><span class="koboSpan" id="kobo.203.2">If you’re using </span><strong class="bold"><span class="koboSpan" id="kobo.204.1">Visual Studio Code</span></strong><span class="koboSpan" id="kobo.205.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.206.1">VSCode</span></strong><span class="koboSpan" id="kobo.207.1">), there’s actually a terminal built into </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">the IDE:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.209.1">macOS users</span></strong><span class="koboSpan" id="kobo.210.1">: </span><em class="italic"><span class="koboSpan" id="kobo.211.1">⌃</span></em><span class="koboSpan" id="kobo.212.1"> + </span><em class="italic"><span class="koboSpan" id="kobo.213.1">`</span></em></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.214.1">Windows users</span></strong><span class="koboSpan" id="kobo.215.1">: </span><em class="italic"><span class="koboSpan" id="kobo.216.1">Ctrl</span></em><span class="koboSpan" id="kobo.217.1"> + </span><em class="italic"><span class="koboSpan" id="kobo.218.1">`</span></em></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.219.1">Linux users</span></strong><span class="koboSpan" id="kobo.220.1">: </span><em class="italic"><span class="koboSpan" id="kobo.221.1">Ctrl</span></em><span class="koboSpan" id="kobo.222.1"> + </span><em class="italic"><span class="koboSpan" id="kobo.223.1">Shift</span></em><span class="koboSpan" id="kobo.224.1"> + </span><em class="italic"><span class="koboSpan" id="kobo.225.1">`</span></em></li>
</ul>
<p><span class="koboSpan" id="kobo.226.1">If you run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">npm run dev</span></strong><span class="koboSpan" id="kobo.228.1"> command, it will start the development server and provide you with a local </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">preview URL.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer021">
<span class="koboSpan" id="kobo.230.1"><img alt="Figure 2.2 – Output of the npm run dev command" src="image/B19563_02_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.231.1">Figure 2.2 – Output of the npm run dev command</span></p>
<p><span class="koboSpan" id="kobo.232.1">Since we don’t </span><a id="_idIndexMarker039"/><span class="koboSpan" id="kobo.233.1">have a functional app right now, we need to work on its core feature: the list. </span><span class="koboSpan" id="kobo.233.2">You can leave the development server running since it will automatically </span><a id="_idIndexMarker040"/><span class="koboSpan" id="kobo.234.1">update (this is called hot reloading) with the newly </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">writ</span><a id="_idTextAnchor040"/><span class="koboSpan" id="kobo.236.1">ten code.</span></span></p>
<h2 id="_idParaDest-36"><a id="_idTextAnchor041"/><span class="koboSpan" id="kobo.237.1">Making a list</span></h2>
<p><span class="koboSpan" id="kobo.238.1">The actual functionality</span><a id="_idIndexMarker041"/><span class="koboSpan" id="kobo.239.1"> resides in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">TodoList.vue</span></strong><span class="koboSpan" id="kobo.241.1"> component, which we’ll now create. </span><span class="koboSpan" id="kobo.241.2">We’ll start small and add the more complex features in steps. </span><span class="koboSpan" id="kobo.241.3">Let’s start with a static list that has multiple </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">list statuses.</span></span></p>
<p><span class="koboSpan" id="kobo.243.1">Let’s look at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">script</span></strong><span class="koboSpan" id="kobo.245.1"> block first. </span><span class="koboSpan" id="kobo.245.2">Apart from importing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">ListItem</span></strong><span class="koboSpan" id="kobo.247.1"> component, we’re defining </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">type</span></strong><span class="koboSpan" id="kobo.249.1"> for </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">Item</span></strong><span class="koboSpan" id="kobo.251.1">, which consists of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">title</span></strong><span class="koboSpan" id="kobo.253.1"> property as a string and the optional property </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">checked</span></strong><span class="koboSpan" id="kobo.255.1"> as a Boolean. </span><span class="koboSpan" id="kobo.255.2">TypeScript lets us define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">Type</span></strong><span class="koboSpan" id="kobo.257.1"> alias, which our IDE can plug into when interacting </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">Type</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.261.1">In this example, when accessing the properties on </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">item</span></strong><span class="koboSpan" id="kobo.263.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">ListItem</span></strong><span class="koboSpan" id="kobo.265.1"> template, the IDE already recognizes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">title</span></strong><span class="koboSpan" id="kobo.267.1"> and optional </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">checked</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.269.1"> properties:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.270.1">
&lt;script lang='ts' setup&gt;import ListItem from './ListItem.vue'
type Item = {
  title: string,
  checked?: boolean
}
const listItems: Item[] = [
  { title: 'Make a todo list app', checked: true },
  { title: 'Predict the weather', checked: false },
  { title: 'Play some tunes', checked: false },
  { title: 'Let\'s get cooking', checked: false },
  { title: 'Pump some iron', checked: false },
  { title: 'Track my expenses', checked: false },
  { title: 'Organize a game night', checked: false },
  { title: 'Learn a new language', checked: false },
  { title: 'Publish my work' }
]
&lt;/script&gt;</span></pre>
<p><span class="koboSpan" id="kobo.271.1">When constructing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">ListItems</span></strong><span class="koboSpan" id="kobo.273.1"> array, we assign </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">Type</span></strong><span class="koboSpan" id="kobo.275.1"> as an array of that type using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">[]</span></strong><span class="koboSpan" id="kobo.277.1"> symbols. </span><span class="koboSpan" id="kobo.277.2">We immediately fill the </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">ListItems</span></strong><span class="koboSpan" id="kobo.279.1"> array with a list of items. </span><span class="koboSpan" id="kobo.279.2">This means that TypeScript could also infer the types, but it is a better practice to explicitly set the </span><a id="_idIndexMarker042"/><span class="koboSpan" id="kobo.280.1">types </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">where possible.</span></span></p>
<p><span class="koboSpan" id="kobo.282.1">In the template, we are creating an unordered list element and use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">v-for</span></strong><span class="koboSpan" id="kobo.284.1"> directive to iterate over the items in </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">the array:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.286.1">
&lt;template&gt;  &lt;ul&gt;
    &lt;li
      :key='key'
      v-for='(item, key) in listItems'
    &gt;
      &lt;ListItem :is-checked='item.checked'&gt;{{ item.title }}&lt;/ListItem&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/template&gt;</span></pre>
<p><span class="koboSpan" id="kobo.287.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">v-for</span></strong><span class="koboSpan" id="kobo.289.1"> directive is used to loop over collections and repeat the template that marks the collection. </span><span class="koboSpan" id="kobo.289.2">For every item, the current value is assigned to the first argument (</span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">item</span></strong><span class="koboSpan" id="kobo.291.1">) and optionally provides an index of the collection as the second </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">argument (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">key</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.295.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">v-for</span></strong><span class="koboSpan" id="kobo.297.1"> directive repeats the </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">&lt;li&gt;</span></strong><span class="koboSpan" id="kobo.299.1"> item with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">&lt;ListItem /&gt;</span></strong><span class="koboSpan" id="kobo.301.1">  component enclosed. </span><span class="koboSpan" id="kobo.301.2">For every item, we fill the </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">&lt;ListItem /&gt;</span></strong><span class="koboSpan" id="kobo.303.1"> component with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">is-checked</span></strong><span class="koboSpan" id="kobo.305.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">title</span></strong><span class="koboSpan" id="kobo.307.1"> properties for </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">that item.</span></span></p>
<p><span class="koboSpan" id="kobo.309.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">key</span></strong><span class="koboSpan" id="kobo.311.1"> attribute helps Vue.js in keeping track of the changes that are being made so that it can update</span><a id="_idIndexMarker043"/><span class="koboSpan" id="kobo.312.1"> the virtual DOM </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">more efficiently.</span></span></p>
<p><span class="koboSpan" id="kobo.314.1">Lastly, we have added a </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">scoped</span></strong><span class="koboSpan" id="kobo.316.1"> style block to stylize the elements for the browser. </span><span class="koboSpan" id="kobo.316.2">There’s not much going </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">on here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.318.1">
&lt;style scoped&gt;ul {
  list-style: none;
}
li {
  margin: 0.4rem 0;
}
&lt;/style&gt;</span></pre>
<p><span class="koboSpan" id="kobo.319.1">We now have a non-interactive Todo list app and have met the first two requirements already. </span><span class="koboSpan" id="kobo.319.2">Let’s take a look at how we can add </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">some in</span><a id="_idTextAnchor042"/><span class="koboSpan" id="kobo.321.1">teractivity.</span></span></p>
<h1 id="_idParaDest-37"><a id="_idTextAnchor043"/><span class="koboSpan" id="kobo.322.1">Reactivity explained</span></h1>
<p><span class="koboSpan" id="kobo.323.1">If you have opened the app and clicked an item, you can toggle the checkbox, but on refreshing the page, nothing happens. </span><span class="koboSpan" id="kobo.323.2">Also, if you’ve looked closely at the CSS of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">&lt;ListItem /&gt;</span></strong><span class="koboSpan" id="kobo.325.1"> component, you may have noticed that strikethrough styling should be applied on a checked item. </span><span class="koboSpan" id="kobo.325.2">This is only the case on the </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">first item.</span></span></p>
<p><span class="koboSpan" id="kobo.327.1">The toggling of the checkbox is, in </span><a id="_idIndexMarker044"/><span class="koboSpan" id="kobo.328.1">fact, native browser behavior and doesn’t signify anything in the context of the state of the </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">Todo list!</span></span></p>
<p><span class="koboSpan" id="kobo.330.1">We need to wire the changes in the UI to the state of the application. </span><span class="koboSpan" id="kobo.330.2">In order to get started, we need to import some utilities from the Vue.js package. </span><span class="koboSpan" id="kobo.330.3">Add these two lines to the top of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">&lt;</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">script&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.333.1"> block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.334.1">
import { ref } from 'vue'import type { Ref } from 'vue'</span></pre>
<p><span class="koboSpan" id="kobo.335.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">ref</span></strong><span class="koboSpan" id="kobo.337.1"> function is used to </span><a id="_idIndexMarker045"/><span class="koboSpan" id="kobo.338.1">add reactivity and track updates to certain parts of the code. </span><span class="koboSpan" id="kobo.338.2">The value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">ref</span></strong><span class="koboSpan" id="kobo.340.1"> is automatically inferred by TypeScript, but for complex types, we can specify </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">the type.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.342.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.343.1">Vue.js also offers a </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">reactive</span></strong><span class="koboSpan" id="kobo.345.1"> utility to mark reactivity. </span><span class="koboSpan" id="kobo.345.2">There are slight differences between the two, where </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">ref</span></strong><span class="koboSpan" id="kobo.347.1"> can be used to track primitives and objects and </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">reactive</span></strong><span class="koboSpan" id="kobo.349.1"> can only be initialized with an object. </span><span class="koboSpan" id="kobo.349.2">In general, you can opt for consistency in code by choosing </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">ref</span></strong><span class="koboSpan" id="kobo.351.1"> over </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">reactive</span></strong><span class="koboSpan" id="kobo.353.1">. </span><span class="koboSpan" id="kobo.353.2">The only </span><em class="italic"><span class="koboSpan" id="kobo.354.1">downside</span></em><span class="koboSpan" id="kobo.355.1"> is that you have to access the value of the reactive item by a </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">.value</span></strong><span class="koboSpan" id="kobo.357.1"> property in the script block. </span><span class="koboSpan" id="kobo.357.2">When using the variable in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">template</span></strong><span class="koboSpan" id="kobo.359.1"> block, it is automatically unwrapped by Vue.js. </span><span class="koboSpan" id="kobo.359.2">It’s therefore a small concession for being able to use </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">ref</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.361.1"> consistently.</span></span></p>
<p><span class="koboSpan" id="kobo.362.1">Now that we have imported the utility, we can mark the </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">listItems</span></strong><span class="koboSpan" id="kobo.364.1"> to be tracked by wrapping the contents in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">ref</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.366.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.367.1">
const listItems: </span><strong class="bold"><span class="koboSpan" id="kobo.368.1">Ref&lt;Item[]&gt; = ref(</span></strong><span class="koboSpan" id="kobo.369.1">[  { title: 'Make a todo list app', checked: true },
  { title: 'Predict the weather', checked: false },
  { title: 'Play some tunes', checked: false },
  { title: 'Let\'s get cooking', checked: false },
  { title: 'Pump some iron', checked: false },
  { title: 'Track my expenses', checked: false },
  { title: 'Organise a game night', checked: false },
  { title: 'Learn a new language', checked: false },
  { title: 'Publish my work' }
]</span><strong class="bold"><span class="koboSpan" id="kobo.370.1">)</span></strong></pre>
<p><span class="koboSpan" id="kobo.371.1">Note that capitalized </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">Ref</span></strong><span class="koboSpan" id="kobo.373.1"> is used to</span><a id="_idIndexMarker046"/><span class="koboSpan" id="kobo.374.1"> type the value and lowercase </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">ref</span></strong><span class="koboSpan" id="kobo.376.1"> is used as a wrapper of the array of items. </span><span class="koboSpan" id="kobo.376.2">If we now want to access the values in the script block, we need to access</span><a id="_idIndexMarker047"/><span class="koboSpan" id="kobo.377.1"> them by </span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">listItems.value</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.381.1">Now that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">listItems</span></strong><span class="koboSpan" id="kobo.383.1"> are reactive, the virtual DOM will respond automatically to changes on the variables. </span><span class="koboSpan" id="kobo.383.2">We can add a method that changes an item so that it will be reflected in the </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">user interface.</span></span></p>
<p><span class="koboSpan" id="kobo.385.1">Let’s add the following function to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">script</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.387.1"> block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.388.1">
const updateItem = (item: Item): void =&gt; {  const updatedItem = findItemInList(item)
  toggleItemChecked(updatedItem)
}
const findItemInList = (item: Item): Item | undefined =&gt; {
  return listItems.value.find(
    (itemInList: Item) =&gt; itemInList.title === item.title
  )
}
const toggleItemChecked = (item: Item): void =&gt; {
  item.checked = !item.checked
}</span></pre>
<p><span class="koboSpan" id="kobo.389.1">Adopting Robert C Martin’s Clean Code philosophy, I split the instruction into separate functions with their own clear intent. </span><span class="koboSpan" id="kobo.389.2">When calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">updateItem</span></strong><span class="koboSpan" id="kobo.391.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">item</span></strong><span class="koboSpan" id="kobo.393.1"> as an argument, it will try to find it in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">itemList</span></strong><span class="koboSpan" id="kobo.395.1"> and toggle the </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">checked</span></strong><span class="koboSpan" id="kobo.397.1"> property on </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">the object.</span></span></p>
<p><span class="koboSpan" id="kobo.399.1">We can see that TypeScript is</span><a id="_idIndexMarker048"/><span class="koboSpan" id="kobo.400.1"> guiding us to a slightly better solution: because </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">findItemInList</span></strong><span class="koboSpan" id="kobo.402.1"> could return an </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">undefined</span></strong><span class="koboSpan" id="kobo.404.1"> value and </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">toggleItemChecked</span></strong><span class="koboSpan" id="kobo.406.1"> expects a parameter, the argument of calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">toggleItemChecked</span></strong><span class="koboSpan" id="kobo.408.1"> function gets a </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">squiggly line.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer022">
<span class="koboSpan" id="kobo.410.1"><img alt="Figure 2.3 – TypeScript hinting at a possible problem in our code" src="image/B19563_02_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.411.1">Figure 2.3 – TypeScript hinting at a possible problem in our code</span></p>
<p><span class="koboSpan" id="kobo.412.1">We can fix this by adding a statement surrounding the call of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">toggleItemChecked</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.414.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.415.1">
const updateItem = (item: Item): void =&gt; {  const updatedItem = findItemInList(item)
  </span><strong class="bold"><span class="koboSpan" id="kobo.416.1">if (updatedItem) {</span></strong><span class="koboSpan" id="kobo.417.1">
    toggleItemChecked(updatedItem)
  </span><strong class="bold"><span class="koboSpan" id="kobo.418.1">}</span></strong><span class="koboSpan" id="kobo.419.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.420.1">With the </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">script</span></strong><span class="koboSpan" id="kobo.422.1"> block changes complete, we can attach the interactivity to the user interface in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">template</span></strong><span class="koboSpan" id="kobo.424.1"> block. </span><span class="koboSpan" id="kobo.424.2">We want the visitor to be able to click on a </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">ListItem</span></strong><span class="koboSpan" id="kobo.426.1"> to mark it as complete. </span><span class="koboSpan" id="kobo.426.2">Vue.js has a built-in directive for this: </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">v-on</span></strong><span class="koboSpan" id="kobo.428.1">. </span><span class="koboSpan" id="kobo.428.2">This acts as an event handler and supports a couple of modifiers as well. </span><span class="koboSpan" id="kobo.428.3">For more information, </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">see </span></span><a href="https://vuejs.org/api/built-in-directives.html#v-on"><span class="No-Break"><span class="koboSpan" id="kobo.430.1">https://vuejs.org/api/built-in-directives.html#v-on</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.431.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.432.1">We can add it to the template </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.434.1">
&lt;ListItem :is-checked='item.checked' v-on:click.prevent="updateItem(item)"&gt;{{ item.title }}&lt;/ListItem&gt;</span></pre> <p><span class="koboSpan" id="kobo.435.1">We’ve also added a </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">.prevent</span></strong><span class="koboSpan" id="kobo.437.1"> modifier</span><a id="_idIndexMarker049"/><span class="koboSpan" id="kobo.438.1"> to prevent the default behavior of the checkbox mechanics. </span><span class="koboSpan" id="kobo.438.2">This is all the code that’s needed to call </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">the method!</span></span></p>
<p><span class="koboSpan" id="kobo.440.1">There’s even a shorthand for </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">v-on:click</span></strong><span class="koboSpan" id="kobo.442.1">, by using </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">@click</span></strong><span class="koboSpan" id="kobo.444.1">. </span><span class="koboSpan" id="kobo.444.2">You will see examples of both directives in resources, so it’s good to understand they are </span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">the same.</span></span></p>
<p><span class="koboSpan" id="kobo.446.1">Under the hood, Vue.js uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">ref</span></strong><span class="koboSpan" id="kobo.448.1"> function to register a series of watchers on the values. </span><span class="koboSpan" id="kobo.448.2">The template engine is used to generate a virtual DOM (a node tree representation of the elements that make up the component). </span><span class="koboSpan" id="kobo.448.3">Once a reactive value is changed, the virtual DOM node where that value is used is </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">also changed.</span></span></p>
<p><span class="koboSpan" id="kobo.450.1">Vue.js compares the changes to the DOM and updates only the necessary elements in the real DOM to reflect the state. </span><span class="koboSpan" id="kobo.450.2">Being able to granularly update the DOM very accurately is what makes Vue.js 3 a highly performant framework, since it doesn’t have to traverse whole branches of virtual </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">DOM nodes!</span></span></p>
<p><span class="koboSpan" id="kobo.452.1">Let’s use the list that we have as input for our next step, where we’ll</span><a id="_idTextAnchor044"/><span class="koboSpan" id="kobo.453.1"> look </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">at sorting.</span></span></p>
<h2 id="_idParaDest-38"><a id="_idTextAnchor045"/><span class="koboSpan" id="kobo.455.1">Sorting the list</span></h2>
<p><span class="koboSpan" id="kobo.456.1">We’re now perfectly capable of showing variables in the template. </span><span class="koboSpan" id="kobo.456.2">There are cases, however, when you have a</span><a id="_idIndexMarker050"/><span class="koboSpan" id="kobo.457.1"> need for more advanced expressions, such as, in our example, the requirement of sorting the list. </span><span class="koboSpan" id="kobo.457.2">For variables that have no side effects and include reactive data, you can use the Vue.js </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">computed</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.459.1"> function.</span></span></p>
<p><span class="koboSpan" id="kobo.460.1">Typically, you would use </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">computed</span></strong><span class="koboSpan" id="kobo.462.1"> for filtering data, format expressions, displaying calculations, or Boolean conditionals. </span><span class="koboSpan" id="kobo.462.2">Let’s apply it to sort the list with completed items at </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">the bottom.</span></span></p>
<p><span class="koboSpan" id="kobo.464.1">First, we’ll import </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">computed</span></strong><span class="koboSpan" id="kobo.466.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">TodoList</span></strong><span class="koboSpan" id="kobo.468.1"> component. </span><span class="koboSpan" id="kobo.468.2">We can add it to the import where we also import the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">ref</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.470.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.471.1">
import { ref, </span><strong class="bold"><span class="koboSpan" id="kobo.472.1">computed</span></strong><span class="koboSpan" id="kobo.473.1"> } from 'vue'</span></pre> <p><span class="koboSpan" id="kobo.474.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">computed</span></strong><span class="koboSpan" id="kobo.476.1"> function is very similar to </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">ref</span></strong><span class="koboSpan" id="kobo.478.1">, in the sense that it follows the same reactivity in updating the DOM when the value changes and you can even access the value using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">.value</span></strong><span class="koboSpan" id="kobo.480.1"> property in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">script</span></strong><span class="koboSpan" id="kobo.482.1"> block! </span><span class="koboSpan" id="kobo.482.2">The main difference is that a </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">computed</span></strong><span class="koboSpan" id="kobo.484.1"> value is cached and only updates when one of the </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">inputs changes.</span></span></p>
<p><span class="koboSpan" id="kobo.486.1">For sorting the list, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">listItems</span></strong><span class="koboSpan" id="kobo.488.1"> as input and apply a simple JavaScript sorting function on the</span><a id="_idIndexMarker051"/><span class="koboSpan" id="kobo.489.1"> array. </span><span class="koboSpan" id="kobo.489.2">We can just add this line to define the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">computed</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.491.1"> value:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.492.1">
const sortedList = computed(() =&gt;    [...listItems.value].sort((a, b) =&gt; (a.checked ? </span><span class="koboSpan" id="kobo.492.2">1 : 0) - (b.checked ? </span><span class="koboSpan" id="kobo.492.3">1 : 0))
)</span></pre>
<p><span class="koboSpan" id="kobo.493.1">As you can see, </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">computed</span></strong><span class="koboSpan" id="kobo.495.1"> is a function that gets called on a change of the reactive value. </span><span class="koboSpan" id="kobo.495.2">In this case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">listItems.value</span></strong><span class="koboSpan" id="kobo.497.1">. </span><span class="koboSpan" id="kobo.497.2">We’ll simply apply a </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">sort</span></strong><span class="koboSpan" id="kobo.499.1"> function to </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">the collection.</span></span></p>
<p><span class="koboSpan" id="kobo.501.1">In the template, we can now swap out </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">listItems</span></strong><span class="koboSpan" id="kobo.503.1"> for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">sortedList</span></strong><span class="koboSpan" id="kobo.505.1"> variable and you will see that checked items will be placed below t</span><a id="_idTextAnchor046"/><span class="koboSpan" id="kobo.506.1">he </span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">unchecked items.</span></span></p>
<h2 id="_idParaDest-39"><a id="_idTextAnchor047"/><span class="koboSpan" id="kobo.508.1">Preserving changes to the list</span></h2>
<p><span class="koboSpan" id="kobo.509.1">We have a final requirement to</span><a id="_idIndexMarker052"/><span class="koboSpan" id="kobo.510.1"> achieve now, and that is to preserve the state of the list on reloading and revisiting the app. </span><span class="koboSpan" id="kobo.510.2">We’ll keep it as simple as we can for now and use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">localStorage</span></strong><span class="koboSpan" id="kobo.512.1"> API of the web browser to store and retrieve the state of </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">the list.</span></span></p>
<p><span class="koboSpan" id="kobo.514.1">We’ll first add the functions that we can use to write to </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">localStorage</span></strong><span class="koboSpan" id="kobo.516.1"> and retrieve </span><span class="No-Break"><span class="koboSpan" id="kobo.517.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">localStorage</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.520.1">
const setToStorage = (items: Item[]): void =&gt; {  localStorage.setItem('list-items', JSON.stringify(items))
}
const getFromStorage = (): Item[] | [] =&gt; {
  const stored = localStorage.getItem('list-items')
  if (stored) {
    return JSON.parse(stored)
  }
  return []
}</span></pre>
<p><span class="koboSpan" id="kobo.521.1">These two functions interface with </span><a id="_idIndexMarker053"/><span class="koboSpan" id="kobo.522.1">browsers’ abilities to store a string of data, so we need to stringify and parse that object. </span><span class="koboSpan" id="kobo.522.2">We’re storing the data on the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">list-items</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.524.1"> key.</span></span></p>
<p><span class="koboSpan" id="kobo.525.1">Now we need to make sure we try and retrieve the data when the component gets loaded. </span><span class="koboSpan" id="kobo.525.2">There’s a function for it, called </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">onMounted</span></strong><span class="koboSpan" id="kobo.527.1"> and it is part of the Vue.js core, so we can import it in a similar fashion to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">ref</span></strong><span class="koboSpan" id="kobo.529.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">computed</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.531.1"> functions.</span></span></p>
<p><span class="koboSpan" id="kobo.532.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">onMounted</span></strong><span class="koboSpan" id="kobo.534.1"> function is what we call a life cycle hook. </span><span class="koboSpan" id="kobo.534.2">They are functions that get called at certain points in the </span><em class="italic"><span class="koboSpan" id="kobo.535.1">life cycle</span></em><span class="koboSpan" id="kobo.536.1"> of a component. </span><span class="koboSpan" id="kobo.536.2">The main life cycle events are triggered when a component gets mounted (or before), gets updated (or before), gets unmounted (or before), and gives an error. </span><span class="koboSpan" id="kobo.536.3">More information can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">here: </span></span><a href="https://vuejs.org/api/composition-api-lifecycle.html#composition-api-lifecycle-hooks"><span class="No-Break"><span class="koboSpan" id="kobo.538.1">https://vuejs.org/api/composition-api-lifecycle.html#composition-api-lifecycle-hooks</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.539.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.540.1">In our case, we want the list to be retrieved in the browser when the component gets rendered (it would otherwise have no access to </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">localStorage</span></strong><span class="koboSpan" id="kobo.542.1">). </span><span class="koboSpan" id="kobo.542.2">So, we’ll import </span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">the function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.544.1">
import { ref, </span><strong class="bold"><span class="koboSpan" id="kobo.545.1">onMounted</span></strong><span class="koboSpan" id="kobo.546.1">, computed } from 'vue'</span></pre> <p><span class="koboSpan" id="kobo.547.1">And we need to create a reactive variable to hold </span><span class="No-Break"><span class="koboSpan" id="kobo.548.1">the items:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.549.1">
const storageItems: Ref&lt;Item[]&gt; = ref([])</span></pre> <p><span class="koboSpan" id="kobo.550.1">We’ll also create a function (</span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">initListItems</span></strong><span class="koboSpan" id="kobo.552.1">) that will run once when mounted, and move the initialization of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">listItems</span></strong><span class="koboSpan" id="kobo.554.1"> there. </span><span class="koboSpan" id="kobo.554.2">We’ll also make a change to the declaration of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">listItems</span></strong><span class="koboSpan" id="kobo.556.1"> by wrapping it with a check on the existence of </span><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">storageItems</span></strong><span class="koboSpan" id="kobo.558.1">. </span><span class="koboSpan" id="kobo.558.2">If they do not exist, we will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">listItems</span></strong><span class="koboSpan" id="kobo.560.1"> as default and write the contents </span><span class="No-Break"><span class="koboSpan" id="kobo.561.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">localStorage</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.563.1">:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.564.1">const initListItems = (): void =&gt; {</span></strong><strong class="bold"><span class="koboSpan" id="kobo.565.1">  if (storageItems.value?.length === 0) {</span></strong><span class="koboSpan" id="kobo.566.1">
    const listItems = [
      { title: 'Make a todo list app', checked: true },
      { title: 'Predict the weather', checked: false },
      { title: 'Read some comics', checked: false },
      { title: 'Let\'s get cooking', checked: false },
      { title: 'Pump some iron', checked: false },
      { title: 'Track my expenses', checked: false },
      { title: 'Organise a game night', checked: false },
      { title: 'Learn a new language', checked: false },
      { title: 'Publish my work' }
    ]
 </span><strong class="bold"><span class="koboSpan" id="kobo.567.1">   setToStorage(listItems)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.568.1">    storageItems.value = listItems</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.569.1">  }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.570.1">}</span></strong></pre>
<p><span class="koboSpan" id="kobo.571.1">Now, we add the following</span><a id="_idIndexMarker054"/><span class="koboSpan" id="kobo.572.1"> functions to retrieve any locally stored </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">list items:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.574.1">
onMounted(() =&gt; {  initListItems()
  storageItems.value = getFromStorage()
})</span></pre>
<p><span class="koboSpan" id="kobo.575.1">In order to keep the changes in sync, we can now modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.576.1">findItemInList</span></strong><span class="koboSpan" id="kobo.577.1"> function to look in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">storageItems</span></strong><span class="koboSpan" id="kobo.579.1"> collection rather than </span><strong class="source-inline"><span class="koboSpan" id="kobo.580.1">listItems</span></strong><span class="koboSpan" id="kobo.581.1"> and also write the change to the storage after the item </span><a id="_idIndexMarker055"/><span class="koboSpan" id="kobo.582.1">has been updated. </span><span class="koboSpan" id="kobo.582.2">We’ll modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">updateItem</span></strong><span class="koboSpan" id="kobo.584.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">findItemInList</span></strong><span class="koboSpan" id="kobo.586.1"> functions </span><span class="No-Break"><span class="koboSpan" id="kobo.587.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.588.1">
const updateItem = (item: Item): void =&gt; {  const updatedItem = findItemInList(item)
  if (updatedItem) {
    toggleItemChecked(updatedItem)
    </span><strong class="bold"><span class="koboSpan" id="kobo.589.1">setToStorage(storageItems.value)</span></strong><span class="koboSpan" id="kobo.590.1">
  }
}
const findItemInList = (item: Item): Item | undefined =&gt; {
  return </span><strong class="bold"><span class="koboSpan" id="kobo.591.1">storageItems</span></strong><span class="koboSpan" id="kobo.592.1">.value.find(
    (itemInList: Item) =&gt; itemInList.title === item.title
  )
}</span></pre>
<p><span class="koboSpan" id="kobo.593.1">Now, in the template, we’re using a computed value, so we should update the computed function too in order to see </span><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">localStorage</span></strong><span class="koboSpan" id="kobo.595.1"> as the input for </span><span class="No-Break"><span class="koboSpan" id="kobo.596.1">our data:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.597.1">
const sortedList = computed(() =&gt;  [...</span><strong class="bold"><span class="koboSpan" id="kobo.598.1">storageItems</span></strong><span class="koboSpan" id="kobo.599.1">.value].sort((a, b) =&gt; (a.checked ? </span><span class="koboSpan" id="kobo.599.2">1 : 0) - (b.checked ? </span><span class="koboSpan" id="kobo.599.3">1 : 0))
)</span></pre>
<p><span class="koboSpan" id="kobo.600.1">We’ve seen how we can use different components with specific uses to build a simple reactive app and how we can organize our code with readability and maintainability in mind. </span><span class="koboSpan" id="kobo.600.2">Vue.js encourages </span><a id="_idIndexMarker056"/><span class="koboSpan" id="kobo.601.1">using Single File Components</span><a id="_idTextAnchor048"/><span class="koboSpan" id="kobo.602.1"> to structure </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">your code.</span></span></p>
<h1 id="_idParaDest-40"><a id="_idTextAnchor049"/><span class="koboSpan" id="kobo.604.1">Single File Components</span></h1>
<p><span class="koboSpan" id="kobo.605.1">The way that we have organized</span><a id="_idIndexMarker057"/><span class="koboSpan" id="kobo.606.1"> the app, with individual components having a single feature to fulfill is referred to as the </span><strong class="bold"><span class="koboSpan" id="kobo.607.1">Single File Components</span></strong><span class="koboSpan" id="kobo.608.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.609.1">SFC</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.610.1">) philosophy.</span></span></p>
<p><span class="koboSpan" id="kobo.611.1">This approach is designed to enhance code readability, maintenance, and reusability. </span><span class="koboSpan" id="kobo.611.2">With SFC, you can create reusable and modular components that can be easily shared and reused across </span><span class="No-Break"><span class="koboSpan" id="kobo.612.1">different projects.</span></span></p>
<p><span class="koboSpan" id="kobo.613.1">To be fair, we did cut some corners with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">TodoList.vue</span></strong><span class="koboSpan" id="kobo.615.1"> component, since we could have abstracted the getting and setting of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">listItems</span></strong><span class="koboSpan" id="kobo.617.1"> to a different component. </span><span class="koboSpan" id="kobo.617.2">For the sake of this example, however, it illustrates the capabilities in an acceptable way. </span><span class="koboSpan" id="kobo.617.3">There are no strict rules or guidelines for how you structure </span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">your components.</span></span></p>
<p><span class="koboSpan" id="kobo.619.1">Note that you can structure or restructure the contents of the script block in a way that makes sense to you. </span><span class="koboSpan" id="kobo.619.2">You have the freedom to group related sets together, which makes for very readable code</span><a id="_idTextAnchor050"/><span class="koboSpan" id="kobo.620.1"> that’s easy </span><span class="No-Break"><span class="koboSpan" id="kobo.621.1">to refactor.</span></span></p>
<h1 id="_idParaDest-41"><a id="_idTextAnchor051"/><span class="koboSpan" id="kobo.622.1">The Vue.js DevTools</span></h1>
<p><span class="koboSpan" id="kobo.623.1">If you’ve not yet installed the Vue.js</span><a id="_idIndexMarker058"/><span class="koboSpan" id="kobo.624.1"> DevTools, please refer back to the </span><em class="italic"><span class="koboSpan" id="kobo.625.1">Vue.js DevTools</span></em><span class="koboSpan" id="kobo.626.1"> section in </span><a href="B19563_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.627.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.628.1">, </span><em class="italic"><span class="koboSpan" id="kobo.629.1">Introduction to Vue.js</span></em><span class="koboSpan" id="kobo.630.1">, to follow the instructions. </span><span class="koboSpan" id="kobo.630.2">We will take a close look at the DevTools using our Todo list application </span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">for reference.</span></span></p>
<p><span class="koboSpan" id="kobo.632.1">If you have the browser plugin installed and you visit a website where Vue.js is detected, the icon in the toolbar will indicate that Vue.js is detected on that </span><span class="No-Break"><span class="koboSpan" id="kobo.633.1">particular URL:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer023">
<span class="koboSpan" id="kobo.634.1"><img alt="Figure 2.4 – Screenshot of Vue DevTools in the browser’s toolbar" src="image/B19563_02_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.635.1">Figure 2.4 – Screenshot of Vue DevTools in the browser’s toolbar</span></p>
<p><span class="koboSpan" id="kobo.636.1">If you click it, it will refer you to opening the browser’s DevTools, where a tab dedicated to Vue </span><span class="No-Break"><span class="koboSpan" id="kobo.637.1">is added.</span></span></p>
<p><span class="koboSpan" id="kobo.638.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.639.1">Vue.js</span></strong><span class="koboSpan" id="kobo.640.1"> tab offers a lot of ways of drilling down into a certain aspect of the rendered code and some time travel inspection methods. </span><span class="koboSpan" id="kobo.640.2">It offers an accessible representation of the inputs and outputs of a </span><a id="_idIndexMarker059"/><span class="koboSpan" id="kobo.641.1">component, which can help you visualize how a component </span><span class="No-Break"><span class="koboSpan" id="kobo.642.1">is rendered.</span></span></p>
<p><span class="koboSpan" id="kobo.643.1">So, let’s zoom in on a particular element, </span><a id="_idTextAnchor052"/><span class="koboSpan" id="kobo.644.1">by using the </span><span class="No-Break"><span class="koboSpan" id="kobo.645.1">inspect mode.</span></span></p>
<h2 id="_idParaDest-42"><a id="_idTextAnchor053"/><span class="koboSpan" id="kobo.646.1">Inspecting a component</span></h2>
<p><span class="koboSpan" id="kobo.647.1">Let’s see if we can inspect a </span><strong class="source-inline"><span class="koboSpan" id="kobo.648.1">ListItem</span></strong><span class="koboSpan" id="kobo.649.1"> component. </span><span class="koboSpan" id="kobo.649.2">We have several ways of doing this: we can drill down into the</span><a id="_idIndexMarker060"/><span class="koboSpan" id="kobo.650.1"> DOM tree in the Vue.js panel, we can filter for the component name, and we can use the crosshair button to point out the component on </span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">the page.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer024">
<span class="koboSpan" id="kobo.652.1"><img alt="Figure 2.5 – Drilling down into the DOM tree in the Vue.js panel" src="image/B19563_02_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.653.1">Figure 2.5 – Drilling down into the DOM tree in the Vue.js panel</span></p>
<p><span class="koboSpan" id="kobo.654.1">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.655.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.656.1">.6</span></em><span class="koboSpan" id="kobo.657.1">, we’ll use the filtering option to type the name of the component we want filtered. </span><span class="koboSpan" id="kobo.657.2">This works well when you’re not exactly sure what the structure of the application </span><span class="No-Break"><span class="koboSpan" id="kobo.658.1">looks like.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer025">
<span class="koboSpan" id="kobo.659.1"><img alt="Figure 2.6 – Filtering for the component name" src="image/B19563_02_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.660.1">Figure 2.6 – Filtering for the component name</span></p>
<p><span class="koboSpan" id="kobo.661.1">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.662.1">Figure 2</span></em></span><em class="italic"><span class="koboSpan" id="kobo.663.1">.7</span></em><span class="koboSpan" id="kobo.664.1">, we use the crosshair icon to select the element from the browser’s viewport. </span><span class="koboSpan" id="kobo.664.2">This works very </span><a id="_idIndexMarker061"/><span class="koboSpan" id="kobo.665.1">well when you have a strong visual reference to </span><span class="No-Break"><span class="koboSpan" id="kobo.666.1">a component!</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer026">
<span class="koboSpan" id="kobo.667.1"><img alt="Figure 2.7 – Using the crosshair to point out a component on the page" src="image/B19563_02_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.668.1">Figure 2.7 – Using the crosshair to point out a component on the page</span></p>
<p><span class="koboSpan" id="kobo.669.1">Depending on your use case, you may prefer one method over the other. </span><span class="koboSpan" id="kobo.669.2">For this example, feel free to try all of them out to see </span><span class="No-Break"><span class="koboSpan" id="kobo.670.1">their effect.</span></span></p>
<p><span class="koboSpan" id="kobo.671.1">When you click in the component, you will see additional details, such as the props, extract of the setup function, event listeners, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.672.1">onClick</span></strong><span class="koboSpan" id="kobo.673.1"> event we registered with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">v-on</span></strong><span class="koboSpan" id="kobo.675.1"> (or </span><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">@</span></strong><span class="koboSpan" id="kobo.677.1">) </span><span class="No-Break"><span class="koboSpan" id="kobo.678.1">directive.</span></span></p>
<p><span class="koboSpan" id="kobo.679.1">Apart from inspecting the props that the component was given, we can use the control buttons to scroll to and highlight the component on the page, inspect the render function for that component, highlight the generated DOM code, and even open the source file in the </span><span class="No-Break"><span class="koboSpan" id="kobo.680.1">code editor!</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer027">
<span class="koboSpan" id="kobo.681.1"><img alt="Figure 2.8 – The various controls of Vue DevTools in the browser extension" src="image/B19563_02_08.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.682.1">Figure 2.8 – The various controls of Vue DevTools in the browser extension</span></p>
<p><span class="koboSpan" id="kobo.683.1">Those several ways of inspecting components are useful tools when debugging the state of a component. </span><span class="koboSpan" id="kobo.683.2">What makes them especially powerful is that you’re looking at the component from within</span><a id="_idIndexMarker062"/><span class="koboSpan" id="kobo.684.1"> the browser’s environment, which is also how users of your app experience and intera</span><a id="_idTextAnchor054"/><span class="koboSpan" id="kobo.685.1">ct with </span><span class="No-Break"><span class="koboSpan" id="kobo.686.1">your application!</span></span></p>
<h2 id="_idParaDest-43"><a id="_idTextAnchor055"/><span class="koboSpan" id="kobo.687.1">Manipulating a component</span></h2>
<p><span class="koboSpan" id="kobo.688.1">Apart from inspecting, we can also manipulate the </span><a id="_idIndexMarker063"/><span class="koboSpan" id="kobo.689.1">state of a component. </span><span class="koboSpan" id="kobo.689.2">We can’t modify the properties of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.690.1">ListItem</span></strong><span class="koboSpan" id="kobo.691.1">, since it’s read-only. </span><span class="koboSpan" id="kobo.691.2">Let’s take a look at the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">TodoList</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.693.1"> component.</span></span></p>
<p><span class="koboSpan" id="kobo.694.1">If you inspect it, you’ll see two collections that power the list: the </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">sortedList</span></strong><span class="koboSpan" id="kobo.696.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">storageList</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.698.1"> variables.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer028">
<span class="koboSpan" id="kobo.699.1"><img alt="Figure 2.9 – The collections that power the contents of the list" src="image/B19563_02_09.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.700.1">Figure 2.9 – The collections that power the contents of the list</span></p>
<p><span class="koboSpan" id="kobo.701.1">Again, </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">sortedList</span></strong><span class="koboSpan" id="kobo.703.1"> is a computed property and cannot </span><span class="No-Break"><span class="koboSpan" id="kobo.704.1">be manipulated.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer029">
<span class="koboSpan" id="kobo.705.1"><img alt="Figure 2.10 – The values of the computed sortedList items cannot be modified" src="image/B19563_02_10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.706.1">Figure 2.10 – The values of the computed sortedList items cannot be modified</span></p>
<p><span class="koboSpan" id="kobo.707.1">When we look at </span><strong class="source-inline"><span class="koboSpan" id="kobo.708.1">storageList</span></strong><span class="koboSpan" id="kobo.709.1"> and expand the collection, we see some modifiers. </span><span class="koboSpan" id="kobo.709.2">We can toggle the </span><strong class="source-inline"><span class="koboSpan" id="kobo.710.1">checked</span></strong><span class="koboSpan" id="kobo.711.1"> property </span><a id="_idIndexMarker064"/><span class="koboSpan" id="kobo.712.1">and update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.713.1">title</span></strong><span class="koboSpan" id="kobo.714.1"> property. </span><span class="koboSpan" id="kobo.714.2">Those changes even propagate to the values of the </span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">corresponding </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.716.1">sortedList</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.717.1">!</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer030">
<span class="koboSpan" id="kobo.718.1"><img alt="Figure 2.11 – The values of the storageItems items can be modified and propagate to the corresponding sortedList values" src="image/B19563_02_11.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.719.1">Figure 2.11 – The values of the storageItems items can be modified and propagate to the corresponding sortedList values</span></p>
<p><span class="koboSpan" id="kobo.720.1">With the browser being dependent on the computed value, it means you see the effect in the browser as well. </span><span class="koboSpan" id="kobo.720.2">This is very useful for debugging different variants of the state of the user interface. </span><span class="koboSpan" id="kobo.720.3">You can also see the methods that are used in the component, available </span><span class="No-Break"><span class="koboSpan" id="kobo.721.1">for inspection.</span></span></p>
<p><span class="koboSpan" id="kobo.722.1">In other scenarios, we will touch upon different uses of Vue DevTools so you will slowly get more familiar with using them to more accurately debug or inspect the applications you build. </span><span class="koboSpan" id="kobo.722.2">When debugging any application state that affects the browser, Vue DevTools offers a very good set of features to help you analyze what is happening with the rendering of </span><span class="No-Break"><span class="koboSpan" id="kobo.723.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.724.1">Taking a look at the </span><a id="_idIndexMarker065"/><span class="koboSpan" id="kobo.725.1">application, you’ll notice that the first item on our Todo list is checked, which now accurately represents the progress we’ve made. </span><span class="koboSpan" id="kobo.725.2">Let’s work on checking off th</span><a id="_idTextAnchor056"/><span class="koboSpan" id="kobo.726.1">e next items on </span><span class="No-Break"><span class="koboSpan" id="kobo.727.1">the list!</span></span></p>
<h1 id="_idParaDest-44"><a id="_idTextAnchor057"/><span class="koboSpan" id="kobo.728.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.729.1">At this point, we’ve used the Vue CLI tool to create and customize our app boilerplate settings. </span><span class="koboSpan" id="kobo.729.2">We’ve been using two-way data binding, which translates to the reactivity in our applications. </span><span class="koboSpan" id="kobo.729.3">Using and applying the Single File Components philosophy, we can now apply this to build applications that are maintainable at </span><span class="No-Break"><span class="koboSpan" id="kobo.730.1">any scale.</span></span></p>
<p><span class="koboSpan" id="kobo.731.1">With Vue DevTools, we have learned a means of inspecting components and can apply this to debug </span><span class="No-Break"><span class="koboSpan" id="kobo.732.1">our applications.</span></span></p>
<p><span class="koboSpan" id="kobo.733.1">In the next chapter, we’ll connect our application with external APIs, giving it real-time data to </span><span class="No-Break"><span class="koboSpan" id="kobo.734.1">work with.</span></span></p>
</div>
</body></html>