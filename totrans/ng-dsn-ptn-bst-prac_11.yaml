- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Micro Frontend with Angular Elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As your application grows and becomes more complex, one team alone is not enough
    to maintain the growth rate, and new people are needed to handle other parts of
    the application as they appear. At this point, the architecture of your project
    needs to evolve, and one possibility is to divide your application into several
    projects that are integrated as one. This practice was born in the world of backend
    services and appears in the frontend world under the name of **micro frontends**.
    In this chapter, we will learn how to apply this principle in an Angular project.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Micro frontend – concepts and application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slicing your application in the micro frontend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a micro frontend application with standalone components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing a page to be loaded by the base application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamically loading micro frontends
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to assess when it is necessary
    to use a micro frontend, how to organize your Angular projects, and how to integrate
    it into a cohesive application.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow the instructions in this chapter, you’ll need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code ([https://code.visualstudio.com/Download](https://code.visualstudio.com/Download))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js 18 or higher ([https://nodejs.org/en/download/](https://nodejs.org/en/download/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code files for this chapter are available at [https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch11](https://github.com/PacktPublishing/Angular-Design-Patterns-and-Best-Practices/tree/main/ch11).
  prefs: []
  type: TYPE_NORMAL
- en: Before you start reading this chapter, remember to run the backend of the application
    found in the `gym-diary-backend` folder with the `npm` `start` command.
  prefs: []
  type: TYPE_NORMAL
- en: Micro frontend – concepts and application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In 2014, an article by Martin Fowler and James Lewis ([https://martinfowler.com/articles/microservices.html](https://martinfowler.com/articles/microservices.html))
    shook the world of development with the formalization of the concept of microservices.
    Focused on the development of backend services, the idea of dividing a large system
    (known as a monolith) into small, independent services focused on just one aspect
    of the business was undoubtedly a milestone for system architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Not long after, this concept was applied to the frontend world, with one of
    the main articles written by Cam Jackson ([https://martinfowler.com/articles/micro-frontends.html](https://martinfowler.com/articles/micro-frontends.html)).
    The basic idea of the *micro frontend* is the same as its sibling, *microservices*,
    which consists of dividing a large frontend project (monolith) into small, independent
    projects focused on one aspect of the business. However, the concerns are different,
    of course. In microservices, we worry about databases and communication protocols,
    whereas on the frontend, we need to worry about packet size, accessibility, and
    user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by analyzing whether you need to use this type of architecture for
    your project.
  prefs: []
  type: TYPE_NORMAL
- en: When to use a micro frontend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A big but very true cliché in systems architecture is that there is no silver
    bullet – that is, there is no one-size-fits-all solution for all problems – and
    micro frontends cannot escape this cliché. The main advantage of this architecture,
    before any technical aspect, is its organizational aspect.
  prefs: []
  type: TYPE_NORMAL
- en: When we use the micro frontend, we are separating an independent part focused
    on one aspect of the business that will be handled by a team specializing in that
    aspect. With this, your project can scale across different teams dealing with
    specific subjects that will be integrated into an experience for your user. Each
    team has autonomy in the delivery cycle of this project, with independence from
    build, deployment, and testing. Independence can reach a level where teams can
    work with different versions of Angular and even different frameworks such as
    React and Vue, although this is not highly recommended, as we will discuss in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: When not to use a micro frontend project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another software engineering cliché is that there is no free lunch, and choosing
    to use micro frontends has its costs and challenges.
  prefs: []
  type: TYPE_NORMAL
- en: The first challenge is the performance issue of your frontend. As we saw in
    [*Chapter 1*](B19562_01.xhtml#_idTextAnchor017), *Starting Projects the Right
    Way*, in a **single-page application** (**SPA**), the user’s browser downloads
    the application bundle containing the Angular framework code, in addition to the
    code that your team produced. After this download, the browser interprets the
    bundle and renders the pages for the user. This entire process must be as quick
    and efficient as possible because, while it is occurring, the user cannot interact
    with the screen, causing frustration.
  prefs: []
  type: TYPE_NORMAL
- en: Now imagine this process happening in every part of your system because, to
    guarantee version and even framework independence, each micro frontend carries
    its framework engine in the specific version. There are techniques and tools such
    as webpack’s module federation ([https://webpack.js.org/concepts/module-federation/](https://webpack.js.org/concepts/module-federation/)),
    but you and your team must evaluate this challenge.
  prefs: []
  type: TYPE_NORMAL
- en: Another care we must take is concerning the user experience and the design of
    the components on screen because, for them, the components between interfaces
    must be fundamentally the same to guarantee cohesion in their experience.
  prefs: []
  type: TYPE_NORMAL
- en: This challenge can be overcome by implementing a design system – that is, a
    single design guide for your company’s components, preferably with a library that
    supports it. An example of a design system is Google’s Material Design.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a basic understanding of micro frontends, let’s move on to
    the next section, where we will explore how to split our application into micro
    frontends.
  prefs: []
  type: TYPE_NORMAL
- en: Slicing your application into micro frontends
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To maximize gains from the micro frontend architecture and minimize the risks
    defined in the previous section, we need to create microservices that are as independent
    as possible and that make sense for your team’s organization.
  prefs: []
  type: TYPE_NORMAL
- en: The most common type of project organization is the verticalization of functionalities
    – that is, for one project you might have an entire user journey, such as a product
    purchase screen, another project for product registration, and another for the
    administration module of the application.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Micro frontend division](img/B19562_11_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – Micro frontend division
  prefs: []
  type: TYPE_NORMAL
- en: This diagram exemplifies the concept of division using an Angular application.
    In each project, we have all the components for the user experience.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering, “*Can I achieve this same separation using Angular modules?*”
    and the answer is yes, you can. If a team takes care of all the modules for your
    company’s organization or the teams can organize themselves into just one project,
    you can (and even should) do this.
  prefs: []
  type: TYPE_NORMAL
- en: We need to keep in mind that the reason for dividing your project into micro
    frontends is to meet an organizational requirement of your project, and teams
    want to have deployment and development independence.
  prefs: []
  type: TYPE_NORMAL
- en: With the basic concepts in mind, we will exemplify how to implement them in
    our gym diary project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a micro frontend application with standalone components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To exemplify the use of the micro frontend architecture in our gym diary, we
    will create a form to define new exercises for our users. Let’s create another
    Angular project, simulating a new team that will specifically take care of this
    functionality. In your operating system’s command line, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We learned about the `ng new` command in [*Chapter 1*](B19562_01.xhtml#_idTextAnchor017),
    *Starting Projects the Right Way*, but here we are using some parameters that
    we haven’t seen before. We are using the `skip-git` parameter because, in this
    example, we are creating it in the same Git project (which already has the `gym-diary`
    and `gym-backend` projects). The `routing` parameter is set to `false` because
    our project will be loaded in the diary application route, and the `style` parameter
    is set to `CSS` so the Angular CLI does not need to ask what type of styling our
    project will have.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest difference in this command is `standalone`, which parameterized
    our project to create all components as standalone by default. But you might be
    wondering what a `standalone` component is. Created from version 15 of Angular,
    this feature allows you to create a component without using Angular modules (`NgModule`).
    Although modules are very important, as we saw in [*Chapter 2*](B19562_02.xhtml#_idTextAnchor081),
    *Organizing Your Application*, there are cases in which they are not very useful
    and make the project unnecessarily complicated. A good example of this is in small
    projects with a limited scope, such as this micro frontend, where we will not
    have multiple routes or lazy loading.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start creating the exercise form, let’s add and configure the Tailwind
    CSS framework, as we want to have a style compatible with our main application.
    Inside the created project folder, run the following command from the command
    line of your operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This command will add development dependencies to the project and create configuration
    files in the Tailwind CSS framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `tailwind.config.js` file, make the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this file, we are telling Angular that it will apply the Tailwind CSS framework
    to all HTML files in the `src` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, add the following lines of code to the `app.component.css` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: With these CSS variables, the component will have access to the `tailwindcss`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will then create a service that will be responsible for interacting with
    our backend’s exercise API. On the command line, we will use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Note a detail of our architecture: we already have a service that queries the
    exercise API in our main project, but we cannot reuse it here because they are
    independent projects, and certain code duplication is a cost of this architecture.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the best practices, we will create our API as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are recreating the types that represent the API data. For more details
    about TypeScript interfaces, you can consult [*Chapter 3*](B19562_03.xhtml#_idTextAnchor112),
    *TypeScript Patterns* *for Angular*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the created service, we will add interaction with the backend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the service, we are making HTTP requests to consult exercises and add new
    ones. For more details about Angular services, you can consult [*Chapter 5*](B19562_05.xhtml#_idTextAnchor163),
    *Angular Services and the Singleton Pattern*, and [*Chapter 9*](B19562_09.xhtml#_idTextAnchor242),
    *Exploring Reactivity* *with RxJS*.
  prefs: []
  type: TYPE_NORMAL
- en: However, we are experiencing an error because we are not importing the `HttpClientModule`
    module. But how can we import it if we don’t have a module in a standalone component?
  prefs: []
  type: TYPE_NORMAL
- en: 'In a project without modules, the import happens in the component itself; for
    services, we have the `app.config.ts` file, and we will add the import to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that we are importing the `provideHttpClient` provider and not the module.
    This happens because this provider was created by the Angular team to handle these
    standalone application cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the main components of the application, we will code its behavior as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s first highlight the component configuration in the `@Component` decorator
    metadata. The `standalone` property means that this component can be used directly
    without being declared in any module. In the `imports` property, we declare its
    dependencies, which are `CommonModule`, the basis for any Angular component, and
    `ReactiveFormsModule`, as we will be developing a reactive form (for more details
    about the form, read [*Chapter 6*](B19562_06.xhtml#_idTextAnchor186), *Handling
    User Input: Forms*). In the component, we are injecting `NonNullableFormBuilder`
    and `ExercisesService` and we take the initial list and assign it to the `exerciseList$`
    attribute. We create the form object with the `formBuilder` service, and finally,
    we create the `newExercise` method responsible for the **Submit** button.'
  prefs: []
  type: TYPE_NORMAL
- en: As we will have the list of exercises in the same form, in the `subscribe` method,
    we assign the `exerciseList$` attribute again to refresh the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'To finish the component, let’s create its template as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the first part, we have the list of exercises, and here we are using Angular’s
    `async` pipe to subscribe and search the list (for more details, read [*Chapter
    9*](B19562_09.xhtml#_idTextAnchor242), *Exploring Reactivity* *with RxJS*).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same template file, we will add the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We created a reactive form with just the **Description** field and added simple
    validation.
  prefs: []
  type: TYPE_NORMAL
- en: 'By running our application with the `ng serve` command, we will have the following
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Exercise form](img/B19562_11_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – Exercise form
  prefs: []
  type: TYPE_NORMAL
- en: With our micro frontend project ready, we can prepare it to be consumed by our
    main application.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing a page to be loaded by the base application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our micro frontend project ready, we need to prepare it to be consumed
    by another application. There are several ways to share micro frontends, from
    the simplest (and obsolete), with the use of iframes, to more modern, but complex,
    solutions such as module federation.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will use an approach widely used in the market, which is
    the use of Web Components. Web Components is a specification that aims to standardize
    components created by different frameworks into a model that can be consumed between
    them. In other words, by creating an Angular component following this specification,
    an application created in React or Vue could consume this component. Although
    Web Components was not created with micro frontend projects in mind, we can see
    that its definition fits perfectly for what we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like almost everything in the Angular framework, to create this type of component,
    we don’t need to do it manually, as the Angular team created a tool for this:
    Angular elements. An Angular element component is a common component but *transpiled*
    to the Web Components standard, packaging not only our code but also the Angular
    rendering engine, making it framework agnostic.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add it to our `gym_exercises` project on the command line of our operating
    system with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'With the preceding command, we add the `angular/elements` dependency to our
    project, and to use it, we will make a change to the `angular.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The component generated by Angular elements will encapsulate the Tailwind CSS
    framework, so we need to increase the component size budget a little to avoid
    errors when building the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next change we must make is to the project’s `main.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This file is responsible for configuring the initialization of an Angular project,
    and we normally do not change it as we want standard SPA build and execution behavior.
    However, here, we need to change it to inform Angular that the result of this
    project will be a web component generated by the Angular elements package. Here,
    we are configuring the project so that the application will generate a web component
    whose tag name will be `exercise-form`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to change the `index.html` file to understand this new tag so that
    we can render our micro frontend for testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, we change the default `<app-root>` Angular component with the Web Components
    `<exercise-form> tag`. Our main application will be our micro frontend JavaScript,
    but the change to `index.html` will allow you and your team to maintain the micro
    frontend without needing to load the main project.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have a challenge in that, despite creating a web component, the project
    build is creating it in three files and with hashes, which is correct if our application
    is not a micro frontend, but in our case, we would like to have all the code in
    a single file and without the hash. We can do this manually, but the community
    has a package that automates this treatment: the `ngx-build-plus` package.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add it to the command line with the help of the Angular CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To serve this micro frontend, we will use the `http-server` package, and add
    it with `npm` on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let’s create some `npm` scripts to make running `mfe` easier. In the
    `package.json` file, we will make the following change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the `build` script, we specify our intention to run it, resulting in a single
    generated file (`--single-bundle`). We also instruct it to retain and encapsulate
    the CSS (`--bundle-styles --keep-styles`) while ensuring that the generated file’s
    name does not include any type of hash (`--output-hashing=none`).
  prefs: []
  type: TYPE_NORMAL
- en: The `serve-mfe` script uses the `http-server` service to publish the contents
    of the `dist` folder that will contain the compiled micro frontend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run our project with the following command and check the micro frontend
    we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: By accessing `http://127.0.0.1:8080`, we can see that our micro frontend application
    is being generated successfully.
  prefs: []
  type: TYPE_NORMAL
- en: With our micro frontend ready to be consumed, in the next section, we will consume
    it in the main application.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically loading micro frontends
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s prepare our main application gym diary to consume the micro frontend
    that we prepared previously. To do this, let’s start by creating a new module
    in the application. On the command line, we will use the following Angular CLI
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: With the preceding commands, we create the module with the generated route file
    and a component that will be responsible for loading `mfe`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s adjust the `exercise-routing.module.ts` file to target the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the `routes` array, we define a base route for the exercise registration
    component as it will be loaded via lazy loading.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will refactor the `home-routing.module.ts` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Our `HomePage` module contains the menu, and in this section, we are adding
    the new module to be loaded in the correct area of the interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'To finish adding this new module, let’s change the `home.component.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: With the new menu item added to the `home` template, we now have the task of
    including the micro frontend generated in the other project in our interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, we have a community package called `@angular-extensions` that allows
    us to load our micro frontend simply using a directive, as we will see later.
    But first, let’s install this dependency in our project using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, we can change the `ExerciseModule` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this file, we are first adding the library module called `LazyElementsModule`
    to have access to the directive that we will use in the component. Furthermore,
    we have a new property in the metadata called `schemas`. In it, we are informing
    Angular with the `CUSTOM_ELEMENTS_SCHEMA` token that this module will receive
    elements from outside the project. By default, Angular checks whether the tag
    used in the template exists in the project or in the HTML standard, such as the
    `input` tag.
  prefs: []
  type: TYPE_NORMAL
- en: As we are going to import the `exercise-form` tag defined by our micro frontend
    here, this attribute will prevent Angular from carrying out this check at the
    project compile time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `exercise.component.ts` file, we will add a new attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are defining the address where the micro frontend’s main files will
    be served.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s change the component template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are declaring the new `exercise-form` element, and to load it, we use
    the `axLazyElement` directive assigning the micro frontend address.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run our project, make sure the micro frontend is being served with the `npm
    run serve-mfe` command. With everything configured, we can see the result of our
    work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19562_11_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – Exercise form dynamically loaded into the main application
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the architecture of micro frontends and how to
    apply one to an Angular project.
  prefs: []
  type: TYPE_NORMAL
- en: We learned about the concept of the architecture, its advantages, and its trade-offs.
    We explored how the main reason for opting for this architecture is its flexibility
    in relation to the organizational structure of each team, as several teams can
    work on different parts of the frontend project independently.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned how we can ideally divide our application into micro frontends.
  prefs: []
  type: TYPE_NORMAL
- en: With all these concepts, we applied our project by creating a small application
    using Angular’s standalone components feature and preparing it to be loaded by
    another project using the Angular elements library.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we performed dynamic loading in our main application with the help
    of the `@``angular-extensions/elements` library.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore the best practices for deploying an Angular
    application.
  prefs: []
  type: TYPE_NORMAL
