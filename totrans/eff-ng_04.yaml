- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building Forms Like a Pro
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Forms** are at the core of many frontend applications. They allow you to
    collect user input to save and act upon data provided by your application users.
    Building forms is one of the aspects where Angular excels. Angular provides two
    different approaches for building forms, both with tools to validate individual
    form fields as well as the validity of the entire form.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to create Angular **template-driven** and
    **reactive forms**, synchronize your form fields with your application state,
    validate forms and individual form fields, and learn about advanced concepts such
    as dynamic form creation. By the end of this chapter, you will be able to create
    forms like a pro!
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the different types of forms in Angular
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building template-driven forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building reactive forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating forms dynamically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the different types of forms in Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Angular provides two different types of forms: template-driven forms and reactive
    forms. This section will discuss the differences between template-driven and reactive
    forms and help you assess what approach best fits your situation.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by explaining the key characteristics of both approaches for building
    forms.
  prefs: []
  type: TYPE_NORMAL
- en: Characteristics of template-driven forms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Template-driven forms are a way to build forms where the HTML template plays
    a central role. Template-driven forms implicitly define form controls and validation
    rules in the HTML template using directives. This means the form controls and
    validation rules are created and managed by the directives you place on the HTML
    elements instead of manually creating the form controls and validations inside
    your TypeScript files and directly communicating with the form API yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The template-driven approach relies on two-way data binding using the `ngModel`
    directive to synchronize changes in the data model for both user input and programmatic
    changes. When you add the `ngModel` directive to an HTML element, the directive
    creates and manages a `FormControl` instance for you. These `FormControl` classes
    that are created by the `ngModel` directive are used to track and validate the
    status of individual form fields inside your form.
  prefs: []
  type: TYPE_NORMAL
- en: When using template-driven forms, the form data is mutable, meaning you don’t
    update the form values using the form API, but you directly change values that
    are used within the `FormControl` instances.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: It’s also important to note that the data flow for template-driven forms is
    asynchronous and updates through events and subscriptions. While this asynchronous
    behavior is managed for you, it’s good to know because it can affect tests and
    sometimes lead to unexpected behavior if you aren’t aware that the data flow is
    asynchronous.
  prefs: []
  type: TYPE_NORMAL
- en: Template-driven forms are easy and quick to build and work very well combined
    with Signals (we will learn more about Signals in [*Chapter 7*](B21625_07.xhtml#_idTextAnchor129)),
    which can reduce the number of times change detection is triggered, improving
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: However, the data model and form controls of template-driven forms are complex
    to reuse and test; also, when building large forms, your HTML template becomes
    bloated. When creating forms that need rigorous testing, reusable form models
    and controls, or forms that need a dynamic way of being constructed, reactive
    forms might be the better fit.
  prefs: []
  type: TYPE_NORMAL
- en: Characteristics of reactive forms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reactive forms provide a flexible, model-driven approach to creating forms.
    Reactive forms facilitate more programmatic control compared to template-driven
    forms. When using the reactive approach, you explicitly define the form model
    by creating `FormGroup`, `FormControl`, and `FormArray` instances in your TypeScript
    files. The explicit nature of reactive forms allows for more complex logic, easy
    testing, and better reusability of form controls and models. In reactive forms,
    validation rules are also explicitly defined using `Validator` classes or custom
    validators, allowing for more complex validations.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive forms provide fine-grained control over the form’s state, allowing
    you to set, get, and manipulate values programmatically. Once a form and its form
    controls have been created, you cannot directly modify the values. This makes
    reactive forms immutable. Immutable forms provide a more reliable data model,
    which, in turn, leads to fewer bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Because you directly define the form models in your TypeScript files using the
    form API, the form models that are created for reactive forms can easily be reused
    and tested. Reactive forms are straightforward when it comes to writing tests
    because you can directly use the form API in your tests, just like you do in your
    component classes.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive forms have a synchronous data flow between the view (by *view*, we
    mean the HTML template that’s displayed in the browser) and the data model. As
    a result, Angular knows precisely when to run change detection on reactive forms,
    improving performance.
  prefs: []
  type: TYPE_NORMAL
- en: While the reactive approach requires more initial setup compared to template-driven
    forms, reactive forms are better suited for large, complex forms where additional
    control, testing, and reusability of form controls and models are crucial.
  prefs: []
  type: TYPE_NORMAL
- en: Key differences between template-driven forms and reactive forms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following table outlines the differences between template-driven and reactive
    forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Template-Driven Forms** | **Reactive Forms** |'
  prefs: []
  type: TYPE_TB
- en: '| Form, model, and validation creation | Implicitly using directives in the
    HTML template | Explicitly using classes in TypeScript files |'
  prefs: []
  type: TYPE_TB
- en: '| Setting up and creating the form | Easy and simple to set up | Needs more
    initial setup and can feel more complex |'
  prefs: []
  type: TYPE_TB
- en: '| Data model | Unstructured and mutable | Structured and immutable |'
  prefs: []
  type: TYPE_TB
- en: '| Data flow | Asynchronous | Synchronous |'
  prefs: []
  type: TYPE_TB
- en: '| Compatible with Signals | Good | Not good |'
  prefs: []
  type: TYPE_TB
- en: '| Testability | Difficult to unit test | Easy to test using the form API |'
  prefs: []
  type: TYPE_TB
- en: '| Reusability and dynamic creation of the form | Harder to reuse or build dynamically
    | Easy to reuse and build dynamically |'
  prefs: []
  type: TYPE_TB
- en: 'Table 4.1: Key differences between template-driven forms and reactive forms'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know the key characteristics of Angular template-driven and reactive
    forms, let’s do a deep dive and learn how you can create both types of forms.
  prefs: []
  type: TYPE_NORMAL
- en: Building template-driven forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will build a template-driven form. You will learn how to
    bind data to input fields, group form fields, and perform built-in and custom
    validation rules in template-driven forms. You will also learn how template-driven
    forms work behind the scenes to get a better understanding of template-driven
    forms.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this section, you’ll be able to build robust template-driven forms
    and create a template-driven form to add expenses to our demo application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a forms library with a form component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we start creating the form, we need a new library. We will generate the
    new library using the custom Nx generator we made in [*Chapter 1*](B21625_01.xhtml#_idTextAnchor014).
  prefs: []
  type: TYPE_NORMAL
- en: You can debate about how to separate the forms library. You can either create
    one library that holds all the forms of a specific domain, you can create a forms
    library for each application in a particular domain, or you can create a new library
    for each form.
  prefs: []
  type: TYPE_NORMAL
- en: Using a single library for each form is the best way to use the Nx caching and
    incremental build systems, but it also has some extra overhead in terms of development
    and maintenance. If your organization has a lot of forms that are reused among
    multiple applications, splitting them up into individual libraries might be worth
    the extra setup as it will speed up your builds and pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our example, I will create a forms library dedicated to the *expenses-registration*
    *application* so that the library will contain all the forms for this specific
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the custom Nx generator to create the library. Name it `expenses-registration-forms`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **finance** for the domain and **ui** for the type. Then, click **Generate**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the library has been generated, restart VS Code so that the Nx schematics
    are updated with your new library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will create a component for our template-driven form using the Nx generator.
    Name the component `add-expense`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the newly created library for the project, check the **standalone** checkbox,
    click **Show all options**, and select **OnPush** for the **changeDetection**
    option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Generate** in the top-right corner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the component has been generated, export it into the `index.ts` file of
    the library. I like to end the component selector for forms with `form`, so I
    will rename the component selector `bt-libs-ui-add-expense-form`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we’ve created the library and component, we can start creating the
    template-driven form.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a template-driven form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start by creating a simple HTML form and slowly convert it into an
    Angular template-driven form. Add this to your `add-expense.component.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can replace the **dots** with any additional form fields you want. In this
    example, I will have four fields: **description**, **amount excluding VAT**, **VAT
    percentage**, and **date**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the complete form and styling in this book’s GitHub repository:
    [https://github.com/PacktPublishing/Effective-Angular/tree/feature/chapter-four/building-forms-like-a-pro](https://github.com/PacktPublishing/Effective-Angular/tree/feature/chapter-four/building-forms-like-a-pro).'
  prefs: []
  type: TYPE_NORMAL
- en: Import the `AddExpenseForm` class into `expenses-overview-page.component.ts`
    and add the component selector in the corresponding HTML file to display our HTML
    form. When you click the submit button, you’ll notice that the page is reloaded;
    this is the default native behavior when submitting forms. Yet, when building
    modern applications using frameworks such as Angular, we expect a better user
    experience where we process form submissions without page reloads, just like when
    we route to pages without reloading the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start converting our native HTML form into an Angular template-driven
    form by importing `FormsModule`. This `FormsModule` contains all the directives
    we need to build our template-driven forms. If you’re building with `NgModules`,
    you must import `FormsModule` in the corresponding `NgModule`. We’re using standalone
    components, so we’ll import `FormsModule` into components where we build a form.
    Add `FormsModule` inside the `imports` array of the component decorator of our
    newly created `add-expense` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '<form #addExpenseForm="ngForm">………</form>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: export interface AddExpense {
  prefs: []
  type: TYPE_NORMAL
- en: 'description: string;'
  prefs: []
  type: TYPE_NORMAL
- en: 'amountExclVat: number | null;'
  prefs: []
  type: TYPE_NORMAL
- en: 'vatPercentage: number | null;'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: Date | null;'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '@Input() expenseToAdd: AddExpense = { description: '''', amountExclVat: null,
    vatPercentage: null, date: null }'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: <input ngModel directive, just like we did with two-way data binding for inputs
    and outputs in *Chapter 2*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like using two-way data binding for input values, you can also split this
    `ngModel` into a separate input and output, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Using the input and output separately can be useful when you’re working with
    Signals or when you want to perform additional logic before binding the input
    value to the data model.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you create your input fields, adding the `name` attribute to the field
    is important as this provides a unique key for the `ngForm` instance to track
    the form field. You will get an error in your browser console if you don’t add
    the `name` attribute. Now, go ahead and add the `ngModel` directive and `name`
    attribute for all the fields in your form. After adding all the `ngModel` directives
    and `name` attributes, you can confirm that two-way data binding works by temporarily
    adding the following code to your HTML template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: After adding the preceding code to your HTML template, the `expenseToAdd` object
    is displayed as JSON on your screen. When you start to type in the form inputs,
    you can see the properties of the `expenseToAdd` object being updated. Vice versa,
    when you assign values to the properties of `expenseToAdd` in your component class,
    the form is also updated, and just like that, you’ve created a form with two-way
    data binding.
  prefs: []
  type: TYPE_NORMAL
- en: The `ngModel` and `ngForm` directives have some other interesting configurations
    that are useful. Let’s start by examining `ngModelOptions`.
  prefs: []
  type: TYPE_NORMAL
- en: Additional form field options
  prefs: []
  type: TYPE_NORMAL
- en: You can use `ngModelOptions` to configure form control instances in template-driven
    forms. The `ngModelOptions` directive can be used to define the `name` attribute,
    control the update behavior, or mark an `ngModel` instance as standalone.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add `ngModelOptions` by adding the directive to an input field where
    you declare the `ngModel` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Let’s learn more about the properties you can set on the `ngModelOptions` directive.
  prefs: []
  type: TYPE_NORMAL
- en: Using the name property
  prefs: []
  type: TYPE_NORMAL
- en: When you set the `name` property of `ngModelOptions`, you can remove the `name`
    attribute on the `input` field as using the `name` property with `ngModelOptions`
    is the same as providing the `name` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Using the updateOn property
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have the `updateOn` property, which controls the update behavior of
    the form control and can take three values – `change`, `blur`, or `submit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`change`: This is the default value and doesn’t have to be set explicitly unless
    the update strategy for the entire form is changed to something else. With the
    `change` value, the form control will update on each keystroke.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`blur`: When you set `updateOn` to `blur`, the form control will update when
    you blur (focus out) from the correlating input field. This can be useful when
    you run some logic that can take a lot of time or resources to run. If you run
    heavy logic on each keystroke, your performance will suffer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`submit`: If you set `updateOn` to `submit`, the form control will only be
    updated when the form is submitted. Just like `blur`, the `submit` option can
    help improve the performance of your form.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also change the update behavior for all the form controls in your form
    by using the `ngFormOptions` directive on the HTML form tag. The `ngFormOptions`
    directive only takes the `updateOn` property. When you change the update behavior
    of the entire form, you can still overwrite it for individual form controls using
    the `ngModelOptions` directive.
  prefs: []
  type: TYPE_NORMAL
- en: Using the standalone property
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we have the `standalone` property. When you mark a form control as standalone,
    the form control won’t register itself in the `ngForm` instance. When a form control
    is marked as standalone, you don’t have to provide the `name` attribute because
    the `ngForm` instance doesn’t have to track the value of the input. Determining
    the form’s validity will also not account for the fields marketed as standalone.
    This can be useful when you have form fields that do not represent the form model.
  prefs: []
  type: TYPE_NORMAL
- en: Another scenario for standalone form controls is a single input for which you
    don’t need to create an entire form, but you do want to use the `ngModel` directive.
    Some examples might be a theme toggle, language selection, or search.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping template-driven form fields
  prefs: []
  type: TYPE_NORMAL
- en: Often, you have a group of form fields that belong together. A good example
    is address fields such as street, ZIP code, and house number. You might want to
    check the validity of the fields as a group, add styling or user feedback, or
    perform validation logic on the group instead of the individual fields.
  prefs: []
  type: TYPE_NORMAL
- en: For these use cases, Angular provides the `FormGroup` class. In template-driven
    forms, you can create a `FormGroup` class using the `ngModelGroup` directive.
    When you declare the `ngModel` group, Angular will create a `FormGroup` class
    behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring `ngModelGroup` is simple! Just add the `ngModelGroup` directive to
    an HTML tag, which wraps multiple HTML elements with an `ngModel` directive declared
    on it.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, we can group our amount, excluding VAT, and VAT percentage fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this like so:'
  prefs: []
  type: TYPE_NORMAL
- en: Wrap the HTML for the amount and VAT percentage fields inside a `fieldset` tag
    and declare the `ngModelGroup` directive on this `fieldset` tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Assign `ngModelGroup` with a name for your `FormGroup`, and that’s it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that all the input fields have been declared and bound to your data fields
    using the `ngModel` directive, you need a way to listen for the form submission.
  prefs: []
  type: TYPE_NORMAL
- en: Submitting template-driven forms
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may have noticed, we added the `submit` type to our submit button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This will trigger a submit event. When this submit event happens, Angular will
    trigger its own internal submit event called `ngSubmit`. We can listen for this
    `ngSubmit` event as we would for any other browser event or component output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '@ViewChild(''addExpenseForm'') form!: NgForm;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '@Output() addExpense = new EventEmitter<AddExpense>();'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: onSubmit() {
  prefs: []
  type: TYPE_NORMAL
- en: this.addExpense.emit(structuredClone(this.expenseToAdd));
  prefs: []
  type: TYPE_NORMAL
- en: this.form.reset();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: <input max validator. You can still type a number higher than 100, but the form
    field will be invalid.
  prefs: []
  type: TYPE_NORMAL
- en: 'To apply the `max` validator, add the following to the input tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also conditionally add validators. Upon using the notation with square
    brackets, as we did with the `max` validator, and supplying a property to it as
    a value when the value is set to `null`, the validation rule is disabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If you want, you can add additional validation rules to your form; go through
    the validators in the Angular documentation and add the directives of the validation
    rules you want to use.
  prefs: []
  type: TYPE_NORMAL
- en: I briefly want to mention the pattern validator as this is a special one. The
    pattern validator can be used for many use cases as it takes a regular expression
    and checks if the value in the input field matches the regular expression pattern.
    Other validators are used for a single purpose, such as checking for a maximum
    input value or whether the field has a value.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to add the built-in validation rules, let’s find out how
    we can style the form fields based on the status and validity of the form and
    form controls.
  prefs: []
  type: TYPE_NORMAL
- en: Styling the form and form fields based on control status values
  prefs: []
  type: TYPE_NORMAL
- en: To provide a good user experience for your application users, it’s important
    to provide visual feedback about the status of the form and its fields. The best
    way to do this is by utilizing the control status of your form and its form controls.
  prefs: []
  type: TYPE_NORMAL
- en: The form, as well as its `FormGroup` and `FormControl` instances, are updated
    by Angular with a control status and corresponding CSS classes. The best way to
    provide visual feedback about the status of your form and its fields is by providing
    styles for the control status CSS classes. Because these stylings are shared among
    all your applications, it’s a good practice to create them as a global styling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by creating a new `global-styling` folder under the shared library
    folder. In this `global-styling` folder, create a file named `form-control-status.scss`.
    After you’ve made the folder and file, add the following under `devDependencies`
    in the root `package.json` file of the *Nx monorepo*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Next, you need to run `npm install` so that you can use `@global/styling` to
    import your global styling inside CSS files throughout your *Nx monorepo*.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it’s time to add the styling for the control status CSS classes inside
    our newly created CSS file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular provides us with eight different control status CSS classes by which
    we can style our form and its form groups and controls:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ng-valid`: This is applied when the form control or group is valid based on
    the validation rules. It’s applied to the form when all groups and controls are
    valid.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng-invalid`: This is applied when the form control doesn’t pass all validation
    rules. It’s applied to the form when one or more controls are invalid.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng-pending`: This is applied when an asynchronous validation is being validated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng-pristine`: This is applied to a form control that has not been interacted
    with. It’s applied to the form when there has been no interaction with any of
    the form controls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng-dirty`: This is applied to a form control that has been interacted with.
    It’s applied to the form when there has been interaction with at least one form
    control.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng-untouched`: This is applied to a form control that the user has not focused
    on or interacted with. It’s applied to the form when no field has been focused
    or interacted with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng-touched`: This is applied to a form control that the user has focused on
    or interacted with. It’s applied to the form when at least one field has been
    focused or interacted with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ng-submitted`: This is applied to the form element when the form has been
    submitted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use these CSS classes to style the form however you see fit. We will
    style the form fields based on their validity in our `add-expense` form but only
    do so when the form has been touched.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add the following inside the `form-control-status.scss` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we only need to import this file into the CSS file of our `add-expense`
    form. Open your `add-expense.component.scss` file and add the following `import`
    statement at the top of the file to import the `form-control-status` styling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: After adding the import, the styles will be applied to the form.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to style the form and its form groups and controls using
    the control status classes, let’s learn how to display messages to the user based
    on the status of the form controls.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying messages based on the status of form controls
  prefs: []
  type: TYPE_NORMAL
- en: You can improve the user experience even further by showing messages when a
    form field isn’t valid. You can do this by using the form control instances created
    by `ngModel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding a template variable to the inputs where you declared `ngModel`
    and assign the `ngModel` instance to the template variable so that you can use
    it throughout the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: <span>This field is required</span>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*ngIf="addExpenseForm.touched && description.hasError(''required'')"'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: <span *ngIf="addExpenseForm.touched && hasError with the max parameter to get
    the validity of the max validator. If you want to display the message under other
    conditions, you can change the *ngIf statement however you see fit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another common way to improve the user experience of your form is to prevent
    the user from submitting the form when the form isn’t valid yet. You can do this
    by binding the form validity to the `disabled` attribute of the submit button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: export * from './lib/template-driven-validators/max-word-count.directive';
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '@Input(''btLibsUtilMaxWordCount'') maxWords = 1;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: export class MaxWordCountDirective implements Validator {}
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'validate(control: AbstractControl): ValidationErrors|null{}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: const wordCount = control?.value?.trim().split(' ').length;
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'return wordCount > this.maxWords ?   {btLibsUtilMaxWordCount: { count: wordCount
    }} : null;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'providers: [{'
  prefs: []
  type: TYPE_NORMAL
- en: 'provide: NG_VALIDATORS,'
  prefs: []
  type: TYPE_NORMAL
- en: 'useExisting: MaxWordCountDirective,'
  prefs: []
  type: TYPE_NORMAL
- en: 'multi: true'
  prefs: []
  type: TYPE_NORMAL
- en: '}]'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '<input hasError method on the control, just like we did when we checked for
    the required error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'When you look at the `error` object we return in our directive, you might notice
    that we included a `count` property with the number of words we used in our form
    control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You can retrieve the `count` value by using the `getError` method on the form
    control instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we used the description template variable, which holds the reference
    to the form control instance, and called `getError` to retrieve the error object.
    You can use the `error` object to display extra information to the user in an
    error message; in our example, you can include the current count of words.
  prefs: []
  type: TYPE_NORMAL
- en: With that, you know how to add a custom validator to template-driven forms and
    show error messages when your custom errors occur. Next, we will learn how to
    validate form groups with custom validators.
  prefs: []
  type: TYPE_NORMAL
- en: Validating form groups with custom validators
  prefs: []
  type: TYPE_NORMAL
- en: In our current example, we’re declaring our custom validator directive on HTML
    elements with `ngModel` declared on it. However, in some cases, you might want
    to perform cross-field validations or validate multiple fields at once. A typical
    example is when you have a password and confirm the password input field in your
    form and want to check if both fields hold the same value.
  prefs: []
  type: TYPE_NORMAL
- en: When you want to perform validation logic on a group of fields, you group the
    fields in your form using `ngModelGroup`, as we did with our VAT fields. Next,
    you must declare the custom validator on the HTML tag with `ngModelGroup`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you declare the directive on an element with `ngModelGroup` on it, the
    validator directive will receive `FormGroup` as the `AbstractControl` function
    parameter. Inside the custom validator, you can then access the values of the
    individual form controls of the form group, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `string` value inside the `get` method should be equal to the name you
    declared on the form control in your HTML template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'providers: [{'
  prefs: []
  type: TYPE_NORMAL
- en: 'provide: NG_ASYNC_VALIDATORS,'
  prefs: []
  type: TYPE_NORMAL
- en: 'useExisting: UsernameAvailabilityDirective,'
  prefs: []
  type: TYPE_NORMAL
- en: 'multi: true,'
  prefs: []
  type: TYPE_NORMAL
- en: '}]'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'validate(control: AbstractControl): Promise<ValidationErrors | null> | Observable<ValidationErrors
    | null> {'
  prefs: []
  type: TYPE_NORMAL
- en: const username = control.value;
  prefs: []
  type: TYPE_NORMAL
- en: return checkUsernameInDatabase(username).pipe(
  prefs: []
  type: TYPE_NORMAL
- en: 'map((isAvailable) => (isAvailable ? null : { usernameTaken: true }))'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: <form>
  prefs: []
  type: TYPE_NORMAL
- en: <div class=»form-field">
  prefs: []
  type: TYPE_NORMAL
- en: <label for=»description»>Description:</label>
  prefs: []
  type: TYPE_NORMAL
- en: <input type=»text» id=»description»>
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: …………
  prefs: []
  type: TYPE_NORMAL
- en: <button type=»submit»>Submit</button>
  prefs: []
  type: TYPE_NORMAL
- en: </form>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: addExpenseForm = new FormGroup({
  prefs: []
  type: TYPE_NORMAL
- en: 'description: new FormControl(''''),'
  prefs: []
  type: TYPE_NORMAL
- en: 'amountExclVat: new FormControl(null),'
  prefs: []
  type: TYPE_NORMAL
- en: 'vatPercentage: new FormControl(null),'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: new FormControl(''''),'
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '<form FormControl instances to the form field by using the formControlName
    directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: <div>{{addExpenseForm.value | json}}</div>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: <fieldset> ……… </fieldset>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: addExpenseForm = new FormGroup({
  prefs: []
  type: TYPE_NORMAL
- en: 'description: new FormControl(''Test''),'
  prefs: []
  type: TYPE_NORMAL
- en: 'amount: new FormGroup({'
  prefs: []
  type: TYPE_NORMAL
- en: 'amountExclVat: new FormControl(null),'
  prefs: []
  type: TYPE_NORMAL
- en: 'vatPercentage: new FormControl(null),'
  prefs: []
  type: TYPE_NORMAL
- en: '}),'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: new FormControl(''''),'
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: <fieldset formGroupName="amount"> ……… </fieldset>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"description": "",'
  prefs: []
  type: TYPE_NORMAL
- en: 'amount": {'
  prefs: []
  type: TYPE_NORMAL
- en: '"amountExclVat": null,'
  prefs: []
  type: TYPE_NORMAL
- en: '"vatPercentage": null },'
  prefs: []
  type: TYPE_NORMAL
- en: '"date": ""'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'tags: new FormArray([ new FormControl('''')])'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: <fieldset formArrayName="tags"> </fieldset>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: <div class="form-field" *ngFor="let item of addExpenseForm.controls.tags.controls;
    index as i">
  prefs: []
  type: TYPE_NORMAL
- en: <label for=»tag-{{i}}»>Tag:</label>
  prefs: []
  type: TYPE_NORMAL
- en: <div class=»tag-field»>
  prefs: []
  type: TYPE_NORMAL
- en: <input [formControlName]="i" type="text" id="tag-{{i}}">
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: <div>
  prefs: []
  type: TYPE_NORMAL
- en: <button *ngIf="i > 0" (click)="removeTag(i)">-</button>
  prefs: []
  type: TYPE_NORMAL
- en: <button (click)=»addTag()">+</button>
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: addTag() {
  prefs: []
  type: TYPE_NORMAL
- en: this.addExpenseForm.controls.tags.insert(0, new FormControl(''));
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'removeTag(index: number) {'
  prefs: []
  type: TYPE_NORMAL
- en: this.addExpenseForm.controls.tags.removeAt(index);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'statuses: new FormRecord({})'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: this.form.controls.statuses.addControl('someKey', new FormControl(''));
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'address: new FormGroup<IAddress>({…………})'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'statuses: new FormRecord<FormControl<boolean>>({…………})'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'description: new FormControl('''', ngModelOptions directive inside our template-driven
    form, you also had the option to mark an input field as standalone. As with template-driven
    forms, you can also have a standalone reactive form element, but you don’t have
    to set it with a standalone property; instead, you just declare a FormControl
    instance without FormGroup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'For a standalone reactive form field, you can use the `formControl` directive
    instead of the `formControlName` directive inside your HTML template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'You can access the value of your standalone form field by using the value property
    of `FormControl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of using the value property, you can also access the value more reactively
    and react to each update of `FormControl`. You can handle the changes reactively
    by subscribing to the `valueChanges` observable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Now that you know how to control the update behavior of the form fields and
    how you can reactively create standalone form fields, let’s learn how to programmatically
    set and update form values.
  prefs: []
  type: TYPE_NORMAL
- en: Setting and updating values programmatically
  prefs: []
  type: TYPE_NORMAL
- en: Often, you need a way to set and update values programmatically inside your
    component class. In reactive forms, you can use `setValue` to set values on individual
    form controls and the `patchValue` method when you want to update multiple fields
    of your form simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will create our component `@Input()` directive and use `patchValue`
    to update the default form values with the values we received from the parent
    component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding a new interface inside the `add-expense.interface.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will add the `@Input()` directive with a setter. Inside this setter,
    we will use the `patchValue` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The `patchValue` method will update all values that are supplied inside the
    value object. So, if the value only contains the description key, only the description
    will be updated; when the value object contains the description and amount with
    both properties, all these values will be updated. The only exceptions are the
    `date` and `tags` fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may have noticed, when we defined the date in the interface, we gave
    the `date` property a string array type; this is because to set a default value,
    we need to supply the form control with a string array, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: If you provide a value in a similar format from the parent component, `patchValue`
    will also work for the date; when you provide it with a simple string, the input
    will not be populated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you also update the default value inside `FormControl`; otherwise,
    you will get compiler errors because the types inside your control and patch value
    don’t match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides the `date` field, the `tags` field is also different because we use
    it to add controls to our form dynamically. When we assign `addExpenseForm` with
    the form model, our `FormArray` tags receive a default value of one `FormControl`.
    Because we only added one `FormControl` inside `FormArray`, when we use the `patchValue`
    method on the form, only one tag will be set, even if more tags are supplied.
    To update the value of `FormArray`, we need to add some additional logic inside
    our setter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: First, we used the `clear` method on the `FormArray` tags. The `clear` method
    will clear all existing `FormControl` instances declared inside the `FormArray`.
    After we clear the `FormArray`, we will use a `forEach` loop to add a new `FormControl`
    for each of the tags we received from the parent component.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when we supply an object with values from the parent component, our form
    will be populated with these values.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some scenarios, you only want to set the value of a single control. When
    you only want to set the value of a single control, you must use the `setValue`
    method on the `FormControl` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The `setValue` method doesn’t allow you to assign a number value to the description
    input field, making it a type-safe and programmatic way to set the values of form
    controls. We added the input to receive values from the parent component.
  prefs: []
  type: TYPE_NORMAL
- en: With that, you’ve learned how to set and update values programmatically for
    your reactive forms. Next, we will start learning about validation in reactive
    forms.
  prefs: []
  type: TYPE_NORMAL
- en: Validating reactive forms
  prefs: []
  type: TYPE_NORMAL
- en: As with template-driven forms, you can validate reactive forms using built-in
    or custom validators. We’ll start by looking into the built-in validators and
    then create a custom validator. Reactive forms have the same built-in validators
    as template-driven forms, except we don’t declare them using directives but the
    `Validator` class. Inside your `FormControl` instances, you can add an array with
    the validators you want to apply.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the required validator to our description field, we can use this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'export function maxWordCountValidator(maxWords: number): ValidatorFn {'
  prefs: []
  type: TYPE_NORMAL
- en: 'return (control: AbstractControl): ValidationErrors | null => {'
  prefs: []
  type: TYPE_NORMAL
- en: const wordCount = control?.value?.trim().split(' ').length;
  prefs: []
  type: TYPE_NORMAL
- en: 'return wordCount > maxWords ? { maxWordCount: { count: wordCount } } : null;
    }; }'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'description: new FormControl('''', [Validators.required, null values for different
    validators; you simply call the addValidators or removeValidators method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: With that, you’ve learned how to use the built-in validators, how to create
    validators using the `ValidatorFn` implementation, and how to add and remove validators
    dynamically. In the next section, you’ll learn how to provide visual feedback
    in reactive forms.
  prefs: []
  type: TYPE_NORMAL
- en: Providing visual feedback about the form’s state in reactive forms
  prefs: []
  type: TYPE_NORMAL
- en: Angular applies control status CSS classes to form elements, just like it does
    with template-driven forms. The control status CSS classes are the same ones that
    are used for template-driven and reactive forms, so we don’t have to change anything
    for the styles we’ve already created to be applied. The `FormGroup`, `FormArray`,
    `FormRecord`, and `FormControl` instances will all receive the control value CSS
    classes based on their current status.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only real difference is how we display the error messages. We created a
    template variable in the template-driven form and bound it to the `ngModel` instance
    to access the form controls. When we are using reactive forms, we access the form
    control instances through the form model we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: For the rest, nothing changes, so go ahead and add the error messages you want
    to display to your users. We already discussed providing visual feedback when
    we covered template-driven forms, so when it comes to reactive forms, this is
    all we have to cover.
  prefs: []
  type: TYPE_NORMAL
- en: Submitting and resetting a reactive form works the same as for template-driven
    forms, so you can copy the submission and reset behavior from the *Building template-driven
    forms* section. To finish this chapter, we will learn how to build forms based
    on a configuration object dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Creating forms dynamically
  prefs: []
  type: TYPE_NORMAL
- en: Creating a good form requires quite a bit of code. Regardless of whether you’re
    using the template-driven or reactive approach, you need a lot of HTML; you need
    to define the model, add validators, and additional logic such as the submit behavior.
  prefs: []
  type: TYPE_NORMAL
- en: You could use a base class for some of the shared functionality, but you can
    also build a dynamic form, which will dynamically build the form based on a JSON
    input. In this section, we will build a simple example of a dynamic form. You
    can extend the dynamic form to fit your specific needs. For example, you might
    want to fetch the configuration from an external source or support additional
    validators.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start our dynamic form, create a new form component named `dynamic-form`
    in your `expenses-registration-forms` library. Next, create a `dynamic-control.interfaces.ts`
    file. I will create the new interface inside the component folder, but you can
    locate all interfaces in a designated folder or use any other folder structure
    you like. Our new dynamic control interfaces will define the interface for a form
    control, which will be generated dynamically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we’ve defined the interface, we need to add an input property to the component,
    which will receive an array of `DynamicControl` objects, and a `formModel` property,
    which will hold our form model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'When we receive the form configuration as input, we need to build our form
    model. We can use the `ngOnChanges` life cycle hook to build the form model each
    time we receive a new form configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we check if the `changes` object contains a new `formModelConfig`;
    when `formModelConfig` is included in the changes, we use a `forEach` loop to
    add the form controls of `formModelConfig` to our form model. We also need a submit
    function and an output that will send the form model to the parent component on
    submission:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'For our component class, this is everything we need. We need to translate this
    into the template so that our form will be built based on the configuration. Start
    by adding the form tag, bind it to the form model, and add the `ngSubmit` function
    to the `form` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to create an input for each configuration inside `formModelConfig`.
    We will use a `*ngFor` loop to output elements for each instance inside `formModelConfig`
    and the `*ngSwitch` directive to determine which element to create. We will use
    the properties of `DynamicControl` to bind the elements to the form and provide
    all the correct values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you’ve added this HMTL, each form element will be rendered and bound to
    the form model. The last thing we need to do is add error messages. Here’s an
    example of how you can display error messages inside your dynamic form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an additional `span` for each error message your form supports. To test
    the dynamic form, you can import it inside `expenses-overview-page.component`
    and add the selector inside the HTML template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `formModelConfig` inside the component class so that the dynamic form
    has fields to generate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Go ahead and add the rest of the fields we used inside our reactive and template-driven
    form to `formModelConfig`; you will see that the same form will be generated dynamically,
    including the validation rules and error messages.
  prefs: []
  type: TYPE_NORMAL
- en: This is just a simple example of a dynamic form; you can add additional logic
    if you want, such as to allow form groups, form arrays, and form records. The
    concept stays the same; just adjust the model, add the logic inside the component
    class to generate the form model correctly, and adjust the template so that you
    can render it how you intended.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned about Angular’s different types of forms. You now
    know the difference between template-driven and reactive forms and when to use
    which type. We created a template-driven form that includes validation, error
    messages, default values, and styling based on control statuses. We also created
    a custom validator directive for the template-driven form. Next, we recreated
    the same for using reactive forms.
  prefs: []
  type: TYPE_NORMAL
- en: We also created a custom validator function that can be used inside the reactive
    form. We learned about dynamically adding fields inside form group, form array,
    or form record classes inside the reactive form. Then, we learned how to change
    our fields’ update behavior in both template-driven and reactive forms. Lastly,
    you built a dynamic form that builds the form model based on a configuration and
    will render the form accordingly, including validations and error messages.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to create dynamic components, which
    can be reused in many scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Part 2:Handling Application State and Writing Cleaner, More Scalable Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, you’ll learn how to develop cleaner, more scalable, and performant
    code for your Angular applications. You’ll start by developing dynamic components
    suited for more complex UI scenarios. You’ll learn about lazy-loading individual
    components on demand to reduce your bundle size and enhance performance. Then,
    you’ll explore commonly used conventions and design patterns to develop more robust
    and scalable Angular applications. You’ll finish this part by getting hands-on
    experience implementing the facade pattern, state management using NgRx, and reactive
    programming with RxJs and signals.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part includes the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B21625_05.xhtml#_idTextAnchor083), *Creating Dynamic Angular
    Components*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B21625_06.xhtml#_idTextAnchor115), *Applying Code Conventions
    and Design Patterns in Angular*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B21625_07.xhtml#_idTextAnchor129), *Mastering Reactive Programming
    in Angular*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B21625_08.xhtml#_idTextAnchor150), *Handling Application State
    with Grace*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
