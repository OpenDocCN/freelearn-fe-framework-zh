- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating the Marvel Explorer App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s build an app that’s a bit more advanced, using a third-party API to feed
    it with data. I hope you like comics, because we will build an explorer on the
    Marvel Comics API, and I will try to squeeze in some heroic puns. We’ll explore
    adding different routes and add a bit of abstraction to make better use of writing
    our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving data from the API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routing in a single-page application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing and using composables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching for and handling data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User-friendly error handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll replace **node package manager** (**npm**) with **performant
    npm** (**pnpm**): [https://pnpm.io](https://pnpm.io).'
  prefs: []
  type: TYPE_NORMAL
- en: We need to register at [https://developer.marvel.com/](https://developer.marvel.com/)
    to retrieve an API key. We’ll add **Tailwind CSS** ([https://tailwindcss.com/](https://tailwindcss.com/))
    to apply styling to this app as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we introduce routes using the official router for Vue.js applications:
    [https://router.vuejs.org/](https://router.vuejs.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: The complete code for this chapter is available at [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/tree/main/04.marvel](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/tree/main/04.marvel).
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with our new project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to get started, we need an API key. If you go to [https://developer.marvel.com/](https://developer.marvel.com/)
    and select **Get a Key** from the menu, you will need to register for a free account.
    Afterward, you will be redirected to the developer portal, where you create a
    key to interact with the API. Make sure to note the public and private keys.
  prefs: []
  type: TYPE_NORMAL
- en: For our example, we will access the API from localhost, so you need to add `localhost`
    and `127.0.0.1` to the list of authorized referrers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you want to deploy this app to the web, you will need to make sure to add
    the corresponding URL of the app’s address there as well, but the deployment step
    is not covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: I’d like to point out the documentation, which you’ll find under **Interactive
    Documentation**. I recommend playing around with it for a bit to get a sense of
    our data provider.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start a new project!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Hit `y` to proceed, choose `vue-marvel-explorer` as the project name, and select
    the options shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – The setup configuration for the Marvel Explorer app](img/B19563_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – The setup configuration for the Marvel Explorer app
  prefs: []
  type: TYPE_NORMAL
- en: After following the instructions to install the dependencies we can get to work!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s install our project’s dependencies using pnpm this time. This is an alternative
    package manager for node that has some benefits over npm, such as better storage
    management of packages, which results in increased installation speed and reduced
    network requests. If your internet connection is less than optimal, pnpm has got
    your back! You can read the installation guide here ([https://pnpm.io/installation](https://pnpm.io/installation)).
    The commands are similar to npm, so it should be very easy to get up to speed.
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to your project’s folder and type `pnpm install` (instead of `npm install`).
    The neat thing is that every future installation of the same package will reference
    the already installed local cache, which saves a ton of bandwidth and time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll install tailwind on the project as well, revisiting the steps from the
    Weather app, using pnpm, an alternative to npm, aimed at optimizing `node_modules`
    management:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s update the `tailwind.config.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `style.css` file in the `./``src` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, open the `./src/main.ts` file to import the CSS file into the
    app (note that this file contains the router initialization):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If you run the development server with `pnpm run dev`, you’ll see that the demo
    app added an example route, allowing you to navigate between a Home and About
    view. Close the dev server, and let’s open the project in the code editor.
  prefs: []
  type: TYPE_NORMAL
- en: You can remove the components that the default Vue installation added to clean
    up your project a bit. If you are unsure, you can always refer to the GitHub repository.
    The link can be found at the *Technical* *requirements* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rename the `.env.example` file to .`env` and make sure to insert the secrets
    from the Marvel Developer portal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Variables from a `.env` file that are prefixed with `VITE_APP_` are automatically
    passed to and available in your application on a pre-defined `import.meta.env`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: I want to stress again that sharing secrets is not a best practice in production-like
    environments. You’d normally use something like an authorization broker to make
    sure that the API only receives trusted requests. In a way, we’ve done this by
    defining the request domains in the Marvel API configuration. Typically, `localhost`
    or its equivalent, `127.0.0.1`, is not something you would see in a production
    environment either!
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our environment set up. We’ll now move forward with connecting
    these settings to our application.
  prefs: []
  type: TYPE_NORMAL
- en: The Superhero connection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want to retrieve data from the Marvel Comics API from different components
    in our application. A good pattern for doing this is by creating a Vue composable.
    A Vue composable is a proven pattern for using and reusing logic throughout your
    application. We’ll create a folder called `composables` in the `src` folder and
    create a file called `marvelApi.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: You can import the types from the example repository ([https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/src/types/marvel.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/src/types/marvel.ts)).
  prefs: []
  type: TYPE_NORMAL
- en: These types are mainly contracts with the API. Feel free to take a look at them.
    I created them by ingesting the results from the API and defining the types.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start with an asynchronous function that fetches the data from the API
    from the comics endpoint and returns a promise of the response. We’re going to
    expand the functionality gradually. Add a new composable function called `useComics`
    to the file and don’t forget to import the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can wire the API call to the user interface. We are going to create
    our component to display the data from the endpoint. Create a new Vue component
    in the `src/components` folder called `ComicsOverview.vue`. We’ll start with the
    `script` tag contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `script` block is very similar to the weather app from [*Chapter 4*](B19563_04.xhtml#_idTextAnchor092).
    We’re requesting data when the component gets mounted, and we’ll track the state
    using the `isLoading` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the template of the same file, we’ll add the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You can quickly see the result by temporarily importing the component into `App.vue`
    and loading it in the template. A slight difference here is that we’ve abstracted
    the actual fetch to the composition, which makes the code of the component a bit
    cleaner and makes the fetch more reusable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our data is coming in, we’re going to polish the component a bit.
    Let’s create a `LoadingIndicator.vue` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can import it to the component and then use it to replace the `<div v-if="isLoading"><p>Loading
    comics…</p></div>` element, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We do this to create more consistency when using recurring user interface patterns.
    Again, this is one of the strengths of a component-based architecture.
  prefs: []
  type: TYPE_NORMAL
- en: We can also create the visual representation of a comic. We’re going to apply
    the abstractions right away. In practice, it happens more often that refactors
    occur while progressing on the code base. It’s tricky to predict what code will
    be reused beforehand, so don’t hesitate to refactor early and often, when the
    need arises. In our case, though, we have a different goal to teach, so we won’t
    focus on the refactoring part.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a component called `CardView.vue` that contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this component, we are making use of slots. Slots are placeholders for specific
    dynamic content (components or text) that comes from the parent component. Slots
    are an excellent way to reuse templates and offer a lot of flexibility. Consider
    the `LoadingIndicator` component, which accepts only a text as a property. Restriction
    can be good, but sometimes you might prefer flexibility over constraint. Let’s
    start to apply this generic component.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll create a `ComicCard.vue` component with the following contents: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.1-ComicCard.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.1-ComicCard.vue)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s break that component down, shall we? You should be familiar with most
    of the concepts, but I have managed to introduce a bit more. A particular addition
    is the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Intl` is a standardized namespace that deals with language-sensitive functions.
    In our case, we are setting up a list specific formatter in the English (`en`)
    language and using it in the template to string together the list of creators.
    The list is provided as an array (that is, `[“Evan You”,` `“Sebastien Chopin”,`
    `“Anthony Fu”]`). Using the `Intl` formatter, the result is readable text that
    is specific to that language: *Evan You, Sebastien Chopin, and* *Anthony Fu!*'
  prefs: []
  type: TYPE_NORMAL
- en: We’re using the computed values to create lists of characters for every comic
    (`charactersList`) and the creators of every comic (`creatorsList`).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the template, we see how we are using the slots in the `CardView` component
    and filling it with our own templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We’ve defined the contents of the templates. We’ve designated `comic.title`
    for the header in the component. For the default slot, we’re providing the markup
    for the contents of the card. In both cases, we let the `<CardView>` component
    handle the formatting and style, which also ensures a consistent user interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example code, you will see the shorthand notation for named slots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: For now, we’ll remove the temporary change to `App.vue` because we’re going
    to add this to a specific route view!
  prefs: []
  type: TYPE_NORMAL
- en: With the components we have prepared, we’ll continue by moving those components
    to specific views and routes.
  prefs: []
  type: TYPE_NORMAL
- en: Marvelous routes in a single-page application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let’s take a look at the default setup of the application, because we’ve
    pre-installed the app to use `vue-router`. This configured the app with a couple
    of things:'
  prefs: []
  type: TYPE_NORMAL
- en: We have an `index.ts` file in the `router` folder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `views` folder, we have two components called `HomeView.vue` and `AboutView.vue`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In `App.vue`, we have some components called `RouterLink` and `RouterView`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That’s how routes are tied together. Let’s take a look at each of them.
  prefs: []
  type: TYPE_NORMAL
- en: The contents of the `router` folder define and configure the routes for the
    application. Routes define the different paths in your application and the components
    that should be rendered when those paths are accessed. Each route is represented
    as an object with properties such as `path`, `name`, and `component`.
  prefs: []
  type: TYPE_NORMAL
- en: The `path` property specifies the URL path, and the `component` property specifies
    the Vue component to render. The `name` is not required and more meant as a human-readable
    identifier for a route.
  prefs: []
  type: TYPE_NORMAL
- en: Using the default configuration, it defined the home view for us and set up
    the other view to support code splitting to limit bundle sizes per route. So,
    this is a best practice out of the box!
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll change the references to `about` into `search`, in preparation for our
    final result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll rename `AboutView.vue` to `SearchView.vue`. For the contents of the file,
    you can just strip most of it, we’ll build something new later on. Something like
    this is fine for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: To string it all back together, we can update the `App.vue` file so the `RouterLink`
    component points to `/search` instead of `/about`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be clear: you have to use the path that we’ve configured in the router file.
    The `RouterView` component is used to render the matched component based on the
    current route. It acts as a placeholder where the corresponding component is rendered.
    Whenever the route changes, the `RouterView` component will be automatically updated
    to render the new component. Remember slots? Consider `RouterView` as sort of
    a dynamic slot that can hold an entire view.'
  prefs: []
  type: TYPE_NORMAL
- en: '`RouterLink` in turn is used to create navigation links in your application
    and triggers navigation to the given route when clicked. The `to` attribute of
    `RouterLink` specifies the path or name of the target route.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s clean up the parts of the default configuration we don’t need anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Since our `ComicsOverview.vue` component is ready, we can add it to `HomeView.vue`,
    replacing the `TheWelcome.vue` part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If you now run the app, you can navigate between the home page, which loads
    the comics overview, and the almost empty search page.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll continue to work on getting more information into our application, because
    our application is limited now to just showing the first page of the API results.
  prefs: []
  type: TYPE_NORMAL
- en: Optional parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you analyzed the network request coming from the Marvel API, you may have
    noticed that the comics we are showing are but the tip of the iceberg. There are
    a multitude of comics, and because of that volume, they are not being sent in
    one response. The API offers paged results. We can modify our app to mirror the
    features of the API!
  prefs: []
  type: TYPE_NORMAL
- en: 'If we open the router file, we can add an optional parameter to a route. It
    parses and exposes the value to be used in your application. The notation for
    a parameter (or *param* for short) is to prefix the name with a colon. We’ll add
    a param called `page` to the `home` route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We have introduced a slight bug in our application. The application now *always
    expects a parameter*. For the home page, this is not always the case! The param
    should be optional. To mark a param as optional, we add a question mark as a suffix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Hooray! We’ve successfully added an optional parameter. We can now introduce
    pagination to our comics overview.
  prefs: []
  type: TYPE_NORMAL
- en: Paging Dr Strange
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `vue` router exposes itself as a composable. A composable is a Vue superpower,
    used to encapsulate stateful logic for easy reuse. This means that the router
    composable, in this case, holds the state of the router, which we can use in any
    component!
  prefs: []
  type: TYPE_NORMAL
- en: 'This means we can open our `ComicsOverview.vue` file directly to implement
    pagination. Let’s take a look at the `script` tag of the component and add a few
    lines: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.2-ComicsOverview.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.2-ComicsOverview.vue)'
  prefs: []
  type: TYPE_NORMAL
- en: First, we’re importing the composable (*line 4*) and register it to the route
    constant (*line 12*). Then we’re adding two reactive variables (*lines 16, 17*)
    to track the page information. We access the parameter via the `route.params`
    object. Since we named the variable page we can access the corresponding property
    on the method. We use the `+route.params.page` (*lines 19-21*) as shorthand to
    convert the value to a numeric type, and we store it in the reactive `currentPage`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, in `getComics`, we use the data coming from the endpoint to actualize
    the values (*lines* *27, 28*).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how many pages there are and what page we are on, we can use
    these properties to provide a simple `Pagination` component.
  prefs: []
  type: TYPE_NORMAL
- en: A simple pagination component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So, let’s create a new component called `Pagination.vue` and add the following
    contents: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.3-Pagination.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.3-Pagination.vue)'
  prefs: []
  type: TYPE_NORMAL
- en: 'It should be pretty self-explanatory by now: we’re adding the relevant props
    (for more flexibility, we provide a `path` property as well) and, based on our
    current page, we can render the links to the first, previous, or next and last
    page links and show the pagination status.'
  prefs: []
  type: TYPE_NORMAL
- en: 'I would like to point out the aria-hidden property, which we use to mark decorative
    elements that add no value for screen readers. Now, we’ll add it to the `ComicsOverview.vue`
    component by importing it and pasting the template under the overview of comics
    cards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'That works! We can click to the next page, but nothing happens. That’s because
    our API doesn’t support pagination yet. Let’s look into adding it as a feature,
    so we’ll open the `marvelApi.ts` file. First, we’ll add the option for pagination
    to `useComics`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We’re simply accepting a page number, and we’ll use the predefined `ITEMS_PER_PAGE`
    to determine the offset (which is the way the Marvel API deals with pagination).
    Then, we store the query parameter and add it to the `requestURI`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can flip over to the `ComicsOverview` component again to implement
    the pagination and connect the route parameter to the API request. To accomplish
    this, we add the following to the script block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We can simply add the page now to the `getComics` request and pass it down to
    the `useComics` composable. We do this `onMounted`, for when you enter the application
    from a URL directly. We also add a watch function, that keeps track of the `route.params.page`
    and requests a new page once the value changes. We’re using the quick conversion
    to numeric here as well, as you can see by the plus sign.
  prefs: []
  type: TYPE_NORMAL
- en: With all of this in place, we can now browse through all 2,746 pages! As an
    extra exercise, why not figure out if you can expand the pagination component
    to show multiple pages.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’re ready to move forward, we’ll refactor our app to use composables.
    They are functions that encapsulate (stateful) logic.
  prefs: []
  type: TYPE_NORMAL
- en: Composables, assemble!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s take a look at how we can leverage our composables and refactor the app
    to expand the functionalities a bit. Composables are all about reusability: it’s
    their superpower in the Vue space, so let’s put our previously created composable
    into action.'
  prefs: []
  type: TYPE_NORMAL
- en: First, we will work on refactoring the `useComics` composable, where we will
    lightly apply the clean code principles. In our context, this will translate to
    applying the single responsibility principle and writing small and cohesive functions
    with meaningful names.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring useComics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll refactor in a non-destructive way too, leaving the existing `useComic`
    composable functional until we’re ready to update that too.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll first move the static constants out of the function to the upper scope.
    We’ll also import additional types that we will reference in functions. This way,
    we can still access them, but they are available throughout the file. I make it
    a practice to group these types of values at the top of the file for easy future
    reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If we think about what our new composables should do and have in common, we
    can identify the following activities: determining the pagination, determining
    a search query, constructing the Marvel Developer API URL, and fetching and returning
    data. We’ll create short, separate functions for each activity. These are not
    composables, and we won’t expose them outside of the file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add the `getPagination` function, which accepts page number and translates
    it to a string translating the page to an **offset** (in line with what the Marvel
    API would expect):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To construct an additional string containing a search query, we add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The next addition is a function to construct the request URI, combining the
    static constants with the output of the `getPagination` and `getQuery` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'And we’ll add a function to do a request and return the result. In this case,
    we could potentially reuse this, so we can write it as if it were a composable,
    using the `use` prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can string all of the functions together in a composable that will
    allow us to interact with the Marvel Developer API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we’ve created a function that can either return comics or characters,
    this will depend on the path variable we provide. Since the Marvel Developer API
    has similar mechanics for every endpoint, we were able to make a useful abstraction
    of the options we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code we’ve added to the `MavelAPI.ts` file looks like this: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.4-MarvelAPI.ts](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.4-MarvelAPI.ts)'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve expanded the file with abstractions to retrieve data from the endpoint,
    where we can reuse functions that are generic while being able to request specific
    content.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s investigate incorporating these functionalities into our application.
  prefs: []
  type: TYPE_NORMAL
- en: Reassembling functionalities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we can update our existing `useComics` composable to build on top of this
    foundation. As you can see, we’re now able to reduce the contents of the composable
    to a single line of code, providing only the path and current page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: By running our code, the existing overview of comics with pagination should
    remain fully functional. This is a testament to writing clean code rather than
    the power of composables. It enables us to implement new, useful code with relative
    ease. In our next composable, we’ll request a different type of information, as
    we will describe in the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way we will interact with the search API is to provide the correct path
    to the API and, in our case, we’ll use the `nameStartsWith` way of searching.
    We’ll provide it, together with a dynamic search value, as part of the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This time, as you can see, we’ve changed the expected response type to `Characters`
    instead of `Comics`. Our IDE will be able to make a distinction between the two
    types when we’re interacting with these composables.
  prefs: []
  type: TYPE_NORMAL
- en: We now have our two composables ready for use in the app. The way we refactored
    our file is something of a natural process in coding. Over time, requirements
    will change, so it is only logical that the code changes with it. Having our code
    split into small, focused functions will make it easier to understand and modify
    in the future.
  prefs: []
  type: TYPE_NORMAL
- en: When using composables, we normally follow the same practice of providing simple-to-use
    functions and rather splitting them into separate ones than combining them into
    one.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re interested in applying composables, I recommend checking out [https://vueuse.org/](https://vueuse.org/).
    It hosts a collection of ready-to-use composables for everyday problems in Vue
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we’ve seen how the combination of a clean code mindset, combined
    with specific composables have helped us refactor our application’s code into
    individual parts that are more readable and maintainable. We’ve also experienced
    refactoring code. Sometimes we refactor due to shifting needs, sometimes we just
    want to make existing code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now look at adding more types of data to our application!
  prefs: []
  type: TYPE_NORMAL
- en: Managing the roster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our brand new composable, we have easy access to more data from the Marvel
    Developer API! We’ll move onto creating the Vue components that will allow the
    user interface to deal with searching.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll first create a variant of the `ComicCard.vue` named `CharacterCard.vue`.
    The component will be a bit simpler, so you can either paste the following contents
    in the file or create a copy of the `ComicCard.vue` and update it to match the
    contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: There’s nothing special going on here. We’re expecting a single property character,
    and that should match the type. We can therefore easily map the underlying properties
    to a simple HTML template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll create the main component to host all the user interface elements.
    We’ll create a file called `SearchCharacter.vue`, and we’ll start with just the
    template. This too should look familiar after creating `ComicsOverview.vue`. I’ve
    highlighted the key differences: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.5-SearchCharacter.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.5-SearchCharacter.vue)'
  prefs: []
  type: TYPE_NORMAL
- en: We’re providing a meaningful message when the data is loading (*line 3*), and
    we’re showing results in a different matter, namely a `CharacterCard` (*lines
    8-12*). In `Pagination`, we have provided the current path (*line 16*), and we’ve
    added a more specific message when no data is returned (*lines 25-28*).
  prefs: []
  type: TYPE_NORMAL
- en: Now, we’ll implement a way of inputting a search query to lead into the `SearchCharacter`
    presentation.
  prefs: []
  type: TYPE_NORMAL
- en: Searching for heroes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Searching is an isolated, specific action, so in line with the Single File Components
    philosophy, we are going to create a specific component for this!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a form component by creating a new file called `SearchForm.vue`.
    Start with the `script` tag, and I’ll explain some new things along the way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: There are two interesting things going on. The first highlighted line defines
    an `emit`. Emitting happens if we want to pass something (an event) upwards in
    the scope. Props go down, emits go up. By using the `defineEmits`, we wrap it
    so that Vue can keep track of the event at runtime and we’re assigning it the
    name `searchSubmit`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have a function called `search` that does nothing but emit the event
    by referencing its name and passing `query.value` as a parameter. In our parent
    component, we will be able to catch the event and its value.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s time to add the template. Let’s start as simply as possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here too, two things are important to note. The `v-on:submit.stop` statement
    is a built-in method that prevents the actual form from being submitted as an
    HTML form (which would lead to refreshing the page). Instead, on submit, it calls
    the `search` function.
  prefs: []
  type: TYPE_NORMAL
- en: In order to have any value reference, we can use the `v-model` to bind the value
    of query to the input field. This gives you two-way databinding.
  prefs: []
  type: TYPE_NORMAL
- en: Adding search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although the form works, it doesn’t feel like an app: we still have to manually
    submit the form. Let’s upgrade the `SearchForm` before moving on to showing the
    results. We’ll use a watcher to monitor the value of the query and trigger the
    `search` function when it has changed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll update the code in the `script` tag to match the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: It’s easy to understand the importing of the watch function and defining the
    watcher. And instead of directly calling the search function, the watcher calls
    `debouncedSearch`.
  prefs: []
  type: TYPE_NORMAL
- en: Firing requests to an API is expensive in terms of resources. By debouncing
    the function, we run a timer of, in this case 500 milliseconds (ms). When the
    timer runs out, we then call the `search` function, which in turn emits the `searchSubmit`
    event. If, however, the `debouncedSearch` function is called before the timer
    was cleared, we simply reset the timer and wait another 500 ms.
  prefs: []
  type: TYPE_NORMAL
- en: An overview with superpowers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can finally assemble the `SearchCharacter` component. Let’s start with the
    `script` tag, since we left it out when we first started: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.6-SearchCharacter.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.6-SearchCharacter.vue)'
  prefs: []
  type: TYPE_NORMAL
- en: Apart from importing our utilities and components, the core of the component
    is to trigger the search action on the Marvel Developer API. The `getCharacterSearch`
    (*lines 20-34*) takes care of updating the reactive values to translate to the
    UI and calculate the pagination. Its core is using our composable to retrieve
    the results, which are passed to the reactive data property.
  prefs: []
  type: TYPE_NORMAL
- en: The `searchReset` function (*lines 36-41*) makes sure we can always return to
    the initial state, for instance, when you’d want to clear the UI or when somebody
    searches for an empty value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the template itself, we only need to add the `SearchForm` so that our users
    can find their favorite hero from the Marvel Universe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We have extended the app now with the very useful search function. This means
    we can put our new composable structure to the test. It allows us to focus on
    the implementation of the search form with debouncing, rather than fetching the
    data.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve seen how our abstractions have helped to expand features with minimal
    effort. All we’ve built so far has mostly been about a “happy flow,” where the
    individual parts work as expected. Since we’re depending on a third-party API,
    we have no control over its stability and have to prepare for cases where the
    data is not returned. We’ll focus on error handling in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: A different vision
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, our app is functioning just fine. We can improve our app experience
    by making sure we can handle situations when the API returns an error. Let’s see
    how we can make our app a bit more robust in that sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll add a page that will be able to display errors to the user when they
    occur. Let’s start with a new file in the `views` folder called `ErrorView.vue`.
    Just create a template with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll circle back to this file later. We can now at least create a new route
    in the `router/index.ts` file, which just duplicates similar logic from the `search`
    route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: If we then navigate to the `/error` route in the app, we should see our `errorpage`.
    Since the data is coming from an external API, we can’t control it. This makes
    it an obvious weakness in the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'On top of that, it is common practice to code defensively. If we look at the
    `marvelApi` composable file, we can add some safeguards around the composables
    that we’re using in the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You could also consider adding these `try`/`catch` blocks on `useFetch` and
    `useMarvelAPI`. On error, the error will propagate upwards through the call stack,
    which means it will be caught at the highest level.
  prefs: []
  type: TYPE_NORMAL
- en: We’re going to simulate erroneous behavior in order to develop for these unforeseen
    circumstances. An easy way of doing this is to go to your `.env` file and temporarily
    rename the value of the `VITE_APP_MARVEL_API_PUBLIC` variable to `VITE_APP_MARVEL_API_PUBLIC_ERROR`.
    We will change it back once we’re done! If you run the app, it will not be able
    to request anything, and you will see the error message we’ve set in the console.
  prefs: []
  type: TYPE_NORMAL
- en: Handling the error
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we’ll focus on dealing with the error in a user-friendly way. Let’s start
    with the `ComicsOverview.vue` file. We’ll wrap the contents of the `getComics`
    function with another `try`/`catch` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the user cannot recover the state from this error, so it doesn’t
    make sense to remain on this page, since it’s completely broken. We’ll redirect
    the user to our error page instead. This means we’ll import the `useRouter` composable
    from `vue-router` and instantiate it on the component. We’ll modify file and specifically
    the `getComics` function accordingly: [https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.7-ComicsOverview.vue](https://github.com/PacktPublishing/Building-Real-world-Web-Applications-with-Vue.js-3/blob/main/04.marvel/.notes/4.7-ComicsOverview.vue)'
  prefs: []
  type: TYPE_NORMAL
- en: We’re importing (*line 4*) and registering the router (*line 14*) and use the
    `router` to redirect to a new route when an error occurs (*lines 27-29*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll create a component to show in the `ErrorView.vue`. Let’s create
    a new component called `ErrorMessage.vue` with some static content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'And we’ll update `ErrorView.vue` to load the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run our code, we should get redirected to the `/error` path as long as
    the API treats us as if we’re not authorized. We’ll add `errorhandling` to `SearchCharacter.vue`
    as well in similar fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In this case, after you’ve attempted a search, the app will redirect to the
    same page. It would be nice if we could provide a bit of context to our user,
    so they can better understand what went wrong. Fortunately, we have access to
    the error message we’ve thrown in the `catch` block.
  prefs: []
  type: TYPE_NORMAL
- en: Adding query parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll modify the `router.push` action so that it passes some additional information
    to the destination.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s an easy change that we’ll apply to both the `ComicsOverview.vue` and the
    `SearchCharacter.vue` line. Let’s change this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'And we’ll change it so that it provides information on the `query` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we’ll pass the message from the error message as a `query` parameter
    to the route. Note that it is not meant to send a large amount of text, but it
    serves as a good example of using the `query` parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we can modify the `ErrorMessage.vue` file to read into the `query`
    parameter in order to show it on the component. We can achieve that by reading
    into the route by utilizing the `useRoute` composable once the component is mounted.
    The file would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: If you now end up in the error state, you should see a message stating more
    accurately what went wrong. Don’t forget to rename your `VITE_APP_MARVEL_API_PUBLIC`
    variable once you’re done!
  prefs: []
  type: TYPE_NORMAL
- en: At this point we’ve made good progress on pretty common techniques and principles.
    In this chapter, we have introduced composables to the app, which bring reusable
    functionalities. We’ve also added client side routing and were able to create
    links in our apps’ user interface as well as apply dynamic routing and passing
    additional parameters.
  prefs: []
  type: TYPE_NORMAL
- en: As an extra bonus, we’ve introduced basic error handling and learned a bit more
    about favorite Marvel comic books.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we’ve learned how to add multiple pages and navigate by several
    means: by using the router-link component or manipulating the routes programmatically.
    We’ve created composables in order to use and reuse logic within our application.
    For a better user experience, we learned how we can handle errors in a user-friendly
    manner.'
  prefs: []
  type: TYPE_NORMAL
- en: In our next chapter, we’ll build an application using Vuetify, a third-party
    component library. Component libraries allow us to speed up development by making
    use of ready-made components. In addition, we’ll introduce an application state
    using Pinia, where we can modularly store data (or a state) to be shared between
    components throughout our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: Intermediate Projects'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, you will iterate on using external APIs to build data-rich applications.
    You will also learn how to handle more complex application state, apply the basics
    of data storage and retrieval, and identify when and how to use short-term storage
    or long-term, persistent storage solutions. You will be introduced to using web
    technologies to build applications beyond the web and deploy them anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B19563_05.xhtml#_idTextAnchor130), *Building a Recipe App with
    Vuetify*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B19563_06.xhtml#_idTextAnchor162), *Creating a Fitness Tracker
    with Data Visualization*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B19563_07.xhtml#_idTextAnchor204), *Building a Multi-Platform
    Expense Tracker Using Quasar*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
