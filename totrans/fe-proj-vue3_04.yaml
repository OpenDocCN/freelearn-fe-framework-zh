- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Nesting Components (Modularity)
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件嵌套（模块化）
- en: In the previous chapter, we learned how to initialize, build, and debug a simple
    Vue application. In this chapter, you will discover how to modularize a Vue application
    using component hierarchies and nesting. This chapter introduces concepts such
    as props, events, prop validation, and slots. It also covers how to use refs to
    access DOM elements during runtime.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何初始化、构建和调试一个简单的 Vue 应用程序。在本章中，您将了解如何使用组件层次结构和嵌套来模块化 Vue 应用程序。本章介绍了
    props、事件、prop 验证和插槽等概念。它还涵盖了如何在运行时使用 refs 访问 DOM 元素。
- en: By the end of this chapter, you will be able to define communication interfaces
    between components using props, events, and validators, and be ready to build
    components for your Vue component library or a Vue application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够使用 props、事件和验证器定义组件之间的通信接口，并准备好为您的 Vue 组件库或 Vue 应用程序构建组件。
- en: 'This chapter covers the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Passing props
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递 props
- en: Understanding prop types and validation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 prop 类型验证
- en: Understanding slots, named slots, and scoped slots
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解插槽、命名插槽和作用域插槽
- en: Understanding Vue refs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Vue 的 refs
- en: Using events for child-parent communication
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用事件进行子父通信
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, you need to set up a basic Vue project following the instructions
    in [*Chapter 1*](B18645_01.xhtml#_idTextAnchor015), *Starting Your First Vue Project*.
    It’s recommended to create a Vue component in a single file to practice the examples
    and concepts covered here with ease.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您需要按照 [*第 1 章*](B18645_01.xhtml#_idTextAnchor015) 中 *启动您的第一个 Vue 项目* 的说明设置一个基本的
    Vue 项目。建议创建一个单文件 Vue 组件来轻松练习本章涵盖的示例和概念。
- en: 'The complete code for this chapter is available on GitHub at: [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter04](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter04).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整代码可在 GitHub 上找到：[https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter04](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter04)。
- en: Passing props
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传递 props
- en: '`this`) and in the component’s `template`.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`this`) 以及在组件的 `template` 中。'
- en: The value of a prop depends on what the parent passes in its `template` to the
    child component at render time.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: prop 的值取决于父组件在渲染时传递给子组件的 `template` 中的内容。
- en: Defining a simple component that accepts props
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义一个接受 props 的简单组件
- en: Let’s look at a simple `HelloWorld` single-file component. You can find this
    at `./src/components/HelloWorld.vue`, generated automatically when you create
    a Vue project with Vite.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的 `HelloWorld` 单文件组件。您可以在 `./src/components/HelloWorld.vue` 找到它，这是在您使用
    Vite 创建 Vue 项目时自动生成的。
- en: Note how the `msg` value is set in the `props` array and that it is interpolated
    as a value using `{{` `msg }}`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `msg` 值是如何在 `props` 数组中设置的，并且它是如何使用 `{{` `msg }}` 进行插值的。
- en: The `props` property of a Vue component can be an array of strings or an object
    literal, each property field of which is a component’s prop definition.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 组件的 `props` 属性可以是一个字符串数组或一个对象字面量，其中每个属性字段都是一个组件的 prop 定义。
- en: 'When a value is defined in `props`, it is then accessible as an instance variable
    in the `template` section of the Vue component:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 `props` 中定义一个值时，它随后作为实例变量在 Vue 组件的 `template` 部分中可访问：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We will now learn how to render a component using props.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将学习如何使用 props 渲染组件。
- en: Passing props to a component
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 props 传递给组件
- en: What follows is a demonstration of how to use the `HelloWorld` component in
    our Vue application.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的内容将演示如何在我们的 Vue 应用程序中使用 `HelloWorld` 组件。
- en: 'First, we need to import `HelloWorld` in our `App.vue` file using `<``script
    setup>`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在 `App.vue` 文件中使用 `<``script setup>` 导入 `HelloWorld`：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, in the `template` section, we need to render `<HelloWorld>` with the
    `msg` attribute set to `"Vue.js"`, as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `template` 部分中，我们需要将 `<HelloWorld>` 渲染为具有 `msg` 属性设置为 `"Vue.js"`，如下所示：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will render the following on the page:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在页面上渲染以下内容：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We have seen how to use a component with props from its parent. This is useful
    for code reuse and for abstracting application behavior into component-sized chunks.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用具有来自父组件的 props 的组件。这对于代码重用和将应用程序行为抽象成组件大小的块非常有用。
- en: Next, we will look at a practical example of a `Greeting` component.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看一个 `Greeting` 组件的实际示例。
- en: Exercise 4.01 – Implementing a Greeting component
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 4.01 – 实现问候组件
- en: In this exercise, we will create a component that lets you customize both the
    `greeting` (for example, `Hello`, `Hey`, or `Hola`) and `who` to greet (for example,
    `World`, `Vue.js`, or `JavaScript developers`) using what we’ve just learned about
    passing props from parent to child.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个组件，允许你使用我们刚刚学到的从父组件到子组件传递props的知识来自定义`greeting`（例如，`Hello`、`Hey`或`Hola`）和要问候的对象（例如，`World`、`Vue.js`或`JavaScript开发者`）。
- en: To access the code file for this exercise, refer to [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter04/Exercise4.01](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter04/Exercise4.01).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅[https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter04/Exercise4.01](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter04/Exercise4.01)。
- en: 'Work through the following steps to complete this exercise:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成这个练习：
- en: 'Use the application generated with `npm init vue@3` as a starting point, or
    within the root folder of the code repository, navigate to the `Chapter04/Exercise4.01`
    folder using the following commands in order:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用由`npm init vue@3`生成的应用程序作为起点，或者在你的代码仓库的根目录中，使用以下命令导航到`Chapter04/Exercise4.01`文件夹：
- en: '[PRE4]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Open the exercise project in VS Code (by using the `code .` command within the
    project directory), or alternatively in your preferred IDE.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中打开练习项目（在项目目录中使用`code .`命令），或者在你的首选IDE中打开。
- en: Create a new file named `Greeting.vue` in the `./src/components` directory.
    This will be our single-file component.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`./src/components`目录下创建一个名为`Greeting.vue`的新文件。这将是我们单文件组件。
- en: 'Start by scaffolding the component with empty `template` and `script` tags:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用带有空`template`和`script`标签的组件脚手架：
- en: '[PRE6]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we need to tell Vue that our component expects props. For this, we will
    add a `props` property to our component options object as an array with two fields,
    `greeting` and `who`, as shown in the following code block:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要告诉Vue我们的组件期望props。为此，我们将在组件选项对象中添加一个`props`属性，作为一个包含两个字段的数组，即`greeting`和`who`，如下面的代码块所示：
- en: '[PRE12]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we want to render `greeting` and `who` in the template as follows:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们想在模板中将`greeting`和`who`渲染如下：
- en: '[PRE15]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `Greeting` component is now ready to be used from `App.vue`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`Greeting`组件现在已准备好在`App.vue`中使用。'
- en: 'Open the `src/App.vue` file and import the `Greeting` component from `./src/components/Greeting.vue`
    into the `script` section:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`src/App.vue`文件，并将`Greeting`组件从`./src/components/Greeting.vue`导入到`script`部分：
- en: '[PRE18]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we can use `Greeting` in `template`:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用`Greeting`在`template`中：
- en: '[PRE21]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Run the application using the following command:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行应用程序：
- en: '[PRE26]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You will see the following when visiting your app in the browser:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你在浏览器中访问你的应用时，你会看到以下内容：
- en: '[PRE27]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Modify the `greeting` and `who` props using the attribute values in `template`:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`template`中的属性值修改`greeting`和`who`props：
- en: '[PRE28]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Open a Vue tab in the browser DevTools and you will see the values of the two
    `greeting` and `who` props have been updated:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器DevTools中打开Vue标签页，你会看到两个`greeting`和`who`props的值已经更新：
- en: '![Figure 4.1 – Output in a Vue tab for the Greeting component](img/B18645_04_01.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1 – Greeting组件在Vue标签页中的输出](img/B18645_04_01.jpg)'
- en: Figure 4.1 – Output in a Vue tab for the Greeting component
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – Greeting组件在Vue标签页中的输出
- en: 'And the browser now displays the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在浏览器显示以下内容：
- en: '[PRE33]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this exercise, we have learned how we can use props to enable communication
    between parent and child while keeping the component reusable. Instead of the
    component rendering static data, its parent passes it the data to render.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们学习了如何使用props在父组件和子组件之间启用通信，同时保持组件的可复用性。而不是组件渲染静态数据，其父组件传递数据以进行渲染。
- en: In the next section, we will learn how to set prop values dynamically.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何动态设置prop值。
- en: Binding reactive data to props
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将响应式数据绑定到props
- en: In the previous section, we saw how to pass static data as props to a component.
    What if we want to pass reactive data from the parent to the child?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了如何将静态数据作为props传递给组件。如果我们想从父组件传递响应式数据到子组件怎么办？
- en: This is where `v-bind:` (or `:` for short) to enable **one-way binding** of
    a parent’s reactive data to the child component’s props.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使用`v-bind:`（或简写为`:`）来启用父组件的响应式数据到子组件props的单向绑定。
- en: 'In the following code example, we bind the `appWho` data to the `msg` prop
    of the `HelloWorld` component:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码示例中，我们将`appWho`数据绑定到`HelloWorld`组件的`msg`prop：
- en: '[PRE34]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The output will be as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE35]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let’s add two buttons that change the value of `appWho`, one to `JavaScript`
    and the other to `Everyone`, by triggering a `setWho` method with the appropriate
    value as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加两个按钮来改变`appWho`的值，一个用于`JavaScript`，另一个用于`Everyone`，通过触发带有适当值的`setWho`方法，如下所示：
- en: '[PRE36]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The browser now displays the following output:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器现在显示以下输出：
- en: '![Figure 4.2 – Browser displays the component with two buttons](img/B18645_04_02.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2 – 浏览器显示带有两个按钮的组件](img/B18645_04_02.jpg)'
- en: Figure 4.2 – Browser displays the component with two buttons
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 浏览器显示带有两个按钮的组件
- en: 'When you click the `appWho` value and then re-renders the `HelloWorld` child
    component with the new value passed to the `msg` prop. Thus, `Hello JavaScript`
    is displayed, as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击`appWho`值并重新渲染带有新值传递给`msg`属性的`HelloWorld`子组件时。因此，显示为`Hello JavaScript`，如下所示：
- en: '![Figure 4.3 – Hello JavaScript displayed after clicking the JavaScript button](img/B18645_04_03.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3 – 点击JavaScript按钮后显示的“Hello JavaScript”](img/B18645_04_03.jpg)'
- en: Figure 4.3 – Hello JavaScript displayed after clicking the JavaScript button
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – 点击JavaScript按钮后显示的“Hello JavaScript”
- en: 'Similarly, when you click the `Hello Everyone`, as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当你点击`Hello Everyone`时，如下所示：
- en: '![Figure 4.4 – Hello Everyone displayed after clicking the Everyone button](img/B18645_04_04.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图4.4 – 点击Everyone按钮后显示的“Hello Everyone”](img/B18645_04_04.jpg)'
- en: Figure 4.4 – Hello Everyone displayed after clicking the Everyone button
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 – 点击Everyone按钮后显示的“Hello Everyone”
- en: As we have seen, we are able to bind reactive data to props so that any data
    updated in the parent will be reflected in the child component’s data accordingly.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们能够将响应式数据绑定到props，以便在父组件中更新的任何数据都会相应地反映在子组件的数据中。
- en: Exercise 4.02 – Passing reactive data that changes frequently to props
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.02 – 将频繁更改的响应式数据传递给props
- en: In this exercise, we will implement a component that allows users to change
    the name of the person to greet and pass it to the `Greeting` component we built
    in *Exercise 4.01*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将实现一个组件，允许用户更改要问候的人的名字，并将其传递给我们构建在*练习4.01*中的`Greeting`组件。
- en: To access the code file for this exercise, refer to [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter04/Exercise4.02](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter04/Exercise4.02).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅[https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter04/Exercise4.02](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter04/Exercise4.02)。
- en: 'Work through the following steps to complete this exercise:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此练习：
- en: 'Use the application built in *Exercise 4.01* or navigate to the `Chapter04/Exercise4.02`
    folder using the following commands in order:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*练习4.01*中构建的应用程序或使用以下命令导航到`Chapter04/Exercise4.02`文件夹：
- en: '[PRE37]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Open the exercise project in VS Code (by using the `code .` command within the
    project directory) or in your preferred IDE.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中打开练习项目（在项目目录中使用`code .`命令）或使用您首选的IDE。
- en: 'In the `script` section of `App.vue`, let’s remove the `setup` attribute from
    the `script` tag, and register `Greeting` as a child component in the `components`
    field as follows:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`App.vue`的`script`部分，让我们从`script`标签中移除`setup`属性，并在`components`字段中注册`Greeting`作为子组件，如下所示：
- en: '[PRE39]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then create a `data` top-level method that returns an initial `greeting` and
    `who`:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后创建一个返回初始`greeting`和`who`的顶级`data`方法：
- en: '[PRE47]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The browser should display the same output as in *Exercise 4.01*.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器应显示与*练习4.01*相同的输出。
- en: 'We will now create an `input` field that accepts a string value for `who` from
    users and binds the `who` data to the `who` prop of `Greeting`:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将创建一个`input`字段，它接受用户输入的`who`字符串值，并将`who`数据绑定到`Greeting`的`who`属性：
- en: '[PRE58]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now when you type any name in the input field, the greeting message will change
    accordingly, as shown in the following screenshot:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当你在输入字段中输入任何名字时，问候信息将相应地改变，如下面的截图所示：
- en: '![Figure 4.5 – Output of greeting value updated according to users’ inputs](img/B18645_04_05.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图4.5 – 根据用户输入更新问候值的结果输出](img/B18645_04_05.jpg)'
- en: Figure 4.5 – Output of greeting value updated according to users’ inputs
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 – 根据用户输入更新问候值的结果输出
- en: Next, we will learn how to add type hints and validation to our component’s
    props to ensure they are used correctly.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何为我们的组件props添加类型提示和验证以确保它们被正确使用。
- en: Understanding prop types and validation
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解prop类型和验证
- en: We use props to define the interfaces of Vue components and ensure other developers
    use our components correctly. We need to define their interfaces with types and
    validation. Vue offers that capability out of the box by changing how we pass
    the props as string elements to the `props` property in an object form.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用属性来定义 Vue 组件的接口，并确保其他开发者正确使用我们的组件。我们需要使用类型和验证来定义它们的接口。Vue 通过改变我们如何将属性作为字符串元素传递给对象中的
    `props` 属性来提供这种能力。
- en: Primitive prop validation
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原始属性验证
- en: 'Assume we want a `Repeat.vue` component that takes a `times` prop and a `content`
    prop and then calculates the array of `repetitions` using `computed` based on
    the `times` value. We can define the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要一个 `Repeat.vue` 组件，它接受 `times` 属性和 `content` 属性，然后根据 `times` 的值使用 `computed`
    计算出 `repetitions` 数组。我们可以定义以下内容：
- en: '[PRE65]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In `App.vue`, we can consume our `Repeat` component as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `App.vue` 中，我们可以如下使用我们的 `Repeat` 组件：
- en: '[PRE66]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The preceding code will lead to the following output in the browser:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将在浏览器中产生以下输出：
- en: '![Figure 4.6 – Output of the repeat example in action (no clicks)](img/B18645_04_06.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.6 – 重复示例动作输出（无点击）](img/B18645_04_06.jpg)'
- en: Figure 4.6 – Output of the repeat example in action (no clicks)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 – 重复示例动作输出（无点击）
- en: 'Whenever clicking the `Repeat` button, the `Repeat` component will display
    the content one more time, as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 每次点击 `Repeat` 按钮，`Repeat` 组件将显示内容一次，如下所示：
- en: '![Figure 4.7 – Output of the repeat example after five clicks](img/B18645_04_07.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.7 – 五次点击后的重复示例输出](img/B18645_04_07.jpg)'
- en: Figure 4.7 – Output of the repeat example after five clicks
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 – 五次点击后的重复示例输出
- en: Now, for this component to work properly, we need `times` to be a `Number` type
    and, ideally, `content` to be a `String` type.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了使此组件正常工作，我们需要 `times` 是 `Number` 类型，理想情况下 `content` 是 `String` 类型。
- en: Note
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Props type in Vue can be any type including `String`, `Number`, `Boolean`, `Array`,
    `Object`, `Date`, `Function`, and `Symbol`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 中的属性类型可以是任何类型，包括 `String`、`Number`、`Boolean`、`Array`、`Object`、`Date`、`Function`
    和 `Symbol`。
- en: 'Let’s define the `times` prop as a `Number` and the `content` props as a `String`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义 `times` 属性为 `Number` 类型，并将 `content` 属性定义为 `String` 类型：
- en: '[PRE67]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Let’s see what happens if we update `App` to pass the wrong prop type to `Repeat`
    – for example, let’s say `times` is a `String` and `content` is a `Number`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果我们将 `App` 更新为向 `Repeat` 传递错误的属性类型会发生什么 – 例如，让我们假设 `times` 是一个 `String`，而
    `content` 是一个 `Number`：
- en: '[PRE68]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'In this case, the `Repeat` component will fail to render, and the following
    errors will be logged to the console:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`Repeat` 组件将无法渲染，并且以下错误将被记录到控制台：
- en: '![Figure 4.8 – Mistyping prop errors](img/B18645_04_08.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.8 – 错误输入属性错误](img/B18645_04_08.jpg)'
- en: Figure 4.8 – Mistyping prop errors
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 – 错误输入属性错误
- en: 'The `times` prop check fails with a message that explains that we passed a
    `String` to a prop that expects to receive a `Number`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`times` 属性检查失败，显示一条消息解释说我们传递了一个 `String` 给期望接收 `Number` 的属性：'
- en: '[PRE69]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The same occurs with the `content` prop check, with a message that explains
    that we passed a `Number` as a prop that was supposed to be a `String`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，对于 `content` 属性检查，也会出现一条消息，解释说我们传递了一个 `Number` 作为属性，而这个属性本应该是 `String`：
- en: '[PRE70]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Next, let’s explore custom prop types and union types.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们探索自定义属性类型和联合类型。
- en: Understanding union and custom prop types
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解联合和自定义属性类型
- en: 'Vue supports union types. A `[String, Number]`. We declare a prop to accept
    a union type by using the `type` field of that data prop object. For example,
    we set `content` to accept a union type that will be either a number or a string:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 支持联合类型。例如 `[String, Number]`。我们通过使用该数据属性对象的 `type` 字段来声明一个接受联合类型的属性。例如，我们将
    `content` 设置为接受一个联合类型，该类型可以是数字或字符串：
- en: '[PRE71]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'In this case, we can consume the `Repeat` component as follows without errors:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以如下使用 `Repeat` 组件而不会出现错误：
- en: '[PRE72]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We can also use any valid JavaScript constructor as a prop’s `type`, such as
    a `Promise` or a custom `User` class constructor, as in the following example
    with the `TodoList` component:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用任何有效的 JavaScript 构造函数作为属性的类型，例如 `Promise` 或自定义的 `User` 类构造函数，如下面的 `TodoList`
    组件示例所示：
- en: '[PRE73]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Note here we import the `User` custom type from another file. We can use this
    `TodoList` component as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里我们从一个文件中导入 `User` 自定义类型。我们可以如下使用此 `TodoList` 组件：
- en: '[PRE74]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: In the preceding code, we only fetch `todosPromise` once Vue mounts the component
    instance, and create a new instance of `User` using `new User()`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们只在使用 Vue 挂载组件实例时获取 `todosPromise`，并使用 `new User()` 创建一个新的 `User` 实例。
- en: We have now seen how to use the union and custom types to validate Vue props.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用联合和自定义类型来验证 Vue props。
- en: Note
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Vue uses `instanceof` validation internally, so make sure any custom types are
    instantiated using the relevant constructor.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 使用 `instanceof` 验证内部，所以请确保任何自定义类型都使用相关构造函数实例化。
- en: Passing `null` or `undefined` will fail the check for `Array` and `Object`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 传递 `null` 或 `undefined` 将会导致对 `Array` 和 `Object` 的检查失败。
- en: Passing an array will pass the check for `Object` since an array is also an
    instance of `Object` in JavaScript.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 传递一个数组将通过 `Object` 的检查，因为在 JavaScript 中数组也是 `Object` 的实例。
- en: Next, we will explore how to enable validation for props on certain types.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何为特定类型启用对 props 的验证。
- en: Custom validation of arrays and objects
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组和对象的自定义验证
- en: Vue allows custom validators to be used as props using the `validator` property.
    This allows us to implement deep checks regarding object and collection types.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 允许使用 `validator` 属性将自定义验证器用作 props。这允许我们实现关于对象和集合类型的深入检查。
- en: Let’s look at a `CustomSelect` component.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `CustomSelect` 组件。
- en: On a basic level, the prop interface for `select` comprises an array of `options`
    and a `selected` option.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本层面上，`select` 的 prop 接口由一个 `options` 数组和一个 `selected` 选项组成。
- en: Each option should have a `label` that represents what is displayed in `select`,
    and a `value` representing its actual value. The `selected` option’s value can
    be empty or be equal to the `value` field for one of our `options`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 每个选项都应该有一个 `label`，它代表在 `select` 中显示的内容，以及一个 `value`，代表其实际值。`selected` 选项的值可以是空的，也可以等于我们
    `options` 中的一个 `value` 字段。
- en: 'We can implement `CustomSelect` in a naive way (no validation of the inputs)
    as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以简单的方式实现 `CustomSelect`（不验证输入）如下：
- en: '[PRE75]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Then use `CustomSelect` to display a list of British crisp flavors (in `src/App.vue`):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用 `CustomSelect` 来显示一系列英国薯片口味（在 `src/App.vue` 中）：
- en: '[PRE76]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The preceding example outputs a `select` element where `Salt & Vinegar` is
    the default selected option, as shown in the following screenshot:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例输出一个 `select` 元素，其中 `Salt & Vinegar` 是默认选中的选项，如下面的截图所示：
- en: '![Figure 4.9 – Collapsed CustomSelect with Salt & Vinegar selected](img/B18645_04_09.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.9 – 已选中 Salt & Vinegar 的折叠 CustomSelect](img/B18645_04_09.jpg)'
- en: Figure 4.9 – Collapsed CustomSelect with Salt & Vinegar selected
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 – 已选中 Salt & Vinegar 的折叠 CustomSelect
- en: 'The following screenshot shows the three flavor options displayed when the
    dropdown is opened:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了下拉菜单打开时显示的三个口味选项：
- en: '![Figure 4.10 – Open CustomSelect with flavor options and Salt & Vinegar selected](img/B18645_04_10.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.10 – 已打开的 CustomSelect，带有口味选项和已选中 Salt & Vinegar](img/B18645_04_10.jpg)'
- en: Figure 4.10 – Open CustomSelect with flavor options and Salt & Vinegar selected
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10 – 已打开的 CustomSelect，带有口味选项和已选中 Salt & Vinegar
- en: 'Now we can implement a prop `validator` method to enable further validation
    for our component’s logic, as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以实现一个 prop `validator` 方法来为我们的组件逻辑启用进一步的验证，如下所示：
- en: '[PRE77]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'If we pass an option with a missing `value` or `label`, we will get the following
    message in the console:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们传递一个缺少 `value` 或 `label` 的选项，我们将在控制台中收到以下消息：
- en: '![Figure 4.11 – Console warning when a custom validator fails](img/B18645_04_11.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.11 – 当自定义验证器失败时的控制台警告](img/B18645_04_11.jpg)'
- en: Figure 4.11 – Console warning when a custom validator fails
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11 – 当自定义验证器失败时的控制台警告
- en: With that, we have learned how to use a custom validator to do in-depth validation
    for complex props. Next, we will learn how the `required` property of a prop works.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经学习了如何使用自定义验证器对复杂 props 进行深入验证。接下来，我们将学习 prop 的 `required` 属性是如何工作的。
- en: Understanding required props
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解必需 props
- en: To mark a prop as required, we can use the `required` prop type property.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一个 prop 标记为必需，我们可以使用 `required` prop 类型属性。
- en: 'In the `CustomSelect` example, we can make `selected` a required prop by adding
    `required: true` to its prop definition, as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '在 `CustomSelect` 示例中，我们可以通过在 prop 定义中添加 `required: true` 来使 `selected` 成为必需的
    prop，如下所示：'
- en: '[PRE78]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Now, if we don’t pass a value to the `selected` prop of `CustomSelect` on the
    parent component, we will see the following error:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们不在父组件的 `CustomSelect` 的 `selected` prop 上传递值，我们将看到以下错误：
- en: '![Figure 4.12 – Console warning when the selected required prop is missing](img/B18645_04_12.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.12 – 当选定的必需 prop 缺失时的控制台警告](img/B18645_04_12.jpg)'
- en: Figure 4.12 – Console warning when the selected required prop is missing
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12 – 当选定的必需 prop 缺失时的控制台警告
- en: With that, we have learned how to mark props as required and saw what happens
    when we don’t pass a value to a required prop. Next, we will learn how to set
    the default value for a prop and see why it is a good practice to do so.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就学会了如何标记属性为必需的，并看到了当我们没有传递必需属性的值时会发生什么。接下来，我们将学习如何为属性设置默认值，并了解为什么这样做是一个好的实践。
- en: Setting the default props value
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置默认属性值
- en: There are situations where setting the default value for a prop is good practice
    to follow.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 有时为属性设置默认值是遵循良好实践的好方法。
- en: 'Take a `PaginatedList` component, for instance. This component takes a list
    of `items`, a `limit` number of items to display, and an `offset` number. Then
    it will display a subset of items – `currentWindow` – based on the `limit` and
    `offset` values:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `PaginatedList` 组件为例。该组件接受一个 `items` 列表，要显示的项目数 `limit`，以及 `offset` 数。然后它将根据
    `limit` 和 `offset` 值显示项目子集 – `currentWindow`：
- en: '[PRE79]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Instead of passing the values of `limit` and `offset` every time, it might be
    better to set `limit` to a default value (like `2`) and `offset` to `0` (this
    means that by default, we show the first page, which contains `2` results).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是每次都传递 `limit` 和 `offset` 的值，可能更好的做法是将 `limit` 设置为默认值（例如 `2`），将 `offset` 设置为
    `0`（这意味着默认情况下，我们将显示第一页，其中包含 `2` 个结果）。
- en: 'We can implement this change using the default property for each prop definition
    object as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用每个属性定义对象的默认属性来实现这个更改，如下所示：
- en: '[PRE80]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Then in `App.vue`, we can use `PaginatedList` without passing `limit` and `offset`.
    Vue automatically falls back to the default values in case no value is passed:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `App.vue` 中，我们可以使用 `PaginatedList` 而不传递 `limit` 和 `offset`。如果没有传递值，Vue
    会自动回退到默认值：
- en: '[PRE81]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The browser will display only the first two items, as shown in the following
    screenshot:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器将只显示前两个项目，如下面的屏幕截图所示：
- en: '![Figure 4.13 – Output of a snack list with first two items only by default](img/B18645_04_13.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.13 – 默认只显示前两项的零食列表输出](img/B18645_04_13.jpg)'
- en: Figure 4.13 – Output of a snack list with first two items only by default
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13 – 默认只显示前两项的零食列表输出
- en: When you pass values for `offset` or `limit`, Vue will use these values instead
    of the defaults and render the component accordingly.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当你传递 `offset` 或 `limit` 的值时，Vue 将使用这些值而不是默认值，并相应地渲染组件。
- en: 'In cases where a prop is an array or an object, we can’t assign its `default`
    value with a static array or object. Instead, we need to assign it a function
    that returns the desired default value. We can set the `default` value of `items`
    from the `PaginatedList` component to an empty array, as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在属性是数组或对象的情况下，我们无法使用静态数组或对象为其分配 `default` 值。相反，我们需要分配一个返回所需默认值的函数。例如，我们可以将 `PaginatedList`
    组件的 `items` 的 `default` 值设置为空数组，如下所示：
- en: '[PRE82]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: At this point, we have learned how to set default values for component props.
    Note here that once you set a `default` value, you don’t need to set `required`
    field anymore. We can use a `default` value to ensure our props are always with
    values, regardless of whether this is required or optional.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学会了如何为组件属性设置默认值。请注意，一旦设置了 `default` 值，就不再需要设置 `required` 字段。我们可以使用
    `default` 值来确保我们的属性始终有值，无论这是必需的还是可选的。
- en: Registering props in <script setup> (setup hook)
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 `<script setup>` 中注册属性（setup 钩子）
- en: 'If you use `<script setup>`, since there is no options object, we can’t define
    the component’s props using the `props` field. Instead, we use the `defineProps()`
    function from the `vue` package and pass all the relevant props’ definitions to
    it, just as we did with the `props` field. For example, in the `MessageEditor`
    component, we can rewrite the event registering with `defineEmits()` as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 `<script setup>`，由于没有选项对象，我们无法使用 `props` 字段来定义组件的属性。相反，我们使用 `vue` 包中的
    `defineProps()` 函数，并将所有相关的属性定义传递给它，就像我们使用 `props` 字段时做的那样。例如，在 `MessageEditor`
    组件中，我们可以将使用 `defineEmits()` 的事件注册重写如下：
- en: '[PRE83]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '`defineProps()` returns an object containing all the props’ values. We can
    then access a prop such as `items` using `props.items` instead within the `script`
    section, and `items` as usual in the `template` section. In the previous example,
    we also use `computed()` to declare a reactive data `currentWindow` for this component,
    the usage of which we will discuss further in [*Chapter 5*](B18645_05.xhtml#_idTextAnchor193),
    *The* *Composition API*.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`defineProps()` 返回一个包含所有属性值的对象。然后我们可以使用 `props.items` 在 `script` 部分访问属性，如 `items`
    一样在 `template` 部分中。在上一个示例中，我们还使用了 `computed()` 来声明一个响应式数据 `currentWindow`，我们将在
    [*第 5 章*](B18645_05.xhtml#_idTextAnchor193) *《组合 API》* 中进一步讨论其用法。'
- en: Let’s practice writing component props with defaults, types, and validators
    in the next exercise.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将练习编写具有默认值、类型和验证器的组件 props。
- en: Exercise 4.03 – Validating an Object property
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 4.03 – 验证对象属性
- en: In this exercise, we will write a `Repeat` component that accepts a `config`
    data prop for passing `times`, which is a `Number`, and `content`, which is a
    `String`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将编写一个 `Repeat` 组件，该组件接受一个 `config` 数据 prop，用于传递 `times`（一个 `Number`）和
    `content`（一个 `String`）。
- en: We will write a custom validator to make sure `times` and `content` exist and
    are of the correct type.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个自定义验证器以确保 `times` 和 `content` 存在并且类型正确。
- en: To access the code file for this exercise, refer to [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter04/Exercise4.03](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter04/Exercise4.03).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅 [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter04/Exercise4.03](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter04/Exercise4.03)。
- en: 'Work through the following steps to complete this exercise:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此练习：
- en: 'Use the application generated with `npm init vue@3` as a starting point. Otherwise,
    within the root folder of the code repository, navigate to the `Chapter04/Exercise4.03`
    folder using the following commands in order:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以使用 `npm init vue@3` 生成的应用程序作为起点。否则，在代码仓库的根目录中，使用以下命令导航到 `Chapter04/Exercise4.03`
    文件夹：
- en: '[PRE84]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Open the exercise project in VS Code (using the `code .` command within the
    project directory) or in your preferred IDE.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中打开练习项目（在项目目录中使用 `code .` 命令）或使用你喜欢的 IDE。
- en: Create a new file named `Repeat.vue` in the `./``src/components` directory.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `./src/components` 目录中创建一个名为 `Repeat.vue` 的新文件。
- en: 'Define a prop `config` for `Repeat.vue`. This prop will be of the `Object`
    type, as follows:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `Repeat.vue` 定义一个名为 `config` 的 prop。此 prop 将是 `Object` 类型，如下所示：
- en: '[PRE86]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '`Config` contains two fields – `times` and `content`. We compute a reactive
    data array called `repetitions` for the `Repeat` component with its length based
    on `config.times`:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Config` 包含两个字段 – `times` 和 `content`。我们为 `Repeat` 组件计算一个名为 `repetitions` 的响应式数据数组，其长度基于
    `config.times`：'
- en: '[PRE96]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Set up `<template>` so that it renders `config.content` for each of the `repetitions`
    items:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 `<template>` 以便为每个 `repetitions` 项目渲染 `config.content`：
- en: '[PRE106]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'We need to ensure that `content` and `times` will receive the correct value
    by implementing a `validator` for `config`. The `validator` will check whether
    the received value’s `times` and `content` `typeof` are of `number` and `string`,
    respectively:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要通过实现 `config` 的 `validator` 来确保 `content` 和 `times` 将接收到正确的值：
- en: '[PRE113]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Next, we import and use `Repeat` in `src/App.vue`:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们在 `src/App.vue` 中导入并使用 `Repeat`：
- en: '[PRE128]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Unfortunately, this will not render anything since `config` is an empty object.
    You will observe a warning in the console, as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这不会渲染任何内容，因为 `config` 是一个空对象。你将在控制台中观察到警告，如下所示：
- en: '![Figure 4.14 – Console warning due to the config prop’s custom validator check
    failing](img/B18645_04_14.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.14 – 由于配置属性的自定义验证器检查失败导致的控制台警告](img/B18645_04_14.jpg)'
- en: Figure 4.14 – Console warning due to the config prop’s custom validator check
    failing
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14 – 由于配置属性的自定义验证器检查失败导致的控制台警告
- en: 'We will see this same error in the following cases:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在以下情况下看到相同的错误：
- en: 'We only add a `times` property, that is, `<Repeat :config="{ times: 3 }" />`'
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '我们只添加一个 `times` 属性，即 `<Repeat :config="{ times: 3 }" />`'
- en: 'We only add a `content` property, that is, `<Repeat :config="{ content: ''Repeat
    me.'' }" />`'
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '我们只添加一个 `content` 属性，即 `<Repeat :config="{ content: ''Repeat me.'' }" />`'
- en: '`times` is of the wrong type, that is, `<Repeat :config="{ times: ''3'', content:
    ''Repeat me.'' }" />`'
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`times` 的类型错误，即 `<Repeat :config="{ times: ''3'', content: ''Repeat me.'' }"
    />`'
- en: '`content` is of the wrong type property, that is, `<Repeat :config="{ times:
    3, content: 42 }" />`'
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`content` 的类型属性错误，即 `<Repeat :config="{ times: 3, content: 42 }" />`'
- en: 'For `Repeat` to work correctly, we can amend the line consuming it in `template`
    to the following:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使 `Repeat` 正确工作，我们可以修改 `template` 中消耗它的行，如下所示：
- en: '[PRE141]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'This shows no errors in the console and renders `Repeat me.` three times, as
    follows:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这在控制台中不会显示任何错误，并按如下方式渲染 `Repeat me.` 三次：
- en: '[PRE142]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: We have demonstrated how we use a validator to better define components with
    props.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了如何使用验证器更好地定义具有 props 的组件。
- en: In the next section, we will have a deep dive into slots, a mechanism we use
    to compose our components by deferring template logic.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将深入了解插槽，这是我们通过延迟模板逻辑来组合组件的一种机制。
- en: Understanding slots, named slots, and scoped slots
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解槽、命名槽和作用域槽
- en: '**Slots** are sections of a component where the template/rendering is delegated
    back to the parent of the component. We can consider slots as templates or markup
    that are passed from a parent to a child for rendering in its main template.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '**槽**是组件中模板/渲染被委派回组件父级的部分。我们可以将槽视为从父组件传递给子组件以在主模板中渲染的模板或标记。'
- en: Passing markup to a component for rendering
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将标记传递给组件进行渲染
- en: The simplest type of slot is the default child slot.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的槽类型是默认子槽。
- en: 'We can define a `Box` component with a slot as follows:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个具有槽的 `Box` 组件，如下所示：
- en: '[PRE143]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'The following markup is for the parent component (`src/App.vue`):'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 以下标记是父组件 (`src/App.vue`) 的：
- en: '[PRE144]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'The preceding code will render the following text in the browser:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将在浏览器中渲染以下文本：
- en: '[PRE145]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'If there is no template content passed to `Box`, Vue will fall back to the
    default template defined in the `Box` component, which is the following text:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有传递模板内容给 `Box`，Vue 将回退到在 `Box` 组件中定义的默认模板，如下所示：
- en: '[PRE146]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Behind the scenes, Vue compiles the `template` section of `Box` and replaces
    `<slot />` with the content wrapped inside `<Box />` from the parent (`App`).
    The scope of the replaced content, however, stays within the parent’s scope.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，Vue 编译 `Box` 的 `template` 部分，并将 `<slot />` 替换为父组件 (`App`) 中 `<Box />` 内部包裹的内容。然而，替换内容的范围仍然保持在父组件的作用域内。
- en: 'Consider the following example:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE147]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'The preceding code will render `count` per its value in the parent component.
    It does not have access to the `Box` instance data or props and will generate
    the following output:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将根据父组件中的值渲染 `count`。它无法访问 `Box` 实例数据或 props，并将生成以下输出：
- en: '![Figure 4.15 – Initial h3 with a count of 0, per the initial data in the parent
    component](img/B18645_04_15.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.15 – 初始 h3，计数为 0，根据父组件中的初始数据](img/B18645_04_15.jpg)'
- en: Figure 4.15 – Initial h3 with a count of 0, per the initial data in the parent
    component
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.15 – 初始 h3，计数为 0，根据父组件中的初始数据
- en: 'Incrementing the `count` from the parent updates the template content, since
    the `count` variable in the template passed to `Box` was bound to data on the
    parent. This will generate the following output:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 从父组件增加 `count` 会更新模板内容，因为传递给 `Box` 的模板中的 `count` 变量绑定到了父组件的数据。这将生成以下输出：
- en: '![Figure 4.16 – h3 with a count of 5 after five increments of the count in
    the parent component’s scope](img/B18645_04_16.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.16 – 父组件作用域中计数增加五次后的 h3，计数为 5](img/B18645_04_16.jpg)'
- en: Figure 4.16 – h3 with a count of 5 after five increments of the count in the
    parent component’s scope
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.16 – 在父组件作用域中计数增加五次后的 h3，计数为 5
- en: Slots are a way to let the parent have control over rendering a section of a
    child’s template. Any references to instance properties, data, or methods will
    use the parent component instance. This type of slot does not have access to the
    child component’s properties, props, or data.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 槽是让父组件控制子组件模板部分渲染的一种方式。任何对实例属性、数据或方法的引用都将使用父组件实例。这种类型的槽无法访问子组件的属性、props 或数据。
- en: In the next section, we will look at how to use named slots to render multiple
    sections.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何使用命名槽来渲染多个部分。
- en: Using named slots to delegate rendering of multiple sections
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用命名槽来委托多个部分的渲染
- en: We use named slots when a child component wants to allow its parent to customize
    the multiple sections in its template.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 当子组件想要允许其父组件自定义其模板中的多个部分时，我们使用命名槽。
- en: For example, an `Article` component might delegate rendering of `title` and
    `excerpt` to its parent.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个 `Article` 组件可能会将 `title` 和 `excerpt` 的渲染委托给其父组件。
- en: 'In this case, we will use multiple `slot` and assign each with an appropriate
    `name` attribute value, shown as follows:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将使用多个 `slot` 并为每个分配适当的 `name` 属性值，如下所示：
- en: '[PRE148]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: By doing so, we allow the parent of `article` to override the slots named `title`
    and `excerpt` with its desired UI templates.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们允许 `article` 的父组件用其期望的 UI 模板覆盖名为 `title` 和 `excerpt` 的槽。
- en: To pass content to the desired slot, we use `template` with the `v-slot:name`
    directive (where `name` should be replaced with the slot’s name).
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 要将内容传递到所需的槽，我们使用带有 `v-slot:name` 指令的 `template`（其中 `name` 应替换为槽的名称）。
- en: 'For example, for the slot named `title`, we will use `v-slot:title`, while
    for the `excerpt` slot, we will use `v-slot:excerpt`:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于名为 `title` 的槽，我们将使用 `v-slot:title`，而对于 `excerpt` 槽，我们将使用 `v-slot:excerpt`：
- en: '[PRE149]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'When the preceding application is seen in the browser, it will look as follows:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 当在浏览器中查看前面的应用程序时，它将如下所示：
- en: '![Figure 4.17 – Article using named slots to render templates defined by the
    parent](img/B18645_04_17.jpg)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.17 – 使用命名插槽渲染由父组件定义的模板](img/B18645_04_17.jpg)'
- en: Figure 4.17 – Article using named slots to render templates defined by the parent
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.17 – 使用命名插槽渲染由父组件定义的模板
- en: As you can see, the named slots do indeed render the expected content.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，命名的插槽确实渲染了预期的内容。
- en: 'The shorthand syntax for `v-slot:slot-name` is `#slot-name`. We can refactor
    our template that consumes `Article` as follows:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`v-slot:slot-name` 的简写语法是 `#slot-name`。我们可以按照以下方式重构消耗 `Article` 的模板：'
- en: '[PRE150]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Note here that `v-slot` cannot be used with native elements. You can only use
    it with `template` and /or with the component itself. For example, the following
    `<template>` section attempts to set a `v-slot` on a `h3` element:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里，`v-slot` 不能与原生元素一起使用。您只能与 `template` 或组件本身一起使用。例如，以下 `<template>` 部分尝试在
    `h3` 元素上设置 `v-slot`：
- en: '[PRE151]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'This template will fail with a compilation error of `v-slot can only be used
    on components or <template>`, as shown in the following screenshot:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板将因 `v-slot 只能在组件或 <template> 上使用` 的编译错误而失败，如下截图所示：
- en: '![Figure 4.18 – v-slot on a native element – compilation error](img/B18645_04_18.jpg)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.18 – 在原生元素上使用 v-slot – 编译错误](img/B18645_04_18.jpg)'
- en: Figure 4.18 – v-slot on a native element – compilation error
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.18 – 在原生元素上使用 v-slot – 编译错误
- en: Note
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Everything that applies to the default slot applies to named slots. In fact,
    the default slot is a named slot called `default`. This means that named slots
    also have access to the parent instance but not the child instance.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 对默认插槽适用的所有内容也适用于命名插槽。实际上，默认插槽是一个名为 `default` 的命名插槽。这意味着命名插槽也有权访问父实例，但不能访问子实例。
- en: 'The default slot is just a slot named `default` and we can define it with no
    name. The `default` slot is implicitly inferred as follows:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 默认插槽只是一个名为 `default` 的插槽，我们可以不指定名称来定义它。`default` 插槽的隐式推断如下：
- en: '[PRE152]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'We can also denote the default slot with shorthand slot notation:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用简写插槽数法表示默认插槽：
- en: '[PRE153]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Or we can denote the default slot with longhand slot notation as follows:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用长句插槽数法如下表示默认插槽：
- en: '[PRE154]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: We have now seen how named slots allow components to delegate templating of
    certain sections to a consumer, as well as how these named slots can have a default
    template to cater for cases where a named slot is optional.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，命名插槽允许组件将某些部分的模板委托给消费者，以及这些命名插槽如何有一个默认模板来应对命名插槽可选的情况。
- en: In the next section, we will learn how scoped slots are used to wrap prop-passing
    logic.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何使用作用域插槽来封装属性传递逻辑。
- en: Using scoped slots to wrap prop-passing logic
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用作用域插槽封装属性传递逻辑
- en: The types of slots we have explored so far only have access to the component
    instance where slot template content is passed – the parent component.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止探索的插槽类型只能访问传递插槽模板内容的组件实例——父组件。
- en: In many scenarios, it is handier to let the parent component decide how to render
    the UI while letting the child component handle the data and pass it to the slot.
    We use scoped slots for this purpose.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多场景中，让父组件决定如何渲染 UI，同时让子组件处理数据并将其传递给插槽会更方便。我们使用作用域插槽来实现这个目的。
- en: A `slot` element receives props and passes them to the related template content
    by using `v-bind` or the shorthand, `:`.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`slot` 元素通过使用 `v-bind` 或简写 `:` 将 props 传递给相关的模板内容。'
- en: 'In the following code example, we bind the slot’s `item` prop to `el`, which
    is an element of the `currentWindow` data in the `PaginatedList` component:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码示例中，我们将插槽的 `item` prop 绑定到 `el`，它是 `PaginatedList` 组件中 `currentWindow`
    数据的一个元素：
- en: '[PRE155]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'On the consumer side (the parent component), Vue renders the template for that
    slot with a props object containing all the data props passed to the slot from
    the child component. We need to let Vue know what data prop we want to access
    within a template content by specifying it with the following syntax:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在消费者端（父组件），Vue 使用包含从子组件传递给插槽的所有数据属性的 props 对象来渲染该插槽的模板。我们需要通过以下语法指定，让 Vue 知道我们想要在模板内容中访问哪些数据属性：
- en: '[PRE156]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Or, we can specify the name of the props object to be used within the template
    content as follows:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以指定在模板内容中使用的 props 对象的名称如下：
- en: '[PRE157]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: Then within the template content, we can access a data prop by using `propName`
    or `slotProps.propName`, depending on which approach you use. Note here that you
    can change the `propName` value to any prop’s name, and the same goes for `slotProps`.
    If the slot doesn’t have a name, we will use `default` to denote `slot-name` instead.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在模板内容中，我们可以通过使用`propName`或`slotProps.propName`来访问数据属性，具体取决于你使用哪种方法。注意，在这里你可以将`propName`的值更改为任何属性的名称，同样也适用于`slotProps`。如果插槽没有名称，我们将使用`default`来表示`slot-name`。
- en: 'For example, to access the `item` data prop passed to the slot in `PaginatedList`,
    we add the following to its parent:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要访问传递给`PaginatedList`插槽的`item`数据属性，我们在其父组件中添加以下内容：
- en: '[PRE158]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Our `template` section in `App.vue` with the parent of `PaginatedList` will
    now look as follows:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`App.vue`中`PaginatedList`的父组件的`template`部分将如下所示：
- en: '[PRE159]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'The `script` section (with snacks to render) will be as follows:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '`script`部分（包含要渲染的零食）将如下所示：'
- en: '[PRE160]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'We get the following output in the browser:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，我们得到以下输出：
- en: '![Figure 4.19 – Snacks displayed using a scoped slot](img/B18645_04_19.jpg)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
  zh: '![图4.19 – 使用作用域插槽显示的零食](img/B18645_04_19.jpg)'
- en: Figure 4.19 – Snacks displayed using a scoped slot
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.19 – 使用作用域插槽显示的零食
- en: And we have learned how scoped slots give components increased flexibility to
    delegate templating logic to consumers.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了作用域插槽如何使组件具有更大的灵活性，将模板逻辑委托给消费者。
- en: Now, let’s learn how to implement a card component with the help of these named
    slots.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何使用这些命名插槽来实现卡片组件。
- en: Exercise 4.04 – Implementing a card component using named slots
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.04 – 使用命名插槽实现卡片组件
- en: In this exercise, we will implement a card component using named slots. The
    card will have a title, image, and description sections. We will use slots to
    allow `title`, `image`, and `description` to be defined by a parent component.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用命名插槽实现一个卡片组件。该卡片将包含标题、图像和描述部分。我们将使用插槽允许父组件定义`title`、`image`和`description`。
- en: To access the code file for this exercise, refer to [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter04/Exercise4.04](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter04/Exercise4.04).
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问这个练习的代码文件，请参考[https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter04/Exercise4.04](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter04/Exercise4.04)。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成这个练习：
- en: 'Use the application generated with `npm init vue@3` as a starting point, or
    within the root folder of the code repository, navigate to the `Chapter04/Exercise4.04`
    folder using the following commands in order:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用由`npm init vue@3`生成的应用作为起点，或者在任何代码仓库的根目录下，使用以下命令导航到`Chapter04/Exercise4.04`文件夹：
- en: '[PRE161]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: Open the exercise project in your VS Code (by using the `code .` command within
    the project directory), or in your preferred IDE.
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的VS Code中打开练习项目（在项目目录中使用`code .`命令），或者在你的首选IDE中打开。
- en: 'We will start by creating a new `src/components/Card.vue` component that has
    a template that supports three named slots – `title`, `image`, and `description`:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先创建一个新的`src/components/Card.vue`组件，它有一个支持三个命名插槽的模板 – `title`、`image`和`description`：
- en: '[PRE163]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'We will then import our `Card.vue` component into the `script` section of a
    new `src/App.vue` file:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将把我们的`Card.vue`组件导入到新的`src/App.vue`文件的`script`部分：
- en: '[PRE170]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'We can now use `Card` in our `template`:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以在`template`中使用`Card`：
- en: '[PRE178]'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'Run the app, and the output will be as follows:'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用，输出将如下所示：
- en: '![Figure 4.20 – Card component with an image, title, and description](img/B18645_04_20.jpg)'
  id: totrans-449
  prefs: []
  type: TYPE_IMG
  zh: '![图4.20 – 包含图像、标题和描述的卡片组件](img/B18645_04_20.jpg)'
- en: Figure 4.20 – Card component with an image, title, and description
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.20 – 包含图像、标题和描述的卡片组件
- en: With that, we have learned how different types of slots can help to create more
    generic components. Slots allow child components to defer the rendering of certain
    parts of themselves to their parent component (consumer).
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经学习了不同类型的插槽如何帮助创建更通用的组件。插槽允许子组件将它们自身的某些部分渲染推迟到父组件（消费者）。
- en: As we learned, Vue provides an abstraction layer over the actual DOM. When it’s
    crucial to access the DOM’s elements directly, such as to integrate a DOM library,
    Vue provides a first-class way to do so with refs. We will learn about Vue references
    in the next section.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所学的，Vue在真实DOM之上提供了一个抽象层。当直接访问DOM元素至关重要时，例如集成DOM库，Vue通过refs提供了一种一等的方式来这样做。我们将在下一节学习Vue引用。
- en: Understanding Vue refs
  id: totrans-453
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Vue引用
- en: In Vue, **refs** are references to DOM elements or other component instances
    that have been mounted to the DOM.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vue 中，**引用**是对已挂载到 DOM 中的 DOM 元素或其他组件实例的引用。
- en: One of the major use cases for refs is direct DOM manipulation and integration
    with DOM-based libraries (that usually take a DOM node they should mount to),
    such as an animation library.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 引用的一大主要用例是直接 DOM 操作和与基于 DOM 的库（通常需要一个挂载到的 DOM 节点）的集成（例如动画库）。
- en: 'We define refs by using the syntax `ref="name"` on a native element or child
    component in the template. In the following example, we will add a reference to
    the input element under the name `theInput`:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在模板中的原生元素或子组件上使用 `ref="name"` 语法来定义引用。在下面的示例中，我们将向名为 `theInput` 的输入元素添加一个引用：
- en: '[PRE201]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: Refs can be accessed from the Vue component instance through `this.$refs[refName]`.
    So, in the preceding example, where we had a ref defined as `ref="theInput"`,
    it can be accessed through `this.$refs.theInput`.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过 `this.$refs[refName]` 从 Vue 组件实例中访问引用。因此，在前面的示例中，我们定义了一个 `ref="theInput"`，可以通过
    `this.$refs.theInput` 来访问。
- en: 'Now let’s programmatically focus on the `input` field when clicking the **Focus
    Input** button, as follows:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过编程方式在点击 **Focus Input** 按钮时聚焦到 `input` 字段，如下所示：
- en: '[PRE202]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'When clicking the **Focus Input** button, the input field will be focused,
    as shown in the following screenshot:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击 **Focus Input** 按钮时，输入字段将被聚焦，如下面的截图所示：
- en: '![Figure 4.21 – Input focused on a button click](img/B18645_04_21.jpg)'
  id: totrans-462
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.21 – 点击按钮聚焦输入](img/B18645_04_21.jpg)'
- en: Figure 4.21 – Input focused on a button click
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.21 – 点击按钮聚焦输入
- en: Note here that we can only access `$refs` once the component is mounted to the
    DOM. Hence `this.$refs.theInput` in our example is only available in the `mounted()`
    life cycle hook. Also, if you use `<script setup>`, there is no `$refs` available
    since there is no `this` and `setup` runs before the component instance is created.
    Hence to use DOM references with `<script setup>` or the setup hook, we use the
    `ref()` function from the Composition API instead, which we will discuss further
    in [*Chapter 5*](B18645_05.xhtml#_idTextAnchor193), *The* *Composition API*.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们只能在组件挂载到 DOM 后才能访问 `$refs`。因此，我们示例中的 `this.$refs.theInput` 只在 `mounted()`
    生命周期钩子中可用。另外，如果你使用 `<script setup>`，则没有 `$refs` 可用，因为没有 `this`，并且 `setup` 在组件实例创建之前运行。因此，为了使用
    `<script setup>` 或 setup 钩子中的 DOM 引用，我们使用 Composition API 中的 `ref()` 函数，我们将在 [*第
    5 章*](B18645_05.xhtml#_idTextAnchor193)，*Composition API* 中进一步讨论。
- en: We have learned how to use `$refs` to access the DOM elements from the component.
    When you need select a DOM node directly, we recommend you use a `ref` instead
    of using the DOM API (`querySelector`/`querySelectorAll`).
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何使用 `$refs` 从组件中访问 DOM 元素。当你需要直接选择一个 DOM 节点时，我们建议你使用 `ref` 而不是使用 DOM
    API (`querySelector`/`querySelectorAll`)。
- en: In the following exercise, we will learn how the `Countable` library helps increase
    interactivity in a project.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下练习中，我们将学习 `Countable` 库如何帮助提高项目的交互性。
- en: Exercise 4.05 – Wrapping Countable.js in Vue application
  id: totrans-467
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 4.05 – 在 Vue 应用程序中包装 Countable.js
- en: '`Countable` is a library that, given an element (usually an HTML `textarea`
    or input), will add live counts of paragraphs, words, and characters. Live metrics
    on the text being captured can be quite useful to increase interactivity in a
    project where editing text is a core concern.'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '`Countable` 是一个库，给定一个元素（通常是 HTML `textarea` 或输入），将为段落、单词和字符添加实时计数。对正在捕获的文本的实时度量可以非常有用，尤其是在编辑文本是核心关注点的项目中。'
- en: One of the large use cases of refs in Vue is to be able to integrate with libraries
    that act directly on the DOM.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 中引用的一个大型用例是能够与直接作用于 DOM 的库集成。
- en: In this exercise, we will create a component with paragraph/word/character-counting
    functionality for content in a `textarea` by using `Countable.js` and Vue refs.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用 `Countable.js` 和 Vue 引用创建一个具有段落/单词/字符计数功能的组件，用于 `textarea` 中的内容。
- en: To access the code file for this exercise, refer to [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter04/Exercise4.05](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter04/Exercise4.05).
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此练习的代码文件，请参阅 [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter04/Exercise4.05](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter04/Exercise4.05)。
- en: 'Work through the following steps to complete this exercise:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此练习：
- en: 'Use the application generated with `npm init vue@3` as a starting point, or
    within the root folder of the code repository, navigate to the `Chapter04/Exercise4.05`
    folder using the following commands in order:'
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用由`npm init vue@3`生成的应用程序作为起点，或者在你的代码仓库的根目录下，使用以下命令导航到`Chapter04/Exercise4.05`文件夹：
- en: '[PRE203]'
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE204]'
- en: Open the exercise project in VS Code (using the `code .` command within the
    project directory), or in your preferred IDE.
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中打开练习项目（在项目目录中使用`code .`命令），或者在你的首选IDE中打开。
- en: 'Create a new `src/components/TextEditorWithCount.vue` component with a `textarea`
    that we will have a `ref` to:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`src/components/TextEditorWithCount.vue`组件，其中包含一个我们将有`ref`的`textarea`：
- en: '[PRE205]'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-485
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE214]'
- en: 'Next, we will import and render the component in `src/App.vue`:'
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将导入并渲染`src/App.vue`中的组件：
- en: '[PRE215]'
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-493
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-495
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-500
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-501
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE228]'
- en: 'The application renders a `textarea` field, as follows:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序渲染了一个`textarea`字段，如下所示：
- en: '![Figure 4.22 – A bare textarea field, as rendered by the application](img/B18645_04_22.jpg)'
  id: totrans-504
  prefs: []
  type: TYPE_IMG
  zh: '![图4.22 – 应用程序渲染的裸`textarea`字段](img/B18645_04_22.jpg)'
- en: Figure 4.22 – A bare textarea field, as rendered by the application
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.22 – 应用程序渲染的裸`textarea`字段
- en: 'We now need to integrate `Countable`. We will import it and initialize it with
    `this.$refs.textArea`. We will also store the counts on the instance as `this.count`:'
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要集成`Countable`。我们将导入它并使用`this.$refs.textArea`进行初始化。我们还将把计数值存储在实例上作为`this.count`：
- en: '[PRE229]'
  id: totrans-507
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-509
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-510
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-511
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-512
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-513
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-514
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-515
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-516
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-517
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-518
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-519
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-520
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-521
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE243]'
- en: 'With a small update to `template`, we can display the counts we care about:'
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过对`template`进行少量更新，我们可以显示我们关心的计数值：
- en: '[PRE244]'
  id: totrans-523
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-524
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-525
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-526
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-527
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-528
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-529
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-530
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-531
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-532
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE253]'
- en: 'Now, we can see the counts set to `0` when `textarea` is empty, as follows:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到当`textarea`为空时计数值被设置为`0`，如下所示：
- en: '![Figure 4.23 – textarea with counts set to 0 when empty](img/B18645_04_23.jpg)'
  id: totrans-534
  prefs: []
  type: TYPE_IMG
  zh: '![图4.23 – 当空时计数值设置为0的`textarea`](img/B18645_04_23.jpg)'
- en: Figure 4.23 – textarea with counts set to 0 when empty
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.23 – 当空时计数值设置为0的`textarea`
- en: 'If we drop some *Lorem ipsum* filler text into our `textarea`, the counts will
    update accordingly, as follows:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在`textarea`中放入一些`Lorem ipsum`填充文本，计数值将相应更新，如下所示：
- en: '![Figure 4.24 – textarea with counts updated when filled](img/B18645_04_24.jpg)'
  id: totrans-537
  prefs: []
  type: TYPE_IMG
  zh: '![图4.24 – 当填充时更新计数的`textarea`](img/B18645_04_24.jpg)'
- en: Figure 4.24 – textarea with counts updated when filled
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.24 – 当填充时更新计数的`textarea`
- en: 'One last thing we need to do is remove the `Countable` event listener when
    the component is unmounted:'
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一件我们需要做的是，当组件卸载时移除`Countable`事件监听器：
- en: '[PRE254]'
  id: totrans-540
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-541
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-542
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-543
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-544
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-545
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-546
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-547
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-548
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-549
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-550
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-551
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-552
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-553
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE267]'
- en: This integration of a JavaScript/DOM library inside a Vue app is a key application
    of Vue refs. Refs allow us to pick from the existing ecosystem of libraries and
    wrap or integrate them into a component.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vue应用内部集成JavaScript/DOM库是Vue refs的关键应用。Refs允许我们从现有的生态系统中选择库并将它们包装或集成到组件中。
- en: Vue refs are useful for integrating DOM libraries or for accessing DOM APIs
    directly.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: Vue refs对于集成DOM库或直接访问DOM API非常有用。
- en: To round off our examination of component composition, we need to know how to
    pass data from child components back to their parents, which we will explore next.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束我们对组件组合的考察，我们需要了解如何从子组件向父组件传递数据，这将在下一节中探讨。
- en: Using events for child-parent communication
  id: totrans-557
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用事件进行子父通信
- en: We have already seen that props are used to pass data from a parent component
    to a child component. To pass data from a child component back to a parent component,
    Vue offers custom events.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到props用于从父组件向子组件传递数据。要从子组件向父组件传递数据，Vue提供了自定义事件。
- en: In a component, we can emit an event using the `$emit` method; with `this.$emit('eventName',
    payload)` within `<script>`; or just with `$emit` within the `template` section.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件中，我们可以使用`$emit`方法发出事件；在`<script>`中使用`this.$emit('eventName', payload)`；或者在`template`部分仅使用`$emit`。
- en: 'Assuming we have got a reactive instance property, `this.message`, we could
    emit a `send` event with the `message` value in the `script` section using `this.$emit`.
    This could be the basis for a `MessageEditor` component:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个响应式实例属性`this.message`，我们可以在`script`部分使用`this.$emit`发出一个带有`message`值的`send`事件。这可能是`MessageEditor`组件的基础：
- en: '[PRE268]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: 'In the same scenario, we could trigger a `send` event from the `template` section
    as follows:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 在相同的场景中，我们也可以从`template`部分触发一个`send`事件，如下所示：
- en: '[PRE269]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: From a parent component, we can use `v-on:event-name` or the shorthand `@event-name`.
    `event-name` must match the name passed to `$emit`. Note `eventName` and `event-name`
    are not equivalent.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 从父组件中，我们可以使用`v-on:event-name`或简写`@event-name`。`event-name`必须与传递给`$emit`的名称匹配。注意`eventName`和`event-name`不是等效的。
- en: For instance, in the parent component we want to listen to the `send` event
    and modify some data accordingly. We bind `@send` with some event handler logic,
    which can be a JavaScript expression or a method declared using `methods`.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在父组件中，我们希望监听 `send` 事件并根据需要修改一些数据。我们将 `@send` 绑定到一些事件处理逻辑上，这可以是一个 JavaScript
    表达式或使用 `methods` 声明的方法。
- en: 'Vue will trigger this event handler and pass the event’s payload object to
    it when applicable. You can use `$event` in the JavaScript expression of the template
    as the payload, as shown in the following example of the `template` section in
    `App`:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 当适用时，Vue 将触发此事件处理程序，并将事件的有效负载对象传递给它。你可以在模板的 JavaScript 表达式中使用 `$event` 作为有效负载，如下所示
    `App` 中的 `template` 部分的以下示例：
- en: '[PRE270]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: 'We can also extract the JavaScript expression to a component’s `updateParentMessage`
    method and bind it as follows:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将 JavaScript 表达式提取到组件的 `updateParentMessage` 方法中，并按如下方式绑定：
- en: '[PRE271]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: 'Using either approach yields the same result. The full app should look as follows
    in the browser:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 使用任何一种方法都会得到相同的结果。在浏览器中，完整的应用程序应如下所示：
- en: '![Figure 4.25 – Hello World! message being emitted from child-parent](img/B18645_04_25.jpg)'
  id: totrans-571
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.25 – 从子组件到父组件发出的“Hello World!”消息](img/B18645_04_25.jpg)'
- en: Figure 4.25 – Hello World! message being emitted from child-parent
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.25 – 从子组件到父组件发出的“Hello World!”消息
- en: Custom events support passing any JavaScript type as the payload. The event
    name, however, must be a `String`.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义事件支持将任何 JavaScript 类型作为负载传递。然而，事件名必须是一个 `String`。
- en: Registering events with <script setup> (or setup hook)
  id: totrans-574
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `<script setup>` (或 setup 钩子) 注册事件
- en: If you use `<script setup>`, since there is no component’s options object, we
    can’t define custom events using the `emits` field. Instead, we use the `defineEmits()`
    function from the `vue` package and pass all the relevant events’ definitions
    to it.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 `<script setup>`，由于没有组件的选项对象，我们无法使用 `emits` 字段来定义自定义事件。相反，我们使用 `vue` 包中的
    `defineEmits()` 函数，并将所有相关事件定义传递给它。
- en: 'For example, in the `MessageEditor` component, we can rewrite the event-registering
    functionality with `defineEmits()` as follows:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 `MessageEditor` 组件中，我们可以使用 `defineEmits()` 重新编写事件注册功能，如下所示：
- en: '[PRE272]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '`defineEmits()` returns a function that we can trigger in the same concept
    with `this.$emits`. We will certainly need to use `ref()` to declare a reactive
    data `message` for this component, the usage of which we will discuss further
    in [*Chapter 5*](B18645_05.xhtml#_idTextAnchor193), *The* *Composition API*.'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '`defineEmits()` 返回一个函数，我们可以使用 `this.$emits` 在相同的概念下触发它。我们肯定需要使用 `ref()` 来声明一个响应式数据
    `message`，对此组件的使用我们将在[*第 5 章*](B18645_05.xhtml#_idTextAnchor193)，“*组合 API*”中进一步讨论。'
- en: Now, let’s complete an activity based on everything we’ve learned so far.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们根据到目前为止所学的一切来完成一个活动。
- en: Activity 4.01 – A local message view with reusable components
  id: totrans-580
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 4.01 – 带有可重用组件的本地消息视图
- en: To access the code file for this activity, refer to [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter04/Activity4.01](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter04/Activity4.01)
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此活动的代码文件，请参阅 [https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter04/Activity4.01](https://github.com/PacktPublishing/Frontend-Development-Projects-with-Vue.js-3/tree/v2-edition/Chapter04/Activity4.01)
- en: This activity aims to leverage components, props, events, and refs to render
    a chat interface where the user can add messages and have them displayed.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动旨在利用组件、props、事件和refs来渲染一个聊天界面，用户可以添加消息并显示它们。
- en: 'Follow these steps to complete this activity:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此活动：
- en: Create a `MessageEditor` component (in `src/components/MessageEditor.vue`) that
    displays a `textarea` field to the user.
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `MessageEditor` 组件（在 `src/components/MessageEditor.vue` 中），该组件向用户显示一个 `textarea`
    字段。
- en: Add a `message` reactive instance variable to `MessageEditor`, defaulted to
    `''`.
  id: totrans-585
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MessageEditor` 中添加一个名为 `message` 的响应式实例变量，默认值为 `''`。
- en: Listen to `change` events for `textarea` and set the value of `message` to the
    value of the content of `textarea` (it is exposed as the value of the event).
  id: totrans-586
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 监听 `textarea` 的 `change` 事件，并将 `message` 的值设置为 `textarea` 内容的值（它作为事件的值暴露）。
- en: Add a `Send` button that, on `click`, emits a `send` event with `message` as
    the payload.
  id: totrans-587
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个“发送”按钮，当点击时，会发出一个带有“message”作为负载的“send”事件。
- en: Add a `main` component to `src/App.vue` that renders `MessageEditor`.
  id: totrans-588
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/App.vue` 中添加一个 `main` 组件，用于渲染 `MessageEditor`。
- en: In `App`, listen to `send` events from `MessageEditor` and store each message
    in a `messages` reactive data variable (`messages` is an array).
  id: totrans-589
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `App` 中监听来自 `MessageEditor` 的 `send` 事件，并将每条消息存储在 `messages` 响应式数据变量中（`messages`
    是一个数组）。
- en: Create a `MessageFeed` (in `src/components/MessageFeed.vue`) that has a required
    `messages` prop, which is an array.
  id: totrans-590
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `MessageFeed`（在 `src/components/MessageFeed.vue` 中），它有一个必需的 `messages`
    prop，它是一个数组。
- en: In `MessageFeed`, render each passed message from the `messages` prop in a paragraph
    (the `p` element).
  id: totrans-591
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MessageFeed` 中，将 `messages` prop 传递的每个消息在段落（`p` 元素）中渲染。
- en: Import and render `MessageFeed` into `App`, binding the `messages` app instance
    variable as the `messages` prop of `MessageFeed`.
  id: totrans-592
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `MessageFeed` 导入并渲染到 `App` 中，将 `messages` 应用实例变量绑定为 `MessageFeed` 的 `messages`
    prop。
- en: Improve `MessageEditor` so that the message is reset and focused after the message
    is sent. To do this, we will need to set `textarea.value` using a ref, reset the
    `message` instance variable accordingly, and use `textarea.focus()` to focus on
    `textarea` programmatically.
  id: totrans-593
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 改进 `MessageEditor`，以便在消息发送后重置并聚焦消息。为此，我们需要使用 ref 设置 `textarea.value`，相应地重置 `message`
    实例变量，并使用 `textarea.focus()` 以编程方式聚焦到 `textarea`。
- en: Note
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The easier way to reset `textarea` would have been to use `v-model="message"`
    in the first place instead of binding `@change` and manually syncing `textarea.value`
    to `message`.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 重置 `textarea` 的更简单的方法一开始就使用 `v-model="message"` 而不是绑定 `@change` 并手动同步 `textarea.value`
    到 `message`。
- en: 'The expected output is as follows:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的输出如下：
- en: '![Figure 4.26 – Message app with Hello World! and Hello JavaScript! sent](img/B18645_04_26.jpg)'
  id: totrans-597
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.26 – 发送了 Hello World! 和 Hello JavaScript! 的消息应用](img/B18645_04_26.jpg)'
- en: Figure 4.26 – Message app with Hello World! and Hello JavaScript! sent
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.26 – 发送了 Hello World! 和 Hello JavaScript! 的消息应用
- en: Summary
  id: totrans-599
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Throughout this chapter, we have explored how to enable data communication between
    components using props and custom events. We explored slots and saw how we enable
    UI template customization for a component from its parent. We also learned how
    to use refs to unlock integration opportunities with third-party JavaScript or
    DOM libraries by allowing us to access DOM elements directly.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何使用 props 和自定义事件启用组件之间的数据通信。我们探讨了 slots，并看到了如何从其父组件中启用组件的 UI 模板定制。我们还学习了如何使用
    refs 通过直接访问 DOM 元素来解锁与第三方 JavaScript 或 DOM 库的集成机会。
- en: We’re now able to create and compose components that clearly define their interfaces
    with inputs (props and slots) and outputs (rendered templates and events), while
    also visiting commonly faced use cases (such as wrapping a DOM library).
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在能够创建和组合组件，这些组件通过输入（props 和 slots）和输出（渲染的模板和事件）清楚地定义了它们的接口，同时访问常见的用例（例如包装
    DOM 库）。
- en: In the next chapter, we’ll look at advanced component composition patterns and
    techniques that enable better code reuse.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨高级组件组合模式和技巧，这些模式和技巧能够实现更好的代码重用。
