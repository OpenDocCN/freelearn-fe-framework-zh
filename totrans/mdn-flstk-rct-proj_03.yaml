- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Getting to Know Node.js and MongoDB
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解 Node.js 和 MongoDB
- en: In the previous chapter, we set up our IDE and a basic project for frontend
    development. In this chapter, we will first learn how to write and run scripts
    with Node.js. Then, we will move on to introducing Docker as a way to set up a
    database service. Once we have set up Docker and a container for our database,
    we are going to access it to learn more about MongoDB, the document database that
    we will use going forward. Finally, we will connect everything we have learned
    in this chapter by accessing MongoDB via Node.js scripts.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们设置了我们的 IDE 和一个基本的前端开发项目。在本章中，我们将首先学习如何使用 Node.js 编写和运行脚本。然后，我们将介绍 Docker
    作为设置数据库服务的一种方式。一旦我们设置了 Docker 和数据库的容器，我们将访问它以了解更多关于 MongoDB 的信息，这是我们接下来将要使用的文档数据库。最后，我们将通过通过
    Node.js 脚本访问 MongoDB 来连接本章所学的一切。
- en: By the end of this chapter, you will have an understanding of the most important
    tools and concepts in backend development with JavaScript. This chapter gives
    us a good foundation to create a backend service for our first full-stack application
    in the upcoming chapters.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解使用 JavaScript 进行后端开发中最重要工具和概念。本章为我们提供了一个良好的基础，以便在接下来的章节中为我们的第一个全栈应用创建后端服务。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Writing and running scripts with Node.js
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Node.js 编写和运行脚本
- en: Introducing Docker, a platform for containers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Docker，一个容器平台
- en: Introducing MongoDB, a document database
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 MongoDB，一个文档数据库
- en: Accessing the MongoDB database via Node.js
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 Node.js 访问 MongoDB 数据库
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Before we start, please install the following (in addition to all technical
    requirements from [*Chapter 1*](B19385_01.xhtml#_idTextAnchor016), *Preparing
    for Full-stack Development*), if you do not already have them installed:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，请安装以下内容（除了来自 [*第 1 章*](B19385_01.xhtml#_idTextAnchor016)，*为全栈开发做准备*）的所有技术要求，如果您还没有安装它们：
- en: Docker v24.0.6
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker v24.0.6
- en: Docker Desktop v4.25.2
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Desktop v4.25.2
- en: MongoDB Shell v2.1.0
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB Shell v2.1.0
- en: The versions listed are the ones used in the book. While installing a newer
    version should not be an issue, please note that certain steps might work differently
    on a newer version. If you are having an issue with the code and steps provided
    in this book, please try using the mentioned versions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 列出的版本是本书中使用的版本。虽然安装较新版本不应有问题，但请注意，某些步骤在较新版本上可能有所不同。如果您在本书中提供的代码和步骤遇到问题，请尝试使用提到的版本。
- en: 'You can find the code for this chapter on GitHub: [https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch2](https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch2).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 上找到本章的代码：[https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch2](https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch2).
- en: 'The CiA video for this chapter can be found at: [https://youtu.be/q_LHsdJEaPo](https://youtu.be/q_LHsdJEaPo).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的 CiA 视频可以在：[https://youtu.be/q_LHsdJEaPo](https://youtu.be/q_LHsdJEaPo) 找到。
- en: Important
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 重要
- en: If you cloned the full repository for the book, Husky may not find the **.git**
    directory when running **npm install**. In that case, just run **git init** in
    the root of the corresponding chapter folder.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您克隆了本书的完整仓库，当运行 **npm install** 时，Husky 可能找不到 **.git** 目录。在这种情况下，只需在相应章节文件夹的根目录下运行
    **git init**。
- en: Writing and running scripts with Node.js
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Node.js 编写和运行脚本
- en: For us to become full-stack developers, it is important to get familiar with
    backend technologies. As we are already familiar with JavaScript from writing
    frontend applications, we can use Node.js to develop backend services using JavaScript.
    In this section, we are going to create our first simple Node.js script to get
    familiar with the differences between backend scripts and frontend code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成为全栈开发者，熟悉后端技术非常重要。因为我们已经熟悉了从编写前端应用中使用的 JavaScript，我们可以使用 Node.js 来用 JavaScript
    开发后端服务。在本节中，我们将创建第一个简单的 Node.js 脚本，以便熟悉后端脚本和前端代码之间的区别。
- en: Similarities and differences between JavaScript in the browser and in Node.js
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浏览器中的 JavaScript 和 Node.js 之间的相似之处和不同之处
- en: Node.js is built on V8, the JavaScript engine used by Chromium-based browsers
    (Google Chrome, Brave, Opera, Vivaldi, and Microsoft Edge). As such, JavaScript
    code will run the same way in the browser and Node.js. However, there are some
    differences, specifically in the environment. The environment is built on top
    of the engine and allows us to render something on a website in the browser (using
    the `document` and `window` objects). In Node.js, there are certain modules provided
    to interface with the operating system, for tasks such as creating files and handling
    network requests. These modules allow us to create a backend service using Node.js.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 是基于 V8 构建的，这是基于 Chromium 的浏览器（Google Chrome、Brave、Opera、Vivaldi 和 Microsoft
    Edge）使用的 JavaScript 引擎。因此，JavaScript 代码在浏览器和 Node.js 中将以相同的方式运行。然而，有一些差异，特别是在环境方面。环境建立在引擎之上，并允许我们在浏览器中渲染某些内容（使用
    `document` 和 `window` 对象）。在 Node.js 中，有一些模块提供与操作系统接口，用于创建文件和处理网络请求等任务。这些模块允许我们使用
    Node.js 创建后端服务。
- en: 'Let’s have a look at the Node.js architecture versus JavaScript in the browser:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 Node.js 架构与浏览器中 JavaScript 的对比：
- en: '![Figure 2.1 – The Node.js architecture versus JavaScript in the browser](img/B19385_02_1.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – Node.js 架构与浏览器中 JavaScript 的对比](img/B19385_02_1.jpg)'
- en: Figure 2.1 – The Node.js architecture versus JavaScript in the browser
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – Node.js 架构与浏览器中 JavaScript 的对比
- en: As we can see from the visualization, both Node.js and browser JavaScript run
    on a JavaScript engine, which is always V8 in Node.js, and can be V8 for Chromium-based
    browsers, SpiderMonkey for Firefox, or JavaScriptCore for Safari.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '从可视化中我们可以看出，Node.js 和浏览器 JavaScript 都运行在 JavaScript 引擎上，在 Node.js 中总是 V8，对于基于
    Chromium 的浏览器可以是 V8，Firefox 中的 SpiderMonkey，或 Safari 中的 JavaScriptCore。 '
- en: Now that we know that we can run JavaScript code in Node.js, let’s try it out!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们可以在 Node.js 中运行 JavaScript 代码，让我们试试看！
- en: Creating our first Node.js script
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的第一个 Node.js 脚本
- en: 'Before we can start writing backend services, we need to get familiar with
    the Node.js environment. So, let’s start by writing a simple “hello world” example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写后端服务之前，我们需要熟悉 Node.js 环境。因此，让我们先写一个简单的“hello world”示例：
- en: 'Copy the **ch1** folder from the previous chapter to a new **ch2** folder,
    as follows:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将上一章的 **ch1** 文件夹复制到新的 **ch2** 文件夹中，如下所示：
- en: '[PRE0]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: On macOS, it is important to run the command with a capitalized **-R** flag,
    not **-r**. The **-r** flag deals differently with symlinks and causes the **node_modules/**
    folder to break. The **-r** flag only exists for historic reasons and should not
    be used on macOS. Always prefer using the **-R** flag instead.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 上，运行命令时需要使用大写的 **-R** 标志，而不是 **-r**。**-r** 标志对符号链接的处理方式不同，会导致 **node_modules/**
    文件夹损坏。**-r** 标志仅出于历史原因存在，不应在 macOS 上使用。始终优先使用 **-R** 标志。
- en: Open the new **ch2** folder in VS Code.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中打开新的 **ch2** 文件夹。
- en: Create a new **backend** folder in the **ch2** folder. This will contain our
    backend code.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **ch2** 文件夹中创建一个新的 **backend** 文件夹。这将包含我们的后端代码。
- en: 'In the **backend** folder, create a **helloworld.js** file and enter the following
    code:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **backend** 文件夹中创建一个 **helloworld.js** 文件，并输入以下代码：
- en: '[PRE1]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Open a Terminal in the **ch2** folder and run the following command to execute
    the Node.js script:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **ch2** 文件夹中打开一个终端，并运行以下命令来执行 Node.js 脚本：
- en: '[PRE2]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You will see that the console output shows `hello node.js world!`. When writing
    Node.js code, we can make use of familiar functions from the frontend JavaScript
    world and run the same JavaScript code on the backend!
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到控制台输出显示 `hello node.js world!`。在编写 Node.js 代码时，我们可以利用前端 JavaScript 世界中熟悉的函数，并在后端运行相同的
    JavaScript 代码！
- en: Note
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: While most frontend JavaScript code will run just fine in Node.js, not all code
    from the frontend will automatically work in a Node.js environment. There are
    certain objects, such as **document** and **window**, that are specific to a browser
    environment. This is important to keep in mind, especially when we introduce server-side
    rendering later.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数前端 JavaScript 代码在 Node.js 中运行良好，但并非所有前端代码都能在 Node.js 环境中自动运行。有一些对象，如 **document**
    和 **window**，是特定于浏览器环境的。这一点需要记住，尤其是在我们后面介绍服务器端渲染时。
- en: Now that we have a basic understanding of how Node.js works, let’s get started
    handling files with Node.js.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对 Node.js 的工作原理有了基本的了解，让我们开始用 Node.js 处理文件。
- en: Handling files in Node.js
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Node.js 中处理文件
- en: Unlike in the browser environment, Node.js provides functions to handle files
    on our computer via the `node:fs` (filesystem) module. For example, we could make
    use of this functionality to read and write various files or even use files as
    a simple database.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 与浏览器环境不同，Node.js 通过 `node:fs`（文件系统）模块提供了处理我们计算机上文件的功能。例如，我们可以利用这个功能来读取和写入各种文件，甚至可以将文件用作简单的数据库。
- en: 'Follow these steps to create your first Node.js script that handles files:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建你的第一个处理文件的 Node.js 脚本：
- en: Create a new **backend/files.js** file.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **backend/files.js** 文件。
- en: Import the **writeFileSync** and **readFileSync** functions from the **node:fs**
    internal Node.js module. This module does not need to be installed via npm, as
    it is provided by the Node.js runtime.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **node:fs** 内部 Node.js 模块导入 **writeFileSync** 和 **readFileSync** 函数。这个模块不需要通过
    npm 安装，因为它是由 Node.js 运行时提供的。
- en: '[PRE3]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create a simple array containing users, with a name and email address:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含用户信息的简单数组，包括姓名和电子邮件地址：
- en: '[PRE4]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Before we can save this array to a file, we first need to convert it to a string
    by using **JSON.stringify**:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们能够将这个数组保存到文件之前，我们首先需要使用 **JSON.stringify** 将它转换成一个字符串：
- en: '[PRE5]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now we can save our JSON string to a file by using the **writeFileSync** function.
    This function takes two arguments – first the filename, then the string to be
    written to the file:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以通过使用 **writeFileSync** 函数将我们的 JSON 字符串保存到文件中。这个函数接受两个参数——首先是要写入的文件名，然后是要写入文件中的字符串：
- en: '[PRE6]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After writing to the file, we can attempt reading it again using **readFileSync**
    and parsing the JSON string using **JSON.parse**:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在写入文件后，我们可以尝试再次使用 **readFileSync** 读取它，并使用 **JSON.parse** 解析 JSON 字符串：
- en: '[PRE7]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, we log the parsed array:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们打印出解析后的数组：
- en: '[PRE8]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now we can run our script. You will see that the array gets logged and a **users.json**
    file was created in our **backend/** folder:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以运行我们的脚本了。你会看到数组被打印出来，并且在我们的 **backend/** 文件夹中创建了一个 **users.json** 文件：
- en: '[PRE9]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You may have noticed that we have been using `writeFileSync`, and not `writeFile`.
    The default behavior in Node.js is to run everything asynchronously, which means
    that if we used `writeFile`, the file may not have been created yet at the time
    when we called `readFile`, as asynchronous code is not executed in order.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们一直在使用 `writeFileSync`，而不是 `writeFile`。在 Node.js 中，默认的行为是异步运行所有操作，这意味着如果我们使用
    `writeFile`，在调用 `readFile` 时文件可能还没有被创建，因为异步代码不是按顺序执行的。
- en: This behavior might be annoying when writing simple scripts like we did, but
    is very useful when dealing with, for example, network requests, where we do not
    want to block other users from accessing our service while dealing with another
    request.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写像我们这样的简单脚本时，这种行为可能会让人烦恼，但当处理例如网络请求时，它非常有用，我们不想在处理另一个请求时阻塞其他用户访问我们的服务。
- en: After learning about handling files with Node.js, let’s learn more about how
    asynchronous code is executed in the browser and Node.js.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了如何使用 Node.js 处理文件之后，让我们再来了解一下在浏览器和 Node.js 中异步代码是如何执行的。
- en: Concurrency with JavaScript in the browser and Node.js
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浏览器和 Node.js 中的 JavaScript 并发
- en: An essential and special trait of JavaScript is that most API functions are
    asynchronous by default. This means that code does not simply run in the sequence
    in which it is defined. Specifically, JavaScript is event-driven. In the browser,
    this means that JavaScript code will run because of user interactions. For example,
    when a button is clicked, we define an `onClick` handler to execute some code.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的一个基本且特殊的特性是，大多数 API 函数默认都是异步的。这意味着代码不会简单地按照定义的顺序执行。具体来说，JavaScript
    是事件驱动的。在浏览器中，这意味着 JavaScript 代码会因为用户交互而运行。例如，当按钮被点击时，我们定义一个 `onClick` 处理器来执行一些代码。
- en: On the server side, input/output operations, such as reading and writing files,
    and network requests, are handled asynchronously. This means that we can handle
    multiple network requests at once, without having to deal with threads or multiprocessing
    ourselves. Specifically, in Node.js, `libuv` is responsible for assigning threads
    for I/O operations while giving us, as a programmer, access to a single runtime
    thread to write our code in. However, this does not mean that each connection
    to our backend will create a new thread. Threads are created on the fly when advantageous.
    As a developer, we do not have to deal with multi-threading and can focus on developing
    with asynchronous code and callbacks.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，输入/输出操作，如读写文件和网络请求，是异步处理的。这意味着我们可以同时处理多个网络请求，而无需自己处理线程或多进程。具体来说，在Node.js中，`libuv`负责为I/O操作分配线程，同时给我们，作为程序员，提供一个单独的运行时线程来编写我们的代码。然而，这并不意味着每个连接到我们后端都会创建一个新的线程。当有利时，线程会动态创建。作为开发者，我们不需要处理多线程，可以专注于使用异步代码和回调进行开发。
- en: If code is synchronous, it is executed directly by putting it on the `onClick`
    listener in the browser – when the user clicks the related element, the callback
    will also be put in the task queue, which means it will be executed when nothing
    else is left on the stack. Similarly, in Node.js, we can add listeners for network
    events, and execute a callback when a request comes in.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码是同步的，它将通过在浏览器中的`onClick`监听器上直接放置代码来执行 – 当用户点击相关元素时，回调函数也将放入任务队列，这意味着它将在栈上没有其他内容时执行。同样，在Node.js中，我们可以添加网络事件的监听器，并在收到请求时执行回调。
- en: In contrast to multi-threaded servers, a Node.js server accepts all requests
    in a single thread, which contains the event loop. Multi-threaded servers have
    the disadvantage that threads can block I/O completely and slow down the server.
    Node.js, however, delegates operations in a fine-grained way on the fly to threads.
    This results in less blocking of I/O operations by default. The downside with
    Node.js is that we have less control over how the multi-threading happens and
    thus need to be careful to avoid using synchronous functions whenever possible.
    Otherwise, we will block the main Node.js thread and slow down our server. For
    simplicity, we still use synchronous functions in this chapter. Going forward,
    in the next chapters, we will avoid using those and rely solely on asynchronous
    functions (when possible) to get the best performance.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 与多线程服务器相比，Node.js服务器在一个包含事件循环的单线程中接受所有请求。多线程服务器的缺点是线程可以完全阻塞I/O并减慢服务器。然而，Node.js默认情况下以细粒度方式动态地将操作委托给线程。这导致I/O操作阻塞更少。Node.js的缺点是我们对多线程的控制较少，因此需要尽可能避免使用同步函数。否则，我们将阻塞主Node.js线程并减慢我们的服务器。为了简单起见，我们在这章中仍然使用同步函数。从现在开始，在下一章中，我们将避免使用这些函数，并完全依赖异步函数（在可能的情况下）以获得最佳性能。
- en: 'The following diagram visualizes the difference between multi-threaded servers
    and a Node.js server:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了多线程服务器与Node.js服务器的区别：
- en: '![Figure 2.2 – The difference between multi-threaded servers and a Node.js
    server](img/B19385_02_2.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – 多线程服务器与Node.js服务器的区别](img/B19385_02_2.jpg)'
- en: Figure 2.2 – The difference between multi-threaded servers and a Node.js server
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – 多线程服务器与Node.js服务器的区别
- en: 'We can see this asynchrony in action by using `setTimeout`, a function that
    you may be familiar with from frontend code. It waits a specified number of milliseconds
    and then executes the code specified in the callback function. For example, if
    we run the following code (with a Node.js script or in the browser, the result
    is the same for both):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`setTimeout`函数来观察这种异步行为，这是一个你可能从前端代码中熟悉的函数。它等待指定数量的毫秒，然后执行回调函数中指定的代码。例如，如果我们运行以下代码（无论是使用Node.js脚本还是在浏览器中，两者的结果都是相同的）：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can see that they get printed in the following order:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到它们按照以下顺序打印出来：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This makes sense, because we are delaying the “second” `console.log` by a second.
    However, the same output will happen if we execute the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有意义的，因为我们通过延迟“第二个”`console.log`一秒钟。然而，如果我们执行以下代码，也会得到相同的结果：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now that we are waiting zero milliseconds before executing the code, you would
    think that “second” gets printed after “first.” However, that is not the case.
    Instead, we get the same output as before:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们等待零毫秒后执行代码，你可能会认为“第二个”会在“第一个”之后打印出来。然而，情况并非如此。相反，我们得到了与之前相同的输出：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The reason is that when we use `setTimeout`, the JavaScript engine calls either
    a web API (on the browser) or a native API (on Node.js). This API runs in native
    code in the engine, tracks the timeout internally, and puts the callback into
    the task queue, because the timer completes right away. While this is happening,
    the JavaScript engine continues processing the other code by pushing it onto the
    stack and executing it. When the stack is empty (there is no more code to execute),
    the event loop advances. It sees that there is something in the task queue, so
    it executes that code, resulting in “second” being printed last.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是当我们使用 `setTimeout` 时，JavaScript 引擎会调用 Web API（在浏览器上）或原生 API（在 Node.js 上）。这个
    API 在引擎的本地代码中运行，内部跟踪超时，并将回调放入任务队列，因为计时器立即完成。当这个过程中发生时，JavaScript 引擎继续通过将其推入栈中并执行它来处理其他代码。当栈为空（没有更多的代码要执行）时，事件循环前进。它看到任务队列中有东西，因此执行那个代码，导致最后打印出“second”。
- en: Tip
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'You can use the Loupe tool to visualize the inner workings of the Call Stack,
    web APIs, Event Loop, and Callback/Task Queue: [http://latentflip.com/loupe/](http://latentflip.com/loupe/)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 Loupe 工具来可视化调用栈、Web API、事件循环和回调/任务队列的内部工作原理：[http://latentflip.com/loupe/](http://latentflip.com/loupe/)
- en: Now that we have learned how asynchronous code is handled in the browser and
    Node.js, let’s create our first web server with Node.js!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了在浏览器和 Node.js 中如何处理异步代码，让我们使用 Node.js 创建我们的第一个 Web 服务器！
- en: Creating our first web server
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的第一个 Web 服务器
- en: 'Now that we have learned the basics of how Node.js works, we can use the `node:http`
    library to create a simple web server. For our first simple server, we are just
    going to return a **200 OK** response and some plain text on any request. Let’s
    get started with the steps:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Node.js 的工作原理的基础，我们可以使用 `node:http` 库来创建一个简单的 Web 服务器。对于我们的第一个简单服务器，我们将只对任何请求返回一个
    **200 OK** 响应和一些纯文本。让我们开始以下步骤：
- en: 'Create a new **backend/simpleweb.js** file, open it, and import the **createServer**
    function from the **node:http** module:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **backend/simpleweb.js** 文件，打开它，并从 **node:http** 模块导入 **createServer**
    函数：
- en: '[PRE14]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The **createServer** function is asynchronous, so it requires us to pass a
    callback function to it. This function will be executed when a request comes in
    from the server. It has two arguments, a request object (**req**) and a response
    object (**res**). Use the **createServer** function to define a new server:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**createServer** 函数是异步的，因此我们需要向它传递一个回调函数。当服务器收到请求时，这个函数将被执行。它有两个参数，一个请求对象（**req**）和一个响应对象（**res**）。使用
    **createServer** 函数定义一个新的服务器：'
- en: '[PRE15]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For now, we will ignore the request object and only return a static response.
    First, we set the status code to **200**:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将忽略请求对象，只返回一个静态响应。首先，我们将状态码设置为 **200**：
- en: '[PRE16]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, we set the **Content-Type** header to **text/plain**, such that the browser
    knows what kind of response data it is dealing with:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将 **Content-Type** 标头设置为 **text/plain**，这样浏览器就知道它正在处理什么类型的响应数据：
- en: '[PRE17]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Lastly, we end the request by returning a **Hello HTTP world!** string in the
    response:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们通过在响应中返回一个 **Hello HTTP world!** 字符串来结束请求：
- en: '[PRE18]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After defining the server, we need to make sure to listen on a certain host
    and port. These will define where the server will be available. For now, we use
    localhost on port **3000** to make sure our server is available via **http://localhost:3000/**:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在定义服务器后，我们需要确保在特定的主机和端口上监听。这些将定义服务器将在哪里可用。现在，我们使用 localhost 的端口 **3000** 来确保我们的服务器可以通过
    **http://localhost:3000/** 访问：
- en: '[PRE19]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The **server.listen** function is also asynchronous and requires us to pass
    a callback function, which will execute as soon as the server is up and running.
    We can simply log something here for now:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**server.listen** 函数也是异步的，需要我们传递一个回调函数，该函数将在服务器启动并运行后立即执行。我们现在可以在这里简单地记录一些信息：'
- en: '[PRE20]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Run the Node.js script as follows:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按以下方式运行 Node.js 脚本：
- en: '[PRE21]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You will notice that we get our **Server listening on http://localhost:3000**
    log message, so we know the server was started successfully. This time, the Terminal
    does not return control to us; the script keeps running. We can now open **http://localhost:3000**
    in a browser:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您会注意到我们得到了 **Server listening on http://localhost:3000** 的日志消息，因此我们知道服务器已成功启动。这次，终端没有返回控制权；脚本继续运行。现在我们可以在浏览器中打开
    **http://localhost:3000**：
- en: '![Figure 2.3 – A plaintext response from our first web server!](img/B19385_02_3.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – 来自我们第一个 Web 服务器的纯文本响应！](img/B19385_02_3.jpg)'
- en: Figure 2.3 – A plaintext response from our first web server!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 来自我们第一个 Web 服务器的纯文本响应！
- en: Now that we have set up a simple web server, we can extend it to serve a JSON
    file instead of simply returning plaintext.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个简单的Web服务器，我们可以将其扩展以服务JSON文件而不是简单地返回纯文本。
- en: Extending the web server to serve our JSON file
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展Web服务器以服务我们的JSON文件
- en: 'We can now try combining our knowledge of the `node:fs` module with the HTTP
    server to create a server that serves the previously created `users.json` file.
    Let’s get started with the steps:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以尝试将我们对`node:fs`模块的了解与HTTP服务器结合起来，创建一个服务之前创建的`users.json`文件的服务器。让我们从以下步骤开始：
- en: Copy the **backend/simpleweb.js** file to a new **backend/webfiles.js** file.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**backend/simpleweb.js**文件复制到新的**backend/webfiles.js**文件。
- en: 'At the beginning of the file, add an import of **readFileSync**:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件的开头添加对**readFileSync**的导入：
- en: '[PRE22]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Change the **Content-Type** header to **application/json**:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Content-Type**头更改为**application/json**：
- en: '[PRE23]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Replace the string in **res.end()** with the JSON string from our file. In
    this case, we do not need to parse the JSON, as **res.end()** expects a string
    anyway:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**res.end()**中的字符串替换为文件中的JSON字符串。在这种情况下，我们不需要解析JSON，因为**res.end()**无论如何都期望一个字符串：
- en: '[PRE24]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If it is still running, stop the previous server script via *Ctrl* + *C*. We
    need to do this because we cannot listen on the same port twice.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它仍在运行，通过*Ctrl* + *C*停止先前的服务器脚本。我们必须这样做，因为我们不能在同一个端口上监听两次。
- en: 'Run the server and refresh the page to see the JSON from the file being printed.
    Try changing the **users.json** file and see how it is read again on the next
    request (when refreshing the website):'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行服务器并刷新页面，以查看文件中的JSON被打印出来。尝试更改**users.json**文件，看看在下一个请求（刷新网站时）它又是如何被读取的：
- en: '[PRE25]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: While useful as an exercise, files are not a proper database to be used in production.
    As such, we are later going to introduce MongoDB as a database. We are going to
    run the MongoDB server in Docker, so let’s first briefly have a look at Docker.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然作为练习很有用，但文件并不是用于生产的适当数据库。因此，我们稍后将介绍MongoDB作为数据库。我们将在Docker中运行MongoDB服务器，所以让我们先简要地看看Docker。
- en: Introducing Docker, a platform for containers
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Docker，一个容器平台
- en: Docker is a platform that allows us to package, manage, and run applications
    in loosely isolated environments, called **containers**. Containers are lightweight,
    are isolated from each other, and include all dependencies needed to run an application.
    As such, we can use containers to easily set up various services and apps without
    having to deal with managing dependencies or conflicts between them.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是一个允许我们在称为**容器**的松散隔离环境中打包、管理和运行应用程序的平台。容器轻量级，彼此隔离，并包含运行应用程序所需的所有依赖项。因此，我们可以使用容器轻松地设置各种服务和应用程序，而无需处理依赖项或它们之间的冲突。
- en: Note
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There are also other tools, such as Podman (which even has a compatibility layer
    for the Docker CLI commands), and Rancher Desktop, which also supports Docker
    CLI commands.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他工具，例如Podman（它甚至有一个与Docker CLI命令兼容的层），以及Rancher Desktop，它也支持Docker CLI命令。
- en: We can use Docker locally to set up and run services in an isolated environment.
    Doing so avoids polluting our host environment and ensures that there is a consistent
    state to build upon. This consistency is especially important when working in
    larger development teams, as it ensures that everyone is working with the same
    state.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在本地使用Docker设置和运行隔离环境中的服务。这样做可以避免污染我们的主机环境，并确保有一个一致的状态可以在此基础上构建。这种一致性在大型开发团队中尤为重要，因为它确保每个人都在使用相同的状态。
- en: Additionally, Docker makes it easy to deploy containers to various cloud services
    and run them in a **continuous integration/continuous delivery** (**CI/CD**) workflow.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Docker使得将容器部署到各种云服务并运行在**持续集成/持续交付**（**CI/CD**）工作流程中变得容易。
- en: In this section, we will first get an overview of the Docker platform. Then,
    we will learn how to create a container and how to access Docker from VS Code.
    At the end, we will understand how Docker works and how it can be used to manage
    services.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将首先了解Docker平台的整体情况。然后，我们将学习如何创建容器以及如何从VS Code访问Docker。最后，我们将了解Docker的工作原理以及如何用它来管理服务。
- en: The Docker platform
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker平台
- en: 'The Docker platform essentially consists of three parts:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Docker平台本质上由三个部分组成：
- en: '**Docker Client**: Can run commands by sending them to the **Docker daemon**,
    which is either running on the local machine or a remote environment.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker客户端**：可以通过将命令发送到**Docker守护进程**来运行命令，该守护进程要么在本地机器上运行，要么在远程环境中运行。'
- en: '**Docker Host**: Contains the Docker daemon, images, and containers.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker主机**：包含Docker守护进程、镜像和容器。'
- en: '**Docker Registry**: Hosts and stores docker images, extensions, and plugins.
    By default, the public registry **Docker Hub** will be used to search for images.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker 仓库**：托管和存储 Docker 镜像、扩展和插件。默认情况下，将使用公共仓库 **Docker Hub** 来搜索镜像。'
- en: '![Figure 2.4 – Overview of the Docker platform](img/B19385_02_4.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.4 – Docker 平台概览](img/B19385_02_4.jpg)'
- en: Figure 2.4 – Overview of the Docker platform
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – Docker 平台概览
- en: '`mongo` image, which contains a MongoDB server, is based on the `ubuntu` image.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 包含 MongoDB 服务器的 `mongo` 镜像是基于 `ubuntu` 镜像的。
- en: '**Docker containers** are instances of images. They run an operating system
    with a configured service (such as a MongoDB server on Ubuntu). Additionally,
    they can be configured, for example, to forward some ports from within the container
    to the host, or to mount a storage volume in the container that stores data on
    the host machine. By default, a container is isolated from the host machine, so
    if we want to access ports or storage from it on the host, we need to tell Docker
    to allow this.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**Docker 容器**是镜像的实例。它们运行一个配置了服务的操作系统（例如在 Ubuntu 上的 MongoDB 服务器）。此外，它们可以被配置，例如，将容器内的某些端口转发到主机，或者将存储卷挂载到容器中，该卷在主机机器上存储数据。默认情况下，容器与主机机器隔离，因此如果我们想从主机访问端口或存储，我们需要告诉
    Docker 允许这样做。'
- en: Installing Docker
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Docker
- en: 'The easiest way to set up the Docker platform for local development is using
    Docker Desktop. It can be downloaded from the official Docker website ([https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/)).
    Follow the instructions to install it and start the Docker engine. After installation,
    you should have a `docker` command available in your Terminal. Run the following
    command to verify that it is working properly:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 Docker 平台进行本地开发最简单的方法是使用 Docker Desktop。它可以从官方 Docker 网站下载（[https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/))。按照说明进行安装并启动
    Docker 引擎。安装后，你应该在终端中有一个可用的 `docker` 命令。运行以下命令以验证其是否正常工作：
- en: '[PRE26]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This command should output the Docker version, like in the following example:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令应输出 Docker 版本，如下例所示：
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: After installing and starting Docker, we can move on to creating a container.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 安装并启动 Docker 后，我们可以继续创建容器。
- en: Creating a container
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建容器
- en: 'Docker Client can instantiate a container from an image via the `docker run`
    command. Let’s now create an `ubuntu` container and run a shell (`/bin/bash`)
    in it:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 客户端可以通过 `docker run` 命令从镜像实例化一个容器。现在让我们创建一个 `ubuntu` 容器并在其中运行一个 shell
    (`/bin/bash`)：
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The **:24.04** string after the image name is called the **tag**, and it can
    be used to pin images to certain versions. In this book, we use tags to pull specific
    versions of images so that the steps are reproducible even when new versions are
    released. By default, if no tag is specified, Docker will attempt to use the **latest**
    tag.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像名称后面的 **:24.04** 字符串被称为 **标签**，它可以用来将镜像固定到特定版本。在这本书中，我们使用标签来拉取特定版本的镜像，以便即使发布新版本，步骤也可以重复。默认情况下，如果没有指定标签，Docker
    将尝试使用 **latest** 标签。
- en: 'A new shell will open. We can verify that this shell is running in the container
    by executing the following command to see which operating system is running:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 将打开一个新的 shell。我们可以通过执行以下命令来验证这个 shell 是否在容器中运行，以查看正在运行的操作系统的版本：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If you get a version number that ends with `-linuxkit`, you have successfully
    run a command in the container, because LinuxKit is a toolkit to create small
    Linux VMs!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你得到一个以 `-linuxkit` 结尾的版本号，那么你已经在容器中成功运行了一个命令，因为 LinuxKit 是一个用于创建小型 Linux 虚拟机的工具包！
- en: 'You can now type the following command to exit the shell and the container:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以输入以下命令来退出 shell 和容器：
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following figure shows the result of running these commands:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了运行这些命令的结果：
- en: '![Figure 2.5 – Running our first Docker container](img/B19385_02_5.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.5 – 运行我们的第一个 Docker 容器](img/B19385_02_5.jpg)'
- en: Figure 2.5 – Running our first Docker container
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – 运行我们的第一个 Docker 容器
- en: 'The `docker run` command does the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker run` 命令执行以下操作：'
- en: If you have never run a container based on the **ubuntu** image before, Docker
    will start by pulling the image from the Docker registry (this is equivalent to
    executing **docker** **pull ubuntu**).
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你之前从未运行过基于 **ubuntu** 镜像的容器，Docker 将首先从 Docker 仓库拉取该镜像（这相当于执行 **docker pull
    ubuntu** 命令）。
- en: After the image is downloaded, Docker creates a new container (the equivalent
    to executing **docker** **container create**).
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载镜像后，Docker 将创建一个新的容器（相当于执行 **docker container create** 命令）。
- en: Then, Docker configures a read-write filesystem for the container and creates
    a default network interface.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，Docker 为容器配置了一个读写文件系统并创建了一个默认的网络接口。
- en: Finally, Docker starts the container and executes the specified command. In
    our case, we specified the **/bin/bash** command. Because we passed the **-i**
    (keeps **STDIN** open) and **-t** (allocates a pseudo-tty) options, Docker attaches
    the container’s shell to our currently running Terminal, allowing us to use the
    container as if we were directly accessing a Terminal on our host machine.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，Docker 启动容器并执行指定的命令。在我们的例子中，我们指定了 **/bin/bash** 命令。因为我们传递了 **-i**（保持 **STDIN**
    打开）和 **-t**（分配伪终端）选项，Docker 将容器的 shell 连接到我们当前运行的终端，使我们能够像直接访问主机机器上的终端一样使用容器。
- en: As we can see, Docker is very useful for creating self-contained environments
    for our apps and services to run in. Later in this book, we are going to learn
    how to package our own apps in Docker containers. For now, we are only going to
    use Docker to run services without having to install them on our host system.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Docker 对于创建我们的应用程序和服务运行的自包含环境非常有用。在本书的后续章节中，我们将学习如何将我们的应用程序打包到 Docker
    容器中。现在，我们只是使用 Docker 来运行服务，而无需在主机系统上安装它们。
- en: Accessing Docker via VS Code
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过 VS Code 访问 Docker
- en: 'We can also access Docker via the VS Code extension we installed in [*Chapter
    1*](B19385_01.xhtml#_idTextAnchor016), *Preparing for Full-stack Development*.
    To do so, click the Docker icon in the left sidebar of VS Code. The Docker sidebar
    will open, showing you a list of containers, images, registries, networks, volumes,
    contexts, and relevant resources:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过我们在 [*第 1 章*](B19385_01.xhtml#_idTextAnchor016) 中安装的 VS Code 扩展来访问 Docker，*为全栈开发做准备*。要做到这一点，请点击
    VS Code 左侧边栏中的 Docker 图标。Docker 侧边栏将打开，显示容器、镜像、注册表、网络、卷、上下文和相关资源的列表：
- en: '![Figure 2.6 – The Docker sidebar in VS Code](img/B19385_02_6.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.6 – VS Code 中的 Docker 侧边栏](img/B19385_02_6.jpg)'
- en: Figure 2.6 – The Docker sidebar in VS Code
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 – VS Code 中的 Docker 侧边栏
- en: Here, you can see which containers are stopped and which ones are running. You
    can right-click on a container to start, stop, restart, or remove it. You can
    also view its logs to debug what is going on inside the container. Additionally,
    you can attach a shell to the container to get access to its operating system.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以查看哪些容器已停止，哪些正在运行。您可以在容器上右键单击以启动、停止、重启或删除它。您还可以查看其日志以调试容器内部发生的情况。此外，您还可以将
    shell 连接到容器以获取对其操作系统的访问权限。
- en: Now that we know the essentials of Docker, we can create a container for our
    MongoDB database server.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Docker 的基础知识，我们可以为我们的 MongoDB 数据库服务器创建一个容器。
- en: Introducing MongoDB, a document database
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 MongoDB，一个文档数据库
- en: MongoDB, at the time of writing, is the most popular NoSQL database. Unlike
    **Structured Query Language** (**SQL**) databases (such as MySQL or PostgreSQL),
    NoSQL means that the database specifically does not use SQL to query the database.
    Instead, NoSQL databases have various other ways to query the database and often
    have a vastly different structure of how data is stored and queried.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 截至撰写本文时，MongoDB 是最受欢迎的 NoSQL 数据库。与 **结构化查询语言**（**SQL**）数据库（如 MySQL 或 PostgreSQL）不同，NoSQL
    表示数据库特别不使用 SQL 来查询数据库。相反，NoSQL 数据库有各种其他查询数据库的方式，并且通常数据存储和查询的结构大不相同。
- en: 'The following main types of NoSQL databases exist:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 存在以下主要类型的 NoSQL 数据库：
- en: Key-value stores (for example, Valkey/Redis)
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键值存储（例如，Valkey/Redis）
- en: Column-oriented databases (for example, Amazon Redshift)
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列式数据库（例如，Amazon Redshift）
- en: Graph-based databases (for example, Neo4j)
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于图的数据库（例如，Neo4j）
- en: Document-based databases (for example, MongoDB)
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档数据库（例如，MongoDB）
- en: '![Figure 2.7 – Overview of NoSQL databases](img/B19385_02_7.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.7 – NoSQL 数据库概述](img/B19385_02_7.jpg)'
- en: Figure 2.7 – Overview of NoSQL databases
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 – NoSQL 数据库概述
- en: MongoDB is a document-based database, which means that each entry in the database
    is stored as a document. In MongoDB, these documents are basically JSON objects
    (internally, they are stored as BSON – a binary JSON format to save space and
    improve performance, among other advantages). Instead, SQL databases store data
    as rows in tables. As such, MongoDB provides a lot more flexibility. Fields can
    be freely added or left out in documents. The downside of such a structure is
    that we do not have a consistent schema for documents. However, this can be solved
    by using libraries, such as Mongoose, which we will learn about in [*Chapter 3*](B19385_03_split_000.xhtml#_idTextAnchor050),
    *Implementing a Backend Using Express, Mongoose ODM,* *and Jest*.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 是一种基于文档的数据库，这意味着数据库中的每个条目都存储为文档。在 MongoDB 中，这些文档基本上是 JSON 对象（内部，它们以
    BSON 格式存储，这是一种二进制 JSON 格式，可以节省空间并提高性能，以及其他优点）。相反，SQL 数据库将数据存储为表中的行。因此，MongoDB
    提供了更多的灵活性。字段可以自由添加或省略在文档中。这种结构的缺点是我们没有文档的一致模式。然而，这可以通过使用库，如 Mongoose 来解决，我们将在
    [*第 3 章*](B19385_03_split_000.xhtml#_idTextAnchor050)，*使用 Express、Mongoose ODM
    和 Jest 实现后端* 中了解。
- en: '![Figure 2.8 – Comparison between MongoDB and SQL databases](img/B19385_02_8.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.8 – MongoDB 与 SQL 数据库的比较](img/B19385_02_8.jpg)'
- en: Figure 2.8 – Comparison between MongoDB and SQL databases
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8 – MongoDB 与 SQL 数据库的比较
- en: MongoDB is also based on a JavaScript engine. Since version 3.2, it has been
    using SpiderMonkey (the JavaScript engine that Firefox uses) instead of V8\. Nevertheless,
    this still means we can execute JavaScript code in MongoDB. For example, we can
    use JavaScript in the **MongoDB Shell** to help with administrative tasks. Again,
    we must be careful with this, though, as the MongoDB environment is vastly different
    from a browser or Node.js environment.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 也基于 JavaScript 引擎。从版本 3.2 开始，它使用 SpiderMonkey（Firefox 使用的 JavaScript
    引擎）而不是 V8。尽管如此，这意味着我们仍然可以在 MongoDB 中执行 JavaScript 代码。例如，我们可以在 **MongoDB Shell**
    中使用 JavaScript 来帮助进行管理任务。然而，我们必须对此保持谨慎，因为 MongoDB 环境与浏览器或 Node.js 环境大不相同。
- en: In this section, we will first learn how to set up a MongoDB server using Docker.
    Then, we will learn more about MongoDB and how to access it directly using the
    MongoDB Shell for the administration of our database and the data. We are also
    going to learn how to use VS Code to access MongoDB. At the end of this section,
    you will have an understanding of how CRUD operations work in MongoDB.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将首先学习如何使用 Docker 设置 MongoDB 服务器。然后，我们将更深入地了解 MongoDB 以及如何使用 MongoDB Shell
    直接访问它来进行数据库和数据的管理。我们还将学习如何使用 VS Code 访问 MongoDB。在本节的最后，您将了解 MongoDB 中的 CRUD 操作是如何工作的。
- en: Note
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: CRUD is an acronym for create, read, update, and delete, which are the common
    operations that backend services usually provide.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: CRUD 是创建、读取、更新和删除的缩写，这是后端服务通常提供的常见操作。
- en: Setting up a MongoDB server
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 MongoDB 服务器
- en: 'Before we can start using MongoDB, we need to set up a server. Since we already
    have Docker installed, we can make things easier for ourselves by running MongoDB
    in a Docker container. Doing so also allows us to have separate, clean MongoDB
    instances for our apps by creating separate containers. Let’s get started with
    the steps:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用 MongoDB 之前，我们需要设置一个服务器。由于我们已安装 Docker，我们可以通过在 Docker 容器中运行 MongoDB 来简化操作。这样做还可以通过创建单独的容器来为我们的应用程序拥有独立的、干净的
    MongoDB 实例。让我们从以下步骤开始：
- en: 'Make sure Docker Desktop is running and Docker is started. You can verify this
    by running the following command, which lists all running containers:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保 Docker Desktop 正在运行且 Docker 已启动。您可以通过运行以下命令来验证这一点，该命令列出了所有正在运行的容器：
- en: '[PRE31]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If you already have some containers running, it will be followed by a list of
    started containers.
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您已经运行了一些容器，将随后列出已启动的容器列表。
- en: 'Run the following Docker command to create a new container with a MongoDB server:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下 Docker 命令以创建一个新的容器并包含 MongoDB 服务器：
- en: '[PRE32]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Install the MongoDB Shell on your host system (not within the container) by
    following the instructions on the MongoDB website ([https://www.mongodb.com/docs/mongodb-shell/install/](https://www.mongodb.com/docs/mongodb-shell/install/)).
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照 MongoDB 网站上的说明（[https://www.mongodb.com/docs/mongodb-shell/install/](https://www.mongodb.com/docs/mongodb-shell/install/））在您的宿主系统上安装
    MongoDB Shell（不要在容器内安装）。
- en: 'On your host system, run the following command to connect to the MongoDB server
    using the MongoDB Shell (**mongosh**). After the hostname and port, we specify
    a database name. We are going to call our database **ch2**:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的宿主系统上，运行以下命令以使用MongoDB Shell（**mongosh**）连接到MongoDB服务器。在主机名和端口号之后，我们指定一个数据库名称。我们将把我们的数据库命名为**ch2**：
- en: '[PRE33]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ch2> console.log("test")
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ch2> console.log("test")
- en: '[PRE34]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following figure shows JavaScript code being executed in the MongoDB Shell:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了在MongoDB Shell中执行的JavaScript代码：
- en: '![Figure 2.9 – Connecting to our MongoDB database server running in a Docker
    container](img/B19385_02_9.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图2.9 – 连接到运行在Docker容器中的我们的MongoDB数据库服务器](img/B19385_02_9.jpg)'
- en: Figure 2.9 – Connecting to our MongoDB database server running in a Docker container
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 – 连接到运行在Docker容器中的我们的MongoDB数据库服务器
- en: Now that we have a shell connected to our MongoDB database server, we can start
    practicing running commands directly on the database.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经连接到我们的MongoDB数据库服务器，我们可以开始练习直接在数据库上运行命令。
- en: Running commands directly on the database
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 直接在数据库上运行命令
- en: Before we get started creating a backend service that interfaces with MongoDB,
    let’s spend some time getting familiar with MongoDB itself via the MongoDB Shell.
    The MongoDB Shell is very important for debugging and doing maintenance tasks
    on the database, so it is a good idea to get to know it well.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始创建一个与MongoDB交互的后端服务之前，让我们花些时间通过MongoDB Shell熟悉MongoDB本身。MongoDB Shell对于数据库的调试和维护任务非常重要，因此深入了解它是明智的。
- en: Creating a collection and inserting and listing documents
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建集合并插入和列出文档
- en: '**Collections** in MongoDB are the equivalent of tables in relational databases.
    They store documents, which are like JSON objects. To make it easier to understand,
    a collection can be seen as a very large JSON array containing JSON objects. Unlike
    simple arrays, collections support the creation of indices, which speed up the
    lookup of certain fields in documents. In MongoDB, a collection is automatically
    created when we attempt to insert a document into it or create an index for it.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**集合**在MongoDB中相当于关系数据库中的表。它们存储文档，类似于JSON对象。为了更容易理解，可以将集合视为一个非常大的包含JSON对象的JSON数组。与简单的数组不同，集合支持创建索引，这可以加快查找文档中某些字段的查找速度。在MongoDB中，当我们尝试向其中插入文档或为其创建索引时，集合会自动创建。'
- en: 'Let’s use the MongoDB Shell to insert a document into our database in the `users`
    collection:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用MongoDB Shell将一个文档插入到我们的`users`集合中：
- en: 'To insert a new user document into the **users** collection, run the following
    command in the MongoDB Shell:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将新的用户文档插入到**users**集合中，请在MongoDB Shell中运行以下命令：
- en: '[PRE35]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: While **insertOne()** allows us to insert a single document into the collection,
    there is also an **insertMany()** method, where we can pass an array of documents
    to add to the collection.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然**insertOne()**允许我们向集合中插入单个文档，但还有一个**insertMany()**方法，我们可以传递一个文档数组以添加到集合中。
- en: 'We can now list all documents from the **users** collection by running the
    following command:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以通过运行以下命令列出**users**集合中的所有文档：
- en: '[PRE36]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Doing so will return an array with our previously inserted document:'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这样做将返回一个包含我们之前插入的文档的数组：
- en: '[PRE37]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As we can see, MongoDB automatically created a unique ID (`ObjectId`) for our
    document. This ID consists of 12 bytes in hexadecimal format (so each byte is
    displayed as two characters). The bytes are defined as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，MongoDB自动为我们文档创建了一个唯一的ID（`ObjectId`）。该ID由12个字节的十六进制格式组成（因此每个字节显示为两个字符）。字节定义如下：
- en: The first 4 bytes are a timestamp, representing the creation of the ID measured
    in seconds since the Unix epoch
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前面的4个字节是一个时间戳，表示自Unix纪元以来的ID创建时间
- en: The next 5 bytes are a random value unique to the machine and currently running
    database process
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的5个字节是机器和当前运行的数据库进程的唯一随机值
- en: The last 3 bytes are a randomly initialized incrementing counter
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后3个字节是一个随机初始化的递增计数器
- en: Note
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The way **ObjectId** identifiers are generated in MongoDB ensures that IDs are
    unique, avoiding ID collisions even when two ids are generated at the same time
    from different instances, without requiring a form of communication between the
    instances, which would slow down the creation of documents when scaling the database.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB中**ObjectId**标识符的生成方式确保了ID的唯一性，即使在同一时间从不同的实例生成两个ID时也能避免ID冲突，而不需要实例之间的通信形式，这会减慢数据库扩展时文档的创建速度。
- en: Querying and sorting documents
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询和排序文档
- en: 'Now that we have inserted some documents, we can query them by accessing different
    fields from the object. We can also sort the list of documents returned from MongoDB.
    Follow these steps:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经插入了一些文档，我们可以通过访问对象的不同字段来查询它们。我们还可以对MongoDB返回的文档列表进行排序。按照以下步骤操作：
- en: 'Before we get started querying, let’s insert two more documents into our **users**
    collection:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们开始查询之前，让我们将另外两个文档插入到我们的**users**集合中：
- en: '[PRE38]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now we can start querying for a certain username by using **findOne** and passing
    an object with the **username** field. When using **findOne**, MongoDB will return
    the first matching object:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以通过使用**findOne**并传递包含**username**字段的对象来开始查询特定的用户名。当使用**findOne**时，MongoDB将返回第一个匹配的对象：
- en: '[PRE39]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can also query for full names, or any other field in the documents from
    the collection. When using **find**, MongoDB will return an array of all matches:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以查询全名，或者集合中任何其他字段的文档。当使用**find**时，MongoDB将返回所有匹配项的数组：
- en: '[PRE40]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'An important thing to watch out for is that when querying an **ObjectId**,
    we need to wrap the ID string with an **ObjectId()** constructor, as follows:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要注意的一个重要事项是，在查询**ObjectId**时，我们需要用**ObjectId()**构造函数将ID字符串括起来，如下所示：
- en: '[PRE41]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'MongoDB also provides certain query operators, prefixed by **$**. For example,
    we can find everyone above the age of 30 in our collection by using the **$gt**
    operator, as follows:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MongoDB还提供了一些查询运算符，以**$**为前缀。例如，我们可以使用**$gt**运算符在我们的集合中找到所有30岁以上的所有人，如下所示：
- en: '[PRE42]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If we want to sort our results, we can use the **.sort()** method after **.find()**.
    For example, we can return all items from the **users** collection, sorted by
    age ascending (**1** for ascending, **-1** for descending):'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想对结果进行排序，我们可以在**.find()**之后使用**.sort()**方法。例如，我们可以返回**users**集合中所有按年龄升序排序的项（**1**表示升序，**-1**表示降序）：
- en: '[PRE43]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Updating documents
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新文档
- en: 'To update a document in MongoDB, we combine the arguments from the query and
    insert operations into a single operation. We can use the same criteria to filter
    documents as we did for `find()`. To update a single field from the document,
    we use the `$``set` operator:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 要在MongoDB中更新文档，我们将查询和插入操作的参数组合成一个单一的操作。我们可以使用与`find()`相同的标准来过滤文档。要更新文档中的单个字段，我们使用`$set`运算符：
- en: 'We can update the **age** field for the user with the username **dan** as follows:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以更新用户名为**dan**的用户的**age**字段，如下所示：
- en: '[PRE44]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Just like **findOne**, **updateOne** only updates the first matching document.
    If we want to update all documents that match, we can use **updateMany**.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 就像**findOne**一样，**updateOne**只更新第一个匹配的文档。如果我们想更新所有匹配的文档，我们可以使用**updateMany**。
- en: MongoDB will return an object with information about how many documents matched
    (`matchedCount`), how many were modified (`modifiedCount`), and how many were
    upserted (`upsertedCount`).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB将返回一个对象，其中包含有关匹配的文档数量（`matchedCount`）、修改的文档数量（`modifiedCount`）以及插入的文档数量（`upsertedCount`）的信息。
- en: 'The **updateOne** method accepts a third argument, which is an **options**
    object. One useful option here is the **upsert** option, which, if set to **true**,
    will insert a document if it does not exist yet, and update it if it does exist
    already. Let’s first try to update a non-existent user with **upsert: false**:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**updateOne**方法接受第三个参数，这是一个**options**对象。这里一个有用的选项是**upsert**选项，如果设置为**true**，将在文档不存在时插入文档，如果已存在则更新它。让我们首先尝试使用**upsert:
    false**更新一个不存在的用户：'
- en: '[PRE45]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now we set **upsert** to **true**, which inserts the user:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将**upsert**设置为**true**，这将插入用户：
- en: '[PRE46]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to remove a field from a document, use the **$unset** operator.
    If you want to replace the whole document with a new document, you can use the
    **replaceOne** method and pass a new document as the second argument to it.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想从一个文档中删除一个字段，请使用**$unset**运算符。如果你想用新的文档替换整个文档，可以使用**replaceOne**方法并将新文档作为第二个参数传递给它。
- en: Deleting documents
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除文档
- en: To delete documents from the database, MongoDB provides the `deleteOne` and
    `deleteMany` methods, which have a similar API to the `updateOne` and `updateMany`
    methods. The first argument is, again, used to match documents.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 要从数据库中删除文档，MongoDB提供了`deleteOne`和`deleteMany`方法，这些方法与`updateOne`和`updateMany`方法具有类似的API。第一个参数再次用于匹配文档。
- en: 'Let’s say the user with the username `new` wants to delete their account. To
    do so, we need to remove them from the `users` collection. We can do so as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 假设用户名为`new`的用户想要删除他们的账户。为了做到这一点，我们需要从`users`集合中删除他们。我们可以这样做：
- en: '[PRE47]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: That’s all there is to it! As you can see, it is very simple to do CRUD operations
    in MongoDB if you already know how to work with JSON objects and JavaScript, making
    it the perfect database for a Node.js backend.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 就这么简单！正如你所见，如果你已经知道如何处理 JSON 对象和 JavaScript，那么在 MongoDB 中执行 CRUD 操作非常简单，这使得它成为
    Node.js 后端的完美数据库。
- en: Now that we have learned how to access MongoDB using the MongoDB Shell, let’s
    learn about accessing it from within VS Code.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何使用 MongoDB Shell 访问 MongoDB，让我们学习如何在 VS Code 中访问它。
- en: Accessing the database via VS Code
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过 VS Code 访问数据库
- en: 'Up until now, we have been using the Terminal to access the database. If you
    remember, in [*Chapter 1*](B19385_01.xhtml#_idTextAnchor016), *Preparing for Full-stack
    Development*, we installed a MongoDB extension for VS Code. We can now use this
    extension to access our database in a more visual way:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用终端来访问数据库。如果你还记得，在[*第一章*](B19385_01.xhtml#_idTextAnchor016)，*准备全栈开发*中，我们为
    VS Code 安装了一个 MongoDB 扩展。现在我们可以使用这个扩展以更直观的方式访问我们的数据库：
- en: 'Click on the MongoDB icon on the left sidebar (it should be a leaf icon) and
    click on the **Add** **Connection** button:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左侧侧边栏上的 MongoDB 图标（它应该是一个叶子图标），然后点击 **Add Connection** 按钮：
- en: '![Figure 2.10 – The MongoDB sidebar in VS Code](img/B19385_02_10.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.10 – VS Code 中的 MongoDB 侧边栏](img/B19385_02_10.jpg)'
- en: Figure 2.10 – The MongoDB sidebar in VS Code
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10 – VS Code 中的 MongoDB 侧边栏
- en: 'A new **MongoDB** tab will open up. In this tab, click on **Connect** in the
    **Connect with Connection** **String** box:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将会打开一个新的 **MongoDB** 选项卡。在这个选项卡中，点击 **Connect with Connection String** 框中的 **Connect**：
- en: '![Figure 2.11 – Adding a new MongoDB connection in VS Code](img/B19385_02_11.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.11 – 在 VS Code 中添加新的 MongoDB 连接](img/B19385_02_11.jpg)'
- en: Figure 2.11 – Adding a new MongoDB connection in VS Code
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.11 – 在 VS Code 中添加新的 MongoDB 连接
- en: 'A popup should open at the top. In this popup, enter the following connection
    string to connect to your local database:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该在顶部打开一个弹出窗口。在这个弹出窗口中，输入以下连接字符串以连接到你的本地数据库：
- en: '[PRE48]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Press *Return/Enter* to confirm. A new connection will be listed in the MongoDB
    sidebar. You can browse the tree to view databases, collections, and documents.
    For example, click the first document to view it:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 *Return/Enter* 确认。新的连接将列在 MongoDB 侧边栏中。你可以浏览树形结构来查看数据库、集合和文档。例如，点击第一个文档来查看它：
- en: '![Figure 2.12 – Viewing a document in the MongoDB extension in VS Code](img/B19385_02_12.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.12 – 在 VS Code 的 MongoDB 扩展中查看文档](img/B19385_02_12.jpg)'
- en: Figure 2.12 – Viewing a document in the MongoDB extension in VS Code
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.12 – 在 VS Code 的 MongoDB 扩展中查看文档
- en: Tip
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can also directly edit a document by editing a field in VS Code and saving
    the file. The updated document will automatically be saved to the database.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过在 VS Code 中编辑一个字段并保存文件来直接编辑一个文档。更新的文档将自动保存到数据库中。
- en: 'The MongoDB extension is very useful for debugging our database, as it lets
    us visually spot problems and quickly make edits to documents. Additionally, we
    can right-click on **Documents** and **Search for documents…** to open a new window
    where we can run MongoDB queries, just like we did in the Terminal. The queries
    can be executed on the database by clicking on the **Play** button in the top
    right. You may need to confirm a dialog with **Yes**, and then the results will
    show in a new pane, as can be seen in the following screenshot:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 扩展对于调试我们的数据库非常有用，因为它让我们可以直观地发现问题，并快速对文档进行编辑。此外，我们可以在 **Documents** 上右键单击并选择
    **Search for documents…** 以打开一个新窗口，在那里我们可以运行 MongoDB 查询，就像我们在终端中做的那样。可以通过点击右上角的
    **Play** 按钮在数据库上执行查询。你可能需要通过点击 **Yes** 确认一个对话框，然后结果将显示在一个新的面板中，如下面的截图所示：
- en: '![Figure 2.13 – Querying MongoDB in VS Code](img/B19385_02_13.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.13 – 在 VS Code 中查询 MongoDB](img/B19385_02_13.jpg)'
- en: Figure 2.13 – Querying MongoDB in VS Code
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.13 – 在 VS Code 中查询 MongoDB
- en: Now that we have learned the basics of using and debugging MongoDB databases,
    we can start integrating our database in a Node.js backend service, instead of
    simply storing and reading information from files.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了使用和调试 MongoDB 数据库的基础知识，我们可以开始将数据库集成到 Node.js 后端服务中，而不仅仅是简单地从文件中存储和读取信息。
- en: Accessing the MongoDB database via Node.js
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 Node.js 访问 MongoDB 数据库
- en: 'We are now going to create a new web server that, instead of returning users
    from a JSON file, returns the list of users from our previously created `users`
    collection:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建一个新的网络服务器，它将不再从 JSON 文件中返回用户，而是从我们之前创建的 `users` 集合中返回用户列表：
- en: 'In the **ch2** folder, open a Terminal. Install the **mongodb** package, which
    contains the official MongoDB driver for Node.js:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**ch2**文件夹中，打开终端。安装**mongodb**包，该包包含Node.js的官方MongoDB驱动程序：
- en: '[PRE49]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Create a new **backend/mongodbweb.js** file and open it. Import the following:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的**backend/mongodbweb.js**文件并打开它。导入以下内容：
- en: '[PRE50]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Define the connection URL and database name and then create a new MongoDB client:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义连接URL和数据库名称，然后创建一个新的MongoDB客户端：
- en: '[PRE51]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Connect to the database and log a message after we are connected successfully,
    or when there is an error with the connection:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到数据库，并在成功连接后或连接出错时记录一条消息：
- en: '[PRE52]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next, create an HTTP server, like we did before:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个HTTP服务器，就像我们之前做的那样：
- en: '[PRE53]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then, select the database from the client, and the **users** collection from
    the database:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，从客户端选择数据库，并选择数据库中的**users**集合：
- en: '[PRE54]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, execute the **find()** method on the **users** collection. In the MongoDB
    Node.js driver, we also need to call the **toArray()** method to resolve the iterator
    to an array:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在**users**集合上执行**find()**方法。在MongoDB Node.js驱动程序中，我们还需要调用**toArray()**方法将迭代器解析为数组：
- en: '[PRE55]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Finally, set the status code and response header, and return the users list:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，设置状态码和响应头，并返回用户列表：
- en: '[PRE56]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now that we have defined our server, copy over the code from before to listen
    to **localhost** on port **3000**:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的服务器，将之前的代码复制到监听**localhost**端口的**3000**端口的代码中：
- en: '[PRE57]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Run the server by executing the script:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行脚本启动服务器：
- en: '[PRE58]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Open **http://localhost:3000** in your browser and you should see the list
    of users from our database being returned:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开**http://localhost:3000**，你应该会看到从我们的数据库返回的用户列表：
- en: '![Figure 2.14 – Our first Node.js service retrieving data from a MongoDB database!](img/B19385_02_14.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![图2.14 – 我们第一个从MongoDB数据库检索数据的Node.js服务！](img/B19385_02_14.jpg)'
- en: Figure 2.14 – Our first Node.js service retrieving data from a MongoDB database!
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14 – 我们第一个从MongoDB数据库检索数据的Node.js服务！
- en: As we have seen, we can use similar methods that we have used in the MongoDB
    Shell in Node.js as well. However, the APIs of the `node:http` module and the
    `mongodb` package are very low-level, requiring a lot of code to create an HTTP
    API and talk to the database.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，我们可以在Node.js中使用与MongoDB Shell中类似的方法。然而，`node:http`模块和`mongodb`包的API非常底层，需要编写大量代码来创建HTTP
    API并与数据库通信。
- en: In the next chapter, we are going to learn about libraries that abstract these
    processes to allow for easier creation of HTTP APIs and handling of the database.
    These libraries are Express and Mongoose. Express is a web framework that allows
    us to easily define API routes and handle requests. Mongoose allows us to create
    schemas for documents in our database to more easily create, read, update, and
    delete objects.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习关于库的内容，这些库将这些过程抽象化，以便更容易地创建HTTP API和处理数据库。这些库是Express和Mongoose。Express是一个允许我们轻松定义API路由和处理请求的Web框架。Mongoose允许我们在数据库中为文档创建模式，以便更容易地创建、读取、更新和删除对象。
- en: Summary
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to use Node.js to develop scripts that can run
    on a server. We also learned how to create containers with Docker, and how MongoDB
    works and can be interfaced with. At the end of this chapter, we even successfully
    created our first simple backend service using Node.js and MongoDB!
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用Node.js开发可以在服务器上运行的脚本。我们还学习了如何使用Docker创建容器，以及MongoDB的工作原理及其接口。在本章末尾，我们甚至成功地使用Node.js和MongoDB创建了我们第一个简单的后端服务！
- en: In the next chapter, [*Chapter 3*](B19385_03_split_000.xhtml#_idTextAnchor050),
    *Implementing a Backend Using Express, Mongoose ODM, and Jest*, we are going to
    learn how to put together what we learned in this chapter to extend our simple
    backend service to a production-ready backend for a blog application.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，[*第3章*](B19385_03_split_000.xhtml#_idTextAnchor050)，*使用Express、Mongoose
    ODM和Jest实现后端*，我们将学习如何将本章学到的内容结合起来，将我们的简单后端服务扩展为适用于博客应用的成品后端。
