- en: '19'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '19'
- en: Understanding TDD in the Wider Testing Landscape
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在更广泛的测试领域中理解TDD
- en: 'Besides the mechanics of test-driven development, this book has touched on
    a few ideas about the mindset of the TDD practitioner: how and when to “cheat,”
    systematic refactoring, *strict* TDD, and so on.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 除了测试驱动开发的机制之外，本书还涉及了一些关于TDD实践者心态的想法：何时何地“作弊”，系统重构，*严格*的TDD等等。
- en: 'Some dev teams like to adopt the mantra of *move fast and break things*. TDD
    is the opposite: go slow and think about things. To understand what this means
    in practice, we can compare TDD with various other popular testing techniques.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发团队喜欢采用“快速行动，打破事物”的口号。TDD则相反：放慢速度，深思熟虑。为了理解在实践中这意味着什么，我们可以将TDD与各种其他流行的测试技术进行比较。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Test-driven development as a testing technique
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试驱动开发作为一种测试技术
- en: Manual testing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动测试
- en: Automated testing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化测试
- en: Not testing at all
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全不进行测试
- en: By the end of this chapter, you should have a good idea of why and how we practice
    TDD compared to other programming practices.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该对为什么以及如何与其他编程实践相比，我们实践TDD（测试驱动开发）有一个很好的理解。
- en: Test-driven development as a testing technique
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动开发作为一种测试技术
- en: TDD practitioners sometimes like to say that TDD is not about testing; rather,
    it’s about design, behavior, or specification, and the automated tests we have
    at the end are simply a bonus.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: TDD实践者有时喜欢说，TDD不是关于测试；而是关于设计、行为或规范，而我们最终拥有的自动化测试只是一个额外的好处。
- en: Yes, TDD is about design, but TDD is certainly about testing, too. TDD practitioners
    care that their software has a high level of *quality*, and this is the same thing
    that testers care about.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，TDD是关于设计的，但TDD当然也是关于测试的。TDD实践者关心他们的软件具有高*质量*，这与测试人员关心的是同一件事。
- en: Sometimes, people question the naming of TDD because they feel that the notion
    of a “test” confuses the actual process. The reason for this is that developers
    misunderstand what it means to build a “test.” A typical unit testing tool offers
    you practically no guidance on how to write *good* tests. And it turns out that
    reframing tests as specifications and examples is a good way to introduce testing
    to developers.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，人们会质疑TDD的命名，因为他们觉得“测试”这个概念混淆了实际的过程。原因在于开发者误解了构建“测试”的含义。典型的单元测试工具实际上几乎不提供如何编写*良好*测试的指导。结果证明，将测试重新构造成规范和示例是向开发者介绍测试的好方法。
- en: All automated tests are hard to write. Sometimes, we forget to write important
    tests, or we build brittle tests, write loose expectations, over-complicate solutions,
    forget to refactor, and so on.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 所有自动化测试都很难编写。有时，我们会忘记编写重要的测试，或者构建脆弱的测试，编写宽松的期望，过度复杂化解决方案，忘记重构，等等。
- en: It’s not just novices who struggle with this – everyone does it, experts included.
    People make a mess all the time. That’s also part of the fun. Discovering the
    joy of TDD requires a certain degree of humility and accepting that you aren’t
    going to be writing pristine test suites most of the time. Pristine test suites
    are very rare indeed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅新手会遇到这个问题——每个人都会，包括专家。人们经常一团糟。这也是乐趣的一部分。发现TDD的乐趣需要一定的谦卑，并接受你大多数时候不会编写完美的测试套件。完美的测试套件确实非常罕见。
- en: If you are lucky enough to have a tester on your team, you may think that TDD
    encroaches on their work, or may even put them out of a job. However, if you ask
    them their opinion, you’ll undoubtedly find they are only too keen for developers
    to take an interest in the quality of their work. With TDD, you can catch all
    those trivial logic errors yourself without needing to rely on someone else’s
    manual testing. The testers can then better use their time by focusing on testing
    complex use cases and hunting down missed requirements.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你很幸运，你的团队里有测试人员，你可能会认为TDD侵犯了他们的工作，甚至可能让他们失业。然而，如果你询问他们的意见，你无疑会发现他们非常希望开发者对他们的工作质量感兴趣。有了TDD，你可以自己捕捉到所有那些微不足道的逻辑错误，而不需要依赖他人的手动测试。然后测试人员可以更好地利用他们的时间，专注于测试复杂用例和寻找遗漏的需求。
- en: Best practices for your unit tests
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试的最佳实践
- en: 'The following are some great unit tests:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些优秀的单元测试：
- en: '**Independent**: Each test should test just one thing, and invoke only one
    unit. There are many techniques that we can employ to achieve this goal. To take
    just two examples, collaborators are often (but not always) mocked, and example
    data should be the minimum set of data required to correctly describe the test.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**独立**：每个测试应该只测试一件事，并只调用一个单元。我们可以采用许多技术来实现这一目标。仅举两个例子，协作者通常（但不总是）被模拟，示例数据应该是正确描述测试所需的最小数据集。'
- en: Classicist versus mockist TDD
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 经典主义者与模拟主义者TDD
- en: You may have heard of the great TDD debate of *classicist* versus *mockist*
    TDD. The idea is that the classicist will not use mocks and stubs, while the mockist
    will mock all collaborators. In reality, both techniques are important. You have
    seen both in use in this book. I encourage you to not limit yourself to a single
    approach, but instead experiment and learn to be comfortable with both.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能听说过伟大的TDD辩论，即*经典主义者*与*模拟主义者*的TDD。其想法是，经典主义者不会使用模拟和存根，而模拟主义者会模拟所有协作者。在现实中，这两种技术都很重要。你在本书中已经看到了它们的使用。我鼓励你不要局限于单一的方法，而是实验并学会对两者都感到舒适。
- en: '**Short, with a high level of abstraction**: The test description should be
    concise. The test code should highlight all the pieces of code that are important
    to the test, and hide any apparatus that’s required but not relevant.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简短，高度抽象**：测试描述应该简洁。测试代码应突出显示对测试重要的所有代码片段，并隐藏任何所需但不相关的设备。'
- en: '**Quick to run**: Use test doubles instead of interacting with system resources
    (files, network connections, and so on) or other processes. Do not use timeouts
    in your code, or rely on the passing of time.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速运行**：使用测试替身而不是与系统资源（文件、网络连接等）或其他进程交互。不要在代码中使用超时，或依赖时间的流逝。'
- en: '**Focused on observable behavior**: The system is interesting for what it does
    to the outside world, not for how it does it. In the case of React, we care about
    DOM interaction.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**专注于可观察的行为**：系统对外部世界的影响才是有趣的，而不是它如何做到这一点。在React的情况下，我们关注DOM交互。'
- en: '**In three parts**: These parts are **Arrange**, **Act**, and **Assert**, also
    known as the **AAA** pattern. Each test should follow this structure.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分为三部分**：这些部分是**安排**、**行动**和**断言**，也称为**AAA**模式。每个测试都应该遵循这个结构。'
- en: '**Don’t Repeat Yourself** (**DRY**): Always take the time to refactor and clean
    up your tests, aiming for readability.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要重复自己**（**DRY**）：始终花时间重构和清理你的测试，目标是可读性。'
- en: '**A design tool**: Great tests help you figure out how to design your system.
    That’s not to say that up-front design isn’t important. In almost every chapter
    in this book, we started with a little design before we embarked on our tests.
    It’s important to do some thinking so that you have an idea of the general direction
    you’re headed. Just don’t try to plan too far ahead, and be prepared to throw
    out your design entirely as you proceed.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设计工具**：优秀的测试帮助你弄清楚如何设计你的系统。这并不是说前置设计不重要。在本书的几乎每一章中，我们在开始测试之前都进行了一些设计。做一些思考，这样你就有了一个大致的方向。只是不要试图计划得太远，并且准备好在前进过程中完全放弃你的设计。'
- en: TDD is not a replacement for great design. To be a great TDD practitioner, you
    should also learn about and practice software design. There are many books about
    software design. Do not limit yourself to books about JavaScript or TypeScript;
    good design transcends language.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: TDD不是优秀设计的替代品。要成为一名优秀的TDD实践者，你还应该了解并练习软件设计。关于软件设计有许多书籍。不要局限于关于JavaScript或TypeScript的书籍；优秀的设计超越语言。
- en: Improving your technique
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提高你的技术
- en: 'The following are some general tips for improving:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些改进的一般性建议：
- en: '**Work with others**: Beyond reading this book, the best way to level up in
    TDD is to work with experts. Since TDD lends itself so well to pair and mob programming,
    it can give structure to teams of mixed experience. More experienced developers
    can use the granularity of small tests to help improve the work of less experienced
    developers.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与他人合作**：除了阅读这本书之外，提高TDD水平的最佳方式是与专家合作。由于TDD非常适合结对和团队编程，它可以给不同经验水平的团队提供结构。经验丰富的开发者可以使用小型测试的粒度来帮助提高经验不足的开发者的工作。'
- en: '**Experiment with design**: TDD gives you a safety net that allows you to experiment
    with the style and shape of your programs. Make use of that safety net to learn
    more about design. Your tests will keep you safe.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实验设计**：TDD为你提供了一个安全网，让你可以实验程序的风格和形状。利用这个安全网来了解更多关于设计的信息。你的测试会保护你。'
- en: '**Learn to slow down**: TDD requires a great deal of personal discipline. Unfortunately,
    there is no room for sloppiness. You must not cut corners; instead, take every
    opportunity to refactor. Once your test passes, sit with your code. Before moving
    on to the next test, stare at your current solution and think carefully about
    whether it is the best it can be.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**学会放慢速度**：TDD 需要大量的个人自律。不幸的是，没有余地可以马虎。你绝对不能走捷径；相反，要抓住每一个机会进行重构。一旦测试通过，就坐下来审视你的代码。在继续下一个测试之前，仔细看看你的当前解决方案，并认真思考它是否是最好的。'
- en: '**Don’t be afraid to defer design decisions**: Sometimes, we’re faced with
    several design options, and it can be tricky to know which option to choose. Even
    a simple act such as naming variables can be difficult. Part of having a sense
    of design is knowing when to defer your thinking. If you’re in the refactor stage
    and feel yourself weighing up two or more options, move on and add another test,
    and then revisit your design. You’ll often find that you have more design knowledge
    and will be closer to the right answer.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要害怕推迟设计决策**：有时，我们面临几个设计选择，知道选择哪个选项可能很棘手。即使是命名变量这样的简单行为也可能很困难。拥有设计感的一部分是知道何时推迟你的思考。如果你处于重构阶段，并发现自己正在权衡两个或更多选项，那就继续前进，添加另一个测试，然后回过头来审视你的设计。你通常会发现自己有更多的设计知识，并且更接近正确答案。'
- en: '**Solve a kata each day**: A kata is a short exercise designed to be practiced
    repeatedly to teach you a certain technique. Two basic katas are *Coin Changer*
    and *Roman Numerals*. More complex katas include the bowling game kata, the bank
    kata, and Conway’s *Game of Life*. The diamond kata is a favorite of mine, as
    are sorting algorithms.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**每天解决一个 kata**：kata 是一种短期的练习，旨在反复练习以教授你某种技术。两个基本的 kata 是 *硬币兑换器* 和 *罗马数字*。更复杂的
    kata 包括保龄球 kata、银行 kata 和康威的 *生命游戏*。钻石 kata 是我最喜欢的，还有排序算法。'
- en: '**Attend a Coderetreat**: **Coderetreats** involve a day of pairing and TDD
    that revolves around the *Game of Life* kata. The *Global Day of Coderetreat*
    is held in November. Groups from all around the world get together to solve this
    problem. It’s not only fun but a great way to expand your TDD horizons.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参加编码 retreat**：**编码 retreat** 涉及一天的对偶编程和 TDD，围绕 *生命游戏* kata 展开。*全球编码 retreat
    日* 在 11 月举行。来自世界各地的团队聚集在一起解决这个问题。这不仅有趣，而且是扩展你的 TDD 视野的好方法。'
- en: That covers the general advice on TDD. Next, let’s look at manual testing techniques.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了关于 TDD 的一般建议。接下来，让我们看看手动测试技术。
- en: Manual testing
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动测试
- en: Manual testing, as you may have guessed, means starting your application and
    actually using it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜到的，手动测试意味着启动你的应用程序并实际使用它。
- en: Since your software is your creative work, naturally, you are interested to
    find out how it performs. You should certainly take the time to do this but think
    of it as downtime and a chance to relax, rather than a formal part of your development
    process.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你的软件是你的创造性作品，自然地，你很想知道它的表现如何。你当然应该花时间做这件事，但把它视为休息和放松的机会，而不是你开发过程的一个正式部分。
- en: The downside to *using* your software as opposed to *developing* your software
    is that using it takes up a lot of time. It sounds silly but pointing, clicking,
    and typing all take up valuable time. Plus, it takes time to get test environments
    set up and primed with the relevant test data.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 与 *使用* 软件相比，*开发* 软件的缺点是使用它需要花费大量时间。听起来很傻，但指向、点击和输入都占用了宝贵的时间。此外，设置测试环境并准备好相关测试数据也需要时间。
- en: For this reason, it’s important to avoid manual testing where possible. There
    are, however, times when it’s necessary, as we’ll discover in this section.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽可能避免手动测试是很重要的。然而，在某些情况下，它是必要的，正如我们将在本节中发现的那样。
- en: There is always a temptation to manually test the software after each feature
    is complete, just to verify that it works. If you find yourself doing this a lot,
    consider how much confidence you have in your unit tests.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 总是会有一种诱惑，在每一个特性完成后手动测试软件，只是为了验证它是否工作。如果你发现自己经常这样做，考虑一下你对单元测试的信心有多大。
- en: If you can claim, “I have 100% confidence in my unit tests,” why would you ever
    need to *use* your software to prove it?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你声称，“我对我的单元测试有 100% 的信心”，那你为什么还需要 *使用* 你的软件来证明它呢？
- en: Let’s look at some specific types of manual testing, starting with demonstrating
    software.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些具体的手动测试类型，从展示软件开始。
- en: Demonstrating software
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 展示软件
- en: 'There are at least two important occasions where you should *always* manually
    test: when you are demonstrating your software to your customers and users, and
    when you are preparing to demonstrate your software.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 至少有两个重要场合你应该*始终*手动测试：当你向客户和用户展示你的软件时，以及当你准备展示你的软件时。
- en: Preparing means writing down a demo script that lists every action you want
    to perform. Rehearse your script at least a couple of times before you perform
    it live. Very often, rehearsals will bring about changes to the script, which
    is why rehearsals are so important. Always make sure you’ve done at least one
    full run-through that didn’t require changes before you perform a live demo.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 准备意味着写下一份演示脚本，列出你想要执行的所有操作。在实际演示之前，至少练习你的脚本两遍。很多时候，排练会带来对脚本的修改，这就是为什么排练如此重要的原因。在正式演示之前，一定要确保你已经至少进行了一次不需要修改的完整演练。
- en: Testing the whole product
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试整个产品
- en: 'Frontend development includes a lot of moving parts, including the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 前端开发包括很多移动部件，包括以下内容：
- en: Multiple browser environments that require support
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要支持的多个浏览器环境
- en: CSS
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSS
- en: Distributed components, such as proxies and caches
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式组件，如代理和缓存
- en: Authentication mechanisms
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证机制
- en: Manually testing is necessary because of the interaction of all these moving
    parts. We need to check that everything sits together nicely.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有这些移动部件的交互，手动测试是必要的。我们需要检查所有部件是否能够很好地组合在一起。
- en: Alternatively, you can use end-to-end tests for the same coverage; however,
    these are costly to develop and maintain.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用端到端测试来达到相同的覆盖率；然而，这些测试的开发和维护成本也很高。
- en: Exploratory testing
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索性测试
- en: Exploratory testing is what you want your QA team to do. If you don’t work with
    a QA team, you should allocate time to do this yourself. Exploratory testing involves
    exploring software and hunting for missing requirements or complex use cases that
    your team has not thought about yet.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 探索性测试是你希望你的QA团队做的事情。如果你没有与QA团队合作，你应该分配时间自己来做这件事。探索性测试涉及探索软件并寻找团队尚未考虑的缺失需求或复杂用例。
- en: Because TDD works at a very low level, it can be easy to miss or even misunderstand
    requirements. Your unit tests may cover 95% of cases, but you can accidentally
    forget about the remaining 5%. This happens a lot when a team is new to TDD, or
    is made up of novice programmers. It happens all the time with experienced TDDers,
    too – even those of us who write books on TDD! We all make errors from time to
    time.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于TDD在非常低的层面上工作，很容易错过或甚至误解需求。你的单元测试可能覆盖了95%的情况，但你可能会不小心忘记剩下的5%。当团队刚开始使用TDD，或者由新手程序员组成时，这种情况经常发生。即使是经验丰富的TDD实践者，也会发生这种情况——即使是那些写TDD书籍的人！我们都会时不时犯错误。
- en: A very common error scenario involves mocks. When a class or function signature
    is changed, any mocks of that class or function must also be updated. This step
    is often forgotten; the unit tests still pass, and the error is only discovered
    when you run the application for real.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常常见的错误场景涉及到模拟。当一个类或函数签名发生变化时，该类或函数的任何模拟也必须更新。这一步经常被遗忘；单元测试仍然通过，错误只有在实际运行应用程序时才会被发现。
- en: Bug-free software
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 无bug的软件
- en: TDD can give you more confidence, but there is absolutely no way that TDD guarantees
    bug-free software.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: TDD可以给你更多的信心，但绝对没有保证TDD能保证无bug的软件。
- en: With time and experience, you’ll get better at spotting all those pesky edge
    cases before they make it to the QA team.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间和经验的积累，你将更擅长在它们到达QA团队之前发现所有那些讨厌的边缘情况。
- en: An alternative to exploratory testing is automated acceptance tests, but as
    with end-to-end tests, these are costly to develop and maintain, and they also
    require a high level of expertise and team discipline.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 探索性测试的替代方案是自动化验收测试，但就像端到端测试一样，这些测试的开发和维护成本很高，而且它们还要求有高水平的专业知识和团队纪律。
- en: Debugging in the browser
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浏览器中的调试
- en: 'Debugging is always an epic time sink. It can be an incredibly frustrating
    experience, with a lot of hair-pulling. That’s a big reason we test-drive: so
    that we never have to debug. Our tests do the debugging for us.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 调试总是耗时巨大。这可能是一种极其令人沮丧的经历，伴随着大量的焦虑。这就是我们进行测试驱动开发的一个主要原因：这样我们就永远不需要调试。我们的测试为我们做了调试。
- en: Conversely, a downside of TDD is that your debugging skills will languish.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，TDD的一个缺点是，你的调试技能可能会退化。
- en: For the TDD practitioner, debugging should, in theory, be a very rare experience,
    or at least something that is actively avoided. But there are always occasions
    when debugging is necessary.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于TDD实践者来说，从理论上讲，调试应该是一个非常罕见的情况，或者至少是积极避免的情况。但总有需要调试的情况。
- en: Print-line debugging is the name given to the debugging technique where a code
    base is littered with `console.log` statements in the hope that they can provide
    runtime clues about what’s going wrong. I’ve worked with many programmers who
    began their careers with TDD; for many of them, print-line debugging is the only
    form of debugging they know. Although it’s a simple technique, it’s also time-consuming,
    involves a lot of trial and error, and you have to remember to clean up after
    yourself when you’re done. There’s a risk of accidentally forgetting about a stray
    `console.log` and it then going live in production.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 打印行调试是一种调试技术，其中代码库中充满了`console.log`语句，希望它们可以提供有关运行时错误的线索。我与许多程序员合作过，他们职业生涯的开始是TDD；对于他们中的许多人来说，打印行调试是他们所知道的唯一调试形式。尽管这是一个简单的技术，但它也很耗时，涉及大量的尝试和错误，您完成工作后必须记得清理。有可能会忘记一个多余的`console.log`，然后它在生产环境中生效。
- en: Modern browsers have very sophisticated debugging tools that, until just recently,
    would have been imaginable only in a “full-fat” IDE such as Visual Studio or IntelliJ.
    You should make time to learn about all of the standard debugging techniques,
    including setting breakpoints (including conditional breakpoints), stepping in,
    out, and over, watching variables, and so on.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现代浏览器具有非常复杂的调试工具，直到最近，这些工具只能在“全功能”IDE（如Visual Studio或IntelliJ）中想象得到。您应该抽出时间来了解所有标准的调试技术，包括设置断点（包括条件断点）、进入、退出和跳过、监视变量等等。
- en: A common anti-pattern is to use debugging techniques to track down a bug, and
    once it’s discovered, fix it and move on to the next task. What you should be
    doing instead is writing a failing test to prove the existence of a bug. As if
    by magic, the test has done the debugging for you. Then, you can fix the bug,
    and immediately, the test will tell you whether the issue has been fixed, without
    you needing to manually re-test. Think of all the time you’ll save!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的反模式是使用调试技术来追踪一个错误，一旦发现，就修复它并继续下一个任务。您应该做的是编写一个失败的测试来证明错误的存在。就像魔法一样，测试已经为您完成了调试。然后，您可以修复错误，并且立即，测试会告诉您问题是否已修复，而无需您手动重新测试。想想您将节省多少时间！
- en: Check out the *Further reading* section for resources on the Chrome debugger.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 查看**进一步阅读**部分，获取有关Chrome调试器的资源。
- en: That covers the main types of manual testing that you’ll perform. Next, let’s
    take a look at automated testing techniques.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了您将执行的主要手动测试类型。接下来，让我们看看自动化测试技术。
- en: Automated testing
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化测试
- en: TDD is a form of automated testing. This section lists some other popular types
    of automated testing and how they compare to TDD.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: TDD是一种自动化测试形式。本节列出了其他一些流行的自动化测试类型，以及它们与TDD的比较。
- en: Integration tests
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成测试
- en: These tests check how two or more independent processes interact. Those processes
    could either be on the same machine or distributed across a network. However,
    your system should exercise the same communication mechanisms as it would in production,
    so if it makes HTTP calls out to a web service, then it should do so in your integration
    tests, regardless of where the web service is running.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试检查两个或更多独立进程之间的交互。这些进程可以是同一台机器上的，也可以分布在网络中。然而，您的系统应该使用与生产环境中相同的通信机制，因此如果它向一个网络服务发出HTTP调用，那么它应该在您的集成测试中这样做，无论该网络服务在哪里运行。
- en: Integration tests should be written in the same unit test framework that you
    use for unit tests, and all of the same rules about writing good unit tests apply
    to integration tests.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试应该使用与单元测试相同的单元测试框架编写，所有关于编写良好单元测试的规则都适用于集成测试。
- en: The trickiest part of integration testing is the orchestration code, which involves
    starting and stopping processes, and waiting for processes to complete their work.
    Doing that reliably can be difficult.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试中最棘手的部分是编排代码，这涉及到启动和停止进程，以及等待进程完成其工作。可靠地执行这些操作可能很困难。
- en: If you’re choosing to mock objects in your unit tests, you will need at least
    *some* coverage of those interactions when they *aren’t* mocked, and integration
    tests are one way to do that. Another way is system testing, as discussed below.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择在单元测试中模拟对象，当你不模拟这些交互时，你需要至少*一些*对这些交互的覆盖，集成测试是这样做的一种方式。另一种方式是系统测试，如以下所述。
- en: System tests and end-to-end tests
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统测试和端到端测试
- en: These are automated tests that exercise the entire system, usually (but not
    necessarily) by driving a UI.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是自动化测试，它们通过驱动UI来测试整个系统，通常（但不一定）是通过驱动UI来实现的。
- en: They are useful when manual exploratory testing starts taking an inordinate
    amount of time. This happens with codebases as they grow in size and age.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当手动探索性测试开始占用过多时间时，它们是有用的。这种情况发生在代码库随着规模和年龄的增长而增长。
- en: End-to-end tests are costly to build and maintain. Fortunately, they can be
    introduced gradually, so you can start small and prove their value before increasing
    their scope.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试的建设和维护成本很高。幸运的是，它们可以逐步引入，这样你就可以从小规模开始，证明它们的价值，然后再扩大其范围。
- en: Acceptance tests
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接受测试
- en: Acceptance tests are written by the customer, or a proxy to the customer such
    as a product owner, where *acceptance* refers to a quality gate that must be passed
    for the released software to be accepted as complete. They may or may not be automated,
    and they specify behavior at a system level.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接受测试是由客户或代表客户的代理（如产品负责人）编写的，其中“接受”指的是必须通过的质量关卡，以便发布的软件被视为完整。它们可能是自动化的，也可能不是，并且它们在系统级别指定行为。
- en: How should the customer write these tests? For automated tests, you can often
    use system testing tools such as Cucumber and Cypress. The Gherkin syntax that
    we saw in [*Chapter 17*](B18423_17.xhtml#_idTextAnchor344)*, Writing Your First
    Cucumber Test*, and [*Chapter 18*](B18423_18.xhtml#_idTextAnchor355)*, Adding
    Features Guided by Cucumber Tests*, is one way to do it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 客户应该如何编写这些测试？对于自动化测试，你通常可以使用系统测试工具，如Cucumber和Cypress。我们在[*第17章*](B18423_17.xhtml#_idTextAnchor344)*，编写您的第一个Cucumber测试*和[*第18章*](B18423_18.xhtml#_idTextAnchor355)*，由Cucumber测试引导的功能添加*中看到的Gherkin语法是这样做的一种方式。
- en: Acceptance tests can be used to build trust between developers and product stakeholders.
    If the customer is endlessly testing your software looking for bugs, that points
    to a low level of trust between the development team and the outside world. Acceptance
    tests could help improve that trust if they start catching bugs that would otherwise
    be found by your customer. At the same time, however, you should be asking yourself
    why TDD isn’t catching all those bugs in the first place and consider how you
    can improve your overall testing process.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接受测试可以用来在开发人员和产品利益相关者之间建立信任。如果客户不断测试你的软件以寻找错误，这表明开发团队与外界之间的信任水平很低。如果接受测试开始捕获那些客户可能发现的错误，它们可以帮助提高这种信任。然而，与此同时，你也应该问自己为什么TDD一开始就没有捕获所有这些错误，并考虑如何改进你的整体测试流程。
- en: Property-based and generative testing
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于属性和生成式测试
- en: 'In traditional TDD, we find a small set of specifications or examples to test
    our functions against. Property-based testing is different: it generates a large
    set of tests based on a definition of what the inputs to those functions should
    be. The test framework is responsible for generating the input data and the tests.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的TDD中，我们找到一小组规范或示例来测试我们的函数。基于属性的测试不同：它基于对函数输入定义的测试生成大量测试。测试框架负责生成输入数据和测试。
- en: For example, if I had a function that converted Fahrenheit to Celsius, I could
    use a generative test framework to generate tests for a large, random sample of
    integer-valued Fahrenheit measurements and ensure that each of them converts into
    the correct Celsius value.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我有一个将华氏度转换为摄氏度的函数，我就可以使用生成式测试框架来生成针对大量随机整数华氏度测量值的测试，并确保每个值都能正确转换为摄氏度值。
- en: Property-based testing is just as hard as TDD. It is no magic bullet. Finding
    the right properties to assert is challenging, particularly if you aim to build
    them up in a test-driven style.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 基于属性的测试与TDD（测试驱动开发）一样困难。它不是万能的灵丹妙药。找到正确的属性进行断言是具有挑战性的，尤其是如果你旨在以测试驱动的方式构建它们。
- en: This kind of testing does not replace TDD, but it is another tool in any TDD
    practitioner’s toolbox.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这种测试不会取代TDD，但它是任何TDD实践者的工具箱中的另一个工具。
- en: Snapshot testing
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快照测试
- en: This is a popular testing technique for React applications. React component
    trees are serialized to disk as a JSON string and then compared between test runs.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种流行的React应用程序测试技术。React组件树被序列化为JSON字符串并存储到磁盘上，然后在测试运行之间进行比较。
- en: 'React component trees are useful in a couple of important scenarios, including
    the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: React组件树在几个重要场景中非常有用，包括以下内容：
- en: When your team has a low level of experience with TDD and general program design
    and could become more confident with a safety net of snapshot testing
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你的团队在TDD和一般程序设计方面经验不足，并且可以通过快照测试的安全网来增强信心时
- en: When you have zero test coverage of software that is already being used in production,
    and you would like to quickly gain some level of confidence before making any
    changes
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你正在使用的软件在生产的测试覆盖率为零，并且你希望在做出任何更改之前快速获得一定程度的信心时
- en: QA teams are sometimes interested in how software changes visually between releases,
    but they will probably not want to write tests in your unit test suites; they’ll
    have their own specialized tool for that.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 质量保证团队有时会对软件在版本之间的视觉变化感兴趣，但他们可能不会想在你的单元测试套件中编写测试；他们会有自己的专用工具来做这件事。
- en: 'Snapshot testing is certainly a useful tool to know about, but be aware of
    the following issues:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 快照测试当然是一个值得了解的有用工具，但要注意以下问题：
- en: Snapshots are not descriptive. They do not go beyond saying, “this component
    tree looks the same as it did before.” This means that if they break, it will
    not be immediately clear why they broke.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快照不是描述性的。它们不会超出说“这个组件树看起来和之前一样”。这意味着如果它们崩溃了，不会立即清楚为什么它们崩溃了。
- en: If snapshots are rendered at a high level in your component tree, they are brittle.
    Brittle tests break frequently and therefore take a lot of time to correct. Since
    the tests are at a high level, they do not pinpoint where the error is, so you’ll
    spend a lot of time hunting down failures.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果快照在组件树的高层渲染，它们就会变得脆弱。脆弱的测试经常失败，因此需要花费大量时间来纠正。由于测试是在高层进行的，它们无法精确指出错误的位置，因此你将花费大量时间寻找失败的原因。
- en: 'Snapshot tests can pass in two scenarios: first, when the component tree is
    the same as the previous version that was tested, and second, when no snapshot
    artifacts from the previous test run are found. This means that a green test does
    not give you full confidence – it could simply be green because previous artifacts
    are missing.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快照测试可以在两种情况下通过：首先，当组件树与之前测试的版本相同，其次，当找不到之前测试运行中的快照工件。这意味着绿色测试并不能给你带来完全的信心——它可能只是因为之前的工件缺失而变绿。
- en: 'When writing good tests (of any kind), you want the following to be true of
    any test failure that occurs:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写良好的测试（任何类型的测试）时，你希望以下关于任何测试失败都是真实的：
- en: It is very quick to ascertain whether the failure is due to an error or a change
    in specification
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非常快地确定失败是由于错误还是规范的变化
- en: In the case of errors, it is very quick to pinpoint the problem and the location
    of the error
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在错误的情况下，非常快地确定问题和错误的位置
- en: TDD is an established technique that the community has learned enough about
    to know how to write good tests. We aren’t quite there with snapshot testing.
    If you absolutely must employ snapshot testing in your code base, make sure that
    you measure how much value it is providing you and your team.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: TDD是一种社区已经学到了足够多的、知道如何编写良好测试的成熟技术。我们在快照测试方面还没有达到这个水平。如果你绝对必须在代码库中采用快照测试，请确保你衡量它为你和你的团队提供的价值。
- en: Canary testing
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 金丝雀测试
- en: 'Canary testing is when you release your software to a small proportion of your
    users and see what happens. It can be useful for web applications with a large
    user base. One version of canary testing involves sending each request to two
    systems: the live system and the system under test. Users only sense the live
    system but the test system results are recorded and analyzed by you. Differences
    in functionality and performance can then be observed, while your users are never
    subjected to test software.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 金丝雀测试是在你将软件发布给一小部分用户并观察发生了什么。对于拥有大量用户的Web应用程序来说，这可能很有用。金丝雀测试的一种形式涉及将每个请求发送到两个系统：运行中的系统和测试系统。用户只能感知到运行中的系统，但测试系统的结果由你记录和分析。然后可以观察到功能和性能的差异，而你的用户永远不会受到测试软件的影响。
- en: Canary testing is attractive because, on the surface, it seems very cost-effective,
    and also requires next to no *thinking* from the programmer.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 金丝雀测试很有吸引力，因为从表面上看，它似乎非常具有成本效益，而且几乎不需要程序员进行任何*思考*。
- en: Unlike TDD, canary testing cannot help you with the design of your software,
    and it may take a while for you to get any feedback.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 与TDD不同，金丝雀测试无法帮助你设计软件，而且你可能需要一段时间才能得到任何反馈。
- en: 'That completes our look at the automated testing landscape. We started this
    chapter by looking at manual testing techniques. Now, let’s round this chapter
    off with a final technique: not testing at all!'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们对自动化测试领域的考察。我们本章开始时探讨了手动测试技术。现在，让我们以一个最终技术来结束本章：完全不进行测试！
- en: Not testing at all
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完全不进行测试
- en: There is a belief that TDD doesn’t apply to some scenarios in which it does
    – for example, if your code is throwaway or if it’s presumed to never need modification
    once it’s deployed. Believing this is almost ensuring the opposite is true. Code,
    particularly code without tests, has a habit of living on beyond its intended
    lifespan.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种观点认为，TDD不适用于某些它确实适用的场景——例如，如果你的代码是废弃的，或者一旦部署就被认为永远不需要修改。相信这一点几乎可以确保相反的情况是真实的。代码，尤其是没有测试的代码，往往会在其预期寿命之外继续存在。
- en: Fear of deleting code
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 删除代码的恐惧
- en: In addition to reducing the fear of changing code, tests also reduce the fear
    of *removing* code. Without tests, you’ll read some code and think “maybe something
    uses this code for some purpose I don’t quite remember.” With tests in place,
    this won’t be a concern. You’ll read the test, see that the test no longer applies
    due to a changed requirement, and then delete the test and its corresponding production
    code.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 除了减少更改代码的恐惧之外，测试还可以减少删除代码的恐惧。没有测试，你可能会阅读一些代码并想“也许有人用这段代码来达到我不太记得的目的。”有了测试，这就不会成为问题。你会阅读测试，看到由于需求的变化，测试不再适用，然后删除测试及其相应的生产代码。
- en: However, there are several scenarios in which not writing tests is acceptable.
    The two most important ones are as follows.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一些情况下不编写测试是可以接受的。其中最重要的两个如下。
- en: When quality doesn’t matter
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当质量不重要时
- en: Unfortunately, in many environments, quality doesn’t matter. Many of us can
    relate to this. We’ve worked for employers who actively disregard quality. These
    people make enough profit that they don’t *need* or *want* to care. Caring about
    quality is, unfortunately, a personal choice. If you are in a team that does not
    value quality, it will be hard to convince them that TDD is worthwhile.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在许多环境中，质量并不重要。我们中的许多人都能理解这一点。我们为那些积极忽视质量的雇主工作过。这些人赚得足够的利润，以至于他们不需要或不想关心。关心质量，不幸的是，是一个个人的选择。如果你在一个不重视质量的团队中，将很难说服他们TDD是值得的。
- en: If you’re in this situation and you have a burning desire to use TDD, then you
    have a few options. First, you can spend time convincing your colleagues that
    it is a good idea. This is never an easy task. You could also play the TDD-by-stealth
    game, in which you don’t ask permission before you start. Failing these options,
    some programmers will be fortunate enough that they can take the risk of finding
    an alternative employer that *does* value quality.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你处于这种情况，并且你迫切希望使用TDD，那么你有几个选择。首先，你可以花时间说服你的同事这是一个好主意。这从来都不是一件容易的事情。你也可以玩TDD-by-stealth游戏，在你开始之前不征求任何人的同意。如果这些选项都失败了，一些程序员可能会足够幸运，能够找到一家确实重视质量的替代雇主。
- en: Spiking and deleting code
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写和删除代码
- en: Spiking means coding without tests. We spike when we’re in uncharted territory.
    We need to find a workable approach to a problem we’ve never solved before, and
    there is likely to be a great deal of trial and error, along with a lot of backtracking.
    There is a high chance of finding *unworkable* approaches before a workable one.
    Writing tests doesn’t make much sense in this situation because many of the tests
    written along the way will ultimately end up being scrapped.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Spike意味着不进行测试的编码。我们在未知领域时进行spike。我们需要找到解决我们以前从未解决过的问题的可行方法，这很可能会涉及大量的尝试和错误，以及大量的回溯。在找到可行方法之前，找到不可行方法的可能性很高。在这种情况下编写测试没有太多意义，因为许多在过程中编写的测试最终都会被废弃。
- en: Let’s say, for example, that I’m building a web socket server and client, but
    it’s the first time I’ve used WebSockets. This would be a good candidate for spiking
    – I can safely explore the WebSocket API until I’m comfortable baking it into
    my application.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，例如，我正在构建一个WebSocket服务器和客户端，但这是我第一次使用WebSocket。这将是一个很好的spike候选者——我可以安全地探索WebSocket
    API，直到我对将其集成到我的应用程序中感到舒适。
- en: It’s important to stop spiking when you feel that you’ve hit on a workable approach.
    You don’t need a complete solution, just one that teaches you enough to set you
    off on the right path.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当你觉得你已经找到了一个可行的方案时，重要的是要停止 spiking。你不需要一个完整的解决方案，只需要一个能教会你足够知识，让你走上正确道路的方案。
- en: In the purist vision of TDD, spiking must be followed by deleting. If you’re
    going to spike, you must be comfortable with deleting your work. Unfortunately,
    that’s easier said than done; it’s hard to scrub out creative output. You must
    shake off the belief that your code is sacred. Be happy to chuck it away.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TDD 的纯粹主义视角中，spiking 必须随后进行删除。如果你要进行 spike，你必须习惯于删除你的工作。不幸的是，说起来容易做起来难；很难清除创造性输出。你必须摆脱你的代码是神圣的信念。乐于将其丢弃。
- en: In the pragmatic vision of TDD, spiking can often be followed by writing tests
    around the spiked code. I use this technique all the time. If you’re new to TDD,
    it may be wise to avoid this particular cheat until you’re confident that you
    can think out a test sequence of required tests that will cover all the required
    functionality within spike code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TDD 的实用主义视角中，spiking 常常可以随后编写围绕 spike 代码的测试。我经常使用这个技巧。如果你是 TDD 的新手，在你自信能够想出一套测试序列，覆盖
    spike 代码中所有必需的功能之前，避免使用这个特定的作弊技巧可能更明智。
- en: A purist may say that your spike code can include redundant code, and it may
    not be the simplest solution because tests will not have driven the implementation.
    There is some merit to this argument.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 纯粹主义者可能会说，你的 spike 代码可以包含冗余代码，并且它可能不是最简单的解决方案，因为测试并没有驱动实现。这个论点有一定的道理。
- en: Spiking and test-last development
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Spiking 和测试最后开发
- en: Spiking is related to the practice of **test last**, but there’s a subtle difference.
    Writing code around a spike is a TDD cheat in that you want your finished tests
    to look as if you used TDD in the first place. Anyone else coming along after
    you should never know that you cheated.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Spiking 与**测试最后**的实践有关，但存在细微的差别。围绕 spike 编写代码是 TDD 的一个作弊行为，因为你希望你的最终测试看起来就像你一开始就使用了
    TDD 一样。任何在你之后到来的人都不应该知道你作弊了。
- en: '**Test last**, however, is a more loosely defined way of testing where you
    write all the production code and then write some unit tests that prove *some*
    of the more important use cases. Writing tests like this gives you some level
    of regression coverage but none of the other benefits of TDD.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试最后**，然而，是一种更宽松的测试方式，你先编写所有生产代码，然后编写一些单元测试来证明*一些*更重要的用例。以这种方式编写测试给你提供了一定程度的回归覆盖率，但没有
    TDD 的其他好处。'
- en: Summary
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Becoming a great practitioner of TDD takes great effort. It requires practice,
    experience, determination, and discipline.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 成为 TDD 的优秀实践者需要极大的努力。这需要练习、经验、决心和纪律。
- en: Many people have tried TDD and failed. Some of them will conclude that TDD is
    broken. But I don’t believe it’s broken. It just takes effort and patience to
    get right.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人尝试过 TDD 并失败了。其中一些人可能会得出结论说 TDD 是有缺陷的。但我并不认为它是有缺陷的。只是需要努力和耐心才能做对。
- en: But what is getting it right, anyway?
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 但究竟什么是做对的呢？
- en: All software development techniques are subjective. Everything in this book
    is subjective; it is not the *right way*. It is a collection of techniques that
    I like to use, and that I have found success with. Other people have found success
    with other techniques.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 所有软件开发技术都是主观的。本书中的所有内容都是主观的；它不是*正确的方式*。这是一系列我喜欢使用并且发现成功的技巧集合。其他人也用其他技巧取得了成功。
- en: The exciting part of TDD is not the black-and-white, strict form of the process;
    it is the grays in which we can define (and refine) a development process that
    works for us and our colleagues. The TDD cycle gives us *just enough* structure
    that we can find joy in fleshing it out with our rules and our own dogma.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: TDD 的激动人心之处不在于过程的黑白、严格形式；而是在于灰色地带，我们可以定义（并完善）一个适合我们和同事的开发过程。TDD 循环给我们提供了*刚好足够*的结构，我们可以从中找到乐趣，用我们的规则和教条来充实它。
- en: I hope you have found this book valuable and enjoyable. There are many, many
    ways to test-drive React applications and I hope that this is the launchpad for
    you to evolve your testing practice.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你觉得这本书有价值且有趣。测试驱动 React 应用程序的方法有很多，我希望这能成为你发展测试实践的平台。
- en: Further reading
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章所涉及的主题，请查看以下资源：
- en: 'Useful Kata resources:'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有用的 Kata 资源：
- en: '[http://codingdojo.org/kata/](http://codingdojo.org/kata/)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://codingdojo.org/kata/](http://codingdojo.org/kata/)'
- en: '[http://codekata.com](http://codekata.com)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://codekata.com](http://codekata.com)'
- en: '[http://kata-log.rocks](http://kata-log.rocks)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://kata-log.rocks](http://kata-log.rocks)'
- en: '[https://github.com/sandromancuso/Bank-kata](https://github.com/sandromancuso/Bank-kata)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/sandromancuso/Bank-kata](https://github.com/sandromancuso/Bank-kata)'
- en: '[http://www.natpryce.com/articles/000807.xhtml](http://www.natpryce.com/articles/000807.xhtml)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.natpryce.com/articles/000807.xhtml](http://www.natpryce.com/articles/000807.xhtml)'
- en: 'Global Day of Coderetreat: [https://www.coderetreat.org](https://www.coderetreat.org)'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全球程序员重置日：[https://www.coderetreat.org](https://www.coderetreat.org)
- en: 'Getting Started with Debugging JavaScript in Chrome DevTools: [https://developers.google.com/web/tools/chrome-devtools/javascript/](https://developers.google.com/web/tools/chrome-devtools/javascript/)'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Chrome 开发者工具中开始调试 JavaScript：[https://developers.google.com/web/tools/chrome-devtools/javascript/](https://developers.google.com/web/tools/chrome-devtools/javascript/)
- en: 'Property-based testing for JavaScript: [https://github.com/leebyron/testcheck-js](https://github.com/leebyron/testcheck-js)'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 的基于属性的测试：[https://github.com/leebyron/testcheck-js](https://github.com/leebyron/testcheck-js)
