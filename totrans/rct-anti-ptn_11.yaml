- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introducing Layered Architecture in React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As React applications grow in size and complexity, managing code efficiently
    becomes a challenge. The linear growth of features can lead to an exponential
    increase in complexity, making the code base difficult to understand, test, and
    maintain. Enter **Layered Architecture**, a design approach that’s not just confined
    to backend systems but is equally beneficial for client-side applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Structuring your React application in a layered manner solves several key problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Separation of concerns**: Different layers handle different responsibilities,
    making the code base easier to navigate and understand'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reusability**: Business logic and data models become easily reusable across
    different parts of the application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testability**: A layered architecture makes it simpler to write unit and
    integration tests, leading to a more robust application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintainability**: As the application scales, making changes or adding features
    becomes significantly easier when following a layered structure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will explore the concept of layered architecture in the
    context of a React application, delving into the extraction of application concern
    layers, defining precise data models, and illustrating the use of strategy patterns.
    Through a step-by-step example, we’ll see how to practically implement these concepts
    and why they are indispensable for large-scale applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the evolution of a React application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhancing the Code Oven application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the ShoppingCart component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delving into layered architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A GitHub repository has been created to host all the code we discuss in the
    book. For this chapter, you can find the recommended structure at [https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch11](https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch11).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the evolution of a React application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applications with different sizes require different strategies. For small or
    one-off projects, you might find that all logic is just written inside React components.
    You may see one or only a few components in total. The code looks pretty much
    like HTML, with only some variables or states used to make the page “dynamic,”
    but overall, the code is easy to understand and change.
  prefs: []
  type: TYPE_NORMAL
- en: As the application grows, and more and more code is added to the code base,
    without a proper way to organize it, the code base will soon get into an unmaintainable
    state. This means that even adding small features will be time-consuming as developers
    need more time to read the code.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I’ll list several different ways we can structure our React
    application to make sure our code always remains in a healthy state, making it
    effortless to add new features and easy to extend or fix existing defects. We’ll
    start with a simple structure and gradually evolve it to handle scale problems.
    Let’s have a quick review of the steps to build frontend applications that scale.
  prefs: []
  type: TYPE_NORMAL
- en: Single-component applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start, let’s talk about the simplest possible approach to writing a React
    application – a single-component application.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 11.1: Single-component applic\uFEFFation](img/B31103_11_01.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.1: Single-component application'
  prefs: []
  type: TYPE_NORMAL
- en: The mono-component undertakes a variety of tasks, ranging from fetching data
    from a remote server, managing its internal state, and handling domain logic,
    to rendering. This approach may be suitable for small applications with a single
    form or for those looking to understand the process of transitioning their application
    from another framework to React.
  prefs: []
  type: TYPE_NORMAL
- en: However, you’ll soon realize that consolidating everything into a single component
    can make the code difficult to understand and manage. Everything being housed
    in one component can quickly become overwhelming, particularly when dealing with
    logic such as iterating over item lists to create individual components. This
    complexity highlights the need to decompose the mono-component into smaller, responsibility-focused
    components.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple-component applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Deciding to split the component into several components, with these structures
    reflecting what’s happening on the resulting HTML, is a good idea and it helps
    you to focus on one component at a time.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2: Multiple-component application](img/B31103_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.2: Multiple-component application'
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, you’ll transition from a monolithic component to multiple components,
    each with a specific purpose. For example, one component may be dedicated to rendering
    a list, another to rendering a list item, and another solely for fetching data
    and passing data down to its children.
  prefs: []
  type: TYPE_NORMAL
- en: It’s better to have clear responsibilities. However, as your application expands,
    responsibilities extend beyond the view layer to include tasks such as sending
    network requests, reshaping data for the view to consume, and collecting data
    to send back to the server. Additionally, there might be logic to transform data
    once it’s fetched. Housing this calculation logic within views doesn’t seem appropriate
    as it’s not directly related to user interfaces. Moreover, some components may
    become cluttered with excessive internal states.
  prefs: []
  type: TYPE_NORMAL
- en: State management with Hooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s a better idea to split this logic into separate places. Luckily, in React,
    you can define your own Hooks. This is a great way to share this state and the
    logic whenever state changes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3: State management with Hooks](img/B31103_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.3: State management with Hooks'
  prefs: []
  type: TYPE_NORMAL
- en: Now you have a bunch of elements extracted from components. You have a few pure
    presentational components, some reusable Hooks that make other components stateful,
    and some container components (for data fetching, for example).
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, it’s common to find calculations scattered across views, Hooks,
    or various utility functions. The lack of structure can make further modifications
    quite challenging and prone to errors. For instance, if you’ve fetched some data
    for rendering, but the data schema differs in views, you’ll need to transform
    the data. However, the location for placing this transforming logic may not be
    clear.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting business models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, you’ve started to become aware that extracting this logic into yet another
    place can bring you many benefits. For example, with that split, the logic can
    be cohesive and independent of any views. Then, you extract a few domain objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'These simple objects can handle data mapping (from one format to another),
    check nulls, and use fallback values as required. As the amount of these domain
    objects grows, you will find you need some inheritance or polymorphism to make
    things even cleaner. Thus you apply many design patterns you find helpful from
    other places to the frontend application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4: Extracting business models](img/B31103_11_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.4: Extracting business models'
  prefs: []
  type: TYPE_NORMAL
- en: Now, your code base has expanded with more elements, each having a clear boundary
    regarding their responsibilities. Hooks are employed for state management, while
    domain objects represent domain concepts, such as a user object encompassing an
    avatar, or a `PaymentMethod` object representing the details of a payment method.
  prefs: []
  type: TYPE_NORMAL
- en: As we segregate different elements from the views, the code base scales accordingly.
    Eventually, it reaches a point where we need to structure the application to respond
    to changes more efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Layered frontend application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the application continues to evolve, certain patterns begin to emerge. You’ll
    notice a collection of objects that don’t belong to any user interface, and they
    remain indifferent to whether the underlying data originates from a remote service,
    local storage, or cache. Consequently, you’ll want to segregate them into distinct
    layers. We’ll need to introduce a better approach for these different parts of
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5: Layered frontend application](img/B31103_11_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.5: Layered frontend application'
  prefs: []
  type: TYPE_NORMAL
- en: As illustrated in *Figure 11**.5*, we can allocate different parts to separate
    folders, each distinctly and physically isolated from the others. This way, if
    there’s a need to modify models, you won’t need to navigate through the views
    folder, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: That was a high-level overview of the evolution process, and you should have
    a taste of how you should structure your code or at least what the direction should
    be. In larger-scale applications, you’ll likely encounter a variety of modules
    and functions, each tailored to different aspects of the app. This could include
    a request module for handling network requests, or adapters designed to interface
    with various data vendors, such as Google’s login API or payment gateway clients.
  prefs: []
  type: TYPE_NORMAL
- en: However, there will be many details, such as how to define a model, how to access
    a model from views or Hooks, and so on. You need to consider this before applying
    the theory to your application.
  prefs: []
  type: TYPE_NORMAL
- en: Read more
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find a detailed explanation of Presentation Domain Data Layering here:
    [https://martinfowler.com/bliki/PresentationDomainDataLayering.html](https://martinfowler.com/bliki/PresentationDomainDataLayering.html).'
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, I’ll guide you through expanding the Code Oven application
    we introduced in [*Chapter 7*](B21103_07.xhtml#_idTextAnchor176), to showcase
    essential patterns and design principles for large frontend applications.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing the Code Oven application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recall that at the end of [*Chapter 7*](B21103_07.xhtml#_idTextAnchor176), we
    developed the basic structure of a pizza store application named Code Oven, leveraging
    test-driven development to establish a solid foundation for the app.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6: The Code Oven application](img/B31103_11_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.6: The Code Oven application'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Remember that we employed the design mockup as a guide, not to implement all
    the details exhaustively. The primary goal remains to illustrate how to refactor
    the code while preserving its maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: Although we didn’t delve much into feature implementation in that chapter, in
    this chapter, we’ll extend our setup further. We’ll explore how different architectural
    types can assist us in managing complexity.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a refresher, by the end of [*Chapter 7*](B21103_07.xhtml#_idTextAnchor176),
    our structure looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And we assumed the data to be in this shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: While this setup allows consumers to browse what the restaurant offers, it would
    be significantly more useful if we enabled online ordering. However, one immediate
    issue is that the pizzas lack prices and descriptions, crucial for supporting
    online orders. Descriptions are also vital as they list the ingredients, informing
    consumers of what’s included.
  prefs: []
  type: TYPE_NORMAL
- en: Saying that, it’s actually not practical to define menu data within the JavaScript
    code. Typically, we’d have a service hosting such data, providing more detailed
    information.
  prefs: []
  type: TYPE_NORMAL
- en: 'To show this, suppose we have data hosted on the [https://api.code-oven.com/menus](https://api.code-oven.com/menus)
    remote service, defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To bridge the gap between our app and this data, we need to define a type for
    the remote data, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to integrate this remote menu data, we’ll utilize `useEffect` to fetch
    the data, and then display the items once fetched. We’ll make these changes within
    the `MenuList` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `MenuList` component fetches a list of menu items from an external
    API upon the initial render and displays this list. Each item comes with an `onAddMenuItem`
    function, passed as a prop to `MenuList`, with the item name as its argument.
  prefs: []
  type: TYPE_NORMAL
- en: By mapping `RemoteMenuItem` to a string after fetching the data, we ensure our
    tests continue to pass.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we aim to reveal the price and display the ingredients from the data to
    the UI components. However, given the potentially long list of ingredients, we’ll
    only show the first three to avoid occupying too much screen space. Also, we want
    to use lowercase `category` and rename it to `type`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initially, we define a new type to better structure our data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `MenuItem` type includes the item’s `id`, `name`, `price`, `ingredients`,
    and `type` properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it’s time to update our `MenuList` component to use this new type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the `MenuList` component, we’ve now made use of the `MenuItem` type in our
    `useState` Hook. The `fetchMenuItems` function, triggered within `useEffect`,
    reaches out to the API, fetches the menu items, and maps over them to transform
    the data into the desired `MenuItem` format. This transformation includes retaining
    only the first three items from the `ingredients` array for each item.
  prefs: []
  type: TYPE_NORMAL
- en: Each `MenuItem` component is then rendered as a list item within the component.
    We display the item’s name, price, and iterate over the `ingredients` array to
    render each ingredient.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the code is functional, there’s a concern: we’ve intertwined network
    requests, data mapping, and rendering logic within a single component. It’s a
    sound practice to separate view-related code from non-view code, ensuring cleaner,
    more maintainable code.'
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the MenuList through a custom Hook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’re no strangers to using custom Hooks for data fetching – it’s a practice
    that enhances readability and organizes logic neatly. In our scenario, extracting
    the `menuItems` state and the fetching logic into a separate Hook will declutter
    the `MenuList` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s create a Hook named `useMenuItems`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Within the `useMenuItems` Hook, we initialize the `menuItems` state with an
    empty array. When the Hook mounts, it triggers the `fetchMenuItems` function that
    fetches data from the specified URL. Following the fetch, a mapping operation
    is performed to convert each `RemoteMenuItem` object to a `MenuItem` object. The
    transformation details are omitted here, but it’s where we adapt the fetched data
    to the desired format. Subsequently, the transformed menu items are set to the
    `menuItems` state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in our `MenuList` component, we can simply call `useMenuItems` to obtain
    the `menuItems` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This refactoring is quite beneficial, redirecting `MenuList` back to a streamlined
    state and reinstating its single responsibility. However, when we shift our focus
    to the `useMenuItems` Hook, particularly the data mapping segment, a few operations
    occur. It fetches data and trims off some unused fields such as `description`
    and `calories` from the remote data. It also encapsulates the logic to retain
    only the first three ingredients. Ideally, we’d like to centralize this transformation
    logic into a common location, ensuring a tidy and manageable code structure.
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning to a class-based model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As touched upon in [*Chapter 8*](B21103_08.xhtml#_idTextAnchor212), employing
    the `MenuItem` type definition into a class, hence centralizing all mapping logic
    within this class. This setup will serve as a dedicated hub for any future data
    shape alterations and related logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Transitioning `MenuItem` from a type to a class is straightforward. We require
    a constructor to accept `RemoteMenuItem` and some getter functions to access the
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the `MenuItem` class, we define private `readonly` properties for `id`, `name`,
    `type`, `price`, and `ingredients`. The constructor initializes these properties
    using values from a `RemoteMenuItem` object passed to it. We then have getter
    methods for each property to provide read-only access to their values. Particularly,
    the `ingredients` getter returns only the first three items from the `ingredients`
    array.
  prefs: []
  type: TYPE_NORMAL
- en: Though, at a glance, this setup seems to have more code compared to a simple
    type definition, it effectively encapsulates the data and exposes it in a controlled
    manner. This aligns with the principles of immutability and encapsulation. The
    class structure’s beauty is its capability to house behaviors – in our case, the
    slicing logic for ingredients is tucked neatly within the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this new class in place, our `useMenuItems` Hook becomes more streamlined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, the `useMenuItems` Hook merely maps over the fetched menu items, creating
    a new instance of `MenuItem` for each, which significantly tidies up the transformation
    logic previously housed within the Hook.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of a class-based model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Transitioning to a class-based model from a simple type comes with a set of
    advantages that could serve our application well in the long run:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Encapsulation**: A class brings related properties and methods under one
    roof, thus promoting clear structure and organization. It also restricts direct
    data access, fostering better control and data integrity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Method behavior**: For complex behaviors or operations associated with a
    menu item, a class provides a structured platform to define these methods, whether
    they relate to data manipulation or other business logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inheritance and polymorphism**: In the case of a hierarchy or polymorphic
    behavior among menu items, a class structure is indispensable. It allows different
    menu item types to inherit from a common base class, overriding or extending behavior
    as needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistent interface**: Classes ensure a consistent interface to the data,
    which is invaluable when multiple application parts interact with menu items.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Read-only properties**: Classes enable the definition of read-only properties,
    thereby controlling data mutation. This is a crucial aspect of maintaining data
    integrity and working with immutable data structures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, as we transition into expanding our application’s functionality with a
    shopping cart, it’s crucial to approach this new section with the lessons learned
    from our data modeling exercise. This will ensure a structured and effective implementation,
    paving the way for a user-friendly online ordering experience.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the ShoppingCart component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we venture into the implementation of the `ShoppingCart` component, we will
    aim to provide a seamless interface for users to review their selected items before
    proceeding to the checkout. Besides displaying the items, we also intend to reward
    our customers with some appealing discount policies.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [*Chapter 7*](B21103_07.xhtml#_idTextAnchor176), we defined a rudimentary
    `ShoppingCart` component, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `ShoppingCart` component accepts a `cartItems` prop, which is an array of
    strings. It returns a `div` tag containing an ordered list (`<ol>`), where each
    item in the `cartItems` array is rendered as a list item (`<li>`). Below the list,
    a `cartItems` array is empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, to enhance the user experience, it’s crucial to display the price
    for each item and the total amount beneath the item list, yet above the **Place
    My Order** button. Here’s how we can augment our component to fulfill these requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `ShoppingCart` component is now equipped to accept a `cartItems` prop, which
    comprises an array of `MenuItem` objects (instead of a simple string). To compute
    the total price of items in the cart, we employ the `reduce` method. This method
    iterates over each item, accumulating their prices to present a total. The component
    then returns a JSX markup that renders a list of cart items, each displaying its
    name and price.
  prefs: []
  type: TYPE_NORMAL
- en: This revamped `ShoppingCart` component not only enhances the clarity of the
    order for users but also lays down a foundation for introducing discount policies,
    which we can explore as we continue refining our application.
  prefs: []
  type: TYPE_NORMAL
- en: Applying discounts to Items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s assume we have different discount policies for different types of menu
    items. For instance, pizzas with more than three toppings receive a 10 percent
    discount, while large pasta dishes enjoy a 15 percent discount.
  prefs: []
  type: TYPE_NORMAL
- en: 'To incorporate this, we initially attempt to extend the `MenuItem` class with
    a new field called `calculateDiscount`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: However, we encounter a problem – since pasta dishes don’t have toppings, this
    leads to a type error.
  prefs: []
  type: TYPE_NORMAL
- en: 'To resolve this, we first extract an interface named `IMenuItem`, and then
    have `PizzaMenuItem` and `PastaMenuItem` classes implement this interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define an abstract class to implement the interface, allowing `PizzaMenuItem`
    and `PastaMenuItem` to extend the abstract class respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the `AbstractMenuItem` class, we introduced a static `from` method. This
    method takes an `IMenuItem` instance and transforms it into a `RemoteMenuItem`
    instance, preserving the necessary fields for our application.
  prefs: []
  type: TYPE_NORMAL
- en: The `calculateDiscount` method is declared as an abstract method, requiring
    its child classes to implement the actual discount calculation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: An **abstract class** serves as a base class for other classes and cannot be
    instantiated on its own. It’s a way to define a common interface and/or implementation
    for a set of derived classes. Abstract classes often contain abstract methods,
    which are declared without implementations, leaving it to derived classes to provide
    specific implementations. By doing so, abstract classes enable a common structure
    while ensuring that certain methods are implemented in derived classes, promoting
    a consistent behavior across all derived types. They are a key feature in object-oriented
    programming, supporting polymorphism and encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to override and put the actual `calculateDiscount` logic in sub-classes.
    For `PizzaMenuItem`, it simply extends `AbstractMenuItem` and implements `calculateDiscount`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PizzaMenuItem` class extends `AbstractMenuItem`, inheriting its properties
    and methods. It defines a private `readonly` property, `toppings`, to hold the
    number of toppings. In the constructor, it takes two arguments: `RemoteMenuItem`
    and `toppings` (which indicates the number of toppings). It calls the constructor
    of `AbstractMenuItem` with `item` using `super(item)` and initializes `this.toppings`
    with the passed-in `toppings` argument.'
  prefs: []
  type: TYPE_NORMAL
- en: The `calculateDiscount` method is implemented to return a 10% discount if the
    number of toppings is 3 or more. This method overrides the abstract `calculateDiscount`
    method from `AbstractMenuItem`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can create a `PastaMenuItem` class like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The relationship of these classes can be visualized as in *Figure 11**.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.7: Model classes](img/B31103_11_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.7: Model classes'
  prefs: []
  type: TYPE_NORMAL
- en: The `AbstractMenuItem` abstract class implements the `IMenuItem` interface and
    uses `RemoteMenuItem`. Both `PizzaItem` and `PastaItem` are extending `AbstractMenuItem`
    and have their own logic for calculating the discount.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in the `MenuList` component, when adding items to the shopping cart,
    we create instances of the right class based on the item type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `handleAddMenuItem` function transforms the `IMenuItem` object item into
    a `RemoteMenuItem` object using the `AbstractMenuItem.from(item)` method. Following
    this, it checks the type property of the item to determine whether it’s a pizza
    or pasta. If it’s a pizza, a new `PizzaMenuItem` instance is created using `remoteItem`
    and the selected number of toppings, and this new item is added to the cart via
    the `onAddMenuItem` function. If the item is neither a pizza nor pasta, the original
    item is added to the cart directly through the `onAddMenuItem` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, within the `ShoppingCart` component, we calculate the total discount
    value similarly to how we calculated the total price, and use it for rendering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `ShoppingCart` component calculates `totalPrice` by iterating over the `cartItems`
    array and summing up the price of each item. Similarly, it calculates `totalDiscount`
    by summing up the discounts for each item, obtained by calling the `calculateDiscount()`
    method on each item. In the returned JSX, it renders a list and displays `totalDiscount`
    and the final total price (which is `totalPrice` minus `totalDiscount`) below
    the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this juncture, the function operates effectively. Nonetheless, there are
    several factors to contemplate – the discount is currently specified on each product:
    for instance, pizza has its own discount rule while pasta has its own. What would
    be our approach if we need to implement a store-wide discount, such as a discount
    for a public holiday?'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Strategy pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose it’s a bustling Friday night, and we wish to offer a special discount
    on all pizzas and drinks. However, we don’t intend to apply additional discounts
    on items already discounted — for instance, a pizza with four toppings should
    only receive this specific special discount.
  prefs: []
  type: TYPE_NORMAL
- en: Handling such arbitrary discounts can be complex, necessitating a decoupling
    of the calculation logic from the item type. Moreover, we’d like the flexibility
    to remove these discounts after Friday or after a certain period.
  prefs: []
  type: TYPE_NORMAL
- en: We can use a design pattern called the **Strategy pattern** to achieve flexibility
    here. The Strategy pattern is a behavioral design pattern that enables selecting
    an algorithm’s implementation at runtime. It encapsulates a family of algorithms
    and makes them interchangeable, allowing the client to choose the most suitable
    one without modifying the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll extract the logic into a separate entity, defining a strategy interface
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This interface provides a blueprint for different discount strategies. For
    example, we could have a strategy with no discount:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `NoDiscountStrategy` class implements the `IDiscountStrategy` interface
    with a `calculate` method that takes a price as input and returns zero, meaning
    no discount is applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'And for `SpecialDiscountStrategy` component, a special discount strategy offering
    a 15% discount will be applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To utilize these strategies, we need to slightly modify the `IMenuItem` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We added `discountStrategy` with type `IDiscountStrategy` in the `IMenuItem`
    interface. And because we moved the logic of calculating discount into strategy,
    we don’t need the `calculateDiscount` abstract method in `AbstractMenuItem` anymore
    and the class will no longer remain abstract, so we renamed it to `BaseMenuItem`
    instead. Instead, it will incorporate a setter for the discount strategy and implement
    the discount calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `BaseMenuItem` class now implements the `IMenuItem` interface and encapsulates
    a discount strategy, initially set to `NoDiscountStrategy`. It defines a setter
    to update the discount strategy, and a `calculateDiscount` method, which delegates
    the discount calculation to the encapsulated discount strategy’s `calculate` method,
    passing the item’s price as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11**.8* should now give you a much clearer idea of what the relationships
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.8: The class diagram of all the classes](img/B31103_11_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.8: The class diagram of all the classes'
  prefs: []
  type: TYPE_NORMAL
- en: As observed, `BaseMenuItem` implements the `IMenuItem` interface and utilizes
    `IDiscountStrategy`. There are multiple implementations of the `IDiscountStrategy`
    interface for specific discount algorithms, and several classes extend the `BaseMenuItem`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `RemoteMenuItem` type is used by all the classes implementing
    the `IMenuItem` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when we need to apply a particular strategy, it can be done effortlessly,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the `MenuList` component, the `handleAddMenuItem` function checks if today
    is Friday using the `isTodayFriday` function. If it is, it sets `discountStrategy`
    of the item to a new instance of `SpecialDiscountStrategy` before passing the
    item to the `onAddMenuItem` function, which is received as a prop. This way, a
    special discount is applied to the menu item on Fridays.
  prefs: []
  type: TYPE_NORMAL
- en: 'This setup grants us the desired flexibility. For instance, in the `handleAddMenuItem`
    function, depending on whether it’s Friday or the item is a pizza, we can easily
    switch the discount strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this `handleAddMenuItem` function, depending on certain conditions, a different
    discount strategy is applied to the item before it’s passed to the `onAddMenuItem`
    function. Initially, it checks if today is Friday using `isTodayFriday()` and,
    if true, it assigns a new instance of `SpecialDiscountStrategy` to `item.discountStrategy`.
    However, if the item is of type `pizza`, irrespective of the day, it overwrites
    `item.discountStrategy` with a new instance of `PizzaDiscountStrategy`.
  prefs: []
  type: TYPE_NORMAL
- en: This approach keeps our discount logic modular and easy to adjust, catering
    to different scenarios with minimal code modification. As we’re extracting new
    logic components – Hooks, data models, domain logic (discount strategies), and
    views – out of the application code, it’s evolving into a layered frontend application.
  prefs: []
  type: TYPE_NORMAL
- en: Delving into layered architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our application has transitioned wonderfully to a more robust state, with clear,
    understandable, and modifiable logic, which is now also more test-friendly.
  prefs: []
  type: TYPE_NORMAL
- en: 'A further refinement I envision is relocating the logic present in `ShoppingCart`
    to a custom Hook. We can do this like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `useShoppingCart` Hook accepts an array of `IMenuItem` objects and computes
    two values – `totalPrice` and `totalDiscount`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`totalPrice` is calculated by reducing the items, summing up their `price`
    property'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`totalDiscount` is calculated by reducing the items, summing up the discount
    for each item obtained by calling `item.calculateDiscount()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both calculations are wrapped in `useMemo` to ensure they are only recomputed
    when the items array changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this modification, `ShoppingCart` becomes elegantly simplified and can
    easily utilize these values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: An alternative approach would be employing the context and `useReducer` Hook
    to manage all logic within context and Hooks, however, since we explored that
    in [*Chapter 8*](B21103_08.xhtml#_idTextAnchor212), I’ll leave further exploration
    to you (you can use both code examples provided in [*Chapter 8*](B21103_08.xhtml#_idTextAnchor212)
    and this chapter and try to use `context` and `useReducer` to simplify `ShoppingCart`).
  prefs: []
  type: TYPE_NORMAL
- en: The layered structure of the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ve delved into organizing components and models into separate files; it’s
    equally vital to continue refining our project structure. Functions with distinct
    responsibilities should reside in different folders, streamlining navigation through
    the application and saving time. Our application now exhibits a fresh structural
    anatomy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: And that’s how the layers formed. Within the view layer, we have primarily pure
    TSX rendering straightforward tags. These views leverage Hooks for state and side
    effect management. Meanwhile, in the model layer, model objects encompass business
    logic, algorithms for toggling between different discount strategies, and data
    shape transformations, among other functionalities. This structure promotes separation
    of concerns, making the code organized, reusable, and easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note the one-directional link here; the upper layer accesses
    the lower layer, but not vice versa. TSX uses Hooks for state management, and
    Hooks employ models for calculations. However, we can’t use JSX or Hooks in the
    model layer. This layering technique facilitates change or replacement in the
    underlying layers without impacting the upper layers, promoting a clean and maintainable
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: In our Code Oven application, as illustrated in *Figure 11**.9*, the layout
    features a menu items list on the left and a shopping cart on the right. Within
    the shopping cart, each item displays detailed discount and price information
    on the page.
  prefs: []
  type: TYPE_NORMAL
- en: "![Fig\uFEFFure 11.9: Final look and feel of the application](img/B31103_11_09.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.9: Final look and feel of the application'
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of layered architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The layered architecture confers numerous benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enhanced maintainability**: The division of a component into distinct segments
    facilitates easier identification and rectification of defects in specific code
    sections, thus minimizing time spent and reducing the likelihood of engendering
    new bugs during modifications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Increased modularity**: This architecture is inherently more modular, promoting
    code reuse and simplifying the addition of new features. Even within each layer,
    such as views, the code tends to be more composable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhanced readability**: The logic within the code becomes significantly more
    understandable and navigable, an asset not only for the original developer but
    also for others who may interact with the code base. This clarity is central to
    effecting changes in the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved scalability**: The reduced complexity within each module renders
    the application more scalable, making it easier to introduce new features or alterations
    without impacting the entire system—a critical advantage for large, complex applications
    projected to evolve over time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tech-stack migration**: Albeit unlikely in most projects, should the need
    arise, the view layer can be replaced without altering the underlying models and
    logic, thanks to the encapsulation of domain logic in pure JavaScript (or TypeScript)
    code, oblivious to the views’ existence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we implemented layered architecture in our application, enhancing
    its maintainability, modularity, readability, scalability, and potential for tech-stack
    migration. By segregating logic, refining the `ShoppingCart` component through
    a custom Hook, and organizing the application into distinct layers, we’ve significantly
    bolstered the code’s structure and ease of management. This architectural approach
    not only streamlines the current code base but also lays a solid foundation for
    future expansions and refinements.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll look at the end-to-end journey of implementing an
    application from scratch, using the user acceptance test-driven development approach,
    doing refactoring, cleaning up along the way, and always keeping our code as clean
    as we can.
  prefs: []
  type: TYPE_NORMAL
