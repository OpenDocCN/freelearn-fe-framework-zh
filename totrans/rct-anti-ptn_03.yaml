- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Organizing Your React Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to a chapter dedicated to unraveling the various strategies to structure
    a React project. Here, we’ll take a step beyond code and delve into the fascinating
    world of application architecture – an essential aspect of software development
    that often doesn’t receive as much attention in the frontend world as it should.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn about different React project structuring strategies
    – including the feature-based structure, component-based structure, atomic design
    structure, and **Model-View-ViewModel** (**MVVM**) structure – and the unique
    advantages and potential pitfalls that each approach brings to the table. You’ll
    also be exposed to practical examples of these structures, gain insights into
    when to use one over another, and explore the trade-offs that come with each decision.
  prefs: []
  type: TYPE_NORMAL
- en: But why should we care about project structure in the first place? A well-structured
    project can significantly enhance code maintainability, make it easier for new
    team members to understand the system and improve scalability, and even influence
    the overall success of the project. In contrast, an inefficient structure can
    lead to code smells and increased complexity, and it can become a source of technical
    debt.
  prefs: []
  type: TYPE_NORMAL
- en: By understanding these structuring strategies, you’ll be better equipped to
    make decisions that can have a long-lasting impact on your project’s health and
    success. You’ll be able to assess your project’s specific needs and constraints
    and use these strategies as a guiding light, enabling you to create a structure
    that improves code quality, fosters a productive development environment, and
    ultimately leads to a successful project.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the problem of a less-structured project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the complications of frontend applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring common structures in React applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping your project structure organized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A GitHub repository has been created to host all the code we’ll discuss in this
    book. For this chapter, you can find the recommended structure at [https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch3](https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch3).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the problem of a less-structured project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The rapid growth of a project can be astonishing, leading to a sense of things
    spiraling out of control. Initializing a frontend project is typically straightforward,
    and for small-scale projects, there may be little concern regarding file structure
    since the number of files to manage is minimal. However, as the project expands,
    the need for proper file organization becomes apparent:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1: A simple project might not need a structure](img/B21103_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: A simple project might not need a structure'
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem with having a less-structured project is that it can lead to several
    challenges and difficulties in managing and maintaining the code base effectively.
    Some of the key problems that arise from a lack of structure are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Code disorganization**: Without a clear structure, it becomes harder to locate
    specific code files or components. This can result in wasted time and effort spent
    searching for relevant code, especially as the project becomes larger.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Poor code reusability**: Without a proper structure, it becomes challenging
    to identify reusable components or functions. This can lead to code duplication
    and a lack of consistency, making it harder to maintain and update the code base
    in the long run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Difficulty in collaboration**: When team members are working on a less-structured
    project, it becomes harder to understand and navigate each other’s code. This
    can lead to communication gaps, slower development, and an increased risk of introducing
    bugs or conflicts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability issues**: As the project expands and new features are added,
    the lack of structure can make it challenging to integrate new components seamlessly.
    This can result in a tangled code base that is difficult to extend or modify,
    leading to decreased productivity and increased development time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintenance complexity**: Without a clear organization, maintaining the code
    base becomes more complex. Making changes or fixing issues can become a time-consuming
    task as there may be a lack of consistency in how code is structured or named.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before proposing a recommended project structure, let’s look at the typical
    components of a modern frontend project. Understanding these components will provide
    a foundation for designing an effective project structure.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the complications of frontend applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a medium-sized frontend project, you may be surprised by the multitude of
    components required for its successful implementation. Alongside the core features,
    numerous other elements contribute to the project’s functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'The folder structure of a React project provides a glimpse into the various
    aspects you’ll need to manage within a typical React code base:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source code**: This is the heart of your application and contains the JavaScript/TypeScript
    files that contain your application’s logic, HTML files for structure, and style
    files for appearance. Everything that defines the operation and user interface
    of your application is found here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Assets**: This category holds all the static files, such as images, videos,
    and fonts, that are utilized by your application. These files are essential in
    enhancing the visual experience and interaction of your application, contributing
    to its overall look and feel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`package.json` and environment-specific variables to the rules for building
    your project, these files are crucial for the operation and deployment of your
    application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tests**: This category is dedicated to ensuring the correctness and stability
    of your application. It holds all the unit, integration, and **end-to-end tests**
    that simulate user behavior, validate interactions, and check the functionality
    of your application, helping to catch and prevent potential bugs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`README` file providing an overview of the project to the API documentation
    and the style guide for coding, these documents help maintain consistency, understanding,
    and ease of use for anyone interacting with the project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build artifacts**: These are the outputs of the build process, including
    bundled and optimized JavaScript, CSS, and HTML files ready for deployment, and
    other temporary or diagnostic files that help debug build issues. They’re key
    to distributing your application to end users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Development tools and configurations**: This is the toolkit that enforces
    code quality, formatting, and version control and facilitates automated testing
    and deployment processes. They work in the background, ensuring a smooth, error-free,
    and efficient development process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collectively, these diverse components form the foundation of a typical React
    code base, highlighting the complexity and breadth of considerations involved
    in medium-sized frontend projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exploring each feature folder can be an enjoyable experience as it unravels
    a variety of elements:'
  prefs: []
  type: TYPE_NORMAL
- en: Common components, such as modal dialogs, navigation menus, buttons, and cards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dedicated components tailored to specific features, such as `SpecialOffer` for
    special offers that only display on the menu page or `PayWithApple` for pay with
    ApplePay
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Style definitions using CSS-in-JS or SCSS/LESS code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various types of testing code, including unit tests and browser tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculation logic encapsulated within utility/helper functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom Hooks for reusable functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contexts for security, **internationalization** (**i18n**), and other specific
    needs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional configuration files such as `eslint config`, `jest config`, `webpack
    settings`, and more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given the multitude of files, how can we arrange them in a manner that facilitates
    easy navigation and quick access for modifications? While there is no one-size-fits-all
    solution, consistently organizing the code base can greatly assist in this endeavor.
  prefs: []
  type: TYPE_NORMAL
- en: Consistency is paramount when it comes to naming and structuring code elements.
    Regardless of the approach that’s chosen, it is crucial to maintain uniformity
    throughout the project. For example, if you decide to place style files alongside
    their respective components, it is essential to adhere to this convention across
    all components in the code base.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, if a `tests` folder is being used to house test files, ensure to
    maintain this convention consistently across the entire code base. For instance,
    other naming patterns such as `__tests__` or `specs` should be avoided to prevent
    confusion and maintain uniformity.
  prefs: []
  type: TYPE_NORMAL
- en: Having grasped the complexity inherent in medium to large-sized projects, and
    acknowledging the challenges that a disorganized code base can pose, it’s time
    we explore some tried-and-tested approaches to structuring our code. These strategies
    aim to simplify the development process and make life easier for developers.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring common structures in React applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many different ways of organizing a large React application. In the
    following subsections, we will discuss the four most common structures:'
  prefs: []
  type: TYPE_NORMAL
- en: Feature-based structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component-based structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Atomic design structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MVVM structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each structure has its own set of benefits and drawbacks, and the choice depends
    on the specific requirements and complexity of the project. Sometimes, we might
    need to mix them in some way so that they fit our project-specific needs.
  prefs: []
  type: TYPE_NORMAL
- en: To explore these different structure methods further, we’ll use an online shopping
    application as an example since it’s relatively complicated and you should have
    some familiarity with that domain already. The application also contains elements
    such as API calls, routers, and state management.
  prefs: []
  type: TYPE_NORMAL
- en: Feature-based structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Feature-based structure** means the application is organized based on features
    or modules. Each feature contains its own set of components, views, API calls,
    and state management, allowing for clear separation and encapsulation of functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With a feature-based architecture in the context of online shopping, you can
    organize your files and folders as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2: Feature-based structure](img/B21103_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: Feature-based structure'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at this structure:'
  prefs: []
  type: TYPE_NORMAL
- en: The `features` directory represents different features of the application, such
    as `Home`, `Cart`, `ProductDetails`, `Checkout`, `Profile`, and more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each feature has a folder containing `components`, `containers`, `pages`, `services`,
    `types`, and `utils` related to that feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `shared` directory contains reusable `components`, `containers`, `services`,
    `types`, and `utils` that can be shared across multiple features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `api` directory houses modules for making API calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `store` directory contains modules for state management (for example, Redux)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `router` directory contains the routing configuration and related components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `App.tsx` file serves as the entry point of the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This method has the following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Clear separation of concerns**: Each feature has a folder, making it easier
    to locate and modify related code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modularity**: Features are self-contained, allowing for easier testing, maintenance,
    and reuse'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: New features can be added without directly impacting existing
    code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Team collaboration**: Developers can work on different features concurrently
    with minimal conflicts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, it has the following drawback:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Potential duplication**: Features may share similar components or logic,
    leading to some duplication. Careful planning and refactoring can help mitigate
    this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component-based structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Component-based structure** means the application is organized around reusable
    components. Components are categorized based on their functionality and can be
    composed together to build larger views.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With a component-based architecture in the context of online shopping, you
    can organize your files and folders as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3: Component-based structure](img/B21103_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: Component-based structure'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at this structure:'
  prefs: []
  type: TYPE_NORMAL
- en: The `components` folder contains individual components related to various features
    of the online shopping application. Each component is organized into a folder,
    which may contain child components as necessary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `routes` folder handles frontend routing in the application. It includes
    the main `AppRouter.tsx` file, which configures the routing logic, and the `routes.tsx`
    file, which defines the individual routes and their corresponding components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `api` folder contains separate files for different API domains or functionalities.
    These files, such as `products.ts`, `cart.ts`, `auth.ts`, and `payment.ts`, handle
    the API calls related to their respective domains.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The example also assumes the use of a state management library such as Redux
    or React Context API for managing the global application state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This method has the following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Modularity**: The component-based structure promotes modularity by organizing
    components into separate files and folders based on their functionality. This
    enhances code maintainability and reusability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Separation of concerns**: Each component focuses on its specific functionality,
    leading to clearer code and easier debugging. The separation of concerns improves
    code readability and maintainability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code reusability**: With components organized in a modular structure, it
    becomes easier to reuse components across the application or in future projects,
    leading to improved development efficiency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, it has the following drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Project complexity**: As the project grows, maintaining a complex component
    structure can become challenging. It requires careful planning and adherence to
    best practices to avoid component sprawl and keep the structure manageable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Learning curve**: The initial learning curve for component-based development
    and TypeScript may be steeper for developers who are new to these concepts. However,
    the benefits that are gained in terms of code organization and maintainability
    outweigh the initial learning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`components` folder, you may find smaller elements that are identical or closely
    resemble those in other component folders. The more you break down these components
    into finer parts, the greater the likelihood of identifying components that can
    be reused. When such reusable components emerge, it’s a good practice to place
    them in a “shared” folder, like what is shown in a feature-based structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Atomic design structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Atomic design** is a methodology for designing and organizing user interfaces.
    It emphasizes the construction of user interfaces by breaking them down into small,
    reusable components called atoms, which are combined to form molecules, organisms,
    templates, and pages.'
  prefs: []
  type: TYPE_NORMAL
- en: The key idea behind atomic design is to create a systematic approach to building
    UI components that encourages reusability, scalability, and maintainability. It
    provides a clear structure for organizing and naming components, making it easier
    to understand and navigate the UI code base.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how the atomic design methodology categorizes UI components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Atoms**: Atoms are the smallest building blocks of a UI and represent individual
    elements such as buttons, inputs, icons, or labels. They are typically simple
    and self-contained.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Molecules**: Molecules are combinations of atoms and represent more complex
    UI components. They encapsulate a group of atoms working together to form a functional
    unit, such as a form field or a navigation bar.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Organisms**: Organisms are larger components that combine molecules and/or
    atoms to create more significant sections of a UI. They represent distinct sections
    of a user interface, such as a header, sidebar, or card component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Templates**: Templates provide a layout structure for arranging organisms
    and/or molecules. They define the overall skeleton of a page or a specific section
    of a UI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pages**: Pages represent complete user interface screens that are composed
    of templates, organisms, molecules, and atoms. They represent the final output
    visible to the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With an atomic design architecture in the context of online shopping, you can
    organize your files and folders as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.4: Atomic design structure](img/B21103_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4: Atomic design structure'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at this structure:'
  prefs: []
  type: TYPE_NORMAL
- en: The `atoms`, `molecules`, `organisms`, `templates`, and `pages` directories
    represent the different levels of component composition and abstraction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `api` directory contains the API-related files for making API calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `views` directory contains the individual views that render the components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `routes` directory handles the routing configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This method has the following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reusability**: Components can be easily reused across the application, promoting
    code efficiency'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistency**: The structure encourages a consistent design language and
    UI pattern'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: The modular approach allows for easy scaling and the addition
    of new components'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintainability**: Components are organized in a logical hierarchy, making
    them easier to locate and update'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collaboration**: The atomic design structure facilitates collaboration between
    designers and developers as it provides a common language for discussing UI components'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, it has the following drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Learning curve**: It may require some initial learning and adaptation to
    understand and implement the atomic design principles effectively'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**: As the application grows, managing a large number of components
    and their relationships can become challenging'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Overengineering**: It’s important to strike a balance between component reusability
    and overengineering as excessive abstraction can introduce unnecessary complexity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The MVVM structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **MVVM structure** is a software architectural pattern that’s primarily
    used in building user interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: The *Model* represents the actual data and/or information we are dealing with.
    This could be a database, a file, a web service, or even a simple object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *View* is what the user sees and interacts with. It’s the user interface
    that presents the Model to the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *ViewModel* is where most of the logic resides in this pattern. It is an
    abstraction of the View that exposes public properties and commands, bridging
    the gap between the View and the Model, and processes the data from the Model
    into a format that is easy for the View to handle. It can perform operations on
    the data and decide how it should be presented to the View.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To structure a React application with the MVVM architecture in the context
    of online shopping, you can organize your files and folders as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5: The MVVM structure](img/B21103_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.5: The MVVM structure'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at this structure:'
  prefs: []
  type: TYPE_NORMAL
- en: The `components` directory contains reusable UI components, organized by their
    respective features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `models` directory includes the data models or entities representing the
    application’s domain objects, such as `CartItemModel` and `ProductModel`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `viewmodels` directory holds the Hooks responsible for managing the state,
    logic, and interactions of the views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `services` directory contains modules for handling API calls and other external
    services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `views` directory includes the view components that display the UI based
    on the `ViewModel` state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `routers` directory houses the routing configuration and components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `App.tsx` file serves as the entry point of the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This method has the following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Separation of concerns**: The ViewModel separates the business logic from
    the UI components, promoting cleaner and more maintainable code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testability**: The ViewModel can be easily unit tested without the need for
    the actual UI components'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reusability**: Components, models, and services can be reused across different
    features and views'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: New features and views can be added while reusing existing
    ViewModel and service modules'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, it has the following drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Complexity**: Implementing the MVVM pattern may introduce additional layers
    of abstraction and complexity to the application, especially for smaller projects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Learning curve**: Developers need to understand the concepts and principles
    of MVVM to effectively structure and manage the application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have explored these four popular structures, let’s delve into the
    continuous evolution of our application’s structure. This ongoing process ensures
    that the structure remains beneficial for developers in terms of easy navigation,
    seamless addition of new features, and the ability to maintain scalability over
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping your project structure organized
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The feature-based structure is always a good starting point. As the project
    expands and patterns of duplication start to emerge, an additional layer can be
    introduced to eliminate redundancy.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let’s use the online shopping application again. It contains
    various pages:'
  prefs: []
  type: TYPE_NORMAL
- en: Home page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log in/sign up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store address search
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Product list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shopping cart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Order details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Payment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coupon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the initial stages, organizing pages based on their features is a common
    approach. We can create a folder for each feature and put all the related components,
    styles, and tests inside that folder.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the initial structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The initial folder structure in the `src` directory is quite straightforward
    and follows a feature-based approach, with each page having its own folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: However, as the project evolves, you may encounter duplication of components
    or functionalities across different pages. To address this, it becomes necessary
    to introduce an additional layer of abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if both the `Login` and `Order` pages require a `Button` component,
    it would be impractical to have separate implementations of the button on each
    page. Instead, you can extract the `Button` component into a separate layer, such
    as a components or shared folder. This way, `Button` can be reused across multiple
    pages without duplication.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an extra layer to remove duplicates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By adding this extra layer, you promote reusability and maintainability in your
    code base. It helps in eliminating redundancy, streamlining development efforts,
    and ensuring consistency throughout the application. As the project expands, this
    modular approach allows for easy management and scalability, making it easier
    to add new features or make changes without impacting the entire code base.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, you can create a `components` folder for all the reusable components and
    a `pages` folder for all the feature pages, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As the project expands, it becomes necessary to create a separate components
    folder to house reusable components that are shared across different pages. In
    this structure, each component is organized within its respective folder, promoting
    modularity and code reuse. Additionally, you can introduce nested folders to represent
    component hierarchies, such as the `Offer` folder, which contains a specific component
    called `SpecialOffer`.
  prefs: []
  type: TYPE_NORMAL
- en: Alongside the `components` folder, you may need folders for other essential
    elements. The `pages` folder contains feature-specific pages, while the `hooks`
    folder houses React Hooks that provide reusable logic and functionality. The `context`
    folder is used for managing the global state and provides different contexts that
    can be shared throughout the application.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that not all components need to be moved to the `components`
    folder. Only components that exhibit duplication across different pages should
    be lifted to the shared folder, ensuring that you maintain a balance between modularity
    and unnecessary complexity.
  prefs: []
  type: TYPE_NORMAL
- en: This file structure allows for better organization, code reuse, and scalability
    as the project grows. It promotes maintainability by reducing redundancy and ensuring
    consistency across the application. Additionally, having a separate folder for
    Hooks and contexts helps centralize related code and makes it easier to manage
    and maintain global state and reusable logic.
  prefs: []
  type: TYPE_NORMAL
- en: Naming files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In an individual component, there are different approaches to naming files,
    and each approach has its advantages and considerations. Let’s explore two approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Naming files with index.tsx and explicit component names
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this approach, each file within the component folder has an explicit name
    that corresponds to the component it represents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `index.tsx` file serves as the default export file, allowing you to import
    the component from the folder directly. `Button.tsx` is the JSX for the component,
    and `Button.test.tsx` is the corresponding test file, while `style.css` defines
    CSS styles.
  prefs: []
  type: TYPE_NORMAL
- en: This approach promotes clear and self-descriptive filenames, making it easier
    to understand the purpose and content of each file. However, it can result in
    a long list of index files when browsing or searching for components in an editor
    or file explorer.
  prefs: []
  type: TYPE_NORMAL
- en: Naming files with kebab case
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this approach, the files within the `components` folder are named using
    **kebab case**, a naming convention where words are lowercase and separated by
    hyphens. If there is only one word, simply use lowercase – this follows a consistent
    convention that’s used in the JavaScript community:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The filename of the component is explicitly named using kebab case (for example,
    `button.tsx`) to match the component’s name.
  prefs: []
  type: TYPE_NORMAL
- en: This approach maintains consistency with the convention of kebab case filenames
    and promotes a unified naming structure throughout the project. However, it may
    require specifying the filename explicitly when importing the component.
  prefs: []
  type: TYPE_NORMAL
- en: Both approaches have their merits, and the choice depends on personal preference
    and the project’s requirements or team conventions. It is crucial to establish
    and maintain consistency within the project to enhance collaboration and understanding
    among team members.
  prefs: []
  type: TYPE_NORMAL
- en: 'Either way, you can use ESlint and FolderLint to ensure your team has the same
    naming standard for files and folders. For example, the following screenshot shows
    that filenames should be in the kebab case and suggests changing `Button.tsx`
    into `button.tsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 3.6: ESlint c\uFEFFhecks](img/B21103_03_06.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.6: ESlint checks'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring a more customized structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As your application grows and different types of abstractions are added, it
    becomes necessary to organize the project structure accordingly. Relying solely
    on any previously discussed structure may not be ideal for your specific scenario.
    It’s often necessary to customize the structure so that it aligns well with your
    project’s needs. Remember, the primary goal of establishing a project structure
    is to simplify and streamline the development process for developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with the feature-based structure, we need to adjust our current folder
    structure to the following folder structure to reflect this evolution:'
  prefs: []
  type: TYPE_NORMAL
- en: '`api`: This folder represents the module or directory for managing API-related
    code, including functions for making network requests, handling responses, and
    interacting with the backend services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`components`: This folder contains reusable UI components that can be used
    across different pages or features of the application. It includes components
    such as `Accordion`, `Button`, `GenericCard`, `Modal`, `Offer`, and `StackView`.
    These components can be organized into subfolders based on their functionality
    or purpose.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`context`: This folder represents the module or directory for managing React
    context, which allows for global state management and data sharing across components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hooks`: This folder contains custom React Hooks that encapsulate reusable
    logic and behavior. These Hooks can be shared across different parts of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mocks`: This folder holds mock data or mock implementations for testing purposes.
    It includes subfolders for `graphql` and `rest`, which represent mocks for GraphQL
    and REST APIs, respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pages`: This folder represents the different pages or features of the application.
    Each page or feature has a folder. The folders that are included are `Address`,
    `Home`, `Login`, `Order`, `Payment`, `Product`, `Profile`, `SignUp`, as well as
    their respective subfolders. The subfolders may contain additional components,
    Hooks, or context related to that specific page or feature.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By structuring the project in this way, you can achieve a modular and organized
    code base that facilitates code reuse, separation of concerns, and scalability.
    Each directory represents a specific aspect of the application, making it easier
    to locate and manage code related to that particular functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see this in the following figure, where we are returning to our shopping
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7: A mixed structure for an online shopping application](img/B21103_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.7: A mixed structure for an online shopping application'
  prefs: []
  type: TYPE_NORMAL
- en: While this structure provides a solid foundation, it’s important to adapt it
    based on the specific needs and scale of your project. Regularly reviewing and
    refactoring the structure can help maintain its effectiveness and accommodate
    future changes.
  prefs: []
  type: TYPE_NORMAL
- en: As the application becomes larger, it may be beneficial to extract the `components`
    folder into a shared library that can be used across multiple projects or as an
    internal design system. This approach promotes code reuse, consistency, and maintainability.
    The shared library can be hosted on an internal registry or published to *npmjs
    Registry* ([https://www.npmjs.com/](https://www.npmjs.com/)) for easy distribution
    and consumption.
  prefs: []
  type: TYPE_NORMAL
- en: Also, as your application evolves and new features are introduced, the existing
    structure may no longer fully meet your requirements. In such cases, it can be
    beneficial to incorporate architectural patterns such as MVVM, which follows a
    layered approach. This allows for better separation of concerns and facilitates
    the management of complex features and state in a more organized manner. We’ll
    have an in-depth discussion about using layered architecture in [*Chapter 11*](B21103_11.xhtml#_idTextAnchor286).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the challenges that arise when managing a large
    React application and the importance of establishing a solid project structure.
    We discussed various styles of structuring a React application, including feature-based,
    component-based, MVVM, and atomic design. Each approach offers its benefits and
    considerations, allowing developers to choose the most suitable structure for
    their specific project requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we proposed a continuously evolving approach to shaping the folder
    structure as the project grows. Starting with a simple initial structure, we emphasized
    the need to adapt and introduce new layers and abstractions to reduce duplication
    and maintain code organization. By continuously refining the structure and adhering
    to consistent conventions, developers can navigate, add new features, and maintain
    scalability effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we highlighted the importance of keeping the project
    structure flexible and evolving to meet the changing needs of the application.
    By staying proactive in shaping the folder structure, developers can mitigate
    the challenges of managing a large React application and ensure maintainability
    and scalability in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: In the forthcoming chapter, we will delve into prevalent design patterns and
    strategies for component implementation. These techniques will allow us to craft
    code that is amenable to feature additions, intuitive to comprehend, and requires
    less maintenance effort.
  prefs: []
  type: TYPE_NORMAL
