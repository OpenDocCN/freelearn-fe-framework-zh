- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Architecture for Large-Scale Web Apps
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大型Web应用的架构
- en: In the previous chapter, we explored building and scaling large-scale applications
    in Vue 3\. We discussed why we need Vue.js performance optimization, the primary
    reasons behind poor Vue performance, how to check your Vue.js application’s bundle
    size, and optimizing the performance of an enterprise Vue application using different
    methods such as asynchronous/lazy component loading, WebP images, and image compression
    and code splitting.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了在Vue 3中构建和扩展大型应用。我们讨论了为什么我们需要Vue.js性能优化，导致Vue性能不佳的主要原因，如何检查你的Vue.js应用包的大小，以及使用异步/懒加载组件、WebP图像、图像压缩和代码拆分等方法优化企业级Vue应用性能。
- en: In this chapter, we will learn how to handle a sizable enterprise-ready project,
    from managing larger file structures to using the micro frontend architecture.
    We will also learn how to handle the internationalization and localization of
    our Vue.js 3 project.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何处理一个大型企业级项目，从管理更大的文件结构到使用微前端架构。我们还将学习如何处理我们Vue.js 3项目的国际化与本地化。
- en: 'We will cover the following key topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下关键主题：
- en: File architecture and structure
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件架构和结构
- en: Micro frontend architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微前端架构
- en: Internationalization and localization
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 国际化和本地化
- en: By the end of this chapter, you will know how to architect large-scale web apps
    with Vue 3, how to implement structures and file architecture using the law of
    predictability, and how to use community-recommended packages to inform predictability
    in your Vue.js 3 enterprise-ready application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将知道如何使用Vue 3构建大型Web应用，如何使用可预测性原则实现结构和文件架构，以及如何使用社区推荐的包来告知你的Vue.js 3企业级应用中的可预测性。
- en: You will also learn how to use micro frontend architecture to your advantage
    and how to implement an Atomic Design with Storybook to streamline your component
    directory and make your enterprise project less difficult to understand.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将学习如何利用微前端架构的优势，以及如何使用Storybook实现原子设计，以简化你的组件目录，使企业级项目更容易理解。
- en: And lastly, you will learn how to add and properly integrate internationalization
    in to your Vue application and about the benefits this brings.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将学习如何将国际化正确地集成到你的Vue应用中，以及这将带来的好处。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To get started with this chapter, I recommend you read through [*Chapter 3*](B17237_03.xhtml#_idTextAnchor087),
    *Scaling Performance in Vue.js 3*, where we elucidate the building and scaling
    of large-scale applications in Vue 3.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始本章的学习，我建议你阅读[*第3章*](B17237_03.xhtml#_idTextAnchor087)，*Vue.js 3中的性能扩展*，其中我们阐述了在Vue
    3中构建和扩展大型应用。
- en: All the code files for this chapter can be found at [https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-4](https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-4).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码文件都可以在[https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-4](https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-4)找到。
- en: Understanding file architecture and structure
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解文件架构和结构
- en: Structuring your project depends solely on the preference of your organization
    and how easy it is to access files and folders when fixing bugs and adding new
    features.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 项目结构完全取决于你组织的偏好以及修复错误和添加新功能时访问文件和文件夹的难易程度。
- en: In this section, we will explore different principles that will give you an
    idea of how you can structure your project to incorporate best practices, standards,
    and easy-to-access files.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨不同的原则，这些原则将给你一个想法，了解你如何构建项目以融入最佳实践、标准和易于访问的文件。
- en: What is the most effective way to structure your project to scale and keep it
    maintainable and extendable the more it grows?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是最有效的项目结构方式，以实现扩展并保持其可维护性和可扩展性？
- en: 'This is a common question in the software development industry but there is
    no one-size-fits-all method. It all depends on the principle of predictability,
    as discussed in this article: [https://vueschool.io/articles/vuejs-tutorials/how-to-structure-a-large-scale-vue-js-application/](https://vueschool.io/articles/vuejs-tutorials/how-to-structure-a-large-scale-vue-js-application/).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在软件开发行业中常见的疑问，但没有一种适合所有情况的解决方案。这完全取决于可预测性的原则，正如本文所讨论的：[https://vueschool.io/articles/vuejs-tutorials/how-to-structure-a-large-scale-vue-js-application/](https://vueschool.io/articles/vuejs-tutorials/how-to-structure-a-large-scale-vue-js-application/)。
- en: The principle of predictability is simply the ability to go from point A to
    point B in any code base to intuitively go from a feature request or bug report
    to the location in the code base where the said task can be addressed. Furthermore,
    it’s the ability to quickly or easily understand a particular code base based
    on the standard use of community or popular libraries and tools.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 可预测性的原则简单来说就是能够在任何代码库中从A点到B点的直觉性移动，从功能请求或错误报告到代码库中可以解决该任务的地点。此外，它还指的是根据社区或流行库和工具的标准使用，快速或轻松地理解特定的代码库的能力。
- en: To elaborate, when a code base uses standard, community-agreed, and popular
    libraries or tools, it gives a great developer experience as developers are already
    familiar with these tools.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了详细说明，当一个代码库使用标准、社区同意和流行的库或工具时，它为开发者提供了极佳的开发体验，因为开发者已经熟悉这些工具。
- en: In the next section, we will delve deeper into discussing predictability and
    how we can achieve it in Vue 3.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将更深入地讨论可预测性以及如何在Vue 3中实现它。
- en: Predictability in Vue 3
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Vue 3中的可预测性
- en: How to achieve predictability in Vue 3 is very simple, as stated previously;
    it boils down to using Vue 3 standards and style guides.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如何在Vue 3中实现可预测性非常简单，如前所述；它归结为使用Vue 3标准和风格指南。
- en: For example, just imagine buying a new iPhone 13 ProMax in a different size;
    it will be awkward since you must have certainly predicted the size to stay the
    same from your reviews.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，只需想象购买一个不同尺寸的新iPhone 13 ProMax；这将很尴尬，因为您肯定已经根据您的评论预测了尺寸将保持不变。
- en: The approach applies to the mindsets of developers toward a new code base; we
    expect most libraries, component names, files, and folder structures to follow
    Vue 3 community standards and style guide with a little adjustment to suit the
    organization’s use case (if any).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法适用于开发者对新代码库的心态；我们期望大多数库、组件名称、文件和文件夹结构都遵循Vue 3社区标准和风格指南，并略作调整以适应组织的用例（如果有）。
- en: So how can we achieve predictability in Vue 3? In the following subsections,
    we will look at a few ways to achieve standards in your enterprise Vue 3 application.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何在Vue 3中实现可预测性呢？在接下来的小节中，我们将探讨几种在您的企业Vue 3应用程序中实现标准的方法。
- en: Community-wide standards for predictability
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可预测性的社区标准
- en: If you’re coming from Vue 2, you should already be familiar with the standards
    that exist within it. We will discuss adding more Vue 3 specific standards from
    there.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您来自Vue 2，您应该已经熟悉其中存在的标准。我们将从那里讨论添加更多Vue 3特定标准。
- en: 'Vue has the following pages where you can look out for community standards:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Vue有以下页面，您可以查看社区标准：
- en: Start by reviewing the official Vue.js style guide ([https://v3.vuejs.org/style-guide/#rule-categories](https://v3.vuejs.org/style-guide/#rule-categories))
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，请查看官方Vue.js风格指南（[https://v3.vuejs.org/style-guide/#rule-categories](https://v3.vuejs.org/style-guide/#rule-categories)）
- en: Always use the scaffolding generated by the Vue **command-line interface** (**CLI**)
    or Vite in Vue 3 ([https://vuejs.org/guide/quick-start.html](https://vuejs.org/guide/quick-start.html))
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Vue 3中，始终使用由Vue **命令行界面**（**CLI**）或Vite生成的脚手架（[https://vuejs.org/guide/quick-start.html](https://vuejs.org/guide/quick-start.html)）
- en: The official Vue.js libraries are found under the *Community* *Guide* ([https://vuejs.org/about/community-guide.html](https://vuejs.org/about/community-guide.html))
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方Vue.js库可以在 *社区* *指南* 下找到（[https://vuejs.org/about/community-guide.html](https://vuejs.org/about/community-guide.html)）
- en: Use one of the most popular component frameworks such as Vuetify ([https://vuetifyjs.com/en/](https://vuetifyjs.com/en/))
    or Quasar ([https://quasar.dev/](https://quasar.dev/))
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用最流行的组件框架之一，如Vuetify ([https://vuetifyjs.com/en/](https://vuetifyjs.com/en/))
    或 Quasar ([https://quasar.dev/](https://quasar.dev/))
- en: Official libraries and component libraries
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 官方库和组件库
- en: Using official libraries and component libraries not only brings functionality
    to your project but also enforces standards and allows you to build applications
    following standard and generally acceptable patterns according to the Vue community.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用官方库和组件库不仅为您的项目带来功能，还强制执行标准，并允许您根据Vue社区的标准和通常可接受的模式构建应用程序。
- en: For example, Vuex is a state management system that prides itself on implementing
    a pattern and a library together because it enforces a standard to follow when
    building Vue applications.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Vuex是一个以实现模式和库相结合而自豪的状态管理系统，因为它在构建Vue应用程序时强制执行遵循的标准。
- en: Another great example is Vue Router, which enables developers to build routing
    systems in ways that are adaptable to other projects.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个很好的例子是 Vue Router，它允许开发者以适应其他项目的方式构建路由系统。
- en: And the good thing about all of this is when a developer who has built with
    these libraries is added to a new code base, using these tools, it becomes predictable.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些的好处是，当一个使用这些库构建的开发者加入到一个新的代码库中时，使用这些工具，它变得可预测。
- en: Standard file structure
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标准文件结构
- en: Another important aspect of project standards is the file structure. The file
    structure is an arguable aspect of project standards because different organizations
    and projects use different structures and Vue does not provide detailed documentation
    specifying a structure.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 项目标准的一个重要方面是文件结构。文件结构是项目标准的一个有争议的方面，因为不同的组织和项目使用不同的结构，Vue 也没有提供详细的文档来指定一个结构。
- en: However, when you use the official Vue CLI, it provides a starting point for
    creating a standard folder and file structure that is widely used in the Vue.js
    world, and it’s most familiar for Vue developers around the world.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当你使用官方的 Vue CLI 时，它提供了一个创建标准文件夹和文件结构的起点，这在 Vue.js 界内被广泛使用，并且对于全球的 Vue 开发者来说最为熟悉。
- en: 'The following code block shows how to create a new Vue 3 project using the
    official Vue 3 standalone CLI called Vite:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码块展示了如何使用官方的 Vue 3 独立 CLI（称为 Vite）创建一个新的 Vue 3 项目：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following screenshot shows the official project scaffolding using the Vue
    3 official CLI called Vite:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了使用 Vue 3 官方 CLI（称为 Vite）的官方项目脚手架：
- en: '![Figure 4.1 – Official Vue CLI file structure](img/Figure_4.01_B17237.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 官方 Vue CLI 文件结构](img/Figure_4.01_B17237.jpg)'
- en: Figure 4.1 – Official Vue CLI file structure
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 官方 Vue CLI 文件结构
- en: The initial structure used in the preceding screenshot should already be familiar
    to many developers, therefore making it predictable. Always stick with Vue’s initial
    structure, build on it, and only change it for a good reason.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中所使用的初始结构应该对许多开发者来说已经很熟悉了，因此使其变得可预测。始终遵循 Vue 的初始结构，在此基础上构建，并且只有出于良好的理由才进行更改。
- en: Recommended component rules
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 推荐的组件规则
- en: The Vue component directory is where the confusion begins because thousands
    of files and Vue components can be created, and it becomes very difficult to manage
    with time.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Vue 组件目录是混乱开始的地方，因为可以创建成千上万的文件和 Vue 组件，随着时间的推移，管理起来变得非常困难。
- en: Adapting your code base to follow the official Vue 3 style guide is a starting
    point for a predictable code base and you can learn a lot about making your folder
    and file structure more predictable for developers from there. The style guide
    provides lots of community-wide standards and best practices for the Vue ecosystem.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的代码库调整为遵循官方 Vue 3 风格指南是创建可预测代码库的起点，并且你可以从那里学习很多关于如何使你的文件夹和文件结构对开发者来说更加可预测的知识。风格指南为
    Vue 生态系统提供了许多社区标准和最佳实践。
- en: 'Some of the most important points are listed here:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了其中一些最重要的要点：
- en: First, we have the **Single-File Component** (**SFC**) style guide, which states
    a lot of points to follow, with the important one being that your components should
    be named in PascalCase.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们有 **单文件组件**（**SFC**）风格指南，它陈述了许多需要遵循的点，其中重要的一点是，你的组件应该以 PascalCase 命名。
- en: Secondly, an SFC ([https://vuejs.org/guide/scaling-up/sfc.html](https://vuejs.org/guide/scaling-up/sfc.html))
    should always order the `<script>`, `<template>`, and `<style>` tags consistently,
    with `<style>` at the end. This is because the `script` and `template` tags are
    always necessary while the style tag is optional.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，SFC（[https://vuejs.org/guide/scaling-up/sfc.html](https://vuejs.org/guide/scaling-up/sfc.html)）应始终一致地排序
    `<script>`、`<template>` 和 `<style>` 标签，其中 `<style>` 在最后。这是因为 `script` 和 `template`
    标签总是必要的，而 `style` 标签是可选的。
- en: It also states that, when possible, each component should be defined in its
    own dedicated file (SFC). This is where Storybook or Atomic Design, in general,
    comes in to play as we will see in the following sections.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它还指出，在可能的情况下，每个组件都应该定义在其自己的专用文件（SFC）中。这就是 Storybook 或 Atomic Design 在这里发挥作用的地方，我们将在接下来的章节中看到。
- en: Additionally, component names should always be multi-worded to not conflict
    with any existing or future HTML elements. Don’t create a `Table` component or
    a `Button` component since there are HTML tags with those names already; you can
    create a multi-word such as the following `DataTable` or `CustomButton`.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，组件名称应始终为多词，以避免与任何现有或未来的HTML元素冲突。不要创建名为 `Table` 或 `Button` 的组件，因为这些名称的HTML标签已经存在；您可以创建多词，例如以下
    `DataTable` 或 `CustomButton`。
- en: Most importantly, tightly coupled child components should be prefixed with their
    parent component’s name, such as `TodoListItem` in a `TodoList` component. The
    method also helps in debugging, as developers can easily spot components with
    names in error messages.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最重要的是，紧密耦合的子组件应该以父组件的名称为前缀，例如在 `TodoList` 组件中的 `TodoListItem`。此方法也有助于调试，因为开发者可以轻松地识别出错误信息中的名称错误的组件。
- en: Vue.js has a full style guide at [https://vuejs.org/style-guide/](https://vuejs.org/style-guide/)
    with a number of other standards that will help your project be more predictable
    for a community-wide audience of developers.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js 在 [https://vuejs.org/style-guide/](https://vuejs.org/style-guide/) 提供了一份完整的风格指南，其中包含许多其他标准，这些标准将帮助您的项目对社区范围内的开发者更加可预测。
- en: Recommended community-wide standards for predictability
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 推荐的社区通用标准以提高可预测性
- en: Over the years, the Vue community has developed and argued on numerous different
    standards that should be used by Vue developers for a more predictive code base.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 几年来，Vue 社区已经就Vue开发者应使用的、旨在提高代码库可预测性的众多不同标准进行了发展和争论。
- en: In the following subsections, we will discuss a handful of these standards and
    how to implement them in your enterprise project.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下小节中，我们将讨论一些这些标准以及如何在企业项目中实施它们。
- en: A flat component directory
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 平面组件目录
- en: A flat component directory entails giving a specific naming convention to your
    Vue components and your team, sticking with that convention throughout application
    development.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 平面组件目录意味着为您的Vue组件和团队指定特定的命名约定，并在整个应用程序开发过程中坚持该约定。
- en: 'You can use a single or nested directory structure, but the naming convention
    should stay the same. The next two screenshots show different ways to implement
    the flat component directory. The following screenshot shows a single flat component
    directory:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用单一或嵌套的目录结构，但命名约定应保持一致。接下来的两个截图展示了实现平面组件目录的不同方式。下面的截图展示了单一平面组件目录：
- en: '![Figure 4.2 – Single flat component directory](img/Figure_4.02_B17237.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – 单一平面组件目录](img/Figure_4.02_B17237.jpg)'
- en: Figure 4.2 – Single flat component directory
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 单一平面组件目录
- en: 'The following screenshot shows a nested flat component directory:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图展示了嵌套平面组件目录：
- en: "![Figure 4.3 – Nested flat compo\uFEFF\uFEFFnent directory](img/Figure_4.03_B17237.jpg)"
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3 – 嵌套平面组件目录](img/Figure_4.03_B17237.jpg)'
- en: Figure 4.3 – Nested flat component directory
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 嵌套平面组件目录
- en: Standardized route/page naming convention
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 标准化的路由/页面命名约定
- en: Another important improvement to the principle of predictability is having proper
    and well-defined route/page naming conventions throughout your team and project.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 可预测性原则的另一项重要改进是在整个团队和项目中拥有适当且定义明确的路由/页面命名约定。
- en: For instance, using routes/page naming conventions used in Laravel or AdonisJS
    makes it easy for developers who have prior knowledge of these frameworks to quickly
    predict the code base. The same is applicable if you define your custom convention
    and stick with it through your team. It allows new members to easily predict and
    understand your code base.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用Laravel或AdonisJS中使用的路由/页面命名约定，对于熟悉这些框架的开发者来说，可以轻松预测代码库。如果您定义了自己的约定并坚持使用，这也适用。它允许新成员轻松预测和理解您的代码库。
- en: 'The following screenshot shows how you can structure your routes to be predictable
    based on routing standards from Laravel and AdonisJS:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图展示了如何根据Laravel和AdonisJS的路由标准来结构化您的路由，以实现可预测性：
- en: '![Figure 4.4 – Showing the pattern that can be adopted](img/Figure_4.04_B17237.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4 – 展示可采用的模式](img/Figure_4.04_B17237.jpg)'
- en: Figure 4.4 – Showing the pattern that can be adopted
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – 展示可采用的模式
- en: You should always reference your routes properly with their name when using
    them in router links and programmatically for more consistency and flexibility.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在路由链接中使用路由时，应始终正确引用其名称，并在程序中使用以获得更多一致性和灵活性。
- en: 'For example, see the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，参见以下内容：
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Also, note that not all routes will fit this pattern exactly, as some routes
    will be cruddier than others. If this happens, a good recommendation is to continue
    using PascalCase for your route names for consistency.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，并非所有路由都完全符合此模式，因为一些路由可能比其他路由更简单。如果发生这种情况，一个好的建议是继续使用 PascalCase 为你的路由名称保持一致性。
- en: A more comprehensive file structure
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更全面的文件结构
- en: Using the basic file structure from the Vue CLI is a great starting point for
    predictability and can be extended from there to include other files and directories
    in a way that standardizes our enterprise project for better predictability.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Vue CLI 的基本文件结构是预测性的良好起点，并可以从那里扩展以包括其他文件和目录，从而以标准化的方式使我们的企业项目更具可预测性。
- en: 'The following screenshot shows how to extend the file structure to include
    other necessary files and directories:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了如何扩展文件结构以包括其他必要的文件和目录：
- en: '![Figure 4.5 – Extending the file structure from the default Vue CLI structure](img/Figure_4.05_B17237.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.5 – 从默认 Vue CLI 结构扩展文件结构](img/Figure_4.05_B17237.jpg)'
- en: Figure 4.5 – Extending the file structure from the default Vue CLI structure
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – 从默认 Vue CLI 结构扩展文件结构
- en: The additional files and folders will solely depend on your team, organization,
    or project, but the additional folders in *Figure 4**.5* are the structure we
    have defined for the project we are building, and extending it from the default
    Vue CLI structure makes it more predictable.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的文件和文件夹将完全取决于你的团队、组织或项目，但图 4.5 中的额外文件夹是我们为正在构建的项目定义的结构，从默认 Vue CLI 结构扩展它使其更具可预测性。
- en: Also, providing a `README.md` file ([https://changelog.md/](https://changelog.md/))
    in the root of a standard directory explaining the purpose of the directory and
    any rules for what should be included in it or how to use the directory files
    is very useful. This comes in handy, especially for those standards that aren’t
    community-wide standards.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在标准目录的根目录中提供一个 `README.md` 文件（[https://changelog.md/](https://changelog.md/)），解释目录的目的以及应包含在其中的任何规则或如何使用目录文件，这非常有用。这对于那些不是社区标准的标准尤其有用。
- en: While we tend to make our code base predictable enough for developers, no matter
    how well the project uses community-wide standards and Vue style guides, there
    are cases where we need to define specific files and folders that are generic
    to our project or team.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们倾向于使代码库对开发者足够可预测，无论项目如何使用社区标准和 Vue 风格指南，仍有一些情况需要定义特定于我们项目或团队的通用文件和文件夹。
- en: While creating a predictable code base is great for larger projects and teams
    using the steps and patterns discussed in the previous sections, there is still
    a lot to explore, and in the next section, we will explore different patterns,
    architectures, and structures that can be used to structure your larger-scale
    enterprise projects.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然创建一个可预测的代码库对于使用上一节中讨论的步骤和模式的大型项目和团队来说是个不错的选择，但仍有很多东西可以探索。在下一节中，我们将探讨可以用来构建更大规模企业项目的不同模式、架构和结构。
- en: Different frontend architectural patterns
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同的前端架构模式
- en: In this section, we will explore different architectural patterns we can use
    to structure our enterprise Vue 3 applications.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨我们可以用来构建我们的企业 Vue 3 应用程序的不同架构模式。
- en: Micro frontend architecture
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微前端架构
- en: Micro frontend is the first architecture that comes to mind when it comes to
    structuring enterprise frontend projects. As expressed in the official documentation,
    it extends the concept of microservices in the backend to the frontend world.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到构建企业前端项目时，微前端架构是首先想到的架构。正如官方文档中所述，它将后端微服务概念扩展到前端世界。
- en: The concept of a micro frontend comes from the buzzword microservices ([https://martinfowler.com/articles/microservices.html](https://martinfowler.com/articles/microservices.html))
    used in a backend web application to split gigantic blocks into a smaller, more
    manageable code base.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 微前端的概念源于在后台网络应用程序中用于将巨大块拆分为更小、更易于管理的代码库的流行词“微服务”（[https://martinfowler.com/articles/microservices.html](https://martinfowler.com/articles/microservices.html)）。
- en: This approach to software development makes it easier for teams to manage, maintain,
    and deploy larger and enterprise applications faster.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这种软件开发方法使团队更容易管理、维护和快速部署更大规模的企业应用程序。
- en: This concept, which has changed the way backend applications have been developed
    over many years, is introduced into frontend projects in the form of micro frontends.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念已经改变了多年来后端应用的开发方式，现在以微前端的形式引入到前端项目中。
- en: According to Martin Fowler ([https://martinfowler.com/articles/micro-frontends.html](https://martinfowler.com/articles/micro-frontends.html)),
    “*Micro Frontend is an architectural style where independently deliverable frontend
    applications are composed into a* *greater whole*.”
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 根据马丁·福勒([https://martinfowler.com/articles/micro-frontends.html](https://martinfowler.com/articles/micro-frontends.html))的说法，“*微前端是一种架构风格，其中独立交付的前端应用被组合成一个更大的整体*。”
- en: In recent years, since the initial adoption, there has been tremendous adoption
    of this concept in larger projects, thereby bringing the benefits of microservices
    into frontend projects.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，随着最初的应用，这一概念在大型项目中得到了巨大的采用，从而将微服务的好处引入到前端项目中。
- en: 'The following are some key benefits that come with implementing the micro frontend
    architecture:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 实施微前端架构带来的以下是一些关键好处：
- en: It comes with more scalable organizations with decoupled and autonomous teams
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它带来了更可扩展的组织，具有解耦和自治的团队
- en: It brings smaller, more cohesive, and maintainable code bases
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它带来了更小、更紧密、更易于维护的代码库
- en: The provides the ability to upgrade, update, or even rewrite parts of the frontend
    in a more incremental fashion
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了以更渐进的方式升级、更新或甚至重写前端部分的能力
- en: As much as there are tremendous benefits to using this architecture in your
    enterprise project as outlined in the official documentation, the pattern requires
    a steep learning curve, a higher number of team expatriates, and a large number
    of team members.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在官方文档中概述了使用这种架构在您的企业项目中带来的巨大好处，但这种模式需要陡峭的学习曲线、更多的团队外派人员以及大量的团队成员。
- en: 'The following diagram shows an end-to-end example of teams using a micro frontend
    for the Pinterest demo application:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图展示了团队使用微前端为 Pinterest 示例应用构建端到端示例：
- en: '![Figure 4.6 – An end-to-end example of teams using a micro frontend](img/Figure_4.06_B17237.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图4.6 – 团队使用微前端的端到端示例](img/Figure_4.06_B17237.jpg)'
- en: Figure 4.6 – An end-to-end example of teams using a micro frontend
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 – 团队使用微前端的端到端示例
- en: 'Here’s a diagram of how structuring the Pinterest demo application will look
    using the micro frontend architecture:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了一个使用微前端架构构建 Pinterest 示例应用的架构图：
- en: '![Figure 4.7 – A screenshot of a micro frontend in action](img/Figure_4.07_B17237.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图4.7 – 微前端在实际应用中的截图](img/Figure_4.07_B17237.jpg)'
- en: Figure 4.7 – A screenshot of a micro frontend in action
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 – 微前端在实际应用中的截图
- en: From the screenshot, we can easily separate each of the features into a different
    service and have a dedicated team of frontend engineers to work on it.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从截图中，我们可以轻松地将每个功能分离成不同的服务，并为每个服务配备一个专门的前端工程师团队来处理。
- en: Micro frontend is one of the best architectural patterns to use in enterprise
    applications because the core ideas behind a micro frontend are having isolated
    team code, it being technology-agnostic, ownership, and so on. These features
    make developing enterprise applications a breeze. However, other patterns are
    also widely used, and we will explore them in the next section.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 微前端是企业应用中最佳架构模式之一，因为微前端的核心思想包括隔离的团队代码、技术无关性、所有权等。这些特性使得开发企业应用变得轻松。然而，其他模式也被广泛使用，我们将在下一节中探讨它们。
- en: Atomic Design
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原子设计
- en: Atomic Design ([https://bradfrost.com/blog/post/atomic-web-design/](https://bradfrost.com/blog/post/atomic-web-design/))
    is a methodology for crafting design systems. Brad Frost first introduced it for
    creating scalable design systems using ideas from chemistry.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 原子设计([https://bradfrost.com/blog/post/atomic-web-design/](https://bradfrost.com/blog/post/atomic-web-design/))是一种构建设计系统的方法论。布拉德·弗罗斯特首先将其用于使用化学思想创建可扩展的设计系统。
- en: From chemistry class, we know that matter comprises atoms that bond together
    to form molecules, which in turn combine to form more complex organisms and ultimately
    create all the matter in the universe.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 从化学课中，我们知道物质由原子组成，这些原子结合形成分子，进而结合形成更复杂的生物体，最终创造出宇宙中的所有物质。
- en: 'Similarly, we can break down our components into fundamental building blocks
    and work up from there. These building blocks can be divided into five components
    from the chemistry example, as listed here:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以将我们的组件分解成基本构建块，并从这里开始工作。这些构建块可以从化学示例中分为五个组件，如下所示：
- en: Atoms
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原子
- en: Molecules
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分子
- en: Organisms
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生物体
- en: Templates
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板
- en: Pages
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 页面
- en: 'This diagram from Rohan Kamath ([https://blog.kamathrohan.com/atomic-design-methodology-for-building-design-systems-f912cf714f53](https://blog.kamathrohan.com/atomic-design-methodology-for-building-design-systems-f912cf714f53))
    gives a clear illustration of the Atomic Design elements:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这张由Rohan Kamath提供的图表（[https://blog.kamathrohan.com/atomic-design-methodology-for-building-design-systems-f912cf714f53](https://blog.kamathrohan.com/atomic-design-methodology-for-building-design-systems-f912cf714f53)）清楚地展示了原子设计元素：
- en: '![Figure 4.8 – Atomic Design elements explained (source: https://blog.kamathrohan.com/atomic-design-methodology-for-building-design-systems-f912cf714f53)](img/Figure_4.08_B17237.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图4.8 – 原子设计元素解释（来源：https://blog.kamathrohan.com/atomic-design-methodology-for-building-design-systems-f912cf714f53）](img/Figure_4.08_B17237.jpg)'
- en: 'Figure 4.8 – Atomic Design elements explained (source: https://blog.kamathrohan.com/atomic-design-methodology-for-building-design-systems-f912cf714f53)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8 – 原子设计元素解释（来源：https://blog.kamathrohan.com/atomic-design-methodology-for-building-design-systems-f912cf714f53）
- en: Let’s explore each of these components to understand them.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索这些组件中的每一个，以便理解它们。
- en: Atoms
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原子
- en: In science class, we learned that atoms are the basic building blocks of matter.
    But when applied to web interfaces, atoms are the HTML tags such as `input`, `label`,
    and so on. They can also be customized to include abstract elements such as color
    palettes, fonts, or animations.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在科学课上，我们学习了原子是物质的基本构建块。但将它们应用于网络界面时，原子是像`input`、`label`这样的HTML标签。它们也可以定制，包括抽象元素，如调色板、字体或动画。
- en: Atoms are not very useful on their own except when combined with other elements
    to form molecules.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 原子本身并不很有用，除非与其他元素结合形成分子。
- en: Molecules
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分子
- en: When we start combining atoms, things start to get a little interesting and
    tangible.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始组合原子时，事情开始变得有点有趣和具体。
- en: The smallest unit of a compound is called a molecule, and it comprises groups
    of atoms bonded together. In web interfaces, these molecules take on their own
    properties and serve as the backbone of any design system.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 化合物的最小单位称为分子，它由结合在一起的原子组成。在网络界面中，这些分子具有自己的属性，并成为任何设计系统的骨架。
- en: For instance, a form input, label, or button is not very useful as standalone
    functionality, but when combined as a form, they become very useful because they
    can actually do something. Furthermore, by combining atoms to form useful components,
    these components become reusable and can also be combined to form organisms.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，表单输入、标签或按钮作为独立的功能性并不十分有用，但结合成表单后，它们就变得非常有用，因为它们实际上可以完成某些事情。此外，通过组合原子形成有用的组件，这些组件变得可重用，也可以组合成生物体。
- en: Organisms
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生物体
- en: An organism is the combination of different molecules used to form a relatively
    complex and distinct section of a component.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 生物体是由用于形成组件相对复杂和独特部分的分子组合而成。
- en: An organism is designed to consist of different or similar molecule types. For
    instance, a molecule can consist of a primary navigation, a list of social media
    channels, a search form, and a logo.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 生物体被设计成由不同或相似类型的分子组成。例如，一个分子可以包含主要导航、社交媒体渠道列表、搜索表单和标志。
- en: The wonderful part of building an organism from molecules is that it encourages
    creating standalone, portable, or reusable components.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 从分子构建生物体的奇妙之处在于，它鼓励创建独立、便携或可重复使用的组件。
- en: Templates
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模板
- en: Templates will already be familiar to the web development world; they are predefined
    groups of organisms stitched together to form a page. In templates, the designs
    start to come together, and the layout of the page becomes structured and visible.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 模板对网络开发世界来说已经非常熟悉；它们是由预定义的、拼接在一起的生物体组成的页面。在模板中，设计开始整合，页面的布局变得结构化和可见。
- en: Each template contains all related abstract molecules, organisms, and atoms
    in some cases. Since templates are visible pages or part of a page, clients can
    start to see the final design.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模板都包含所有相关的抽象分子、生物体和原子，在某些情况下。由于模板是可见的页面或页面的一部分，客户可以开始看到最终设计。
- en: With templates, you can create different versions of your design, whether high
    fidelity, low fidelity, and so on. Templates are more HTML wireframes and can
    also become the final deliverable.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模板，你可以创建不同版本的设计，无论是高保真度、低保真度等。模板更像是HTML线框，也可以成为最终交付成果。
- en: Pages
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 页面
- en: A page is a specific instance of a template; in some cases, a complex page can
    contain more than one template combined to form a bigger page.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 页面是模板的具体实例；在某些情况下，一个复杂的页面可以包含多个模板组合成更大的页面。
- en: A page gives an accurate depiction of what the user will ultimately see, and
    they are the highest level of fidelity and most tangible. It is typically where
    most time is spent, and more reviews revolve around it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 页面提供了用户最终将看到的准确描述，它们是最高级别的保真度和最直观的。通常，大多数时间都花在这里，并且更多的审查都围绕它进行。
- en: In Vue.js, pages represent the different routes users access when navigating
    your application.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vue.js 中，页面代表用户在导航应用程序时访问的不同路由。
- en: Using Atomic Design principles gives us the ability to traverse from abstract
    pages or templates to concrete ones. Because of this, we can create systems that
    promote consistency and scalability while simultaneously showing things in their
    final context.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用原子设计原则使我们能够从抽象的页面或模板过渡到具体的页面。正因为如此，我们能够创建既促进一致性又具有可扩展性的系统，同时展示事物在其最终上下文中的样子。
- en: In this book, we will learn how to use the Atomic Design pattern to structure
    our enterprise project and use Storybook for the design system.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将学习如何使用原子设计模式来构建我们的企业项目，并使用 Storybook 来设计系统。
- en: Tip
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: A design system is a set of interconnected patterns and standards to manage
    design at scale by reducing redundancy while creating a shared language and visual
    consistency across different pages and channels.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 设计系统是一套相互关联的模式和标准，通过减少冗余，在各个页面和渠道之间创建共享语言和视觉一致性，以实现大规模的设计管理。
- en: Storybook
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Storybook
- en: Storybook can be implemented with any architectural pattern, such as Atomic
    Design, to build component-driven **user interfaces** (**UIs**) faster. According
    to the official website ([https://storybook.js.org/](https://storybook.js.org/)),
    Storybook is an open-source tool for building UI components and pages in isolation.
    It streamlines UI development, testing, and documentation.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Storybook 可以与任何架构模式结合使用，例如原子设计，以更快地构建以组件驱动的**用户界面**（**UIs**）。根据官方网站 ([https://storybook.js.org/](https://storybook.js.org/))，Storybook
    是一个用于独立构建 UI 组件和页面的开源工具。它简化了 UI 开发、测试和文档。
- en: Storybook allows us, the developers, to create and test components in isolation.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Storybook 允许我们，作为开发者，在隔离的环境中创建和测试组件。
- en: In the next section, we will learn how to implement Storybook into our project
    and start using the Atomic Design principles to create a maintainable Vue.js 3
    project.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何将 Storybook 实现到我们的项目中，并开始使用原子设计原则来创建可维护的 Vue.js 3 项目。
- en: Implementing Storybook in Vue.js 3
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Vue.js 3 中实现 Storybook
- en: Visit the official documentation for Vue implementation ([https://storybook.js.org/docs/vue/get-started/introduction](https://storybook.js.org/docs/vue/get-started/introduction))
    to follow along with the implementation. In Storybook, everything revolves around
    stories. A story describes the state of a rendered component and captures everything
    a component should/can do when rendered.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 访问官方文档以了解 Vue 实现 ([https://storybook.js.org/docs/vue/get-started/introduction](https://storybook.js.org/docs/vue/get-started/introduction))
    并跟随实现步骤。在 Storybook 中，一切围绕故事展开。一个故事描述了渲染组件的状态，并捕捉了组件在渲染时应该/可以执行的所有操作。
- en: Installing Storybook
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 Storybook
- en: You can use the Storybook CLI to install it in a single command by running it
    inside your existing Vue.js project’s root directory.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 Storybook CLI 在单个命令中将其安装到现有 Vue.js 项目的根目录中。
- en: Storybook will look into your project’s dependencies during installation and
    provide you with the best configuration available.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装过程中，Storybook 会检查您的项目依赖项，并提供最佳的配置。
- en: 'Next, depending on your framework, first, build your app and then check that
    everything works by running the following command:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，根据您的框架，首先构建您的应用程序，然后通过运行以下命令来检查一切是否正常工作：
- en: '[PRE2]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding command will start a new development server and open a browser
    window showing you a welcome screen:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将启动一个新的开发服务器，并打开一个显示欢迎界面的浏览器窗口：
- en: '![Figure 4.9 – The welcome screen](img/Figure_4.09_B17237.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.9 – 欢迎界面](img/Figure_4.09_B17237.jpg)'
- en: Figure 4.9 – The welcome screen
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 – 欢迎界面
- en: Creating a story is as easy as telling the computer what a particular component
    will do, the properties needed to carry out the task, and the different designs
    a particular component can have. In the next section, we will explore how to create
    a story in Storybook.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个故事就像告诉计算机一个特定组件将做什么，执行任务所需的属性，以及特定组件可以具有的不同设计。在下一节中，我们将探讨如何在 Storybook 中创建一个故事。
- en: Creating a story
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个故事
- en: Before we delve into creating stories (components), let’s make sure we’re in
    sync with our folder structure for this project using Atomic Design and Storybook.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入创建故事（组件）之前，让我们确保我们使用原子设计和 Storybook 为此项目同步文件夹结构。
- en: 'The following screenshot shows the complete folder structure for implementing
    Atomic Design and the `stories` folder for Storybook:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了实现原子设计和 Storybook 的 `stories` 文件夹的完整文件夹结构：
- en: '![Figure 4.10 – A screenshot showing the Vue 3 component and the Storybook
    structure](img/Figure_4.10_B17237.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.10 – 展示 Vue 3 组件和 Storybook 结构的屏幕截图](img/Figure_4.10_B17237.jpg)'
- en: Figure 4.10 – A screenshot showing the Vue 3 component and the Storybook structure
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10 – 展示 Vue 3 组件和 Storybook 结构的屏幕截图
- en: From the screenshot example, we have restructured our Vue.js project to use
    the Atomic Design principle and folder structures (the red indicator), and Storybook
    added the `stories` folder (the yellow indicator) to help us understand how to
    write our own stories. We can delete the `stories` folder and follow the pattern
    in *Figure 4**.10* to create our story inside the `component` folder.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 从屏幕截图示例中，我们已经重构了我们的 Vue.js 项目以使用原子设计原则和文件夹结构（红色指示器），并且 Storybook 添加了 `stories`
    文件夹（黄色指示器）以帮助我们了解如何编写自己的故事。我们可以删除 `stories` 文件夹，并按照 *图 4.10* 中的模式在 `component`
    文件夹内创建我们的故事。
- en: Now, we can start creating stories; remember, a story has to depict a particular
    action or group of related actions.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始创建故事；请记住，一个故事必须描绘特定的动作或一系列相关的动作。
- en: 'Here is a story we created for the `Button` component we will use throughout
    the project:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们为将在整个项目中使用的 `Button` 组件创建的故事：
- en: '[PRE3]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For instance, a button will be created in the `atoms` directory because it is
    a single element, though it can have different properties and actions, such as
    being a blue button, white button, clickable button, disabled button, and so on.
    It’s still a button.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，按钮将在 `atoms` 目录中创建，因为它是一个单一元素，尽管它可以有不同的属性和动作，如蓝色按钮、白色按钮、可点击按钮、禁用按钮等。它仍然是一个按钮。
- en: From the story, we can see that the `Button` component will have two sizes (`small`
    and `large`), also, it will have two designs, which are `primary` and `secondary`,
    and additionally, it will accept two properties, namely `primary` and `label`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 从故事中，我们可以看到 `Button` 组件将有两个尺寸（`small` 和 `large`），此外，它还将有两个设计，即 `primary` 和 `secondary`，并且它还将接受两个属性，即
    `primary` 和 `label`。
- en: You can learn how to write a story to test the properties and actions of the
    button using the official documentation ([https://storybook.js.org/docs/vue/get-started/whats-a-story](https://storybook.js.org/docs/vue/get-started/whats-a-story)).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过官方文档了解如何编写故事来测试按钮的属性和动作（[https://storybook.js.org/docs/vue/get-started/whats-a-story](https://storybook.js.org/docs/vue/get-started/whats-a-story)）。
- en: 'Once you have created all your components and stories, you should have a directory
    like the one shown in the following screenshot:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您创建了所有组件和故事，您应该有一个如下截图所示的目录：
- en: '![Figure 4.11 – A screenshot showing a complete directory including Storybook
    stories](img/Figure_4.11_B17237.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.11 – 展示包括 Storybook 故事的完整目录的屏幕截图](img/Figure_4.11_B17237.jpg)'
- en: Figure 4.11 – A screenshot showing a complete directory including Storybook
    stories
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11 – 展示包括 Storybook 故事的完整目录的屏幕截图
- en: Furthermore, with your project arranged like this, it becomes easy for developers
    to understand the structure and where to find components easily. Members of the
    team can easily test out components with different properties before even using
    them in the real project using Storybook.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，按照这样的项目结构，开发者可以轻松理解结构并快速找到组件。团队成员可以在实际项目中使用 Storybook 在使用组件之前轻松测试具有不同属性的组件。
- en: In the next section, we will explore how to create an internationalized application
    in Vue.js 3, which allows your application to not be limited to a single language
    and cultural setting.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何在 Vue.js 3 中创建国际化应用程序，这使得您的应用程序不仅限于单一的语言和文化环境。
- en: Implementing internationalization and localization
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施国际化和本地化
- en: The essence of building an enterprise application is to support local markets
    around the world and to achieve this, that’s where internationalization comes
    into place.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 构建企业应用程序的本质是支持全球各地的本地市场，而要实现这一点，国际化就派上用场了。
- en: The process of preparing software to support local languages and the cultural
    settings of other geographical locations is called **internationalization** (**I18n**).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 准备软件以支持本地语言和其他地理区域的文化的过程被称为**国际化**（**I18n**）。
- en: I18n is often misrepresented as **localization** (**L10n**) and sometimes even
    translation.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: I18n经常被误认为是**本地化**（**L10n**），有时甚至翻译。
- en: While Il8n is a product development approach that is focused on making one code
    base capable of supporting worldwide languages and locale-specific formatting
    and behaviors, L10n makes a product specific to a target market or region(s),
    including translation of the interface and possible adaptation of terminology
    and more.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Il8n 是一种产品开发方法，旨在使一个代码库能够支持全球语言和特定地区格式的格式和行为，但 L10n 使产品针对特定市场或地区（包括界面翻译和术语可能的调整等）。
- en: In this section, we will first look into the benefits of internationalizing
    the software and further explore how to implement I18n in Vue 3.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将首先探讨软件国际化的好处，并进一步探讨如何在Vue 3中实现I18n。
- en: Benefits of internationalizing software
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件国际化的好处
- en: 'The benefits of creating internalized software are enormous and some of these
    are listed here:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 创建内部化软件的好处是巨大的，其中一些列在这里：
- en: It creates higher-quality software that meets the technical and cultural needs
    of multiple locales
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它创建出满足多个地区技术和文化需求的更高质量的软件
- en: It provides greater in-country customer acceptance and satisfaction
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了更高的国内客户接受度和满意度
- en: It provides a single source code for all languages of the product
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为产品的所有语言提供单一源代码
- en: Internalized software reduces time, cost, and effort for L10n
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部化软件减少了本地化所需的时间、成本和努力
- en: Internalized software is simpler, and supports easier maintenance for future
    iterations of the product
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部化软件更简单，并支持产品未来迭代时更容易的维护
- en: Market acceptance is one of the major problems that arises when software is
    not fully internalized before or after release.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 市场接受度是软件在发布前后没有完全内部化时出现的主要问题之一。
- en: Therefore, we will look at how to implement I18n in our enterprise Vue 3 application
    right from the development phase.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将探讨如何在我们的企业Vue 3应用程序的开发阶段实现I18n。
- en: Installing Vue I18n
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Vue I18n
- en: In Vue 3, Vue-I18n is a great compatible plugin that is used to implement I18n,
    and it easily integrates some localization features into your Vue.js application.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vue 3中，Vue-I18n是一个优秀的兼容插件，用于实现I18n，并且它能够轻松地将一些本地化功能集成到你的Vue.js应用中。
- en: 'Follow these steps to internationalize your app:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤国际化你的应用：
- en: 'There are different ways to install the package according to the official documentation
    (`https://vue-i18n.intlify.dev/installation.html`), but we will install it using
    the `npm` command, as shown here:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据官方文档（`https://vue-i18n.intlify.dev/installation.html`），有不同方式来安装该包，但我们将使用`npm`命令安装，如下所示：
- en: '[PRE4]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After installation, inside the Vue 3 `main.js` file, add the following script:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装后，在Vue 3的`main.js`文件中，添加以下脚本：
- en: '[PRE5]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With the preceding setup, you should have internalization added to your Vue
    project, but it will easily get bloated when developers start adding translations.
    So, we recommend creating a `locales` folder where every locale-related configuration
    will be added.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的设置中，你应该已经将内部化添加到你的Vue项目中，但当开发者开始添加翻译时，它将很容易变得臃肿。因此，我们建议创建一个`locales`文件夹，其中将添加所有与地区相关的配置。
- en: 'Let’s create the folder and the files inside the root directory like so:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们按照如下方式在根目录下创建文件夹和文件：
- en: '[PRE6]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, inside each of the translation files, add the following codes and other
    translations:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在每个翻译文件中，添加以下代码和其他翻译：
- en: '[PRE7]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Inside the `index.js` file, add the following scripts to import different locales:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`index.js`文件中，添加以下脚本以导入不同的地区：
- en: '[PRE8]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Lastly, add the files to your `createI18n` configuration in your `main.js`
    file:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将文件添加到你的`main.js`文件中的`createI18n`配置中：
- en: '[PRE9]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Arranging your files and folder in this structure allows for easy adoption
    and maintainability. Let’s look at the final structure of our project, including
    internationalization, in the following screenshot:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这种结构安排你的文件和文件夹，可以方便地采用和维护。让我们在以下屏幕截图中查看我们的项目最终结构，包括国际化：
- en: "![Figure \uFEFF4.12 – The final structure of the Vue 3 application](img/Figure_4.12_B17237.jpg)"
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.12 – Vue 3应用程序的最终结构](img/Figure_4.12_B17237.jpg)'
- en: Figure 4.12 – The final structure of the Vue 3 application
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12 – Vue 3应用程序的最终结构
- en: Summary
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter reviewed in more depth architecting large-scale web apps with Vue
    3\. We discussed the structure and file architecture by diving deeper into the
    law of predictability and how to use community-recommended packages to inform
    predictability in your Vue.js 3 enterprise-ready application.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 本章更深入地回顾了使用 Vue 3 架构大型 Web 应用。我们通过深入研究可预测性法则以及如何使用社区推荐的包来提高你的 Vue.js 3 企业级应用的可预测性，讨论了结构和文件架构。
- en: We also covered in detail how to use micro frontend architecture to your advantage.
    Also, we discussed how to implement an Atomic Design with Storybook to streamline
    your component directory and make your enterprise project less difficult to understand.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还详细介绍了如何利用微前端架构的优势。此外，我们还讨论了如何使用 Storybook 实现 Atomic Design，以简化你的组件目录，并使你的企业项目更容易理解。
- en: Next, we discussed how to add I18n to your Vue application. We also discussed
    the benefits and how to properly integrate I18n into your Vue 3 application.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们讨论了如何将 I18n 添加到你的 Vue 应用中。我们还讨论了其优势和如何正确地将 I18n 集成到你的 Vue 3 应用程序中。
- en: In the next chapter, we will explore GraphQL, GraphQL Apollo Server 2, queries,
    mutations, and how to integrate these technologies into your Vue.js 3 application.
    In addition, you will learn how to utilize GraphQL to deliver scalable and high-performing
    applications.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 GraphQL、GraphQL Apollo Server 2、查询、突变，以及如何将这些技术集成到你的 Vue.js 3 应用程序中。此外，你还将学习如何利用
    GraphQL 来提供可扩展且性能高的应用程序。
