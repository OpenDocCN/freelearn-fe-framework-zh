<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Performance of React Apps"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Performance of React Apps</h1></div></div></div><p>In the previous chapter, we learned to use various React add-ons. We saw add-ons ranging from immutability helpers to test utilities.</p><p>In this chapter, we will look at React performance tools that can improve the performance of our React apps. In particular, we will be using the PERF add-on, <code class="literal">PureRenderMixin</code> and <code class="literal">shouldComponentUpdate</code>. We will also look at some of the gotchas that needs to be considered while using the performance tools provided by React.</p><div class="section" title="Performance of React apps"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec63"/>Performance of React apps</h1></div></div></div><p>"Hey Mike, I have few questions for you today. I have been thinking about our search app over the weekend. Do you have some time to discuss them?" Shawn asked.</p><p>"Sure, but let me get some coffee first. Okay, I am ready now. Shoot!" said Mike.</p><p>"I have few <a id="id214" class="indexterm"/>questions about the performance of React apps. I know React is very good at re-rendering the component tree whenever the state changes. React has made it very easy for me to understand and reason my code. However, does it not hamper the performance? Re-rendering seems like a very costly affair, especially when re-rendering large component trees." Shawn asked.</p><p>"Shawn, the re-rendering can be expensive. Nevertheless, React is smart about it. It only renders the part that is changed. It does not need to re-render everything on the page. It's also smart at keeping the DOM manipulation as least as possible."</p><p>"How is that possible? How does it know which part of the page is changed? Does it not depend on user interactions or incoming states and props?" questioned Shawn.</p><p>"The virtual DOM comes to the rescue here. It does all the heavy lifting of keeping track of what changed and helping React make only minimal changes to the real DOM." Mike explained.</p></div></div>
<div class="section" title="Virtual DOM"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec64"/>Virtual DOM</h1></div></div></div><p>"Shawn, React uses virtual DOM <a id="id215" class="indexterm"/>to keep track of what has changed in the real DOM. It's concept is very easy to understand. React always keeps a copy of the representation of the actual DOM in memory. Whenever something changes, such as some state manipulation, it calculates another copy of the DOM that will be generated with new state and props. Then it calculates the difference between the original copy of the virtual DOM and the new copy of the virtual DOM. This difference results in minimal operations on the real DOM that can take the current DOM to a new stage. In this way, React does not have to do major changes when something changes." Mike explained.</p><p>"But isn't the diff calculation expensive?" asked Shawn.</p><p>"It's not expensive when you compare it with actual DOM operations. Manipulation of DOM is always expensive. The comparison of virtual DOM occurs in JavaScript code, so it is always faster than doing manual DOM operations." said Mike.</p><p>"Another advantage of this approach is that once React knows what operations are needed to be performed on DOM, it does them in a single batch. Therefore, when we render a list of 100 elements, instead of appending one element at a time, React will do minimal DOM operations to insert these 100 elements on the page." Mike explained.</p><p>"I am impressed!" Shawn exclaimed .</p><p>"You will be more impressed. Let me actually show you what I mean. Let's use the PERF add-on from React and actually see what we discussed in real time."</p></div>
<div class="section" title="The PERF addon"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec65"/>The PERF addon</h1></div></div></div><p>"Let's start with installing the PERF addon."</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ npm install react-addons-perf --save-dev</strong></span>
</pre></div><p>"We need this <a id="id216" class="indexterm"/>add-on only in the development mode. This is an important point to remember because in production, we don't need the debugging information as it may make our app slow." informed Mike.</p><p>"Shawn, the PERF add-on can be used to see what changes React is doing with the DOM, where is it spending time while rendering our app, is it wasting some time while rendering, and so on. This information can then be used to improve the performance of the app." said Mike.</p><p>"Let's start by exposing the PERF add-on as a global object. We can use it in the browser console while our app is running to see how React is making changes as per the user interactions." explained Mike.</p><div class="informalexample"><pre class="programlisting">// index.js
import ReactDOM from 'react-dom';
import React from 'react';
import App from './App';
import Perf from 'react-addons-perf';

window.Perf = Perf;

ReactDOM.render(&lt;App /&gt;, document.getElementById('rootElement'));</pre></div><p>"We have <a id="id217" class="indexterm"/>imported the PERF add-on in our <code class="literal">index.js</code> file, which is the starting point of the app. We can access the <code class="literal">Perf</code> object in the browser console as we have attached it to <code class="literal">window.Perf</code>." Mike added.</p><div class="mediaobject"><img src="graphics/4730_08_01.jpg" alt="The PERF addon"/></div><p>"The PERF add-on comes with methods that can help us understand what React is doing with the DOM when something changes. Let's measure some performance statistics. We will start the measurement process by calling <code class="literal">Perf.start()</code> in the browser console. After that, we will interact with the app. We will type in a query to search a book, hit submit, and the search results will be displayed. We will stop the performance measurement by calling <code class="literal">Perf.stop()</code> in the browser console. After that, let's analyze the information that we gathered." Mike explained the process.</p><div class="mediaobject"><img src="graphics/4730_08_02.jpg" alt="The PERF addon"/></div><p>"Let's search for books written by Dan Brown."</p><div class="mediaobject"><img src="graphics/4730_08_03.jpg" alt="The PERF addon"/></div><p>"Once the <a id="id218" class="indexterm"/>results are displayed, let's stop the performance measurements."</p><div class="mediaobject"><img src="graphics/4730_08_04.jpg" alt="The PERF addon"/></div></div>
<div class="section" title="DOM operations performed by React"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec66"/>DOM operations performed by React</h1></div></div></div><p>"Shawn, the <a id="id219" class="indexterm"/>PERF add-on can show us which DOM operations <a id="id220" class="indexterm"/>were performed by React. Let's see what manipulations React did to the DOM to render the list of books by Dan Brown." said Mike.</p><div class="mediaobject"><img src="graphics/4730_08_05.jpg" alt="DOM operations performed by React"/></div><p>"The <code class="literal">Perf.printDOM()</code> method tells us the DOM manipulations made by React. It has made only two set <code class="literal">innerHTML</code> calls. First one is to render the spinner and second one is to render the list of rows. In between, we see a call to remove, which must be when the spinner was removed from the page."</p><p>"Wow, this method looks very handy as it can tell us if React is somehow doing some extra DOM manipulations." said Shawn.</p><p>"Yes, but <a id="id221" class="indexterm"/>there are more tools for the purpose analyzing the <a id="id222" class="indexterm"/>performance. Let's see how much time does React require to render each component. This can be achieved using <code class="literal">Perf.printInclusive()</code>." explained Mike.</p><div class="section" title="Time taken to render all the components"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec14"/>Time taken to render all the components</h2></div></div></div><div class="mediaobject"><img src="graphics/4730_08_06.jpg" alt="Time taken to render all the components"/></div><p>"This method <a id="id223" class="indexterm"/>prints the overall time taken to render all the components. This also included the time required to process props and set up initial state and calls to <code class="literal">componentDidMount</code> and <code class="literal">componentWillMount</code>."</p><p>"Therefore, if we have some time-intensive operation in one of these hooks, it will impact the output shown by the <code class="literal">printInclusive</code> function, right?" Shawn asked.</p><p>"Exactly. Though the PERF add-on provided another method—<code class="literal">printExclusive()</code>—that prints the time to taken render without these hooks, which are used to mount apps."</p><div class="mediaobject"><img src="graphics/4730_08_07.jpg" alt="Time taken to render all the components"/></div><p>"But Mike, these methods are not that helpful for detecting the performance of React. I get the <a id="id224" class="indexterm"/>overall picture about what all things happened, but it does not tell me how to optimize which part." asked Shawn.</p></div><div class="section" title="Time wasted by React"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec15"/>Time wasted by React</h2></div></div></div><p>"Shawn, the PERF add-on can also tell us how much time was wasted by React and where. It is <a id="id225" class="indexterm"/>helpful in determining the parts of our app that we can optimize further." said Mike.</p><p>"What is wasted time?"</p><p>"When React re-renders a component tree, some components may not change from their previous representation. However, if they are rendered again, then React has wasted time in rendering the same output. The PERF add-on can keep track of all such time and give us a summary of how React wasted time rendering the same output as before. Let's see this in action." said Mike.</p><div class="mediaobject"><img src="graphics/4730_08_08.jpg" alt="Time wasted by React"/></div><p>"The PERF add-on tells us that it wasted time in re-rendering the <code class="literal">Form</code> component twice, but nothing was changed in the Form component, therefore, it just re-rendered everything as it is." explained Mike.</p><p>"Let's see the <code class="literal">Form</code> component to understand why it is happening."</p><div class="informalexample"><pre class="programlisting">// src/Form.js

import React from 'react';

export default React.createClass({
  getInitialState() {
    return { searchTerm: '' };
  },

  _submitForm() {
    this.props.performSearch(this.state.searchTerm);
  },

  render() {
    return (
      &lt;div className="row" style={this.props.style}&gt;
        &lt;div&gt;
          &lt;div className="input-group"&gt;
            &lt;input type="text"
                   className="form-control input-lg"
                   placeholder="Search books..."
                   onChange={(event) =&gt; { this.setState({searchTerm: event.target.value}) }}/&gt;
            &lt;span className="input-group-btn"&gt;
              &lt;button className="btn btn-primary btn-lg"
                      type="button"
                      onClick={this._submitForm}&gt;
                Go!
              &lt;/button&gt;
            &lt;/span&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    )
  }
})</pre></div><p>"Shawn, the <code class="literal">Form</code> component does not depend on state or props for its rendering. It renders the same output irrespective of state and props. However, we update its state when a user enters a character in the input box. Due to this, React will re-render it. Nothing is actually <a id="id226" class="indexterm"/>changed in the re-rendered output. Therefore, the PERF add-on is complaining about the wasted time." Mike explained.</p><p>"This is useful information, but this looks like an insignificant wastage, right?" Shawn asked.</p><p>"Agree. Let's make some changes so that I can show you how React can literally waste a lot of time re-rendering the same output when it shouldn't." said Mike.</p><p>"Currently, we only show the first 100 search results returned by the Open Library API. Let's change our code to show all the results on same page."</p><div class="informalexample"><pre class="programlisting">// src/App.js
getInitialState() {
    return { books: [],
             totalBooks: 0,
             offset: 100,
             searching: false,
             sorting: 'asc',
             page: 1,
             searchTerm: '',
             totalPages: 1
    };
  }</pre></div><p>"I have introduced a new state to hold the search term, total number of pages to fetch from the Open Library, and current page number being fetched."</p><p>"Now, we want to fetch all the results from the API, by default, on the same page. The API returns us the total number of books found for a query in the <code class="literal">numFounds</code> attribute. Based on this, we <a id="id227" class="indexterm"/>need to find the total number of pages that we need to fetch from the API."</p><p>"Also, each time maximum 100 records are returned that we have stored in <code class="literal">state.offset</code> already."</p><div class="informalexample"><pre class="programlisting">totalPages = response.numFound / this.state.offset + 1;</pre></div><p>"Once we get the total number of pages, we need to keep asking for the search results for the next page until all the pages are fetched. You want to try and get this working?" asked Mike.</p><p>"Sure." said Shawn.</p><div class="informalexample"><pre class="programlisting"> // src/App.js  

 // Called when user hits "Go" button.
 _performSearch(searchTerm) {
    this.setState({searching: true, searchTerm: searchTerm});
    this._searchOpenLibrary(searchTerm);
  },

  _searchOpenLibrary(searchTerm) {
    let openlibraryURI = `https://openlibrary.org/search.json?q=${searchTerm}&amp;page=${this.state.page}`;
    this._fetchData(openlibraryURI).then(this._updateState);
  },

  // called with the response received from open library API
  _updateState(response) {
    let jsonResponse = response;
    let newBooks = this.state.books.concat(jsonResponse.docs);
    let totalPages = jsonResponse.numFound / this.state.offset + 1;
    let nextPage = this.state.page + 1;

    this.setState({
      books: newBooks,
      totalBooks: jsonResponse.numFound,
      page: nextPage,
      totalPages: totalPages
    } this._searchAgain);
  },

     // Keep searching until all pages are fetched.
  _searchAgain() {
    if (this.state.page &gt; this.state.totalPages) {
      this.setState({searching: false});
    } else {
      this._searchOpenLibrary(this.state.searchTerm);
    }
  }</pre></div><p>"I changed the API URL to include the page parameter. Each time the response is received from API, we update the state with a new page. We also update <code class="literal">this.state.books</code> to include the newly fetched books. Then, the <code class="literal">_searchAgain</code> function gets <a id="id228" class="indexterm"/>called in the callback of the <code class="literal">this.setState</code> call so that it is the correct value of the next page that was set by the <code class="literal">this.setState</code> call." explains Shawn.</p><p>"Nice, it's an important point to remember not to call the <code class="literal">_searchAgain</code> function outside of the <code class="literal">this.setState()</code> call as it may get executed before <code class="literal">setState()</code> is finished.</p><p>Because if we call it outside, the <code class="literal">_searchAgain</code> function may use an incorrect value of <code class="literal">this.state.page</code>. However, as you have passed the <code class="literal">_searchAgain</code> function in the callback to <code class="literal">setState</code>, there is no chance this will happen." said Mike.</p><p>"The <code class="literal">_searchAgain</code> function just keeps fetching the results until all the pages are completed. In this way, we will display all the search results on the page, not just the first 100." informed Shawn.</p><p>"That's what I wanted. Good job. Let me cleanup the render method so that spinner will always be displayed at the bottom." said Mike.</p><div class="informalexample"><pre class="programlisting">// src/App.js
render() {
    let style = {paddingTop: '5%'};
    return (
      &lt;div className='container'&gt;
        &lt;Header style={style}&gt;&lt;/Header&gt;
        &lt;Form style={style}
              performSearch={this._performSearch}&gt;
        &lt;/Form&gt;

        {this.state.totalBooks &gt; 0 ?
         &lt;BookList
             searchCount={this.state.totalBooks}
             _sortByTitle={this._sortByTitle}&gt;
           {this._renderBooks()}
         &lt;/BookList&gt;
       : null }

        { this.state.searching ? &lt;Spinner /&gt; : null }
      &lt;/div&gt;
    );
  }</pre></div><p>"This will make sure that the spinner will be displayed until all the results are displayed. OK, all done. Now let's measure the performance again." said Mike.</p><div class="mediaobject"><img src="graphics/4730_08_09.jpg" alt="Time wasted by React"/></div><p>"Wow, the wasted time has increased a lot! Did Dan Brown release new books or what? So much <a id="id229" class="indexterm"/>extra time than what we saw last time?" said Shawn.</p><p>"Haha, I don't think that he released new books just now. Whenever the books on next page are fetched, we add them to the existing books and start fetching books from the next page. However, the books rendered for the previous pages are not changed at all. As we are keeping all of our state in the top-level <code class="literal">App</code> component, whenever its state changes, the whole component tree under <code class="literal">App</code> gets re-rendered. Therefore, <code class="literal">BookList</code> is rendered again. In turn, all <code class="literal">BookRows</code> are rendered again. This results in a significant amount of time getting wasted in rendering the same <code class="literal">BookRow</code> components for the previous pages again and again." said Mike.</p><p>"So each time we fetch books from a new page, all books, including the existing ones already present on page, get re-rendered again? I think just appending new book rows to the existing list is better in this case." said Shawn.</p><p>"Don't worry. We can easily get rid of this unnecessary wastage of time. React provides us a hook <a id="id230" class="indexterm"/>for short-circuiting the re-render process. It's <code class="literal">shouldComponentUpdate</code>."</p></div><div class="section" title="The shouldComponentUpdate hook"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec16"/>The shouldComponentUpdate hook</h2></div></div></div><p>"Shawn, <code class="literal">shouldComponentUpdate</code> is a hook that tells React whether to re-render a component or not. It's not called for initial rendering of the component. However, whenever <a id="id231" class="indexterm"/>a component is going to receive <a id="id232" class="indexterm"/>new state or props, <code class="literal">shouldComponentUpdate</code> is called before that. If the return value of this function is true, then React re-renders the component. However, if the return value is <code class="literal">false</code>, then React does not re-render the component until the next time it is called. The <code class="literal">componentWillUpdate</code> and <code class="literal">componentDidUpdate</code> hooks will also not be called in this case." Mike explained.</p><p>"Nice. Then why did our code waste so much time? Should React not use this hook to optimize it and not re-render the same <code class="literal">BookRow</code> components repeatedly?" Shawn asked.</p><p>"By default, <code class="literal">shouldComponentUpdate</code> always returns true. React does this to avoid subtle bugs. We can have mutable state or props in our code that can make <code class="literal">shouldComponentUpdate</code> to return false positives. It may return false when it should return true, resulting in the component not being re-rendered when it should. Therefore, React places the responsibility of implementing <code class="literal">shouldComponentUpdate</code> in the developer's hand." said Mike.</p><p>"Let's try to use <code class="literal">shouldComponentUpdate</code> ourselves in order to reduce the time wasted in re-rendering the same <code class="literal">BookRow</code> components." Mike added.</p><p>"This is our <code class="literal">BookRow</code> component as of now:"</p><div class="informalexample"><pre class="programlisting">// src/BookRow.js

import React from 'react';

export default React.createClass({
  render() {
    return(
      &lt;tr style={this.props.style}&gt;
        &lt;td&gt;&lt;h4&gt;#{this.props.index}&lt;/h4&gt;&lt;/td&gt;
        &lt;td&gt;&lt;h4&gt;{this.props.title}&lt;/h4&gt;&lt;/td&gt;
        &lt;td&gt;&lt;h4&gt;{(this.props.author_name || []).join(', ')}&lt;/h4&gt;&lt;/td&gt;
        &lt;td&gt;&lt;h4&gt;{this.props.edition_count}&lt;/h4&gt;&lt;/td&gt;
      &lt;/tr&gt;
    );
  }
});</pre></div><p>"Let's add <code class="literal">shouldComponentUpdate</code> to reduce unnecessary re-rendering."</p><div class="informalexample"><pre class="programlisting">// src/BookRow.js

import React from 'react';

export default React.createClass({
  shouldComponentUpdate(nextProps, nextState) {
    return nextProps.title !== this.props.title ||
           nextProps.author_name !== this.props.author_name ||
           nextProps.edition_count !== this.props.edition_count;
  },

  render() {
    return(
      &lt;tr style={this.props.style}&gt;
        &lt;td&gt;&lt;h4&gt;#{this.props.index}&lt;/h4&gt;&lt;/td&gt;
        &lt;td&gt;&lt;h4&gt;{this.props.title}&lt;/h4&gt;&lt;/td&gt;
        &lt;td&gt;&lt;h4&gt;{(this.props.author_name || []).join(', ')}&lt;/h4&gt;&lt;/td&gt;
        &lt;td&gt;&lt;h4&gt;{this.props.edition_count}&lt;/h4&gt;&lt;/td&gt;
      &lt;/tr&gt;
    );
  }
});</pre></div><p>The <code class="literal">shouldComponentUpdate</code> hook gets <code class="literal">nextProps</code> and <code class="literal">nextState</code> as arguments and we can <a id="id233" class="indexterm"/>compare them with the current <a id="id234" class="indexterm"/>state or props to make a decision whether to return true or false.</p><p>"Here, we are checking whether the title, author name, or edition count is changed or not. If any of these attributes are changed, then we will return <code class="literal">true</code>. However, if all of them are unchanged, then we will return <code class="literal">false</code>. Therefore, if none of the props are changed, the component will not get re-rendered. As the <code class="literal">BookRow</code> component only depends on props, we don't have to worry about the state change at all." added Mike.</p><p>"Now, measure the performance again and see if we got some improvements."</p><div class="mediaobject"><img src="graphics/4730_08_10.jpg" alt="The shouldComponentUpdate hook"/></div><p>"Awesome, we <a id="id235" class="indexterm"/>got rid of the time <a id="id236" class="indexterm"/>spent in re-rendering the <code class="literal">BookRow</code> components completely. However, we can still improve a lot. Looks like we can also get rid of the time spent re-rendering the <code class="literal">Form</code> and <code class="literal">Header</code> components, based on the preceding result. They are static components. Therefore, they should not be re-rendered at all. Shawn, that's your next challenge."</p><p>"On it."</p><div class="informalexample"><pre class="programlisting">// src/Header.js

import React from 'react';

export default React.createClass({
  shouldComponentUpdate(nextProps, nextState) {
    return false;
  },

  render() {
    return (
      &lt;div className="row" style={this.props.style}&gt;
        &lt;div className="col-lg-8 col-lg-offset-2"&gt;
          &lt;h1&gt;Open Library | Search any book you want!&lt;/h1&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    )
  }
})

// src/Form.js

import React from 'react';

export default React.createClass({
  getInitialState() {
    return { searchTerm: '' };
  },

  shouldComponentUpdate(nextProps, nextState) {
    return false;
  },

  _submitForm() {
    this.props.performSearch(this.state.searchTerm);
  },

  render() {
    return (
      &lt;div className="row" style={this.props.style}&gt;
        &lt;div&gt;
          &lt;div className="input-group"&gt;
            &lt;input type="text"
                   className="form-control input-lg"
                   placeholder="Search books..."
                   onChange={(event) =&gt; { this.setState({searchTerm: event.target.value}) }}/&gt;
            &lt;span className="input-group-btn"&gt;
              &lt;button className="btn btn-primary btn-lg"
                      type="button"
                      onClick={this._submitForm}&gt;
                Go!
              &lt;/button&gt;
            &lt;/span&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    )
  }
})</pre></div><p>"Mike, we <a id="id237" class="indexterm"/>can simply return <code class="literal">false</code> from <code class="literal">shouldComponentUpdate</code> for <code class="literal">Header</code> and <code class="literal">Form</code> components as they do not <a id="id238" class="indexterm"/>depend on states or props at all for rendering!"</p><p>"Perfect find, Shawn. Make a note of such static components that do not depend on anything. They are perfect targets for just telling React to not even compare their virtual DOM as they do not need to be re-rendered at all." informed Mike.</p><p>"Right. I will keep an eye on such static parts of UI that can be extracted into smaller components." said Shawn.</p><p>"Let's now see if we got rid of some more wasted time after doing these improvements."</p><div class="mediaobject"><img src="graphics/4730_08_11.jpg" alt="The shouldComponentUpdate hook"/></div><p>"Cool! We <a id="id239" class="indexterm"/>got rid of the time wasted <a id="id240" class="indexterm"/>for re-rendering the same <code class="literal">Header</code> and <code class="literal">Form</code> components." said Mike.</p><p>"Awesome! Let me also try to get rid of the time spent on <code class="literal">BookList</code> and <code class="literal">RowAlternator</code> too." informed Shawn.</p><p>"Hold on, Shawn. Before doing this, I want to discuss about an alternative to <code class="literal">shouldComponentUpdate</code>."</p></div></div>
<div class="section" title="PureRenderMixin"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec67"/>PureRenderMixin</h1></div></div></div><p>"Shawn, <code class="literal">PureRenderMixin</code> is an add-on that can be used in place of <code class="literal">shouldComponentUpdate</code>. Under the hood, it uses <code class="literal">shouldComponentUpdate</code> and compares the <a id="id241" class="indexterm"/>current props and state with the next props and states. Let's try it in <a id="id242" class="indexterm"/>our code. First, we need to install the add-on, of course." said Mike.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ npm install react-addons-pure-render-mixin</strong></span>

<span class="strong"><strong>// src/Header.js</strong></span>

<span class="strong"><strong>import React from 'react';</strong></span>
<span class="strong"><strong>import PureRenderMixin from 'react-addons-pure-render-mixin';</strong></span>

<span class="strong"><strong>export default React.createClass({</strong></span>
<span class="strong"><strong>  mixins: [PureRenderMixin],</strong></span>
<span class="strong"><strong>     ..</strong></span>
<span class="strong"><strong>     ..</strong></span>
<span class="strong"><strong>})</strong></span>

<span class="strong"><strong>// src/Form.js</strong></span>

<span class="strong"><strong>import React from 'react';</strong></span>
<span class="strong"><strong>import PureRenderMixin from 'react-addons-pure-render-mixin';</strong></span>

<span class="strong"><strong>export default React.createClass({</strong></span>
<span class="strong"><strong>  mixins: [PureRenderMixin],</strong></span>
<span class="strong"><strong>  ..</strong></span>
<span class="strong"><strong>  ..</strong></span>
<span class="strong"><strong>     }</strong></span>
<span class="strong"><strong>})</strong></span>
</pre></div><p>"Shawn, let's see the wasted time now that we have used <code class="literal">PureRenderMixin</code>." said Mike.</p><div class="mediaobject"><img src="graphics/4730_08_12.jpg" alt="PureRenderMixin"/></div><p>"Oh, it got worse. The <code class="literal">PureRenderMixin</code> function added the time wasted in re-rendering <code class="literal">Form</code> and <code class="literal">Header</code> components back. What is going on, Mike?" Shawn asked.</p><p>"Calm down! I <a id="id243" class="indexterm"/>am going to explain why this happened. The <code class="literal">PureRenderMixin</code> compares the current props and state with the next props and state, but it does shallow comparison. Therefore, if we are passing the state or props that contain objects and arrays, then the shallow comparison will not return true even if they both have the same content." Mike explained.</p><p>"However, where are we passing any complex objects or arrays to the <code class="literal">Header</code> and <code class="literal">Form</code> components? We are just passing the book data such as the name of author, edition count, and so on. We are not passing anything to <code class="literal">Header</code>, how does <code class="literal">PureRenderMixin</code> fail?" Shawn asked.</p><p>"You are forgetting style prop passed to <code class="literal">Header</code> and <code class="literal">Form</code> from the <code class="literal">App</code> component." informed Mike.</p><div class="informalexample"><pre class="programlisting">// src/App.js

render() {
    let style = {paddingTop: '5%'};
    return (
      &lt;div className='container'&gt;
        &lt;Header style={style}&gt;&lt;/Header&gt;
        &lt;Form style={style}
              performSearch={this._performSearch}&gt;
        &lt;/Form&gt;
         ..
         ..
      &lt;/div&gt;
)}</pre></div><p>"Each time <code class="literal">App</code> gets re-rendered, a new object for style is created and sent to <code class="literal">Header</code> and <code class="literal">Form</code> in props."</p><div class="mediaobject"><img src="graphics/4730_08_13.jpg" alt="PureRenderMixin"/></div><div class="section" title="The PureRenderMixin anti pattern"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec17"/>The PureRenderMixin anti pattern</h2></div></div></div><p>The <code class="literal">PureRenderMixin</code> internally <a id="id244" class="indexterm"/>implements <code class="literal">shouldComponentUpdate</code>, as follows: </p><div class="informalexample"><pre class="programlisting">var ReactComponentWithPureRenderMixin = {
  shouldComponentUpdate: function(nextProps, nextState) {
    return shallowCompare(this, nextProps, nextState);
  },
};</pre></div><p>The <code class="literal">shallowCompare</code> function is also an add-on provided by React that is a helper function to compare the <a id="id245" class="indexterm"/>current state and props with the next state and props. It basically achieves the same thing as <code class="literal">PureRenderMixin</code>, but as it is a function, it can be used directly instead of using <code class="literal">PureRenderMixin</code>. It is especially needed when we are using ES6 classes with React." Mike explained.</p><p>"Mike, so the shallow comparison is the reason why <code class="literal">PureRenderMixin</code> is failing to detect that there is no change in the next props?" Shawn asked.</p><p>"Yes. The <code class="literal">shallowCompare</code> just iterates over the keys of objects that are being compared and returns false when the value of the key in each object is not strictly equal. Therefore, if we pass simple props, as follows, then <code class="literal">shallowCompare</code> will correctly determine that re-rendering is not required:"</p><div class="informalexample"><pre class="programlisting">// shallowCompare will detect correctly that props are not changed.
{ author_name: "Dan Brown", 
  edition_count: "20", 
  title: "Angels and Demons" }</pre></div><p>"However, it will fail immediately with a prop that is an object or array."</p><div class="informalexample"><pre class="programlisting">{ author_name: "Dan Brown", 
  edition_count: "20", 
  title: "Angels and Demons", 
  style: { paddingTop: '%5' } }</pre></div><p>"Though <code class="literal">PureRenderMixin</code> saves us a few lines of code, it may not work all the time as we expect it to work. Especially when we have mutable state, objects, or arrays in props." said Mike.</p><p>"Got it. So we can write our own <code class="literal">shouldComponentUpdate</code> function when we have nested state or props right?", Shawn asked.</p><p>"Yes. <code class="literal">PureRenderMixin</code> and <code class="literal">shallowCompare</code> is good for simple components with simple props <a id="id246" class="indexterm"/>and states but we should take <a id="id247" class="indexterm"/>care when we are using it." Mike.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p>Using mixins is discouraged in React world for various reasons. Checkout alternative <a id="id248" class="indexterm"/>approaches for <code class="literal">PureRenderMixin</code> pattern here - <a class="ulink" href="https://github.com/gaearon/react-pure-render">https://github.com/gaearon/react-pure-render</a>.</p></div></div></div></div>
<div class="section" title="Immutable data"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec68"/>Immutable data</h1></div></div></div><p>"Mike, I have <a id="id249" class="indexterm"/>a question though. All said and done, why does <code class="literal">PureRenderMixin</code> perform shallow comparison in the first place? Should it not perform a deep comparison so that we will always have better performance?" Shawn was not very happy with <code class="literal">PureRenderMixin</code>.</p><p>"Well, there is a reason for this. Shallow comparison is very cheap. It does not take much time. Deep comparison is always expensive. Therefore, <code class="literal">PureRenderMixin</code> does shallow comparison, which is good enough for most of the simple use cases," said Mike.</p><p>"However, React does provide us an option of defining our own version of <code class="literal">shouldComponentUpdate</code> as we saw earlier. We can completely short-circuit the re-rendering process by just returning <code class="literal">false</code> from <code class="literal">shouldComponentUpdate</code> or we can compare only those props that are required by our component."</p><p>"True, just like we had written <code class="literal">shouldComponentUpdate</code> for the <code class="literal">BookRow</code> component right?" asked Shawn.</p><div class="informalexample"><pre class="programlisting">// src/BookRow.js

export default React.createClass({
  shouldComponentUpdate(nextProps, nextState) {
    return nextProps.title !== this.props.title ||
           nextProps.author_name !== this.props.author_name ||
           nextProps.edition_count !== this.props.edition_count;
  },

  render() {
    return(
      &lt;tr style={this.props.style}&gt;
        ..
      &lt;/tr&gt;
    );
  }
});</pre></div><p>"Exactly, Shawn. If needed, you can also perform a deep comparison as per the requirements of your component when needed."</p><div class="informalexample"><pre class="programlisting">// custom deep comparison as per requirement
shouldComponentUpdate(nextProps, nextState) {
    return nextProps.book.review === props.book.review;
}</pre></div><p>"Shawn, another option we have is using immutable data. Comparing immutable data with each other is very easy as it will always create new data or objects instead of mutating the existing ones."</p><div class="informalexample"><pre class="programlisting">// pseudo code 
book_ids = [1, 2, 3]
new_book_ids = book_ids.push(4)
book_ids === new_book_ids # false</pre></div><p>"Therefore, we<a id="id250" class="indexterm"/> just have to compare the reference of the new object with the old object, they are always same when the values are equal and they are always different when values are unequal. Therefore, if we use immutable data for our props and state, then <code class="literal">PureRenderMixin</code> will work as expected." said Mike.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note14"/>Note</h3><p>Check <a class="ulink" href="http://facebook.github.io/immutable-js/">http://facebook.github.io/immutable-js/</a> as an option for using<a id="id251" class="indexterm"/> immutable data for state and props.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec69"/>Summary</h1></div></div></div><p>In this chapter, you learned about the performance tools provided by React and how to use them. We used the PERF add-on: <code class="literal">shouldComponentUpdate</code> and <code class="literal">PureRenderMixin</code>. We also saw which areas to look for when trying to improve the performance of our apps. We also studied the pitfalls while improving the performance, especially with <code class="literal">PureRenderMixin</code>. In the end, we discussed the importance and advantages of immutable data.</p><p>In the next chapter, we will look at the data model of React in detail using React Router and Flux. You will learn how to use React with other frameworks such as Backbone.</p></div></body></html>