<html><head></head><body>
		<div id="_idContainer055">
			<h1 id="_idParaDest-111"><em class="italic"><a id="_idTextAnchor203"/>Chapter 6</em>: Use Memo to Boost Performance</h1>
			<p>In the previous chapter, we learned how the <strong class="source-inline">useEffect</strong> hook is designed and how to use it to manage a side effect in <em class="italic">React</em>. In this chapter, we will change to an optimization topic for reusing the last assignment. We will first introduce how we can run into performance degradation in a typical web application. Then, we will walk through the design and source code behind <strong class="source-inline">useMemo</strong> and describe various ways of reusing a value conditionally. We'll then apply the optimization technique to two common cases: clicking to search and debouncing the search. At the end, the chapter also includes two bonus topics in the <em class="italic">Appendix</em> section, <em class="italic">Not a Classical Memorization</em> and <em class="italic">Skipping a Child Update</em>.</p>
			<p>We will cover the following main topics in this chapter:</p>
			<ul>
				<li>Performance degradation</li>
				<li>Understanding the <strong class="source-inline">useMemo</strong> design</li>
				<li>Reusing a last assignment</li>
				<li>Test-Driving <strong class="source-inline">useMemo</strong> </li>
				<li><strong class="source-inline">useMemo</strong> examples</li>
				<li>Questions and answers</li>
				<li>Appendix<a id="_idTextAnchor204"/></li>
			</ul>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor205"/>Performance degradation</h1>
			<p>When we build a site, we normally start<a id="_idIndexMarker246"/> it with a draft or prototype version where a couple of pages are laid out with the sample data and the preliminary logic. The idea is to start small and see whether the site has any potential to grow. Though this is a very common approach, interestingly, most of the performance-related issues do not show up at this point. When the site with the real business logic grows, we start to experience performance degradation issues. Understanding how these issues are created in the first place is valuable since it helps us plan for the growth of the site.</p>
			<p>Let's build such a case<a id="_idIndexMarker247"/> from scratch. A variable defined inside the body of a function component is evaluated when it gets invoked:</p>
			<p class="source-code"><strong class="bold">const</strong> Title = ({ text }) <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> a = 1</p>
			<p class="source-code">  ...</p>
			<p class="source-code">}</p>
			<p>In the preceding code, the <strong class="source-inline">a</strong> variable is assigned with a <strong class="source-inline">1</strong> constant. Storing a number like this shouldn't cost us much when <strong class="source-inline">a</strong> is reassigned every time when the <strong class="source-inline">text</strong> prop changes. But what if we need to calculate something heavy, such as matching a text in a large array?</p>
			<p class="source-code"><strong class="bold">const</strong> Title = ({ text }) <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> found = matchTextInArray(text)</p>
			<p class="source-code">  ...</p>
			<p class="source-code">}</p>
			<p>Say the preceding <strong class="source-inline">matchTextInArray</strong> function takes an average of 200 <em class="italic">milliseconds</em> to complete, which is a bit costly. We can argue that the <strong class="source-inline">found</strong> variable only gets assigned when <strong class="source-inline">text</strong> changes, so if <strong class="source-inline">text</strong> doesn't get changed often, we don't have to worry about <strong class="source-inline">found</strong> getting assigned too often. Let's ponder over this a bit. </p>
			<p>A function component can be invoked for various reasons. In <em class="italic">React</em>, the update of a function component is mostly triggered by a state change. However, the state could be from inside the <strong class="source-inline">Title</strong> component or from the parent (or grandparent) of the <strong class="source-inline">Title</strong> component. Therefore, we can't just assume the update frequency of a component by looking at it.</p>
			<p>Just imagine if the user decides to refresh the page; it should cause all the components of this page to update. In a way, the component can only determine what gets updated but can't entirely decide when it gets updated. In other words, when it comes to the update, the component also depends on its parent's behavior.</p>
			<p>Let's take a look at the following example:</p>
			<p class="source-code"><strong class="bold">const</strong> Title = ({ text, flag }) <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> found = matchTextInArray(text)</p>
			<p class="source-code">  ...</p>
			<p class="source-code">}</p>
			<p>In the preceding code, the <strong class="source-inline">Title</strong> component gets another <strong class="source-inline">flag</strong> prop. Thus, whenever the <strong class="source-inline">flag</strong> prop flips, it renders and spends 200 milliseconds on calculating <strong class="source-inline">a</strong>. You can imagine the flag as a user voting button from a parent component.</p>
			<p>If the user keeps<a id="_idIndexMarker248"/> clicking the button, multiple 200 milliseconds can quickly stack up to become a second or two, and the performance of the app is essentially now tied directly to how quickly the user flips the flag. When this happens, to use a gaming term here, it causes a lag, or a frame drop. The user should start to feel a laggy response and lose confidence in using the site.</p>
			<p>When this happens in a game, what do we do? Well, that's the time the gamer needs to upgrade their gaming hardware. But it could also be a time for developers to exploit an opportunity for optimizatio<a id="_idTextAnchor206"/>n.</p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor207"/>Reusing a previous assignment</h2>
			<p>So, what do we do in the situation of performance degradation? Let's take a look at what we have following the current timeline. When either the <strong class="source-inline">flag</strong> or the <strong class="source-inline">text</strong> prop changes, the <strong class="source-inline">found</strong> variable<a id="_idIndexMarker249"/> gets a new assignment: </p>
			<p class="source-code">|----TFTF--------TF------&gt; flag flip</p>
			<p class="source-code">----------a---------b----&gt; text change</p>
			<p class="source-code">c----cccc-c------cc-c----&gt; new assignment</p>
			<p>So, in our case, there's something we want to acknowledge, that is, the <strong class="source-inline">matchTextInArray</strong> does not even depend on the <strong class="source-inline">flag</strong> because the function doesn't take input arguments other than <strong class="source-inline">text</strong>.</p>
			<p>Why do we want to perform a new assignment when the previous assignment could still be valid? Can't we skip assignments when the <strong class="source-inline">flag</strong> prop changes? </p>
			<p>We learned in <a href="B17963_05_Epub.xhtml#_idTextAnchor157"><em class="italic">Chapter 5</em></a>, <em class="italic">Use Effect to Handle Side Effects,</em> that an effect can be used to listen to a value change. In our case, can we listen to the <strong class="source-inline">text</strong> prop change to make an assignment<a id="_idIndexMarker250"/> while ignoring other values? Let's give it a shot:</p>
			<p class="source-code"><strong class="bold">const</strong> Title = ({ text, flag }) <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> [found, setFound] = useState("")</p>
			<p class="source-code">  useEffect(() <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    setFound(matchTextInArray(text))</p>
			<p class="source-code">  }, [text])</p>
			<p class="source-code">  ...</p>
			<p class="source-code">}</p>
			<p>In the preceding code, we use the dependency array from <strong class="source-inline">useEffect</strong> to act upon the <strong class="source-inline">text</strong> change and dispatch to update the <strong class="source-inline">found</strong> state after <strong class="source-inline">matchTextInArray</strong>. This is confirmed by the following timeline sketch:</p>
			<p class="source-code">|----TFTF--------TF------&gt; flag flip</p>
			<p class="source-code">----------a---------b----&gt; text change</p>
			<p class="source-code">-c---------c---------c---&gt; new assignment</p>
			<p>The solution works out of the box. The flag flips back and forth lots of times (six times), but we only have three new assignments due to the text change. Thus, the assignment isn't tied to the flip. This is wonderful because we manage to overcome potential performance degradation.</p>
			<p>Though the solution works, we would like to improve upon it because it uses a side effect to handle the assignment, and we can see this assignment doesn't have to be a side effect. Since a side effect gets collected later after the update, it must wait till the next update. This means the assignment behaves very differently from a direct assignment, such as <strong class="source-inline">a = 1</strong>. Last but not least, a <strong class="source-inline">found</strong> state is used to hold the assignment value, and the value does not have to be a state. It's better if we can address all these issues.</p>
			<p><em class="italic">React</em> adds a <strong class="source-inline">useMemo</strong> hook to do exactly that without other hurdles. The job of the hook is to allow us to reuse the previous assignment in an update. Let's take a look at the <strong class="source-inline">useMemo</strong> design fi<a id="_idTextAnchor208"/>rst.</p>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor209"/>Understanding the useMemo design</h1>
			<p>React provides a <strong class="source-inline">useMemo</strong> hook to support a value<a id="_idIndexMarker251"/> assignment through a function that can either return a new value or an old value from the previous update:</p>
			<p class="source-code"><strong class="bold">const</strong> Title = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> label = useMemo(() <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    <strong class="bold">return</strong> "Hello World"</p>
			<p class="source-code">  }, [])</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">useMemo</strong> function takes a <strong class="source-inline">create</strong> function as its first input argument. This function returns a new value if invoked. The second parameter is a <strong class="source-inline">deps</strong> dependency array, similar to <strong class="source-inline">deps</strong> in <strong class="source-inline">useEffect</strong>. In the preceding case, <strong class="source-inline">"Hello World"</strong> is assigned to a <strong class="source-inline">label</strong> variable only once after the mount.</p>
			<p>There's no additional data structure required for <strong class="source-inline">useMemo</strong> other than the basic hook support, as shown in <em class="italic">Figure 6.1</em>:</p>
			<div>
				<div id="_idContainer049" class="IMG---Figure">
					<img src="image/Figure_6.1_B17963.jpg" alt="Figure 6.1 – Data structure for useMemo&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1 – Data structure for useMemo</p>
			<p>The hook's state persists between updates, and it's up to each hook function to define what (or in which format) it wants to persist. For instance, a <strong class="source-inline">useState</strong> hook stores a state array, a <strong class="source-inline">useEffect</strong> hook stores an effect object, and now a <strong class="source-inline">useMemo</strong> hook stores things related to an assignment. In fact, <strong class="source-inline">useMemo</strong> takes the form of the assigned value and the dependency array as <strong class="source-inline">[value, de<a id="_idTextAnchor210"/>ps]</strong>.</p>
			<p>The source code of <strong class="source-inline">useMemo</strong> is structured with <strong class="source-inline">mountMemo</strong> and <strong class="source-inline">updateMemo</strong> in a typical hook<a id="_idIndexMarker252"/> setup, depending on whether the fiber is under mount or the update via the <strong class="source-inline">isFiberMounting</strong> flag, as explained in <a href="B17963_03_Epub.xhtml#_idTextAnchor080"><em class="italic">Chapter 3</em></a>, <em class="italic">Hooking into React</em>:</p>
			<p class="source-code"><strong class="bold">function</strong> useMemo(create, deps) {</p>
			<p class="source-code">  <strong class="bold">if</strong> (isFiberMounting) {</p>
			<p class="source-code">    <strong class="bold">return</strong> mountMemo(create, deps)</p>
			<p class="source-code">  } <strong class="bold">else</strong> {</p>
			<p class="source-code">    <strong class="bold">return</strong> updateMemo(create, deps)</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">useMemo</strong> hook accepts the <strong class="source-inline">create</strong> assignment function and the <strong class="source-inline">deps</strong> dependency array as inputs. The <strong class="source-inline">name</strong>, <strong class="source-inline">create</strong>, indicates that it creates a new value when it gets invoked.</p>
			<p>When under the mount, it first gets the hook object by creating one:</p>
			<p class="source-code">function mountMemo(create, deps) {</p>
			<p class="source-code">  const hook = mountHook()</p>
			<p class="source-code">  const value = create()</p>
			<p class="source-code">  hook.state = [value, deps]</p>
			<p class="source-code">  return value</p>
			<p class="source-code">}</p>
			<p>If <strong class="source-inline">deps</strong> is not given at all, it's converted to <strong class="source-inline">null</strong> by default, and the initial value is stored by invoking the <strong class="source-inline">create</strong> assignment function. Before returning the value, both the initial value and its dependency<a id="_idIndexMarker253"/> are stored in the <strong class="source-inline">state</strong> property under the hook using an array.</p>
			<p>When under the update, it gets the hook by cloning one:</p>
			<p class="source-code">function updateMemo(create, deps) {</p>
			<p class="source-code">  const hook = updateHook()</p>
			<p class="source-code">  const prevState = hook.state</p>
			<p class="source-code">  if (prevState !== null) {</p>
			<p class="source-code">    if (deps !== null) {</p>
			<p class="source-code">      const prevDeps = prevState[1]</p>
			<p class="source-code">      if (areDepsEqual(ndeps, prevDeps)) {</p>
			<p class="source-code">        return prevState[0]</p>
			<p class="source-code">      }</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">  const value = create()</p>
			<p class="source-code">  hook.state = [value, deps]</p>
			<p class="source-code">  return value</p>
			<p class="source-code">}</p>
			<p>Once we have the hook, it gets <strong class="source-inline">prevState</strong> from the hook's <strong class="source-inline">state</strong>, which is an array of the previous value and the previous dependency array. </p>
			<p>It checks whether the dependency has changed with <strong class="source-inline">areDepsEqual</strong>. If there's no change, it simply returns the previous value. And if there is a change, it invokes the <strong class="source-inline">create</strong> assignment function again to update into the new <strong class="source-inline">value</strong>. Before we return the value, both the value and the dependency are stored in the hook's <strong class="source-inline">state</strong>. Here is the summarized <strong class="source-inline">useMemo</strong> workflow:</p>
			<div>
				<div id="_idContainer050" class="IMG---Figure">
					<img src="image/Figure_6.2_B17963.jpg" alt="Figure 6.2 – useMemo workflow&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2 – useMemo workflow</p>
			<p>Compared to <strong class="source-inline">useState</strong> and <strong class="source-inline">useEffect</strong>, <strong class="source-inline">useMemo</strong> is quite straightforward. It doesn't have any dispatch<a id="_idIndexMarker254"/> or effect involved. Instead, you can think of it as a special assignment statement. When the <strong class="source-inline">deps</strong> dependency is met, it then creates a value and returns it as the current value. In all cases, the current value is returned. So, to be<a id="_idIndexMarker255"/> precise, <em class="italic">an assignment is made in all cases; when the condition isn't met, an old value is reused</em>.</p>
			<p>Now that we know how <strong class="source-inline">useMemo</strong> is designed, let's walk you through all the scenarios that this special assignment <a id="_idTextAnchor211"/>can do.</p>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor212"/>Reusing a last assignment</h1>
			<p>Reusing a value and memorizing a value<a id="_idIndexMarker256"/> sometimes refer to similar behavior. However, it's worth noting that the <strong class="source-inline">useMemo</strong> hook can only remember one value from the past, the last value.</p>
			<p>A single <em class="italic">JavaScript</em> variable, by default, serves a purpose that, unless overwritten by a new assignment, holds the previously assigned value. So, take caution when reading the word "memo" here. If you take the word "memo" as a single value instead of memorizing all values, it could help you visualize it the right way as <em class="italic">React</em> designed it. If you are interested in classical memorization, check out the <em class="italic">Appendix A – Not a classical memorization</em> section at the end of this chapter.</p>
			<p>How <strong class="source-inline">useMemo</strong> reuses the previous assignment is controlled by a <strong class="source-inline">deps</strong> dependency array, and it uses the <strong class="source-inline">areDepsEqual</strong> utility function to compare two dependency arrays between the previous and current update. We have already examined this function in <a href="B17963_05_Epub.xhtml#_idTextAnchor157"><em class="italic">Chapter 5</em></a>, <em class="italic">Use Effect to Handle Side Effects</em>. We will skip the source code here and jump straight to the scenarios that correspond to each dependency array configuration. </p>
			<p>Similarly, we get three cases here, no dependency, empty dependency, and some dependencies:</p>
			<ul>
				<li><strong class="bold">No dependency</strong>:<p>If the dependency<a id="_idIndexMarker257"/> array is omitted entirely, it creates a new value in every update:</p><p class="source-code">  <strong class="bold">const</strong> v = useMemo(() <strong class="bold">=&gt;</strong> {...})</p><p>This is rarely used in production because it's almost reverted to the direct assignment, as in the following:</p><p class="source-code">  <strong class="bold">const</strong> v = ...</p><p>The usage of <strong class="source-inline">useMemo</strong> without a dependency provided is not common, but it's easy to see how a <strong class="source-inline">useMemo</strong> hook statement and a direct assignment can replace each other very quickly, as they<a id="_idIndexMarker258"/> share the assignment statement in <strong class="source-inline">...</strong>.</p></li>
				<li><strong class="bold">Empty dependency</strong>:<p>If a <strong class="source-inline">deps</strong> array is provided<a id="_idIndexMarker259"/> but with no element inside, it means the value doesn't depend on anything. Therefore, the value is created only once after the mount:</p><p class="source-code">  const v = useMemo(() =&gt; {...}, [])</p><p>If you want to hold a static value for all updates, this is a good use of it. You might wonder why we can't take a static value declaration outside of the component. It's because the assignment can still use the variables inside the component. </p></li>
				<li><strong class="bold">Some dependencies</strong>:<p>This is the most popular usage of <strong class="source-inline">useMemo</strong>. When the elements of <strong class="source-inline">deps</strong> are not empty, it compares<a id="_idIndexMarker260"/> each element between the previous and next dependencies to determine the change:</p><p class="source-code">  const v = useMemo(() =&gt; {...}, [a, b])</p><p>If any of the elements change, the value gets ass<a id="_idTextAnchor213"/>igned again.</p></li>
			</ul>
			<p>There's one thing to make a note of – in all of the cases mentioned, the assignment is performed for all updates. Though sometimes the assignment seems to be skipped, what we really mean here is that the assignment is reused from the last time when the conditions met.</p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor214"/>Assignment value type</h2>
			<p>The type of value that returns<a id="_idIndexMarker261"/> from the assignment can be in any format – a string, a number, an object, or even a function. That makes <strong class="source-inline">useMemo</strong> a bit flexible to meet all cases that require reusing values: </p>
			<p class="source-code">  <strong class="bold">const</strong> a = useMemo(() <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    <strong class="bold">return</strong> b + 3</p>
			<p class="source-code">  }, [b])</p>
			<p>The preceding usage of <strong class="source-inline">useMemo</strong> adds a <strong class="source-inline">3</strong> number to <strong class="source-inline">b</strong> and assigns the result to <strong class="source-inline">a</strong> when <strong class="source-inline">b</strong> changes. Similarly, we can construct a usage for using an object:</p>
			<p class="source-code">  <strong class="bold">const</strong> obj = useMemo(() <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    <strong class="bold">return</strong> { name }</p>
			<p class="source-code">  }, [name])</p>
			<p>In the preceding usage, an object with a <strong class="source-inline">name</strong> property is assigned to <strong class="source-inline">obj</strong> when <strong class="source-inline">name</strong> changes. We can even construct a usage for a function:</p>
			<p class="source-code">  <strong class="bold">const</strong> fn = useMemo(() <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    <strong class="bold">return</strong> () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">      return 1</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }, [])</p>
			<p>In the preceding code, we constructed an assignment to create a function instance after being mounted. To make things a bit easier to understand, we can take <strong class="source-inline">useMemo</strong> out to see what the raw assignment is:</p>
			<p class="source-code">  <strong class="bold">const</strong> fn = () <strong class="bold">=&gt;</strong> { return 1 }</p>
			<p>There's some subtlety when it comes to the usage of <strong class="source-inline">useMemo</strong> applying to a non-primitive value, such as an object, an array, or a function. When creating any of these values, you get a new value pointing to a new memory space. This means that when the dependency conditions are not met, old memory space is used instead.  </p>
			<p>All in all, the <strong class="source-inline">useMemo</strong> hook can be used as a special assignment to return any t<a id="_idTextAnchor215"/>ype of value.</p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor216"/>The myth of skipping an update</h2>
			<p>We may all be thinking from<a id="_idIndexMarker262"/> the use of the word "memo" that, maybe, <strong class="source-inline">useMemo</strong> can help us skip an update:</p>
			<p class="source-code">const Title = () =&gt; {</p>
			<p class="source-code">  const a = useMemo(() =&gt; { ... }, [])</p>
			<p class="source-code">  return &lt;Child a={a} /&gt;</p>
			<p class="source-code">}</p>
			<p>In the preceding code, since the <strong class="source-inline">a</strong> variable doesn't get a new value after the mount, maybe the <strong class="source-inline">Child</strong> component doesn't get any new updates either. Unfortunately, this is not the case.</p>
			<p>The answer to this question harks back to what makes an update in <em class="italic">React</em>. We mentioned at the beginning of this chapter that a state change from the <strong class="source-inline">Title</strong> component or its parent can make a new update, but the <strong class="source-inline">a</strong> variable is not a state and no one makes a dispatch for updating this value either.</p>
			<p>In a way, the <strong class="source-inline">useMemo</strong> hook has no direct relationship with an update. It doesn't carry any functionalities in terms of hooking into the update as either <strong class="source-inline">useState</strong> or <strong class="source-inline">useEffect</strong> does. In fact, <strong class="source-inline">useMemo</strong> doesn't do anything more than an assignment, except the assignment is conditional. </p>
			<p>Skipping an update based on the prop change can be done with a <strong class="source-inline">memo</strong> function provided by <strong class="source-inline">React</strong>. And <strong class="source-inline">memo</strong> and <strong class="source-inline">useMemo</strong> are two different things; we do not discuss <strong class="source-inline">memo</strong> in this book. If you really want to skip an update with the <strong class="source-inline">useMemo</strong> hook, we provide a special usage in the <em class="italic">Appendix B – Skipping a child update</em> section at the end of this chapter.</p>
			<p>Now that we know what <strong class="source-inline">useMemo</strong> is and what it can and cannot do, let's give it<a id="_idTextAnchor217"/> a test drive.</p>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor218"/>Test-Driving useMemo</h1>
			<p>Let's improve the example<a id="_idIndexMarker263"/> that we saw at the beginning of the chapter with the <strong class="source-inline">useMemo</strong> hook to gain some performance:</p>
			<p class="source-code"><strong class="bold">const</strong> Title = ({ text, flag }) <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> found = useMemo(() <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    console.log('created')         ➀</p>
			<p class="source-code">    <strong class="bold">return</strong> matchTextInArray(text))</p>
			<p class="source-code">  }, [text])  </p>
			<p class="source-code">  console.log('updated', found)    ➁</p>
			<p class="source-code">  ...</p>
			<p class="source-code">}</p>
			<p>The preceding code replaces <strong class="source-inline">useState</strong> and <strong class="source-inline">useEffect</strong> with <strong class="source-inline">useMemo</strong>. Let's take a look at the timeline to see what difference it makes:</p>
			<p class="source-code">|----TFTF--------TF------&gt; flag</p>
			<p class="source-code">----------a---------b----&gt; text</p>
			<p class="source-code">R----RRRR-R---------R----&gt; updated ➁</p>
			<p class="source-code">c---------c---------c----&gt; created ➀</p>
			<p>A new value is created in the <strong class="source-inline">"created"</strong> series when the <strong class="source-inline">text</strong> changes, independent of the <strong class="source-inline">flag</strong> flips. Even better this time, there's no delay between assigning the <strong class="source-inline">found</strong> value and receiving the <strong class="source-inline">text</strong> change because it's a direct assignment under the same update now.</p>
			<p>It's important to note that with or without <strong class="source-inline">useMemo</strong>, there's no big code structure change introduced to address the performance issue. In fact, to switch back to the non-optimized version, we can either omit the dependency or simply remove the <strong class="source-inline">useMemo</strong> usage with only one or two lines.</p>
			<p>Okay, we have now seen how the <strong class="source-inline">useMemo</strong> hook is used. Next, let's take a look at two examples of how we can apply it to some real perf<a id="_idTextAnchor219"/>ormance issues.</p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor220"/>useMemo examples</h1>
			<p>The <strong class="source-inline">useMemo</strong> hook tends <a id="_idIndexMarker264"/>to be a hook that we use when we want to optimize the site for either resolving site performance and/or improving user experience. Thus, it normally tends to be used to address problems. In the following sections, we will go through two examples relating to a search to demonstrate the application of <strong class="source-inline">useMemo</strong> as an op<a id="_idTextAnchor221"/>timization tool.</p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor222"/>Clicking to search</h2>
			<p>Say you have a list<a id="_idIndexMarker265"/> of fruits and you'd like to search it to find the matched fruit using an input box and a button. For example, typing <strong class="source-inline">"bl"</strong> should return us blackberries and blueberries from a list of fruits.</p>
			<div>
				<div id="_idContainer051" class="IMG---Figure">
					<img src="image/Figure_6.3_B17963.jpg" alt="Figure 6.3 – Clicking on the search UI&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.3 – Clicking on the search UI</p>
			<p>Here's a list of fruits defined in a <strong class="source-inline">fruits</strong> global variable:</p>
			<p class="source-code"><strong class="bold">const</strong> fruits = ["Apple", "Banana", "Blackberries", ...]</p>
			<p>We use a <strong class="source-inline">text</strong> state to store the string that the user types in at the moment. When the user clicks the <strong class="bold">Search</strong> button, the current <strong class="source-inline">text</strong> is sent to a <strong class="source-inline">query</strong> state as the current search query string:</p>
			<p class="source-code"><strong class="bold">const</strong> Title = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> [text, setText] = useState('')</p>
			<p class="source-code">  <strong class="bold">const</strong> [query, setQuery] = useState('')</p>
			<p class="source-code">  <strong class="bold">const</strong> matched = fruits.filter(v <strong class="bold">=&gt;</strong> v.includes(query))  </p>
			<p class="source-code">  <strong class="bold">const</strong> onType = e <strong class="bold">=&gt;</strong> { setText(e.target.value) }</p>
			<p class="source-code">  <strong class="bold">const</strong> onSearch = () <strong class="bold">=&gt;</strong> { setQuery(text) } </p>
			<p class="source-code">  console.log('updated', text)      ➁</p>
			<p class="source-code">  <strong class="bold">return</strong> (</p>
			<p class="source-code">    <strong class="bold">&lt;&gt;</strong></p>
			<p class="source-code">      <strong class="bold">&lt;input</strong> value={text} onChange={onType} <strong class="bold">/&gt;</strong></p>
			<p class="source-code">      <strong class="bold">&lt;button</strong> onClick={onSearch}<strong class="bold">&gt;</strong>Search<strong class="bold">&lt;/button&gt;</strong></p>
			<p class="source-code">      {{matched.join(',')}</p>
			<p class="source-code">    <strong class="bold">&lt;/&gt;</strong></p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">fruits</strong> list is filtered against the <strong class="source-inline">query</strong> string to find our <strong class="source-inline">matched</strong> fruits. The preceding code works out of the box. But, after we send this piece to production, we get<a id="_idIndexMarker266"/> some feedback that the <em class="italic">UI</em> chokes a bit and can become quite laggy when a user types on the keyboard quickly or corrects their typos frequently. </p>
			<p>As we dug into the issue, we found out that the problem is caused by the following line of code:</p>
			<p class="source-code">  <strong class="bold">const</strong> matched = titles.filter(v <strong class="bold">=&gt;</strong> v.includes(query))</p>
			<p>We can take a look at the timelines to help us visualize the problem: </p>
			<p class="source-code">|----kkkk--------kk------&gt; user type</p>
			<p class="source-code">----------x---------x----&gt; search click</p>
			<p class="source-code">R-----RRRR-R------RR-R---&gt; updated  ➁</p>
			<p class="source-code">m-----mmmm-m------mm-m---&gt; created  ➁</p>
			<p>Every keystroke the user types translates into an update where the <strong class="source-inline">matched</strong> value is created. This is the exact same problem we talked about in our introduction, except that <strong class="source-inline">text</strong> and <strong class="source-inline">query</strong> are both states instead of props. The nature of the problem is the same though.</p>
			<p>So, the solution here<a id="_idIndexMarker267"/> is to see whether we can limit the <strong class="source-inline">matched</strong> values to be created only upon the <strong class="source-inline">query</strong> change. This way, when the user types, we do not need to constantly make new <strong class="source-inline">matched</strong> values. Let's try this idea with <strong class="source-inline">useMemo</strong>:</p>
			<p class="source-code">  <strong class="bold">const</strong> matched = useMemo(() <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    console.log('created', query)   ➀</p>
			<p class="source-code">    <strong class="bold">return</strong> titles.filter(v <strong class="bold">=&gt;</strong> v.includes(query))</p>
			<p class="source-code">  }, [query])</p>
			<p>Note that we added <strong class="source-inline">query</strong> to the <strong class="source-inline">deps</strong> change dependency array. If other things changed – for example, the user type – it shouldn't touch the <strong class="source-inline">matched</strong> values. Let's confirm it with the following timeline:</p>
			<p class="source-code">|----kkkk--------kk------&gt; user type</p>
			<p class="source-code">----------x---------x----&gt; search click</p>
			<p class="source-code">R-----RRRR-R------RR-R---&gt; updated  ➁</p>
			<p class="source-code">m----------m---------m---&gt; created  ➀</p>
			<p>Now, we get a lower amount of new <strong class="source-inline">matched</strong> values, and the performance isn't tied to how the user types the keystroke anymore. This is great as we can all type quickly these days.</p>
			<p class="callout-heading">Playground – Click to Search</p>
			<p class="callout">Feel free to play with this online example at <a href="https://codepen.io/windmaomao/pen/OJjmjBv">https://codepen.io/windmaomao/pen/OJjmjBv</a>.</p>
			<p>Click and search is one of the classic examples of user experience, and it serves as a solid pattern when it comes to performing a search on the web. While this approach is still being used, these days, users expect more from a responsive website, so there exists a more popular approach of improving the user experience w<a id="_idTextAnchor223"/>ith this problem. </p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor224"/>Debouncing the search</h2>
			<p>We all have used <em class="italic">Google</em> to search<a id="_idIndexMarker268"/> for something at some point. When we type in the search bar, a dropdown slides down to provide the closest matches following the user input. It's a very smooth user experience, as <em class="italic">Google</em> has trained all of us to get used to it for decades, as shown in <em class="italic">Figure 6.4</em>: </p>
			<div>
				<div id="_idContainer052" class="IMG---Figure">
					<img src="image/Figure_6.4_B17963.jpg" alt="Figure 6.4 – Debouncing the search UI&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.4 – Debouncing the search UI</p>
			<p>There's no search button the user can click anymore; all the user needs to do is to keep typing. And when the user stops typing, the matched list is revealed. So, how do we implement this? Let's first remove the <strong class="bold">Search</strong> button:</p>
			<p class="source-code"><strong class="bold">const</strong> Title = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> [text, setText] = useState('')</p>
			<p class="source-code">  <strong class="bold">const</strong> [query, setQuery] = useState('')</p>
			<p class="source-code">  <strong class="bold">const</strong> matched = useMemo(() <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    console.log('created', query)    ➀</p>
			<p class="source-code">    <strong class="bold">return</strong> fruits.filter(v <strong class="bold">=&gt;</strong> v.includes(query))</p>
			<p class="source-code">  }, [query])</p>
			<p class="source-code">  <strong class="bold">const</strong> onType = e <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    <strong class="bold">const</strong> v = e.target.value</p>
			<p class="source-code">    setText(v)</p>
			<p class="source-code">    setQuery(v)</p>
			<p class="source-code">  }</p>
			<p class="source-code">  console.log('updated', text)       ➁</p>
			<p class="source-code">  <strong class="bold">return</strong> (</p>
			<p class="source-code">    <strong class="bold">&lt;&gt;</strong></p>
			<p class="source-code">      <strong class="bold">&lt;input</strong> value={text} onChange={onType} <strong class="bold">/&gt;</strong></p>
			<p class="source-code">      {matched.join(',')}</p>
			<p class="source-code">    <strong class="bold">&lt;/&gt;</strong></p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p>Although we don't have the button to click, the nature of this click-to-search doesn't change. Somehow, we still need a moment of this "click" when the user is about to finish typing and expect<a id="_idIndexMarker269"/> a search to happen. So, the idea here is to find the right "click" moment. </p>
			<p>How exactly can we know such timing, when something is about to happen but has not happened yet? Actually, there's a perfect analogy for this problem. Ever wondered how an elevator waits for all people to get inside before it closes its door? How does the door know when is the right time to close it? How does it anticipate whether no one else is going to get squeezed in at the next second?</p>
			<p>Given an <strong class="source-inline">fn</strong> function, if a request to invoke it arrives, it doesn't do it right away. Instead, it waits for a certain<a id="_idIndexMarker270"/> amount of time. During that period, if no request comes in to invoke it anymore, it then invokes at the end of the period. This behavior is called <strong class="bold">Debouncing</strong>.</p>
			<p>Debouncing was introduced for mechanical<a id="_idIndexMarker271"/> switches and relays – coincidence? To resolve hitting the key too frequently, the processor in a keyboard defers the hitting by "combining" them across time into a single hit. Quite a few libraries implement the <strong class="source-inline">debounce</strong> function; instead of reinventing the wheel, this book<a id="_idIndexMarker272"/> borrows one from a library called <em class="italic">Lodash</em>:</p>
			<p class="source-code"><strong class="bold">const</strong> debouncedFn = debounce(fn, dt)</p>
			<p>The <strong class="source-inline">debounce</strong> function takes the original <strong class="source-inline">fn</strong> function and a <strong class="source-inline">dt</strong> duration to wait before invoking <strong class="source-inline">fn</strong>; it returns a new <strong class="source-inline">debouncedFn</strong> function with the debouncing behavior. Instead of invoking <strong class="source-inline">fn</strong>, we invoke <strong class="source-inline">debouncedFn</strong> now. </p>
			<p>Let's apply it to find the right moment of "click":</p>
			<p class="source-code">  <strong class="bold">const</strong> setDebouncedQuery = debounce(</p>
			<p class="source-code">    t <strong class="bold">=&gt;</strong> { setQuery(t) }, 300</p>
			<p class="source-code">  )</p>
			<p class="source-code">  <strong class="bold">const</strong> onType = e <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    <strong class="bold">const</strong> v = e.target.value</p>
			<p class="source-code">    setText(v)</p>
			<p class="source-code">    setDebouncedQuery(v)</p>
			<p class="source-code">  }</p>
			<p>In the preceding change, upon each user typing, a debounced <strong class="source-inline">setDebouncedQuery</strong> version gets invoked. But not all typing updates the query via <strong class="source-inline">setQuery</strong>; instead, it waits 300 <em class="italic">milliseconds</em> to make sure the user happens to stop the typing, and that moment is our moment of "click." Multiple user keystrokes are combined into a single <strong class="source-inline">setQuery</strong>. As we have set up, after each <strong class="source-inline">query</strong> change, the <strong class="source-inline">useMemo</strong> hook creates a new search.</p>
			<p>There's only one small issue left to get everything working; the <strong class="source-inline">setDebouncedQuery</strong> function is created as a new instance upon each user keystroke, which is not what we wanted. Instead, we want to have one instance of <strong class="source-inline">setDebouncedQuery</strong> so that all the keystrokes<a id="_idIndexMarker273"/> can be debounced to the same <strong class="source-inline">setQuery</strong> function. How do we reuse the last function instance? Yes – with the <strong class="source-inline">useMemo</strong> hook we just learned about:</p>
			<p class="source-code">  <strong class="bold">const</strong> setDebouncedQuery = useMemo(() <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    <strong class="bold">return</strong> debounce(t <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">      console.log('clicked')         ➂ </p>
			<p class="source-code">      setQuery(t)) </p>
			<p class="source-code">    }, 300)</p>
			<p class="source-code">  }, [setQuery])</p>
			<p>In the preceding code, we improved <strong class="source-inline">setDebouncedQuery</strong> with the usage of the <strong class="source-inline">useMemo</strong> hook, and inside we inserted <strong class="source-inline">debounce</strong> for <strong class="source-inline">setQuery</strong>. Now, let's confirm with the following timeline:</p>
			<p class="source-code">|----kkkk--------kk------&gt; user type</p>
			<p class="source-code">---------x---------x-----&gt; "clicked" ➂ </p>
			<p class="source-code">R-----RRRRR-------RRR----&gt; updated   ➁</p>
			<p class="source-code">m---------m---------m----&gt; created   ➀</p>
			<p>Awesome! For two groups of user sessions, it performs two searches. Comparing this timeline with the previous timeline as in the classical clicking to search, you can see they are quite similar. The physical button click is replaced with an imaginary "click," and we get a nicer user experience. </p>
			<p class="callout-heading">Playground – Debouncing the Search</p>
			<p class="callout">Feel free to play with this online example at <a href="https://codepen.io/windmaomao/pen/xxLdPga">https://codepen.io/windmaomao/pen/xxLdPga</a>.</p>
			<p>With these two examples, we should now know how <strong class="source-inline">useMemo</strong> can <a id="_idTextAnchor225"/>be applied effectively.</p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor226"/>Summary</h1>
			<p>In this chapter, we first learned about a new hook, <strong class="source-inline">useMemo</strong>. We first briefly went over what can cause performance degradation in general, and then we learned about the <strong class="source-inline">useMemo</strong> design and read line by line how an optimization scheme is constructed to reuse the last value without creating a new one every time. Then, we went through all scenarios of reusing a value based on a dependency array. We took <strong class="source-inline">useMemo</strong> for a spin, and at the end, we saw how it's applied to two classic examples, clicking to search and debouncing the search. </p>
			<p>In the next chapter, we will get into another hook in the <em class="italic">React</em> family where a state change can be dispatched to multiple locati<a id="_idTextAnchor227"/>ons for an are update.</p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor228"/>Questions</h1>
			<p>Here are some questions and answers to <a id="_idTextAnchor229"/>refresh your knowledge:</p>
			<ol>
				<li>What is <strong class="source-inline">useMemo</strong>?<p>A <strong class="source-inline">useMemo</strong> hook is an assignment statement where a new value is created when one of the dependencies changes. It can be used to minimize the creation of a value, so it behaves like that sometimes when an a<a id="_idTextAnchor230"/>ssignment is "skipped."</p></li>
				<li>What's the common usage of <strong class="source-inline">useMemo</strong>?<p>It's mainly used as an optimization to avoid heavy operation on every render otherwise. If a certain evaluation is excessively used, thus blocking the <em class="italic">UI</em>, it is the right time to think about using <strong class="source-inline">useMemo</strong> to limit the usage to only relevant conditions. For instance, if typing isn't related to that task, we can take it out <a id="_idTextAnchor231"/>of the dependency list.</p></li>
				<li>How do you use <strong class="source-inline">useMemo</strong> for memorization?<p><strong class="source-inline">useMemo</strong> doesn't remember all past values and only remembers the last created value. So, the best usage of it is to use it as a special assignment replacement, instead <a id="_idTextAnchor232"/>of a caching mechanism.</p></li>
			</ol>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor233"/>Appendix</h1>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor234"/>Appendix A – Not a Classical Memorization</h2>
			<p>It's very easy to confuse <strong class="source-inline">useMemo</strong> with a <strong class="bold">Memorization</strong> used in computer science, as the name indicates. </p>
			<p>Memorization is an optimization technique<a id="_idIndexMarker274"/> in computer programs, primarily designed to speed up the process by storing the results of expensive operations and returning the cached result if it has been computed under the same condition before. The last part, "under the same condition before," is the part that makes it special.</p>
			<p>The <em class="italic">Fibonacci</em> sequence is a classical memorization problem. If it's written using a recursive algorithm, it can be very costly; therefore, we tend to use cache storage to store all past calculated values: </p>
			<p class="source-code"><strong class="bold">const</strong> fibs = { 0: 1, 1: 1 }</p>
			<p class="source-code"><strong class="bold">function</strong> fib(n)  {</p>
			<p class="source-code">  <strong class="bold">if</strong> (!fibs[n]) {</p>
			<p class="source-code">    fibs[n] = fibs[n - 1] + fibs[n - 2]</p>
			<p class="source-code">  }</p>
			<p class="source-code">  <strong class="bold">return</strong> fibs[n]</p>
			<p class="source-code">}</p>
			<p>The preceding code gives a specialized <strong class="source-inline">fib</strong> function; if you call it sequentially from <strong class="source-inline">1</strong>, <strong class="source-inline">2</strong>, and so on, it can give you the next number without too much effort. </p>
			<p>Say in the <em class="italic">React</em> app, we start with <strong class="source-inline">n=0</strong>; unless <strong class="source-inline">n</strong> moves to the next number, we don't want to calculate a new value. We could add <strong class="source-inline">useMemo</strong>:</p>
			<p class="source-code"><strong class="bold">const</strong> Title = ({ n, text }) <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> f = useMemo(() <strong class="bold">=&gt;</strong> fib(n), [n])  </p>
			<p class="source-code">  <strong class="bold">return &lt;div&gt;</strong>{text} – {f}<strong class="bold">&lt;/div&gt;</strong></p>
			<p class="source-code">}</p>
			<p>The first thing we quickly find out is that it actually reuses the <strong class="source-inline">fib</strong> function, which means their functionalities don't overlap at all. In another way, <strong class="source-inline">useMemo</strong> doesn't do what <strong class="source-inline">fib</strong> does. Amazing!</p>
			<p>Another discovery is that what the <strong class="source-inline">Title</strong> component does is to ensure that when another <strong class="source-inline">text</strong> prop changes, it doesn't calculate <strong class="source-inline">f</strong> again. But if we change <strong class="source-inline">n</strong> from <strong class="source-inline">3</strong> to <strong class="source-inline">2</strong>, it still creates a new number. This means the code can be reduced to the following:</p>
			<p class="source-code"><strong class="bold">const</strong> Title = ({ n, text }) <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> f = fib(n)  </p>
			<p class="source-code">  <strong class="bold">return &lt;div&gt;</strong>{text} - {f}<strong class="bold">&lt;/div&gt;</strong></p>
			<p class="source-code">}</p>
			<p>Haha, this is a bit funny now. We literally removed <strong class="source-inline">useMemo</strong>. Why? Because the saved calculation is already implemented by <strong class="source-inline">fib</strong>, the classical memorization. Moreover, the <strong class="source-inline">useMemo</strong> hook doesn't provide any of that kind of storage.</p>
			<p><strong class="source-inline">useMemo</strong> has one memoized storage built for <em class="italic">a last value</em>. If you can take advantage of this, that's great. Otherwise, you just over-complicate things.</p>
			<p>Don't expect <strong class="source-inline">useMemo</strong> to give you more values, since it doesn't even have a key/value map for multiple values. <em class="italic">React</em> itself is a big state machine; given a change, it moves to a new state. All it cares about is the current and next scene it's going into. Moving from <strong class="source-inline">t-1</strong> to <strong class="source-inline">t</strong> is what <em class="italic">React</em> is good at, but not at moving from <strong class="source-inline">t</strong> to <strong class="source-inline">t-2</strong>. Therefore, <strong class="source-inline">useMemo</strong> can't fit in the memorization context, which is normally<a id="_idTextAnchor235"/> what caching is about.</p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor236"/>Appendix B – Skipping a Child Update</h2>
			<p>We will use a profiler chart provided by <em class="italic">React Developer Tools</em> to inspect the React component hierarchies inside the browser, as shown in <em class="italic">Figure 6.5</em>:</p>
			<div>
				<div id="_idContainer053" class="IMG---Figure">
					<img src="image/Figure_6.05_B17963.jpg" alt="Figure 6.5 – Profiler render with Child bailout failed&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.5 – Profiler render with Child bailout failed</p>
			<p>What a profiler chart provides is a topology overview of all the fibers visited in one update. The topology speaks for itself on how they are wired like a tree. Moreover, we can tell what happened to them based on their colors.</p>
			<p>A bar with a solid color stands for an update from this component. On the other hand, if the color is shaded gray, it means that <em class="italic">React</em> decides to skip updating the component, termed as a bailout.</p>
			<p>The chart is useful when we get to study the performance of the site because it can tell us in a given update how many fibers are replaced and how many are reused, and whether a particular fiber has been visited or not. </p>
			<p>A value created by <strong class="source-inline">useMemo</strong> can be used for any purpose. For it to impact a child component, it can be wired with a prop to send the info deeper:</p>
			<p class="source-code"><strong class="bold">const</strong> Title = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> a = useMemo(() <strong class="bold">=&gt;</strong> { ... }, [])</p>
			<p class="source-code">  <strong class="bold">return </strong>&lt;Child a={a} /&gt;</p>
			<p class="source-code">}</p>
			<p>If we get a previous <strong class="source-inline">assignment</strong> of the a variable wiring to the <strong class="source-inline">Child</strong> component via a prop, does that mean we can have a conditional update of <strong class="source-inline">Child</strong>? This is a good question. </p>
			<p>From the profiler chart corresponding to all components when the <strong class="source-inline">Title</strong> updates (see <em class="italic">Figure 6.5</em>), we quickly find out the answer is no. The preceding code can't make a skip of the <strong class="source-inline">Child</strong> update because, when the <strong class="source-inline">Title</strong> parent updates, it generates a new set of props through the reconciliation of the <strong class="source-inline">Child</strong> fiber. In other words, it triggers the update of <strong class="source-inline">Child</strong> regardless of whether an individual prop, such as <strong class="source-inline">a</strong>, has a new value. </p>
			<p>Then, how exactly can we use <strong class="source-inline">useMemo</strong> to skip a child update manually? Let's try something different. Keep in mind what <strong class="source-inline">useMemo</strong> is designed to do – to hold a value from the last update until the condition is met again: </p>
			<p class="source-code"><strong class="bold">const</strong> Title = () <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">  <strong class="bold">const</strong> child = useMemo(() <strong class="bold">=&gt;</strong> {</p>
			<p class="source-code">    <strong class="bold">return </strong>&lt;Child a="Hello World" /&gt;</p>
			<p class="source-code">  }, [])  </p>
			<p class="source-code">  <strong class="bold">return</strong> child</p>
			<p class="source-code">}</p>
			<p>In the preceding <strong class="source-inline">useMemo</strong> code, instead of returning a string, we use it to hold the <strong class="source-inline">&lt;Child /&gt;</strong> component instance. What is <strong class="source-inline">&lt;Child /&gt;</strong>? It's an element object returned from the <strong class="source-inline">Child</strong> function component. So, as long as the element stays the same, we expect the screen to be the same. Let's confirm this approach with the profiler chart, as shown in <em class="italic">Figure 6.6</em>:</p>
			<div>
				<div id="_idContainer054" class="IMG---Figure">
					<img src="image/Figure_6.06_B17963.jpg" alt="Figure 6.6 – Profiler render with Child bailout successful&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.6 – Profiler render with Child bailout successful</p>
			<p>After the mount, as the <strong class="source-inline">[]</strong> dependency array indicates, <strong class="source-inline">child</strong> holds the same <strong class="source-inline">Child</strong> update from the last time. Now, when the <strong class="source-inline">Title</strong> component gets updated, it doesn't update the <strong class="source-inline">Child</strong> component. This is because, to React, there's no dispatched change from under the <strong class="source-inline">Title</strong> component, so it bails out everything underneath it. </p>
		</div>
	</body></html>