<html><head></head><body>
		<div id="_idContainer065">
			<h1 id="_idParaDest-140"><em class="italic"><a id="_idTextAnchor163"/>Chapter 8</em>: Routing in React</h1>
			<p>Currently, we have one screen and one path that our users can visit. When users visit Graphbook, they can log in and see their news feed and chats. Another requirement for a social network is that users have their own profile pages. We will implement this feature in this chapter.</p>
			<p>We will introduce client-side routing for our React application. </p>
			<p>This chapter will cover the following topics:</p>
			<ul>
				<li>Setting up React Router</li>
				<li>Advanced routing with React Router</li>
			</ul>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor164"/>Technical requirements</h1>
			<p>The source code for this chapter is available in the following GitHub repository: </p>
			<p><a href="https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter08">https://github.com/PacktPublishing/Full-Stack-Web-Development-with-GraphQL-and-React-Second-Edition/tree/main/Chapter08</a></p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor165"/>Setting up React Router</h1>
			<p>Routing is essential to most web applications. You cannot cover all of the features of your application in just one page. It would be overloaded, and your user would find it difficult to understand. Sharing links<a id="_idIndexMarker653"/> to pictures, profiles, or posts is also very important for a social network such as Graphbook. One advantageous feature, for example, is being able to send links to specific profiles. This requires each<a id="_idIndexMarker654"/> profile to have its own <strong class="bold">Uniform Resource Locator</strong> (<strong class="bold">URL</strong>) and page. Otherwise, it will not be possible to share a direct link to a single item of your application. It is also crucial to split the<a id="_idIndexMarker655"/> content into different pages, due to <strong class="bold">search engine optimization</strong> (<strong class="bold">SEO</strong>).</p>
			<p>At the moment, we render our complete application to <strong class="bold">HyperText Markup Language</strong> (<strong class="bold">HTML</strong>) in the browser, based on the<a id="_idIndexMarker656"/> authentication status. Only the server implements a simple routing functionality. Carrying out client-side routing can save a lot of work and time for the user if the router merely swaps out the correct parts in React, instead of reloading the page completely when following a link. It is vital that the application makes use of the HTML5 history implementation so that it handles the history of the browser. Importantly, this should also work for navigation in different directions. We should be able to go forward and backward with the arrow navigation buttons in the browser, without reloading the application. No unnecessary page reloads should happen with this solution.</p>
			<p>Common frameworks that you may know about, such as Angular, Ember, and Ruby on Rails, use static routing. That is also the case for Express.js, which we covered in <a href="B17337_02_Final_ASB_ePub.xhtml#_idTextAnchor032"><em class="italic">Chapter 2</em></a><em class="italic">,</em> <em class="italic">Setting Up GraphQL with Express.js</em>, of this book. <strong class="bold">Static routing</strong> means that you configure your routing<a id="_idIndexMarker657"/> flow and the components to render upfront. Your application then processes the routing table in a separate step, renders the required components, and presents the results to the user.</p>
			<p>With the release of version 4 and also the current version 5 of React Router, which we are going to use, <strong class="bold">dynamic routing</strong> was introduced. The unique thing<a id="_idIndexMarker658"/> about it is that the routing takes place while the rendering of your application is running. It doesn't require the application to first process a configuration in order to show the correct components. This approach<a id="_idIndexMarker659"/> fits with React's workflow well. The routing happens directly in your application, not in a preprocessed configuration.</p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor166"/>Installing React Router</h2>
			<p>In the past, there were a lot<a id="_idIndexMarker660"/> of React routers, with various implementations and features. As we mentioned previously, we are going to install and configure version 5 for this book. If you search for other tutorials on this topic, make sure that you follow the instructions for this version. Otherwise, you might miss some of the changes that React Router has gone through.</p>
			<p>To install React Router, simply run <strong class="source-inline">npm</strong> again, as follows:</p>
			<p class="source-code">npm install --save react-router-dom</p>
			<p>From the package name, you might assume that this is not the main package for React. The reason for this is that React Router is a multi-package library. That comes in handy when using the same tool for multiple platforms. The core package is called <strong class="source-inline">react-router</strong>.</p>
			<p>There are two further packages. The first one is the <strong class="source-inline">react-router-dom</strong> package, which we installed<a id="_idIndexMarker661"/> in the preceding code snippet, and the second one is the <strong class="source-inline">react-router-native</strong> package. If at some point, you plan to build a React Native app, you can use the same routing instead<a id="_idIndexMarker662"/> of using the browser's <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>) for a real mobile app.</p>
			<p>The first step that we will take introduces a simple router to get our current application working, including different paths for all of the screens. The routes that we are going to add are detailed here:</p>
			<ul>
				<li>Our posts feed, chats, and the top bar, including the search box, should be accessible under the <strong class="source-inline">/app</strong> route of our application. The path is self-explanatory, but you could also use the <strong class="source-inline">/</strong> root as the main path.</li>
				<li>The login and signup forms should have a separate path, which will be accessible under the <strong class="source-inline">/</strong> root path. </li>
				<li>As we do not have any further screens, we also have to handle a situation in which none of the preceding routes match. In that case, we could display a so-called 404 page, but instead, we are going to redirect to the root path directly.</li>
			</ul>
			<p>There is one thing that we have to prepare before continuing. For development, we are using the webpack development server, as this is what we configured in <a href="B17337_01_Final_ASB_ePub.xhtml#_idTextAnchor017"><em class="italic">Chapter 1</em></a>, <em class="italic">Preparing Your Development Environment</em>. To get the routing working out of the box, we will add two parameters to the <strong class="source-inline">webpack.client.config.js</strong> file. The <strong class="source-inline">devServer</strong> field should look like this:</p>
			<p class="source-code">devServer: {</p>
			<p class="source-code">  port: 3000,</p>
			<p class="source-code">  open: true,</p>
			<p class="source-code">  historyApiFallback: true,</p>
			<p class="source-code">},</p>
			<p>The <strong class="source-inline">historyApiFallback</strong> field tells <strong class="source-inline">devServer</strong> to serve the <strong class="source-inline">index.html</strong> file, not only for the root path, <strong class="source-inline">http://localhost:3000/</strong>, but also when it would typically receive a 404 error (such as for paths like <strong class="source-inline">http://localhost:3000/app</strong>). This happens when the path does not match a file or folder that is normal when implementing routing.</p>
			<p>The <strong class="source-inline">output</strong> field at the top of the <strong class="source-inline">config</strong> file must have a <strong class="source-inline">publicPath</strong> property, as follows:</p>
			<p class="source-code">output: {</p>
			<p class="source-code">  path: path.join(__dirname, buildDirectory),</p>
			<p class="source-code">  filename: 'bundle.js',</p>
			<p class="source-code">  publicPath: '/',</p>
			<p class="source-code">},</p>
			<p>The <strong class="source-inline">publicPath</strong> property tells webpack to prefix the bundle URL to an absolute path, instead of a relative path. When this property is not included, the browser cannot download the bundle<a id="_idIndexMarker663"/> when visiting the sub-directories of our application, as we are implementing client-side routing. Let's begin with the first path and bind the central part of our application, including the news feed, to the <strong class="source-inline">/app</strong> path.</p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor167"/>Implementing your first route</h2>
			<p>Before implementing the routing, we will clean up the <strong class="source-inline">App.js</strong> file. To do<a id="_idIndexMarker664"/> this, follow these steps:</p>
			<ol>
				<li>Create a <strong class="source-inline">Main.js</strong> file next to the <strong class="source-inline">App.js</strong> file in the <strong class="source-inline">client</strong> folder. Insert the following code:<p class="source-code">import React from 'react';</p><p class="source-code">import Feed from './Feed';</p><p class="source-code">import Chats from './Chats';</p><p class="source-code">import Bar from './components/bar';</p><p class="source-code">export const Main = ({ changeLoginState }) =&gt; {</p><p class="source-code">  return (</p><p class="source-code">    &lt;&gt;</p><p class="source-code">      &lt;Bar changeLoginState={changeLoginState} /&gt;</p><p class="source-code">      &lt;Feed /&gt;</p><p class="source-code">      &lt;Chats /&gt;</p><p class="source-code">    &lt;/&gt;</p><p class="source-code">  );</p><p class="source-code">}</p><p class="source-code">export default Main;</p><p>As you might have noticed, the preceding code is pretty much the same as the logged-in condition inside the <strong class="source-inline">App.js</strong> file. The only change is that the <strong class="source-inline">changeLoginState</strong> function is taken from the properties and is not directly a method of the component itself. That is because we split this part out of the <strong class="source-inline">App.js</strong> file and<a id="_idIndexMarker665"/> put it in a separate file. This improves reusability for other components that we are going to implement.</p></li>
				<li>Now, open and replace the <strong class="source-inline">return</strong> statement of the <strong class="source-inline">App</strong> component to reflect those changes, as follows:<p class="source-code">return (</p><p class="source-code">  &lt;div className="container"&gt;</p><p class="source-code">    &lt;Helmet&gt;</p><p class="source-code">      &lt;title&gt;Graphbook - Feed&lt;/title&gt;</p><p class="source-code">      &lt;meta name="description" content="Newsfeed of</p><p class="source-code">        all your friends on Graphbook" /&gt;</p><p class="source-code">    &lt;/Helmet&gt;</p><p class="source-code">    &lt;Router loggedIn={loggedIn}</p><p class="source-code">      changeLoginState={handleLogin}/&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">)</p><p>If you compare the preceding method with the old one, you can see that we have inserted a <strong class="source-inline">Router</strong> component, instead of directly rendering either the posts feed or the login form. The original components of the <strong class="source-inline">App.js</strong> file are now in the previously created <strong class="source-inline">Main.js</strong> file. Here, we pass the <strong class="source-inline">loggedIn</strong> property and the <strong class="source-inline">changeLoginState</strong> function to the <strong class="source-inline">Router</strong> component. Remove the dependencies at the top, such as the <strong class="source-inline">Chats</strong> and <strong class="source-inline">Feed</strong> components, because we won't use them any more thanks to the new <strong class="source-inline">Main</strong> component. </p></li>
				<li>Add the following line<a id="_idIndexMarker666"/> to the dependencies of our <strong class="source-inline">App.js</strong> file:<p class="source-code">import Router from './router';</p><p>To get the routing working, we have to implement our custom <strong class="source-inline">Router</strong> component first. Generally, it is easy to get the routing running with React Router, and you are not required to separate the routing functionality into a separate file, but that makes it more readable. </p></li>
				<li>To do this, create a new <strong class="source-inline">router.js</strong> file in the <strong class="source-inline">client</strong> folder, next to the <strong class="source-inline">App.js</strong> file, with the following content:<p class="source-code">import React from 'react';</p><p class="source-code">import { BrowserRouter as Router, Route, Redirect, Switch } from 'react-router-dom';</p><p class="source-code">import LoginRegisterForm from './components/loginregister';</p><p class="source-code">import Main from './Main';</p><p class="source-code">export const routing = ({ changeLoginState, loggedIn }) =&gt; {</p><p class="source-code">  return (</p><p class="source-code">    &lt;Router&gt;</p><p class="source-code">      &lt;Switch&gt;</p><p class="source-code">        &lt;Route path="/app" component={() =&gt; &lt;Main</p><p class="source-code">          changeLoginState= {changeLoginState}/&gt;}/&gt;</p><p class="source-code">      &lt;/Switch&gt;</p><p class="source-code">    &lt;/Router&gt;</p><p class="source-code">  )</p><p class="source-code">}</p><p class="source-code">export default routing;</p></li>
			</ol>
			<p>At the top, we import all of the dependencies. They include the new <strong class="source-inline">Main</strong> component and the <strong class="source-inline">react-router</strong> package. Here is a quick explanation of all of the components that we are importing from the React Router package:</p>
			<ul>
				<li><strong class="source-inline">BrowserRouter</strong> (or <strong class="source-inline">Router</strong>, for short, as we called it here) is the component<a id="_idIndexMarker667"/> that keeps the URL in the address bar in sync with the <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>); it handles all of the routing logic.</li>
				<li>The <strong class="source-inline">Switch</strong> component forces<a id="_idIndexMarker668"/> the first matching <strong class="source-inline">Route</strong> or <strong class="source-inline">Redirect</strong> component to be rendered. We need it to stop re-rendering the UI if the user is already in the location to which a redirect is trying to navigate. I generally recommend that you use the <strong class="source-inline">Switch</strong> component, as it catches unforeseeable routing errors.</li>
				<li><strong class="source-inline">Route</strong> is the component<a id="_idIndexMarker669"/> that tries to match the given path to the URL of the browser. If this is the case, the <strong class="source-inline">component</strong> property is rendered. You can see in the preceding code snippet that we are not setting the <strong class="source-inline">Main</strong> component directly as a parameter; instead, we return it from a stateless function. That is required because the <strong class="source-inline">component</strong> property of a <strong class="source-inline">Route</strong> component only accepts functions and not a component object. This solution allows us to pass the <strong class="source-inline">changeLoginState</strong> function to the <strong class="source-inline">Main</strong> component.</li>
				<li><strong class="source-inline">Redirect</strong> navigates the browser<a id="_idIndexMarker670"/> to a given location. The component receives a property called <strong class="source-inline">to</strong>, filled by a path starting with <strong class="source-inline">/</strong>. We are going to use this component in the next section.</li>
			</ul>
			<p>The problem with the preceding code is that we are only listening for one route, which is <strong class="source-inline">/app</strong>. If you are not logged in, there will be many errors that are not covered. The best thing to do would be to redirect the user to the root path, where they can log in.</p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor168"/>Secured routes</h2>
			<p><strong class="bold">Secured routes</strong> represent a way to specify<a id="_idIndexMarker671"/> paths that are only accessible if the user is authenticated or has the correct authorization.</p>
			<p>The recommended solution to implement<a id="_idIndexMarker672"/> secure routes in React Router is to write a small, stateless function that conditionally renders either a <strong class="source-inline">Redirect</strong> component or the component specified on the route that requires an authenticated user. We extract the <strong class="source-inline">component</strong> property of the router into the <strong class="source-inline">Component</strong> variable, which is a renderable React object:</p>
			<ol>
				<li value="1">Insert the following code into the <strong class="source-inline">router.js</strong> file:<p class="source-code">const PrivateRoute = ({ component: Component, ...rest }) =&gt; (</p><p class="source-code">  &lt;Route {...rest} render={(props) =&gt; (</p><p class="source-code">    rest.loggedIn === true</p><p class="source-code">      ? &lt;Component {...props} /&gt;</p><p class="source-code">      : &lt;Redirect to={{</p><p class="source-code">          pathname: '/',</p><p class="source-code">        }} /&gt;</p><p class="source-code">  )} /&gt;</p><p class="source-code">)</p><p>We call the <strong class="source-inline">PrivateRoute</strong> stateless function. It returns a standard <strong class="source-inline">Route</strong> component, which receives all of the properties initially given to the <strong class="source-inline">PrivateRoute</strong> function. To pass all properties, we use a destructuring assignment with the <strong class="source-inline">...rest</strong> syntax. Using the syntax inside of curly braces on a React component passes all fields of the <strong class="source-inline">rest</strong> object as properties to the component. The <strong class="source-inline">Route</strong> component is only rendered if the given path is matched.</p><p>Furthermore, the rendered<a id="_idIndexMarker673"/> component is dependent on the user's <strong class="source-inline">loggedIn</strong> state<a id="_idIndexMarker674"/> variable, which we have to pass. If the user is logged in, we render the <strong class="source-inline">Component</strong> variable without any problems. Otherwise, we redirect the user to the root path of our application using the <strong class="source-inline">Redirect</strong> component.</p></li>
				<li>Use the new <strong class="source-inline">PrivateRoute</strong> component in the <strong class="source-inline">return</strong> statement of the <strong class="source-inline">Router</strong> component and replace the old <strong class="source-inline">Route</strong> component, as follows:<p class="source-code">&lt;PrivateRoute path="/app" component={() =&gt; &lt;Main changeLoginState={changeLoginState} /&gt;} loggedIn={loggedIn}/&gt;</p><p>Notice that we pass the <strong class="source-inline">loggedIn</strong> property by taking the value from the properties of the <strong class="source-inline">Router</strong> component itself. It initially receives the <strong class="source-inline">loggedIn</strong> property from the <strong class="source-inline">App</strong> component that we edited previously. The great thing is that the <strong class="source-inline">loggedIn</strong> variable can be updated from the parent <strong class="source-inline">App</strong> component at any time. That means that the <strong class="source-inline">Redirect</strong> component is rendered, and the user is automatically navigated to the login form if the user logs out, for example. We do not have to write separate logic to implement this functionality.</p><p>However, we have now created a new problem. We redirect from <strong class="source-inline">/app</strong> to <strong class="source-inline">/</strong> if the user is not logged in, but we do not have any routes set up for the initial <strong class="source-inline">'/'</strong> path. It makes sense for this path to either show the login form or to redirect the user to <strong class="source-inline">/app</strong> if the user is logged in. The pattern for the new component is the same as the preceding<a id="_idIndexMarker675"/> code for the <strong class="source-inline">PrivateRoute</strong> component<a id="_idIndexMarker676"/> but in the opposite direction. </p></li>
				<li>Add the new <strong class="source-inline">LoginRoute</strong> component to the <strong class="source-inline">router.js</strong> file, as follows:<p class="source-code">const LoginRoute = ({ component: Component, ...rest }) =&gt; (</p><p class="source-code">  &lt;Route {...rest} render={(props) =&gt; (</p><p class="source-code">    rest.loggedIn === false</p><p class="source-code">      ? &lt;Component {...props} /&gt;</p><p class="source-code">      : &lt;Redirect to={{</p><p class="source-code">          pathname: '/app',</p><p class="source-code">        }} /&gt;</p><p class="source-code">  )} /&gt;</p><p class="source-code">)</p><p>The preceding condition is inverted to render the original component. If the user is not logged in, the login form is rendered. Otherwise, they will be redirected to the posts feed.</p></li>
				<li>Add the new path to the router, as follows:<p class="source-code">&lt;LoginRoute exact path="/" component={() =&gt; &lt;LoginRegisterForm changeLoginState={changeLoginState}/&gt;} loggedIn={loggedIn}/&gt;</p><p>The code looks the same as that of the <strong class="source-inline">PrivateRoute</strong> component, except that we now have a new property, called <strong class="source-inline">exact</strong>. If we pass this property to a route, the browser's location has to match 100%. The following table shows a quick example, taken from the official React Router documentation:</p></li>
			</ol>
			<div>
				<div id="_idContainer063" class="IMG---Figure">
					<img src="image/B17337_08_Table_8.1.jpg" alt=""/>
				</div>
			</div>
			<p>For the root path, we set <strong class="source-inline">exact</strong> to <strong class="source-inline">true</strong> because otherwise, the path matches with any browser's location<a id="_idIndexMarker677"/> where <strong class="source-inline">/</strong> is included, as you can see<a id="_idIndexMarker678"/> in the preceding table.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">There are many more configuration options that React Router<a id="_idIndexMarker679"/> offers, such as enforcing trailing slashes, case sensitivity, and much more. You can find all of the options and examples in the official documentation at <a href="https://v5.reactrouter.com/web/api/">https://v5.reactrouter.com/web/api/</a>.</p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor169"/>Catch-all routes in React Router</h2>
			<p>Currently, we have two paths set up, which are <strong class="source-inline">/app</strong> and <strong class="source-inline">/</strong>. If a user visits a non-existent path, such as <strong class="source-inline">/test</strong>, they will see an empty<a id="_idIndexMarker680"/> screen. The solution is to implement<a id="_idIndexMarker681"/> a route that matches any path. For simplicity, we redirect the user to the root of our application, but you could easily replace the redirection with a typical 404 page.</p>
			<p>Add the following code to the <strong class="source-inline">router.js</strong> file:</p>
			<p class="source-code">const NotFound = () =&gt; {</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;Redirect to="/"/&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">NotFound</strong> component is minimal. It just redirects the user to the root path. Add the next <strong class="source-inline">Route</strong> component to the <strong class="source-inline">Switch</strong> component in the <strong class="source-inline">Router</strong> component. Ensure that it is the last one on the list. The code is shown here:</p>
			<p class="source-code">&lt;Route component={NotFound} /&gt;</p>
			<p>As you can see, we are rendering a simple <strong class="source-inline">Route</strong> component in the preceding code. What makes the route special is that we are not passing a <strong class="source-inline">path</strong> property with it. By default, the <strong class="source-inline">path</strong> property is completely ignored, and the component is rendered every time, except if there is a match with a previous component. That is why we added the route to the bottom of the <strong class="source-inline">Router</strong> component. When no route matches, we redirect the user to the login screen in the root path, or, if the user is already logged in, we redirect them to a different screen using the routing logic of the root path. Our <strong class="source-inline">LoginRoute</strong> component handles this last case.</p>
			<p>You can test all changes when starting<a id="_idIndexMarker682"/> the frontend with <strong class="source-inline">npm run client</strong> and the backend<a id="_idIndexMarker683"/> with <strong class="source-inline">npm run server</strong>. We have now moved the current state of our application from a standard, single-route application to an application that differentiates the login form and the news feed based on the location of the browser.</p>
			<p>In the next section, we will have a look at how we can implement more complicated routing by adding parameterized routes and loading the data depending on those parameters.</p>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor170"/>Advanced routing with React Router</h1>
			<p>The primary goal of this chapter is to build a profile page for your users. We need a separate page to show all of the content<a id="_idIndexMarker684"/> that a single user has entered or created. The content would not fit next to the posts feed. When looking at Facebook, we can see that every user has their own address, under which we can find the profile page of a specific user. We are going to create our profile page in the same way and use the username as the custom path.</p>
			<p>We have to implement the following features:</p>
			<ol>
				<li value="1">We add a new parameterized route for the user profile. The path starts with <strong class="source-inline">/user/</strong> and follows a username.</li>
				<li>We change the user profile page to send all GraphQL queries, including the <strong class="source-inline">username</strong> route parameter, inside of the <strong class="source-inline">variables</strong> field of the GraphQL request.</li>
				<li>We edit the <strong class="source-inline">postsFeed</strong> query to filter all posts by the <strong class="source-inline">username</strong> parameter provided.</li>
				<li>We implement a new GraphQL query on the backend to request a user by their username, in order to show information about the user.</li>
				<li>When all of the queries are finished, we render a new user profile header component and the posts feed.</li>
				<li>Finally, we enable<a id="_idIndexMarker685"/> navigation between each page without reloading the complete page, but only the changed parts.</li>
			</ol>
			<p>Let's start by implementing routing for the profile page in the next section.</p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor171"/>Parameters in routes</h2>
			<p>We have prepared most of the work<a id="_idIndexMarker686"/> required to add a new user route. Open up the <strong class="source-inline">router.js</strong> file<a id="_idIndexMarker687"/> again. Add the new route, as follows:</p>
			<p class="source-code">&lt;PrivateRoute path="/user/:username" component={props =&gt; &lt;User {...props} changeLoginState={changeLoginState}/&gt;} loggedIn={loggedIn}/&gt;</p>
			<p>The code contains two new elements, as follows:</p>
			<ul>
				<li>The path that we entered is <strong class="source-inline">/user/:username</strong>. As you can see, the username is prefixed with a colon, telling React Router to pass the value of it to the underlying component being rendered.</li>
				<li>The component that we rendered previously was a stateless function that returned either the <strong class="source-inline">LoginRegisterForm</strong> component or the <strong class="source-inline">Main</strong> component. Neither of these received any parameters or properties from React Router. Now, however, it is required that all properties of React Router are transferred to the child component. That includes the <strong class="source-inline">username</strong> parameter that we just introduced. We use the same destructuring assignment with the <strong class="source-inline">props</strong> object to pass all properties to the <strong class="source-inline">User</strong> component.</li>
			</ul>
			<p>Those are all of the changes that we need to accept parameterized paths in React Router. We read out the value inside of the new user page component. Before implementing it, we import the dependency at the top of <strong class="source-inline">router.js</strong> to get the preceding route working, as follows:</p>
			<p class="source-code">import User from './User';</p>
			<p>Create the preceding <strong class="source-inline">User.js</strong> file next to the <strong class="source-inline">Main.js</strong> file. As with the <strong class="source-inline">Main</strong> component, we are collecting<a id="_idIndexMarker688"/> all of the components that we render on this page. You should<a id="_idIndexMarker689"/> stay with this layout, as you can directly see which main parts each page consists of. The <strong class="source-inline">User.js</strong> file should look like this:</p>
			<p class="source-code">import React from 'react';</p>
			<p class="source-code">import UserProfile from './components/user';</p>
			<p class="source-code">import Chats from './Chats';</p>
			<p class="source-code">import Bar from './components/bar';</p>
			<p class="source-code">export const User = ({ changeLoginState, match }) =&gt; {</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;&gt;</p>
			<p class="source-code">      &lt;Bar changeLoginState={changeLoginState} /&gt;</p>
			<p class="source-code">      &lt;UserProfile username={match.params.username}/&gt;</p>
			<p class="source-code">      &lt;Chats /&gt;</p>
			<p class="source-code">    &lt;/&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p class="source-code">export default User</p>
			<p>We have all common components including the <strong class="source-inline">Bar</strong> and <strong class="source-inline">Chat</strong> component. If a user visits the profile of a friend, they see the common application bar at the top. They can access their chats on the right-hand side, like on Facebook. It is one of the many situations in which React and the reusability of components come in handy.</p>
			<p>We removed the <strong class="source-inline">Feed</strong> component and replaced it with a new <strong class="source-inline">UserProfile</strong> component. Importantly, the <strong class="source-inline">UserProfile</strong> component receives the <strong class="source-inline">username</strong> property. Its value is taken<a id="_idIndexMarker690"/> from the properties of the <strong class="source-inline">User</strong> component. These properties were passed over by React Router. If you have a parameter, such as <strong class="source-inline">username</strong>, in the routing path, the value is stored in the <strong class="source-inline">match.params.username</strong> property of the child component. The <strong class="source-inline">match</strong> object generally contains all matching information of React Router.</p>
			<p>From this point on, you can implement any custom logic that you want with this value. We will now continue with implementing the profile page.</p>
			<p>One thing before building the user profile page is to extract the feed rendering logic to a separate component to reuse it. Create a <strong class="source-inline">feedlist.js</strong> file inside the <strong class="source-inline">post</strong> folder.</p>
			<p>Insert the following code in the <strong class="source-inline">feedlist.js</strong> file:</p>
			<ol>
				<li value="1">Import the following dependencies at the top, as follows:<p class="source-code">import React, { useState } from 'react';</p><p class="source-code">import InfiniteScroll from 'react-infinite-scroll-component';</p><p class="source-code">import Post from './';</p></li>
				<li>Then, just copy the main parts of the feed list <strong class="source-inline">return</strong> statement, as follows:<p class="source-code">export const FeedList = ({fetchMore, posts}) =&gt; {</p><p class="source-code">  const [hasMore, setHasMore] = useState(true);</p><p class="source-code">  const [page, setPage] = useState(0);</p><p class="source-code">  return (</p><p class="source-code">    &lt;div className="feed"&gt;</p><p class="source-code">      &lt;InfiniteScroll</p><p class="source-code">        dataLength={posts.length}</p><p class="source-code">        next={() =&gt; loadMore(fetchMore)}</p><p class="source-code">        hasMore={hasMore}</p><p class="source-code">        loader={&lt;div className="loader"</p><p class="source-code">          key={"loader"}&gt;Loading ...&lt;/div&gt;}</p><p class="source-code">      &gt;</p><p class="source-code">      {posts.map((post, i) =&gt;</p><p class="source-code">          &lt;Post key={post.id} post={post} /&gt;</p><p class="source-code">      )}</p><p class="source-code">      &lt;/InfiniteScroll&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">  );</p><p class="source-code">}</p><p class="source-code">export default FeedList;</p></li>
				<li>One thing that is missing now is the <strong class="source-inline">loadMore</strong> function, which we also can just copy. Just add it straight<a id="_idIndexMarker691"/> to the preceding component, as follows:<p class="source-code">const loadMore = (fetchMore) =&gt; {</p><p class="source-code">    fetchMore({</p><p class="source-code">      variables: {</p><p class="source-code">          page: page + 1,</p><p class="source-code">      },</p><p class="source-code">      updateQuery(previousResult, { fetchMoreResult })</p><p class="source-code">        {</p><p class="source-code">        if(!fetchMoreResult.postsFeed.posts.length) {</p><p class="source-code">          setHasMore(false);</p><p class="source-code">          return previousResult;</p><p class="source-code">        }</p><p class="source-code">        setPage(page + 1);</p><p class="source-code">        const newData = {</p><p class="source-code">          postsFeed: {</p><p class="source-code">            __typename: 'PostFeed',</p><p class="source-code">            posts: [</p><p class="source-code">              ...previousResult.postsFeed.posts,</p><p class="source-code">              ...fetchMoreResult.postsFeed.posts</p><p class="source-code">            ]</p><p class="source-code">          }</p><p class="source-code">        };</p><p class="source-code">        return newData;</p><p class="source-code">      }</p><p class="source-code">    });</p><p class="source-code">  }</p></li>
				<li>Just replace the part<a id="_idIndexMarker692"/> on the <strong class="source-inline">Feed.js</strong> file's <strong class="source-inline">return</strong> statement. It should look like this:<p class="source-code">return (</p><p class="source-code">  &lt;div className="container"&gt;</p><p class="source-code">    &lt;div className="postForm"&gt;</p><p class="source-code">      &lt;form onSubmit={handleSubmit}&gt;</p><p class="source-code">        &lt;textarea value={postContent} onChange={(e) =&gt;</p><p class="source-code">          setPostContent(e.target.value)} </p><p class="source-code">            placeholder="Write your custom post!"/&gt;</p><p class="source-code">        &lt;input type="submit" value="Submit" /&gt;</p><p class="source-code">      &lt;/form&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">    &lt;FeedList posts={posts} fetchMore={loadMore}/&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">)</p></li>
			</ol>
			<p>We can use this <strong class="source-inline">FeedList</strong> component now where we need to display a feed of posts, such as on our user profile page.</p>
			<p>Follow these steps to build<a id="_idIndexMarker693"/> the user's profile page:</p>
			<ol>
				<li value="1">Create a new folder, called <strong class="source-inline">user</strong>, inside the <strong class="source-inline">components</strong> folder.</li>
				<li>Create a new file, called <strong class="source-inline">index.js</strong>, inside the <strong class="source-inline">user</strong> folder.</li>
				<li>Import the dependencies at the top of the file, as follows:<p class="source-code">import React from 'react';</p><p class="source-code">import FeedList from '../post/feedlist';</p><p class="source-code">import UserHeader from './header';</p><p class="source-code">import Loading from '../loading';</p><p class="source-code">import Error from '../error';</p><p class="source-code">import { useGetPostsQuery } from '../../apollo/queries/getPosts';</p><p class="source-code">import { useGetUserQuery } from '../../apollo/queries/getUser'; </p><p>The first three lines should look familiar. Two imported files, however, do not exist at the moment, but we are going to change that shortly. The first new file is <strong class="source-inline">UserHeader</strong>, which takes care of rendering the avatar image, the name, and information about the user. Logically, we request the data that we will display in this header through a new Apollo query Hook, called <strong class="source-inline">getUser</strong>.</p></li>
				<li>Insert the code for the <strong class="source-inline">UserProfile</strong> component that we are building at the moment beneath<a id="_idIndexMarker694"/> the dependencies, as follows:<p class="source-code">const UserProfile = ({ username }) =&gt; {</p><p class="source-code">  const { data: user, loading: userLoading } = </p><p class="source-code">    useGetUserQuery({ username });</p><p class="source-code">  const { loading, error, data: posts, fetchMore } = </p><p class="source-code">    useGetPostsQuery({ username });</p><p class="source-code">  if (loading || userLoading) return &lt;Loading /&gt;;</p><p class="source-code">  if (error) return &lt;Error&gt;&lt;p&gt;{error.message}&lt;/p&gt;</p><p class="source-code">    &lt;/Error&gt;;</p><p class="source-code">  return (</p><p class="source-code">    &lt;div className="user"&gt;</p><p class="source-code">      &lt;div className="inner"&gt;</p><p class="source-code">        &lt;UserHeader user={user.user} /&gt;</p><p class="source-code">      &lt;/div&gt;</p><p class="source-code">      &lt;div className="container"&gt;</p><p class="source-code">        &lt;FeedList posts={posts.postsFeed.posts}</p><p class="source-code">          fetchMore={fetchMore}/&gt;</p><p class="source-code">      &lt;/div&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">  )</p><p class="source-code">}</p><p class="source-code">export default UserProfile;</p><p>The <strong class="source-inline">UserProfile</strong> component is not complex. We are running two Apollo queries simultaneously. Both have the <strong class="source-inline">variables</strong> property set. The <strong class="source-inline">useGetPostsQuery</strong> Hook receives the username, which initially came from React Router. This property<a id="_idIndexMarker695"/> is also handed over to <strong class="source-inline">useGetUserQuery</strong>.</p></li>
				<li>Now edit and create Apollo queries, before programming the profile header component. Open the <strong class="source-inline">getPosts.js</strong> file from the <strong class="source-inline">queries</strong> folder.</li>
				<li>To use the username as input to the GraphQL query, we first have to change the query string from the <strong class="source-inline">GET_POSTS</strong> variable. Change the first two lines to match the following code:<p class="source-code">query postsFeed($page: Int, $limit: Int, $username: String) { </p><p class="source-code">  postsFeed(page: $page, limit: $limit, username:</p><p class="source-code">    $username) { </p></li>
				<li>Then, replace the last line with the following code to provide a way to pass variables to the <strong class="source-inline">useQuery</strong> Hook:<p class="source-code">export const useGetPostsQuery = (variables) =&gt; useQuery(GET_POSTS, { pollInterval: 5000, variables: { page: 0, limit: 10, ...variables } });</p><p>If the custom query component receives a <strong class="source-inline">username</strong> property, it is included in the GraphQL request. It is used to filter posts by the specific user that we are viewing.</p></li>
				<li>Create a new <strong class="source-inline">getUser.js</strong> file in the <strong class="source-inline">queries</strong> folder to create a query Hook, which we are missing at present.</li>
				<li>Import all of the dependencies<a id="_idIndexMarker696"/> and parse the new query schema with <strong class="source-inline">gql</strong>, as follows:<p class="source-code">import { gql, useQuery } from '@apollo/client';</p><p class="source-code">import { USER_ATTRIBUTES } from '../fragments/userAttributes';</p><p class="source-code">export const GET_USER = gql'</p><p class="source-code">  query user($username: String!) {</p><p class="source-code">    user(username: $username) {</p><p class="source-code">      ...userAttributes</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">  ${USER_ATTRIBUTES}</p><p class="source-code">';</p><p class="source-code">export const useGetUserQuery = (variables) =&gt; useQuery(GET_USER, { variables: { ...variables }});</p><p>The preceding query is nearly the same as the <strong class="source-inline">currentUser</strong> query. We are going to implement the corresponding <strong class="source-inline">user</strong> query later, in our GraphQL <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>).</p></li>
				<li>The last step is to implement the <strong class="source-inline">UserProfileHeader</strong> component. This component renders the <strong class="source-inline">user</strong> property, with all its values. It is just simple HTML markup. Copy the following<a id="_idIndexMarker697"/> code into the <strong class="source-inline">header.js</strong> file, in the <strong class="source-inline">user</strong> folder:<p class="source-code">import React from 'react';</p><p class="source-code">export const UserProfileHeader = ({user}) =&gt; {</p><p class="source-code">  const { avatar, username } = user;</p><p class="source-code">  return (</p><p class="source-code">    &lt;div className="profileHeader"&gt;</p><p class="source-code">      &lt;div className="avatar"&gt;</p><p class="source-code">        &lt;img src={avatar}/&gt;</p><p class="source-code">      &lt;/div&gt;</p><p class="source-code">      &lt;div className="information"&gt;</p><p class="source-code">        &lt;p&gt;{username}&lt;/p&gt;</p><p class="source-code">        &lt;p&gt;You can provide further information here</p><p class="source-code">           and build your really personal header </p><p class="source-code">           component for your users.&lt;/p&gt;</p><p class="source-code">      &lt;/div&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">  )</p><p class="source-code">}</p><p class="source-code">export default UserProfileHeader;</p></li>
			</ol>
			<p>If you need help getting the <strong class="bold">Cascading Style Sheets</strong> (<strong class="bold">CSS</strong>) styling right, take a look at the official<a id="_idIndexMarker698"/> repository for this book. The preceding code only renders the user's data; you could also implement features such as a chat button, which would give the user the option to start messaging with other people. Currently, we have not implemented this feature anywhere, but it is not necessary to explain the principles of React and GraphQL.</p>
			<p>We have finished the new frontend components, but the <strong class="source-inline">UserProfile</strong> component is still not working. The queries that we are using here either do not accept the <strong class="source-inline">username</strong> parameter or have not yet been implemented.</p>
			<p>The next section will cover which parts of the backend have to be adjusted.</p>
			<h2 id="_idParaDest-149"><a id="_idTextAnchor172"/>Querying the user profile</h2>
			<p>With the new profile<a id="_idIndexMarker699"/> page, we have to update our backend accordingly. Let's take a look at what needs to be done, as follows:</p>
			<ul>
				<li>We have to add the <strong class="source-inline">username</strong> parameter to the schema of the <strong class="source-inline">postsFeed</strong> query and adjust the resolver function.</li>
				<li>We have to create a schema and a resolver function for the new <strong class="source-inline">UserQuery</strong> component.</li>
			</ul>
			<p>We will begin with the <strong class="source-inline">postsFeed</strong> query:</p>
			<ol>
				<li value="1">Edit the <strong class="source-inline">postsFeed</strong> query in the <strong class="source-inline">RootQuery</strong> type of the <strong class="source-inline">schema.js</strong> file to match the following code:<p class="source-code">postsFeed(page: Int, limit: Int, username: String): PostFeed @auth</p><p>Here, I have added <strong class="source-inline">username</strong> as an optional parameter.</p></li>
				<li>Now, head over to the <strong class="source-inline">resolvers.js</strong> file and take a look at the corresponding <strong class="source-inline">resolver</strong> function. Replace the signature of the function to extract the username from the variables, as follows:<p class="source-code">postsFeed(root, { page, limit, username }, context) {</p></li>
				<li>To make use of the new parameter, add the following lines of code above the <strong class="source-inline">return</strong> statement:<p class="source-code">if(username) {</p><p class="source-code">  query.include = [{model: User}];</p><p class="source-code">  query.where = { '$User.username$': username };</p><p class="source-code">}</p></li>
			</ol>
			<p>We have already covered the basic Sequelize API and how to query associated models by using the <strong class="source-inline">include</strong> parameter in <a href="B17337_03_Final_ASB_ePub.xhtml#_idTextAnchor054"><em class="italic">Chapter 3</em></a>, <em class="italic">Connecting to the Database</em>. An important point is how we filter posts associated with a user by their username. We'll do this in the following steps: </p>
			<ol>
				<li value="1">In the preceding code, we fill the <strong class="source-inline">include</strong> field of the <strong class="source-inline">query</strong> object with the Sequelize model that we want to join. This allows us to filter the associated <strong class="source-inline">User</strong> model in the next step.</li>
				<li>Then, we create<a id="_idIndexMarker700"/> a normal <strong class="source-inline">where</strong> object in which we write the filter condition. If you want to filter the posts by an associated table of users, you can wrap the model and field names that you want to filter by with dollar signs. In our case, we wrap <strong class="source-inline">User.username</strong> with dollar signs, which tells Sequelize to query the <strong class="source-inline">User</strong> model's table and filter by the value of the <strong class="source-inline">username</strong> column.</li>
			</ol>
			<p>No adjustments are required for the pagination part. The GraphQL query is now ready. The great thing about the small changes that we have made is that we have just one API function that accepts several parameters, either to display posts on a single user profile or to display a list of posts, such as a news feed.</p>
			<p>Let's move on and implement the new <strong class="source-inline">user</strong> query:</p>
			<ol>
				<li value="1">Add the following line to the <strong class="source-inline">RootQuery</strong> type in your GraphQL schema:<p class="source-code">user(username: String!): User @auth</p><p>This query only accepts a <strong class="source-inline">username</strong> parameter, but this time it is a required parameter in the new query. Otherwise, the query would make no sense since we only use it when visiting a user's profile through their username. </p></li>
				<li>In the <strong class="source-inline">resolvers.js</strong> file, implement the resolver function using Sequelize, as follows:<p class="source-code">user(root, { username }, context) {</p><p class="source-code">  return User.findOne({</p><p class="source-code">    where: {</p><p class="source-code">      username: username</p><p class="source-code">    }</p><p class="source-code">  });</p><p class="source-code">},</p><p>In the preceding code snippet, we use the <strong class="source-inline">findOne</strong> method of the <strong class="source-inline">User</strong> model by using Sequelize and search for exactly one user with the username that we provided in the parameter.</p></li>
			</ol>
			<p>Now that the backend<a id="_idIndexMarker701"/> code and the user page are ready, we have to allow the user to navigate to this new page. The next section will cover user navigation using React Router. </p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor173"/>Programmatic navigation in React Router</h2>
			<p>We created a new site with the user profile, but now we have to offer the user a link to get there. The transition<a id="_idIndexMarker702"/> between the news feed and the login and registration forms is automated by React Router, but not the transition from the news feed to a profile page. The user decides whether they want to view the profile of the user. React Router has multiple ways to handle navigation. We are going to extend the news feed to handle clicks on the username or the avatar image, in order to navigate<a id="_idIndexMarker703"/> to the user's profile page. Open the <strong class="source-inline">header.js</strong> file in the <strong class="source-inline">post</strong> components folder. Import the <strong class="source-inline">Link</strong> component provided by React Router, as follows:</p>
			<p class="source-code">import { Link } from 'react-router-dom';</p>
			<p>The <strong class="source-inline">Link</strong> component is a tiny wrapper around a regular HTML <strong class="source-inline">a</strong> tag. Apparently, in standard web applications or websites, there is no complex logic behind hyperlinks; you click on them, and a new page is loaded from scratch. With React Router or most <strong class="bold">single-page application</strong> (<strong class="bold">SPA</strong>) <strong class="bold">JavaScript</strong> (<strong class="bold">JS</strong>) frameworks, you can add<a id="_idIndexMarker704"/> more logic behind<a id="_idIndexMarker705"/> hyperlinks. Importantly, instead of completely reloading the pages when navigating between different routes, this now gets handled by React Router. There won't be complete page reloads when navigating; instead, only the required parts are exchanged, and the GraphQL queries are run. This method saves the user expensive bandwidth because it means that we can avoid downloading all of the HTML, CSS, and image files again.</p>
			<p>To test this, wrap the username<a id="_idIndexMarker706"/> and the avatar image<a id="_idIndexMarker707"/> in the <strong class="source-inline">Link</strong> component, as follows:</p>
			<p class="source-code">&lt;Link to={'/user/'+post.user.username}&gt;</p>
			<p class="source-code">  &lt;img src={post.user.avatar} /&gt;</p>
			<p class="source-code">  &lt;div&gt;</p>
			<p class="source-code">    &lt;h2&gt;{post.user.username}&lt;/h2&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/Link&gt;</p>
			<p>In the rendered HTML, the <strong class="source-inline">img</strong> and <strong class="source-inline">div</strong> tags are surrounded by a common <strong class="source-inline">a</strong> tag but are handled inside React Router. The <strong class="source-inline">Link</strong> component receives a <strong class="source-inline">to</strong> property, which is the destination of the navigation. You have to copy one new CSS rule because the <strong class="source-inline">Link</strong> component has changed the markup. The code is illustrated in the following snippet:</p>
			<p class="source-code">.post .header a &gt; * {</p>
			<p class="source-code">  display: inline-block;</p>
			<p class="source-code">  vertical-align: middle;</p>
			<p class="source-code">}</p>
			<p>If you test the changes now, clicking on the username or avatar image, you should notice that the content of the page dynamically changes but does not entirely reload. A further task would be to copy this approach to the user search list in the application bar and the chats. Currently, the users are displayed, but there is no option to visit their profile pages by clicking on them.</p>
			<p>Now, let's take a look at another way to navigate with React Router. If the user has reached a profile page, we want them to navigate back by clicking on a button in the application bar. First of all, we will create a new <strong class="source-inline">home.js</strong> file in the <strong class="source-inline">bar</strong> folder, and we will enter the following code:</p>
			<p class="source-code">import React from 'react';</p>
			<p class="source-code">import { withRouter } from 'react-router';</p>
			<p class="source-code">const Home = ({ history }) =&gt; {</p>
			<p class="source-code">  const goHome = () =&gt; {</p>
			<p class="source-code">    history.push('/app');</p>
			<p class="source-code">  }</p>
			<p class="source-code">  return (</p>
			<p class="source-code">    &lt;button className="goHome" onClick={goHome}&gt;Home</p>
			<p class="source-code">    &lt;/button&gt;</p>
			<p class="source-code">  );</p>
			<p class="source-code">}</p>
			<p class="source-code">export default withRouter(Home);</p>
			<p>We are using multiple React Router techniques<a id="_idIndexMarker708"/> here. We export the <strong class="source-inline">Home</strong> component through a <strong class="bold">higher-order component</strong> (<strong class="bold">HOC</strong>). The <strong class="source-inline">withRouter</strong> HOC gives the <strong class="source-inline">Home</strong> component access to the <strong class="source-inline">history</strong> object of React Router. That is great because it means that we do not need to pass this object from the top of our React tree down to the <strong class="source-inline">Home</strong> component.</p>
			<p>Furthermore, we use the <strong class="source-inline">history</strong> object<a id="_idIndexMarker709"/> to navigate the user to the news feed. In the <strong class="source-inline">render</strong> method, we return<a id="_idIndexMarker710"/> a button that, when clicked, runs the <strong class="source-inline">history.push</strong> function. This function adds the new path to the history of the browser and navigates the user to the <strong class="source-inline">'/app'</strong> main page. The good thing is that it works in the same way as the <strong class="source-inline">Link</strong> component and does not reload the entire website.</p>
			<p>There are a few things to do in order to get the button working, as follows:</p>
			<ol>
				<li value="1">Import the component into the <strong class="source-inline">index.js</strong> file of the <strong class="source-inline">bar</strong> folder, as follows:<p class="source-code">import Home from './home';</p></li>
				<li>Then, replace the <strong class="source-inline">buttons</strong> <strong class="source-inline">div</strong> tag with the following lines of code:<p class="source-code">&lt;div className="buttons"&gt;</p><p class="source-code">  &lt;Home/&gt;</p><p class="source-code">  &lt;Logout changeLoginState={changeLoginState}/&gt;</p><p class="source-code">&lt;/div&gt;</p></li>
				<li>Wrap the two buttons in a separate <strong class="source-inline">div</strong> tag so that it is easier<a id="_idIndexMarker711"/> to align them correctly. You can replace<a id="_idIndexMarker712"/> the old CSS for the <strong class="bold">Logout</strong> button and add the following:<p class="source-code">.topbar .buttons {</p><p class="source-code">  position: absolute;</p><p class="source-code">  right: 5px;</p><p class="source-code">  top: 5px;</p><p class="source-code">  height: calc(100% - 10px);</p><p class="source-code">}</p><p class="source-code">.topbar .buttons &gt; * {</p><p class="source-code">  height: 100%;</p><p class="source-code">  margin-right: 5px;</p><p class="source-code">  border: none;</p><p class="source-code">  border-radius: 5px;</p><p class="source-code">}</p></li>
			</ol>
			<p>Now that we have everything together, the user can visit the profile page and navigate back again. Our final result looks like this:</p>
			<div>
				<div id="_idContainer064" class="IMG---Figure">
					<img src="image/Figure_8.01_B17337.jpg" alt="Figure 8.1 – User profile&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1 – User profile</p>
			<p>We have a big profile header for the user<a id="_idIndexMarker713"/> and their posts at the bottom of the window. At the top, you can see the top<a id="_idIndexMarker714"/> bar with the currently logged-in user.</p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor174"/>Remembering the redirect location</h2>
			<p>When a visitor comes to your page, they have probably followed a link that was posted elsewhere. This link is likely<a id="_idIndexMarker715"/> to be a direct address for a user, a post, or anything<a id="_idIndexMarker716"/> else that you offer direct access to. For those that are not logged in, we configured the application to redirect that person to the login or signup forms. This behavior makes sense. However, once that person has either logged in or signed up with a new account, they are then navigated to the news feed. A better way of doing this would be to remember the initial destination that the person wanted to visit. To do this, we will make a few changes to the router. Open the <strong class="source-inline">router.js</strong> file. With all of the routing components provided by React Router, we always get access to the properties inside of them. We will make use of this and save the last location that we were redirected from.</p>
			<p>In the <strong class="source-inline">PrivateRoute</strong> component, swap out the <strong class="source-inline">Redirect</strong> component with the following code:</p>
			<p class="source-code">&lt;Redirect to={{</p>
			<p class="source-code">  pathname: '/',</p>
			<p class="source-code">  state: { from: props.location }</p>
			<p class="source-code">}} /&gt;</p>
			<p>Here, we have added the <strong class="source-inline">state</strong> field. The value that it receives comes from the parent <strong class="source-inline">Route</strong> component, which holds the last matched path in the <strong class="source-inline">props.location</strong> field generated by React Router. The path can be a user's profile page or the news feed since both rely on the <strong class="source-inline">PrivateRoute</strong> component where authentication is required. When the preceding redirect is triggered, you receive the <strong class="source-inline">from</strong> field inside the router's state. </p>
			<p>We want to use this variable<a id="_idIndexMarker717"/> when the user is logging in. Replace the <strong class="source-inline">Redirect</strong> component<a id="_idIndexMarker718"/> in the <strong class="source-inline">LoginRoute</strong> component with the following lines of code:</p>
			<p class="source-code">&lt;Redirect to={{</p>
			<p class="source-code">  pathname: (typeof props.location.state !== typeof </p>
			<p class="source-code">    undefined) ? </p>
			<p class="source-code">  props.location.state.from.pathname : '/app',</p>
			<p class="source-code">}} /&gt;</p>
			<p>Here, I have introduced a small condition for the <strong class="source-inline">pathname</strong> parameter. If the <strong class="source-inline">location.state</strong> property is defined, we can rely on the <strong class="source-inline">from</strong> field. Previously, we stored the redirect path in the <strong class="source-inline">PrivateRoute</strong> component. If the <strong class="source-inline">location.state</strong> property does not exist, the user was not visiting a direct hyperlink but just wanted to log in normally. They will be navigated to the news feed with the <strong class="source-inline">/app</strong> path.</p>
			<p>Your application should now be able to handle all routing scenarios, and this should allow your users to view your site comfortably.</p>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor175"/>Summary</h1>
			<p>In this chapter, we transitioned from our one-screen application to a multi-page setup. React Router, our main library for routing purposes now has three paths, under which we display different parts of Graphbook. Furthermore, we now have a catch-all route, in which we can redirect the user to a valid page. </p>
			<p>In the next chapter, we will continue with this progression by implementing server-side rendering, which needs many adjustments on both the frontend and the backend.</p>
		</div>
	</body></html>