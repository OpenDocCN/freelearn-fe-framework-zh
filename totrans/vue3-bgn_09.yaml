- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Introduction to Advanced Vue.js Techniques – Slots, Lifecycle, and Template
    Refs
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级Vue.js技术介绍 – 插槽、生命周期和模板引用
- en: Up until now, we have learned about the basic features and techniques offered
    by Vue.js. Things such as properties and computed are the foundation of the Vue.js
    framework and will be used daily as you develop your next application with Vue.js.
    In this chapter, we are going to cover a few features that are what I call “advanced.”
    This is not described as “advanced” because of its complexity, but in the fact
    that you will be less likely to use this daily. Features such as slots and Template
    Refs are used to solve specific use cases and are not expected to be encountered
    during your average task but are more likely to be used for specific situations
    that occur less frequently during a project. What you will learn in this chapter
    may not be used for quite some time, so it would be good to remember its existence
    and make sure you come back to it if the need for any of these features arises
    in your task.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了Vue.js提供的基本功能和技巧。例如属性和计算属性是Vue.js框架的基础，您在用Vue.js开发下一个应用程序时将每天使用它们。在本章中，我们将介绍一些我称之为“高级”的功能。这不是因为它们的复杂性而被描述为“高级”，而是因为您在日常使用中不太可能使用它们。例如插槽和模板引用用于解决特定的用例，并不期望在您的常规任务中遇到，而更可能用于在项目过程中发生的较少的特定情况。您在本章中学到的知识可能不会立即使用，所以记住它的存在，并在需要任何这些功能时确保您能回想起它。
- en: In this chapter, we are going to add yet more features to our Companion App.
    We are first going to enhance our base button to introduce the notion of slots.
    Next, we will create a shared layout to be used in our static pages using named
    slots. Then, we will turn our attention to adding a new feature that will allow
    us to add new posts. While doing so, we are going to learn how to use Template
    Ref to access the `CreatePost.vue` component. To conclude the chapter, we are
    going to build a completely new feature that will allow us to expand and collapse
    our sidebar. While doing so, we are not only going to iterate over the Vue.js
    lifecycles hooks but we are also using this opportunity to go over previously
    learned techniques such as methods, dynamic classes, and directives.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向我们的伴侣应用程序添加更多功能。首先，我们将增强我们的基本按钮以引入插槽的概念。接下来，我们将创建一个共享布局，使用命名插槽在我们的静态页面中使用。然后，我们将关注添加一个新功能，这将使我们能够添加新帖子。在这样做的时候，我们将学习如何使用模板引用来访问`CreatePost.vue`组件。为了结束本章，我们将构建一个全新的功能，这将使我们能够展开和折叠侧边栏。在这样做的时候，我们不仅将遍历Vue.js的生命周期钩子，而且还将利用这个机会回顾之前学过的技术，如方法、动态类和指令。
- en: 'The chapter will be divided into the following sections:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将分为以下几部分：
- en: The power of slots
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插槽的力量
- en: Accessing components elements with Template Refs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模板引用访问组件元素
- en: Deep diving into the lifecycle of a real app
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解真实应用的生命周期
- en: By the end of this chapter, you will be able to use components that offer slots
    and develop components that expose one or multiple slots. You will also be able
    to access an element within a component with the use of Template Refs and finally
    be able to make better decisions when using lifecycles, to ensure that the application
    is free of bugs.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够使用提供插槽的组件，并开发暴露一个或多个插槽的组件。您还将能够使用模板引用在组件内访问元素，并最终在使用生命周期时做出更好的决策，以确保应用程序无bug。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, the branch is called `CH09`. To pull this branch, run the
    following command or use your GUI of choice to support you in this operation:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，分支被命名为`CH09`。要拉取此分支，请运行以下命令或使用您选择的GUI来支持您进行此操作：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The code files for the chapter can be found at [https://github.com/PacktPublishing/Vue.js-3-for-Beginners](https://github.com/PacktPublishing/Vue.js-3-for-Beginners).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在[https://github.com/PacktPublishing/Vue.js-3-for-Beginners](https://github.com/PacktPublishing/Vue.js-3-for-Beginners)找到。
- en: The power of slots
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插槽的力量
- en: In the first few chapters of this book, we have learned how properties and events
    can be used for a parent and a child to communicate with each other. This method
    of communication is not very flexible, as the only way for a component to expose
    information is by creating a new property.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前几章中，我们学习了如何使用属性和事件让父组件和子组件相互通信。这种通信方式不是很灵活，因为组件暴露信息的唯一方式是创建一个新的属性。
- en: In many cases, the rigidity that properties provide is precisely what we want
    to make sure that our component renders correctly, but there are times when more
    flexibility is needed, and this is where slots come in.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，属性提供的僵化性正是我们想要确保组件正确渲染的，但有时需要更多的灵活性，这就是插槽发挥作用的地方。
- en: Let’s consider our base button component. Its look and feel are defined by its
    properties and so is its value, but what would happen if we wanted to create a
    button with an icon before its value?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑我们的基础按钮组件。它的外观和感觉由其属性定义，其值也是如此，但如果我们想在值之前创建一个带有图标的按钮会怎样呢？
- en: With our current knowledge of Vue.js, we would resort to creating a new prop
    of icon (`prependIcon`) that accepts an icon. Then, a further requirement may
    need us to add an icon after the value, so we would again resort to a new property
    of icon (`appendIcon`). Each additional request may result in a new property making
    our component very hard to maintain. Luckily, all the preceding requirements can
    be solved using slots.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们对 Vue.js 的当前了解，我们会求助于创建一个新的属性 `icon`（`prependIcon`），它接受一个图标。然后，进一步的要求可能需要我们在值之后添加一个图标，因此我们又会求助于一个新的属性
    `icon`（`appendIcon`）。每个额外的请求可能会导致一个新的属性，使得我们的组件难以维护。幸运的是，所有上述要求都可以使用插槽来解决。
- en: Slots turn your component into a wrapper, allowing people to pass any arbitrary
    HTML or components into it. Slots are nothing new; in fact, native HTML offers
    a very similar functionality that you have been using automatically without knowing
    it. `<div>` is just a wrapper to other elements, `<h1>` can include text but also
    other elements in its content, and the list can go on.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 插槽将你的组件变成一个包装器，允许人们传递任何任意的 HTML 或组件到其中。插槽并不是什么新东西；实际上，原生 HTML 提供了非常类似的功能，你一直在不知不觉中使用它。`<div>`
    只是一个包装其他元素的容器，`<h1>` 可以包含文本，也可以在其内容中包含其他元素，以此类推。
- en: The same functionality that a native button, heading, or span offers is also
    offered by Vue.js slots.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js 插槽也提供了原生按钮、标题或 span 提供的相同功能。
- en: 'Let’s consider how we would use a button in HTML. We would open the element
    with `<button>` and then we would add something within its content – this could
    be simple text, another element, or both. Finally, we would close the element
    with `</button>`, just like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下在 HTML 中如何使用按钮。我们会用 `<button>` 打开元素，然后在其内容中添加一些东西——这可以是简单的文本，另一个元素，或者两者都有。最后，我们会用
    `</button>` 关闭元素，就像这样：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Well, the `My button` text and the `<icon>` element displayed in the previous
    code snippets are what we refer to in Vue.js as **slot content**. As previously
    mentioned, using properties is a great way to ensure that the values passed to
    the component are of a certain type, but this advantage can easily turn into a
    disadvantage that makes the component quite rigid.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，`My button` 文本和之前代码片段中显示的 `<icon>` 元素，在 Vue.js 中我们称之为**插槽内容**。正如之前提到的，使用属性是确保传递给组件的值是特定类型的一种很好的方式，但这种优势很容易变成劣势，使得组件变得相当僵化。
- en: Let’s see how to use slots by modifying `TheButton.vue`. We are going to remove
    the property called value and replace it with a slot so that our button will act
    as a native HTML button.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过修改 `TheButton.vue` 来看看如何使用插槽。我们将移除名为 `value` 的属性，并用一个插槽来替换它，这样我们的按钮将像原生
    HTML 按钮一样工作。
- en: 'Let’s modify our component:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改我们的组件：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: First, we removed the property called `value` from the `defineProps` object,
    and then we added a slot in our component template by adding a Vue.js element
    called `<slot>`. This element does not need to be imported as it is accessible
    globally.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从 `defineProps` 对象中移除了名为 `value` 的属性，然后在组件模板中添加了一个 Vue.js 元素 `<slot>` 来添加一个插槽。这个元素不需要导入，因为它可以在全局范围内访问。
- en: 'Now, we need to find all the occurrences of `TheButton` and replace the syntax
    from the previous one that used the property value:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要找到所有 `TheButton` 的出现，并替换之前使用属性值时的语法：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We need to replace this with the new one that uses a slot:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要用新的插槽来替换它：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding change needs to happen in `CreatePost.vue`, `SocialPost.vue`,
    and `Sidebar.vue`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 上述更改需要在 `CreatePost.vue`、`SocialPost.vue` 和 `Sidebar.vue` 中发生。
- en: Slots are more than just text
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 插槽不仅仅是文本
- en: Remember that now our component value not only accepts text, but it can also
    accept other HTML elements and Vue components.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，现在我们的组件值不仅接受文本，还可以接受其他 HTML 元素和 Vue 组件。
- en: Now that we know the basics of slots, let’s move on and learn about them in
    more detail, starting with the slot default value.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了插槽的基础知识，让我们继续深入学习，从插槽默认值开始。
- en: Adding default values to a slot
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为插槽添加默认值
- en: Vue.js slots not only allow us to replicate native functionalities, but they
    also offer some extra features, one of which is the ability to add default values
    to our slots. This could either be a dialog heading or the text shown in a form
    submit button; default values can help you keep your code clean.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js的插槽不仅允许我们复制原生的功能，还提供了一些额外功能，其中之一是能够向我们的插槽添加默认值。这可以是对话框标题或表单提交按钮中显示的文本；默认值可以帮助你保持代码的整洁。
- en: Adding default values for your slot is very simple; all you need to do is add
    the value that you want directly within the `<slot>` declaration. This value is
    going to be used if no other alternative is passed to the component, otherwise,
    it is going to be removed and overridden from the slot received.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的插槽添加默认值非常简单；你只需要直接在`<slot>`声明中添加你想要的值。如果没有传递其他替代值给组件，这个值将被使用，否则，它将被移除并从接收到的插槽中覆盖。
- en: Let’s see a quick example to understand the declaration and usage of default
    slots.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个快速示例来了解默认插槽的声明和使用。
- en: 'First, we are going to add a default text of `Click Me` to `TheButton.vue`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将向`TheButton.vue`添加一个默认文本`点击我`：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that we have added a default value, our button will automatically show the
    new text, in the case in which no content is passed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了默认值，我们的按钮将自动显示新的文本，在这种情况下没有传递内容。
- en: 'To see the default slot in action, we would have to call our button without
    any slot content, so the code would look like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到默认插槽的实际效果，我们需要调用我们的按钮而不包含任何插槽内容，因此代码看起来是这样的：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will render our default text.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这将渲染我们的默认文本。
- en: '![Figure 9.1: Default button with a value of “Click me”](img/B21130_09_01.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1：默认按钮，值为“点击我”](img/B21130_09_01.jpg)'
- en: 'Figure 9.1: Default button with a value of “Click me”'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1：默认按钮，值为“点击我”
- en: 'The text is there just as a fallback; in fact, adding a value within the slot
    will override the text:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 文本只是作为一个后备；实际上，在插槽内添加一个值将覆盖文本：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Just as we saw before, adding text in the slot will display it, just as you
    would expect in a native HTML element:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，在插槽中添加文本将显示它，就像你预期在原生的HTML元素中一样：
- en: '![Figure 9.2: Default button with a value of “Show this”](img/B21130_09_02.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2：默认按钮，值为“显示此内容”](img/B21130_09_02.jpg)'
- en: 'Figure 9.2: Default button with a value of “Show this”'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2：默认按钮，值为“显示此内容”
- en: Slot versus property
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插槽与属性对比
- en: Before we learn one more feature about slots, I want to write a few words to
    clarify why we need two methods (slots and properties) to achieve a very similar
    result.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们学习关于插槽的另一个特性之前，我想说几句话来澄清为什么我们需要两种方法（插槽和属性）来实现非常相似的结果。
- en: 'Slots and properties solve two different use cases, and both have advantages
    and disadvantages:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 插槽和属性解决了两种不同的用例，并且两者都有优点和缺点：
- en: '**Slots**: These are used mainly for components that require the values to
    be flexible. These are components that just provide a structure, for example,
    a dialog or end elements such as buttons or headings.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插槽**：这些主要用于需要值灵活性的组件。这些组件仅提供结构，例如对话框或按钮或标题等结束元素。'
- en: '**Properties**: These are used for elements that require fine control of what
    is being passed to them. This could either be due to some style that would break
    with different content or because of the need to validate or format the value
    received.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性**：这些用于需要精细控制传递给它们的元素的元素。这可能是由于某些样式会因不同内容而破坏，或者因为需要验证或格式化接收到的值。'
- en: We can use native HTML elements to emphasize the differences we just defined.
    In favor of slots, we have headings tags such as `<h1>` and `<h2>`. These are
    very generic elements that provide styles, mainly in the form of font size and
    spacing to its content. This element requires flexibility, and the use of slots
    is perfect for it. In fact, native heading elements wrap their content just like
    slots.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用原生的HTML元素来强调我们刚刚定义的差异。对于插槽，我们有标题标签，如`<h1>`和`<h2>`。这些是非常通用的元素，它们提供样式，主要是以字体大小和间距的形式为其内容提供样式。这个元素需要灵活性，使用插槽是完美的。事实上，原生的标题元素就像插槽一样包裹其内容。
- en: On the other hand, we have the `<input>` element to prove the usefulness of
    attribute values (properties in Vue.js). The input element requires a specific
    attribute called `value`. The value offered by the input field only accepts a
    string or a number as its value. Offering a syntax that accepts an attribute,
    `<input value="text" />`, ensures that the value passed to the input field is
    validated.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们有 `<input>` 元素来证明属性值（Vue.js 中的属性）的有用性。输入元素需要一个特定的属性，称为 `value`。输入字段提供的值只接受字符串或数字作为其值。提供接受属性的语法，`<input
    value="text" />` 确保传递给输入字段的值是经过验证的。
- en: Provide multiple slots with named slots
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供多个带有命名插槽的插槽
- en: As you have probably noticed, slots have lots of useful features and can be
    very handy for constructing complex components. In the previous section, we have
    seen how we can define a single slot, but Vue.js offers more than that.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经注意到的，插槽有很多有用的功能，对于构建复杂组件非常有用。在前一节中，我们看到了如何定义单个插槽，但 Vue.js 提供的不仅仅是这些。
- en: In fact, components in Vue.js can define more than one slot at a time. This
    is achieved using a functionality called **named slots**.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，Vue.js 中的组件可以同时定义多个插槽。这是通过一个称为**命名插槽**的功能实现的。
- en: A common use of named slots is to define layouts. You can define a layout that
    accepts a sidebar, main content, and footer and then allow users to pass all the
    content that they see fit within the individual section. Another good example
    is a main hero component that offers a heading and a subheading, or a dialog component
    that offers a title and its content.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 命名插槽的常见用途是定义布局。您可以定义一个接受侧边栏、主要内容以及页脚的布局，然后允许用户在各个部分中传递他们认为合适的内容。另一个很好的例子是一个提供标题和副标题的主要英雄组件，或者是一个提供标题及其内容的对话框组件。
- en: 'Let’s create a very basic layout for our static content. We are going to store
    our new component in a folder called `templates` and call it `StaticTemplate.vue`.
    The relative URL would be `src/components/templates/StaticTemplate.vue`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的静态内容创建一个非常基本的布局。我们打算将新组件存储在一个名为 `templates` 的文件夹中，并命名为 `StaticTemplate.vue`。相对URL将是
    `src/components/templates/StaticTemplate.vue`：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Our layout is going to have some basic styles that are required to create the
    correct spacing and show the difference between the individual sections. The template
    also includes three different sections: a heading defined with `<h1>`, the main
    content defined with the `<main>` element, and finally, `<footer>`.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的布局将包含一些基本的样式，这些样式是创建正确间距并显示各个部分之间差异所必需的。模板还包括三个不同的部分：使用 `<h1>` 定义的标题，使用 `<main>`
    元素定义的主要内容，以及最后的 `<footer>`。
- en: 'Let’s now add the named slot to our templates. The syntax of the named slot
    is very similar to the normal slot, therefore defined using the `<slot>` element,
    but with the addition of a `name` attribute. Just to emphasize the previous learning
    material, we are going to provide a default value for the footer:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们给我们的模板添加一个命名插槽。命名插槽的语法与普通插槽非常相似，因此也是使用 `<slot>` 元素定义的，但增加了一个 `name` 属性。为了强调之前的学习材料，我们将为页脚提供一个默认值：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With the preceding code, the `StaticTemplate.vue` file can be called with the
    possibility to pass three different sections. Let’s go over the `AboutView.vue`
    page within the `Views` folder and try to use this new layout.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`StaticTemplate.vue` 文件可以调用，并具有传递三个不同部分的可能性。让我们查看 `Views` 文件夹中的 `AboutView.vue`
    页面，并尝试使用这个新布局。
- en: 'The syntax for the named slot is a little different than the default slot,
    as we need to define the actual name of the section that we are defining. To use
    a named slot, you use the `<template #``slotName></template>` syntax.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '命名插槽的语法与默认插槽略有不同，因为我们需要定义我们正在定义的章节的实际名称。要使用命名插槽，您使用 `<template #slotName></template>`
    语法。'
- en: 'Let’s try to apply this to our `AboutView` page:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试将其应用到我们的 `AboutView` 页面上：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: First, we imported the new component in the script section and then we used
    the component just like we would use `<div>` or `<span>`. Last, we added content
    for our slot by defining a heading and default section. Because **About Page**
    does not require the overriding of the footer, we are leaving that out of our
    instance so that the default value can be rendered.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在脚本部分导入了新组件，然后就像使用 `<div>` 或 `<span>` 一样使用该组件。最后，我们通过定义标题和默认部分来为我们的插槽添加内容。由于**关于页面**不需要覆盖页脚，所以我们将其排除在我们的实例之外，以便可以渲染默认值。
- en: 'If we access **About Page** at “[http://localhost:5173/about](http://localhost:5173/about)”,
    we should see the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们访问“[http://localhost:5173/about](http://localhost:5173/about)”上的**关于页面**，我们应该看到以下内容：
- en: '![Figure 9.3: About Page using the new layout](img/B21130_09_03.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3：使用新布局的关于页面](img/B21130_09_03.jpg)'
- en: 'Figure 9.3: About Page using the new layout'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3：使用新布局的关于页面
- en: The page is displaying all three sections as we expected.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 页面正在显示我们预期的所有三个部分。
- en: 'The default slot does not require the <template #default> syntax'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '默认插槽不需要`<template #default>`语法'
- en: 'If we wanted to, we would have been able to call the default slot without the
    need to use `<template #default>`, but this is not a suggested approach as it
    would have produced a hard-to-read code with mixed methodology.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '如果我们愿意，我们可以在不使用`<template #default>`的情况下调用默认插槽，但这不是一个建议的方法，因为它会产生难以阅读的代码，并且混合了不同的方法。'
- en: There is one more feature offered by Vue.js slot implementation called the **scoped
    slot**. This is a very advanced technique that allows you to define slots that
    expose the child’s scope to its parents. Due to their complexity, these are not
    going to be tackled within this book.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js插槽实现提供的一个额外功能是**作用域插槽**。这是一个非常高级的技术，允许你定义将子组件的作用域暴露给其父组件的插槽。由于它们的复杂性，这些内容不会在本书中讨论。
- en: Slots are a very powerful technique that helps us make our components easier
    to use, improve their readability, and offer enhanced flexibility. Just like every
    other feature, slots have their own advantages and disadvantages and should be
    used just when needed. The flexibility caused by the use of slots can produce
    unwanted side effects with the UI and it can be easier at times to control the
    layout of a component by imposing its values with the use of properties.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 插槽是一个非常强大的技术，它帮助我们使组件更容易使用，提高其可读性，并提供增强的灵活性。就像其他每个特性一样，插槽也有自己的优缺点，并且应该只在需要时使用。使用插槽带来的灵活性可能会对UI产生不期望的副作用，有时通过使用属性来强制设置值，可以更容易地控制组件的布局。
- en: In this chapter so far, we have introduced the notion of slots by comparing
    them with existing features available within native HTML elements, and we then
    learned the syntax required to define and use default slots. After, we compared
    slots and properties and tried to distinguish the different scenarios in which
    one method may be preferred to another. Last, we learned how to define default
    values for a slot and the possibility of defining multiple slots with the named
    slot.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们通过将它们与原生HTML元素中现有的功能进行比较，介绍了插槽的概念，然后学习了定义和使用默认插槽所需的语法。之后，我们比较了插槽和属性，并试图区分在哪些情况下一种方法可能比另一种方法更可取。最后，我们学习了如何为插槽定义默认值以及定义多个具有命名插槽的可能性。
- en: We are going to continue the chapter with another advanced topic, introducing
    how we can access children’s components or HTML elements with the use of Template
    Ref.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续本章，介绍另一个高级主题，介绍如何使用模板引用来访问子组件或HTML元素。
- en: Accessing components elements with Template Refs
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模板引用访问组件元素
- en: In this section, we are going to improve the control of our components by learning
    how to access the DOM element.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过学习如何访问DOM元素来提高我们组件的控制能力。
- en: When I first started to learn about Vue.js, I was astonished by how much could
    be accomplished without the need to access DOM elements. The Vue.js engine is
    structured in a way that we can accomplish all basic operations with the use of
    props, data, methods, and computed properties.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当我最初开始学习Vue.js时，我被它在不访问DOM元素的情况下能完成多少事情所震惊。Vue.js引擎的结构是这样的，我们可以使用props、data、methods和计算属性来完成所有基本操作。
- en: Just like everything else, there are times when we may need some extra control,
    and this can be achieved with the use of `Template Ref`. Using this feature exposes
    the DOM element in which the Ref was defined. This would be the same as using
    `querySelector` or `getElementById` offered by vanilla JavaScript.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他所有事情一样，有时候我们可能需要一些额外的控制，而这可以通过使用`模板引用`来实现。使用这个特性会暴露出定义了引用的DOM元素。这和直接使用原生JavaScript提供的`querySelector`或`getElementById`方法是一样的。
- en: Same Refs different usage
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的引用，不同的用法
- en: You may be wondering why we are learning about Refs if we already learned about
    it at the start of the book to define the private properties of a component. Well,
    this Refs is different. It is defined with the same syntax, but it is going to
    hold the value of an HTML element or component instead of primitive data such
    as strings and numbers.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们学习Refs，因为我们已经在书的开始部分学习了它来定义组件的私有属性。嗯，这个Refs是不同的。它是用相同的语法定义的，但它将持有HTML元素或组件的值，而不是字符串和数字等原始数据。
- en: Refs can be used for two different scenarios. The first is accessing a native
    element to access its native APIs; one such thing could be to focus an element
    or trigger native validation for an input field. The next is to access another
    Vue component or package to expose methods or their inner information. A common
    scenario for this is the need to set or fetch the value of a WYSIWYG (What you
    see is what you get) or code editor. The second scenario is not common practice
    and should be used just in case of emergency. The reason why accessing a child
    component using Template Ref is not suggested is that it will couple the two elements
    together and this should always be avoided in component-based architecture.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Refs可用于两种不同的场景。第一种是访问原生元素以访问其原生API；这样的事情之一可能是聚焦一个元素或触发输入字段的原生验证。第二种是访问另一个Vue组件或包以公开方法或其内部信息。一个常见的场景是需要设置或获取WYSIWYG（所见即所得）或代码编辑器的值。第二种场景不是常见做法，仅应在紧急情况下使用。不建议使用模板引用访问子组件的原因是它将两个元素耦合在一起，而在基于组件的架构中，这应该始终避免。
- en: Focus an onMounted element
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 专注于onMounted元素
- en: Let’s start to play with Template Refs by learning how to fetch the reference
    of an input field and focus it when the page loads. The focus feature could have
    been achieved with the `autofocus` attribute, but we will develop the feature
    manually to showcase the use of Refs.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过学习如何获取输入字段的引用并在页面加载时将其聚焦来开始玩转模板引用。聚焦功能原本可以通过`autofocus`属性实现，但我们将手动开发这个功能来展示Refs的使用。
- en: We are going to work in `CreatePost.vue` and autofocus the `textarea` used to
    write a new post.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`CreatePost.vue`中工作，并自动聚焦用于撰写新帖子的`textarea`。
- en: 'We need to make three modifications to our component. First, we are going to
    define a `ref`, just like we learned throughout this book. Next, we are going
    to assign the Template Ref to `textarea` and we are going to access that element
    using the `onMounted` lifecycle and focus the component:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对组件进行三项修改。首先，我们将定义一个`ref`，就像我们在整本书中学到的。接下来，我们将模板引用分配给`textarea`，并使用`onMounted`生命周期访问该元素并聚焦组件：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Working with Refs follows a specific order; we first create the `const textareaRef
    = ref(null)` Ref and, at this point, the Ref is going to be null. We then assign
    the ref to a specific element within our component; in our scenario, we add it
    to `textarea`. The Ref is still empty because the component is not rendered, and
    the element does not exist on the page yet. Finally, we trigger our logic within
    the `onMounted` lifecycle. Because the `onMounted` lifecycle is triggered after
    the component is fully rendered, the Ref will be fully defined and ready to use.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Refs的顺序是特定的；我们首先创建`const textareaRef = ref(null)` Ref，此时Ref将是null。然后我们将ref分配给组件内的一个特定元素；在我们的场景中，我们将其添加到`textarea`。由于组件尚未渲染，元素尚未在页面上存在，因此Ref仍然是空的。最后，我们在`onMounted`生命周期中触发我们的逻辑。因为`onMounted`生命周期是在组件完全渲染后触发的，所以Ref将完全定义并准备好使用。
- en: Before we move on, I want to focus on three more parts of the code block. First
    is a reminder that Refs in Vue.js require `.value` to be appended to them to be
    able to access their internal value. This applies to both normal refs, such as
    strings and numbers, and Template Refs which we are covering in this section of
    the book. Second, I want to emphasize the fact a Tempalte Ref associated with
    an element (in our case, `texareaRef`) is going to be null until `onMounted` is
    triggered. This means that if we ever use it in a computed property or method,
    we need to ensure that we check for null values to avoid errors. The last is about
    the naming convention. It is important for the name of the Template Ref and the
    one used in the HTML element to match for it to function. It is important for
    the name of the Template Ref variables (const textareaRef) and the one used in
    the HTML attribute (ref="textareaRef") to match for it to function successfully.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我想关注代码块中的三个更多部分。首先是一个提醒，Vue.js 中的 Refs 需要附加 `.value` 才能访问它们的内部值。这适用于正常的
    Refs，如字符串和数字，以及我们在本书的这一部分中介绍的模板 Refs。其次，我想强调，与元素关联的模板 Ref（在我们的例子中是 `textareaRef`）在
    `onMounted` 触发之前将是 null。这意味着如果我们将其用于计算属性或方法，我们需要确保检查 null 值以避免错误。最后是关于命名约定的问题。模板
    Ref 的名称和用于 HTML 元素的名称必须匹配才能正常工作。模板 Ref 变量（const textareaRef）和用于 HTML 属性（ref="textareaRef"）的名称必须匹配才能成功工作。
- en: Refs are just for exceptional cases
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Refs 仅适用于特殊情况
- en: Vue.js provides us with mostly everything we need out of the box, so Refs should
    not be overused. The use of Refs should be saved for specific use cases and not
    become the norm. If you find yourself using this more than a handful of times
    in a project, you are probably misusing other Vue.js features.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Vue.js 提供了我们大部分需要的现成功能，因此 Refs 不应过度使用。Refs 的使用应仅限于特定的用例，而不是成为常规。如果你在项目中发现 Refs
    的使用次数超过几次，那么你很可能误用了其他 Vue.js 功能。
- en: Access from native validation
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从原生验证访问
- en: This section will focus on advanced topics; we are going to reiterate the topic
    we just introduced by implementing another example that uses Template Ref to access
    an element. We will continue to work on the code that handles the creation of
    a post by adding some validation using the native HTML validation offered by HTML
    form inputs.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将关注高级主题；我们将通过实现另一个使用模板 Ref 访问元素的示例来重述我们刚刚介绍的主题。我们将继续处理创建帖子的代码，通过添加一些使用 HTML
    表单输入提供的原生 HTML 验证来执行验证。
- en: 'We are going to continue our work in `CreatePost.vue`. First, we are going
    to add some specific validation within our `<``textarea>` element:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续在 `CreatePost.vue` 中工作。首先，我们将在 `<textarea>` 元素内添加一些特定的验证：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We made `textarea` required and defined a minimum character length of `10`.
    Next, we are going to create a new ref, and this time, we will gain access to
    the main `<form>` element within the page:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `textarea` 设置为必填，并定义了最小字符长度为 `10`。接下来，我们将创建一个新的 Ref，这次我们将获取页面中主 `<form>`
    元素的访问权限：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Just like in our previous example, the creation of a Ref requires two steps.
    First, we add an attribute of Ref to an element, and then we create a constant
    that has a name matching the Ref.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前的例子一样，创建 Ref 需要两个步骤。首先，我们给一个元素添加一个 Ref 属性，然后创建一个与 Ref 名称匹配的常量。
- en: 'In this last step, we are going to create a method that will be called when
    the form is submitted and use our newly created Template Ref to access the native
    form validation API:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一最后步骤中，我们将创建一个在表单提交时被调用的方法，并使用我们新创建的模板 Ref 来访问原生的表单验证 API：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To achieve this, we used our knowledge of events gained in [*Chapter 6*](B21130_06.xhtml#_idTextAnchor074)
    and triggered a method called `createPost` on form submission. Then, we created
    a method that prevented the native submit from triggering and used the `createPostForm`
    Ref to check the validity of the form with `createPostForm.value.reportValidity()`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们使用了在 [*第 6 章*](B21130_06.xhtml#_idTextAnchor074) 中获得的事件知识，并在表单提交时触发了名为
    `createPost` 的方法。然后，我们创建了一个方法来阻止原生提交触发，并使用 `createPostForm` Ref 通过 `createPostForm.value.reportValidity()`
    检查表单的有效性。
- en: This method will return a Boolean (so `true` or `false`) depending on whether
    the form is valid and it will also display the native error message on the screen.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将返回一个布尔值（因此是 `true` 或 `false`），取决于表单是否有效，并且它还会在屏幕上显示原生错误消息。
- en: 'Let’s start our application and try to trigger the form with an empty input:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启动我们的应用程序，并尝试通过一个空输入来触发表单：
- en: '![Figure 9.4: Native HTML validation error displayed on textarea](img/B21130_09_04.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4：在textarea上显示的本地HTML验证错误](img/B21130_09_04.jpg)'
- en: 'Figure 9.4: Native HTML validation error displayed on textarea'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4：在textarea上显示的本地HTML验证错误
- en: We are going to leave this form as it is even if it is not fully functional
    as the code required to submit the form will be completed in [*Chapter 12*](B21130_12.xhtml#_idTextAnchor163).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保留这个表单的原样，即使它不完全功能，因为提交表单所需的代码将在[*第12章*](B21130_12.xhtml#_idTextAnchor163)中完成。
- en: In this section, we have learned that Ref is not only used to define our component
    values but it is also used to hold values of HTML elements. We have applied this
    newly learned technique by developing the functionality and validation needed
    to create new posts in `CreatePost.vue`. Finally, we iterated on the flow in which
    Refs are defined and how it requires the mounted state to be completed for it
    to be accessible.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解到Ref不仅用于定义组件值，还用于保存HTML元素的值。我们通过开发在`CreatePost.vue`中创建新帖子所需的功能和验证来应用这项新学到的技术。最后，我们迭代了定义Refs的流程以及它如何需要完成挂载状态才能使其可访问。
- en: In the next section, we will add the ability to expand and minimize the sidebar
    of our application and iterate through the notion of the lifecycle.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将添加扩展和最小化应用侧边栏的能力，并迭代生命周期概念。
- en: Deep diving into the lifecycle of a real app
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入研究真实应用的生命周期
- en: Lifecycles are not a new notion and have been mentioned once or twice throughout
    this book, but due to their importance, it is a good idea to iterate through them
    by adding further functionality to our Companion App.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期不是一个新概念，在本书中被提及过一两次，但由于其重要性，通过向我们的伴侣应用添加更多功能来迭代它们是个好主意。
- en: In this section, we are going to add new functionality that will enable us to
    expand and minimize the left sidebar of our application and store the value in
    `localStorage` to ensure the user preferences are persistent on refresh. We are
    going to learn how having a better understanding of the lifecycle can improve
    the user experience provided by our application.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将添加新的功能，使我们能够扩展和最小化应用的左侧边栏，并将值存储在`localStorage`中，以确保在刷新时用户偏好保持持久。我们将学习如何更好地理解生命周期可以改善我们应用提供的用户体验。
- en: Before we jump into the code itself, let’s think about what steps would be required
    to achieve this new functionality. Thinking over a problem helps you memorize
    all the different aspects of the Vue.js framework that we have learned and supports
    you in realizing any lack of knowledge or misunderstanding that you may have.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码本身之前，让我们思考一下实现这个新功能所需的步骤。思考问题有助于你记住我们所学Vue.js框架的所有不同方面，并支持你实现任何可能存在的知识或理解上的缺乏。
- en: 'To complete the task of enabling the sidebar to collapse and expand, we would
    need to do the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成使侧边栏能够折叠和展开的任务，我们需要做以下几步：
- en: Add the UI required for the user to trigger this action.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加用户触发此操作的UI。
- en: Add some style to improve the look and feel of the sidebar.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些样式以改善侧边栏的外观和感觉。
- en: Create a new value that will hold the state of the sidebar.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的值来保存侧边栏的状态。
- en: Expand the sidebar to have different renderings for the different states.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展侧边栏以对不同状态有不同的渲染。
- en: Add the logic to handle the sidebar state change and save the value.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加处理侧边栏状态变化并保存值的逻辑。
- en: Finally, read the user preferences on load and apply them to the component.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在加载时读取用户偏好并应用到组件上。
- en: The list may seem very long, but these are all small tasks that you should be
    able to accomplish without my aid. Let’s start our work by working on the new
    UI changes.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 列表可能看起来非常长，但这些都是你可以不依赖我的帮助就能完成的小任务。让我们通过着手新的UI更改开始我们的工作。
- en: Adding conditional rendering to the sidebar
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向侧边栏添加条件渲染
- en: Let’s start by reiterating the Vue.js directive by using `v-if` and `v-else`
    to effectively display two different views. One will show the expanded sidebar,
    while the other will display a minimal layout with just the button required to
    expand the sidebar.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使用`v-if`和`v-else`重述Vue.js指令开始，有效地显示两种不同的视图。一个将显示展开的侧边栏，而另一个将显示一个仅包含展开侧边栏按钮的最小布局。
- en: 'All the following developments will take place in the `SideBar.vue` file that
    holds the logic required for our sidebar. Before we make changes to its layout,
    we are going to import two new icons, `IconLeftArrow` and `IconRightArrow`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 所有后续的开发都将发生在包含我们侧边栏所需逻辑的 `SideBar.vue` 文件中。在我们对其布局进行更改之前，我们将导入两个新图标，`IconLeftArrow`
    和 `IconRightArrow`：
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we are going to add the two layouts using the conditional logic provided
    by `v-if/v-else`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 `v-if/v-else` 提供的条件逻辑添加两个布局：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`<aside>` includes two different blocks, both delineated by the `<template>`
    element. The first block just contains the right arrow icon and will be used to
    display our collapsed layout, while the other layout includes the existing code
    that was present in the component before we started the modification, with the
    addition of the left arrow icon.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`<aside>` 包含两个不同的块，都由 `<template>` 元素界定。第一个块只包含右箭头图标，将用于显示我们的折叠布局，而另一个布局包括我们在开始修改之前组件中存在的现有代码，并添加了左箭头图标。'
- en: 'If you have looked closely at the preceding code, you may realize that something
    is missing, or incomplete. In fact, a conditional statement such as an if/else
    requires a hypothesis and this is currently missing in our code: `<template` `v-if=""
    >`.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细查看前面的代码，你可能意识到某些内容缺失或不完整。事实上，如 if/else 这样的条件语句需要一个假设，而我们的代码中目前缺少这个假设：`<template
    v-if="" >`。
- en: For the statement to work, we need to add a condition that will be evaluated
    by the Vue.js compiler to display the correct layout. We are going to create a
    R`ef` called `closed` that will hold a Boolean value. This variable will be used
    by our if/else statement to define which layout should be displayed.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使该语句生效，我们需要添加一个条件，该条件将由 Vue.js 编译器评估以显示正确的布局。我们将创建一个名为 `closed` 的 R`ef`，它将保存一个布尔值。这个变量将用于我们的
    if/else 语句，以定义应该显示哪个布局。
- en: 'To accomplish this, we first define the `ref` in our script section:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们首先在我们的脚本部分定义 `ref`：
- en: <script setup>
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: <script setup>
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we use this new variable within the `v-if` directive that we have previously
    defined:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在之前定义的 `v-if` 指令中使用这个新变量：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Due to the value of `closed` being hardcoded to `false`, the sidebar will always
    display the expanded layout. In the next section, we will write the logic required
    to toggle the two layouts.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `closed` 的值被硬编码为 `false`，侧边栏将始终显示展开布局。在下一节中，我们将编写切换两种布局所需的逻辑。
- en: Writing the logic to handle the sidebar states
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写处理侧边栏状态的逻辑
- en: To be able to toggle between the two different views of our sidebar, we need
    to provide the user with the ability to change the value of `closed`. We will
    use the left arrow and right arrow icons added in the previous section to trigger
    a click event on user input. The event will initiate a method that we are going
    to call `toggleSidebar`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在两个不同的侧边栏视图中切换，我们需要提供用户改变 `closed` 值的能力。我们将使用上一节中添加的左箭头和右箭头图标来触发用户输入的点击事件。该事件将启动我们即将调用的
    `toggleSidebar` 方法。
- en: 'To code this, we are first going to add the event handler to the two icons:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写这段代码，我们首先将事件处理程序添加到两个图标上：
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, we declare the `toggleSidebar` method in the `<script>` section of our
    component:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在组件的 `<script>` 部分声明 `toggleSidebar` 方法：
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The method accepts no argument and just redeclares the value of `closed` by
    making it equal to the opposite of the current value of `closed`. This generates
    a logic that toggles a Boolean value between `true` and `false`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法不接受任何参数，只是通过将其设置为 `closed` 当前值的相反来重新声明 `closed` 的值。这生成了一种在 `true` 和 `false`
    之间切换布尔值的逻辑。
- en: If you run the application now, you should be able to toggle between two layouts.
    The next step involves adding some styles to the collapsed layout that is currently
    still showing a full-size sidebar.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行应用程序，你应该能够在两种布局之间切换。下一步涉及向当前仍然显示全尺寸侧边栏的折叠布局添加一些样式。
- en: 'Let’s add some styles to our component:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的组件中添加一些样式：
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: To better style our two layouts, we declared two classes. The first is `sidebar__closed`,
    which is used to reduce the width of our sidebar. The second is `sidebar__icon`,
    which is used to define the size and position of the arrows.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地样式化我们的两个布局，我们声明了两个类。第一个是 `sidebar__closed`，用于减小侧边栏的宽度。第二个是 `sidebar__icon`，用于定义箭头的大小和位置。
- en: '`sidebar__icon` is applied to both icons, while `sidebar__closed` is just assigned
    to `<aside>` if the value of `closed` is `true`. To do so, we used the `:class="{
    ''sidebar__closed'': closed}"` syntax. This syntax is useful as it allows you
    to create complex styles with the ability to easily apply classes when a specific
    condition is met.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`sidebar__icon` 应用于两个图标，而 `sidebar__closed` 仅在 `closed` 的值为 `true` 时分配给 `<aside>`。为此，我们使用了
    `:class="{ ''sidebar__closed'': closed}"` 语法。这种语法很有用，因为它允许你在满足特定条件时轻松地应用类，从而创建复杂的样式。'
- en: At this stage, the sidebar not only works but it is also styled properly with
    a collapsed and expanded layout. What is left to do is to make the data *persistent*.
    In development, we describe data as persistent when its value remains consistent,
    even after a browser refresh.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，侧边栏不仅功能正常，而且其折叠和展开布局也被正确地样式化了。剩下要做的就是使数据 *持久化*。在开发中，我们描述数据为持久化，当其值在浏览器刷新后仍然保持一致时。
- en: '![Figure 9.5: Expanded sidebar](img/B21130_09_05.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.5：展开的侧边栏](img/B21130_09_05.jpg)'
- en: 'Figure 9.5: Expanded sidebar'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5：展开的侧边栏
- en: '![Figure 9.6: Collapsed sidebar](img/B21130_09_06.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.6：折叠的侧边栏](img/B21130_09_06.jpg)'
- en: 'Figure 9.6: Collapsed sidebar'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6：折叠的侧边栏
- en: Now that the sidebar’s look has been improved, it is time to make its value
    persist on refresh.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在侧边栏的外观已经得到改善，是时候让它刷新后也能保持其价值了。
- en: Save and read the user preference in localStorage
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 localStorage 中保存和读取用户偏好
- en: At this stage, even if the sidebar logic is fully working, its data is not persistent
    yet. In fact, if you set the sidebar to its collapsed state and refresh the page,
    you will see that it will go back to the expanded view that was defined as its
    default state (the value that we used to initialize the `closed` ref was `false`).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，即使侧边栏逻辑完全正常工作，其数据还没有持久化。实际上，如果你将侧边栏设置为折叠状态并刷新页面，你会看到它会回到默认的展开视图（我们用来初始化
    `closed` 引用的值是 `false`）。
- en: To enable persistence, we are going to use `localStorage` to save our value
    and re-read it on page load.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现持久性，我们将使用 `localStorage` 来保存我们的值，并在页面加载时重新读取它。
- en: Before we go through the code, we should try and define what the best method
    is for us to achieve this. In fact, this section was named after the Vue.js lifecycle,
    but up to this stage, we have not used them yet.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看代码之前，我们应该尝试定义实现这一目标的最佳方法。实际上，本节是以 Vue.js 生命周期命名的，但到目前为止，我们还没有使用它们。
- en: Why is the use of the correct lifecycle important?
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么正确使用生命周期很重要？
- en: Before moving forward, spend a few minutes to try and understand what the consequences
    would be of using the incorrect lifecycle to load our data from `localStorage`.
    Think about the different lifecycles, when they are triggered, and what could
    be the effect on the application.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续前进之前，花几分钟时间尝试理解使用不正确的生命周期从 `localStorage` 加载数据的后果。考虑不同的生命周期，它们何时被触发，以及它们可能对应用程序产生的影响。
- en: As we learned in [*Chapter 2*](B21130_02.xhtml#_idTextAnchor028), there are
    different lifecycles that support different use cases. In our scenario, we are
    planning to use a lifecycle to read the value of our `closed` variable and apply
    it to the component. When making an operation like this one, you usually should
    ask yourself a couple of questions. The first is whether the data is asynchronous,
    and the second is whether the data is required before the application is rendered
    on screen.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在 [*第 2 章*](B21130_02.xhtml#_idTextAnchor028) 中所学，存在不同的生命周期，支持不同的用例。在我们的场景中，我们计划使用一个生命周期来读取我们的
    `closed` 变量的值，并将其应用于组件。在执行此类操作时，你通常应该问自己几个问题。第一个问题是数据是否异步，第二个问题是数据是否在应用程序渲染到屏幕之前就必需。
- en: Each lifecycle happens at different stages of the component life. Some such
    as `beforeCreate` is triggered before the component is even created, while others
    trigger after a component is fully mounted within the DOM like `onMounted`, and
    it is important to select the correct one for our specific scenario.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 每个生命周期都在组件生命周期的不同阶段发生。例如，`beforeCreate` 在组件甚至创建之前就被触发，而其他如 `onMounted` 则在组件完全挂载到
    DOM 中后触发，因此选择正确的生命周期对于我们的特定场景非常重要。
- en: In our case, the data is fetched from `localStorage` and is a synchronous operation;
    it is needed before the component is fully rendered or screened, also referred
    to as “before mounted.”.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，数据是从 `localStorage` 中获取的，这是一个同步操作；它需要在组件完全渲染或显示之前，也称为“在挂载之前”。
- en: The lifecycle that best fits our needs is `onBeforeMount`. This will trigger
    just before the component is rendered but after all the methods and Refs have
    been initialized.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最适合我们需求的生命周期是`onBeforeMount`。这将触发在组件渲染之前，但在所有方法和Refs初始化之后。
- en: 'Let’s add this logic to our component:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个逻辑添加到我们的组件中：
- en: '[PRE22]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: To achieve persistence, we first imported the `onBeforeMount` method from the
    Vue package and then we saved the value of the `closed` Ref every time the `toggleSidebar`
    method was triggered. To achieve this, we used the `localStorage.setItem` method
    that is available in the `window` object. Lastly, we used `onBeforeMount` to read
    the value from localStorage and then assign it to the `closed` ref.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现持久性，我们首先从Vue包中导入了`onBeforeMount`方法，然后每次触发`toggleSidebar`方法时，我们都保存`closed`
    Ref的值。为了实现这一点，我们使用了`window`对象中可用的`localStorage.setItem`方法。最后，我们使用`onBeforeMount`从localStorage中读取值，并将其分配给`closed`
    ref。
- en: At this stage, our application will not only allow the user to toggle the sidebar,
    but its value will also be persistent on refresh.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们的应用不仅允许用户切换侧边栏，而且其值在刷新时也会保持持久。
- en: Before we complete this chapter, I want to focus on why using the correct lifecycle
    is important. In fact, if we had used another lifecycle such as `onMounted`, the
    sidebar would have been fully rendered (incorrectly) before the value of `localStorage`
    would have been read and applied to the app. The main issue with bugs such as
    this one is that in development they may not reproduce or may be very hard to
    see.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本章之前，我想重点强调为什么正确使用生命周期很重要。实际上，如果我们使用了另一个生命周期，比如`onMounted`，那么在读取并应用`localStorage`的值之前，侧边栏就已经被完全渲染（错误地）了。这类bug的主要问题是，在开发过程中它们可能不会复现，或者非常难以发现。
- en: It is very important when creating code that is going to alter the view of the
    component to ensure that you have used the correct lifecycle and, if working with
    asynchronous data, that the correct loading is defined, or the promise awaited
    before the rest of the component executes. This practice may seem hard to comprehend
    at first, but code practice and mistakes will help you improve your understanding
    of a Vue.js component and improve your skills.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建将要改变组件视图的代码时，确保你已经使用了正确的生活周期，如果处理异步数据，那么在组件的其他部分执行之前，必须定义正确的加载状态，或者等待promise完成。这种做法一开始可能难以理解，但代码实践和错误将帮助你提高对Vue.js组件的理解，并提高你的技能。
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have covered a couple of advanced topics such as slots,
    lifecycles, and refs. The aim of this chapter was not to provide you with all
    the information that you may need on these topics but to introduce you to these
    points so that you can practice them in your next development and continue to
    learn as you expand your knowledge of Vue.js.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了一些高级主题，例如插槽、生命周期和refs。本章的目标并不是提供你在这方面的所有信息，而是让你对这些概念有所了解，以便你在接下来的开发中能够实践它们，并在扩展你对Vue.js知识的过程中继续学习。
- en: We have learned how to use slots to expand the flexibility of our components.
    Slots and named slots can be used for simple cases, such as `<button>`, style
    elements, such as `<div>`, or for more advanced techniques, such as defining a
    page layout with different areas.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何使用插槽来扩展组件的灵活性。插槽和命名插槽可以用于简单的情况，例如`<button>`、样式元素，如`<div>`，或者用于更高级的技术，例如定义具有不同区域的页面布局。
- en: We then moved on to Template `Ref`, a topic that we had partly introduced in
    an earlier chapter. We learned how Template `Ref` can be used to access a component
    DOM element. This is defined as an advanced technique because, with all the available
    features offered by Vue.js, it is uncommon that you would need to use Template
    `Ref` this way.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们继续讨论模板`Ref`，这是一个我们在之前章节中部分介绍过的主题。我们学习了如何使用模板`Ref`来访问组件的DOM元素。这被定义为一种高级技术，因为，在Vue.js提供的所有功能中，你很少需要以这种方式使用模板`Ref`。
- en: Lastly, we went over lifecycles again. Vue.js lifecycles are very important,
    and they require lots of practice to help you understand their usage and, more
    importantly, their order of execution. We have added an extra feature to our Companion
    App so that we can understand one of its use cases and think over the possible
    result that a different lifecycle would have produced.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们再次回顾了生命周期。Vue.js的生命周期非常重要，需要大量的实践来帮助你理解它们的用法以及，更重要的是，它们的执行顺序。我们在我们的伴侣应用中增加了一个额外功能，以便我们能够理解其一个使用案例，并思考如果使用不同的生命周期会产生什么样的可能结果。
- en: In the next chapter, we are going to learn how to define multiple routes with
    **vue-router**. Defining multiple pages is a required step for most applications
    and **vue-router** offers a very simple syntax that will help us achieve this
    functionality within our Companion App.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用**vue-router**定义多个路由。对于大多数应用来说，定义多个页面是一个必要的步骤，而**vue-router**提供了一个非常简单的语法，这将帮助我们在我们的小伴侣应用中实现这一功能。
