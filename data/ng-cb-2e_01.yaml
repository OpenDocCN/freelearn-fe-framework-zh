- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Winning Component Communication
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 赢得组件通信
- en: In this chapter, you’ll master component communication in Angular. You’ll learn
    different techniques to establish communication between components and will learn
    which technique is suitable in which situation. You’ll also learn about the new
    Signals API, which is stable since Angular v17, in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将掌握 Angular 中的组件通信。您将学习不同的技术来建立组件间的通信，并了解在哪种情况下哪种技术是合适的。您还将学习关于自 Angular
    v17 起稳定的新的信号 API 的内容。
- en: 'The following are the recipes we’re going to cover in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下食谱：
- en: Component communication using component **@Input** and **@Output** properties
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用组件 **@Input** 和 **@Output** 属性进行组件通信
- en: Component communication using services
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用服务进行组件通信
- en: Using setters for intercepting input property changes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用设置器来拦截输入属性的变化
- en: Using **ngOnChanges** to intercept input property changes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **ngOnChanges** 来拦截输入属性的变化
- en: Accessing a child component in a parent template via template variables
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过模板变量在父模板中访问子组件
- en: Accessing a child component in a parent component class using **ViewChild**
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **ViewChild** 在父组件类中访问子组件
- en: Standalone components and passing data through route params
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立组件和通过路由参数传递数据
- en: Component communication using signals
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用信号进行组件通信
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For the recipes in this chapter, ensure your setup is complete as per the ''Technical
    Requirements'' in the ''Angular-Cookbook-2E'' GitHub repository. For setup details,
    visit: [https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md).
    The starter code for this chapter is located at [https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter01](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter01).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的食谱，请确保您的设置已按照 'Angular-Cookbook-2E' GitHub 仓库中的 'Technical Requirements'
    完成。有关设置详情，请访问：[https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/docs/technical-requirements.md)。本章的起始代码位于
    [https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter01](https://github.com/PacktPublishing/Angular-Cookbook-2E/tree/main/start/apps/chapter01)。
- en: Component communication using component @Input and @Output properties
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用组件 @Input 和 @Output 属性进行组件通信
- en: You’ll start with an app with a parent component and two child components. You’ll
    then use Angular `@Input` and `@Output` decorators to establish communication
    between them using attributes and **EventEmitter**(s). The flow of the communication
    is shown in *Figure 1.1*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您将从包含父组件和两个子组件的应用开始。然后，您将使用 Angular `@Input` 和 `@Output` 装饰器通过属性和 **EventEmitter**(s)
    建立它们之间的通信。通信流程如图 *图 1.1* 所示。
- en: '![](img/B18469_01_01.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18469_01_01.png)'
- en: 'Figure 1.1: Communication flow using @Input() and @Output() properties'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1：使用 @Input() 和 @Output() 属性的通信流程
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with resides in `start/apps/chapter01/cc-inputs-outputs`
    inside the cloned repository:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的应用位于克隆的仓库中的 `start/apps/chapter01/cc-inputs-outputs`：
- en: Open the code repository in your code editor.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令来启动项目：
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用，您应该看到以下内容：
- en: '![](img/B18469_01_02.png)'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_01_02.png)'
- en: 'Figure 1.2: The cc-inputs-outputs app running on http://localhost:4200'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.2：在 http://localhost:4200 上运行的 cc-inputs-outputs 应用
- en: How to do it…
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'So far, we have an app with `AppComponent`, `NotificationsButtonComponent`,
    and `NotificationsManagerComponent`. While `AppComponent` is the parent of the
    other two components mentioned, there is absolutely no component communication
    between them to sync the notification count value among both components. Let’s
    establish the appropriate communication between them using the following steps:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个包含 `AppComponent`、`NotificationsButtonComponent` 和 `NotificationsManagerComponent`
    的应用。虽然 `AppComponent` 是其他两个组件的父组件，但它们之间完全没有组件通信来同步两个组件中的通知计数值。让我们使用以下步骤建立它们之间适当的通信：
- en: 'We’ll move the `notificationsCount` variable from `NotificationsManagerComponent`
    to the `AppComponent`. To do so, create a `notificationsCount` property in `app.component.ts`
    as follows:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将把 `notificationsCount` 变量从 `NotificationsManagerComponent` 移动到 `AppComponent`。为此，在
    `app.component.ts` 中创建一个 `notificationsCount` 属性，如下所示：
- en: '[PRE1]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, convert the `notificationsCount` property in `notifications-manager.component.ts`
    to `@Input()`, rename it to `count`, and replace its usages as follows:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将 `notifications-manager.component.ts` 中的 `notificationsCount` 属性转换为 `@Input()`，将其重命名为
    `count`，并按以下方式替换其用法：
- en: '[PRE2]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Update `notifications-manager.component.html` to use `count` instead of `notificationsCount`:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `notifications-manager.component.html` 以使用 `count` 而不是 `notificationsCount`：
- en: '[PRE3]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, pass the `notificationsCount` property from `app.component.html` to the
    `<app-notifications-manager>` element as an input:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将 `notificationsCount` 属性从 `app.component.html` 传递到 `<app-notifications-manager>`
    元素作为输入：
- en: '[PRE4]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You could now test whether the value is being correctly passed from `app.component.html`
    to `app-notifications-manager` by assigning the value of `notificationsCount`
    in `app.component.ts` as `10`. You’ll see that in `NotificationsManagerComponent`,
    the initial value shown will be `10`:'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，你可以通过将 `app.component.ts` 中的 `notificationsCount` 的值赋为 `10` 来测试值是否被正确地从 `app.component.html`
    传递到 `app-notifications-manager`。你将看到在 `NotificationsManagerComponent` 中显示的初始值将是
    `10`：
- en: '[PRE5]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, create an `@Input()` in `notifications-button.component.ts` named `count`
    as well:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `notifications-button.component.ts` 中也创建一个名为 `count` 的 `@Input()`：
- en: '[PRE6]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Pass `notificationsCount` to `<app-notifications-button>` as well from `app.component.html`:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `app.component.html` 中也将 `notificationsCount` 传递给 `<app-notifications-button>`：
- en: '[PRE7]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Use the `count` input in `notifications-button.component.html` with the notification
    bell icon:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `notifications-button.component.html` 中的 `count` 输入与通知铃声图标一起：
- en: '[PRE8]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You should now see the value `10` for the notification bell icon count as well.
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你现在应该看到通知铃声图标计数的值也是 `10`。
- en: Right now, if you change the count by adding/removing notifications from `NotificationsManagerComponent`,
    the count on the notification bell icon won’t change.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 目前，如果你通过添加/删除通知从 `NotificationsManagerComponent` 改变计数，通知铃声图标上的计数不会改变。
- en: 'To communicate the change from `NotificationsManagerComponent` to `NotificationsButtonComponent`,
    we’ll use an Angular `@Output()` property now. Use `@Output` and `@EventEmitter`
    from `''@angular/core''` inside `notifications-manager.component.ts`:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了传达从 `NotificationsManagerComponent` 到 `NotificationsButtonComponent` 的变化，我们现在将使用
    Angular 的 `@Output()` 属性。在 `notifications-manager.component.ts` 中使用来自 `'@angular/core'`
    的 `@Output` 和 `@EventEmitter`：
- en: '[PRE9]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, we’ll listen in `app.component.html` for the previously emitted event
    from `NotificationsManagerComponent` and update the `notificationsCount` property
    accordingly:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 `app.component.html` 中监听来自 `NotificationsManagerComponent` 的先前发出的事件，并相应地更新
    `notificationsCount` 属性：
- en: '[PRE10]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Since we’ve listened to the `countChanged` event previously and called the
    `updateNotificationsCount` method, we need to create this method in `app.component.ts`
    and update the value of the `notificationsCount` property accordingly:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们之前已监听 `countChanged` 事件并调用 `updateNotificationsCount` 方法，我们需要在 `app.component.ts`
    中创建此方法并相应地更新 `notificationsCount` 属性的值：
- en: '[PRE11]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works…
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'In order to communicate between components using `@Input()` and `@Output()`
    properties, the data flow will always go *from* the **child components** *to*
    the **parent component via output event emitters** (`@Output()`), **and from the
    parent component to the child component via input bindings** (`@Input()`). In
    general, when two sibling components have to communicate, one of them has to use
    an output emitter to pass the value to the parent, which can then provide the
    new (updated) value *as an input* to the other child components. So, `NotificationsManagerComponent`
    emits the `countChanged` event. `AppComponent` (being the parent component) listens
    for the event and updates the value of `notificationsCount`, which automatically
    updates the `count` property in `NotificationsButtonComponent` because `notificationsCount`
    is being passed as the `@Input()` count to `NotificationsButtonComponent`. *Figure
    1.3* shows the entire process:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 `@Input()` 和 `@Output()` 属性在组件之间进行通信，数据流始终是 *从* 子组件 *到* 父组件通过输出事件发射器（`@Output()`），*从*
    父组件到子组件通过输入绑定（`@Input()`）。一般来说，当两个兄弟组件需要通信时，其中一个必须使用输出发射器将值传递给父组件，然后父组件可以将新的（更新的）值
    *作为输入* 提供给其他子组件。因此，`NotificationsManagerComponent` 发出 `countChanged` 事件。`AppComponent`（作为父组件）监听该事件并更新
    `notificationsCount` 的值，由于 `notificationsCount` 被作为 `@Input()` count 传递给 `NotificationsButtonComponent`，这会自动更新
    `NotificationsButtonComponent` 中的 `count` 属性。*图 1.3* 展示了整个流程：
- en: '![](img/B18469_01_03.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18469_01_03.png)'
- en: 'Figure 1.3: How component communication works with inputs and outputs'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3：组件如何通过输入和输出进行通信
- en: See also
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考内容
- en: How do Angular components communicate? [https://www.thirdrocktechkno.com/blog/how-angular-components-communicate](https://www.thirdrocktechkno.com/blog/how-angular-components-communicate)
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 组件如何通信？[https://www.thirdrocktechkno.com/blog/how-angular-components-communicate](https://www.thirdrocktechkno.com/blog/how-angular-components-communicate)
- en: '*Component Communication in Angular* by Dhananjay Kumar: [https://www.youtube.com/watch?v=I8Z8g9APaDY](https://www.youtube.com/watch?v=I8Z8g9APaDY)'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dhananjay Kumar 的《*Angular 中的组件通信*》：[https://www.youtube.com/watch?v=I8Z8g9APaDY](https://www.youtube.com/watch?v=I8Z8g9APaDY)
- en: Component communication using services
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用服务进行组件通信
- en: In this recipe, you’ll start with an app with a parent component and a child
    component. You’ll then use an Angular service to establish communication between
    them. We’re going to use `BehaviorSubject` and `Observable` streams to communicate
    between components and the service.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将从包含父组件和子组件的应用程序开始。然后，你将使用 Angular 服务在它们之间建立通信。我们将使用 `BehaviorSubject`
    和 `Observable` 流来在组件和服务之间进行通信。
- en: Getting ready
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project for this recipe resides in `start/apps/chapter01/cc-services`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '该菜谱的项目位于 `start/apps/chapter01/cc-services`:'
- en: Open the project in Visual Studio Code.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio Code 中打开项目。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令以启动项目：
- en: '[PRE12]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This should open the app in a new browser tab, and you should see the app as
    follows:'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用程序，你应该看到如下所示的应用程序：
- en: '![](img/B18469_01_04.png)'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_01_04.png)'
- en: 'Figure 1.4: The cc-services app running on http://localhost:4200'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.4：运行在 http://localhost:4200 上的 cc-services 应用程序
- en: How to do it…
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Similar to the previous recipe, we have an app with `AppComponent`, `NotificationsButtonComponent`,
    and `NotificationsManagerComponent`. `AppComponent` is the parent of the other
    two components mentioned previously, and we need to establish the appropriate
    communication between them using the following steps:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的菜谱类似，我们有一个包含 `AppComponent`、`NotificationsButtonComponent` 和 `NotificationsManagerComponent`
    的应用程序。`AppComponent` 是前面提到的其他两个组件的父组件，我们需要使用以下步骤在它们之间建立适当的通信：
- en: 'From the terminal, make sure you are at the root of the workspace, and create
    a new service called `NotificationsService` by running the following command:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从终端确保你位于工作区的根目录，并运行以下命令创建一个名为 `NotificationsService` 的新服务：
- en: '[PRE13]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create a `BehaviorSubject` named `count$` inside `notifications.service.ts`
    and initialize it with `0` (a `BehaviorSubject` requires an initial value):'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `notifications.service.ts` 中创建一个名为 `count$` 的 `BehaviorSubject`，并使用 `0` 初始化它（`BehaviorSubject`
    需要一个初始值）：
- en: '[PRE14]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Rename the `notificationsCount` property in `notifications-manager.component.ts`
    to `notificationsCount$` and assign the services’s `count$` property to it as
    follows:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `notifications-manager.component.ts` 中的 `notificationsCount` 属性重命名为 `notificationsCount$`，并将其分配给服务的
    `count$` 属性，如下所示：
- en: '[PRE15]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Modify the functions with the `NotificationsManagerComponent` to update the
    `Behavior Subject` value as follows:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改与 `NotificationsManagerComponent` 相关的函数，以更新 `Behavior Subject` 的值，如下所示：
- en: '[PRE16]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Use the `notificationsCount$` Observable in `notifications-manager.component.html`
    with the `async` pipe to show its value:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `notifications-manager.component.html` 中使用 `async` 管道，利用 `notificationsCount$`
    可观察对象来显示其值：
- en: '[PRE17]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, similarly inject `NotificationsService` in `notifications-button.component.ts`,
    create an Observable named `notificationsCount$` inside `NotificationsButtonComponent`,
    and assign the service’s `count$` Observable to it:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，类似地，在 `notifications-button.component.ts` 中注入 `NotificationsService`，在 `NotificationsButtonComponent`
    中创建一个名为 `notificationsCount$` 的可观察对象，并将其分配给服务的 `count$` 可观察对象：
- en: '[PRE18]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Use the `notificationsCount$` Observable in `notifications-button.component.html`
    with the `async` pipe:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `notifications-button.component.html` 中使用 `async` 管道，利用 `notificationsCount$`
    可观察对象：
- en: '[PRE19]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you refresh the app now, you should be able to see the value `0` for both
    the notifications manager component and the notifications button component.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你现在刷新应用程序，你应该能够在通知管理组件和通知按钮组件中看到值 `0`。
- en: 'Change the initial value for the `count BehaviorSubject` to `10` and see whether
    that reflects in both components:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `count BehaviorSubject` 的初始值更改为 `10` 并查看它是否在两个组件中反映：
- en: '[PRE20]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works…
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: '`BehaviorSubject` is a special type of **Observable** that requires an initial
    value and can be used by many subscribers. In this recipe, we create a `BehaviorSubject`
    to store the value of the notifications count.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`BehaviorSubject` 是一种特殊的 **Observable** 类型，它需要一个初始值并且可以被多个订阅者使用。在这个菜谱中，我们创建一个
    `BehaviorSubject` 来存储通知计数器的值。'
- en: Once we have created the `BehaviorSubject` named `count$`, we inject `NotificationsService`
    in our components using the (fairly new) `inject` function and assign the `count$`
    property of the service to a property of the components. This allows us to work
    with the `BehaviorSubject` in both the `NotificationsButtonComponent` and the
    `NotificationsManagerComponent`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了名为 `count$` 的 `BehaviorSubject`，我们使用（相对较新的）`inject` 函数在我们的组件中注入 `NotificationsService`，并将服务的
    `count$` 属性分配给组件的一个属性。这允许我们在 `NotificationsButtonComponent` 和 `NotificationsManagerComponent`
    中使用 `BehaviorSubject`。
- en: Then we use the `notificationsCount$` property in the templates of both above-mentioned
    functions to be able to render the count value. Notice that we use the **async**
    pipe in the templates. This helps Angular to let the template subscribe to the
    `BehaviorSubject` when the component is rendered and to unsubscribe automatically
    when the component is destroyed.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在上述两个函数的模板中使用 `notificationsCount$` 属性，以便能够渲染计数值。注意，我们在模板中使用了 **async**
    管道。这有助于 Angular 在组件渲染时让模板订阅 `BehaviorSubject`，并在组件销毁时自动取消订阅。
- en: To update the value of the `BehaviorSubject`, we use its `next` method by providing
    the new value to be set. As soon as the value of `count$` is updated, the components
    rerender the new value, thanks to RxJS and Angular’s change detection.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新 `BehaviorSubject` 的值，我们通过提供要设置的新值来使用其 `next` 方法。一旦 `count$` 的值被更新，组件就会因为
    RxJS 和 Angular 的变更检测而重新渲染新值。
- en: '![](img/B18469_01_05.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18469_01_05.png)'
- en: 'Figure 1.5: How component communication works using an Angular service'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5：使用 Angular 服务进行组件通信的方式
- en: See also
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'Subjects from RxJS’s official documentation: [https://www.learnrxjs.io/learn-rxjs/subjects](https://www.learnrxjs.io/learn-rxjs/subjects)'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自 RxJS 官方文档的主题：[https://www.learnrxjs.io/learn-rxjs/subjects](https://www.learnrxjs.io/learn-rxjs/subjects)
- en: '`BehaviorSubject` versus **Observable** on Stack Overflow: [https://stackoverflow.com/a/40231605](https://stackoverflow.com/a/40231605)'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BehaviorSubject` 与 **Observable** 在 Stack Overflow 上的比较：[https://stackoverflow.com/a/40231605](https://stackoverflow.com/a/40231605)'
- en: Using setters for intercepting input property changes
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用设置器来拦截输入属性更改
- en: In this recipe, you will learn how to intercept changes in an `@Input` passed
    from a parent component and how to perform some action on this event. We’ll intercept
    the `vName` input passed from the `VersionControlComponent` parent component to
    the `VcLogsComponent` child component. We’ll use *setters* to generate a log whenever
    the value of `vName` changes and will show those logs in the child component.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何拦截从父组件传递的 `@Input` 的更改，以及如何在此事件上执行某些操作。我们将拦截从 `VersionControlComponent`
    父组件传递到 `VcLogsComponent` 子组件的 `vName` 输入。我们将使用 *设置器* 在 `vName` 的值更改时生成日志，并在子组件中显示这些日志。
- en: Getting ready
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project for this recipe resides in `start/apps/chapter01/cc-setters`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的项目位于 `start/apps/chapter01/cc-setters`：
- en: Open the project in Visual Studio Code.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio Code 中打开项目。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令以启动项目：
- en: '[PRE21]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This should open the app in a new browser tab, and you should see the app as
    follows:'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该会在新浏览器标签页中打开应用程序，你应该看到以下应用程序：
- en: '![](img/B18469_01_06.png)'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_01_06.png)'
- en: 'Figure 1.6: The cc-setters app running on http://localhost:4200'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.6：在 http://localhost:4200 上运行的 cc-setters 应用程序
- en: How to do it…
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We’ll first create a `logs` array in `VcLogsComponent` as follows to store
    all the logs that we’ll display later using our template:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先在 `VcLogsComponent` 中创建一个 `logs` 数组，如下所示，以存储我们稍后将在模板中显示的所有日志：
- en: '[PRE22]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let’s modify the HTML template so we can show the logs. Modify the `vc-logs.component.html`
    file as follows:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们修改 HTML 模板，以便我们可以显示日志。按照以下方式修改 `vc-logs.component.html` 文件：
- en: '[PRE23]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following screenshot shows the app with the logs container:'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了带有日志容器的应用程序：
- en: '![](img/B18469_01_07.png)'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_01_07.png)'
- en: 'Figure 1.7: The cc-setters app with logs container'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.7：带有日志容器的 cc-setters 应用程序
- en: 'Now, we’ll convert the `@Input()` in `vc-logs.component.ts` to use a *getter*
    and *setter* so we can intercept the input changes. To do that, we’ll also create
    an internal property named `_vName`. The code should look as follows:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将`vc-logs.component.ts`中的`@Input()`转换为使用*getter*和*setter*，以便我们可以拦截输入变化。为此，我们还将创建一个名为`_vName`的内部属性。代码应如下所示：
- en: '[PRE24]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Modify the `setter` to create some logs now. We’ll push a new log to the `logs`
    array whenever the value of `vName` changes. For the first time, we’ll push a
    log saying `''initial version is x.x.x''`:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改setter以创建一些日志。每当`vName`的值发生变化时，我们将向`logs`数组中推送一个新的日志。第一次，我们将推送一条日志，内容为`'initial
    version is x.x.x'`：
- en: '[PRE25]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, every time we change the version name, we need to show a different message
    saying `''version changed to x.x.x''`. *Figure 1.8* shows the final output. To
    make the required changes, let’s modify the `vName` setter as follows:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，每次我们更改版本名称时，都需要显示不同的消息，内容为`'version changed to x.x.x'`。*图1.8*显示了最终输出。为了进行必要的更改，让我们修改`vName`setter如下：
- en: '[PRE26]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following screenshot shows the final output:'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了最终输出：
- en: '![](img/B18469_01_08.png)'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_01_08.png)'
- en: 'Figure 1.8: Final output using the setter'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图1.8：使用setter的最终输出
- en: How it works…
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: JavaScript has `getters` as functions that return a dynamically computed value.
    It also has `setters` as functions that execute some logic when the targeted property
    changes. Angular uses TypeScript, which is a superset of JavaScript and Angular’s
    `@Input()` properties can also use `getters` and `setters` since they’re basically
    properties of the provided class.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript有`getters`作为返回动态计算值的函数。它也有`setters`作为在目标属性变化时执行一些逻辑的函数。Angular使用TypeScript，它是JavaScript的超集，Angular的`@Input()`属性也可以使用`getters`和`setters`，因为它们基本上是提供类中的属性。
- en: '![](img/B18469_01_09.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18469_01_09.png)'
- en: 'Figure 1.9: Diagram explaining the flow of data in the cc-setters app'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.9：解释cc-setters应用中数据流的图表
- en: For this recipe, we use a getter and a setter for our input named `vName` so
    whenever the input changes, we use the setter function to push the new version
    to the logs list. Then we use the `logs` array in the template to render the list
    of logs on the view.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们为名为`vName`的输入使用getter和setter，所以每当输入发生变化时，我们使用setter函数将新版本推送到日志列表。然后我们在模板中使用`logs`数组来渲染视图上的日志列表。
- en: It is always a good idea to use a private variable/property along with the property
    using getters and setters. This is so that we can modify the private property
    in our component and the template only accesses the public property using the
    getter.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 总是使用私有变量/属性与使用getters和setters的属性一起使用是一个好主意。这样我们就可以在我们的组件中修改私有属性，而模板只通过getter访问公共属性。
- en: See also
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Angular’s official docs for setters: [https://angular.io/guide/component-interaction#intercept-input-property-changes-with-a-setter](https://angular.io/guide/component-interaction#intercept-input-property-changes-with-a-setter)'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular的setter官方文档：[https://angular.io/guide/component-interaction#intercept-input-property-changes-with-a-setter](https://angular.io/guide/component-interaction#intercept-input-property-changes-with-a-setter)
- en: 'Mozilla’s official docs for a getter function: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get)'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mozilla的getter函数官方文档：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get)
- en: 'Mozilla’s official docs for a setter function: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set)'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mozilla的setter函数官方文档：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set)
- en: Using ngOnChanges to intercept input property changes
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ngOnChanges拦截输入属性变化
- en: In this recipe, you’ll learn how to use `ngOnChanges` to intercept changes using
    the `SimpleChanges` API. We’ll listen to a `vName` input passed from the `VersionControlComponent`
    parent component to the `VcLogsComponent` child component.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，您将学习如何使用`ngOnChanges`通过`SimpleChanges` API拦截变化。我们将监听从`VersionControlComponent`父组件传递到`VcLogsComponent`子组件的`vName`输入。
- en: Getting ready
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with resides in `start/apps/chapter01/cc-ng-on-changes`
    inside the cloned repository:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的应用位于克隆的仓库中的`start/apps/chapter01/cc-ng-on-changes`：
- en: Open the code repository in your code editor.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令以启动项目：
- en: '[PRE27]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用，你应该看到以下内容：
- en: '![](img/B18469_01_10.png)'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_01_10.png)'
- en: 'Figure 1.10: The cc-ng-on-changes app running on http://localhost:4200'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图1.10：运行在http://localhost:4200上的cc-ng-on-changes应用
- en: How to do it…
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We’ll first create a logs array in `VcLogsComponent` as follows to store all
    the logs that we’ll display later using our template:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先在`VcLogsComponent`中创建一个`logs`数组，如下所示，以存储我们稍后将在模板中使用的所有日志：
- en: '[PRE28]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let’s create the HTML for where we’ll show the logs. Let’s add the `logs` container
    and log items using the following code to `vc-logs.component.html`:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建显示日志的HTML。让我们在`vc-logs.component.html`中使用以下代码添加`logs`容器和日志项：
- en: '[PRE29]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following screenshot shows the app with the `logs` container:'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了带有`logs`容器的应用：
- en: '![](img/B18469_01_11.png)'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_01_11.png)'
- en: 'Figure 1.11: The cc-ng-on-changes app with logs container'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图1.11：带有日志容器的cc-ng-on-changes应用
- en: 'Now, let’s implement `ngOnChanges` using simple changes in `VcLogsComponent`
    as follows in the `vc-logs.component.ts` file:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在`VcLogsComponent`中实现`ngOnChanges`，如下所示，在`vc-logs.component.ts`文件中使用简单的更改：
- en: '[PRE30]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We now can add a log for the initial value of the `vName` input saying `''initial
    version is x.x.x''`. We do this by checking whether it is the initial value using
    the `isFirstChange` method as follows:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以为`vName`输入的初始版本添加一个日志，表示“初始版本是x.x.x”。我们通过使用`isFirstChange`方法检查它是否是初始值来完成此操作，如下所示：
- en: '[PRE31]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let’s handle the case where we update the version after the initial value is
    assigned. For that, we’ll add another log that says `''version changed to x.x.x''`
    using an `else` condition, as follows:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们处理在初始值分配之后更新版本的情况。为此，我们将添加另一个日志，表示“版本已更改为x.x.x”，使用`else`条件，如下所示：
- en: '[PRE32]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following screenshot shows the final output:'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了最终输出：
- en: '![](img/B18469_01_12.png)'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_01_12.png)'
- en: 'Figure 1.12: Final output using ngOnChanges'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图1.12：使用`ngOnChanges`的最终输出
- en: How it works…
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: '`ngOnChanges` is one of the many **lifecycle hooks** that Angular provides
    out of the box. It triggers even before the `ngOnInit` hook. So, you get the *initial
    values* in the first call and the *updated values* later on. Whenever any of the
    inputs change, the `ngOnChanges` callback is triggered with `SimpleChanges`. And
    in the changes, for each `@Input()`, you can get the previous value, the current
    value, and a *Boolean* representing whether this is the first change to the input
    (that is, the initial value). When we update the value of the `vName` input in
    the parent, `ngOnChanges` gets called with the updated value. Then, based on the
    situation, we add an appropriate log into our `logs` array and display it on the
    UI.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngOnChanges`是Angular提供的许多**生命周期钩子**之一。它在`ngOnInit`钩子之前触发。因此，在第一次调用中，你将获得*初始值*，稍后获得*更新后的值*。每当任何输入发生变化时，`ngOnChanges`回调都会使用`SimpleChanges`触发。在变化中，对于每个`@Input()`，你可以获取前一个值、当前值以及一个表示这是否是输入的第一个更改（即初始值）的*布尔值*。当我们更新父级中的`vName`输入值时，`ngOnChanges`会使用更新后的值被调用。然后，根据情况，我们将适当的日志添加到我们的`logs`数组中，并在UI上显示它。'
- en: '![](img/B18469_01_13.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18469_01_13.png)'
- en: 'Figure 1.13: How ngOnChanges pushes the new version to the logs array'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.13：`ngOnChanges`如何将新版本推送到日志数组
- en: See also
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Angular lifecycle hooks: [https://angular.io/guide/lifecycle-hooks](https://angular.io/guide/lifecycle-hooks)'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular生命周期钩子：[https://angular.io/guide/lifecycle-hooks](https://angular.io/guide/lifecycle-hooks)
- en: 'Using change detection hooks with `ngOnChanges`: [https://angular.io/guide/lifecycle-hooks#using-change-detection-hooks](https://angular.io/guide/lifecycle-hooks#using-change-detection-hooks)'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ngOnChanges`生命周期钩子进行变更检测：[https://angular.io/guide/lifecycle-hooks#using-change-detection-hooks](https://angular.io/guide/lifecycle-hooks#using-change-detection-hooks)
- en: '**SimpleChanges** API reference: [https://angular.io/api/core/SimpleChanges](https://angular.io/api/core/SimpleChanges
    )'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SimpleChanges** API参考：[https://angular.io/api/core/SimpleChanges](https://angular.io/api/core/SimpleChanges)'
- en: Accessing a child component in a parent template via template variables
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过模板变量在父模板中访问子组件
- en: In this recipe, you’ll learn how to use **Angular template reference variables**
    to access a child component in the parent component’s template. You’ll start with
    an app having `AppComponent` as the parent component and `GalleryComponent` as
    the child component. You’ll then create a template variable for the child component
    in the parent’s template to access it and perform some actions in the component
    class.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你将学习如何使用 **Angular 模板引用变量** 来在父组件的模板中访问子组件。你将从具有 `AppComponent` 作为父组件和
    `GalleryComponent` 作为子组件的应用程序开始。然后你将在父模板中为子组件创建一个模板变量来访问它并在组件类中执行一些操作。
- en: Getting ready
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with resides in `start/apps/chapter01/cc-template-vars`
    inside the cloned repository:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的应用程序位于克隆的仓库中的 `start/apps/chapter01/cc-template-vars` 目录内：
- en: Open the code repository in your code editor.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令以启动项目：
- en: '[PRE33]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This should open the app in a new browser tab, and you should see the following:'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用程序，你应该看到以下内容：
- en: '![](img/B18469_01_14.png)'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_01_14.png)'
- en: 'Figure 1.14: The cc-template-vars app running on http://localhost:4200'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.14：在 http://localhost:4200 上运行的 cc-template-vars 应用程序
- en: Click the buttons at the top to see the respective console logs. This shows
    that we have click handlers already bound to the buttons.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 点击顶部的按钮以查看相应的控制台日志。这表明我们已经将点击处理程序绑定到了按钮上。
- en: How to do it…
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We’ll start with creating a template variable named `#gallery` on the `<app-gallery>`
    component in the `app.component.html` file, as follows:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在 `app.component.html` 文件中的 `<app-gallery>` 组件上创建一个名为 `#gallery` 的模板变量，如下所示：
- en: '[PRE34]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Modify the `addNewPicture` and `removeFirstPicture` methods in `app.component.ts`
    to accept an argument named `gallery`. This is so that we can pass the template
    variable `#gallery` to them from `app.component.html` when we click the buttons.
    The code should look as follows:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `app.component.ts` 中的 `addNewPicture` 和 `removeFirstPicture` 方法，使其接受一个名为
    `gallery` 的参数。这样我们就可以在点击按钮时，从 `app.component.html` 将模板变量 `#gallery` 传递给它们。代码如下：
- en: '[PRE35]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, let’s pass the `#gallery` template variable from `app.component.html`
    to the click handlers for both buttons as follows:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将 `#gallery` 模板变量从 `app.component.html` 传递给两个按钮的点击处理程序，如下所示：
- en: '[PRE36]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '![](img/B18469_01_15.png)'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_01_15.png)'
- en: 'Figure 1.15: Console log on clicking the Add Picture button'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.15：点击添加图片按钮时的控制台日志
- en: 'We can now implement the code for adding a new picture. For this, we’ll access
    `GalleryComponent` class’s `generateImage` method and add a new item to the `pictures`
    array as the first element. The code is as follows:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以实现添加新图片的代码。为此，我们将访问 `GalleryComponent` 类的 `generateImage` 方法，并将一个新项目作为第一个元素添加到
    `pictures` 数组中。代码如下：
- en: '[PRE37]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'For removing the first item from the array, we’ll use the JavaScript array
    class’s `shift` method on the `pictures` array in the `GalleryComponent` class.
    The code looks as follows:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了从数组中移除第一个项目，我们将在 `GalleryComponent` 类中的 `pictures` 数组上使用 JavaScript 数组类的 `shift`
    方法。代码如下：
- en: '[PRE38]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How it works…
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'A **template reference variable** is often a reference to a DOM element within
    a template. It can also refer to a component or directive in Angular (source:
    [https://angular.io/guide/template-reference-variables](https://angular.io/guide/template-reference-variables)).'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**模板引用变量** 通常是指向模板中 DOM 元素的引用。它也可以是指向 Angular 中的组件或指令（来源：[https://angular.io/guide/template-reference-variables](https://angular.io/guide/template-reference-variables)）。'
- en: In this recipe, we create a reference (variable) to the gallery component in
    our `app.component.html` by putting it on the `<app-gallery>` tag. And that tag
    is an Angular component in this case. After referencing it with the variable in
    our template, we pass the reference (template variable) to the functions in our
    component as the function arguments.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们通过在 `<app-gallery>` 标签上创建一个引用（变量）来在 `app.component.html` 中引用我们的画廊组件。在这个例子中，这个标签是一个
    Angular 组件。在模板中用变量引用它之后，我们将这个引用（模板变量）作为函数参数传递给组件中的函数。
- en: We then access the properties and the methods of `GalleryComponent` by using
    the passed template variable. You can see that we are able to add and remove items
    from the `pictures` array that resides in `GalleryComponent` directly from `AppComponent`
    – i.e., we’re accessing the `GalleryComponent`'s properties and methods from the
    parent (`App`) component.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后通过传递的模板变量来访问 `GalleryComponent` 的属性和方法。您可以看到，我们能够直接从 `AppComponent` 中添加和移除位于
    `GalleryComponent` 中的 `pictures` 数组中的项目——即，我们是从父组件（`App`）中访问 `GalleryComponent`
    的属性和方法。
- en: See also
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Angular template variables: [https://angular.io/guide/template-reference-variables](https://angular.io/guide/template-reference-variables)'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 模板变量：[https://angular.io/guide/template-reference-variables](https://angular.io/guide/template-reference-variables)
- en: 'Angular template statements: [https://angular.io/guide/template-statements](https://angular.io/guide/template-statements)'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 模板语句：[https://angular.io/guide/template-statements](https://angular.io/guide/template-statements)
- en: Accessing a child component in a parent component class using ViewChild
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在父组件类中使用 ViewChild 访问子组件
- en: In this recipe, you’ll learn how to use the `ViewChild` decorator to access
    a child component in a parent component’s class. You’ll start with an app that
    has `AppComponent` as the parent component and `GalleryComponent` as the child
    component. You’ll then create a `ViewChild` for the child component in the parent’s
    component class to access it and perform some actions.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，您将学习如何使用 `ViewChild` 装饰器在父组件类中访问子组件。您将从具有 `AppComponent` 作为父组件和 `GalleryComponent`
    作为子组件的应用程序开始。然后，您将在父组件类中为子组件创建一个 `ViewChild` 以访问它并执行一些操作。
- en: Getting ready
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project that we are going to work with resides in `chapter01/start_here/cc-view-child`
    inside the cloned repository:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的项目位于克隆的仓库中的 `chapter01/start_here/cc-view-child`：
- en: Open the code repository in your code editor.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令以运行项目：
- en: '[PRE39]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This should open the app in a new browser tab, and you should see something
    like the following:'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签页中打开应用程序，您应该看到以下内容：
- en: '![](img/B18469_01_16.png)'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_01_16.png)'
- en: 'Figure 1.16: The cc-view-child app running on http://localhost:4200'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.16：在 http://localhost:4200 上运行的 cc-view-child 应用
- en: Click the buttons at the top to see the respective console logs.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 点击顶部的按钮以查看相应的控制台日志。
- en: How to do it…
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'We’ll start with importing `GalleryComponent` into our `app.component.ts` file
    so we can create a `ViewChild` for it:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从将 `GalleryComponent` 导入到我们的 `app.component.ts` 文件开始，这样我们就可以为它创建一个 `ViewChild`：
- en: '[PRE40]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To handle adding new pictures, we will use the gallery `ViewChild` in the `addNewPicture`
    method inside `AppComponent`. We will add a new picture to the top of that array
    using the `generateImage` method of `GalleryComponent`, as follows:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了处理添加新图片，我们将在 `AppComponent` 中的 `addNewPicture` 方法中使用 gallery `ViewChild`。我们将使用
    `GalleryComponent` 的 `generateImage` 方法将新图片添加到数组的顶部，如下所示：
- en: '[PRE41]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To handle removing pictures, we’ll add the logic to the `removeFirstPicture`
    method inside the `AppComponent` class. We’ll use the `Array.prototype.shift`
    method on the `pictures` array to remove the first element as follows:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了处理移除图片，我们将在 `AppComponent` 类中的 `removeFirstPicture` 方法中添加逻辑。我们将使用 `Array.prototype.shift`
    方法在 `pictures` 数组上移除第一个元素，如下所示：
- en: '[PRE42]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: How it works…
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: '`ViewChild()` is a decorator that Angular provides to access child components
    used in the template of a parent component. It configures a **view query** for
    the Angular change detector. The change detector tries to find the first element
    matching the query and assigns it to the property associated with the `ViewChild()`
    decorator. In our recipe, we create a `ViewChild` by providing `GalleryComponent`
    as the query parameter, that is, `ViewChild(GalleryComponent)`. This allows the
    Angular change detector to find the `<app-gallery>` element inside the `app.component.html`
    template, and then it assigns it to the `gallery` property within the `AppComponent`
    class. It is important to define the `gallery` property’s type as `GalleryComponent`
    so we can easily use that in the component later with all the TypeScript magic.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewChild()` 是 Angular 提供的一个装饰器，用于访问在父组件模板中使用的子组件。它为 Angular 的变更检测器配置了一个 **视图查询**。变更检测器试图找到与查询匹配的第一个元素，并将其分配给与
    `ViewChild()` 装饰器关联的属性。在我们的教程中，我们通过提供 `GalleryComponent` 作为查询参数创建了一个 `ViewChild`，即
    `ViewChild(GalleryComponent)`。这允许 Angular 变更检测器在 `app.component.html` 模板中找到 `<app-gallery>`
    元素，然后将其分配给 `AppComponent` 类中的 `gallery` 属性。定义 `gallery` 属性的类型为 `GalleryComponent`
    非常重要，这样我们就可以在组件中轻松地使用它，并利用 TypeScript 的所有魔法。'
- en: The view query is executed after the `ngOnInit` lifecycle hook and before the
    `ngAfterViewInit` hook.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 视图查询在 `ngOnInit` 生命周期钩子之后和 `ngAfterViewInit` 钩子之前执行。
- en: See also
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Angular `ViewChild`: [https://angular.io/api/core/ViewChild](https://angular.io/api/core/ViewChild)'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular `ViewChild`：[https://angular.io/api/core/ViewChild](https://angular.io/api/core/ViewChild)
- en: 'Array’s shift method: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/shift](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/shift)'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组的 `shift` 方法：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/shift](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/shift)
- en: Standalone components and passing data through route params
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 独立组件和通过路由参数传递数据
- en: In this recipe, we’ll learn how to work with **standalone components** and how
    to pass some data using route parameters to other components. Note that this is
    not limited to standalone components and can be achieved with regular components
    as well. The app’s starter code gives us a list view of some users. Our task is
    to implement the `details` view using the route parameters.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习如何使用 **独立组件** 并如何通过路由参数传递一些数据到其他组件。请注意，这不仅仅限于独立组件，也可以用常规组件实现。应用程序的起始代码为我们提供了一个用户列表视图。我们的任务是使用路由参数实现
    `details` 视图。
- en: Getting ready
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project that we are going to work with resides in `start/apps/cc-standalone-components`
    inside the cloned repository:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的项目位于克隆的仓库中的 `start/apps/cc-standalone-components` 目录下：
- en: Open the code repository in your code editor.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令来运行项目：
- en: '[PRE43]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You should be able to see the app as follows:'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您应该能够看到应用程序如下所示：
- en: '![](img/B18469_01_17.png)'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_01_17.png)'
- en: 'Figure 1.17: Users list is shown for the app cc-standalone-components'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.17：显示应用程序 cc-standalone-components 的用户列表
- en: How to do it…
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Create the `UserDetails` component/page where we will see individual user’s
    details later. Run the following command to create it from the project root:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `UserDetails` 组件/页面，稍后我们将在这里查看单个用户的详细信息。从项目根目录运行以下命令来创建它：
- en: '[PRE44]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If asked, choose the `@nx/angular:component` `schematics` and choose the “As
    provided” action.
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果被问及，请选择 `@nx/angular:component` 的 `schematics` 并选择“按提供”操作。
- en: 'We’re now going to create a route for the `UserDetailsComponent`. Update the
    `app.routes.ts` file as follows:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将创建一个路由用于 `UserDetailsComponent`。按照以下方式更新 `app.routes.ts` 文件：
- en: '[PRE45]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now add `RouterModule` as an import in the `UsersComponent` as follows in the
    `users.component.ts` file:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在 `users.component.ts` 文件中将 `RouterModule` 作为导入添加到 `UsersComponent` 中，如下所示：
- en: '[PRE46]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Add a `routerLink` for each user item in the users list in `users.component.html`
    to navigate to the user details page, as follows:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `users.component.html` 文件中为用户列表中的每个用户项添加 `routerLink` 以导航到用户详情页面，如下所示：
- en: '[PRE47]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Add the `RouterModule` in the imports of the `UserDetailsComponent` class in
    the file `user-details.component.ts`:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `user-details.component.ts` 文件中 `UserDetailsComponent` 类的导入中添加 `RouterModule`：
- en: '[PRE48]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Update the `UserDetailsComponent` further to create an **Observable** to keep
    the currently displayed user data:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进一步更新 `UserDetailsComponent` 以创建一个用于保持当前显示用户数据的 **可观察对象**：
- en: '[PRE49]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now create a `constructor` function to get the `uuid` from the route parameters
    and to get and set the currently displayed user data as follows:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个 `constructor` 函数，从路由参数中获取 `uuid`，并获取和设置当前显示的用户数据，如下所示：
- en: '[PRE50]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Finally, let’s update the template of the `UserDetailsComponent` in the `user-details.component.html`
    file to show the user as follows:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们更新 `user-details.component.html` 文件中 `UserDetailsComponent` 的模板，以如下方式显示用户：
- en: '[PRE51]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '![](img/B18469_01_18.png)'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_01_18.png)'
- en: 'Figure 1.18: User Details paging showing the currently selected user information'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.18：用户详细信息分页显示当前选定的用户信息
- en: How it works…
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The application’s starter template contained a `UsersComponent` configured to
    be shown on the home route (**/**). We first create the `UserDetailsComponent`
    using the Nx CLI command `nx g c user-details --standalone --directory apps/chapter01/cc-standalone-components/src/app/user-details`.
    Notice that this uses `--standalone` to let Angular know that we need a standalone
    component. We also use `--directory apps/chapter01/cc-standalone-components/src/app/user-details`;
    since we’re working with an Nx repository, we need to specify which exact directory
    we’re creating the component in.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的起始模板包含一个配置为在主页路由（**/**）上显示的 `UsersComponent`。我们首先使用 Nx CLI 命令 `nx g c user-details
    --standalone --directory apps/chapter01/cc-standalone-components/src/app/user-details`
    创建 `UserDetailsComponent`。注意，这使用 `--standalone` 来让 Angular 知道我们需要一个独立组件。我们还使用
    `--directory apps/chapter01/cc-standalone-components/src/app/user-details`；因为我们正在使用
    Nx 仓库，我们需要指定我们创建组件的确切目录。
- en: Then we add the route for the `UserDetailsComponent` in the `app.routes.ts`
    file. Notice that we use `':uuid'` as the path for this route. This would result
    in an example route `http://localhost:4200/abc123` showing the component, and
    the value of `uuid` becomes `abc123` as the route parameter. We then import the
    `RouterModule` in both `UserDetailsComponent` and `UsersComponent` classes in
    the decorator metadata. If you’ve worked with Angular before, you may be thinking
    that this usually is imported in an `NgModule`. Well, you’re right. But since
    these are standalone components, they need to have their own imports handled since
    they’re not part of any `NgModule` themselves.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在 `app.routes.ts` 文件中添加 `UserDetailsComponent` 的路由。注意，我们使用 `':uuid'` 作为此路由的路径。这将导致一个示例路由
    `http://localhost:4200/abc123` 显示组件，而 `uuid` 的值变为 `abc123` 作为路由参数。然后我们在 `UserDetailsComponent`
    和 `UsersComponent` 类的装饰器元数据中导入 `RouterModule`。如果你之前使用过 Angular，你可能认为这通常是在 `NgModule`
    中导入的。嗯，你是对的。但是，由于这些是独立组件，它们需要有自己的导入处理，因为它们本身不是任何 `NgModule` 的一部分。
- en: We then add a `routerLink` for each user item on the home route (in the `UsersComponent`
    template) to navigate to the user’s detail page passing the user’s ID as the `uuid`
    parameter. The final step is then to retrieve the `uuid` parameter from the `ActivatedRoute`
    service and to get the desired user using the `uuid` (the ID of the user). You’ll
    notice that we execute the `find` method on the `USERS` array to find the desired
    user by `uuid`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在主页路由（在 `UsersComponent` 模板）上的每个用户项添加 `routerLink` 以导航到用户的详细信息页面，并将用户的
    ID 作为 `uuid` 参数传递。接下来的步骤是从 `ActivatedRoute` 服务中检索 `uuid` 参数，并使用 `uuid`（用户的 ID）获取所需用户。你会注意到我们在
    `USERS` 数组上执行 `find` 方法，通过 `uuid` 查找所需用户。
- en: In the end, we modify the `user-details.component.html` file to update the template
    to show the desired user on the view. Easy peasy!
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们修改 `user-details.component.html` 文件以更新模板，显示视图上所需用户。简单易行！
- en: See also
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Standalone Components - Angular Official: [https://angular.io/guide/standalone-components](https://angular.io/guide/standalone-components)'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立组件 - Angular 官方：[https://angular.io/guide/standalone-components](https://angular.io/guide/standalone-components)
- en: 'Getting started with Angular standalone components: [https://www.youtube.com/watch?v=x5PZwb4XurU](https://www.youtube.com/watch?v=x5PZwb4XurU)'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用 Angular 独立组件：[https://www.youtube.com/watch?v=x5PZwb4XurU](https://www.youtube.com/watch?v=x5PZwb4XurU)
- en: Component communication using signals
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用信号进行组件通信
- en: '**Signals** are a powerful addition in the Angular ecosystem. They are also
    more efficient than regular Angular class properties because when you change the
    value of a signal, Angular will only notify the components that are subscribed
    to that signal to run the change detection. This can improve the performance of
    your application, especially if there are many components that are subscribed
    to the signal. In this recipe, we will work with Angular Signals to achieve a
    few interesting results. We will show the number of the finished tasks against
    total tasks. And we will show a message when all tasks are completed. Let’s do
    this!'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**信号** 是 Angular 生态系统中的一个强大补充。它们也比常规的 Angular 类属性更高效，因为当你改变信号值时，Angular 只会通知订阅了该信号的组件来运行变更检测。这可以提高你应用程序的性能，特别是如果有许多组件订阅了该信号。在这个菜谱中，我们将使用
    Angular 信号来实现一些有趣的结果。我们将显示完成任务的数目与总任务数。当所有任务都完成时，我们还将显示一条消息。让我们开始吧！'
- en: Getting ready
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The app that we are going to work with resides in `start/apps/chapter01/ng-cc-signals`
    inside the cloned repository. Perform the following steps to get started:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要工作的应用程序位于克隆的仓库中的 `start/apps/chapter01/ng-cc-signals` 目录内。执行以下步骤开始：
- en: Open the code repository in your code editor.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码编辑器中打开代码仓库。
- en: 'Open the terminal, navigate to the code repository directory, and run the following
    command to serve the project:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，导航到代码仓库目录，并运行以下命令来运行项目：
- en: '[PRE52]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This should open the app a new tab in the browser should see the following
    at `http://localhost:4200`:'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该会在浏览器中打开一个新标签页，你应该在 `http://localhost:4200` 看到以下内容：
- en: '![](img/B18469_01_19.png)'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_01_19.png)'
- en: 'Figure 1.19: ng-cc-signals app running on http://localhost:4200'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.19：ng-cc-signals 应用在 http://localhost:4200 上运行
- en: Now that we have the app running locally, let’s walk through the steps of the
    recipe in the next section.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本地运行了应用程序，让我们在下一节中逐步介绍菜谱。
- en: How to do it
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'The app which we are working with is a basic *tasks manager* application. However,
    we have two interesting requirements as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在工作的应用程序是一个基本的 *任务管理器* 应用程序。然而，我们有以下两个有趣的要求：
- en: We should be able to see the finished tasks count against the total tasks along
    the **Task Manager** heading *reactively*. That means that any changes to tasks
    should update it automatically.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该能够在 **任务管理器** 标题下 *动态地* 看到完成任务的计数与总任务数。这意味着任何对任务的更改都应该自动更新它。
- en: When all tasks are completed, we should show a message to the user to congratulate
    them.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当所有任务都完成时，我们应该向用户显示一条消息以祝贺他们。
- en: 'Let’s get started:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: 'First, we will create a `type` for the tasks and an `enum` for the filters
    because – *TypeScript for the win*. Create a new file inside the `src/app` folder
    named `task.model.ts`, and add the following code to it:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将为任务创建一个 `type`，并为过滤器创建一个 `enum`，因为 —— *TypeScript 赢家*。在 `src/app` 文件夹内创建一个新文件，命名为
    `task.model.ts`，并将以下代码添加到其中：
- en: '[PRE53]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, we will create our first signal for the tasks array in the `app.component.ts`
    file. Update it as follows:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将在 `app.component.ts` 文件中为任务数组创建第一个信号。更新如下：
- en: '[PRE54]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `app.component.html` should start crying now because of the change of the
    property to being a signal.
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于属性更改为信号，`app.component.html` 应该会开始抱怨。
- en: 'Update the `app.component.html` file to use the signal via its getter function
    as follows:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `app.component.html` 文件以使用信号及其获取函数如下：
- en: '[PRE55]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We will implement the ability to toggle a task as completed or incomplete.
    Update the `app.component.ts` as follows:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将实现切换任务为完成或未完成的功能。更新 `app.component.ts` 如下：
- en: '[PRE56]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now update the template to bind the click handler on each item to toggle its
    `completed` status. Update `app.component.html` as follows:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在更新模板以将每个项的点击处理程序绑定到切换其 `完成` 状态。更新 `app.component.html` 如下：
- en: '[PRE57]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: You should be able to mark the tasks as `completed` or not by clicking the task
    items.
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该能够通过点击任务项来标记任务为 `完成` 或未完成。
- en: 'We will now create a `computed` property to keep track of the finished tasks.
    Update the `app.component.ts` file as follows:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将创建一个 `computed` 属性来跟踪完成任务的数目。更新 `app.component.ts` 文件如下：
- en: '[PRE58]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Update the template to show the finished tasks count. We will update the `app.component.html`
    file as follows:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新模板以显示完成任务的计数。我们将更新 `app.component.html` 文件如下：
- en: '[PRE59]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'You should be able to see the finished tasks count and the tasks count as shown
    in the following figure:'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该能够看到如图所示的完成任务的计数和任务计数：
- en: '![](img/B18469_01_20.png)'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B18469_01_20.png)'
- en: 'Figure 1.20: Finished tasks count being displayed'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.20：显示完成任务的计数
- en: 'We will now add the ability to add a new task. Update the `app.component.ts
    file` as follows:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将添加添加新任务的功能。按照以下方式更新 `app.component.ts` 文件：
- en: '[PRE60]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now, update the `app.component.html` to bind the `addTask` method to the input
    and the `Add` button as follows:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，更新 `app.component.html` 以将 `addTask` 方法绑定到输入和 `Add` 按钮上，如下所示：
- en: '[PRE61]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'You should be able to create new tasks as shown in the following figure:'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该能够创建如图所示的新任务：
- en: '![](img/B18469_01_21.png)'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_01_21.png)'
- en: 'Figure 1.21: Creating new tasks in the app'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 1.21：在应用程序中创建新任务]'
- en: 'We will now add the possibility of filtering items by their completed status.
    Let us add a new `signal` and a `computed` property for this in the `app.component.ts`
    file as follows:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将添加通过项目完成状态过滤项的可能性。让我们在 `app.component.ts` 文件中添加一个新的 `signal` 和一个 `computed`
    属性，如下所示：
- en: '[PRE62]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We can now use the `changeFilter` method and the `filteredTasks` computed signal
    in the template to filter the tasks. Update the `app.component.html` file as follows:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用 `changeFilter` 方法和在模板中的 `filteredTasks` 计算信号来过滤任务。按照以下方式更新 `app.component.html`
    文件：
- en: '[PRE63]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'If you now see the application, you can filter the tasks by **All**, **Active**,
    or **Completed**, as shown in the following figure:'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你现在查看应用程序，你可以通过**所有**、**活动**或**完成**来过滤任务，如图所示：
- en: '![](img/B18469_01_22.png)'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_01_22.png)'
- en: 'Figure 1.22: Filtering tasks in the application by Active'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 1.22：通过 Active 应用中的过滤任务
- en: 'Finally, we will implement the snack bar. We want to show it whenever the user
    completes all the active tasks. Let us update the `app.component.ts` file first
    to import the `SnackbarComponent` and to create an `effect` as follows:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将实现 snack bar。我们希望在用户完成所有活动任务时显示它。让我们首先更新 `app.component.ts` 文件以导入 `SnackbarComponent`
    并创建一个 `effect`，如下所示：
- en: '[PRE64]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now, we can update the template to add the snackbar component in the UI. Let
    us update the `app.component.html` file as follows:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以更新模板以在 UI 中添加 snackbar 组件。让我们按照以下方式更新 `app.component.html` 文件：
- en: '[PRE65]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'If you now mark all the tasks as completed, you should see the snackbar as
    shown in the following figure:'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你现在将所有任务标记为完成，你应该会看到如图所示的 snackbar：
- en: '![](img/B18469_01_23.png)'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18469_01_23.png)'
- en: 'Figure 1.23: Snackbar displayed on all tasks’ completion using an **effect**'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 1.23：使用**效果**显示所有任务完成时的 snackbar]'
- en: Voila! Just by using the signals, we can create a fully functional (mini) tasks
    manager application in Angular. Now that you know how to work with signals in
    Angular, see the next section to understand how the recipe works.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！仅仅通过使用信号，我们就可以在 Angular 中创建一个完全功能（小型）的任务管理器应用程序。现在你知道如何在 Angular 中使用信号了，请看下一节了解菜谱是如何工作的。
- en: How it works
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: The Angular core team published a **Request for Comments** (**RFC**) about signals,
    and I was excited. Did I already say that? *I guess yes!* But it is so awesome
    that I had to mention it again. The biggest benefit of signals is the way they
    work with Angular’s change detection. Instead of Angular’s change detection looking
    for changes in the application, signals can notify the Angular change detection
    when something changes.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 核心团队发布了一个关于信号的**请求评论**（**RFC**），我非常兴奋。我已经说过这个了吗？*我想是的！*但是它太棒了，我不得不再次提到。信号最大的好处是它们与
    Angular 的变更检测协同工作的方式。而不是 Angular 的变更检测在应用程序中寻找变化，信号可以在发生变化时通知 Angular 变更检测。
- en: In this recipe, we started by creating a `type` for the task item and an `enum`
    for the filters. Then we used the `signal` function from `@angular/core` package
    to create a `WritableSignal` of type `Task`. This is because the `signal` function
    returns a `WritableSignal`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们首先创建了一个任务项的 `type` 和一个过滤器的 `enum`。然后我们使用 `@angular/core` 包中的 `signal`
    函数创建了一个 `WritableSignal`，类型为 `Task`。这是因为 `signal` 函数返回一个 `WritableSignal`。
- en: At the time of authoring this book, the `signal` function is exported from the
    `@angular/core` package and signals are still in developer preview. This might
    change with future releases.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，`signal` 函数是从 `@angular/core` 包导出的，信号仍然处于开发者预览阶段。这可能会随着未来的版本而改变。
- en: When using signals in Angular, the way to get or render the value of a signal
    is to use its getter function, which is just calling the signal as a function.
    In the recipe, you can see that we have `this.tasks()` mentioned at several places.
    We are getting the value of the tasks signal, which is an array of type `Task`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 中使用信号时，获取或渲染信号值的方式是使用其 getter 函数，这实际上就是将信号作为一个函数来调用。在菜谱中，你可以看到我们提到了
    `this.tasks()` 几次。我们正在获取任务信号的值，它是一个类型为 `Task` 的数组。
- en: 'Note that we also use this signal the same way in our template (`app.component.html`)
    to render the count of total tasks by using `{{tasks().length}}`. And that’s all
    about how you can get the value of a signal. However, to set a signal, we need
    to use the `set` method on the signal itself. Let us observe the `filter` signal
    and the `changeFilter` method as follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们也在模板（`app.component.html`）中以相同的方式使用这个信号来通过`{{tasks().length}}`渲染总任务数。这就是如何获取信号值的方法。然而，要设置信号，我们需要在信号本身上使用`set`方法。让我们观察`filter`信号和`changeFilter`方法如下：
- en: '[PRE66]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Notice that to update the filter signal’s value, we use the statement `this.filter.set(filter)`.
    We could have avoided creating the `changeFilter` method and could have used statements
    like `filter.set(filters.All)` etc, in the `app.component.html` (the template)
    but I find this approach much cleaner and easier to read in both the TypeScript
    and HTML files.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了更新过滤信号值，我们使用语句`this.filter.set(filter)`。我们本可以避免创建`changeFilter`方法，并在`app.component.html`（模板）中使用类似`filter.set(filters.All)`等的语句，但我发现这种方法在TypeScript和HTML文件中都要干净得多，也更容易阅读。
- en: 'Apart from signals, we also used *computed properties*. These are properties
    that depend on one or more signals and will automatically update if any of those
    signals are changed. This is powerful and provides reactivity in the application
    without writing much code. If you mouseover the `finishedTasksCount` (computed)
    property in the `app.component.ts`, you will notice it says:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 除了信号之外，我们还使用了*计算属性*。这些属性依赖于一个或多个信号，如果这些信号中的任何一个发生变化，它们将自动更新。这很强大，可以在不写很多代码的情况下为应用程序提供响应性。如果你将鼠标悬停在`app.component.ts`中的`finishedTasksCount`（计算）属性上，你会注意到它显示：
- en: '[PRE67]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This means that computed properties are not writable signals since they are
    computed automatically, and we don’t change them manually.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着计算属性不是可写的信号，因为它们是自动计算的，我们不会手动更改它们。
- en: Finally, we worked with an `effect`. An `effect` is a piece of code – technically
    a function that triggers automatically if any of the signals used in the function’s
    code block change. This can be useful for things like making an API call, saving
    stuff to local storage, reporting an analytics event, and logging. If there is
    a side-effect in your code that you need to trigger based on signals, you can
    use an `effect` for it.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们实现了一个`效果`。一个`效果`是一段代码——技术上是一个函数，如果函数代码块中使用的任何信号发生变化，它将自动触发。这可以用于诸如发起API调用、保存到本地存储、报告分析事件和记录日志等操作。如果你的代码中存在需要根据信号触发的副作用，你可以使用`效果`来实现。
- en: Now that you know how the recipe works, see the next section for further reading.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了食谱的工作原理，请查看下一节以获取更多阅读内容。
- en: See also
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Angular Signals with examples: [https://www.youtube.com/watch?v=IzMzjZXbeQk](https://www.youtube.com/watch?v=IzMzjZXbeQk)'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带示例的Angular信号：[https://www.youtube.com/watch?v=IzMzjZXbeQk](https://www.youtube.com/watch?v=IzMzjZXbeQk)
- en: 'Angular Signals official docs: [https://angular.dev/guide/signals#writable-signals](https://angular.dev/guide/signals#writable-signals)'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular信号官方文档：[https://angular.dev/guide/signals#writable-signals](https://angular.dev/guide/signals#writable-signals)
- en: Learn more on Discord
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Discord上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入这本书的Discord社区——在那里你可以分享反馈、向作者提问，并了解新版本发布——请扫描下面的二维码：
- en: '[https://packt.link/AngularCookbook2e](Chapter_1.xhtml)'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/AngularCookbook2e](Chapter_1.xhtml)'
- en: '![](img/QR_Code1388317275422265.png)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code1388317275422265.png)'
