- en: Chapter 8. Performance of React Apps
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. React应用的性能
- en: In the previous chapter, we learned to use various React add-ons. We saw add-ons
    ranging from immutability helpers to test utilities.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用各种React插件。我们看到了从不可变辅助工具到测试工具的各种插件。
- en: In this chapter, we will look at React performance tools that can improve the
    performance of our React apps. In particular, we will be using the PERF add-on,
    `PureRenderMixin` and `shouldComponentUpdate`. We will also look at some of the
    gotchas that needs to be considered while using the performance tools provided
    by React.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨可以提高我们React应用性能的React性能工具。特别是，我们将使用PERF插件、`PureRenderMixin`和`shouldComponentUpdate`。我们还将探讨在使用React提供的性能工具时需要考虑的一些陷阱。
- en: Performance of React apps
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React应用的性能
- en: '"Hey Mike, I have few questions for you today. I have been thinking about our
    search app over the weekend. Do you have some time to discuss them?" Shawn asked.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '"嗨，迈克，我今天有几个问题想问你。周末我一直在思考我们的搜索应用。你有时间讨论一下吗？"肖恩问道。'
- en: '"Sure, but let me get some coffee first. Okay, I am ready now. Shoot!" said
    Mike.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '"当然，但让我先喝点咖啡。好的，我现在准备好了。开始吧！"迈克说。'
- en: '"I have few questions about the performance of React apps. I know React is
    very good at re-rendering the component tree whenever the state changes. React
    has made it very easy for me to understand and reason my code. However, does it
    not hamper the performance? Re-rendering seems like a very costly affair, especially
    when re-rendering large component trees." Shawn asked.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '"我对React应用的性能有几个问题。我知道React在状态变化时重新渲染组件树方面做得非常好。React使我能很容易地理解和推理我的代码。然而，这不会影响性能吗？重新渲染看起来是一个非常昂贵的操作，尤其是在重新渲染大型组件树时。"肖恩问道。'
- en: '"Shawn, the re-rendering can be expensive. Nevertheless, React is smart about
    it. It only renders the part that is changed. It does not need to re-render everything
    on the page. It''s also smart at keeping the DOM manipulation as least as possible."'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '"肖恩，重新渲染可能会很昂贵。然而，React在这方面很聪明。它只渲染发生变化的部分。它不需要重新渲染页面上的一切。它也在尽量减少DOM操作方面很聪明。"'
- en: '"How is that possible? How does it know which part of the page is changed?
    Does it not depend on user interactions or incoming states and props?" questioned
    Shawn.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '"这是怎么可能的？它是怎么知道页面哪一部分发生了变化？它不是依赖于用户交互或传入的状态和属性吗？"肖恩质疑道。'
- en: '"The virtual DOM comes to the rescue here. It does all the heavy lifting of
    keeping track of what changed and helping React make only minimal changes to the
    real DOM." Mike explained.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '"虚拟DOM在这里发挥了作用。它完成了跟踪变化和帮助React对真实DOM进行最小更改的所有繁重工作。"迈克解释道。'
- en: Virtual DOM
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟DOM
- en: '"Shawn, React uses virtual DOM to keep track of what has changed in the real
    DOM. It''s concept is very easy to understand. React always keeps a copy of the
    representation of the actual DOM in memory. Whenever something changes, such as
    some state manipulation, it calculates another copy of the DOM that will be generated
    with new state and props. Then it calculates the difference between the original
    copy of the virtual DOM and the new copy of the virtual DOM. This difference results
    in minimal operations on the real DOM that can take the current DOM to a new stage.
    In this way, React does not have to do major changes when something changes."
    Mike explained.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '"肖恩，React使用虚拟DOM来跟踪真实DOM中的变化。它的概念非常容易理解。React始终在内存中保留实际DOM表示的副本。每当某些状态操作发生变化时，它都会计算一个新的DOM副本，该副本将使用新的状态和属性生成。然后它计算原始虚拟DOM副本和新虚拟DOM副本之间的差异。这个差异导致对真实DOM进行最小操作，可以将当前DOM带到新的阶段。这样，React在发生变化时不需要进行重大更改。"迈克解释道。'
- en: '"But isn''t the diff calculation expensive?" asked Shawn.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '"但是，差异计算不是很昂贵吗？"肖恩问道。'
- en: '"It''s not expensive when you compare it with actual DOM operations. Manipulation
    of DOM is always expensive. The comparison of virtual DOM occurs in JavaScript
    code, so it is always faster than doing manual DOM operations." said Mike.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '"与实际的DOM操作相比，它并不昂贵。DOM操作总是昂贵的。虚拟DOM的比较发生在JavaScript代码中，所以它总是比手动DOM操作快。"迈克说。'
- en: '"Another advantage of this approach is that once React knows what operations
    are needed to be performed on DOM, it does them in a single batch. Therefore,
    when we render a list of 100 elements, instead of appending one element at a time,
    React will do minimal DOM operations to insert these 100 elements on the page."
    Mike explained.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '"这种方法的优势之一是，一旦 React 知道需要在 DOM 上执行哪些操作，它就会一次性完成。因此，当我们渲染 100 个元素的列表时，而不是逐个添加元素，React
    将执行最少的 DOM 操作来在页面上插入这 100 个元素。"迈克解释道。'
- en: '"I am impressed!" Shawn exclaimed .'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '"我印象深刻！"肖恩惊呼。'
- en: '"You will be more impressed. Let me actually show you what I mean. Let''s use
    the PERF add-on from React and actually see what we discussed in real time."'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '"你们会更加印象深刻。让我实际展示一下我的意思。让我们使用来自 React 的 PERF 插件，并实际看到我们讨论的内容。" '
- en: The PERF addon
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: The PERF 插件
- en: '"Let''s start with installing the PERF addon."'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '"让我们从安装 PERF 插件开始。"'
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '"We need this add-on only in the development mode. This is an important point
    to remember because in production, we don''t need the debugging information as
    it may make our app slow." informed Mike.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '"我们只需要在开发模式下使用这个插件。这是一个需要记住的重要点，因为在生产中，我们不需要调试信息，因为它可能会使我们的应用程序变慢。"迈克告知。'
- en: '"Shawn, the PERF add-on can be used to see what changes React is doing with
    the DOM, where is it spending time while rendering our app, is it wasting some
    time while rendering, and so on. This information can then be used to improve
    the performance of the app." said Mike.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '"肖恩，PERF 插件可以用来查看 React 对 DOM 做了哪些更改，它在渲染我们的应用程序时在哪里花费时间，它是否在渲染过程中浪费了一些时间，等等。然后，我们可以使用这些信息来提高应用程序的性能。"迈克说。'
- en: '"Let''s start by exposing the PERF add-on as a global object. We can use it
    in the browser console while our app is running to see how React is making changes
    as per the user interactions." explained Mike.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '"让我们首先将 PERF 插件暴露为一个全局对象。当我们的应用程序运行时，我们可以使用它在浏览器控制台中查看 React 根据用户交互所做的更改。"迈克解释道。'
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '"We have imported the PERF add-on in our `index.js` file, which is the starting
    point of the app. We can access the `Perf` object in the browser console as we
    have attached it to `window.Perf`." Mike added.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '"我们已经将 PERF 插件导入到我们的 `index.js` 文件中，这是应用程序的起点。我们可以在浏览器控制台中访问 `Perf` 对象，因为我们已经将其附加到
    `window.Perf`。"迈克补充道。'
- en: '![The PERF addon](img/4730_08_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![The PERF 插件](img/4730_08_01.jpg)'
- en: '"The PERF add-on comes with methods that can help us understand what React
    is doing with the DOM when something changes. Let''s measure some performance
    statistics. We will start the measurement process by calling `Perf.start()` in
    the browser console. After that, we will interact with the app. We will type in
    a query to search a book, hit submit, and the search results will be displayed.
    We will stop the performance measurement by calling `Perf.stop()` in the browser
    console. After that, let''s analyze the information that we gathered." Mike explained
    the process.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '"PERF 插件附带了一些方法，可以帮助我们了解当某些内容发生变化时 React 如何处理 DOM。让我们测量一些性能统计数据。我们将通过在浏览器控制台中调用
    `Perf.start()` 来开始测量过程。之后，我们将与应用程序进行交互。我们将输入一个查询以搜索一本书，点击提交，搜索结果将显示出来。我们将通过在浏览器控制台中调用
    `Perf.stop()` 来停止性能测量。之后，让我们分析我们收集到的信息。"迈克解释了整个过程。'
- en: '![The PERF addon](img/4730_08_02.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![The PERF 插件](img/4730_08_02.jpg)'
- en: '"Let''s search for books written by Dan Brown."'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '"让我们搜索丹·布朗写的书籍。"'
- en: '![The PERF addon](img/4730_08_03.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![The PERF 插件](img/4730_08_03.jpg)'
- en: '"Once the results are displayed, let''s stop the performance measurements."'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '"一旦结果显示出来，我们就停止性能测量。"'
- en: '![The PERF addon](img/4730_08_04.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![The PERF 插件](img/4730_08_04.jpg)'
- en: DOM operations performed by React
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React 执行的 DOM 操作
- en: '"Shawn, the PERF add-on can show us which DOM operations were performed by
    React. Let''s see what manipulations React did to the DOM to render the list of
    books by Dan Brown." said Mike.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '"肖恩，PERF 插件可以显示 React 执行了哪些 DOM 操作。让我们看看 React 对丹·布朗的书籍列表进行了哪些操作。"迈克说。'
- en: '![DOM operations performed by React](img/4730_08_05.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![React 执行的 DOM 操作](img/4730_08_05.jpg)'
- en: '"The `Perf.printDOM()` method tells us the DOM manipulations made by React.
    It has made only two set `innerHTML` calls. First one is to render the spinner
    and second one is to render the list of rows. In between, we see a call to remove,
    which must be when the spinner was removed from the page."'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '"`Perf.printDOM()` 方法告诉我们 React 执行的 DOM 操作。它只做了两次设置 `innerHTML` 调用。第一次是渲染加载指示器，第二次是渲染行列表。在这之间，我们看到一个移除调用，这应该是加载指示器从页面上移除的时候。"'
- en: '"Wow, this method looks very handy as it can tell us if React is somehow doing
    some extra DOM manipulations." said Shawn.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '"哇，这个方法看起来非常实用，因为它可以告诉我们React是否在某种程度上做了额外的DOM操作。" 肖恩说。'
- en: '"Yes, but there are more tools for the purpose analyzing the performance. Let''s
    see how much time does React require to render each component. This can be achieved
    using `Perf.printInclusive()`." explained Mike.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '"是的，但还有更多工具可以用来分析性能。让我们看看React渲染每个组件需要多少时间。这可以通过使用`Perf.printInclusive()`来实现。"
    迈克解释道。'
- en: Time taken to render all the components
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染所有组件所需的时间
- en: '![Time taken to render all the components](img/4730_08_06.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![渲染所有组件所需的时间](img/4730_08_06.jpg)'
- en: '"This method prints the overall time taken to render all the components. This
    also included the time required to process props and set up initial state and
    calls to `componentDidMount` and `componentWillMount`."'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '"这个方法打印了渲染所有组件所需的总时间。这还包括处理属性、设置初始状态以及调用`componentDidMount`和`componentWillMount`所需的时间。"'
- en: '"Therefore, if we have some time-intensive operation in one of these hooks,
    it will impact the output shown by the `printInclusive` function, right?" Shawn
    asked.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '"因此，如果我们在这其中的某个钩子中有一些耗时操作，它将影响`printInclusive`函数显示的输出，对吧？" 肖恩问道。'
- en: '"Exactly. Though the PERF add-on provided another method—`printExclusive()`—that
    prints the time to taken render without these hooks, which are used to mount apps."'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '"正是如此。尽管PERF插件提供了另一种方法——`printExclusive()`——它可以在不使用这些钩子的情况下打印渲染所需的时间，这些钩子用于安装应用程序。"'
- en: '![Time taken to render all the components](img/4730_08_07.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![渲染所有组件所需的时间](img/4730_08_07.jpg)'
- en: '"But Mike, these methods are not that helpful for detecting the performance
    of React. I get the overall picture about what all things happened, but it does
    not tell me how to optimize which part." asked Shawn.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '"但是迈克，这些方法对于检测React的性能并不那么有帮助。我了解了所有发生的事情的总体情况，但它并没有告诉我如何优化哪个部分。" 肖恩问道。'
- en: Time wasted by React
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React浪费的时间
- en: '"Shawn, the PERF add-on can also tell us how much time was wasted by React
    and where. It is helpful in determining the parts of our app that we can optimize
    further." said Mike.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '"肖恩，PERF插件还可以告诉我们React浪费了多少时间以及在哪里。这有助于确定我们可以进一步优化的应用程序的部分。" 迈克说。'
- en: '"What is wasted time?"'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '"什么是浪费时间？"'
- en: '"When React re-renders a component tree, some components may not change from
    their previous representation. However, if they are rendered again, then React
    has wasted time in rendering the same output. The PERF add-on can keep track of
    all such time and give us a summary of how React wasted time rendering the same
    output as before. Let''s see this in action." said Mike.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '"当React重新渲染组件树时，一些组件可能不会从它们的前一个表示形式中改变。然而，如果它们再次渲染，那么React在渲染相同的输出上就浪费了时间。PERF插件可以跟踪所有这些时间，并给我们一个React浪费了时间渲染相同输出的总结。让我们看看这个实际操作。"
    迈克说。'
- en: '![Time wasted by React](img/4730_08_08.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![React浪费的时间](img/4730_08_08.jpg)'
- en: '"The PERF add-on tells us that it wasted time in re-rendering the `Form` component
    twice, but nothing was changed in the Form component, therefore, it just re-rendered
    everything as it is." explained Mike.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '"PERF插件告诉我们，它浪费了时间在两次重新渲染`Form`组件上，但`Form`组件中没有任何变化，因此，它只是按照原样重新渲染了一切。" 迈克解释道。'
- en: '"Let''s see the `Form` component to understand why it is happening."'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '"让我们看看`Form`组件，了解为什么会发生这种情况。"'
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '"Shawn, the `Form` component does not depend on state or props for its rendering.
    It renders the same output irrespective of state and props. However, we update
    its state when a user enters a character in the input box. Due to this, React
    will re-render it. Nothing is actually changed in the re-rendered output. Therefore,
    the PERF add-on is complaining about the wasted time." Mike explained.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '"肖恩，`Form`组件的渲染不依赖于状态或属性。无论状态和属性如何，它都会渲染相同的输出。然而，当用户在输入框中输入字符时，我们会更新其状态。因此，React会重新渲染它。实际上，重新渲染的输出并没有任何变化。因此，PERF插件正在抱怨浪费了时间。"
    迈克解释道。'
- en: '"This is useful information, but this looks like an insignificant wastage,
    right?" Shawn asked.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '"这是有用的信息，但这看起来像是一种微不足道的浪费，对吧？" 肖恩问道。'
- en: '"Agree. Let''s make some changes so that I can show you how React can literally
    waste a lot of time re-rendering the same output when it shouldn''t." said Mike.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '"同意。让我们做一些更改，这样我就可以向您展示React如何在实际上不应该的情况下浪费大量时间重新渲染相同的输出。" 迈克说。'
- en: '"Currently, we only show the first 100 search results returned by the Open
    Library API. Let''s change our code to show all the results on same page."'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '"目前，我们只显示Open Library API返回的前100个搜索结果。让我们更改我们的代码，在同一页面上显示所有结果。"'
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '"I have introduced a new state to hold the search term, total number of pages
    to fetch from the Open Library, and current page number being fetched."'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '"我引入了一个新的状态来保存搜索词、从开放图书馆获取的总页数以及当前正在获取的页码。"'
- en: '"Now, we want to fetch all the results from the API, by default, on the same
    page. The API returns us the total number of books found for a query in the `numFounds`
    attribute. Based on this, we need to find the total number of pages that we need
    to fetch from the API."'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '"现在，我们想要从API默认获取同一页的所有结果。API通过`numFounds`属性返回查询找到的书籍总数。基于这个，我们需要找到需要从API获取的总页数。"'
- en: '"Also, each time maximum 100 records are returned that we have stored in `state.offset`
    already."'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '"此外，每次最多返回100条记录，这些记录我们已经存储在`state.offset`中了。"'
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '"Once we get the total number of pages, we need to keep asking for the search
    results for the next page until all the pages are fetched. You want to try and
    get this working?" asked Mike.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '"一旦我们得到总页数，我们需要继续请求下一页的搜索结果，直到所有页面都被获取。你想要尝试让它工作吗？" 迈克问道。'
- en: '"Sure." said Shawn.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '"当然。" 肖恩说。'
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '"I changed the API URL to include the page parameter. Each time the response
    is received from API, we update the state with a new page. We also update `this.state.books`
    to include the newly fetched books. Then, the `_searchAgain` function gets called
    in the callback of the `this.setState` call so that it is the correct value of
    the next page that was set by the `this.setState` call." explains Shawn.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '"我将API URL更改为包含页面参数。每次从API收到响应时，我们都会用新的页面更新状态。我们还更新`this.state.books`以包括新获取的书籍。然后，在`this.setState`调用的回调中调用`_searchAgain`函数，以确保它是`setState`调用设置的下一页的正确值。"
    肖恩解释说。'
- en: '"Nice, it''s an important point to remember not to call the `_searchAgain`
    function outside of the `this.setState()` call as it may get executed before `setState()`
    is finished.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '"很好，这是一个重要的要点，要记住不要在`this.setState()`调用之外调用`_searchAgain`函数，因为它可能会在`setState()`完成之前执行。"'
- en: Because if we call it outside, the `_searchAgain` function may use an incorrect
    value of `this.state.page`. However, as you have passed the `_searchAgain` function
    in the callback to `setState`, there is no chance this will happen." said Mike.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '"因为如果我们在外面调用它，`_searchAgain`函数可能会使用错误的`this.state.page`值。然而，由于你已经在回调中将`_searchAgain`函数传递给了`setState`，所以这种情况不可能发生。"
    迈克解释道。'
- en: '"The `_searchAgain` function just keeps fetching the results until all the
    pages are completed. In this way, we will display all the search results on the
    page, not just the first 100." informed Shawn.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '"`_searchAgain`函数会一直获取结果，直到所有页面都完成。这样，我们将在页面上显示所有搜索结果，而不仅仅是前100条。" 肖恩通知说。'
- en: '"That''s what I wanted. Good job. Let me cleanup the render method so that
    spinner will always be displayed at the bottom." said Mike.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '"这正是我想要的。做得好。让我清理一下渲染方法，这样旋转器就会始终显示在底部。" 迈克说。'
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '"This will make sure that the spinner will be displayed until all the results
    are displayed. OK, all done. Now let''s measure the performance again." said Mike.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '"这将确保在所有结果都显示之前，旋转器会一直显示。好的，都完成了。现在让我们再次测量性能。" 迈克说。'
- en: '![Time wasted by React](img/4730_08_09.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![React浪费的时间](img/4730_08_09.jpg)'
- en: '"Wow, the wasted time has increased a lot! Did Dan Brown release new books
    or what? So much extra time than what we saw last time?" said Shawn.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '"哇，浪费的时间增加了很多！丹·布朗发布了新书吗？比我们上次看到的时间多了这么多？" 肖恩说。'
- en: '"Haha, I don''t think that he released new books just now. Whenever the books
    on next page are fetched, we add them to the existing books and start fetching
    books from the next page. However, the books rendered for the previous pages are
    not changed at all. As we are keeping all of our state in the top-level `App`
    component, whenever its state changes, the whole component tree under `App` gets
    re-rendered. Therefore, `BookList` is rendered again. In turn, all `BookRows`
    are rendered again. This results in a significant amount of time getting wasted
    in rendering the same `BookRow` components for the previous pages again and again."
    said Mike.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '"哈哈，我认为他刚才并没有发布新书。每次从下一页获取书籍时，我们都将它们添加到现有的书籍中，并从下一页开始获取书籍。然而，之前页面的书籍渲染并没有任何变化。因为我们把所有状态都保存在顶层的`App`组件中，所以每当它的状态发生变化时，`App`下的整个组件树都会重新渲染。因此，`BookList`会再次渲染。反过来，所有的`BookRows`也会再次渲染。这导致在重复渲染之前页面的相同`BookRow`组件上浪费了大量的时间。"
    迈克说道。'
- en: '"So each time we fetch books from a new page, all books, including the existing
    ones already present on page, get re-rendered again? I think just appending new
    book rows to the existing list is better in this case." said Shawn.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '"所以每次我们从新页面获取书籍时，包括已经在页面上存在的所有书籍都会再次重新渲染？我认为在这种情况下，仅仅将新的书籍行添加到现有列表中会更好。"肖恩说。'
- en: '"Don''t worry. We can easily get rid of this unnecessary wastage of time. React
    provides us a hook for short-circuiting the re-render process. It''s `shouldComponentUpdate`."'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '"别担心。我们可以轻松地消除这种不必要的浪费时间。React为我们提供了一个用于短路重新渲染过程的钩子。它是`shouldComponentUpdate`。"'
- en: The shouldComponentUpdate hook
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应该使用`shouldComponentUpdate`钩子
- en: '"Shawn, `shouldComponentUpdate` is a hook that tells React whether to re-render
    a component or not. It''s not called for initial rendering of the component. However,
    whenever a component is going to receive new state or props, `shouldComponentUpdate`
    is called before that. If the return value of this function is true, then React
    re-renders the component. However, if the return value is `false`, then React
    does not re-render the component until the next time it is called. The `componentWillUpdate`
    and `componentDidUpdate` hooks will also not be called in this case." Mike explained.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '"肖恩，`shouldComponentUpdate`是一个钩子，它告诉React是否重新渲染组件。它不会在组件的初始渲染时被调用。然而，每当组件即将接收新的状态或属性时，`shouldComponentUpdate`都会在那时被调用。如果这个函数的返回值是`true`，那么React将重新渲染组件。然而，如果返回值是`false`，那么React将不会在下次调用之前重新渲染组件。在这种情况下，`componentWillUpdate`和`componentDidUpdate`钩子也不会被调用。"迈克解释道。'
- en: '"Nice. Then why did our code waste so much time? Should React not use this
    hook to optimize it and not re-render the same `BookRow` components repeatedly?"
    Shawn asked.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '"很好。那么我们的代码为什么浪费了这么多时间？React不应该使用这个钩子来优化它，并且不应该反复重新渲染相同的`BookRow`组件吗？"肖恩问道。'
- en: '"By default, `shouldComponentUpdate` always returns true. React does this to
    avoid subtle bugs. We can have mutable state or props in our code that can make
    `shouldComponentUpdate` to return false positives. It may return false when it
    should return true, resulting in the component not being re-rendered when it should.
    Therefore, React places the responsibility of implementing `shouldComponentUpdate`
    in the developer''s hand." said Mike.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '"默认情况下，`shouldComponentUpdate`总是返回`true`。React这样做是为了避免微小的错误。我们的代码中可能有可变的状态或属性，这会使`shouldComponentUpdate`返回假阳性。它可能在应该返回`true`时返回`false`，导致组件在应该重新渲染时没有重新渲染。因此，React将实现`shouldComponentUpdate`的责任放在了开发者的手中。"迈克说。'
- en: '"Let''s try to use `shouldComponentUpdate` ourselves in order to reduce the
    time wasted in re-rendering the same `BookRow` components." Mike added.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '"让我们尝试自己使用`shouldComponentUpdate`来减少在重新渲染相同的`BookRow`组件上浪费的时间。"迈克补充道。'
- en: '"This is our `BookRow` component as of now:"'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '"这是我们目前的`BookRow`组件："'
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '"Let''s add `shouldComponentUpdate` to reduce unnecessary re-rendering."'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '"让我们添加`shouldComponentUpdate`以减少不必要的重新渲染。"'
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `shouldComponentUpdate` hook gets `nextProps` and `nextState` as arguments
    and we can compare them with the current state or props to make a decision whether
    to return true or false.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`shouldComponentUpdate`钩子接收`nextProps`和`nextState`作为参数，并且我们可以将它们与当前的状态或属性进行比较，以做出是否返回`true`或`false`的决定。'
- en: '"Here, we are checking whether the title, author name, or edition count is
    changed or not. If any of these attributes are changed, then we will return `true`.
    However, if all of them are unchanged, then we will return `false`. Therefore,
    if none of the props are changed, the component will not get re-rendered. As the
    `BookRow` component only depends on props, we don''t have to worry about the state
    change at all." added Mike.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '"在这里，我们正在检查标题、作者姓名或版次是否已更改。如果这些属性中的任何一个已更改，那么我们将返回`true`。然而，如果所有这些都没有更改，那么我们将返回`false`。因此，如果没有任何属性更改，组件将不会重新渲染。由于`BookRow`组件只依赖于属性，我们根本不必担心状态变化。"迈克补充道。'
- en: '"Now, measure the performance again and see if we got some improvements."'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '"现在，再次测量性能，看看我们是否有所改进。"'
- en: '![The shouldComponentUpdate hook](img/4730_08_10.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![shouldComponentUpdate钩子](img/4730_08_10.jpg)'
- en: '"Awesome, we got rid of the time spent in re-rendering the `BookRow` components
    completely. However, we can still improve a lot. Looks like we can also get rid
    of the time spent re-rendering the `Form` and `Header` components, based on the
    preceding result. They are static components. Therefore, they should not be re-rendered
    at all. Shawn, that''s your next challenge."'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '"太棒了，我们完全消除了`BookRow`组件重新渲染所花费的时间。然而，我们还可以做得更好。看起来我们也可以消除重新渲染`Form`和`Header`组件的时间，根据前面的结果。它们是静态组件。因此，它们根本不应该重新渲染。肖恩，这是你的下一个挑战。"'
- en: '"On it."'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '"知道了。"'
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '"Mike, we can simply return `false` from `shouldComponentUpdate` for `Header`
    and `Form` components as they do not depend on states or props at all for rendering!"'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '"迈克，我们可以简单地从`shouldComponentUpdate`中返回`false`，对于`Header`和`Form`组件，因为它们在渲染时根本不依赖于状态或props！"'
- en: '"Perfect find, Shawn. Make a note of such static components that do not depend
    on anything. They are perfect targets for just telling React to not even compare
    their virtual DOM as they do not need to be re-rendered at all." informed Mike.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '"完美的发现，肖恩。记下这些不依赖于任何东西的静态组件。它们是告诉React不比较它们的虚拟DOM的完美目标，因为它们根本不需要重新渲染。"迈克通知说。'
- en: '"Right. I will keep an eye on such static parts of UI that can be extracted
    into smaller components." said Shawn.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '"没错。我会密切关注UI中可以提取成更小组件的这些静态部分。"肖恩说。'
- en: '"Let''s now see if we got rid of some more wasted time after doing these improvements."'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '"现在让我们看看在进行这些改进之后，是否消除了更多浪费的时间。"'
- en: '![The shouldComponentUpdate hook](img/4730_08_11.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![The shouldComponentUpdate hook](img/4730_08_11.jpg)'
- en: '"Cool! We got rid of the time wasted for re-rendering the same `Header` and
    `Form` components." said Mike.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '"酷！我们消除了重新渲染相同的`Header`和`Form`组件所浪费的时间。"迈克说。'
- en: '"Awesome! Let me also try to get rid of the time spent on `BookList` and `RowAlternator`
    too." informed Shawn.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '"太棒了！让我也尝试一下消除`BookList`和`RowAlternator`上花费的时间。"肖恩通知道。'
- en: '"Hold on, Shawn. Before doing this, I want to discuss about an alternative
    to `shouldComponentUpdate`."'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '"等等，肖恩。在我们做这件事之前，我想讨论一下`shouldComponentUpdate`的一个替代方案。"'
- en: PureRenderMixin
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PureRenderMixin
- en: '"Shawn, `PureRenderMixin` is an add-on that can be used in place of `shouldComponentUpdate`.
    Under the hood, it uses `shouldComponentUpdate` and compares the current props
    and state with the next props and states. Let''s try it in our code. First, we
    need to install the add-on, of course." said Mike.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '"肖恩，`PureRenderMixin`是一个可以作为`shouldComponentUpdate`替代品使用的附加组件。在底层，它使用`shouldComponentUpdate`并比较当前和下一个props和state。让我们在我们的代码中试试它。当然，首先我们需要安装这个附加组件。"迈克说。'
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '"Shawn, let''s see the wasted time now that we have used `PureRenderMixin`."
    said Mike.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '"肖恩，现在我们用过了`PureRenderMixin`，来看看浪费的时间吧。"迈克说。'
- en: '![PureRenderMixin](img/4730_08_12.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![PureRenderMixin](img/4730_08_12.jpg)'
- en: '"Oh, it got worse. The `PureRenderMixin` function added the time wasted in
    re-rendering `Form` and `Header` components back. What is going on, Mike?" Shawn
    asked.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '"哦，情况变得更糟了。`PureRenderMixin`函数又把重新渲染`Form`和`Header`组件所浪费的时间加回去了。怎么了，迈克？"肖恩问道。'
- en: '"Calm down! I am going to explain why this happened. The `PureRenderMixin`
    compares the current props and state with the next props and state, but it does
    shallow comparison. Therefore, if we are passing the state or props that contain
    objects and arrays, then the shallow comparison will not return true even if they
    both have the same content." Mike explained.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '"冷静点！我要解释一下为什么会这样。`PureRenderMixin`会将当前的props和state与下一个props和state进行比较，但它进行的是浅比较。因此，如果我们传递包含对象和数组的state或props，即使它们内容相同，浅比较也不会返回true。"迈克解释道。'
- en: '"However, where are we passing any complex objects or arrays to the `Header`
    and `Form` components? We are just passing the book data such as the name of author,
    edition count, and so on. We are not passing anything to `Header`, how does `PureRenderMixin`
    fail?" Shawn asked.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '"然而，我们在哪里将任何复杂对象或数组传递给`Header`和`Form`组件呢？我们只是传递了书籍数据，如作者的名字、版次等。我们没有向`Header`传递任何东西，`PureRenderMixin`怎么会失败呢？"肖恩问道。'
- en: '"You are forgetting style prop passed to `Header` and `Form` from the `App`
    component." informed Mike.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '"你忘了从`App`组件传递给`Header`和`Form`组件的样式属性。"迈克提醒说。'
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '"Each time `App` gets re-rendered, a new object for style is created and sent
    to `Header` and `Form` in props."'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '"每次`App`重新渲染时，都会创建一个新的样式对象，并通过props发送给`Header`和`Form`。"'
- en: '![PureRenderMixin](img/4730_08_13.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![PureRenderMixin](img/4730_08_13.jpg)'
- en: The PureRenderMixin anti pattern
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: The PureRenderMixin anti pattern
- en: 'The `PureRenderMixin` internally implements `shouldComponentUpdate`, as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`PureRenderMixin`内部实现了`shouldComponentUpdate`，如下所示：'
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `shallowCompare` function is also an add-on provided by React that is a
    helper function to compare the current state and props with the next state and
    props. It basically achieves the same thing as `PureRenderMixin`, but as it is
    a function, it can be used directly instead of using `PureRenderMixin`. It is
    especially needed when we are using ES6 classes with React." Mike explained.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`shallowCompare`函数也是React提供的一个附加功能，是一个比较当前状态和props与下一个状态和props的辅助函数。它基本上实现了与`PureRenderMixin`相同的功能，但由于它是一个函数，可以直接使用，而不是使用`PureRenderMixin`。当我们使用ES6类与React一起使用时，这尤其必要。"
    迈克解释说。'
- en: '"Mike, so the shallow comparison is the reason why `PureRenderMixin` is failing
    to detect that there is no change in the next props?" Shawn asked.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '"迈克，所以浅比较是`PureRenderMixin`未能检测到下一个props没有变化的原因吗？" 肖恩问。'
- en: '"Yes. The `shallowCompare` just iterates over the keys of objects that are
    being compared and returns false when the value of the key in each object is not
    strictly equal. Therefore, if we pass simple props, as follows, then `shallowCompare`
    will correctly determine that re-rendering is not required:"'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '"是的。`shallowCompare`只是遍历正在比较的对象的键，当每个对象中键的值不是严格相等时返回`false`。因此，如果我们传递简单的props，如下所示，那么`shallowCompare`将正确地确定不需要重新渲染："'
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '"However, it will fail immediately with a prop that is an object or array."'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '"然而，如果道具是一个对象或数组，它将立即失败。"'
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '"Though `PureRenderMixin` saves us a few lines of code, it may not work all
    the time as we expect it to work. Especially when we have mutable state, objects,
    or arrays in props." said Mike.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '"尽管`PureRenderMixin`为我们节省了一些代码行，但它可能不会像我们预期的那样始终有效。特别是当我们有可变状态、对象或数组作为props时。"
    迈克说。'
- en: '"Got it. So we can write our own `shouldComponentUpdate` function when we have
    nested state or props right?", Shawn asked.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '"明白了。所以当我们有嵌套状态或props时，我们可以编写自己的`shouldComponentUpdate`函数吗？" 肖恩问道。'
- en: '"Yes. `PureRenderMixin` and `shallowCompare` is good for simple components
    with simple props and states but we should take care when we are using it." Mike.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '"是的。`PureRenderMixin`和`shallowCompare`对于具有简单props和states的简单组件来说很好，但我们在使用它时应该小心。"
    迈克说。'
- en: Note
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Using mixins is discouraged in React world for various reasons. Checkout alternative
    approaches for `PureRenderMixin` pattern here - [https://github.com/gaearon/react-pure-render](https://github.com/gaearon/react-pure-render).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于各种原因，在React世界中不建议使用混入。在此处查看`PureRenderMixin`模式的替代方法 - [https://github.com/gaearon/react-pure-render](https://github.com/gaearon/react-pure-render)。
- en: Immutable data
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变数据
- en: '"Mike, I have a question though. All said and done, why does `PureRenderMixin`
    perform shallow comparison in the first place? Should it not perform a deep comparison
    so that we will always have better performance?" Shawn was not very happy with
    `PureRenderMixin`.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '"迈克，不过我有一个问题。尽管如此，为什么`PureRenderMixin`最初要执行浅比较呢？它不应该执行深度比较，以便我们始终有更好的性能吗？"
    肖恩对`PureRenderMixin`不太满意。'
- en: '"Well, there is a reason for this. Shallow comparison is very cheap. It does
    not take much time. Deep comparison is always expensive. Therefore, `PureRenderMixin`
    does shallow comparison, which is good enough for most of the simple use cases,"
    said Mike.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '"嗯，这里有一个原因。浅比较非常便宜。它不花太多时间。深度比较总是昂贵的。因此，`PureRenderMixin`执行浅比较，这对于大多数简单用例来说已经足够好了。"
    迈克说。'
- en: '"However, React does provide us an option of defining our own version of `shouldComponentUpdate`
    as we saw earlier. We can completely short-circuit the re-rendering process by
    just returning `false` from `shouldComponentUpdate` or we can compare only those
    props that are required by our component."'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '"然而，React确实为我们提供了一个选项，可以定义我们自己的`shouldComponentUpdate`版本，就像我们之前看到的。我们只需从`shouldComponentUpdate`返回`false`就可以完全短路重新渲染过程，或者我们只需比较我们组件所需的那部分props。"'
- en: '"True, just like we had written `shouldComponentUpdate` for the `BookRow` component
    right?" asked Shawn.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '"没错，就像我们为`BookRow`组件编写`shouldComponentUpdate`一样？" 肖恩问。'
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '"Exactly, Shawn. If needed, you can also perform a deep comparison as per the
    requirements of your component when needed."'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '"确实如此，肖恩。如果需要，你还可以根据组件的需求进行深度比较。"'
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '"Shawn, another option we have is using immutable data. Comparing immutable
    data with each other is very easy as it will always create new data or objects
    instead of mutating the existing ones."'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '"肖恩，我们还有另一个选择，那就是使用不可变数据。比较不可变数据非常简单，因为它总是会创建新的数据或对象，而不是修改现有的对象。"'
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '"Therefore, we just have to compare the reference of the new object with the
    old object, they are always same when the values are equal and they are always
    different when values are unequal. Therefore, if we use immutable data for our
    props and state, then `PureRenderMixin` will work as expected." said Mike.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '"因此，我们只需要比较新对象的引用与旧对象的引用，当值相等时它们总是相同的，当值不相等时它们总是不同的。因此，如果我们使用不可变数据作为我们的props和state，那么`PureRenderMixin`将按预期工作。"
    迈克说道。'
- en: Note
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Check [http://facebook.github.io/immutable-js/](http://facebook.github.io/immutable-js/)
    as an option for using immutable data for state and props.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 检查[http://facebook.github.io/immutable-js/](http://facebook.github.io/immutable-js/)，作为使用不可变数据作为state和props的选项。
- en: Summary
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you learned about the performance tools provided by React
    and how to use them. We used the PERF add-on: `shouldComponentUpdate` and `PureRenderMixin`.
    We also saw which areas to look for when trying to improve the performance of
    our apps. We also studied the pitfalls while improving the performance, especially
    with `PureRenderMixin`. In the end, we discussed the importance and advantages
    of immutable data.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了React提供的性能工具以及如何使用它们。我们使用了PERF插件：`shouldComponentUpdate`和`PureRenderMixin`。我们还看到了在尝试提高我们应用性能时需要关注的区域。我们还研究了在提高性能时可能遇到的陷阱，特别是与`PureRenderMixin`相关。最后，我们讨论了不可变数据的重要性和优势。
- en: In the next chapter, we will look at the data model of React in detail using
    React Router and Flux. You will learn how to use React with other frameworks such
    as Backbone.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用React Router和Flux详细查看React的数据模型。你将学习如何使用React与其他框架如Backbone一起使用。
