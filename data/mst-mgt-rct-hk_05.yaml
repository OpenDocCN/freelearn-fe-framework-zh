- en: '*Chapter 3*: Sharing Component State with Context'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第三章*：使用 Context 共享组件状态'
- en: React has provided Context since version 16.3\. Context has nothing to do with
    states, but it's a mechanism for passing data from component to component instead
    of using props. By combining Context with a component state, we can provide a
    global state.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: React 自 16.3 版本以来提供了 Context。Context 与状态无关，但它是一种从组件到组件传递数据的机制，而不是使用 props。通过将
    Context 与组件状态结合，我们可以提供全局状态。
- en: In addition to the Context support provided since React 16.3, React 16.8 introduced
    the `useContext` hook. By using `useContext` and `useState` (or `useReducer`),
    we can create custom hooks for a global state.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 除了自 React 16.3 版本以来提供的 Context 支持，React 16.8 引入了 `useContext` 钩子。通过使用 `useContext`
    和 `useState`（或 `useReducer`），我们可以为全局状态创建自定义 hooks。
- en: Context is not fully designed for global states. One of the known limitations
    is that all Context consumers re-render upon updates, which can lead to extra
    re-renders. It's a general recommendation to split a global state into pieces.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Context 并非完全为全局状态而设计。其中一个已知的限制是，所有 Context 消费者在更新时都会重新渲染，这可能导致额外的重新渲染。通常建议将全局状态拆分成多个部分。
- en: In this chapter, we discuss the general recommendations for using Context and
    show some concrete examples. We also discuss some techniques to use Context with
    TypeScript. The goal is to make you feel confident with using Context for a global
    state.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们讨论了使用 Context 的一般建议，并展示了具体的示例。我们还讨论了一些使用 TypeScript 与 Context 结合的技术。目标是让你对使用
    Context 进行全局状态管理感到自信。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将涵盖以下主题：
- en: Exploring `useState` and `useContext`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 `useState` 和 `useContext`
- en: Understanding Context
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Context
- en: Creating a Context for a global state
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为全局状态创建 Context
- en: Best practices for using Context
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Context 的最佳实践
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: If you are new to React Context, it's highly recommended to learn some basics;
    check out the official documentation ([https://reactjs.org/docs/context.html](https://reactjs.org/docs/context.html))
    and the official blog ([https://reactjs.org/blog/2018/03/29/react-v-16-3.html](https://reactjs.org/blog/2018/03/29/react-v-16-3.html)).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚接触 React Context，强烈建议学习一些基础知识；查看官方文档([https://reactjs.org/docs/context.html](https://reactjs.org/docs/context.html))和官方博客([https://reactjs.org/blog/2018/03/29/react-v-16-3.html](https://reactjs.org/blog/2018/03/29/react-v-16-3.html))。
- en: You are also expected to have general knowledge around React including React
    hooks; you can refer to the official site ([https://reactjs.org](https://reactjs.org))
    to learn more.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该对 React 有一定的了解，包括 React hooks；你可以参考官方网站([https://reactjs.org](https://reactjs.org))了解更多信息。
- en: 'In some code, we use TypeScript, which you should have basic knowledge of;
    you can find out more here: [https://www.typescriptlang.org](https://www.typescriptlang.org).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些代码中，我们使用了 TypeScript，你应该对其有基本的了解；你可以在这里了解更多：[https://www.typescriptlang.org](https://www.typescriptlang.org)。
- en: The code in this chapter is available on GitHub at [https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_03](https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_03).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码可在 GitHub 上找到，链接为 [https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_03](https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_03)。
- en: To run the code snippets in this chapter, you need a React environment—for example,
    Create React App ([https://create-react-app.dev](https://create-react-app.dev))
    or CodeSandbox ([https://codesandbox.io](https://codesandbox.io)).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本章中的代码片段，你需要一个 React 环境——例如，Create React App ([https://create-react-app.dev](https://create-react-app.dev))或
    CodeSandbox ([https://codesandbox.io](https://codesandbox.io))。
- en: Exploring useState and useContext
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 useState 和 useContext
- en: By combining `useState` and `useContext`, we can create a simple global state.
    Let's recap on how to use `useState` without `useContext`, how `useContext` works
    for static values, and how we combine `useState` and `useContext`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合 `useState` 和 `useContext`，我们可以创建一个简单的全局状态。让我们回顾一下如何在不使用 `useContext` 的情况下使用
    `useState`，`useContext` 对于静态值是如何工作的，以及我们如何结合 `useState` 和 `useContext`。
- en: Using useState without useContext
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不使用 useContext 使用 useState
- en: Before diving into `useContext`, let's be reminded of how to `useState`, with
    a concrete example. This example is going to be a reference for the following
    examples in the chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入 `useContext` 之前，让我们回顾一下如何使用 `useState`，以下是一个具体的示例。这个示例将成为本章后续示例的参考。
- en: Here, we define a `count` state with `useState` higher in the component tree
    and pass the state value and the update function down the tree.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个在组件树中较高的 `count` 状态，并通过状态值和更新函数将其传递到树中。
- en: 'In the `App` component, we use `useState` and get `count` and `setCount`, which
    are passed to the `Parent` component. The code is illustrated in the following
    snippet:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在`App`组件中，我们使用`useState`获取`count`和`setCount`，这些被传递给`Parent`组件。代码在下面的代码片段中展示：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is a very basic pattern, which we know as *lifting the state up*, from
    [*Chapter 2*](B17780_02_Final_VK_ePub.xhtml#_idTextAnchor035), *Using Local and
    Global States*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常基本的模式，我们称之为*提升状态*，来自[*第二章*](B17780_02_Final_VK_ePub.xhtml#_idTextAnchor035)，*使用本地和全局状态*。
- en: 'Now, let''s define a `Parent` component. It passes the two props to `Component1`
    and `Component2`, as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义一个`Parent`组件。它将两个props传递给`Component1`和`Component2`，如下所示：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This passing of props from parent to children is a repetitive task and is often
    referred to as **prop drilling**.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从父组件到子组件的这种props传递是一个重复的任务，通常被称为**属性钻取**。
- en: '`Component1` and `Component2` display the `count` state and a button to increase
    the `count` state with `setCount`, as illustrated in the following code snippet:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`Component1`和`Component2`显示`count`状态和一个按钮，用于通过`setCount`增加`count`状态，如下面的代码片段所示：'
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These two components are pure components, which means they receive props and
    display things based only on those props. `Component2` is slightly different from
    `Component1`, which increases the count by two. If it were identical, we wouldn't
    need to define two components.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个组件是纯组件，这意味着它们只根据接收到的props接收并显示内容。`Component2`与`Component1`略有不同，它将计数增加两次。如果它们是相同的，我们就不需要定义两个组件。
- en: There is nothing wrong with this example. Only when the app gets bigger, passing
    props down the tree, will this not make sense. In this case, the `Parent` component
    doesn't necessarily need to know about the `count` state, and it may make sense
    to hide the existence of the `count` state in the `Parent` component.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子没有问题。只有当应用变大，向下传递props时，这才会没有意义。在这种情况下，`Parent`组件不一定需要知道`count`状态，并且隐藏`Parent`组件中`count`状态的存在可能是合理的。
- en: Using useContext with a static value
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用静态值`useContext`
- en: React Context helps to eliminate props. It's a means to pass a value from a
    parent component to its children under the tree, without using props.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: React上下文有助于消除props。它是一种从父组件向其子组件传递值的方法，而不使用props。
- en: The following example shows how to use React Context with a static value. It
    has multiple providers to provide different values. Providers can be nested, and
    a consumer component (a consumer component means a component with `useContext`)
    will pick the closest provider in the component tree to get the Context value.
    There is only one component with `useContext` to consume the Context, and the
    component is used in multiple places.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何使用具有静态值的React上下文。它有多个提供者来提供不同的值。提供者可以是嵌套的，并且消费者组件（消费者组件意味着具有`useContext`的组件）将选择组件树中最接近的提供者以获取上下文值。只有一个具有`useContext`的组件来消费上下文，该组件在多个地方使用。
- en: 'Firstly, we define a color Context with `createContext`, which takes a default
    value, as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`createContext`定义一个颜色上下文，它接受一个默认值，如下所示：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this case, the default value for the color Context is `'black'`. The default
    value is used if a component is not in any providers.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，颜色上下文的默认值是`'black'`。如果组件不在任何提供者中，则使用默认值。
- en: 'Now, we define a consumer component. It reads the color Context and displays
    a text in that color. The code is illustrated in the following snippet:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们定义一个消费者组件。它读取颜色上下文并显示该颜色的文本。代码在下面的代码片段中展示：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`Component` reads the `color` Context value, but at this point, we don''t know
    what the color is, and it literally depends on the Context.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`Component`读取`color`上下文值，但在此阶段，我们不知道颜色是什么，它实际上依赖于上下文。'
- en: 'Finally, we define an `App` component. The component tree in the `App` component
    has multiple `ColorContext.Provider` components with different colors. The code
    is illustrated in the following snippet:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义一个`App`组件。在`App`组件中的组件树有多个不同颜色的`ColorContext.Provider`组件。代码在下面的代码片段中展示：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first `Component` instance shows the color `"black"` because it's not wrapped
    by any providers. The second and the third show `"red"` and `"green"` respectively.
    The fourth `Component` instance shows `"blue"`, and the last `Component` instance
    shows `"skyblue"`, because the closest provider has the value `"skyblue"` even
    though it's inside the provider with `"blue"`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`Component`实例显示颜色`"black"`，因为它没有被任何提供者包裹。第二个和第三个分别显示`"red"`和`"green"`。第四个`Component`实例显示`"blue"`，最后一个`Component`实例显示`"skyblue"`，因为最近的提供者的值是`"skyblue"`，即使它位于包含`"blue"`的提供者内部。
- en: Multiple providers and reusing the consumer component is an important capability
    of React Context. If this capability is not important for your use case, you might
    not need React Context. We will discuss the subscription method without Context
    in [*Chapter 4*](B17780_04_Final_VK_ePub.xhtml#_idTextAnchor066), *Sharing Module
    State with Subscription*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 多个提供者和重用消费者组件是React Context的重要功能。如果这个功能对你的用例不重要，你可能不需要React Context。我们将在[*第4章*](B17780_04_Final_VK_ePub.xhtml#_idTextAnchor066)
    *使用Context的最佳实践*部分讨论没有Context的订阅方法。
- en: Using useState with useContext
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用useState与useContext结合
- en: Now, let's learn how the combination of `useState` and `useContext` structure
    our code. We can pass the `state` value and `update` function in Context instead
    of props.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何将`useState`和`useContext`结合来结构化我们的代码。我们可以在上下文中传递`state`值和`update`函数，而不是通过props。
- en: The following example implements a simple `count` state with `useState` and
    `useContext`. We define a Context that holds both the `count` state value and
    the `setCount` update function. The `Parent` component doesn't take props, and
    `Component1` and `Component2` use `useContext` to get the state.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用`useState`和`useContext`实现了一个简单的`count`状态。我们定义了一个上下文，它包含`count`状态值和`setCount`更新函数。`Parent`组件不接收props，`Component1`和`Component2`使用`useContext`获取状态。
- en: 'First, we create a Context for the `count` state. The default value holds a
    static `count` value and a fallback empty `setCount` function. The code is illustrated
    in the following snippet:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为`count`状态创建一个上下文。默认值包含一个静态的`count`值和一个回退的空`setCount`函数。代码在下面的代码片段中展示：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The default value helps to infer types in TypeScript. However, in most cases,
    we need a state instead of a static value, as the default value is not very useful.
    Using the default value is almost unintentional in such cases, so we may throw
    an error instead. We will discuss some best practices later in the *Best practices
    for using Context* section.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值有助于在TypeScript中推断类型。然而，在大多数情况下，我们需要状态而不是静态值，因为默认值并不很有用。在这种情况下使用默认值几乎是无意识的，所以我们可能会抛出一个错误。我们将在*使用Context的最佳实践*部分稍后讨论一些最佳实践。
- en: 'The `App` component has a state with `useState`, and passes `count` and `setCount`
    to the created Context provider component, as illustrated in the following code
    snippet:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`App`组件使用`useState`有一个状态，并将`count`和`setCount`传递给创建的上下文提供者组件，如下面的代码片段所示：'
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The Context value we pass to `CountStateContext.Provider` is an object containing
    `count` and `setCount`. This object has the same structure as the default value.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给`CountStateContext.Provider`的上下文值是一个包含`count`和`setCount`的对象。此对象结构与默认值相同。
- en: 'We define a `Parent` component. Unlike the example in the previous section,
    we don''t need to pass props. The code is illustrated in the following snippet:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个`Parent`组件。与上一节中的示例不同，我们不需要传递props。代码在下面的代码片段中展示：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Even though the `Parent` component is in the Context provider in `App`, it does
    not know about the existence of the `count` state. The components inside `Parent`
    can still use the `count` state through the Context.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`Parent`组件位于`App`中的上下文提供者中，但它并不知道`count`状态的存在。`Parent`内部的组件仍然可以通过上下文使用`count`状态。
- en: 'Finally, we define `Component1` and `Component2`. They take `count` and `setCount`
    from the Context value instead of props. The code is illustrated in the following
    snippet:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义了`Component1`和`Component2`。它们从上下文值中获取`count`和`setCount`，而不是从props中获取。代码在下面的代码片段中展示：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: What is the Context value these components get? They get the Context value from
    the closest provider. We can use multiple providers to provide isolated count
    states, which, again, is an important capability of using React Context.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件获取的上下文值是什么？它们从最近的提供者获取上下文值。我们可以使用多个提供者来提供隔离的计数状态，这再次是使用React Context的重要功能。
- en: In this section, we learned about React Context and how to create a simple global
    state with it. Coming up, we will dive into React Context behavior.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了 React Context 以及如何使用它创建一个简单的全局状态。接下来，我们将深入了解 React Context 的行为。
- en: Understanding Context
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Context
- en: When a Context provider has a new Context value, all Context consumers receive
    the new value and re-render. This means the value in the provider is propagated
    to all the consumers. It is important for us to understand how Context propagation
    works and its limitations.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个 Context 提供者有一个新的 Context 值时，所有 Context 消费者都会接收到新的值并重新渲染。这意味着提供者中的值会传播到所有消费者。了解
    Context 传播的工作方式和其限制对我们来说很重要。
- en: How Context propagation works
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Context 传播的工作方式
- en: If you use a Context provider, you can update the Context value. When a Context
    provider receives a new Context value, it triggers *all* the Context consumer
    components to re-render.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Context 提供者，你可以更新 Context 值。当 Context 提供者接收到新的 Context 值时，它会触发 *所有* Context
    消费者组件的重新渲染。
- en: It's sometimes the case that a child component re-renders for two reasons—one
    because of the parent, and the other because of the Context.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，子组件会因两个原因而重新渲染——一个是因为父组件，另一个是因为 Context。
- en: To stop re-rendering without Context value changes, in this case, we can use
    the *lift content up* technique, or `memo`. `memo` is a function to wrap a component
    and is used to prevent re-renders if the component props don't change.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要在不改变 Context 值的情况下停止重新渲染，在这种情况下，我们可以使用 *提升内容向上* 技术或 `memo`。`memo` 是一个用于包裹组件的函数，用于防止在组件属性没有变化时重新渲染。
- en: Let's see an example with some components wrapped with `memo` to understand
    its behavior.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过将一些组件包裹在 `memo` 中来举一个例子，以了解其行为。
- en: 'As with previous examples, we again use a simple Context that holds a color
    string, as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的例子一样，我们再次使用一个简单的 Context，它包含一个颜色字符串，如下所示：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`''black''` is the default value, which will be used if there are no Context
    providers found in the component tree.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`''black''` 是默认值，如果组件树中没有找到 Context 提供者，将使用此值。'
- en: 'We then define `ColorComponent`, which is similar to previous examples, but
    it also has `renderCount` to show how many times this component is rendered, as
    illustrated in the following code snippet:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着定义 `ColorComponent`，它类似于之前的例子，但它还有一个 `renderCount` 来显示这个组件被渲染了多少次，如下面的代码片段所示：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We use `useRef` for `renderCount`. `renderCount.current` is a number indicating
    the render count. The `renderCount.current` number is incremented by one with
    `useEffect`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `useRef` 为 `renderCount`。`renderCount.current` 是一个表示渲染次数的数字。`renderCount.current`
    数字通过 `useEffect` 增加一。
- en: 'Next is `MemoedColorComponent`, which is `ColorComponent` wrapped by `memo`.
    The code is illustrated in the following snippet:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `MemoedColorComponent`，它是被 `memo` 包裹的 `ColorComponent`。代码在下面的代码片段中展示：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `memo` function is to create a memoized component from a base component.
    The memoized component produces a stable result for the same props.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`memo` 函数用于从基础组件创建一个记忆化的组件。记忆化组件对相同的属性产生稳定的结果。'
- en: 'We define another component, `DummyComponent`, which doesn''t use `useContext`.
    The code is illustrated in the following snippet:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了另一个组件，`DummyComponent`，它没有使用 `useContext`。代码在下面的代码片段中展示：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This component is to compare the behavior against `ColorComponent`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件是为了与 `ColorComponent` 的行为进行比较。
- en: 'We also define `MemoedDummyComponent` for `DummyComponent` with `memo`, as
    follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用 `memo` 为 `DummyComponent` 定义了 `MemoedDummyComponent`，如下所示：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we define a `Parent` component; it has four kinds of components we defined
    previously. The code is illustrated in the following snippet:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个 `Parent` 组件；它包含我们之前定义的四种组件。代码在下面的代码片段中展示：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, the `App` component has a color state with `useState` and passes the
    value to `ColorContext.Provider`. It also shows a text field to change the color
    state. The code is illustrated in the following snippet:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`App` 组件使用 `useState` 有一个颜色状态，并将值传递给 `ColorContext.Provider`。它还显示一个文本字段来更改颜色状态。代码在下面的代码片段中展示：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This example behaves in the following way:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子表现如下：
- en: Initially, all the components render.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始时，所有组件都会进行渲染。
- en: If you change the value in the text input, the `App` component renders because
    of `useState`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你更改文本输入中的值，`App` 组件会由于 `useState` 而重新渲染。
- en: Then, `ColorContext.Provider` gets a new value, and at the same time, the `Parent`
    component renders.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，`ColorContext.Provider` 获得了一个新值，同时 `Parent` 组件也进行了渲染。
- en: '`DummyComponent` renders but `MemoedDummyComponent` doesn''t.'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DummyComponent` 会渲染，但 `MemoedDummyComponent` 不会。'
- en: '`ColorComponent` renders for two reasons—firstly, the parent renders, and secondly,
    the Context changes.'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ColorComponent` 由于两个原因而渲染——首先，父组件渲染，其次，上下文发生变化。'
- en: '`MemoedColorComponent` renders because the Context changes.'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MemoedColorComponent` 由于上下文变化而渲染。'
- en: What's important to learn here is that `memo` doesn't stop the internal Context
    consumer from re-rendering. This is obviously unavoidable because otherwise, components
    could have inconsistent Context values.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这里重要的是要学习的是 `memo` 并不能阻止内部上下文消费者重新渲染。这显然是不可避免的，否则组件可能会有不一致的上下文值。
- en: Limitations when using Context for objects
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用上下文处理对象时的限制
- en: Using primitive values for Context values is intuitive, but using object values
    may require caution due to their behavior. An object may contain several values,
    and Context consumers may not use all of them.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用原始值作为上下文值是直观的，但使用对象值可能需要谨慎，因为它们的行为。一个对象可能包含多个值，而上下文消费者可能不会使用它们全部。
- en: The following example is to reproduce such a case where a component uses only
    part of an object.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例是为了重现这样一个案例，其中组件只使用对象的一部分。
- en: 'First, we define a Context whose value is an object with two counts, `count1`
    and `count2`, as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一个上下文，其值是一个包含两个计数 `count1` 和 `count2` 的对象，如下所示：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Using this count Context, we define a `Counter1` component is to show `count1`.
    We have `renderCount` to show the render count. We also define a `MemoedCounter1`
    component, which is the memoized component. The code is illustrated in the following
    snippet:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个计数上下文，我们定义一个 `Counter1` 组件来显示 `count1`。我们有 `renderCount` 来显示渲染计数。我们还定义了一个
    `MemoedCounter1` 组件，这是一个记忆化组件。代码如下所示：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice that the `Counter1` component uses only `count1` from the Context value.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `Counter1` 组件只使用了上下文值中的 `count1`。
- en: 'Likewise, we define a `Counter2` component that shows `count2` and the memoized
    `MemoCounter2` component, as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们定义了一个显示 `count2` 和记忆化的 `MemoCounter2` 组件的 `Counter2` 组件，如下所示：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `Parent` component has two memoized components, as illustrated in the following
    code snippet:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parent` 组件有两个记忆化的组件，如下面的代码片段所示：'
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, the `App` component has two counts with two `useState` hooks and provides
    the two counts with one Context. It has two buttons to increment two counts respectively,
    as illustrated in the following code snippet:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`App` 组件有两个计数，使用两个 `useState` 钩子，并通过一个上下文提供这两个计数。它有两个按钮分别增加两个计数，如下面的代码片段所示：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice again that the place of two buttons is not very important.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，两个按钮的位置并不重要。
- en: The two counts, `count1` and `count2`, are totally separate—`Counter1` uses
    only `count1` and `Counter2` uses only `count2`. Hence, ideally, `Counter1` should
    re-render only when `count1` is changed. If `Counter1` re-renders without changing
    `count1`, it produces the same result, which means that was just an extra re-render.
    In this example, `Counter1` re-renders even when only `count2` is changed.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 两个计数 `count1` 和 `count2` 完全独立——`Counter1` 只使用 `count1`，而 `Counter2` 只使用 `count2`。因此，理想情况下，`Counter1`
    只应在 `count1` 发生变化时重新渲染。如果 `Counter1` 在不改变 `count1` 的情况下重新渲染，它会产生相同的结果，这意味着这只是额外的重新渲染。在这个例子中，即使只有
    `count2` 发生变化，`Counter1` 也会重新渲染。
- en: This is the extra re-render limitation in the behavior that we should be aware
    of when we utilize React Context.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们利用 React Context 时应该注意的额外重新渲染限制。
- en: Extra Re-Renders
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的重新渲染
- en: Extra re-renders are a pure overhead that should be technically avoided. However,
    this would be fine unless performance is a big concern because users wouldn't
    notice a few extra re-renders. Overengineering to avoid a few extra re-renders
    might not be worth resolving in practice.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的重新渲染是纯粹的开销，应该从技术上避免。然而，除非性能是一个大问题，否则这将是可行的，因为用户不会注意到几个额外的重新渲染。为了避免几个额外的重新渲染而过度设计可能在实际中不值得解决。
- en: In this section, we learned about the behavior of React Context and why it's
    limited to being used with objects. Coming up, we learn some typical patterns
    for implementing a global state with Context.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了 React Context 的行为以及为什么它限制为只能与对象一起使用。接下来，我们将学习一些实现全局状态的典型模式。
- en: Creating a Context for a global state
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为全局状态创建一个上下文
- en: 'Based on the React Context behavior, we will discuss two solutions regarding
    using Context with a global state, as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 React Context 的行为，我们将讨论两个关于使用全局状态与上下文结合的解决方案，如下：
- en: Creating small state pieces
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建小的状态片段
- en: Creating one state with `useReducer` and propagating with multiple Contexts
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `useReducer` 创建一个状态并使用多个上下文进行传播
- en: Let's take a look at each solution.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看每个解决方案。
- en: Creating small state pieces
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建小的状态片段
- en: The first solution is to split a global state into pieces. So, instead of using
    a big combined object, create a global state and a Context for each piece.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种解决方案是将全局状态分割成片段。因此，而不是使用一个大型的组合对象，创建一个全局状态和每个片段的上下文。
- en: The following example creates two `count` states, with a Context and a provider
    component for each `count` state.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例创建了两个 `count` 状态，每个状态都有一个上下文和提供者组件。
- en: 'Firstly, we define two Contexts, `Count1Context` and `Count2Context`, one for
    each piece, as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义了两个上下文，`Count1Context` 和 `Count2Context`，每个片段一个，如下所示：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The Context value is a tuple of a `count` value and an updating function. We
    specified a static value and a dummy function as a default value.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文值是一个包含 `count` 值和更新函数的元组。我们指定了一个静态值和一个占位函数作为默认值。
- en: 'We then define a `Counter1` component that only uses `Count1Context`, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们定义了一个仅使用 `Count1Context` 的 `Counter1` 组件，如下所示：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notice the implementation of `Counter1` only depends on `Count1Context`, and
    it doesn't know about any other Contexts.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `Counter1` 的实现仅依赖于 `Count1Context`，并且它不知道任何其他上下文。
- en: 'Likewise, we define a `Counter2` component that uses only `Count2Context`,
    as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们定义了一个仅使用 `Count2Context` 的 `Counter2` 组件，如下所示：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `Parent` component has `Counter1` and `Counter2` components, as illustrated
    in the following code snippet:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parent` 组件包含 `Counter1` 和 `Counter2` 组件，如下面的代码片段所示：'
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `Parent` component has two counters each, just for demonstration purposes.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parent` 组件有两个计数器，仅用于演示目的。'
- en: 'We define a `Count1Provider` component for `Count1Context`. The `Count1Provider`
    component has a `count` state with `useState` and passes the count value and `update`
    function to the `Count1Context.Provider` component, as illustrated in the following
    code snippet:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为 `Count1Context` 定义了一个 `Count1Provider` 组件。`Count1Provider` 组件使用 `useState`
    有一个 `count` 状态，并将计数值和 `update` 函数传递给 `Count1Context.Provider` 组件，如下面的代码片段所示：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Likewise, we define a `Count2Provider` component for `Count2Context`, as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们为 `Count2Context` 定义了一个 `Count2Provider` 组件，如下所示：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `Count1Provider` and `Count2Provider` components are similar; the only difference
    is the Context to provide a value.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`Count1Provider` 和 `Count2Provider` 组件类似；唯一的区别是提供值的上下文。'
- en: 'Finally, the `App` component has a `Parent` component with two provider components,
    as illustrated in the following code snippet:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`App` 组件有一个包含两个提供者组件的 `Parent` 组件，如下面的代码片段所示：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Notice the `App` component has two provider components nested. Having more provider
    components lead to deeper nesting. We will discuss mitigating nesting in the *Best
    practices for using Context* section.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `App` 组件有两个嵌套的提供者组件。拥有更多的提供者组件会导致更深层次的嵌套。我们将在 *使用上下文的最佳实践* 部分讨论缓解嵌套的方法。
- en: This example doesn't suffer from the extra re-render limitation we described
    in the previous section. This is because Contexts hold only primitive values.
    The `Counter1` and `Counter2` components only re-render when `count1` and `count2`
    are changed respectively. It is necessary to create a provider for each state;
    otherwise, `useState` would return a new tuple object and a Context would trigger
    re-renders.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例不受我们在上一节中描述的额外重新渲染限制的影响。这是因为上下文只持有原始值。`Counter1` 和 `Counter2` 组件仅在 `count1`
    和 `count2` 分别更改时重新渲染。对于每个状态创建一个提供者是很必要的；否则，`useState` 会返回一个新的元组对象，上下文将触发重新渲染。
- en: 'If you are sure that an object is used at once and the usage doesn''t hit the
    limitation of the Context behavior, putting an object as a Context value is totally
    acceptable. Here''s an example of a `user` object that would be used at once:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确定一个对象一次就会被使用，并且使用不会触及上下文行为的限制，将对象作为上下文值是完全可接受的。以下是一个一次性使用的 `user` 对象的示例：
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this case, it doesn't make sense to split it into Contexts. Using a single
    Context for a `user` object would be better.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，将其分割成上下文没有意义。对于 `user` 对象使用单个上下文会更好。
- en: Next, let's look at another solution.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看另一个解决方案。
- en: Creating one state with useReducer and propagating with multiple Contexts
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 useReducer 创建一个状态并通过多个上下文传播
- en: The second solution is to create a single state and use multiple Contexts to
    distribute state pieces. In this case, distributing a function to update the state
    should be done with a separate Context.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种解决方案是创建一个单一的状态，并使用多个上下文来分配状态片段。在这种情况下，应该使用一个单独的上下文来分配更新状态的函数。
- en: The following example is based on `useReducer`. It has three Contexts; two are
    for state pieces, and the last one is for a dispatch function.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例基于`useReducer`。它有三个上下文；两个用于状态片段，最后一个用于分发函数。
- en: 'First, we create two value Contexts for two counts, and one Context for the
    dispatch function that will be used to update the two counts, as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为两个计数创建两个值上下文，并为将用于更新两个计数的分发函数创建一个上下文，如下所示：
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this case, if we have more counts, we create more count Contexts, but the
    dispatch Context will remain just one.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果我们有更多的计数，我们将创建更多的计数上下文，但分发上下文将保持只有一个。
- en: We define a reducer for the dispatch function later in this example.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本例的后面定义分发函数的reducer。
- en: 'Next, we define a `Counter1` component that uses two Contexts—one for the value
    and another for the dispatch function, as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个使用两个上下文的`Counter1`组件——一个用于值，另一个用于分发函数，如下所示：
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `Counter1` component reads `count1` from `Count1Context`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`Counter1`组件从`Count1Context`读取`count1`。'
- en: 'We define a `Counter2` component, which is just like `Counter1` except that
    it reads `count2` from a different Context. The code is illustrated in the following
    snippet:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义一个`Counter2`组件，它与`Counter1`类似，只是从不同的上下文中读取`count2`。代码如下所示：
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Both `Counter1` and `Counter2` components use the same `DispatchContext` Context.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`Counter1`和`Counter2`组件都使用相同的`DispatchContext`上下文。'
- en: 'The `Parent` component is the same as the previous example, as we can see here:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，`Parent`组件与之前的例子相同：
- en: '[PRE33]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, we define a `Provider` component that is unique in this example. The `Provider`
    component uses `useReducer`. The reducer function handles two action types—`INC1`
    and `INC2`. The `Provider` component includes providers from three Contexts that
    we defined previously. The code is illustrated in the following snippet:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们定义一个在本例中独特的`Provider`组件。`Provider`组件使用`useReducer`。reducer函数处理两种动作类型——`INC1`和`INC2`。`Provider`组件包括我们之前定义的三个上下文的提供者。代码如下所示：
- en: '[PRE34]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The code is a bit long because of the reducer, which can be more complex. The
    point is nested providers, providing each state piece and one dispatch function.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 由于reducer的存在，代码稍微长了一些，它可能更复杂。重点是嵌套提供者，提供每个状态片段和一个分发函数。
- en: 'Finally, the `App` component just has the `Provider` component and the `Parent`
    component in it, as illustrated in the following code snippet:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`App`组件中只包含`Provider`组件和`Parent`组件，如下面的代码片段所示：
- en: '[PRE35]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This example also doesn't suffer from the extra re-render limitation; changing
    `count1` in the state only triggers `Counter1` to re-render, while `Counter2`
    is not affected.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 本例也不受额外重新渲染限制的影响；在状态中更改`count1`只会触发`Counter1`重新渲染，而`Counter2`不受影响。
- en: 'The benefit of using a single state over using multiple states in the previous
    example is that the single state can update multiple pieces with one action. For
    example, you can add something like this in the reducer:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单个状态而不是使用多个状态在上一个示例中的好处是，单个状态可以通过一个动作更新多个片段。例如，你可以在reducer中添加如下内容：
- en: '[PRE36]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As we discussed in the first solution, it is acceptable to create a Context
    for an object (such as the `user` object) in this solution too.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在第一个解决方案中讨论的那样，在这个解决方案中也可以为对象（例如`user`对象）创建上下文。
- en: In this section, we learned two solutions to use Context for a global state.
    They are typical solutions, but there would be many variants. The key point is
    to use multiple Contexts to avoid extra re-renders. In the next section, we learn
    some best practices to deal with a global state based on multiple Contexts.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了两种使用上下文处理全局状态的方法。它们是典型的方法，但会有很多变体。关键是使用多个上下文来避免额外的重新渲染。在下一节中，我们将学习一些基于多个上下文处理全局状态的最佳实践。
- en: Best practices for using Context
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用上下文的最佳实践
- en: 'In this section, we will learn three patterns to deal with Contexts for a global
    state, as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习三种处理全局状态上下文的模式，如下所示：
- en: Creating custom hooks and provider components
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义钩子和提供者组件
- en: A factory pattern with a custom hook
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有自定义钩子的工厂模式
- en: Avoiding provider nesting with `reduceRight`
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`reduceRight`避免提供者嵌套
- en: Let's take a look at each one.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一看看。
- en: Creating custom hooks and provider components
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义钩子和提供者组件
- en: In the previous examples in this chapter, we directly used `useContext` to get
    Context values. Now, we will explicitly create custom hooks to access Context
    values as well as provider components. This allows us to hide Contexts and restrict
    their usage.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面的示例中，我们直接使用`useContext`来获取上下文值。现在，我们将显式创建自定义钩子来访问上下文值以及提供者组件。这允许我们隐藏上下文并限制它们的用法。
- en: The following example creates custom hooks and provider components. We make
    a default Context value `null` and check if the value is `null` in the custom
    hooks. This checks if the custom hooks are used under the providers.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例创建了自定义钩子和提供者组件。我们设置默认上下文值为`null`并在自定义钩子中检查该值是否为`null`。这检查自定义钩子是否在提供者下使用。
- en: 'The first thing we do, as always, is to create a Context; this time, the default
    value of the Context is `null`, which indicates that the default value can''t
    be used and the provider is always is required. The code is illustrated in the
    following snippet:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先做的事情，就像往常一样，是创建一个上下文；这次，上下文的默认值是`null`，这表示默认值不能使用，并且总是需要提供者。代码在下面的代码片段中展示：
- en: '[PRE37]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We then define `Count1Provider`, which creates a state with `useState` and
    passes it to `Count1Context.Provider`, as illustrated in the following code snippet:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义`Count1Provider`，使用`useState`创建一个状态并将其传递给`Count1Context.Provider`，如下面的代码片段所示：
- en: '[PRE38]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Notice that we use `useState(0)` in the `const [count, setCount] = useState(0);`
    and `return <Count1Context.Provider value={[count, setCount]}>` in one line.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在`const [count, setCount] = useState(0);`和`return <Count1Context.Provider
    value={[count, setCount]}>`一行中使用了`useState(0)`。
- en: 'Next, we define a `useCount1` hook to return a value from `Count1Context`.
    Here, we check that `null` from the Context value throws a meaningful error. Developers
    often make mistakes, and having explicit errors would make it easier for us to
    detect bugs. The code is illustrated in the following snippet:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个`useCount1`钩子来从`Count1Context`返回一个值。在这里，我们检查从上下文值中抛出的`null`会引发一个有意义的错误。开发者经常犯错误，有明确的错误会使我们更容易检测到错误。代码在下面的代码片段中展示：
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Following on, we create `Count2Context`, define a `Count2Provider` component
    and a `useCount2` hook (they are the same as `Count1Context`, `Count1Provider`,
    and `useCount1`, except for the names). The code is illustrated in the following
    snippet:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们创建`Count2Context`，定义一个`Count2Provider`组件和一个`useCount2`钩子（它们与`Count1Context`、`Count1Provider`和`useCount1`相同，只是名称不同）。代码在下面的代码片段中展示：
- en: '[PRE40]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, we define a `Counter1` component to use the `count1` state and show the
    count and a button. Notice in the following code snippet that this component doesn''t
    know about a Context, which is hidden in the `useCount1` hook:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个`Counter1`组件来使用`count1`状态并显示计数和一个按钮。注意，在下面的代码片段中，这个组件不知道上下文的存在，它在`useCount1`钩子中被隐藏：
- en: '[PRE41]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Likewise, we define a `Counter2` component, as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们定义一个`Counter2`组件，如下所示：
- en: '[PRE42]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Notice the `Counter2` component is almost similar to the `Counter1` component.
    The major difference is that the `Counter2` component uses the `useCount2` hook
    instead of the `useCount1` hook.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Counter2`组件几乎与`Counter1`组件相同。主要区别在于`Counter2`组件使用`useCount2`钩子而不是`useCount1`钩子。
- en: 'We define a `Parent` component that has `Counter1` and `Counter2` defined previously,
    as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义一个`Parent`组件，该组件定义了之前定义的`Counter1`和`Counter2`，如下所示：
- en: '[PRE43]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, an `App` component is defined to complete the example. It wraps the
    `Parent` component with two provider components, as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，定义一个`App`组件来完成示例。它用两个提供者组件包裹`Parent`组件，如下所示：
- en: '[PRE44]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Although it's not very explicit with this snippet, we typically have a separate
    file such as `contexts/count1.jsx` for each Context and export only custom hooks
    such as `useCount1` and provider components such as `Count1Provider`. In this
    case, `Count1Context` is not exported.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个片段不是很明确，我们通常为每个上下文有一个单独的文件，例如`contexts/count1.jsx`，并只导出自定义钩子，如`useCount1`和提供者组件，如`Count1Provider`。在这种情况下，`Count1Context`没有被导出。
- en: Factory pattern with a custom hook
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有自定义钩子的工厂模式
- en: Creating a custom hook and a provider component is a somewhat repetitive task;
    however, we can create a function that does the task.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自定义钩子和提供者组件是一项相对重复的任务；然而，我们可以创建一个函数来完成这项任务。
- en: The following example shows `createStateContext` as a concrete implementation.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例展示了`createStateContext`的具体实现。
- en: The `createStateContext` function takes a `useValue` custom hook that takes
    an initial value and returns a state. If you use `useState`, it returns a tuple
    of the `state` value and the `setState` function. The `createStateContext` function
    returns a tuple of a provider component and a custom hook to get the state. This
    is the pattern we learned in the previous sections.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`createStateContext` 函数接受一个 `useValue` 自定义钩子，该钩子接受一个初始值并返回一个状态。如果你使用 `useState`，它返回一个包含
    `state` 值和 `setState` 函数的元组。`createStateContext` 函数返回一个包含提供者组件和用于获取状态的自定义钩子的元组。这是我们之前章节中学到的模式。'
- en: 'In addition, this provides a new feature; the provider component accepts an
    optional `initialValue` prop that is passed into `useValue`. This allows you to
    set the initial value of the state at runtime instead of defining an initial value
    at creation. The code is illustrated in the following snippet:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这还提供了一个新特性；提供者组件接受一个可选的 `initialValue` 属性，该属性传递给 `useValue`。这允许你在运行时设置状态的初始值，而不是在创建时定义初始值。代码在下面的片段中展示：
- en: '[PRE45]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, let''s see how to use `createStateContext`. We define a custom hook, `useNumberState`;
    it takes an optional `init` parameter. We then invoke `useState` with `init`,
    as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用 `createStateContext`。我们定义一个自定义钩子，`useNumberState`；它接受一个可选的 `init`
    参数。然后我们像下面这样使用 `useState`：
- en: '[PRE46]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'By passing `useNumberState` to `createStateContext`, we can create as many
    state Contexts as we want; we created two sets of them. The types of `useCount1`
    and `useCount2` are inferred from `useNumberState`. The code is illustrated in
    the following snippet:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 `useNumberState` 传递给 `createStateContext`，我们可以创建任意数量的状态上下文；我们创建了两组。`useCount1`
    和 `useCount2` 的类型是从 `useNumberState` 推断出来的。代码在下面的片段中展示：
- en: '[PRE47]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Notice we avoid the repetitive definition thanks to `createStateContext`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们通过 `createStateContext` 避免了重复的定义。
- en: 'We then define `Counter1` and `Counter2` components. The way to use `useCount1`
    and `useCount2` is identical to the previous example, as we can see in the following
    code snippet:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义 `Counter1` 和 `Counter2` 组件。使用 `useCount1` 和 `useCount2` 的方式与上一个示例相同，如下代码片段所示：
- en: '[PRE48]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finally, we create `Parent` and `App` components. The way to use `Count1Provider`
    and `Count2Provider` is also the same, as we can see here:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建 `Parent` 和 `App` 组件。使用 `Count1Provider` 和 `Count2Provider` 的方式也是相同的，如下所示：
- en: '[PRE49]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Notice how we reduce our code from the previous example. The whole point of
    `createStateContext` is to avoid repetitive code and provide the same functionality.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何从上一个示例中减少代码的。`createStateContext` 的整个目的就是为了避免重复代码并提供相同的功能。
- en: 'Instead of `useNumberState` with `useState`, we could make the custom hook
    with `useReducer`, as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用 `useState` 的 `useNumberState` 不同，我们可以使用 `useReducer` 创建自定义钩子，如下所示：
- en: '[PRE50]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We could also create a more complex hook. The following example has `inc1`
    and `inc2` custom action functions. It uses `useEffect` to show an updated log
    in the console:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以创建一个更复杂的钩子。以下示例有 `inc1` 和 `inc2` 自定义动作函数。它使用 `useEffect` 在控制台显示更新的日志：
- en: '[PRE51]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We can still use the `createStateContext` function for these `useMyState` hooks
    and any other custom hooks.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以使用 `createStateContext` 函数为这些 `useMyState` 钩子和任何其他自定义钩子。
- en: 'It''s worth noting that this factory pattern works well in TypeScript. TypeScript
    provides extra checks with types, and developers can get better experience from
    type checking. The following code snippet shows the typed version of `createStateContext`
    and `useNumberState`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，这种工厂模式在 TypeScript 中工作得很好。TypeScript 通过类型提供额外的检查，开发者可以从类型检查中获得更好的体验。下面的代码片段展示了
    `createStateContext` 和 `useNumberState` 的类型化版本：
- en: '[PRE52]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If we use the typed version of `createStateContext` and `useNumberState`, the
    result is also typed.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `createStateContext` 和 `useNumberState` 的类型化版本，结果也将是类型化的。
- en: Avoiding provider nesting with reduceRight
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 reduceRight 避免提供者嵌套
- en: 'With the `createStateContext` function, it''s very easy to create many states.
    Let''s suppose we created five of them, as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `createStateContext` 函数，创建多个状态非常容易。假设我们创建了五个，如下所示：
- en: '[PRE53]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Our `App` component would then look like this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `App` 组件将看起来像这样：
- en: '[PRE54]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This is absolutely correct, and it captures how a component tree is structured.
    However, too much nesting is not very comfortable while coding. To mitigate this
    coding style, we could use `reduceRight`. The `App` component can be refactored,
    as shown in the following example:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全正确，并且捕捉到了组件树的结构。然而，过多的嵌套在编码时并不舒适。为了减轻这种编码风格，我们可以使用 `reduceRight`。`App` 组件可以被重构，如下面的示例所示：
- en: '[PRE55]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: There could be some variations of this technique, such as creating a `reduceRight`
    to construct a provider tree.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的变体可能包括创建一个 `reduceRight` 来构建提供者树。
- en: This technique is not only for a global state with Context but also for any
    components.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术不仅适用于使用 Context 的全局状态，也适用于任何组件。
- en: In this section, we learned some best practices to work with a global state
    with Contexts. These are not something you must follow. As long as you understand
    the behavior of Context and its limitations, any pattern would work fine.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了一些与使用 Context 的全局状态相关的最佳实践。这些并不是你必须遵循的规则。只要你能理解 Context 的行为及其限制，任何模式都可以很好地工作。
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to create global states with React Context.
    The Context propagation works to avoid passing props. If you understand the Context
    behavior correctly, implementing global states with Context is straightforward.
    Basically, we should create a Context for each state piece to avoid extra re-renders.
    Some best practices will help in the implementation of a global state with Context,
    particularly the concrete implementation of `createStateContext`, which will help
    when organizing your app code.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用 React Context 创建全局状态。Context 的传播旨在避免传递 props。如果你正确理解了 Context
    的行为，使用 Context 实现全局状态将非常简单。基本上，我们应该为每个状态部分创建一个 Context，以避免额外的重新渲染。一些最佳实践将有助于使用
    Context 实现全局状态，特别是 `createStateContext` 的具体实现，这将有助于组织你的应用代码。
- en: In the next chapter, we will learn another pattern of implementing a global
    state with subscriptions.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习另一种使用订阅实现全局状态的模式。
