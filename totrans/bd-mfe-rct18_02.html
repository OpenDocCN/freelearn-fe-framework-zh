<html><head></head><body>
		<div id="_idContainer013" class="calibre2">
			<h1 id="_idParaDest-16" class="chapter-number"><a id="_idTextAnchor015" class="pcalibre1 calibre6 pcalibre"/>1</h1>
			<h1 id="_idParaDest-17" class="calibre7"><a id="_idTextAnchor016" class="pcalibre1 calibre6 pcalibre"/>Introducing Microfrontends</h1>
			<p class="calibre3">We are coming full circle with microfrontends! During the Web 1.0 era, websites primarily comprised single pages built in ASP, JSP, or PHP, where we could make changes to each individual page and upload it to a server via FTP and it was immediately available to consumers. Then came the Web 2.0 era and the notion of web apps and <strong class="bold">Single-Page Apps</strong> (<strong class="bold">SPAs</strong>), where we compile, transpile, and deploy large monolithic apps. Now, we seem to be going back to working with smaller apps <span>and pages.</span></p>
			<p class="calibre3">The early 2000s brought in the era of Web 2.0 and the notion of web apps. A few years later, JavaScript frameworks allowed you to build SPAs that updated instantly and didn’t reload a new page each time the user clicked on a link or a button. SPAs were indeed fast for small to medium-sized apps, but as teams went full throttle with building large-scale SPAs, and as applications and teams grew, the velocity and speed of development dropped significantly. Teams seemed to be debating about folder structures, state management, and breaking each other’s code, due to centrally managed libraries and so on. These large SPAs also started becoming less performant due to the large bundle sizes of these apps. More importantly, the high execution time required to parse these JavaScript bundles made the apps even more sluggish on low-end devices and mobile phones. That’s when developers and architects started looking for solutions to these problems. Thankfully, they didn’t have to look <span>too far.</span></p>
			<p class="calibre3">You see, the backend teams went through the exact same problems with the large backend monoliths a few decades back and moved toward the microservices architecture pattern in order to solve their performance and scaling challenges. The frontend teams now look to apply the same principles of microservices to their frontend apps, which are being referred to<a id="_idIndexMarker000" class="pcalibre1 calibre6 pcalibre"/> <span>as </span><span><strong class="bold">microfrontends</strong></span><span>.</span></p>
			<p class="calibre3">The journey for backend teams toward microservices has been a very long one, spanning multiple decades, and many teams still struggle with it. However, thanks to a lot of debates, discussions, thoughts, leadership, and sharing learning from various microservice implementations, there is an overall maturity to and consensus around <span>microservices architecture.</span></p>
			<p class="calibre3">Frontend teams are just waking up to the notion of microfrontends, and there are multiple schools of thought on what defines a microfrontend, including, in fact, whether microfrontends are even a good thing or not. It will take a couple of years, if not a decade, before there is some consensus around microfrontends. The good thing, however, is that we can learn a lot from the journey of microservices, as a lot of principles and architecture patterns of microservices also apply <span>to microfrontends.</span></p>
			<p class="calibre3">In this chapter, we’ll start by understanding the need for microfrontends. We will cover the definition of microfrontends, and then the different patterns of microfrontends. We will also look into the parameters that will help us choose which pattern to go with for designing your apps. Finally, we will create our very <span>first microfrontend.</span></p>
			<p class="calibre3">In this chapter, we will cover the <span>following topics:</span></p>
			<ul class="calibre15">
				<li class="calibre14"><span>Defining Microfrontends</span></li>
				<li class="calibre14">Understanding <span>Microfrontend patterns</span></li>
				<li class="calibre14">Choosing a <span>suitable pattern</span></li>
				<li class="calibre14">Hello World <span>with Microfrontends</span></li>
			</ul>
			<p class="calibre3">By the end of this chapter, you will have a better understanding of two of the most common patterns for building microfrontends and a guide to help you decide which one would be most suitable <span>for you.</span></p>
			<p class="calibre3">Toward the end of this chapter, we will build out a simple multi-SPA microfrontend example and get a feel for how we navigate between the the <span>different SPAs.</span></p>
			<h1 id="_idParaDest-18" class="calibre7"><a id="_idTextAnchor017" class="pcalibre1 calibre6 pcalibre"/>Technical requirements</h1>
			<p class="calibre3">As you go through the code examples in this chapter, you will need <span>the following:</span></p>
			<ul class="calibre15">
				<li class="calibre14">A PC, Mac, or Linux desktop/laptop with at least 8 GB of RAM (16 <span>GB preferred)</span></li>
				<li class="calibre14">An Intel chipset i5+, AMD, or an Apple M1 + <span>chipset</span></li>
				<li class="calibre14">At least 256 GB of free hard <span>disk storage</span></li>
			</ul>
			<p class="calibre3">You will also need the following software installed on <span>your computer:</span></p>
			<ul class="calibre15">
				<li class="calibre14">Node.js version 16+ (use <strong class="source-inline1">nvm</strong> to manage different versions of Node.js if you <span>have to).</span></li>
				<li class="calibre14">Terminal: A modern shell such as <strong class="source-inline1">zsh</strong>, iTerm2 with <strong class="source-inline1">oh-my-zsh</strong> for Mac (you will thank me later), or Hyper for <span>Windows (</span><a href="https://hyper.is/" class="pcalibre1 calibre6 pcalibre"><span>https://hyper.is/</span></a><span>).</span></li>
				<li class="calibre14">IDE: We recommend <span>VS Code.</span></li>
				<li class="calibre14"><strong class="source-inline1">npm</strong>, <strong class="source-inline1">yarn</strong>, or pnpm. We recommend PNPM because it’s fast and <span>storage efficient.</span></li>
				<li class="calibre14">Browser: Chrome/Microsoft Edge, Brave, or Firefox (I <span>use Firefox).</span></li>
			</ul>
			<p class="calibre3">The code files for this chapter can be found <span>here: </span><a href="https://github.com/PacktPublishing/Building-Micro-Frontends-with-React" class="pcalibre1 calibre6 pcalibre"><span>https://github.com/PacktPublishing/Building-Micro-Frontends-with-React</span></a><span>.</span></p>
			<h1 id="_idParaDest-19" class="calibre7"><a id="_idTextAnchor018" class="pcalibre1 calibre6 pcalibre"/>Defining Microfrontends</h1>
			<p class="calibre3">In this section, we will <a id="_idIndexMarker001" class="pcalibre1 calibre6 pcalibre"/>focus on defining what microfrontends and their key benefits are, and also become aware of the initial upfront investments associated with setting <span>up microfrontends.</span></p>
			<p class="calibre3">The currently accepted definition of a microfrontend is <span>as follows.</span></p>
			<p class="calibre3">“Microfrontends are a composition of micro apps that can be <strong class="bold">independently deployed</strong> and are owned by <strong class="bold">independent teams</strong> responsible for delivering business value of a focused area of the <span>overall application”.</span></p>
			<p class="calibre3">The keywords in this definition are independently deployed and independent teams. If at least one of these terms doesn’t apply to you or your team, then you probably don’t need a microfrontend. A regular SPA would work out to be more efficient and productive. As we will see later, microfrontends come with a bit of upfront complexity and may not be worth it unless you have a large application, where sections of the app are managed by <span>individual teams.</span></p>
			<p class="calibre3">We’ve noticed that some teams that are on their journey to implementing microfrontends misinterpret the <em class="italic">micro</em> part of microfrontends and believe an application doesn’t follow a microfrontend architecture unless it’s broken down to its smallest level. They break down their apps into really small apps, which adds a lot of unnecessary complexity. In fact, it negates all the benefits that microfrontends are supposed <span>to deliver.</span></p>
			<p class="calibre3">In our opinion, it <a id="_idIndexMarker002" class="pcalibre1 calibre6 pcalibre"/>actually works the other way around. When breaking down an application into micro apps, the teams should ideally look to identify the largest possible micro app or micro apps that a scrum team can independently manage and deploy to production without impacting other <span>micro apps.</span></p>
			<p class="calibre3">The key takeaway from this is not to be swayed by the term “micro” but instead identify the largest possible app that can be independently deployed by a single <span>scrum team.</span></p>
			<p class="calibre3">Before we go deeper into the wonderful world of microfrontends, it is important to remember that every application doesn’t need to be a microfrontend. Let’s learn more about this in the <span>following section.</span></p>
			<h2 id="_idParaDest-20" class="calibre5"><a id="_idTextAnchor019" class="pcalibre1 calibre6 pcalibre"/>Understanding the Microfrontend Premium</h2>
			<p class="calibre3"><em class="italic">Martin Fowler</em> talks about the <a id="_idIndexMarker003" class="pcalibre1 calibre6 pcalibre"/>microservice premium. This refers to the fact that microservices come with a bit of overhead and complexity, mainly in terms of the initial setup and the communication channels between the services. Martin goes on to say that the benefits of a microservices architecture only start showing when size and complexity boosters kick in. To understand this, let’s look at the <span>following diagram:</span></p>
			<div class="calibre2">
				<div id="_idContainer007" class="img---figure">
					<img src="image/Figure_1.01_B18987.jpg" alt="Figure 1.1 – The microservice premium graph (source: https://martinfowler.com/bliki/MicroservicePremium.html)" class="calibre4"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 1.1 – The microservice premium graph (source: <a href="https://martinfowler.com/bliki/MicroservicePremium.html" class="pcalibre1 calibre6 pcalibre">https://martinfowler.com/bliki/MicroservicePremium.html</a>)</p>
			<p class="calibre3">The preceding diagram is a graph of the productivity versus the complexity of an application and depicts the drop in productivity for a monolith SPA and microfrontend as <span>complexity grows.</span></p>
			<p class="calibre3">The same holds <a id="_idIndexMarker004" class="pcalibre1 calibre6 pcalibre"/>true for the microfrontend architecture. The whole process of decoupling the various parts of components, routing, and templates and delegating them to different systems can become an unnecessary overhead for small or <span>medium-scale apps.</span></p>
			<p class="calibre3">The benefits of microfrontends kick in only when your project starts reaching the size and complexity thresholds shown in <span><em class="italic">Figure 1</em></span><span><em class="italic">.1</em></span><span>.</span></p>
			<h2 id="_idParaDest-21" class="calibre5"><a id="_idTextAnchor020" class="pcalibre1 calibre6 pcalibre"/>Exploring the benefits of Microfrontends</h2>
			<p class="calibre3">All the <a id="_idIndexMarker005" class="pcalibre1 calibre6 pcalibre"/>benefits of a microfrontend architecture are linked to size and scale. Having said that, the following benefits of microfrontends hold true only for apps that are built and supported by teams with over <span>15 people.</span></p>
			<p class="calibre3">In the following sections, we will learn about the benefits that teams can expect when they implement a microfrontend architecture, all of which are directly linked to improved productivity and better developer experience for <span>team members.</span></p>
			<h3 class="calibre9">Faster development and deployments</h3>
			<p class="calibre3">One of the main drawbacks of monolithic Single Page Apps is that as the application and team sizes grow, feature development and deployments come to a crawl. We notice the team spending a lot more time where one team is waiting on the other team to finish something before the application can be deployed. With a microfrontend architecture, every scrum team works independently on their micro app, building and releasing features without having to worry a lot about what other teams <span>are doing.</span></p>
			<h3 class="calibre9">Easier to scale as the application grows</h3>
			<p class="calibre3">A microfrontend architecture is all about composing smaller micro apps, so as the application grows in size, it’s just a question of adding additional micro apps and having a scrum team <span>own it.</span></p>
			<p class="calibre3">Now, since each team deals with a smaller micro app, their team members need to spend less time understanding the code base and should not get overwhelmed or worried about how their code changes will impact <span>other teams.</span></p>
			<p class="calibre3">Microfrontends allow one to scale up very quickly, with scrum teams working in parallel once the base microfrontend framework is <span>set up.</span></p>
			<h3 class="calibre9">Improved Developer Experience</h3>
			<p class="calibre3">With isolated, independent <a id="_idIndexMarker006" class="pcalibre1 calibre6 pcalibre"/>micro apps, the time required for each team to compile, build, and run automated unit tests for their part of the micro apps is greatly reduced. This allows teams to build and deliver features a <span>lot faster.</span></p>
			<p class="calibre3"><em class="italic">While teams run isolated unit and automation tests for their micro apps more frequently, we recommend running full regression suites of end-to-end tests on demand or before committing the code </em><span><em class="italic">to Git.</em></span></p>
			<h3 class="calibre9">Progressive upgrades</h3>
			<p class="calibre3">The frontend ecosystem is the fastest-evolving ecosystem. Every few months, a new framework or library springs up that is better and faster than the previous one. Having said that, there is always an urge to rewrite your existing application using the <span>latest framework.</span></p>
			<p class="calibre3">With large applications, it’s not possible to easily upgrade or introduce a new framework without rewriting the entire application. The cost of rewriting the application and the associated risks of introducing bugs due to the rewrite are far too high. Teams keep deprioritizing the upgrade and within a few years, they find themselves working on an <span>outdated framework.</span></p>
			<p class="calibre3">With microfrontends, it is easier to pick up one small micro app and upgrade it or rewrite it and then gradually roll it out to other micro apps. This also allows teams to experience the benefits of the new change and learn and course-correct as they migrate the new framework to the other <span>micro apps.</span></p>
			<p class="calibre3">As we move on to the next section, let’s quickly recap some of the key points that we’ve learned <span>so far:</span></p>
			<ul class="calibre15">
				<li class="calibre14">Microfrontends are suited for building large-scale apps where teams are set up as full-stack teams, where the backend developers, frontend developers, product owners, and so on are within the same <span>scrum team.</span></li>
				<li class="calibre14">Microfrontends <a id="_idIndexMarker007" class="pcalibre1 calibre6 pcalibre"/>have numerous benefits, such as team independence, features launched with improved velocity, and better developer experience. However, these benefits will start becoming visible once you have overcome the initial phase of complexity associated with the “<span>microfrontend premium.”</span></li>
			</ul>
			<h1 id="_idParaDest-22" class="calibre7"><a id="_idTextAnchor021" class="pcalibre1 calibre6 pcalibre"/>Understanding Microfrontend patterns</h1>
			<p class="calibre3">When it comes to microfrontends, there <a id="_idIndexMarker008" class="pcalibre1 calibre6 pcalibre"/>are way too many interpretations. These are still early days for microfrontends, and there is no right or wrong way of building them. The answer to any technical/architectural question is “It depends….” In this section, we will focus on two of the most common patterns that teams adopt while building microfrontends. We will see what key factors to consider when deciding which pattern may be right for you. We will end this section by building a really basic microfrontend to get the <span>ball rolling.</span></p>
			<p class="calibre3">At a very high level, there are two primary patterns for microfrontends. Both of these patterns can be applied irrespective <a id="_idIndexMarker009" class="pcalibre1 calibre6 pcalibre"/>of whether you are building a <strong class="bold">Server-Side-Rendered</strong> (<strong class="bold">SSR</strong>) app or<a id="_idIndexMarker010" class="pcalibre1 calibre6 pcalibre"/> a <strong class="bold">Client-Side-Rendered</strong> (<strong class="bold">CSR</strong>) app. To better illustrate these patterns, we will take the use case of an e-commerce application such <span>as Amazon.</span></p>
			<p class="calibre3">In the following subsections, we will look at these two patterns and how they differ from <span>each other.</span></p>
			<h2 id="_idParaDest-23" class="calibre5"><a id="_idTextAnchor022" class="pcalibre1 calibre6 pcalibre"/>The Multi-SPA Pattern</h2>
			<p class="calibre3">The<a id="_idIndexMarker011" class="pcalibre1 calibre6 pcalibre"/> first pattern that we will discuss is the <strong class="bold">multi-SPA</strong> pattern. As<a id="_idIndexMarker012" class="pcalibre1 calibre6 pcalibre"/> the name suggests, the application is built up of multiple SPAs. Here, the app is broken down into 2-3 distinct SPAs and each app is rendered at its own URL. When the user navigates from one SPA to another, they are redirected via a browser reload. In the case of an e-commerce application, we could look at the search, product listing, and product details as one SPA, and the cart and checkout as the other SPA. Similarly, the <strong class="bold">My Accounts</strong> section, which includes the login, registration, and profile information, would form the <span>third SPA.</span></p>
			<p class="calibre3">The following<a id="_idIndexMarker013" class="pcalibre1 calibre6 pcalibre"/> figure shows an illustration of a multi-SPA pattern microfrontend for an <span>e-commerce app:</span></p>
			<div class="calibre2">
				<div id="_idContainer008" class="img---figure">
					<img src="image/Figure_1.02_B18987.jpg" alt="Figure 1.2 – Multi-SPA pattern microfrontend for an e-commerce app" class="calibre4"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 1.2 – Multi-SPA pattern microfrontend for an e-commerce app</p>
			<p class="calibre3">As you <a id="_idIndexMarker014" class="pcalibre1 calibre6 pcalibre"/>can see from the preceding figure, our e-commerce application consists of three SPAs: the Catalog SPA, the Checkout SPA, and the <span>Accounts SPA.</span></p>
			<p class="calibre3">In the simplest form of this pattern, each app behaves as an independent SPA that sits within its own unique <span>global URL.</span></p>
			<p class="calibre3">Each SPA is deployed at a unique global route. For example, the catalog app would be deployed at a URL such as <strong class="source-inline">mysite.com/catalog/*</strong> and all subsequent secondary routes within the catalog app will load up as an SPA within the <strong class="source-inline">/</strong><span><strong class="source-inline">catalog/*</strong></span><span> route.</span></p>
			<p class="calibre3">Similarly, the accounts app would live in the global route of <strong class="source-inline">mysite.com/accounts/</strong> and the different pages within the account’s app login, signup, and profile would be available at URLs such as <strong class="source-inline">mysite.com/accounts/login</strong> <span>or </span><span><strong class="source-inline">mysite.com/accounts/register</strong></span><span>.</span></p>
			<p class="calibre3">As mentioned earlier, when the user moves from one macro app to another, there will be a reload of the page in the browser. This is because we usually use the HTML <strong class="source-inline">href</strong> tags to navigate between the apps. This browser refresh is perfectly fine. I’ve seen teams go to great lengths, complicating their architecture, to try to achieve a single-page experience. The truth, however, is that users don’t really care if your app is an SPA or a <strong class="bold">Multi-Page App</strong> (<strong class="bold">MPA</strong>). As<a id="_idIndexMarker015" class="pcalibre1 calibre6 pcalibre"/> long as the experience is fast and non-janky, they <span>are happy.</span></p>
			<p class="calibre3">At times, the <a id="_idIndexMarker016" class="pcalibre1 calibre6 pcalibre"/>browser reload may work in your<a id="_idIndexMarker017" class="pcalibre1 calibre6 pcalibre"/> favor as it will reduce the risks of memory bloat due to either memory leaks or too much data being put into a <span>data store.</span></p>
			<p class="calibre3">However, if you really want to nail that SPA experience, then you can always create a thin app shell that hosts the global routes and data store, such that each app is called within this app shell. <em class="italic">We will be going into more detail of this pattern in the </em><span><em class="italic">upcoming chapters.</em></span></p>
			<p class="calibre3">In this pattern, the routing is generally split into two parts, the global or primary routes, which reside within the app shell, and the secondary routes, which reside within the <span>respective apps.</span></p>
			<p class="calibre3">The following figure shows an example of a multi-SPA with an <span>app shell:</span></p>
			<div class="calibre2">
				<div id="_idContainer009" class="img---figure">
					<img src="image/Figure_1.03_B18987.jpg" alt="Figure 1.﻿3 – A multi-SPA pattern with an app shell to give an SPA experience" class="calibre4"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 1.3 – A multi-SPA pattern with an app shell to give an SPA experience</p>
			<p class="calibre3">Here, you will notice that we have introduced the notion of an app shell, which incorporates the header component, and the different SPAs load within the content slot. This pattern gives a true SPA experience as the header component doesn’t refresh when transitioning from one SPA to <span>the other.</span></p>
			<h2 id="_idParaDest-24" class="calibre5"><a id="_idTextAnchor023" class="pcalibre1 calibre6 pcalibre"/>The Micro Apps Pattern</h2>
			<p class="calibre3">The other<a id="_idIndexMarker018" class="pcalibre1 calibre6 pcalibre"/> pattern for building microfrontends is what we call <a id="_idIndexMarker019" class="pcalibre1 calibre6 pcalibre"/>the <strong class="bold">micro apps</strong> pattern. The reason we call it the micro apps pattern is that this is a more granular breakdown of <span>the application.</span></p>
			<p class="calibre3">As you can see in <span><em class="italic">Figure 1</em></span><em class="italic">.4</em>, the web page is composed of different components where each component is an independent micro app that can exist in isolation and work in tandem with other micro apps as part of the <span>same page.</span></p>
			<p class="calibre3"><img src="image/Figure_1.04_B18987.png" alt="Figure 1.﻿4 – Micro app architecture with product images and recommended products co-existing as different micro apps" class="calibre4"/></p>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 1.4 – Micro app architecture with product images and recommended products co-existing as different micro apps</p>
			<p class="calibre3">You will notice the preceding diagram is a more granular version of <span><em class="italic">Figure 1</em></span><em class="italic">.3</em>, where we further break down the central content slot into smaller micro apps. Notice how the central content area now consists of two micro apps, namely the product details and recommended products <span>micro apps.</span></p>
			<p class="calibre3">The micro apps pattern is a lot more complex than the multi-SPA pattern and it is recommended mainly for very large web applications, where there are multiple teams that own different elements on a <span>single page.</span></p>
			<p class="calibre3">In <span><em class="italic">Figure 1</em></span><em class="italic">.4</em>, we would assume that there is a dedicated team that manages the product description component of the page, and another team that manages the product recommendations component on the <span>same page.</span></p>
			<p class="calibre3">We would<a id="_idIndexMarker020" class="pcalibre1 calibre6 pcalibre"/> also assume that the frequencies at which these components get updated with feature enhancements would be different; for example, the recommendations micro app would constantly undergo A/B tests, and<a id="_idIndexMarker021" class="pcalibre1 calibre6 pcalibre"/> hence would need to be deployed more frequently than the product image and description micro app, which may not change <span>as often.</span></p>
			<p class="calibre3">In this pattern, all the routes, both primary and secondary, are managed by the app shell. Here, in addition to managing the routing and global states, the app shell also needs to store/retrieve information about the page layout for each of the routes and the different micro apps that need to be loaded within each of <span>the pages.</span></p>
			<p class="calibre3">In most cases, such large apps usually<a id="_idIndexMarker022" class="pcalibre1 calibre6 pcalibre"/> have a <strong class="bold">Content Management System</strong> (<strong class="bold">CMS</strong>) in place or a templating engine where the layout and the component tree are stored and served to <span>the frontend.</span></p>
			<p class="calibre3">To summarize, as we come to the end of this section, we saw two primary patterns for building microfrontends, the multi-SPA pattern and the micro apps pattern. These patterns primarily differ in the level of granularity at which you break down your application, and how routing is managed within the <span>microfrontend architecture.</span></p>
			<p class="calibre3">In the next section, we will look at the guidelines that will help you choose the <span>right pattern.</span></p>
			<h1 id="_idParaDest-25" class="calibre7"><a id="_idTextAnchor024" class="pcalibre1 calibre6 pcalibre"/>Choosing a suitable pattern</h1>
			<p class="calibre3">Now that we have a <a id="_idIndexMarker023" class="pcalibre1 calibre6 pcalibre"/>broad understanding of the two patterns of microfrontends, let’s spend some time on some of the key considerations that will help you decide which pattern to <span>go with.</span></p>
			<p class="calibre3">While there may be <a id="_idIndexMarker024" class="pcalibre1 calibre6 pcalibre"/>numerous points of view on what is right, how far to think into the future, and how to future-proof your app and architecture, we believe there are two primary factors that will help you decide on which of the two patterns to go with for your microfrontend architecture. Let’s look at them in detail in the <span>following sections.</span></p>
			<h2 id="_idParaDest-26" class="calibre5"><a id="_idTextAnchor025" class="pcalibre1 calibre6 pcalibre"/>Team Composition</h2>
			<p class="calibre3">For teams that build applications on microservices and microfrontends, it is a common practice that they are vertically sliced based on business functionality. In the e-commerce example, we may have a team that focuses on the browsing journey and another team that focuses on the checkout journey. If one scrum team owns the entire browser journey <a id="_idIndexMarker025" class="pcalibre1 calibre6 pcalibre"/>and one scrum team owns the entire checkout journey, then it is recommended that you go for the multi-SPA pattern. However, if you have numerous small teams that own different entities of the business domain, such as, say, search, product recommendations, and promotions, then it would be wise to go for the micro apps pattern. As mentioned earlier, the rule of thumb is for each scrum team to ideally own a single <span>micro app.</span></p>
			<h2 id="_idParaDest-27" class="calibre5"><a id="_idTextAnchor026" class="pcalibre1 calibre6 pcalibre"/>Frequency of Deployments</h2>
			<p class="calibre3">Another factor<a id="_idIndexMarker026" class="pcalibre1 calibre6 pcalibre"/> that would come into play when deciding how to break down your microfrontend would be the frequency of deployments. If there are specific sections of the app that change more than others, then those sections can be separated into its own microfrontend, which can be separately deployed without affecting the other sections of the app. This reduces the amount of testing that needs to be done because now we need to test only the micro app that is being changed and not the <span>entire application.</span></p>
			<p class="calibre3">As we can see, the decision on whether you should go for a multi-SPA pattern or the micro apps pattern boils down to the two key factors of team composition and deployment frequency, and this is directly related to the two keywords from the definition of microfrontend, namely, independent teams and <span>independent deployments.</span></p>
			<h1 id="_idParaDest-28" class="calibre7"><a id="_idTextAnchor027" class="pcalibre1 calibre6 pcalibre"/>Hello World with Microfrontends</h1>
			<p class="calibre3">OK, it’s time<a id="_idIndexMarker027" class="pcalibre1 calibre6 pcalibre"/> to get our hands dirty writing some code. We are <a id="_idIndexMarker028" class="pcalibre1 calibre6 pcalibre"/>going to start simple by building a basic multi-SPA pattern app. In this example, we will use Next.js, which is currently the most popular tool for building performant React applications. Follow <span>these steps:</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">For the rest of this chapter, we assume you are using <strong class="source-inline1">pnpm</strong> as the package manager. If not, replace <strong class="source-inline1">pnpm</strong> with <strong class="source-inline1">npm</strong> in the <span>respective commands.</span></p>
			<ol class="calibre13">
				<li class="calibre14">Let’s start by creating a root folder for our app. We’ll call it <strong class="source-inline1">my-store</strong>. Run the following command in <span>your terminal:</span><pre class="console">
<strong class="bold1">mkdir my-store</strong></pre></li>				<li class="calibre14">Now, let’s <strong class="source-inline1">cd</strong> into <strong class="source-inline1">my-store</strong> and <a id="_idIndexMarker029" class="pcalibre1 calibre6 pcalibre"/>create our <a id="_idIndexMarker030" class="pcalibre1 calibre6 pcalibre"/>two Next.js apps, namely, <strong class="source-inline1">home</strong> and <strong class="source-inline1">catalog</strong>, by typing the following commands in <span>our terminal:</span><pre class="console">
<strong class="bold1">cd my-store</strong><strong class="bold1">pnpm create-next-app@12</strong></pre><p class="calibre3">Or, we can type <span>the following:</span></p><pre class="console">
<strong class="bold1">cd my-store</strong><strong class="bold1">npx create-next-app@12</strong></pre></li>
				<li class="calibre14">When it prompts you to add a project name, call it <strong class="source-inline1">home</strong>. It will then go through the various steps and complete <span>the installation.</span><p class="calibre3">The interesting thing about create-next-app is even through you define the version as @12, it will nevertheless pull the latest version of Next.js, hence to ensure consistency with the rest of this chapter we will update the version of next in package.json <span>as follows:</span></p><pre class="console">
 "dependencies": {    "next": "12",
    "react": "18.2.0",
    "react-dom": "18.2.0"</pre></li>
				<li class="calibre14">Now delete the <strong class="source-inline1">node_modules</strong> folder and the package lock file and run the pnpm <span>i command</span></li>
			</ol>
			<p class="callout-heading">Important note</p>
			<p class="callout">While you can always use <strong class="source-inline1">yarn</strong> or <strong class="source-inline1">npx</strong> to run the CLI, we recommend using <strong class="source-inline1">pnpm</strong> as it is 2-3 times faster than <strong class="source-inline1">npm</strong> <span>or </span><span><strong class="source-inline1">yarn</strong></span><span>.</span></p>
			<ol class="calibre13">
				<li value="5" class="calibre14">Once it’s done with the setup, go ahead and create another app repeating steps 2-5. Let’s call this <span>project </span><span><strong class="source-inline1">catalog</strong></span><span>.</span><p class="calibre3">Once complete, your folder structure would look <span>as follows:</span></p><pre class="console">
└── my-store/    ├── home
    └── catalog</pre></li>
				<li class="calibre14">Now, let’s run the <strong class="source-inline1">home</strong> app by typing the <span>following commands:</span><pre class="console">
<strong class="bold1">cd home</strong><strong class="bold1">pnpm run dev</strong></pre></li>
				<li class="calibre14">Your app<a id="_idIndexMarker031" class="pcalibre1 calibre6 pcalibre"/> should now be served on port <strong class="source-inline1">3000</strong>. Verify it by visiting <strong class="source-inline1">http://localhost:3000</strong> on <span>your browser.</span></li>
				<li class="calibre14">Let’s get rid of<a id="_idIndexMarker032" class="pcalibre1 calibre6 pcalibre"/> the boilerplate code and add simple navigation. Locate and open up the file located at <strong class="source-inline1">home/pages/index.js</strong> and replace everything within the <strong class="source-inline1">&lt;main&gt;&lt;/main&gt;</strong> tags with <span>the following:</span><pre class="console">
     &lt;main className={styles.main}&gt;       &lt;nav&gt;&lt;a href="/"&gt;Home&lt;/a&gt; | &lt;a href="/catalog"&gt;Catalog&lt;/a&gt; &lt;/nav&gt;
        &lt;h1 className={styles.title}&gt;
          Home:Hello World! 
          &lt;/h1&gt;
          &lt;h2&gt;Welcome to my store&lt;/h2&gt;
        &lt;/main&gt;</pre><p class="calibre3">Note that we’ve added basic navigation to navigate between the home and catalog pages. Your home app that is running on <strong class="source-inline">localthost:3000</strong> should now look <span>as follows:</span></p></li>
			</ol>
			<div class="calibre2">
				<div id="_idContainer011" class="img---figure">
					<img src="image/Figure_1.05_B18987.jpg" alt="Figure 1.﻿5 – Screenshot of the home app with two navigation links for Home and Catalog" class="calibre4"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 1.5 – Screenshot of the home app with two navigation links for Home and Catalog</p>
			<ol class="calibre13">
				<li value="9" class="calibre14">Now, let’s<a id="_idIndexMarker033" class="pcalibre1 calibre6 pcalibre"/> move on to the catalog app. Navigate to <a id="_idIndexMarker034" class="pcalibre1 calibre6 pcalibre"/>the index page, located at <strong class="source-inline1">/catalog/pages/index.js</strong>, and again, let’s get rid of the boilerplate code and replace the contents within the <strong class="source-inline1">&lt;main&gt;</strong> tag with the <span>following code:</span><pre class="console">
      &lt;main className={styles.main}&gt;        &lt;nav&gt;&lt;a href="/"&gt;Home&lt;/a&gt; | &lt;a href="/catalog"&gt;Catalog&lt;/a&gt; &lt;/nav&gt;
        &lt;h1 className={styles.title}&gt;
            Catalog:Hello World! 
      &lt;/h1&gt;
       &lt;h2&gt;List of Products&lt;/h2&gt;
      &lt;/main&gt;</pre><p class="calibre3">Now, since we already have the home page being served on port <strong class="source-inline">3000</strong>, we will run our catalog app on <span>port </span><span><strong class="source-inline">3001</strong></span><span>.</span></p></li>
				<li class="calibre14">We do this by adding the port flag for the <strong class="source-inline1">dev</strong> command within the <strong class="source-inline1">scripts</strong> section of the <strong class="source-inline1">catalog/package.json</strong> file, <span>as follows:</span><pre class="console">
"scripts": {    "dev": "next dev -p 3001
…
}</pre></li>
				<li class="calibre14">Now, running <strong class="source-inline1">pnpm run dev</strong> from within the catalog app should run the catalog<a id="_idIndexMarker035" class="pcalibre1 calibre6 pcalibre"/> app on <strong class="source-inline1">http://localhost:3001</strong>. You can <a id="_idIndexMarker036" class="pcalibre1 calibre6 pcalibre"/>see this in the <span>following screenshot:</span></li>
			</ol>
			<div class="calibre2">
				<div id="_idContainer012" class="img---figure">
					<img src="image/Figure_1.06_B18987.jpg" alt="Figure 1.﻿6 – Screenshot of the catalog app running on port 3001" class="calibre4"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 1.6 – Screenshot of the catalog app running on port 3001</p>
			<p class="calibre3">The next step is to wire these up such that when the user hits <strong class="source-inline">localhost:3000</strong>, it directs them to the home app, and when the user hits <strong class="source-inline">localhost:3000/catalog</strong>, they are redirected to the catalog app. This is to ensure that both apps feel as if they are part of the same app, even though they are running on <span>different ports.</span></p>
			<ol class="calibre13">
				<li value="12" class="calibre14">We do this by setting the <strong class="source-inline1">rewrites</strong> rule in the <strong class="source-inline1">home/next.config.js</strong> file, <span>as follows:</span><pre class="console">
const nextConfig = {  reactStrictMode: true,
  swcMinify: true,
  async rewrites() {
    return [
      {
        source: '/:path*',
        destination: `/:path*`,
      },
      {
        source: '/catalog',
        destination: `http://localhost:3001/catalog`,
      },
      {
        source: '/catalog/:path*',
        destination: `http://localhost:3001/catalog/:path*`,
      },
    ]
  },
}
module.exports = nextConfig</pre><p class="calibre3">As you can see from the preceding code, we simply tell Next.js that if the source URL is <strong class="source-inline">/catalog</strong>, then load the app <span>from </span><span><strong class="source-inline">localhost:3001/catalog</strong></span><span>.</span></p></li>
				<li class="calibre14">Before we<a id="_idIndexMarker037" class="pcalibre1 calibre6 pcalibre"/> test it out, there is another small <a id="_idIndexMarker038" class="pcalibre1 calibre6 pcalibre"/>change needed to the catalog app. As you can see, the catalog app will be served on the root of port <strong class="source-inline1">3001</strong>, but what we would like is for it to be served at <strong class="source-inline1">:3000/catalog</strong>. This is because with the rewrite we did earlier, Next.js will expect the catalog apps and its assets to be available at <strong class="source-inline1">/catalog/*</strong>. We can do this by setting the <strong class="source-inline1">basePath</strong> variable in the <strong class="source-inline1">catalog/next.config.js</strong> file <span>as follows:</span><pre class="console">
const nextConfig = {  reactStrictMode: true,
  swcMinify: true,
  basePath:'/catalog'
}</pre></li>
				<li class="calibre14">Now, to<a id="_idIndexMarker039" class="pcalibre1 calibre6 pcalibre"/> test that this is working fine, we <a id="_idIndexMarker040" class="pcalibre1 calibre6 pcalibre"/>will run up both of the apps in two different terminal windows by navigating to the home and catalog apps and running the <strong class="source-inline1">pnpm run </strong><span><strong class="source-inline1">dev</strong></span><span> command.</span></li>
				<li class="calibre14">Open up <strong class="source-inline1">http://localhost:3000</strong> in your browser and verify that the home app is loaded. Click on the <strong class="bold">Catalog</strong> link and verify that the catalog page does load up at <strong class="source-inline1">http://localhost:3000/catalog</strong>. Notice that the app catalog that’s running individually on port <strong class="source-inline1">3001</strong> is sort of “proxied” to load up within a unique URL of the parent/host app. This is one of the key principles of microfrontends, where apps running on different ports and different locations are “stitched” together to make it look like they are a part of the <span>same application.</span></li>
			</ol>
			<p class="calibre3">With that, we come to the end of creating our very first microfrontend with the multi-SPA pattern. We will look at the micro apps pattern in more detail in the upcoming chapters. This pattern meets the majority of the use cases for building microfrontends and checks all the key principles of microfrontends, which we are going to see in the <span>next chapter.</span></p>
			<h1 id="_idParaDest-29" class="calibre7"><a id="_idTextAnchor028" class="pcalibre1 calibre6 pcalibre"/>Summary</h1>
			<p class="calibre3">It’s a wrap for this chapter. We started off by learning how microfrontends (when executed correctly) help teams to continue to release new features at a consistent pace even as the app size and complexity grow. Then, we learned that there are two primary patterns for implementing microfrontends, the multi-SPA pattern and the micro apps pattern. We saw that the multi-SPA pattern is easier to implement and would suit the majority of use cases. The micro apps pattern would be more suitable when different elements of a given page are owned by different scrum teams. Finally, we learned how to build our very own microfrontend application and saw how we can navigate between the two apps while still giving the user the illusion that they are both part of a <span>single app.</span></p>
			<p class="calibre3">In the next chapter, we will look at some of the key principles to strictly adhere to when designing your microfrontend architecture. We will also look at some of the key components of microfrontend and the various ways they can <span>be implemented.</span></p>
		</div>
	</body></html>