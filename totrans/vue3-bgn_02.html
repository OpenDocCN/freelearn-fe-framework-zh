<html><head></head><body>
		<div id="_idContainer027">
			<h1 id="_idParaDest-29" class="chapter-number"><a id="_idTextAnchor028"/><span class="koboSpan" id="kobo.1.1">2</span></h1>
			<h1 id="_idParaDest-30"><a id="_idTextAnchor029"/><span class="koboSpan" id="kobo.2.1">The Foundation of Vue.js</span></h1>
			<p><span class="koboSpan" id="kobo.3.1">If you are reading this book, chances are that you have decided to use Vue.js as your framework of choice and there is very little reason to try to convince you not to use it. </span><span class="koboSpan" id="kobo.3.2">We are going to use this chapter to begin sharing details of what makes Vue.js unique and why it has become </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">so successful.</span></span></p>
			<p><span class="koboSpan" id="kobo.5.1">We are first going to learn what makes Vue.js different from other frameworks; we will then move on to study Vue.js’ reactivity and its lifecycles. </span><span class="koboSpan" id="kobo.5.2">Finally, we will learn about the component structure </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">of Vue.js.</span></span></p>
			<p><span class="koboSpan" id="kobo.7.1">In this chapter, we will learn </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">the following:</span></span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.9.1">Vue.js’ </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">reactivity fundamentals</span></span></li>
				<li><span class="koboSpan" id="kobo.11.1">Understanding the Vue.js lifecycle </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">and hooks</span></span></li>
				<li><span class="koboSpan" id="kobo.13.1">Vue.js’ </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">component structure</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.15.1">The goal of this chapter is to provide you with information regarding Vue.js that will become the foundation of your future learning. </span><span class="koboSpan" id="kobo.15.2">Understanding Vue.js’ reactivity will help differentiate Vue.js from other frontend frameworks and libraries, and you will learn the complete lifecycle of a Vue.js component to help you make the correct technical decisions. </span><span class="koboSpan" id="kobo.15.3">Finally, understanding the different ways to define a Vue.js component will prepare you for the chapters </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">to come.</span></span></p>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor030"/><span class="koboSpan" id="kobo.17.1">Vue.js reactivity fundamentals</span></h1>
			<p><span class="koboSpan" id="kobo.18.1">Vue.js has been </span><a id="_idIndexMarker050"/><span class="koboSpan" id="kobo.19.1">around for some time; the framework’s first release dates back to 2014, when its creator, Evan You, a former Google developer, informed the world of </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">its creation.</span></span></p>
			<p><span class="koboSpan" id="kobo.21.1">Evan’s previous experience with Angular at Google gave him the knowledge necessary to build a great framework. </span><span class="koboSpan" id="kobo.21.2">In an interview for </span><em class="italic"><span class="koboSpan" id="kobo.22.1">Between the Wires</span></em><span class="koboSpan" id="kobo.23.1"> shortly after making the framework public, Evan said </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">the following:</span></span></p>
			<p class="author-quote"><span class="koboSpan" id="kobo.25.1">I figured, what if I could just extract the part that I really liked about Angular and build something really lightweight.</span></p>
			<p><span class="koboSpan" id="kobo.26.1">Evan did not just create a lightweight framework, but he also managed to build an amazing community around it, making it one of the most loved frameworks </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">by developers.</span></span></p>
			<p><span class="koboSpan" id="kobo.28.1">Vue.js has had just three major releases until now, with the latest one being a full rewrite that made Vue.js faster, smaller, and even easier </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">to use.</span></span></p>
			<p><span class="koboSpan" id="kobo.30.1">Two main aspects made Vue.js so successful. </span><span class="koboSpan" id="kobo.30.2">The first is that its growth and adoption are driven by the community for the community. </span><span class="koboSpan" id="kobo.30.3">Vue.js is one of the few major frameworks not to be backed by a big company. </span><span class="koboSpan" id="kobo.30.4">It is fully funded by people’s donations to the core </span><a id="_idIndexMarker051"/><span class="koboSpan" id="kobo.31.1">team and its development is mainly driven by the community. </span><span class="koboSpan" id="kobo.31.2">This is shown by the focus on the development experience that is always present within the </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">Vue.js ecosystem.</span></span></p>
			<p><span class="koboSpan" id="kobo.33.1">The second aspect that makes it unique is its reactivity system. </span><span class="koboSpan" id="kobo.33.2">The Vue.js core engine has been built to be reactive behind the scenes, making handling states with Vue.js simple </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">and intuitive.</span></span></p>
			<p><span class="koboSpan" id="kobo.35.1">When we talk about reactivity in development, we refer to the ability of certain variables to automatically update when a change occurs. </span><span class="koboSpan" id="kobo.35.2">A simple example of reactivity outside of the developing world is offered by Excel and Google Sheets. </span><span class="koboSpan" id="kobo.35.3">Setting up a calculation, such as a sum of a column, will result in the total number being “reactive” to any chance that happens in the </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">summed cells:</span></span></p>
			<div>
				<div id="_idContainer022" class="IMG---Figure">
					<span class="koboSpan" id="kobo.37.1"><img src="image/B21130_02_01.jpg" alt="Figure 2.1: Google Sheet example showing how the value of cells updates automatically"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.38.1">Figure 2.1: Google Sheet example showing how the value of cells updates automatically</span></p>
			<p><span class="koboSpan" id="kobo.39.1">Like Excel, reactivity in web development, particularly in Vue.js, allows your variables to be dynamic and automatically change when a value it depends </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">on changes.</span></span></p>
			<p><span class="koboSpan" id="kobo.41.1">Let’s see a real example to understand how reactivity plays a big part in the UI framework. </span><span class="koboSpan" id="kobo.41.2">Let’s start by seeing the behavior of vanilla JS and then see how this translates </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">into Vue.js.</span></span></p>
			<p><span class="koboSpan" id="kobo.43.1">In the following code, we are going to create two variables, </span><strong class="source-inline"><span class="koboSpan" id="kobo.44.1">firstName</span></strong><span class="koboSpan" id="kobo.45.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.46.1">lastName</span></strong><span class="koboSpan" id="kobo.47.1">, and then we will try to create a reactive variable </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.49.1">fullName</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.51.1">
let firstName = "Simone";
let secondName = "Cuomo";
const fullName = `${firstName} ${secondname}`;
console.log(fullName);
// output: Simone Cuomo</span></pre>
			<p><span class="koboSpan" id="kobo.52.1">In the preceding </span><a id="_idIndexMarker052"/><span class="koboSpan" id="kobo.53.1">code snippets, the full name that is printed in the console is equal to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">firstName</span></strong><span class="koboSpan" id="kobo.55.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.56.1">secondName</span></strong><span class="koboSpan" id="kobo.57.1"> variables that we have created. </span><span class="koboSpan" id="kobo.57.2">What would happen if we now change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">firstName</span></strong><span class="koboSpan" id="kobo.59.1"> variable to a different value? </span><span class="koboSpan" id="kobo.59.2">What would the value of </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">fullName</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.61.1"> be?</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.62.1">
let firstName = "Simone";
let secondName = "Cuomo";
const fullName = `${firstName} ${secondname}`;
console.log(fullName);
// output: Simone Cuomo
firstName = "John";
Console.log(fullName);
// output: Simone Cuomo</span></pre>
			<p><span class="koboSpan" id="kobo.63.1">As you can see from the preceding code, the variable that is supposed to print the full name has output the incorrect value, as it has not “reacted” to the change in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">firstName</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.65.1"> variable.</span></span></p>
			<p><span class="koboSpan" id="kobo.66.1">This is perfectly normal behavior; you do not want all variables to automatically react in JavaScript, as this will complicate its usage, but when it comes to the UI, having values that are updated is the </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">expected behavior.</span></span></p>
			<p><span class="koboSpan" id="kobo.68.1">Say, for example, you are filling up a basket and you want the total number of items to change if you add one more item to your basket, or you would like the word count to update if you type in a limited textbox, and </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">so on.</span></span></p>
			<p><span class="koboSpan" id="kobo.70.1">Let’s replicate the preceding example </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">using Vue.js:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.72.1">
let firstName = ref("Simone");
let secondName = ref("Cuomo");
const fullName = computed( () =&gt; `${firstName.value} ${secondName.value}`);
console.log(fullName);
// output: Simone Cuomo
firstName.value = "John";
Console.log(fullName);
// output: John Cuomo</span></pre>
			<p><span class="koboSpan" id="kobo.73.1">At this stage, your understanding of Vue.js is still limited to what experience you had before reading this book, so you are not expected to understand the preceding code yet. </span><span class="koboSpan" id="kobo.73.2">What we </span><a id="_idIndexMarker053"/><span class="koboSpan" id="kobo.74.1">need to focus our attention on is the output that the code produces when compared to the one produced by </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">plain JavaScript.</span></span></p>
			<p><span class="koboSpan" id="kobo.76.1">As the preceding code shows, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">fullName</span></strong><span class="koboSpan" id="kobo.78.1"> variable changes automatically as soon as any of its dependent variables (</span><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">firstName</span></strong><span class="koboSpan" id="kobo.80.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">secondName</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">) change.</span></span></p>
			<p><span class="koboSpan" id="kobo.83.1">Understanding how the reactivity system works behind the scenes is out of the scope of this book, but this does not prevent us from understanding the technicalities that take place behind </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">the scenes.</span></span></p>
			<p><span class="koboSpan" id="kobo.85.1">The following diagram shows what happens behind the scenes and how the reactivity actually </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">takes place:</span></span></p>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<span class="koboSpan" id="kobo.87.1"><img src="image/B21130_02_02.jpg" alt="Figure 2.2: Diagram explaining the Vue.js reactivity system"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.88.1">Figure 2.2: Diagram explaining the Vue.js reactivity system</span></p>
			<p><span class="koboSpan" id="kobo.89.1">This illustration </span><a id="_idIndexMarker054"/><span class="koboSpan" id="kobo.90.1">is a simplified version of what happens within the Vue.js reactivity core system to make our variables dynamic. </span><span class="koboSpan" id="kobo.90.2">Let’s break down what </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">is happening:</span></span></p>
			<ol>
				<li><span class="koboSpan" id="kobo.92.1">We defined reactive variables, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">FirstName</span></strong><span class="koboSpan" id="kobo.94.1">. </span><span class="koboSpan" id="kobo.94.2">Vue.js watches this variable for any </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">change event.</span></span></li>
				<li><span class="koboSpan" id="kobo.96.1">We declared a complex variable that is dependent on other reactive variables (</span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">e.g., </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">fullName</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">).</span></span></li>
				<li><span class="koboSpan" id="kobo.100.1">Vue.js tracks a dependency tree. </span><span class="koboSpan" id="kobo.100.2">It creates a list of what depends </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">on what.</span></span></li>
				<li><span class="koboSpan" id="kobo.102.1">When a change takes place in a reactive variable, the reactivity engine will </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">trigger </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">onDependenciesChange</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">.</span></span></li>
				<li><span class="koboSpan" id="kobo.106.1">Vue.js evaluates which values depend on the value that was just changed and triggers an update </span><em class="italic"><span class="koboSpan" id="kobo.107.1">only</span></em><span class="koboSpan" id="kobo.108.1"> if the value is part of </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">their dependencies.</span></span></li>
			</ol>
			<p><span class="koboSpan" id="kobo.110.1">While reading the preceding process, you probably thought that it sounded quite familiar, and you would be correct, as the reactivity system follows the same principles offered by HTML elements such as input fields. </span><span class="koboSpan" id="kobo.110.2">Elements such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">&lt;input&gt;</span></strong><span class="koboSpan" id="kobo.112.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">&lt;select&gt;</span></strong><span class="koboSpan" id="kobo.114.1">, and many more have the ability to hold values and react when they are changed by triggering an </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">onChange</span></strong><span class="koboSpan" id="kobo.116.1"> or </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">similar event.</span></span></p>
			<p><span class="koboSpan" id="kobo.118.1">As shown in the preceding example, listening to a change event to handle data reactivity is not something unique. </span><span class="koboSpan" id="kobo.118.2">So, what makes the Vue.js reactivity system special? </span><span class="koboSpan" id="kobo.118.3">Vue.js reactivity </span><a id="_idIndexMarker055"/><span class="koboSpan" id="kobo.119.1">stands out for the way it handles the dependencies tree and automatically updates variables behind the scenes. </span><span class="koboSpan" id="kobo.119.2">The reactivity system of Vue.js is non-obstructive and it is completely unseen by developers. </span><span class="koboSpan" id="kobo.119.3">Vue.js manages all the dependencies behind the scenes as part of its </span><strong class="old"><span class="koboSpan" id="kobo.120.1">lifecycles</span></strong><span class="koboSpan" id="kobo.121.1"> and acts upon changes with speed and </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">high performance.</span></span></p>
			<p><span class="koboSpan" id="kobo.123.1">This section introduced you to the Vue.js reactivity system, explaining how it plays a vital role in the success of the framework. </span><span class="koboSpan" id="kobo.123.2">We then explained, with the help of some examples, how the engine works behind the scenes. </span><span class="koboSpan" id="kobo.123.3">It is now time to understand how the Vue.js core engine works by taking a closer look at its lifecycles and understanding how they can be used within our </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">application development.</span></span></p>
			<h1 id="_idParaDest-32"><a id="_idTextAnchor031"/><span class="koboSpan" id="kobo.125.1">Understanding the Vue.js lifecycle and hooks</span></h1>
			<p><span class="koboSpan" id="kobo.126.1">As we progress into the book, our knowledge of Vue.js continues to expand. </span><span class="koboSpan" id="kobo.126.2">In this section, we are going to discuss the </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">Vue.js lifecycle.</span></span></p>
			<p><span class="koboSpan" id="kobo.128.1">When we </span><a id="_idIndexMarker056"/><span class="koboSpan" id="kobo.129.1">use Vue.js, the application goes through a defined list of steps, from creating the component HTML to gathering all the dynamic values, as well as displaying these </span><a id="_idIndexMarker057"/><span class="koboSpan" id="kobo.130.1">values in the DOM. </span><span class="koboSpan" id="kobo.130.2">Each of these is part of what we call the </span><strong class="old"><span class="koboSpan" id="kobo.131.1">lifecycle</span></strong><span class="koboSpan" id="kobo.132.1">, and in this section, we are going to define them all and learn when and how to use them during the course of our </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">development careers.</span></span></p>
			<p><span class="koboSpan" id="kobo.134.1">If you have ever tried to learn Vue.js in the past, you have probably already been exposed to the following diagram, which is available in the main </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">Vue.js documentation:</span></span></p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<span class="koboSpan" id="kobo.136.1"><img src="image/B21130_02_03.jpg" alt="Figure 2.3: Vue.js lifecycle diagram (from www.vuejs.org)"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.137.1">Figure 2.3: Vue.js lifecycle diagram (from www.vuejs.org)</span></p>
			<p><span class="koboSpan" id="kobo.138.1">No matter how long you have been using Vue.js, the preceding diagram will repeatedly appear in your browser history, and it will slowly be imprinted in your memory, as it is the foundation of Vue.js and a must-know in order to write clean and </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">performant code.</span></span></p>
			<p><span class="koboSpan" id="kobo.140.1">As you progress in the course of this book, you will be asked to revisit different parts of the lifecycle, and you will be asked to revisit </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">the diagram.</span></span></p>
			<p><span class="koboSpan" id="kobo.142.1">In the next section, we are going to review the diagram step by step and understand what it means and how this knowledge can be applied </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">during development.</span></span></p>
			<p><span class="koboSpan" id="kobo.144.1">We are going </span><a id="_idIndexMarker058"/><span class="koboSpan" id="kobo.145.1">to start explaining it from the top down, but we will be starting with </span><strong class="old"><span class="koboSpan" id="kobo.146.1">beforeCreate</span></strong><span class="koboSpan" id="kobo.147.1">. </span><span class="koboSpan" id="kobo.147.2">We are purposely leaving </span><strong class="old"><span class="koboSpan" id="kobo.148.1">setup</span></strong><span class="koboSpan" id="kobo.149.1"> for later, as it is easier to understand after all the lifecycles have been introduced, even if it is the first part of </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">the list.</span></span></p>
			<p><span class="koboSpan" id="kobo.151.1">The following lifecycles are progressive; this means that the end state of one of them is the beginning of </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">the next.</span></span></p>
			<h3><span class="koboSpan" id="kobo.153.1">beforeCreate</span></h3>
			<p><span class="koboSpan" id="kobo.154.1">This lifecycle is created as soon as a component is initialized. </span><span class="koboSpan" id="kobo.154.2">At this stage, our component </span><a id="_idIndexMarker059"/><span class="koboSpan" id="kobo.155.1">does not exist at all. </span><span class="koboSpan" id="kobo.155.2">The Vue.js framework has just been instructed to create it and it is triggering this hook to inform us that the component is on </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">its way.</span></span></p>
			<p><span class="koboSpan" id="kobo.157.1">At this stage, nothing of the component is available, no HTML is being created, and no internal variables are </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">set yet.</span></span></p>
			<p><span class="koboSpan" id="kobo.159.1">Usually, this lifecycle is used to trigger analytics logs or long </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">async tasks.</span></span></p>
			<h3><span class="koboSpan" id="kobo.161.1">created</span></h3>
			<p><span class="koboSpan" id="kobo.162.1">At this stage, Vue.js </span><a id="_idIndexMarker060"/><span class="koboSpan" id="kobo.163.1">knows about your component, and it has loaded its JavaScript logic, but it has not yet rendered or mounted </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">any HTML.</span></span></p>
			<p><span class="koboSpan" id="kobo.165.1">This is the perfect stage to trigger async calls to gather some data. </span><span class="koboSpan" id="kobo.165.2">Triggering a slow request now will help us save some time, as this request will continue behind the scenes while our component is </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">being rendered.</span></span></p>
			<h3><span class="koboSpan" id="kobo.167.1">beforeMount</span></h3>
			<p><span class="koboSpan" id="kobo.168.1">This lifecycle </span><a id="_idIndexMarker061"/><span class="koboSpan" id="kobo.169.1">is triggered right before the HTML is appended to the DOM. </span><span class="koboSpan" id="kobo.169.2">There are very limited use cases for this lifecycle, as most of the pre-render actions are triggered within the </span><span class="No-Break"><strong class="old"><span class="koboSpan" id="kobo.170.1">created</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.171.1"> lifecycle.</span></span></p>
			<h3><span class="koboSpan" id="kobo.172.1">mounted</span></h3>
			<p><span class="koboSpan" id="kobo.173.1">At this stage, the component has been fully rendered, and its HTML has been attached to the DOM. </span><span class="koboSpan" id="kobo.173.2">If you </span><a id="_idIndexMarker062"/><span class="koboSpan" id="kobo.174.1">need to complete any operation that requires you to access the DOM, this is the correct lifecycle, as the HTML is ready to be read </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">and modified.</span></span></p>
			<p><span class="koboSpan" id="kobo.176.1">If you come from a non-framework background, you may think that most of the logic of your component will probably be included in this lifecycle, but you will quickly learn that due to the way Vue.js components are specified, you will rarely need access to </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">the DOM.</span></span></p>
			<h3><span class="koboSpan" id="kobo.178.1">beforeUpdate and update</span></h3>
			<p><strong class="old"><span class="koboSpan" id="kobo.179.1">beforeUpdate</span></strong><span class="koboSpan" id="kobo.180.1"> and </span><strong class="old"><span class="koboSpan" id="kobo.181.1">update</span></strong><span class="koboSpan" id="kobo.182.1"> form a recursive circle that happens any time the component </span><a id="_idIndexMarker063"/><span class="koboSpan" id="kobo.183.1">data or dependencies change. </span><span class="koboSpan" id="kobo.183.2">We already introduced this step in the previous section when we spoke about the </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">reactivity system.</span></span></p>
			<p><strong class="old"><span class="koboSpan" id="kobo.185.1">beforeUpdate</span></strong><span class="koboSpan" id="kobo.186.1"> is triggered as soon as Vue.js realizes that a reactive value on which the component depends </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">has changed.</span></span></p>
			<p><span class="koboSpan" id="kobo.188.1">On the </span><a id="_idIndexMarker064"/><span class="koboSpan" id="kobo.189.1">other hand, </span><strong class="old"><span class="koboSpan" id="kobo.190.1">update</span></strong><span class="koboSpan" id="kobo.191.1"> is triggered when the value has been fully changed, and its value has been assigned to the correct DOM node and is ready in </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">the DOM.</span></span></p>
			<p><span class="koboSpan" id="kobo.193.1">You will very rarely have to use these two lifecycles directly, as Vue.js provides other features, such as computed properties and watchers, to be able to handle individual changes within the </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">component data.</span></span></p>
			<h3><span class="koboSpan" id="kobo.195.1">beforeUnmount and unmount</span></h3>
			<p><span class="koboSpan" id="kobo.196.1">At this </span><a id="_idIndexMarker065"/><span class="koboSpan" id="kobo.197.1">stage, our component is no longer needed, and Vue.js </span><a id="_idIndexMarker066"/><span class="koboSpan" id="kobo.198.1">is ready to remove it from the DOM. </span><span class="koboSpan" id="kobo.198.2">This could be due to the user navigating to a different page or any other event that would require the component to be removed from </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">the UI.</span></span></p>
			<p><span class="koboSpan" id="kobo.200.1">There is very little difference in usage between </span><strong class="old"><span class="koboSpan" id="kobo.201.1">beforeUnmount</span></strong><span class="koboSpan" id="kobo.202.1"> and </span><strong class="old"><span class="koboSpan" id="kobo.203.1">unmount</span></strong><span class="koboSpan" id="kobo.204.1">. </span><span class="koboSpan" id="kobo.204.2">This lifecycle </span><a id="_idIndexMarker067"/><span class="koboSpan" id="kobo.205.1">is very useful for unsubscribing to events, such </span><a id="_idIndexMarker068"/><span class="koboSpan" id="kobo.206.1">as “click” and “observers,” that will result in a drop in performance if </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">left active.</span></span></p>
			<h3><span class="koboSpan" id="kobo.208.1">setup</span></h3>
			<p><span class="koboSpan" id="kobo.209.1">As promised at the start of this section, we left </span><strong class="old"><span class="koboSpan" id="kobo.210.1">setup</span></strong><span class="koboSpan" id="kobo.211.1"> for last, as it is easier to explain it after all </span><a id="_idIndexMarker069"/><span class="koboSpan" id="kobo.212.1">lifecycles were covered. </span><strong class="old"><span class="koboSpan" id="kobo.213.1">setup</span></strong><span class="koboSpan" id="kobo.214.1"> is not a lifecycle in itself, but it is the entry point used by the CompositionAPI (something that you will learn </span><a id="_idIndexMarker070"/><span class="koboSpan" id="kobo.215.1">about a bit later in this chapter). </span><span class="koboSpan" id="kobo.215.2">When using </span><strong class="old"><span class="koboSpan" id="kobo.216.1">setup</span></strong><span class="koboSpan" id="kobo.217.1">, you have the ability to call and access all the lifecycles (</span><strong class="old"><span class="koboSpan" id="kobo.218.1">mounted</span></strong><span class="koboSpan" id="kobo.219.1">, </span><strong class="old"><span class="koboSpan" id="kobo.220.1">updated</span></strong><span class="koboSpan" id="kobo.221.1">, </span><strong class="old"><span class="koboSpan" id="kobo.222.1">unmounted</span></strong><span class="koboSpan" id="kobo.223.1">, and so on). </span><span class="koboSpan" id="kobo.223.2">You can think of </span><strong class="old"><span class="koboSpan" id="kobo.224.1">setup</span></strong><span class="koboSpan" id="kobo.225.1"> as a wrapper for the Vue.js lifecycle, a single method that includes all lifecycle hooks. </span><span class="koboSpan" id="kobo.225.2">Composition API is going to be what we use in this book, and we are going to explain the </span><strong class="old"><span class="koboSpan" id="kobo.226.1">setup</span></strong><span class="koboSpan" id="kobo.227.1"> function in much more detail at a </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">later stage.</span></span></p>
			<p><span class="koboSpan" id="kobo.229.1">In this section, we have learned the basic flow of Vue.js, introducing all its lifecycles. </span><span class="koboSpan" id="kobo.229.2">At this stage, we should know when Vue.js component is rendered, updated, or destroyed. </span><span class="koboSpan" id="kobo.229.3">This knowledge will drive our development and allow us to make the correct choices to make our application performant. </span><span class="koboSpan" id="kobo.229.4">In the next section, we are going to see how to introduce Vue.js component syntax, and we will also learn how to make use of the </span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">preceding lifecycles.</span></span></p>
			<h1 id="_idParaDest-33"><a id="_idTextAnchor032"/><span class="koboSpan" id="kobo.231.1">Vue.js component structure</span></h1>
			<p><span class="koboSpan" id="kobo.232.1">Components are the basis of the Vue.js framework. </span><span class="koboSpan" id="kobo.232.2">They are the building blocks required </span><a id="_idIndexMarker071"/><span class="koboSpan" id="kobo.233.1">to create an application using this framework. </span><span class="koboSpan" id="kobo.233.2">As was previously explained, a component can be as small as a simple button or as large as a </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">full page.</span></span></p>
			<p><span class="koboSpan" id="kobo.235.1">No matter their size, all components are built using the same syntax and structure. </span><span class="koboSpan" id="kobo.235.2">In this section, we are going to learn the different forms of syntax available to write components </span><a id="_idIndexMarker072"/><span class="koboSpan" id="kobo.236.1">and learn about the different sections that make up a Vue.js </span><strong class="old"><span class="koboSpan" id="kobo.237.1">single-file </span></strong><span class="No-Break"><strong class="old"><span class="koboSpan" id="kobo.238.1">component</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.239.1"> (</span></span><span class="No-Break"><strong class="old"><span class="koboSpan" id="kobo.240.1">SFC</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">).</span></span></p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor033"/><span class="koboSpan" id="kobo.242.1">Single-file components</span></h2>
			<p><span class="koboSpan" id="kobo.243.1">SFCs are </span><a id="_idIndexMarker073"/><span class="koboSpan" id="kobo.244.1">specific to Vue.js and can be </span><a id="_idIndexMarker074"/><span class="koboSpan" id="kobo.245.1">found in Vue.js projects with the extension </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">.vue</span></strong><span class="koboSpan" id="kobo.247.1">. </span><span class="koboSpan" id="kobo.247.2">These files are composed of three main sections: </span><strong class="old"><span class="koboSpan" id="kobo.248.1">template</span></strong><span class="koboSpan" id="kobo.249.1">, </span><strong class="old"><span class="koboSpan" id="kobo.250.1">script</span></strong><span class="koboSpan" id="kobo.251.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">and </span></span><span class="No-Break"><strong class="old"><span class="koboSpan" id="kobo.253.1">style</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.255.1">
&lt;template&gt;&lt;/template&gt;
&lt;script&gt;&lt;/script&gt;
&lt;style&gt;&lt;/style&gt;</span></pre>
			<p><span class="koboSpan" id="kobo.256.1">The Vue.js compiler takes the preceding three sections and splits them up into individual chunks during build time. </span><span class="koboSpan" id="kobo.256.2">We are now going to explain each of them in this section. </span><span class="koboSpan" id="kobo.256.3">We will cover the SFC section in the </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">following order:</span></span></p>
			<ol>
				<li><span class="No-Break"><span class="koboSpan" id="kobo.258.1">Template</span></span></li>
				<li><span class="No-Break"><span class="koboSpan" id="kobo.259.1">Style</span></span></li>
				<li><span class="No-Break"><span class="koboSpan" id="kobo.260.1">Script</span></span></li>
			</ol>
			<h3><span class="koboSpan" id="kobo.261.1">The &lt;template&gt; tag</span></h3>
			<p><span class="koboSpan" id="kobo.262.1">The first </span><a id="_idIndexMarker075"/><span class="koboSpan" id="kobo.263.1">section is </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">&lt;template&gt;</span></strong><span class="koboSpan" id="kobo.265.1">. </span><span class="koboSpan" id="kobo.265.2">This section includes the HTML hosted by our component. </span><span class="koboSpan" id="kobo.265.3">So, if we take an example of an extremely </span><a id="_idIndexMarker076"/><span class="koboSpan" id="kobo.266.1">simple button, the template will look </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">like this:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.268.1">
&lt;template&gt;
    &lt;button&gt;My button&lt;/button&gt;
&lt;/template&gt;</span></pre>
			<p><span class="koboSpan" id="kobo.269.1">In contrast to React, the HTML of a Vue.js component is plain </span><strong class="old"><span class="koboSpan" id="kobo.270.1">HTML</span></strong><span class="koboSpan" id="kobo.271.1"> and not </span><strong class="old"><span class="koboSpan" id="kobo.272.1">JSX</span></strong><span class="koboSpan" id="kobo.273.1">. </span><span class="koboSpan" id="kobo.273.2">As we will learn in the course of the book, Vue.js provides some handy tools to simplify the content of </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">our HTML.</span></span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.275.1">Important note</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.276.1">As for template writing styles, it is possible to write your HTML with different methods, such as render functions, or by writing it in JSX (with the correct loader), but these two methods are for specific uses and are not expected within the </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">Vue.js ecosystem.</span></span></p>
			<h3><span class="koboSpan" id="kobo.278.1">The &lt;style&gt; tag</span></h3>
			<p><span class="koboSpan" id="kobo.279.1">The next section available is </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">&lt;style&gt;</span></strong><span class="koboSpan" id="kobo.281.1">. </span><span class="koboSpan" id="kobo.281.2">This section will include the styles associated with our component using plain </span><strong class="old"><span class="koboSpan" id="kobo.282.1">CSS</span></strong><span class="koboSpan" id="kobo.283.1">. </span><span class="koboSpan" id="kobo.283.2">If you are not completely new to Vue.js, you may have realized </span><a id="_idIndexMarker077"/><span class="koboSpan" id="kobo.284.1">that what I just said is not fully true, as using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">&lt;style&gt;</span></strong><span class="koboSpan" id="kobo.286.1"> tag in a component does not </span><em class="italic"><span class="koboSpan" id="kobo.287.1">scope</span></em><span class="koboSpan" id="kobo.288.1"> the style to that </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">specific component.</span></span></p>
			<p><span class="koboSpan" id="kobo.290.1">Before we move on, let’s explain what it actually means for styles to be scoped and how to achieve this in our </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">Vue.js application.</span></span></p>
			<p><span class="koboSpan" id="kobo.292.1">When we use a simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">&lt;style&gt;</span></strong><span class="koboSpan" id="kobo.294.1"> tag, as shown in the preceding example, our style will leak to the rest of the application. </span><span class="koboSpan" id="kobo.294.2">Anything we declare in the tag will be global unless we scope it </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">with CSS:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.296.1">
&lt;style&gt;
p {
  color: red;
}
&lt;/style&gt;</span></pre>
			<p><span class="koboSpan" id="kobo.297.1">Writing the preceding style in Vue.js is permitted and is even suggested for performance and maintainability reasons. </span><span class="koboSpan" id="kobo.297.2">The problem is that the preceding declaration will change the color of our paragraph to red in the whole application and not just in the component in which it has </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">been written.</span></span></p>
			<p><span class="koboSpan" id="kobo.299.1">Luckily for us, Vue.js has a handy tool to use in the case where we would like our component to be fully scoped, making sure that no style bleeds and breaks the rest of the app. </span><span class="koboSpan" id="kobo.299.2">To do so, we need to add an attribute called </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">scoped</span></strong><span class="koboSpan" id="kobo.301.1"> to our </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">&lt;</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">style&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.304.1"> tag:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.305.1">
&lt;style </span><strong class="old"><span class="koboSpan" id="kobo.306.1">scoped</span></strong><span class="koboSpan" id="kobo.307.1">&gt;
p {
  color: red;
}
&lt;/style&gt;</span></pre>
			<p><span class="koboSpan" id="kobo.308.1">With this new attribute, our styles will be locked to the component in which they are defined, and they will not affect the rest of the application. </span><span class="koboSpan" id="kobo.308.2">We are going to learn more about when it is best to use these two methods when building our </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">Companion App</span></span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">.</span></span></p>
			<h3><span class="koboSpan" id="kobo.311.1">The &lt;script&gt; tag</span></h3>
			<p><span class="koboSpan" id="kobo.312.1">The next section available within an SFC is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">&lt;script&gt;</span></strong><span class="koboSpan" id="kobo.314.1"> tag. </span><span class="koboSpan" id="kobo.314.2">This tag will include the component </span><a id="_idIndexMarker078"/><span class="koboSpan" id="kobo.315.1">JavaScript logic, from the properties that are accepted for the component to the private data used to define the component logic, all the </span><a id="_idIndexMarker079"/><span class="koboSpan" id="kobo.316.1">way to the actual methods needed for the component to </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">function properly.</span></span></p>
			<p><span class="koboSpan" id="kobo.318.1">Just a few years ago, when Vue.js’ major version was still 2, components were mostly defined using </span><a id="_idIndexMarker080"/><span class="koboSpan" id="kobo.319.1">a syntax called </span><strong class="old"><span class="koboSpan" id="kobo.320.1">Options API</span></strong><span class="koboSpan" id="kobo.321.1">. </span><span class="koboSpan" id="kobo.321.2">Even though other methodologies were available, this was the main way to write a </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">Vue.js component.</span></span></p>
			<p><span class="koboSpan" id="kobo.323.1">With the release of Vue.js 3, a new method of writing components was created. </span><span class="koboSpan" id="kobo.323.2">This is offered alongside the existing Options API, and it offers better TypeScript support, improved </span><a id="_idIndexMarker081"/><span class="koboSpan" id="kobo.324.1">techniques to reuse logic, and flexible code organization. </span><span class="koboSpan" id="kobo.324.2">This method is called </span><span class="No-Break"><strong class="old"><span class="koboSpan" id="kobo.325.1">Composition API</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">.</span></span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.327.1">Important note</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.328.1">Composition </span><a id="_idIndexMarker082"/><span class="koboSpan" id="kobo.329.1">API is also referred to as </span><span class="No-Break"><strong class="old"><span class="koboSpan" id="kobo.330.1">Script Setup</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.332.1">At this moment in time, neither of the two methods is officially preferred over the other; this is also emphasized by the Vue.js official documentation, which currently showcases all its tutorials and examples using both methodologies, offering the option to switch between </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">the methods:</span></span></p>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<span class="koboSpan" id="kobo.334.1"><img src="image/B21130_02_04.jpg" alt="Figure 2.4: Vue.js official documentation for API preference switch"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.335.1">Figure 2.4: Vue.js official documentation for API preference switch</span></p>
			<p><span class="koboSpan" id="kobo.336.1">The content </span><a id="_idIndexMarker083"/><span class="koboSpan" id="kobo.337.1">of this book and its Companion App are </span><a id="_idIndexMarker084"/><span class="koboSpan" id="kobo.338.1">going to be written using Composition API. </span><span class="koboSpan" id="kobo.338.2">This decision was made for two </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">main reasons:</span></span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.340.1">Due to Vue.js 2’s history, the web is full of resources that focus on Options API but less so on the new Composition </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">API syntax</span></span></li>
				<li><span class="koboSpan" id="kobo.342.1">Evan You (the creator of Vue.js) has predicted (more than once) that, in the long run, Composition API will take over and become </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">the standard</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.344.1">Because I am a strong believer that extra knowledge does no harm, in this section, we are going to learn how to define the component in both syntaxes, including Options API. </span><span class="koboSpan" id="kobo.344.2">Knowing both methods can help you build a strong foundation to support your learning of the </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">Vue.js framework.</span></span></p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor034"/><span class="koboSpan" id="kobo.346.1">Options API versus Composition API – Two sides of the same coin</span></h2>
			<p><span class="koboSpan" id="kobo.347.1">Under the </span><a id="_idIndexMarker085"/><span class="koboSpan" id="kobo.348.1">hood, both methods are actually going to </span><a id="_idIndexMarker086"/><span class="koboSpan" id="kobo.349.1">produce a very similar output, with Composition </span><a id="_idIndexMarker087"/><span class="koboSpan" id="kobo.350.1">API producing slightly more performant code. </span><span class="koboSpan" id="kobo.350.2">Nevertheless, the syntax differences and benefits that these methods bring are quite different and can make a big change depending on </span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">your habits.</span></span></p>
			<p><span class="koboSpan" id="kobo.352.1">The first and main difference between Composition API and Options API is in the way the </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">&lt;script&gt;</span></strong><span class="koboSpan" id="kobo.354.1"> section of your code is broken down. </span><span class="koboSpan" id="kobo.354.2">As I mentioned before, both syntaxes </span><a id="_idIndexMarker088"/><span class="koboSpan" id="kobo.355.1">will offer the </span><a id="_idIndexMarker089"/><span class="koboSpan" id="kobo.356.1">same features, so this means that we can </span><a id="_idIndexMarker090"/><span class="koboSpan" id="kobo.357.1">declare props data, compute, and methods, as well as access all the lifecycles in both methods, but the way we do </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">so differs.</span></span></p>
			<p><span class="koboSpan" id="kobo.359.1">The differences are </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">as follows:</span></span></p>
			<ul>
				<li><strong class="old"><span class="koboSpan" id="kobo.361.1">Composition API</span></strong><span class="koboSpan" id="kobo.362.1">: Code </span><a id="_idIndexMarker091"/><span class="koboSpan" id="kobo.363.1">broken down </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">by functionality</span></span></li>
				<li><strong class="old"><span class="koboSpan" id="kobo.365.1">Options API</span></strong><span class="koboSpan" id="kobo.366.1">: Code </span><a id="_idIndexMarker092"/><span class="koboSpan" id="kobo.367.1">broken down by </span><span class="No-Break"><span class="koboSpan" id="kobo.368.1">Vue.js options</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.369.1">Let’s look at an example to clearly define the difference between </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">both methods.</span></span></p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<span class="koboSpan" id="kobo.371.1"><img src="image/B21130_02_05_v2.jpg" alt="Figure 2.5: Comparison between Composition API and Options API for breaking down code"/></span>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.372.1">Figure 2.5: Comparison between Composition API and Options API for breaking down code</span></p>
			<p><span class="koboSpan" id="kobo.373.1">As </span><a id="_idIndexMarker093"/><span class="koboSpan" id="kobo.374.1">shown in the </span><a id="_idIndexMarker094"/><span class="koboSpan" id="kobo.375.1">preceding diagram, in Options API, the code does </span><a id="_idIndexMarker095"/><span class="koboSpan" id="kobo.376.1">not take into consideration the actual component requirements and logic, but it is sliced vertically using Vue.js options: </span><strong class="old"><span class="koboSpan" id="kobo.377.1">Props</span></strong><span class="koboSpan" id="kobo.378.1">, </span><strong class="old"><span class="koboSpan" id="kobo.379.1">Data</span></strong><span class="koboSpan" id="kobo.380.1">, </span><strong class="old"><span class="koboSpan" id="kobo.381.1">Methods</span></strong><span class="koboSpan" id="kobo.382.1">, </span><strong class="old"><span class="koboSpan" id="kobo.383.1">Computed</span></strong><span class="koboSpan" id="kobo.384.1">, </span><strong class="old"><span class="koboSpan" id="kobo.385.1">mounted</span></strong><span class="koboSpan" id="kobo.386.1">, and </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">so on.</span></span></p>
			<p><span class="koboSpan" id="kobo.388.1">On the other hand, Composition API takes a different approach by breaking down the component by its technical output. </span><span class="koboSpan" id="kobo.388.2">This allows us to create a section for Feature 1, a section for Feature 2, and </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">so on</span></span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.391.1">The second difference is associated with TypeScript support. </span><span class="koboSpan" id="kobo.391.2">This is the main reason that led the Vue.js core team to decide to create The Composition API during the Vue.js 3 rewrite. </span><span class="koboSpan" id="kobo.391.3">Options API offers very basic TypeScript support, and this has prevented many developers from joining the </span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">Vue.js ecosystem.</span></span></p>
			<p><span class="koboSpan" id="kobo.393.1">We </span><a id="_idIndexMarker096"/><span class="koboSpan" id="kobo.394.1">have reached </span><a id="_idIndexMarker097"/><span class="koboSpan" id="kobo.395.1">the end of this section, and it is time to </span><a id="_idIndexMarker098"/><span class="koboSpan" id="kobo.396.1">clearly say which method is better, but, unfortunately, the answer is that </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">it depends.</span></span></p>
			<p><span class="koboSpan" id="kobo.398.1">Because both syntactic sugars compile in the same code, the decision really goes back to coding preferences. </span><span class="koboSpan" id="kobo.398.2">Options API provides more structure, and it can, therefore, be more helpful at the start of your career when your experience in creating a component is still limited, while Composition API, with the added TypeScript support and greater flexibility in code partitioning, can be a very strong tool to improve code readability in </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">big applications.</span></span></p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor035"/><span class="koboSpan" id="kobo.400.1">Sample components</span></h2>
			<p><span class="koboSpan" id="kobo.401.1">At this stage, we have learned enough about the foundations of Vue.js to be ready to introduce </span><a id="_idIndexMarker099"/><span class="koboSpan" id="kobo.402.1">some sample components and see the framework </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">in action.</span></span></p>
			<p><span class="koboSpan" id="kobo.404.1">We are going to look at an example of an Atom. </span><span class="koboSpan" id="kobo.404.2">In our case, it is a simple icon component. </span><span class="koboSpan" id="kobo.404.3">This sample component is going to exhibit the </span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">following features:</span></span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.406.1">It is going to accept a couple of properties (</span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">size</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.408.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">name</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">)</span></span></li>
				<li><span class="koboSpan" id="kobo.411.1">It is going to include </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">some style</span></span></li>
				<li><span class="koboSpan" id="kobo.413.1">It is going to dynamically load </span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">the icon</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.415.1">The component will be called using the </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">following HTML:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.417.1">
&lt;vfb-icon name="clog" size="small" @click="doSomething /&gt;</span></pre>
			<p><span class="koboSpan" id="kobo.418.1">As previously mentioned, in this section, I am going to show the components utilizing both writing </span><a id="_idIndexMarker100"/><span class="koboSpan" id="kobo.419.1">methods; however, later in the book, we will just write components using Script Setup (</span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">Composition API).</span></span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.421.1">Important note</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.422.1">Please note that we will cover all of this again in more detail later in the book. </span><span class="koboSpan" id="kobo.422.2">This is just a quick introduction to </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">Vue.js components.</span></span></p>
			<h3><span class="koboSpan" id="kobo.424.1">An Atom component using Options API</span></h3>
			<p><span class="koboSpan" id="kobo.425.1">Let’s first </span><a id="_idIndexMarker101"/><span class="koboSpan" id="kobo.426.1">see how this component looks as a Vue.js </span><a id="_idIndexMarker102"/><span class="koboSpan" id="kobo.427.1">component using </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">Options API:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.429.1">
&lt;template&gt;
  &lt;img
    :src="iconPath"
    :class="sizeClass"
  /&gt;
&lt;/template&gt;
&lt;script&gt;
  export default {
    name: 'vfb-icon',
    props: {
      size: String,
      name: String
    },
    computed: {
      iconPath() {
        return `/assets/${this.name}.svg`;
      },
      sizeClass() {
        return `${this.size}-icon`
      }
    }
};
&lt;/script&gt;
&lt;style scoped&gt;
.small-icon {
    width: 16px;
    height: 16px;
}
.medium-icon {
  width: 32px;
  height: 32px;
}
.large-icon {
  width: 48px;
  height: 48px;
}
&lt;/style&gt;</span></pre>
			<p><span class="koboSpan" id="kobo.430.1">Now let’s break down all the sections, starting with </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">&lt;template&gt;</span></strong><span class="koboSpan" id="kobo.432.1">, which hosts the HTML for </span><a id="_idIndexMarker103"/><span class="koboSpan" id="kobo.433.1">our component; in this case, this is a native </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">&lt;img&gt;</span></strong><span class="koboSpan" id="kobo.435.1"> element. </span><span class="koboSpan" id="kobo.435.2">This component has a few attributes being passed to it. </span><span class="koboSpan" id="kobo.435.3">The first two </span><a id="_idIndexMarker104"/><span class="koboSpan" id="kobo.436.1">are native attributes: </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">src</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.438.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">class</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.441.1">
:src="iconPath"
:class="sizeClass"</span></pre>
			<p><span class="koboSpan" id="kobo.442.1">These attributes are declared a little bit differently than you are used to in HTML, as they are preceded by </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">:</span></strong><span class="koboSpan" id="kobo.444.1">. </span><span class="koboSpan" id="kobo.444.2">When an attribute has this syntax, it means that its value is dynamic and that the values (in our case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">iconPath</span></strong><span class="koboSpan" id="kobo.446.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">sizeClass</span></strong><span class="koboSpan" id="kobo.448.1">) are going to be evaluated as a JavaScript variable and not </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">actual strings.</span></span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.450.1">Important note</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.451.1">Please note that you can write plain HTML in Vue.js, and using the dynamic variables is not a requirement for the framework but just a feature to make the </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">attributes dynamic.</span></span></p>
			<p><span class="koboSpan" id="kobo.453.1">Next up, let’s move to the logical part of the application, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">&lt;script&gt;</span></strong><span class="koboSpan" id="kobo.455.1"> section. </span><span class="koboSpan" id="kobo.455.2">Here, we start by declaring the name of </span><span class="No-Break"><span class="koboSpan" id="kobo.456.1">our component:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.457.1">
name: 'vfb-icon',</span></pre>
			<p class="callout-heading"><span class="koboSpan" id="kobo.458.1">Important note</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.459.1">It is good practice for all Vue.js components to be formed of two words. </span><span class="koboSpan" id="kobo.459.2">This will ensure that the component does not clash with native </span><span class="No-Break"><span class="koboSpan" id="kobo.460.1">HTML elements.</span></span></p>
			<p><span class="koboSpan" id="kobo.461.1">Next, it is time to declare the properties. </span><span class="koboSpan" id="kobo.461.2">Properties are values that are accepted by our component </span><a id="_idIndexMarker105"/><span class="koboSpan" id="kobo.462.1">when it is initialized. </span><span class="koboSpan" id="kobo.462.2">This is an existing </span><a id="_idIndexMarker106"/><span class="koboSpan" id="kobo.463.1">concept in development, as all HTML elements accept attributes such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">class</span></strong><span class="koboSpan" id="kobo.465.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">id</span></strong><span class="koboSpan" id="kobo.467.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">value</span></strong><span class="koboSpan" id="kobo.469.1">. </span><span class="koboSpan" id="kobo.469.2">These properties make our components reusable and flexible. </span><span class="koboSpan" id="kobo.469.3">In our example, we declared two different properties: </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">name</span></strong><span class="koboSpan" id="kobo.471.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">size</span></strong><span class="koboSpan" id="kobo.473.1">. </span><span class="koboSpan" id="kobo.473.2">These will be passed down when the component is called, just as if they were native </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">HTML attributes:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.475.1">
props: {
  size: String,
  name: String
},</span></pre>
			<p><span class="koboSpan" id="kobo.476.1">This example shows a basic configuration for a property, in which we just define its type, but, as we will later see in the course of the book, </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">props</span></strong><span class="koboSpan" id="kobo.478.1"> can have different configurations, such as validation, default values, and requirements rules, to state whether they are required </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">or not.</span></span></p>
			<p><span class="koboSpan" id="kobo.480.1">The next piece of code is where we declare our dynamic properties. </span><span class="koboSpan" id="kobo.480.2">For our component to function correctly, we need a path and a class defined as </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">iconPath </span></strong><span class="koboSpan" id="kobo.482.1">and </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">sizeClass</span></strong><span class="koboSpan" id="kobo.484.1">. </span><span class="koboSpan" id="kobo.484.2">These values are going to be dynamic due to the fact that they include the dynamic properties and will be declared using something called </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">computed properties:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.486.1">
computed: {
  iconPath() { return `/assets/${this.name}.svg`; },
  sizeClass() { return `${this.size}-icon` }
},</span></pre>
			<p><span class="koboSpan" id="kobo.487.1">The computed properties allow us to declare values that are reactive (remember the reactivity </span><a id="_idIndexMarker107"/><span class="koboSpan" id="kobo.488.1">chapter earlier on in the book) and can make </span><a id="_idIndexMarker108"/><span class="koboSpan" id="kobo.489.1">use of our entire component logic; in this case, we just used the props, but we could have used a collection of values and external logic to create a </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">new value.</span></span></p>
			<p class="callout-heading"><span class="koboSpan" id="kobo.491.1">Important note</span></p>
			<p class="callout"><span class="koboSpan" id="kobo.492.1">Please note that when using Options API, you have to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">this</span></strong><span class="koboSpan" id="kobo.494.1"> keyword to be able to access variables within the component, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">props</span></strong><span class="koboSpan" id="kobo.496.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">computed</span></strong><span class="koboSpan" id="kobo.498.1">. </span><span class="koboSpan" id="kobo.498.2">In our example, we used it to access properties by using </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">this.name</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.500.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">this.size</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">;.</span></span></p>
			<p><span class="koboSpan" id="kobo.503.1">Our last section </span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">&lt;style&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.507.1">
&lt;style scoped&gt;
  .small-icon {
    width: 16px;
    height: 16px;
  }
  .medium-icon {
    width: 32px;
    height: 32px;
  }
  .large-icon {
    width: 48px;
    height: 48px;
  }
&lt;/style&gt;</span></pre>
			<p><span class="koboSpan" id="kobo.508.1">This is quite simple because this example does not include anything different than you would normally see in plain CSS. </span><span class="koboSpan" id="kobo.508.2">As mentioned in a previous chapter, we can add the attribute </span><a id="_idIndexMarker109"/><span class="koboSpan" id="kobo.509.1">scoped to our style to ensure that their style </span><a id="_idIndexMarker110"/><span class="koboSpan" id="kobo.510.1">does not bleed from </span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">our component.</span></span></p>
			<p><span class="koboSpan" id="kobo.512.1">In the preceding example, you can see (in practice) how Options API divides our c</span><a id="_idTextAnchor036"/><span class="koboSpan" id="kobo.513.1">omponent into sections. </span><span class="koboSpan" id="kobo.513.2">In our case, we have </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">props</span></strong><span class="koboSpan" id="kobo.515.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">name</span></strong><span class="koboSpan" id="kobo.517.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">computed</span></strong><span class="koboSpan" id="kobo.519.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">methods</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.523.1">
export default {
  name: '',
  props: {},
  computed: { },
  methods: { }
}</span></pre>
			<h3><span class="koboSpan" id="kobo.524.1">An Atom component using Script Setup</span></h3>
			<p><span class="koboSpan" id="kobo.525.1">It is now </span><a id="_idIndexMarker111"/><span class="koboSpan" id="kobo.526.1">time to look at the same component </span><a id="_idIndexMarker112"/><span class="koboSpan" id="kobo.527.1">but written using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">&lt;script </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">setup&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.530.1"> syntax:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.531.1">
&lt;template&gt;...&lt;/template&gt;
&lt;script setup&gt;
  import { computed } from 'vue';
  const props = defineProps({
    size: String,
    name: String
  });
  const iconPath = computed( () =&gt; {
    return `/assets/${props.name}.svg`;
  });
  const sizeClass = computed( () =&gt; {
    return `${props.size}-icon`;
  });
&lt;/script&gt;
&lt;style scoped&gt;...&lt;/style&gt;</span></pre>
			<p><span class="koboSpan" id="kobo.532.1">As you can clearly see, the preceding example omits the </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">&lt;template&gt;</span></strong><span class="koboSpan" id="kobo.534.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">&lt;style&gt;</span></strong><span class="koboSpan" id="kobo.536.1"> tags. </span><span class="koboSpan" id="kobo.536.2">These </span><a id="_idIndexMarker113"/><span class="koboSpan" id="kobo.537.1">have been omitted because they are </span><a id="_idIndexMarker114"/><span class="koboSpan" id="kobo.538.1">identical to the Options API counterpart. </span><span class="koboSpan" id="kobo.538.2">In fact, as we have already mentioned, the difference between these two methods only affects the logical part of the component, which </span><span class="No-Break"><span class="koboSpan" id="kobo.539.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">&lt;script&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.542.1">The first line of our component </span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">import</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.545.1">:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.546.1">
import { computed } from 'vue';</span></pre>
			<p><span class="koboSpan" id="kobo.547.1">In contrast to Options API, where all the options were already available to us when using </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">&lt;script setup&gt;</span></strong><span class="koboSpan" id="kobo.549.1">, we have to import each individual Vue.js method from </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">'vue'</span></strong><span class="koboSpan" id="kobo.551.1">, just as we did in the previous code </span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">computed</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.554.1">.</span></span></p>
			<p><span class="koboSpan" id="kobo.555.1">Next up, we are going to see how properties are defined in </span><span class="No-Break"><span class="koboSpan" id="kobo.556.1">Composition API:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.557.1">
const props = defineProps({
  size: String,
  name: String
})</span></pre>
			<p><span class="koboSpan" id="kobo.558.1">Properties </span><a id="_idIndexMarker115"/><span class="koboSpan" id="kobo.559.1">are one of the few options to have a </span><a id="_idIndexMarker116"/><span class="koboSpan" id="kobo.560.1">verbose declaration while using </span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">&lt;script setup&gt;</span></strong><span class="koboSpan" id="kobo.562.1">. </span><span class="koboSpan" id="kobo.562.2">In fact, to be able to declare them, we need to make use of a compiler </span><a id="_idIndexMarker117"/><span class="koboSpan" id="kobo.563.1">macro called </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">defineProps</span></strong><span class="koboSpan" id="kobo.565.1">. </span><span class="koboSpan" id="kobo.565.2">Macros do not need to be imported, as they are just going to be used by the compiler and removed from the code. </span><span class="koboSpan" id="kobo.565.3">If you have ever used  TypeScript, you will be familiar with </span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">this approach.</span></span></p>
			<p><span class="koboSpan" id="kobo.567.1">Next up, we </span><span class="No-Break"><span class="koboSpan" id="kobo.568.1">have </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">computed</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.570.1">:</span></span></p>
			<pre class="source-code"><span class="koboSpan" id="kobo.571.1">
  const iconPath = computed( () =&gt; {
    return `/assets/${props.name}.svg`;
  });
  const sizeClass = computed( () =&gt; {
    return `${props.size}-icon`;
  });</span></pre>
			<p><span class="koboSpan" id="kobo.572.1">Declaring the properties of </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">computed</span></strong><span class="koboSpan" id="kobo.574.1"> is very similar to Options API but with two </span><span class="No-Break"><span class="koboSpan" id="kobo.575.1">small differences:</span></span></p>
			<ul>
				<li><span class="koboSpan" id="kobo.576.1">The logic of the properties of </span><strong class="source-inline"><span class="koboSpan" id="kobo.577.1">computed</span></strong><span class="koboSpan" id="kobo.578.1"> need to be passed as a callback to the computed method imported </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.580.1">'vue'</span></strong></span></li>
				<li><span class="koboSpan" id="kobo.581.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.582.1">this</span></strong><span class="koboSpan" id="kobo.583.1"> keyword is not available anymore, and we can access </span><span class="No-Break"><span class="koboSpan" id="kobo.584.1">variables directly</span></span></li>
			</ul>
			<p><span class="koboSpan" id="kobo.585.1">This is as far as we will go in terms of explaining the differences between Options API and Composition API for now. </span><span class="koboSpan" id="kobo.585.2">We will cover Script Setup (Composition API) in more detail later in the book. </span><span class="koboSpan" id="kobo.585.3">If you are extremely new to Vue.js, this section probably included lots of new syntax, and it was a little hard to grasp, but as soon as we start to build our Companion App, as you gain knowledge with Vue.js and its syntax, things will quickly make more sense </span><span class="No-Break"><span class="koboSpan" id="kobo.586.1">to you.</span></span></p>
			<p><span class="koboSpan" id="kobo.587.1">In this section, we have </span><a id="_idIndexMarker118"/><span class="koboSpan" id="kobo.588.1">started to learn how Vue.js </span><a id="_idIndexMarker119"/><span class="koboSpan" id="kobo.589.1">components are defined and the different sections that form an SFC. </span><span class="koboSpan" id="kobo.589.2">We then concluded the section by covering a sample component in both syntactic sugars </span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">in detail.</span></span></p>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor037"/><span class="koboSpan" id="kobo.591.1">Summary</span></h1>
			<p><span class="koboSpan" id="kobo.592.1">We have now reached the end of this fairly theory-heavy chapter, and this was required for us to get started with our app-building process. </span><span class="koboSpan" id="kobo.592.2">In this chapter, we have learned what makes Vue.js different from the other frameworks by analyzing its reactivity system. </span><span class="koboSpan" id="kobo.592.3">We then broke down the composition of a Vue.js SFC, also known as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.593.1">.vue</span></strong><span class="koboSpan" id="kobo.594.1"> file, and we walked through a Vue.js component’s lifecycle by analyzing all the different lifecycle hooks available within </span><span class="No-Break"><span class="koboSpan" id="kobo.595.1">the framework.</span></span></p>
			<p><span class="koboSpan" id="kobo.596.1">In the middle of the chapter, we learned the main differences between Composition API and Options API by exploring them using </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">sample components.</span></span></p>
			<p><span class="koboSpan" id="kobo.598.1">In the next chapter, we will start to learn Vue.js by starting to build our Companion App. </span><span class="koboSpan" id="kobo.598.2">This will be the beginning of your long journey from being a complete beginner to an experienced </span><span class="No-Break"><span class="koboSpan" id="kobo.599.1">Vue.js developer.</span></span></p>
		</div>
	

		<div id="_idContainer028" class="Content">
			<h1 id="_idParaDest-38" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor038"/><span class="koboSpan" id="kobo.1.1">Part 2: Understanding the Core Features of Vue.js</span></h1>
			<p><span class="koboSpan" id="kobo.2.1">Part 2 of this book focuses on Vue.js and its core features. </span><span class="koboSpan" id="kobo.2.2">We will build the core of the Companion App one step at a time, while continuing to expand our knowledge of the </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">Vue.js framework.</span></span></p>
			<p><span class="koboSpan" id="kobo.4.1">This part contains the </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">following chapters:</span></span></p>
			<ul>
				<li><a href="B21130_03.xhtml#_idTextAnchor039"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 3</span></em></a><em class="italic"><span class="koboSpan" id="kobo.7.1">, Making Our HTML Dynamic</span></em></li>
				<li><a href="B21130_04.xhtml#_idTextAnchor049"><em class="italic"><span class="koboSpan" id="kobo.8.1">Chapter 4</span></em></a><em class="italic"><span class="koboSpan" id="kobo.9.1">, Utilizing Vue’s Built-in Directives for Effortless Development</span></em></li>
				<li><a href="B21130_05.xhtml#_idTextAnchor060"><em class="italic"><span class="koboSpan" id="kobo.10.1">Chapter 5</span></em></a><em class="italic"><span class="koboSpan" id="kobo.11.1">, Leveraging Computed Properties and Methods in Vue.js</span></em></li>
				<li><a href="B21130_06.xhtml#_idTextAnchor074"><em class="italic"><span class="koboSpan" id="kobo.12.1">Chapter 6</span></em></a><em class="italic"><span class="koboSpan" id="kobo.13.1">, </span></em><em class="italic"><span class="koboSpan" id="kobo.14.1">Event and Data Handling in Vue.js</span></em></li>
				<li><a href="B21130_07.xhtml#_idTextAnchor088"><em class="italic"><span class="koboSpan" id="kobo.15.1">Chapter 7</span></em></a><em class="italic"><span class="koboSpan" id="kobo.16.1">, </span></em><em class="italic"><span class="koboSpan" id="kobo.17.1">Handling API Data and Managing Async Components with Vue.js</span></em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer029">
			</div>
		</div>
		<div>
			<div id="_idContainer030">
			</div>
		</div>
		<div>
			<div id="_idContainer031">
			</div>
		</div>
		<div>
			<div id="_idContainer032">
			</div>
		</div>
		<div>
			<div id="_idContainer033">
			</div>
		</div>
		<div>
			<div id="_idContainer034" class="Basic-Graphics-Frame">
			</div>
		</div>
		<div>
			<div id="_idContainer035" class="Basic-Graphics-Frame">
			</div>
		</div>
		<div>
			<div id="_idContainer036">
			</div>
		</div>
		<div>
			<div id="_idContainer037">
			</div>
		</div>
		<div>
			<div id="_idContainer038" class="Basic-Graphics-Frame">
			</div>
		</div>
	</body></html>