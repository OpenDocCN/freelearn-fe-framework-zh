- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Creating a Router-First Line-of-Business App
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建以路由优先的业务线应用
- en: As you read in *Chapter 3*, *Architecting an Enterprise App*, **Line-of-Business**
    (**LOB**) applications are the bread and butter of the software development world.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在第3章“架构企业应用”中阅读到的，**业务线**（**LOB**）应用是软件开发世界的基石。
- en: In this and the remaining chapters of the book, we’ll set up a new application
    with rich features that can meet the demands of an LOB application with scalable
    architecture and engineering best practices that will help you start small and
    be able to grow your solution quickly if there’s demand. We will follow the router-first
    design pattern, relying on reusable components to create a grocery store LOB application
    named LemonMart. We’ll discuss designing around major data entities and the importance
    of completing high-level mock-ups for your application before implementing various
    conditional navigation elements, which may change significantly during the design
    phase.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的此部分和后续章节中，我们将设置一个具有丰富功能的新应用，以满足具有可扩展架构和工程最佳实践的业务线应用的需求。我们将遵循路由优先的设计模式，依靠可重用组件来创建名为LemonMart的杂货店业务线应用。我们将讨论围绕主要数据实体进行设计的重要性，以及在实现各种条件导航元素之前完成应用程序的高级原型设计的重要性，这些元素在设计阶段可能会发生重大变化。
- en: The source code for this project is provided on GitHub at [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart),
    including various stages of development in the `Projects` folder. The project
    is supported by unit tests using Jasmine and E2E tests using Cypress, environment
    variables, Angular Material, and a **Continuous Integration and** **Continuous
    Delivery** (**CI/CD**) pipeline leveraging CircleCI. You can find more information
    on CI/CD in *Chapter 10*, *Releasing to Production with CI/CD*.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目的源代码可在GitHub上找到，地址为[https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)，包括在“Projects”文件夹中的各个开发阶段。该项目由Jasmine单元测试和Cypress端到端测试支持，使用环境变量、Angular
    Material，以及利用CircleCI的**持续集成和持续交付**（**CI/CD**）管道。你可以在第10章“使用CI/CD发布到生产环境”中找到更多关于CI/CD的信息。
- en: LemonMart is a separate Angular repo. For enterprise or full-stack development,
    you may ask, why is it not configured as a monorepo? In *Chapter 5*, *Designing
    Authentication and Authorization*, we cover how to create a monorepo using Git’s
    submodule feature. For a more opinionated and ergonomic approach to working on
    large Angular applications, I urge you to consider Nx. Its smart build system
    alone can save hours of build time. Check it out at [https://nx.dev](https://nx.dev).
    However, a deep dive of this tool is outside the scope of this book.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: LemonMart是一个独立的Angular仓库。对于企业或全栈开发，你可能会问，为什么它没有配置为单仓库？在第5章“设计身份验证和授权”中，我们将介绍如何使用Git的子模块功能创建单仓库。为了在大型Angular应用上工作提供更具有意见和更人性化的方法，我强烈建议你考虑Nx。它智能的构建系统本身就可以节省数小时的构建时间。请在[https://nx.dev](https://nx.dev)上查看。然而，对这个工具的深入探讨超出了本书的范围。
- en: 'Feeling adventurous? Run the following command to create your Nx workspace:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 想要冒险吗？运行以下命令以创建你的Nx工作空间：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this chapter, we’re going to cover the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating LemonMart
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建LemonMart
- en: Generating router-enabled modules
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成具有路由功能的模块
- en: Branding, customization, and Material icons
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 品牌化、定制和Material图标
- en: Feature modules with lazy loading
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有懒加载的功能模块
- en: Creating the walking skeleton
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建行走骨架
- en: Common testing module
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见测试模块
- en: Designing around major data entities
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 围绕主要数据实体进行设计
- en: High-level UX design
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级用户体验设计
- en: In *Chapters 5* to *9*, we will evolve LemonMart to demonstrate the aforementioned
    concepts.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5章到第9章中，我们将逐步完善LemonMart以展示上述概念。
- en: Technical requirements
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The most up-to-date versions of the sample code for the book are on GitHub at
    the following linked repository. The repository contains the final and completed
    state of the code. You can verify your progress at the end of this chapter by
    looking for the end-of-chapter snapshot of code under the `projects` folder.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 书籍的示例代码的最新版本可在以下链接的GitHub仓库中找到。该仓库包含代码的最终和完成状态。你可以在本章末尾通过查找“projects”文件夹下的章节末尾代码快照来验证你的进度。
- en: 'For *Chapter 4*:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第4章：
- en: 'Clone the repo: [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart).'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆仓库：[https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)。
- en: Execute `npm install` on the root folder to install dependencies.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根目录下执行`npm install`以安装依赖项。
- en: 'The end state of the project is reflected at:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目的最终状态反映在：
- en: '[PRE1]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the stage name to any `ng` command to act only on that stage:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将阶段名称添加到任何`ng`命令中，使其仅对该阶段生效：
- en: '[PRE2]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that the `dist/stage7` folder at the root of the repository will contain
    the compiled result.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，存储库根目录下的`dist/stage7`文件夹将包含编译结果。
- en: Beware that the source code provided in the book and the version on GitHub are
    likely to be different. The ecosystem around these projects is ever-evolving.
    Between changes to how the Angular CLI generates new code, bug fixes, new versions
    of libraries, or side-by-side implementations of multiple techniques, there’s
    a lot of variation that’s impossible to account for. If you find errors or have
    questions, please create an issue, or submit a pull request on GitHub.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，书中提供的源代码和GitHub上的版本可能不同。这些项目周围的生态系统是不断演变的。在Angular CLI生成新代码的方式、错误修复、库的新版本或多种技术的并行实现之间，存在许多难以计数的差异。如果您发现错误或有疑问，请创建问题，或在GitHub上提交拉取请求。
- en: Read more about updating Angular in the supplemental guide *Keeping Angular
    and Tools Evergreen* at [https://angularforenterprise.com/evergreen](https://angularforenterprise.com/evergreen).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在补充指南*保持Angular和工具常青*中了解更多关于更新Angular的信息，该指南位于[https://angularforenterprise.com/evergreen](https://angularforenterprise.com/evergreen)。
- en: Next, let’s start by creating LemonMart^™, a fully featured LOB app you can
    use as a template to kickstart your next professional project. LemonMart is a
    robust and realistic project that can support feature growth and different backend
    implementations, and it comes with a complete and configurable authentication
    and authorization solution out of the box.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们首先创建LemonMart^™，这是一个功能齐全的LOB应用程序，您可以用作启动下一个专业项目的模板。LemonMart是一个强大且现实的项目，可以支持功能增长和不同的后端实现，并且它自带完整且可配置的认证和授权解决方案。
- en: Since its introduction in 2018, LemonMart has served over 257,000 lemons to
    more than 32,500 developers. Zesty!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 自2018年推出以来，LemonMart已为超过32,500名开发者提供了超过257,000个柠檬。真香！
- en: You can always clone the finished project from GitHub, [https://www.github.com/duluca/lemon-mart](https://www.github.com/duluca/lemon-mart),
    whenever needed. Let’s jump right into it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以随时从GitHub克隆完成的项目，[https://www.github.com/duluca/lemon-mart](https://www.github.com/duluca/lemon-mart)，
    whenever needed。让我们直接开始吧。
- en: Creating LemonMart
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建LemonMart
- en: LemonMart will be a mid-sized line-of-business application with over 90 code
    files. We will start our journey by creating a new Angular app, with routing and
    Angular Material configured.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: LemonMart将是一个中等规模的业务线应用程序，拥有超过90个代码文件。我们将从创建一个新的Angular应用程序开始，其中已配置路由和Angular
    Material。
- en: It is presumed that you have installed all the requisite software mentioned
    in *Appendix A*, *Setting Up Your Development Environment*. If you have not, execute
    the following commands for your OS to configure your environment.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已安装了附录A中提到的所有必需软件，即*设置您的开发环境*。如果没有，请根据您的操作系统执行以下命令来配置您的环境。
- en: 'On Windows PowerShell, execute:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows PowerShell中执行：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'On macOS Terminal, execute:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS终端中执行：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For more information, refer to [https://github.com/duluca/web-dev-environment-setup](https://github.com/duluca/web-dev-environment-setup).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如需更多信息，请参阅[https://github.com/duluca/web-dev-environment-setup](https://github.com/duluca/web-dev-environment-setup)。
- en: Creating a router-first app
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个路由优先的应用程序
- en: 'We will create LemonMart as a standalone project, which means a root module
    is not required to bootstrap the application, and all components created within
    the application will be configured as a standalone component. We will implement
    a modular architecture using lazy-loaded feature modules and selectively use lazy-loaded
    standalone components for components shared across feature modules. With the router-first
    approach, we want to enable routing early on in our application:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建LemonMart作为一个独立项目，这意味着不需要根模块来启动应用程序，并且应用程序内创建的所有组件都将配置为独立组件。我们将使用懒加载功能模块实现模块化架构，并选择性地使用懒加载的独立组件来共享功能模块中的组件。采用路由优先的方法，我们希望在应用程序早期启用路由：
- en: 'You can create the new application, with routing already configured, by executing
    this command:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过执行此命令创建一个新的应用程序，其中已配置路由：
- en: '[PRE5]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A new `app.routes.ts` file has been created for us:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们创建了一个新的`app.routes.ts`文件：
- en: '[PRE6]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We will be defining `routes` inside the routes array.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在路由数组内部定义`routes`。
- en: 'Observe that the `routes` are provided in `app.config.ts`, as shown:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，`routes`在`app.config.ts`中提供，如下所示：
- en: '[PRE7]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Ultimately, `ApplicationConfig` is consumed by `bootstrapApplication` in `main.ts`,
    which kicks off the application bootstrap process:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终，`ApplicationConfig`在`main.ts`中被`bootstrapApplication`消费，从而启动应用程序的引导过程：
- en: '[PRE8]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Execute your project by running `npm start`.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行`npm start`来执行您的项目。
- en: Configuring Angular and VS Code
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置Angular和VS Code
- en: 'Apply the following configuration steps to your project using `mrm`, a command-line
    tool to help keep configuration files in projects in sync:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`mrm`，一个帮助保持项目配置文件同步的命令行工具，应用以下配置步骤到您的项目中：
- en: The following scripts do not require you to use VS Code. If you wish to use
    another IDE like WebStorm, the `npm` scripts that are configured will run equally
    well.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本不需要您使用VS Code。如果您希望使用WebStorm等其他IDE，配置的`npm`脚本同样可以正常运行。
- en: You can read more about `mrm` at [https://mrm.js.org/docs/getting-started](https://mrm.js.org/docs/getting-started).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://mrm.js.org/docs/getting-started](https://mrm.js.org/docs/getting-started)了解更多关于`mrm`的信息。
- en: 'Apply the Angular VS Code configuration:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用Angular VS Code配置：
- en: '[PRE9]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Apply the `npm` scripts for the Docker configuration:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用Docker配置的`npm`脚本：
- en: '[PRE10]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Implement an `npm` script to build your application in production mode named
    `build:prod`:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个名为`build:prod`的`npm`脚本来在生产模式下构建您的应用程序：
- en: '[PRE11]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: By default, Angular will build your code in production mode. However, this behavior
    can be changed in `angular.json`. For this reason, I prefer to explicitly request
    a production build for code that’s intended to be shipped, to avoid mistakes.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认情况下，Angular将在生产模式下构建您的代码。但是，这种行为可以在`angular.json`中更改。因此，我更喜欢明确请求生产构建，以便将代码发布，以避免错误。
- en: These settings are continually tweaked to adapt to the ever-evolving landscape
    of extensions, plug-ins, Angular, and VS Code. Alternatively, you can use the
    Angular Evergreen extension for VS Code to run the configuration commands with
    one click.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些设置不断调整以适应扩展、插件、Angular和VS Code不断变化的格局。或者，您可以使用VS Code的Angular Evergreen扩展一键运行配置命令。
- en: 'Note that if the preceding configuration scripts fail to execute, the following
    `npm` scripts will also fail. In this case, you have two options: revert your
    changes and ignore these scripts, or manually implement these scripts as covered
    in earlier chapters (or as demonstrated on GitHub).'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，如果前面的配置脚本执行失败，以下`npm`脚本也将失败。在这种情况下，您有两个选择：撤销您的更改并忽略这些脚本，或者手动实现这些脚本，如前几章所述（或如GitHub上所示）。
- en: Execute `npm run style:fix`.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`npm run style:fix`。
- en: Execute `npm run lint:fix`.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`npm run lint:fix`。
- en: Execute `npm start`.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`npm start`。
- en: Refer to *Appendix A*, *Setting Up Your Development Environment*, for further
    configuration details.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考*附录A*，*设置您的开发环境*，以获取更多配置细节。
- en: 'For more information on the `mrm` tasks, refer to:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`mrm`任务的更多信息，请参阅：
- en: '[https://github.com/expertly-simple/mrm-task-angular-vscode](https://github.com/expertly-simple/mrm-task-angular-vscode)'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/expertly-simple/mrm-task-angular-vscode](https://github.com/expertly-simple/mrm-task-angular-vscode)'
- en: '[https://github.com/expertly-simple/mrm-task-npm-docker](https://github.com/expertly-simple/mrm-task-npm-docker)'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/expertly-simple/mrm-task-npm-docker](https://github.com/expertly-simple/mrm-task-npm-docker)'
- en: '[https://github.com/expertly-simple/mrm-task-npm-aws](https://github.com/expertly-simple/mrm-task-npm-aws)'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/expertly-simple/mrm-task-npm-aws](https://github.com/expertly-simple/mrm-task-npm-aws)'
- en: Configuring Angular Material and styles
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置Angular Material和样式
- en: 'Several years ago, it was a necessary practice to apply a reset or normalize
    CSS stylesheet to themed projects to account for discrepancies in how browsers
    handled layout or spacing. However, current browsers are more faithful to the
    CSS specification, so a legacy reset stylesheet can be overkill. Below, I implement
    `styles.scss` with reset parameters like `body { margin: 0 }` and `html, body
    { height: 100% }`.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '几年前，将重置或规范化CSS样式表应用到主题项目中以解决浏览器处理布局或间距的差异是一个必要的实践。然而，当前浏览器对CSS规范的遵循更加严格，因此传统的重置样式表可能过于冗余。以下，我使用具有重置参数如`body
    { margin: 0 }`和`html, body { height: 100% }`的`styles.scss`实现。'
- en: If you want to check out a modern version of a normalize stylesheet, I recommend
    [https://github.com/sindresorhus/modern-normalize](https://github.com/sindresorhus/modern-normalize).
    It’s easy to set up and works seamlessly when imported in `styles.scss`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想查看规范化样式表的现代版本，我推荐[https://github.com/sindresorhus/modern-normalize](https://github.com/sindresorhus/modern-normalize)。它易于设置，并在导入到`styles.scss`时无缝工作。
- en: 'We will also need to set up Angular Material and configure a theme to use:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要设置Angular Material并配置一个要使用的主题：
- en: 'Install Angular Material:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Angular Material：
- en: '[PRE12]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that since this is a standalone project, we will need to import the required
    Material modules and `FlexModule` on each individual component that requires it.
    When the `@ngbracket/ngx-layout` package implements a root-level provider, adding
    `FlexModule` manually won’t be needed anymore.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，由于这是一个独立项目，我们将在每个需要它的单个组件中导入所需的Material模块和`FlexModule`。当`@ngbracket/ngx-layout`包实现根级提供者时，将不再需要手动添加`FlexModule`。
- en: 'Append common CSS to `styles.scss` as shown in the following code:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如以下代码所示，将常见的CSS追加到`styles.scss`中：
- en: '[PRE13]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Update your application’s title in `index.html`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`index.html`中更新您应用程序的标题。
- en: We will apply custom branding to the app later in this chapter. Next, let’s
    start designing our line-of-business application.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的后面部分为应用程序应用自定义品牌。接下来，让我们开始设计我们的业务应用程序。
- en: Designing LemonMart
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计LemonMart
- en: It is important to build a rudimentary roadmap to follow, from the database
    to the frontend, while also avoiding over-engineering. This initial design phase
    is critical to the long-term health and success of your project, where any existing
    silos between teams must be broken down and an overall technical vision must be
    well understood by all members of the team. This is easier said than done, and
    there are volumes of books written on the topic.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库到前端的过程中，同时避免过度设计，构建一个基本的路线图来遵循是很重要的。这个初始设计阶段对于项目的长期健康和成功至关重要，其中必须打破团队之间存在的任何隔阂，并且所有团队成员都必须对整体技术愿景有清晰的理解。这比说起来容易做起来难，关于这个主题已经写了很多本书。
- en: In engineering, there’s no right answer to a problem, so it is important to
    remember that no person can ever have all the answers or a crystal-clear vision.
    It is important that technical and non-technical leaders create a safe space with
    opportunities for open discussion and experimentation as part of the culture.
    The humility and empathy that come along with being able to court such uncertainty
    as a team is as important as any single team member’s technical capability. Every
    team member must be comfortable leaving their egos at the door because our collective
    goal will be to grow and evolve an application to ever-changing requirements during
    the development cycle. You will know that you have succeeded if individual parts
    of the software you created are easily replaceable by anyone.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在工程领域，对于问题没有绝对正确的答案，因此记住没有人能够拥有所有答案或清晰的愿景是很重要的。在文化中创造一个安全的空间，允许开放讨论和实验，对于技术和非技术领导者来说至关重要。作为一个团队能够共同面对这种不确定性所带来的谦逊和同理心，与任何单个团队成员的技术能力一样重要。每个团队成员都必须感到自在，将他们的自我放下，因为我们的共同目标是在开发周期中不断增长和演变应用程序以适应不断变化的需求。如果你知道你成功了，那么你创建的软件的各个部分将很容易被任何人替换。
- en: So, let’s start by developing a roadmap and identifying the scope of our application.
    For this, we will be defining user roles and then building a site map to create
    a vision of how our app might work.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们先制定一个路线图，并确定我们应用程序的范围。为此，我们将定义用户角色，然后构建一个网站图，以形成一个关于我们的应用程序可能如何工作的愿景。
- en: Identifying user roles
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 识别用户角色
- en: The first step of our design will be to think about who is using the application
    and why.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计的第一步将是思考谁在使用这个应用程序以及为什么。
- en: 'We envision four user states, or roles, for LemonMart:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设想了LemonMart的四种用户状态或角色：
- en: '**Authenticated**: any authenticated user would have access to their profile'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证用户**：任何认证用户都可以访问他们的个人资料'
- en: '**Cashier**, whose sole role is to check out customers'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**收银员**，其唯一职责是结账客户'
- en: '**Clerk**, whose sole role is to perform inventory-related functions'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**店员**，其唯一职责是执行与库存相关的功能'
- en: '**Manager**, who can perform all actions a cashier and a clerk can perform
    but also has access to administrative functions'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**经理**，可以执行收银员和店员可以执行的所有操作，还可以访问管理功能'
- en: With this in mind, we can start to create a high-level design for our app.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们可以开始为我们的应用程序创建一个高级设计。
- en: Identifying high-level modules with a site map
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用网站图来识别高级模块
- en: 'Develop a high-level site map of your application, as shown in the following
    image:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下图像所示，开发您应用程序的高级网站图：
- en: '![A screenshot of a login page  Description automatically generated with medium
    confidence](img/B20960_04_01.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![登录页面截图，描述自动生成，中等置信度](img/B20960_04_01.png)'
- en: 'Figure 4.1: Landing pages for users'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1：用户登录页面
- en: 'I used MockFlow.com’s SiteMap tool to create the site map shown: [https://sitemap.mockflow.com](https://sitemap.mockflow.com).'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了MockFlow.com的SiteMap工具来创建显示的网站图：[https://sitemap.mockflow.com](https://sitemap.mockflow.com)。
- en: 'Upon first examination, three high-level modules emerge as lazy-loading candidates:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 初步检查后，有三个高级模块被确定为懒加载候选者：
- en: '**Point of Sale**(**POS**)'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**销售点**（**POS**）'
- en: '**Inventory**'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**库存**'
- en: '**Manager**'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**经理**'
- en: 'The cashier will only have access to the **POS** module and component. The
    clerk will only have access to the **Inventory** module, which will include additional
    screens for the **Stock Entry**, **Products**, and **Categories** management components:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 收银员只能访问**POS**模块和组件。店员只能访问**库存**模块，该模块将包括**库存录入**、**产品**和**类别**管理组件的附加屏幕：
- en: '![A picture containing text, screenshot, line  Description automatically generated](img/B20960_04_02.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、截图、行的图片，描述自动生成](img/B20960_04_02.png)'
- en: 'Figure 4.2: Inventory pages'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：库存页面
- en: 'Finally, the **Manager** will be able to access all three modules with the
    **Manager** module, including user management and receipt lookup components:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，**经理**将能够通过**经理**模块访问所有三个模块，包括用户管理和收据查找组件：
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B20960_04_03.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图，描述自动生成，中等置信度](img/B20960_04_03.png)'
- en: 'Figure 4.3: Manager pages'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3：经理页面
- en: There will be great benefits from enabling lazy loading for all three modules;
    since Cashiers and Clerks will never use components belonging to other user roles,
    there’s no reason to send those bytes down to their devices. As the **Manager**
    module gains more advanced reporting features or new roles are added to the application,
    the **POS** module will be unaffected by the bandwidth and memory impact of an
    otherwise growing application.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为所有三个模块启用懒加载将带来巨大好处；由于收银员和店员永远不会使用属于其他用户角色的组件，因此没有必要将这些字节发送到他们的设备。随着**经理**模块获得更多高级报告功能或新角色被添加到应用程序中，**POS**模块将不会受到其他情况下不断增长的应用程序带宽和内存影响的干扰。
- en: This means fewer support calls and consistent performance on the same hardware
    for much longer.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在相同硬件上支持调用更少，并且性能保持一致的时间更长。
- en: Generating router-enabled modules
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成具有路由功能的模块
- en: 'Now that we have our high-level components defined as **Manager**, **Inventory**,
    and **POS**, we can define them as modules. These modules will be different from
    the ones you’ve created for routing and Angular Material. We can create the user
    profile as a component on the app module; however, note that the user profile
    will only ever be used for already-authenticated users, so it makes sense to define
    a fourth module only meant for authenticated users in general. This way, you will
    ensure that your app’s first payload remains as minimal as possible. In addition,
    we will create a `home` component to contain the landing experience for our app
    so that we can keep implementation details out of `app.component`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将高级组件定义为**经理**、**库存**和**POS**，我们可以将它们定义为模块。这些模块将不同于您为路由和Angular Material创建的模块。我们可以在应用程序模块上创建用户配置文件作为组件；然而，请注意，用户配置文件将仅用于已认证的用户，因此定义一个仅针对一般已认证用户的第四个模块是有意义的。这样，您将确保应用程序的第一个负载尽可能小。此外，我们还将创建一个`home`组件来包含我们应用程序的着陆体验，这样我们就可以将实现细节排除在`app.component`之外：
- en: 'Generate `manager`, `inventory`, `pos`, and `user` feature modules by specifying
    their names and routing capabilities:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过指定名称和路由能力生成`manager`、`inventory`、`pos`和`user`功能模块：
- en: '[PRE14]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note the abbreviated command structure, where `ng generate module manager` becomes
    `ng g m manager`, and similarly, `--module` becomes `-m`.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意简化的命令结构，其中`ng generate module manager`变为`ng g m manager`，同样，`--module`变为`-m`。
- en: Verify that you don’t have CLI errors.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认您没有CLI错误。
- en: Note that using `npx` on Windows may throw an error such as `Path must be a
    string. Received undefined`. This error doesn’t seem to affect the successful
    operation of the command, which is why it is critical always to inspect what the
    CLI tool generates.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，在Windows上使用`npx`可能会抛出错误，例如`Path must be a string. Received undefined`。这个错误似乎不会影响命令的成功执行，因此始终检查CLI工具生成的输出是至关重要的。
- en: 'Verify that the folder and the files are created:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认已创建文件夹和文件：
- en: '[PRE15]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let’s examine how `ManagerModule` has been configured. Remember that a feature
    module is decorated by the `@NgModule` annotation. In Angular apps configured
    with a root `NgModule`, you’ll notice that it implements the `bootstrap` property,
    whereas a feature module does not implement this. See the generated code below:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查 `ManagerModule` 的配置。记住，功能模块由 `@NgModule` 注解装饰。在配置有根 `NgModule` 的 Angular
    应用中，你会注意到它实现了 `bootstrap` 属性，而功能模块没有实现此属性。下面是生成的代码：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Since we specified the `--routing` option, a `routing` module has been created
    and imported into `ManagerModule`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们指定了 `--routing` 选项，已创建并导入到 `ManagerModule` 中的 `routing` 模块：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that `RouterModule` is being configured using `forChild`, as opposed to
    the optional `forRoot` method, either configured in an `AppRouting` module or
    a router provider in `ApplicationConfig`. By specifying the context, we allow
    the router to understand the proper relationship between routes defined in different
    module contexts. For example, all child routes defined in `ManagerRoutingModule`
    will be prepended by the route segment `/manager`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`RouterModule` 正在使用 `forChild` 进行配置，而不是可选的 `forRoot` 方法，该方法配置在 `AppRouting`
    模块或 `ApplicationConfig` 中的路由提供者。通过指定上下文，我们允许路由器理解不同模块上下文中定义的路由之间的正确关系。例如，在 `ManagerRoutingModule`
    中定义的所有子路由都将由路由段 `/manager` 预先添加。
- en: 'Be sure to execute `style` and `lint` `fix` commands before moving on:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，务必执行 `style` 和 `lint fix` 命令：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, let’s design how the landing page for LemonMart will look and work.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们设计 LemonMart 的着陆页将如何看起来和工作。
- en: Designing the home route
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计主页路由
- en: 'Consider the following mock-up as the landing experience for LemonMart:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下模拟作为 LemonMart 的着陆体验考虑：
- en: '![A screenshot of a login box  Description automatically generated with low
    confidence](img/B20960_04_04.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![登录框的截图，描述由低置信度自动生成](img/B20960_04_04.png)'
- en: 'Figure 4.4: LemonMart landing experience'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4：LemonMart 着陆体验
- en: Unlike the LocalCast Weather app, we don’t want a lot of layout markup in `AppComponent`.
    The `AppComponent` is the root element of your entire application; therefore,
    it should only contain elements that will persistently appear throughout your
    application. In the following annotated mock-up, the toolbar marked as **1** will
    be persistent throughout the app.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 与 LocalCast 天气应用不同，我们不希望在 `AppComponent` 中有太多的布局标记。`AppComponent` 是你整个应用的根元素；因此，它应该只包含将在你的应用中持续出现的元素。在以下注释模拟中，标记为
    **1** 的工具栏将在整个应用中保持不变。
- en: 'The area marked as **2** will house the `home` component, which itself will
    contain a login user control marked as **3**:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 标记为 **2** 的区域将包含 `home` 组件，该组件本身将包含一个标记为 **3** 的登录用户控件：
- en: '![A screenshot of a computer login  Description automatically generated with
    medium confidence](img/B20960_04_05.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![计算机登录的截图，描述由中等置信度自动生成](img/B20960_04_05.png)'
- en: 'Figure 4.5: LemonMart layout structure'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5：LemonMart 布局结构
- en: It’s best practice to create your default or landing component as a separate
    element in Angular. This helps reduce the amount of code that must be loaded and
    logically executed on every page, but it also results in a more flexible architecture
    when utilizing the router.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 中，将默认或着陆组件作为单独的元素创建是最佳实践。这有助于减少必须加载和在每个页面上逻辑执行的代码量，但它也使得在利用路由器时具有更灵活的架构。
- en: 'Generate the `home` component with an inline template and styles:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内联模板和样式生成 `home` 组件：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that a component with an inline template and a style is also called a **Single
    File Component** or an **SFC**.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，具有内联模板和样式的组件也称为 **单文件组件** 或 **SFC**。
- en: Now, you are ready to configure the router.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已准备好配置路由器。
- en: Setting up default routes
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置默认路由
- en: 'Let’s get started with setting up a simple route for LemonMart. We need to
    set up the `/` route (also known as the empty route) and the `/home` route to
    display the `HomeComponent`. We also need a wildcard route to capture all undefined
    routes and display a `PageNotFoundComponent`, which must also be created:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始设置 LemonMart 的简单路由。我们需要设置 `/` 路由（也称为空路由）和 `/home` 路由以显示 `HomeComponent`。我们还需要一个通配符路由来捕获所有未定义的路由并显示一个
    `PageNotFoundComponent`，这也必须被创建：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let’s put together the route configuration above step by step:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步整理上述路由配置：
- en: Define a path for `'home'` and direct the router to render `HomeComponent` by
    setting the `component` property.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `'home'` 的路径，并通过设置 `component` 属性将路由器指向渲染 `HomeComponent`。
- en: Set the default path of the application `''` to be redirected to `'/home'`.
    By setting the `pathMatch` property, we always ensure that this specific instance
    of the `home` route will be rendered as the landing experience; otherwise, in
    its default prefix setting, `pathMatch` considers an empty path to be a prefix
    of all routes, resulting in an endless redirect loop.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将应用程序的默认路径`''`设置为重定向到`'/home'`。通过设置`pathMatch`属性，我们始终确保这个特定的`home`路由实例将被渲染为着陆体验；否则，在其默认前缀设置中，`pathMatch`将考虑空路径为所有路由的前缀，导致无限重定向循环。
- en: Create a `pageNotFound` component with an inline template.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有内联模板的`pageNotFound`组件。
- en: Configure a wildcard route for `PageNotFoundComponent` as the last entry.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`PageNotFoundComponent`配置为最后一个条目的通配符路由。
- en: By configuring the wildcard route as the last entry, we handle any route that
    is not matched gracefully by redirecting it to `PageNotFoundComponent`. The wildcard
    path must be the last property in the array; otherwise, routes defined after will
    not be considered.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将通配符路由配置为最后一个条目，我们处理任何未通过优雅匹配的路由，将其重定向到`PageNotFoundComponent`。通配符路径必须是数组中的最后一个属性；否则，定义在后面的路由将不会被考虑。
- en: RouterLink
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RouterLink
- en: 'When a user lands on the `PageNotFoundComponent`, we would like them to be
    able to get back to the `HomeComponent` using the `routerLink` directive:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户到达`PageNotFoundComponent`时，我们希望他们能够使用`routerLink`指令返回到`HomeComponent`：
- en: 'On `PageNotFoundComponent`, replace the inline template to link back to `home`
    using `routerLink`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PageNotFoundComponent`中，替换内联模板，使用`routerLink`链接回`home`：
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This navigation can also be done via an `<a href>` tag implementation; however,
    in more dynamic and complicated navigation scenarios, you will lose features such
    as automatic active link tracking or dynamic link generation.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这种导航也可以通过`<a href>`标签实现；然而，在更动态和复杂的导航场景中，你将失去诸如自动活动链接跟踪或动态链接生成等特性。
- en: The Angular bootstrap process will ensure that `AppComponent` is inside the
    `<app-root>` element in `index.html`. However, we must manually define where we
    would like `HomeComponent` to render to finalize the router configuration.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Angular引导过程将确保`AppComponent`位于`index.html`中的`<app-root>`元素内。然而，我们必须手动定义我们希望`HomeComponent`渲染的位置，以最终完成路由配置。
- en: Router outlet
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路由出口
- en: '`AppComponent` is considered a root element for the root router defined in
    `app-routes.ts`, which allows us to define outlets within this root element to
    dynamically load any content we wish using the `<router-outlet>` element:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppComponent`被认为是`app-routes.ts`中定义的根路由的根元素，这允许我们在根元素内部定义出口，以动态加载我们希望使用`<router-outlet>`元素加载的任何内容：'
- en: Configure `AppComponent` to use inline templates and styles, deleting any existing
    content in the `html` and `scss` file.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`AppComponent`配置为使用内联模板和样式，删除`html`和`scss`文件中任何现有的内容。
- en: Add the toolbar for your application.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你的应用程序添加工具栏。
- en: Add the name of your application as a button link so that it takes the user
    to the home page when clicked on.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将应用程序的名称作为按钮链接添加，以便在点击时将用户带到主页。
- en: Import `RouterLink`, `RouterOutlet`, and `MatToolbarModule` in the component.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件中导入`RouterLink`、`RouterOutlet`和`MatToolbarModule`。
- en: 'Add `<router-outlet>` for the content to render:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为内容添加`<router-outlet>`以进行渲染：
- en: '[PRE22]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, the contents of `home` will render inside `<router-outlet>`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`home`的内容将渲染在`<router-outlet>`内。
- en: Branding, customization, and Material icons
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 品牌、定制和Material图标
- en: To construct an attractive and intuitive toolbar, we must introduce some iconography
    and branding to the app so that the users can easily navigate through the app
    with the help of familiar icons.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建一个吸引人且直观的工具栏，我们必须向应用程序引入一些图标和品牌，以便用户可以在熟悉图标的帮助下轻松地导航应用程序。
- en: Branding
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 品牌
- en: In terms of branding, you should ensure that your web app has a custom color
    palette and integrates with desktop and mobile browser features to bring forward
    your app’s name and iconography.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在品牌方面，你应该确保你的Web应用有一个自定义的色彩调色板，并且与桌面和移动浏览器功能集成，以突出你的应用名称和图标。
- en: Color palette
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 色彩调色板
- en: 'Pick a color palette using the **Material Color** tool, located at [https://m2.material.io/design/color/the-color-system.html#tools-for-picking-colors](https://m2.material.io/design/color/the-color-system.html#tools-for-picking-colors).
    For LemonMart, I picked the following values:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用位于[https://m2.material.io/design/color/the-color-system.html#tools-for-picking-colors](https://m2.material.io/design/color/the-color-system.html#tools-for-picking-colors)的**Material
    Color**工具选择一个色彩调色板。对于LemonMart，我选择了以下值：
- en: '**Primary Color**- `#2E7D32`:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**主颜色**- `#2E7D32`：'
- en: '[PRE23]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**Secondary Color**- `#C6FF00`:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**次要颜色**- `#C6FF00`：'
- en: '[PRE24]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You may either implement your theme in `styles.scss` or create a separate theme
    file. A separate file is useful if you intend to further customize individual
    components.
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以在`styles.scss`中实现您的主题，或者创建一个单独的主题文件。如果打算进一步自定义单个组件，则单独的文件很有用。
- en: Add a file named `lemonmart-theme.scss`
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`lemonmart-theme.scss`的文件
- en: 'Move theme-related CSS from `styles.scss` over to the new file. Theme-related
    content will be above the following line:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将与主题相关的CSS从`styles.scss`移动到新文件。主题相关内容将在以下行之上：
- en: '[PRE25]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Update `styles.scss` to include the new theme in the first line of the file:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`styles.scss`更新为在文件的第一行包含新主题：
- en: '[PRE26]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Configure your custom theme with the chosen color palette.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用所选的色彩调色板配置您的自定义主题。
- en: You can also grab LemonMart-related assets from GitHub at [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以从GitHub获取与LemonMart相关的资源，网址为[https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)。
- en: For the LocalCast Weather app, we replaced the `favicon.ico` file to brand our
    app in the browser. While this would’ve been enough 10 years ago, today’s devices
    vary wildly, and each platform can leverage optimized assets better to represent
    your web app within its operating system. Next, let’s implement a more robust
    favicon.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 对于LocalCast天气应用，我们替换了`favicon.ico`文件，以在浏览器中为我们的应用打上品牌。虽然这在10年前就足够了，但今天的设备种类繁多，每个平台都可以更好地利用优化后的资源来代表您的Web应用在其操作系统中的表现。接下来，让我们实现一个更健壮的favicon。
- en: Implementing a browser manifest and icons
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现浏览器清单和图标
- en: 'You must ensure the browser shows the correct title text and icon in a **Browser**
    tab. Further, a manifest file should be created that implements specific icons
    for various mobile operating systems so that if a user pins your website, a desirable
    icon is displayed similarly to other app icons on the phone. This will ensure
    that if a user favorites or pins your web app on their mobile device’s home screen,
    they’ll get a native-looking app icon:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须确保浏览器在**浏览器**标签中显示正确的标题文本和图标。此外，应创建一个实现各种移动操作系统特定图标的清单文件，以便如果用户将您的网站固定，将显示一个类似其他手机应用图标的图标。这将确保如果用户在移动设备的首页上收藏或固定您的Web应用，他们将获得一个看起来像原生应用图标的图标：
- en: Create or obtain an SVG version of your website’s logo from a designer or a
    site like [https://www.flaticon.com](https://www.flaticon.com).
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从设计师或类似[https://www.flaticon.com](https://www.flaticon.com)的网站创建或获取您网站标志的SVG版本。
- en: In this case, I will be using the likeness of the Eureka lemon:![A picture containing
    yellow, banana  Description automatically generated](img/B20960_04_06.png)
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个例子中，我将使用尤里卡柠檬的相似图像：![包含黄色、香蕉的图片 自动生成的描述](img/B20960_04_06.png)
- en: 'Figure 4.6: LemonMart’s signature logo'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.6：LemonMart的标志性标志
- en: 'When using images you find online, pay attention to applicable copyrights.
    In this case, I have purchased a license to be able to publish this lemon logo,
    but you may grab your own copy at the following URL, given that you provide the
    required attribution to the author of the image: [https://www.flaticon.com/free-icon/lemon_605070](https://www.flaticon.com/free-icon/lemon_605070).'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当使用在线找到的图片时，请注意适用的版权。在这种情况下，我已购买许可证以能够发布这个柠檬标志，但您可以在以下URL获取自己的副本，前提是您向图片的作者提供所需的归属：[https://www.flaticon.com/free-icon/lemon_605070](https://www.flaticon.com/free-icon/lemon_605070)。
- en: Generate the `favicon.ico` and manifest files using a tool such as [https://realfavicongenerator.net](https://realfavicongenerator.net).
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用工具如[https://realfavicongenerator.net](https://realfavicongenerator.net)生成`favicon.ico`和清单文件。
- en: Adjust settings for iOS, Android, Windows, and macOS Safari to your liking.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整iOS、Android、Windows和macOS Safari的设置以符合您的喜好。
- en: In the generator, be sure to set a version number, as favicons can be notorious
    for caching; a random version number will ensure that users always get the latest
    version.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在生成器中，务必设置一个版本号，因为favicon可能会因缓存而出名；一个随机的版本号将确保用户总是获得最新版本。
- en: Download and extract the generated `favicons.zip` file into your `src` folder.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并解压缩生成的`favicons.zip`文件到您的`src`文件夹。
- en: 'Edit the `angular.json` file to include the new assets in your app:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`angular.json`文件以将新资源包含到您的应用中：
- en: '[PRE27]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Insert the generated code in the `<head>` section of `index.html`:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`index.html`的`<head>`部分插入生成的代码：
- en: '[PRE28]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Place the generated code between the favicon declaration and the CSS style imports.
    The order does matter. Browsers load data top-down. You want your application’s
    icon to be parsed before the user must wait for CSS files to be downloaded.
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在favicon声明和CSS样式导入之间放置生成的代码。顺序很重要。浏览器自上而下加载数据。您希望应用程序的图标在用户等待下载CSS文件之前被解析。
- en: Ensure that your new favicon displays correctly.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您的新 favicon 正确显示。
- en: Once your basic branding work has been completed, consider whether you’d like
    to establish a more unique look and feel with theming.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的基本品牌工作完成，请考虑是否希望通过主题化建立更独特的视觉和感觉。
- en: Custom themes
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义主题
- en: 'You may further customize Material’s look and feel to achieve a unique experience
    for your app by leveraging tools listed at [https://m2.material.io/resources](https://m2.material.io/resources)
    and some other tools that I have discovered, which are listed as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过利用以下工具列表中的工具以及我发现的某些其他工具来进一步自定义 Material 的外观和感觉，以实现您应用独特的体验：[https://m2.material.io/resources](https://m2.material.io/resources)：
- en: Material Design Theme Palette Generator will generate the necessary code to
    define your custom color palette to create truly unique themes at [http://mcg.mbitson.com](http://mcg.mbitson.com)
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Material Design 主题调色板生成器将在 [http://mcg.mbitson.com](http://mcg.mbitson.com)
    生成定义您自定义调色板的必要代码，以创建真正独特的主题。
- en: Color Blender helps with finding midway points between two colors, which is
    useful when defining in-between colors for the color swatches, located at [https://meyerweb.com/eric/tools/color-blend](https://meyerweb.com/eric/tools/color-blend)
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 颜色混合器有助于找到两种颜色之间的中间点，这在定义颜色样本之间的颜色时很有用，位于 [https://meyerweb.com/eric/tools/color-blend](https://meyerweb.com/eric/tools/color-blend)。
- en: In 2021, Google announced **Material 3**, aka Material You, a dynamic theming
    system that adapts to user preferences around OS-level color use. In 2023, Angular
    Material is still based on Material 2\. The Angular team transitioned to new **Material
    Design Components for Web** (**MDC**) style components in Angular 15 and will
    deprecate the old styles with Angular 17\. The MDC-style components support adjustable
    density and are more dynamic as a result. After this milestone, the Angular team
    plans to tackle the implementation of Material You.
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 2021 年，Google 宣布了 **Material 3**，也称为 Material You，这是一个动态主题系统，它适应用户在操作系统级别颜色使用方面的偏好。到
    2023 年，Angular Material 仍然基于 Material 2。Angular 团队在 Angular 15 中过渡到新的 **Web 端
    Material 设计组件**（**MDC**）风格组件，并在 Angular 17 中弃用旧样式。MDC 风格组件支持可调整的密度，因此更加动态。在此里程碑之后，Angular
    团队计划解决 Material You 的实现问题。
- en: 'You can follow this thread for updates: [https://github.com/angular/components/issues/22738](https://github.com/angular/components/issues/22738).'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以关注此线程以获取更新：[https://github.com/angular/components/issues/22738](https://github.com/angular/components/issues/22738)。
- en: There is a wealth of information at [https://material.io](https://material.io)
    on the in-depth philosophy behind the Material design, with great sections on
    things like the color system, [https://material.io/design/color/the-color-system.html](https://material.io/design/color/the-color-system.html),
    which dives deep into selecting the right color palette for your brand and other
    topics, such as creating a dark theme for your app.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [https://material.io](https://material.io) 上有大量关于 Material 设计深入哲学的信息，包括关于色彩系统等内容，如
    [https://material.io/design/color/the-color-system.html](https://material.io/design/color/the-color-system.html)，它深入探讨了为您的品牌选择正确的调色板以及其他主题，例如为您的应用创建深色主题。
- en: It is very important to distinguish your brand from other apps or your competitors.
    Creating a high-quality custom theme will be a time-consuming process; however,
    the benefits of creating a great first impression with your users are considerable.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 区分您的品牌与其他应用或竞争对手非常重要。创建高质量的定制主题将是一个耗时的过程；然而，通过给用户留下深刻的第一印象所带来的好处是相当可观的。
- en: Next, we will show you how to add custom icons to your Angular apps.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将向您展示如何将自定义图标添加到您的 Angular 应用中。
- en: Custom icons
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义图标
- en: 'Now, let’s add your custom branding to your Angular app. You will need the
    `svg` icon you used to create your favicon:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将您自定义的品牌添加到您的 Angular 应用中。您需要用于创建 favicon 的 `svg` 图标：
- en: Place the image under `src/assets/img/icons`, named `lemon.svg`.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图片放置在 `src/assets/img/icons` 目录下，命名为 `lemon.svg`。
- en: In `app.config.ts`, add `provideHttpClient()` as a provider so that the `.svg`
    file can be requested over HTTP.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `app.config.ts` 中，添加 `provideHttpClient()` 作为提供者，以便可以通过 HTTP 请求 `.svg` 文件。
- en: 'Update `AppComponent` to register the new .`svg` file as an icon:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `AppComponent` 以注册新的 `.svg` 文件作为图标：
- en: '[PRE29]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Beware that adding an `svg` icon from a URL resource doesn’t work in a **Server-Side
    Rendering** (**SSR**) configuration. Instead, you can add your `svg` icon as a
    `const` string in a TypeScript file import and register it as shown below:'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，从 URL 资源添加 `svg` 图标在 **服务器端渲染**（**SSR**）配置中不起作用。相反，您可以将 `svg` 图标作为 TypeScript
    文件导入中的 `const` 字符串添加，并按以下方式注册：
- en: '[PRE30]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Import `MatIconModule`.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `MatIconModule`。
- en: 'Following the pattern in the documentation for `MatToolbar`, found at [https://material.angular.io/components/toolbar](https://material.angular.io/components/toolbar),
    add the icon to the toolbar:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照在[https://material.angular.io/components/toolbar](https://material.angular.io/components/toolbar)文档中找到的`MatToolbar`模式，将图标添加到工具栏：
- en: '[PRE31]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, let’s add the remaining icons for the menu, user profile, and logout.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加菜单、用户个人资料和注销的剩余图标。
- en: Material icons
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 材料图标
- en: Angular Material works out of the box with the Material Design icon font, automatically
    imported into your app as a web font in `index.html`. It is possible to self-host
    the font; however, if you go down that path, you don’t get the benefit if the
    user’s browser has already cached the font from when they visited another website,
    which could save the speed and latency of downloading a 42-56 KB file in the process.
    The complete list of icons can be found at [https://fonts.google.com/icons](https://fonts.google.com/icons).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Angular Material与Material Design图标字体无缝配合，自动作为网页字体导入到您的应用中，位于`index.html`。您可以自行托管字体；然而，如果您选择这条路，如果用户的浏览器已经从访问另一个网站时缓存了字体，那么您将无法获得好处，这可能会在下载42-56
    KB文件的过程中节省速度和延迟。完整的图标列表可以在[https://fonts.google.com/icons](https://fonts.google.com/icons)找到。
- en: 'Now let’s update the toolbar with some icons and set up the home page with
    a minimal template for a fake login button:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更新工具栏并添加一些图标，设置主页并使用最小模板添加一个假登录按钮：
- en: 'Ensure that the Material icons `<link>` tag has been added to `index.html`:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保材料图标的`<link>`标签已添加到`index.html`：
- en: '[PRE32]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Instructions on self-hosting can be found under the **Self Hosting** section
    at [http://google.github.io/material-design-icons/#getting-icons](http://google.github.io/material-design-icons/#getting-icons).
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在[http://google.github.io/material-design-icons/#getting-icons](http://google.github.io/material-design-icons/#getting-icons)的**自托管**部分可以找到自托管说明。
- en: Once configured, working with Material icons is easy.
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦配置完成，使用材料图标就变得简单。
- en: On `AppComponent`, update the toolbar to place a **Menu** button to the left
    of the title.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AppComponent`上，更新工具栏，将**菜单**按钮放置在标题的左侧。
- en: Add the `fxFlex` directive so that the remaining icons are right-aligned.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`fxFlex`指令，以便剩余的图标右对齐。
- en: Import `FlexModule` and `MatButtonModule`.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`FlexModule`和`MatButtonModule`。
- en: 'Add user profile and logout icons:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加用户个人资料和注销图标：
- en: '[PRE33]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'On `HomeComponent`, add a minimal template for a login experience, replacing
    any existing content. Don’t forget to import `FlexModule` and `MatButtonModule`:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`HomeComponent`上，添加一个用于登录体验的最小模板，替换任何现有内容。别忘了导入`FlexModule`和`MatButtonModule`：
- en: '[PRE34]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Your app should look similar to this screenshot:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用应该看起来与这张截图相似：
- en: '![A screenshot of a computer  Description automatically generated](img/B20960_04_07.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![计算机截图 自动生成描述](img/B20960_04_07.png)'
- en: 'Figure 4.7: LemonMart with minimal login'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7：LemonMart的最小登录界面
- en: There’s still some work to be done in terms of implementing and showing/hiding
    the menu, profile, and logout icons, given the user’s authentication status. We
    will cover this functionality in *Chapter 7*, *Working with REST and GraphQL APIs*.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 由于用户的认证状态，在实现和显示/隐藏菜单、个人资料和注销图标方面还有一些工作要做。我们将在*第7章*，*使用REST和GraphQL API*中介绍这个功能。
- en: To debug the router, get a visualization of your routes, and tightly integrate
    Angular with Chrome debugging features, use Angular DevTools, available from Chrome
    Web Store (also compatible with Microsoft Edge) or Firefox add-ons at [https://angular.dev/tools/devtools](https://angular.dev/tools/devtools).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 要调试路由，获取您的路由的可视化，并将Angular紧密集成到Chrome的调试功能中，请使用从Chrome Web Store（也兼容Microsoft
    Edge）或Firefox插件[https://angular.dev/tools/devtools](https://angular.dev/tools/devtools)提供的Angular
    DevTools。
- en: Now that you’ve set up basic routing for your app, we can move on to setting
    up lazily loaded modules with subcomponents. If you’re unfamiliar with troubleshooting
    and debugging Angular, please refer to [https://angular.dev/tools/devtools](https://angular.dev/tools/devtools)
    before moving forward.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经为您的应用设置了基本的路由，我们可以继续设置带有子组件的懒加载模块。如果您不熟悉Angular的故障排除和调试，请在继续之前查阅[https://angular.dev/tools/devtools](https://angular.dev/tools/devtools)。
- en: Feature modules with lazy loading
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有懒加载的功能模块
- en: 'There are two ways resources are loaded: eagerly or lazily. When the browser
    loads up `index.html` for your app, it starts processing it from top to bottom.
    First, the `<head>` element is processed, then `<body>`. For example, the CSS
    resources we defined in `<head>` of our app will be downloaded before our app
    is rendered because our Angular app is defined as `<script>` in `<body>` of the
    HTML file.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 资源加载有两种方式：急切加载或懒加载。当浏览器加载你的应用的`index.html`时，它从上到下开始处理。首先处理`<head>`元素，然后是`<body>`。例如，我们在应用的`<head>`中定义的CSS资源将在我们的Angular应用在HTML文件的`<body>`中定义为`<script>`之前下载，因为我们的Angular应用被定义为HTML文件的`<body>`中的`<script>`。
- en: When you use the `ng build` command, Angular leverages the webpack module bundler
    to combine all the JavaScript, HTML, and CSS into minified and optimized JavaScript
    bundles.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`ng build`命令时，Angular利用webpack模块打包器将所有JavaScript、HTML和CSS组合成最小化和优化的JavaScript包。
- en: If you don’t leverage lazy loading in Angular, the entire contents of your app
    will be eagerly loaded. The user won’t see the first screen of your app until
    all screens are downloaded and loaded.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不在Angular中使用懒加载，你的应用的所有内容都将被急切加载。用户将看不到你的应用的第一屏，直到所有屏幕都下载并加载完成。
- en: Lazy loading allows the Angular build process, working in tandem with webpack,
    to separate your web application into different JavaScript files called chunks.
    We can enable this chunking by separating out portions of the application into
    feature modules. Feature modules and their dependencies can be bundled into separate
    chunks. Remember that the root module and its dependencies will always be in the
    first downloaded chunk. So, by chunking our application’s JavaScript bundle size,
    we keep the size of the initial chunk at a minimum. With a minimal first chunk,
    no matter how big your application grows, the time to First Meaningful Paint remains
    constant. Otherwise, your app would take longer and longer to download and render
    as you add more features and functionality to it. Lazy loading is critical to
    achieving a scalable application architecture.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 懒加载允许Angular构建过程与webpack协同工作，将你的Web应用分割成不同的JavaScript文件，称为chunks。我们可以通过将应用程序的部分分离到功能模块中来实现这种chunking。功能模块及其依赖项可以捆绑到单独的chunks中。请记住，根模块及其依赖项将始终在第一个下载的chunk中。因此，通过chunking我们的应用程序的JavaScript包大小，我们保持初始chunk的大小最小。有了最小化的第一个chunk，无论你的应用如何增长，首次有意义的绘制时间保持不变。否则，随着你向应用添加更多功能和功能，你的应用将需要更长的时间来下载和渲染。懒加载对于实现可扩展的应用程序架构至关重要。
- en: 'Consider the following graphic to determine which routes are eagerly loaded
    and which ones are lazily loaded:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下图形以确定哪些路由是急切加载的，哪些是懒加载的：
- en: '![A diagram of a system  Description automatically generated](img/B20960_04_08.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![系统图，描述自动生成](img/B20960_04_08.png)'
- en: 'Figure 4.8: Angular router eager vs lazy loading'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8：Angular路由急切加载与懒加载
- en: 'The black triangles are standalone components, and the black circles are components
    that depend on a module. `rootRouter` defines three routes: `a`, `b`, and `c`.
    `/master` and `/detail` represent named router outlets, which are covered in *Chapter
    9*, *Recipes – Master/Detail, Data Tables, and NgRx*. Route `a` is the default
    route for the app. Routes `a` and `c` are connected to `rootRouter` with a solid
    line, whereas route `b` is connected using a dashed line. In this context, route
    `b` is configured as a lazy-loaded route. This means route `b` will dynamically
    load a feature module, `BModule`, containing `childRouter`. `childRouter` can
    define any number of components, even reusing route names that were reused elsewhere.
    In this case, `b` defines two additional routes: `/b/a` and `/b/b`.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 黑色三角形是独立组件，而黑色圆圈是依赖于模块的组件。`rootRouter`定义了三条路由：`a`、`b`和`c`。`/master`和`/detail`代表命名路由出口，这在*第9章*、*食谱
    – 主/详情、数据表和NgRx*中有详细说明。路由`a`是应用的默认路由。路由`a`和`c`用实线连接到`rootRouter`，而路由`b`则使用虚线连接。在这种情况下，路由`b`被配置为懒加载路由。这意味着路由`b`将动态加载一个包含`childRouter`的功能模块`BModule`。`childRouter`可以定义任意数量的组件，甚至可以重用其他地方已经重用的路由名称。在这种情况下，`b`定义了两个额外的路由：`/b/a`和`/b/b`。
- en: 'Consider the example router definition for `rootRouter`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑`rootRouter`的示例路由定义：
- en: '[PRE35]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Note that the definitions for routes `/b/a`, `/b/b`, `/c/a`, and `/c/b` do
    not exist in `rootRouter`. See the example router definition for `childRouter`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，路由`/b/a`、`/b/b`、`/c/a`和`/c/b`的定义在`rootRouter`中不存在。请参阅`childRouter`的示例路由定义：
- en: '[PRE36]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can see, the routes defined in `childRouter` are independent of the ones
    defined in `rootRouter`. Child routes exist in a hierarchy, where `/b` is the
    parent path. To navigate to `BAComponent`, you must use the path `/b/a`, and to
    navigate to `CAComponent`, you use `/c/a`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Given this example configuration, every component defined in `rootRouter` and
    their dependencies would be in the first chunk of our app and thus eagerly loaded.
    The first chunk would include the components `A`, `Master`, `Detail`, and `PageNotFound`.
    The second chunk would contain the components `BA` and `BB`. This second chunk
    would not be downloaded or loaded until the user navigated to a path starting
    with `/b`; thus, it’s lazily loaded. In a standalone configuration, this chunking
    can be granular at the component level.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: I cover lazy loading standalone components in *Chapter 8*, *Recipes – Reusability,
    Forms, and Caching*, when we add shared components used across different modules.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: You can read about it more in detail at [https://angular.io/guide/standalone-components#lazy-loading-a-standalone-component](https://angular.io/guide/standalone-components#lazy-loading-a-standalone-component).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: We will now go over how to set up a feature module with components and routes.
    We will also use Angular DevTools to observe the effects of our various router
    configurations.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Configuring feature modules with components and routes
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The manager module needs a landing page, as shown in this mock-up:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B20960_04_09.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.9: Manager’s dashboard'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by creating the home screen for `ManagerModule`:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `ManagerHome` component:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: To create the new component under the `manager` folder, we must prefix `manager/`before
    the component name. Since this is another landing page, it is unlikely to be complicated
    enough to require separate HTML and CSS files. You can use `--inline-style` (alias
    `-s`) and/or `--inline-template` (alias `-t`) to avoid creating additional files.
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Verify that your folder structure looks as follows:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Configure the `ManagerHome` component’s route in `manager-routing.module.ts`,
    similar to how we configured the `Home` `component` in `app.route.ts`:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note that `http://localhost:4200/manager` doesn’t resolve to a component yet,
    because our Angular app isn’t aware that `ManagerModule` exists. Eager-loading
    modules in a standalone project simply don’t make sense; we will only consider
    the lazy loading of a feature module.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s implement lazy loading for `ManagerModule`, so Angular can navigate
    to it.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Lazy loading
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Lazy loading code may seem like black magic (aka misunderstood) code. To load
    routes from a different module, we know we can’t simply import them; otherwise,
    they will be eagerly loaded. The answer lies in configuring a route using the
    `loadChildren` attribute with an inline `import` statement informing the router
    how to load a feature module in `app.routes.ts`:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 懒加载代码可能看起来像是黑魔法（即误解）代码。为了从不同的模块加载路由，我们知道我们不能简单地导入它们；否则，它们将被预先加载。答案在于使用 `loadChildren`
    属性配置路由，并使用内联 `import` 语句通知路由器如何在 `app.routes.ts` 中加载功能模块：
- en: 'In `app.routes.ts`, implement or update the `''manager''` path with the `loadChildren`
    attribute:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `app.routes.ts` 中，使用 `loadChildren` 属性实现或更新 `'manager'` 路径：
- en: '[PRE40]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Lazy loading is achieved via a clever trick that avoids using an `import` statement
    at the file level. A function delegate is set to the `loadChildren` property,
    which contains an inline `import` statement defining the location of the feature
    module file, such as `./manager/manager.module`, allowing us to refer to `ManagerModule`
    in a type-safe manner without fully loading it. The inline `import` statement
    can be interpreted during the build process to create a separate JavaScript chunk
    that can be downloaded only when needed. `ManagerModule` is self-sufficient as
    a feature module; it manages all its child dependencies and routes.
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 懒加载是通过一种巧妙的技巧实现的，避免了在文件级别使用 `import` 语句。将一个函数委托设置到 `loadChildren` 属性，该属性包含一个内联
    `import` 语句，定义了功能模块文件的位置，例如 `./manager/manager.module`，允许我们以类型安全的方式引用 `ManagerModule`
    而无需完全加载它。内联 `import` 语句可以在构建过程中被解释，以创建一个单独的 JavaScript 块，只有在需要时才能下载。`ManagerModule`
    作为功能模块是自给自足的；它管理所有子依赖项和路由。
- en: 'Update the `manager-routing.module.ts` routes, considering that `manager` is
    now their root route:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑到 `manager` 现在是它们的根路由，更新 `manager-routing.module.ts` 路由：
- en: '[PRE41]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We can now update the route for `ManagerHomeComponent` to a more meaningful
    `'home'` path. This path won’t clash with the one found in `app.routes.ts` because,
    in this context, `'home'` resolves to `'manager/home'` and, similarly, where `path`
    is empty, the URL will look like `http://localhost:4200/manager`.
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在可以将 `ManagerHomeComponent` 的路由更新为更有意义的 `'home'` 路径。这个路径不会与 `app.routes.ts`
    中的路径冲突，因为在当前上下文中，`'home'` 解析为 `'manager/home'`，同样地，当 `path` 为空时，URL 将看起来像 `http://localhost:4200/manager`。
- en: Restart your `ng serve` or `npm start` command, so Angular can chunk the app
    properly.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动 `ng serve` 或 `npm start` 命令，以便 Angular 可以正确地分块应用程序。
- en: Navigate to `http://localhost:4200/manager`.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `http://localhost:4200/manager`。
- en: 'Confirm that lazy loading is working by observing the CLI output contains a
    new **Lazy Chunk Files** section:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过观察 CLI 输出是否包含一个新的 **Lazy Chunk Files** 部分，以确认懒加载是否正常工作：
- en: '[PRE42]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We have successfully set up a feature module with lazy loading. Next, let’s
    implement the walking skeleton for LemonMart.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已成功设置了一个具有懒加载的功能模块。接下来，让我们为 LemonMart 实现行走骨架。
- en: Creating the walking skeleton
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建行走骨架
- en: Using the site map we created for LemonMart earlier in the chapter, we need
    to create the walking skeleton navigation experience for the app. To create this
    experience, we must create some buttons to link all modules and components together.
    We will go at this module by module.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本章早期为 LemonMart 创建的网站图，我们需要为应用程序创建行走骨架导航体验。为了创建这种体验，我们必须创建一些按钮来链接所有模块和组件。我们将按模块逐一进行。
- en: 'Before we start, update the `Login` button on `HomeComponent` to navigate to
    the `''manager''` path using the `routerLink` attribute and rename the button:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，更新 `HomeComponent` 上的 `Login` 按钮以使用 `routerLink` 属性导航到 `'manager'` 路径，并重命名该按钮：
- en: '[PRE43]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now, we can navigate to the `ManagerHome` component by clicking on the **Login**
    button.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过点击 **Login** 按钮导航到 `ManagerHome` 组件。
- en: The manager module
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理模块
- en: Since we already enabled lazy loading for `ManagerModule`, let’s go ahead and
    complete the rest of the navigational elements for it.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已为 `ManagerModule` 启用了懒加载，让我们继续完成其余的导航元素。
- en: 'In the current setup, `ManagerHomeComponent` renders in `<router-outlet>` defined
    in `AppComponent`''s template, so when the user navigates from `HomeComponent`
    to `ManagerHomeComponent`, the toolbar implemented in `AppComponent` remains in
    place. See the following mock-up for **Manager’s Dashboard**:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前设置中，`ManagerHomeComponent` 在 `AppComponent` 模板中定义的 `<router-outlet>` 中渲染，因此当用户从
    `HomeComponent` 导航到 `ManagerHomeComponent` 时，`AppComponent` 中实现的工具栏将保持原位。参见以下
    **管理仪表板** 的模拟图：
- en: '![A close-up of a login form  Description automatically generated with low
    confidence](img/B20960_04_10.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![登录表单的特写  描述由低置信度自动生成](img/B20960_04_10.png)'
- en: 'Figure 4.10: App-wide and feature module toolbars'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10：应用范围和功能模块工具栏
- en: The app-wide toolbar remains in place no matter where we navigate to. Imagine
    that we can implement a similar toolbar for the feature module that persists throughout
    `ManagerModule`. So, the navigational **User Management** and **Receipt Look-up**
    buttons would always be visible. This allows us to create a consistent UX for
    navigating subpages across modules.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 应用范围工具栏无论我们导航到哪里都保持不变。想象一下，我们可以为`ManagerModule`中持续存在的功能模块实现一个类似的工具栏。因此，导航的**用户管理**和**收据查找**按钮将始终可见。这允许我们在模块之间创建一致的UX来导航子页面。
- en: 'To implement a secondary toolbar, we need to replicate the parent-child relationship
    between `AppComponent` and `HomeComponent`, where the parent implements the toolbar
    and `<router-outlet>` so that child elements can be rendered in there:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现一个次要工具栏，我们需要复制`AppComponent`和`HomeComponent`之间的父子关系，其中父元素实现工具栏和`<router-outlet>`，以便子元素可以渲染在那里：
- en: 'Start by creating the base `manager` component:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建基本的`manager`组件：
- en: '[PRE44]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `--flat` option skips directory creation and places the component directly
    under the `manager` folder, just like `AppComponent` residing directly under the
    `app` folder.
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`--flat`选项跳过目录创建，并将组件直接放置在`manager`文件夹下，就像位于`app`文件夹下的`AppComponent`一样。'
- en: 'In `ManagerComponent`, implement a navigational toolbar with `activeLink` tracking:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ManagerComponent`中实现一个带有`activeLink`跟踪的导航工具栏：
- en: '[PRE45]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In a standalone project, every new component is created as a standalone component.
    This means that every component must import its own dependencies. Don’t forget
    to granularly import every feature used in the template.
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在独立项目中，每个新组件都是作为一个独立组件创建的。这意味着每个组件都必须导入它自己的依赖项。别忘了在模板中逐个导入每个使用的功能。
- en: 'Create components for the subpages:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建子页面的组件：
- en: '[PRE46]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Create the parent-children routing. We know that we need the following routes
    to be able to navigate to our subpages, as follows:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建父子路由。我们知道我们需要以下路由才能导航到我们的子页面，如下所示：
- en: '[PRE47]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To target `<router-outlet>` defined in `ManagerComponent`, we need to create
    a parent route first and then specify routes for the subpages:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 要针对在`ManagerComponent`中定义的`<router-outlet>`，我们需要首先创建一个父路由，然后指定子页面的路由：
- en: '[PRE48]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You should now be able to navigate through the app. When you click on the **Login
    as Manager** button, you will be taken to the page shown here. The clickable targets
    are highlighted:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够导航到应用中。当你点击**登录为管理员**按钮时，你将被带到这里显示的页面。可点击的目标被突出显示：
- en: '![A screenshot of a computer  Description automatically generated](img/B20960_04_11.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的描述](img/B20960_04_11.png)'
- en: 'Figure 4.11: Manager’s Dashboard with all router links highlighted'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11：带有所有路由链接高亮显示的管理员仪表板
- en: If you click on **LemonMart**, you will be taken to the home page. If you click
    on **Manager’s Dashboard**, **User Management**, or **Receipt Lookup**, you will
    be navigated to the corresponding subpage, while the active link will be bold
    and underlined on the toolbar.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击**LemonMart**，你将被带到主页。如果你点击**管理员的仪表板**、**用户管理**或**收据查找**，你将被导航到相应的子页面，而活动链接将在工具栏上加粗并下划线。
- en: User module
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户模块
- en: 'Upon login, users can access their profiles and view a list of actions they
    can access in the LemonMart app through a side navigation menu. In *Chapter 6*,
    *Implementing Role-Based Navigation*, when we implement authentication and authorization,
    we will be receiving the role of the user from the server. Based on the user’s
    role, we can automatically navigate or limit the options users can see. We will
    implement these components in this module so that they will only be loaded once
    a user is logged in. To complete the walking skeleton, we will ignore authentication-related
    concerns:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 用户登录后，可以通过侧边导航菜单访问他们的个人资料并查看在LemonMart应用中可以访问的操作列表。在*第6章*，*实现基于角色的导航*中，当我们实现身份验证和授权时，我们将从服务器接收用户的角色。根据用户的角色，我们可以自动导航或限制用户可以看到的选项。我们将在这个模块中实现这些组件，以便它们只在用户登录时加载。为了完成行走骨架，我们将忽略与身份验证相关的关注点：
- en: 'Create the necessary components:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建必要的组件：
- en: '[PRE49]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Implement routing.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现路由。
- en: 'Start with implementing the lazy loading in `app.routes.ts`:'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从在`app.routes.ts`中实现懒加载开始：
- en: '[PRE50]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: As explained earlier, ensure that the `PageNotFoundComponent` route is always
    the last route in `app.routes.ts` – because it has a wildcard matcher, it will
    overwrite routes defined after it.
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如前所述，确保`PageNotFoundComponent`路由始终是`app.routes.ts`中的最后一个路由——因为它有一个通配符匹配器，它将覆盖其后的路由定义。
- en: 'Now implement the child routes in `user-routing.module.ts`:'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在在`user-routing.module.ts`中实现子路由：
- en: '[PRE51]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We are implementing routing for `NavigationMenuComponent` because it’ll be directly
    used as an HTML element. In addition, since `UserModule` doesn’t have a landing
    page, there’s no default path defined.
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们正在为`NavigationMenuComponent`实现路由，因为它将被直接用作HTML元素。此外，由于`UserModule`没有登录页面，因此没有定义默认路径。
- en: 'In `AppComponent`, wire up the `user` and `logout` icons:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AppComponent`中连接`user`和`logout`图标：
- en: '[PRE52]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Icon buttons can be cryptic, so it’s a good idea to add tooltips. For tooltips
    to work, switch from the `mat-icon-button` directive to the `mat-mini-fab` directive
    and ensure you import `MatTooltipModule` as required. In addition, ensure that
    you add `aria-label` for icon-only buttons so that users with disabilities relying
    on screen readers can still navigate your web application.
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图标按钮可能难以理解，因此添加工具提示是个好主意。为了让工具提示工作，从`mat-icon-button`指令切换到`mat-mini-fab`指令，并确保按需导入`MatTooltipModule`。此外，确保为仅图标按钮添加`aria-label`，以便依赖屏幕阅读器的残障用户仍然可以导航您的Web应用程序。
- en: Ensure that the app works.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保应用程序正常工作。
- en: 'You’ll note that the two buttons are too close to each other, as follows:'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您会注意到两个按钮彼此之间太近，如下所示：
- en: '![A green and white flag  Description automatically generated with low confidence](img/B20960_04_12.png)'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![A green and white flag  Description automatically generated with low confidence](img/B20960_04_12.png)'
- en: 'Figure 4.12: Toolbar with icons'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.12：带有图标的工具栏
- en: You can fix the icon layout issue by adding `fxLayoutGap="8px"` to `<mat-toolbar>`;
    however, now the lemon logo is too far apart from the app name, as shown:![](img/B20960_04_13.png)
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过在`<mat-toolbar>`中添加`fxLayoutGap="8px"`来解决图标布局问题；然而，现在柠檬标志与应用程序名称的距离太远，如下所示：![img/B20960_04_13.png](img/B20960_04_13.png)
- en: 'Figure 4.13: Toolbar with padded icons'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.13：带有填充图标的工具栏
- en: 'The logo layout issue can be fixed by merging the icon and the button:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过合并图标和按钮可以修复标志布局问题：
- en: '[PRE53]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'As shown in the following screenshot, the grouping fixes the layout issue:'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如以下截图所示，分组解决了布局问题：
- en: '![](img/B20960_04_14.png)'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![img/B20960_04_14.png](img/B20960_04_14.png)'
- en: 'Figure 4.14: Toolbar with grouped and padded elements'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图4.14：带有分组和填充元素的工具栏
- en: 'Another alternative is to wrap the text around `<span>`; however, in that case,
    you need to add some padding to maintain the look:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个替代方案是将文本包裹在`<span>`标签中；然而，在这种情况下，您需要添加一些填充以保持外观：
- en: '[PRE54]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This is more desirable from a UX perspective; now, users can return to the home
    page by clicking on the lemon.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户体验的角度来看，这更令人满意；现在，用户可以通过点击柠檬返回主页。
- en: POS and inventory modules
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: POS和库存模块
- en: Our walking skeleton presumes the role of the manager. To be able to access
    all the components we are about to create, we need to enable the manager to be
    able to access the POS and inventory modules.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的行走骨架扮演管理者的角色。为了能够访问我们即将创建的所有组件，我们需要使管理者能够访问POS和库存模块。
- en: 'Update `ManagerComponent` with two new buttons:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 用两个新按钮更新`ManagerComponent`：
- en: '[PRE55]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note that these router links will navigate us out of the realm of `ManagerModule`,
    so it is normal for the manager-specific secondary toolbar to disappear.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些路由链接将使我们离开`ManagerModule`的领域，因此管理特定的二级工具栏消失是正常的。
- en: Now, it’ll be up to you to implement the last two remaining modules. For the
    two new modules, I provide high-level steps and refer you to a previous module
    on which you can model the new one. If you get stuck, refer to the `projects/stage7`
    folder on the GitHub project at [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将取决于您来实现最后两个剩余的模块。对于这两个新模块，我提供了高级步骤，并指导您参考先前的模块，您可以在其中为新模块建模。如果您遇到困难，请参考GitHub项目[https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)中的`projects/stage7`文件夹。
- en: PosModule
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PosModule
- en: '`PosModule` is very similar to `UserModule`, except that `PosModule` was a
    default path. `PosComponent` will be the default component. This has the potential
    to be a complicated component with some subcomponents, so don’t use inline templates
    or styles:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`PosModule`与`UserModule`非常相似，除了`PosModule`是默认路径。`PosComponent`将是默认组件。这可能是一个具有一些子组件的复杂组件，因此不要使用内联模板或样式：'
- en: Create `PosComponent`.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`PosComponent`。
- en: Register `PosComponent` as the default path.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`PosComponent`注册为默认路径。
- en: Configure lazy loading for `PosModule`.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`PosModule`配置懒加载。
- en: Ensure that the app works.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保应用程序正常工作。
- en: Now let’s implement `InventoryModule`.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们实现`InventoryModule`。
- en: InventoryModule
  id: totrans-359
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: InventoryModule
- en: '`InventoryModule` is very similar to `ManagerModule`, as shown:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`InventoryModule`与`ManagerModule`非常相似，如下所示：'
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B20960_04_15.png)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.15: Inventory Dashboard mock-up'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: Create a base `Inventory` component.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register `MaterialModule`.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create **Inventory Home**, **Stock Entry**, **Products**, and **Categories**
    components.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure parent-children routes in `inventory-routing.module.ts`.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure lazy loading for `InventoryModule`.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a secondary toolbar for internal `InventoryModule` navigation in `InventoryComponent`.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Ensure that the app works, as shown:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B20960_04_16.png)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.16: LemonMart Inventory Dashboard'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: Now that the walking skeleton of the app is completed, it is important to inspect
    the CLI output to ensure that all expected modules or components are being lazy
    loaded.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to resolve any testing errors before moving on. Ensure that `npm test`
    and `npm run e2e` execute without errors.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Common testing module
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a lot of modules to deal with, it becomes tedious to configure
    the imports and providers for each `spec` file individually. For this purpose,
    create a common testing module to contain a generic configuration that you can
    reuse across the board.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: 'First, start by creating a new .`ts` file:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: Create `common/common.testing.ts`.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Populate it with common testing providers, fakes, and modules.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'I have provided a `commonTestingModules` array:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now let’s see a sample use of this shared configuration file:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: While `commonTestingModules` is convenient, as your application grows, it’ll
    start slowing down test runs by importing unnecessary modules. Standalone components
    go a long way to mitigate this issue since they bring their own imports with them.
    Be mindful not to overload this convenience module.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: Stop! Did you ensure all your unit tests are passing? To ensure your tests are
    always passing, implement a CI pipeline in CircleCI, as demonstrated in *Chapter
    10*, *Releasing to Production with CI/CD*.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: With your tests up and running, the walking skeleton for LemonMart is completed.
    Now, let’s look ahead and start thinking about what kinds of data entities we
    might be working with.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Designing around major data entities
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fourth step in router-first architecture is achieving a stateless, data-driven
    design. To achieve this, it helps a lot to organize your APIs around major data
    components. This will roughly match how you consume data in various components
    in your Angular application. We will start off by defining our major data components
    by creating a rough data **Entity Relationship Diagram** (**ERD**). In *Chapter
    5*, *Designing Authentication and Authorization*, we will review the design and
    implementation of an API for the user data entity using Swagger.io and Express.js
    for REST and Apollo for GraphQL.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: Defining entities
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start by looking at what kind of entities you would like to store and
    how these entities might relate to one another.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a sample design for LemonMart, created using [draw.io](http://draw.io):'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B20960_04_17.png)'
  id: totrans-391
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.17: ERD for LemonMart'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: Currently, whether your entities are stored in a SQL or NoSQL database is inconsequential.
    My suggestion is to stick to what you know, but if you’re starting from scratch,
    a NoSQL database like MongoDB will offer the most flexibility as your implementation
    and requirements evolve.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: Generally, you will need CRUD APIs for each entity. Considering these data elements,
    we can also imagine user interfaces around these CRUD APIs. Let’s do that next.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: High-level UX design
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mock-ups are important in determining what kind of components and user controls
    we will need throughout the app. Any user control or component that will be used
    across components must be defined at the root level, and others must be scoped
    with their own modules.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier in this chapter, we identified the sub modules and designed landing
    pages for them to complete the walking skeleton. Now that we have defined the
    major data components, we can complete mock-ups for the rest of the app. When
    designing screens at a high level, keep several things in mind:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: Can a user complete common tasks required for their role with as little navigation
    as possible?
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can users readily access all information and functionality of the app through
    visible elements on the screen?
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can a user search for the data they need easily?
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once a user finds a record of interest, can they drill down into detailed records
    or view related records with ease?
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is that pop-up alert necessary? You know users won’t read it, right?
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that there’s no one right way to design any UX, which is why when designing
    screens, you should always keep modularity and reusability in mind.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: Creating an artifacts wiki
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier in the chapter, it is important to document every artifact
    you create. Wikis offer a way to create living documentation that can be collaboratively
    updated or edited. While Slack, Teams, email, and whiteboards offer good collaboration
    opportunities, their ephemeral nature leaves much to be desired.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: 'So, as you generate various design artifacts, such as mock-ups or design decisions,
    take care to post them on a wiki reachable by all team members:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: On GitHub, switch over to the **Wiki** tab.
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may check out my sample wiki at [https://github.com/duluca/lemon-mart/wiki](https://github.com/duluca/lemon-mart/wiki),
    as shown:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B20960_04_18.png)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.18: GitHub.com LemonMart wiki'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: When creating a wiki page, ensure that you cross-link between any other documentation
    available, such as **Readme**.
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that GitHub shows subpages on the wiki under **Pages**.
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: However, an additional summary is helpful, such as the **Design Artifacts**
    section, since some people may miss the navigational element on the right.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you complete mock-ups, post them on the wiki.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can see a summary view of the wiki here:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B20960_04_19.png)'
  id: totrans-416
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.19: Summary view of LemonMart mock-ups'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: Now that your artifacts are in a centralized place, it is accessible to all
    team members. They can add, edit, update, or groom the content. This way, your
    wiki becomes useful, living documentation of the information that your team needs,
    as opposed to a piece of documentation you feel like you’re being forced to create.
    Raise your hand if you’ve ever found yourself in that situation!
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: Next, integrate your mock-ups into your app, so you can collect early feedback
    from your stakeholders and test out the flow of your application.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging mock-ups in your app
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Place the mock-ups in the walking skeleton app so that testers can better envision
    the functionality that is yet to be developed. See an example of this idea in
    action here:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B20960_04_20.png)'
  id: totrans-422
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.20: Using mock-ups in the UI to verify the flow of the app'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: This will also be helpful when designing and implementing your authentication
    and authorization workflow. With the mock-ups completed, we need to implement
    a backend in *Chapter 5*, *Designing Authentication and Authorization*, before
    we can continue the implementation of LemonMart’s authentication and authorization
    workflow in *Chapter 6*, *Implementing Role-Based Navigation*.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you mastered effectively using the Angular CLI to create major
    Angular components and scaffolding. You created the branding of your app, leveraging
    custom and built-in Material iconography.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: You learned how to debug complicated router configurations with Angular DevTools.
    Finally, you began building router-first apps, defining user roles early on, designing
    with lazy loading in mind, and nailing down a walking-skeleton navigation experience
    early on. We went over designing around major data entities. We also covered the
    importance of completing and documenting the high-level UX design of our entire
    app so that we can properly design a great conditional navigation experience.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: 'To recap, to pull off a router-first implementation, you need to do this:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: Develop a roadmap and scope.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Design with lazy loading in mind.
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a walking-skeleton navigation experience.
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Achieve a stateless, data-driven design.
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enforce a decoupled component architecture.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Differentiate between user controls and components.
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Maximize code reuse with TypeScript and ES6.
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this chapter, you executed steps 1-3; in the following chapters, you will
    execute steps 4-7\. In *Chapter 5*, *Designing Authentication and Authorization*,
    you will see a concrete full-stack implementation using the minimal MEAN stack.
    In *Chapter 6*, *Implementing Role-Based Navigation,* and *Chapter 7*, *Working
    with REST and GraphQL APIs*, we will tap into OOP design and inheritance and abstraction,
    along with a deep dive into security considerations and designing a conditional
    navigation experience. *Chapter 8*, *Recipes – Reusability, Forms, and Caching*,
    and *Chapter 9*, *Recipes – Master/Detail, Data Tables, and NgRx*, will tie everything
    together by sticking to a decoupled component architecture, smartly choosing between
    creating user controls and components, and maximizing code reuse with various
    TypeScript, RxJS, and Angular coding techniques.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-437
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we haven’t implemented a lazy loading component. As a challenge, following
    the documentation at [https://angular.io/guide/standalone-components](https://angular.io/guide/standalone-components),
    update `app.route.ts` so that `PageNotFoundComponent` is lazy loaded. After you
    complete your update, verify that the CLI output correctly shows the new chunked
    file, and also open up the **Network** tab in DevTools to watch the chunks being
    downloaded as you navigate the app.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-439
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'DevTools overview: [https://angular.io/guide/devtools](https://angular.io/guide/devtools)'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Material Design: [https://m3.material.io](https://m3.material.io)'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Getting Started with Standalone Components*, Google, August 30, 2023: [https://angular.io/guide/standalone-components](https://angular.io/guide/standalone-components)'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Webpack module bundler: [https://webpack.js.org/](https://webpack.js.org/)'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions
  id: totrans-444
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions as best as possible to ensure you’ve understood
    the key concepts from this chapter without googling anything. Do you know if you
    got all the answers right? Visit [https://angularforenterprise.com/self-assessment](https://angularforenterprise.com/self-assessment)
    for more:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between the root module and a feature module?
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the benefits of lazy loading?
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How’s a standalone component different from a module?
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do we create a walking skeleton of our application?
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What’s the benefit of designing around major data entities?
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should we create wikis for our projects?
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
