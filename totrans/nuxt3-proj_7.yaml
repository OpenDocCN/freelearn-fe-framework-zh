- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a Quiz Game Application to Learn about Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will continue our journey and build a quiz game application
    using Nuxt 3, with a deep focus on enhancing our testing skills. This chapter
    is crafted for developers aiming to refine their skills in unit testing and **End-to-End**
    (**E2E**) testing.
  prefs: []
  type: TYPE_NORMAL
- en: Initially, we’ll talk about the importance of testing in software development,
    illustrating how it serves as the backbone of any application. We’ll kick off
    with unit testing, where you’ll learn how to construct unit tests for both the
    Pinia store and Vue components, ensuring each piece of logic and every UI element
    behaves as intended.
  prefs: []
  type: TYPE_NORMAL
- en: Following this, we’ll continue our testing strategy to learn about E2E tests,
    simulating real user interactions to affirm the overall functionality of the quiz
    game. We will also provide visual insights into test results and coverage.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the quiz game app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing unit tests for the Pinia store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing unit tests for components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing end-to-end tests for the quiz game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring Vitest UI and test coverage tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code files for this chapter can be found at [https://github.com/PacktPublishing/Nuxt-3-Projects/tree/main/chapter07](https://github.com/PacktPublishing/Nuxt-3-Projects/tree/main/chapter07).
  prefs: []
  type: TYPE_NORMAL
- en: The CiA video for this chapter can be found on [https://packt.link/tAMjs](https://packt.link/tAMjs)
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we did in the previous chapter, let’s quickly review the `starter` folder
    in our repository. This folder, pre-populated with essential components, a quiz
    store, and TypeScript interfaces, is ready to be copied into your new project.
    It serves as the groundwork, allowing us to concentrate on the critical task of
    this chapter: implementing and learning testing strategies within Nuxt 3.'
  prefs: []
  type: TYPE_NORMAL
- en: Essential background – fundamentals of testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we shift our focus to testing in [*Chapter 7*](B19760_07.xhtml#_idTextAnchor141),
    understanding the foundational aspects of testing becomes crucial. Testing is
    a critical process in software development, aimed at ensuring that your application
    performs correctly under various scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'Traditionally, developers used to test applications manually, which required
    hands-on effort to find bugs. However, the evolution of testing practices has
    significantly reduced reliance on manual testing through the adoption of automated
    testing. Automated testing introduces efficiency and consistency by automating
    repetitive tasks. It encompasses three primary levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit** testing: Focuses on testing individual components or functions in
    isolation, making it easier to pinpoint errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration** testing: Tests the interaction between integrated units or
    components to ensure they work together as intended. While this chapter will not
    focus heavily on integration testing, it remains an important part of the testing
    pyramid.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**E2E testing**: Simulates real-world user behaviors and interactions with
    the application from start to finish, ensuring the entire system functions as
    expected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By implementing automated testing, we can significantly reduce the need for
    manual testing, allowing for more frequent and comprehensive test runs with less
    effort. Next, let’s see how to implement the quiz game app.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the quiz game app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will kick off our quiz game application by setting up a new Nuxt 3 project.
    As with our previous endeavors, we’ll utilize the `starter` folder to fast-track
    our development process. Once you’ve created your new project, copy the contents
    of the starter folder into it. If prompted, agree to replacing the existing files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll need to install a few essential Nuxt modules, such as Pinia, Tailwind
    CSS, and Google Fonts. We already discussed each module in previous chapters.
    Run the following commands in your terminal to add these packages to your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'With the dependencies in place, it’s time to fire up our project and see the
    initial setup in action. Execute the project as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon running the project, you should be greeted with the initial layout of
    the quiz game application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1: Quiz game app](img/B19760_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: Quiz game app'
  prefs: []
  type: TYPE_NORMAL
- en: Before diving into the testing aspect of our quiz game application, let’s take
    a moment to understand the structure and components that form the backbone of
    our project.
  prefs: []
  type: TYPE_NORMAL
- en: Questions data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The questions data is located in `data/questions.ts`. It stores the quiz questions,
    each with multiple answers, enabling the dynamic generation of quizzes each time
    a user engages with the app.
  prefs: []
  type: TYPE_NORMAL
- en: Types definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The structure and types of data used across the application are meticulously
    defined in `types/index.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s ad breakdown of the types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`rightAnswerId`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Answer**: Defines the structure for each answer option for a question, with
    its own ID and the answer body'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Question` type by including the user’s selected answer (`userAnswer`) and
    a flag (`answerIsRight`) indicating whether the chosen answer is correct'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, let’s see the content of the quiz store.
  prefs: []
  type: TYPE_NORMAL
- en: Quiz Pinia store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This store is designed to manage the game’s state using Pinia, from tracking
    the current question to calculating the player’s score. Here’s an overview of
    its key features.
  prefs: []
  type: TYPE_NORMAL
- en: 'This initial segment sets up the quiz store and initializes the state, including
    the current question index, quiz completion status, results array, and score:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, `quiz` is a computed property that selects five random questions from
    the provided questions dataset, ensuring a varied quiz experience each time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note that `selectRandomQuestions` is a utility function stored in the `utils`
    folder. So, it’s automatically imported due to the power of the Nuxt auto-imports
    feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the instance of the current question based on `currentQuestionIndex`,
    we’ll create another computed method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in order to update the progress, there is a function called `updateProgress`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`updateProgress` is a crucial function that evaluates whether the user’s answer
    is correct, updates the score for correct answers, and appends the question along
    with the user’s answer and the correct answer to the results array. It also determines
    whether to move to the next question or conclude the quiz.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, in order to restart the quiz after finishing, we can use the `restartQuiz`
    function, which allows users to reset the quiz to its initial state, clearing
    all progress and scores, and make another attempt with the same set of questions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure to return all refs and functions at the end of the store file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s move on to see an overview of `app.vue`.
  prefs: []
  type: TYPE_NORMAL
- en: The app.vue file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the skeleton of the `app.vue` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This file contains the main layout and flow of our quiz game. We initiate the
    quiz store in the `script` section to be accessible within the component. `template`
    employs a conditional rendering approach with `v-if="quizFinished"`. This condition
    checks whether the quiz has concluded, based on the `quizFinished` flag from our
    `quizStore`.
  prefs: []
  type: TYPE_NORMAL
- en: Upon completion, it displays the user’s score out of five and lists the questions
    alongside the user’s answers, as well as the correct answers, applying different
    background colors to indicate whether the answers were correct or incorrect. There
    is also a restart quiz button that allows users to reset the quiz and try again.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, the app will render `Question.vue`, which will be responsible for
    rendering the question with answers, capturing user responses, and updating the
    quiz’s progress. It’s straightforward. You can check its content from the starter
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Having explored the foundational components of our quiz game project, we’re
    now ready to dive into the basics of unit testing and E2E testing. This knowledge
    equips us with the necessary skills to ensure our application meets the high standards
    of quality and reliability expected in modern web development.
  prefs: []
  type: TYPE_NORMAL
- en: Writing unit tests for the Pinia store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we move forward, the task at hand involves writing unit tests for the Pinia
    store. This step is pivotal in verifying the application’s state management logic
    and introduces us to the principles of unit testing within a Pinia store.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Vitest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Vitest, designed with Vite in mind, offers a next-generation testing framework
    that enhances the testing experience through integration with Vite’s ecosystem,
    leading to faster and more efficient tests. It provides a Jest-compatible API,
    enabling easy migration and parallel test execution for improved performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compared to Jest, Vitest stands out for projects using Vite due to its seamless
    integration, faster setup, and execution, making it a preferred choice for modern
    web development. For more details, visit the official website: [https://vitest.dev](https://vitest.dev).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure Vitest works seamlessly with Nuxt, we integrate `@nuxt/test-utils`
    into our setup. This toolkit is designed to work with various testing frameworks
    and environments, providing flexibility and power to our testing strategy. Let’s
    clarify the key components of our setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@nuxt/test-utils`: Essential for Nuxt applications, offering specialized tools
    and functionalities, as well as integration with existing testing frameworks,
    for a smooth testing experience in the Nuxt environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Vitest`: Our chosen testing framework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`happy-dom`: A lightweight DOM simulation library, `happy-dom` provides a more
    accurate and faster simulation of browser environments within tests. It’s chosen
    for its efficiency in running tests that involve DOM manipulation or browser API
    interactions, replicating how components behave in a real browser without needing
    one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, install these tools with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We then create a `vitest.config.ts` file in the root of our project. This configuration
    file is crucial for specifying our test environment preferences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: By setting the environment to `'happy-dom'`, we instruct Vitest to simulate
    a browser-like environment using `happy-dom` for our tests.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a test file named `temp.spec.ts` in the root folder of our project.
    The `.spec` suffix in the filename is a convention that stands for “specification.”
    It signifies that the file contains a series of specifications (tests) that describe
    how the application or a particular component should behave. This naming convention
    helps Vitest to automatically locate and execute tests, scanning for files that
    end with `.spec.ts` or `.test.ts`, when we run the `vitest` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now populate `temp.spec.ts` with a simple test to get familiar with Vitest’s
    syntax and capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `describe` is used to group our test under a common suite,
    `it` outlines an individual test case, and `expect` formulates an assertion about
    the code’s behavior. Here, we’ve created a simple test case to ensure that the
    `sum` function is working properly. We expected the result of `sum(2, 3)` to be
    equal to `5`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run our newly created test, we first need to make a small adjustment to
    our project’s `package.json` file. By adding a new script entry for `"test"`,
    we configure it to execute `vitest`, which in turn runs our test suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'With this script in place, execute the test suite by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon execution, Vitest springs into action, automatically scanning the project
    for any test files. For our simple test in `temp.spec.ts`, Vitest should recognize
    it as the sole test file, identifying the single `describe` block and the one
    test case it contains. If everything is set up correctly, you’ll see output indicating
    that the test case passed as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2: Vitest output](img/B19760_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.2: Vitest output'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s introduce an additional test case to our `temp.spec.ts` file, one
    that we anticipate will fail, to observe Vitest’s behavior in handling failing
    tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Vitest continuously monitors for any changes in your test files. So, when you
    save your `temp.spec.ts` file with the intentionally failing test, Vitest automatically
    re-runs the tests. This time, you’ll notice in the terminal output that while
    the first test case passes as before, the new test case fails. This immediate
    feedback highlights the failing assertion, offering insights into what went wrong
    and where, directly in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3: Vitest output with wrong tests](img/B19760_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: Vitest output with wrong tests'
  prefs: []
  type: TYPE_NORMAL
- en: Now, with Vitest actively monitoring our project for changes, let’s proceed
    to test the quiz store to ensure its logic performs correctly under various conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the quiz store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our focus now shifts to the quiz store. By unit testing this store, we aim to
    confirm that our game’s logic and state management work as intended, providing
    a solid foundation for a great user experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s clear the stage by removing the `temp.spec.ts` temporary test
    file and creating `quiz.spec.ts` in the `/stores` folder next to our quiz store.
    To effectively unit test a Pinia store, we have to establish a fresh Pinia instance
    for each test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `beforeEach` function is important for maintaining test integrity. It’s
    a function provided by Vitest that runs before each test case in our `describe`
    block. By calling `setActivePinia(createPinia())` within `beforeEach`, we guarantee
    that each test interacts with a fresh instance of Pinia, allowing us to assess
    the functionality of the quiz store in each test independently.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our testing setup ready, it’s time to write our first test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This test verifies that the quiz store correctly initializes with a set of five
    questions, ensuring our game starts with the expected number of challenges for
    the player. After running the test, the terminal should indicate the test case
    passed.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure our quiz store behaves as expected, we need to test each function
    comprehensively. One crucial aspect is verifying that the store correctly handles
    incorrect answers. The idea here is to simulate a scenario where a player chooses
    a wrong answer and to confirm that such an action does not lead to an increase
    in their score.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how we implement this test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: To achieve 100% coverage, we should continue using this testing approach for
    every function within the quiz store, ensuring each aspect of our game’s logic
    is rigorously validated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the approach to not increment the score with a wrong answer, we will
    also test the positive scenario. We implement a similar test case to ensure the
    score increments by 1 when the correct answer is selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s validate the quiz’s flow with a test to ensure it moves to the
    next question after an answer is selected. This test starts by checking the initial
    question index is 0, simulates answering the first question, and then confirms
    the quiz store correctly updates to indicate the next question is ready:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To conclude our testing of the quiz flow, we implement a test to confirm the
    quiz is marked as finished after the last question is answered. This test iterates
    through all questions, simulating correct answers for each, and checks that the
    quiz store flags the quiz as completed. It further verifies that all questions
    have been accounted for in the results, ensuring the game concludes as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: With these main test cases covered, we’ve laid a solid foundation for ensuring
    the quiz store functions correctly. For a complete view of all test cases, please
    refer to the full suite available in the project repository.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s shift our focus to writing unit tests for the `Question` component,
    where we’ll apply similar rigor to ensure the components of our quiz game app
    behave as expected under various scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Writing unit tests for components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When transitioning from testing the store to testing Vue components, our focus
    moves toward verifying that components behave as expected when they receive props,
    interact with the Pinia store, and render correctly. Component testing can include
    checking that components properly display data passed via props, react to user
    input, and integrate seamlessly with the store for state management.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up for component testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To effectively test Vue components, we introduce two crucial tools: `@vue/test-utils`
    and `@pinia/testing`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@vue/test-utils`: This library provides utilities to mount and interact with
    Vue components in a testing environment. The `mount` function is particularly
    important as it allows us to render a component in isolation and returns a wrapper
    object that we can use to examine the rendered output and simulate user interactions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@pinia/testing`: This offers tools for testing Pinia stores within Vue components.
    The `createTestingPinia` function is used to create a mock Pinia instance that
    can be used in tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, let’s install these libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s move on to creating the component test file.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Question.spec.ts test file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inside the `/components` folder, create a file called `Question.spec.ts` and
    add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a breakdown of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: The `wrapper` object returned by `mount` encapsulates the mounted component,
    providing a range of methods and properties to query and interact with it. This
    wrapper allows you to test the component’s rendered output, check its state, and
    simulate user interactions, such as clicks and input changes..
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `createSpy` option, used in conjunction with `createTestingPinia`, allows
    us to pass a spy function (`vi.fn` from Vitest) that can be used to monitor and
    verify interactions with the store. Spies can track calls to store refs and methods,
    providing insights into how the component interacts with the store.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With our testing environment configured, let’s proceed to write our first unit
    test for the component.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the component unit test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let’s have a look at the `Question.vue` component that we’ve already
    copied from the `starter` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `Question` component is a key part of our quiz game application, designed
    to present users with a single question and its multiple-choice answers. Upon
    rendering, it dynamically displays the content of the current question retrieved
    from the Pinia store, including the question text and a set of buttons for each
    answer option. Users can select their answer by clicking one of these buttons,
    triggering the answered function that calls the `updateProgress` function from
    the Pinia store to update the quiz’s progress based on the selected answer ID
    and move on to the next question.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our goal in testing the `Question` component is to ensure it functions as intended:
    displaying the current question and its answers correctly and responding to user
    interactions appropriately.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first test case focuses on verifying that the `Question` component correctly
    displays the current question along with its four corresponding answers. Inside
    the `Question.spec.ts` file, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are key points in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`wrapper.text()`: Checks the text content of the mounted component to ensure
    it includes the current question’s body'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wrapper.`findAll`(''button'')`: Verifies that exactly four buttons (answers)
    are rendered'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wrapper.html()`: Used to inspect the HTML output of the component, ensuring
    each answer’s body is present'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second test case verifies that when a user clicks an answer, the component’s
    `answered` method is correctly called with the appropriate `answerId`. This test
    simulates user interaction and checks the component’s logic for processing answers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Key points in the code are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`wrapper.findAll(''button'')[0].trigger(''click'')`: Simulates a user clicking
    the first answer button. The trigger function is used to dispatch DOM events,
    imitating user actions. If you check the questions data, you’ll notice that the
    ID of the first answer is always 1\. We’ll use the information to check the prop
    that is passed to the `updateProgress` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toHaveBeenCalledWith(1)`: Asserts that the `updateProgress` method within
    the quiz store was called with the correct argument, indicating the user’s selected
    answer ID (in this case, it’s 1). This ensures the component correctly communicates
    user selections to the store.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After running the unit tests for our quiz game components and the quiz store,
    you should see results similar to this in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4: Vitest output after testing component](img/B19760_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.4: Vitest output after testing component'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s transition to writing E2E tests to ensure the game operates seamlessly
    from start to finish, as experienced by the end user.
  prefs: []
  type: TYPE_NORMAL
- en: Writing end-to-end tests for the quiz game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: E2E testing is a technique used to test the entire application from start to
    finish, simulating real-user scenarios and interactions. It ensures that the application
    behaves as expected in a production-like environment, covering UIs, databases,
    APIs, and other services. E2E testing is crucial for verifying the integrated
    operation of all application components and detecting issues that unit or integration
    tests might miss.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up for E2E testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To conduct E2E tests in our project, we have to install `playwright-core`,
    a powerful tool for automating browser interactions, enabling tests that simulate
    real user actions. It also supports testing across multiple browsers. Run this
    command to install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `@nuxt/test-utils` package includes utilities such as `setup` and `createPage`
    to facilitate E2E testing with Playwright or other test runners. Before beginning
    your E2E tests, initializing the test context with `setup` is necessary. This
    function prepares the Nuxt environment for testing by configuring the necessary
    `beforeAll`, `beforeEach`, `afterEach`, and `afterAll` hooks, ensuring your tests
    run within a correctly set up Nuxt context. `createPage`, on the other hand, allows
    you to create a configured Playwright browser instance and optionally navigate
    to a specific path on your running server. We’ll use it to create an instance
    from the quiz page to be able to simulate the user actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin by creating our E2E test file, `app.spec.ts`, at the root of our
    project, then add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: With the initial setup complete, we’re now ready to write specific test cases
    that will walk through the quiz game.
  prefs: []
  type: TYPE_NORMAL
- en: Writing E2E tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our E2E testing sequence, we begin by verifying the initial state of the
    quiz game to ensure it loads correctly for the user. This includes checking for
    the presence of a question headline and four corresponding answer buttons, which
    are fundamental to the quiz’s functionality. Here is the test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a breakdown of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`createPage(''/'')`: This function initializes a new browser page instance
    and navigates to the root of our application, where the quiz is presumed to start.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`page.locator(''h1'').count()`: This uses Playwright’s locator API to find
    all `<h1>` elements on the page, then counts them. We expect exactly one `<h1>`
    element, typically containing the quiz question.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`page.locator(''button'').count()`: Similarly, this line finds and counts all
    `<button>` elements, which should correspond to the quiz answer options. The expectation
    is to have exactly four buttons, each representing a potential answer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now let’s move on to the next test case. In this test case, we aim to simulate
    a user accurately answering all quiz questions to verify that the application
    correctly transitions to the result page and displays the final score. This process
    involves the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigating to the quiz
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Iterating through questions: For each question displayed, the test locates
    the correct answer based on our predefined questions data, then simulates a click
    on the corresponding answer button.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Verifying the result page : After all questions have been answered correctly,
    the quiz should transition to a result page. This page displays a message indicating
    the quiz is finished and shows the user’s score.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Checking the score: The final part verifies that the score displayed matches
    the expected outcome of answering all questions correctly.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Some syntax highlights are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`page.locator(button:has-text("${answerText}")).click()`: Locates the button
    with the text matching the correct answer and simulates a click event'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expect(finishedText).toBe(''Finished'')`: Checks whether the text Finished
    is displayed, indicating the quiz completion'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expect(score).toContain(''5 / 5'')`: Validates that the final score, displayed
    within an `<h2>` element, correctly indicates all questions were answered correctly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In this test case, we’ve opted for a more general search approach by using element
    tags (`h1` and `h2`) directly due to our knowledge of the page structure—there’s
    only one `h1` element displaying the quiz question and a single `h2` element showing
    the result. However, for more complex UIs or when multiple elements of the same
    type exist on a page, it’s advisable to perform more specific searches, such as
    targeting elements with unique identifiers such as classes or IDs. This will enhance
    the test’s precision, ensuring we’re interacting with the correct elements even
    in densely structured pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we initiate the E2E test, be prepared for it to take a bit longer to complete
    compared to unit tests. This delay is because the test involves simulating a real
    browser environment, requiring the page to fully load before any interactions
    (such as clicking on answer buttons) can occur. Your output in the terminal should
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5: E2E test output](img/B19760_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.5: E2E test output'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If this is the first time you’re using the Playwright library on your machine,
    you might encounter an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, just run the command shown in the terminal, then retry the test.
    Some developers have reported the need to run the following as well, in order
    to make Playwright work properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: With our E2E tests now complete, let’s shift our focus to exploring Vitest’s
    interactive UI and understanding test coverage. This will help us visualize our
    testing efforts and ensure complete coverage across our application.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Vitest UI and test coverage tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our journey toward mastering testing with Vitest, two powerful tools stand
    out for their ability to enhance our development workflow: Vitest UI and test
    coverage tools. Vitest UI offers an interactive interface for running tests and
    visualizing results in real time, making it easier to manage and debug tests.
    Meanwhile, the test coverage tool provides insights into which parts of our code
    are thoroughly tested and which areas might need more attention.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To incorporate these tools into our project, we first need to install them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'With the packages installed, we’ll adjust our testing script to enable both
    the UI and coverage reporting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'After making this adjustment, stop any currently running test processes and
    restart them to activate the changes. Upon reinitiating the tests, you’ll observe
    that Vitest launches a UI project, indicated by a message in the terminal similar
    to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6: Vitest UI dashboard URL](img/B19760_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.6: Vitest UI dashboard URL'
  prefs: []
  type: TYPE_NORMAL
- en: By navigating to this URL in your web browser, you’re greeted by the Vitest
    UI dashboard. Let’s explore the UI and coverage reports to gain deeper insights
    into our testing landscape and identify opportunities for improvement.
  prefs: []
  type: TYPE_NORMAL
- en: The **Dashboard** interface summarizes key metrics, including the total number
    of tests run, the breakdown of passed and failed tests, the total number of test
    files involved, and the execution time for all tests. This overview provides a
    clear snapshot of the project’s testing health.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7: Vitest UI Dashboard](img/B19760_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.7: Vitest UI Dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: As you explore the sidebar, you’ll find a list of your project’s test files.
    Clicking on one, for example, `app.spec.ts`, opens a detailed view of that specific
    test file. In this detailed view, you’ll see each test case listed along with
    its execution status—passed, failed, or skipped. Also, you’ll be able to re-run
    the test cases in this file. This allows for easy identification of which tests
    have succeeded and which may require further attention or debugging.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8: Vitest test file](img/B19760_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.8: Vitest test file'
  prefs: []
  type: TYPE_NORMAL
- en: To gain insights into our code’s test coverage, a simple click on the coverage
    icon (located in the top-left corner, next to the play button) reveals a new dimension
    of our project’s health. The coverage overview presents a summary at the top of
    tested files, tested statements, branches, functions, and lines. Below the summary,
    a table lists each file alongside its coverage percentage
  prefs: []
  type: TYPE_NORMAL
- en: Let’s search for the `stores` folder and click on it. It reveals that 88.46%
    of the code and 50% of functions have been tested.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9: Vitest coverage UI](img/B19760_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.9: Vitest coverage UI'
  prefs: []
  type: TYPE_NORMAL
- en: A closer look at an individual file within this folder highlights untested code
    segments, such as the `restartQuiz` function—confirming areas where our test coverage
    could be improved.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10: Vitest file coverage](img/B19760_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.10: Vitest file coverage'
  prefs: []
  type: TYPE_NORMAL
- en: This level of detail pinpoints exactly where we need to enhance our tests. Such
    an approach to identifying untested code is invaluable, guiding us to achieve
    more comprehensive test coverage and, by extension, a more reliable application.
  prefs: []
  type: TYPE_NORMAL
- en: Our exploration of Vitest UI and test coverage concludes here, setting the stage
    for a summary of our journey through strong testing practices in enhancing the
    quiz game application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B19760_07.xhtml#_idTextAnchor141) steered us through the crucial
    role of testing in the development of a quiz game application with Nuxt 3\. We
    began by laying the groundwork with unit testing, utilizing Vitest to test the
    logic of our Pinia store and components, ensuring their reliability. By simulating
    user interactions and asserting expected outcomes, we verified the functionality
    of critical parts of our application.'
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning to E2E testing, we employed Playwright to mimic real-user scenarios,
    from navigating through quiz questions to completing the game. This phase reinforced
    our application’s user experience and functionality, highlighting the significance
    of testing in identifying and rectifying potential issues before they affect users.
  prefs: []
  type: TYPE_NORMAL
- en: The journey concluded with an exploration of Vitest UI and coverage tools, which
    illuminated untested code segments and provided a visual and interactive approach
    to managing our test suite. This not only enhanced our testing efficiency but
    also deepened our understanding of test coverage’s impact on application quality.
  prefs: []
  type: TYPE_NORMAL
- en: Looking ahead, [*Chapter 8*](B19760_08.xhtml#_idTextAnchor165) levels up our
    skills by creating a custom translation module in Nuxt 3\. This next chapter will
    guide us through the intricacies of i18n (Internationalization), from building
    a custom module to injecting it with the necessary components and functionalities
    to facilitate seamless language switching and localization.
  prefs: []
  type: TYPE_NORMAL
- en: Practice questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the purpose of unit testing in a Vue.js application?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describe the process of setting up Vitest in a Nuxt 3 project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explain how to use the `describe` and `it` blocks to structure your tests in
    Vitest.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What role does `expect` play in a test case?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can you mock a user interaction, such as clicking a button, in a unit test?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you test a Vue component that interacts with a Pinia store?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can you simulate browser interactions in an E2E test?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the purpose of the `createPage` function in Nuxt’s test utils?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can Vitest’s UI and coverage tools help improve the quality of your tests?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Vitest official website: [https://vitest.dev/](https://vitest.dev/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Why Vitest: [https://vitest.dev/guide/why.html#why-vitest](https://vitest.dev/guide/why.html#why-vitest)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Vue testing: [https://vuejs.org/guide/scaling-up/testing](https://vuejs.org/guide/scaling-up/testing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pinia testing: [https://pinia.vuejs.org/cookbook/testing.html](https://pinia.vuejs.org/cookbook/testing.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Nuxt testing: [https://nuxt.com/docs/getting-started/testing](https://nuxt.com/docs/getting-started/testing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Vitest UI: [https://vitest.dev/guide/ui](https://vitest.dev/guide/ui)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Vitest coverage: [https://vitest.dev/guide/coverage](https://vitest.dev/guide/coverage)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
