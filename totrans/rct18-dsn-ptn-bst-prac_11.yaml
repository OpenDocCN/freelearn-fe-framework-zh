- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore two beneficial tools: the **React Context
    API** and **React Suspense**. The Context API simplifies the process of sharing
    data across our entire application without the need to pass it down through multiple
    layers. On the other hand, React Suspense enables specific parts of our app to
    wait for certain actions before being displayed, resulting in a smoother loading
    experience.'
  prefs: []
  type: TYPE_NORMAL
- en: By utilizing these tools collectively, we can enhance data management and improve
    the overall performance of our app. Join us on this journey as we delve into the
    efficient handling of data in React.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The React Context API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to consume a context with `useContext`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use React Suspense with SWR (Stale-While-Revalidate)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use Redux Toolkit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js 19+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find the code for this chapter in the book’s GitHub repository: [https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter11](https://github.com/PacktPublishing/React-18-Design-Patterns-and-Best-Practices-Fourth-Edition/tree/main/Chapter11).'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the React Context API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **React Context API** has come a long way since it was first introduced
    as an experimental feature. Since version 16.3.0, it has been officially added
    to React and has become a game-changer for many developers. In fact, many are
    now using the new Context API instead of Redux. The Context API allows you to
    share data between components without having to pass a prop to every child component.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate how to use the new Context API, let’s revisit the example from
    *Chapter 8*, *React Hooks*, where we fetched GitHub issues using React Hooks,
    but this time by using the Context API instead.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our first context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing you need to do is to create the issue context. For this, you
    can create a folder called `contexts` inside your **src** folder, where you will
    add the `Issue.tsx` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you need to import some functions from React and `axios`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, it is clear that you should install `axios`. If you still don’t
    have it, just do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to declare our interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we need to do after this is to create our context by using
    the `createContext` function and defining the value we want to export:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have `IssueContext`, we need to create a component where we can receive
    props, set some states, and perform the fetch by using `useEffect`, and then we
    render `IssueContext.Provider` where we specify the context (value) we will export:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you know, every time you want to use a function inside the `useEffect` Hook,
    you need to wrap your function with the `useCallback` Hook. A good practice if
    you want to use async/await is to have it in a separate function and not directly
    in `useEffect`.
  prefs: []
  type: TYPE_NORMAL
- en: Once we perform the fetch and get the data in our `issues` state, we will add
    all the values we want to export as context, then when we render `IssueContext.Provider`,
    we will pass the context on the `value` prop, and finally, we will render the
    children of the component.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping our components with the provider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The way you consume a context is divided into two parts. The first one is where
    you wrap your app with your context provider, so this code can be added to `App.tsx`
    (normally, all the providers are defined in parent components).
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice here that we are importing the `IssueProvider` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are wrapping the `Issues` component with `IssueProvider`.
    This means that inside the `Issues` component, we can consume our context and
    get the issues value.
  prefs: []
  type: TYPE_NORMAL
- en: Many people find this concept confusing. If you forget to wrap your components
    with the provider, you won’t be able to access your context within them. The challenging
    aspect is that you might not receive an error message; instead, you will encounter
    undefined data, making it difficult to pinpoint the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we comprehend the significance of correctly wrapping our components
    with providers, let’s explore how we can precisely consume our context using the
    `useContext` Hook within our `Issues` component.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming context with useContext
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’ve already placed `IssueProvider` in `App.tsx`, now you can consume your
    context in your `Issues` component by using the `useContext` Hook.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice here that we are importing the `IssueContext` context (between `{ }`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you did everything correctly, you should be able to see the issues list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18414_11_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.1: ContentPI Issues from Context'
  prefs: []
  type: TYPE_NORMAL
- en: The **Context API** is super useful when you want to separate your application
    from your data and do all the fetching in there. Of course, there are multiple
    uses for the **Context API**, which can also be used for theming or to pass functions;
    it all depends on your application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to learn how to implement **React Suspense**
    using the SWR library.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing React Suspense with SWR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React Suspense was introduced in React 16.6\. Suspense lets you suspend component
    rendering until a condition is met. You can render a loading component or anything
    you want as a fallback of Suspense.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right now, there are only two use cases for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Code splitting**: When you split your application and you’re waiting to download
    a chunk of your app when a user wants to access it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data fetching**: When you’re fetching data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In both scenarios, you can render a fallback, which can normally be a loading
    spinner, some loading text, or even better, a placeholder skeleton.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing SWR
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Stale-While-Revalidate** (**SWR**) is a React Hook for data fetching; it
    is an HTTP cache invalidation strategy. SWR is a strategy to first return the
    data from cache (stale), then send the fetch request (revalidate), and finally,
    return with up-to-date data, and was developed by **Vercel**, the company that
    created **Next.js**.'
  prefs: []
  type: TYPE_NORMAL
- en: Building a Pokedex!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I could not find a better example to explain React Suspense and SWR than building
    a **Pokedex**. We will use a public Pokemon API ([https://pokeapi.co](https://pokeapi.co)):
    *gotta catch ‘em all*!'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you need to do is to install some packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: For this example, you will need to create the Pokemon directory at `src/components/Pokemon`.
    The first thing we need to do to work with SWR is to create a fetcher file where
    we will perform our requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'This file should be created at `src/components/Pokemon/fetcher.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you notice, we are returning an object with an `error` if the response is
    not successful. This is because sometimes we can get a 404 error from the API
    that can cause the app to break.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have created your fetcher, let’s modify `App.tsx` to configure `SWRConfig`
    and enable Suspense:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we need to wrap our `PokeContainer` component inside `SWRConfig`
    to be able to fetch the data. The `PokeContainer` component will be our parent
    component, where we will add our first `Suspense`. This file exists at `src/components/Pokemon/PokeContainer.tsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are defining a fallback for our first `Suspense`, which is
    just `Loading Pokedex...` text. You can render whatever you want in there, React
    components or plain text. Then, we have our Pokedex component inside Suspense.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s take a look at our Pokedex component where we are going to fetch
    data for the first time by using the `useSWR` Hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are fetching the first 150 Pokemon because I’m old school
    and those were the first generation. Right now, I don’t know how many Pokemon
    exist. Also, if you notice, we are grabbing the `results` variable that comes
    from the data (this is the actual response from the API). Then we map our results
    to render each Pokemon, but we add a Suspense component to each one with a `<LoadingSkeleton
    />` fallback (`<StyledGrid />` has some CSS styles to make it look nicer), and
    finally, we pass `pokemonName` to our `<Pokemon>` component, and this is because
    the first fetch just brings us the name of the Pokemon, but we need to do another
    fetch to bring the actual Pokemon data (name, types, power, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, finally, our Pokemon component will perform a specific fetch by the Pokemon
    name and will render the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Basically, in this component, we put together all the Pokemon data (ID, name,
    sprites, and types) and we render the information. As you have seen, I’m using
    styled components, which are amazing, so if you want to know the styles that I’m
    using for Pokedex, here is the `Pokemon.styled.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, our `LoadingSkeleton` component should be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This library is amazing. It lets you create skeleton placeholders to wait for
    the data. Of course, you can build as many forms as you want. You have probably
    seen this effect on sites such as LinkedIn or YouTube.
  prefs: []
  type: TYPE_NORMAL
- en: Testing React Suspense
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once you have all the pieces of the code working, there is a trick you can
    do in order to see all the Suspense fallbacks. Normally, if you have a high-speed
    connection, it is hard to see it, but you can slow down your connection to see
    how everything is being rendered. You can do this by selecting **Slow 3G** in
    your **Network** tab on your Chrome inspector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18414_11_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.2: Slow 3G connection'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you set the **Slow 3G** preset and you run your project, the first fallback
    you will see is **Loading Pokedex...**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18414_11_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.3: Loading Pokedex'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you will see the Pokemon fallbacks that are rendering `SkeletonLoading`
    for each Pokemon that is being loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18414_11_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.4: SkeletonLoading'
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally those loaders have animation, but you won’t see that in this book,
    of course! And then you will start seeing how the data is rendering and some images
    start appearing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18414_11_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.5: Loading Pokedex'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wait until all the data has downloaded correctly, you should now see
    the Pokedex with all the Pokemon:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18414_11_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.6: Displaying the entire Pokedex'
  prefs: []
  type: TYPE_NORMAL
- en: Pretty nice, huh? But there is something else to mention; as I mentioned before,
    SWR will bring the data from the cache first and then will revalidate the data
    all the time to see whether there are new updates. This means that any time the
    data changes, SWR will perform another fetch to revalidate whether the old data
    is still valid or needs to be replaced by a new one.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see this effect even if you move out from the Pokedex tab to another
    and then come back. You’ll see that your **Network** terminal, for the first time,
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18414_11_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.7: Requests'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we performed 151 initial requests (1 for the Pokemon lists
    and 150 others, 1 for each Pokemon), but if you change the tab and come back,
    you will see how SWR is fetching again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18414_11_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.8: 151 requests'
  prefs: []
  type: TYPE_NORMAL
- en: Now you can see that it is performing 302 requests (another 151). This is very
    useful when you have real-time data that you want to fetch every second or every
    minute.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, React Suspense lacks a defined pattern of use, which implies that
    there are various ways to utilize it, and there are no established best practices
    for it yet. I have found that SWR is the easiest and most understandable approach
    to working with React Suspense. I believe it is a powerful library that can be
    utilized effectively even without the need for Suspense.
  prefs: []
  type: TYPE_NORMAL
- en: 'After exploring the flexibility of React Suspense, let’s redirect our attention
    to another formidable tool within the React ecosystem: Redux Toolkit. This tool
    is revolutionizing the approach to Redux, and in the subsequent section, we will
    delve into its essential features and demonstrate its application through practical
    code examples.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Redux Toolkit: a modern approach to Redux'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Redux Toolkit** is the official, opinionated, and batteries-included toolset
    for efficient Redux development. It was created to help developers write better
    and more efficient Redux code with less boilerplate. In this section, we’ll explore
    the key features of Redux Toolkit, along with code examples to demonstrate how
    to use it in your application.'
  prefs: []
  type: TYPE_NORMAL
- en: Key features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Redux Toolkit comes with several key features that simplify the Redux development
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: '**configureStore**: A function that sets up a Redux store with sensible defaults.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**createSlice**: A function that automatically generates action creators and
    reducers based on a provided configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**createAction**: A utility function to create action creators with a specific
    type and payload.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**createReducer**: A utility function that simplifies reducer creation using
    **Immer**, enabling direct state manipulation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, install Redux Toolkit and its peer dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Creating a store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a store, we’ll use the `configureStore` function provided by Redux
    Toolkit (`store.ts`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Creating a slice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A slice represents a portion of the Redux store that corresponds to a specific
    feature or domain. To create a slice, use the `createSlice` function (`createSlice.ts`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Combining reducers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you have multiple slices, you can use the `combineReducers` function from
    Redux Toolkit to create a root reducer (`rootReducer.ts`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Connecting components to the store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To connect a React component to the Redux store, use the `useSelector` and
    `useDispatch` Hooks from the `react-redux` package (`Counter.ts`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Integrating the store with a React application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, wrap your React application with the `Provider` component from `react-redux`
    and pass your store as a prop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we’ve explored Redux Toolkit’s key features, including `configureStore`,
    `createSlice`, `createAction`, and `createReducer`. By utilizing these features,
    developers can write more efficient and maintainable Redux code with less boilerplate.
    The provided code examples demonstrate how to create a simple counter application
    using Redux Toolkit, illustrating the steps required to set up the store, create
    slices and reducers, and connect components to the store. By leveraging Redux
    Toolkit, you can simplify your Redux development process and build more robust
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I really hope you enjoyed reading this chapter, which contains a lot of information
    about the React Context API and how to implement React Suspense with SWR. We covered
    the basics of the Context API, including how to create and consume contexts, as
    well as how to use the `useContext` Hook for simpler consumption.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we explored React Suspense and how it can improve the user experience
    by allowing us to handle loading states more effectively. We also learned about
    SWR and how it can simplify data fetching and caching with React Suspense. Finally,
    we learned how to implement the new Redux Toolkit. By utilizing these powerful
    tools, you can build more efficient and user-friendly React applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to use **Server-Side Rendering** in React
    with **Next.js**.
  prefs: []
  type: TYPE_NORMAL
