- en: Chapter 4. Events
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章。事件
- en: In the previous chapters, we looked at how to find elements in the DOM and how
    to manipulate them after they are found. In this chapter, we actually start looking
    at how to build applications with jQuery and the important role that events play.
    Web applications use an event-driven programming model, so it is very important
    to understand events well. Without them, web apps—as we now know them—would not
    be possible. But before we go any further, let's look at what an event is.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们了解了如何在 DOM 中查找元素以及在找到它们后如何操作它们。在本章中，我们实际开始了解如何使用 jQuery 构建应用程序以及事件所起的重要作用。Web
    应用程序使用事件驱动的编程模型，因此深入了解事件非常重要。没有事件，我们现在所知的 Web 应用程序将不可能存在。但在我们进一步深入之前，让我们先了解一下什么是事件。
- en: An **event** is the occurrence of anything the system considers significant.
    It can originate in the browser, the form, the keyboard, or any other subsystem,
    and it can also be generated by the application via a trigger. An event can be
    as simple as a key press or as complex as the completion of an Ajax request.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件**是系统认为重要的任何事物的发生。它可以起源于浏览器、表单、键盘或任何其他子系统，也可以由应用程序通过触发生成。事件可以简单到按键，也可以复杂到完成
    Ajax 请求。'
- en: 'While there are a myriad of potential events, events only matter when the application
    listens for them. This is also known as hooking an event. By hooking an event,
    you tell the browser that this occurrence is important to you and to let you know
    when it happens. When the event occurs, the browser calls your event handling
    code passing the event object to it. The event object holds important event data,
    including which page element triggered it. We will look at the event object in
    greater detail later in the chapter. Here is a list of the things we will cover
    in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然存在大量潜在的事件，但只有在应用程序监听它们时事件才重要。这也被称为挂钩事件。通过挂钩事件，您告诉浏览器此发生对您很重要，并让它在发生时通知您。当事件发生时，浏览器调用您的事件处理代码并将事件对象传递给它。事件对象保存重要的事件数据，包括触发它的页面元素。我们将在本章后面更详细地查看事件对象。以下是本章将涵盖的内容列表：
- en: The ready event
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就绪事件
- en: Hooking and unhooking events
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挂钩和取消事件
- en: Namespacing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间
- en: The event handler and object
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件处理程序和对象
- en: Passing data to an event
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向事件传递数据
- en: Event shorthand methods
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件快捷方式方法
- en: Custom events
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义事件
- en: Triggering events
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发事件
- en: The ready event
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 就绪事件
- en: The first thing event programmers new to jQuery usually learn is the ready event,
    sometimes referred to as the **document ready event**. This event signifies that
    the DOM is fully loaded and that jQuery is open for business. The ready event
    is similar to the document load event except that it doesn't wait for all of the
    page's images and other assets to load. It only waits for the DOM to be ready.
    Also, if the ready event fires before it is hooked, the handler code will be called
    at least once, unlike most events. The `.ready()` event can only be attached to
    the document element. When you think about it, this makes sense since it fires
    when the DOM, is fully loaded.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 刚接触 jQuery 的事件编程者通常会学习的第一件事是 ready 事件，有时也被称为**文档就绪事件**。该事件表示 DOM 已完全加载，并且 jQuery
    可以正常运行。就绪事件类似于文档加载事件，但不会等待页面的所有图像和其他资源加载完毕。它只等待 DOM 就绪。此外，如果就绪事件在挂钩之前触发，处理程序代码将至少被调用一次，与大多数事件不同。`.ready()`事件只能附加到文档元素上。仔细想想，这是有道理的，因为它在
    DOM 完全加载时触发。
- en: 'The `.ready()` event has a few different hooking styles. All of the styles
    do the same thing: they hook the event. Which hook you use is up to you. In its
    most basic form, the hooking code looks like the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`.ready()`事件有几种不同的挂钩样式。所有样式都做同样的事情：它们挂钩事件。使用哪种挂钩取决于你。在其最基本的形式中，挂钩代码看起来像下面这样：'
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Since it can only be attached to the document element, the selector can be
    omitted. In such a case, the event hook looks like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它只能附加到文档元素，因此选择器可以省略。在这种情况下，事件挂钩如下所示：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The jQuery documentation does not recommend using the preceding form, however.
    There is a terser version of this event''s hook. This version omits nearly everything
    and only passes an event handler to the jQuery function. It looks like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，jQuery 文档不推荐使用上述形式。此事件的挂钩有一个更简洁的版本。此版本几乎什么都省略了，只将事件处理程序传递给 jQuery 函数。它看起来像这样：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: While all of the different styles work, I only recommend the first form since
    it is the most clear. While the other forms work and save a few bytes worth of
    characters, they do that at the expense of code clarity. If you are worried about
    the number of bytes an expression uses, you should use a JavaScript minimizer
    instead; it will do a much more thorough job of shrinking the code than you can
    ever do by hand.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然所有不同的样式都能起作用，但我只推荐第一种形式，因为它最清晰。虽然其他形式也能起作用并节省一些字节的字符，但这是以代码清晰度为代价的。如果你担心表达式使用的字节数，你应该使用
    JavaScript 缩小器；它会比你手工做的工作更彻底地缩小代码。
- en: 'The ready event can be hooked as many times as you''d like. When the event
    is triggered, the handlers are called in the order in which they were hooked.
    Let''s take a look at an example via code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 准备事件可以挂接多次。当事件被触发时，处理程序按照挂接的顺序调用。让我们通过代码示例来看一下：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, we hook the ready event three times, using a different
    hooking style each time. The handlers are called in the same order in which they
    are hooked. In the first event handler, we hook the event again. Since the event
    has been triggered already, we might expect that the handler will never be called,
    but we would be wrong. jQuery treats the ready event differently than other events.
    Its handler is always called, even if the event has already been triggered. This
    makes the ready event a great place for initialization and other code that must
    be run.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们三次挂接准备事件，每次使用不同的挂接样式。处理程序按照它们被挂接的顺序调用。在第一个事件处理程序中，我们再次挂接事件。由于事件已经被触发，我们可能期望处理程序永远不会被调用，但我们会错。jQuery
    对待准备事件与其他事件不同。它的处理程序总是会被调用，即使事件已经被触发。这使得准备事件成为初始化和其他必须运行的代码的理想场所。
- en: Hooking events
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挂接事件
- en: 'The ready event is different than all of the other events. Its handler will
    be called once, unlike the other events. It is also hooked differently than the
    other events. All of the other events are hooked by chaining the `.on()` method
    to the set of elements with which you wish to trigger the event. The first parameter
    passed to the hook is the name of the event, followed by the handling function,
    which can either be an anonymous function or the name of a function. This is the
    basic pattern for event hooking. It looks like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 准备事件与所有其他事件不同。它的处理程序将被调用一次，不像其他事件。它也与其他事件挂接方式不同。所有其他事件都是通过将`.on()`方法链接到您希望触发事件的元素集来挂接的。传递给挂接的第一个参数是事件的名称，后跟处理函数，它可以是匿名函数或函数的名称。这是事件挂接的基本模式。它看起来像这样：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `.on()` method and its companion, the `.off()` method, were first added
    in version 1.7 of jQuery. For older versions of jQuery, the method used to hook
    the event is `.bind()`. Neither the `.bind()` method nor its companion, the `.unbind()`
    method, are deprecated, but `.on()` and `.off()` are preferred over them. If you
    are switching from `.bind()`, the call to `.on()` is identical at its simplest
    levels. The `.on()` method has capabilities beyond that of the `.bind()` method,
    which requires different sets of parameter to be passed to it. We will explore
    these capabilities later in this chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`.on()`方法及其伴侣`.off()`方法首次在 jQuery 的 1.7 版本中添加。对于旧版本的 jQuery，用于挂接事件的方法是`.bind()`。`.bind()`方法及其伴侣`.unbind()`方法都没有被弃用，但是`.on()`和`.off()`比它们更受青睐。如果您从`.bind()`切换，那么`.on()`的调用在最简单的层面上是相同的。`.on()`方法具有超出`.bind()`方法的能力，需要传递不同的参数集。我们将在本章后面探讨这些功能。'
- en: 'If you would like more than one event to share the same handler, simply place
    the name of the next event after the previous with a space separating them:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望多个事件共享相同的处理程序，只需在前一个事件之后用空格分隔它们的名称：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Unhooking events
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消事件挂接
- en: 'The main method used to unhook an event handler is `.off()`, and calling it
    is simple. It looks like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 主要用于取消事件处理程序的方法是`.off()`，调用它很简单。它看起来像这样：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The handling function is optional, and the event name is optional as well.
    If the event name is omitted, then all events attached to the elements are removed.
    If the event name is included, then all handlers for the specified event are removed.
    This can create problems. Think about this scenario: you write a click event handler
    for a button. A bit later in the app''s life cycle, someone else needs to know
    when the button is clicked on. Not wanting to interfere with already working code,
    they add a second handler. When their code is complete, they remove the handler,
    as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 处理函数是可选的，事件名称也是可选的。如果省略了事件名称，那么所有添加到元素的事件都被移除。如果包括了事件名称，那么所有指定事件的处理程序都被移除。这可能会造成问题。想象一下这种情况：你为一个按钮编写了一个点击事件处理程序。在应用程序的后期，其他人需要知道按钮何时被点击。他们不想干扰已经工作的代码，所以他们添加了一个第二个处理程序。当他们的代码完成后，他们移除了处理程序，如下所示：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Since the handler was called using only the event name, it removed not only
    the handler it added, but also all of the handlers for the click event. This is
    not what was wanted. Don''t despair, however; there are two fixes for this problem:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于处理程序只使用事件名称被调用，它不仅移除了添加的处理程序，还移除了所有关于点击事件的处理程序。这不是想要的结果。然而，不要绝望；对于这个问题有两种解决方法：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first fix is to pass the event handler to the `.off()` method. In the preceding
    code, we placed two click event handlers on the button named `clickB`. The first
    event handler is installed using a function declaration, and the second is installed
    using an anonymous function. When the button is clicked on, both of the event
    handlers are called. The second one turns off the first by calling the `.off()`
    method and passing its event handler as a parameter. By passing the event handler,
    the `.off()` method is able to match the signature of the handler you'd like to
    turn off. If you are not using anonymous functions, this fix works well. But what
    if you want to pass an anonymous function as the event handler? Is there a way
    to turn off one handler without turning off the other? Yes, there is; the second
    fix is to use event namespacing.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个解决方法是将事件处理程序传递给`.off()`方法。在前面的代码中，我们在名为`clickB`的按钮上放置了两个点击事件处理程序。第一个事件处理程序是使用函数声明安装的，第二个是使用匿名函数安装的。当按钮被点击时，两个事件处理程序都会被调用。第二个通过调用`.off()`方法并将其事件处理程序作为参数传递来关闭第一个处理程序。通过传递事件处理程序，`.off()`方法能够匹配你想要关闭的处理程序的签名。如果你不使用匿名函数，这种修复方法很有效。但是如果你想要将匿名函数作为事件处理程序传递怎么办？有没有办法关闭一个处理程序而不关闭另一个处理程序呢？是的，有；第二种解决方法是使用事件命名空间。
- en: Namespacing events
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件命名空间
- en: 'At times, it is necessary to be able to distinguish between different handlers
    for the same event without using the handler function. When this need arises,
    jQuery provides the ability to namespace events. To namespace an event, you add
    a period and the namespace to the name of the event. For example, to give the
    click event the namespace of `alpha`, perform this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有时需要能够在不使用处理程序函数的情况下区分相同事件的不同处理程序。当出现这种需求时，jQuery提供了对事件进行命名空间的能力。要给事件设置命名空间，你需要在事件名称后加上一个句点和命名空间。例如，要给点击事件设置`alpha`的命名空间，执行以下操作：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'jQuery only allows you to create namespaces that are one level deep. If you
    add a second namespace, you don''t create a second level; instead, you create
    a second namespace for the same event. Take a look at the following code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery只允许你创建一级深的命名空间。如果添加第二级命名空间，你不会创建第二级，而是为同一事件创建第二个命名空间。看一下下面的代码：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding code is equivalent to creating two separate namespaces, such
    as the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码等同于创建两个独立的命名空间，如下所示：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Using namespaces makes it possible for us to be more granular with our events,
    in the way we trigger them off and how we trigger them manually. We will explore
    how to trigger events programmatically later in this chapter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命名空间使我们能够更细粒度地处理我们的事件，以及如何在程序中触发它们。我们将在本章后面探讨如何以编程方式触发事件。
- en: The event handler
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件处理程序
- en: 'So far, we''ve just sort of glossed over the event handler. We''ve used it
    but not really explained it. It is time for us to correct that and look thoroughly
    at the event handler. Let''s begin with what jQuery passes to the event handler.
    jQuery passes two things to every event handler: the `event` object and the `this`
    object. The `this` object is passed implicitly, which means that it is not a parameter
    like the `event` object. It is set by jQuery to point to the element to which
    the event handler is bound. The `this` object in JavaScript is somewhat like `this`
    in Java and C# or `self` in Objective-C; it points to the active object. This
    can be very handy, especially when a set of elements shares the same handler.
    The use of the `this` object makes it easy to act upon the correct element among
    many others:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是大致了解了事件处理程序。我们使用了它，但并没有真正解释它。是时候纠正这一点，彻底了解事件处理程序了。让我们从 jQuery 传递给事件处理程序的内容开始。jQuery
    将两个东西传递给每个事件处理程序：`event` 对象和 `this` 对象。`this` 对象是隐式传递的，这意味着它不像 `event` 对象那样是一个参数。它由
    jQuery 设置为指向绑定事件处理程序的元素。JavaScript 中的 `this` 对象有点像 Java 和 C# 中的 `this` 或 Objective-C
    中的 `self`；它指向活动对象。这非常方便，特别是当一组元素共享相同的处理程序时。`this` 对象的使用使得在许多其他元素中轻松地对正确的元素进行操作：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code, we place a click event on each of the `<li>` tags. We
    use the `this` object, which is implicitly passed to us, to tell which one of
    the `<li>` tags triggered the event. Also, note that we didn't use the event parameter
    since it was not needed for our example.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在每个 `<li>` 标签上放置了一个点击事件。我们使用隐式传递给我们的 `this` 对象来告诉我们哪个 `<li>` 标签触发了事件。还要注意，我们没有使用事件参数，因为它对我们的示例不需要。
- en: The event object
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件对象
- en: The event object, which is based on W3C specifications and is explicitly passed
    as a parameter to all event handlers, holds quite a few important properties,
    many of which may be useful to the event handler function. Because each event
    is different, so to be the values in the properties passed in the event object.
    Not every event populates every property, so some properties may be undefined.
    But there are a few properties that are universal, and we will explore them in
    detail next.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 事件对象是基于 W3C 规范的，并作为参数明确传递给所有事件处理程序，它拥有许多重要属性，其中许多属性对事件处理程序函数可能很有用。因为每个事件都不同，所以在事件对象中传递的属性值也不同。并非每个事件都填充每个属性，因此某些属性可能未定义。但有一些属性是通用的，我们将在下面详细探讨它们。
- en: event.target
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: event.target
- en: 'This is the element that triggered the event. This is not the same thing as
    the element bound to the event handler (the one pointed to by the `this` object).
    For example, if you click an `<a>` tag, which doesn''t have a handler, but its
    parent, `<div>`, does, the event bubbles up to the parent. Under these conditions,
    `event.target` points to the `<a>` tag, but the `this` object points to the `<div>`
    element. Let''s explore this with code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是触发事件的元素。这与绑定到事件处理程序的元素（由 `this` 对象指向的元素）不同。例如，如果单击一个没有处理程序但其父级 `<div>` 有处理程序的
    `<a>` 标签，则事件会冒泡到父级。在这种情况下，`event.target` 指向 `<a>` 标签，但 `this` 对象指向 `<div>` 元素。让我们用代码来探索一下：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the sample, we place a click event handler on the `<div>` tag that surrounds
    an `<a>` tag. There is no handler placed in `<a>`. When `<a>` is clicked on, since
    it doesn't have an elevator, it bubbles the event up to its parent, the `<div>`
    tag. The `this` object will now point to the `<div>` element, while `event.target`
    will still point to the `<a>` tag.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我们在包围 `<a>` 标签的 `<div>` 标签上放置了一个点击事件处理程序。在 `<a>` 中没有放置处理程序。当单击 `<a>` 时，由于它没有电梯，它会将事件冒泡到其父级，即
    `<div>` 标签。现在 `this` 对象将指向 `<div>` 元素，而 `event.target` 仍将指向 `<a>` 标签。
- en: event.relatedTarget
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: event.relatedTarget
- en: 'The `relatedTarget` property also points to an element when valid, but rather
    than being the element that triggered the event, it is an element that is somehow
    related to the event instead. An easy way to see this is with the `mouseenter`
    event. Check out the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`relatedTarget` 属性在有效时也指向一个元素，但与触发事件的元素不同，它是与事件相关的元素。一个简单的例子是使用 `mouseenter`
    事件。看看下面的代码：'
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When the `mouseenter` event is triggered, the `relatedTarget` property points
    to the element that will receive the `mouseleave` event. In our example, if we
    start on top `<a>` and move the cursor up and over the `<input>` tag, the related
    target will be the `<div>` tag that surrounds the `<a>` tag.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当触发`mouseenter`事件时，`relatedTarget`属性指向将接收`mouseleave`事件的元素。在我们的示例中，如果我们从顶部`<a>`开始并移动光标并跨越`<input>`标签，则相关目标将是包围`<a>`标签的`<div>`标签。
- en: event.type
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: event.type
- en: 'This property holds the name of the current event. It could come in handy if
    you use a single event handler for multiple events:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性保存当前事件的名称。如果您对多个事件使用单个事件处理程序，这可能会派上用场：
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding code, we have two different events sharing the same handler.
    When either occurs, it displays the event type to enable us to tell them apart.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们有两个共享相同处理程序的不同事件。当任一事件发生时，它显示事件类型以使我们能够将它们区分开。
- en: event.which
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: event.which
- en: 'When a mouse or keyboard event occurs, this property can be used to tell which
    button or key was pressed. Let''s take a quick look at a code sample:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当鼠标或键盘事件发生时，可以使用此属性来告诉按下了哪个按钮或键。让我们快速看一个代码示例：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When a key is pressed, the `which` property holds the key's code, which is a
    numeric value.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 按下键时，`which`属性保存键的代码，这是一个数字值。
- en: event.metaKey
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: event.metaKey
- en: This is a simple property, which holds a boolean value. It is set to `true`
    if the `metaKey` was pressed when the event fired or `false` if it was not. The
    `metaKey` method on the Macintosh keyboards is usually the command key; on Windows
    machines, it is the usually the Windows key.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的属性，它保存一个布尔值。如果在事件触发时按下了`metaKey`，则设置为`true`；如果没有按下，则设置为`false`。Macintosh键盘上的`metaKey`方法通常是命令键；在Windows机器上，通常是Windows键。
- en: event.pageX and event.pageY
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: event.pageX 和 event.pageY
- en: 'The `pageX` and `pageY` properties hold the mouse position relative to the
    upper-left corner of the page. This could be useful when creating dynamic applications
    that update the page as the user moves the mouse like how it''s done in a drawing
    program:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`pageX`和`pageY`属性保存鼠标相对于页面左上角的位置。这在创建随着用户移动鼠标而更新页面的动态应用程序时非常有用，就像在绘图程序中所做的那样：'
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the code sample, we hook the `mousemove` event and display the current x
    and y position of the mouse dynamically.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码示例中，我们挂钩`mousemove`事件并动态显示鼠标当前的x和y位置。
- en: event.originalEvent
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: event.originalEvent
- en: When an event occurs, jQuery normalizes it so that the events in every browser
    behave in the same manner. Occasionally, jQuery's normalized event object lacks
    something that the original event object had and your application needs. jQuery
    places a complete copy of the original event object in the `originalEvent` property
    exactly for this reason.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件发生时，jQuery会对其进行归一化，以便每个浏览器中的事件表现出相同的行为。偶尔，jQuery的标准化事件对象缺少原始事件对象具有的某些内容，而您的应用程序需要。正是出于这个原因，jQuery在`originalEvent`属性中放置了原始事件对象的完整副本。
- en: Passing data to an event
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向事件传递数据
- en: 'If you ever need to pass data to an event, all you need to do is pass the data
    after the event name when hooking the event. You can pass nearly any type of data
    with a few caveats. First, if the data is a string, then you must also set the
    optional selector parameter that precedes it in the parameter list. If you don''t
    need the selector parameter, you can set it to null. Second, the data that you
    pass can''t be null or undefined. Here is a little sample that shows how to pass
    data to an event:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您曾经需要向事件传递数据，您需要做的就是在挂钩事件之后传递数据。您几乎可以传递任何类型的数据，但有一些注意事项。首先，如果数据是字符串，那么您还必须设置参数列表中它之前的可选选择器参数。如果您不需要选择器参数，可以将其设置为null。其次，传递的数据不能是null或undefined。以下是一个小示例，展示了如何向事件传递数据：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the second event hook, we pass a null selector parameter in order to avoid
    confusion since we are passing a string as the data parameter.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个事件挂钩中，我们传递了一个空的选择器参数，以避免混淆，因为我们将字符串作为数据参数传递。
- en: Event shorthand methods
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件快捷方法
- en: 'Web programming is event-driven, and some events are used so often that jQuery
    has created shorthand methods to hook them. The following two methods are equal:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Web编程是事件驱动的，一些事件是如此常用，以至于jQuery已经创建了快捷方法来挂钩它们。以下两种方法是相等的：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The second form is shorter and possibly easier to read, but there is a downside.
    In the shorthand form, there is no way to add the extra and optional parameters.
    If you need the selector or data parameters, then you must use the longhand form.
    Here is a list of all of the shorthand methods:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种形式更短，可能更易阅读，但有一个缺点。在简写形式中，没有办法添加额外的和可选的参数。如果你需要选择器或数据参数，那么必须使用长格式。以下是所有简写方法的列表：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Creating your own events
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您自己的事件
- en: 'Creating your own events is common practice in JavaScript. There are a lot
    of reasons for this. For one, it is a best practice since it promotes the loose
    coupling of code. Code that uses events to communicate isn''t tightly coupled.
    This is easy to do; you create event handlers for your own events in the same
    way that you create handlers for system events. Imagine that we need to create
    an event and would like to call `superDuperEvent`. Here is the code that creates
    its handler:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中创建自定义事件是常见实践。这样做有很多原因。首先，这是最佳实践，因为它促进了代码的松耦合。使用事件进行通信的代码不是紧密耦合的。这很容易做到；你可以以与为系统事件创建处理程序相同的方式为自己的事件创建事件处理程序。假设我们需要创建一个事件并希望调用`superDuperEvent`。这是创建其处理程序的代码：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the code, we create two event handlers. The first creates a handler for our
    `superDuperEvent method`. If the code looks nearly identical to the handler code
    we've created for system events, then that is the way it is intended.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们创建了两个事件处理程序。第一个为我们的`superDuperEvent方法`创建了一个处理程序。如果代码看起来与我们为系统事件创建的处理程序代码几乎相同，那么这就是意图。
- en: Triggering events
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 触发事件
- en: 'Once you have created the handler code for your custom event, the next question
    you need to answer is this: how do you trigger the event? This is something we
    haven''t mentioned yet, but all you need is the `.trigger()` method. The `.trigger()`
    method executes all of the handlers bound to the matched set of elements for the
    event type. As the preceding code shows, all we need to do in order to trigger
    our custom event is call the `.trigger()` method on the set of elements and pass
    in the event''s name.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦为您的自定义事件创建了处理程序代码，您需要回答的下一个问题是：如何触发事件？这是我们还没有提到的事情，但你所需要的只是`.trigger()`方法。`.trigger()`方法执行与事件类型匹配的元素集绑定的所有处理程序。如上述代码所示，要触发我们的自定义事件，我们所需的就是在一组元素上调用`.trigger()`方法并传入事件的名称。
- en: 'If we''d like, we can also pass custom data to the event''s handler. And again,
    this is the same as what we''ve done with regular events. We simply call the `.trigger()`
    method, and after we pass the event name, we pass the custom data:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们愿意，我们也可以将自定义数据传递给事件处理程序。再次强调，这与我们对常规事件所做的操作是一样的。我们只需调用`.trigger()`方法，然后在传递事件名称之后传递自定义数据：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As the preceding code shows, passing data to our event''s handler can do one
    thing that passing data bound to the event hook can''t: we can pass fresh data.
    When we pass data in the event hook, it never changes, which limits its usefulness.
    But the data in the trigger can be changed each time we call the event. Take a
    look at this code sample:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如上述代码所示，向我们的事件处理程序传递数据可以做一件钩子事件绑定数据无法做到的事情：我们可以传递新鲜的数据。当我们在事件钩子中传递数据时，它永远不会改变，这限制了其有用性。但是在触发器中的数据可以每次调用事件时更改。看一下这个代码示例：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Each time our custom event is triggered, we pass it the current time in milliseconds.
    Passing fresh data is not possible when hooking events.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们触发自定义事件时，我们向其传递当前时间的毫秒数。当挂接事件时，无法传递新鲜的数据。
- en: The death of the .live() and .die() methods
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`.live()`和`.die()`方法的消失'
- en: As of version 1.7 of jQuery, both the `.live()` method and its companion, the
    `.die()` method, have been deprecated. And they were both removed from the library
    as of version 1.9\. While they still exist within the jQuery Migrate Plugin, they
    should not be used to write new code, and any old code using them should be rewritten.
    A lot of users really liked these methods, especially the `.live()` method. It
    was used to write very dynamic code. So, why were these methods removed from the
    library?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 从jQuery 1.7版开始，`.live()`方法及其伴侣`.die()`方法已被弃用。并且从版本1.9开始从库中删除了它们。尽管它们仍存在于jQuery迁移插件中，但不应用于编写新代码，并且应该重写任何旧代码使用它们。许多用户真的很喜欢这些方法，尤其是`.live()`方法。它被用来编写非常动态的代码。那么，为什么这些方法从库中删除了呢？
- en: The jQuery documentation does a great job of listing some of the problems with
    the `.live()` method. First among them was its performance. The `.live()` method,
    in spite of what was passed in the selector, was actually bound to the document
    element. Yet, it would still retrieve the set of elements specified by the selector,
    which could be time consuming on large documents. When an event occurred, it had
    to bubble all the way up to the document before it could be handled. This meant
    that every event handled by `.live()` was guaranteed to take the longest, slowest
    path to its handler function.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 文档在列出 `.live()` 方法的一些问题方面做得很好。其中最重要的是性能问题。尽管传递给选择器的内容不同，`.live()` 方法实际上绑定到了文档元素上。然而，它仍然会检索由选择器指定的元素集，这在大型文档中可能是耗时的。当事件发生时，它必须冒泡到文档才能被处理。这意味着每个由
    `.live()` 处理的事件都保证要走最长、最慢的路径到其处理函数。
- en: The `.live()` method didn't behave similar to other jQuery methods, and this
    led to bugs. It didn't support chaining events, though it looked like it did.
    Calling `event.stopProgation()` does nothing since there is nothing at a level
    higher than the document. It also didn't play well with other events. So, it was
    decided to deprecate this event and remove it eventually.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`.live()` 方法的行为与其他 jQuery 方法不同，这导致了 bug 的产生。它不支持事件链接，尽管看起来像支持。调用 `event.stopProgation()`
    什么也不做，因为没有比文档更高级别的东西。它也不与其他事件协调。因此，决定废弃此事件并最终删除它。'
- en: Looking deeper at .on()
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入研究 .on()
- en: The `.on()` method is not just a renamed `.bind()` method. It has capabilities
    that the former lacked. Part of the reason for these new capabilities is to give
    developers a way to write code in a fashion similar to what the `.live()` method
    provided.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`.on()` 方法不仅仅是一个重命名的 `.bind()` 方法。它具有前者缺乏的功能。这些新功能的部分原因是为了给开发人员提供一种以与 `.live()`
    方法相似的方式编写代码的方法。'
- en: 'The `.on()` method has an optional parameter; the `which` selector is a string.
    Most of the time, it isn''t required, so either it isn''t passed, or a null is
    passed instead. When you''d like to replace the `.live()` method without its inefficiencies,
    use the `.on()` method:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`.on()` 方法有一个可选参数；`which` 选择器是一个字符串。大多数情况下，它并不是必需的，所以要么没有传递它，要么传递了一个空值。当你想要替换
    `.live()` 方法而又不希望效率低下时，可以使用 `.on()` 方法：'
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the preceding code, we hook two events. We first hook the parent element,
    the `<ul>` tag, which will serve as a container for all of the `<li>` tags: those
    that exist now and those that will be created later. Then, we hook the button
    that will be used to generate new `<li>` tags. Each time we create a new tag,
    we increment a counter and concatenate it to the string used for the new tags
    `id` and then append it to the `<ul>` tag.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们挂接了两个事件。首先挂接父元素，即 `<ul>` 标签，它将作为所有 `<li>` 标签的容器：现在存在的和以后创建的。然后，我们挂接了用于生成新
    `<li>` 标签的按钮。每次我们创建一个新标签时，我们都会增加一个计数器并将其连接到用于新标签 `id` 的字符串，然后将其附加到 `<ul>` 标签上。
- en: Summary
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'We''ve learned a lot about one of the most important things in web programming:
    events. Events make websites interactive. We began by looking at one of the most
    important events, the jQuery ready event. We continued to cover hooking and unhooking
    events, namespacing, and finally, writing event handlers using the event object.
    With the basics covered, we showed how to write your own events and trigger them.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学到了 Web 编程中最重要的事情之一：事件。事件使网站具有交互性。我们首先从最重要的事件之一开始，即 jQuery 就绪事件。我们继续讨论挂接和取消挂接事件、命名空间，并最终使用事件对象编写事件处理程序。基础知识介绍完毕后，我们展示了如何编写自己的事件并触发它们。
- en: In the next chapter, we will learn how to make our site smooth and polished
    using jQuery's built-in and custom animations. Animations help ease the transition
    from one application state to the next. Without it, a site can seem jarring to
    a user when elements on the page appear and disappear abruptly.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用jQuery的内置和自定义动画使我们的网站变得流畅和精致。动画有助于使应用程序状态之间的过渡变得平滑。没有它，当页面上的元素突然出现和消失时，网站对用户来说可能会显得令人不适。
