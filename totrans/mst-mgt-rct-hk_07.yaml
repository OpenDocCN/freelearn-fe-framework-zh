- en: '*Chapter 5*: Sharing Component State with Context and Subscription'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第五章*: 使用上下文和订阅共享组件状态'
- en: 'In the previous two chapters, we learned how to use Context and Subscription
    for a global state. Each has different benefits: Context allows us to provide
    different values for different subtrees, while Subscriptions prevent extra re-renders.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两章中，我们学习了如何使用上下文和订阅来实现全局状态。每个都有不同的好处：上下文允许我们为不同的子树提供不同的值，而订阅可以防止额外的重新渲染。
- en: 'In this chapter, we will learn a new approach: combining React Context and
    Subscriptions. The combination will give us the benefits of each, which means:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习一种新的方法：结合React上下文和订阅。这种结合将给我们带来各自的好处，这意味着：
- en: Context can provide a global state to a subtree and the Context provider can
    be nested. Context allows us to control a global state in the React component
    lifecycle like the `useState` hook.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文可以为子树提供一个全局状态，并且上下文提供者可以嵌套。上下文允许我们在React组件的生命周期中控制全局状态，就像`useState`钩子一样。
- en: On the other hand, Subscriptions allow us to control re-renders, which is not
    possible with a single Context.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，订阅允许我们控制重新渲染，这是单个上下文无法实现的。
- en: Having the benefits of both can be a good solution for larger apps – because,
    as mentioned, this means we can have different values in different subtrees, and
    we can also avoid extra re-renders.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 结合两者的好处可以是大应用的一个好解决方案——因为，如前所述，这意味着我们可以在不同的子树中拥有不同的值，我们还可以避免额外的重新渲染。
- en: This approach is useful for mid to large apps. In such apps, having different
    values in different subtrees can happen, and we can avoid extra re-renders, which
    can be very important for our apps.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法对于中等到大型应用很有用。在这些应用中，不同的子树可能具有不同的值，我们可以避免额外的重新渲染，这对我们的应用来说可能非常重要。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Exploring the limitations of module state
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索模块状态的局限性
- en: Understanding when to use Context
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解何时使用上下文
- en: Implementing the Context and Subscription pattern
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现上下文和订阅模式
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You are expected to have moderate knowledge of React, including React Hooks.
    Refer to the official site, [https://reactjs.org](https://reactjs.org), to learn
    more.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 预期你具备一定的React知识，包括React Hooks。请参考官方网站[https://reactjs.org](https://reactjs.org)以了解更多信息。
- en: In some code, we use TypeScript ([https://www.typescriptlang.org](https://www.typescriptlang.org)),
    and you should have basic knowledge of it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些代码中，我们使用TypeScript ([https://www.typescriptlang.org](https://www.typescriptlang.org))，你应该对其有基本了解。
- en: 'The code in this chapter is available on GitHub: [https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_05](https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_05).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码可在GitHub上找到：[https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_05](https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_05)。
- en: To run code snippets, you need a React environment, for example, Create React
    App ([https://create-react-app.dev](https://create-react-app.dev)) or CodeSandbox
    ([https://codesandbox.io](https://codesandbox.io)).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行代码片段，你需要一个React环境，例如，Create React App ([https://create-react-app.dev](https://create-react-app.dev))或CodeSandbox
    ([https://codesandbox.io](https://codesandbox.io))。
- en: Exploring the limitations of module state
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索模块状态的局限性
- en: 'Because module state resides outside React components, there''s a limitation:
    the module state defined globally is a singleton, and you can''t have different
    states for different component trees or subtrees.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因为模块状态位于React组件之外，存在一个限制：全局定义的模块状态是单例的，你不能为不同的组件树或子树有不同的状态。
- en: 'Let''s revisit our `createStore` implementation from [*Chapter 4*](B17780_04_Final_VK_ePub.xhtml#_idTextAnchor066),
    *Sharing Module State with Subscription*:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下[*第四章*](B17780_04_Final_VK_ePub.xhtml#_idTextAnchor066)中关于*使用订阅共享模块状态*的`createStore`实现：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Using this `createStore`, let''s define a new `store`. We define a `store`
    with a property `count`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个`createStore`，让我们定义一个新的`store`。我们定义一个具有`count`属性的`store`：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that this `store` is defined outside the React component.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个`store`是在React组件外部定义的。
- en: 'To use `store` in a React component, we use `useStore`. The following is an
    example with two components that show the shared count from the same `store` variable.
    We use `useStore`, which was defined in [*Chapter 4*](B17780_04_Final_VK_ePub.xhtml#_idTextAnchor066),
    *Sharing Module State with Subscription*:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要在React组件中使用`store`，我们使用`useStore`。以下是一个示例，其中包含两个组件，它们显示了来自同一`store`变量的共享计数。我们使用`useStore`，它是在[*第四章*](B17780_04_Final_VK_ePub.xhtml#_idTextAnchor066)中定义的，*使用订阅共享模块状态*：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We have the component `Counter`, which is to show the `count` number in the
    `store` object, and a `button` to update the `count` value. Because this `Counter`
    component is reusable, `Component` can have two `Counter` instances. This will
    show a pair of two counters sharing the same state.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个`Counter`组件，用于在`store`对象中显示`count`数字，以及一个`button`来更新`count`值。由于这个`Counter`组件是可重用的，`Component`可以有两个`Counter`实例。这将显示一对共享相同状态的计数器。
- en: Now, suppose we want to show another pair of counters. We would like to have
    two new components in `Component`, but the new pair should show different counters
    from the first set.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想显示另一对计数器。我们希望在`Component`中有两个新的组件，但新的一对应该显示与第一组不同的计数器。
- en: 'Let''s create a new `count` value. We could add a new property to the `store`
    object we already defined, but we assume there are other properties and want to
    isolate stores. Therefore, we create `store2`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的`count`值。我们可以在已经定义的`store`对象中添加一个新的属性，但我们假设还有其他属性，并希望隔离存储。因此，我们创建`store2`：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Because `createStore` is reusable, creating a new `store2` object is straightforward.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`createStore`是可重用的，创建一个新的`store2`对象很简单。
- en: 'We then need to create components to use `store2`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要创建组件来使用`store2`：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You may notice the similarity between `Counter` and `Counter2` – that they are
    both 14 lines of code, and the only difference is the `store` variable they are
    referencing – `store` for `Counter` and `store2` for `Counter2`. We would need
    `Counter3` or `Counter4` to support more stores. Ideally, `Counter` should be
    reusable. But, as module state is defined outside React, it's not possible. This
    is the limitation of module state.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到`Counter`和`Counter2`之间的相似性——它们都是14行代码，唯一的区别是它们引用的`store`变量——`Counter`使用`store`，而`Counter2`使用`store2`。我们需要`Counter3`或`Counter4`来支持更多的存储。理想情况下，`Counter`应该是可重用的。但是，由于模块状态是在React外部定义的，所以这是不可能的。这是模块状态的限制。
- en: Important Note
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You may notice we can make the `Counter` component reusable if we put `store`
    in `props`. However, that will require prop drilling when components are deeply
    nested, and the primary reason for introducing module state is to avoid prop drilling.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，如果我们把`store`放在`props`中，就可以使`Counter`组件可重用。然而，这将需要在组件深层嵌套时进行属性钻取，而引入模块状态的主要原因是避免属性钻取。
- en: 'It would be nice to reuse the `Counter` component for different stores. The
    pseudocode would be as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 很好地重用`Counter`组件来为不同的存储提供支持。伪代码如下：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you look at the code, you will notice that `Component`, `Component2`, and
    `Component3` are mostly the same. The only difference is the `Provider` components.
    This is exactly where React Context fits in. We will discuss this in more detail
    in the *Implementing the Context and Subscription pattern* section.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看代码，你会注意到`Component`、`Component2`和`Component3`几乎相同。唯一的区别是`Provider`组件。这正是React
    Context发挥作用的地方。我们将在*实现上下文和订阅模式*部分详细讨论这一点。
- en: Now you understand the limitation of module state and the ideal patterns for
    multiple stores. Next up, we'll recap React Context and explore the usage of Context.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了模块状态的限制和多个存储的理想模式。接下来，我们将回顾React Context并探讨上下文的使用。
- en: Understanding when to use Context
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解何时使用上下文
- en: Before diving into learning the way to combine Context and Subscription, let's
    recap how Context works.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入学习如何结合上下文和订阅之前，让我们回顾一下上下文是如何工作的。
- en: 'The following is a simple Context example with a theme. So, we specify a default
    value for `createContext`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的带有主题的Context示例。因此，我们为`createContext`指定一个默认值：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: What `useContext(ThemeContext)` returns depends on the Context in the component
    tree.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`useContext(ThemeContext)`返回的内容取决于组件树中的上下文。'
- en: 'To change the Context value, we use a `Provider` component in Context as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改上下文值，我们使用Context中的`Provider`组件如下：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this case, `Component` will show the theme as `dark`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`Component`将显示主题为`dark`。
- en: 'The provider can be nested. It will use the value from the innermost provider:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 提供者可以嵌套。它将使用最内层提供者的值：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If there are no providers in the component tree, it will use the default value.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果组件树中没有提供者，它将使用默认值。
- en: 'For example, here, we assume `Root` is a component at the root:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在这里，我们假设`Root`是一个根组件：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this case, `Component` will show the theme as `light`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`Component`也将显示主题为`light`。
- en: 'Let''s see an example that has a provider to provide the same default value
    at the root:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个示例，它有一个提供者在根处提供相同的默认值：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this case too, `Component` will show the theme as `light`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`Component`也将显示主题为`light`。
- en: 'So, let''s discuss when to use Context. To do this, think of our example: what
    is the difference between this example with a provider and the previous example
    without a provider? We can say that there is no difference. Using the default
    value gives the same result.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们讨论何时使用 Context。为此，考虑我们的示例：有提供者和没有提供者的这个示例之间有什么区别？我们可以这样说，没有区别。使用默认值会得到相同的结果。
- en: Having a proper default value for Context is important. The Context provider
    can be seen as a method to override the default Context value or a value provided
    by the parent provider if it exists.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为 Context 设置适当的默认值非常重要。Context 提供者可以被视为一种覆盖默认 Context 值或父提供者（如果存在）提供值的方法。
- en: In the case of `ThemeContext`, if we have the proper default value, then what's
    the point of using a provider? It will be required to provide a different value
    for a subtree of the entire component tree. Otherwise, we can just use the default
    value from `Context`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ThemeContext` 的情况下，如果我们有适当的默认值，那么使用提供者的意义何在？将需要为整个组件树的一个子树提供不同的值。否则，我们只需使用
    `Context` 的默认值。
- en: For a global state with Context, you may only use one provider at the root.
    This is a valid use case, but this use case can be covered by module state with
    Subscription, which we learned about in [*Chapter 4*](B17780_04_Final_VK_ePub.xhtml#_idTextAnchor066),
    *Sharing Module State with Subscription*. Given that module state covers the use
    case with one Context provider at the root, Context for a global state is only
    required if we need to provide different values for different subtrees.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用 Context 的全局状态，你可能在根处只能使用一个提供者。这是一个有效的用例，但这个用例可以通过我们在[*第 4 章*](B17780_04_Final_VK_ePub.xhtml#_idTextAnchor066)
    *使用 Subscription 共享模块状态*中学到的模块状态来覆盖。鉴于模块状态涵盖了根处只有一个 Context 提供者的用例，因此，如果需要为不同的子树提供不同的值，才需要全局状态的
    Context。
- en: In this section, we revisited React Context and learned when to use it. Next
    up, we will learn how to combine Context and Subscription.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们回顾了 React Context 的使用，并学习了何时使用它。接下来，我们将学习如何结合 Context 和 Subscription。
- en: Implementing the Context and Subscription pattern
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 Context 和 Subscription 模式
- en: 'As we learned, using one Context to propagate a global state value has a limitation:
    it causes extra re-renders.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所学的，使用一个 Context 来传播全局状态值有一个限制：它会导致额外的重新渲染。
- en: 'Module state with Subscription doesn''t have such a limitation, but there is
    another: it only provides a single value for the entire component tree.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 带有 Subscription 的模块状态没有这样的限制，但还有一个限制：它只为整个组件树提供一个值。
- en: 'We would like to combine Context and Subscription to overcome both limitations.
    Let''s implement this feature. We''ll start with `createStore`. This is exactly
    the same implementation we developed in [*Chapter 4*](B17780_04_Final_VK_ePub.xhtml#_idTextAnchor066),
    *Sharing Module State with Subscription*:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望结合 Context 和 Subscription 来克服两者的限制。让我们实现这个功能。我们将从 `createStore` 开始。这正是我们在[*第
    4 章*](B17780_04_Final_VK_ePub.xhtml#_idTextAnchor066) *使用 Subscription 共享模块状态*中开发的实现：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In [*Chapter 4*](B17780_04_Final_VK_ePub.xhtml#_idTextAnchor066), *Sharing Module
    State with Subscription*, we used `createStore` for module state. This time, we'll
    use `createStore` for the `Context` value.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 4 章*](B17780_04_Final_VK_ePub.xhtml#_idTextAnchor066) *使用 Subscription
    共享模块状态*中，我们使用了 `createStore` 来处理模块状态。这次，我们将使用 `createStore` 来设置 `Context` 的值。
- en: 'The following is the code to create a Context. The default value is passed
    to `createContext`, which we refer to as a default store:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为创建 Context 编写的代码。默认值传递给 `createContext`，我们将其称为默认存储：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this case, the default store has a state with two properties: `count` and
    `text`.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，默认存储具有两个属性的状态：`count` 和 `text`。
- en: 'To provide different stores for subtrees, we implement `StoreProvider`, which
    is a tiny wrapper around `StoreContext.Provider`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为子树提供不同的存储，我们实现了 `StoreProvider`，它是对 `StoreContext.Provider` 的小型包装：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`useRef` is used to make sure that the store object is initialized only once
    at the first render.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`useRef` 用于确保存储对象仅在第一次渲染时初始化一次。'
- en: 'To use a store object, we implement a hook called `useSelector`. Unlike `useStoreSelector`,
    defined in the *Working with a selector and useSubscription* section in [*Chapter
    4*](B17780_04_Final_VK_ePub.xhtml#_idTextAnchor066), *Sharing Module State with
    Subscription*, `useSelector` doesn''t take a `store` object in its arguments.
    It takes a `store` object from `StoreContext` instead:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用存储对象，我们实现了一个名为 `useSelector` 的钩子。与在 [*第 4 章*](B17780_04_Final_VK_ePub.xhtml#_idTextAnchor066)
    中 *使用选择器和 useSubscription* 部分定义的 `useStoreSelector` 不同，`useSelector` 不在其参数中接受
    `store` 对象。它从 `StoreContext` 中获取 `store` 对象：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Using `useContext` together with `useSubscription` is the key point of this
    pattern. This combination allows us the benefits of both Context and Subscription.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `useContext` 与 `useSubscription` 结合使用是这种模式的关键点。这种组合使我们能够享受到 Context 和订阅的双重优势。
- en: 'Unlike module state, we need to provide a way to update the state with Context.
    `useSetState` is a simple hook to return the `setState` function in `store`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 与模块状态不同，我们需要提供一种使用 Context 更新状态的方法。`useSetState` 是一个简单的钩子，用于在 `store` 中返回 `setState`
    函数：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, let''s use what we have implemented. The following is a component that
    shows `count` in `store`, along with `button` to increment `count`. We define
    `selectCount` outside the `Component`, otherwise, we would need to wrap the function
    with `useCallback`, which introduces extra work:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用我们所实现的功能。以下是一个显示 `store` 中的 `count` 并带有用于增加 `count` 的 `button` 的组件。我们在
    `Component` 外部定义 `selectCount`，否则我们需要用 `useCallback` 包装函数，这会引入额外的工作：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It's important to note here that this `Component` component is not tied to any
    specific store object. The `Component` component can be used for different stores.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的是，这个 `Component` 组件并不绑定到任何特定的存储对象。`Component` 组件可以用于不同的存储。
- en: 'We can also have `Component` in various places:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在各个地方使用 `Component`：
- en: Outside any providers
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任何提供者外部
- en: Inside the first provider
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一个提供者内部
- en: Inside the second provider
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二个提供者内部
- en: 'The following `App` component includes the `Component` components in three
    places: 1) outside of `StoreProvider`, 2) inside the first `StoreProvider` component,
    and 3) inside the second nested `StoreProvider` component. The `Component` components
    in different `StoreProvider` components share different `count` values:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `App` 组件在三个地方包含了 `Component` 组件：1) 在 `StoreProvider` 外面，2) 在第一个 `StoreProvider`
    组件内部，以及 3) 在第二个嵌套的 `StoreProvider` 组件内部。不同 `StoreProvider` 组件中的 `Component` 组件共享不同的
    `count` 值：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Each `Component` component using the same `store` object will share the `store`
    object and show the same `count` value. In this case, the components in different
    component tree levels use a different `store`, hence the components show a different
    `count` value in various places. When you run this app, you will see something
    like the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同 `store` 对象的每个 `Component` 组件将共享 `store` 对象并显示相同的 `count` 值。在这种情况下，不同组件树级别的组件使用不同的
    `store`，因此在不同位置显示不同的 `count` 值。当你运行这个应用程序时，你会看到以下内容：
- en: '![Figure 5.1 – Screenshot of the running app  ](img/Figure_5.1_B17780.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – 运行中的应用程序截图](img/Figure_5.1_B17780.jpg)'
- en: Figure 5.1 – Screenshot of the running app
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 运行中的应用程序截图
- en: If you click the **+1** button in **Using default store**, you will see two
    counts in **Using default store** are updated together. If you click the **+1**
    button in **Using store provider**, you will see two counts in **Using store provider**
    are updated together. The same applies to **Using inner store provider**.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击 **使用默认存储** 中的 **+1** 按钮，你将看到 **使用默认存储** 中的两个计数器一起更新。如果你点击 **使用存储提供者**
    中的 **+1** 按钮，你将看到 **使用存储提供者** 中的两个计数器一起更新。同样适用于 **使用内部存储提供者**。
- en: In this section, we learned how to implement a global state with Context and
    Subscription, taking advantage of the related benefits. We can isolate state in
    a subtree thanks to Context, and we can avoid extra re-renders thanks to Subscription.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何利用 Context 和订阅实现全局状态，并利用相关的优势。由于 Context 的存在，我们可以将状态隔离在子树中，并且由于订阅的存在，我们可以避免额外的重新渲染。
- en: Summary
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we learned a new approach: combining React Context and Subscription.
    It provides the benefits of both: providing isolated values in subtrees and avoiding
    extra re-renders. This approach is useful for mid to large apps. In such apps,
    having different values in different subtrees can happen, and we can avoid extra
    re-renders, which can be very important for our apps.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了一种新的方法：结合 React Context 和 Subscription。这种方法提供了两者的好处：在子树中提供隔离的值，并避免额外的重新渲染。这种方法对于中等到大型应用非常有用。在这些应用中，不同的子树可能具有不同的值，我们可以避免额外的重新渲染，这对我们的应用可能非常重要。
- en: Starting from the next chapter, we will dive into various global state libraries.
    We will learn how those libraries are based on what we have learned so far.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 从下一章开始，我们将深入探讨各种全局状态库。我们将学习这些库是如何基于我们迄今为止所学的内容构建的。
