- en: JSON in Reason
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll learn how to work with JSON by building a simple customer
    management application. This application lives within the `/customers` route of
    our existing app and can create, read, and update customers. JSON data persists
    to `localStorage`. Throughout this chapter, we convert external JSON into a typed
    data structure that Reason can understand in two different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Using pure Reason
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `bs-json` library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll compare and contrast each method at the end of the chapter. We'll also
    discuss how **GraphQL** can help provide a pleasant developer experience when
    working with JSON in a statically typed language such as Reason.
  prefs: []
  type: TYPE_NORMAL
- en: 'To follow along with building the customer management application, clone this
    book''s GitHub repository and start from `Chapter07/app-start`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this chapter we will look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Building views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating with localStorage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using bs-json
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using GraphQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In total, we''ll have three views:'
  prefs: []
  type: TYPE_NORMAL
- en: A list view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A create view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An update view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each view has its own route. The create and update views share a common component
    because they're so similar.
  prefs: []
  type: TYPE_NORMAL
- en: File structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since our `bsconfig.json` includes subdirectories, we can create a `src/customers`
    directory to house related components, and BuckleScript will recursively look
    for Reason (and OCaml) files in subdirectories of `src`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Let's move on and rename the `src/Page1.re` component to `src/customers/CustomerList.re`.
    In the same directory, we'll later create `Customer.re`, which will be used to
    both create and update individual customers.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the router and navigation menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In `Router.re`, we''ll replace the `/page1` route with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also add the routes for `/customers/create` and `/customers/:id`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The router has been updated so it can handle route variables (such as `/customers/:id`).
    This change has been made for you in `Chapter07/app-start`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, be sure to also update the navigation menu in `<App.re />`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: CustomerType.re
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This file will hold the customer type used by both `<CustomerList />` and `<Customer
    />`. This is done to avoid any circular dependency compiler errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: CustomerList.re
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For now, we''ll use a hardcoded array of customers. Soon, we''ll retrieve this
    data from `localStorage`. The following component renders a styled array of customers.
    Each customer is wrapped in a `<Link />` component. Clicking on a customer navigates
    to the update view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Customer.re
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This reducer component renders a form where every customer field is editable
    inside an input element. The component has two modes—`Create` and `Update`—based
    on the `window.location.pathname`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by binding to `window.location.pathname`, and defining our component''s
    actions and state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add our component styles using `bs-css`. To see the styles, check
    out `Chapter07/app-end/src/customers/Customer.re`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have helper functions, for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: To extract the customer ID from `window.location.pathname`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To get a customer by ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To generate a default customer:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And, of course, the following is our component''s `make` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `Save` action doesn't yet save to `localStorage`. The form is empty when
    navigating to `/customers/create` and populated when navigating to, for example,
    `/customers/1`.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating with localStorage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create a separate module to interact with the data layer, which we'll
    call `DataPureReason.re`. Here, we expose bindings to `localStorage.getItem` and
    `localStorage.setItem`, and a parsing function to parse JSON strings into the
    `CustomerType.t` record defined earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Populating localStorage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You'll find some initial data in `Chapter07/app-end/src/customers/data.json`.
    Please run `localStorage.setItem("customers", JSON.stringify(/* paste JSON data
    here */))` in your browser's console to populate `localStorage` with this initial
    data.
  prefs: []
  type: TYPE_NORMAL
- en: DataPureReason.re
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Remember when BuckleScript bindings felt kind of obscure? Hopefully, they''re
    now starting to feel a bit more straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: To parse the JSON, we'll use the `Js.Json` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Js.Json documentation can be found at the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://bucklescript.github.io/bucklescript/api/Js_json.html](https://bucklescript.github.io/bucklescript/api/Js_json.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Soon, you''ll see one way to use the `Js.Json` module to parse JSON strings.
    One caveat, though: it''s a bit tedious. But it''s important to understand what
    is going on and why we need to do this for typed languages such as Reason. At
    a high level, we will validate the JSON string to ensure that it''s valid JSON,
    and if so use the `Js.Json.classify` function to convert the JSON string (`Js.Json.t`)
    into a tagged type (`Js.Json.tagged_t`). The available tags are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This way, we can convert JSON strings into typed Reason data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Validating JSON strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `getItem` binding defined in the previous section will return a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can validate the JSON string like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If the JSON is not valid, it will generate a runtime error. At the end of the
    chapter, we'll learn how GraphQL can help improve this situation.
  prefs: []
  type: TYPE_NORMAL
- en: Using Js.Json.classify
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s assume that we''ve validated the following JSON (it''s an array of objects):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have validated the JSON, we''re ready to classify it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We pattern-match on the possible tags for `Js.Json.tagged_t`. If it's an array,
    we then map over it using `Belt.Array.map` (or `Js.Array.map`). Otherwise, we
    get a runtime error in the context of our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `map` function is passed a reference to each object in the array. But Reason
    doesn''t yet know that each element is an object. Inside the `map`, we once again
    classify each element of the array. After classifying, Reason now knows that each
    element is, in fact, an object. We''ll define a custom helper function called
    `parseCustomer` for use with the `map` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if each element of the array is an object, we want to return a new record.
    This record will be of type `CustomerType.t`. Otherwise, we get a runtime error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, for each field (that is, `id`, `name`, `address`, and so on), we use `Js.Dict.get`
    to get and classify each field:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Js.Dict` documentation can be found at the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://bucklescript.github.io/bucklescript/api/Js.Dict.html](https://bucklescript.github.io/bucklescript/api/Js.Dict.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: See `src/customers/DataPureReason.re` for the full implementation. `DataPureReason.rei`
    hides implementation details and only exposes the `localStorage` bindings and
    a parse function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Phew, that was a bit tedious, wasn''t it? Now that it''s done though, we can
    replace the hardcoded customer array in both `CustomerList.re` and `Customer.re`
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: So far, so good! The JSON data is being pulled in dynamically, and parsed, and
    now works the same as it did when hardcoded.
  prefs: []
  type: TYPE_NORMAL
- en: Writing to localStorage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now add the functionality to create and update customers. To do this,
    we''ll need to convert our Reason data structure to JSON. In the interface file, `DataPureReason.rei`,
    we''ll expose a `toJson` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'And then we''ll implement it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And then we''ll use the `toJson` function in the `Customer.re` reducer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the reducer, we update `self.state.customer` with values from the DOM, and
    then call a function that updates `localStorage`. Now, we're able to write to
    `localStorage` by creating or updating customers. Navigate to `/customers/create`
    to create a new customer, and then navigate back to `/customers` to see your newly
    added customer. Click on a customer to navigate to the update view, update the
    customer, click the Update button, and refresh the page.
  prefs: []
  type: TYPE_NORMAL
- en: Using bs-json
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we understand exactly how to convert JSON strings into typed Reason
    data structures, we notice that the process is a bit tedious. It's more lines
    of code than one would expect coming from a dynamic language such as JavaScript.
    Also, there is quite a bit of repetitive code. As an alternative, many in the
    Reason community have adopted `bs-json` as an "official" solution for encoding
    and decoding JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a new module called `DataBsJson.re` and a new interface file, `DataBsJson.rei`.
    We'll copy the exact same interface as we had in `DataPureReason.rei` so that
    we know that, once we're done, we'll be able to replace all references to `DataPureReason`
    with `DataBsJson` and everything should work the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'The exposed interface is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s focus on the `parse` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are accepting the same JSON string as before, validating it, converting
    it to a `Js.Json.t` (via `Json.parseOrRaise`), and then passing the result into
    this new `Json.Decode.array(customerDecoder)` function. `Json.Decode.array` will
    attempt to decode the JSON string into an array, and decode each element of the
    array with a custom function called `customerDecoder`—which we''ll see next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `customerDecoder` function accepts the JSON associated with each element
    of the array and tries to decode that into a record of type `CustomerType.t`.
    This is pretty much exactly the same as what we did previously, but it''s much
    less verbose and much easier to read. As you can see, we have another customer
    decoder, called `addressDecoder`, which is used to decode the `CustomerType.address`
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the custom decoders are easily composed. Each record field is decoded
    by calling `Json.Decode.field`, passing the name of the field (on the JSON side),
    and passing in a `Json.Decode` function that ultimately converts the JSON field
    to a type Reason can understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Encoding works similarly, but in the reverse order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The array of customers is mapped and each customer is encoded to a JSON object.
    The result is an array of JSON objects, which then gets encoded to JSON, and stringified.
    Much better than our previous implementation.
  prefs: []
  type: TYPE_NORMAL
- en: After copying over the same `localStorage` bindings from `DataPureReason.re`,
    our interface is now implemented. After replacing all references to `DataPureReason`
    with `DataBsJson`, we see that our app is working just the same.
  prefs: []
  type: TYPE_NORMAL
- en: Using GraphQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At ReactiveConf 2018, there was an amazing talk by Sean Grove on Reason and
    GraphQL titled *ReactiveMeetups w/ Sean Grove | ReasonML GraphQL.* The following
    is an excerpt from this talk that nicely summarizes the problems and solution
    for using JSON in Reason:'
  prefs: []
  type: TYPE_NORMAL
- en: So I would argue that, in typed languages, like Reason, there are three really,
    really big problems when you want to interact with the real world. The first is
    all the boilerplate that it takes to get data into and out of your type system.
  prefs: []
  type: TYPE_NORMAL
- en: The second is, even if you can program your way out of the boilerplate, you
    are still worried about the accuracy, the safety of conversion.
  prefs: []
  type: TYPE_NORMAL
- en: And then finally, even if you if you get all of this and you're absolutely sure
    you've caught all the variation, someone can still change it from underneath you
    without you knowing.
  prefs: []
  type: TYPE_NORMAL
- en: How many times do we get a changelog whenever the server changes fields? In
    an ideal world, we would. But most of the time we don't. We get to reverse-engineer
    what our server changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'So I would argue that, in order to solve this in a broadly applicable way,
    we want four things:'
  prefs: []
  type: TYPE_NORMAL
- en: 1) Access to all of the data types that an API can provide to us in a programmatic
    way.
  prefs: []
  type: TYPE_NORMAL
- en: 2) Automatic conversions that are guaranteed to be safe.
  prefs: []
  type: TYPE_NORMAL
- en: 3) And we want to have a contract. We want the server to guarantee if it said
    a field is not nullable, they will never give us null. If they change the field
    name, then we immediately know and that they know.
  prefs: []
  type: TYPE_NORMAL
- en: 4) And we want all of that in a programmatic way.
  prefs: []
  type: TYPE_NORMAL
- en: And that's GraphQL.
  prefs: []
  type: TYPE_NORMAL
- en: -Sean Grove
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the video of *ReactiveMeetups w/ Sean Grove | ReasonML GraphQL* at
    the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://youtu.be/t9a-_VnNilE](https://youtu.be/t9a-_VnNilE)'
  prefs: []
  type: TYPE_NORMAL
- en: 'And, here is ReactiveConf''s Youtube channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.youtube.com/channel/UCBHdUnixTWymmXBIw12Y8Qg](https://www.youtube.com/channel/UCBHdUnixTWymmXBIw12Y8Qg)'
  prefs: []
  type: TYPE_NORMAL
- en: It's beyond the scope of this book to go too deeply into GraphQL, but a high-level
    introduction seems fitting given that we're discussing using JSON in Reason.
  prefs: []
  type: TYPE_NORMAL
- en: What is GraphQL?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're part of the ReactJS community, then you've likely already heard of
    GraphQL. GraphQL is a query language and a runtime we can use to fulfill those
    queries and was also created by Facebook. With GraphQL, ReactJS components can
    include GraphQL fragments for data that a component requires—this means that a
    component can couple HTML, CSS, JavaScript, and its external data all in one file.
  prefs: []
  type: TYPE_NORMAL
- en: When using GraphQL, do I need to create JSON decoders?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since GraphQL knows your application's external data intimately, the GraphQL
    client (`reason-apollo`) will generate the decoders for you automatically. Of
    course, the decoders would have to be automatically generated so we're confident
    that they reflect the current shape of the external data. This is just another
    reason to consider using GraphQL with your Reason application when you need to
    handle external data.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As long as we're working within Reason, the type system will prevent you from
    running into runtime type errors. However, when interacting with the outside world—whether
    it be JavaScript or external data—we lose those guarantees. To be able to preserve
    these guarantees within Reason's boundaries, we need to help out the type system
    when using things outside Reason. We previously learned how to use external JavaScript
    in Reason, and in this chapter we've learned how to use external data in Reason.
    Although writing decoders and encoders is more challenging, it's quite similar
    to writing JavaScript bindings. In the end, we're simply telling Reason the type
    of something external to Reason. With GraphQL, we can extend the boundaries of
    Reason to include external data. There are trade-offs, and nothing is perfect,
    but it's definitely worth giving GraphQL a shot.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll explore testing in the context of Reason. What tests
    should we write? What tests should we avoid? We'll also explore how unit testing
    can help us improve the code we wrote in this chapter.
  prefs: []
  type: TYPE_NORMAL
