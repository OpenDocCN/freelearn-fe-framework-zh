<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Following Best Practices and Developing MERN Further</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will elaborate on some of the best practices to apply when building the six MERN applications in this book. Additionally, we will explore other practices that we have not applied in this book but that should be considered for real-world applications to ensure reliability and scalability as complexity grows. We will review the decisions behind organizing the project code in modules, the <span>approaches to</span> applying frontend styling, server-side rendering with data only for selective views, and how React interfaces may be composed to manage state across components. We will also look at ways to improve security, add testing to the projects, and optimize bundling with webpack. Finally, we will wrap up with suggestions for enhancing, and steps for extending, the applications built. With these insights, you will be better equipped to prepare your full-stack MERN projects for the real world.</p>
<p>The topics covered in this chapter include the following:</p>
<ul>
<li style="font-weight: 400">Separation of concerns with modularity in the application structure</li>
<li style="font-weight: 400">Considering the options for CSS styling solutions</li>
<li style="font-weight: 400">Server-side rendering with data for selected views</li>
<li style="font-weight: 400">Using ES6 classes for stateful versus purely functional components</li>
<li style="font-weight: 400">Deciding on whether to use Redux or Flux</li>
<li style="font-weight: 400">Security enhancements for storing user credentials</li>
<li style="font-weight: 400">Writing test code</li>
<li>Optimizing bundle sizes</li>
<li style="font-weight: 400">How to add new features to existing applications</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Separation of concerns with modularity</h1>
                </header>
            
            <article>
                
<p>While building the MERN stack applications in this book, we followed a common folder structure across each application. We employed a modular approach by dividing and grouping the code based on relevance and common functionality. The idea behind creating these smaller and distinct sections in the code is to make sure each section addresses a separate concern, so individual sections can be reused, as well as developed and updated independently. In the following section, we will review this structure and its benefits.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Revisiting the application folder structure</h1>
                </header>
            
            <article>
                
<p>In the application folder structure, we kept the client-side and server-side code separate with further subdivisions within these two sections. This gave us some freedom to design and build the frontend and backend of the application independently. At the project root level, the <kbd>client</kbd> and <kbd>server</kbd> folders were the main divisions, as shown in the following structure:</p>
<pre>| mern_application/<br/>  | -- client/<br/>  | -- server/</pre>
<p>In these <kbd>client</kbd> and <kbd>server</kbd> folders, we divided the code further into subfolders that mapped to unique functionalities. We did this by dividing models, controllers, and routes in the server for specific features, and grouping all components related to a feature in one place on the client side. In the following sections, we will review the divisions within the <kbd>server</kbd> and <kbd>client</kbd> folders.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Server-side code</h1>
                </header>
            
            <article>
                
<p>On the server side, we divided the code according to functionality, by separating code that defines business models from code implementing routing logic, and controller code that responds to client requests at these routes. Within the <kbd>server</kbd> folder, we maintained three main sections, as shown in the following structure:</p>
<pre>  | -- server/<br/>    | --- controllers/<br/>    | --- models/<br/>    | --- routes/</pre>
<p>In this structure, each folder contains code with a specific purpose:</p>
<ul>
<li style="font-weight: 400"><kbd>models</kbd>: This folder is meant to contain all of the Mongoose schema model definitions in separate files, with each file representing a single model.</li>
<li style="font-weight: 400"><kbd>routes</kbd>: This folder contains all routes that allow the client to interact with the server, with routes placed in separate files that may be associated with a model in the <kbd>models</kbd> folder.</li>
<li style="font-weight: 400"><kbd>controllers</kbd>: This folder contains all of the controller functions that define logic to respond to incoming requests at the defined routes. These controllers are divided into separate files corresponding to the relevant model and route files.</li>
</ul>
<p>As demonstrated throughout the book, these specific separations of concerns for the code on the server side allowed us to extend the server developed for the skeleton application by just adding the required model, route, and controller files. In the next section, we will go over the divisions in the client-side code structure.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Client-side code</h1>
                </header>
            
            <article>
                
<p>The client-side code for the MERN applications consists primarily of React components. In order to organize the component code and related helper code in a reasonable and understandable manner, we separated the code into folders related to a feature entity or unique functionality, as shown in the following structure:</p>
<pre>  | -- client/<br/>    | --- auth/<br/>    | --- core/<br/>    | --- post/<br/>    | --- user/<br/>    | --- componentFolderN/</pre>
<p>In the preceding structure, we placed all of the auth-related components and helper code in the <kbd>auth</kbd> folder; common and basic components, such as the <kbd>Home</kbd> and <kbd>Menu</kbd> components, in the <kbd>core</kbd> folder; and then we made <kbd>post</kbd> and <kbd>user</kbd> folders for all of the post-related or user-related components in the respective folders.</p>
<p>This separation and grouping of components based on features allowed us to extend the frontend views in the skeleton application for each application that followed, by adding a new feature-related component code folder, as required, to the <kbd>client</kbd> folder.</p>
<p>Separating the client and server code, and also modularizing the code within these divisions, made it easier to extend the different applications we developed throughout the book. In the final section of this chapter, we will further <span>demonstrate</span> the advantages of this modularized approach of separating the application code, as we outline the general workflow that can be followed to add a new feature to any of the existing applications developed in this book. In the next section, we will explore the different options available for defining and applying styling to the frontend React components, which will be a necessary decision for every full-stack MERN project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding CSS styles</h1>
                </header>
            
            <article>
                
<p><span>When discussing <strong>user interface</strong> (<strong>UI</strong>) implementations for</span> the applications in t<span>his book, we chose not to focus on the details of the CSS styling code applied and instead relied mostly on the default Material-UI stylings. However, given that implementing any UI requires us to consider styling solutions, we will briefly look at some of the options that are available. </span></p>
<p>When it comes to adding CSS styles to the frontend, there are a number of options, each with pros and cons. In the following sections, we will discuss the two most common options, which are external style sheets and inline styles, along with the relatively newer approach of writing CSS in JavaScript, or, more specifically, JSS, which is used in Material-UI components and hence also for the applications in this book.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">External style sheets </h1>
                </header>
            
            <article>
                
<p>External style sheets allow us to define CSS rules in separate files, which can be injected into the necessary view. Placing CSS styles in external style sheets this way was once considered the best practice because it enforced the separation of style and content, allowing reusability and also maintaining modularity if a separate CSS file was created for each component.</p>
<p>However, as web development technologies continue evolving, the demands of better CSS organization and performance are no longer met by this approach. For example, using external style sheets while developing frontend views with React components limits our control over updating styles based on the component state. Moreover, loading external CSS for React applications requires additional webpack configurations with <kbd>css-loader</kbd> and <kbd>style-loader</kbd>.</p>
<p>When applications grow and share multiple style sheets, it also becomes impossible to avoid selector conflicts because CSS has a single global namespace. Hence, though external style sheets may be enough for simple and trivial applications, as an application grows, other options for using CSS become more relevant. In the next section, we will look at the option of adding styles directly inline.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Inline styles</h1>
                </header>
            
            <article>
                
<p>Inline CSS is a style defined and applied directly to individual elements in the view. Although this takes care of some of the problems faced when using external style sheets, such as eliminating the issue of selector conflicts and allowing state-dependent styles, it takes away reusability and introduces a few problems of its own, such as limiting the CSS features that can be applied.</p>
<p>Using only inline CSS for a React-based frontend has important limitations for growing applications, such as poor performance because all of the inline styles are recomputed at each render, and inline styles are slower than class names, to begin with.</p>
<p>Inline CSS may seem like an easy fix in some cases, but it does not serve as a good option for overall usage. In the next section, we will explore the option to add CSS styles using JavaScript, which addresses some of the issues of using inline and external styles. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JavaScript Style Sheets (JSS)</h1>
                </header>
            
            <article>
                
<p>JSS allows us to write CSS styles using JavaScript in a declarative way. This also means that all the features of JavaScript are now available for writing CSS, making it possible to write reusable and maintainable styling code.</p>
<p>JSS works as a JS to CSS compiler that takes JS objects, where keys represent class names and values represent corresponding CSS rules, and then generates the CSS along with scoped class names.</p>
<p>In this way, JSS generates unique class names by default when it compiles JSON representations to CSS, eliminating the chances of selector conflicts that could be faced with external style sheets. Moreover, unlike inline styles, the CSS rules that are defined with JSS can be shared across multiple elements and all CSS features can be used in the definitions.</p>
<p>Material-UI uses JSS to style its components, and, as a result, we used JSS to apply Material-UI themes and also custom CSS to the components developed for the frontend views in all of the applications. Based on the utility of each approach, you can choose to use one or a combination of external style sheets, inline styles, or JSS for styling the frontend of your full-stack application. In the next section, we will review the approaches to and relevance of incorporating server-side rendering of the React frontend in a full-stack MERN application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Selective server-side rendering with data</h1>
                </header>
            
            <article>
                
<p>When we developed the frontend of the base skeleton application in <a href="6f2ca10a-8079-4e3a-9d42-a3db8e85b9d9.xhtml">Chapter 4</a>, <em>Adding a React Frontend to Complete MERN</em>, we integrated basic server-side rendering in order to load client-side routes directly from the browser address bar when the request went to the server. In this server-side rendering implementation, while rendering the React component's server-side, we did not consider loading the data from the database for the components that displayed data. The data only loads in these components when the client-side JavaScript takes over after the initial load of the server side-rendered markup.</p>
<p>We did update this implementation to add server-side rendering with data for the individual media detail pages in the MERN Mediastream application, which was discussed in <a href="d10817c4-6f74-4ef2-90f4-182466e95b33.xhtml">Chapter 12</a>, <em>Customizing the Media Player and Improving the SEO</em>. In this case, we decided to render this specific view with data by injecting data into the server side-generated markup of the React frontend. The reasoning behind this selective server-side rendering with data only for specific views can be based on certain desired behaviors for the view in question, as discussed in the following section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">When is server-side rendering with data relevant?</h1>
                </header>
            
            <article>
                
<p>Implementing server-side rendering with data for all of the React views in an application can get <span>complicated, and will be </span>additional work if we need to consider views with client-side authentication or views consisting of multiple data sources. In many cases, it may be unnecessary to tackle these complexities if the view does not require server-side rendering with data. In order to judge whether a view needs to be server-rendered with data, answer the following questions for the specific view to make your decision:</p>
<ul>
<li style="font-weight: 400">Is it important for the data to be displayed in the initial load of the view when JavaScript may not be available in the browser?</li>
<li style="font-weight: 400">Do the view and its data need to be SEO-friendly?</li>
</ul>
<p>Loading data in the initial load of the page may be relevant from a usability perspective, so it really depends on the use case for the specific view. For SEO, server-side rendering with data will give search engines easier access to the data content in the view; so, if this is crucial for the view in question, then adding server-side rendering with data is a good idea. In the next section, we will go over the varied approaches of composing the React frontend in a full-stack application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using stateful versus pure functional components</h1>
                </header>
            
            <article>
                
<p>While building a UI with React components, composing the views with more stateless functional components can make the frontend code manageable, clean, and easier to test. However, some components will require the state or life cycle Hooks to be more than pure presentational components. In the following sections, we will look at what it takes to build stateful and stateless functional React components, when to use one or the other, and how often.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Stateful React components with ES6 classes or Hooks</h1>
                </header>
            
            <article>
                
<p>We can define stateful React components with ES6 classes or by using Hooks without writing a class. React components defined using ES6 classes have access to life cycle methods, the <kbd>this</kbd> keyword, and can manage state with <kbd>setState</kbd> when building stateful components. Similarly, React components defined with a function can also access some of these features using Hooks, such as managing state with the <kbd>useState</kbd> Hook, in order <span>to build stateful components</span>. </p>
<p>Stateful components allow us to build interactive components that can manage to change data in the state, and propagate any business logic that needs to be applied across the UI. Generally, for complex UIs, stateful components should be higher-level container components that manage the state of the smaller, stateless functional components they are composed of. In comparison, these simpler stateless components can be defined as pure functions, as discussed in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Stateless React components as pure functions</h1>
                </header>
            
            <article>
                
<p>React components can be defined as stateless functional components using the ES6 class syntax or as pure functions. The main idea is that a stateless component does not modify state and only receives props.</p>
<p>The following code defines a stateless component using the ES6 class syntax:</p>
<pre>class Greeting extends React.Component {<br/>  render() {<br/>    return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt; <br/>  }<br/>}</pre>
<p>This component, although defined with a class, does not use state. The same component can also be defined using JavaScript pure functions, as follows:</p>
<pre>function Greeting(props) {<br/>  return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt; <br/>}</pre>
<p>A pure function always gives the same output when given the same input without any side effects. Modeling React components as pure functions enforces the creation of smaller, more defined, and self-contained components that emphasize UI over business logic as there is no state manipulation in these components. These kinds of components are composable, reusable, and easy to debug and test. I<span>n the next section, we will discuss how to</span> combine stateful and stateless components when designing the UI.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Designing the UI with stateful components and stateless functional components</h1>
                </header>
            
            <article>
                
<p>When thinking about the component composition for a UI, you can design the root or a parent component as a stateful component that will contain child components or as the composable components that only receive props and cannot manipulate state. All the state-changing actions and life cycle issues will be handled by the root or parent component, and the changes will be propagated to the child components.</p>
<p>In the applications developed for this book, there is a mixture of stateful higher-level components and smaller stateless components. For example, in the MERN Social application, the <kbd>Profile</kbd> component modifies the state for stateless child components, such as the <kbd>FollowProfileButton</kbd> and <kbd>FollowGrid</kbd> components. There is scope for refactoring some of the larger components that were developed in this book into smaller, more self-contained components, and this should be considered before extending the applications to incorporate more features.</p>
<p>The main takeaway that can be applied to new component designs, or when refactoring existing components, is that as the React application grows and gets more complex, it is better to have more stateless functional components added to higher-level stateful components that are in charge of managing state for the inner components. In the next section, we will briefly discuss popular libraries and patterns that can be utilized on top of React to handle state management across growing React applications.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using Redux or Flux </h1>
                </header>
            
            <article>
                
<p>When React applications begin to grow and become more complex, managing communication between components can become problematic. When using regular React, the way to communicate is to pass down values and callback functions as props to the child components. However, this can be tedious if there are a lot of intermediary components that the callback must pass through. To address these state communication and management-related issues as the React application grows, people turn to use React with libraries and architecture patterns such as Redux and Flux.</p>
<p>It is outside the scope of this book to delve into the details of integrating React with the Redux library or the Flux architecture, but you can consider these options for their growing MERN applications while keeping the following in mind:</p>
<ul>
<li style="font-weight: 400">Redux and Flux utilize patterns that enforce changing states in a React application from a central location. A trick to avoid using Redux or Flux in React applications of manageable sizes is to move all state changes up the component tree to the parent components.</li>
<li style="font-weight: 400">Smaller applications work just as well without Flux or Redux.</li>
</ul>
<div class="packt_tip">You can learn more about using React with Redux at <a href="https://redux.js.org/" target="_blank">https://redux.js.org/</a>, and about using React with Flux at <a href="http://facebook.github.io/flux/">facebook.github.io/flux/</a>.<a href="http://facebook.github.io/flux/"/></div>
<p>You can choose to integrate Flux or Redux based on your application size and complexity. In the next section, we will discuss the security implementations applied to the MERN applications developed in this book and the possible enhancements that could be made.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enhancing security</h1>
                </header>
            
            <article>
                
<p>In the MERN applications developed for this book, we kept the auth-related security implementations simple by using <strong>JSON web tokens</strong> (<strong>JWTs</strong>) as an authentication mechanism and by storing hashed passwords in the user collection. The approaches followed in these implementations are standard practices for adding authentication to a web application. However, there are advanced options available for adding more layers of security, if that is required for certain applications. In the following sections, we will go over the security choices made for building the applications in this book and point to possible enhancements.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JSON web tokens – client-side or server-side storage</h1>
                </header>
            
            <article>
                
<p>With the JWT authentication mechanism, the client side becomes responsible for maintaining the user state. Once the user signs in, the token sent by the server is stored and maintained by the client-side code on browser storage, such as <kbd>sessionStorage</kbd>. Hence, it is also up to the client-side code to invalidate the token by removing it when a user signs out or needs to be signed out. This mechanism works out well for most applications that require minimal authentication to protect access to resources. However, for instances where it may be necessary to track user sign-ins, sign-outs, and to let the server know that a specific token is no longer valid for signing in, just the client-side handling of the tokens is not enough.</p>
<p>For these cases, the implementation discussed for handling JWT tokens on the client side can be extended to storage on the server side as well. In the specific case of keeping track of invalidated tokens, a MongoDB collection can be maintained by the server to store these invalidated tokens as a reference, which is moderately similar to how it is done for storing session data on the server side.</p>
<p>The thing to be cautious about and to keep in mind is that storing and maintaining auth-related information on both the client and server side may be overkill in most cases. Therefore, it is entirely up to the specific use case and the related trade-offs to be considered. In the next section, we will review our options for storing user passwords securely.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Securing password storage</h1>
                </header>
            
            <article>
                
<p>While storing user credentials for authentication in the user collection, we made sure that the original password string provided by the user was never stored directly in the database. Instead, we generated a hash of the password along with a salt value using the <kbd>crypto</kbd> module in Node.</p>
<p>In <kbd>user.model.js</kbd> from our applications, we defined the following functions to generate the hashed <kbd>password</kbd> and <kbd>salt</kbd> values:</p>
<pre>encryptPassword: function(password) {<br/>    if (!password) return '' <br/>    try {<br/>      return crypto<br/>        .createHmac('sha1', this.salt)<br/>        .update(password)<br/>        .digest('hex') <br/>    } catch (err) {<br/>      return '' <br/>    }<br/>  },<br/>  makeSalt: function() {<br/>    return Math.round((new Date().valueOf() * Math.random())) + '' <br/>  }</pre>
<p>With this implementation, every time a user enters a password to sign in, a hash is generated with the salt. If the generated hash matches the stored hash, then the password is correct; otherwise, the password is wrong. So, in order to check whether a password is correct, the salt is required, and therefore it is stored with the user details in the database along with the hash.</p>
<p>This is the standard practice for securing passwords stored for user authentication, but there are other advanced approaches that may be explored if a specific application's security requirements demand it. Some options that can be considered include multi-iteration hashing approaches, other secure hashing algorithms, limiting the number of login attempts per user account, and multi-level authentication with additional steps, such as answering security questions or entering security codes. These options can add more layers of security as needed. In the next section, we will discuss options for adding test code in full-stack React applications, which is essential for building sturdy production-ready applications.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing test code</h1>
                </header>
            
            <article>
                
<p>Though discussing and writing test code is outside the scope of this book, it is a crucial part of developing reliable software. As full-stack JavaScript applications become more mainstream over time, the need for better testing capabilities is producing a good number of testing tools in this ecosystem. In the following sections, we will first look at some of the popular testing tools that are available for testing the different parts of a MERN-based application. Then, to help you get started with writing test code for the MERN applications developed in this book, we will also discuss an example of adding a client-side test to the MERN Social application from <a href="27d3dbdf-0617-4ad8-9dcc-27afa417c174.xhtml">Chapter 5</a>, <em>Growing the Skeleton into a Social Media Application</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing tools for full-stack JavaScript projects</h1>
                </header>
            
            <article>
                
<p><span>A whole range of testing tools is available for incorporating testing and maintaining code quality in full-stack JavaScript projects. These include tools that can help with performing static analysis on the code to maintain readability, and with integrating unit testing, integration testing, and end-to-end testing in MERN-based applications. In the following sections, we will highlight a few of these popular testing tools that can be used with the projects in this book, such as ESLint for static analysis, Cypress for frontend testing, and Jest for comprehensive testing in JavaScript applications.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Static analysis with ESLint</h1>
                </header>
            
            <article>
                
<p><span>A good practice for improving and maintaining code quality is to use a linting tool with your project. Linting tools perform static analysis on the code to find problematic patterns or behaviors that violate specified rules and guidelines.</span> <span>Linting code in a JavaScript project can improve overall code readability and also help you to find syntax errors before the code is executed. For linting in MERN-based projects, you can explore ESLint, which is a JavaScript linting utility that allows developers to create their own lint rules.</span></p>
<div class="packt_tip">You can learn more about using and customizing ESLint at <a href="http://esling.org">eslint.org</a>. You can choose to use the Airbnb JavaScript Style Guide (<a href="https://github.com/airbnb/javascript">github.com/airbnb/javascript</a>) to define your lint rules with <kbd>eslint-config-airbnb</kbd><strong>.</strong></div>
<p>You can configure ESLint in your preferred editor and make it a seamless part of your development workflow. This will help you to maintain standards in your code while you are writing it. In the next section, we will take a look at Cypress, which can help to test any code that runs in the browser.   </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">End-to-end testing with Cypress</h1>
                </header>
            
            <article>
                
<p>Cypress provides a complete set of tools for testing the frontend of modern web applications. Using Cypress, we can write end-to-end tests, unit tests, and integration tests for the frontend of our MERN-based applications. Cypress also provides its own locally installed test runner, allowing us to write and run tests, and debug in real time in the browser as we build the application.  </p>
<div class="packt_tip">You can learn more about using Cypress<span> at </span><a href="https://www.cypress.io/">cypress.io</a> to get started with setting up end-to-end testing for JavaScript applications in the browser.</div>
<p>Performing UI testing with Cypress will allow you to ship out your projects more confidently, as you will be able to catch more bugs early on before they are encountered by the end users of the application. In the next section, we will discuss Jest, which can be used to add tests to any JavaScript code base. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Comprehensive testing with Jest</h1>
                </header>
            
            <article>
                
<p>Jest is a comprehensive testing framework for JavaScript. Although it has been more commonly known for testing React components, it can be used for general-purpose testing with any JavaScript library or framework. Among the many JavaScript testing solutions in Jest, it provides support for mocking and snapshot testing, comes with an assertion library, and tests in Jest are written in the <strong>Behavior-Driven Development</strong> (<strong>BDD</strong>) style. </p>
<div class="packt_tip">To learn more about Jest, read the documentation at <a href="https://facebook.github.io/jest/docs/en/getting-started.html" target="_blank">https://facebook.github.io/jest/docs/en/getting-started.html</a>.</div>
<p><span>Besides testing the React components, Jest can be also be adapted to write test code for the Node-Express-Mongoose-based backend as required. Hence, it is a solid testing option to add test code for MERN applications. In the next section, we will explore how you can use Jest to add a test to the MERN Social application, which was developed in  <a href="27d3dbdf-0617-4ad8-9dcc-27afa417c174.xhtml">Chapter 5</a>, <em>Growing the Skeleton into a Social Media Application</em>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding a test to the MERN Social application</h1>
                </header>
            
            <article>
                
<p>In order to <span>demonstrate how to get started with adding tests to MERN applications</span>, we will set up Jest and use it to add a client-side test to the MERN Social application. Before defining a test case, followed by writing and running the corresponding test code, first, we will set up for testing by installing the necessary packages, defining the test run script, and creating a folder for the test code, as discussed in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing the packages</h1>
                </header>
            
            <article>
                
<p>In order to set up Jest and integrate the test code with our projects, we first need to install the relevant Node packages. The following packages will be required in order to write the test code and run the tests:</p>
<ul>
<li style="font-weight: 400"><kbd>jest</kbd>: To include the Jest testing framework</li>
<li style="font-weight: 400"><kbd>babel-jest</kbd>: To compile JS code for Jest</li>
<li style="font-weight: 400"><kbd>react-test-renderer</kbd>: To create a snapshot of the DOM tree rendered by a React DOM without using a browser</li>
</ul>
<p>To install these packages as <kbd>devDependencies</kbd>, run the following <kbd>yarn</kbd> command from the command line:</p>
<pre><strong>yarn add --dev jest babel-jest react-test-renderer</strong></pre>
<p>Once these packages are installed, we can start adding tests after configuring the test runner script, as discussed in the next section. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining the script to run tests</h1>
                </header>
            
            <article>
                
<p>In order to run any test code that we write using Jest, we will define a script command to run the tests. We will update the run scripts defined in <kbd>package.json</kbd> in order to add a script for running tests with the <kbd>jest</kbd> command, as shown in the following code:</p>
<pre>  "scripts": {<br/>    "test": "jest"<br/>  }</pre>
<p>With this script defined, if we run <kbd>yarn test</kbd> from<span> the command line, </span>it will prompt Jest to find the test code in the application folders and run the tests. In the next section, we will add the folder that will contain the test code files for the project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding a tests folder</h1>
                </header>
            
            <article>
                
<p>To add the client-side test in the MERN Social application, we will create a folder, called <kbd>tests</kbd>, in the client folder, which will contain test files relevant to testing the React components. When the test command is run, Jest will look for the test code in these files.</p>
<p>The test case for this example will be a test on the <kbd>Post</kbd> component in the frontend of the MERN Social application, and we will add tests for the <kbd>Post</kbd> component in a file called <kbd>post.test.js</kbd>. This file will be placed in the <kbd>tests</kbd> folder. Now that we have a file ready for adding the test code, in the next section, we will demonstrate how to add an example test case.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding the test</h1>
                </header>
            
            <article>
                
<p>For the MERN Social application, we will write a test to check whether the delete button on a post is only visible when the signed-in user is also the creator of the post. This means that the delete button will only be a part of the rendered Post view if the <kbd>_id</kbd> of the authenticated user is the same as the <kbd>postedby</kbd> value of the post data being rendered.</p>
<p>In order to implement this test case, we will add code that takes care of the following:</p>
<ul>
<li style="font-weight: 400">Defines dummy data for a post and an <kbd>auth</kbd> object containing authenticated user details</li>
<li style="font-weight: 400">Mocks the methods in <kbd>auth-helper.js</kbd></li>
<li style="font-weight: 400">Defines the test, and, within the test definition, does the following:
<ul>
<li style="font-weight: 400">Declares the <kbd>post</kbd> and <kbd>auth</kbd> variables</li>
<li style="font-weight: 400">Sets the return value of the mocked <kbd>isAuthenticated</kbd> method to the dummy <kbd>auth</kbd> object</li>
<li style="font-weight: 400">Uses <kbd>renderer.create</kbd> to create the <kbd>Post</kbd> component with the required dummy props passed and wrapped in <kbd>MemoryRouter</kbd> to provide the props related to <kbd>react-router</kbd></li>
<li style="font-weight: 400">Generates and matches snapshots</li>
</ul>
</li>
</ul>
<p>The code in <kbd>post.test.js</kbd> to incorporate the steps described for this specific test will be as follows:</p>
<pre>import auth from './../auth/auth-helper.js'<br/>import Post from './../post/Post.js'<br/>import React from 'react'<br/>import renderer from 'react-test-renderer'<br/>import { MemoryRouter } from 'react-router-dom'<br/><br/>jest.mock('./../auth/auth-helper.js') <br/><br/>const dummyPostObject = {"_id":"5a3cb2399bcc621874d7e42f",<br/>                         "postedBy":{"_id":"5a3cb1779bcc621874d7e428",<br/>                         "name":"Joe"}, "text":"hey!",<br/>                         "created":"2017-12-22T07:20:25.611Z",<br/>                         "comments":[], "likes":[]} <br/>const dummyAuthObject = {user: {"_id":"5a3cb1779bcc621874d7e428",<br/>                                "name":"Joe",<br/>                                "email":"abc@def.com"}} <br/><br/>test('delete option visible only to authorized user', () =&gt; {<br/>  const post = dummyPostObject <br/>  const auth = dummyAuthObject <br/><br/>  auth.isAuthenticated.mockReturnValue(auth) <br/><br/>  const component = renderer.create(<br/>     &lt;MemoryRouter&gt;<br/>         &lt;Post post={post} key={post._id} &gt;&lt;/Post&gt;<br/>     &lt;/MemoryRouter&gt;<br/>  ) <br/><br/>  let tree = component.toJSON() <br/>  expect(tree).toMatchSnapshot() <br/>}) </pre>
<p>In this code, we first defined dummy posts and <kbd>auth</kbd> objects, and then added the test case for checking the visibility of the delete option. In this test case, we mocked the <kbd>isAuthenticated</kbd> method and rendered the <kbd>Post</kbd> component using the dummy post data. Then, we generated a snapshot with this rendered component, which will be matched with the expected snapshot. In the next section, we will discuss how generated snapshots are compared in this test. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generating a snapshot of the correct Post view</h1>
                </header>
            
            <article>
                
<p>The first time this test is run, we will provide it with the values required to generate the correct snapshot of the Post view. The correct snapshot for this test case will contain the delete button when the <kbd>user._id</kbd> of the <kbd>auth</kbd> object is equal to the <kbd>postedBy</kbd> value of the <kbd>post</kbd> object. This snapshot is generated when the test is run for the first time, and it will be used for comparison in future test executions.</p>
<p><span>This kind of snapshot testing in Jest basically records snapshots of rendered component structures to </span><span>compare them to future renderings. When the recorded snapshot and the current rendering don't match, the test fails, indicating that something has changed. In the next section, we will go over the steps of running the test and checking the test output.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running and checking the test</h1>
                </header>
            
            <article>
                
<p>In the code that we added to the <kbd>post.test.js</kbd> file, the dummy <kbd>auth</kbd> object and the <kbd>post</kbd> object refer to the same user; therefore, running this test in the command line will prompt Jest to generate a snapshot that will contain the delete option and also pass the test.</p>
<p>To run the test, go into the project folder from the command line:</p>
<pre><strong>yarn test</strong></pre>
<p>The test output generated when this command runs will show that the test passed, as portrayed in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-974 image-border" src="assets/9a50bd38-3fca-4012-abb8-168378bc6265.png" style="width:32.33em;height:11.33em;"/></div>
<p><span>The recorded snapshot that is generated, when this test runs successfully for the first time, is added automatically to a</span> <kbd>_snapshots_</kbd> <span>folder in the <kbd>tests</kbd> folder. This snaps</span>hot represents th<span>e state where the delete button is rendered in the view since the authenticated user is also the creator of the post. </span></p>
<p>We can now check whether the test actually fails when the component is rendered with an authenticated user that is not the creator of the post. To perform this check, we will update the dummy data objects by changing the <kbd>user._id</kbd>, so it does not match the <kbd>postedBy</kbd> value, and then run the test again. This will give us a failed test, as the current rendering will no longer have a delete button that is present in the recorded snapshot.</p>
<p>As shown in the following test log, the test fails and indicates that the rendered tree does not match the recorded snapshot since the elements representing the delete button are missing in the received value:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-975 image-border" src="assets/255aafac-37de-4e30-a94b-99ccd2fa2fa7.png" style="width:31.08em;height:24.67em;"/></div>
<p>We have a client-side test for checking whether a signed-in user can view the delete button on their posts. Using this setup, more tests can be added for the MERN application utilizing the capabilities of Jest.</p>
<p><span>Writing test code will make the application you develop reliable and also help ensure code quality. Using tools such as ESLint, Cypress, and Jest, we can incorporate different ways of ensuring the overall quality of MERN-based applications. In the next section, we will move on to discussing ways to optimize the bundling of the application code.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Optimizing the bundle size</h1>
                </header>
            
            <article>
                
<p>As you develop and grow a MERN application, chances are the size of the bundles produced with webpack will also grow, especially if large third-party libraries are used. Larger bundle sizes will affect performance and increase the initial load time of the application. We can make changes in the code to ensure we don't end up with large bundles and also utilize features packed in webpack to help optimize bundling. </p>
<div class="packt_infobox">Before going into the code to update it for bundle size optimization, you can also get familiar with the default optimization options that are part of webpack. In the MERN applications, we used the <kbd>mode</kbd> config to utilize the default settings for both development and production mode. To view an overview of the options that are available, please refer to the article at <a href="https://medium.com/webpack/webpack-4-mode-and-optimization-5423a6bc597a" target="_blank">https://medium.com/webpack/webpack-4-mode-and-optimization-5423a6bc597a</a>.</div>
<p><span>In the following section, we will highlight concepts such as code splitting and dynamic imports, which can give us control over producing smaller bundles and decreasing load time.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Code splitting</h1>
                </header>
            
            <article>
                
<p>Instead of loading all the code at once in one bundle, we can use the code splitting feature supported by webpack to lazy-load parts of the application code as currently needed by the user. After we modify the application code to introduce code-splitting, webpack can create multiple bundles rather than one large bundle. These bundles can be loaded dynamically at runtime, allowing us to improve the performance of the application.</p>
<div class="packt_tip">To learn more about code splitting support in webpack and how to make necessary changes to the setup and configuration, take a look at the guidelines in the documentation at <a href="https://webpack.js.org/guides/code-splitting/" target="_blank"><span>https://webpack.js.org/guides/code-splitting/</span></a>.</div>
<p>There are several ways to introduce code splitting for the application code, but the most important syntax you will come across for this purpose is the dynamic <kbd>import()</kbd>. In the next section, we will look at how to use <kbd>import()</kbd> with our MERN applications.<span class="Apple-converted-space"> </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dynamic import()</h1>
                </header>
            
            <article>
                
<p>Dynamic <kbd>import()</kbd> is a function-like version of the regular import, and it enables the dynamic loading of JS modules. Using <kbd>import(moduleSpecifier)</kbd> will return a promise for the module namespace object of the requested module. When using regular static imports, we import a module at the top of the code and then use it in the code as follows:</p>
<pre>import {<span class="Apple-converted-space">  </span>convert } from './metric'<br/>...<br/>console.log(convert('km', 'miles', 202))</pre>
<p>In contrast, if we were to use dynamic <kbd>import()</kbd> instead of adding the static import at the beginning, the code would look like this:</p>
<pre>import('./metric').then({ convert } =&gt; { <br/>    console.log( convert('km', 'miles', 202) ) <br/>})</pre>
<p>This allows us to import and load the module when the code requires it. While bundling the application code, webpack will treat calls to <kbd>import()</kbd> as split points and automatically start code splitting by placing the requested module and its children into a separate chunk from the main bundle.</p>
<p>In order to optimize the bundling of the frontend React code by applying code splitting at a given component, we need to pair dynamic <kbd>import()</kbd> with React Loadable <span>– </span>a higher-order component for loading components with promises.<span class="Apple-converted-space"> As an example, we will look at the shopping cart developed in <a href="" target="_blank">Chapter 8</a>, <em>Extending the Marketplace for Orders and Payments</em>. While building the interface of the cart, we composed the <kbd>Cart</kbd> component by importing and </span>adding the <kbd>Checkout</kbd> component to the view, as follows:</p>
<pre>import Checkout from './Checkout'<br/>class Cart extends Component {<br/>    ...<br/>    render(){<br/>        ...<br/>        &lt;Checkout/&gt;<br/>    }<br/>    ...<br/>}</pre>
<p>To introduce code splitting here and import the <kbd>Checkout</kbd> component dynamically, we can replace the static import at the beginning with a <kbd>Loadable</kbd> Checkout, as shown in the following code:</p>
<pre>import Loadable from 'react-loadable'<br/>const Checkout = Loadable({<br/>  loader: () =&gt; import('./Checkout'),<br/>  loading: () =&gt; &lt;div&gt;Loading...&lt;/div&gt;,<br/>})</pre>
<p>Making this change and using webpack to build the code again will produce a <kbd>bundle.js</kbd> file of reduced size, and generate another smaller bundle file representing the split code, which will now only load when the <kbd>Cart</kbd> component is rendered.</p>
<div class="packt_tip">Route-based code splitting is also another option besides using dynamic imports. It can be an effective approach for introducing code splitting in React apps that use routes to load components in the view. To learn more about implementing code splitting, specifically with React Router, view the article at <a href="https://tylermcginnis.com/react-router-code-splitting/" target="_blank">https://tylermcginnis.com/react-router-code-splitting/</a>.</div>
<p><span>We can apply code-splitting mechanisms across our application code as required. The thing to keep in mind is that </span><span>effective</span><span> code splitting will depend on using it correctly and applying it at the right places in the code – places that will benefit in optimization from resource-load prioritization. In the next section, we will outline the steps that can be repeated to add new features to the MERN applications developed in this book.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Extending the applications</h1>
                </header>
            
            <article>
                
<p>Throughout the chapters of this book, as we developed each application, we added features by extending the existing code in a common and repeatable number of steps. In this final section, we will review those steps, setting a guideline for adding more features to the current versions of the applications. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Extending the server code</h1>
                </header>
            
            <article>
                
<p>For a specific feature that will require data persistence and APIs to allow the views to manipulate the data, we can start by extending the server code and adding the necessary models, routes, and controller functions, as outlined in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding a model</h1>
                </header>
            
            <article>
                
<p>For the data persistence aspect of the feature, design the data model considering the fields and values that need to be stored. Then, define and export a Mongoose schema for this data model in a separate file, and place it in the <kbd>server/models</kbd> folder. With the data structure defined and ready for the database, you can move on to adding the API endpoints for manipulating this data, as discussed next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing the APIs</h1>
                </header>
            
            <article>
                
<p><span>In order to manipulate and access the data that will be stored in the database based on the model</span>, you need to design the APIs relevant for the desired feature. To start implementing the APIs, you have to add the corresponding controller methods and route declarations, as discussed in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding controllers</h1>
                </header>
            
            <article>
                
<p>With the APIs decided, add the corresponding controller functions that will respond to the requests to these APIs in a separate file in the <kbd>server/controllers</kbd> folder. The controller functions in this file should access and manipulate the data for the model defined for this feature. Next, we will look at how to declare the routes that will invoke these controller methods when the requests come in.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding routes</h1>
                </header>
            
            <article>
                
<p>To complete the implementation of the backend APIs, corresponding routes need to be declared and mounted on the Express app. In a separate file in the <kbd>server/routes</kbd> folder, first, declare and export the routes for these APIs, assigning the relevant controller functions that should be executed when a specific route is requested. Then, load these new routes on the Express app in the <kbd>server/express.js</kbd> file, just like the other existing routes in the application.</p>
<p>This will produce a working version of the new backend APIs that can be run and checked from a REST API client application. Then, these APIs can be used in the frontend views for the feature being developed, which you will add by extending the client code, as discussed in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Extending the client code</h1>
                </header>
            
            <article>
                
<p>On the client side, first, design the views required for the feature, and determine how these views will incorporate user interaction with the data relevant to the feature. Then, add the fetch API code to integrate with the new backend APIs, define the new components that represent these new views, and update the existing code to include these new components in the frontend of the application, as outlined in the following sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding the API fetch methods</h1>
                </header>
            
            <article>
                
<p>Before adding the fetch methods that will make calls to the backend APIs, you will determine a location for placing the new frontend code. In the client folder, create a new folder to house the components and helper code relevant to the feature module being developed. Then, to integrate the new backend APIs with the frontend of the application, define and export the corresponding fetch methods in a separate file in this new components folder. Finally, you can populate this folder with the React components that will be the frontend of this feature, as discussed in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding components</h1>
                </header>
            
            <article>
                
<p>To start adding the UI for the feature, you can create and export new React components that represent views for the desired feature in separate files in the new folder. If authentication is required, you can integrate it into these new components using the existing auth-helper methods. Once the React components are implemented, they need to be loaded into the main application view, as discussed in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Loading new components</h1>
                </header>
            
            <article>
                
<p>In order to incorporate these new components into the frontend, the components either need to be added into existing components or rendered at their own client-side routes.</p>
<p>If these new components need to be rendered at individual routes, update the <kbd>MainRouter.js</kbd> code to add new routes that load these components at given URL paths. Then, these URLs can be used as links to load the components from other views in the application, or directly by visiting the URL from the browser address bar. </p>
<p>However, if the new components need to become part of existing views, then import the components into the existing components to add them to the view as desired.</p>
<p>The new components can also be linked with existing components, such as in the <kbd>Menu</kbd> component, by linking to new components that were added with individual routes.</p>
<p>With the components integrated and connected to the backend, the new feature implementation is complete. These steps can be repeated to add on even more new features to the existing MERN-based applications built throughout this book.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this final chapter, we reviewed and elaborated on some of the best practices that we used while building the MERN applications in this book, highlighted areas of improvement, gave pointers to address issues that may crop up when applications grow, and, finally, set down steps to continue developing more features into the existing applications.</p>
<p>We saw that modularizing the application's code structure helped to extend the application easily, choosing to use JSS over inline CSS and external style sheets kept the styling code contained and easy to work with, and only implementing server-side rendering for specific views as required kept unnecessary complications out of the code.</p>
<p>We discussed the benefits of creating fewer stateful components that are composed of smaller and more defined stateless functional components, and how this can be applied while refactoring existing components or designing new components to extend the applications. For growing applications that may run into issues with managing and communicating state across hundreds of components, we pointed to options such as Redux and Flux, which may be considered to address these issues.</p>
<p>For applications that may have higher demands for stricter security enforcement, we looked back at our existing implementation of user authentication with JWT and password encryption and discussed possible extensions for improved security.</p>
<p>We highlighted testing tools such as ESLint, Cypress, and Jest. Then, we used Jest to demonstrate how test code can be added to the MERN applications and discussed how good practices, such as writing test code and using a linting tool, can improve code quality besides ensuring reliability in an application.</p>
<p>We also looked at bundle optimization features, such as code splitting, that can help to improve performance by reducing the initial bundle size, and by lazy-loading parts of the application as required.</p>
<p>Finally, we reviewed and set down the repeatable steps that were used throughout the book, which you can use as a guideline moving forward to extend the MERN applications by adding more features as desired.</p>


            </article>

            
        </section>
    </body></html>