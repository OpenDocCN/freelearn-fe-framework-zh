<html><head></head><body>
<div id="_idContainer011">
<h1 class="chapter-number" id="_idParaDest-28"><a id="_idTextAnchor039"/><span class="koboSpan" id="kobo.1.1">2</span></h1>
<h1 id="_idParaDest-29"><a id="_idTextAnchor040"/><span class="koboSpan" id="kobo.2.1">Using Libraries for Large-Scale Applications</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Before you start learning how to use different libraries to develop large-scale and enterprise-ready applications with Vue.js 3, you need to understand these individual libraries and the various features they are bundled with to help you navigate through building scalable and </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">enterprise-ready applications.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, we will cover the essential aspects of Vuex, Axios, and Vue Router and how to integrate them with Vue 3 to develop an enterprise application. </span><span class="koboSpan" id="kobo.5.2">This background information will put you in a better position to grasp the terms and concepts of these libraries and help you understand how to build and scale an </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">enterprise-ready application.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">We will cover the following key topics in </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">Exploring </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">large-scale Vuex</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Structuring with the </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">repository pattern</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Creating a </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">repository folder</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Structuring Vue navigation with </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">Vue Router</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.17.1">Once you’ve mastered each of these topics, you will be ready to get started with building your first enterprise-ready application with </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">Vue 3.</span></span></p>
<h1 id="_idParaDest-30"><a id="_idTextAnchor041"/><span class="koboSpan" id="kobo.19.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.20.1">To get started with this chapter, we recommend reading through </span><a href="B17237_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.21.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.22.1">, </span><em class="italic"><span class="koboSpan" id="kobo.23.1">Getting Started with Vue.js 3</span></em><span class="koboSpan" id="kobo.24.1">, and its overview of Vue 3 and the Composition API, which will be intensively used in </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">this chapter.</span></span></p>
<h1 id="_idParaDest-31"><a id="_idTextAnchor042"/><span class="koboSpan" id="kobo.26.1">Exploring large-scale Vuex</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.27.1">Vuex</span></strong><span class="koboSpan" id="kobo.28.1"> is the state</span><a id="_idIndexMarker026"/><span class="koboSpan" id="kobo.29.1"> management library for Vue applications. </span><span class="koboSpan" id="kobo.29.2">It serves as a central store for all the components in a Vue application. </span><span class="koboSpan" id="kobo.29.3">It is also a library implementation tailored specifically to Vue.js to take advantage of its granular reactivity system for </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">efficient updates.</span></span></p>
<p><span class="koboSpan" id="kobo.31.1">Significant benefits can be derived when using Vuex for the state management of a Vue application. </span><span class="koboSpan" id="kobo.31.2">Still, it can easily be misused and overwhelmed if not adequately structured—especially when building a large-scale enterprise application—due to the size of the project and the number of components and features that will be introduced in </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">the project.</span></span></p>
<p><span class="koboSpan" id="kobo.33.1">To tackle this structure problem, we will introduce you to different structures to arrange your Vuex store and the law of predictability discussed in </span><a href="B17237_04.xhtml#_idTextAnchor112"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.34.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.35.1">, </span><em class="italic"><span class="koboSpan" id="kobo.36.1">Architecture for Large-Scale Web Applications</span></em><span class="koboSpan" id="kobo.37.1">, to accommodate large-scale </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">Vue applications.</span></span></p>
<p><span class="koboSpan" id="kobo.39.1">In this section, we will discuss Vuex states, getters, mutations, </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">and actions.</span></span></p>
<p><span class="koboSpan" id="kobo.41.1">Practically, the usual way to structure </span><a id="_idIndexMarker027"/><span class="koboSpan" id="kobo.42.1">your Vuex store is to have every piece of code inside a single </span><strong class="source-inline"><span class="koboSpan" id="kobo.43.1">index.js</span></strong><span class="koboSpan" id="kobo.44.1"> file called a </span><strong class="bold"><span class="koboSpan" id="kobo.45.1">single state tree</span></strong><span class="koboSpan" id="kobo.46.1">. </span><span class="koboSpan" id="kobo.46.2">This method works perfectly for a small project and helps to avoid navigating through different files to find a </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">single method.</span></span></p>
<p><span class="koboSpan" id="kobo.48.1">However, when developing an enterprise project using Vuex, using single state trees becomes very bloated and difficult </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">to maintain.</span></span></p>
<p><span class="koboSpan" id="kobo.50.1">To reduce this large file and split the file into </span><a id="_idIndexMarker028"/><span class="koboSpan" id="kobo.51.1">different features, Vuex allows us to divide our store into </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.52.1">Vuex modules</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.54.1">Before we dive in, the Vue community has introduced a new state management system called Pinia that fixes the problems of Vuex and is directly compatible with Vue 3. </span><span class="koboSpan" id="kobo.54.2">As of the time of writing, Pinia was still in the development and beta phase. </span><span class="koboSpan" id="kobo.54.3">You can learn more about Pinia and how to integrate it into your Vue 3 application </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">here: </span></span><a href="https://pinia.vuejs.org/"><span class="No-Break"><span class="koboSpan" id="kobo.56.1">https://pinia.vuejs.org</span><span id="_idTextAnchor043"/><span class="koboSpan" id="kobo.57.1">/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.58.1">.</span></span></p>
<h2 id="_idParaDest-32"><a id="_idTextAnchor044"/><span class="koboSpan" id="kobo.59.1">Vuex modules</span></h2>
<p><span class="koboSpan" id="kobo.60.1">A Vuex </span><a id="_idIndexMarker029"/><span class="koboSpan" id="kobo.61.1">module is a way to </span><a id="_idIndexMarker030"/><span class="koboSpan" id="kobo.62.1">split our store based on features, where each module can contain its states, getters, actions, mutations, and even </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">nested modules.</span></span></p>
<p><span class="koboSpan" id="kobo.64.1">This method allows us to split our store into features and create different files and folders to arrange the </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">store correctly.</span></span></p>
<p><span class="koboSpan" id="kobo.66.1">We’ll learn how we can split our store into features in the </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">next subsection.</span></span></p>
<p><span class="koboSpan" id="kobo.68.1">Assuming our </span><em class="italic"><span class="koboSpan" id="kobo.69.1">Pinterest</span></em><span class="koboSpan" id="kobo.70.1"> application </span><a id="_idIndexMarker031"/><span class="koboSpan" id="kobo.71.1">will have different states such as photos, users, comments, and so on, we can split the store into separate modules as opposed to having it in a </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">single </span><a id="_idTextAnchor045"/><span class="koboSpan" id="kobo.73.1">file.</span></span></p>
<h3><span class="koboSpan" id="kobo.74.1">Using Vuex modules</span></h3>
<p><span class="koboSpan" id="kobo.75.1">As stated in the previous</span><a id="_idIndexMarker032"/><span class="koboSpan" id="kobo.76.1"> section, using Vuex modules comes with great benefits, and we will stick to it throughout this book. </span><span class="koboSpan" id="kobo.76.2">Firstly, let’s look at the folder structure of our Vuex </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">module store:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.78.1">
const moduleA = {
  state: () =&gt; ({ ... </span><span class="koboSpan" id="kobo.78.2">}),
  mutations: { ... </span><span class="koboSpan" id="kobo.78.3">},
  actions: { ... </span><span class="koboSpan" id="kobo.78.4">},
  getters: { ... </span><span class="koboSpan" id="kobo.78.5">}
}
const moduleB = {
  state: () =&gt; ({ ... </span><span class="koboSpan" id="kobo.78.6">}),
  mutations: { ... </span><span class="koboSpan" id="kobo.78.7">},
  actions: { ... </span><span class="koboSpan" id="kobo.78.8">}
}
const store = createStore({
  modules: {
    a: moduleA,
    b: moduleB
  }
})
store.state.a // -&gt; `moduleA`'s state
store.state.b // -&gt; `moduleB`'s state</span></pre>
<p><span class="koboSpan" id="kobo.79.1">As you can see in the preceding code block, we have created different modules to wrap our Vuex state, actions, and mutations respectively. </span><span class="koboSpan" id="kobo.79.2">It can be useful to structure our project into </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">different features.</span></span></p>
<p><span class="koboSpan" id="kobo.81.1">Now that we </span><a id="_idIndexMarker033"/><span class="koboSpan" id="kobo.82.1">understand how to structure our Vuex store for enterprise projects, let’s discuss how to access and manage the store from a component in Vue in the </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">next s</span><a id="_idTextAnchor046"/><span class="koboSpan" id="kobo.84.1">ection.</span></span></p>
<h2 id="_idParaDest-33"><a id="_idTextAnchor047"/><span class="koboSpan" id="kobo.85.1">The Vuex state</span></h2>
<p><span class="koboSpan" id="kobo.86.1">First and most importantly, let’s discuss states and how we can manage the state of a module </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">Vuex store.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.88.1">The Vuex state</span></strong><span class="koboSpan" id="kobo.89.1"> is the data you stored inside your Vuex store and can be accessed anywhere in your </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">Vue application.</span></span></p>
<p><span class="koboSpan" id="kobo.91.1">The Vuex state follows the </span><a id="_idIndexMarker034"/><span class="koboSpan" id="kobo.92.1">single-state-tree pattern. </span><span class="koboSpan" id="kobo.92.2">This single object contains all your application-level states. </span><span class="koboSpan" id="kobo.92.3">It serves as the “single source of truth”. </span><span class="koboSpan" id="kobo.92.4">But, since we’re adopting modularity to manage our enterprise-ready application, we are going only to learn how to access and manage our </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">module states.</span></span></p>
<p><span class="koboSpan" id="kobo.94.1">The following code snippet shows how to create a simple </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">Vuex state:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.96.1">
// initial state
const state = () =&gt; ({
  photos: [],
})</span></pre>
<p><span class="koboSpan" id="kobo.97.1">In addition, you can access a Vuex store outside of components. </span><span class="koboSpan" id="kobo.97.2">For example, you access Vuex inside of Vue services, helper files, and so on. </span><span class="koboSpan" id="kobo.97.3">However, in the next section, we will explore different ways</span><a id="_idIndexMarker035"/><span class="koboSpan" id="kobo.98.1"> to access our state in </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">the components.</span></span></p>
<h3><span class="koboSpan" id="kobo.100.1">Accessing state withou</span><a id="_idTextAnchor048"/><span class="koboSpan" id="kobo.101.1">t mapping</span></h3>
<p><span class="koboSpan" id="kobo.102.1">Assuming this is our store for</span><a id="_idIndexMarker036"/><span class="koboSpan" id="kobo.103.1"> all photos in our </span><em class="italic"><span class="koboSpan" id="kobo.104.1">Pinterest</span></em><span class="koboSpan" id="kobo.105.1"> application and we have that </span><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">photos</span></strong><span class="koboSpan" id="kobo.107.1"> state, how do we access it in </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">our components?</span></span></p>
<p><span class="koboSpan" id="kobo.109.1">To access the </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">Photos</span></strong><span class="koboSpan" id="kobo.111.1"> array, we will use our module name with the store name, as shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.113.1">
const Photos = {
  template: `&lt;div v-for="(photo, index) in photos"
              :key="index"&gt; &lt;img :src="photo.url"&gt;&lt;/div&gt;`,
  computed: {
    photos () {
      return this.$store.photos.state.photos
    }
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.114.1">The previous code snippet shows how to access a moduled store by creating a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">Photos</span></strong><span class="koboSpan" id="kobo.116.1"> component and displaying all the photos in the </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">photo’s state.</span></span></p>
<p><span class="koboSpan" id="kobo.118.1">To access the </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">Photos</span></strong><span class="koboSpan" id="kobo.120.1"> state array, we used the name of the module it belongs to and accessed the state property </span><em class="italic"><span class="koboSpan" id="kobo.121.1">before</span></em><span class="koboSpan" id="kobo.122.1"> the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">photos</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.124.1"> array.</span></span></p>
<p><span class="koboSpan" id="kobo.125.1">Next, we’re going to explore how to access the Vuex state using the </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">mapping</span><a id="_idTextAnchor049"/><span class="koboSpan" id="kobo.127.1"> approach.</span></span></p>
<h3><span class="koboSpan" id="kobo.128.1">Accessing the state with mapping</span></h3>
<p><span class="koboSpan" id="kobo.129.1">The best </span><a id="_idIndexMarker037"/><span class="koboSpan" id="kobo.130.1">way to access </span><a id="_idIndexMarker038"/><span class="koboSpan" id="kobo.131.1">the store is to use </span><strong class="bold"><span class="koboSpan" id="kobo.132.1">Vuex state maps</span></strong><span class="koboSpan" id="kobo.133.1">, (</span><a href="https://vuex.vuejs.org/guide/state.html#the-mapstate-helper"><span class="koboSpan" id="kobo.134.1">https://vuex.vuejs.org/guide/state.html#the-mapstate-helper</span></a><span class="koboSpan" id="kobo.135.1">), which we will use throughout this book. </span><span class="koboSpan" id="kobo.135.2">You c</span><a href="https://vuex.vuejs.org/"><span class="koboSpan" id="kobo.136.1">an go to the official Vuex </span></a><span class="koboSpan" id="kobo.137.1">documentation (</span><a href="https://vuex.vuejs.org/"><span class="koboSpan" id="kobo.138.1">https://vuex.vuejs.org/</span></a><span class="koboSpan" id="kobo.139.1">) to </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">learn</span></span><span class="No-Break"><a id="_idIndexMarker039"/></span><span class="No-Break"><span class="koboSpan" id="kobo.141.1"> more.</span></span></p>
<p><span class="koboSpan" id="kobo.142.1">Using Vuex mappers is great when your components need to make use of multiple store-state properties or getters. </span><span class="koboSpan" id="kobo.142.2">Declaring all these states and getters can get repetitive and verbose, and that’s exactly what a Vuex mapper tends </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">to solve.</span></span></p>
<p><span class="koboSpan" id="kobo.144.1">Let’s take an example of</span><a id="_idIndexMarker040"/><span class="koboSpan" id="kobo.145.1"> creating a simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">Photos</span></strong><span class="koboSpan" id="kobo.147.1"> component and using the Vuex state to display </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">different images:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.149.1">
import { mapState } from 'vuex'
const Photos = {
  template: `&lt;div v-for="(photo, index) in photos"
              :key="index"&gt; &lt;img :src="photo.url"&gt;&lt;/div&gt;`,
  computed: mapState({
    photos: state =&gt; state.photos.photos,
    }
  })
}</span></pre>
<p><span class="koboSpan" id="kobo.150.1">The preceding snippet creates a </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">Photos</span></strong><span class="koboSpan" id="kobo.152.1"> component, loops through the data from our Vuex state, and displays the images in </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">the store.</span></span></p>
<p><span class="koboSpan" id="kobo.154.1">There you </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">have it.</span></span></p>
<p><span class="koboSpan" id="kobo.156.1">We will use this method in further discussion with actions, mutations, and getters. </span><span class="koboSpan" id="kobo.156.2">You should </span><em class="italic"><span class="koboSpan" id="kobo.157.1">never</span></em><span class="koboSpan" id="kobo.158.1"> forget the names of </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">your modules.</span></span></p>
<p><span class="koboSpan" id="kobo.160.1">We now have a fair understanding of the Vuex state and modules and how we will structure our enterprise and large-scale Vuex application for easy maintainability </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">and accessibility.</span></span></p>
<p><span class="koboSpan" id="kobo.162.1">Let’s discuss getters and how we can manipulate our Vuex state using </span><strong class="bold"><span class="koboSpan" id="kobo.163.1">Vuex getters</span></strong><span class="koboSpan" id="kobo.164.1"> and map getters in the</span><a id="_idTextAnchor050"/> <span class="No-Break"><span class="koboSpan" id="kobo.165.1">next section.</span></span></p>
<h2 id="_idParaDest-34"><a id="_idTextAnchor051"/><span class="koboSpan" id="kobo.166.1">Vuex getters</span></h2>
<p><span class="koboSpan" id="kobo.167.1">Vuex getters are very </span><a id="_idIndexMarker041"/><span class="koboSpan" id="kobo.168.1">useful for manipulating the Vuex state. </span><span class="koboSpan" id="kobo.168.2">Sometimes, you might want to filter or sort the Vuex state before returning the data to </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">the components.</span></span></p>
<p><span class="koboSpan" id="kobo.170.1">Vuex allows us to create getters that manipulate the state just as computed properties in Vue will do. </span><span class="koboSpan" id="kobo.170.2">It also caches the result and updates the cache when </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">data changes.</span></span></p>
<p><span class="koboSpan" id="kobo.172.1">In each module, we will define its specific getters to manipulate the state in that module. </span><span class="koboSpan" id="kobo.172.2">For example, we will create a getter to filter photos based on user ID in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">Photos</span></strong><span class="koboSpan" id="kobo.174.1"> module, </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.176.1">
  getters: {
    getPhotoByID: (state) =&gt; (id) =&gt; {
      return state.photos.find(photo =&gt; photo.id === id)
    }
  }</span></pre>
<p><span class="koboSpan" id="kobo.177.1">The preceding code snippet shows how to create a getter that filters all the photos added by a particular user whose ID is passed to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">getters</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.179.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.180.1">Next, let’s access the getter in our component using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">map</span></strong><span class="koboSpan" id="kobo.182.1"> helper. </span><span class="koboSpan" id="kobo.182.2">See the following </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.184.1">
...mapGetters({
  // map `this.getPhotoByID` to
  // `this.$store.getters.getPhotoByID`
  getPhotoByID: 'getPhotoByID'
})</span></pre>
<p><span class="koboSpan" id="kobo.185.1">Vuex getters are a great way to manipulate and manage Vuex states before they go out to our components and can come in handy for filtering, sorting, updating, and deleting records from our </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">Vuex state.</span></span></p>
<p><span class="koboSpan" id="kobo.187.1">Next, we will discuss </span><strong class="bold"><span class="koboSpan" id="kobo.188.1">Vuex mutations</span></strong><span class="koboSpan" id="kobo.189.1"> and how we can use them in an </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">enterprise-rea</span><a id="_idTextAnchor052"/><span class="koboSpan" id="kobo.191.1">dy</span></span><span class="No-Break"><a id="_idIndexMarker042"/></span><span class="No-Break"><span class="koboSpan" id="kobo.192.1"> application.</span></span></p>
<h2 id="_idParaDest-35"><a id="_idTextAnchor053"/><span class="koboSpan" id="kobo.193.1">Vuex mutations</span></h2>
<p><span class="koboSpan" id="kobo.194.1">The only way to change the state</span><a id="_idIndexMarker043"/><span class="koboSpan" id="kobo.195.1"> of a Vuex state is by committing </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">a mutation.</span></span></p>
<p><span class="koboSpan" id="kobo.197.1">A Vuex mutation is similar to an event. </span><span class="koboSpan" id="kobo.197.2">It takes a string called </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">type</span></strong><span class="koboSpan" id="kobo.199.1"> and a function called </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">handler</span></strong><span class="koboSpan" id="kobo.201.1">. </span><span class="koboSpan" id="kobo.201.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">handler</span></strong><span class="koboSpan" id="kobo.203.1"> function is where you perform </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">the mutation.</span></span></p>
<p><span class="koboSpan" id="kobo.205.1">Assuming we’re still working with our </span><em class="italic"><span class="koboSpan" id="kobo.206.1">Pinterest</span></em><span class="koboSpan" id="kobo.207.1"> photo store, we can add a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">Photo</span></strong><span class="koboSpan" id="kobo.209.1"> object to our state with the following </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.211.1">
const store = createStore({
  state: {
    photos: []
  },
  mutations: {
    ADD_NEW_PHOTO (state, photo) {
      // mutate state
      state.photos.push(photo)
    }
  }
})</span></pre>
<p><span class="koboSpan" id="kobo.212.1">Next, we will look at accessing the Vuex mutation module. </span><span class="koboSpan" id="kobo.212.2">We can access it using Vuex map helpers, which is the recommended way for </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">enterprise projects:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.214.1">
import { mapMutations } from 'vuex'
export default {
  methods: {
    ...mapMutations({
      addPhoto: 'photos/ADD_NEW_PHOTO'
    })
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.215.1">Lastly, we can call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">addPhoto()</span></strong><span class="koboSpan" id="kobo.217.1"> method anywhere in our component, pass the </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">Photo</span></strong><span class="koboSpan" id="kobo.219.1"> object as the only argument, and let Vuex do </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">its thing.</span></span></p>
<p><span class="koboSpan" id="kobo.221.1">In addition, the most </span><a id="_idIndexMarker044"/><span class="koboSpan" id="kobo.222.1">comprehensive place to use Vuex mutations is in </span><strong class="bold"><span class="koboSpan" id="kobo.223.1">Vuex actions</span></strong><span class="koboSpan" id="kobo.224.1">. </span><span class="koboSpan" id="kobo.224.2">In the next section, we will discuss Vuex actions in detail and demonstrate how they can be used in </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">enterp</span><a id="_idTextAnchor054"/><span class="koboSpan" id="kobo.226.1">rise applications.</span></span></p>
<h2 id="_idParaDest-36"><a id="_idTextAnchor055"/><span class="koboSpan" id="kobo.227.1">Vuex actions</span></h2>
<p><span class="koboSpan" id="kobo.228.1">Vuex actions are similar to Vuex</span><a id="_idIndexMarker045"/><span class="koboSpan" id="kobo.229.1"> mutations, but instead, they are asynchronous and are primarily used to commit </span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">Vuex mutations.</span></span></p>
<p><span class="koboSpan" id="kobo.231.1">Vuex actions can make API calls to our backend server and commit the response to our Vuex state using </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">Vuex mutations.</span></span></p>
<p><span class="koboSpan" id="kobo.233.1">Traditionally, to make an API call with Vuex actions, we will do it directly inside the store, as the following code </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">snippet shows.</span></span></p>
<p><span class="koboSpan" id="kobo.235.1">Using our </span><em class="italic"><span class="koboSpan" id="kobo.236.1">Pinterest</span></em><span class="koboSpan" id="kobo.237.1"> photo example, we will have a store similar to </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">this one:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.239.1">
const store = createStore({
  state: {
    photos: []
  },
  mutations: {
    ADD_NEW_PHOTO (state, photo) {
      state.photos.push(photo)
    }
  },
  actions: {
   async getPhoto (context, id) {
       const photo = await Axios.get('/photos/'+id);
       context.commit('ADD_NEW_PHOTO', photo)
    }
  }
})</span></pre>
<p><span class="koboSpan" id="kobo.240.1">Next, to dispatch the action in our component, we will stick with using Vuex maps to dispatch the action and </span><a id="_idIndexMarker046"/><span class="koboSpan" id="kobo.241.1">retrieve a new photo corresponding to the ID passed into the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">getPhoto()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.243.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.244.1">
import { mapActions } from 'vuex'
export default {
  methods: {
    ...mapActions({
      getPhoto: 'photos/getPhoto' // map `this.getPhoto()`
      // to `this.$store.dispatch('photos/getPhoto')`
    })
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.245.1">So far, we have covered a lot on building large-scale applications with Vuex, and we have elucidated Vuex modules, states, getters, mutations, and actions and how to apply them in building </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">enterprise-ready applications.</span></span></p>
<p><span class="koboSpan" id="kobo.247.1">To further solve the problem of structure, we will introduce you to the use of the </span><strong class="bold"><span class="koboSpan" id="kobo.248.1">repository pattern</span></strong><span class="koboSpan" id="kobo.249.1"> in arranging your Vuex store, structuring all your API calls into a repository, and accessing them i</span><a id="_idTextAnchor056"/><span class="koboSpan" id="kobo.250.1">n your </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">Vuex actions.</span></span></p>
<h1 id="_idParaDest-37"><a id="_idTextAnchor057"/><span class="koboSpan" id="kobo.252.1">Structuring with the repository pattern</span></h1>
<p><span class="koboSpan" id="kobo.253.1">When building a large-scale, enterprise-ready Vue application, you must get the project’s structure right from the</span><a id="_idIndexMarker047"/> <span class="No-Break"><span class="koboSpan" id="kobo.254.1">ground up.</span></span></p>
<p><span class="koboSpan" id="kobo.255.1">Separating your Vuex store into individual modules based on an application’s features is excellent and provides direct access to files, making debugging and maintenance </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">a breeze.</span></span></p>
<p><span class="koboSpan" id="kobo.257.1">Using this method alone poses a problem. </span><span class="koboSpan" id="kobo.257.2">Your Vuex actions become extremely large with many API calls, extracting API data, and handling errors all happening in the </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">Vuex actions.</span></span></p>
<p><span class="koboSpan" id="kobo.259.1">Introducing the repository pattern helps eliminate this bloated code base and separates the API calls and management </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">from Vuex.</span></span></p>
<p><span class="koboSpan" id="kobo.261.1">In this section, we will first get an overview of the repository pattern. </span><span class="koboSpan" id="kobo.261.2">Then, we will create a repository folder for our </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">Vue application.</span></span></p>
<p><span class="koboSpan" id="kobo.263.1">Firstly, before we explore how to use the repository pattern in Vuex, let’s get a clear overview of the repository pattern and what can be achieved </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">with it.</span></span></p>
<h2 id="_idParaDest-38"><a id="_idTextAnchor058"/><span class="koboSpan" id="kobo.265.1">Overview of the repository pattern</span></h2>
<p><span class="koboSpan" id="kobo.266.1">The repository pattern is a</span><a id="_idIndexMarker048"/><span class="koboSpan" id="kobo.267.1"> significant pattern used in creating an enterprise-level application, either the frontend or the backend of any </span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">enterprise application.</span></span></p>
<p><span class="koboSpan" id="kobo.269.1">It restricts us from working directly with data in the application and creating a new layer for database operations, business logic, and the </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">application UI.</span></span></p>
<p><span class="koboSpan" id="kobo.271.1">The following is a list of a few reasons you should use the repository pattern in your frontend development, especially when building </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">enterprise applications:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.273.1">The data access code is reusable everywhere across the </span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">entire project</span></span></li>
<li><span class="koboSpan" id="kobo.275.1">It is effortless to implement the </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">domain logic</span></span></li>
<li><span class="koboSpan" id="kobo.277.1">You can unit-test your business logic quickly without any form of </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">tight coupling</span></span></li>
<li><span class="koboSpan" id="kobo.279.1">It aids in the decoupling of business logic and the </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">application UI</span></span></li>
</ul>
<p><strong class="bold"><span class="koboSpan" id="kobo.281.1">Dependency injection</span></strong><span class="koboSpan" id="kobo.282.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.283.1">DI</span></strong><span class="koboSpan" id="kobo.284.1">) is good when writing testable enterprise code, and repository patterns help you achieve DI even in </span><a id="_idIndexMarker049"/><span class="koboSpan" id="kobo.285.1">your </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">frontend projects.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.287.1">DI</span></p>
<p class="callout"><span class="koboSpan" id="kobo.288.1">DI is a programming technique that makes a class independent of </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">its dependencies.</span></span></p>
<p><span class="koboSpan" id="kobo.290.1">In the repository pattern, you</span><a id="_idIndexMarker050"/><span class="koboSpan" id="kobo.291.1"> write an encapsulated code base by hiding the details of how your data is retrieved and processed in your </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">Vuex store.</span></span></p>
<p><span class="koboSpan" id="kobo.293.1">To implement the repository pattern, we will follow the </span><em class="italic"><span class="koboSpan" id="kobo.294.1">Consuming APIs Using the Repository Pattern in Vue.js</span></em><span class="koboSpan" id="kobo.295.1"> article I </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">wrote (</span></span><a href="https://medium.com/backenders-club/consuming-apis-using-the-repository-pattern-in-vue-js-e64671b27b09"><span class="No-Break"><span class="koboSpan" id="kobo.297.1">https://medium.com/backenders-club/consuming-apis-using-the-repository-pattern-in-vue-js-e64671b27b09</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.298.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.299.1">To consume our backend APIs in Vue.js using the repository pattern, let’s demonstrate doing so with an example. </span><span class="koboSpan" id="kobo.299.2">Let’s assume we have a Vuex store action making different API calls, such as the one in the following code snippet, and we want to implement the repository pattern </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">on it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.301.1">
  actions: {
    async all({ commit }, { size = 20, page = 0 }) {
      const response = await
          Axios.get(`/photos?size=${size}&amp;page=${page}`);
      const { data } = response;
      if (data.success) {
        commit("STORE_PHOTOS", data.photos);
      } else {
        commit("STORE_ERROR", data.message);
      }
    },
    async getPhoto({ commit }, id) {
      const response = await Axios.get('/photos/'+id);
      const { data } = response;
      if (data.success) {
        commit("STORE_PHOTO", data.photo);
      } else {
        commit("STORE_ERROR", data.message);
      }
    },
  },</span></pre>
<p><span class="koboSpan" id="kobo.302.1">Now, we can follow the</span><a id="_idIndexMarker051"/><span class="koboSpan" id="kobo.303.1"> upcoming steps to improve the Vuex store by implementin</span><a id="_idTextAnchor059"/><span class="koboSpan" id="kobo.304.1">g the </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">repository pattern.</span></span></p>
<h1 id="_idParaDest-39"><a id="_idTextAnchor060"/><span class="koboSpan" id="kobo.306.1">Creating a repository folder</span></h1>
<p><span class="koboSpan" id="kobo.307.1">First, create a folder in the</span><a id="_idIndexMarker052"/><span class="koboSpan" id="kobo.308.1"> root directory or </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">src</span></strong><span class="koboSpan" id="kobo.310.1"> folder by running the </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.312.1">
mkdir repositories</span></pre>
<p><span class="koboSpan" id="kobo.313.1">We will call ours </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">repositories</span></strong><span class="koboSpan" id="kobo.315.1">. </span><span class="koboSpan" id="kobo.315.2">This folder will contain all your repositories and the H</span><a id="_idTextAnchor061"/><span class="koboSpan" id="kobo.316.1">TTP </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">client configurations.</span></span></p>
<h2 id="_idParaDest-40"><a id="_idTextAnchor062"/><span class="koboSpan" id="kobo.318.1">Creating a clients folder</span></h2>
<p><span class="koboSpan" id="kobo.319.1">We will create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">Clients</span></strong><span class="koboSpan" id="kobo.321.1"> folder inside </span><a id="_idIndexMarker053"/><span class="koboSpan" id="kobo.322.1">the newly created </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">repositories</span></strong><span class="koboSpan" id="kobo.324.1"> folder. </span><span class="koboSpan" id="kobo.324.2">What will be inside this folder are the different HTTP </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">clients used.</span></span></p>
<p><span class="koboSpan" id="kobo.326.1">Sometimes, due to the nature of the project, some projects might require several HTTP clients to make API calls due to different reasons. </span><span class="koboSpan" id="kobo.326.2">One can be a fallback if the default refuses </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">to connect.</span></span></p>
<p><span class="koboSpan" id="kobo.328.1">Hence, creating a </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">Clients</span></strong><span class="koboSpan" id="kobo.330.1"> folder</span><a id="_idIndexMarker054"/><span class="koboSpan" id="kobo.331.1"> is crucial to configure all the HTTP clients at once. </span><span class="koboSpan" id="kobo.331.2">Run the following command to </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">create one:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.333.1">
cd r</span><a id="_idTextAnchor063"/><span class="koboSpan" id="kobo.334.1">epositories &amp;&amp; mkdir Clients</span></pre>
<h2 id="_idParaDest-41"><a id="_idTextAnchor064"/><span class="koboSpan" id="kobo.335.1">Creating an xxxClient.js class</span></h2>
<p><span class="koboSpan" id="kobo.336.1">You can create </span><a id="_idIndexMarker055"/><span class="koboSpan" id="kobo.337.1">a class file corresponding to the HTTP client you are using. </span><span class="koboSpan" id="kobo.337.2">The naming is subjective, and for </span><strong class="bold"><span class="koboSpan" id="kobo.338.1">Axios</span></strong><span class="koboSpan" id="kobo.339.1">, we will create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">AxiosClient.js</span></strong><span class="koboSpan" id="kobo.341.1"> file and </span><a id="_idIndexMarker056"/><span class="koboSpan" id="kobo.342.1">put it in all </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">default configurations.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.344.1">Axios</span></p>
<p class="callout"><span class="koboSpan" id="kobo.345.1">Axios is a promise-based HTTP client for Node.js and the browser. </span><span class="koboSpan" id="kobo.345.2">It can run in the browser and Node.js with the same </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.347.1">Run the following command to create </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">the folder:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.349.1">
touch AxiosClient.js</span></pre>
<p><span class="koboSpan" id="kobo.350.1">In summary, you might want to use many HTTP clients, so you create different </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">xxxClient.js</span></strong><span class="koboSpan" id="kobo.352.1"> files for each with their </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">specific configuration.</span></span></p>
<p><span class="koboSpan" id="kobo.354.1">For Axios, these are my default configurations just for </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">this test:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.356.1">
import axios from "axios";
const baseDomain = "https://localhost:1337"; //For Strapi
const baseURL = `${baseDomain}`; // Incase of /api/v1;
// ALL DEFAULT CONFIGURATION HERE
export default axios.create({
  baseURL,
  headers: {
    // "Authorization": "Bearer xxxxx"
  }
});</span></pre>
<p><span class="koboSpan" id="kobo.357.1">You can add more default</span><a id="_idIndexMarker057"/><span class="koboSpan" id="kobo.358.1"> configurations for Axios in the preceding file</span><a id="_idTextAnchor065"/><span class="koboSpan" id="kobo.359.1"> and export the </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">Axios instance.</span></span></p>
<h2 id="_idParaDest-42"><a id="_idTextAnchor066"/><span class="koboSpan" id="kobo.361.1">Creating an individual repository class</span></h2>
<p><span class="koboSpan" id="kobo.362.1">Next, we will </span><a id="_idIndexMarker058"/><span class="koboSpan" id="kobo.363.1">create an individual repository based on the number of features we have in our </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">enterprise application.</span></span></p>
<p><span class="koboSpan" id="kobo.365.1">For instance, we are building a </span><em class="italic"><span class="koboSpan" id="kobo.366.1">Pinterest</span></em><span class="koboSpan" id="kobo.367.1"> clone application, and we are sure the application will have the </span><strong class="bold"><span class="koboSpan" id="kobo.368.1">Photos</span></strong><span class="koboSpan" id="kobo.369.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.370.1">Users</span></strong><span class="koboSpan" id="kobo.371.1"> features. </span><span class="koboSpan" id="kobo.371.2">So, we can start by creating a repository for the mentioned features by running the </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.373.1">
cd repositories &amp;&amp; touch PhotoRepository.js UserRepository.js</span></pre>
<p><span class="koboSpan" id="kobo.374.1">These repositories will contain all API calls for the individual features. </span><span class="koboSpan" id="kobo.374.2">We will start by creating a </span><strong class="bold"><span class="koboSpan" id="kobo.375.1">Create, Read, Update,</span></strong><span class="koboSpan" id="kobo.376.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.377.1">Delete</span></strong><span class="koboSpan" id="kobo.378.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.379.1">CRUD</span></strong><span class="koboSpan" id="kobo.380.1">) operation</span><a id="_idIndexMarker059"/><span class="koboSpan" id="kobo.381.1"> for the respective repositories to give us an overview. </span><span class="koboSpan" id="kobo.381.2">In contrast, we will update the repositories as we progress along in </span><span class="No-Break"><span class="koboSpan" id="kobo.382.1">the book.</span></span></p>
<p><span class="koboSpan" id="kobo.383.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">PhotoRepository.js</span></strong><span class="koboSpan" id="kobo.385.1"> file and add the </span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">following scripts:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.387.1">
import Axios from './Clients/AxiosClient';
const resource = '/photos;
export default {
    get() {
        return Axios.get(`${resource}`);
    },
    getPhoto(id) {
        return Axios.get(`${resource}/${id}`);
    },
    create(payload) {
        return Axios.post(`${resource}`, payload);
    },
    update(payload, id) {
        return Axios.put(`${resource}/${id}`, payload);
    },
    delete(id) {
        return Axios.delete(`${resource}/${id}`)
    },
    //b MANY OTHER RELATED ENDPOINTS.
</span><span class="koboSpan" id="kobo.387.2">};</span></pre>
<p><span class="koboSpan" id="kobo.388.1">Next, we are</span><a id="_idIndexMarker060"/><span class="koboSpan" id="kobo.389.1"> going to open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">UserRespository.js</span></strong><span class="koboSpan" id="kobo.391.1"> file and add the </span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">following scripts:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.393.1">
import Axios from './Clients/AxiosClient';
const resource = '/users;
export default {
    get() {
        return Axios.get(`${resource}`);
    },
    getUser(id) {
        return Axios.get(`${resource}/${id}`);
    },
    create(payload) {
        return Axios.post(`${resource}`, payload);
    },
    update(payload, id) {
        return Axios.put(`${resource}/${id}`, payload);
    },
    delete(id) {
        return Axios.delete(`${resource}/${id}`)
    },
    //b MANY OTHER RELATED ENDPOINTS.
</span><span class="koboSpan" id="kobo.393.2">};</span></pre>
<p><span class="koboSpan" id="kobo.394.1">We have created two</span><a id="_idIndexMarker061"/><span class="koboSpan" id="kobo.395.1"> repositories for our </span><em class="italic"><span class="koboSpan" id="kobo.396.1">Pinterest</span></em><span class="koboSpan" id="kobo.397.1"> clone application, and any API-related code will</span><a id="_idTextAnchor067"/><span class="koboSpan" id="kobo.398.1"> go into the </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">individual repository.</span></span></p>
<h2 id="_idParaDest-43"><a id="_idTextAnchor068"/><span class="koboSpan" id="kobo.400.1">Creating a RepositoryFactory.js class</span></h2>
<p><span class="koboSpan" id="kobo.401.1">Create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">RepositoryFactory</span></strong><span class="koboSpan" id="kobo.403.1"> factory class inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">repositories</span></strong><span class="koboSpan" id="kobo.405.1"> folder by running the following command to </span><a id="_idIndexMarker062"/><span class="koboSpan" id="kobo.406.1">export all the different individual repositories you may have created so that they’re easy to use anywhere across </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">your application:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.408.1">
touch RepositoryFactory.js</span></pre>
<p><span class="koboSpan" id="kobo.409.1">Once done, paste in the </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.411.1">
import PhotoRepository from './PhotoRepository';
import UserRepository from './UserRepository';
const repositories = {
    'Photos': PhotoRepository,
    'Users': UserRepository
}
export default {
    get: name =&gt; repositories[name]
};</span></pre>
<p><span class="koboSpan" id="kobo.412.1">Now that we have improved our</span><a id="_idIndexMarker063"/><span class="koboSpan" id="kobo.413.1"> Vuex store by creating repositories, let’s see</span><a id="_idTextAnchor069"/><span class="koboSpan" id="kobo.414.1"> how to use these in the </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">next section.</span></span></p>
<h2 id="_idParaDest-44"><a id="_idTextAnchor070"/><span class="koboSpan" id="kobo.416.1">Using the repository pattern</span></h2>
<p><span class="koboSpan" id="kobo.417.1">Let’s see how to utilize the </span><a id="_idIndexMarker064"/><span class="koboSpan" id="kobo.418.1">repositories we have created in our Vuex store. </span><span class="koboSpan" id="kobo.418.2">Open your Vuex store </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">photos</span></strong><span class="koboSpan" id="kobo.420.1"> file created earlier and replace the </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">getPhoto</span></strong><span class="koboSpan" id="kobo.422.1"> action method with the following code to utilize the </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">repository pattern:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.424.1">
import Repository from "@/repositories/RepositoryFactory";
const Photos = Repository.get("Photos");
const Users = Repository.get("Users");
actions: {
   async getPhoto (context, id) {
     const photo = await Photos.getPhoto(id);
     context.commit('ADD_NEW_PHOTO', photo)
    }
   async getUsers(context) {
     const users = await Users.get();
     context.commit('ADD_USERS', users)
    }
  }</span></pre>
<p><span class="koboSpan" id="kobo.425.1">Using the repository pattern eliminates the need to handle errors, manipulate the data retrieved from the API in the Vuex store, and only return the actual data needed in Vuex. </span><span class="koboSpan" id="kobo.425.2">This approach also </span><a id="_idIndexMarker065"/><span class="koboSpan" id="kobo.426.1">utilizes the </span><strong class="bold"><span class="koboSpan" id="kobo.427.1">Don’t Repeat Yourself</span></strong><span class="koboSpan" id="kobo.428.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.429.1">DRY</span></strong><span class="koboSpan" id="kobo.430.1">) principle of software engineering as the repositories can be used across the project by creating a </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">new one.</span></span></p>
<p><span class="koboSpan" id="kobo.432.1">Structuring doesn’t end when </span><a id="_idIndexMarker066"/><span class="koboSpan" id="kobo.433.1">you have your HTTP API calls sorted out with repository patterns. </span><span class="koboSpan" id="kobo.433.2">It extends to the way you arrange your navigation. </span><span class="koboSpan" id="kobo.433.3">The navigation file should not be bloated with a large code base that’s difficult </span><span class="No-Break"><span class="koboSpan" id="kobo.434.1">to understand.</span></span></p>
<p><span class="koboSpan" id="kobo.435.1">In the next section, we will arrange and structure our navigation using Vue Router to ensure maintainability and</span><a id="_idTextAnchor071"/><span class="koboSpan" id="kobo.436.1"> scalability in our </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">enterprise project.</span></span></p>
<h1 id="_idParaDest-45"><a id="_idTextAnchor072"/><span class="koboSpan" id="kobo.438.1">Structuring Vue navigation with Vue Router</span></h1>
<p><span class="koboSpan" id="kobo.439.1">When building an enterprise-ready application, it’s evident that the navigation system will be massive since there</span><a id="_idIndexMarker067"/><span class="koboSpan" id="kobo.440.1"> will be many navigations, routes, </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">and pages.</span></span></p>
<p><span class="koboSpan" id="kobo.442.1">This section will show you how to structure Vue Router in your enterprise project properly. </span><span class="koboSpan" id="kobo.442.2">To achieve this, we will use the </span><em class="italic"><span class="koboSpan" id="kobo.443.1">split-by-feature</span></em><span class="koboSpan" id="kobo.444.1"> approach to organizing Vue Router so that it’s easy to navigate, as we achieved with Vuex earlier in </span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">the chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.446.1">This approach will create a structure where public and private routes will be separated, and more r</span><a id="_idTextAnchor073"/><span class="koboSpan" id="kobo.447.1">outes can also be </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">separated individually.</span></span></p>
<h2 id="_idParaDest-46"><a id="_idTextAnchor074"/><span class="koboSpan" id="kobo.449.1">The folder structure</span></h2>
<p><span class="koboSpan" id="kobo.450.1">The folder will comprise an</span><a id="_idIndexMarker068"/><span class="koboSpan" id="kobo.451.1"> index file, a public file, and a private file containing all the routes belonging to </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">each category.</span></span></p>
<p><span class="koboSpan" id="kobo.453.1">In the root of your </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">src</span></strong><span class="koboSpan" id="kobo.455.1"> folder, create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">router</span></strong><span class="koboSpan" id="kobo.457.1"> folder and create the following files inside the folder by typing in the following commands one after the other in </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">your terminal:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.459.1">
cd src &amp;&amp; mkdir router
touch index.js
mkdir routes &amp;&amp; cd routes
touch public.js private.js combine.js</span></pre>
<p><span class="koboSpan" id="kobo.460.1">The current folder structure is pretty straightforward, and we will customize it more as we progress with the book. </span><span class="koboSpan" id="kobo.460.2">Here’s what each file </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">will contain:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">index.js</span></strong><span class="koboSpan" id="kobo.463.1">: This file will contain the </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">beforeEach</span></strong><span class="koboSpan" id="kobo.465.1"> logic and assembling of all the </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">other routes</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">public.js</span></strong><span class="koboSpan" id="kobo.468.1">: This file will contain all the public-facing routes that do not need restrictions, such as the login page, registration page, and </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">so on</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">private.js</span></strong><span class="koboSpan" id="kobo.471.1">: This file will contain all the private routes used for authenticated users and many restrictions </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">and metadata</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">combine.js</span></strong><span class="koboSpan" id="kobo.474.1">: This file will combine private and public files and make it easy to concatenate it with </span><a id="_idIndexMarker069"/><span class="koboSpan" id="kobo.475.1">the main </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">router file</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.477.1">Next, let’s create an index file to cont</span><a id="_idTextAnchor075"/><span class="koboSpan" id="kobo.478.1">ain the setup of our newly </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">created project.</span></span></p>
<h2 id="_idParaDest-47"><a id="_idTextAnchor076"/><span class="koboSpan" id="kobo.480.1">The index.js file</span></h2>
<p><span class="koboSpan" id="kobo.481.1">The index file is the powerhouse. </span><span class="koboSpan" id="kobo.481.2">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">index.js</span></strong><span class="koboSpan" id="kobo.483.1"> file and add the following code to export all the routes</span><a id="_idIndexMarker070"/><span class="koboSpan" id="kobo.484.1"> created in the public and </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">private files:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.486.1">
import { createRouter, createWebHistory } from "vue-router";
import routes from '@/router/routes/combine.js'
const routes = [
    {
      path: '/',
      redirect: '/'
    }
  ].concat(routes)
const router = createRouter({ history: createWebHistory(), routes });
// ....
</span><span class="koboSpan" id="kobo.486.2">// BeforeE</span><a id="_idTextAnchor077"/><span class="koboSpan" id="kobo.487.1">ach code here
//.....
</span><span class="koboSpan" id="kobo.487.2">export default router</span></pre>
<p><span class="koboSpan" id="kobo.488.1">In Vue Router, there are </span><a id="_idIndexMarker071"/><span class="koboSpan" id="kobo.489.1">two different history modes mostly in use when developing Vue applications with </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">Vue Router:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.491.1">Hash mode</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.492.1">HTML5 mode</span></span></li>
</ul>
<h2 id="_idParaDest-48"><a id="_idTextAnchor078"/><span class="koboSpan" id="kobo.493.1">Hash mode</span></h2>
<p><span class="koboSpan" id="kobo.494.1">This uses a </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">#</span></strong><span class="koboSpan" id="kobo.496.1"> (hash) symbol before the</span><a id="_idIndexMarker072"/><span class="koboSpan" id="kobo.497.1"> actual URL to simulate a full URL so that the page won’t be reloaded when the URL changes. </span><span class="koboSpan" id="kobo.497.2">This is possible because the pages or sections after the hash never get sent to the server. </span><span class="koboSpan" id="kobo.497.3">The implication is that it does not impact the SEO of the page but is the default setup for </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">Vue Router.</span></span></p>
<h2 id="_idParaDest-49"><a id="_idTextAnchor079"/><span class="koboSpan" id="kobo.499.1">HTML5 mode</span></h2>
<p><span class="koboSpan" id="kobo.500.1">As seen in the preceding example, this is </span><a id="_idIndexMarker073"/><span class="koboSpan" id="kobo.501.1">created using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">createWebHistory()</span></strong><span class="koboSpan" id="kobo.503.1"> function, and it is the recommended method for enterprise and production-ready applications. </span><span class="koboSpan" id="kobo.503.2">It requires a bit of tedious configuration on the server for it to </span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">work properly.</span></span></p>
<h2 id="_idParaDest-50"><a id="_idTextAnchor080"/><span class="koboSpan" id="kobo.505.1">The combine.js file</span></h2>
<p><span class="koboSpan" id="kobo.506.1">This is a single utility file that combines all the routes in a single file to be exported to the main router file. </span><span class="koboSpan" id="kobo.506.2">Open the</span><a id="_idIndexMarker074"/><span class="koboSpan" id="kobo.507.1"> file and add the </span><span class="No-Break"><span class="koboSpan" id="kobo.508.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.509.1">
import publicRoutes from '@/router/routes/public.js'
import privateRoutes from '@/router/routes/private.js'
export default publicRoutes.concat(privateRoutes)</span></pre>
<p><span class="koboSpan" id="kobo.510.1">After adding the routes to the utility file, we will import them into</span><a id="_idTextAnchor081"/><span class="koboSpan" id="kobo.511.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">main.js</span></strong><span class="koboSpan" id="kobo.513.1"> file, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.514.1">next section.</span></span></p>
<h2 id="_idParaDest-51"><a id="_idTextAnchor082"/><span class="koboSpan" id="kobo.515.1">Adding the router to Vue</span></h2>
<p><span class="koboSpan" id="kobo.516.1">Lastly, we will add our</span><a id="_idIndexMarker075"/><span class="koboSpan" id="kobo.517.1"> router to the Vue instance, as shown in the next snippet. </span><span class="koboSpan" id="kobo.517.2">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">main.js</span></strong><span class="koboSpan" id="kobo.519.1"> file and add the </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.521.1">
import { createApp } from "vue"
import App from "./App.vue"
import router from "./router/index.js"
import store from "./store"
createApp(App).use(router).use(store).mount("#app")</span></pre>
<p><span class="koboSpan" id="kobo.522.1">As we progress in this book, we will revisit the </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">public.js</span></strong><span class="koboSpan" id="kobo.524.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">private.js</span></strong><span class="koboSpan" id="kobo.526.1"> files to add more routes based on </span><a id="_idTextAnchor083"/><span class="koboSpan" id="kobo.527.1">the </span><em class="italic"><span class="koboSpan" id="kobo.528.1">Pinterest</span></em><span class="koboSpan" id="kobo.529.1"> clone application </span><span class="No-Break"><span class="koboSpan" id="kobo.530.1">we develop.</span></span></p>
<h1 id="_idParaDest-52"><a id="_idTextAnchor084"/><span class="koboSpan" id="kobo.531.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.532.1">This chapter started by exploring the different libraries to develop large-scale and enterprise-ready applications with Vue.js 3. </span><span class="koboSpan" id="kobo.532.2">We discussed the individual libraries and their different features in detail to foster our understanding of building scalable and enterprise-ready applications. </span><span class="koboSpan" id="kobo.532.3">We also covered the essentials of Vuex, discussing how to structure our large-scale Vuex store by splitting Vuex actions, modules, getters, and states using the </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">split-by-feature approach.</span></span></p>
<p><span class="koboSpan" id="kobo.534.1">Next, we discussed the essentials of </span><strong class="bold"><span class="koboSpan" id="kobo.535.1">separation of concerns</span></strong><span class="koboSpan" id="kobo.536.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.537.1">SoC</span></strong><span class="koboSpan" id="kobo.538.1">) by using the repository pattern to split large Vuex actions into individual repositories and make our enterprise application maintainable. </span><span class="koboSpan" id="kobo.538.2">The repository pattern is essential in creating an enterprise application, and we demonstrated how to implement it in </span><span class="No-Break"><span class="koboSpan" id="kobo.539.1">Vue 3.</span></span></p>
<p><span class="koboSpan" id="kobo.540.1">Lastly, we discussed how to structure Vue Router to avoid bloated and large router files as it will be difficult to maintain when the project becomes larger. </span><span class="koboSpan" id="kobo.540.2">We discussed strategic patterns to split the Vue Router files into different files to enable maintainability and ease </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">of debugging.</span></span></p>
<p><span class="koboSpan" id="kobo.542.1">In the next chapter, we will dive deeper into scaling the performance of enterprise Vue 3 applications. </span><span class="koboSpan" id="kobo.542.2">We will explore different performance and scalability hacks to build an enterprise-ready Vue 3 application, such as asynchronous components’ loading/lazy loading, tree shaking, image compression, and so on. </span><span class="koboSpan" id="kobo.542.3">You will learn how to properly increase the performance of your Vue 3 application by applying the tricks in the next chapter to develop large-scale applications with maintainability </span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">and scalability.</span></span></p>
</div>


<div class="Content" id="_idContainer012">
<h1 id="_idParaDest-53"><a id="_idTextAnchor085"/><span class="koboSpan" id="kobo.1.1">Part 2: Large-Scale Apps and Scaling Performance in Vue.js 3</span></h1>
<p><span class="koboSpan" id="kobo.2.1">In this part, you will learn best practices in building large-scale applications, with scalability and performance as first-class citizens. </span><span class="koboSpan" id="kobo.2.2">In addition, you will learn and explore different techniques in scaling large </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">application performance.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">This part comprises the </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">following chapters:</span></span></p>
<ul>
<li><em class="italic"><a id="_idTextAnchor086"/></em><a href="B17237_03.xhtml#_idTextAnchor087"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 3</span></em></a><span class="koboSpan" id="kobo.7.1">, </span><a href="https://epic.packtpub.services/index.php?module=oss_Chapters&amp;action=DetailView&amp;record=e17b2903-7123-3af0-d559-61d6c930c89c"><em class="italic"><span class="koboSpan" id="kobo.8.1">Scaling Performance in Vue.js 3</span></em></a></li>
<li><a href="B17237_04.xhtml#_idTextAnchor112"><em class="italic"><span class="koboSpan" id="kobo.9.1">Chapter 4</span></em></a><span class="koboSpan" id="kobo.10.1">, </span><a href="https://epic.packtpub.services/index.php?module=oss_Chapters&amp;action=DetailView&amp;record=2a7a717b-e1bb-58f4-e12f-61d6c9e83477"><em class="italic"><span class="koboSpan" id="kobo.11.1">Architecture for Large-Scale Web </span></em></a><em class="italic"><span class="koboSpan" id="kobo.12.1">Applications</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer013">
</div>
</div>
<div>
<div id="_idContainer014">
</div>
</div>
</body></html>