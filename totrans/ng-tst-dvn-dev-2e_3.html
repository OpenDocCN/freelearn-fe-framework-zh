<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;The Karma Way"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. The Karma Way</h1></div></div></div><p>JavaScript testing has hit the mainstream, thanks to Karma. Karma makes it seamless to test JavaScript. Angular was created around testing.</p><p>In this chapter, we will learn a few things about Karma, including the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The origin of Karma</li><li class="listitem" style="list-style-type: disc">Why and how Karma will work with an Angular project </li><li class="listitem" style="list-style-type: disc">The Karma configuration and implementation with an Angular project </li><li class="listitem" style="list-style-type: disc">An overview of <span class="strong"><strong>Travis CI</strong></span> </li></ul></div><div class="section" title="The birth of Karma"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec20"/>The birth of Karma</h1></div></div></div><p>When picking up a new tool, it is important to understand where it comes from and why it is built. This section will give us a background of the origin of Karma.</p><div class="section" title="The Karma difference"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec33"/>The Karma difference</h2></div></div></div><p>Karma was created by Vojta Jína. The project was originally called <span class="strong"><strong>Testacular</strong></span>. In Vojtech Jína's thesis, he discusses the design, purpose, and implementation of Karma.</p><p>In his thesis (<span class="emphasis"><em>JavasScript Test Runner</em></span>, <a class="ulink" href="https://github.com/karma-runner/karma/raw/master/thesis.pdf">https://github.com/karma-runner/karma/raw/master/thesis.pdf</a>), he describes Karma as follows:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>"...a test runner that helps web application developers to be more productive and effective by making automated testing simpler and faster. In fact, I have a much higher ambition and this thesis is only a part of it - I want to promote Test Driven Development (TDD) as "the" way to develop web applications, because I believe it is the most effective way to develop high quality software."</em></span></p></blockquote></div><p>Karma has the ability to easily and automatically run JavaScript unit tests on real browsers. Traditionally, tests were run by launching a browser manually and checking for results by continually clicking on the refresh button. This method was awkward and often resulted in developers limiting the number of tests that were written.</p><p>With Karma, a developer can write a test in almost any standard test framework, choose a browser to run against, set the files to watch for changes, and bam! We have continuous automated testing. We have to simply check the output window for failed or passed tests.</p></div><div class="section" title="The importance of combining Karma and Angular"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec34"/>The importance of combining Karma and Angular</h2></div></div></div><p>Karma was built for AngularJS. Before Karma, there was a lack of automated testing tools for web-based JavaScript developers.</p><p>Remember that Karma is a test runner, not a test framework. Its job is to run tests and report which tests will pass or fail. Why is this helpful? A test framework is where you will write your tests. Apart from doing this, you will need to be focused on running the tests easily and seeing the results. Karma easily runs tests across several different browsers. It also has some other features, such as file watching, which will be discussed in detail later in the book.</p></div></div></div>
<div class="section" title="Installing Karma"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Installing Karma</h1></div></div></div><p>It's time to start using Karma. Installations and applications are constantly changing. The following guide is intended to be brief; you can go to the Karma website at <a class="ulink" href="http://karma-runner.github.io/">http://karma-runner.github.io/</a> and find the latest instructions there.</p><p>The main focus of this section will be the specific configuration used in this book and not an in-depth installation guide.</p><div class="section" title="Installation prerequisites"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec35"/>Installation prerequisites</h2></div></div></div><p>To install Karma, we will need to have Node.js on our computer. Node.js runs on Google's V8 engine and allows JavaScript to be run on several operating systems.</p><p>Developers can publish node applications and modules using <span class="strong"><strong>NPM</strong></span> (<span class="strong"><strong>Node Package Manager</strong></span>). NPM allows developers to quickly integrate applications and modules into their applications.</p><p>Karma runs and is installed through the <code class="literal">npm</code> package; therefore, we need Node.js before we can use or install Karma. To install Node.js, go to <a class="ulink" href="http://nodejs.org/">http://nodejs.org/</a> and follow the installation instructions.</p><p>Once we have Node.js installed, lets type the following command in the Command Prompt to install Karma:</p><pre class="programlisting">
<span class="strong"><strong>$ npm install karma -g</strong></span>
</pre><p>The preceding command uses <code class="literal">npm</code> to install Karma globally using <code class="literal">-g</code>. This means that we can use Karma on the Command Prompt by simply typing the following:</p><pre class="programlisting">
<span class="strong"><strong>$ karma --version</strong></span>
</pre><p>By default, installing Karma will install <code class="literal">karma-chrome-launcher</code> and <code class="literal">karma-jasmine</code> as dependencies. Ensure that these modules are installed globally as well.</p></div></div>
<div class="section" title="Configuring Karma"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Configuring Karma</h1></div></div></div><p>Karma comes equipped with an automated way to create a configuration file. To use the automated way, type the following command:</p><pre class="programlisting">
<span class="strong"><strong>$ karma init</strong></span>
</pre><p>Here is a sample of the options chosen:</p><p>
</p><div class="mediaobject"><img src="graphics/image_03_001.jpg" alt="Configuring Karma"/></div><p>
</p><div class="section" title="Customizing Karma's configuration"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec36"/>Customizing Karma's configuration</h2></div></div></div><p>The following instructions describe the specific configuration required to get Karma running for the project. Customization includes the test framework (Jasmine), the browser (Chrome) to test with, and the files to test. To customize the configuration, open <code class="literal">karma.conf.js</code> and perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Ensure that the enabled framework says <code class="literal">jasmine</code> using the following code:<pre class="programlisting">        frameworks: ['jasmine'], &#13;
</pre></li><li class="listitem">Configure the <code class="literal">test</code> directory. Note that the following definition needs to include the tests that are required to be run along with any potential dependencies. The directory that will hold our tests is <code class="literal">/test/unit/</code>:<pre class="programlisting">        files: [ &#13;
            'test/unit/**/*.js' &#13;
        ], &#13;
</pre></li><li class="listitem">Set the test browser to Chrome, as follows. It will then be initialized and will run a popup after every test:<pre class="programlisting">        browsers: ['Chrome'], &#13;
</pre></li></ol></div></div><div class="section" title="Confirming Karma's installation and configuration"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec37"/>Confirming Karma's installation and configuration</h2></div></div></div><p>To confirm Karma's installation and configuration, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Run the following command to confirm that Karma starts with no errors:<pre class="programlisting">        <span class="strong"><strong>$ karma start</strong></span>
</pre></li><li class="listitem">The output should be something like this:<pre class="programlisting">        <span class="strong"><strong>$ INFO [karma]: Karma v0.12.16 server started at &#13;
        http://localhost:9876/</strong></span>
</pre></li><li class="listitem">In addition to this, the output should state that no test files were found:<pre class="programlisting">        <span class="strong"><strong>$ WARN [watcher]: Pattern "test/unit/**/*.js" does not&#13;
        match any file.</strong></span>
</pre><p>The output should do this along with a failed test message:</p><pre class="programlisting">        <span class="strong"><strong>$ Chrome 35.0.1916 (Windows 7): Executed 0 of 0 ERROR&#13;
        (0.016 secs / 0 secs)</strong></span>
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note6"/>Note</h3><p>An important point to note is that we will need to install <code class="literal">jasmine-core</code> globally on the system, or else Karma will not run successfully. </p></div></div></li></ol></div><p>This is expected as no tests have been created yet . Continue to the next step if Karma starts, and we will see our Chrome browser with the following output:</p><p>
</p><div class="mediaobject"><img src="graphics/image_03_002.jpg" alt="Confirming Karma's installation and configuration"/></div><p>
</p></div><div class="section" title="Common installation/configuration issues"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec38"/>Common installation/configuration issues</h2></div></div></div><p>If the Jasmine or Chrome launcher are missing, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">When running the test, an error might occur saying <span class="strong"><strong>missing Jasmine or Chrome Launcher</strong></span>. If you get this error, type the following command to install the missing dependencies:<pre class="programlisting">        <span class="strong"><strong>$ npm install karma-jasmine -g</strong></span>&#13;
        <span class="strong"><strong>$ npm install karma-chrome-launcher -g</strong></span>
</pre></li><li class="listitem">Retry the test and confirm that the errors have been resolved.<p>In some cases, you might not be able to install <code class="literal">npm_modules</code> globally using the <code class="literal">-g</code> command. This is generally due to permission issues on your computer. The following is what you need to do to provide permissions (sudo/administrator):</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The resolution is to install Karma directly in your project folder. Use the same command without <code class="literal">-g</code> to do this:<pre class="programlisting">                <span class="strong"><strong>$ npm install karma</strong></span>
</pre></li><li class="listitem">Run Karma using the relative path:<pre class="programlisting">                <span class="strong"><strong>$ ./node_modules/karma/bin/karma --version</strong></span>
</pre></li></ol></div></li></ol></div><p>Now that Karma is installed and running, it's time to put it to use.</p></div></div>
<div class="section" title="Testing with Karma"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Testing with Karma</h1></div></div></div><p>In this section, we will create a test to confirm that Karma is working as expected. To do this, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create the test directory. In the Karma configuration, tests were defined in the following directory:<pre class="programlisting">        files: [ &#13;
               'test/unit/**/*.js' &#13;
           ], &#13;
    </pre></li><li class="listitem">Go ahead and create the <code class="literal">test/unit</code> directory.</li><li class="listitem">Create a new <code class="literal">firstTest.js</code> file in the <code class="literal">test/unit</code> directory.</li><li class="listitem">Write the first test as follows:<pre class="programlisting">        describe('when testing karma', function (){ &#13;
          it('should report a successful test', function (){ &#13;
            expect(true).toBeTruthy(); &#13;
              }); &#13;
        }); &#13;
</pre></li></ol></div><p>The preceding test uses the Jasmine functions and has the following properties:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">describe</code>: This provides a brief string description of the test suite, the things that will be tested.</li><li class="listitem" style="list-style-type: disc"><code class="literal">it</code>: This provides a brief string of the specific assertion called a test spec</li><li class="listitem" style="list-style-type: disc"><code class="literal">expect</code>: This provides a way to assert values</li><li class="listitem" style="list-style-type: disc"><code class="literal">toBeTruthy</code>: This is one of the several properties of an expectation that can be used to make assertions</li></ul></div><p>This test has no real value other than to confirm the output of a passing test.</p><p>Bam! Let's check our console window and see that Karma has executed our test. And our command line should say something like this:</p><pre class="programlisting">
<span class="strong"><strong>$ INFO [watcher]: Added file "./test/unit/firstTest.js"</strong></span>
</pre><p>This output means that Karma automatically recognized that a new file was added. The next output should be something like this:</p><pre class="programlisting">
<span class="strong"><strong>$ Chrome 35.0.1916 (Windows 7): Executed 1 of 1 SUCCESS (0.02 secs &#13;
    / 0.015 secs)</strong></span>
</pre><p>This means that our test has passed!</p></div>
<div class="section" title="Confirming the Karma installation"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Confirming the Karma installation</h1></div></div></div><p>Now, the initial set up and configuration of Karma is complete. Here is a review of the steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We installed Karma through the <code class="literal">npm</code> command.</li><li class="listitem">We initialized a default configuration through the <code class="literal">karma init</code> command.</li><li class="listitem">Next, we configured Karma with Jasmine and a <code class="literal">test/unit</code> test directory.</li><li class="listitem">We started Karma and confirmed that it could be opened with Chrome.</li><li class="listitem">Then, we added a Jasmine test, <code class="literal">firstTest.js</code>, to our <code class="literal">test/unit</code> test directory.</li><li class="listitem">Karma recognized that <code class="literal">firstTest.js</code> had been added to the test directory.</li><li class="listitem">Finally, Karma executed our <code class="literal">firstTest.js</code> and reported our output.</li></ol></div><p>With a couple of steps, we were able to see Karma running and executing tests automatically. From a TDD perspective, we can focus on moving tests from failing to passing without much effort. There is no need to refresh the browser; just check the command output window. Keep Karma running and all our tests and files will automatically be added and run.</p><p>In the subsequent sections, we will see how to apply Karma with a TDD approach. If you're okay with Karma so far and want to move on to Protractor, skip to the next chapter.</p></div>
<div class="section" title="Using Karma with Angular"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Using Karma with Angular</h1></div></div></div><p>Here, we will walk through a TDD approach to an Angular component. By the end of this chapter, we should be able to do the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Feel confident about using Karma and its configuration</li><li class="listitem" style="list-style-type: disc">Understand the basic components of a Jasmine test</li><li class="listitem" style="list-style-type: disc">Start understanding the integration of a TDD approach in an Angular application</li></ul></div><div class="section" title="Getting Angular"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec39"/>Getting Angular</h2></div></div></div><p>Angular installation is not possible via Bower; as it was with Angular1, it has to be installed via npm. Bootstrapping the Angular application is not as simple as Angular1 because Angular doesn't use plain JavaScript. It uses TypeScript or ES6 (ES2015), both of which need to be compiled to plain JavaScript before running them.</p><p>We believe that most of the developer are already aware of the Angular changes and how its compilation works. Just a quick recap--we will use TypeScript in our Angular example project here as long as Angular recommends that, though there is an option to use ES6 instead. We will use the node/npm tsc module to compile the TypeScript to plain JavaScript; node/npm will be our CLI tools as well to build/start a project and run the test.</p><p>A basic understanding of node/npm modules is required here, specifically, how the npm commands works.</p><div class="section" title="Angular project"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec5"/>Angular project</h3></div></div></div><p>We will not demonstrate how to install Angular and how to build a project from scratch, as the Angular doc site shows that nicely. So, we will get a simple Angular project from the Angular teams' example and update that one for our implementation.</p><p>We will clone the <code class="literal">quickstart</code> project from the Angular GitHub repo and will start on that one. Hope we all have <code class="literal">git</code> installed globally besides the node/npm.</p><pre class="programlisting">
<span class="strong"><strong>$ git clone https://github.com/angular/quickstart.git angular-&#13;
    karma</strong></span>
</pre><p>This will copy the project locally as <code class="literal">angular-karma</code> and the folder structure will look as illustrated:</p><p>
</p><div class="mediaobject"><img src="graphics/image_03_003.jpg" alt="Angular project"/></div><p>
</p><p>Let's proceed with it and get ready to run:</p><pre class="programlisting">
<span class="strong"><strong>$ cd angular-karma</strong></span>
<span class="strong"><strong>$ npm install</strong></span>
</pre><p>Here are a couple of steps to get ready with the example project. The <code class="literal">npm install</code> command will install the required modules for the project dependencies that are defined in the <code class="literal">package.json</code> file in the project root.</p><p>Then, we will run the project with <code class="literal">npm start</code>; this script, defined in <code class="literal">package.json</code>, is used to run the project in the local server.</p><p>Let's compile and run the project:</p><pre class="programlisting">
<span class="strong"><strong>$ npm start</strong></span>
</pre><p>If all the required dependencies are installed, this command will compile the TypeScript to plain JavaScript and will run the project in the local server.</p><p>The project will launch in a browser and will look as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_03_004.jpg" alt="Angular project"/></div><p>
</p><p>If this sample project runs successfully, then we are good to go in the next step, where we will add a test spec, which will include Karma, and run those tests with the Karma runner.</p></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec6"/>Getting ready</h3></div></div></div><p>As we cloned the sample <code class="literal">quickstart</code> project, it already integrated and configured Karma in the project. For the purpose of learning, we would like to integrate Karma in the existing project.</p><p>To do so, we will have to remove the existing <code class="literal">karma.conf.js</code> file from the project root directory. Also, we will remove the Karma, Jasmine, and related modules from <code class="literal">node_modules</code>.</p><p>Interestingly, instead of doing it manually, we can easily create the basic Karma config file with a simple command. And with that command, it will ask some basic questions as we saw in the previous part of this chapter.</p></div></div><div class="section" title="Setting up Karma"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec40"/>Setting up Karma</h2></div></div></div><p>To set up Karma in an Angular project, the first job is to create a <code class="literal">karma.conf.js</code> file in the project root directory. This file basically contains some configuration in key-value pairs.</p><p>Interestingly, instead of doing it manually, we can easily create the basic Karma config file with a simple command. And with that command, it will ask some basic questions as we saw in the previous part of this chapter:</p><pre class="programlisting">
<span class="strong"><strong>$ karma init</strong></span>
</pre><p>Use the default answers. After <code class="literal">karma.conf.js</code> has been created in the current directory, open the configuration. A few configurations may need to change, mostly the one that is the definition of the files for Karma to use.</p><p>Use the following definition in the <code class="literal">files</code> section, which defines the files required to run the test:</p><pre class="programlisting">files: [ &#13;
        // System.js for module loading &#13;
      'node_modules/systemjs/dist/system.src.js', &#13;
 &#13;
      // Polyfills &#13;
      'node_modules/core-js/client/shim.js', &#13;
      'node_modules/reflect-metadata/Reflect.js', &#13;
 &#13;
      // zone.js &#13;
      'node_modules/zone.js/dist/zone.js', &#13;
      'node_modules/zone.js/dist/long-stack-trace-zone.js', &#13;
      'node_modules/zone.js/dist/proxy.js', &#13;
      'node_modules/zone.js/dist/sync-test.js', &#13;
      'node_modules/zone.js/dist/jasmine-patch.js', &#13;
      'node_modules/zone.js/dist/async-test.js', &#13;
      'node_modules/zone.js/dist/fake-async-test.js', &#13;
 &#13;
// RxJs &#13;
      { pattern: 'node_modules/rxjs/**/*.js', included: false,&#13;
      watched: false },      { pattern: 'node_modules/rxjs&#13;
      /**/*.js.map', included: false,        watched: false }, &#13;
 &#13;
// Angular itself &#13;
      { pattern: 'node_modules/@angular/**/*.js', included: &#13;
      false,        watched: false }, &#13;
 &#13;
{ pattern: 'systemjs.config.js', included: false, watched: false }, &#13;
      { pattern: 'systemjs.config.extras.js', included: false,   &#13;
      watched: false }, &#13;
      'karma-test-shim.js', &#13;
 &#13;
          {pattern: 'app/**/*.js', included: false, watched: true} &#13;
    ] &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note7"/>Note</h3><p>Here, with the pattern, we have passed two options, <code class="literal">included</code> and <code class="literal">watched</code>. <code class="literal">included</code> refers to whether or not we want to include the file with the <code class="literal">&lt;script&gt;</code> tag; here, we will add it via SystemJS, so this is passed as <code class="literal">false</code>. And <code class="literal">watched</code> refers to whether or not this file will be watched during changes to the file. We have set <code class="literal">true</code>, as we want to watch the changes.</p></div></div><p>There seem to be a lot of files added, but these are basic and a must for running the test.</p><p>Let's take a closer look at what the files are. In the first chunk, these are mostly library files, including SystemJS as a module loader, zonejs as a sync handler, RxJS as a reactive library, and the Angular library itself.</p><p>Importantly, a new file in the second chunk is <code class="literal">karma-test-shim.js</code>, which we need to use with Karma as the module loader in test suites, that is, use SystemJS to load the modules in the Karma test runner. We will look at that file later in this section.</p><p>And then, it's all our app source file; we will put test/spec files on the same directory as well so that they will load all of our module files, including their test/spec files.</p><p>In addition to the files, we may need to change a few more configuration points based on requirements, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">plugins</code>: This is required as Karma will use these <code class="literal">npm</code> modules to perform. If we plan to use more <code class="literal">npm</code> modules, we will need to add them here; for example, if we plan to use PhantomJS as our browser, we will need to add <code class="literal">'karma-phantomjs-launcher'</code> in the list:<pre class="programlisting">        plugins: [ &#13;
'karma-jasmine', &#13;
'karma-chrome-launcher' &#13;
   ] &#13;
</pre></li><li class="listitem" style="list-style-type: disc"><code class="literal">frameworks</code>: This doesn't need to change for now, as by default it chooses Jasmine; however, it will need to be updated if we plan to use other frameworks, such as Mocha. In that case, the following option should be updated:<pre class="programlisting">        frameworks: ['jasmine'], &#13;
</pre></li><li class="listitem" style="list-style-type: disc"><code class="literal">browsers</code>: This is useful when we need to run the test in multiple browsers, and most of the time, we may need to run the test in PhantomJS, so we can add multiple browsers, as shown:<pre class="programlisting">        browsers: ['Chrome', 'PhantomJS'] &#13;
</pre></li></ul></div><p>So far, these are the basic changes we need in the <code class="literal">karma.con.js</code> files.</p><p>Let's take a look at our <code class="literal">karma.conf.js</code> file and see what it looks like:</p><pre class="programlisting">module.exports = function(config) { &#13;
 &#13;
  config.set({ &#13;
    basePath: '', &#13;
    frameworks: ['jasmine'], &#13;
    plugins: [ &#13;
      require('karma-jasmine'), &#13;
      require('karma-chrome-launcher') &#13;
    ], &#13;
 &#13;
    files: [ &#13;
      // System.js for module loading &#13;
      'node_modules/systemjs/dist/system.src.js', &#13;
 &#13;
      // Polyfills &#13;
      'node_modules/core-js/client/shim.js', &#13;
      'node_modules/reflect-metadata/Reflect.js', &#13;
 &#13;
      // zone.js &#13;
      'node_modules/zone.js/dist/zone.js', &#13;
      'node_modules/zone.js/dist/long-stack-trace-zone.js', &#13;
      'node_modules/zone.js/dist/proxy.js', &#13;
      'node_modules/zone.js/dist/sync-test.js', &#13;
      'node_modules/zone.js/dist/jasmine-patch.js', &#13;
      'node_modules/zone.js/dist/async-test.js', &#13;
      'node_modules/zone.js/dist/fake-async-test.js', &#13;
 &#13;
      // RxJs &#13;
      { pattern: 'node_modules/rxjs/**/*.js', included: false,&#13;
      watched: false },     &#13;
      { pattern: 'node_modules/rxjs/**/*.js.map', included: &#13;
      false,        watched: false }, &#13;
 &#13;
      // Paths loaded via module imports: &#13;
      // Angular itself &#13;
      { pattern: 'node_modules/@angular/**/*.js', included: &#13;
      false,        watched: false },&#13;
      { pattern: 'node_modules/@angular/**/*.js.map', included: &#13;
      false, watched: false },&#13;
      { pattern: 'systemjs.config.js', included: false, &#13;
      watched:        false },&#13;
      { pattern: 'systemjs.config.extras.js', included: false,&#13;
      watched: false },&#13;
 &#13;
      'karma-test-shim.js', &#13;
 &#13;
      { pattern: 'app/**/*.js', included: false, watched: true } &#13;
    ], &#13;
 &#13;
    port: 9876, &#13;
    colors: true, &#13;
    autoWatch: true, &#13;
    browsers: ['Chrome'], &#13;
    singleRun: false &#13;
  }) &#13;
}</pre><p>Another important file that we added in the files list is <code class="literal">karma-test-shim.js</code>; and as we mentioned earlier, it's needed for us to use SystemJS (the module loader) with Karma. We have copied the file from the Angular quick start project and it's possible to change this based on the project structure.</p><p>Let's take a look at our <code class="literal">karma.conf.js</code> file:</p><pre class="programlisting">Error.stackTraceLimit = 0; // "No stacktrace"" is usually best for app testing. &#13;
 &#13;
jasmine.DEFAULT_TIMEOUT_INTERVAL = 1000; &#13;
 &#13;
var builtPath = '/base/app/'; &#13;
 &#13;
__karma__.loaded = function () { }; &#13;
 &#13;
function isJsFile(path) { &#13;
  return path.slice(-3) == '.js'; &#13;
} &#13;
 &#13;
function isSpecFile(path) { &#13;
  return /\.spec\.(.*\.)?js$/.test(path); &#13;
} &#13;
 &#13;
function isBuiltFile(path) { &#13;
  return isJsFile(path) &amp;&amp; (path.substr(0, builtPath.length) == &#13;
  builtPath); &#13;
} &#13;
 &#13;
var allSpecFiles = Object.keys(window.__karma__.files) &#13;
  .filter(isSpecFile) &#13;
  .filter(isBuiltFile); &#13;
 &#13;
System.config({ &#13;
  baseURL: 'base', &#13;
  // Extend usual application package list with test folder &#13;
  packages: { 'testing': { main: 'index.js', defaultExtension: 'js' &#13;
  } }, &#13;
 &#13;
  // Assume npm: is set in `paths` in systemjs.config &#13;
  // Map the angular testing umd bundles &#13;
  map: { &#13;
    '@angular/core/testing':      &#13;
'npm:@angular/core/bundles/core-testing.umd.js',    &#13;
'@angular/common/testing':      &#13;
'npm:@angular/common/bundles/common-testing.umd.js',    &#13;
'@angular/compiler/testing':      &#13;
'npm:@angular/compiler/bundles/compiler-testing.umd.js',    &#13;
'@angular/platform-browser/testing':      &#13;
'npm:@angular/platform-browser/bundles/     &#13;
platform-browser-testing.umd.js',    &#13;
'@angular/platform-browser-dynamic/testing':      'npm:@angular/platform-browser-dynamic/bundles    &#13;
 /platform-browser-dynamic-testing.umd.js',    &#13;
'@angular/http/testing':      &#13;
'npm:@angular/http/bundles/http-testing.umd.js',    &#13;
'@angular/router/testing':      &#13;
'npm:@angular/router/bundles/router-testing.umd.js',    &#13;
'@angular/forms/testing':      &#13;
'npm:@angular/forms/bundles/forms-testing.umd.js', &#13;
  }, &#13;
}); &#13;
 &#13;
System.import('systemjs.config.js') &#13;
  .then(importSystemJsExtras) &#13;
  .then(initTestBed) &#13;
  .then(initTesting); &#13;
 &#13;
/** Optional SystemJS configuration extras. Keep going w/o it */ &#13;
function importSystemJsExtras(){ &#13;
  return System.import('systemjs.config.extras.js') &#13;
  .catch(function(reason) { &#13;
    console.log( &#13;
      'Warning: System.import could not load the optional        "systemjs.config.extras.js". Did you omit it by accident?        Continuing without it.' &#13;
    ); &#13;
    console.log(reason); &#13;
  }); &#13;
} &#13;
 &#13;
function initTestBed(){ &#13;
  return Promise.all([ &#13;
    System.import('@angular/core/testing'), &#13;
    System.import('@angular/platform-browser-dynamic/testing') &#13;
  ]) &#13;
 &#13;
  .then(function (providers) { &#13;
    var coreTesting    = providers[0]; &#13;
    var browserTesting = providers[1]; &#13;
 &#13;
    coreTesting.TestBed.initTestEnvironment( &#13;
      browserTesting.BrowserDynamicTestingModule, &#13;
      browserTesting.platformBrowserDynamicTesting()); &#13;
  }) &#13;
} &#13;
 &#13;
// Import all spec files and start karma &#13;
function initTesting () { &#13;
  return Promise.all( &#13;
    allSpecFiles.map(function (moduleName) { &#13;
      return System.import(moduleName); &#13;
    }) &#13;
  ) &#13;
  .then(__karma__.start, __karma__.error); &#13;
} &#13;
</pre><div class="section" title="Testing the Karma runner"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec7"/>Testing the Karma runner</h3></div></div></div><p>The initial set up of Karma is almost done; we will have to run our test and see how it's coming along. One more step before we run--we have to add the <code class="literal">karma</code> task in the <code class="literal">npm</code> script to run via the <code class="literal">npm</code> command. For that, we will have to add a task, as <code class="literal">test</code>, in the script section of the <code class="literal">package.json</code> file:</p><pre class="programlisting">"scripts": { &#13;
     "test": "karma start karma.conf.js" &#13;
  } &#13;
</pre><p>After adding this snippet, we can run the test via <code class="literal">npm</code>, with <code class="literal">npm test</code>, which works the same way as <code class="literal">karma start</code>:</p><pre class="programlisting">
<span class="strong"><strong>$ npm test</strong></span>
</pre><p>So, finally, we are ready to run our test via Karma. However, oops, we are getting some error! It's missing the <code class="literal">jasmine-core</code> module that is needed to run the test; in fact, there could be more modules missing.</p><p>The output with the error looks as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_03_005.jpg" alt="Testing the Karma runner"/></div><p>
</p><p>Yes, we are indeed missing the modules and these are actually the development dependencies in our test suite. We will get to know a bit more about them in the following section.</p></div><div class="section" title="Missing dependencies"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec8"/>Missing dependencies</h3></div></div></div><p>Though we are building a basic test suite for Angular, we are still missing a few required npm modules and these are the development dependencies for our test suite, which are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">jasmine-core</code>: This states that Jasmine is our test framework</li><li class="listitem" style="list-style-type: disc"><code class="literal">karma</code>: This is the Karma test runner of our test suite</li><li class="listitem" style="list-style-type: disc"><code class="literal">karma-chrome-launcher</code>: This is required to launch Chrome from Karma, as we defined Chrome as our browser in <code class="literal">karma.config</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">karma-jasmine</code>: This is the Karma adapter for Jasmine</li></ul></div><p>As long as these are the dependencies, we should install these modules and include them in <code class="literal">package.json</code> as well.</p><p>We can install all of these together, as shown here:</p><pre class="programlisting">
<span class="strong"><strong>$ npm install jasmine-core karma karma-chrome-launcher karma-&#13;
    jasmine --save-dev</strong></span>
</pre><p>After successfully installing all the required dependencies, it seems like  we are done with our configuration process, and we are ready to run <code class="literal">test</code> again:</p><pre class="programlisting">
<span class="strong"><strong>$ npm test</strong></span>
</pre><p>The command output should state something like this:</p><pre class="programlisting">
<span class="strong"><strong>$ Chrome 39.0.2623 (Mac OS X 10.10.5): Executed 0 of 0 ERROR &#13;
    (0.003 secs / 0 secs) </strong></span>
</pre><p>That is it. Karma is now running for the first Angular application.</p></div></div></div>
<div class="section" title="Testing with Angular and Karma"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Testing with Angular and Karma</h1></div></div></div><p>The purpose of this first test using Karma is to create a dynamic to-do list. This walk-through will follow the TDD steps we discussed in <a class="link" href="ch01.html" title="Chapter 1. Introduction to Test-Driven Development">Chapter 1</a>, <span class="emphasis"><em>Introduction to Test-Driven Development</em></span>: test first, make it run, and make it better. This will allow us to gain more experience in using TDD with an Angular application.</p><div class="section" title="A development to-do list"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec41"/>A development to-do list</h2></div></div></div><p>Before we start the test, let's set our focus on what needs to be developed using a development to-do list. This will allow us to organize our thoughts.</p><p>Here is the to-do list:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Maintain a list of items</strong></span>: The example list consists of test, execute, and refactor</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Add an item to the list</strong></span>: The example list after we add the item is test, execute, refactor, and repeat</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Remove an item from the list</strong></span>: The example list after we add and remove the item is test, execute, and refactor</li></ul></div></div><div class="section" title="Testing a list of items"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec42"/>Testing a list of items</h2></div></div></div><p>The first development item is to provide us with the ability to have a list of items on a component. The next couple of steps will walk us through the TDD process of adding the first feature using the TDD life cycle.
</p><div class="section" title="Test first"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec9"/>Test first</h3></div></div></div><p>Determining where to start is often the most difficult part. The best way is to remember the three <span class="strong"><strong>A</strong></span>s (<span class="strong"><strong>Assemble</strong></span>, <span class="strong"><strong>Act</strong></span>, and <span class="strong"><strong>Assert</strong></span>) and start with the base Jasmine template format. The code to do this is as follows:</p><pre class="programlisting">describe('Title of the test suite', () =&gt; { &#13;
    beforeEach(() =&gt; { &#13;
        // .... &#13;
    }); &#13;
     &#13;
    it('Title of the test spec', () =&gt; { &#13;
        // .... &#13;
    }); &#13;
}); &#13;
</pre><p>Let's look at the explanation:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">describe</code>: This defines the main feature that we are testing. The string will explain the feature in readable terms, and then the function will follow the test.</li><li class="listitem" style="list-style-type: disc"><code class="literal">beforeEach</code>: This is the assemble step. The function defined in this step will be executed before every assert. It is best to put the required test setup before each test in this function.</li><li class="listitem" style="list-style-type: disc"><code class="literal">it</code>: This is the act and assert step. In the <code class="literal">it</code> section, we will perform the action being tested, followed by some assertion. The act step doesn't have to go into the <code class="literal">it</code> function. Depending on the test, it might be more suited in the <code class="literal">beforeEach</code> function.</li></ul></div></div><div class="section" title="The three As - Assemble, Act, and Assert"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec10"/>The three As - Assemble, Act, and Assert</h3></div></div></div><p>Now that the template is ready, we can start fitting in the pieces. We will again follow the three As mantra.</p><p>The following are the two parts of the assemble section.</p><p>In the first part, we initialize the component and execute the contractor of the class using the following code:</p><pre class="programlisting">import { async, ComponentFixture, TestBed } from '@angular/core/testing'; &#13;
 &#13;
import { AppComponent } from './app.component'; &#13;
 &#13;
beforeEach(async(() =&gt; { &#13;
   TestBed.configureTestingModule({ &#13;
      declarations: [ AppComponent ] &#13;
    }) &#13;
    .compileComponents(); &#13;
  })); &#13;
 &#13;
beforeEach(() =&gt; { &#13;
    fixture = TestBed.createComponent(AppComponent); &#13;
    comp = fixture.componentInstance; &#13;
}); &#13;
... &#13;
</pre><p>Here, we imported some Angular testing APIs, such as <code class="literal">async</code> and <code class="literal">Testbed</code>. Here, <code class="literal">async</code> is used to load the required module to Bootstrap the application for the test suite, and <code class="literal">TestBed</code> is the primary API for writing a unit test for the Angular API. It has some service to create, compile, and initiate the components in the test suite.</p><p>We haven't defined the <code class="literal">AppComponent</code> component, but we will do this after we get a failing test.</p><p>The second part talks about the <code class="literal">AppComponent</code> object. The <code class="literal">AppComponent</code> object will contain the list of items on its <code class="literal">this</code> variable. Add the following code to <code class="literal">beforeEach</code> to get the component object:</p><pre class="programlisting">// comp will hold the component object  &#13;
let comp: AppComponent; &#13;
let fixture: ComponentFixture&lt;AppComponent&gt;; &#13;
beforeEach(() =&gt; { &#13;
    fixture = TestBed.createComponent(AppComponent); &#13;
    comp = fixture.componentInstance; &#13;
}); &#13;
</pre><p>In assert, there are two parts again:</p><p>The first assertion is to ensure that the <code class="literal">AppComponent</code> object has an <code class="literal">items</code> variable defined with three items. The <code class="literal">items</code> variable will be used to hold the list of all the items:</p><pre class="programlisting">it('Should define a list object', () =&gt; { &#13;
        expect(com.items).toBeDefined(); &#13;
    }); &#13;
</pre><p>The second and third assertions will be used to confirm whether the data in the list is correct:</p><pre class="programlisting">//Second test &#13;
it('Should have 3 items in list', () =&gt; { &#13;
        expect(com.items.length).toBe(3); &#13;
    }); &#13;
 &#13;
//Third test &#13;
it('List items should be as expected', () =&gt; { &#13;
        expect(com.items).toEqual(['test','execute','refactor']); &#13;
    }); &#13;
</pre><p>That's it; the first is test, the second is execute, and the third is refactor.</p></div><div class="section" title="Make it run"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec11"/>Make it run</h3></div></div></div><p>The next step in the TDD life cycle is to make the application run and fix the code so that the tests pass. Remember, think about the smallest components that can be added to make the test pass by proceeding with the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Run the Karma test by typing the following command:<pre class="programlisting">
<span class="strong"><strong>$ npm start</strong></span>
<span class="strong"><strong>$ npm test</strong></span>
</pre></li><li class="listitem">If we encounter the <code class="literal">TypeError: app_component_1.AppComponent is not a constructor</code> error, then it can be due to the following:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The preceding error message is saying that the <code class="literal">AppComponent</code> object hasn't been defined. Since the error message is telling us what is required, this is the perfect place to start.</li></ul></div><p>
</p></li><li class="listitem">Add the <code class="literal">AppComponent</code> class to the <code class="literal">app.component.ts</code> file, as follows:<pre class="programlisting">        export class AppComponent { };</pre></li><li class="listitem">Run the <code class="literal">start</code> and <code class="literal">test</code> command again from the <code class="literal">npm</code> console. We should now see a new error. <span class="strong"><strong>Error:</strong></span> <code class="literal">The expected undefined to be defined as follow</code><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The new error message is again clear. We can also see that the code has now passed up to the point of our assertion at the following point:<pre class="programlisting">               expect(com.items).toBeDefined();</pre></li><li class="listitem" style="list-style-type: disc">As there are no items in the object, we need to add one. Update the <code class="literal">app/app.component.ts</code> file as follows:<pre class="programlisting">              export class AppComponent { &#13;
                  items:Array&lt;string&gt;; &#13;
              }; &#13;
</pre></li></ul></div></li><li class="listitem">Let's run the <code class="literal">start</code> and <code class="literal">test</code> commands again from the <code class="literal">npm</code> console. We should now see one of the three tests pass! This means that we have successfully used TDD and Karma to get our first test to pass. Now, we need to fix the other three.<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The next error is: <code class="literal">expected 0 to equal 3 </code></li><li class="listitem" style="list-style-type: disc">The error output again describes exactly what needs to happen. We just need to initialize the array with the elements test, execute, and run. Let's go to <code class="literal">app/app.component.ts</code> and add the data to the array initialization:<pre class="programlisting">            export class AppComponent { &#13;
                items:Array&lt;string&gt;; &#13;
                constructor() { &#13;
                    this.items = ['test','execute','refactor']; &#13;
                } &#13;
            }; &#13;
</pre></li></ul></div></li><li class="listitem">Run the <code class="literal">start</code> and <code class="literal">test</code> commands again from the npm console. Excellent! The output is in green and states that all the tests have passed. The result component and class code from this step are as follows:<pre class="programlisting">        import {Component} from '@angular/core'; &#13;
 &#13;
        @Component({ &#13;
            // ...  &#13;
        }) &#13;
 &#13;
        export class AppComponent { &#13;
            items:Array&lt;string&gt;; &#13;
            constructor() { &#13;
                this.items = ['test','execute','refactor']; &#13;
            } &#13;
        }; &#13;
</pre></li></ol></div><p>Now that the <span class="emphasis"><em>Make it run</em></span> step is complete, we can move on to the next step and make it better.
</p></div><div class="section" title="Make it better"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec12"/>Make it better</h3></div></div></div><p>Until this point, there was nothing required to directly refactor or that had been identified in the development to-do list. A review of the development to-do list shows that an item can be crossed out:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>View a list of to-do list items</strong></span>: The example list consists of test, execute, and refactor</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Add an item to a to-do-list</strong></span>: The example list after we add the item will consist of test, execute, refactor, and new item</li></ul></div><p>Next up is the requirement to add a new item to the list. The TDD rhythm will be followed again: test first, make it run, and make it better.</p></div></div><div class="section" title="Adding a function to the component class"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec43"/>Adding a function to the component class</h2></div></div></div><p>The next task is to give the class the ability to add items to the object. This will require the addition of a method to the object. This walk-through will follow the same TDD steps that we followed previously.</p><div class="section" title="Test first"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec13"/>Test first</h3></div></div></div><p>Instead of creating a new file and duplicating some of the assemble steps, the following test will be inserted under the last <code class="literal">it</code> method. The reason is that the same module and controller will be used:</p><pre class="programlisting">describe('Title of the test suite', () =&gt; { &#13;
    let app:AppComponent; &#13;
 &#13;
    beforeEach(() =&gt; { &#13;
        // .... &#13;
    }); &#13;
     &#13;
    it('Title of the test spec', () =&gt; { &#13;
        // .... &#13;
    }); &#13;
 &#13;
    describe('Testing add method', () =&gt; { &#13;
 &#13;
    beforeEach(() =&gt; { &#13;
        // .... &#13;
    }); &#13;
     &#13;
    it('Title of the test spec', () =&gt; { &#13;
        // .... &#13;
    }); &#13;
   }); &#13;
}); &#13;
</pre></div><div class="section" title="The three As - Assemble, Act, and Assert"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec14"/>The three As - Assemble, Act, and Assert</h3></div></div></div><p>Now that the template is ready, we can start filling in the gaps using the 3 As mantra:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Assemble</strong></span>: There is no initialization or setup required as the component and object will be inherited.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Act</strong></span>: Here, we need to act on the <code class="literal">add</code> method with a new item. We place the <code class="literal">act</code> function into the <code class="literal">beforEach</code> function. This allows us to repeat the same step if/when more tests are added:<pre class="programlisting">        beforeEach(() =&gt; { &#13;
             com.add('new-item') &#13;
        }); &#13;
</pre></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Assert</strong></span>: Here, an item should be added to the list, and then you need to confirm that the last item in the array is as expected:<pre class="programlisting">        it('Should have 4 items in list', () =&gt; { &#13;
             expect(com.items.length).toBe(4); &#13;
        }); &#13;
        it('Should add a new item at the end of list', () =&gt; { &#13;
            var lastIndexOfList = com.items.length - 1; &#13;
            expect(com.items[lastIndexOfList]).toEqual('new-item'); &#13;
        }); &#13;
</pre></li></ul></div></div><div class="section" title="Make it run"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec15"/>Make it run</h3></div></div></div><p>The next step in the TDD life cycle is to make it run. Remember, think about the smallest components that can be added to make the test pass, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Ensure that Karma is running in our console by typing in the following commands:<pre class="programlisting">
<span class="strong"><strong>$ npm start</strong></span>
<span class="strong"><strong>$ npm test</strong></span>
</pre></li><li class="listitem" style="list-style-type: disc">The first error will state <code class="literal">TypeError: undefined is not a function</code>.<p>This error refers to the following line of code:</p><pre class="programlisting">        app.add('new-item'); &#13;
</pre><p>The error is telling us that the <code class="literal">add</code> method hasn't been defined. The <code class="literal">add</code> function will need to be added to the <code class="literal">app/app.component.ts</code> code. The class has already been defined, so the <code class="literal">add</code> function needs to be placed in the class:</p><pre class="programlisting">        add() { &#13;
                this.items.push('new-item'); &#13;
        }; &#13;
</pre><p>Note how the <code class="literal">add</code> function doesn't contain any logic. The smallest component has been added to get the test to satisfy the error message.</p></li><li class="listitem" style="list-style-type: disc">Review the console window for the next error.</li></ul></div><p>Success! All five tests have now passed.</p><p>The resulting code added to get the tests to pass is as follows:</p><pre class="programlisting">import {Component} from '@angular/core'; &#13;
 &#13;
@Component({ &#13;
    selector: 'my-app', &#13;
    template: `&lt;h3&gt;MY Items&lt;/h3&gt;&lt;ul&gt;&lt;li *ngFor="let item of items"&gt;{{ &#13;
    item }}&lt;/li&gt;&lt;/ul&gt;` &#13;
}) &#13;
 &#13;
export class AppComponent { &#13;
    items:Array&lt;string&gt;; &#13;
    constructor() { &#13;
        this.items = ['test','execute','refactor']; &#13;
    } &#13;
    add() { &#13;
        this.items.push('new-item'); &#13;
    } &#13;
}; &#13;
</pre></div><div class="section" title="Make it better"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec16"/>Make it better</h3></div></div></div><p>The main thing that we need to refactor is that the <code class="literal">add</code> function still hasn't been fully implemented. It contains a hard coded value, and the minute we send in a different item into the <code class="literal">add</code> function, the test will fail.</p><p>Keep Karma running so that we can keep passing the tests as changes are made. The main issue with the current <code class="literal">add</code> method is as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It doesn't accept any parameters</li><li class="listitem" style="list-style-type: disc">It doesn't push a parameter onto the list but uses a hardcoded value</li></ul></div><p>The resultant <code class="literal">add</code> function should now look as follows:</p><pre class="programlisting">        add(item) { &#13;
            this.items.push(item); &#13;
        }; &#13;
</pre><p>Run the <code class="literal">start</code> and <code class="literal">test</code> commands again from the <code class="literal">npm</code> console. Confirm that the Karma output still displays <code class="literal">SUCCESS</code>:</p><pre class="programlisting">
<span class="strong"><strong>$ Chrome 49.0.2623 (Mac OS X 10.10.5): Executed 5 of 5 SUCCESS&#13;
    (0.016 secs / 0.002 secs)</strong></span>
</pre></div></div></div>
<div class="section" title="Configuring Karma with Travis CI"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Configuring Karma with Travis CI</h1></div></div></div><p><span class="strong"><strong>Continuous integration </strong></span>(<span class="strong"><strong>CI</strong></span>) is a development practice where developers need to integrate code into a shared repository. It is run in the automated build process with a test when any change happens in the codebase. This detects the error early, before it is pushed to production. There are lot of CI services around, including Travis CI, Jenkin CI, Circle CI, and so on.</p><p>In this section, we will see how we can integrate Karma with Travis.</p><div class="section" title="Travis CI"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec44"/>Travis CI</h2></div></div></div><p>Travis CI is a popular hosted continuous integration platform that integrates with the GitHub project/repository to automatically run the test with every change in the code base of any branch or even with a pull request. It's easy to get the integration system just by putting a <code class="literal">.travis.yml</code> file in the project root with some configuration information about the project.</p><p>So, we may ask, why Travis? There are a few other CI services around. If we compare Travis to the other CI services, it has some benefits over the others:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It's a hosted service; there is no need to host, install, and configure</li><li class="listitem" style="list-style-type: disc">It's free and open source</li><li class="listitem" style="list-style-type: disc">It has a separate test code for every branch, so it is easy to run a test for an individual branch</li></ul></div></div><div class="section" title="Configuring Travis"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec45"/>Configuring Travis</h2></div></div></div><p>As we said, we will have a <code class="literal">.travis.yml</code> file in our project directory with some configuration and information about our project.</p><p>Here is what the basic configuration in the YAML file looks like:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Specify the language</strong></span>: We have used Node.js here:<pre class="programlisting">        language: node_js &#13;
        node_js: &#13;
            -  "4" &#13;
</pre></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Command or script</strong></span>: This is required to run before or after each build; as shown here, this script will set the <code class="literal">git</code> username every time before running the build:<pre class="programlisting">        before_script: &#13;
            -  git config - -global user.name jquerygeek  &#13;
</pre></li></ul></div><p>In the preceding example, we have passed the configuration to run the build process in a real browser (Firefox) with a virtual screen, by default, with karma. It has run the process in the PhantomJS headless browser. This might come in handy, as long as Travis supports the real browser beside PhantomJS:</p><pre class="programlisting">        before_script: &#13;
            -  export DISPLAY=:99.0 &#13;
            - sh -e /etc/init.d/xvfb start  &#13;
</pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Notifications</strong></span>: This is required to set the notifications for e-mail and chat. Here, we have set <code class="literal">false</code> for <code class="literal">email</code>, as we do not want overtime e-mail notifications about the builds:<pre class="programlisting">        notifications: &#13;
            email: false  &#13;
</pre></li></ul></div></div><div class="section" title="Setting up the test with Karma"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec46"/>Setting up the test with Karma</h2></div></div></div><p>As seen earlier, we are guessing that we have the <code class="literal">package.json</code> file in our project root among the npm packages; if not, let's create a <code class="literal">package.json</code> file over there and add these configuration snips. Here, the first one is a dependency of Karma and the second one is to set the required params for the <code class="literal">npm test</code>, as Travis will run this to trigger our test. These will tell Travis how to run our test:</p><pre class="programlisting">  'devDependencies': { &#13;
      'karma': '~0.12' &#13;
  }, &#13;
 &#13;
  'scripts': { &#13;
      'test': 'karma start  - -single-run - -browsers PhantomJS ' &#13;
  } &#13;
</pre><p>Our initial setup and configuration are ready for testing. We defined the Karma dependency, as Travis will run <code class="literal">nmp install</code> for every suite, and will take the necessary steps for adding Karma. And for running the test, it will call the <code class="literal">npm test</code>, and we defined how that test task will run the test. Here, we have set the default browser to PhantomJS so that the test will run with it. However, if we need to run the test with a different browser, we should define that in the <code class="literal">.travis.yml</code> file with the <code class="literal">before_script</code> command, as we showed earlier for Firefox.</p><p>In that case, <code class="literal">npm test</code> will not run the test with the custom browser; for that, we have to do a custom call with the browser name, as follows:</p><pre class="programlisting">
<span class="strong"><strong>karma start - -browsers Firefox - -single-run </strong></span>
</pre></div></div>
<div class="section" title="Self-test questions"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Self-test questions</h1></div></div></div><p>The following self-test questions will help you further test your knowledge of using TDD with AngularJS and Karma:</p><p>Q1. How do you use Karma to create a configuration file?</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><code class="literal">karma config</code></li><li class="listitem"><code class="literal">karma init</code></li><li class="listitem"><code class="literal">karma -config karma.conf.js</code></li></ol></div><p>Q2. The Jasmine test method, named <code class="literal">before</code>, gets executed before every test.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">True</li><li class="listitem">False</li></ol></div><p>Q3. Bower is used to install Karma.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">True</li><li class="listitem">False</li></ol></div><p>Q4. The 3 As stand for which one of these?</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">A group of super heroes</li><li class="listitem">Assemble, Act, and Assert</li><li class="listitem">Accept, Approve, and Act</li></ol></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec29"/>Summary</h1></div></div></div><p>In this chapter, we discussed how Karma became important. We saw how to install, configure, and run Karma. Finally, we walked through an Angular example project using Karma with TDD.</p><p>In the next chapter, we will learn about end-to-end testing with Protractor.</p></div></body></html>