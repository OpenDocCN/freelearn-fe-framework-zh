- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multipage Apps with React Router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Build multipage single-page applications (and understand why this is not an
    oxymoron)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the React Router package to load different React components for different
    URL paths
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create static and dynamic routes (and understand what routes are in the first
    place)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigate the website via both links and programmatic commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build nested page layouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having worked through the first twelve chapters of this book, you should now
    know how to build React components and web apps, as well as how to manage components
    and app-wide state, and how to share data between components (via props or context).
  prefs: []
  type: TYPE_NORMAL
- en: But even though you know how to compose a React website from multiple components,
    all these components are on the same single website page. Sure, you can display
    components and content conditionally, but users will never switch to a different
    page. This means that the URL path will never change; users will always stay on
    `your-domain.com` . Also, at this point in time, your React apps don’t support
    any paths such as `your-domain.com/products` or `your-domain.com/blog/latest`
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Uniform Resource Locators** ( **URLs** ) are references to web resources.
    For example, [https://academind.com/courses](https://academind.com/courses) is
    a URL that points to a specific page of the author’s website. In this example,
    `academind.com` is the **domain name** of the website and `/courses` is the **path**
    to a specific website page.'
  prefs: []
  type: TYPE_NORMAL
- en: For React apps, it might make sense that the path of the loaded website never
    changes. After all, in *Chapter 1* , *React – What and Why* , you learned that
    you build **single-page applications** ( **SPAs** ) with React.
  prefs: []
  type: TYPE_NORMAL
- en: But even though it might make sense, it’s also quite a serious limitation.
  prefs: []
  type: TYPE_NORMAL
- en: One Page Is Not Enough
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having just a single page means that complex websites that would typically consist
    of multiple pages (e.g., an online shop with pages for products, orders, and more)
    become quite difficult to build with React. Without multiple pages, you have to
    fall back to state and conditional values to display different content on the
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: But without changing URL paths, your website visitors can’t share links to anything
    but the starting page of your website. Also, any conditionally loaded content
    will be lost when a new visitor visits that starting page. That will also be the
    case if users simply reload the page they’re currently on. A reload fetches a
    new version of the page, and so any state (and therefore user interface) changes
    are lost.
  prefs: []
  type: TYPE_NORMAL
- en: For these reasons, you absolutely need a way of including multiple pages (with
    different URL paths) in a single React app for most React websites. Thanks to
    modern browser features and a highly popular third-party package, that is indeed
    possible (and the default for most React apps).
  prefs: []
  type: TYPE_NORMAL
- en: 'Via the **React Router** package, your React app can listen to URL path changes
    and display different components for different paths. For example, you could define
    the following path-component mappings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<domain>/` => `<Home />` component is loaded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<domain>/products` => `<ProductList />` component is loaded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<domain>/products/p1` => `<ProductDetail />` component is loaded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<domain>/about` => `<AboutUs />` component is loaded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technically, it will still be a SPA because there’s still only one HTML page
    being sent to website users. But in that single-page React app, different components
    are rendered conditionally by the React Router package based on the specific URL
    paths that are being visited. As the developer of the app, you don’t have to manually
    manage this kind of state or render content conditionally—React Router will do
    it for you. In addition, your website is able to handle different URL paths, and
    therefore, individual pages can be shared or reloaded.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Started with React Router and Defining Routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React Router is a third-party React library that can be installed in any React
    project. Once installed, you can use various components in your code to enable
    the aforementioned features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside your React project, the package is installed via this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Once installed, you can import and use various components (and Hooks) from that
    library.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start supporting multiple pages in your React app, you need to set up **routing**
    by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create different components for your different pages (e.g., `Dashboard` and
    `Orders` components).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `createBrowserRouter()` function and the `RouterProvider` component
    from the React Router library to enable routing and define the **routes** that
    should be supported by the React app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this context, the term **routing** refers to the React app being able to
    load different components for different URL paths (e.g., different components
    for the `/` and `/orders` paths). A route is a definition that’s added to the
    React app that defines the URL path for which a predefined JSX snippet should
    be rendered (e.g., the `Orders` component should be loaded for the `/orders` path).
  prefs: []
  type: TYPE_NORMAL
- en: 'In an example React app that contains `Dashboard` and `Orders` components,
    and wherein the React Router library was installed via `npm install` , you can
    enable routing and navigation between these two components by editing the root
    component (in `src/App.jsx` ) like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: You can find the complete example code on GitHub at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/01-getting-started-with-routing](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/01-getting-started-with-routing)
    .
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code snippet, React Router’s `createBrowserRouter()` function
    is called to create a `router` object that contains the application’s route configuration
    (a list of available routes). The array passed to `createBrowserRouter()` contains
    route definition objects, where every object defines a `path` for which the route
    should be matched and an `element` that should be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: React Router’s `RouterProvider` component is then used to set the `router` configuration
    and define a place for the active route elements to be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: You can think of the `<RouterProvider />` element being replaced with the content
    defined via the `element` property once a route becomes active. Therefore, the
    positioning of the `RouterProvider` component matters. In this case (and probably
    in most React apps), it’s the root application component—i.e., React Router, that
    should control the entire application component tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the provided example React app (via `npm run dev` ), you’ll see
    the following output on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_13_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.1: The Dashboard component content is loaded'
  prefs: []
  type: TYPE_NORMAL
- en: 'The content of the `Dashboard` component is displayed on the screen if you
    visit `localhost:5173` . Please note that the visible page content is not defined
    in the `App` component (in the code snippet shared previously). Instead, only
    two route definitions were added: one for the `/` path (i.e., for `localhost:5173/`
    or just `localhost:5173` , without the trailing forward slash—it’s handled in
    the same way) and one for the `/orders` path ( `localhost:5173/orders` ).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: '`localhost` is a local address that’s typically used for development. When
    you deploy your React app (i.e., you upload it to a web server), you will receive
    a different domain—or assign a custom domain. Either way, it will not be `localhost`
    after deployment.'
  prefs: []
  type: TYPE_NORMAL
- en: The part after `localhost` ( `:5173` ) defines the network port to which the
    request will be sent. Without the additional port information, ports `80` or `443`
    (as the default HTTP(S) ports) are used automatically. During development, however,
    these are not the ports you want. Instead, you would typically use ports such
    as `5173` , `8000` , or `8080` as these are normally unoccupied by any other system
    processes and hence can be used safely. Projects created via Vite typically use
    port `5173` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `localhost:5173` is loaded by default (when running `npm run dev` ),
    the first route definition ( `{ path: ''/'', element: <Dashboard /> }` ) becomes
    active. This route is active because its path ( `''/''` ) matches the path of
    `localhost:5173` (since this is the same as `localhost:5173/` ).'
  prefs: []
  type: TYPE_NORMAL
- en: As a result, the JSX code defined via `element` is rendered in place of the
    `<RouterProvider>` component by React Router. In this case, this means that the
    content of the `Dashboard` component is displayed because the `element` property
    value of this route definition is `<Dashboard />` . It is quite common to use
    single components (such as `<Dashboard />` , in this example), but you could set
    any JSX content as a value for the `element` property.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, no complex page is displayed. Instead, only some text
    shows up on the screen. This will change later in this chapter, though.
  prefs: []
  type: TYPE_NORMAL
- en: 'But it gets interesting if you manually change the URL from just `localhost:5173`
    to `localhost:5173/orders` in the browser address bar. In any of the previous
    chapters, this would not have changed the page content. But now, with routing
    enabled and the appropriate routes being defined, the page content does change,
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_13_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.2: For /orders, the content of the Orders component is displayed'
  prefs: []
  type: TYPE_NORMAL
- en: Once the URL changes, the content of the `Orders` component is displayed on
    the screen. It’s again just some basic text in this first example, but it shows
    that different code is rendered for different URL paths.
  prefs: []
  type: TYPE_NORMAL
- en: However, this basic example has a major flaw (besides the quite boring page
    content). Right now, users must enter URLs manually. But, of course, that’s not
    how you typically use websites.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Page Navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To allow users to switch between different website pages without editing the
    browser address bar manually, websites normally contain links, typically added
    via the `<a>` HTML element (the anchor element), like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'For this example, on-page navigation could therefore be added by modifying
    the `Dashboard` component code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code snippet, a link to the `/orders` route has been added. Website
    visitors therefore see this page now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_13_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.3: A navigation link was added'
  prefs: []
  type: TYPE_NORMAL
- en: When website users click this link, they are therefore taken to the `/orders`
    route and the content of the `Orders` component is displayed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach works but has a major flaw: the website is reloaded every time
    a user clicks the link. You can tell that it’s reloaded because the browser’s
    refresh icon changes to a cross (briefly) whenever you click a link.'
  prefs: []
  type: TYPE_NORMAL
- en: This happens because the browser sends a new HTTP request to the server whenever
    a link is clicked. Even though the server always returns the same single HTML
    page, the page is reloaded during that process (because of the new HTTP request
    that was sent).
  prefs: []
  type: TYPE_NORMAL
- en: While that’s not a problem on this simple demo page, it would be an issue if
    you had some shared state (e.g., app-wide state managed via context) that should
    not be reset during a page change. In addition, every new request takes time and
    forces the browser to download all website assets (e.g., script files) again.
    Even though those files might be cached, this is an unnecessary step that may
    impact website performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following, slightly adjusted, example `App` component illustrates the state-resetting
    problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: The code for this example can be found at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/03-naive-navigation-problem](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/03-naive-navigation-problem)
    .
  prefs: []
  type: TYPE_NORMAL
- en: In this example, a simple counter was added to the `App` component. Since `<RouterProvider>`
    is rendered in that same component, below the counter, the `App` component should
    not be replaced when a user visits a different page (instead, it’s `<RouterProvider>`
    that should be replaced—not the entire `App` component JSX code).
  prefs: []
  type: TYPE_NORMAL
- en: 'At least, that’s the theory. But, as you can see in the following screenshot,
    the `counter` state is lost whenever any link is clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_13_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.4: The counter state is reset when switching the page'
  prefs: []
  type: TYPE_NORMAL
- en: In the screenshot, you can see that the counter is initially set to `3` (because
    the button was clicked thrice). After navigating from `Dashboard` to the `Orders`
    page (via clicking the `Orders page` link), the counter changes to `0` .
  prefs: []
  type: TYPE_NORMAL
- en: That happens because the page is reloaded due to the HTTP request that’s sent
    by the browser.
  prefs: []
  type: TYPE_NORMAL
- en: To work around this issue and avoid this unintended page reload, you must prevent
    the browser’s default behavior. Instead of sending a new HTTP request, the browser
    URL address should just be updated (from `localhost:5173` to `localhost:5173/orders`
    ) and the target component ( `Orders` ) should be loaded. Therefore, to the website
    user, it would seem as if a different page was loaded. But behind the scenes,
    it’s just the page document (the DOM) that was updated.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, you don’t have to implement the logic for this on your own. Instead,
    the React Router library exposes a special `Link` component that should be used
    instead of the anchor `<a>` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this new component, the code in `src/routes/Dashboard.jsx` must be adjusted
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: The code for this example can be found at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/04-react-router-navigation](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/04-react-router-navigation)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Inside this updated example, the new `Link` component is used. That component
    requires a `to` prop, which is used to define the URL path that should be loaded.
  prefs: []
  type: TYPE_NORMAL
- en: By using this component in place of the `<a>` anchor element, the counter state
    is no longer reset. This is because React Router now prevents the browser’s default
    behavior (i.e., the unintended page reload described above) and displays the correct
    page content.
  prefs: []
  type: TYPE_NORMAL
- en: Under the hood, the `Link` component still renders the built-in `<a>` element.
    But React Router controls it and implements the behavior described above.
  prefs: []
  type: TYPE_NORMAL
- en: The `Link` component is therefore the default component that should be used
    for internal links. For external links, the standard `<a>` element should be used
    instead since the link leads away from the website, hence there is no state to
    preserve or page reload to prevent.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Layouts & Nested Routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most websites require some form of page-wide navigation (and hence navigation
    links) or other page sections that should be shared across some or all routes.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the previous example website with the routes `/` and `/orders` . The
    example website would also benefit from having a top navigation bar that allows
    users to switch between the starting page (i.e., the `Dashboard` route) and the
    `Orders` page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, `App.jsx` could be adjusted to have a top navigation bar inside
    a `<header>` above `<RouterProvider>` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: But if you try to run this application, you’ll see a blank page and encounter
    an error message in the JavaScript console in the browser developer tools.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_13_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.5: React Router seems to complain about something'
  prefs: []
  type: TYPE_NORMAL
- en: The error message is a bit cryptic, but the problem is that the above code tries
    to use `<Link>` outside of a component controlled by React Router.
  prefs: []
  type: TYPE_NORMAL
- en: Only components loaded via `<RouterProvider>` are controlled by React Router,
    hence React Router features like its `Link` component can only be used in route
    components (or their descendent components).
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, setting up the main navigation inside of the `App` component (which
    is **not** loaded by React Router) does not work.
  prefs: []
  type: TYPE_NORMAL
- en: To wrap or enhance multiple route components with some shared component and
    JSX markup, you must define a new route that wraps the existing routes. Such a
    route is also sometimes called a **layout route** since it can be used to provide
    some shared layout. The routes wrapped by this route would be called **nested
    routes** .
  prefs: []
  type: TYPE_NORMAL
- en: A layout route is defined like any other route inside the route definitions
    array. It then becomes a layout route by wrapping other routes via a special `children`
    property that’s accepted by React Router. That `children` property receives an
    array of nested routes—child routes to the wrapping parent route.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the adjusted route definition code for this example app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this updated code snippet, a new root layout route is defined—a route that
    registers the existing routes (the `Dashboard` and `Orders` components) as child
    routes. This setup therefore allows the `Root` component to be active simultaneously
    to the `Dashboard` or `Orders` route component.
  prefs: []
  type: TYPE_NORMAL
- en: You might also note that the `Dashboard` route no longer has a `path` . Instead,
    it now has an `index` property, which is set to `true` . That `index` property
    is a property that can be used when working with nested routes. It tells React
    Router which nested route to activate (and therefore which component to load)
    if the parent route path is matched exactly.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, when the `/` path is active (i.e., if a user visits `<domain>/`
    ), the `Root` and `Dashboard` components will be rendered. For `<domain>/orders`
    , `Root` and `Orders` would become visible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Root` component is a newly added component in this example. It’s a standard
    component (like `Dashboard` or `Orders` ) with one special feature: it defines
    the place where the child route components should be inserted via a special `Outlet`
    component that’s provided by React Router:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `<Outlet />` placeholder is needed since React Router must know where to
    render the route components of the routes passed to the `children` property.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: You can find the complete example code on GitHub at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/05-layouts-nested-routes](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/05-layouts-nested-routes)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Since the `Root` component itself is also rendered by React Router, it now is
    a component that has access to the `<Link>` tag. Therefore, this `Root` component
    can be used to share common markup (like the navigation `<header>` ) across all
    nested routes.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_13_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.6: A shared navigation bar is displayed at the top (for all routes)'
  prefs: []
  type: TYPE_NORMAL
- en: Hence, nested routes and layout routes (or wrapper routes) are crucial features
    offered by React Router.
  prefs: []
  type: TYPE_NORMAL
- en: It’s also worth noting that you can add as many levels of route nesting as needed
    by your application—you’re **not** restricted to having just one layout route
    that wraps child routes.
  prefs: []
  type: TYPE_NORMAL
- en: From Link to NavLink
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a shared navigation, as set up in the previous chapter, you often want to
    highlight the link that led to the currently active page. For example, if a user
    clicked the `Past Orders` link (and hence navigates to `/orders` ), that link
    should change its appearance (e.g., its color).
  prefs: []
  type: TYPE_NORMAL
- en: Consider the example from previously ( *Figure 13.6* )—there, in the top navigation
    bar, it’s not immediately obvious whether the user is on the `Dashboard` page
    or the `Orders` page. Of course, the URL address and the main page content do
    change, but the navigation items don’t adjust visually.
  prefs: []
  type: TYPE_NORMAL
- en: 'To prove this point, compare the previous screenshot to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_13_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.7: The highlighted “Past Orders” navigation link is underlined and
    changes its color'
  prefs: []
  type: TYPE_NORMAL
- en: In this version of the website, it’s immediately clear that the user is on the
    `"Orders"` page since the `Past Orders` navigation link is highlighted. It’s subtle
    things such as this that make websites more usable and can ultimately lead to
    higher user engagement.
  prefs: []
  type: TYPE_NORMAL
- en: But how can this be achieved?
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, you would not use the `Link` component, but instead, a special
    alternative component offered by `react-router-dom` : the `NavLink` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `NavLink` component is used pretty much like the `Link` component. You wrap
    it around some text (the link’s caption), and you define the target path via the
    `to` prop. However, the `NavLink` component has some extra styling-related features
    the regular `Link` component does not have.
  prefs: []
  type: TYPE_NORMAL
- en: To be precise, the `NavLink` component by default applies a CSS class called
    `active` to the rendered anchor element when the link is active.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B31339_13_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.8: The rendered <a> element received an “active” CSS class'
  prefs: []
  type: TYPE_NORMAL
- en: 'In case you want to apply a different CSS class name or inline styles when
    a link becomes active, `NavLink` also allows you to do that. Because `NavLink`
    ''s `className` and `style` props behave slightly differently than they do on
    other elements. Besides accepting string values ( `className` ) or style objects
    ( `style` ), both props also accept functions that will automatically be called
    by React Router upon every navigation action. For example, the following code
    could be used to ensure that a certain CSS class or style is applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the above code snippet, both `className` and `style` take advantage of the
    function that will be executed by React Router. This function automatically receives
    an object as an input argument—an object that’s created and provided by React
    Router, and that contains an `isActive` property. React Router sets `isActive`
    to `true` if the link leads to the currently active route, and to `false` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: You can therefore return any CSS class names or style objects of your choosing
    in those functions. React Router will then apply them to the rendered `<a>` element.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: You can find the finished code for this example on GitHub at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/06-navlinks](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/06-navlinks)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'One important note is that `NavLink` will consider a route to be active if
    its path matches the current URL path *or* if its path starts with the current
    URL path. For example, if you had a `/blog/all-posts` route, a `NavLink` component
    that points at just `/blog` would be considered active if the current route is
    `/blog/all-posts` (because that route path starts with `/blog` ). If you don’t
    want this behavior, you can add the special `end` prop to the `NavLink` component,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: With this special prop added, this `NavLink` would only be considered active
    if the current route is exactly `/blog` —for `/blog/all-posts` , the link would
    not be active.
  prefs: []
  type: TYPE_NORMAL
- en: An exception from that rule would be links to just `/` . Since all routes technically
    start with this “empty path,” React Router by default only considers `<NavLink
    to="/">` as active if the user is currently on `<domain>/` . For other paths (e.g.,
    `/orders` ), `<NavLink to="/">` would not be marked as active.
  prefs: []
  type: TYPE_NORMAL
- en: '`NavLink` is always the preferred choice when the styling of a link depends
    on the currently active route. For all other internal links, use `Link` . For
    external links, `<a>` is the element of choice.'
  prefs: []
  type: TYPE_NORMAL
- en: Route Components versus “Normal” Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s worth mentioning and noting that, in the previous examples, the `Dashboard`
    and `Orders` components were regular React components. You could use these components
    anywhere in your React app—not just as values for the `element` property of a
    route definition.
  prefs: []
  type: TYPE_NORMAL
- en: However, the two components are special in that both are stored in the `src/routes`
    folder in the project directory. They are not stored in the `src/components` folder,
    which was used for components throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: That’s not something you have to do, though. Indeed, the folder names are entirely
    up to you. These two components could be stored in `src/components` . You could
    also store them in an `src/elements` folder. But using `src/routes` is quite common
    for components that are exclusively used for routing. Popular alternatives are
    `src/screens` , `src/views` , and `src/pages` (again, it is up to you).
  prefs: []
  type: TYPE_NORMAL
- en: If your app includes any other components that are not used as routing elements,
    you would still store those in `src/components` (i.e., in a different path). This
    is not a hard rule or a technical requirement, but it does help with keeping your
    React projects manageable. Splitting your components across multiple folders makes
    it easier to quickly understand which components fulfill which purposes in the
    project.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example project mentioned previously, you can, for example, refactor
    the code such that the navigation code is stored in a separate component (e.g.,
    a `MainNavigation` component, stored in `src/components/shared/MainNavigation.jsx`
    ). The component file code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this code snippet, the `NavLink` component is adjusted to assign a CSS class
    named `active` to any link that belongs to the currently active route. This is
    required when using CSS Modules since the class names are changed during the build
    process, as discussed in *Chapter 6* , *Styling React Apps* . Besides that, it’s
    essentially the same navigation menu code as that used earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `MainNavigation` component can then be imported and used in the `Root.jsx`
    file like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Importing and using the `MainNavigation` component leads to a leaner `Root`
    component and yet preserves the same functionality as before.
  prefs: []
  type: TYPE_NORMAL
- en: These changes show how you can combine routing components that are only used
    for routing ( `Dashboard` and `Orders` ) and components that are used outside
    of routing ( `MainNavigation` ).
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: You can find the finished code for this example on GitHub at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/07-routing-and-normal-cmp](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/07-routing-and-normal-cmp)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'But even with those markup and style improvements, the demo application still
    suffers from an important problem: it only supports static, predefined routes.
    But, for most websites, those kinds of routes are not enough.'
  prefs: []
  type: TYPE_NORMAL
- en: From Static to Dynamic Routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Thus far, all examples have had two routes: `/` for the `Dashboard` component
    and `/orders` for the `Orders` component. But you can, of course, add as many
    routes as needed. If your website consists of 20 different pages, you can (and
    should) add 20 route definitions (i.e., 20 `Route` components) to your `App` component.'
  prefs: []
  type: TYPE_NORMAL
- en: On most websites, however, you will also have some routes that can’t be defined
    manually—because not all routes and their exact paths are known in advance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the example from before, enriched with additional components and some
    dummy data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_13_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.9: A list of order items'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code for this example on GitHub at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/08-dynamic-routes-problem](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/08-dynamic-routes-problem)
    . In the code, you’ll notice that many new components and style files were added.
    The code does not use any new features, though. It’s just used to display a more
    realistic user interface and output some dummy data.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, *Figure 13.9* , you can see a list of order items
    being output on the `Past Orders` page (i.e., by the `Orders` component).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the underlying code, every order item is wrapped with a `Link` component
    so that a separate page with more details can be loaded for each item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code snippet, the path for the `Link` component is set to `/orders`
    . However, that’s not the final value that should be assigned. Instead, this example
    highlights an important problem: while it’s the same route and component that
    should be loaded for every order item (i.e., some component that displays detailed
    data about the selected order), the exact content output by that component depends
    on which order item was selected. It’s the same route and component with different
    data.'
  prefs: []
  type: TYPE_NORMAL
- en: Outside of routing, you would use props to reuse the same component with different
    data. But with routing, it’s not just about the component. You also must support
    different paths—because the detailed data for different orders should be loaded
    via different paths (e.g., `/orders/o1` , `/orders/o2` , etc.). Otherwise, you
    would again end up with URLs that are not shareable or reloadable.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the path must include not only some static identifier (such as `/orders`
    ) but also a dynamic value that’s different for every order item. For three order
    items with `id` values `o1` , `o2` , and `o3` , the goal could be to support the
    `/orders/o1` , `/orders/o2` , and `/order/o3` paths.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this reason, the following three route definitions could be added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: But this solution has a major flaw. Adding all these routes manually is a huge
    amount of work. And that’s not even the biggest problem. You typically don’t even
    know all values in advance. In this example, when a new order is placed, a new
    route would have to be added. But you can’t adjust the source code of your website
    every time a visitor places an order.
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, then, a better solution is needed. React Router offers that better
    solution as it supports **dynamic routes** .
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic routes are defined just like other routes, except that, when defining
    their `path` values, you will need to include one or more **dynamic path segments**
    with identifiers of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `OrderDetail` route definition therefore looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following three key things have changed:'
  prefs: []
  type: TYPE_NORMAL
- en: It’s just one route definition instead of a (possibly) infinite list of definitions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`path` contains a dynamic path segment ( `:id` ).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OrderDetail` no longer receives an `id` prop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `:id` syntax is a special syntax supported by React Router. Whenever a segment
    of a path starts with a colon, React Router treats it as a **dynamic segment**
    . That means that it will be replaced with a different value in the actual URL
    path. For the `/orders/:id` route path, the `/orders/o1` , `/orders/o2` , and
    `/orders/abc` paths would all match and therefore activate the route.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you don’t have to use `:id` . You can use any identifier of your
    choice. For the preceding example, `:orderId` , `:order` , or `:oid` would also
    make sense.
  prefs: []
  type: TYPE_NORMAL
- en: The identifier will help your app access the correct data inside the page component
    that should be loaded for the dynamic route (i.e., the `OrderDetail` route component
    in the example code snippets above). That’s why the `id` prop was removed from
    `OrderDetail` in the last code snippet. Since only one route is defined, only
    one specific `id` value could be passed via props. That won’t help. Therefore,
    a different way of loading order-specific data must be used.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting Route Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous example, when a website user visits `/orders/o1` or `/orders/o2`
    (or the same path for any other order ID), the `OrderDetail` component is loaded.
    This component should then output more information about the specific order that
    was selected (i.e., the order whose ID is encoded in the URL path).
  prefs: []
  type: TYPE_NORMAL
- en: By the way, that’s not just the case for this example; you can think of many
    other types of websites as well. You could also have, for example, an online shop
    with routes for products ( `/products/p1` , `/products/p2` , etc.), or a travel
    blog where users can visit individual blog posts ( `/blog/post1` , `/blog/post2`
    , etc.).
  prefs: []
  type: TYPE_NORMAL
- en: In all these cases, the question is how do you get access to the data that should
    be loaded for the specific identifier (e.g., the ID) that’s included in the URL
    path? Since it’s always the same component that’s loaded, you need a way of dynamically
    identifying the order, product, or blog post for which the detail data should
    be fetched.
  prefs: []
  type: TYPE_NORMAL
- en: One possible solution would be the usage of props. Whenever you build a component
    that should be reusable yet configurable and dynamic, you can use props to accept
    different values. For example, the `OrderDetail` component could accept an `id`
    prop and then, inside the component function body, load the data for that specific
    order ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, as mentioned in the previous section, this is not a possible solution
    when loading the component via routing. Keep in mind that the `OrderDetail` component
    is created when defining the route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Since the component is created when defining the route in the `App` component,
    you can’t pass in any dynamic, ID-specific prop values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, though, that’s not necessary. React Router gives you a solution
    that allows you to extract the data encoded in the URL path from inside the component
    that’s displayed on the screen (when the route becomes active): the `useParams()`
    Hook.'
  prefs: []
  type: TYPE_NORMAL
- en: This Hook can be used to get access to the route parameters of the currently
    active route. Route parameters are simply the dynamic values encoded in the URL
    path— `id` , in the case of this `OrderDetail` example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `OrderDetail` component, `useParams()` can therefore be used to
    extract the specific order ID and load the appropriate order data, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in this snippet, `useParams()` returns an object that contains
    all route parameters of the currently active route as properties. Since the route
    path was defined as `/orders/:id` , the `params` object contains an `id` property.
    The value of that property is then the actual value encoded in the URL path (e.g.,
    `o1` ). If you choose a different identifier name in the route definition (e.g.,
    `/orders/:orderId` instead of `/orders/:id` ), that property name must be used
    to access the value in the `params` object (i.e., access `params.orderId` ).
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: You can find the complete code on GitHub at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/09-dynamic-routes](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/09-dynamic-routes)
    .
  prefs: []
  type: TYPE_NORMAL
- en: By using route parameters, you can thus easily create dynamic routes that lead
    to different data being loaded. But, of course, defining routes and handling route
    activation are not that helpful if you do not have links leading to dynamic routes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Dynamic Links
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier in this chapter (in the *Adding Page Navigation* section),
    website visitors should be able to click on links that should then take them to
    the different pages that make up the overall website—meaning, those links should
    activate the various routes defined with the help of React Router.
  prefs: []
  type: TYPE_NORMAL
- en: As explained in the *Adding Page Navigation* and *From Link to NavLink* sections,
    for internal links (i.e., links leading to routes defined inside the React app),
    the `Link` or `NavLink` components are used.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for static routes such as `/orders` , links are created like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When building a link to a dynamic route such as `/orders/:id` , you can therefore
    simply create a link like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This specific link loads the `OrderDetails` component for the order with the
    ID `o1` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Building the link as follows would be incorrect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The dynamic path segment syntax ( `:id` ) is only used when defining the route—not
    when creating a link. The link has to lead to a specific resource (a specific
    order, in this case).
  prefs: []
  type: TYPE_NORMAL
- en: However, creating links to specific orders, as shown previously, is not very
    practical. Just as it wouldn’t make sense to define all dynamic routes individually
    (see the *From Static to Dynamic Routes* section), it doesn’t make sense to create
    the respective links manually.
  prefs: []
  type: TYPE_NORMAL
- en: Sticking to the orders example, there is also no need to create links like that
    as you already have a list of orders that’s output on one page (the `Orders` component,
    in this case). Similarly, you could have a list of products in an online shop.
    In all these cases, the individual items (orders, products, etc.) should be clickable
    and lead to details pages with more information.
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_13_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.10: A list of clickable order items'
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, the links can be generated dynamically when rendering the list of
    JSX elements. In the case of the orders example, the code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this code example, the value of the `to` prop is set dynamically equal to
    a string that includes the `order.id` value. Therefore, every list item receives
    a unique link that leads to a different details page. Or, to be precise, the link
    always leads to the same component but with a different order `id` value, hence
    loading different order data.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: In this code snippet (which can be found at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/10-dynamic-links](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/10-dynamic-links)
    ), the string is created as a **template literal** . That’s a default JavaScript
    feature that simplifies the creation of strings that include dynamic values.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about template literals on MDN at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Navigating Programmatically
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, as well as earlier in this chapter, user navigation
    was enabled by adding links to the website. Indeed, links are the default way
    of adding navigation to a website. But there are scenarios where programmatic
    navigation is required instead.
  prefs: []
  type: TYPE_NORMAL
- en: Programmatic navigation means that a new page should be loaded via JavaScript
    code (rather than using a link). This kind of navigation is typically required
    if the active page changes in response to some action—e.g., upon form submission.
  prefs: []
  type: TYPE_NORMAL
- en: If you take the example of form submission, you will normally want to extract
    and save the submitted data. But thereafter, the user will sometimes need to be
    redirected to a different page. For example, it makes no sense to keep the user
    on a `Checkout` page after processing the entered credit card details. You might
    want to redirect the user to a `Success` page instead.
  prefs: []
  type: TYPE_NORMAL
- en: In the example discussed throughout this chapter, the `Past Orders` page could
    include an input field that allows users to directly enter an order ID and load
    the respective order data after clicking the `Find` button.
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_13_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.11: An input field that can be used to quickly load a specific order'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the entered order ID is first processed and validated before
    the user is sent to the respective details page. If the provided ID is invalid,
    an error message is shown instead. The code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The code snippet does not yet include the code that will actually trigger the
    page change, but it does show how the user input is read and validated.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, this is a perfect scenario for the use of programmatic navigation.
    A link can’t be used here since it would immediately trigger a page change—without
    allowing you to validate the user input first (at least not after the link was
    clicked).
  prefs: []
  type: TYPE_NORMAL
- en: 'The React Router library also supports programmatic navigation for cases like
    this. You can import and use the special `useNavigate()` Hook to gain access to
    a navigation function that can be used to trigger a navigation action (i.e., a
    page change):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Hence, the `OrdersSummary` component from previously can be adjusted like this
    to use this new Hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: It’s worth noting that the value passed to `navigate()` is a dynamically constructed
    string. Programmatic navigation supports both static and dynamic paths.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: The code for this example can be found at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/11-programmatic-navigation](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/11-programmatic-navigation)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Redirecting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thus far, all the explored navigation options (links and programmatic navigation)
    forward a user to a specific page.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, that’s the intended behavior. But in some cases, the goal is
    to redirect a user instead of forwarding them.
  prefs: []
  type: TYPE_NORMAL
- en: The difference is subtle but important. When a user is forwarded, they can use
    the browser’s navigation buttons ( `Back` and `Forward` ) to go back to the previous
    page or forward to the page they came from. For redirects, that’s not possible.
    Whenever a user is redirected to a specific page (rather than forwarded), they
    can’t use the `Back` button to return to the previous page.
  prefs: []
  type: TYPE_NORMAL
- en: Redirecting users can, for example, be useful for ensuring that users can’t
    go back to a login page after authenticating successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using React Router, the default behavior is to forward users. But you
    can easily switch to redirecting by adding the special `replace` prop to the `Link`
    (or `NavLink` ) components, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'When using programmatic navigation, you can pass a second, optional argument
    to the `navigate()` function. That second parameter value must be an object that
    can contain a `replace` property that should be set to `true` if you want to redirect
    users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Being able to redirect or forward users allows you to build highly user-friendly
    web applications that offer the best possible user experience for different scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Handling Undefined Routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Previous sections in this chapter have all assumed that you have predefined
    routes that should be reachable by website visitors. But what if a visitor enters
    a URL that’s simply not supported?
  prefs: []
  type: TYPE_NORMAL
- en: For example, the demo website used throughout this chapter supports the `/`
    , `/orders` , and `/orders/<some-id>` paths. But it does not support `/home` ,
    `/products/p1` , `/abc` , or any other path that’s not one of the defined route
    paths.
  prefs: []
  type: TYPE_NORMAL
- en: 'To show a custom *Not Found* page, you can define a “catch all” route with
    a special path—the `*` path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: When adding this route to the list of route definitions in the `App` component,
    the `NotFound` component will be displayed on the screen when no other route matches
    the entered or generated URL path.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy Loading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Chapter 10* , *Behind the Scenes of React and Optimization Opportunities*
    , you learned about lazy loading—a technique that can be used to load certain
    pieces of the React application code only when needed.
  prefs: []
  type: TYPE_NORMAL
- en: Code splitting makes a lot of sense if some components will be loaded conditionally
    and may not be needed at all. Hence, routing is a perfect scenario for lazy loading.
    When applications have multiple routes, some routes may never be visited by a
    user. Even if all routes are visited, not all the code for all app routes (i.e.,
    for their components) must be downloaded right at the start when the application
    loads. Instead, it makes sense to only download code for individual routes when
    they actually become active.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thankfully, React Router has built-in support for lazy loading and route-based
    code splitting. It provides a `lazy` property that can be added to a route definition.
    That property expects a function that dynamically imports the lazily loaded file
    (which contains the component that should be rendered). React Router then takes
    care of the rest—for example, you don’t need to wrap `Suspense` around any components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this example, both the `/orders` and `/orders/:id` routes are set up to load
    their respective components lazily.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the above code to work, there’s one important adjustment you must apply
    to your route component files when using this built-in lazy-loading support: you
    must replace the default component function export ( `export default SomeComponent`
    ) with a named export where the component function is named `Component` .'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `Orders` component code needs to be changed to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In this code snippet, the `Orders` component function is exported as `Component`
    . This name is required since React Router looks for a component function named
    `Component` when activating a lazy-loaded route.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: The code for this example can be found at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/12-lazy-loading](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/examples/12-lazy-loading)
    .
  prefs: []
  type: TYPE_NORMAL
- en: As explained in *Chapter 10* , *Behind the Scenes of React and Optimization
    Opportunities* , adding lazy loading can improve your React application’s performance
    considerably. You should always consider using lazy loading, but you should not
    use it for every route. It would be especially illogical for routes that are guaranteed
    to be loaded early, for instance. In the previous example, it would not make too
    much sense to lazy load the `Dashboard` component since that’s the default route
    (with a path of `/` ).
  prefs: []
  type: TYPE_NORMAL
- en: But routes that are not guaranteed to be visited at all (or at least not immediately
    after the website is loaded) are great candidates for lazy loading.
  prefs: []
  type: TYPE_NORMAL
- en: Summary and Key Takeaways
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Routing is a key feature for many React apps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With routing, users can visit multiple pages despite being on an **SPA** .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most common package that helps with routing is the React Router library
    ( `react-router-dom` ).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routes are defined with the help of the `createBrowserRouter()` function and
    the `RouterProvider` component (typically in the `App` component or the `main.jsx`
    file, but you can do it anywhere).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Route definition objects are typically set up with a `path` (for which the route
    should become active) and an `element` (the content that should be displayed)
    property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Content and markup can be shared across multiple routes by setting up layout
    routes—i.e., routes wrapping other nested routes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users can navigate between routes by manually changing the URL path, by clicking
    links, or because of programmatic navigation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internal links (i.e., links leading to application routes defined by you) should
    be created via the `Link` or `NavLink` components, while links to external resources
    use the standard `<a>` element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programmatic navigation is triggered via the `navigate()` function, which is
    yielded by the `useNavigate()` Hook.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can define static and dynamic routes: static routes are the default, while
    dynamic routes are routes where the path (in the route definition) contains a
    dynamic segment (denoted by a colon, e.g., `:id` ).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The actual values for dynamic path segments can be extracted via the `useParams()`
    Hook.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use lazy loading to load route-specific code only when the route is
    actually visited by the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What’s Next?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Routing is a feature that’s not supported by React out of the box but still
    matters for most React applications. That’s why it’s included in this book and
    why the React Router library exists. Routing is a crucial concept that completes
    your knowledge about the most essential React ideas and concepts, allowing you
    to build both simple and complex React applications.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter builds upon this chapter and dives even deeper into React Router,
    exploring its data fetching and manipulation capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Test Your Knowledge!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Test your knowledge of the concepts covered in this chapter by answering the
    following questions. You can then compare your answers to the examples that can
    be found at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/exercises/questions-answers.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/exercises/questions-answers.md)
    :'
  prefs: []
  type: TYPE_NORMAL
- en: How is routing different from loading content conditionally?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are routes defined?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How should you add links to different routes to your pages?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can dynamic routes (e.g., details for one of many products) be added to
    your app?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can dynamic route parameter values be extracted (e.g., to load product data)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What’s the purpose of nested routes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply What You Learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apply your knowledge about routing to the following activities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 13.1: Creating a Basic Three-Page Website'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, your task is to create a very basic first draft for a brand-new
    online shop website. The website must support three main pages:'
  prefs: []
  type: TYPE_NORMAL
- en: A welcome page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A products overview page that shows a list of available products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A product details page, which allows users to explore product details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Final website styling, content, and data will be added by other teams, but you
    should provide some dummy data and default styling. You must also add a shared
    main navigation bar at the top and implement route-based lazy loading.
  prefs: []
  type: TYPE_NORMAL
- en: 'The finished pages should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_13_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.12: The welcome page.'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_13_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.13: A page showing some dummy product placeholders'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_13_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.14: The final product details page with some placeholder data and
    styles'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: For this activity, you can, of course, write all CSS styles on your own. But
    if you want to focus on the React and JavaScript logic, you can also use the finished
    CSS file from the solution at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/13-routing/activities/practice-1/src/index.css](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/13-routing/activities/practice-1/src/index.css)
    .
  prefs: []
  type: TYPE_NORMAL
- en: If you use that file, explore it carefully to ensure you understand which IDs
    or CSS classes might need to be added to certain JSX elements of your solution.
    You can also use the solution’s dummy data instead of creating your own dummy
    product data. You will find the data for this at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/13-routing/activities/practice-1/src/data/products.js](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/13-routing/activities/practice-1/src/data/products.js)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the activity, the solution steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new React project and install the React Router package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create components (with the content shown in the preceding screenshot) that
    will be loaded for the three required pages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable routing and add the route definitions for the three pages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a main navigation bar that’s visible for all pages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add all required links and ensure that the navigation bar links reflect whether
    or not a page is active.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement lazy loading (for routes where it makes sense).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The full code, and solution, for this activity can be found here: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/activities/practice-1](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/13-routing/activities/practice-1)
    .'
  prefs: []
  type: TYPE_NORMAL
