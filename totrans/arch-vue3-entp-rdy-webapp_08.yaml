- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing and What to Test in Vue.js 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned the nitty-gritty details of the steps involved
    in dockerizing your Vue.js 3 project. In addition, you learned about the best
    practices and industry standards to dockerize an enterprise Vue.js 3 web application.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will explore the concept of software testing. You will
    learn what to test from an array of available components and methods. In addition,
    you will learn about best practices and industry standards related to testing
    libraries and how to integrate them with Vue.js 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following key topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing in software engineering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What to test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing a basic Vue.js 3 app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component testing in Vue.js 3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get started with this chapter, I recommend you read through [*Chapter 7*](B17237_07.xhtml#_idTextAnchor230),
    *Dockerizing a Vue 3 App*, first, where we took a more practical approach by dockerizing
    a full stack web application using Docker Compose. We will be using the application
    a lot in this chapter to learn about Vue.js 3 enterprise testing.
  prefs: []
  type: TYPE_NORMAL
- en: All the code files for this chapter can be found at [https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-8](https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-8).
  prefs: []
  type: TYPE_NORMAL
- en: Overview of testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Anyone who has studied computer science should be familiar with the concept
    of SDLC. If you are not aware, **SDLC** stands for **software development** **life
    cycle**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Synopsys ([https://www.synopsys.com/glossary/what-is-sdlc.html](https://www.synopsys.com/glossary/what-is-sdlc.html))
    provides the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: Software Development Life Cycle (SDLC) is a structured process that enables
    the production of high-quality, low-cost software, in the shortest possible production
    time. The goal of the SDLC is to produce superior software that meets and exceeds
    all customer expectations and demands.
  prefs: []
  type: TYPE_NORMAL
- en: If you explore the SDLC further, you’ll see that it defines and outlines eight
    detailed plans with stages or phases that quality and enterprise-level software
    must pass through to produce software that meets and exceeds all customer expectations
    and demands.
  prefs: []
  type: TYPE_NORMAL
- en: Each stage is crucial, including planning, coding, building, and testing. However,
    the testing phase is particularly important, especially when you need to build
    a bug- or defect-free enterprise-level application.
  prefs: []
  type: TYPE_NORMAL
- en: To elaborate further, the testing phase evaluates the created software against
    any bugs, any potential errors, and the requirements of the software from the
    planning phase.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will see what we mean by software testing.
  prefs: []
  type: TYPE_NORMAL
- en: What is software testing?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Software testing is the method of checking whether the software in production
    matches the expected requirements and, most importantly, whether it is defect
    free. The method used to carry out software testing differs depending on the organization.
    However, the method is divided into manual and automated processes.
  prefs: []
  type: TYPE_NORMAL
- en: Individuals and organizations will have different names for software testing.
    It can also be categorized as whitebox or blackbox testing. However, the end result
    of any approach is always the same, which is identifying errors, gaps, or missing
    requirements in contrast to actual requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Blackbox testing involves testing a system without knowing the internal workings
    of the system, while whitebox testing is an approach of testing that allows the
    tester to inspect and verify the internal workings of the system.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of the names, terms, or categories used when referring to software
    testing, in simple terms, software testing means the verification of the **Application
    Under Test** (**AUT**), and it’s a critical and crucial stage in producing high-quality
    enterprise-level software.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will go through the importance of software testing.
  prefs: []
  type: TYPE_NORMAL
- en: Why software testing is important
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The need to incorporate software testing into your application development pipeline
    cannot be overemphasized. It is as important as the planning and development phases
    in the SDLC. In fact, without a proper software testing strategy, it is likely
    that the end product of the software under development will be filled with bugs,
    errors, and unmet software requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Software testing is important because software bugs could be expensive and also
    very dangerous to businesses, and organizations at large. Over the years, there
    have been numerous examples of potential software bugs and monetary losses.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, in April 2015, the Bloomberg terminal in London crashed due to
    a software glitch that affected more than 300,000 traders in financial markets.
    It forced the UK government to postpone a 3 billion pound debt sale, according
    to The Guardian ([https://www.theguardian.com/business/2015/apr/17/uk-halts-bond-sale-bloomberg-terminals-crash-worldwide](https://www.theguardian.com/business/2015/apr/17/uk-halts-bond-sale-bloomberg-terminals-crash-worldwide)).
  prefs: []
  type: TYPE_NORMAL
- en: Also, according to Windows Report ([https://windowsreport.com/windows-10-vulnerability/](https://windowsreport.com/windows-10-vulnerability/)),
    there was a vulnerability in Windows 10 that enabled users to escape from security
    sandboxes through a flaw in the win32k system.
  prefs: []
  type: TYPE_NORMAL
- en: There have been many vulnerability reports on different malicious attempts on
    businesses that have impacted revenue or monetary value, of which some could be
    avoided with proper software testing. This indicates that software testing is
    a very important stage in the SDLC.
  prefs: []
  type: TYPE_NORMAL
- en: Though software testing costs money, I’m sure you will agree with me that the
    cost is nothing compared to the millions per year in development and support companies
    would have to spend if they don’t have a good testing technique and QA processes
    in place.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, having early software testing in place uncovers problems before
    the products go to market. Early testing also uncovers different defects, including
    but not limited to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Architectural flaws
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Poor design decisions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invalid or incorrect functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security vulnerabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scalability issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having proper testing processes in place along the software development pipeline
    improves software reliability and means high-quality applications are delivered
    with few errors. In the next section, we will further explore the benefits of
    software testing.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of software testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous section, we explained why enterprise applications need to include
    testing in their development pipeline. In this section, we will explore the benefits
    of having a proper software testing process. We will go through the following
    points in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: Helps in saving money
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Satisfaction of customers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhancing the development pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quality of product
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Helps in saving money
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Launching buggy software to market can end up being more expensive than creating
    the entire software. As stated previously, there have been many cases of company’s
    monetary value reducing due to software defects and error-prone software.
  prefs: []
  type: TYPE_NORMAL
- en: This problem can be curtailed to some extent if there is a proper software testing
    process built into the development pipeline to detect and rectify these errors
    before moving on to the next stage of the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Satisfaction of customers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For users of your enterprise application to be satisfied, the software must
    work properly and in accordance with the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, before launching the software to market, an acceptance test must
    be conducted to ensure that the product works in accordance with the requirements
    and also to get a sense of how users will access and use the product day to day.
  prefs: []
  type: TYPE_NORMAL
- en: While in the testing phase, if any issues or bugs are detected, the software
    under test can easily be moved back to the development stage instead of finding
    out about the problems in the production stage where real users are interacting
    with the application.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing the development pipeline
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Including software testing in the development pipeline creates an enhanced development
    pipeline. Also, it is an industry-standard practice to include software testing.
    In addition, it is simpler for developers to fix errors in the development stage
    than in the production stage.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, incorporating the software testing process in the development pipeline
    reduces the risk of launching error-prone software to market and enhances the
    development pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Quality of product
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the quality of the product drops, the company might lose customers, resulting
    in a loss of revenue. However, one of the attributes of low-quality software is
    an untested and error-prone software application.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, if there is a proper software testing process built into the development
    pipeline, most errors, bugs, and defects will be detected and fixed before production,
    thereby producing quality software.
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: According to OWASP ([https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/)),
    security should be an integral part of every software. Not considering it could
    result in a reduction in the monetary value of the business.
  prefs: []
  type: TYPE_NORMAL
- en: Software testing is one way to detect security loopholes and fix them in the
    development stage. If a product has undergone testing, the user can be assured
    that they are receiving a reliable product. They will be assured that their personal
    details are safe. Users can receive products that are more likely to be free from
    vulnerabilities with the aid of software testing.
  prefs: []
  type: TYPE_NORMAL
- en: In this subsection, we covered some benefits you can derive from implementing
    software testing into your pipeline when building enterprise-ready applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore the different types of testing and different
    strategies you can integrate into your development pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Testing in software engineering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As stated in the previous section, software testing is an integral part of the
    SDLC, and therefore, according to ANSI/IEEE 1059, testing in software engineering
    is a method of evaluating the software under test to discover whether it meets
    the requirements, as well as whether it is error, bug, and defect free.
  prefs: []
  type: TYPE_NORMAL
- en: The process involves evaluating the features of the software under test for
    requirements in terms of any missing requirements, bugs or errors, security, reliability,
    and performance.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we explored the benefits of testing and why software testing
    is important, and in the next section, we will understand different types of software
    testing. We will explore what to test and how to write basic unit and integration
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: Types of software testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Software testing has been given different names. There are over 150 types of
    software testing according to Guru99 ([https://www.guru99.com/types-of-software-testing.html](https://www.guru99.com/types-of-software-testing.html)).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we are going to classify software testing into two main categories
    and then explore each of the categories and the different types within them. The
    following are the two main categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Functional software testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance software testing (non-functional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following figure shows the high-level classification of software testing
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – A high-level classification of software testing (source: softwaretestinghelp)](img/Figure_8.01_B17237.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1 – A high-level classification of software testing (source: softwaretestinghelp)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can explore more about the different categories of software testing on
    Youtube. However, we will only focus on three main categories of functional software
    testing, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: End-to-end testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This basic approach to software testing is carried out by a programmer to test
    the unit or smallest part of the program. It helps developers to know whether
    individual units of code are working properly or not.
  prefs: []
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This type of testing focuses on the construction and design of the software.
    You need to see whether the integrated units are working without errors or not.
  prefs: []
  type: TYPE_NORMAL
- en: End-to-end testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: End-to-end testing is a methodology that assesses the working order of a complex
    product in a start-to-finish process.
  prefs: []
  type: TYPE_NORMAL
- en: In the coming chapters, we will focus on exploring these different types of
    testing individually. Nevertheless, you can explore more than 150 different types
    of software testing from Guru99 ([https://www.guru99.com/types-of-software-testing.html](https://www.guru99.com/types-of-software-testing.html)).
  prefs: []
  type: TYPE_NORMAL
- en: In summary, now that we know how important software testing is and the different
    types of software testing, how do we know what to test in a large enterprise application?
    In the next section, we are going to explore what to test and how to integrate
    a testing pipeline into the development workflow.
  prefs: []
  type: TYPE_NORMAL
- en: What to test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A popular question among software teams is *what should we test and what should
    we not test?* In this section, we will explore the different things you should
    and shouldn’t test when considering software tests.
  prefs: []
  type: TYPE_NORMAL
- en: We will first explore different test strategies to employ when integrating software
    testing into your development workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Testing strategy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The best testing strategy to implement in your enterprise application is the
    combination of normal (manual) testing and automated testing. In addition, normal
    testing should be done more extensively by the **Quality Assurance** (**QA**)
    team.
  prefs: []
  type: TYPE_NORMAL
- en: To explain this further, when automated testing is written and implemented successfully,
    we usually program it to look for fundamental errors and edge cases that may not
    properly assimilate how a real customer will interact with the application.
  prefs: []
  type: TYPE_NORMAL
- en: What you should test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As much as software testing is important to the efficiency of an enterprise-ready
    application, knowing what to test is paramount so that developers don’t waste
    time testing the wrong things.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of some of the things you can look for when testing
    your enterprise project for errors, bugs, and defects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Passed parameters**: The collection of parameters or arguments passed into
    the method or function to make sure that it has not changed. In some cases, the
    data type of the parameter remains the same.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Algorithm engines**: Every method has a purpose, and the purpose is implemented
    using logic or an algorithm. Your test case should test the algorithm to make
    sure it’s correct and it results in the right output based on the input into the
    method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simple database queries checking predicates**: If your job as a developer
    is related to queries and manipulating databases, you really want to test your
    database queries to make sure it performs the right manipulation and queries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Utility methods**: Utility methods are helpers in your project that are created
    for a specific task. They are usually used when you need to do stuff that does
    not need an instance of a class. This set of methods needs to be tested properly
    to ensure it produces the correct output when used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing less critical codes:** Test the edge cases of a few unusually complex
    pieces of code that you think will probably have errors. Additionally, carry out
    edge-case tests of less critical code whenever someone has time to kill.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding are a few things you can consider for your test cases. However,
    it is important to note that writing tests and having 100% code coverage do not
    necessarily mean that your code is bug free. In the next section, we will explore
    things you should not test in your project.
  prefs: []
  type: TYPE_NORMAL
- en: What you should not test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are the things that you should not be testing in your project:'
  prefs: []
  type: TYPE_NORMAL
- en: Constructors or properties (if they just return variables). Test them only if
    they contain validations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods that call another public method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the code needs to interact with other deployed systems, then an integration
    test should be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configurations such as constants, read-only fields, configs, and enumerations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should not test POJO classes or models; rather, you can test each of the
    methods inside the class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, we have explored the software testing strategy, what to test, and
    what you should not test to help you understand the relevance of software testing
    in your enterprise application. In the next section, we will explore how to test
    a basic Vue.js application.
  prefs: []
  type: TYPE_NORMAL
- en: Testing a basic Vue.js 3 app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we created a Pinterest application using Strapi for
    the backend and Vue.js 3 for the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Previously, we added internationalization, structured the project, and built
    out a complete Pinterest clone. In this section, we will continue by using the
    official project we created for this book to set up software testing, resulting
    in a full-blown enterprise-ready Pinterest clone application.
  prefs: []
  type: TYPE_NORMAL
- en: You can clone the project from this repository, [https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications](https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications),
    to jump right in.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a test folder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is always confusing knowing where to add your test files and folder when
    it comes to creating enterprise applications. There are two methods for structuring
    your test files depending on the approach you used for your enterprise project.
  prefs: []
  type: TYPE_NORMAL
- en: Method 1 – adding test files inside each component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, you can create a specific test file inside each of the `component` folders.
    For instance, inside the `component` folder in our Vue.js 3 project, we will create
    a folder for each component and move the files of each component into the folder,
    including the test file for each component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows an example of how we could arrange our component
    folder to accommodate our testing files and other files related to a particular
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – A screenshot showing our component structure](img/Figure_8.02_B17237.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – A screenshot showing our component structure
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, you can see how you can add any files related to any
    of the components. For example, if you want to add an end-to-end testing or integration
    testing file for each component, you just create the file within each specific
    component folder.
  prefs: []
  type: TYPE_NORMAL
- en: Also, because of the structure of our practice project and the introduction
    of the atomic pattern, we can easily see how many files will be created in each
    component. The same goes for different areas we will be testing throughout the
    project.
  prefs: []
  type: TYPE_NORMAL
- en: However, we can use the next method to arrange everything related to testing
    in a separate folder and create all the files and folders inside the specific
    `tests` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Method 2 – creating a tests folder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we will create a folder inside the `src` folder called `tests`,
    which will contain every file and folder related to testing and test configurations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the folder structure for implementing testing with
    this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – A screenshot of the folder structure](img/Figure_8.03_B17237.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – A screenshot of the folder structure
  prefs: []
  type: TYPE_NORMAL
- en: This method has a single folder that contains all the files and folders related
    to testing, including all the configurations. It is a central place and single
    point of truth for all your software testing files and folders. You can arrange
    this folder in a different structure as per your use case.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the method of structuring your test folder or files and folders
    related to testing does not matter. What matters the most is implementing software
    testing properly and knowing exactly what to test to avoid production bugs and
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the second method in this demo in writing some basic unit tests
    to demonstrate. This is because we don’t want the testing files to be scattered
    across different folders since we are using the atomic pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a basic unit test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we will start by installing the new testing library for Vue.js 3\. Since
    we are using Vite in the project, we will also install the Vitest library for
    our test runner. You can read more about the new Vue.js 3 test library at [https://vitest.dev/guide/](https://vitest.dev/guide/).
  prefs: []
  type: TYPE_NORMAL
- en: Installing the test library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Vitest is a blazing-fast unit test framework powered by Vite. Install the library
    by using any of these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]bash'
  prefs: []
  type: TYPE_NORMAL
- en: with npm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: npm install -D vitest
  prefs: []
  type: TYPE_NORMAL
- en: or with yarn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: yarn add -D vitest
  prefs: []
  type: TYPE_NORMAL
- en: or with pnpm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pnpm add -D vitest
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our testing library set up, let’s create a simple helper file
    to test our configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a helper file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For our demonstration, we will create a helper file inside the `src/helpers`
    folder and add a simple function to increment a value. The following snippet shows
    the code example we have added to the newly created file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The increment function written previously increments a value by `1` until the
    max value is reached. If the max value is reached, it simply returns the current
    value. Next, let’s write a basic unit test for it.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a basic test
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we will write a simple unit test for this function. You can
    follow this by writing unit tests for all the functions and methods of your enterprise
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We will explore unit testing in depth in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s walk through the preceding code together and understand the nitty-gritty
    details of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1: Adding the** **required packages**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, we need the `vitest` package and the `helper` file to test. Next, we
    use the exported functions to create a `describe` block, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `describe` block is used to group related test cases, as demonstrated in
    the preceding code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 2: Using the** **it function**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we use the `it` function to test specific use cases of our function.
    For instance, we test to make sure the number actually increases by `1` each time
    the function is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Step 3: Using the** **except function**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, the `expect` function is used to test the use case. You pass in a value
    and expect the value to be equal to another value, as shown in the example.
  prefs: []
  type: TYPE_NORMAL
- en: You can access different methods ([https://vitest.dev/api/#expect](https://vitest.dev/api/#expect))
    from the `expect` object aside from the `toBe()` function.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will cover the process of running your test with Vitest
    and creating your first component/integration testing examples.
  prefs: []
  type: TYPE_NORMAL
- en: Running a test with Vitest
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will now run the test to see whether it passes or not. Type the following
    command into your root terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If your test is successful, you should see that the three cases passed, as
    shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – A screenshot showing the test result](img/Figure_8.04_B17237.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – A screenshot showing the test result
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have demonstrated how to configure and structure software
    testing with Vue.js 3 using the latest Vitest testing library for Vue.js 3\. We
    have also learned how to write a basic unit test. In the next section, we will
    learn how to create basic component-based testing.
  prefs: []
  type: TYPE_NORMAL
- en: Component testing in Vue.js 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Vue.js, components are the main building block of the UI and refer to a single
    unit of the application that is shareable, testable, and reusable. Therefore,
    component testing sits between unit testing and end-to-end testing. It can also
    be referred to as integration testing.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapters, where we integrated atomic patterns using Storybook,
    we discussed creating component stories and how to create them. If you created
    stories for all your components and configured them to work properly as demonstrated,
    then you will have already implemented component testing using Storybook stories.
  prefs: []
  type: TYPE_NORMAL
- en: However, [*Chapter 10*](B17237_10.xhtml#_idTextAnchor363), *Integrating Testing
    in Vue.js 3* is dedicated to exploring component testing. Nevertheless, we will
    briefly illustrate in this chapter how to implement simple component-based testing
    to aid our understanding of the next chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a basic component test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start by installing the new testing library for Vue.js 3\. Since we
    are using Vite in the project, we will also install the Vitest library for our
    test runner. You can read more about the new Vue.js 3 test library ([https://vuejs.org/guide/scaling-up/testing.html](https://vuejs.org/guide/scaling-up/testing.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Installing the test library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As of the time of writing, `@testing-library/vue` ([https://github.com/testing-library/vue-testing-library](https://github.com/testing-library/vue-testing-library))
    is recommended for component testing, and we will install it in our example. Run
    the following command to install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]bash'
  prefs: []
  type: TYPE_NORMAL
- en: npm install -D vitest happy-dom @testing-library/vue
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, open the `vite.config.js` file and add the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This configuration should allow us to run both unit and component tests at the
    same time. Next, let’s create a simple component test.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a basic component test
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is a simple component test snippet to demonstrate the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The test simply renders `Button` with a custom label value and also checks whether
    we can retrieve the custom label added during the rendering process.
  prefs: []
  type: TYPE_NORMAL
- en: Running the test
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Running the test will result in four passed test cases, including the unit
    test we created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – A screenshot showing the final test result with integration
    testing](img/Figure_8.05_B17237.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – A screenshot showing the final test result with integration testing
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have demonstrated how to configure and structure component
    testing, also known as integration testing, with Vue.js 3 using the latest Vitest
    testing library for Vue.js 3\. We have also written basic component tests to help
    us understand the process. In the next chapters, we will look in-depth at the
    different types of testing we can perform when building enterprise projects with
    Vue.js 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can clone the latest repository for this chapter here: [https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-8](https://github.com/PacktPublishing/Architecting-Vue.js-3-Enterprise-Ready-Web-Applications/tree/chapter-8).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter dove deeper into the concept of software testing to deliver scalable,
    high-performing, and bug-free applications. We also explored what to test from
    an array of available components and methods. In addition, we utilized our knowledge
    of software testing to create basic unit and component test cases in Vue.js 3
    using Vitest.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore everything related to unit testing. We
    will learn how to unit test a Vue.js 3 component and the component and page methods.
    We will also learn about unit testing tools such as Vitest and use them to effectively
    unit test an enterprise project.
  prefs: []
  type: TYPE_NORMAL
