- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Essential Tools for Improving React Native Development
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高React Native开发的基本工具
- en: '**React Native** is a framework with a very strong developer community. During
    the last year, there was an evolutionary growth of a large variety of tools and
    libraries, making the development of React Native apps a lot easier and a lot
    more comfortable.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**React Native**是一个拥有非常强大的开发者社区的框架。在过去的一年里，大量工具和库经历了进化式增长，使得React Native应用的开发变得更加容易和舒适。'
- en: Besides the tools and libraries developed especially for React Native, you can
    also use a lot of things in the plain React ecosystem. This is because most of
    these things are compatible with the JavaScript/React part of any React Native
    app.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 除了专门为React Native开发的工具和库之外，你还可以在纯React生态系统中使用很多东西。这是因为这些大多数东西都与任何React Native应用的JavaScript/React部分兼容。
- en: Being aware of the best tools and libraries and how to use them is really useful
    because it saves you a lot of time and can greatly improve the quality of your
    code and product.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 了解最佳工具和库以及如何使用它们非常有用，因为它可以节省你大量时间，并大大提高你的代码和产品的质量。
- en: Especially when you are working on bigger projects, some tools are an absolute
    must-have to ensure good collaboration in a bigger team.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是在你从事更大项目时，一些工具是绝对必需的，以确保在大团队中的良好协作。
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解以下主题：
- en: How to improve code quality with type safety, linters, and code formatters
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用类型安全、代码检查器和代码格式化工具提高代码质量
- en: Why and when you should use boilerplate solutions and how to leverage them
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么以及何时应该使用样板解决方案，以及如何利用它们
- en: How to find and use high-quality UI libraries
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何寻找和使用高质量的UI库
- en: Why and when you should use Storybook and how to use it
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么以及何时应该使用Storybook，以及如何使用它
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To be able to run the code in this chapter, you have to set up the following
    things:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本章中的代码，你必须设置以下内容：
- en: A working React Native environment ([https://reactnative.dev/docs/environment-setup](https://reactnative.dev/docs/environment-setup))
    – React Native CLI Quickstart
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有效的React Native环境（[https://reactnative.dev/docs/environment-setup](https://reactnative.dev/docs/environment-setup)）
    – React Native CLI 快速入门
- en: Improving code quality with type safety, linters, and code formatters
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类型安全、代码检查器和代码格式化工具提高代码质量
- en: As already mentioned in [*Chapter 2*](B16694_02.xhtml#_idTextAnchor030), *Understanding
    the Essentials of JavaScript and TypeScript*, it is necessary to use typed JavaScript
    alongside some tools to ensure a certain level of quality in bigger projects.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在[*第2章*](B16694_02.xhtml#_idTextAnchor030)，*理解JavaScript和TypeScript的基本知识*中已提到的，在大项目中使用类型化的JavaScript并配合一些工具确保一定程度的代码质量是必要的。
- en: In the following section, you will learn how to do this. Let’s start with type
    safety using TypeScript or Flow.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将学习如何做到这一点。让我们从使用TypeScript或Flow进行类型安全开始。
- en: Ensuring type safety with TypeScript or Flow
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用TypeScript或Flow确保类型安全
- en: '**Type safety** is standard in most programming languages such as Java or C#,
    and this is for good reason. In contrast, JavaScript is dynamically typed. This
    is because of the history of JavaScript. Remember, JavaScript was created as a
    scripting language to write small chunks of code very quickly. For this scenario,
    dynamic typing is fine, but when a project grows, static typing with all its advantages
    is a must-have.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**类型安全**在大多数编程语言中是标准，例如Java或C#，这有很好的理由。相比之下，JavaScript是动态类型的。这是因为JavaScript的历史。记住，JavaScript最初被创建为一种脚本语言，用于快速编写小块代码。在这种情况下，动态类型是可行的，但当项目增长时，具有所有优点的静态类型是必不可少的。'
- en: Using typed JavaScript creates some overhead for creating your types at the
    beginning, but it gives you a lot of advantages at the end. Also, today, most
    libraries come with defined types, which you can use out of the box.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型化的JavaScript在开始创建类型时会产生一些开销，但它最终会给你带来很多优势。此外，如今，大多数库都附带定义好的类型，你可以直接使用。
- en: In [*Chapter 2*](B16694_02.xhtml#_idTextAnchor030), *Understanding the Essentials
    of JavaScript and TypeScript*, you already learned how to use and write TypeScript.
    This subsection focuses on the advantages of TypeScript and what errors you can
    prevent when using it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第2章*](B16694_02.xhtml#_idTextAnchor030)，*理解JavaScript和TypeScript的基本知识*，你已经学习了如何使用和编写TypeScript。本小节重点介绍TypeScript的优势以及在使用它时可以预防的错误。
- en: Dynamic typing can lead to serious and hard-to-find errors
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态类型可能导致严重且难以发现的错误
- en: Let’s start this section with a real-world example, which I experienced in one
    of my projects. While working on a React Native project, we used JavaScript without
    static typing. We fetched questions with a unique ID from a remote database (Google
    Firebase) and stored them locally on the device (`AsyncStorage`).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从现实世界的一个例子开始这个部分，这是我在一个项目中的经历。在处理一个React Native项目时，我们没有使用静态类型化的JavaScript。我们从远程数据库（Google
    Firebase）中通过唯一ID获取问题，并将它们本地存储在设备上（`AsyncStorage`）。
- en: Based on the ID of the questions, we also stored user answers and marked the
    questions as answered in the app. After an update, all the answers seemed to be
    gone from the users’ devices, and nobody understood why. It turned out that the
    update changed the unique IDs from `number` to `string`, which made the comparison
    between the stored user answers and the questions fail.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 根据问题的ID，我们还存储了用户答案，并在应用中将问题标记为已回答。更新后，所有答案似乎都从用户的设备上消失了，没有人知道为什么。结果是更新将唯一的ID从`number`改为`string`，这使得存储的用户答案与问题之间的比较失败。
- en: The debugging of this error was very hard because it didn’t occur when answers
    were created with the updated version of the app. It only occurred when questions
    were answered in an older version of the app; following this, the app was then
    updated, and the questions were synced.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 调试这个错误非常困难，因为它在用应用更新的版本创建答案时不会发生。只有在用应用的老版本回答问题时才会发生；随后，应用被更新，问题被同步。
- en: In addition to that, the error never threw an error message. It just happened
    silently. So, it took quite some time to find and fix the bug. This is just one
    example of an error that happens because of dynamic typing and why it is hard
    to deal with these errors. They can lead to hard errors, which you notice directly,
    but in a lot of cases, they don’t.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '此外，错误从未抛出错误消息。它只是默默地发生了。因此，找到并修复这个错误花了一些时间。这只是一个例子，说明了由于动态类型而发生的错误，以及为什么处理这些错误很困难。它们可能导致直接注意到的严重错误，但在很多情况下，它们不会。 '
- en: This is especially severe in the case of app development, where you store a
    lot of data on the users’ devices. When you don’t realize that you have problems
    with your data types, this can lead to corrupt data on millions of different devices,
    which is really hard to recognize, debug, and fix.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这在应用开发中尤其严重，因为你需要在用户的设备上存储大量数据。当你没有意识到你的数据类型有问题时，这可能导致数百万个不同设备上的数据损坏，这很难识别、调试和修复。
- en: Most of these errors can be prevented with static type checking using TypeScript
    or Flow.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数这些错误可以通过使用TypeScript或Flow进行静态类型检查来预防。
- en: Important note
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: When using TypeScript or Flow, don’t use `any` or `Object` to make your life
    easier while writing your types. Type checking and all its advantages only really
    work when using it in the whole project. So, you should explicitly type all your
    properties.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用TypeScript或Flow时，不要使用`any`或`Object`来使你的类型编写更容易。类型检查及其所有优势只有在整个项目中使用时才能真正发挥作用。因此，你应该明确地为所有属性添加类型。
- en: Typed JavaScript doesn’t only prevent bugs, it can also boost your productivity.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 带有类型检查的JavaScript不仅可以防止错误，还可以提高你的生产力。
- en: Enhancing your IDE with code completion
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过代码补全增强你的IDE
- en: When you have statically defined types, it is easy for your IDE to help you
    with code completion. Most modern IDEs such as Visual Studio Code or JetBrains
    WebStorm have excellent support for TypeScript and Flow.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有静态定义的类型时，你的IDE很容易帮助你进行代码补全。大多数现代IDE，如Visual Studio Code或JetBrains WebStorm，对TypeScript和Flow都有出色的支持。
- en: While WebStorm has most of the support built in for TypeScript and Flow, there
    are a lot of useful plugins for VS Code. Especially when working with Flow, you
    must install an extension for code completion and code navigation to work correctly.
    To do so, go to `Flow Language Support`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然WebStorm为TypeScript和Flow提供了大部分内置支持，但VS Code有很多有用的插件。特别是当使用Flow时，你必须安装一个扩展来确保代码补全和代码导航能正确工作。为此，请转到`Flow
    Language Support`。
- en: Additionally, I would recommend running type checks in every commit with your
    CI pipeline. You can read more about this in [*Chapter 11*](B16694_11.xhtml#_idTextAnchor376),
    *Creating and Automating Workflows*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我建议在每次提交时通过你的CI管道运行类型检查。你可以在[*第11章*](B16694_11.xhtml#_idTextAnchor376) *创建和自动化工作流程*
    中了解更多关于这个内容。
- en: While typed JavaScript prevents a lot of errors and boosts productivity, there
    are many more areas where you can prevent errors from happening. Most of them
    are covered by linters. In the next section, you learn what they are and how they
    work.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然类型化 JavaScript 阻止了许多错误并提高了生产力，但还有许多其他领域可以防止错误发生。其中大部分都由代码检查工具覆盖。在下一节中，你将了解它们是什么以及它们是如何工作的。
- en: Getting rid of the most common bugs with linters
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用代码检查工具消除最常见的错误
- en: Linters are tools that watch your code and enforce certain rules. When it comes
    to JavaScript/TypeScript, ESLint is, by far, the most popular and mature linter
    on the market, so this subsection will focus on ESLint. It analyzes your code
    and finds problems by checking your code against a predefined ruleset.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Linters 是一种监控你的代码并强制执行某些规则的工具。当涉及到 JavaScript/TypeScript 时，ESLint 无疑是市场上最流行和最成熟的代码检查工具，因此本小节将重点关注
    ESLint。它通过将你的代码与预定义的规则集进行对比来分析你的代码并找出问题。
- en: These problems can be errors, non-efficient code, or even code styling errors.
    I would recommend using ESLint because it comes at no cost and can ensure a certain
    level of code quality.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题可能是错误、非高效代码，甚至是代码风格错误。我建议使用 ESLint，因为它免费且可以确保一定程度的代码质量。
- en: 'If you use the React Native CLI to set up your project, you will find ESLint
    preinstalled with a working ruleset. If you want to add it to an existing project,
    you can install it with the following commands: either use `npm install –-save-dev
    eslint` or `yarn add –-dev eslint`. In the next step, you have to set up a configuration.
    This can be done automatically with the `npm init @eslint/config` or `yarn create
    @eslint/config` commands.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 React Native CLI 来设置你的项目，你会发现 ESLint 已经预安装并带有工作规则集。如果你想将其添加到现有项目中，你可以使用以下命令进行安装：要么使用
    `npm install --save-dev eslint`，要么使用 `yarn add --dev eslint`。在下一步中，你必须设置一个配置。这可以通过
    `npm init @eslint/config` 或 `yarn create @eslint/config` 命令自动完成。
- en: Now you can use ESLint to check your code against your ruleset with `npx eslint
    file.js` or `yarn run eslint file.js`. ESLint even comes with a `--fix` option,
    which automatically tries to fix as many errors as possible.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用 `npx eslint file.js` 或 `yarn run eslint file.js` 来使用 ESLint 检查你的代码与你的规则集。ESLint
    还提供了一个 `--fix` 选项，它自动尝试修复尽可能多的错误。
- en: You can also integrate ESLint in most modern IDEs, to highlight and automatically
    fix problems found by ESLint. I would recommend doing so.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将 ESLint 集成到大多数现代 IDE 中，以突出显示并自动修复 ESLint 发现的问题。我建议这样做。
- en: Additionally, I would recommend running ESLint checks in every commit with your
    CI pipeline. You can read more about that in [*Chapter 11*](B16694_11.xhtml#_idTextAnchor376),
    *Creating and Automating Workflows*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我建议在 CI 流程中每次提交时都运行 ESLint 检查。你可以在[*第 11 章*](B16694_11.xhtml#_idTextAnchor376)
    *创建和自动化工作流程*中了解更多相关信息。
- en: ESLint is an awesome tool to find common errors, and even though it also supports
    code styling rules, there is another tool that does a better job in this area.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ESLint 是一个寻找常见错误的优秀工具，尽管它也支持代码风格规则，但在这个领域还有另一个工具做得更好。
- en: Enforcing a common code style with prettier
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 prettier 强制执行常见的代码风格
- en: '**Prettier** is a code formatter that was created in 2016\. Essentially, it
    automatically rewrites your code based on a set of rules. This ensures that it
    follows standards and enforces a common code style for the whole development team
    of a project.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**Prettier** 是一个在 2016 年创建的代码格式化工具。本质上，它根据一组规则自动重写你的代码。这确保了它遵循标准，并为整个项目开发团队强制执行统一的代码风格。'
- en: To use prettier, you can simply install it as a development dependency with
    the following commands. Either use `npm install --save-dev prettier` or `yarn
    add --dev prettier`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 prettier，你可以简单地使用以下命令将其作为开发依赖项安装。要么使用 `npm install --save-dev prettier`，要么使用
    `yarn add --dev prettier`。
- en: It can be a bit challenging to integrate prettier with linters such as ESLint.
    This is because – as you learned in the previous subsection – these linters also
    have rules to format code. When you use both and have specified conflicting rules,
    this won’t work. Fortunately, prettier comes with premade configs for ESLint,
    which prevent exactly that. You can download them from the prettier home page.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 将 prettier 与 ESLint 等代码检查工具集成可能会有些挑战。这是因为——正如你在上一个子节中学到的——这些代码检查工具也有格式化代码的规则。当你同时使用它们并指定了冲突的规则时，这不会起作用。幸运的是，prettier
    随附有 ESLint 的预配置，可以防止这种情况发生。你可以从 prettier 主页下载它们。
- en: After the installation is complete, you can run prettier from the command line.
    To check whether your code styling follows the prettier rules, you can use the
    `prettier` command, followed by the path of a file or folder you want to check.
    In practice, you often want to make prettier format your files for you. This can
    be achieved with `prettier --write` followed by a path of a file or folder.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，您可以从命令行运行 prettier。要检查您的代码格式是否符合 prettier 规则，您可以使用 `prettier` 命令，后跟您想要检查的文件或文件夹的路径。在实践中，您通常希望
    prettier 自动格式化您的文件。这可以通过 `prettier --write` 后跟文件或文件夹的路径来实现。
- en: Important tip
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You can use a `.prettierignore` file to exclude files from getting rewritten
    by prettier. You should use this file to prevent rewriting of files that are not
    written by you, config files, or others.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `.prettierignore` 文件来排除文件不被 prettier 重新编写。您应该使用此文件来防止非您编写的文件、配置文件或其他文件的重新编写。
- en: 'Prettier brings a lot of value to your project, and you will not want to develop
    without it, especially when you are not working alone. The most important advantages
    of using prettier are listed as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Prettier 为您的项目带来了很多价值，您不会希望在没有它的前提下进行开发，尤其是在您不是单独工作的时侯。使用 prettier 的最重要的优势如下列所示：
- en: '**Easier code reviews**: When doing code reviews, most editors highlight the
    changes that have been made. By far, the most annoying thing in a code review
    is when a developer has another autoformatting setting, resulting in all the code
    being marked as changed for the review. While this makes total sense because all
    the code has been changed due to autoformatting, it makes the review process a
    lot harder. It takes more time and makes it more vulnerable to errors in the review.
    Prettier prevents this by enforcing a common code style.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更易于代码审查**：在进行代码审查时，大多数编辑器会突出显示已做的更改。到目前为止，代码审查中最令人烦恼的事情是当开发者有另一个自动格式化设置时，导致所有代码都被标记为已更改以供审查。虽然这完全合理，因为所有代码都因自动格式化而更改，但它使得审查过程变得更加困难。这需要更多时间，并使审查更容易出错。Prettier
    通过强制执行统一的代码风格来防止这种情况。'
- en: '**Easier code readability**: When you add developers to your team, code readability
    is an important factor. The easier the code readability is, the less time a new
    developer will need to be a productive part of your team. Prettier guarantees
    a common code style, which makes the code easier to read and understand.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更易于代码可读性**：当您向团队添加开发者时，代码可读性是一个重要因素。代码的可读性越容易，新开发者成为您团队的有生产力成员所需的时间就越少。Prettier
    保证统一的代码风格，这使得代码更容易阅读和理解。'
- en: 'Prettier is available as a command-line tool and as an IDE extension/plugin
    for all common IDEs. To ensure that it is used, you should include it in the following
    parts of your project:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Prettier 作为命令行工具和所有常见 IDE 的 IDE 扩展/插件提供。为了确保它被使用，您应该在项目的以下部分包含它：
- en: '**IDE**: All developers should add prettier to their IDE and configure their
    autoformatting shortcut to use prettier.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IDE**：所有开发者都应该将 prettier 添加到他们的 IDE 中，并配置他们的自动格式化快捷键以使用 prettier。'
- en: '**Before Commit**: A before commit hook should ensure that prettier does not
    throw any errors.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提交前**：提交前钩子应确保 prettier 不会抛出任何错误。'
- en: '**CI/CD**: When creating a pull request/merge request, prettier should be run
    to ensure that the manual review can be done in an efficient manner. You can read
    more about this in [*Chapter 11*](B16694_11.xhtml#_idTextAnchor376), *Creating
    and Automating Workflows*.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CI/CD**：在创建拉取请求/合并请求时，应该运行 prettier 以确保手动审查可以高效进行。您可以在[*第 11 章*](B16694_11.xhtml#_idTextAnchor376)中了解更多信息，*创建和自动化工作流程*。'
- en: If you implement this process with prettier, you will save a lot of time in
    the long run.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 prettier 实施此过程，从长远来看，您将节省大量时间。
- en: So, you learned about the most important tools while working with React Native
    projects. Now you will get to know some tools to successfully start new React
    Native projects. There are different open source **boilerplate solutions** on
    the market, all with their own advantages. A boilerplate solution means either
    a template you can use to start with or a CLI tool to generate your start project.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您在处理 React Native 项目时了解了最重要的工具。现在您将了解一些工具来成功启动新的 React Native 项目。市场上有不同的开源
    **样板解决方案**，它们都有各自的优势。样板解决方案意味着您可以使用它作为模板开始，或者是一个 CLI 工具来生成您的起始项目。
- en: Using boilerplate solutions
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用样板解决方案
- en: Boilerplate solutions make it easy to set up a project with a solid architecture.
    This can be very helpful, but you should be aware of the trade-offs that come
    with these boilerplate solutions. Additionally, you should know exactly what you
    want because there are completely different solutions out there.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 模板化解决方案使得设置具有稳固架构的项目变得容易。这非常有帮助，但你应该意识到这些模板化解决方案带来的权衡。此外，你应该确切地知道你想要什么，因为外面有完全不同的解决方案。
- en: First, a boilerplate solution in this context is everything that creates code
    for you to start without having to configure everything on your own. This can
    be anything, from a simple template that has built-in TypeScript support but nothing
    else to a complete CLI solution that brings you solutions for navigation, state
    management, fonts, animations, connection, and more such as the Ignite CLI by
    Infinite Red.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在这个上下文中，模板化解决方案是指所有为你生成代码以开始项目而无需自己配置一切的东西。这可以是任何东西，从具有内置 TypeScript 支持但无其他功能的简单模板到提供导航、状态管理、字体、动画、连接等解决方案的完整
    CLI 解决方案，例如 Infinite Red 的 Ignite CLI。
- en: Because there is such a wide range of what a boilerplate solution consists of,
    it’s hard to make general assumptions about them. Nevertheless, what can be said
    is that the more that is packed into the boilerplate solution, the bigger the
    risk that anything inside is broken. Therefore, in this section, you will learn
    about the most common ones, every single solution with advantages, trade-offs,
    and how to use them.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因为模板化解决方案包含的内容范围很广，很难对它们做出一般性的假设。尽管如此，可以说的是，模板化解决方案包含的内容越多，其中任何东西出现问题的风险就越大。因此，在本节中，你将了解最常见的模板，每个解决方案的优点、权衡以及如何使用它们。
- en: Using the React Native TypeScript template
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 React Native TypeScript 模板
- en: 'React Native comes with an integrated template engine. When you are using the
    React Native CLI to set up your project, you can work with a `template` flag.
    This is how you can use the React Native TypeScript template:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: React Native 集成了模板引擎。当你使用 React Native CLI 来设置你的项目时，你可以使用一个 `template` 标志。这就是你可以使用
    React Native TypeScript 模板的方式：
- en: '[PRE0]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This template does not come with any solution for navigation, state management,
    or anything else. It is the plain React Native Starter template, but with support
    for TypeScript. I like it very much because it is very simple, has nearly no dependencies,
    and lets you decide on what you need, while it does all the TypeScript compiler
    configuration for you.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板没有提供导航、状态管理或其他任何解决方案。它是普通的 React Native Starter 模板，但支持 TypeScript。我非常喜欢它，因为它非常简单，几乎没有依赖，并允许你决定你需要什么，同时为你完成所有
    TypeScript 编译器配置。
- en: '**Advantages** of this include the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点**包括以下内容：'
- en: TypeScript support
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript 支持
- en: No unwanted dependencies
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无不必要的依赖
- en: Easy to maintain
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于维护
- en: '**Trade-offs** include the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**权衡**包括以下内容：'
- en: None
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无
- en: While the React Native TypeScript template is a no-brainer to use when starting
    a new project, the following boilerplate solutions are not that easy to decide
    on. This is because they come with more libraries attached.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 React Native TypeScript 模板在开始新项目时使用起来不费吹灰之力，但以下模板化解决方案并不容易决定。这是因为它们附带更多的库。
- en: Using React Native Boilerplate by thecodingmachine
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 by thecodingmachine 的 React Native 模板
- en: 'This boilerplate also uses the built-in React Native template engine to work.
    But compared to the React Native TypeScript template, it already makes decisions
    on many things for you. It comes with Redux, Redux Persist, and the redux toolkit
    for state management, Axios for API calls, React Navigation, and Flipper integration.
    Additionally, it creates a good directory structure for your project. You can
    create a project based on this template with the following call:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板也使用了内置的 React Native 模板引擎来工作。但与 React Native TypeScript 模板相比，它已经为你做了很多决定。它包含了
    Redux、Redux Persist 和用于状态管理的 redux toolkit、用于 API 调用的 Axios、React Navigation 和
    Flipper 集成。此外，它为你的项目创建了一个良好的目录结构。你可以使用以下调用创建基于此模板的项目：
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Because this template comes with a lot of predefined libraries, you should take
    a look at whether it is actively maintained and has been updated recently. Otherwise,
    you could start with very old versions of all the libraries that would need a
    potentially time-consuming update very soon.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个模板包含了很多预定义的库，你应该查看它是否是积极维护的并且最近有更新。否则，你可能会开始使用所有库的非常旧版本，这可能会很快需要耗时的更新。
- en: '**Advantages** of this include the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点**包括以下内容：'
- en: TypeScript support
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript 支持
- en: Good libraries
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 良好的库
- en: Good project structure
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 良好的项目结构
- en: '**Trade-offs** of this include the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**权衡**包括以下内容：'
- en: It uses Redux for State Management, so you might have to stick to that
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用 Redux 进行状态管理，因此你可能不得不坚持使用它
- en: At the time of writing, it was already three versions behind the most recent
    React Native release, so you will miss the most recent features and bug fixes
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在撰写本文时，它已经落后于最新的 React Native 发布版三个版本，因此你将错过最新的功能和错误修复。
- en: For more information on this boilerplate, please visit the official documentation
    at [https://thecodingmachine.github.io/react-native-boilerplate/](https://thecodingmachine.github.io/react-native-boilerplate/).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 关于此样板更详细的信息，请访问官方文档 [https://thecodingmachine.github.io/react-native-boilerplate/](https://thecodingmachine.github.io/react-native-boilerplate/)。
- en: While these are good solutions, you should have a look to see whether they really
    fit your project. The next template comes with a slightly different configuration.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些都是好的解决方案，但你应该查看它们是否真的适合你的项目。下一个模板带有略微不同的配置。
- en: Using React Native Starter Kit by mcnamee
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 mcnamee 的 React Native Starter Kit
- en: This boilerplate does not use any template engine or CLI. It is just a GitHub
    repository that you can download or clone and start with. Additionally, it comes
    with a useful structure and brings a lot of libraries.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个样板不使用任何模板引擎或 CLI。它只是一个你可以下载或克隆并开始的 GitHub 仓库。此外，它还附带了一个有用的结构，并引入了许多库。
- en: It uses Redux and Rematch for state management, React Native Router Flux for
    navigation, and it also comes with Native Base as the UI library and Fastlane
    for deployment. Essentially, it brings you all you need to get your first result
    shipped in hours.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用 Redux 和 Rematch 进行状态管理，React Native Router Flux 进行导航，并且还附带 Native Base 作为
    UI 库和 Fastlane 进行部署。基本上，它为你提供了在数小时内将第一个结果交付所需的一切。
- en: But again, please have a look at how well-maintained the template is. At the
    time of writing, the last release of React Native Router Flux was more than a
    year ago, which means one core library of the template is essentially unusable.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 但再次提醒，请查看模板的维护情况。在撰写本文时，React Native Router Flux 的最后一个发布版本已经超过一年，这意味着模板的一个核心库基本上是不可用的。
- en: '**Advantages** of this include the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点**包括以下内容：'
- en: Good project structure
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 良好的项目结构
- en: Adds everything to get you going
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了所有启动所需的内容
- en: '**Trade-offs** of this include the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**权衡**包括以下内容：'
- en: It uses Redux for State Management, so you might have to stick to that
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用 Redux 进行状态管理，因此你可能不得不坚持使用它
- en: It uses Native Base as UI Toolkit, so you might have to stick to that
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用 Native Base 作为 UI 工具包，因此你可能不得不坚持使用它
- en: It has an outdated navigation library, so you will have problems with the most
    recent versions of React Native
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有一个过时的导航库，因此你将遇到与 React Native 最新版本的问题
- en: You can find more information about this template from the official GitHub page
    at [https://github.com/mcnamee/react-native-starter-kit](https://github.com/mcnamee/react-native-starter-kit).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从官方 GitHub 页面 [https://github.com/mcnamee/react-native-starter-kit](https://github.com/mcnamee/react-native-starter-kit)
    获取更多关于此模板的信息。
- en: After looking at two boilerplate templates, we’ll have a look at two really
    extensive CLI tools to set up your project.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看两个样板模板后，我们将探讨两个真正广泛的 CLI 工具来设置你的项目。
- en: Working with Ignite CLI
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Ignite CLI 进行工作
- en: Ignite is a boilerplate solution developed and maintained by Infinite Red, an
    awesome React Native company, doing awesome open source work. It is much more
    than a simple template. It is a complete CLI, replacing the built-in React Native
    `init` command.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Ignite 是由 Infinite Red 开发和维护的一个样板解决方案，Infinite Red 是一家出色的 React Native 公司，致力于出色的开源工作。它远不止是一个简单的模板。它是一个完整的
    CLI，可以替换内置的 React Native `init` 命令。
- en: 'With the following command, you can create a new app:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令，你可以创建一个新的应用程序：
- en: '[PRE2]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This creates an application with a good folder structure, React Navigation for
    navigation, MobX-State-Tree for state management, apisauce for API calls, and,
    of course, TypeScript support. In addition to that, your project automatically
    supports Flipper and Reactotron for debugging, Detox for end-to-end tests, and
    Expo, including Expo web.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个具有良好文件夹结构的应用程序，使用 React Navigation 进行导航，使用 MobX-State-Tree 进行状态管理，使用 apisauce
    进行 API 调用，当然，还有 TypeScript 支持。除此之外，你的项目还自动支持 Flipper 和 Reactotron 进行调试，Detox 进行端到端测试，以及
    Expo，包括 Expo web。
- en: 'On top of all that, Ignite CLI comes with a feature called **generators**.
    With these generators, you can generate your models, components, screens, and
    navigators via the Ignite CLI. This means you can customize your project to your
    needs, without having to write these files from scratch. If you want to create
    a new component, you can use the following command:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些之上，Ignite CLI还带有一个名为**生成器**的功能。使用这些生成器，你可以通过Ignite CLI生成你的模型、组件、屏幕和导航器。这意味着你可以根据需要自定义项目，而无需从头开始编写这些文件。如果你想创建一个新的组件，可以使用以下命令：
- en: '[PRE3]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This command creates a component based on a template stored in the `ignite/templates`
    folder, which was created with your project.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令基于存储在`ignite/templates`文件夹中的模板创建组件，该模板是用你的项目创建的。
- en: Tip
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: When working with the Ignite generators, you can edit the templates that are
    used to generate your files. Just edit the templates in `ignite/templates`, and
    the generated files will include your changes. This means you can adapt the templates
    to your needs and standards, and then use the generators to ensure that everyone
    sticks to those standards.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Ignite生成器工作时，你可以编辑用于生成文件的模板。只需编辑`ignite/templates`中的模板，生成的文件将包含你的更改。这意味着你可以根据需要和标准调整模板，然后使用生成器确保每个人都遵守这些标准。
- en: While this setup is great for professional projects, it comes with a lot of
    library decisions built in. In particular, MobX-State-Tree for State Management
    is one you might want to have a look at. It is a great solution for state management,
    but it isn’t as popular as Redux or React Context, which means the community support
    is quite poor.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种设置非常适合专业项目，但它内置了许多库决策。特别是，对于状态管理，你可能想看看MobX-State-Tree。这是一个很好的状态管理解决方案，但不像Redux或React
    Context那样受欢迎，这意味着社区支持相当有限。
- en: '**Advantages** of this include the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点**包括以下内容：'
- en: Good project structure
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 良好的项目结构
- en: Good debugging integration
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 良好的调试集成
- en: Integration for Detox end-to-end testing
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Detox端到端测试集成
- en: Localization integration
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地化集成
- en: Generators
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器
- en: '**Trade-offs** of this include the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**权衡**包括以下内容：'
- en: It uses MobX-State-Tree for State Management, which isn’t as popular as Redux
    or React Context.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用MobX-State-Tree进行状态管理，这不像Redux或React Context那样受欢迎。
- en: It has Expo integration out of the box. This will grow your app bundle size
    and adds another dependency.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它自带Expo集成。这将增加你的应用包大小，并添加另一个依赖项。
- en: It adds a lot of overhead for smaller projects
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为小型项目增加了很多开销
- en: For more information on Ignite, please visit the GitHub page at [https://github.com/infinitered/ignite](https://github.com/infinitered/ignite).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解更多关于Ignite的信息，请访问GitHub页面[https://github.com/infinitered/ignite](https://github.com/infinitered/ignite)。
- en: Now you know different boilerplate solutions along with their advantages and
    trade-offs. Even if you don’t use a boilerplate solution for creating your projects,
    I would recommend having a look at the structure they create. This kind of structure
    is something you can build on.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你了解了不同的样板解决方案及其优缺点。即使你不使用样板解决方案来创建你的项目，我也建议你看看它们创建的结构。这种结构是你可以在此基础上构建的。
- en: After looking at these boilerplate solutions, next, we’ll focus on the UI part.
    There are also a lot of useful open source solutions out there, which will make
    your life a lot easier.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看这些样板解决方案之后，接下来我们将关注UI部分。同时，也有很多有用的开源解决方案，这将使你的生活变得更加轻松。
- en: Finding and using high-quality UI libraries
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找和使用高质量的UI库
- en: '**UI libraries** provide a predefined UI for the most common use cases. There
    are a lot of different UI libraries you can use for your project. But some are
    better than others. This section not only names the most popular ones, but it
    also gives you an idea of what you must look for when doing your own research.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**UI库**为最常见的用例提供预定义的UI。你可以为你的项目使用很多不同的UI库。但有些比其他的好。本节不仅列出了最受欢迎的库，还为你提供了在进行自己的研究时必须考虑的一些想法。'
- en: 'A good UI library should meet the following criteria:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的UI库应该满足以下标准：
- en: '**Well maintained**: As with all libraries, it has to be well maintained. This
    means there are multiple contributors, there is good code quality, and there are
    regular releases. This is important to ensure that future version upgrades of
    React Native are supported.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**维护良好**：与所有库一样，它必须得到良好的维护。这意味着有多个贡献者，代码质量良好，并且有定期的发布。这对于确保React Native的未来版本升级得到支持非常重要。'
- en: '**Component-based**: A React Native UI library should provide a set of components,
    which you can use out of the box.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于组件**：一个 React Native UI 库应该提供一组组件，你可以直接使用。'
- en: '**Theming**: The library should include theming options and be easily adaptable
    to your colors, fonts, paddings, and margins.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主题**：库应该包含主题选项，并且易于适应你的颜色、字体、填充和边距。'
- en: '**Type declarations**: A good UI library should have type declarations for
    components and themes.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型声明**：一个好的 UI 库应该为组件和主题提供类型声明。'
- en: There are a lot of different UI libraries out there. I will introduce you to
    two of them in the following subsection, but since they don’t have to be the best
    fit for your project, please do your own research based on the criteria mentioned
    here before using either of them.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 市面上有很多不同的 UI 库。在接下来的子节中，我将向你介绍其中两个，但鉴于它们可能并不完全适合你的项目，请在使用它们之前，根据这里提到的标准进行自己的研究。
- en: Working with React Native Paper
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 React Native Paper
- en: '**React Native Paper** is a UI library based on **Material Design**. It is
    created and maintained by Callstack, a React Native company that is also working
    a lot on the React Native core, so these folks know what they are doing. This
    means the library sets a very high standard regarding code quality.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**React Native Paper** 是一个基于 **Material Design** 的 UI 库。它由 Callstack 创建和维护，Callstack
    是一家专注于 React Native 核心的公司，因此这些人员非常了解他们的工作。这意味着该库在代码质量方面设定了非常高的标准。'
- en: 'React Native Paper meets all the criteria defined in the previous subsection.
    The following features are included in React Native Paper:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: React Native Paper 符合之前子节中定义的所有标准。以下是在 React Native Paper 中包含的功能：
- en: '**Excellent theming support**: Paper comes with integrated theming. You can
    easily change and extend the default themes and use them all over your app.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**出色的主题支持**：Paper 内置了主题支持。你可以轻松地更改和扩展默认主题，并在你的应用中到处使用它们。'
- en: '**Type declarations**: All of the components and themes come with type declarations.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型声明**：所有组件和主题都附带类型声明。'
- en: '`react-native-vector-icons` and `MaterialCommunityIcons` to provide you with
    icons.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react-native-vector-icons` 和 `MaterialCommunityIcons` 为你提供图标。'
- en: '**Over 30 pre-built components**: All components are highly customizable and
    easy to use.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超过 30 个预构建组件**：所有组件都高度可定制且易于使用。'
- en: '`Appbar` as a custom navigation bar in React Navigation.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Appbar` 作为 React Navigation 中的自定义导航栏。'
- en: While React Native Paper is possibly the best UI library out there from a technical
    point of view, you must keep in mind that it is completely based on Google’s Material
    Design. This means you might not want to use it on iOS, since it makes your app
    look different than the iOS standards.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然从技术角度来看，React Native Paper 可能是市面上最好的 UI 库，但你必须记住，它完全基于 Google 的 Material Design。这意味着你可能不希望在
    iOS 上使用它，因为它会使你的应用看起来与 iOS 标准不同。
- en: For more information about React Native Paper, its installation, and its usage,
    please visit the official documentation at [https://callstack.github.io/react-native-paper/](https://callstack.github.io/react-native-paper/).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解更多关于 React Native Paper、其安装和使用的详细信息，请访问官方文档：[https://callstack.github.io/react-native-paper/](https://callstack.github.io/react-native-paper/)。
- en: Another high-quality UI library is NativeBase. In the next subsection, you will
    learn about this library.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个高质量的 UI 库是 NativeBase。在下一个子节中，你将了解这个库。
- en: Working with NativeBase
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 NativeBase
- en: '**NativeBase** is a UI library that works for React Native alongside plain
    React. This means it not only works within your iOS and Android app, but it also
    works on your web app if you have one. For products with Android, iOS, and web
    support, this can be very useful because you can primarily use the same code base
    for all platforms.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**NativeBase** 是一个适用于 React Native 以及纯 React 的 UI 库。这意味着它不仅适用于你的 iOS 和 Android
    应用，如果你有，它也适用于你的 Web 应用。对于需要 Android、iOS 和 Web 支持的产品，这非常有用，因为你可以主要使用相同的代码库为所有平台编写代码。'
- en: 'Additionally, NativeBase meets all of the criteria defined in the first subsection
    of this section. The following features are included in NativeBase:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，NativeBase 符合本节第一子节中定义的所有标准。以下是在 NativeBase 中包含的功能：
- en: '**Excellent theming support**: NativeBase also has very good theming support.
    Essentially, it works quite similarly to React Native Paper. You can easily change
    and extend the default themes and use them all over your app. It also supports
    light and dark modes out of the box.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**出色的主题支持**：NativeBase 也提供了非常好的主题支持。本质上，它的工作方式与 React Native Paper 非常相似。你可以轻松地更改和扩展默认主题，并在你的应用中到处使用它们。它还支持开箱即用的亮色和暗色模式。'
- en: '**Type declarations**: All components and themes come with type declarations.
    You also have excellent documentation on how to extend these types when it comes
    to customizing themes or components.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型声明**：所有组件和主题都带有类型声明。你还有关于如何扩展这些类型以自定义主题或组件的优秀文档。'
- en: '`react-native-vector-icons` for plain React Native projects or `@expo/vector-icon`
    for Expo projects.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react-native-vector-icons` 用于纯 React Native 项目或 `@expo/vector-icon` 用于 Expo
    项目。'
- en: '**Over 30 pre-built components**: All components are highly customizable and
    easy to use.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超过 30 个预构建组件**：所有组件都高度可定制且易于使用。'
- en: '**Responsive support**: NativeBase has excellent responsive design support.
    This means you can adapt your views to different screen sizes with just a few
    additional properties on your components.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应式支持**：NativeBase 具有出色的响应式设计支持。这意味着你只需在组件上添加几个额外的属性，就可以适应不同的屏幕尺寸。'
- en: '**Accessibility**: Based on React Native ARIA, NativeBase provides accessibility
    support for all components. This means you can easily provide support for screen
    readers, ensure a good contrast ratio, and enable keyboard interactions for your
    app.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无障碍性**：基于 React Native ARIA，NativeBase 为所有组件提供了无障碍支持。这意味着你可以轻松地为屏幕阅读器提供支持，确保良好的对比度，并启用应用程序的键盘交互。'
- en: Additionally, NativeBase comes with a Figma file, which makes it an ideal starting
    point for creating your own design system with a design expert. All in all, it
    is a very good solution for creating a beautiful UI in record time.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，NativeBase 还附带一个 Figma 文件，这使得它成为与设计专家一起创建自己的设计系统的理想起点。总的来说，它是一个在创纪录的时间内创建美观界面的非常好的解决方案。
- en: For more information on NativeBase, please visit the official documentation
    at [https://docs.nativebase.io/](https://docs.nativebase.io/).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解更多关于 NativeBase 的信息，请访问官方文档[https://docs.nativebase.io/](https://docs.nativebase.io/)。
- en: 'As already mentioned, there are a lot more open source UI libraries out there.
    Please check this list for the most popular ones:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，还有许多开源 UI 库。请查看此列表以获取最受欢迎的库：
- en: React Native UI Kitten
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Native UI Kitten
- en: React Native Elements
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Native Elements
- en: Material Kit Pro React Native by creative-tim
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Material Kit Pro React Native by creative-tim
- en: Nachos UI Kit for React Native
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nachos UI Kit for React Native
- en: These UI libraries can save you a lot of time. But as you want to create an
    individual app experience for your users, you should only use them as a starting
    point. Fortunately, most of them are adaptive enough that you can use them to
    create your own design while using the battle-proven structure of the library.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 UI 库可以为你节省大量时间。但因为你希望为你的用户提供独特的应用程序体验，所以你应该只将它们作为起点。幸运的是，大多数库都足够灵活，你可以使用它们来创建自己的设计，同时使用经过实战考验的库结构。
- en: As your projects grow, I would recommend extending the library of your choice
    with your own components. If you like and think you have something that can be
    interesting for others too, you can even give something back to the community
    by creating pull requests and extending the official library.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的项目增长，我建议扩展你选择的库，添加你自己的组件。如果你喜欢，并认为你有其他人对之感兴趣的东西，你甚至可以通过创建拉取请求和扩展官方库来为社区做出贡献。
- en: After looking at the UI libraries, in the next subsection, you’ll get to know
    another useful tool. This is especially useful when working on large applications,
    where UI components are shared between different repositories and where some developers
    only work on the UI components. It is called **Storybook**.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看 UI 库之后，在下一个子节中，你将了解另一个有用的工具。这对于开发大型应用程序特别有用，在这些应用程序中，UI 组件在不同的存储库之间共享，并且一些开发者只负责
    UI 组件。它被称为 **Storybook**。
- en: Using Storybook for React Native
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Storybook 进行 React Native 开发
- en: Storybook is very popular in the plain React world. It is a tool that renders
    all your components in predefined states, so you can have a look at them without
    having to start your real app and navigate to the location where they are used.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Storybook 在纯 React 世界中非常受欢迎。这是一个渲染你所有组件在预定义状态下的工具，这样你就可以查看它们，而无需启动你的真实应用程序并导航到它们被使用的位置。
- en: 'With Storybook, you write stories, which are then packed into a storybook.
    Each of these stories contains a component. It also defines the location within
    the storybook. The following code example shows what a story can look like:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Storybook，你可以编写故事，这些故事随后会被打包成故事书。每个故事都包含一个组件。它还定义了故事书中的位置。以下代码示例展示了故事可能的样子：
- en: '[PRE4]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the first line, the `PrimaryButton` component is imported. The following
    default export defines the location in the storybook and which component the story
    is related to. The `Standard` const and the `Alert` const are different states,
    and the `PrimaryButton` component will be rendered and shown in the storybook.
    The corresponding `args` define this state:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行中，导入了 `PrimaryButton` 组件。接下来的默认导出定义了在 Storybook 中的位置以及与哪个组件相关联。`Standard`
    常量和 `Alert` 常量是不同的状态，`PrimaryButton` 组件将在 Storybook 中渲染并显示。相应的 `args` 定义了这个状态：
- en: '![Figure 9.1 – Storybook running in a browser'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1 – Storybook 在浏览器中运行'
- en: '](img/B16694_09_01.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16694_09_01.jpg)'
- en: Figure 9.1 – Storybook running in a browser
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – Storybook 在浏览器中运行
- en: Storybook on React Native either works on the iOS or Android simulator, a real
    device, or you can use React Native Web to create a web version of your components
    and render them into any browser. This is shown in *Figure 9.1* and can be especially
    useful when working with designers.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React Native 上的 Storybook 既可以运行在 iOS 或 Android 模拟器上，也可以在真实设备上运行，或者您可以使用 React
    Native Web 创建组件的网页版本并将它们渲染到任何浏览器中。这如图*图9.1*所示，当与设计师合作时特别有用。
- en: Storybook makes it possible to develop your components isolated from the rest
    of the application. It not only shows you the component, but it also lets you
    change the properties within a storybook. So, you can see how your component will
    behave in your real application under different circumstances.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Storybook 使得您可以在与应用程序的其他部分隔离的情况下开发组件。它不仅展示了组件，还允许您在 Storybook 中更改属性。因此，您可以看到组件在不同情况下在您的实际应用程序中的表现。
- en: I wouldn’t use Storybook for small projects, but when your project and your
    team grow, Storybook can be a useful tool to increase your development speed on
    the UI part. This is especially the case when you have UI components that you
    share between different repositories. I would recommend this when you have multiple
    applications in your company that should all share the same look and feel.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会在小型项目中使用 Storybook，但当您的项目和团队成长时，Storybook 可以成为提高您UI开发速度的有用工具。这尤其适用于您在不同存储库之间共享UI组件的情况。如果您公司有多个应用程序，都应该具有相同的视觉和感觉，我建议您使用它。
- en: In this case, a central repository for your components could be a good solution.
    With Storybook, this repository can be maintained by a developer and designer,
    without needing access to all your applications. You can read more about this
    in [*Chapter 10*](B16694_10.xhtml#_idTextAnchor347), *Structuring Large-Scale,
    Multi-Platform Projects*, in the *Writing own libraries* section.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，为您的组件创建一个中心存储库可能是一个不错的解决方案。使用 Storybook，这个存储库可以由开发者和设计师维护，而无需访问所有应用程序。您可以在[*第10章*](B16694_10.xhtml#_idTextAnchor347)，“结构化大规模、多平台项目”部分的*编写自己的库*中了解更多信息。
- en: For more information on Storybook, please visit the official documentation at
    [https://storybook.js.org/](https://storybook.js.org/).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 Storybook 的更多信息，请访问官方文档[https://storybook.js.org/](https://storybook.js.org/)。
- en: Summary
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about useful tools for increasing code quality,
    catching the most common errors automatically, and speeding up the project setup
    along with the development process. You understood why type definitions are important
    and how to use ESLint and prettier to ensure your code meets certain criteria.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了用于提高代码质量、自动捕获最常见错误以及加快项目设置和开发过程的有用工具。您了解了类型定义的重要性以及如何使用 ESLint 和 prettier
    确保您的代码符合某些标准。
- en: Additionally, you got to know the most popular React Native boilerplate solutions
    to start a project, and you learned what advantages and trade-offs each of these
    solutions have. At the end of the chapter, you learned about Storybook for React
    Native, how to use it, and in which scenarios it is a useful tool.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还了解了最流行的 React Native 模板解决方案以启动项目，并学习了每个解决方案的优势和权衡。在本章末尾，您学习了 React Native
    的 Storybook，如何使用它，以及在哪些场景下它是一个有用的工具。
- en: After learning about all these useful tools, it is time to dive deeper into
    large-scale projects. In the next chapter, you will learn how to set up and maintain
    a project structure, which will work for large-scale projects. Additionally, you
    will learn what options you have, to share code between different platforms, and
    which of these solutions works best in which scenario.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了所有这些有用的工具之后，是时候深入探讨大规模项目了。在下一章中，您将学习如何设置和维护项目结构，这将适用于大规模项目。此外，您还将了解您有哪些选项可以在不同平台之间共享代码，以及这些解决方案在哪些场景下效果最佳。
- en: 'Part 3: React Native in Large-Scale Projects and Organizations'
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3部分：在大型项目和组织中使用React Native
- en: You will learn how to use React Native in large organizations or large-scale
    projects. This includes structuring large applications, setting up good processes,
    using automation wherever possible, and starting to write your own libraries.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学习如何在大型组织或大型项目中使用React Native。这包括结构化大型应用程序、建立良好的流程、尽可能使用自动化，以及开始编写自己的库。
- en: 'The following chapters are in this section:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含以下章节：
- en: '[*Chapter 10*](B16694_10.xhtml#_idTextAnchor347), *Structuring Large-Scale,
    Multiplatform Projects*'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B16694_10.xhtml#_idTextAnchor347)，*结构化大型、多平台项目*'
- en: '[*Chapter 11*](B16694_11.xhtml#_idTextAnchor376), *Creating and Automating
    Workflows*'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B16694_11.xhtml#_idTextAnchor376)，*创建和自动化工作流程*'
- en: '[*Chapter 12*](B16694_12.xhtml#_idTextAnchor410), *Automated Testing of React
    Native Apps*'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B16694_12.xhtml#_idTextAnchor410)，*React Native应用的自动化测试*'
- en: '[*Chapter 13*](B16694_13.xhtml#_idTextAnchor462), *Tips and Outlook*'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B16694_13.xhtml#_idTextAnchor462)，*技巧与展望*'
