- en: Chapter 8. Performance of React Apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned to use various React add-ons. We saw add-ons
    ranging from immutability helpers to test utilities.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at React performance tools that can improve the
    performance of our React apps. In particular, we will be using the PERF add-on,
    `PureRenderMixin` and `shouldComponentUpdate`. We will also look at some of the
    gotchas that needs to be considered while using the performance tools provided
    by React.
  prefs: []
  type: TYPE_NORMAL
- en: Performance of React apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Hey Mike, I have few questions for you today. I have been thinking about our
    search app over the weekend. Do you have some time to discuss them?" Shawn asked.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Sure, but let me get some coffee first. Okay, I am ready now. Shoot!" said
    Mike.'
  prefs: []
  type: TYPE_NORMAL
- en: '"I have few questions about the performance of React apps. I know React is
    very good at re-rendering the component tree whenever the state changes. React
    has made it very easy for me to understand and reason my code. However, does it
    not hamper the performance? Re-rendering seems like a very costly affair, especially
    when re-rendering large component trees." Shawn asked.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Shawn, the re-rendering can be expensive. Nevertheless, React is smart about
    it. It only renders the part that is changed. It does not need to re-render everything
    on the page. It''s also smart at keeping the DOM manipulation as least as possible."'
  prefs: []
  type: TYPE_NORMAL
- en: '"How is that possible? How does it know which part of the page is changed?
    Does it not depend on user interactions or incoming states and props?" questioned
    Shawn.'
  prefs: []
  type: TYPE_NORMAL
- en: '"The virtual DOM comes to the rescue here. It does all the heavy lifting of
    keeping track of what changed and helping React make only minimal changes to the
    real DOM." Mike explained.'
  prefs: []
  type: TYPE_NORMAL
- en: Virtual DOM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Shawn, React uses virtual DOM to keep track of what has changed in the real
    DOM. It''s concept is very easy to understand. React always keeps a copy of the
    representation of the actual DOM in memory. Whenever something changes, such as
    some state manipulation, it calculates another copy of the DOM that will be generated
    with new state and props. Then it calculates the difference between the original
    copy of the virtual DOM and the new copy of the virtual DOM. This difference results
    in minimal operations on the real DOM that can take the current DOM to a new stage.
    In this way, React does not have to do major changes when something changes."
    Mike explained.'
  prefs: []
  type: TYPE_NORMAL
- en: '"But isn''t the diff calculation expensive?" asked Shawn.'
  prefs: []
  type: TYPE_NORMAL
- en: '"It''s not expensive when you compare it with actual DOM operations. Manipulation
    of DOM is always expensive. The comparison of virtual DOM occurs in JavaScript
    code, so it is always faster than doing manual DOM operations." said Mike.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Another advantage of this approach is that once React knows what operations
    are needed to be performed on DOM, it does them in a single batch. Therefore,
    when we render a list of 100 elements, instead of appending one element at a time,
    React will do minimal DOM operations to insert these 100 elements on the page."
    Mike explained.'
  prefs: []
  type: TYPE_NORMAL
- en: '"I am impressed!" Shawn exclaimed .'
  prefs: []
  type: TYPE_NORMAL
- en: '"You will be more impressed. Let me actually show you what I mean. Let''s use
    the PERF add-on from React and actually see what we discussed in real time."'
  prefs: []
  type: TYPE_NORMAL
- en: The PERF addon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Let''s start with installing the PERF addon."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '"We need this add-on only in the development mode. This is an important point
    to remember because in production, we don''t need the debugging information as
    it may make our app slow." informed Mike.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Shawn, the PERF add-on can be used to see what changes React is doing with
    the DOM, where is it spending time while rendering our app, is it wasting some
    time while rendering, and so on. This information can then be used to improve
    the performance of the app." said Mike.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Let''s start by exposing the PERF add-on as a global object. We can use it
    in the browser console while our app is running to see how React is making changes
    as per the user interactions." explained Mike.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '"We have imported the PERF add-on in our `index.js` file, which is the starting
    point of the app. We can access the `Perf` object in the browser console as we
    have attached it to `window.Perf`." Mike added.'
  prefs: []
  type: TYPE_NORMAL
- en: '![The PERF addon](img/4730_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '"The PERF add-on comes with methods that can help us understand what React
    is doing with the DOM when something changes. Let''s measure some performance
    statistics. We will start the measurement process by calling `Perf.start()` in
    the browser console. After that, we will interact with the app. We will type in
    a query to search a book, hit submit, and the search results will be displayed.
    We will stop the performance measurement by calling `Perf.stop()` in the browser
    console. After that, let''s analyze the information that we gathered." Mike explained
    the process.'
  prefs: []
  type: TYPE_NORMAL
- en: '![The PERF addon](img/4730_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '"Let''s search for books written by Dan Brown."'
  prefs: []
  type: TYPE_NORMAL
- en: '![The PERF addon](img/4730_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '"Once the results are displayed, let''s stop the performance measurements."'
  prefs: []
  type: TYPE_NORMAL
- en: '![The PERF addon](img/4730_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: DOM operations performed by React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Shawn, the PERF add-on can show us which DOM operations were performed by
    React. Let''s see what manipulations React did to the DOM to render the list of
    books by Dan Brown." said Mike.'
  prefs: []
  type: TYPE_NORMAL
- en: '![DOM operations performed by React](img/4730_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '"The `Perf.printDOM()` method tells us the DOM manipulations made by React.
    It has made only two set `innerHTML` calls. First one is to render the spinner
    and second one is to render the list of rows. In between, we see a call to remove,
    which must be when the spinner was removed from the page."'
  prefs: []
  type: TYPE_NORMAL
- en: '"Wow, this method looks very handy as it can tell us if React is somehow doing
    some extra DOM manipulations." said Shawn.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Yes, but there are more tools for the purpose analyzing the performance. Let''s
    see how much time does React require to render each component. This can be achieved
    using `Perf.printInclusive()`." explained Mike.'
  prefs: []
  type: TYPE_NORMAL
- en: Time taken to render all the components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![Time taken to render all the components](img/4730_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '"This method prints the overall time taken to render all the components. This
    also included the time required to process props and set up initial state and
    calls to `componentDidMount` and `componentWillMount`."'
  prefs: []
  type: TYPE_NORMAL
- en: '"Therefore, if we have some time-intensive operation in one of these hooks,
    it will impact the output shown by the `printInclusive` function, right?" Shawn
    asked.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Exactly. Though the PERF add-on provided another method—`printExclusive()`—that
    prints the time to taken render without these hooks, which are used to mount apps."'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time taken to render all the components](img/4730_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '"But Mike, these methods are not that helpful for detecting the performance
    of React. I get the overall picture about what all things happened, but it does
    not tell me how to optimize which part." asked Shawn.'
  prefs: []
  type: TYPE_NORMAL
- en: Time wasted by React
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '"Shawn, the PERF add-on can also tell us how much time was wasted by React
    and where. It is helpful in determining the parts of our app that we can optimize
    further." said Mike.'
  prefs: []
  type: TYPE_NORMAL
- en: '"What is wasted time?"'
  prefs: []
  type: TYPE_NORMAL
- en: '"When React re-renders a component tree, some components may not change from
    their previous representation. However, if they are rendered again, then React
    has wasted time in rendering the same output. The PERF add-on can keep track of
    all such time and give us a summary of how React wasted time rendering the same
    output as before. Let''s see this in action." said Mike.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time wasted by React](img/4730_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '"The PERF add-on tells us that it wasted time in re-rendering the `Form` component
    twice, but nothing was changed in the Form component, therefore, it just re-rendered
    everything as it is." explained Mike.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Let''s see the `Form` component to understand why it is happening."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '"Shawn, the `Form` component does not depend on state or props for its rendering.
    It renders the same output irrespective of state and props. However, we update
    its state when a user enters a character in the input box. Due to this, React
    will re-render it. Nothing is actually changed in the re-rendered output. Therefore,
    the PERF add-on is complaining about the wasted time." Mike explained.'
  prefs: []
  type: TYPE_NORMAL
- en: '"This is useful information, but this looks like an insignificant wastage,
    right?" Shawn asked.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Agree. Let''s make some changes so that I can show you how React can literally
    waste a lot of time re-rendering the same output when it shouldn''t." said Mike.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Currently, we only show the first 100 search results returned by the Open
    Library API. Let''s change our code to show all the results on same page."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '"I have introduced a new state to hold the search term, total number of pages
    to fetch from the Open Library, and current page number being fetched."'
  prefs: []
  type: TYPE_NORMAL
- en: '"Now, we want to fetch all the results from the API, by default, on the same
    page. The API returns us the total number of books found for a query in the `numFounds`
    attribute. Based on this, we need to find the total number of pages that we need
    to fetch from the API."'
  prefs: []
  type: TYPE_NORMAL
- en: '"Also, each time maximum 100 records are returned that we have stored in `state.offset`
    already."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '"Once we get the total number of pages, we need to keep asking for the search
    results for the next page until all the pages are fetched. You want to try and
    get this working?" asked Mike.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Sure." said Shawn.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '"I changed the API URL to include the page parameter. Each time the response
    is received from API, we update the state with a new page. We also update `this.state.books`
    to include the newly fetched books. Then, the `_searchAgain` function gets called
    in the callback of the `this.setState` call so that it is the correct value of
    the next page that was set by the `this.setState` call." explains Shawn.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Nice, it''s an important point to remember not to call the `_searchAgain`
    function outside of the `this.setState()` call as it may get executed before `setState()`
    is finished.'
  prefs: []
  type: TYPE_NORMAL
- en: Because if we call it outside, the `_searchAgain` function may use an incorrect
    value of `this.state.page`. However, as you have passed the `_searchAgain` function
    in the callback to `setState`, there is no chance this will happen." said Mike.
  prefs: []
  type: TYPE_NORMAL
- en: '"The `_searchAgain` function just keeps fetching the results until all the
    pages are completed. In this way, we will display all the search results on the
    page, not just the first 100." informed Shawn.'
  prefs: []
  type: TYPE_NORMAL
- en: '"That''s what I wanted. Good job. Let me cleanup the render method so that
    spinner will always be displayed at the bottom." said Mike.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '"This will make sure that the spinner will be displayed until all the results
    are displayed. OK, all done. Now let''s measure the performance again." said Mike.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time wasted by React](img/4730_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '"Wow, the wasted time has increased a lot! Did Dan Brown release new books
    or what? So much extra time than what we saw last time?" said Shawn.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Haha, I don''t think that he released new books just now. Whenever the books
    on next page are fetched, we add them to the existing books and start fetching
    books from the next page. However, the books rendered for the previous pages are
    not changed at all. As we are keeping all of our state in the top-level `App`
    component, whenever its state changes, the whole component tree under `App` gets
    re-rendered. Therefore, `BookList` is rendered again. In turn, all `BookRows`
    are rendered again. This results in a significant amount of time getting wasted
    in rendering the same `BookRow` components for the previous pages again and again."
    said Mike.'
  prefs: []
  type: TYPE_NORMAL
- en: '"So each time we fetch books from a new page, all books, including the existing
    ones already present on page, get re-rendered again? I think just appending new
    book rows to the existing list is better in this case." said Shawn.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Don''t worry. We can easily get rid of this unnecessary wastage of time. React
    provides us a hook for short-circuiting the re-render process. It''s `shouldComponentUpdate`."'
  prefs: []
  type: TYPE_NORMAL
- en: The shouldComponentUpdate hook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '"Shawn, `shouldComponentUpdate` is a hook that tells React whether to re-render
    a component or not. It''s not called for initial rendering of the component. However,
    whenever a component is going to receive new state or props, `shouldComponentUpdate`
    is called before that. If the return value of this function is true, then React
    re-renders the component. However, if the return value is `false`, then React
    does not re-render the component until the next time it is called. The `componentWillUpdate`
    and `componentDidUpdate` hooks will also not be called in this case." Mike explained.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Nice. Then why did our code waste so much time? Should React not use this
    hook to optimize it and not re-render the same `BookRow` components repeatedly?"
    Shawn asked.'
  prefs: []
  type: TYPE_NORMAL
- en: '"By default, `shouldComponentUpdate` always returns true. React does this to
    avoid subtle bugs. We can have mutable state or props in our code that can make
    `shouldComponentUpdate` to return false positives. It may return false when it
    should return true, resulting in the component not being re-rendered when it should.
    Therefore, React places the responsibility of implementing `shouldComponentUpdate`
    in the developer''s hand." said Mike.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Let''s try to use `shouldComponentUpdate` ourselves in order to reduce the
    time wasted in re-rendering the same `BookRow` components." Mike added.'
  prefs: []
  type: TYPE_NORMAL
- en: '"This is our `BookRow` component as of now:"'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '"Let''s add `shouldComponentUpdate` to reduce unnecessary re-rendering."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `shouldComponentUpdate` hook gets `nextProps` and `nextState` as arguments
    and we can compare them with the current state or props to make a decision whether
    to return true or false.
  prefs: []
  type: TYPE_NORMAL
- en: '"Here, we are checking whether the title, author name, or edition count is
    changed or not. If any of these attributes are changed, then we will return `true`.
    However, if all of them are unchanged, then we will return `false`. Therefore,
    if none of the props are changed, the component will not get re-rendered. As the
    `BookRow` component only depends on props, we don''t have to worry about the state
    change at all." added Mike.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Now, measure the performance again and see if we got some improvements."'
  prefs: []
  type: TYPE_NORMAL
- en: '![The shouldComponentUpdate hook](img/4730_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '"Awesome, we got rid of the time spent in re-rendering the `BookRow` components
    completely. However, we can still improve a lot. Looks like we can also get rid
    of the time spent re-rendering the `Form` and `Header` components, based on the
    preceding result. They are static components. Therefore, they should not be re-rendered
    at all. Shawn, that''s your next challenge."'
  prefs: []
  type: TYPE_NORMAL
- en: '"On it."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '"Mike, we can simply return `false` from `shouldComponentUpdate` for `Header`
    and `Form` components as they do not depend on states or props at all for rendering!"'
  prefs: []
  type: TYPE_NORMAL
- en: '"Perfect find, Shawn. Make a note of such static components that do not depend
    on anything. They are perfect targets for just telling React to not even compare
    their virtual DOM as they do not need to be re-rendered at all." informed Mike.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Right. I will keep an eye on such static parts of UI that can be extracted
    into smaller components." said Shawn.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Let''s now see if we got rid of some more wasted time after doing these improvements."'
  prefs: []
  type: TYPE_NORMAL
- en: '![The shouldComponentUpdate hook](img/4730_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '"Cool! We got rid of the time wasted for re-rendering the same `Header` and
    `Form` components." said Mike.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Awesome! Let me also try to get rid of the time spent on `BookList` and `RowAlternator`
    too." informed Shawn.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Hold on, Shawn. Before doing this, I want to discuss about an alternative
    to `shouldComponentUpdate`."'
  prefs: []
  type: TYPE_NORMAL
- en: PureRenderMixin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Shawn, `PureRenderMixin` is an add-on that can be used in place of `shouldComponentUpdate`.
    Under the hood, it uses `shouldComponentUpdate` and compares the current props
    and state with the next props and states. Let''s try it in our code. First, we
    need to install the add-on, of course." said Mike.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '"Shawn, let''s see the wasted time now that we have used `PureRenderMixin`."
    said Mike.'
  prefs: []
  type: TYPE_NORMAL
- en: '![PureRenderMixin](img/4730_08_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '"Oh, it got worse. The `PureRenderMixin` function added the time wasted in
    re-rendering `Form` and `Header` components back. What is going on, Mike?" Shawn
    asked.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Calm down! I am going to explain why this happened. The `PureRenderMixin`
    compares the current props and state with the next props and state, but it does
    shallow comparison. Therefore, if we are passing the state or props that contain
    objects and arrays, then the shallow comparison will not return true even if they
    both have the same content." Mike explained.'
  prefs: []
  type: TYPE_NORMAL
- en: '"However, where are we passing any complex objects or arrays to the `Header`
    and `Form` components? We are just passing the book data such as the name of author,
    edition count, and so on. We are not passing anything to `Header`, how does `PureRenderMixin`
    fail?" Shawn asked.'
  prefs: []
  type: TYPE_NORMAL
- en: '"You are forgetting style prop passed to `Header` and `Form` from the `App`
    component." informed Mike.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '"Each time `App` gets re-rendered, a new object for style is created and sent
    to `Header` and `Form` in props."'
  prefs: []
  type: TYPE_NORMAL
- en: '![PureRenderMixin](img/4730_08_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The PureRenderMixin anti pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `PureRenderMixin` internally implements `shouldComponentUpdate`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `shallowCompare` function is also an add-on provided by React that is a
    helper function to compare the current state and props with the next state and
    props. It basically achieves the same thing as `PureRenderMixin`, but as it is
    a function, it can be used directly instead of using `PureRenderMixin`. It is
    especially needed when we are using ES6 classes with React." Mike explained.
  prefs: []
  type: TYPE_NORMAL
- en: '"Mike, so the shallow comparison is the reason why `PureRenderMixin` is failing
    to detect that there is no change in the next props?" Shawn asked.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Yes. The `shallowCompare` just iterates over the keys of objects that are
    being compared and returns false when the value of the key in each object is not
    strictly equal. Therefore, if we pass simple props, as follows, then `shallowCompare`
    will correctly determine that re-rendering is not required:"'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '"However, it will fail immediately with a prop that is an object or array."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '"Though `PureRenderMixin` saves us a few lines of code, it may not work all
    the time as we expect it to work. Especially when we have mutable state, objects,
    or arrays in props." said Mike.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Got it. So we can write our own `shouldComponentUpdate` function when we have
    nested state or props right?", Shawn asked.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Yes. `PureRenderMixin` and `shallowCompare` is good for simple components
    with simple props and states but we should take care when we are using it." Mike.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using mixins is discouraged in React world for various reasons. Checkout alternative
    approaches for `PureRenderMixin` pattern here - [https://github.com/gaearon/react-pure-render](https://github.com/gaearon/react-pure-render).
  prefs: []
  type: TYPE_NORMAL
- en: Immutable data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Mike, I have a question though. All said and done, why does `PureRenderMixin`
    perform shallow comparison in the first place? Should it not perform a deep comparison
    so that we will always have better performance?" Shawn was not very happy with
    `PureRenderMixin`.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Well, there is a reason for this. Shallow comparison is very cheap. It does
    not take much time. Deep comparison is always expensive. Therefore, `PureRenderMixin`
    does shallow comparison, which is good enough for most of the simple use cases,"
    said Mike.'
  prefs: []
  type: TYPE_NORMAL
- en: '"However, React does provide us an option of defining our own version of `shouldComponentUpdate`
    as we saw earlier. We can completely short-circuit the re-rendering process by
    just returning `false` from `shouldComponentUpdate` or we can compare only those
    props that are required by our component."'
  prefs: []
  type: TYPE_NORMAL
- en: '"True, just like we had written `shouldComponentUpdate` for the `BookRow` component
    right?" asked Shawn.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '"Exactly, Shawn. If needed, you can also perform a deep comparison as per the
    requirements of your component when needed."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '"Shawn, another option we have is using immutable data. Comparing immutable
    data with each other is very easy as it will always create new data or objects
    instead of mutating the existing ones."'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '"Therefore, we just have to compare the reference of the new object with the
    old object, they are always same when the values are equal and they are always
    different when values are unequal. Therefore, if we use immutable data for our
    props and state, then `PureRenderMixin` will work as expected." said Mike.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Check [http://facebook.github.io/immutable-js/](http://facebook.github.io/immutable-js/)
    as an option for using immutable data for state and props.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned about the performance tools provided by React
    and how to use them. We used the PERF add-on: `shouldComponentUpdate` and `PureRenderMixin`.
    We also saw which areas to look for when trying to improve the performance of
    our apps. We also studied the pitfalls while improving the performance, especially
    with `PureRenderMixin`. In the end, we discussed the importance and advantages
    of immutable data.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at the data model of React in detail using
    React Router and Flux. You will learn how to use React with other frameworks such
    as Backbone.
  prefs: []
  type: TYPE_NORMAL
