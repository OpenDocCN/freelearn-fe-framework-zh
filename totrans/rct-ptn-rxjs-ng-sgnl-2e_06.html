<html><head></head><body>
<div id="_idContainer054">
<h1 class="chapter-number" id="_idParaDest-92"><a id="_idTextAnchor097"/><span class="koboSpan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-93"><a id="_idTextAnchor098"/><span class="koboSpan" id="kobo.2.1">Transforming Streams</span></h1>
<p><span class="koboSpan" id="kobo.3.1">When dealing with streams, one of the most frequent use cases you will face is the need to transform a stream of certain values into a stream of other values. </span><span class="koboSpan" id="kobo.3.2">That’s what this chapter </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">is about.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">This chapter revolves around adding an autosave feature to our project that we will be resolving by transforming streams. </span><span class="koboSpan" id="kobo.5.2">We will start by explaining the autosave requirement that we will be implementing in the recipe app. </span><span class="koboSpan" id="kobo.5.3">Then, we will explore the imperative way of implementing this feature. </span><span class="koboSpan" id="kobo.5.4">After that, we will learn about the declarative pattern for doing it and study the most commonly used RxJS transformation operators for </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">this situation.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">Finally, we will delve into the different transformation operators provided by RxJS and their respective use cases, enriching our understanding through </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">hands-on examples.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">So, in this chapter, we’re going to cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.11.1">Defining the </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">autosave requirement</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Exploring the imperative pattern for the </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">autosave feature</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Exploring the declarative pattern for the </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">autosave feature</span></span></li>
</ul>
<h1 id="_idParaDest-94"><a id="_idTextAnchor099"/><span class="koboSpan" id="kobo.17.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.18.1">This chapter assumes that you have a basic understanding </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">of RxJS.</span></span></p>
<p><span class="koboSpan" id="kobo.20.1">For more details about Reactive forms, please refer </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">to </span></span><a href="https://angular.dev/guide/forms/reactive-forms"><span class="No-Break"><span class="koboSpan" id="kobo.22.1">https://angular.dev/guide/forms/reactive-forms</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.23.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.24.1">For demonstration purposes, we will be using a fake autosave service. </span><span class="koboSpan" id="kobo.24.2">Its implementation is available in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.25.1">recipes-book-api</span></strong><span class="koboSpan" id="kobo.26.1"> module in this book’s GitHub repository. </span><span class="koboSpan" id="kobo.26.2">Note that we won’t be going through the details of this service as the focus is not the backend of </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">the project.</span></span></p>
<p><span class="koboSpan" id="kobo.28.1">The source code of this chapter is available </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">at </span></span><a href="https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap06"><span class="No-Break"><span class="koboSpan" id="kobo.30.1">https://github.com/PacktPublishing/Reactive-Patterns-with-RxJS-and-Angular-Signals-Second-Edition/tree/main/Chap06</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.31.1">.</span></span></p>
<h1 id="_idParaDest-95"><a id="_idTextAnchor100"/><span class="koboSpan" id="kobo.32.1">Defining the autosave requirement</span></h1>
<p><span class="koboSpan" id="kobo.33.1">As described </span><a id="_idIndexMarker223"/><span class="koboSpan" id="kobo.34.1">in the </span><em class="italic"><span class="koboSpan" id="kobo.35.1">View 2 – The New Recipe interface</span></em><span class="koboSpan" id="kobo.36.1"> section of </span><a href="B21180_02.xhtml#_idTextAnchor031"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.37.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.38.1">, </span><em class="italic"><span class="koboSpan" id="kobo.39.1">Walking through Our Application</span></em><span class="koboSpan" id="kobo.40.1">, the user can add a new recipe by clicking on the </span><strong class="bold"><span class="koboSpan" id="kobo.41.1">New Recipe</span></strong><span class="koboSpan" id="kobo.42.1"> menu item. </span><span class="koboSpan" id="kobo.42.2">This will display the following form to be </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">filled out:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer043">
<span class="koboSpan" id="kobo.44.1"><img alt="Figure 6.1 – The New Recipe form" src="image/B21180_06_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.45.1">Figure 6.1 – The New Recipe form</span></p>
<p><span class="koboSpan" id="kobo.46.1">The standalone component that’s responsible for displaying the </span><strong class="bold"><span class="koboSpan" id="kobo.47.1">New Recipe</span></strong><span class="koboSpan" id="kobo.48.1"> form is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.49.1">RecipeCreationComponent</span></strong><span class="koboSpan" id="kobo.50.1"> and is available </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">under </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.52.1">recipes-book-front\src\app\recipe-creation</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.54.1">Here, we want to implement the autosave behavior, which consists of storing the user’s changes in the form automatically. </span><span class="koboSpan" id="kobo.54.2">In this example, we will be storing the form changes in the backend so that the user can retrieve the last changes any time after a disconnection, a timeout, or other problems – this feature improves the user experience by preventing </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">data loss.</span></span></p>
<p><span class="koboSpan" id="kobo.56.1">Now that we understand the requirement, let’s look at the imperative way to implement the </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">autosave feature.</span></span></p>
<h1 id="_idParaDest-96"><a id="_idTextAnchor101"/><span class="koboSpan" id="kobo.58.1">Exploring the imperative pattern for the autosave feature</span></h1>
<p><span class="koboSpan" id="kobo.59.1">We </span><a id="_idIndexMarker224"/><span class="koboSpan" id="kobo.60.1">used Angular Reactive forms to build the </span><strong class="bold"><span class="koboSpan" id="kobo.61.1">New Recipe</span></strong><span class="koboSpan" id="kobo.62.1"> creation </span><a id="_idIndexMarker225"/><span class="koboSpan" id="kobo.63.1">form. </span><span class="koboSpan" id="kobo.63.2">As described in the </span><em class="italic"><span class="koboSpan" id="kobo.64.1">Using RxJS in Angular and its advantages</span></em><span class="koboSpan" id="kobo.65.1"> section of </span><a href="B21180_01.xhtml#_idTextAnchor016"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.66.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.67.1">, </span><em class="italic"><span class="koboSpan" id="kobo.68.1">Diving into the Reactive Paradigm</span></em><span class="koboSpan" id="kobo.69.1">, Reactive forms leverage RxJS by providing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">valueChanges</span></strong><span class="koboSpan" id="kobo.71.1"> Observable to track the </span><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">FormControl</span></strong><span class="koboSpan" id="kobo.73.1"> changes. </span><span class="koboSpan" id="kobo.73.2">This makes our implementation easier since we want to listen to the form’s value changes to perform a save on </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">every change.</span></span></p>
<p><span class="koboSpan" id="kobo.75.1">You can find the HTML code of the </span><strong class="bold"><span class="koboSpan" id="kobo.76.1">New Recipe</span></strong><span class="koboSpan" id="kobo.77.1"> creation form in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.78.1">recipe-creation.component.html</span></strong><span class="koboSpan" id="kobo.79.1"> file template. </span><span class="koboSpan" id="kobo.79.2">Then, in </span><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">recipe-creation.component.ts</span></strong><span class="koboSpan" id="kobo.81.1">, we can define the form </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.83.1">
export class RecipeCreationComponent implements OnInit {
  constructor(private formBuilder: FormBuilder) { }
  recipeForm = this.formBuilder.group&lt;Recipe&gt;({
    id: Math.floor(1000 + Math.random() * 9000),
    title: '',
    ingredients: '',
    tags: '',
    imageUrl: '',
    cookingTime: undefined,
    yield: 0,
    prepTime: undefined,
    steps: '',
  });
  tags = recipeTags.TAGS;</span></pre> <p><span class="koboSpan" id="kobo.84.1">Here, we used the Angular </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">FormBuilder</span></strong><span class="koboSpan" id="kobo.86.1"> API to build the reactive form and pass to it a JSON object where we define the different fields of the form. </span><span class="koboSpan" id="kobo.86.2">This JSON object represents our recipe’s data; we’re going to save this later. </span><span class="koboSpan" id="kobo.86.3">Every time we open the </span><strong class="bold"><span class="koboSpan" id="kobo.87.1">New Recipe</span></strong><span class="koboSpan" id="kobo.88.1"> form, a new empty object will </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">be created.</span></span></p>
<p><span class="koboSpan" id="kobo.90.1">Note that the first property of this JSON object, </span><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">id</span></strong><span class="koboSpan" id="kobo.92.1">, is not going to be displayed in the form. </span><span class="koboSpan" id="kobo.92.2">We only add it to initialize the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">Recipe</span></strong><span class="koboSpan" id="kobo.94.1"> object with a random identifier to save the recipe’s data properly in the backend. </span><span class="koboSpan" id="kobo.94.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.95.1">tags</span></strong><span class="koboSpan" id="kobo.96.1"> property is retrieved from a constant declared in </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">src/app/core/model/tags.ts</span></strong><span class="koboSpan" id="kobo.98.1"> that represents the static list of </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">available tags.</span></span></p>
<p><span class="koboSpan" id="kobo.100.1">Now that </span><a id="_idIndexMarker226"/><span class="koboSpan" id="kobo.101.1">we’ve prepared our form, let’s see how we can implement the autosave feature. </span><span class="koboSpan" id="kobo.101.2">The first thing that comes to mind </span><a id="_idIndexMarker227"/><span class="koboSpan" id="kobo.102.1">is subscribing to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">valueChanges</span></strong><span class="koboSpan" id="kobo.104.1"> Observable of </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">recipeForm</span></strong><span class="koboSpan" id="kobo.106.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">ngOninit()</span></strong><span class="koboSpan" id="kobo.108.1"> instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">RecipeCreationComponent</span></strong><span class="koboSpan" id="kobo.110.1">. </span><span class="koboSpan" id="kobo.110.2">Then, every time the </span><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">valueChanges</span></strong><span class="koboSpan" id="kobo.112.1"> Observable emits a new form value, we should raise a save request to save the most recent value of the form. </span><span class="koboSpan" id="kobo.112.2">We can do this </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.114.1">
ngOnInit(): void {
    this.recipeForm.valueChanges.subscribe(
      formValue =&gt; {
        this.service.saveRecipe(&lt;Recipe&gt;formValue);
      }
    );</span></pre> <p><span class="koboSpan" id="kobo.115.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">saveRecipe</span></strong><span class="koboSpan" id="kobo.117.1"> method is then defined and implemented in </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">RecipeService</span></strong><span class="koboSpan" id="kobo.119.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.121.1">
saveRecipe(formValue: Recipe) : Observable&lt;Recipe&gt;  {
  return this.http.post&lt;Recipe&gt;(`${BASE_PATH}/recipes`,
    formValue);
}</span></pre> <p><span class="koboSpan" id="kobo.122.1">Here, we </span><a id="_idIndexMarker228"/><span class="koboSpan" id="kobo.123.1">use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">HTTPClient</span></strong><span class="koboSpan" id="kobo.125.1"> API and call the save service in </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">the backend.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.127.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.128.1">Backend implementation is not the focus of this book. </span><span class="koboSpan" id="kobo.128.2">For that reason, we’ve provided a fake implementation of the POST save service in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">recipes-book-api</span></strong><span class="koboSpan" id="kobo.130.1"> project. </span><span class="koboSpan" id="kobo.130.2">Here, the goal is to simulate the call to an HTTP request to save </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">the data.</span></span></p>
<p><span class="koboSpan" id="kobo.132.1">So, to </span><a id="_idIndexMarker229"/><span class="koboSpan" id="kobo.133.1">recap, the code for </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">RecipeCreationComponent</span></strong><span class="koboSpan" id="kobo.135.1"> will look </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.137.1">
export class RecipeCreationComponent implements OnInit {
  constructor(private formBuilder: FormBuilder, private
  service: RecipesService) { }
  recipeForm = this.formBuilder.group&lt;Recipe&gt;({
    id: Math.floor(1000 + Math.random() * 9000),
    title: '',
    ingredients: '',
    tags: '',
    imageUrl: '',
    cookingTime: undefined,
    yield: 0,
    prepTime: undefined,
    steps: '',
  });
  tags = recipeTags.TAGS;
  ngOnInit(): void {
    this.recipeForm.valueChanges
      .subscribe(
        formValue =&gt; {
          this.service.saveRecipe(&lt;Recipe&gt;formValue);
        }
      );
  }
}</span></pre> <p><span class="koboSpan" id="kobo.138.1">However, this </span><a id="_idIndexMarker230"/><span class="koboSpan" id="kobo.139.1">code won’t work. </span><span class="koboSpan" id="kobo.139.2">You </span><a id="_idIndexMarker231"/><span class="koboSpan" id="kobo.140.1">should know by now that the result of </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">this.service.saveRecipe(&lt;Recipe&gt;formValue)</span></strong><span class="koboSpan" id="kobo.142.1">, which calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">this.http.post&lt;Recipe&gt;(`${BASE_PATH}/recipes`, formValue)</span></strong><span class="koboSpan" id="kobo.144.1">, is an Observable, and since Observables are lazy, we should subscribe to </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">this.service.saveRecipe(&lt;Recipe&gt;formValue)</span></strong><span class="koboSpan" id="kobo.146.1"> to initiate the HTTP POST request. </span><span class="koboSpan" id="kobo.146.2">So, let’s add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">subscribe</span></strong><span class="koboSpan" id="kobo.148.1"> value, </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.150.1">
ngOnInit(): void {
    this.recipeForm.valueChanges.subscribe(
      formValue =&gt; {
        this.service.saveRecipe(&lt;Recipe&gt;formValue)
          .subscribe(
            result =&gt; this.saveSuccess(result),
            errors =&gt; this.handleErrors(errors)
          );
      }
    );</span></pre> <p><span class="koboSpan" id="kobo.151.1">As you </span><a id="_idIndexMarker232"/><span class="koboSpan" id="kobo.152.1">may have noticed, we called a </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">subscribe</span></strong><span class="koboSpan" id="kobo.154.1"> value inside another </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">subscribe</span></strong><span class="koboSpan" id="kobo.156.1">, something we call a nested subscription. </span><span class="koboSpan" id="kobo.156.2">However, this is considered an anti-pattern in RxJS and is problematic for </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">several reasons:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.158.1">Every </span><a id="_idIndexMarker233"/><span class="koboSpan" id="kobo.159.1">time we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">subscribe()</span></strong><span class="koboSpan" id="kobo.161.1">, we open the door to imperative code. </span><span class="koboSpan" id="kobo.161.2">As we have learned throughout this book, we should avoid this as much </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">as possible.</span></span></li>
<li><span class="koboSpan" id="kobo.163.1">Nested subscriptions require careful cleanup; otherwise, we can run into various performance problems. </span><span class="koboSpan" id="kobo.163.2">In the previous example, we didn’t clean up the subscriptions, which means the possibility of serious timing issues arises. </span><span class="koboSpan" id="kobo.163.3">If multiple form values are emitted by </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">valueChanges</span></strong><span class="koboSpan" id="kobo.165.1"> successively, many save requests will be sent in parallel. </span><span class="koboSpan" id="kobo.165.2">If the requests take some time to complete, there is no guarantee that the backend will process the save requests in order. </span><span class="koboSpan" id="kobo.165.3">For instance, we cannot ensure that the last valid form value is the one that’s been saved in the backend. </span><span class="koboSpan" id="kobo.165.4">Consequently, we will end up with </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">data incoherence.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.167.1">What we want to do is perform a save request after the previous one is completed. </span><span class="koboSpan" id="kobo.167.2">Luckily, RxJS includes some interesting operators that fix this for us. </span><span class="koboSpan" id="kobo.167.3">So, without further ado, in the following section, we’ll learn how to implement this in a reactive and </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">declarative way.</span></span></p>
<h1 id="_idParaDest-97"><a id="_idTextAnchor102"/><span class="koboSpan" id="kobo.169.1">Exploring the reactive pattern for the autosave feature</span></h1>
<p><span class="koboSpan" id="kobo.170.1">You </span><a id="_idIndexMarker234"/><span class="koboSpan" id="kobo.171.1">remember the golden rule from </span><a href="B21180_05.xhtml#_idTextAnchor083"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.172.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.173.1">, right? </span><span class="koboSpan" id="kobo.173.2">We should think of everything as a stream. </span><span class="koboSpan" id="kobo.173.3">So, let’s start by identifying </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">our streams.</span></span></p>
<p><span class="koboSpan" id="kobo.175.1">Here, we can </span><a id="_idIndexMarker235"/><span class="koboSpan" id="kobo.176.1">think of the save operation as a stream – it is the result of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">this.service.saveRecipe(&lt;Recipe&gt;formValue)</span></strong><span class="koboSpan" id="kobo.178.1"> method, which calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">this.http.post&lt;Recipe&gt;(`${BASE_PATH}/recipes`, formValue</span></strong><span class="koboSpan" id="kobo.180.1">. </span><span class="koboSpan" id="kobo.180.2">We will call </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">it </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">saveRecipe$</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.184.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">saveRecipe$</span></strong><span class="koboSpan" id="kobo.186.1"> Observable is responsible for saving the data in the backend and will initiate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">http</span></strong><span class="koboSpan" id="kobo.188.1"> request when </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">subscribed to.</span></span></p>
<p><span class="koboSpan" id="kobo.190.1">To avoid nesting subscriptions, what we can do in this situation is map or transform the form value emitted by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">valueChanges</span></strong><span class="koboSpan" id="kobo.192.1"> Observable to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">saveRecipe$</span></strong><span class="koboSpan" id="kobo.194.1"> Observable. </span><span class="koboSpan" id="kobo.194.2">The result is what we call a </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">higher-order Observable.</span></span></p>
<p><span class="koboSpan" id="kobo.196.1">Not clear? </span><span class="koboSpan" id="kobo.196.2">Don’t worry – we will explain this in detail in the </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">next section.</span></span></p>
<h2 id="_idParaDest-98"><a id="_idTextAnchor103"/><span class="koboSpan" id="kobo.198.1">Higher-order Observables</span></h2>
<p><span class="koboSpan" id="kobo.199.1">So, what is </span><a id="_idIndexMarker236"/><span class="koboSpan" id="kobo.200.1">a higher-order Observable? </span><span class="koboSpan" id="kobo.200.2">A </span><strong class="bold"><span class="koboSpan" id="kobo.201.1">higher-order Observable</span></strong><span class="koboSpan" id="kobo.202.1"> is just an Observable like any other, but its values are Observables as well. </span><span class="koboSpan" id="kobo.202.2">So, instead of emitting simple values such as strings, numbers, or arrays, it emits Observables that you can subscribe </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">to separately.</span></span></p>
<p><span class="koboSpan" id="kobo.204.1">Okay, but </span><a id="_idIndexMarker237"/><span class="koboSpan" id="kobo.205.1">when is it useful? </span><span class="koboSpan" id="kobo.205.2">You can create a higher-order Observable whenever you use data emitted from one Observable to emit another Observable. </span><span class="koboSpan" id="kobo.205.3">In our case, for every emitted form value from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">valueChanges</span></strong><span class="koboSpan" id="kobo.207.1"> Observable, we want to emit the </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">saveRecipe$</span></strong><span class="koboSpan" id="kobo.209.1"> Observable. </span><span class="koboSpan" id="kobo.209.2">In other words, we want to transform (or map) the form value to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">saveRecipe$</span></strong><span class="koboSpan" id="kobo.211.1"> Observable. </span><span class="koboSpan" id="kobo.211.2">This would create a higher-order Observable where each value represents a </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">save request.</span></span></p>
<p><span class="koboSpan" id="kobo.213.1">In this situation, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">valueChanges</span></strong><span class="koboSpan" id="kobo.215.1"> Observable is called </span><a id="_idIndexMarker238"/><span class="koboSpan" id="kobo.216.1">the outer </span><a id="_idIndexMarker239"/><span class="koboSpan" id="kobo.217.1">Observable, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">saveRecipe$</span></strong><span class="koboSpan" id="kobo.219.1"> is called the inner Observable. </span><span class="koboSpan" id="kobo.219.2">Under the hood, we want to subscribe to each </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">saveRecipe$</span></strong><span class="koboSpan" id="kobo.221.1"> Observable that’s emitted and receive the response all in one go to avoid </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">nested treatments.</span></span></p>
<p><span class="koboSpan" id="kobo.223.1">Now that we’ve learned what higher-order Observables are and when to use them, let’s look at higher-order </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">map</span><a id="_idTextAnchor104"/><span class="koboSpan" id="kobo.225.1">ping operators.</span></span></p>
<h2 id="_idParaDest-99"><a id="_idTextAnchor105"/><span class="koboSpan" id="kobo.226.1">Higher-order mapping operators</span></h2>
<p><span class="koboSpan" id="kobo.227.1">To transform</span><a id="_idIndexMarker240"/><span class="koboSpan" id="kobo.228.1"> the outer Observable, we should use higher-order mapping operators. </span><span class="koboSpan" id="kobo.228.2">The role of these operators is to map each value from an </span><a id="_idIndexMarker241"/><span class="koboSpan" id="kobo.229.1">outer Observable to a new inner Observable and automatically subscribe and unsubscribe to/from that </span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">inner Observable.</span></span></p>
<p><span class="koboSpan" id="kobo.231.1">But what is the difference between regular mapping and </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">higher-order mapping?</span></span></p>
<p><span class="koboSpan" id="kobo.233.1">Well, regular mapping involves mapping one value to another value. </span><span class="koboSpan" id="kobo.233.2">One of the most used basic mapping operators is the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">map</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.235.1"> operator:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer044">
<span class="koboSpan" id="kobo.236.1"><img alt="Figure 6.2 – The map operator – marble diagram" src="image/B21180_06_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.237.1">Figure 6.2 – The map operator – marble diagram</span></p>
<p><span class="koboSpan" id="kobo.238.1">As described in this marble diagram, the map operator will transform the values of the input stream by multiplying each emitted value by 10. </span><span class="koboSpan" id="kobo.238.2">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">x=&gt;10*x</span></strong><span class="koboSpan" id="kobo.240.1"> is the </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">transformation function.</span></span></p>
<p><span class="koboSpan" id="kobo.242.1">On the other hand, higher-order mapping is about mapping one value into </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">an Observable.</span></span></p>
<p><span class="koboSpan" id="kobo.244.1">RxJS provides several higher-order mapping operators. </span><span class="koboSpan" id="kobo.244.2">In the next section, we will learn about the </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">concatMap()</span></strong><span class="koboSpan" id="kobo.246.1"> operator – which we will use to implement the autosave behavior – before discovering some other commonly </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">used operators.</span></span></p>
<h3><span class="koboSpan" id="kobo.248.1">The concatMap operator</span></h3>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">concatMap</span></strong><span class="koboSpan" id="kobo.250.1"> is a </span><a id="_idIndexMarker242"/><span class="koboSpan" id="kobo.251.1">combination of </span><a id="_idIndexMarker243"/><span class="koboSpan" id="kobo.252.1">the concatenation strategy and </span><span class="No-Break"><span class="koboSpan" id="kobo.253.1">higher-order mapping:</span></span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.254.1">concatMap = concat (concatenation) + map (</span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.255.1">higher-order mapping)</span></em></span></p>
<p><span class="koboSpan" id="kobo.256.1">We looked at the concepts of regular and higher-order mapping in the previous section, so let’s look at the following marble diagram to understand the concatenation strategy, taking the example of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">concat</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.258.1"> operator:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer045">
<span class="koboSpan" id="kobo.259.1"><img alt="Figure 6.3 – The concat operator – marble diagram" src="image/B21180_06_3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.260.1">Figure 6.3 – The concat operator – marble diagram</span></p>
<p><span class="koboSpan" id="kobo.261.1">Let’s break down the </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">marble diagram:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.263.1">The first line represents the timeline of the first Observable passed as input to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">concat</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.265.1"> operator.</span></span></li>
<li><span class="koboSpan" id="kobo.266.1">The second line represents the timeline of the second Observable passed as input to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">concat</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.268.1"> operator.</span></span></li>
<li><span class="koboSpan" id="kobo.269.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">concat</span></strong><span class="koboSpan" id="kobo.271.1"> operator in this example has two inputs. </span><span class="koboSpan" id="kobo.271.2">It will subscribe to the first Observable but not to the second one. </span><span class="koboSpan" id="kobo.271.3">The first Observable will emit the values </span><strong class="bold"><span class="koboSpan" id="kobo.272.1">a</span></strong><span class="koboSpan" id="kobo.273.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.274.1">b</span></strong><span class="koboSpan" id="kobo.275.1">, which get reflected in the result Observable (the </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">last line).</span></span></li>
<li><span class="koboSpan" id="kobo.277.1">Then, the first Observable completes, and at that moment, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">concat</span></strong><span class="koboSpan" id="kobo.279.1"> operator subscribes to the second Observable. </span><span class="koboSpan" id="kobo.279.2">This is how a sequential process </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">is guaranteed.</span></span></li>
<li><span class="koboSpan" id="kobo.281.1">The second Observable will emit the values </span><strong class="bold"><span class="koboSpan" id="kobo.282.1">x</span></strong><span class="koboSpan" id="kobo.283.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.284.1">y</span></strong><span class="koboSpan" id="kobo.285.1">, which get reflected in the </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">result Observable.</span></span></li>
<li><span class="koboSpan" id="kobo.287.1">When the second Observable completes, the output Observable will </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">also complete.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.289.1">As you </span><a id="_idIndexMarker244"/><span class="koboSpan" id="kobo.290.1">may have noticed, Observable concatenation is all about Observable completion. </span><span class="koboSpan" id="kobo.290.2">This is the key point. </span><span class="koboSpan" id="kobo.290.3">It emits the values of</span><a id="_idIndexMarker245"/><span class="koboSpan" id="kobo.291.1"> the first Observable, waits for it to complete, and then emits the values of the next Observable, and so on, until all the </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">Observables complete.</span></span></p>
<p><span class="koboSpan" id="kobo.293.1">Now that we understand the concatenation strategy, we can understand how the </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">concatMap</span></strong><span class="koboSpan" id="kobo.295.1"> operator is a mixture of higher-order mapping and Observable concatenation: it waits for each inner Observable to complete before processing the next one. </span><span class="koboSpan" id="kobo.295.2">It’s like a line at a ticket counter, where each customer (Observable) waits for their turn to be served before the next one </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">is called.</span></span></p>
<h4><span class="koboSpan" id="kobo.297.1">Using concatMap for autosaving</span></h4>
<p><span class="koboSpan" id="kobo.298.1">Based </span><a id="_idIndexMarker246"/><span class="koboSpan" id="kobo.299.1">on the previous discussion, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">concatMap</span></strong><span class="koboSpan" id="kobo.301.1"> operator fits very well with our autosave requirement for the </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">following reasons:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.303.1">We want to take the form value and turn it into a </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">saveRecipe$</span></strong><span class="koboSpan" id="kobo.305.1"> Observable and automatically subscribe and unsubscribe from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">saveRecipe$</span></strong><span class="koboSpan" id="kobo.307.1"> inner Observable – this is what a higher-order mapping </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">operation does.</span></span></li>
<li><span class="koboSpan" id="kobo.309.1">We only want to perform a save request after the previous one is completed. </span><span class="koboSpan" id="kobo.309.2">When one HTTP save request is in progress, the other requests that come in the meantime should wait for its completion before being called to ensure sequentiality. </span><span class="koboSpan" id="kobo.309.3">So, we need to concatenate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">saveRecipe$</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.311.1">Observables together.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.312.1">This is what our code will </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">look like:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.314.1">
  valueChanges$ = this.recipeForm.valueChanges.pipe(
    concatMap(formValue =&gt;
      this.service.saveRecipe(&lt;Recipe&gt;formValue)),
    catchError(errors =&gt; of(errors)),
    tap(result =&gt; this.saveSuccess(result))
  );</span></pre> <p><span class="koboSpan" id="kobo.315.1">Let’s </span><a id="_idIndexMarker247"/><span class="koboSpan" id="kobo.316.1">break down what’s </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">going on:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.318.1">Here, the outer Observable, </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">this.recipeForm.valueChanges</span></strong><span class="koboSpan" id="kobo.320.1">, emits form values. </span><span class="koboSpan" id="kobo.320.2">For each emitted form value, </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">concatMap</span></strong><span class="koboSpan" id="kobo.322.1"> transforms it into </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">this.service.saveRecipe(&lt;Recipe&gt;formValue)</span></strong><span class="koboSpan" id="kobo.324.1">, which is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">saveRecipe$</span></strong><span class="koboSpan" id="kobo.326.1"> Observable – our </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">inner Observable.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">concatMap</span></strong><span class="koboSpan" id="kobo.329.1"> automatically subscribes to the inner Observable and the HTTP POST request will </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">be issued.</span></span></li>
<li><span class="koboSpan" id="kobo.331.1">Another form value might come faster than the time it takes to save the previous form value in the backend. </span><span class="koboSpan" id="kobo.331.2">In this case, the form value will not be mapped to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">saveRecipe$</span></strong><span class="koboSpan" id="kobo.333.1"> Observable. </span><span class="koboSpan" id="kobo.333.2">Instead, </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">concatMap</span></strong><span class="koboSpan" id="kobo.335.1"> will wait for the previous save request to return a response and complete it before transforming the new form value to </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">saveRecipe$</span></strong><span class="koboSpan" id="kobo.337.1">, subscribing to it, and sending a new save request. </span><span class="koboSpan" id="kobo.337.2">When all inner Observables complete, the result </span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">stream completes.</span></span></li>
<li><span class="koboSpan" id="kobo.339.1">Then, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">catchError</span></strong><span class="koboSpan" id="kobo.341.1"> operator to handle the errors and register a side effect with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">tap</span></strong><span class="koboSpan" id="kobo.343.1"> operator to log the </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">Saved successfully</span></strong><span class="koboSpan" id="kobo.345.1"> message in the backend. </span><span class="koboSpan" id="kobo.345.2">You can customize this, of course, and display a message to the </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">end user.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.347.1">To recap, the </span><a id="_idIndexMarker248"/><span class="koboSpan" id="kobo.348.1">complete code for </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">RecipeCreationComponent</span></strong><span class="koboSpan" id="kobo.350.1"> will now look </span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.352.1">
export class RecipeCreationComponent {
  constructor(private formBuilder: FormBuilder, private
  service: RecipesService) { }
  recipeForm = this.formBuilder.group&lt;Recipe&gt;({
    id: Math.floor(1000 + Math.random() * 9000),
    title: '',
    ingredients: '',
    tags: '',
    imageUrl: '',
    cookingTime: undefined,
    yield: 0,
    prepTime: undefined,
    steps: '',
  });
  tags = recipeTags.TAGS;
  valueChanges$ = this.recipeForm.valueChanges.pipe(
    concatMap(formValue =&gt;
      this.service.saveRecipe(&lt;Recipe&gt;formValue)),
    catchError(errors =&gt; of(errors)),
    tap(result =&gt; this.saveSuccess(result))
  );
  saveSuccess(_result: Recipe) {
    console.log('Saved successfully');
  }
}</span></pre> <p><span class="koboSpan" id="kobo.353.1">Now, there’s </span><a id="_idIndexMarker249"/><span class="koboSpan" id="kobo.354.1">just one thing left to do: we should subscribe to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">valueChanges$</span></strong><span class="koboSpan" id="kobo.356.1"> Observable to make all of this work. </span><span class="koboSpan" id="kobo.356.2">As usual, we will do this through the async pipe in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">RecipeCreationComponent</span></strong><span class="koboSpan" id="kobo.358.1"> HTML template, </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.360.1">
&lt;ng-container *ngIf="valueChanges$ | async"&gt;
  &lt;/ng-container&gt;
/** All the form code here**/</span></pre> <p><span class="koboSpan" id="kobo.361.1">With that, the reactive implementation </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">is complete.</span></span></p>
<p><span class="koboSpan" id="kobo.363.1">As you may have noticed, the first benefit of using </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">concatMap</span></strong><span class="koboSpan" id="kobo.365.1"> is that we no longer have nested subscriptions. </span><span class="koboSpan" id="kobo.365.2">We also get rid of explicit subscriptions thanks to the async pipe. </span><span class="koboSpan" id="kobo.365.3">Besides this, all form values are going to be sent to the </span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">backend sequentially.</span></span></p>
<p><span class="koboSpan" id="kobo.367.1">When a delay is introduced in the backend save service (which I’ve set up by default in the provided implementation of the save recipe service), you’ll notice that requests aren’t initiated while another one is still processing. </span><span class="koboSpan" id="kobo.367.2">Instead, they wait until the current request finishes before being triggered. </span><span class="koboSpan" id="kobo.367.3">This is exactly what </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">concatMap</span></strong><span class="koboSpan" id="kobo.369.1"> aims </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">to achieve.</span></span></p>
<p><span class="koboSpan" id="kobo.371.1">Now, let’s take a look at the behavior </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">concatMap</span></strong><span class="koboSpan" id="kobo.373.1"> manifests in the Chrome DevTools </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.374.1">Network</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.375.1"> tab:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer046">
<span class="koboSpan" id="kobo.376.1"><img alt="Figure 6.4 – The concatMap network requests" src="image/B21180_06_4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.377.1">Figure 6.4 – The concatMap network requests</span></p>
<p><span class="koboSpan" id="kobo.378.1">Here, upon typing a character, a POST save request is sent to the server. </span><span class="koboSpan" id="kobo.378.2">When trying to input other characters before the initial request, a response is received. </span><span class="koboSpan" id="kobo.378.3">You’ll notice that requests are not immediately triggered; they are queued and executed sequentially once the preceding request </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">is completed.</span></span></p>
<p><span class="koboSpan" id="kobo.380.1">Our example </span><a id="_idIndexMarker250"/><span class="koboSpan" id="kobo.381.1">served as a straightforward illustration of how the </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">concatMap</span></strong><span class="koboSpan" id="kobo.383.1"> operator works. </span><span class="koboSpan" id="kobo.383.2">However, we could optimize our implementation more to avoid sending requests for every character introduced by the user. </span><span class="koboSpan" id="kobo.383.3">To do so, we could use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">debounceTime(waitingTime)</span></strong><span class="koboSpan" id="kobo.385.1"> operator to wait for the user input to stabilize before sending the requests. </span><span class="koboSpan" id="kobo.385.2">We could also optimize it further by ignoring duplicates and making the </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">distinctUntilChanged()</span></strong><span class="koboSpan" id="kobo.387.1"> operator handle </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">invalid values.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.389.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.390.1">For more </span><a id="_idIndexMarker251"/><span class="koboSpan" id="kobo.391.1">details </span><a id="_idIndexMarker252"/><span class="koboSpan" id="kobo.392.1">about the </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">debounceTime</span></strong><span class="koboSpan" id="kobo.394.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">distinctUntilChanged</span></strong><span class="koboSpan" id="kobo.396.1"> operators, refer to </span><a href="https://rxjs.dev/api/operators/debounceTime"><span class="koboSpan" id="kobo.397.1">https://rxjs.dev/api/operators/debounceTime</span></a><span class="koboSpan" id="kobo.398.1"> and </span><a href="https://rxjs.dev/api/operators/distinctUntilChanged"><span class="No-Break"><span class="koboSpan" id="kobo.399.1">https://rxjs.dev/api/operators/distinctUntilChanged</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.400.1">, respectively.</span></span></p>
<h4><span class="koboSpan" id="kobo.401.1">Using concatMap for pagination</span></h4>
<p><span class="koboSpan" id="kobo.402.1">Besides autosaving, we can also use </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">concatMap</span></strong><span class="koboSpan" id="kobo.404.1"> for list pagination. </span><span class="koboSpan" id="kobo.404.2">In our recipe app, we handle </span><a id="_idIndexMarker253"/><span class="koboSpan" id="kobo.405.1">the Recipes list pagination on the client side – we retrieve all the recipes when loading </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">RecipesListComponent</span></strong><span class="koboSpan" id="kobo.407.1"> by making a </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">GET</span></strong><span class="koboSpan" id="kobo.409.1"> request to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">/api/recipes</span></strong><span class="koboSpan" id="kobo.411.1"> service, as explained in </span><a href="B21180_03.xhtml#_idTextAnchor047"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.412.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.413.1">, </span><em class="italic"><span class="koboSpan" id="kobo.414.1">Fetching Data </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.415.1">as Streams</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.417.1">However, if we were handling a lazy loading mechanism, where we fetch just a few items (let’s say 10) when the component loads initially, and then load more items as needed when the user clicks the </span><strong class="bold"><span class="koboSpan" id="kobo.418.1">Next</span></strong><span class="koboSpan" id="kobo.419.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.420.1">Previous</span></strong><span class="koboSpan" id="kobo.421.1"> buttons, as shown in the following screenshot, we’d need to adjust </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">our logic:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer047">
<span class="koboSpan" id="kobo.423.1"><img alt="Figure 6.5 – Recipes list pagination" src="image/B21180_06_5.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.424.1">Figure 6.5 – Recipes list pagination</span></p>
<p><span class="koboSpan" id="kobo.425.1">This would involve sending a </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">GET</span></strong><span class="koboSpan" id="kobo.427.1"> HTTP request to fetch the data for the next page, using a URL structure such as </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">GET /api/recipes?page=1&amp;limit=10</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.430.1">In such a scenario, </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">concatMap</span></strong><span class="koboSpan" id="kobo.432.1"> is a very good option to issue a request for each emitted “next page” event, </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.434.1">
recipes$ = this.pageNumberChange$.pipe(
    concatMap((pageNumber) =&gt;
      this.http.get&lt;Recipe[]&gt;(`${BASE_PATH}/recipes`, {
        params: {
          page: pageNumber,
          limit: 10,
        },
      })
    )
  );</span></pre> <p><span class="koboSpan" id="kobo.435.1">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">pageNumberChange$</span></strong><span class="koboSpan" id="kobo.437.1"> is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.439.1"> subject that emits the current page number whenever the user clicks on the </span><strong class="bold"><span class="koboSpan" id="kobo.440.1">Next</span></strong><span class="koboSpan" id="kobo.441.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.442.1">Previous</span></strong><span class="koboSpan" id="kobo.443.1"> buttons. </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">concatMap</span></strong><span class="koboSpan" id="kobo.445.1"> then triggers subsequent HTTP GET requests, sequentially fetching the next page’s list based on the current page number and size limit parameters. </span><span class="koboSpan" id="kobo.445.2">This sequential handling ensures data </span><a id="_idIndexMarker254"/><span class="koboSpan" id="kobo.446.1">integrity and systematic </span><span class="No-Break"><span class="koboSpan" id="kobo.447.1">pagination flow.</span></span></p>
<p><span class="koboSpan" id="kobo.448.1">To summarize, </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">concatMap</span></strong><span class="koboSpan" id="kobo.450.1"> is the ideal choice when you want to ensure that operations are processed sequentially, and that each inner Observable is processed </span><em class="italic"><span class="koboSpan" id="kobo.451.1">one at a time and in order</span></em><span class="koboSpan" id="kobo.452.1">. </span><span class="koboSpan" id="kobo.452.2">However, when using </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">concatMap</span></strong><span class="koboSpan" id="kobo.454.1">, it’s important to ensure that the inner Observable completes since </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">concatMap</span></strong><span class="koboSpan" id="kobo.456.1"> waits for the completion of each inner Observable before subscribing to the next one in the sequence. </span><span class="koboSpan" id="kobo.456.2">If an inner Observable never completes, </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">concatMap</span></strong><span class="koboSpan" id="kobo.458.1"> will also never subscribe to the subsequent Observables in the sequence. </span><span class="koboSpan" id="kobo.458.2">This can lead to blocking subsequent emissions and potential memory leaks or performance issues if there is a buildup of pending Observables. </span><span class="koboSpan" id="kobo.458.3">So, never use </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">concatMap</span></strong><span class="koboSpan" id="kobo.460.1"> for </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">endless streams.</span></span></p>
<p><span class="koboSpan" id="kobo.462.1">It’s important to note that not all higher-order mapping operators follow the </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">concat</span></strong><span class="koboSpan" id="kobo.464.1"> strategy. </span><span class="koboSpan" id="kobo.464.2">There are other higher-order mapping operators, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">switch</span></strong><span class="koboSpan" id="kobo.466.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">merge</span></strong><span class="koboSpan" id="kobo.468.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">exhaust</span></strong><span class="koboSpan" id="kobo.470.1">, that offer different strategies and are useful in many situations. </span><span class="koboSpan" id="kobo.470.2">We’ll break down those operators and their respective strategies in the </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">following sections.</span></span></p>
<h3><span class="koboSpan" id="kobo.472.1">The switchMap operator</span></h3>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">switchMap</span></strong><span class="koboSpan" id="kobo.474.1"> is a </span><a id="_idIndexMarker255"/><span class="koboSpan" id="kobo.475.1">combination </span><a id="_idIndexMarker256"/><span class="koboSpan" id="kobo.476.1">of the switch and transformation (or </span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">mapping) strategies:</span></span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.478.1">switchMap = switch(switch) + map (</span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.479.1">higher-order mapping)</span></em></span></p>
<p><span class="koboSpan" id="kobo.480.1">Let’s look at the marble diagram of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">switch</span></strong><span class="koboSpan" id="kobo.482.1"> operator to understand the </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">switch strategy:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer048">
<span class="koboSpan" id="kobo.484.1"><img alt="Figure 6.6 – The switch operator – marble diagram" src="image/B21180_06_6.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.485.1">Figure 6.6 – The switch operator – marble diagram</span></p>
<p><span class="koboSpan" id="kobo.486.1">Let’s </span><a id="_idIndexMarker257"/><span class="koboSpan" id="kobo.487.1">break down what’s happening</span><a id="_idIndexMarker258"/><span class="koboSpan" id="kobo.488.1"> here (you are not used to seeing those diagonal lines, </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">I know!):</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.490.1">The top line is the higher-order Observable. </span><span class="koboSpan" id="kobo.490.2">The higher-order Observable emits the first inner Observable (which has the values </span><strong class="bold"><span class="koboSpan" id="kobo.491.1">a</span></strong><span class="koboSpan" id="kobo.492.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.493.1">b</span></strong><span class="koboSpan" id="kobo.494.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.495.1">c</span></strong><span class="koboSpan" id="kobo.496.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.497.1">d</span></strong><span class="koboSpan" id="kobo.498.1">). </span><span class="koboSpan" id="kobo.498.2">The switch operator subscribes to it under </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">the hood.</span></span></li>
<li><span class="koboSpan" id="kobo.500.1">The first inner Observable emits the values </span><strong class="bold"><span class="koboSpan" id="kobo.501.1">a</span></strong><span class="koboSpan" id="kobo.502.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.503.1">b</span></strong><span class="koboSpan" id="kobo.504.1">, and they get reflected automatically to the </span><span class="No-Break"><span class="koboSpan" id="kobo.505.1">resulting Observable.</span></span></li>
<li><span class="koboSpan" id="kobo.506.1">Then, the higher-order Observable emits the second inner Observable (which has the values </span><strong class="bold"><span class="koboSpan" id="kobo.507.1">e</span></strong><span class="koboSpan" id="kobo.508.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.509.1">f</span></strong><span class="koboSpan" id="kobo.510.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">and </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.512.1">g</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">).</span></span></li>
<li><span class="koboSpan" id="kobo.514.1">The switch will unsubscribe from the first inner Observable (</span><strong class="bold"><span class="koboSpan" id="kobo.515.1">a</span></strong><span class="koboSpan" id="kobo.516.1">-</span><strong class="bold"><span class="koboSpan" id="kobo.517.1">b</span></strong><span class="koboSpan" id="kobo.518.1">-</span><strong class="bold"><span class="koboSpan" id="kobo.519.1">c</span></strong><span class="koboSpan" id="kobo.520.1">-</span><strong class="bold"><span class="koboSpan" id="kobo.521.1">d</span></strong><span class="koboSpan" id="kobo.522.1">) and subscribe to the second inner Observable (</span><strong class="bold"><span class="koboSpan" id="kobo.523.1">e</span></strong><span class="koboSpan" id="kobo.524.1">-</span><strong class="bold"><span class="koboSpan" id="kobo.525.1">f</span></strong><span class="koboSpan" id="kobo.526.1">-</span><strong class="bold"><span class="koboSpan" id="kobo.527.1">g</span></strong><span class="koboSpan" id="kobo.528.1">); that’s why the values </span><strong class="bold"><span class="koboSpan" id="kobo.529.1">e</span></strong><span class="koboSpan" id="kobo.530.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.531.1">f</span></strong><span class="koboSpan" id="kobo.532.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.533.1">g</span></strong><span class="koboSpan" id="kobo.534.1"> get reflected right after </span><strong class="bold"><span class="koboSpan" id="kobo.535.1">a</span></strong><span class="koboSpan" id="kobo.536.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.537.1">b</span></strong><span class="koboSpan" id="kobo.538.1">. </span><span class="koboSpan" id="kobo.538.2">As you may have noticed, in switching, if a new Observable starts emitting values, then the switch will subscribe to the new Observable and unsubscribe from the </span><span class="No-Break"><span class="koboSpan" id="kobo.539.1">previous one.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.540.1">So, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">switchMap</span></strong><span class="koboSpan" id="kobo.542.1"> operator is a higher-order mapping operator that unsubscribes from </span><a id="_idIndexMarker259"/><span class="koboSpan" id="kobo.543.1">any prior inner Observable and switches</span><a id="_idIndexMarker260"/><span class="koboSpan" id="kobo.544.1"> to any new inner Observable. </span><span class="koboSpan" id="kobo.544.2">It is useful when you want to cancel an operation when a new one is triggered. </span><span class="koboSpan" id="kobo.544.3">In other words, </span><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">switchMap</span></strong><span class="koboSpan" id="kobo.546.1"> only focuses on the most recent data, ensuring that only the latest updates are processed while canceling any ongoing operations triggered by </span><span class="No-Break"><span class="koboSpan" id="kobo.547.1">previous data.</span></span></p>
<p><span class="koboSpan" id="kobo.548.1">Think of </span><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">switchMap</span></strong><span class="koboSpan" id="kobo.550.1"> as changing TV channels: each time you press a button, you switch to a different channel, ignoring whatever was playing before. </span><span class="koboSpan" id="kobo.550.2">Similarly, </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">switchMap</span></strong><span class="koboSpan" id="kobo.552.1"> lets you dynamically switch to a new Observable stream whenever the source emits, discarding any ongoing processing from </span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">previous emissions.</span></span></p>
<h4><span class="koboSpan" id="kobo.554.1">Using switchMap for autosaving</span></h4>
<p><span class="koboSpan" id="kobo.555.1">Going back </span><a id="_idIndexMarker261"/><span class="koboSpan" id="kobo.556.1">to our autosave reactive implementation in the Recipe app, if you’re interested in saving the most recent form value and want to cancel any ongoing save operation if a new one is initiated before the current one finishes, then </span><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">switchMap</span></strong><span class="koboSpan" id="kobo.558.1"> is the operator to use (instead </span><span class="No-Break"><span class="koboSpan" id="kobo.559.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">concatMap</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.561.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.562.1">
valueChanges$ = this.recipeForm.valueChanges.pipe(
    switchMap(formValue =&gt;
      this.service.saveRecipe(&lt;Recipe&gt;formValue)),
    catchError(errors =&gt; of(errors)),
    tap(result =&gt; this.saveSuccess(result))
  );</span></pre> <p><span class="koboSpan" id="kobo.563.1">As mentioned previously, I introduced a slight delay in the backend save service to illustrate how ongoing requests are handled when subsequent requests are made concurrently. </span><span class="koboSpan" id="kobo.563.2">So, when inspecting the network console, you’ll notice </span><span class="No-Break"><span class="koboSpan" id="kobo.564.1">the following:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer049">
<span class="koboSpan" id="kobo.565.1"><img alt="Figure 6.7 – The switchMap network requests" src="image/B21180_06_7.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.566.1">Figure 6.7 – The switchMap network requests</span></p>
<p><span class="koboSpan" id="kobo.567.1">Here, we have two requests: one is marked as </span><strong class="bold"><span class="koboSpan" id="kobo.568.1">canceled</span></strong><span class="koboSpan" id="kobo.569.1">, while the other is </span><strong class="bold"><span class="koboSpan" id="kobo.570.1">pending</span></strong><span class="koboSpan" id="kobo.571.1">. </span><span class="koboSpan" id="kobo.571.2">The pending request is the most recent one, indicating that it was initiated while the previous </span><a id="_idIndexMarker262"/><span class="koboSpan" id="kobo.572.1">request was still in progress, resulting in the cancellation of the prior request. </span><span class="koboSpan" id="kobo.572.2">And this is the behavior we </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">aim for.</span></span></p>
<p><span class="koboSpan" id="kobo.574.1">In this example, we’re making an HTTP POST request, but we’re only interested in the success or failure status and don’t need any other data from the response. </span><span class="koboSpan" id="kobo.574.2">However, if you’re expecting a response from the POST request to update the UI or perform tasks, keep in mind that </span><em class="italic"><span class="koboSpan" id="kobo.575.1">only the response from the latest request will be propagated</span></em><span class="koboSpan" id="kobo.576.1">. </span><span class="koboSpan" id="kobo.576.2">In such cases, it’s better to use </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.577.1">concatMap</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.578.1"> instead.</span></span></p>
<h4><span class="koboSpan" id="kobo.579.1">Using switchMap for autocompletion</span></h4>
<p><span class="koboSpan" id="kobo.580.1">Now, let’s explore another practical scenario of using </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">switchMap</span></strong><span class="koboSpan" id="kobo.582.1">: autocompleting suggestions. </span><span class="koboSpan" id="kobo.582.2">This is a very common feature in web applications. </span><span class="koboSpan" id="kobo.582.3">In our recipe app, we’ll implement </span><a id="_idIndexMarker263"/><span class="koboSpan" id="kobo.583.1">an autocomplete dropdown for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.584.1">tags</span></strong><span class="koboSpan" id="kobo.585.1"> field in </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">RecipeCreationComponent</span></strong><span class="koboSpan" id="kobo.587.1">. </span><span class="koboSpan" id="kobo.587.2">Currently, this field is displayed as a radio button with static values retrieved from the constant tags defined in </span><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">src/app/core/model/tags.ts</span></strong><span class="koboSpan" id="kobo.589.1">. </span><span class="koboSpan" id="kobo.589.2">However, we’ll transform it into a user-friendly autocomplete dropdown that dynamically fetches tag suggestions based on the </span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">user’s input.</span></span></p>
<p><span class="koboSpan" id="kobo.591.1">Whenever a user types a query, we’ll retrieve the corresponding tags from a backend service. </span><span class="koboSpan" id="kobo.591.2">We have already implemented a service for that in our ready-to-use backend – that is, </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">recipes-book-api</span></strong><span class="koboSpan" id="kobo.593.1">. </span><span class="koboSpan" id="kobo.593.2">This service has an endpoint called </span><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">/api/tags</span></strong><span class="koboSpan" id="kobo.595.1">, accepts some criteria (the user’s typed input) as a query parameter, and returns a list of tags that match the provided criteria. </span><span class="koboSpan" id="kobo.595.2">The code is available in this book’s </span><span class="No-Break"><span class="koboSpan" id="kobo.596.1">GitHub repository.</span></span></p>
<p><span class="koboSpan" id="kobo.597.1">Let’s delve into the implementation details. </span><span class="koboSpan" id="kobo.597.2">First and foremost, let’s prepare our streams. </span><span class="koboSpan" id="kobo.597.3">How many streams do we have? </span><span class="koboSpan" id="kobo.597.4">We </span><span class="No-Break"><span class="koboSpan" id="kobo.598.1">have two:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.599.1">A stream, named </span><strong class="source-inline"><span class="koboSpan" id="kobo.600.1">searchTerms</span></strong><span class="koboSpan" id="kobo.601.1">, that emits the user’s input, represented by a </span><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">BehaviorSubject</span></strong><span class="koboSpan" id="kobo.603.1"> subject that’s initialized with an </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">empty string:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.605.1">
private searchTerms = new BehaviorSubject&lt;string&gt;('');</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.606.1">We’ll update this stream whenever the user’s input changes by using an </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">update</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.608.1"> method:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.609.1">    updateSearchTerm(searchTerm: string) {
      this.searchTerms.next(searchTerm);
    }</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.610.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">searchTerms</span></strong><span class="koboSpan" id="kobo.612.1"> stream and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">updateSearchTerm</span></strong><span class="koboSpan" id="kobo.614.1"> method will be available </span><a id="_idIndexMarker264"/><span class="No-Break"><span class="koboSpan" id="kobo.615.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">RecipeCreationComponent</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.617.1">.</span></span></p></li> <li><span class="koboSpan" id="kobo.618.1">A stream, named </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">getTags$</span></strong><span class="koboSpan" id="kobo.620.1">, that emits the fetched tags matching the user’s input. </span><span class="koboSpan" id="kobo.620.2">We’ll define this stream in </span><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">RecipesService</span></strong><span class="koboSpan" id="kobo.622.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.623.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.624.1">
  getTags$: (term: string) =&gt; Observable&lt;Tag[]&gt; =
  (term: string) =&gt; {
    return this.http.get&lt;Tag[]&gt;(`${BASE_PATH}/tags`,
      {  params: { criteria: term }  });
  };</span></pre><p class="list-inset"><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">getTags$</span></strong><span class="koboSpan" id="kobo.626.1"> represents a function that takes a string parameter, </span><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">term</span></strong><span class="koboSpan" id="kobo.628.1">, and returns an Observable of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">Tag[]</span></strong><span class="koboSpan" id="kobo.630.1"> type that issues an HTTP GET request to retrieve an array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.631.1">Tag</span></strong><span class="koboSpan" id="kobo.632.1"> objects matching the provided </span><span class="No-Break"><span class="koboSpan" id="kobo.633.1">search term.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.634.1">We defined the </span><strong class="source-inline"><span class="koboSpan" id="kobo.635.1">Tag</span></strong><span class="koboSpan" id="kobo.636.1"> type </span><span class="No-Break"><span class="koboSpan" id="kobo.637.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">\src\app\core\model\tags.ts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.639.1">.</span></span></p></li> </ul>
<p><span class="koboSpan" id="kobo.640.1">Now, it’s time to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.641.1">switchMap</span></strong><span class="koboSpan" id="kobo.642.1">, which will map each value emitted by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">searchTerms</span></strong><span class="koboSpan" id="kobo.644.1"> stream to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">getTags$</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.646.1"> Observable:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.647.1">
tagValues$ = this.searchTerms.pipe(
distinctUntilChanged(), // ignore if next search term is
                           same as previous
switchMap((term: string) =&gt; this.service.getTags$(term))
// switch to new Observable each time
  );</span></pre> <p><span class="koboSpan" id="kobo.648.1">We will define </span><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">tagValues$</span></strong><span class="koboSpan" id="kobo.650.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">RecipeCreationComponent</span></strong><span class="koboSpan" id="kobo.652.1">. </span><span class="koboSpan" id="kobo.652.2">So, overall, </span><strong class="source-inline"><span class="koboSpan" id="kobo.653.1">tagValues$</span></strong><span class="koboSpan" id="kobo.654.1"> issues a search request for every unique user’s input and ensures only the latest search results are displayed, discarding </span><span class="No-Break"><span class="koboSpan" id="kobo.655.1">previous ones.</span></span></p>
<p><span class="koboSpan" id="kobo.656.1">Finally, we will </span><a id="_idIndexMarker265"/><span class="koboSpan" id="kobo.657.1">update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">RecipeCreationComponent</span></strong><span class="koboSpan" id="kobo.659.1"> HTML template to modify how tags are displayed from a radio button to an </span><span class="No-Break"><span class="koboSpan" id="kobo.660.1">autocomplete dropdown:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.661.1">
  &lt;div class="col-3"&gt;
      &lt;label for="Tags"&gt;Tags&lt;/label&gt;
      @if (tagValues$ | async; as tags) {
          &lt;p-autoComplete formControlName="tags"
          [suggestions]="tags"
          (completeMethod)=
          "updateSearchTerm($event.query)"
          field="name"&gt;&lt;/p-autoComplete&gt;
      }
  &lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.662.1">Here, we subscribed to </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">tagValues$</span></strong><span class="koboSpan" id="kobo.664.1"> using the async pipe and stored the emitted value in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">tags</span></strong><span class="koboSpan" id="kobo.666.1"> array. </span><span class="koboSpan" id="kobo.666.2">Then, we used the PrimeNG autocomplete component to provide suggestions as the user types in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">"Tags"</span></strong><span class="koboSpan" id="kobo.668.1"> input field. </span><span class="koboSpan" id="kobo.668.2">The autocomplete component binds to a form control named </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">"tags",</span></strong><span class="koboSpan" id="kobo.670.1"> receives suggestions from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.671.1">tags</span></strong><span class="koboSpan" id="kobo.672.1"> array, and triggers the </span><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">updateSearchTerm</span></strong><span class="koboSpan" id="kobo.674.1"> method with the user’s query when the user starts typing. </span><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">concatMap</span></strong><span class="koboSpan" id="kobo.676.1"> will issue a GET request for every unique user’s input and ensure only the latest search results are displayed, canceling </span><span class="No-Break"><span class="koboSpan" id="kobo.677.1">previous requests.</span></span></p>
<p><span class="koboSpan" id="kobo.678.1">And that’s it! </span><span class="koboSpan" id="kobo.678.2">Here’s an illustration of the implemented behavior. </span><span class="koboSpan" id="kobo.678.3">Here, when we enter </span><strong class="bold"><span class="koboSpan" id="kobo.679.1">B</span></strong><span class="koboSpan" id="kobo.680.1"> in the </span><a id="_idIndexMarker266"/><span class="koboSpan" id="kobo.681.1">search field, we receive </span><strong class="bold"><span class="koboSpan" id="kobo.682.1">Breakfast</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.683.1">a suggestion:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer050">
<span class="koboSpan" id="kobo.684.1"><img alt="Figure 6.8 – The autocompletion suggestion" src="image/B21180_06_8.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.685.1">Figure 6.8 – The autocompletion suggestion</span></p>
<p><span class="koboSpan" id="kobo.686.1">Now, let’s move on to another </span><span class="No-Break"><span class="koboSpan" id="kobo.687.1">operator, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.688.1">mergeMap</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.690.1">The mergeMap operator</span></h3>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">mergeMap</span></strong><span class="koboSpan" id="kobo.692.1"> is</span><a id="_idIndexMarker267"/><span class="koboSpan" id="kobo.693.1"> a combination</span><a id="_idIndexMarker268"/><span class="koboSpan" id="kobo.694.1"> of the merge and transformation (or </span><span class="No-Break"><span class="koboSpan" id="kobo.695.1">mapping) strategies:</span></span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.696.1">mergeMap = merge(merge) + map (</span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.697.1">higher-order mapping)</span></em></span></p>
<p><span class="koboSpan" id="kobo.698.1">Now that you understand the concepts of higher-order mapping, let’s understand the merging strategy by looking at the following marble diagram, which considers the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">merge</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.700.1"> operator:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer051">
<span class="koboSpan" id="kobo.701.1"><img alt="Figure 6.9 – The merge operator – marble diagram" src="image/B21180_06_9.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.702.1">Figure 6.9 – The merge operator – marble diagram</span></p>
<p><span class="koboSpan" id="kobo.703.1">Unlike </span><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">concat</span></strong><span class="koboSpan" id="kobo.705.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">merge</span></strong><span class="koboSpan" id="kobo.707.1"> will not wait for an Observable to complete before subscribing to the next Observable. </span><span class="koboSpan" id="kobo.707.2">It subscribes to every inner Observable at the same time and then </span><a id="_idIndexMarker269"/><span class="koboSpan" id="kobo.708.1">outputs the values to the combined</span><a id="_idIndexMarker270"/><span class="koboSpan" id="kobo.709.1"> result. </span><span class="koboSpan" id="kobo.709.2">As described in this marble diagram, the values of the input Observables are reflected in the output immediately. </span><span class="koboSpan" id="kobo.709.3">The result will only be completed once all the merged Observables </span><span class="No-Break"><span class="koboSpan" id="kobo.710.1">are completed.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">mergeMap</span></strong><span class="koboSpan" id="kobo.712.1"> is a higher-order mapping operator that processes each inner Observable in parallel. </span><span class="koboSpan" id="kobo.712.2">It is like multitasking in the kitchen, where you’re simultaneously handling different cooking tasks, such as chopping, boiling, and mixing, all at once. </span><span class="koboSpan" id="kobo.712.3">However, you should only use </span><strong class="source-inline"><span class="koboSpan" id="kobo.713.1">mergeMap</span></strong><span class="koboSpan" id="kobo.714.1"> if the resulting order doesn’t matter because these requests may be processed out </span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">of order.</span></span></p>
<p><span class="koboSpan" id="kobo.716.1">Suppose we aim to retrieve a list of recipes that match specific tags. </span><span class="koboSpan" id="kobo.716.2">For every tag, we want to initiate an HTTP request to fetch the recipes corresponding to that tag. </span><span class="koboSpan" id="kobo.716.3">The order of tag requests is not important; all requests should be executed concurrently. </span><span class="koboSpan" id="kobo.716.4">Here’s </span><span class="No-Break"><span class="koboSpan" id="kobo.717.1">the code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.718.1">
  selectedTags$ = from(['Salty', 'Sweet', 'Healthy']);
  recipesByTag$ = this.selectedTags$.pipe(
    mergeMap(tag =&gt;
      this.getRecipesByTag(tag)),mergeAll(),toArray());
  getRecipesByTag(name: string): Observable&lt;Recipe[]&gt; {
    return this.http.get&lt;Recipe[]&gt;(
      `${BASE_PATH}/recipesByTags`, { params: { tagName:
        name } });
  }</span></pre> <p><span class="koboSpan" id="kobo.719.1">Here, we created an Observable named </span><strong class="source-inline"><span class="koboSpan" id="kobo.720.1">selectedTags$</span></strong><span class="koboSpan" id="kobo.721.1"> from a static array of tags. </span><strong class="source-inline"><span class="koboSpan" id="kobo.722.1">selectedTags$</span></strong><span class="koboSpan" id="kobo.723.1"> emits the tags (array elements) one by one. </span><span class="koboSpan" id="kobo.723.2">Whenever a tag is emitted by </span><strong class="source-inline"><span class="koboSpan" id="kobo.724.1">selectedTags$</span></strong><span class="koboSpan" id="kobo.725.1">, an HTTP request is issued by </span><strong class="source-inline"><span class="koboSpan" id="kobo.726.1">this.getRecipesByTag(tagName)</span></strong><span class="koboSpan" id="kobo.727.1"> to fetch the corresponding recipes. </span><span class="koboSpan" id="kobo.727.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">mergeMap</span></strong><span class="koboSpan" id="kobo.729.1"> operator is used to concurrently handle multiple tag requests. </span><span class="koboSpan" id="kobo.729.2">When another </span><a id="_idIndexMarker271"/><span class="koboSpan" id="kobo.730.1">tag is emitted while the </span><a id="_idIndexMarker272"/><span class="koboSpan" id="kobo.731.1">previous request is still in progress, the new request is </span><span class="No-Break"><span class="koboSpan" id="kobo.732.1">executed concurrently.</span></span></p>
<p><span class="koboSpan" id="kobo.733.1">We used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.734.1">mergeAll</span></strong><span class="koboSpan" id="kobo.735.1"> operator to flatten the results that were obtained from the different inner Observables into a single Observable stream. </span><span class="koboSpan" id="kobo.735.2">This ensures that the recipes emitted by each inner Observable are merged into a cohesive stream </span><span class="No-Break"><span class="koboSpan" id="kobo.736.1">of recipes.</span></span></p>
<p><span class="koboSpan" id="kobo.737.1">Finally, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.738.1">toArray</span></strong><span class="koboSpan" id="kobo.739.1"> operator is used to convert all emitted recipes into a single array, making it convenient for a list display in </span><span class="No-Break"><span class="koboSpan" id="kobo.740.1">the UI.</span></span></p>
<p><span class="koboSpan" id="kobo.741.1">Again, I previously added a delay to the backend service that returns the recipes by tag. </span><span class="koboSpan" id="kobo.741.2">Upon opening the console, we’ll find that all the requests were run concurrently, even if there are </span><span class="No-Break"><span class="koboSpan" id="kobo.742.1">pending ones:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer052">
<span class="koboSpan" id="kobo.743.1"><img alt="Figure 6.10 – mergeMap’s execution" src="image/B21180_06_10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.744.1">Figure 6.10 – mergeMap’s execution</span></p>
<p><span class="koboSpan" id="kobo.745.1">We can </span><a id="_idIndexMarker273"/><span class="koboSpan" id="kobo.746.1">also use </span><strong class="source-inline"><span class="koboSpan" id="kobo.747.1">mergeMap</span></strong><span class="koboSpan" id="kobo.748.1"> to fetch data from multiple sources in parallel and combine the results. </span><span class="koboSpan" id="kobo.748.2">Imagine that </span><a id="_idIndexMarker274"/><span class="koboSpan" id="kobo.749.1">we have multiple Review sources for our recipes, and we want to collect them (in this case, the order here is not important). </span><span class="koboSpan" id="kobo.749.2">Here’s </span><span class="No-Break"><span class="koboSpan" id="kobo.750.1">the code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.751.1">
  getRecipesReviews(recipeId: number): Observable&lt;Review[]&gt;
  {
    return from([`${BASE_PATH}/source1/reviews`,
    `${BASE_PATH}/source2/reviews`])
      .pipe(
        mergeMap((endpoint) =&gt; this.http.get&lt;Review[]&gt;(
          endpoint, { params: { recipeId: recipeId } })));
  }</span></pre> <p><span class="koboSpan" id="kobo.752.1">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.753.1">getRecipesReviews(recipeId: number)</span></strong><span class="koboSpan" id="kobo.754.1"> is a method that fetches reviews for a recipe identified by </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">recipeId</span></strong><span class="koboSpan" id="kobo.756.1"> from two different sources (</span><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">source1</span></strong><span class="koboSpan" id="kobo.758.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">source2</span></strong><span class="koboSpan" id="kobo.760.1">) by issuing parallel HTTP GET requests to </span><span class="No-Break"><span class="koboSpan" id="kobo.761.1">each source.</span></span></p>
<p><span class="koboSpan" id="kobo.762.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.763.1">from([${BASE_PATH}/source1/reviews, ${BASE_PATH}/source2/reviews])</span></strong><span class="koboSpan" id="kobo.764.1"> line creates an Observable from an array containing two different endpoints to fetch reviews. </span><span class="koboSpan" id="kobo.764.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.765.1">from</span></strong><span class="koboSpan" id="kobo.766.1"> operator emits each item of the array as a separate value in the </span><span class="No-Break"><span class="koboSpan" id="kobo.767.1">Observable sequence.</span></span></p>
<p><span class="koboSpan" id="kobo.768.1">Then, </span><strong class="source-inline"><span class="koboSpan" id="kobo.769.1">mergeMap</span></strong><span class="koboSpan" id="kobo.770.1"> is used </span><a id="_idIndexMarker275"/><span class="koboSpan" id="kobo.771.1">to raise a GET request to fetch reviews </span><a id="_idIndexMarker276"/><span class="koboSpan" id="kobo.772.1">for the specified </span><strong class="source-inline"><span class="koboSpan" id="kobo.773.1">recipeId</span></strong><span class="koboSpan" id="kobo.774.1"> for each endpoint emitted by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.775.1">from</span></strong><span class="koboSpan" id="kobo.776.1"> operator, ensuring that both requests are </span><span class="No-Break"><span class="koboSpan" id="kobo.777.1">made concurrently.</span></span></p>
<p><span class="koboSpan" id="kobo.778.1">With that, let’s move on to the last operator that we will </span><span class="No-Break"><span class="koboSpan" id="kobo.779.1">discuss, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.780.1">exhaustMap</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.781.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.782.1">The exhaustMap operator</span></h3>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.783.1">exhaustMap</span></strong><span class="koboSpan" id="kobo.784.1"> is</span><a id="_idIndexMarker277"/><span class="koboSpan" id="kobo.785.1"> a combination</span><a id="_idIndexMarker278"/><span class="koboSpan" id="kobo.786.1"> of the exhaust and transformation (or </span><span class="No-Break"><span class="koboSpan" id="kobo.787.1">mapping) strategies:</span></span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.788.1">exhaustMap = exhaust(exhaust) + map ()</span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.789.1">higher-order mapping</span></em></span></p>
<p><span class="koboSpan" id="kobo.790.1">Let’s look at this marble diagram to understand the </span><span class="No-Break"><span class="koboSpan" id="kobo.791.1">exhaust strategy:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer053">
<span class="koboSpan" id="kobo.792.1"><img alt="Figure 6.11 – The exhaust operator – marble diagram" src="image/B21180_06_11.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.793.1">Figure 6.11 – The exhaust operator – marble diagram</span></p>
<p><span class="koboSpan" id="kobo.794.1">The top line is a higher-order Observable that produces three inner Observables over time. </span><span class="koboSpan" id="kobo.794.2">When the first inner Observable (</span><strong class="bold"><span class="koboSpan" id="kobo.795.1">a</span></strong><span class="koboSpan" id="kobo.796.1">-</span><strong class="bold"><span class="koboSpan" id="kobo.797.1">b</span></strong><span class="koboSpan" id="kobo.798.1">-</span><strong class="bold"><span class="koboSpan" id="kobo.799.1">c</span></strong><span class="koboSpan" id="kobo.800.1">) is emitted, </span><strong class="source-inline"><span class="koboSpan" id="kobo.801.1">exhaust</span></strong><span class="koboSpan" id="kobo.802.1"> will subscribe to it so that the values </span><strong class="bold"><span class="koboSpan" id="kobo.803.1">a</span></strong><span class="koboSpan" id="kobo.804.1">-</span><strong class="bold"><span class="koboSpan" id="kobo.805.1">b</span></strong><span class="koboSpan" id="kobo.806.1"> get reflected in the output Observable. </span><span class="koboSpan" id="kobo.806.2">Then, the second inner Observable comes and gets ignored by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.807.1">exhaust</span></strong><span class="koboSpan" id="kobo.808.1"> operator; it will not be subscribed to (this is the key part </span><span class="No-Break"><span class="koboSpan" id="kobo.809.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.810.1">exhaust</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.811.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.812.1">Only when the first inner Observable completes will </span><strong class="source-inline"><span class="koboSpan" id="kobo.813.1">exhaust</span></strong><span class="koboSpan" id="kobo.814.1"> subscribe to new Observables. </span><span class="koboSpan" id="kobo.814.2">So, </span><strong class="bold"><span class="koboSpan" id="kobo.815.1">c</span></strong><span class="koboSpan" id="kobo.816.1"> will be reflected, and the first inner Observable will complete. </span><strong class="source-inline"><span class="koboSpan" id="kobo.817.1">exhaust</span></strong><span class="koboSpan" id="kobo.818.1"> is ready now to treat other Observables. </span><span class="koboSpan" id="kobo.818.2">At that point, the third inner Observable comes. </span><span class="koboSpan" id="kobo.818.3">The switch will subscribe to and the values of the third inner Observable, </span><strong class="bold"><span class="koboSpan" id="kobo.819.1">g</span></strong><span class="koboSpan" id="kobo.820.1">-</span><strong class="bold"><span class="koboSpan" id="kobo.821.1">h</span></strong><span class="koboSpan" id="kobo.822.1">-</span><strong class="bold"><span class="koboSpan" id="kobo.823.1">i</span></strong><span class="koboSpan" id="kobo.824.1">, get reflected in </span><span class="No-Break"><span class="koboSpan" id="kobo.825.1">the output.</span></span></p>
<p><span class="koboSpan" id="kobo.826.1">So, </span><strong class="source-inline"><span class="koboSpan" id="kobo.827.1">exhaustMap</span></strong><span class="koboSpan" id="kobo.828.1"> waits for the completion of the current inner Observable before allowing the next Observable to emit values. </span><span class="koboSpan" id="kobo.828.2">Once the inner Observable completes, </span><strong class="source-inline"><span class="koboSpan" id="kobo.829.1">exhaustMap</span></strong><span class="koboSpan" id="kobo.830.1"> subscribes to the next Observable in the sequence. </span><span class="koboSpan" id="kobo.830.2">It ensures that only one inner </span><a id="_idIndexMarker279"/><span class="koboSpan" id="kobo.831.1">Observable is active at a time, ignoring any new Observables that are emitted while the current one is still ongoing. </span><span class="koboSpan" id="kobo.831.2">This is particularly useful in scenarios where you want to ignore new events until a </span><a id="_idIndexMarker280"/><span class="koboSpan" id="kobo.832.1">previous operation has finished, such as handling user clicks on a button, where subsequent clicks are ignored until the current </span><span class="No-Break"><span class="koboSpan" id="kobo.833.1">operation completes.</span></span></p>
<p><span class="koboSpan" id="kobo.834.1">It’s similar to how you might handle tasks when you’re busy with something important. </span><span class="koboSpan" id="kobo.834.2">If someone tries to get your attention with a new task, you might say, “I’m busy right now, please don’t disturb me until I finish what I’m doing.” </span><strong class="source-inline"><span class="koboSpan" id="kobo.835.1">exhaustMap</span></strong><span class="koboSpan" id="kobo.836.1"> operates similarly, ensuring that ongoing tasks are completed before considering </span><span class="No-Break"><span class="koboSpan" id="kobo.837.1">new ones.</span></span></p>
<p><span class="koboSpan" id="kobo.838.1">Let’s consider a scenario in our recipe app where users can edit recipe details and save their changes through a </span><strong class="bold"><span class="koboSpan" id="kobo.839.1">Save</span></strong><span class="koboSpan" id="kobo.840.1"> button. </span><span class="koboSpan" id="kobo.840.2">You want to prevent multiple save requests from being sent if a user rapidly clicks the </span><strong class="bold"><span class="koboSpan" id="kobo.841.1">Save</span></strong><span class="koboSpan" id="kobo.842.1"> button multiple times. </span><strong class="source-inline"><span class="koboSpan" id="kobo.843.1">exhaustMap</span></strong><span class="koboSpan" id="kobo.844.1"> comes in handy here by ignoring subsequent save requests until the current save operation completes. </span><span class="koboSpan" id="kobo.844.2">Here’s </span><span class="No-Break"><span class="koboSpan" id="kobo.845.1">the implementation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.846.1">
  private saveClick = new Subject&lt;Boolean&gt;();
  private saveRecipe$ =
    this.service.saveRecipe(&lt;Recipe&gt;this.recipeForm.value);
  saveClick$ = this.saveClick.pipe(exhaustMap(() =&gt;
    this.service.saveRecipe(&lt;Recipe&gt;this.recipeForm.value))
  );
  saveRecipe() {
    this.saveClick.next(true);
  }</span></pre> <p><span class="koboSpan" id="kobo.847.1">In the component responsible for editing the recipe, we defined </span><span class="No-Break"><span class="koboSpan" id="kobo.848.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.849.1">A private </span><strong class="source-inline"><span class="koboSpan" id="kobo.850.1">saveClick</span></strong><span class="koboSpan" id="kobo.851.1"> subject to track the </span><strong class="bold"><span class="koboSpan" id="kobo.852.1">Save</span></strong><span class="koboSpan" id="kobo.853.1"> button being clicked. </span><strong class="source-inline"><span class="koboSpan" id="kobo.854.1">saveClick </span></strong><span class="koboSpan" id="kobo.855.1">represents our </span><span class="No-Break"><span class="koboSpan" id="kobo.856.1">first stream.</span></span></li>
<li><span class="koboSpan" id="kobo.857.1">A private </span><strong class="source-inline"><span class="koboSpan" id="kobo.858.1">saveRecipe$</span></strong><span class="koboSpan" id="kobo.859.1"> Observable that issues an HTTP save request to save </span><span class="No-Break"><span class="koboSpan" id="kobo.860.1">the recipe.</span></span></li>
<li> <strong class="source-inline"><span class="koboSpan" id="kobo.861.1">saveClick$</span></strong><span class="koboSpan" id="kobo.862.1">, our second stream that listens to </span><strong class="source-inline"><span class="koboSpan" id="kobo.863.1">saveClick</span></strong><span class="koboSpan" id="kobo.864.1"> emissions and uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.865.1">exhaustMap</span></strong><span class="koboSpan" id="kobo.866.1"> operator to issue a new save request only after the previous one </span><span class="No-Break"><span class="koboSpan" id="kobo.867.1">is completed.</span></span></li>
<li><span class="koboSpan" id="kobo.868.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.869.1">saveRecipe</span></strong><span class="koboSpan" id="kobo.870.1"> method. </span><span class="koboSpan" id="kobo.870.2">This will be invoked when the </span><strong class="bold"><span class="koboSpan" id="kobo.871.1">Save</span></strong><span class="koboSpan" id="kobo.872.1"> button is clicked and will send </span><strong class="source-inline"><span class="koboSpan" id="kobo.873.1">true</span></strong><span class="koboSpan" id="kobo.874.1"> to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.875.1">saveClick</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.876.1"> subject.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.877.1">Finally, we must </span><a id="_idIndexMarker281"/><span class="koboSpan" id="kobo.878.1">subscribe to </span><strong class="source-inline"><span class="koboSpan" id="kobo.879.1">saveClick$</span></strong><span class="koboSpan" id="kobo.880.1"> using the async pipe </span><a id="_idIndexMarker282"/><span class="koboSpan" id="kobo.881.1">in the HTML template and add the click handler to the </span><strong class="bold"><span class="koboSpan" id="kobo.882.1">Save</span></strong><span class="koboSpan" id="kobo.883.1"> button to invoke the </span><strong class="source-inline"><span class="koboSpan" id="kobo.884.1">saveRecipe</span></strong><span class="koboSpan" id="kobo.885.1"> method, </span><span class="No-Break"><span class="koboSpan" id="kobo.886.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.887.1">
&lt;ng-container *ngIf="saveClick$ | async"&gt;&lt;/ng-container&gt;
&lt;p-button class="recipe-button" (click)="saveRecipe()"
label="Save"&gt;&lt;/p-button&gt;</span></pre> <p><span class="koboSpan" id="kobo.888.1">This ensures that only one save request is processed at a time, preventing duplicate entries or data corruption. </span><span class="koboSpan" id="kobo.888.2">You can test this code </span><span class="No-Break"><span class="koboSpan" id="kobo.889.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.890.1">RecipeCreationComponent</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.891.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.892.1">You can also use </span><strong class="source-inline"><span class="koboSpan" id="kobo.893.1">exhaustMap</span></strong><span class="koboSpan" id="kobo.894.1"> in drag and drop features to ensure that actions are only processed when a user’s dragging action has been completed, preventing multiple actions from being </span><span class="No-Break"><span class="koboSpan" id="kobo.895.1">triggered simultaneously.</span></span></p>
<h3><span class="koboSpan" id="kobo.896.1">Wrapping up the operators</span></h3>
<p><span class="koboSpan" id="kobo.897.1">Let’s </span><a id="_idIndexMarker283"/><span class="koboSpan" id="kobo.898.1">summarize all the operators that were mentioned in </span><span class="No-Break"><span class="koboSpan" id="kobo.899.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.900.1">If the order is important and you need to process operations in sequence while waiting for completion, then </span><strong class="source-inline"><span class="koboSpan" id="kobo.901.1">concatMap</span></strong><span class="koboSpan" id="kobo.902.1"> is the </span><span class="No-Break"><span class="koboSpan" id="kobo.903.1">right choice</span></span></li>
<li><span class="koboSpan" id="kobo.904.1">If the order is not important and you need to process operations in parallel to enhance performance, </span><strong class="source-inline"><span class="koboSpan" id="kobo.905.1">mergeMap</span></strong><span class="koboSpan" id="kobo.906.1"> is the </span><span class="No-Break"><span class="koboSpan" id="kobo.907.1">best operator</span></span></li>
<li><span class="koboSpan" id="kobo.908.1">If you need </span><a id="_idIndexMarker284"/><span class="koboSpan" id="kobo.909.1">to put a cancellation logic to release resources and take always the most recent information, then </span><strong class="source-inline"><span class="koboSpan" id="kobo.910.1">switchMap</span></strong><span class="koboSpan" id="kobo.911.1"> is the way </span><span class="No-Break"><span class="koboSpan" id="kobo.912.1">to go</span></span></li>
<li><span class="koboSpan" id="kobo.913.1">To ignore new Observables while the current one is still ongoing, </span><span class="No-Break"><span class="koboSpan" id="kobo.914.1">use </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.915.1">exhaustMap</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.916.1">All you have to do is pick the right operator based on your specific </span><span class="No-Break"><span class="koboSpan" id="kobo.917.1">use case.</span></span></p>
<h1 id="_idParaDest-100"><a id="_idTextAnchor106"/><span class="koboSpan" id="kobo.918.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.919.1">In this chapter, we began by illustrating the traditional, imperative approach to implementing the autosave feature in our recipe app. </span><span class="koboSpan" id="kobo.919.2">However, we soon encountered limitations with this method. </span><span class="koboSpan" id="kobo.919.3">We highlighted these problems before exploring a more reactive pattern to address </span><span class="No-Break"><span class="koboSpan" id="kobo.920.1">these challenges.</span></span></p>
<p><span class="koboSpan" id="kobo.921.1">Then, we delved into higher-order Observables and higher-order mapping operators, learning how the </span><strong class="source-inline"><span class="koboSpan" id="kobo.922.1">concatMap</span></strong><span class="koboSpan" id="kobo.923.1"> operator works and how it can help us implement the autosave requirement in the Recipe </span><span class="No-Break"><span class="koboSpan" id="kobo.924.1">app reactively.</span></span></p>
<p><span class="koboSpan" id="kobo.925.1">Additionally, we expanded our exploration to include other strategies, namely the </span><strong class="source-inline"><span class="koboSpan" id="kobo.926.1">merge</span></strong><span class="koboSpan" id="kobo.927.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.928.1">switch</span></strong><span class="koboSpan" id="kobo.929.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.930.1">exhaust</span></strong><span class="koboSpan" id="kobo.931.1"> higher-order mapping operators. </span><span class="koboSpan" id="kobo.931.2">We explained their functionality by using practical examples and use cases to gain a deeper understanding of </span><span class="No-Break"><span class="koboSpan" id="kobo.932.1">these concepts.</span></span></p>
<p><span class="koboSpan" id="kobo.933.1">In the next chapter, we will explore another useful reactive pattern that allows you to share data between your components. </span><span class="koboSpan" id="kobo.933.2">As usual, we will demystify the concepts and then learn the reactive way to </span><span class="No-Break"><span class="koboSpan" id="kobo.934.1">do it.</span></span></p>
</div>
</body></html>