- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rendering Lists and Conditional Content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Output dynamic content conditionally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Render lists of data and map list items to JSX elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimize lists such that React is able to efficiently update the user interface
    when needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By this point in the book, you are already familiar with several key concepts,
    including components, props, state, and events, with which you have all the core
    tools you need to build all kinds of different React apps and websites. You have
    also learned how to output dynamic values and results as part of the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are two topics related to outputting dynamic data that have
    not yet been discussed in depth: outputting content conditionally and rendering
    list data. Since most (if not all) websites and web apps you build will require
    at least one of these two concepts, it is crucial to know how to work with conditional
    content and list data.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will therefore learn how to render and display different
    user interface elements (and even entire user interface sections), based on dynamic
    conditions. In addition, you will learn how to output lists of data (such as a
    to-do list with its items) and render JSX elements dynamically for the items that
    make up a list. This chapter will also explore important best practices related
    to outputting lists and conditional content.
  prefs: []
  type: TYPE_NORMAL
- en: What Are Conditional Content and List Data?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before diving into the techniques for outputting conditional content or list
    data, it is important to understand what exactly is meant by those terms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conditional content simply means any kind of content that should only be displayed
    under certain circumstances. Some examples are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Error overlays that should only show up if a user submits incorrect data in
    a form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional form input fields that appear once the user chooses to enter extra
    details (such as business details)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A loading spinner that is displayed while data is sent or fetched to or from
    a backend server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A side navigation menu that slides into view when the user clicks on a menu
    button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is just a very short list of a few examples. You could, of course, come
    up with hundreds of additional examples. But it should be clear what all these
    examples are about in the end: visual elements or entire sections of the user
    interface that are only shown if certain conditions are met.'
  prefs: []
  type: TYPE_NORMAL
- en: In the first example (an error overlay), the condition would be that a user
    entered incorrect data into a form. The conditionally shown content would then
    be the error overlay.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional content is extremely common since virtually all websites and web
    apps have some content that is similar or comparable to the preceding examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to conditional content, many websites also output lists of data.
    It might not always be immediately obvious, but if you think about it, there is
    virtually no website that does not display some kind of list data. Again, here
    are some examples of list data that may be outputted on a site:'
  prefs: []
  type: TYPE_NORMAL
- en: An online shop displaying a grid or list of products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An event booking site displaying a list of events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A shopping cart displaying a list of cart items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An orders page displaying a list of orders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A blog displaying a list of blog posts—and maybe a list of comments below a
    blog post
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of navigation items in the header
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An endless list (no pun intended) of examples could be created here. Lists are
    everywhere on the web. As the preceding examples show, many (probably even most)
    websites have multiple lists with various kinds of data on the same site.
  prefs: []
  type: TYPE_NORMAL
- en: Take an online shop, for example. Here, you would have a list (or a grid, which
    is really just another kind of list) of products, a list of shopping cart items,
    a list of orders, a list of navigation items in the header, and certainly a lot
    of other lists as well. This is why it is important that you know how to output
    any kind of list with any kind of data in React-driven user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering Content Conditionally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine the following scenario. You have a button that, when clicked, should
    result in the display of an extra text box, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A black and white rectangular sign  Description automatically generated](img/B31339_05_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: Initially, nothing but the button shows up on the screen'
  prefs: []
  type: TYPE_NORMAL
- en: 'After a click on the button, another box is shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screen shot of a computer  Description automatically generated](img/B31339_05_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: After clicking the button, the info box is revealed'
  prefs: []
  type: TYPE_NORMAL
- en: This is a very simple example, but not an unrealistic one. Many websites have
    parts of the user interface that work like this. Showing extra information upon
    a button click (or some similar interaction) is a common pattern. Just think of
    nutrition information below a meal on a food order site or an FAQ section where
    answers are shown after selecting a question.
  prefs: []
  type: TYPE_NORMAL
- en: So, how could this scenario be implemented in a React app?
  prefs: []
  type: TYPE_NORMAL
- en: 'If you ignore the requirement of rendering some of the content conditionally,
    the overall React component could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This component has absolutely no conditional code in it and, therefore, both
    the button and the extra information box are shown all the time.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, how could the paragraph with the terms-of-use summary text
    be shown conditionally (that is, only after the button is clicked)?
  prefs: []
  type: TYPE_NORMAL
- en: 'With the knowledge gained throughout the previous chapters, especially *Chapter
    4* , *Working with Events and State* , you already have the skills needed to only
    show the text after the button is clicked. The following code shows how the component
    could be rewritten to show the full text only after the button is clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Parts of the code shown in this snippet already qualify as conditional content.
    The `paragraphText` value is set conditionally, with the help of an `if` statement
    based on the value stored in the `showTerms` state.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the `<p>` element itself is actually **not** conditional. It is always
    there, regardless of whether it contains a full sentence or an empty string. If
    you were to open the browser developer tools and inspect that area of the page,
    an empty paragraph element would be visible, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_05_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3: An empty paragraph element is rendered as part of the DOM'
  prefs: []
  type: TYPE_NORMAL
- en: Having that empty `<p>` element in the DOM is not ideal. While it’s invisible
    to the user, it’s an extra element that needs to be rendered by the browser. The
    performance impact will very likely be negligible but it’s still something you
    should avoid. A web page doesn’t benefit from having empty elements that contain
    no content.
  prefs: []
  type: TYPE_NORMAL
- en: You can translate your knowledge about conditional values (such as the paragraph
    text) to conditional elements, however. Besides storing standard values such as
    text or numbers in variables, you can also store JSX elements in variables. This
    is possible because, as mentioned in *Chapter 1* , *React – What and Why* , JSX
    is just syntactic sugar. Behind the scenes, a JSX element is a standard JavaScript
    function that is executed by React. Also, of course, the return value of a function
    call can be stored in a variable or constant.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that in mind, the following code could be used to render the entire paragraph
    conditionally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this example, if `showTerms` is `true` , the `paragraph` variable does not
    store text but instead an entire JSX element (the `<p>` element). In the returned
    JSX code, the value stored in the `paragraph` variable is outputted dynamically
    via `{paragraph}` . If `showTerms` is `false` , `paragraph` stores the value `undefined`
    and nothing is rendered to the DOM. Therefore, inserting `null` or `undefined`
    in JSX code leads to nothing being outputted by React. But if `showTerms` is `true`
    , the complete paragraph is saved as a value and outputted in the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: This is how entire JSX elements can be rendered dynamically. Of course, you
    are not limited to single elements. You could store entire JSX tree structures
    (such as multiple, nested, or sibling JSX elements) inside variables or constants.
    As a simple rule, anything that can be returned by a component function can be
    stored in a variable.
  prefs: []
  type: TYPE_NORMAL
- en: Different Ways of Rendering Content Conditionally
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the example shown previously, content is rendered conditionally by using
    a variable, which is set with the help of an `if` statement and then outputted
    dynamically in JSX code. This is a common (and perfectly fine) technique of rendering
    content conditionally, but it is not the only approach you can use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you could also do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Utilize ternary expressions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Abuse* JavaScript logical operators.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use any other valid JavaScript way of selecting values conditionally.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following sections will explore each approach in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing Ternary Expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In JavaScript (and many other programming languages), you can use **ternary
    expressions** (also referred to as **conditional ternary operators** ) as alternatives
    to `if` statements. Ternary expressions can save you lines of code, especially
    with simple conditions where the main goal is to assign some variable value conditionally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a direct comparison—first starting with a regular `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the same logic, implemented with a ternary expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is standard JavaScript code, not specific to React. However, it is important
    to understand this core JavaScript feature in order to understand how it can be
    used in React apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Translated to the previous React example, the paragraph content could be set
    and outputted conditionally with the help of ternary expressions like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the overall code is a bit shorter than before, when an `if`
    statement was used. The paragraph constant contains either the paragraph (including
    the text content) or `null` . `null` is used as an alternative value because `null`
    can safely be inserted into JSX code as it simply leads to nothing being rendered
    in its place.
  prefs: []
  type: TYPE_NORMAL
- en: 'A disadvantage of ternary expressions is that readability and understandability
    may suffer—especially when using nested ternary expressions, like in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This code is difficult to read and even more difficult to understand. For this
    reason, you should typically avoid writing nested ternary expressions and fall
    back to `if` statements in such situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, despite these potential disadvantages, ternary expressions can help
    you write less code in React apps, especially when using them inline, directly
    inside some JSX code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is the same example as before, only now it’s even shorter since here you
    avoid using the `paragraph` constant by utilizing the ternary expression directly
    inside of the JSX snippet. This allows for relatively lean component code, so
    it is quite common to use ternary expressions in JSX code in React apps to take
    advantage of this.
  prefs: []
  type: TYPE_NORMAL
- en: Abusing JavaScript Logical Operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ternary expressions are popular because they enable you to write less code,
    which, when used in the right places (and avoiding nesting multiple ternary expressions),
    can help with overall readability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Especially in React apps, in JSX code you will often write ternary expressions
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: What do these two snippets have in common?
  prefs: []
  type: TYPE_NORMAL
- en: 'They are unnecessarily long because, in both examples, the else case ( `: null`
    ) must be specified, even though it adds nothing to the final user interface.
    After all, the primary purpose of these ternary expressions is to render JSX elements
    ( `<h1>` and `<p>` , in the preceding examples). The `else` case ( `: null` )
    simply means nothing is rendered if the conditions ( `showDetails` and `showTerms`
    ) are not met.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is why a different pattern is popular among React developers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is the shortest possible way of achieving the intended result, rendering
    only the `<h1>` element and its content if `showDetails` is `true` .
  prefs: []
  type: TYPE_NORMAL
- en: This code uses (or abuses) an interesting behavior of JavaScript’s logical operators,
    specifically of the `&&` (logical `and` ) operator. In JavaScript, the `&&` operator
    returns the second value (that is, the value after `&&` ) if the first value (that
    is, the value before `&&` ) is `true` or truthy (that is, not `false` , `undefined`
    , `null` , `0` , and so on). Normally, you’d use the `&&` operator in `if` statements
    or ternary expressions. However, when working with React and JSX, you can take
    advantage of the behavior described previously to output truthy values conditionally.
    This technique is also called **short-circuiting** .
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following code would output `''` `Hello''` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This behavior can be used to write very short expressions that check a condition
    and then output another value, as shown in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that using `&&` can lead to unexpected results if you’re
    using it with non-Boolean condition values (that is, if the value in front of
    `&&` holds a non-Boolean value). If `showDetails` were `0` instead of `false`
    (for whatever reason), the number `0` would be displayed on the screen. You should
    therefore ensure that the value acting as a condition yields `null` or `false`
    instead of arbitrary falsy values. You could, for example, force a conversion
    to a Boolean by adding `!!` (for example, `!!showDetails` ). That is not required
    if your condition value already holds `null` or `false` .
  prefs: []
  type: TYPE_NORMAL
- en: Get Creative!
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this point, you have learned about three different ways of defining and outputting
    content conditionally (regular `if` statements, ternary expressions, and using
    the `&&` operator). However, the most important point is that React code is ultimately
    just regular JavaScript code. Hence, any approach that selects values conditionally
    will work.
  prefs: []
  type: TYPE_NORMAL
- en: 'If it makes sense in your specific use case and React app, you could also have
    a component that selects and outputs content conditionally like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This component outputs either `'de-DE'` , `'en-US'` , or `'` `en-GB'` based
    on the value of the `country` prop. This result is achieved by using JavaScript’s
    dynamic property selection syntax. Instead of selecting a specific property via
    the dot notation (such as `person.name` ), you can select property values via
    the bracket notation. With that notation, you can either pass a specific property
    name ( `languages['de-DE']` ) or an expression that yields a property name ( `languages[country]`
    ).
  prefs: []
  type: TYPE_NORMAL
- en: Selecting property values dynamically like this is another common pattern for
    picking values from a map of values. It is therefore an alternative to specifying
    multiple `if` statements or ternary expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Also, in general, you can use any approach that works in standard JavaScript—because
    React is, after all, just standard JavaScript at its core.
  prefs: []
  type: TYPE_NORMAL
- en: Which Approach is Best?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Various ways of setting and outputting content conditionally have been discussed,
    but which approach is best?
  prefs: []
  type: TYPE_NORMAL
- en: That really is up to you (and, if applicable, your team). The most important
    advantages and disadvantages have been highlighted, but ultimately, it is your
    decision. If you prefer ternary expressions, there’s nothing wrong with choosing
    them over the logical `&&` operator, for example.
  prefs: []
  type: TYPE_NORMAL
- en: It will also depend on the exact problem you are trying to solve. If you have
    a map of values (such as a list of countries and their country language codes),
    going for dynamic property selection instead of multiple `if` statements might
    be preferable. On the other hand, if you have a single `true` / `false` condition
    (such as `age > 18` ), using a standard `if` statement or the logical `&&` operator
    might be best.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Element Tags Conditionally
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Outputting content conditionally is a very common scenario. But sometimes, you
    will also want to choose the type of HTML tag that will be outputted conditionally.
    Typically, this will be the case when you build components whose main task is
    to wrap and enhance built-in components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This `Button` component checks whether the `isButton` prop value is truthy and,
    if that is the case, returns a `<button>` element. The `config` prop is expected
    to be a JavaScript object, and the standard JavaScript spread operator ( `...`
    ) is used to then add all key-value pairs of the `config` object as props to the
    `<button>` element. If `isButton` is not truthy (maybe because no value was provided
    for `isButton` , or because the value is `false` ), the `else` condition becomes
    active. Instead of a `<button>` element, an `<a>` element is returned.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: Using the spread operator ( `...` ) to translate an object’s properties (key-value
    pairs) into component props is another common React pattern (and was introduced
    in *Chapter 3* , *Components and Props* ). The spread operator is not a React-specific
    operator but using it for this special purpose *is* .
  prefs: []
  type: TYPE_NORMAL
- en: 'When spreading an object such as `{link: ''https://some-url.com'', isButton:
    false}` onto an `<a>` element (via `<a {...obj}>` ), the result would be the same
    as if all props had been set individually (that is, `<a link="https://some-url.com"
    isButton={false}>` ).'
  prefs: []
  type: TYPE_NORMAL
- en: This pattern is particularly popular in situations where you build custom *wrapper
    components* that wrap a common core component (e.g., `<button>` , `<input>` ,
    or `<a>` ) to add certain styles or behaviors, while still allowing the component
    to be used in the same way as the built-in component (that is, you can set all
    the default props).
  prefs: []
  type: TYPE_NORMAL
- en: The `Button` component from the preceding example returns two totally different
    JSX elements, depending on the `isButton` prop value. This is a great way of checking
    a condition and returning different content (that is, conditional content).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, by using a special React behavior, this component could be written
    with even less code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The special behavior is that tag names can be stored (as string values) in variables
    or constants, and that those variables or constants can then be used like JSX
    elements in JSX code (as long as the variable or constant name starts with an
    uppercase character, like all your custom components).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Tag` constant in the preceding example stores either the `''button''`
    or `''a''` string. Since it starts with an uppercase character ( `Tag` , instead
    of `tag` ), it can then be used like a custom component inside of JSX code snippets.
    React accepts this as a component, even though it isn’t a component function.
    This is because a standard HTML element tag name is stored, so React can render
    the appropriate built-in component. The same pattern could also be used with custom
    components. Instead of storing string values, you would store pointers to your
    custom component functions through the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is another useful pattern that can help save code and hence leads to leaner
    components.
  prefs: []
  type: TYPE_NORMAL
- en: Outputting List Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides outputting conditional data, you will often work with list data that
    should be outputted on a page. As mentioned earlier in this chapter, some examples
    are lists of products, transactions, and navigation items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, in React apps, such list data is received as an array of values.
    For example, a component might receive an array of products via props (passed
    into the component from inside another component that might be getting that data
    from some backend API):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the products array could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This data can’t be outputted like this, though. Instead, the goal is typically
    to translate it into a list of JSX elements that fits. For example, the desired
    result could be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How can this transformation be achieved?
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, it’s a good idea to ignore React and find a way to transform list data
    with standard JavaScript. One possible way to achieve this would be to use a `for…of`
    loop, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the list of product objects ( `products` ) is transformed into
    a list of product titles (that is, a list of string values). This is achieved
    by looping through all product items in `products` and extracting only the `title`
    property from each product. This `title` property value is then pushed into the
    new `transformedProducts` array.
  prefs: []
  type: TYPE_NORMAL
- en: 'A similar approach can be used to transform the list of objects into a list
    of JSX elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The first time you see code like this, it might look a bit strange. But keep
    in mind that JSX code can be used anywhere where regular JavaScript values (that
    is, numbers, strings, objects, and so on) can be used. Therefore, you can also
    `push` a JSX value onto an array of values. Since it’s JSX code, you can also
    output content dynamically in those JSX elements (such as `<h2>{product.title}</h2>`
    ).
  prefs: []
  type: TYPE_NORMAL
- en: This code is valid and is an important first step toward outputting list data.
    But it is only the first step, since the current data was transformed but still
    isn’t returned by a component.
  prefs: []
  type: TYPE_NORMAL
- en: How can such an array of JSX elements be returned then?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is that it can be returned without any special tricks or code. JSX
    actually accepts array values as dynamically outputted values.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can output the `productElements` array like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'When inserting an array of JSX elements into JSX code, all JSX elements inside
    that array are outputted next to each other. So, the following two snippets would
    produce the same output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in mind, the `ProductsList` component could be written like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This is one possible approach for outputting list data. As explained earlier
    in this chapter, it’s all about using standard JavaScript features and combining
    those features with JSX.
  prefs: []
  type: TYPE_NORMAL
- en: However, it’s not necessarily the most common way of outputting list data in
    React apps. In most projects, you’ll encounter a different solution.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping List Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Outputting list data with `for` loops works, as you can see in the preceding
    examples. However, just as with `if` statements and ternary expressions, you can
    replace `for` loops with an alternative syntax to write less code and improve
    component readability.
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript offers a built-in array method that can be used to transform array
    items: the `map()` method. `map()` is a default method that can be called on any
    JavaScript array. It accepts a function as a parameter and executes that function
    for every array item. The return value of this function should be the transformed
    value. `map()` then combines all these returned, transformed values into a new
    array that is then returned by `map()` .'
  prefs: []
  type: TYPE_NORMAL
- en: 'You could use `map()` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `map()` is used to transform the array of user objects into
    an array of usernames (that is, an array of string values).
  prefs: []
  type: TYPE_NORMAL
- en: The `map()` method is often able to produce the same result as that of a `for`
    loop but with less code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, `map()` can also be used to generate an array of JSX elements and
    the `ProductsList` component from before could be rewritten like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This is already shorter than the earlier `for` loop example. However, just
    as with ternary expressions, the code can be shortened even more by moving the
    logic directly into the JSX code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Depending on the complexity of the transformation (that is, the complexity of
    the code executed inside the inner function, which is passed to the `map()` method),
    for readability reasons, you might want to consider not using this *inline* approach
    (such as when mapping array elements to some complex JSX structure or when performing
    extra calculations as part of the mapping process). Ultimately, this comes down
    to personal preference and judgment.
  prefs: []
  type: TYPE_NORMAL
- en: Because it’s very concise, using the `map()` method (either with the help of
    an extra variable or constant, or directly *inline* in the JSX code) is the de
    facto standard approach for outputting list data in React apps and JSX in general.
  prefs: []
  type: TYPE_NORMAL
- en: Updating Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine you have a list of data mapped to JSX elements and a new list item is
    added at some point. Or, consider a scenario in which you have a list wherein
    two list items swap places (that is, the list is reordered). How can such updates
    be reflected in the DOM?
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that React will take care of that for you if the update is
    performed in a stateful way (that is, by using React’s state concept, as explained
    in *Chapter 4* , *Working with Events and State* ).
  prefs: []
  type: TYPE_NORMAL
- en: However, there are a couple of important aspects to updating (stateful) lists
    you should be aware of.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a simple example that would **not** work as intended:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Initially, two to-do items would be displayed on the screen ( `<li>Learn React</li>`
    and `<li>Recommend this book</li>` ). But once the button is clicked and `handleAddTodo`
    is executed, the expected result of another to-do item being displayed will not
    materialize.
  prefs: []
  type: TYPE_NORMAL
- en: This is because executing `todos.push('A new todo')` will update the `todos`
    array, but React won’t notice it. Keep in mind that you must only update the state
    via the state updating function returned by `useState()` ; otherwise, React will
    not re-evaluate the component function.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how about this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This is also incorrect because the state updating function ( `setTodos` , in
    this case) should receive the new state (that is, the state that should be set)
    as an argument. However, the `push()` method doesn’t return the updated array.
    Instead, it mutates the existing array in place. Even if `push()` were to return
    the updated array, it would still be wrong to use the preceding code, because
    the data would be changed (mutated) behind the scenes before the state updating
    function would be executed. Since arrays are objects, and therefore reference
    data types, technically, data would be changed before informing React about that
    change. Following the React best practices, this should be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, when updating an array (or, as a side note, an object in general),
    you should perform this update in an **immutable** way (i.e., without changing
    the original array or object). Instead, a new array or object should be created.
    This new array can be based on the old array and contain all the old data, as
    well as any new or updated data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, the `todos` array should be updated like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: By using `concat()` or a new array, combined with the spread operator, a brand-new
    array is provided to the state updating function. Note also that a function is
    passed to the state updating function since the new state depends on the previous
    state.
  prefs: []
  type: TYPE_NORMAL
- en: When updating an array (or any object) state value like this, React is able
    to pick up those changes. Therefore, React will re-evaluate the component function
    and apply any required changes to the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: Immutability is not a React-specific concept, but it’s a key one in React apps
    nonetheless. When working with state and reference values (that is, objects and
    arrays), immutability is extremely important to ensure that React is able to pick
    up changes and no “invisible” (that is, not recognized by React) state changes
    are performed.
  prefs: []
  type: TYPE_NORMAL
- en: There are different ways of updating objects and arrays immutably, but a popular
    approach is to create new objects or arrays and then use the spread operator (
    `...` ) to merge existing data into those new arrays or objects.
  prefs: []
  type: TYPE_NORMAL
- en: A Problem with List Items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you’re following along with your own code, and you output list data as described
    in the previous sections, you might’ve noticed that React actually shows a warning
    in the browser developer tools console, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_05_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.4: React sometimes generates a warning regarding missing unique keys'
  prefs: []
  type: TYPE_NORMAL
- en: React is complaining about missing keys.
  prefs: []
  type: TYPE_NORMAL
- en: To understand this warning and the idea behind keys, it’s helpful to explore
    a specific use case and a potential problem with that scenario. Assume that you
    have a React component that is responsible for displaying a list of items—maybe
    a list of to-do items. In addition, assume that those list items can be reordered
    and that the list can be edited in other ways (for example, new items can be added,
    existing items can be updated or deleted, and so on). In other words, the list
    is not static.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example user interface, in which a new item is added to a list
    of to-do items:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_05_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.5: A list gets updated by inserting a new item at the top'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, you can see the initially rendered list ( *1* ), which
    is then updated after a user enters and submits a new to-do value ( *2* ). A new
    to-do item is added to the top of the list (that is, as the first item of the
    list) ( *3* ).
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: The example source code for this demo app can be found at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/05-lists-conditional-code/examples/02-keys](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/05-lists-conditional-code/examples/02-keys)
    .
  prefs: []
  type: TYPE_NORMAL
- en: If you work on this app and open the browser developer tools (and then the JavaScript
    console), you will see the “missing keys” warning that has been mentioned before.
    This app also helps with understanding where this warning is coming from.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Chrome DevTools, navigate to the **Elements** tab and select one of
    the to-do items or the empty to-do list (that is, the `<ul>` element). Once you
    add a new to-do item, any DOM elements that were inserted or updated are highlighted
    by Chrome in the **Elements** tab (by flashing briefly). Refer to the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_05_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.6: Updated DOM items are highlighted in the Chrome DevTools'
  prefs: []
  type: TYPE_NORMAL
- en: The interesting part is that not only the newly added to-do element (that is,
    the newly inserted `<li>` element) is flashing. Instead, **all** existing `<li>`
    elements, which reflect existing to-do items that were not changed, are highlighted
    by Chrome. This implies that all these other `<li>` elements were also updated
    in the DOM—even though there was no need for that update. The items existed before,
    and their content (the to-do text) didn’t change.
  prefs: []
  type: TYPE_NORMAL
- en: For some reason, React seems to destroy the existing DOM nodes (that is, the
    existing `<li>` items), just to then recreate them immediately. This happens for
    every new to-do item that is added to the list. As you might imagine, this is
    not very efficient and can cause performance problems for more complex apps that
    might be rendering dozens or hundreds of items across multiple lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'This happens because React has no way of knowing that only one DOM node should
    be inserted. It cannot tell that all other DOM nodes should stay untouched because
    React only received a brand-new state value: a new array, filled with new JavaScript
    objects. Even if the content of those objects didn’t change, they are technically
    still new objects (new values in memory).'
  prefs: []
  type: TYPE_NORMAL
- en: As the developer, you know how your app works and that the content of the to-do
    array didn’t actually change that much. But React doesn’t know that. Therefore,
    React determines that all existing list items ( `<li>` items) must be discarded
    and replaced by new items that reflect the new data that was provided as part
    of the state update. That is why **all** list-related DOM nodes are updated (that
    is, destroyed and recreated) for every state update.
  prefs: []
  type: TYPE_NORMAL
- en: Keys to the Rescue!
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The problem outlined previously is an extremely common one. Most list updates
    are incremental updates, not bulk changes. But React can’t tell whether that is
    the case for your use case and your list.
  prefs: []
  type: TYPE_NORMAL
- en: That’s why React uses the concept of **keys** when working with list data and
    rendering list items. Keys are simply unique identifier values that can (and should)
    be attached to JSX elements when rendering list data. Keys help React identify
    elements that were rendered before and didn’t change. By allowing the unique identification
    of all list elements, keys also help React to move (list item) DOM elements around
    efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keys are added to JSX elements via the special built-in `key` prop that is
    accepted by every component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This special prop can be added to all components, be they built-in or custom.
    You don’t need to accept or handle the `key` prop in any way on your custom components;
    React will do that for you automatically.
  prefs: []
  type: TYPE_NORMAL
- en: The `key` prop requires a value that is unique for every list item. No two list
    items should have the same key. In addition, good keys are directly attached to
    the underlying data that makes up the list item. Therefore, list item indexes
    are poor keys because the index isn’t attached to the list item data. If you reorder
    items in a list, the indexes stay the same (an array always starts with index
    `0` , followed by `1` , and so on) but the data is changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `'Sports'` has the index `0` in the `hobbies` array. In the
    `reversed` array, its index would be `1` (because it’s the second item now). In
    this case, if the index were used as a key, the data would not be attached to
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Good keys are unique `id` values, such that every `id` belongs to exactly one
    value. If that value moves or is removed, its `id` should move or disappear with
    that value.
  prefs: []
  type: TYPE_NORMAL
- en: Finding good `id` values typically isn’t a huge problem since most list data
    is fetched from databases anyway. No matter whether you’re dealing with products,
    orders, users, or shopping cart items, it’s all data that would typically be stored
    in a database. This kind of data already has unique `id` values since you always
    have some kind of unique identification criteria when storing data in databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, even the values themselves can be used as keys. Consider the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Hobbies are `string` values, and there is no unique `id` value attached to
    individual hobbies. Every hobby is a primitive value (a `string` ). However, in
    cases like this, you typically won’t have duplicate values as it doesn’t make
    sense for a hobby to be listed more than once in an array like this. Therefore,
    the values themselves qualify as good keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In cases where you can’t use the values themselves and there is no other possible
    key value, you can generate unique `id` values directly in your React app code.
    As a last resort, you can also fall back to using indexes; but be aware that this
    can lead to unexpected bugs and side effects if you reorder list items.
  prefs: []
  type: TYPE_NORMAL
- en: With keys added to list item elements, React is able to identify all items correctly.
    When the component state changes, it can identify JSX elements that were rendered
    before already. Those elements are therefore not destroyed or recreated anymore.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can confirm this by again opening the browser DevTools to check which DOM
    elements are updated upon changes to the underlying list data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_05_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.7: From multiple list items, only one DOM element gets updated'
  prefs: []
  type: TYPE_NORMAL
- en: After adding keys, when updating the list state, only the new DOM item is highlighted
    in the Chrome DevTools. The other items are (correctly) ignored by React.
  prefs: []
  type: TYPE_NORMAL
- en: Summary and Key Takeaways
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like any other JavaScript value, JSX elements can be set and changed dynamically,
    based on different conditions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Content can be set conditionally via `if` statements, ternary expressions, the
    logical “and” operator ( `&&` ), or in any other way that works in JavaScript.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are multiple ways to handle conditional content—any approach that would
    work in vanilla JavaScript can also be used in React apps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays with JSX elements can be inserted into JSX code and will lead to the
    array elements being outputted as sibling DOM elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List data can be converted into JSX element arrays via `for` loops, the `map()`
    method, or any other JavaScript approach that leads to a similar conversion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `map()` method is the most common way of converting list data to JSX
    element lists.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keys (via the `key` prop) should be added to the list JSX elements to help React
    update the DOM efficiently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What’s Next?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With conditional content and lists, you now have all the key tools needed to
    build both simple and more complex user interfaces with React. You can hide and
    show elements or groups of elements as needed, and you can dynamically render
    and update lists of elements to output lists of products, orders, or users.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, that’s not all that’s needed to build realistic user interfaces.
    Adding logic for changing content dynamically is one thing, but most web apps
    also need CSS styling that should be applied to various DOM elements. This book
    is not about CSS, but the next chapter will still explore how React apps can be
    styled. Especially when it comes to setting and changing styles dynamically or
    scoping styles to specific components, there are various React-specific concepts
    that should be familiar to every React developer.
  prefs: []
  type: TYPE_NORMAL
- en: Test Your Knowledge!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Test your knowledge about the concepts covered in this chapter by answering
    the following questions. You can then compare your answers to examples that can
    be found at [https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/05-lists-conditional-code/exercises/questions-answers.md](https://github.com/mschwarzmueller/book-react-key-concepts-e2/blob/05-lists-conditional-code/exercises/questions-answers.md)
    :'
  prefs: []
  type: TYPE_NORMAL
- en: What is “conditional content”?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name at least two different ways of rendering JSX elements conditionally.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which elegant approach can be used to define element tags conditionally?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What’s a potential downside of using only ternary expressions (for conditional
    content)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can lists of data be rendered as JSX elements?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should keys be added to rendered list items?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give one example each for a good and a bad key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply What You Learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You are now able to use your React knowledge to change dynamic user interfaces
    in a variety of ways. Besides being able to change displayed text values and numbers,
    you can now also hide or show entire elements (or chunks of elements) and display
    lists of data.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, you will find two activities that allow you to apply
    your newly gained knowledge (combined with the knowledge gained in the other book
    chapters).
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 5.1: Showing a Conditional Error Message'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, you’ll build a basic form that allows users to enter their
    email address. Upon form submission, the user input should be validated and invalid
    email addresses (for simplicity, here email addresses that contain no `@` sign
    are being referred to) should lead to an error message being shown below the form.
    When invalid email addresses are made valid, potentially visible error messages
    should be removed again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Build a user interface that contains a form with a label, an input field (of
    the text type—to make entering incorrect email addresses easier for demo purposes),
    and a submit button that leads to the form being submitted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Collect the entered email address and show an error message below the form if
    the email address contains no `@` sign.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final user interface should look and work as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_05_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.8: The final user interface of this activity'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Styling will, of course, differ. To get the same styling as shown in the screenshot,
    use my prepared starting project, which you can find here: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/05-lists-conditional-code/activities/practice-1-start](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/05-lists-conditional-code/activities/practice-1-start)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Analyze the `index.css` file in that project to determine how to structure your
    JSX code to apply the styles.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the full example solution here: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/05-lists-conditional-code/activities/practice-1](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/05-lists-conditional-code/activities/practice-1)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 5.2: Outputting a List of Products'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, you will build a user interface where a list of (dummy) products
    is displayed on the screen. The interface should also contain a button that, when
    clicked, adds another new (dummy) item to the existing list of products.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a list of dummy product objects (every object should have an ID, title,
    and price) to a React component and add code to output these product items as
    JSX elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a button to the user interface. When clicked, the button should add a new
    product object to the product data list. This should then cause the user interface
    to update and display an updated list of product elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final user interface should look and work as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/B31339_05_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.9: The final user interface of this activity'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Styling will, of course, differ. To get the same styling as shown in the screenshot,
    use my prepared starting project, which you can find here: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/05-lists-conditional-code/activities/practice-2-start](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/05-lists-conditional-code/activities/practice-2-start)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Analyze the `index.css` file in that project to determine how to structure your
    JSX code to apply the styles.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the full example solution here: [https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/05-lists-conditional-code/activities/practice-2](https://github.com/mschwarzmueller/book-react-key-concepts-e2/tree/05-lists-conditional-code/activities/practice-2)
    .'
  prefs: []
  type: TYPE_NORMAL
