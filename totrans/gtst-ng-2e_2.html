<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;The Building Blocks of an Angular Application"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. The Building Blocks of an Angular Application</h1></div></div></div><p>In the previous chapter, we looked at the drivers for the design decisions behind the new Angular. We described the main reasons that led to the development of a brand new framework; Angular takes advantage of the newest Web standards while keeping the past lessons in mind. Although we are familiar with the main drivers, we still haven't described the core Angular concepts. The last major release of the framework took a different path from AngularJS and introduced a lot of changes in the fundamental building blocks used for the development of single-page applications.</p><p>The mission of this chapter is to describe the framework's core and make a brief introduction to its main concepts. In the next couple of pages, we will also make an overview of how these concepts can be put together to help us build professional user interfaces for our Web applications. The subsequent sections will give us an overview of everything that we will learn in more detail later in this book.</p><p>In this chapter, we will take a look at the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A conceptual overview of the framework, showing how different concepts relate to each other.</li><li class="listitem" style="list-style-type: disc">How we can build a user interface as a composition of components.</li><li class="listitem" style="list-style-type: disc">What path the directives took in the new versions of Angular, and how their interface changed compared to the previous major version of the framework.</li><li class="listitem" style="list-style-type: disc">The reasons for the enforced separation of concerns, which led to the decomposition of the directives into two different concepts. In order to get a better sense of them, we will demonstrate basic syntax for their definition.</li><li class="listitem" style="list-style-type: disc">An overview of the improved change detection, and how it involves the context that directives provide.</li><li class="listitem" style="list-style-type: disc">What zones are, and how they can make our daily development process easier.</li><li class="listitem" style="list-style-type: disc">What pipes are, and how they are related to the AngularJS filters.</li><li class="listitem" style="list-style-type: disc">Introduction to the brand new <span class="strong"><strong>dependency injection</strong></span> (<span class="strong"><strong>DI</strong></span>) mechanism in Angular and how it is related to the services.</li></ul></div><div class="section" title="A conceptual overview of Angular"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec12"/>A conceptual overview of Angular</h1></div></div></div><p>Before we dive into the different parts of Angular, let's get a conceptual overview of how everything fits together. Let's take a look at the following diagram:</p><p>
</p><div class="mediaobject"><img alt="A conceptual overview of Angular" src="graphics/5081_02_01.jpg"/></div><p>
</p><p>Figure 1</p><p>
<span class="emphasis"><em>Figure 1</em></span> to <span class="emphasis"><em>Figure 4</em></span> show the main Angular concepts and the connections between them. The main purpose of these diagrams is to illustrate the core blocks for building single-page applications with Angular, and their relations.</p><p>The <span class="strong"><strong>Component</strong></span> is the main building block we will use to create the user interface of our applications with Angular. The <span class="strong"><strong>Component</strong></span> is a direct successor of the <span class="strong"><strong>Directive</strong></span>, which is the primitive for attaching behavior to the DOM. Components extend <span class="strong"><strong>Directives</strong></span> by providing further features, such as a template, which can be used to render composition of directives. Inside the template of the view can reside different expressions.</p><p>
</p><div class="mediaobject"><img alt="A conceptual overview of Angular" src="graphics/5081_02_02.jpg"/></div><p>
</p><p>Figure 2</p><p>The preceding diagram conceptually illustrates the <span class="strong"><strong>Change Detection</strong></span> mechanism of Angular. It performs dirty checking, which evaluates the registered expressions in the context of specific UI components. Since the concept of scope has been removed from Angular, the execution context of the expressions are the instances of the controllers of the components associated with them.</p><p>The <span class="strong"><strong>Change Detection</strong></span> mechanism can be enhanced using <span class="strong"><strong>Differs</strong></span>; that's why there's a direct relation between these two elements on the diagram.</p><p>
<span class="strong"><strong>Pipes</strong></span> are another component of Angular. We can think of Pipes as the filters from AngularJS. Pipes can be used together with components. We can include them in the expressions, which are defined in the context of any component.</p><p>
</p><div class="mediaobject"><img alt="A conceptual overview of Angular" src="graphics/5081_02_03.jpg"/></div><p>
</p><p>Figure 3</p><p>Now let's take a look at the preceding diagram. <span class="strong"><strong>Directives</strong></span> and <span class="strong"><strong>Components</strong></span> delegate the business logic to <span class="strong"><strong>Services</strong></span>. This enforces better separation of concerns, maintainability, and code reusability. <span class="strong"><strong>Directives</strong></span> receive references to instances of specific services declared as dependencies using the <span class="strong"><strong>DI</strong></span> mechanism of the framework, and delegate the execution of the business-related logic to them. Both <span class="strong"><strong>Directives</strong></span> and <span class="strong"><strong>Components</strong></span> may use the <span class="strong"><strong>DI</strong></span> mechanism, not only to inject services but also to inject DOM elements and/or other <span class="strong"><strong>Components</strong></span> or <span class="strong"><strong>Directives</strong></span>.</p><p>
<span class="strong"><strong>Modules</strong></span> (also known as <span class="strong"><strong>NgModules</strong></span>) are a core concept which combines the building blocks into separate, logically related, groups. NgModules are quite similar to the AngularJS modules but bring more semantics on top. Note that NgModules are different from the ES2015 modules that we described in <a class="link" href="ch03.html" title="Chapter 3. TypeScript Crash Course">Chapter 3</a>, <span class="emphasis"><em>TypeScript Crash Course</em></span>. The Angular modules are a framework feature, in contrast to ES2015 modules which are a language construct.</p><p>NgModules have the following responsibilities:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Provide context of the Angular template compiler.</li><li class="listitem" style="list-style-type: disc">Provide a level of encapsulation where we can have components or directives, which are used only within the boundaries of a given module.</li><li class="listitem" style="list-style-type: disc">In NgModules, we can configure the providers for the DI mechanism of the framework.</li></ul></div><p>
</p><div class="mediaobject"><img alt="A conceptual overview of Angular" src="graphics/5081_02_04.jpg"/></div><p>
</p><p>Figure 4</p><p>Lastly, the new router is used to define the routes in our application. Since <span class="strong"><strong>Directives</strong></span> do not own a template, only the <span class="strong"><strong>Components</strong></span> can be rendered by the router, representing the different views in our application. The router also uses a set of predefined directives, which allow us to define hyperlinks between the different views and the container where they should be rendered.</p><p>Now, we will look more closely at these concepts, see how they work together to make Angular applications, and how they've changed from their AngularJS predecessors.</p></div></div>
<div class="section" title="Changing directives"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec13"/>Changing directives</h1></div></div></div><p>AngularJS introduced the concept of directives in the development of single-page applications. The purpose of directives is to encapsulate the DOM-related logic and allow us to build user interfaces by composing them. This way, we are able to extend the syntax and the semantics of HTML. Initially, like most innovative concepts, directives were viewed controversially because they predispose us to write invalid HTML when using custom elements or attributes without the <code class="literal">data-</code> prefix. However, over time, this concept has gradually been accepted and has proved that it is here to stay.</p><p>Another drawback of the implementation of directives in AngularJS is the different ways we can use them. This requires an understanding of the attribute values, which can be literals, expressions, callbacks, or microsyntax. This makes tooling essentially impossible.</p><p>The latest versions of Angular keep the concept of directives, but take the best parts from AngularJS and add some new ideas and syntax to it. The main purpose of Angular's directives is to attach behavior to the DOM by extending it with custom logic defined in an ES2015 class. We can think of these classes as controllers associated to the directives and think of their constructors as similar to the linking function of the directives from AngularJS. However, the new directives have limited configurability. They do not allow to associate a template with them, which makes most of the already known properties for defining directives unnecessary. The simplicity of the API does not limit directives' behavior, but only enforces stronger separation of concerns. To complement this simpler API, Angular 2 introduced a richer interface for the definition of UI elements, called components. Components extend the functionality of directives by allowing them to own a template, through the<span class="strong"><strong> component metadata</strong></span>. We will take a further look at components later in this book.</p><p>The syntax used for Angular directives involves ES2016 decorators. We can use TypeScript, ES2015, or even <span class="strong"><strong>ECMAScript</strong></span>
<span class="strong"><strong>5</strong></span> (<span class="strong"><strong>ES5</strong></span>) in order to achieve the same result with a little bit more typing. This code defines a simple directive, written in TypeScript:</p><pre class="programlisting">@Directive({ selector: '[tooltip]' })&#13;
export class Tooltip { &#13;
  @Input() tooltip: string; &#13;
  private overlay: Overlay;&#13;
 &#13;
  constructor(private el: ElementRef, manager: OverlayManager) { &#13;
    this.overlay = manager.get(); &#13;
  }&#13;
 &#13;
  @HostListener('mouseenter') onMouseEnter() { &#13;
    this.overlay.open(this.el.nativeElement, this.tooltip); &#13;
  }&#13;
 &#13;
  @HostListener('mouseleave') onMouseLeave() { &#13;
    this.overlay.close(); &#13;
  } &#13;
} &#13;
</pre><p>The directive can be used with the following markup in our template:</p><pre class="programlisting">&lt;div tooltip="42"&gt;Tell me the answer!&lt;/div&gt; &#13;
</pre><p>Once the user points over the label, <span class="strong"><strong>Tell me the answer!</strong></span>, Angular will invoke the method defined under the <code class="literal">@HostListener</code> decorator in the directive's definition. In the end, the <code class="literal">open</code> method of the overlay manager will be executed.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note5"/>Note</h3><p>Since we can have multiple directives on a single element, the best practices state that we should use an attribute as a selector.</p></div></div><p>An alternative ECMAScript 5 syntax for the definition of this directive is as follows:</p><pre class="programlisting">var Tooltip = ng.core.Directive({ &#13;
  selector: '[tooltip]', &#13;
  inputs: ['tooltip'], &#13;
  host: { &#13;
    '(mouseenter)': 'onMouseEnter()', &#13;
    '(mouseleave)': 'onMouseLeave()' &#13;
  } &#13;
}) &#13;
.Class({ &#13;
  constructor: [ng.core.ElementRef, Overlay, function (tooltip, el, manager) { &#13;
    this.el = el; &#13;
    this.overlay = manager.get(); &#13;
  }], &#13;
  onMouseEnter() { &#13;
    this.overlay.open(this.el.nativeElement, this.tooltip); &#13;
  }, &#13;
  onMouseLeave() { &#13;
    this.overlay.close(); &#13;
  } &#13;
}); &#13;
</pre><p>The preceding ES5 syntax demonstrates the internal JavaScript DSL that Angular provides in order to allow us to write our code without the syntax, which is not yet supported by modern browsers.</p><p>We can summarize that Angular kept the concept of directives by maintaining the idea of attaching behavior to the DOM. The core differences with AngularJS are the new syntax, and the further separation of concerns introduced by bringing the components. In <a class="link" href="ch04.html" title="Chapter 4. Getting Started with Angular Components and Directives">
Chapter 4</a>, <span class="emphasis"><em>Getting Started with Angular Components and Directives</em></span>, we will take a further look at directives' API. We'll also compare the directives' definition syntax using ES2016 and ES5. Now, let's take a look at the big change to Angular components.</p></div>
<div class="section" title="Getting to know Angular components"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Getting to know Angular components</h1></div></div></div><p>
<span class="strong"><strong>Model View Controller</strong></span> (<span class="strong"><strong>MVC</strong></span>) is a micro-architectural pattern initially introduced for the implementation of user interfaces. As Angular developers, we use different variations of this pattern on a daily basis, most often <span class="strong"><strong>Model View ViewModel</strong></span> (<span class="strong"><strong>MVVM</strong></span>). In MVC, we have the model, which encapsulates the business logic of our application, and the view, which is responsible for rendering the user interface, accepting user input, and delegating the user interaction logic to the controller. The view is represented as composition of components, which is formally known as the <span class="strong"><strong>composite design pattern</strong></span>.</p><p>Let's take a look at the following structural diagram, which shows the composite design pattern:</p><p>
</p><div class="mediaobject"><img alt="Getting to know Angular components" src="graphics/5081_02_05.jpg"/></div><p>
</p><p>Figure 5</p><p>Here, we have three classes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An abstract class called <code class="literal">Component</code>.</li><li class="listitem" style="list-style-type: disc">Two concrete classes called <code class="literal">Leaf</code> and <code class="literal">Composite</code>. The <code class="literal">Leaf</code> class is a simple terminal component in the component tree that we will build soon.</li></ul></div><p>The <code class="literal">Component</code> class defines an abstract operation called <code class="literal">operation</code>. Both <code class="literal">Leaf</code> and <code class="literal">Composite</code> inherit from the <code class="literal">Component</code> class. However, the <code class="literal">Composite</code> class also owns references to it. We can take this even further and allow <code class="literal">Composite</code> to own a list of references to instances of <code class="literal">Component</code>, as shown in the diagram. The components list inside <code class="literal">Composite</code> can hold references to different <code class="literal">Composite</code> or <code class="literal">Leaf</code> instances, or instances of other classes, which extend the <code class="literal">Component</code> class or any of its successors. We can have a different behavior of the <code class="literal">operation</code> methods of the individual <code class="literal">Component</code> instances invoked within the implementation of the <code class="literal">operation</code> method of <code class="literal">Composite</code>. This is because of the late-binding mechanism used for the implementation of polymorphism in object-oriented programming languages.</p><div class="section" title="Components in action"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec15"/>Components in action</h2></div></div></div><p>Enough of theory! Let's build a component tree based on the class hierarchy illustrated in the preceding diagram. This way, we will demonstrate how we can take advantage of the composite pattern for building user interface using simplified syntax. We will take a look at a similar example in the context of Angular in <a class="link" href="ch04.html" title="Chapter 4. Getting Started with Angular Components and Directives">
Chapter 4</a>, <span class="emphasis"><em>Getting Started with Angular Components and Directives</em></span>:</p><pre class="programlisting">Composite c1 = new Composite(); &#13;
Composite c2 = new Composite(); &#13;
Composite c3 = new Composite(); &#13;
 &#13;
c1.components.push(c2); &#13;
c1.components.push(c3); &#13;
 &#13;
Leaf l1 = new Leaf(); &#13;
Leaf l2 = new Leaf(); &#13;
Leaf l3 = new Leaf(); &#13;
 &#13;
c2.components.push(l1); &#13;
c2.components.push(l2); &#13;
 &#13;
c3.components.push(l3); &#13;
</pre><p>The preceding pseudo-code creates three instances of the <code class="literal">Composite</code> class and three instances of the <code class="literal">Leaf</code> class. The <code class="literal">c1</code> instance holds references to <code class="literal">c2</code> and <code class="literal">c3</code> inside the components list. The <code class="literal">c2</code> instance holds references to <code class="literal">l1</code> and <code class="literal">l2</code>, and <code class="literal">c3</code> holds reference to <code class="literal">l3</code>:</p><p>
</p><div class="mediaobject"><img alt="Components in action" src="graphics/5081_02_06.jpg"/></div><p>
</p><p>Figure 6</p><p>The preceding diagram is a graphical representation of the component tree we built in the snippet. This is a simplified version of what the view in the modern JavaScript frameworks looks similar to. However, it illustrates the very basics of how we can compose directives and components. For instance, in the context of Angular, we can think of directives as instances of the <code class="literal">Leaf</code> class (since they don't own view and, thus, cannot compose other directives and components) and components as instances of the <code class="literal">Composite</code> class.</p><p>If we think more abstractly for the user interface in AngularJS, we can notice that we used quite a similar approach. The templates of our views compose different directives together in order to deliver a fully functional user interface to the end user of our application.</p></div><div class="section" title="Components in Angular"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec16"/>Components in Angular</h2></div></div></div><p>Angular took this approach by introducing new building blocks called components. Components extend the directive concept we described in the previous section and provide a broader functionality. Here is the definition of a basic "Hello world" component:</p><pre class="programlisting">@Component({ &#13;
  selector: 'hello-world', &#13;
  template: '&lt;h1&gt;Hello, {{target}}!&lt;/h1&gt;' &#13;
}) &#13;
class HelloWorld { &#13;
  target: string; &#13;
  constructor() { &#13;
    this.target = 'world'; &#13;
  } &#13;
} &#13;
</pre><p>We can use it by inserting the following markup in our view:</p><pre class="programlisting">&lt;hello-world&gt;&lt;/hello-world&gt; &#13;
</pre><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note6"/>Note</h3><p>According to the best practices, we should use a selector of type element for components since we may have only a single component per DOM element.</p></div></div><p>The alternative ES5 syntax Angular provides using the DSL is as follows:</p><pre class="programlisting">var HelloWorld = ng.core &#13;
  .Component({ &#13;
    selector: 'hello-world', &#13;
    template: '&lt;h1&gt;Hello, {{target}}!&lt;/h1&gt;' &#13;
  }) &#13;
  .Class({ &#13;
    constructor: function () { &#13;
      this.target = 'world'; &#13;
    } &#13;
  }); &#13;
</pre><p>We will take a look at the preceding syntax in more detail later in this book. Now let's briefly describe the functionality that this component provides. Once the Angular application is bootstrapped, it will look at all the elements in the DOM tree and process them. When it finds an element called <code class="literal">hello-world</code>, it will invoke the logic associated with its definition, which means that the template of the component will be rendered and the expression between the curly brackets will be evaluated. This will result in the markup, <code class="literal">&lt;h1&gt;Hello, world!&lt;/h1&gt;</code>.</p><p>So, to summarize, the Angular core team separated out the directives from AngularJS into two different parts-components and directives. Directives provide an easy way to attach behavior to DOM elements without defining a view. Components in Angular provide a powerful, and yet simple-to-learn API, which makes it easier to define the user interface of our applications. Angular components allow us to do the same amazing things as AngularJS directives, but with less typing and fewer things to learn. Components extend the Angular directive concept by adding a view to it. We can think of the relation between Angular components and directives the same way as the relation between <code class="literal">Composite</code> and <code class="literal">Leaf</code> from the diagram we saw in <span class="emphasis"><em>Figure 5</em></span>.</p><p>Conceptually, we can present the relation between Directive and Component as inheritance. <a class="link" href="ch04.html" title="Chapter 4. Getting Started with Angular Components and Directives">
Chapter 4</a>, <span class="emphasis"><em>Getting Started with Angular Components and Directives</em></span>, describes these two concepts in further detail.</p></div></div>
<div class="section" title="Angular modules"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Angular modules</h1></div></div></div><p>In AngularJS, we have the concept of modules. Modules there are responsible for grouping pieces of related functionality together and registering it internally during the bootstrap process. Unfortunately, they didn't provide features such as encapsulation and lazy loading.</p><p>Angular introduced the NgModules as part of the fifth release candidate of the framework. The main purpose of the new modules is to give a context for the Angular compiler and achieve a good level of encapsulation. For instance, if we are building a library with NgModules, we can have a number of declarations, which are used internally but not exported as part of the public interface. Let's take a look at the following example:</p><pre class="programlisting">import {NgModule} from '@angular/core';&#13;
import {CommonModule} from '@angular/common';&#13;
import {TabComponent} from './tab.component';&#13;
import {TabItemComponent} from './tab-item.component';&#13;
&#13;
@NgModule({&#13;
  imports: [CommonModule],&#13;
  declarations: [TabComponent, TabItemComponent],&#13;
  exports: [TabComponent]&#13;
})&#13;
class TabModule { }</pre><p>Do not worry if you're not familiar with the TypeScript syntax in the preceding example; we will take a deep dive into the language in the next chapter.</p><p>In the preceding code snippet, using the <code class="literal">@NgModule</code> decorator, we declare <code class="literal">TabModule</code>. Note that in the list of <code class="literal">declarations</code>, we include both <code class="literal">TabComponent</code> and <code class="literal">TabItemComponent</code>, but in the list of <code class="literal">exports</code>, we have only <code class="literal">TabComponent</code>. This way, we can achieve a level of encapsulation for our library. The users of the module will be able to use only <code class="literal">TabComponent</code>, so we don't have to worry about backward compatibility of the API of <code class="literal">TabItemComponent</code> since it's accessible only internally, within the boundaries of our module. Finally, by setting the <code class="literal">imports</code> property of the object literal passed to <code class="literal">@NgModule</code>, we can list modules that we want to use inside of the current module. This way, we will be able to take advantage of all the <code class="literal">exports</code> and <code class="literal">providers</code> (we'll discuss providers in <a class="link" href="ch05.html" title="Chapter 5. Dependency Injection in Angular">Chapter 5</a>, <span class="emphasis"><em>Dependency Injection in Angular</em></span>) declared by them.</p><div class="section" title="Bootstrapping an Angular application"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec17"/>Bootstrapping an Angular application</h2></div></div></div><p>Similar to AngularJS, before our application gets rendered, it goes through the bootstrap process. In the new Angular, we can bootstrap an application in different ways, depending on the used platform (for instance, web, NativeScript, with JiT or AoT compilation enabled, and so on). Let's take a look at a simple example, of how we can bootstrap a Web app, in order to get a better understanding of how the new Angular modules can be used in the process:</p><pre class="programlisting">import {NgModule} from '@angular/core';&#13;
import {platformBrowserDynamic} from '@angular/platform-browser-dynamic';&#13;
import {BrowserModule} from '@angular/platform-browser';&#13;
&#13;
import {AppComponent} from './app.component';&#13;
&#13;
@NgModule({&#13;
  imports: [BrowserModule],&#13;
  bootstrap: [AppComponent],&#13;
  declarations: [AppComponent],&#13;
})&#13;
export class AppModule {}&#13;
&#13;
platformBrowserDynamic().bootstrapModule(AppModule);</pre><p>In the <code class="literal">@NgModule</code> decorator in the preceding example, we declare <code class="literal">AppComponent</code> and we also import <code class="literal">BrowserModule</code>. Note that this time, we provide value to the <code class="literal">bootstrap</code> property where we explicitly declare that we want <code class="literal">AppComponent</code> to be used for bootstrapping our application.</p><p>On the last line of the file, we invoke the <code class="literal">bootstrapModule</code> method of the object returned by the invocation of <code class="literal">platformBrowserDynamic</code> with argument <code class="literal">AppModule</code>.</p><p>In recap, the modules in Angular have an important role-they not only group the building blocks of our application logically but also provide a way we can achieve encapsulation. Last, but not least, NgModules are heavily used in the application's bootstrap process.</p></div></div>
<div class="section" title="Pipes"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Pipes</h1></div></div></div><p>In business applications, we often need to have different visual representations of the same piece of data. For example, if we have the number 100,000 and we want to format it as currency, most likely we won't want to display it as plain data; more likely, we'll want something like $100,000.</p><p>The responsibility for formatting data in AngularJS was assigned to filters. Another example for a data formatting requirement is when we use collections of items. For instance, if we have a list of items, we may want to filter it based on a predicate (a boolean function); in a list of numbers, we may want to display only the prime numbers. AngularJS has a filter called <code class="literal">filter</code>, which allows us to do this. However, the duplication of the names often leads to confusion. That's another reason the core team renamed the filter component to a <span class="strong"><strong>pipe</strong></span>.</p><p>The motivation behind the new name is the syntax used for pipes and filters:</p><pre class="programlisting">{{expression | decimal | currency}} &#13;
</pre><p>In the preceding example, we apply the pipes, <code class="literal">decimal</code>, and <code class="literal">currency</code>, to the value returned by the <code class="literal">expression</code>. The entire expression between the curly braces looks like Unix pipe syntax.</p><div class="section" title="Defining pipes"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Defining pipes</h2></div></div></div><p>The syntax for defining pipes is similar to the one used for the definition of modules, directives, and components. In order to create a new pipe, we can use the ES2015 decorator, <code class="literal">@Pipe</code>. It allows us to add metadata to a class, declaring it as a pipe. All we need to do is provide a name for the pipe and define the data formatting logic. There's also an alternative ES5 syntax, which can be used if we want to skip the process of transpilation.</p><p>During runtime, once the Angular expression interpreter finds out that a given expression includes a call of a pipe, it will retrieve it out of the pipes' collection allocated within the component and invoke it with appropriate arguments.</p><p>The following example illustrates how we can define a simple pipe called <code class="literal">lowercase1</code>, which transforms the given string, passed as argument to its lowercase representation:</p><pre class="programlisting">@Pipe({ name: 'lowercase1' }) &#13;
class LowerCasePipe1 implements PipeTransform { &#13;
  transform(value: string): string { &#13;
    if (!value) return value; &#13;
    if (typeof value !== 'string') { &#13;
      throw new Error('Invalid pipe value', value); &#13;
    } &#13;
    return value.toLowerCase(); &#13;
  } &#13;
} &#13;
</pre><p>In order to be consistent, let's show the ECMAScript 5 syntax for defining pipes:</p><pre class="programlisting">var LowercasePipe1 = ng.core &#13;
  .Pipe({ &#13;
    name: 'lowercase1' &#13;
  }) &#13;
  .Class({ &#13;
    constructor: function () {}, &#13;
    transform: function (value) { &#13;
      if (!value) return value; &#13;
      if (typeof value === 'string') { &#13;
        throw new Error('Invalid pipe value', value); &#13;
      } &#13;
      return value.toLowerCase(); &#13;
    } &#13;
  }); &#13;
</pre><p>Using the TypeScript syntax, we implement the <code class="literal">PipeTransform</code> interface and define the <code class="literal">transform</code> method declared inside it. However, in ECMAScript 5, we do not have support for interfaces, but we still need to implement the <code class="literal">transform</code> method in order to define a valid Angular pipe. We will explain the TypeScript interfaces in the next chapter.</p><p>Now, let's demonstrate how we can use the <code class="literal">lowercase1</code> pipe inside a component:</p><pre class="programlisting">@Component({ &#13;
  selector: 'app', &#13;
  template: '&lt;h1&gt;{{"SAMPLE" | lowercase1}}&lt;/h1&gt;' &#13;
}) &#13;
class App {} &#13;
&#13;
@NgModule({&#13;
  declarations: [App, LowerCasePipe1],&#13;
  bootstrap: [App],&#13;
  imports: [BrowserModule]&#13;
})&#13;
class AppModule {}&#13;
&#13;
platformBrowserDynamic().bootstrapModule(AppModule);</pre><p>Also, the alternative ECMAScript 5 syntax for this is as follows:</p><pre class="programlisting">var App = ng.core.Component({ &#13;
  selector: 'app', &#13;
  template: '&lt;h1&gt;{{"SAMPLE" | lowercase1}}&lt;/h1&gt;' &#13;
}) &#13;
.Class({ &#13;
  constructor: function () {} &#13;
}); &#13;
&#13;
var AppModule = ng.core.NgModule({&#13;
  declarations: [App, LowerCasePipe1],&#13;
  bootstrap: [App],&#13;
  imports: [BrowserModule]&#13;
})&#13;
.Class({&#13;
  constructor: function {}&#13;
});&#13;
&#13;
ng.platformBrowserDynamic&#13;
 .platformBrowserDynamic()&#13;
 .bootstrapModule(AppModule);&#13;
&#13;
</pre><p>We can use the <code class="literal">App</code> component with the following markup:</p><pre class="programlisting">   &lt;app&gt;&lt;/app&gt; &#13;
</pre><p>The result we will see on the screen is the text sample within an <code class="literal">h1</code> element. Note that we're including a reference to the <code class="literal">LowerCasePipe1</code> in the <code class="literal">declarations</code> property of the <code class="literal">@NgModule</code> decorator.</p><p>By keeping the data formatting logic as a separate component, Angular keeps the strong separation of concerns that can be seen throughout. We will take a look at how we can define stateful and stateless pipes for our application in <a class="link" href="ch07.html" title="Chapter 7. Explaining Pipes and Communicating with RESTful Services">
Chapter 7</a>, <span class="emphasis"><em>Explaining Pipes and Communicating with RESTful Services</em></span>.</p></div></div>
<div class="section" title="Improving change detection"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Improving change detection</h1></div></div></div><p>As we saw earlier, the view in MVC updates itself, based on change events it receives from the model. A number of <span class="strong"><strong>Model View Whatever</strong></span> (<span class="strong"><strong>MVW</strong></span>) frameworks took this approach and embedded the observer pattern in the core of their change detection mechanism.</p><div class="section" title="Classical change detection"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Classical change detection</h2></div></div></div><p>Let's take a look at a simple example, which doesn't use any framework. Suppose, we have a model called <code class="literal">User</code>, which has a property called <code class="literal">name</code>:</p><pre class="programlisting">class User extends EventEmitter { &#13;
  private name: string;&#13;
 &#13;
  setName(name: string) { &#13;
    this.name = name; &#13;
    this.emit('change');&#13;
  }&#13;
 &#13;
  getName(): string { &#13;
    return this.name;&#13;
  } &#13;
} &#13;
</pre><p>The preceding snippet again uses TypeScript. Do not worry if the syntax does not look familiar to you, we will make an introduction to the language in the next chapter.</p><p>The <code class="literal">user</code> class extends the <code class="literal">EventEmitter</code> class. This provides primitives for emitting and subscribing to events.</p><p>Now, let's define a view, which displays the <code class="literal">name</code> of an instance of the <code class="literal">User</code> class, passed as an argument to its <code class="literal">constructor</code>:</p><pre class="programlisting">class View { &#13;
  constructor(user: User, el: Element /* a DOM element */) { &#13;
    el.innerHTML = user.getName();&#13;
  } &#13;
} &#13;
</pre><p>We can initialize the <code class="literal">view</code> element by:</p><pre class="programlisting">let user = new User(); &#13;
user.setName('foo'); &#13;
let view = new View(user, document.getElementById('label')); &#13;
</pre><p>As the end result, the user will see a label with the content <span class="strong"><strong>foo</strong></span>. However, changes in user will not be reflected by the view. In order to update the view when the <code class="literal">name</code> of the user changes, we need to subscribe to the <code class="literal">change</code> event and then update the content of the DOM element. We need to update the <code class="literal">View</code> definition in the following way:</p><pre class="programlisting">class View { &#13;
  constructor(user:User, el:any /* a DOM element */) { &#13;
    el.innerHTML = user.getName(); &#13;
    user.on('change', () =&gt; { &#13;
      el.innerHTML = user.getName();&#13;
    }); &#13;
  } &#13;
} &#13;
</pre><p>This is how most frameworks used to implement their change detection before the era of AngularJS.</p></div><div class="section" title="Change detection in AngularJS"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec20"/>Change detection in AngularJS</h2></div></div></div><p>Most beginners are fascinated by the data binding mechanism in AngularJS. The basic "Hello world" example looks similar to this:</p><pre class="programlisting">function MainCtrl($scope) { &#13;
  $scope.label = 'Hello world!'; &#13;
}</pre><pre class="programlisting">&lt;body ng-app ng-controller="MainCtrl"&gt; &#13;
  {{label}} &#13;
&lt;/body&gt; &#13;
</pre><p>If you run this, <span class="strong"><strong>Hello world!</strong></span> magically appears on the screen. However, that is not the only most impressive thing! If we add a text input and we bind it to the <code class="literal">label</code> property of the scope, each change will reflect in the content displayed by the interpolation directive:</p><pre class="programlisting">&lt;body ng-controller="MainCtrl"&gt; &#13;
  &lt;input ng-model="label"&gt; &#13;
  {{label}} &#13;
&lt;/body&gt; &#13;
</pre><p>How awesome is that! This is one of the main selling points of AngularJS-the extreme ease of achieving data binding. We add a few attributes in our markup, interpolation directive, the <code class="literal">label</code> property to a mystical object called <code class="literal">$scope</code>, which is magically passed to a custom function we define, and everything simply works!</p><p>The more experienced Angular developer has a better understanding of what is actually going on behind the scenes. In the preceding example, inside the directives, <code class="literal">ng-model</code> and <code class="literal">ng-bind</code> (in our case, the interpolation directive, <code class="literal">{{}}</code>), Angular adds watchers with different behavior associated with the same expression - <code class="literal">label</code>. These watchers are quite similar to the observers in the classical MVC pattern. On some specific events (in our case, change of the content of the text input), AngularJS will loop over all such watchers, evaluate the expressions associated with them in the context of a given scope, and store their results. This loop is known as the <span class="strong"><strong>digest loop</strong></span>.</p><p>In the preceding examples, the evaluation of the expression, <code class="literal">label</code>, in the context of the scope will return the text, <span class="strong"><strong>Hello world!</strong></span>. On each iteration, AngularJS will compare the current result of the evaluation with the previous result and will invoke the associated callback in case the values differ. For instance, the callback added by the interpolation directive will set the content of the element to be the new result of the expression's evaluation. This is an example of the dependency between the callbacks of the watchers of two directives. The callback of the watcher added by <code class="literal">ng-model</code> modifies the result of the expression associated with the watcher added by the interpolation directive.</p><p>This approach has its own drawbacks. We said that the digest loop will be invoked on some specific events, but what if these events happen outside the framework; for example, what if we use <code class="literal">setTimeout</code>, and inside the callback, passed as the first argument, we change properties attached to the scope that we're watching? AngularJS will be unaware of the change and won't invoke the digest loop, so we need to do that explicitly using <code class="literal">$scope.$apply</code>. But, what if the framework knew about all the asynchronous events happening in the browser, such as user events, the <code class="literal">XMLHttpRequest</code> events, the <code class="literal">WebSocket</code>-related events, and others? In such a case, Angular would be able to intercept the event's handling and could invoke the digest loop without forcing us to do so!</p><div class="section" title="In the zone.js"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec0"/>In the zone.js</h3></div></div></div><p>That's exactly the case in the new versions of Angular. This functionality is implemented with zones using <code class="literal">zone.js</code>.</p><p>At ng-conf in 2014, Brian Ford gave a talk about zones. Brian presented zones as meta-monkey patching of browser APIs. Zone.js is a library developed by the Angular team, which implements zones in JavaScript. They represent an execution context, which allows us to intercept asynchronous browser calls. Basically, using zones, we are able to invoke a piece of logic just after the given <code class="literal">XMLHttpRequest</code> completes or when we receive a new <code class="literal">WebSocket</code> event. Angular took advantage of <code class="literal">zone.js</code> by intercepting asynchronous browser events and invoking the digest loop just at the right time. This totally eliminates the need for explicit calls of the digest loop by the developer using Angular.</p></div><div class="section" title="Simplified data flow"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec1"/>Simplified data flow</h3></div></div></div><p>The cross-watcher dependencies may create a tangled data flow in our application, which is hard to follow. This may lead to unpredictable behavior and bugs, which are hard to find. Although Angular kept the dirty checking as a way to achieve change detection, it enforced unidirectional data flow. This happened by disallowing dependencies between the different watchers, which allows the digest loop to be run only once. This strategy increases the performance of our applications dramatically and reduces the complexity of the data flow. Angular also made improvements to memory efficiency and the performance of the digest loop. Further details on Angular's change detection and the different strategies used for its implementation can be found in <a class="link" href="ch04.html" title="Chapter 4. Getting Started with Angular Components and Directives">
Chapter 4</a>, <span class="emphasis"><em>Getting Started with Angular Components and Directives</em></span>.</p></div></div><div class="section" title="Enhancing AngularJS's change detection"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Enhancing AngularJS's change detection</h2></div></div></div><p>Now, let's take a step back and again think about the change detection mechanism of the framework.</p><p>We said that inside the digest loop, Angular evaluates registered expressions and compares the evaluated values with the values associated with the same expressions in the previous iteration of the loop.</p><p>The most optimal algorithm used for the comparison may differ depending on the type of the value returned from the expression's evaluation. For instance, if we get a mutable list of items, we need to loop over the entire collection and compare the items in the collections one by one in order to verify if there is a change or not. However, if we have an immutable list, we can perform a check with a constant complexity, only by comparing references. This is the case because the instances of immutable data structures cannot change. Instead of applying an operation, which intends to modify such instances, we'll get a new reference with the modification applied.</p><p>In AngularJS, we can add watchers using a few methods. Two of them are <code class="literal">$watch(exp, fn, deep)</code> and <code class="literal">$watchCollection(exp, fn)</code>. These methods give us some level of control over the way the change detection will perform the equality check. For example, adding a watcher using <code class="literal">$watch</code> and passing a <code class="literal">false</code> value as a third argument will make AngularJS perform a reference check (that is, compare the current value with the previous one using <code class="literal">===</code>). However, if we pass a truthy (any <code class="literal">true</code> value), the check will be deep (that is, using <code class="literal">angular.equals</code>). This way, depending on the expected type of the return by the expression value, we can add listeners in the most appropriate way in order to allow the framework to perform equality checks with the most optimal algorithm available. This API has two limitations:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It does not allow you to choose the most appropriate equality check algorithm at runtime.</li><li class="listitem" style="list-style-type: disc">It does not allow you to extend the change detection to third parties for their specific data structures.</li></ul></div><p>The Angular core team assigned this responsibility to differs, allowing them to extend the change detection mechanism and optimize it, based on the data we use in our applications. Angular defines two base classes, which we can extend in order to define custom algorithms:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">KeyValueDiffer</code>: This allows us to perform advanced diffing over key value-based data structures.</li><li class="listitem" style="list-style-type: disc"><code class="literal">IterableDiffer</code>: This allows us to perform advanced diffing over list-like data structures.</li></ul></div><p>Angular allows us to take full control over the change detection mechanism by extending it with custom algorithms, which wasn't possible in the previous version of the framework. We'll take a further look into the change detection and how we can configure it in <a class="link" href="ch04.html" title="Chapter 4. Getting Started with Angular Components and Directives">
Chapter 4</a>, <span class="emphasis"><em>Getting Started with Angular Components and Directives</em></span>.</p></div></div>
<div class="section" title="Services"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Services</h1></div></div></div><p>Services are the building blocks that Angular provides for the definition of the business logic of our applications. In AngularJS, we had three different ways of defining services:</p><pre class="programlisting">// The Factory method &#13;
module.factory('ServiceName', function (dep1, dep2, ...) { &#13;
  return { &#13;
    // public API &#13;
  }; &#13;
}); &#13;
 &#13;
// The Service method &#13;
module.service('ServiceName', function (dep1, dep2, ...) { &#13;
  // public API &#13;
  this.publicProp = val; &#13;
}); &#13;
 &#13;
// The Provider method &#13;
module.provider('ServiceName', function () { &#13;
  return { &#13;
    $get: function (dep1, dep2, ...) { &#13;
      return { &#13;
        // public API &#13;
      }; &#13;
    } &#13;
  }; &#13;
}); &#13;
</pre><p>Although the first two syntactical variations provide similar functionality, they differ in the way the registered service will be instantiated. The third syntax allows further configuration of the registered provider during configuration time.</p><p>Having three different methods for defining services is quite confusing for the AngularJS beginners. Let's think for a second what necessitated the introduction of these methods for registering services. Why can't we simply use JavaScript constructor functions, object literals, or ES2015 classes instead, which Angular will not be aware of? We could encapsulate our business logic inside a custom JavaScript constructor function like this:</p><pre class="programlisting">function UserTransactions(id) { &#13;
  this.userId = id; &#13;
}&#13;
 &#13;
UserTransactions.prototype.makeTransaction = function (amount) { &#13;
  // method logic &#13;
}; &#13;
 &#13;
module.controller('MainCtrl', function () { &#13;
  this.submitClick = function () { &#13;
    new UserTransactions(this.userId).makeTransaction(this.amount); &#13;
  }; &#13;
}); &#13;
</pre><p>This code is completely valid. However, it doesn't take advantage of one of the key features that AngularJS provides: the DI mechanism. The <code class="literal">MainCtrl</code> function uses the constructor function, <code class="literal">UserTransaction</code>, which is visible in its body. The preceding code has two main pitfalls:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We're coupled with the logic used for the service's instantiation.</li><li class="listitem" style="list-style-type: disc">The code is not testable. In order to mock <code class="literal">UserTransactions</code>, we need to monkey patch it.</li></ul></div><p>How does AngularJS deal with these two things? When a given service is required, through the DI mechanism of the framework, AngularJS resolves all of its dependencies and instantiates it by passing it to a factory function, which encapsulates the logic for its creation. The factory function is passed as the second argument to the <code class="literal">factory</code> and <code class="literal">service</code> methods. The <code class="literal">provider</code> method allows the definition of a service on a lower level; the factory method there is the one under the <code class="literal">$get</code> property.</p><p>Just like AngularJS, the new versions of Angular tolerates this separation of concerns as well, so the core team kept the services. In contrast to AngularJS, the last major version of the framework provides a much simpler interface for their definition by allowing us to use plain ES2015 classes or ES5 constructor functions. We cannot escape from the fact that we need to explicitly state the services that should be available for injection and somehow specify instructions for their instantiation. In contrast to AngularJS, now the framework uses the ES2016 decorator's syntax for this purpose, instead of the methods familiar to us from AngularJS. This allows us to define the services in our applications as simple as ES2015 classes, with decorators for configuration of the DI:</p><pre class="programlisting">import {Injectable} from '@angular/core'; &#13;
 &#13;
@Injectable() &#13;
class HttpService { &#13;
  constructor() { /* ... */ } &#13;
} &#13;
 &#13;
@Injectable() &#13;
class User { &#13;
  constructor(private service: HttpService) {}&#13;
 &#13;
  save() { &#13;
    return this.service.post('/users') &#13;
      .then(res =&gt; { &#13;
        this.id = res.id; &#13;
        return this; &#13;
      }); &#13;
  } &#13;
} &#13;
</pre><p>This is the alternative ECMAScript 5 syntax:</p><pre class="programlisting">var HttpService = ng.core.Class({ &#13;
  constructor: function () {} &#13;
}); &#13;
var User = ng.core.Class({ &#13;
  constructor: [HttpService, function (service) { &#13;
    this.service = service; &#13;
  }], &#13;
  save: function () { &#13;
    return this.service.post('/users') &#13;
      .then(function (res) { &#13;
        this.id = res.id; &#13;
        return this; &#13;
      }); &#13;
  } &#13;
}); &#13;
</pre><p>Services are related to the components and the directives described in the previous sections. For developing highly coherent and reusable UI components, we need to move all the business-related logic to inside our services. Also, in order to develop testable components, we need to take advantage of the DI mechanism to resolve all their dependencies.</p><p>A core difference with the services in AngularJS is the way their dependencies are being resolved and represented internally. AngularJS uses strings to identify the different services and the associated factories used for their instantiation. On the other hand, now Angular uses keys instead. Usually, the keys are the types of the distinct services. Another core difference in the instantiation is the hierarchical structure of injectors, which encapsulate different dependency providers with different visibility.</p><p>Another distinction between the services in the last two major versions of the framework is the simplified syntax. Although the new versions of Angular use ES2015 classes for the definition of our business logic, we can use the ECMAScript 5 <code class="literal">constructor</code> functions as well or use the DSL provided by the framework. The DI in the latest versions of Angular has a completely different syntax and has improved behavior by providing a consistent way of injecting dependencies. The syntax used in the preceding example uses ES2016 decorators, and in <a class="link" href="ch05.html" title="Chapter 5. Dependency Injection in Angular">
Chapter 5</a>, <span class="emphasis"><em>Dependency Injection in Angular</em></span>, we'll take a look at alternative syntax, which uses ECMAScript 5. You can also find a more detailed explanation of Angular services and DI in <a class="link" href="ch05.html" title="Chapter 5. Dependency Injection in Angular">
Chapter 5</a>, <span class="emphasis"><em>Dependency Injection in Angular</em></span>.</p></div>
<div class="section" title="The new router"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>The new router</h1></div></div></div><p>In traditional Web applications, all the page changes are associated with a full-page reload, which fetches all of the referenced resources and data and renders the entire page onto the screen. However, requirements for Web applications have evolved over time.</p><p>
<span class="strong"><strong>Single-page applications</strong></span> (<span class="strong"><strong>SPAs</strong></span>) that we build with Angular simulate desktop user experiences. This often involves incremental loading of the resources and data required by the application, and no full-page reloads after the initial page load. Often, the different pages or views in SPAs are represented by different templates, which are loaded asynchronously and rendered on a specific position on the screen. Later, when the template with all the required resources is loaded and the route is changed, the logic attached to the selected page is invoked and populates the template with data. If the user presses the refresh button after the given page in our SPA is loaded, the same page needs to be re-rendered after the refresh of the view completes. This involves similar behavior: finding the requested view, fetching the required template with all referenced resources, and invoking the logic associated with that view.</p><p>The template that needs to be fetched, and the logic that should be invoked after the page reloads successfully, depends on the view selected before the user pressed the refresh button. The framework determines this by parsing the page URL, which contains the identifier of the currently selected page, represented in a hierarchical structure.</p><p>All the responsibilities related to the navigation, changing the URL, loading the appropriate template, and invoking specific logic when the view is loaded are assigned to the router component. These are some quite challenging tasks, and support for different navigation APIs required for cross-browser compatibility makes the implementation of routing in modern SPAs a nontrivial problem.</p><p>AngularJS introduced the router in its core, which was later externalized into the <code class="literal">ngRoute</code> module. It allows a declarative way for defining the different views in our SPA, by providing a template for each page and a piece of logic that needs to be invoked when a page is selected. However, the functionality of the router is limited. It does not support essential features, such as nested view routing. That's one of the reasons most developers preferred to use <code class="literal">ui-router</code>, developed by the community. Both AngularJS's router, and <code class="literal">ui-router</code>, route-definitions include a route configuration object, which defines a template and a controller associated with the page.</p><p>As described in the previous sections, Angular changed the building blocks it provides for the development of SPAs. Angular removes the floating controllers and instead represents views as a composition of components. This necessitates the development of a brand new router, which empowers these new concepts.</p><p>The core differences between the AngularJS router and the new Angular router are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The new router is component based, <code class="literal">ngRoute</code> is not. The new Angular router associates a component with the individual routes or a module in case of lazy-loaded routes.</li><li class="listitem" style="list-style-type: disc">There is now support for nested views.</li></ul></div><div class="section" title="Angular route definition syntax"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec22"/>Angular route definition syntax</h2></div></div></div><p>Let's take a brief look at the new syntax used by the Angular router to define routes in our applications:</p><pre class="programlisting">import {Component, NgModule} from '@angular/core';&#13;
import {BrowserModule} from '@angular/platform-browser';&#13;
import {RouterModule, Routes} from '@angular/router';&#13;
&#13;
import {HomeComponent} from './home/home.component';&#13;
import {AboutComponent} from './about/about.component';&#13;
import {AppComponent} from './app.component';&#13;
&#13;
const routes: Routes = [&#13;
  { path: 'home', component: HomeComponent },&#13;
  { path: 'about', component: AboutComponent }&#13;
];&#13;
&#13;
@NgModule({ &#13;
  imports: [BrowserModule, RouterModule.forRoot(routes)],&#13;
  declarations: [AppComponent, HomeComponent, AboutComponent],&#13;
  bootstrap: [AppComponent]&#13;
})&#13;
export class AppModule {} &#13;
</pre><p>We won't go into too much detail here since <a class="link" href="ch06.html" title="Chapter 6. Working with the Angular Router and Forms">
Chapter 6</a>, <span class="emphasis"><em>Working with the Angular Router and Forms,</em></span> and <a class="link" href="ch07.html" title="Chapter 7. Explaining Pipes and Communicating with RESTful Services">
Chapter 7</a>, <span class="emphasis"><em>Explaining Pipes and Communicating with RESTful Services</em></span>, are dedicated to the new router, but let's mention the main points in the preceding code snippet.</p><p>The router lives in <code class="literal">@angular/router</code>. Since <code class="literal">AppModule</code> is the root module of our application, we use the <code class="literal">forRoot</code> method of <code class="literal">RouterModule</code> in order to import all the required directives and services exported by the router.</p><p>The parameter passed to the <code class="literal">RouterModule.forRoot</code> decorator shows how we define the routes in our application. We use an array with objects, which defines the mappings between routes and the components associated with them.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Summary</h1></div></div></div><p>In this chapter, we took a quick overview of the main building blocks for developing SPAs provided by Angular. We pointed out the main differences with the core concepts from AngularJS.</p><p>Although we can use ES2015, or even ES5, to build Angular applications, the recommendation from Google is to take advantage of the language used for the development of the framework-TypeScript. This way we can use advanced features such as Ahead-of-Time compilation that we're going to describe in <a class="link" href="ch08.html" title="Chapter 8. Tooling and Development Experience">Chapter 8</a>, <span class="emphasis"><em>Tooling and </em></span>
<span class="emphasis"><em>Development Experience</em></span>.</p><p>In the next chapter, we'll take a look at TypeScript and how we can start using it in our next application. We will also explain how with ambient type definitions we can take advantage of the static typing in the JavaScript libraries and frameworks written in vanilla JavaScript.</p></div></body></html>