- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: JavaScript Engines and Hermes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript引擎和Hermes
- en: React Native runs on JavaScript and, as mentioned in [*Chapter 2*](B16694_02.xhtml#_idTextAnchor030),
    *Understanding the Essentials of JavaScript and TypeScript*, JavaScript needs
    a JavaScript engine to interpret and/or transform the code into executable machine
    code. There is no exception to this for React Native.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: React Native运行在JavaScript上，如[*第2章*](B16694_02.xhtml#_idTextAnchor030)中所述，*理解JavaScript和TypeScript的基本知识*，JavaScript需要一个JavaScript引擎来解释和/或将其转换为可执行的机器代码。对于React
    Native来说，这没有例外。
- en: While there are quite a lot of different JS engines out there, only a few are
    used in React Native projects. This is due to the quite complex process to change
    the JS engine as well as the new Hermes engine, which is an engine developed for
    React Native and is going to be the default soon. Nevertheless, it is important
    and helpful to understand the different possible engines with their strengths
    and weaknesses.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管市面上有相当多的不同JavaScript引擎，但在React Native项目中只有少数被使用。这是因为改变JavaScript引擎的过程相当复杂，以及新的Hermes引擎，这是一个为React
    Native开发的引擎，很快将成为默认引擎。尽管如此，了解不同可能的引擎及其优缺点仍然很重要和有帮助。
- en: 'In this theoretical chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的理论部分，我们将涵盖以下主题：
- en: Understanding JavaScript engines
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解JavaScript引擎
- en: Getting to know the Hermes engine
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Hermes引擎
- en: Comparing key metrics
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较关键指标
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Since this is a theoretical chapter, you don’t need to have anything set up.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个理论章节，你不需要设置任何东西。
- en: Understanding JavaScript engines
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解JavaScript引擎
- en: As mentioned in the introduction to this chapter, a JavaScript engine is responsible
    for interpreting JavaScript and/or transforming it into machine code, so that
    the device can execute it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章引言所述，JavaScript引擎负责解释JavaScript并将其/转换为机器代码，以便设备可以执行它。
- en: The first JavaScript engines were simple interpreters that simply processed
    the statements and ensured the execution. The code was just executed like it was
    written. This has changed a lot.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最初的JavaScript引擎是简单的解释器，它们只是处理语句并确保执行。代码就像它被编写的那样执行。这已经发生了很大变化。
- en: Modern JS engines provide a lot of optimization features. The most discussed
    is **just-in-time** (**JIT**) compilation, which is implemented by all modern
    JS engines.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现代JS引擎提供了许多优化功能。最被讨论的是**即时编译**（**JIT**），这是所有现代JS引擎都实现的。
- en: Compiled languages such as C are compiled before the execution of the code.
    In this compile step, the transformation to machine language is done as well as
    a lot of optimization steps. This creates an output that is extremely performant.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 编译型语言，如C语言，在代码执行前进行编译。在这个编译步骤中，不仅将代码转换为机器语言，还包括许多优化步骤。这产生了一个性能极优的输出。
- en: '*Just-in-time* compilation means that the code is compiled while it runs. This
    means the just-in-time compiler does not know all the code while it compiles.
    This makes code optimization a lot more difficult. The just-in-time compiler contains
    two components – the **profiler** and the **compiler**. While the JS code is executed
    by the interpreter, the profiler keeps an eye on how often the different statements
    are executed.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*即时编译*意味着代码在运行时进行编译。这意味着即时编译器在编译时并不知道所有代码。这使得代码优化变得更加困难。即时编译器包含两个组件——**分析器**和**编译器**。当JS代码由解释器执行时，分析器会关注不同语句执行的频率。'
- en: The more often a statement is executed, the higher priority it gets from the
    profiler. When a certain threshold is hit, the profiler sends these statements
    of code to the compiler, which then compiles the statements to bytecode. When
    the statement shall be executed the next time, it is done via a highly optimized
    bytecode interpreter. This makes these sections run much faster.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个语句执行得越频繁，它从分析器那里得到的优先级就越高。当达到某个阈值时，分析器将这些代码语句发送给编译器，编译器然后将这些语句编译为字节码。当该语句下次要执行时，它将通过一个高度优化的字节码解释器执行。这使得这些部分运行得更快。
- en: There are some more optimizations that can be done during the compilation. This
    depends a lot on the implementation and every modern JS engine has its own just-in-time
    compiler implementation.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译过程中还可以进行一些优化。这很大程度上取决于实现，每个现代JS引擎都有自己的即时编译器实现。
- en: In general, just-in-time compilation works better for longer running code, because
    then the compiler has more time to learn how to optimize. Since a lot of JS code
    is executed while running a React Native app, just-in-time compilation works great.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，即时编译对运行时间较长的代码效果更好，因为编译器有更多时间来学习如何优化。由于在运行 React Native 应用时执行了大量的 JS 代码，即时编译效果极佳。
- en: The most widely known JS engines today are JavaScriptCore and V8\. Since both
    can be used in React Native, we’ll have a deeper look at them.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 目前最知名的 JS 引擎是 JavaScriptCore 和 V8。由于两者都可以用于 React Native，我们将更深入地探讨它们。
- en: Using JavaScriptCore
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 JavaScriptCore
- en: '**JavaScriptCore** is the JS engine that powers the Safari browser. It is the
    default engine shipping with React Native. If you create a new blank project,
    JavaScriptCore will interpret and execute your JS code.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScriptCore** 是为 Safari 浏览器提供动力的 JS 引擎。它是随 React Native 一起提供的默认引擎。如果你创建一个新的空白项目，JavaScriptCore
    将解释并执行你的 JS 代码。'
- en: Using V8
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 V8
- en: '**V8** is an open source JS engine, heavily backed by Google. It is used by
    default when you are using the remote debugging feature of React Native. In this
    case, your JS code is executed in your Chrome browser, which is powered by V8.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**V8** 是一个开源的 JS 引擎，得到了谷歌的大力支持。当你使用 React Native 的远程调试功能时，默认使用 V8。在这种情况下，你的
    JS 代码将在由 V8 驱动的 Chrome 浏览器中执行。'
- en: Important tip
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Please always keep in mind that you are using different JS engines when having
    remote debugging on/off. Without remote debugging, your JS code runs on your device
    or simulator; with remote debugging activated, your JS code runs on your computer
    in Chrome and communicates with native via WebSockets. Even if the two engines
    should behave quite similarly, there are some inconsistencies. So always test
    without remote debugging before shipping your app.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 请始终记住，当你在远程调试开启/关闭时，你正在使用不同的 JS 引擎。在没有远程调试的情况下，你的 JS 代码在设备或模拟器上运行；当远程调试激活时，你的
    JS 代码在计算机上的 Chrome 中运行，并通过 WebSocket 与本地进行通信。即使这两个引擎的行为应该相当相似，也有一些不一致之处。因此，在发布你的应用之前，始终在没有远程调试的情况下进行测试。
- en: 'There is also a project that provides support for V8 as the main JS engine
    for React Native. This is no big deal for Android since it just replaces the JavaScriptCore
    for Android JS engine with the V8 engine. It gets more complex on iOS since JavaScriptCore
    is available on iOS without having to include it in the app bundle. So instead
    of just using the available JS engine, you would have to bundle the V8 engine
    in your app. This increases your app bundle size by up to 7 MB depending on the
    version you use. You can find more information on this on the `react-native-v8`
    project: [https://bit.ly/prn-rn-v8](https://bit.ly/prn-rn-v8).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个项目为 React Native 提供了将 V8 作为主要 JS 引擎的支持。对于 Android 来说这并不是什么大问题，因为它只是用 V8
    引擎替换了 Android JS 引擎的 JavaScriptCore。在 iOS 上则更为复杂，因为 JavaScriptCore 在 iOS 上可用，无需将其包含在应用包中。因此，你不仅需要使用可用的
    JS 引擎，还必须在你的应用中捆绑 V8 引擎。这会使你的应用包大小增加高达 7 MB，具体取决于你使用的版本。你可以在 `react-native-v8`
    项目中找到更多关于此的信息：[https://bit.ly/prn-rn-v8](https://bit.ly/prn-rn-v8)。
- en: While both engines work fine, Facebook started a project called **Hermes** to
    develop their own JS engine for React Native. The use case of React Native differs
    a lot from that of the browser engines as the code is available at build time
    and cannot change after shipping; hence, there is a lot more room for optimization.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这两个引擎都能正常工作，但 Facebook 开始了一个名为 **Hermes** 的项目，以开发他们自己的 React Native JS 引擎。由于
    React Native 的用例与浏览器引擎有很大不同，因为代码在构建时是可用的，并且在发布后无法更改；因此，有更多的优化空间。
- en: Getting to know the Hermes engine
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解 Hermes 引擎
- en: Hermes was brought to the React Native community at the React Native EU conference
    in 2019\. Back then, it was already in production in Facebook’s apps for more
    than a year. It is completely built with mobile in mind, which changes the architectural
    approach completely. The following figure shows how a modern JS engine works.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Hermes 是在 2019 年的 React Native EU 大会上引入 React Native 社区的。当时，它已经在 Facebook 的应用中投入生产超过一年。它是完全以移动为中心构建的，这完全改变了架构方法。以下图显示了现代
    JS 引擎的工作方式。
- en: '![Figure 8.1 – Modern JS engine pipeline (inspired by Tsvetan Mikov)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.1 – 现代JS引擎管道（灵感来自Tsvetan Mikov）](#)'
- en: '](img/B16694_08_01.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B16694_08_01.jpg)'
- en: Figure 8.1 – Modern JS engine pipeline (inspired by Tsvetan Mikov)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.1 – 现代JS引擎管道（灵感来自Tsvetan Mikov）](#)'
- en: When creating and building JavaScript code, usually there is some transcompiling
    done to backward-compatible JS code and some JS code minification. This minified
    JS bundle is then sent to a device and gets executed. JS engines such as JavaScriptCore
    or V8 try to optimize the execution using just-in-time compilation, which, as
    described before, is a quite complex process and may store and optimize the wrong
    code statements. Hermes changes the way this is done completely.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建和构建 JavaScript 代码时，通常会有一些向后兼容的 JS 代码的转换编译和一些 JS 代码的压缩。然后，这个压缩后的 JS 包被发送到设备并执行。JavaScript
    引擎如 JavaScriptCore 或 V8 会尝试使用即时编译来优化执行，正如之前所描述的，这是一个相当复杂的过程，可能会存储和优化错误的代码语句。Hermes
    完全改变了这种方式。
- en: 'The following figure shows how optimization and compilation are done in Hermes:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了 Hermes 中优化和编译的执行方式：
- en: '![Figure 8.2 – Hermes pipeline (inspired by Tzvetan Mikov)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.2 – Hermes 管道（灵感来源于 Tzvetan Mikov）](img/B16694_08_02.jpg)'
- en: '](img/B16694_08_02.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: Figure 8.2 – Hermes pipeline (inspired by Tzvetan Mikov)
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – Hermes 管道（灵感来源于 Tzvetan Mikov）
- en: Because we know all the code, we want to ship in our React Native app, it is
    possible to do the compilation and optimization during the build process. This
    means all optimization is done on your computer (or in your CI environment) and
    not on the users’ devices. Hermes uses a so-called internal code representation,
    which is highly optimized for the optimization of code.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们知道所有代码，我们希望在 React Native 应用中打包，所以可以在构建过程中进行编译和优化。这意味着所有优化都是在您的计算机（或您的 CI
    环境中）进行的，而不是在用户的设备上。Hermes 使用一种所谓的内部代码表示，这种表示对代码优化进行了高度优化。
- en: After optimizing the code, it is compiled to optimized bytecode. So, when working
    with Hermes, you don’t ship JavaScript any longer, you ship optimized bytecode.
    This bytecode only has to be loaded and executed by the Hermes engine on the users’
    devices.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 优化代码后，它被编译成优化的字节码。因此，当使用 Hermes 时，您不再发送 JavaScript，而是发送优化的字节码。这种字节码只需要在用户的设备上由
    Hermes 引擎加载和执行。
- en: 'This approach brings a lot of benefits. The most important are as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法带来了许多好处。其中最重要的如下：
- en: '**No warmup**: We don’t need to spend time on just-in-time compiler warmup.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无需预热**：我们不需要花费时间在即时编译器预热上。'
- en: '**No memory usage for just-in-time compiler output**: We don’t need any memory
    for the output of the just-in-time compiler. This reduces the memory footprint
    a lot.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**即时编译器输出的内存使用量为零**：我们不需要为即时编译器的输出占用任何内存。这大大减少了内存占用。'
- en: '**Startup optimizations**: Some operations that are done by JS engines at startup
    can be precomputed. This makes the start of the application a lot faster.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启动优化**：一些在启动时由 JS 引擎执行的运算可以预先计算。这使得应用程序的启动速度大大提高。'
- en: '**Smaller bundle size**: The optimized bundle is smaller than minified JavaScript
    code.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更小的包大小**：优化后的包比压缩后的 JavaScript 代码更小。'
- en: 'Due to the benefits of this approach, Hermes is pushed to become the default
    JS engine for React Native as soon as possible. At the point of writing, you still
    have to activate it, but it is quite simple:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种方法的好处，Hermes 被推动尽快成为 React Native 的默认 JS 引擎。在撰写本文时，您仍然需要激活它，但操作非常简单：
- en: '`android/app/build.gradle` file and change `enableHermes` from `false` to `true`.
    You have to clean and rebuild your application after that.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `android/app/build.gradle` 文件中将 `enableHermes` 从 `false` 改为 `true`。之后，您必须清理并重新构建您的应用程序。
- en: '`ios/Podfile` file and change `:hermes_enabled => false` to `:hermes_enabled
    => true`. Reinstall your pods with `cd ios && pod install`.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `ios/Podfile` 文件中将 `:hermes_enabled => false` 改为 `:hermes_enabled => true`。使用
    `cd ios && pod install` 重新安装您的 pods。
- en: Please note that the remote debugging feature does work differently when using
    Hermes. Since the approach is completely different, there is no bundle that can
    be run directly in your Chrome browser. Nevertheless, Hermes does support debugging
    with the Chrome inspector protocol and the Chrome developer tools.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当使用 Hermes 时，远程调试功能的工作方式与之前不同。由于方法完全不同，没有可以直接在您的 Chrome 浏览器中运行的包。尽管如此，Hermes
    支持使用 Chrome 检查器协议和 Chrome 开发者工具进行调试。
- en: 'To use remote debugging, you have to connect your Chrome browser to your running
    device via Metro. This is done as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用远程调试，您必须通过 Metro 将您的 Chrome 浏览器连接到正在运行的设备。这可以通过以下方式完成：
- en: Go to `chrome://inspect/#devices` in your Chrome browser.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的 Chrome 浏览器中转到 `chrome://inspect/#devices`。
- en: Click on the `Configure…` button and add the Metro server address (usually `localhost:8081`).
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `配置…` 按钮，并添加 Metro 服务器地址（通常是 `localhost:8081`）。
- en: Now, there is a `Hermes React Native` target, which you can inspect.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，有一个 `Hermes React Native` 目标，您可以进行检查。
- en: For more information, please visit the Hermes documentation of React Native
    ([https://bit.ly/prn-hermes](https://bit.ly/prn-hermes)) or the documentation
    of the Hermes engine itself ([https://bit.ly/prn-hermes-engine](https://bit.ly/prn-hermes-engine)).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请访问 React Native 的 Hermes 文档（[https://bit.ly/prn-hermes](https://bit.ly/prn-hermes)）或
    Hermes 引擎本身的文档（[https://bit.ly/prn-hermes-engine](https://bit.ly/prn-hermes-engine)）。
- en: As mentioned, the Hermes approach brings a lot of benefits to React Native.
    This is also reflected in key metrics, which we are going to have a look at in
    the following section.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Hermes 方法给 React Native 带来了很多好处。这也在关键指标中得到了反映，我们将在下一节中查看这些指标。
- en: Comparing key metrics
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较关键指标
- en: When it comes to mobile apps, there are a few metrics you should have a look
    at when optimizing your application.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到移动应用时，在优化您的应用时，您应该查看以下几个指标。
- en: Understanding important metrics
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解重要指标
- en: 'The most important key metrics on mobile are the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 移动设备上最重要的关键指标如下：
- en: '**Time to interaction** (**TTI**): This is the time between the user clicking
    on your app icon and when the user can use your app. It is important to reduce
    the TTI as much as possible because mobile app users are very impatient. The longer
    the TTI is, the more users will leave your app without even using it.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交互时间**（**TTI**）：这是用户点击您的应用图标到用户可以使用您的应用之间的时间。尽可能减少 TTI 非常重要，因为移动应用用户非常没有耐心。交互时间越长，用户就越有可能在不使用您应用的情况下离开。'
- en: '**Application size**: This is the size the user has to download from the store
    to install your application. The larger the application size is, the more users
    won’t download your app. This can have many reasons such as high transfer costs
    in some countries or disk space left on the user’s device. The fact is, the smaller
    your app is, the more users will download it.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用大小**：这是用户必须从商店下载以安装您的应用的大小。应用大小越大，用户就越不愿意下载您的应用。这可能有多种原因，例如某些国家的高传输成本或用户设备上剩余的磁盘空间。事实是，您的应用越小，用户就越有可能下载它。'
- en: '**Memory utilization**: This metric describes how much memory your application
    consumes during execution. If your app is very memory-hungry, it can lead to problems,
    especially on older devices or during multitasking. Also, it can lead to the operating
    system closing your app. The less memory your app consumes, the better it is.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存利用率**：这个指标描述了您的应用在执行过程中消耗了多少内存。如果您的应用非常耗内存，可能会导致问题，尤其是在旧设备或多任务处理期间。此外，它可能导致操作系统关闭您的应用。您的应用消耗的内存越少，越好。'
- en: There are some benchmark results publicly available when looking at these metrics.
    As JavaScriptCore and V8 deliver mostly similar results (V8 is a bit better in
    most tests), we’ll focus on the comparison of JavaScriptCore and Hermes used in
    a React Native application.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看这些指标时，有一些基准结果公开可用。由于 JavaScriptCore 和 V8 提供的结果大多相似（V8 在大多数测试中略好），我们将重点关注
    React Native 应用中使用的 JavaScriptCore 和 Hermes 的比较。
- en: Comparing JavaScriptCore and Hermes on Android
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Android 上比较 JavaScriptCore 和 Hermes
- en: 'The following test compares the key metrics of JSC and Hermes on Android. The
    test was run by the Hermes team at Facebook with a very early version of Hermes:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下测试比较了 Android 上 JSC 和 Hermes 的关键指标。这次测试是由 Facebook 的 Hermes 团队使用 Hermes 的一个非常早期版本进行的：
- en: '|  | JSC | Hermes |  |  |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '|  | JSC | Hermes |  |  |'
- en: '| Time to interaction | 4.30s | 2.01s | -2.29s | -53% |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 交互时间 | 4.30s | 2.01s | -2.29s | -53% |'
- en: '| Application size | 41MB | 22MB | -19MB | -46% |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 应用大小 | 41MB | 22MB | -19MB | -46% |'
- en: '| Memory Utilization | 185MB | 136MB | -49MB | -26% |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 内存利用率 | 185MB | 136MB | -49MB | -26% |'
- en: Figure 8.3 – Facebook JSC/Hermes test on Android (https://bit.ly/prn-hermes-test-fb)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – Facebook JSC/Hermes 在 Android 上的测试（https://bit.ly/prn-hermes-test-fb）
- en: 'There was another test run by Kudo Chien, a well-respected member of the React
    Native community, that also included TTI. This test also worked with different
    bundle sizes:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 另一次由备受尊敬的 React Native 社区成员 Kudo Chien 进行的测试运行也包含了 TTI。这次测试使用了不同的套件大小：
- en: '|  | JSC | Hermes | *in ms |  |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '|  | JSC | Hermes | *毫秒 |  |'
- en: '| TTI 3MB bundle | 400 | 240 | 160 | -40% |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| TTI 3MB 套件 | 400 | 240 | 160 | -40% |'
- en: '| TTI 10MB bundle | 584 | 305 | 279 | -48% |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| TTI 10MB 套件 | 584 | 305 | 279 | -48% |'
- en: '| TTI 15MB bundle | 694 | 342 | 352 | -51% |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| TTI 15MB 套件 | 694 | 342 | 352 | -51% |'
- en: Figure 8.4 – TTI test by Kudo Chien on Android (https://bit.ly/prn-hermes-test-kudo)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – Kudo Chien 在 Android 上的 TTI 测试（https://bit.ly/prn-hermes-test-kudo）
- en: If you have a look at the test results, they are just remarkable on Android.
    The time to interaction was reduced by around 50% in all tests. This is a real
    game-changer. React Native apps used to open quite slowly compared to real native
    or Flutter apps. This is due to the need of initializing the JS engine before
    rendering their first screen. Hermes is a huge step in the right direction for
    React Native in this area.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看测试结果，它们在Android上非常显著。所有测试中的交互时间都减少了大约50%。这是一个真正的变革。与真正的原生或Flutter应用程序相比，React
    Native应用程序过去打开速度较慢。这是由于在渲染第一个屏幕之前需要初始化JS引擎。Hermes在React Native这个领域是一个巨大的进步。
- en: When having a look at the Facebook test, the application size was also reduced
    by nearly 50%. This is partly because we don’t have to bundle the JavaScriptCore
    engine into our application anymore, so this effect will reduce on larger applications.
    But you can expect a saving in bundle size by around 30% even on larger apps.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看Facebook的测试时，应用程序大小也减少了近50%。这部分原因是因为我们不再需要将JavaScriptCore引擎打包到我们的应用程序中，因此这种效果将在大型应用程序中减少。但即使在大型应用程序中，你也可以期待大约30%的包大小节省。
- en: Now let’s have a look at memory utilization. In Facebook’s test, Hermes achieved
    memory savings of around 25%. This is mostly because of the not needed just-in-time
    compilation and is also a huge achievement.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看内存使用情况。在Facebook的测试中，Hermes实现了大约25%的内存节省。这主要是因为不需要即时编译，这也是一个巨大的成就。
- en: Again, these tests were run with very early versions of Hermes, so you can expect
    larger gains in the future.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这些测试是在Hermes的非常早期版本上运行的，因此你可以期待未来有更大的提升。
- en: While the results are very clear on Android, let’s proceed with tests on iOS.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在Android上的结果非常清晰，但让我们继续在iOS上进行测试。
- en: Comparing JSC and Hermes on iOS
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在iOS上比较JSC和Hermes
- en: 'On iOS, we have to keep in mind that JavaScriptCore is provided by the operating
    system. This means when using JSC, we don’t have to bundle any JavaScript engine
    into our application. Also, JavaScriptCore is optimized for iOS and Apple products.
    The implementation of Hermes on iOS was done by **Callstack**, a company that
    contributes a lot to React Native in general. After completing the implementation,
    the Callstack team also ran some tests to compare JSC and Hermes. These are the
    results:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS上，我们必须记住JavaScriptCore是由操作系统提供的。这意味着当我们使用JSC时，我们不需要将任何JavaScript引擎打包到我们的应用程序中。此外，JavaScriptCore针对iOS和苹果产品进行了优化。iOS上Hermes的实现是由**Callstack**公司完成的，这是一家为React
    Native做出了大量贡献的公司。完成实现后，Callstack团队还进行了一些测试，以比较JSC和Hermes。以下是结果：
- en: '|  | JSC | Hermes | *in ms |  |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '|  | JSC | Hermes | *以毫秒为单位 |  |'
- en: '| Time to interaction | 920ms | 570ms | -350ms | -38% |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 交互时间 | 920ms | 570ms | -350ms | -38% |'
- en: '| Application size | 10.6MB | 13MB | 2,4MB | 18% |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 应用程序大小 | 10.6MB | 13MB | 2.4MB | 18% |'
- en: '| Memory utilization | 216MB | 178MB | -38MB | -18% |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 内存使用量 | 216MB | 178MB | -38MB | -18% |'
- en: Figure 8.5 – Callstack JSC/Hermes test on iOS (https://bit.ly/prn-hermes-test-ios)
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 – iOS上JSC/Hermes调用栈测试（https://bit.ly/prn-hermes-test-ios）
- en: As on Android, time to interaction and memory utilization improved a lot. The
    values are a little lower than on Android, but this can be explained due to the
    better optimization of JSC on iOS. The application size increased on iOS, which
    seems only logical, so we now have to add Hermes to our bundle, while JSC is provided
    by the operating system.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 与Android一样，交互时间和内存使用量都有很大提升。这些值略低于Android，但这可以归因于iOS上JSC的更好优化。iOS上的应用程序大小增加了，这似乎是合乎逻辑的，因此我们现在必须将Hermes添加到我们的包中，而JSC则由操作系统提供。
- en: But when the JavaScript bundle of your app grows, this effect will decrease
    due to the smaller bytecode of Hermes compared to the minified JS code shipped
    with the JSC-based bundle.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当你的应用程序的JavaScript包增长时，由于Hermes的字节码比基于JSC的包中分发的压缩JS代码更小，这种效果将会减少。
- en: Summary
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we had a look at JavaScript engines in general, learned about
    the special requirements React Native has for a JavaScript engine, the different
    engines we can use in React Native, and how to change the JS engine of our React
    Native project. We then had a look at Hermes, a JavaScript engine developed with
    mobile in general and React Native especially in mind.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了JavaScript引擎的一般情况，学习了React Native对JavaScript引擎的特殊要求，我们可以在React Native中使用的不同引擎，以及如何更改我们的React
    Native项目的JS引擎。然后我们了解了Hermes，这是一个考虑到移动设备和React Native（尤其是React Native）而开发的JavaScript引擎。
- en: After understanding the approach of Hermes and its benefits, we compared mobile
    app key metrics on apps running on JavaScriptCore, V8, and Hermes. While there
    is no big difference in using JSC or V8, Hermes brings a huge boost in terms of
    TTI and memory utilization to React Native.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解了 Hermes 的方法和其优势之后，我们比较了在 JavaScriptCore、V8 和 Hermes 上运行的应用程序的关键指标。虽然使用 JSC
    或 V8 没有太大差异，但 Hermes 在 TTI（触摸到文本显示时间）和内存利用率方面给 React Native 带来了巨大的提升。
- en: After mastering JavaScript engines, we’ll have a look at useful tools when working
    with React Native in the next chapter.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握 JavaScript 引擎之后，我们将在下一章中查看在处理 React Native 时有用的工具。
