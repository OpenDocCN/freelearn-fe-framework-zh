<html><head></head><body>
		<div id="_idContainer044">
			<h1 id="_idParaDest-45" class="chapter-number"><a id="_idTextAnchor044"/>2</h1>
			<h1 id="_idParaDest-46"><a id="_idTextAnchor045"/>Introducing TypeScript</h1>
			<p>In this chapter, we will start by understanding what TypeScript is and how it provides a much richer type system on top of JavaScript. We will learn about the basic types in TypeScript, such as numbers and strings, and then learn how to create our own types to represent objects and arrays using different TypeScript features. Finally, we will finish the chapter by understanding the TypeScript compiler and its key options in a <span class="No-Break">React app.</span></p>
			<p>By the end of the chapter, you’ll be ready to learn how to use TypeScript to build frontends <span class="No-Break">with React.</span></p>
			<p>In this chapter, we’ll cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Understanding the benefits <span class="No-Break">of TypeScript</span></li>
				<li>Understanding <span class="No-Break">JavaScript types</span></li>
				<li>Using basic <span class="No-Break">TypeScript types</span></li>
				<li>Creating <span class="No-Break">TypeScript types</span></li>
				<li>Using the <span class="No-Break">TypeScript compiler</span></li>
			</ul>
			<h1 id="_idParaDest-47"><a id="_idTextAnchor046"/>Technical requirements</h1>
			<p>We will use the following technologies in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li><strong class="bold">Browser</strong>: A modern browser such as <span class="No-Break">Google Chrome.</span></li>
				<li><strong class="bold">TypeScript Playground</strong>: This is a website at https://www.typescriptlang.org/play/ that allows you to play around with and understand the features of TypeScript without <span class="No-Break">installing it.</span></li>
				<li><strong class="bold">CodeSandbox</strong>: We’ll briefly use this online tool to explore JavaScript’s type system. This can be found <span class="No-Break">at </span><a href="https://codesandbox.io/"><span class="No-Break">https://codesandbox.io/</span></a><span class="No-Break">.</span></li>
				<li><strong class="bold">Visual Studio Code</strong>: We’ll need an editor to experience TypeScript’s benefits and explore the TypeScript compiler. This one can be installed from <a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a>. Other editors that could be used can be found <span class="No-Break">at </span><a href="https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support"><span class="No-Break">https://github.com/Microsoft/TypeScript/wiki/TypeScript-Editor-Support</span></a><span class="No-Break">.</span></li>
				<li><strong class="bold">Node.js</strong> and <strong class="bold">npm</strong>: TypeScript is dependent on these pieces of software. You can install them <span class="No-Break">from </span><a href="https://nodejs.org/en/download/"><span class="No-Break">https://nodejs.org/en/download/</span></a><span class="No-Break">.</span></li>
			</ul>
			<p>All the code snippets in this chapter can be found online <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter2"><span class="No-Break">https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/tree/main/Chapter2</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor047"/>Understanding the benefits of TypeScript</h1>
			<p>In this section, we will start by understanding what TypeScript is, how it relates to JavaScript, and how TypeScript enables teams to be <span class="No-Break">more productive.</span></p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor048"/>Understanding TypeScript</h2>
			<p>TypeScript <a id="_idIndexMarker089"/>was first released in 2012 and is still being developed, with new releases happening every few months. But what is TypeScript, and what are <span class="No-Break">its benefits?</span></p>
			<p>TypeScript is often referred to as a superset or extension of JavaScript because any feature in JavaScript is available in TypeScript. Unlike JavaScript, TypeScript can’t be executed directly in a browser – it must be transpiled into <span class="No-Break">JavaScript first.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">It is worth being aware that a proposal is being considered that <em class="italic">would</em> allow TypeScript to be executed directly in a browser without transpilation. See the following link for more <span class="No-Break">information: </span><a href="https://github.com/tc39/proposal-type-annotations"><span class="No-Break">https://github.com/tc39/proposal-type-annotations</span></a><span class="No-Break">.</span></p>
			<p>TypeScript <a id="_idIndexMarker090"/>adds a rich type system to JavaScript. It is generally used with frontend frameworks such as Angular, Vue, and React. TypeScript can also be used to build a backend with Node.js. This demonstrates how flexible TypeScript’s type <span class="No-Break">system is.</span></p>
			<p>When a JavaScript codebase grows, it can become hard to read and maintain. TypeScript’s type system solves this problem. TypeScript uses the type system to allow code editors to <a id="_idIndexMarker091"/>catch type errors as developers write problematic code. Code editors also use the type system to provide productivity features such as robust code navigation and <span class="No-Break">code refactoring.</span></p>
			<p>Next, we will step through an example of how TypeScript catches an error that <span class="No-Break">JavaScript can’t.</span></p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor049"/>Catching type errors early</h2>
			<p>The type information<a id="_idIndexMarker092"/> helps the TypeScript compiler catch type errors. In code editors such as Visual Studio Code, a type error is underlined in red immediately after the developer has made a type mistake. Carry out the following steps to experience an example of TypeScript catching a <span class="No-Break">type error:</span></p>
			<ol>
				<li>Open Visual Studio Code in a folder of <span class="No-Break">your choice.</span></li>
				<li>Create a new file called <strong class="source-inline">calculateTotalPrice.js</strong> by choosing the <strong class="bold">New File</strong> option in the <span class="No-Break"><strong class="bold">EXPLORER</strong></span><span class="No-Break"> panel.</span></li>
			</ol>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="image/B19051_02_01.jpg" alt="Figure 2.1 – Creating a new file in Visual Studio Code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – Creating a new file in Visual Studio Code</p>
			<ol>
				<li value="3">Enter the following code into <span class="No-Break">the file:</span><pre class="source-code">
function calculateTotalPriceJS(product, quantity, discount) {</pre><pre class="source-code">
  const priceWithoutDiscount = product.price * quantity;</pre><pre class="source-code">
  const discountAmount = priceWithoutDiscount * discount;</pre><pre class="source-code">
  return priceWithoutDiscount - discountAmount;</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>Remember that the code snippets are available online to copy. The link to the previous snippet can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter2/Section1-Understanding-TypeScript/calculateTotalPrice.js"><span class="No-Break">https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter2/Section1-Understanding-TypeScript/calculateTotalPrice.js</span></a><span class="No-Break">.</span></p>
			<p>There is a bug in the code that might be difficult to spot, and the error won’t be highlighted by Visual <span class="No-Break">Studio Code.</span></p>
			<ol>
				<li value="4">Now <a id="_idIndexMarker093"/>create a copy of the file but with a <strong class="source-inline">.ts</strong> extension instead of <strong class="source-inline">.js</strong>. A file can be copied by right-clicking on the file in the <strong class="bold">EXPLORER</strong> panel and selecting the <strong class="bold">Copy</strong> option. Then right-click the <strong class="bold">EXPLORER</strong> panel again and select the <strong class="bold">Paste</strong> option to create the <span class="No-Break">copied file.</span></li>
			</ol>
			<p class="callout-heading">Note</p>
			<p class="callout">A <strong class="source-inline">.ts</strong> file extension denotes a TypeScript file. This means a TypeScript compiler will perform type checking on <span class="No-Break">this file.</span></p>
			<ol>
				<li value="5">In the <strong class="source-inline">calculateTotalPrice.ts</strong> file, remove the <strong class="source-inline">JS</strong> from the end of the function name and make the following highlighted updates to <span class="No-Break">the code:</span><pre class="source-code">
function <strong class="bold">calculateTotalPrice</strong>(</pre><pre class="source-code">
  product<strong class="bold">: { name: string; unitPrice: number }</strong>,</pre><pre class="source-code">
  quantity<strong class="bold">: number</strong>,</pre><pre class="source-code">
  discount<strong class="bold">: number</strong></pre><pre class="source-code">
) {</pre><pre class="source-code">
  const priceWithoutDiscount = product.price * quantity;</pre><pre class="source-code">
  const discountAmount = priceWithoutDiscount * discount;</pre><pre class="source-code">
  return priceWithoutDiscount - discountAmount;</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>Here, we have added TypeScript <strong class="bold">type annotations</strong> to the <strong class="source-inline">function</strong> parameters. We will<a id="_idIndexMarker094"/> learn about type annotations in detail in the <span class="No-Break">next section.</span></p>
			<p>The <a id="_idIndexMarker095"/>key point is that the type error is now highlighted by a red <span class="No-Break">squiggly underline:</span></p>
			<div>
				<div id="_idContainer020" class="IMG---Figure">
					<img src="image/B19051_02_02.jpg" alt="Figure 2.2 – Highlighted type error"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – Highlighted type error</p>
			<p>The bug is that the function references a <strong class="source-inline">price</strong> property in the product object that doesn’t exist. The property that should be referenced <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">unitPrice</strong></span><span class="No-Break">.</span></p>
			<p>Catching these problems early in the development process increases the team’s throughput and is one less thing for quality assurance to catch. It could be worse – the bug could have gotten into the live app and given users a <span class="No-Break">bad experience.</span></p>
			<p>Keep these files open in Visual Studio Code because we will run through an example of TypeScript improving the developer <span class="No-Break">experience next.</span></p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor050"/>Improving developer experience and productivity with IntelliSense</h2>
			<p><strong class="bold">IntelliSense</strong> is <a id="_idIndexMarker096"/>a <a id="_idIndexMarker097"/>feature in code editors that gives useful information about elements of code and allows code to be quickly completed. For example, IntelliSense can provide the list of properties available in <span class="No-Break">an object.</span></p>
			<p>Carry out the <a id="_idIndexMarker098"/>following steps to experience how TypeScript works better with IntelliSense than JavaScript and how this positively impacts productivity. As part of this exercise, we will fix the price bug from the <span class="No-Break">previous section:</span></p>
			<ol>
				<li value="1">Open <strong class="source-inline">calculateTotalPrice.js</strong> and on line 2, where <strong class="source-inline">product.price</strong> is referenced, remove <strong class="source-inline">price</strong>. Then, with the cursor after the dot (<strong class="source-inline">.</strong>), click <em class="italic">Ctrl</em> + spacebar. This <a id="_idIndexMarker099"/>opens Visual Studio <span class="No-Break">Code’s IntelliSense:</span></li>
			</ol>
			<div>
				<div id="_idContainer021" class="IMG---Figure">
					<img src="image/B19051_02_03.jpg" alt="Figure 2.3 – IntelliSense in a JavaScript file"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – IntelliSense in a JavaScript file</p>
			<p>Visual Studio Code can only guess the potential property name, so it lists variable names and function names it has seen in the file. Unfortunately, IntelliSense doesn’t help in this case because the correct property name, <strong class="source-inline">unitPrice</strong>, is <span class="No-Break">not listed.</span></p>
			<ol>
				<li value="2">Now open <strong class="source-inline">calculateTotalPrice.ts</strong>, remove <strong class="source-inline">price</strong> from <strong class="source-inline">product.price</strong>, and press <em class="italic">Ctrl</em> + spacebar to open <span class="No-Break">IntelliSense again:</span></li>
			</ol>
			<div>
				<div id="_idContainer022" class="IMG---Figure">
					<img src="image/B19051_02_04.jpg" alt="Figure 2.4 – IntelliSense in a TypeScript file"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 – IntelliSense in a TypeScript file</p>
			<p>This time, Visual Studio Code lists the <span class="No-Break">correct properties.</span></p>
			<ol>
				<li value="3">Select <strong class="bold">unitPrice</strong> from IntelliSense to resolve the <span class="No-Break">type error.</span></li>
			</ol>
			<p>IntelliSense is<a id="_idIndexMarker100"/> just one tool that TypeScript provides. It can<a id="_idIndexMarker101"/> also provide robust <a id="_idIndexMarker102"/>refactoring features, such as renaming React components, and helps with accurate code navigation, such as going to a <span class="No-Break">function definition.</span></p>
			<p>To recap what we learned in <span class="No-Break">this section:</span></p>
			<ul>
				<li>TypeScript’s type-checking feature helps catch problems earlier in the <span class="No-Break">development process</span></li>
				<li>TypeScript enables code editors to offer productivity features such <span class="No-Break">as IntelliSense</span></li>
				<li>These advantages provide significant benefits when working in <span class="No-Break">larger codebases</span></li>
			</ul>
			<p>Next, we will learn about the type system in JavaScript. This will further underline the need for TypeScript in a <span class="No-Break">large codebase.</span></p>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor051"/>Understanding JavaScript types</h1>
			<p>Before <a id="_idIndexMarker103"/>understanding the type system in TypeScript, let’s briefly explore the type system in JavaScript. To do this, open the CodeSandbox at <a href="https://codesandbox.io/">https://codesandbox.io/</a> and<a id="_idIndexMarker104"/> carry out the <span class="No-Break">following steps:</span></p>
			<ol>
				<li value="1">Create a new plain JavaScript project by choosing the <span class="No-Break"><strong class="bold">Vanilla</strong></span><span class="No-Break"> option.</span></li>
				<li>Open <strong class="source-inline">index.js</strong>, remove its content, and replace it with the <span class="No-Break">following code:</span><pre class="source-code">
let firstName = "Fred"</pre><pre class="source-code">
console.log("firstName", firstName, typeof firstName);</pre><pre class="source-code">
let score = 9</pre><pre class="source-code">
console.log("score", score, typeof score);</pre><pre class="source-code">
let date = new Date(2022, 10, 1);</pre><pre class="source-code">
console.log("date", date, typeof date);</pre></li>
			</ol>
			<p>The code assigns three variables to various values. The code also outputs the variable values to the console, along with their <span class="No-Break">JavaScript type.</span></p>
			<p>Here’s the <span class="No-Break">console output:</span></p>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<img src="image/B19051_02_05.jpg" alt="Figure 2.5 – Some JavaScript types"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5 – Some JavaScript types</p>
			<p>It isn’t surprising that <strong class="source-inline">firstName</strong> is a string and <strong class="source-inline">score</strong> is a number. However, it is a little surprising that <strong class="source-inline">date</strong> is an object rather than something more specific such as <span class="No-Break">a date.</span></p>
			<ol>
				<li value="3">Let’s add another couple of lines of code after the <span class="No-Break">existing code:</span><pre class="source-code">
score = "ten"</pre><pre class="source-code">
console.log("score", score, typeof score);</pre></li>
			</ol>
			<p>Again, the console output is a <span class="No-Break">little surprising:</span></p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/B19051_02_06.jpg" alt="Figure 2.6 – Variable changing type"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6 – Variable changing type</p>
			<p>The <strong class="source-inline">score</strong> variable has changed from a <strong class="source-inline">number</strong> type to a <strong class="source-inline">string</strong> type! This is because JavaScript is <span class="No-Break">loosely typed.</span></p>
			<p>A key point is that <a id="_idIndexMarker105"/>JavaScript only has a minimal set of types, such as <strong class="source-inline">string</strong>, <strong class="source-inline">number</strong>, and <strong class="source-inline">boolean</strong>. It is worth noting that all of the JavaScript types are available in TypeScript because Typescript is a superset <span class="No-Break">of Javascript.</span></p>
			<p>Also, JavaScript allows a variable to change its type – meaning that the JavaScript engine won’t throw an error if a variable is changed to a completely different type. This loose typing makes it impossible for code editors to catch <span class="No-Break">type errors.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">For more<a id="_idIndexMarker106"/> information on JavaScript types, <span class="No-Break">see </span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures"><span class="No-Break">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures</span></a><span class="No-Break">.</span></p>
			<p>Now that we understand the limitations of the type system in JavaScript, we will learn about TypeScript’s type system, starting with <span class="No-Break">basic types.</span></p>
			<h1 id="_idParaDest-53"><a id="_idTextAnchor052"/>Using basic TypeScript types</h1>
			<p>In this section, we’ll start <a id="_idIndexMarker107"/>by understanding how TypeScript types can be declared and how they are inferred from assigned values. We will then learn the basic types commonly used in TypeScript that aren’t available in JavaScript and understand helpful <span class="No-Break">use cases.</span></p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor053"/>Using type annotations</h2>
			<p>TypeScript type annotations<a id="_idIndexMarker108"/> enable variables to be declared with specific types. These allow the TypeScript compiler to check that the code adheres to these types. In short, type annotations allow TypeScript to catch bugs where our code uses the wrong type much earlier than we would if we were writing our code <span class="No-Break">in JavaScript.</span></p>
			<p>Open the<a id="_idIndexMarker109"/> TypeScript Playground at <a href="https://www.typescriptlang.org/play">https://www.typescriptlang.org/play</a> and carry out the following steps to explore <span class="No-Break">type annotations:</span></p>
			<ol>
				<li value="1">Remove any existing code in the left-hand pane and enter the following <span class="No-Break">variable declaration:</span><pre class="source-code">
let unitPrice: number;</pre></li>
			</ol>
			<p>The type annotation comes after the variable declaration. It starts with a colon followed by the type we want to assign to the variable. In this case, <strong class="source-inline">unitPrice</strong> is going to be a <strong class="source-inline">number</strong> type. Remember that <strong class="source-inline">number</strong> is a type in JavaScript, which means that it is available for us to use in <span class="No-Break">TypeScript too.</span></p>
			<p>The transpiled JavaScript appears on the right-hand side <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
let unitPrice;</pre>
			<p>However, notice that the type annotation has disappeared. This is because type annotations don’t exist <span class="No-Break">in JavaScript.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">You may also see <strong class="source-inline">"use strict";</strong> at the top of the transpiled JavaScript. This means that the JavaScript will be executed in JavaScript strict mode, which will pick up more coding mistakes. For more information on JavaScript strict mode, <span class="No-Break">see </span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode"><span class="No-Break">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode</span></a><span class="No-Break">.</span></p>
			<ol>
				<li value="2">Add a second line to <span class="No-Break">the program:</span><pre class="source-code">
unitPrice = "Table";</pre></li>
			</ol>
			<p>Notice that a red line appears under <strong class="source-inline">unitPrice</strong> on this line. If you hover over the underlined <strong class="source-inline">unitPrice</strong>, a type error <span class="No-Break">is described:</span></p>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="image/B19051_02_07.jpg" alt="Figure 2.7 – A type error being caught"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7 – A type error being caught</p>
			<ol>
				<li value="3">You<a id="_idIndexMarker110"/> can also add type annotations to function parameters and a function’s return value using the same syntax as annotating a variable. As an example, enter the following function in the <span class="No-Break">TypeScript Playground:</span><pre class="source-code">
function getTotal(</pre><pre class="source-code">
  unitPrice: number,</pre><pre class="source-code">
  quantity: number,</pre><pre class="source-code">
  discount: number</pre><pre class="source-code">
): number {</pre><pre class="source-code">
  const priceWithoutDiscount = unitPrice * quantity;</pre><pre class="source-code">
  const discountAmount = priceWithoutDiscount * discount;</pre><pre class="source-code">
  return priceWithoutDiscount - discountAmount;</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>We’ve declared the <strong class="source-inline">unitPrice</strong>, <strong class="source-inline">quantity</strong>, and <strong class="source-inline">discount</strong> parameters, all with a <strong class="source-inline">number</strong> type. The return type annotation comes after the function’s parentheses, which is also a <strong class="source-inline">number</strong> type in the <span class="No-Break">preceding example.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">We have used both <strong class="source-inline">const</strong> and <strong class="source-inline">let</strong> to declare variables in different examples. <strong class="source-inline">let</strong> allows the variable to change the value after the declaration, whereas <strong class="source-inline">const</strong> variables can’t change. In the preceding function, <strong class="source-inline">priceWithoutDiscount</strong> and <strong class="source-inline">discountAmount</strong> never change the value after the initial assignment, so we have <span class="No-Break">used </span><span class="No-Break"><strong class="source-inline">const</strong></span><span class="No-Break">.</span></p>
			<ol>
				<li value="4">Add <a id="_idIndexMarker111"/>another line of code to call <strong class="source-inline">getTotal</strong> with an incorrect type for <strong class="source-inline">quantity</strong>. Assign the result of the call to <strong class="source-inline">getTotal</strong> to a variable with an <span class="No-Break">incorrect type:</span><pre class="source-code">
let total: string = getTotal(500, "one", 0.1);</pre></li>
			</ol>
			<p>Both errors are immediately detected <span class="No-Break">and highlighted:</span></p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/B19051_02_08.jpg" alt="Figure 2.8 – Both type errors being caught"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.8 – Both type errors being caught</p>
			<p>This strong type checking is something that we don’t get in JavaScript, and it is very useful in large codebases because it helps us immediately detect <span class="No-Break">type errors.</span></p>
			<p>Next, we will learn how TypeScript doesn’t always need type annotations in order to <span class="No-Break">type-check code.</span></p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor054"/>Using type inference</h2>
			<p>Type annotations are really valuable, but they require additional code to be written. This extra code <a id="_idIndexMarker112"/>takes time to write. Luckily, TypeScript’s powerful <strong class="bold">type inference</strong> system means type annotations don’t need to be specified all the time. TypeScript infers the type of a variable when it is assigned a value from <span class="No-Break">that value.</span></p>
			<p>Explore type inference by carrying out the following steps in the <span class="No-Break">TypeScript Playground:</span></p>
			<ol>
				<li value="1">First, remove any previous code and then add the <span class="No-Break">following line:</span><pre class="source-code">
let flag = false;</pre></li>
				<li>Hover over the <strong class="source-inline">flag</strong> variable. A tooltip will appear showing the type that <strong class="source-inline">flag</strong> has been <span class="No-Break">inferred to:</span></li>
			</ol>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/B19051_02_09.jpg" alt="Figure 2.9 – Hovering over a variable reveals its type"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.9 – Hovering over a variable reveals its type</p>
			<ol>
				<li value="3">Add another line beneath this to incorrectly set <strong class="source-inline">flag</strong> to an <span class="No-Break">invalid value:</span><pre class="source-code">
flag = "table";</pre></li>
			</ol>
			<p>A type error is immediately caught, just like when we used a type annotation to assign a type to <span class="No-Break">a variable.</span></p>
			<p>Type inference <a id="_idIndexMarker113"/>is an excellent feature of TypeScript and prevents code bloat that lots of type annotations would bring. Therefore, it is common practice to use type inference and only revert to using type annotations where inference <span class="No-Break">isn’t possible.</span></p>
			<p>Next, we will look at the <strong class="source-inline">Date</strong> type <span class="No-Break">in TypeScript.</span></p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor055"/>Using the Date type</h2>
			<p>We are<a id="_idIndexMarker114"/> already aware that a <strong class="source-inline">Date</strong> type doesn’t exist in<a id="_idIndexMarker115"/> JavaScript, but luckily, a <strong class="source-inline">Date</strong> type does exist in TypeScript. The TypeScript <strong class="source-inline">Date</strong> type<a id="_idIndexMarker116"/> is a representation of the JavaScript <span class="No-Break"><strong class="source-inline">Date</strong></span><span class="No-Break"> object.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">See the following link for more information on the JavaScript <strong class="source-inline">Date</strong> <span class="No-Break">object: </span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date"><span class="No-Break">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date</span></a><span class="No-Break">.</span></p>
			<p>To explore the<a id="_idIndexMarker117"/> TypeScript <strong class="source-inline">Date</strong> type, carry out the following steps in the <span class="No-Break">TypeScript Playground:</span></p>
			<ol>
				<li value="1">First, remove any previous code and then add the <span class="No-Break">following lines:</span><pre class="source-code">
let today: Date;</pre><pre class="source-code">
today = new Date();</pre></li>
			</ol>
			<p>A <strong class="source-inline">today</strong> variable is declared that is assigned a <strong class="source-inline">Date</strong> type and set to <span class="No-Break">today’s date.</span></p>
			<ol>
				<li value="2">Refactor these two lines into the following single line that uses type inference rather than a <span class="No-Break">type annotation:</span><pre class="source-code">
let today = new Date();</pre></li>
				<li>Check<a id="_idIndexMarker118"/> that <strong class="source-inline">today</strong> has been assigned the <strong class="source-inline">Date</strong> type by hovering over it and checking <span class="No-Break">the tooltip:</span></li>
			</ol>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/B19051_02_10.jpg" alt="Figure 2.10 – Confirmation that today has inferred the Date type"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.10 – Confirmation that today has inferred the Date type</p>
			<ol>
				<li value="4">Now, check IntelliSense is working by adding <strong class="source-inline">today.</strong> on a <span class="No-Break">new line:</span></li>
			</ol>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="image/B19051_02_11.jpg" alt="Figure 2.11 – IntelliSense working nicely on a date"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.11 – IntelliSense working nicely on a date</p>
			<ol>
				<li value="5">Remove this <a id="_idIndexMarker119"/>line and add a slightly different line <span class="No-Break">of code:</span><pre class="source-code">
today.addMonths(2);</pre></li>
			</ol>
			<p>An <strong class="source-inline">addMonths</strong> function doesn’t exist in the <strong class="source-inline">Date</strong> object, so a type error <span class="No-Break">is raised:</span></p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/B19051_02_12.jpg" alt="Figure 2.12 – Type error caught on a date"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.12 – Type error caught on a date</p>
			<p>In <a id="_idIndexMarker120"/>summary, the <strong class="source-inline">Date</strong> type has all the features we expect – inference, IntelliSense, and type checking – which are really useful when working <span class="No-Break">with dates.</span></p>
			<p>Next, we will learn about an escape hatch in TypeScript’s <span class="No-Break">type system.</span></p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor056"/>Using the any type</h2>
			<p>What<a id="_idIndexMarker121"/> if we <a id="_idIndexMarker122"/>declare a variable with no type annotation and no value? What will TypeScript infer as the type? Let’s find out by entering the following code in the <span class="No-Break">TypeScript Playground:</span></p>
			<pre class="source-code">
let flag;</pre>
			<p>Now, hover the mouse <span class="No-Break">over </span><span class="No-Break"><strong class="source-inline">flag</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="image/B19051_02_13.jpg" alt="Figure 2.13 – Variable given the any type"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.13 – Variable given the any type</p>
			<p>So, TypeScript <a id="_idIndexMarker123"/>gives a variable with no type annotation and no immediately assigned value the <strong class="source-inline">any</strong> type. It is a way of opting out of performing type checking on a particular variable and is commonly used for dynamic content or values from third-party libraries. However, TypeScript’s increasingly powerful type system means that we need to use <strong class="source-inline">any</strong> less often<a id="_idIndexMarker124"/> <span class="No-Break">these days.</span></p>
			<p>Instead, there is a better alternative: the <span class="No-Break"><strong class="source-inline">unknown</strong></span><span class="No-Break"> type.</span></p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor057"/>Using the unknown type</h2>
			<p><strong class="source-inline">unknown</strong> is a <a id="_idIndexMarker125"/>type <a id="_idIndexMarker126"/>we can use when we are unsure of the type but want to interact with it in a strongly-typed manner. Carry out the following <a id="_idIndexMarker127"/>steps to explore how this is a better alternative to the <span class="No-Break"><strong class="source-inline">any</strong></span><span class="No-Break"> type:</span></p>
			<ol>
				<li value="1">In the TypeScript Playground, remove any previous code, and enter <span class="No-Break">the following:</span><pre class="source-code">
fetch("https://swapi.dev/api/people/1")</pre><pre class="source-code">
  .then((response) =&gt; response.json())</pre><pre class="source-code">
  .then((data) =&gt; {</pre><pre class="source-code">
    console.log("firstName", data.firstName);</pre><pre class="source-code">
  });</pre></li>
			</ol>
			<p>The code fetches a Star Wars character from a web API. No type errors are raised, so the code <span class="No-Break">appears okay.</span></p>
			<ol>
				<li value="2">Now click on the <strong class="bold">Run</strong> option to execute <span class="No-Break">the code:</span></li>
			</ol>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="image/B19051_02_14.jpg" alt="Figure 2.14 – firstName property has an undefined value"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.14 – firstName property has an undefined value</p>
			<p>The <strong class="source-inline">firstName</strong> property <a id="_idIndexMarker128"/>doesn’t appear to be in the fetched data because it is <strong class="source-inline">undefined</strong> when it is output to <span class="No-Break">the console.</span></p>
			<p>Why wasn’t a type error raised on line 4 where <strong class="source-inline">firstName</strong> was referenced? Well, <strong class="source-inline">data</strong> is of the type <strong class="source-inline">any</strong>, which means no type checking will occur on it. You can hover over <strong class="source-inline">data</strong> to confirm that it has been given the <span class="No-Break"><strong class="source-inline">any</strong></span><span class="No-Break"> type.</span></p>
			<ol>
				<li value="3">Give <strong class="source-inline">data</strong> the <strong class="source-inline">unknown</strong> <span class="No-Break">type annotation:</span><pre class="source-code">
 fetch("https://swapi.dev/api/people/1")</pre><pre class="source-code">
  .then((response) =&gt; response.json())</pre><pre class="source-code">
  .then((data<strong class="bold">: unknown</strong>) =&gt; {</pre><pre class="source-code">
    console.log("firstName", data.firstName);</pre><pre class="source-code">
  });</pre></li>
			</ol>
			<p>A type error is <a id="_idIndexMarker129"/>now raised where <strong class="source-inline">firstName</strong> <span class="No-Break">is referenced:</span></p>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<img src="image/B19051_02_15.jpg" alt="Figure 2.15 – Type error on unknown data parameter"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.15 – Type error on unknown data parameter</p>
			<p>The <strong class="source-inline">unknown</strong> type is the opposite of the <strong class="source-inline">any</strong> type, as it contains nothing within its type. A type that doesn’t contain anything may seem useless. However, a variable’s type can be widened if cheks are made to allow TypeScript to <span class="No-Break">widen it.</span></p>
			<ol>
				<li value="4">Before we <a id="_idIndexMarker130"/>give TypeScript information to widen <strong class="source-inline">data</strong>, change the property referenced within it from <strong class="source-inline">firstName</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">name</strong></span><span class="No-Break">:</span><pre class="source-code">
fetch("https://swapi.dev/api/people/1")</pre><pre class="source-code">
  .then((response) =&gt; response.json())</pre><pre class="source-code">
  .then((data: unknown) =&gt; {</pre><pre class="source-code">
    console.log("<strong class="bold">name</strong>", data.<strong class="bold">name</strong>);</pre><pre class="source-code">
  });</pre></li>
			</ol>
			<p><strong class="source-inline">name</strong> is a valid property, but a type error is still occurring. This is because <strong class="source-inline">data</strong> is <span class="No-Break">still </span><span class="No-Break"><strong class="source-inline">unknown</strong></span><span class="No-Break">.</span></p>
			<ol>
				<li value="5">Now make<a id="_idIndexMarker131"/> the highlighted changes to the code to widen the <span class="No-Break"><strong class="source-inline">data</strong></span><span class="No-Break"> type:</span><pre class="source-code">
fetch("https://swapi.dev/api/people/1")</pre><pre class="source-code">
  .then((response) =&gt; response.json())</pre><pre class="source-code">
  .then((data: unknown) =&gt; {</pre><pre class="source-code">
    <strong class="bold">if (isCharacter(data)) {</strong></pre><pre class="source-code">
      console.log("name", data.name);</pre><pre class="source-code">
    <strong class="bold">}</strong></pre><pre class="source-code">
  });</pre><pre class="source-code">
<strong class="bold">function isCharacter(</strong></pre><pre class="source-code">
<strong class="bold">  character: any</strong></pre><pre class="source-code">
<strong class="bold">): character is { name: string } {</strong></pre><pre class="source-code">
<strong class="bold">  return "name" in character;</strong></pre><pre class="source-code">
<strong class="bold">}</strong></pre></li>
			</ol>
			<p>The code snippet can be copied <span class="No-Break">from </span><a href="https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter2/Section2-Basic-types/Using-the-unknown-type/code.ts"><span class="No-Break">https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter2/Section2-Basic-types/Using-the-unknown-type/code.ts</span></a><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">if</strong> statement<a id="_idIndexMarker132"/> uses a function called <strong class="source-inline">isCharacter</strong> to verify that a <strong class="source-inline">name</strong> property is contained within the object. The result of this call is <strong class="source-inline">true</strong> in this example, so the logic will flow into the <span class="No-Break"><strong class="source-inline">if</strong></span><span class="No-Break"> branch.</span></p>
			<p>Notice the return type of <strong class="source-inline">isCharacter</strong>, <span class="No-Break">which is:</span></p>
			<pre class="source-code">
character is { name: string }</pre>
			<p>This<a id="_idIndexMarker133"/> is a <strong class="bold">type predicate</strong>. TypeScript will narrow or widen the type of <strong class="source-inline">character</strong> to <strong class="source-inline">{ name: string }</strong> if the function returns <strong class="source-inline">true</strong>. The type predicate is <strong class="source-inline">true</strong> in this example, so <strong class="source-inline">character</strong> is widened to an object with a <strong class="source-inline">name</strong> <span class="No-Break">string property.</span></p>
			<ol>
				<li value="6">Hover over<a id="_idIndexMarker134"/> the <strong class="source-inline">data</strong> variable on each line where it is referenced. <strong class="source-inline">data</strong> starts off with the <strong class="source-inline">unknown</strong> type where it is assigned with a type annotation. Then, it is widened to <strong class="source-inline">{name: string}</strong> inside the <span class="No-Break"><strong class="source-inline">if</strong></span><span class="No-Break"> branch:</span></li>
			</ol>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="image/B19051_02_16.jpg" alt="Figure 2.16 – Widened type given to data"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.16 – Widened type given to data</p>
			<p>Notice that the type error has also <span class="No-Break">disappeared. Nice!</span></p>
			<ol>
				<li value="7">Next, run<a id="_idIndexMarker135"/> the code. You will see <strong class="source-inline">Luke Skywalker</strong> output to <span class="No-Break">the console.</span></li>
			</ol>
			<p>In summary, the <strong class="source-inline">unknown</strong> type <a id="_idIndexMarker136"/>is an excellent choice for data whose type you are unsure about. However, you can’t interact with <strong class="source-inline">unknown</strong> variables – the variable must be widened to a different type before <span class="No-Break">any interaction.</span></p>
			<p>Next, we will learn about a type used for a function not returning <span class="No-Break">a value.</span></p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor058"/>Using the void type</h2>
			<p>The <strong class="source-inline">void</strong> type<a id="_idIndexMarker137"/> is <a id="_idIndexMarker138"/>used to represent a function’s return type where the function doesn’t return <span class="No-Break">a value.</span></p>
			<p>As an example, enter<a id="_idIndexMarker139"/> the following function in the <span class="No-Break">TypeScript Playground:</span></p>
			<pre class="source-code">
function logText(text: string) {
  console.log(text);
}</pre>
			<p>Hovering over the function name confirms that the function return type is given a <span class="No-Break"><strong class="source-inline">void</strong></span><span class="No-Break"> type.</span></p>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="image/B19051_02_17.jpg" alt="Figure 2.17 – Return type confirmed as void"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.17 – Return type confirmed as void</p>
			<p>You may think that you could use <strong class="source-inline">undefined</strong> as the return type for the <span class="No-Break">preceding example:</span></p>
			<pre class="source-code">
function logText(text: string)<strong class="bold">: undefined</strong> {
  console.log(text);
}</pre>
			<p>However, this raises a type error because a return type of <strong class="source-inline">undefined</strong> means that the function is <a id="_idIndexMarker140"/>expected to return a value (of type <strong class="source-inline">undefined</strong>). The example function doesn’t return any value, so the return type <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">void</strong></span><span class="No-Break">.</span></p>
			<p>In summary, <strong class="source-inline">void</strong> is a special type for a function’s return type where the function doesn’t have a <span class="No-Break">return statement.</span></p>
			<p>Next, we will learn about the <span class="No-Break"><strong class="source-inline">never</strong></span><span class="No-Break"> type.</span></p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor059"/>Using the never type</h2>
			<p>The <strong class="source-inline">never</strong> type <a id="_idIndexMarker141"/>represents <a id="_idIndexMarker142"/>something that will never occur and is typically used to specify unreachable code areas. Let’s explore an example <a id="_idIndexMarker143"/>in the <span class="No-Break">TypeScript Playground:</span></p>
			<ol>
				<li value="1">Remove any existing code and enter the <span class="No-Break">following code:</span><pre class="source-code">
function foreverTask(taskName: string): never {</pre><pre class="source-code">
  while (true) {</pre><pre class="source-code">
    console.log(`Doing ${taskName} over and over again       ...`);</pre><pre class="source-code">
  }</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>The function invokes an infinite loop, meaning the function is never exited. So, we have given the function a return type annotation of <strong class="source-inline">never</strong> because we don’t expect the function to be exited. This is different from <strong class="source-inline">void</strong> because <strong class="source-inline">void</strong> means it <em class="italic">will</em> exit, but with <span class="No-Break">no value.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">We used a JavaScript template literal to construct the string to output to the console in the preceding example. Template literals are enclosed by backticks (<strong class="source-inline">` `</strong>) and can include a JavaScript expression in curly braces prefixed with a dollar sign (<strong class="source-inline">${expression}</strong>). Template literals are great when we need to merge static text with variables. See this link for more information on template <span class="No-Break">literals: </span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals"><span class="No-Break">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals</span></a><span class="No-Break">.</span></p>
			<ol>
				<li value="2">Change<a id="_idIndexMarker144"/> the <strong class="source-inline">foreverTask</strong> function to break out of <span class="No-Break">the loop:</span><pre class="source-code">
function foreverTask(taskName: string): never {</pre><pre class="source-code">
  while (true) {</pre><pre class="source-code">
    console.log(`Doing ${taskName} over and over again       ...`);</pre><pre class="source-code">
    <strong class="bold">break;</strong></pre><pre class="source-code">
  }</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>TypeScript quite <span class="No-Break">rightly complains:</span></p>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<img src="image/B19051_02_18.jpg" alt="Figure 2.18 – Type error on the never return type"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.18 – Type error on the never return type</p>
			<ol>
				<li value="3">Remove<a id="_idIndexMarker145"/> the <strong class="source-inline">break</strong> statement and remove the <strong class="source-inline">never</strong> return <span class="No-Break">type annotation:</span><pre class="source-code">
function foreverTask(taskName: string) {</pre><pre class="source-code">
  while (true) {</pre><pre class="source-code">
    console.log(`Doing ${taskName} over and over again ...`);</pre><pre class="source-code">
  }</pre><pre class="source-code">
}</pre></li>
				<li>Hover over the <strong class="source-inline">foreverTask</strong> function name with your mouse. We can see that TypeScript has inferred the return type <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">void</strong></span><span class="No-Break">:</span></li>
			</ol>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/B19051_02_19.jpg" alt="Figure 2.19 – Return type inferred as void"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.19 – Return type inferred as void</p>
			<p>So, TypeScript <a id="_idIndexMarker146"/>is unable to infer the <strong class="source-inline">never</strong> type<a id="_idIndexMarker147"/> in this case. Instead, it infers the return type as <strong class="source-inline">void</strong>, which means the function will exit with no value, which isn’t the case in this example. This is a reminder to always check the inferred type and resort to using a type annotation <span class="No-Break">where appropriate.</span></p>
			<p>In summary, the <strong class="source-inline">never</strong> type is used in places where code <span class="No-Break">never reaches.</span></p>
			<p>Next up, let’s <span class="No-Break">cover arrays.</span></p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor060"/>Using arrays</h2>
			<p>Arrays <a id="_idIndexMarker148"/>are<a id="_idIndexMarker149"/> structures that TypeScript inherits from JavaScript. We add type annotations to arrays as usual, but with square brackets <strong class="source-inline">[]</strong> at the end to denote that this is an <span class="No-Break">array type.</span></p>
			<p>Let’s explore an<a id="_idIndexMarker150"/> example in the <span class="No-Break">TypeScript Playground:</span></p>
			<ol>
				<li value="1">Remove any existing code, and enter <span class="No-Break">the following:</span><pre class="source-code">
const numbers<strong class="bold">: number[]</strong> = [];</pre></li>
			</ol>
			<p>Alternatively, the <strong class="source-inline">Array</strong> generic type syntax can <span class="No-Break">be used:</span></p>
			<pre class="source-code">
const numbers<strong class="bold">: Array&lt;number&gt;</strong> = [];</pre>
			<p>We will learn about generics in TypeScript in <a href="B19051_11.xhtml#_idTextAnchor273"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>, <span class="No-Break"><em class="italic">Reusable Components</em></span><span class="No-Break">.</span></p>
			<ol>
				<li value="2">Add <strong class="source-inline">1</strong> to the array by using the array’s <span class="No-Break"><strong class="source-inline">push</strong></span><span class="No-Break"> function:</span><pre class="source-code">
numbers.push(1);</pre></li>
				<li>Now<a id="_idIndexMarker151"/> add a string to <span class="No-Break">the array:</span><pre class="source-code">
numbers.push("two");</pre></li>
			</ol>
			<p>A type error is raised as we <span class="No-Break">would expect:</span></p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="image/B19051_02_20.jpg" alt="Figure 2.20 – Type error when adding a string type to a number array"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.20 – Type error when adding a string type to a number array</p>
			<ol>
				<li value="4">Now <a id="_idIndexMarker152"/>replace all the code with <span class="No-Break">the following:</span><pre class="source-code">
const numbers = [1, 2, 3];</pre></li>
				<li>Hover over <strong class="source-inline">numbers</strong> to verify that TypeScript has inferred its type to <span class="No-Break">be </span><span class="No-Break"><strong class="source-inline">number[]</strong></span><span class="No-Break">.</span></li>
			</ol>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/B19051_02_21.jpg" alt="Figure 2.21 – Array type inference"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.21 – Array type inference</p>
			<p>Excellent – we can see that TypeScript’s type inference works <span class="No-Break">with arrays!</span></p>
			<p>Arrays are one of the most common types used to structure data. In the preceding examples, we’ve only used an array with elements having a <strong class="source-inline">number</strong> type, but any type can be used for elements, including objects, which have their <span class="No-Break">own properties.</span></p>
			<p>Here’s a recap of all<a id="_idIndexMarker153"/> the basic types we have learned in <span class="No-Break">this section:</span></p>
			<ul>
				<li>TypeScript adds many useful types to JavaScripts types, such as <strong class="source-inline">Date</strong>, and is capable of <span class="No-Break">representing arrays.</span></li>
				<li>TypeScript can infer a variable’s type from its assigned value. A type annotation can be used where type inference doesn’t give the <span class="No-Break">desired type.</span></li>
				<li>No type <a id="_idIndexMarker154"/>checking occurs on variables with the <strong class="source-inline">any</strong> type, so this type should <span class="No-Break">be avoided.</span></li>
				<li>The <strong class="source-inline">unknown</strong> type is a strongly-typed alternative to <strong class="source-inline">any</strong>, but <strong class="source-inline">unknown</strong> variables must be widened to be <span class="No-Break">interacted with.</span></li>
				<li><strong class="source-inline">void</strong> is a return type for a function that doesn’t return <span class="No-Break">a value.</span></li>
				<li>The <strong class="source-inline">never</strong> type can be used to mark unreachable areas <span class="No-Break">of code.</span></li>
				<li>Array types can be defined using square brackets after the array <span class="No-Break">item type.</span></li>
			</ul>
			<p>In the next section, we will learn how to create our <span class="No-Break">own types.</span></p>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor061"/>Creating TypeScript types</h1>
			<p>The last section<a id="_idIndexMarker155"/> showed that TypeScript has a great set of standard types. In this section, we will learn how to create our own types. We will start by learning three different methods for creating object types. We will then learn about strongly-typing JavaScript classes. Lastly, we will learn two different methods for creating types for variables that hold a range <span class="No-Break">of values.</span></p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor062"/>Using object types</h2>
			<p>Objects <a id="_idIndexMarker156"/>are very common in JavaScript programs, so<a id="_idIndexMarker157"/> learning how to represent them in TypeScript is really important. In fact, we have already used an object type earlier in this chapter for the <strong class="source-inline">product</strong> parameter in the <strong class="source-inline">calculateTotalPrice</strong> function. Here is a reminder of the <strong class="source-inline">product</strong> parameter’s <span class="No-Break">type annotation:</span></p>
			<pre class="source-code">
function calculateTotalPrice(
  product: <strong class="bold">{ name: string; unitPrice: number }</strong>,
  ...
) {
  ...
}</pre>
			<p>An <a id="_idIndexMarker158"/>object type <a id="_idIndexMarker159"/>in TypeScript is represented a bit like a JavaScript object literal. However, instead of property values, property types are specified instead. Properties in the object definitions can be separated by semicolons or commas, but using a semicolon is <span class="No-Break">common practice.</span></p>
			<p>Clear any existing code in the <a id="_idIndexMarker160"/>TypeScript Playground and follow this example to explore <span class="No-Break">object types:</span></p>
			<ol>
				<li value="1">Enter the following variable assignment to <span class="No-Break">an object:</span><pre class="source-code">
let table = {name: "Table", unitPrice: 450};</pre></li>
			</ol>
			<p>If you hover over the <strong class="source-inline">table</strong> variable, you’ll see it is inferred to be the <span class="No-Break">following type:</span></p>
			<pre class="source-code">
{
  name: string;
  unitPrice: number;
}</pre>
			<p>So, type inference works nicely <span class="No-Break">for objects.</span></p>
			<ol>
				<li value="2">Now, on the next line, try to set a <strong class="source-inline">discount</strong> property <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">10</strong></span><span class="No-Break">:</span><pre class="source-code">
table.discount = 10;</pre></li>
			</ol>
			<p>A <strong class="source-inline">discount</strong> property doesn’t exist in the type, though – only the <strong class="source-inline">name</strong> and <strong class="source-inline">unitPrice</strong> properties exist. So, a type <span class="No-Break">error occurs.</span></p>
			<ol>
				<li value="3">Let’s say we want to represent a <strong class="source-inline">product</strong> object containing the <strong class="source-inline">name</strong> and <strong class="source-inline">unitPrice</strong> properties, but we want <strong class="source-inline">unitPrice</strong> to be optional. Remove the existing code and <a id="_idIndexMarker161"/>replace it with <span class="No-Break">the following:</span><pre class="source-code">
const table: { name: string; unitPrice: number } = {</pre><pre class="source-code">
  name: "Table",</pre><pre class="source-code">
};</pre></li>
				<li>This raises<a id="_idIndexMarker162"/> a type error because <strong class="source-inline">unitPrice</strong> is a required property in the type annotation. We can use a <strong class="source-inline">?</strong> symbol as follows to make this optional rather <span class="No-Break">than required:</span><pre class="source-code">
const table: { name: string; unitPrice<strong class="bold">?</strong>: number } = {</pre><pre class="source-code">
  name: "Table",</pre><pre class="source-code">
};</pre></li>
			</ol>
			<p>The type <span class="No-Break">error disappears.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">?</strong> symbol can be used in functions for optional parameters. For example, <strong class="source-inline">myFunction(requiredParam: string, </strong><span class="No-Break"><strong class="source-inline">optionalParam</strong></span><span class="No-Break"><strong class="bold">?</strong></span><span class="No-Break"><strong class="source-inline">: string)</strong></span><span class="No-Break">.</span></p>
			<p>Now, let’s learn a way to streamline object <span class="No-Break">type definitions.</span></p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor063"/>Creating type aliases</h2>
			<p>The type annotation <a id="_idIndexMarker163"/>we used in the last example was quite lengthy and would be longer for more complex object structures. Also, having <a id="_idIndexMarker164"/>to write the same object structure to assign to different variables is a <span class="No-Break">little frustrating:</span></p>
			<pre class="source-code">
const table: { name: string; unitPrice?: number } = ...;
const chair: { name: string; unitPrice?: number } = ...;</pre>
			<p><strong class="bold">Type aliases</strong> solve these problems. As the name suggests, a type alias refers to another type, and the syntax is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
type YourTypeAliasName = AnExistingType;</pre>
			<p>Open the TypeScript Playground <a id="_idIndexMarker165"/>and follow along to explore<a id="_idIndexMarker166"/> <span class="No-Break">type aliases:</span></p>
			<ol>
				<li value="1">Start by creating a type alias for the product object structure we used in the <span class="No-Break">last example:</span><pre class="source-code">
type Product = { name: string; unitPrice?: number };</pre></li>
				<li>Now assign two variables to this <span class="No-Break"><strong class="source-inline">Product</strong></span><span class="No-Break"> type:</span><pre class="source-code">
let table: Product = { name: "Table" };</pre><pre class="source-code">
let chair: Product = { name: "Chair", unitPrice: 40 };</pre></li>
			</ol>
			<p>That’s <span class="No-Break">much cleaner!</span></p>
			<ol>
				<li value="3">A type alias can extend another object using the <strong class="source-inline">&amp;</strong> symbol. Create a second type for a discounted product by adding the following <span class="No-Break">type alias:</span><pre class="source-code">
type DiscountedProduct = Product &amp; { discount: number };</pre></li>
			</ol>
			<p><strong class="source-inline">DiscountedProduct</strong> represents an object containing <strong class="source-inline">name</strong>, <strong class="source-inline">unitPrice</strong> (optional), and <span class="No-Break"><strong class="source-inline">discount</strong></span><span class="No-Break"> properties.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">A type that extends another using the <strong class="source-inline">&amp;</strong> symbol is referred<a id="_idIndexMarker167"/> to as an <span class="No-Break"><strong class="bold">intersection type</strong></span><span class="No-Break">.</span></p>
			<ol>
				<li value="4">Add the following variable with the <strong class="source-inline">DiscountedProduct</strong> type <span class="No-Break">as follows:</span><pre class="source-code">
let chairOnSale: DiscountedProduct = {</pre><pre class="source-code">
  name: "Chair on Sale",</pre><pre class="source-code">
  unitPrice: 30,</pre><pre class="source-code">
  discount: 5,</pre><pre class="source-code">
};</pre></li>
				<li>A type alias can also be used to represent a function. Add the following type alias to represent <span class="No-Break">a function:</span><pre class="source-code">
type Purchase = (quantity: number) =&gt; void;</pre></li>
			</ol>
			<p>The <a id="_idIndexMarker168"/>preceding type represents a function containing a <strong class="source-inline">number</strong> parameter and doesn’t <span class="No-Break">return anything.</span></p>
			<ol>
				<li value="6">Use<a id="_idIndexMarker169"/> the <strong class="source-inline">Purchase</strong> type to create a <strong class="source-inline">purchase</strong> function property in the <strong class="source-inline">Product</strong> type <span class="No-Break">as follows:</span><pre class="source-code">
type Purchase = (quantity: number) =&gt; void;</pre><pre class="source-code">
type Product = {</pre><pre class="source-code">
  name: string;</pre><pre class="source-code">
  unitPrice?: number;</pre><pre class="source-code">
  <strong class="bold">purchase: Purchase;</strong></pre><pre class="source-code">
};</pre></li>
			</ol>
			<p>Type errors will be raised on the <strong class="source-inline">table</strong>, <strong class="source-inline">chair</strong>, and <strong class="source-inline">chairOnSale</strong> variable declarations because the <strong class="source-inline">purchase</strong> function property <span class="No-Break">is required.</span></p>
			<ol>
				<li value="7">Add a <strong class="source-inline">purchase</strong> function property to the <strong class="source-inline">table</strong> variable declarations <span class="No-Break">as follows:</span><pre class="source-code">
let table: Product = {</pre><pre class="source-code">
  name: "Table"<strong class="bold">,</strong></pre><pre class="source-code">
  <strong class="bold">purchase: (quantity) =&gt;</strong></pre><pre class="source-code">
<strong class="bold">    console.log(`Purchased ${quantity} tables`),</strong></pre><pre class="source-code">
};</pre><pre class="source-code">
<strong class="bold">table.purchase(4);</strong></pre></li>
			</ol>
			<p>The type error is resolved on the <strong class="source-inline">table</strong> <span class="No-Break">variable declaration.</span></p>
			<ol>
				<li value="8">A purchase property could be added in a similar way to the <strong class="source-inline">chair</strong> and <strong class="source-inline">chairOnSale</strong> variable declarations to resolve their type errors. However, ignore these type errors for this exploration and move on to the <span class="No-Break">next step.</span></li>
				<li>Click the <strong class="bold">Run</strong> option<a id="_idIndexMarker170"/> to run the code that purchases four tables. <strong class="bold">“Purchased 4 tables”</strong> is output to <span class="No-Break">the console.</span></li>
			</ol>
			<p>In summary, type aliases<a id="_idIndexMarker171"/> allow existing types to be composed together and improve the readability and reusability of types. We will use type aliases extensively in <span class="No-Break">this book.</span></p>
			<p>Next, we will explore an alternative method of creating types. Leave the TypeScript Playground open with the code intact – we’ll use this in the <span class="No-Break">next section.</span></p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor064"/>Creating interfaces</h2>
			<p>As we <a id="_idIndexMarker172"/>created in <a id="_idIndexMarker173"/>the last example with type aliases, object types can be created using TypeScript’s <strong class="bold">interface</strong> syntax. An interface is created with the <strong class="source-inline">interface</strong> keyword, followed by its name, followed by the bits that make up the <strong class="source-inline">interface</strong> in <span class="No-Break">curly brackets:</span></p>
			<pre class="source-code">
interface Product {
  ...
}</pre>
			<p>Go to the TypeScript Playground that contains the code from the type alias exploration, and follow along to <a id="_idIndexMarker174"/><span class="No-Break">explore interfaces:</span></p>
			<ol>
				<li value="1">Start by replacing the <strong class="source-inline">Product</strong> type alias with a <strong class="source-inline">Product</strong> interface <span class="No-Break">as follows:</span><pre class="source-code">
interface Product {</pre><pre class="source-code">
  name: string;</pre><pre class="source-code">
  unitPrice?: number;</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>The <strong class="source-inline">table</strong> variable assignment has a type error because the <strong class="source-inline">purchase</strong> property doesn’t exist yet – we’ll add this in <em class="italic">step 4</em>. However, the <strong class="source-inline">chair</strong> variable assignment compiles <span class="No-Break">without error.</span></p>
			<ol>
				<li value="2">An interface <a id="_idIndexMarker175"/>can extend another interface using the <strong class="source-inline">extends</strong> keyword. Replace the <strong class="source-inline">DiscountedProduct</strong> type alias with the <span class="No-Break">following interface:</span><pre class="source-code">
interface DiscountedProduct extends Product {</pre><pre class="source-code">
  discount: number;</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>Notice that<a id="_idIndexMarker176"/> the <strong class="source-inline">chairOnSale</strong> variable assignment compiles <span class="No-Break">without error.</span></p>
			<ol>
				<li value="3">An interface can also be used to represent a function. Add the following interface to represent a function, replacing the type <span class="No-Break">alias version:</span><pre class="source-code">
interface Purchase {(quantity: number): void}</pre></li>
			</ol>
			<p>The interface syntax for creating functions isn’t as intuitive as using a <span class="No-Break">type alias.</span></p>
			<ol>
				<li value="4">Add the <strong class="source-inline">Purchase</strong> interface to the <strong class="source-inline">Product</strong> interface <span class="No-Break">as follows:</span><pre class="source-code">
interface Product {</pre><pre class="source-code">
  name: string;</pre><pre class="source-code">
  unitPrice?: number;</pre><pre class="source-code">
<strong class="bold">  purchase: Purchase;</strong></pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>The type error on the <strong class="source-inline">table</strong> variable declarations is resolved now, but type errors are raised on the <strong class="source-inline">chair</strong> and <strong class="source-inline">chairOnSale</strong> <span class="No-Break">variable declarations.</span></p>
			<ol>
				<li value="5">Click the <strong class="bold">Run</strong> option to run the code that purchases four tables. <strong class="bold">“Purchased 4 tables”</strong> is output to <span class="No-Break">the console.</span></li>
			</ol>
			<p>In the preceding steps, we carried out the same tasks using an interface as we did using a type alias. So, the obvious question is, <em class="italic">when should I use a type alias instead of an interface and vice versa?</em> The capabilities of type aliases and interfaces for creating object types are very similar – so the simple answer is that it is down to preference for object types. Type aliases <a id="_idIndexMarker177"/>can create types that interfaces <a id="_idIndexMarker178"/>can’t, though, such as union types, which we shall cover later in this chapter. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">See the following link for more information on the differences between type aliases and <span class="No-Break">interfaces: </span><a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces"><span class="No-Break">https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces</span></a><span class="No-Break">.</span></p>
			<p class="callout">The rest of this book uses type aliases rather than interfaces to <span class="No-Break">define types.</span></p>
			<p>Next, we will learn how to use TypeScript <span class="No-Break">with classes.</span></p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor065"/>Creating classes</h2>
			<p>A <strong class="bold">class</strong> is a standard <a id="_idIndexMarker179"/>JavaScript feature that acts as a template for creating an object. Properties and methods defined in the class are automatically included in objects created from <span class="No-Break">the class.</span></p>
			<p>Open the TypeScript <a id="_idIndexMarker180"/>Playground, remove any existing code, and <a id="_idIndexMarker181"/>carry out the following steps to explore classes <span class="No-Break">in TypeScript:</span></p>
			<ol>
				<li value="1">Add the following code to create a class to represent a product with properties for the name and <span class="No-Break">unit price:</span><pre class="source-code">
class Product {</pre><pre class="source-code">
  name;</pre><pre class="source-code">
  unitPrice;</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>If you hover over the <strong class="source-inline">name</strong> and <strong class="source-inline">unitPrice</strong> properties, you’ll see that they have the <strong class="source-inline">any</strong> type. As we know, that means no type checking will occur <span class="No-Break">on them.</span></p>
			<ol>
				<li value="2">Add the <a id="_idIndexMarker182"/>following type annotations to <span class="No-Break">the properties:</span><pre class="source-code">
class Product {</pre><pre class="source-code">
  name<strong class="bold">: string</strong>;</pre><pre class="source-code">
  unitPrice<strong class="bold">: number</strong>;</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>Unfortunately, TypeScript <a id="_idIndexMarker183"/>raises the <span class="No-Break">following error:</span></p>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="image/B19051_02_22.jpg" alt="Figure 2.22 – Type errors on the class properties"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.22 – Type errors on the class properties</p>
			<p>The error is because when an instance of the class is created, those property values would be <strong class="source-inline">undefined</strong>, which isn’t within the <strong class="source-inline">string</strong> or <span class="No-Break"><strong class="source-inline">number</strong></span><span class="No-Break"> types.</span></p>
			<ol>
				<li value="3">A solution would be to make the properties optional so that they can accept <strong class="source-inline">undefined</strong> as a value. Try this solution by adding a <strong class="source-inline">?</strong> symbol at the start of the <span class="No-Break">type annotations:</span><pre class="source-code">
class Product {</pre><pre class="source-code">
  name<strong class="bold">?</strong>: string;</pre><pre class="source-code">
  unitPrice<strong class="bold">?</strong>: number;</pre><pre class="source-code">
}</pre></li>
				<li>If we don’t <a id="_idIndexMarker184"/>want the values to initially be <strong class="source-inline">undefined</strong>, we can assign initial values <span class="No-Break">like so:</span><pre class="source-code">
class Product {</pre><pre class="source-code">
  name <strong class="bold">= ""</strong>;</pre><pre class="source-code">
  unitPrice <strong class="bold">= 0</strong>;</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>If you hover over the properties now, you will see that <strong class="source-inline">name</strong> has been inferred to be a <strong class="source-inline">string</strong> type, and <strong class="source-inline">unitPrice</strong> has been inferred to be a <span class="No-Break"><strong class="source-inline">number</strong></span><span class="No-Break"> type.</span></p>
			<ol>
				<li value="5">Another <a id="_idIndexMarker185"/>method of adding types to class properties is in a constructor. Remove the values assigned to the properties and add a constructor to the class <span class="No-Break">as follows:</span><pre class="source-code">
class Product {</pre><pre class="source-code">
  name;</pre><pre class="source-code">
  unitPrice;</pre><pre class="source-code">
  <strong class="bold">constructor(name: string, unitPrice: number) {</strong></pre><pre class="source-code">
<strong class="bold">    this.name = name;</strong></pre><pre class="source-code">
<strong class="bold">    this.unitPrice = unitPrice;</strong></pre><pre class="source-code">
<strong class="bold">  }</strong></pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>If you hover over the properties, you’ll see that the correct types have <span class="No-Break">been inferred.</span></p>
			<ol>
				<li value="6">In fact, the properties don’t need to be defined if the constructor parameters are marked <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">public</strong></span><span class="No-Break">.</span><pre class="source-code">
class Product {</pre><pre class="source-code">
  constructor(<strong class="bold">public</strong> name: string, <strong class="bold">public</strong> unitPrice:     number) {</pre><pre class="source-code">
    this.name = name;</pre><pre class="source-code">
    this.unitPrice = unitPrice;</pre><pre class="source-code">
  }</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>TypeScript <a id="_idIndexMarker186"/>will automatically create properties for constructor parameters that are marked <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">public</strong></span><span class="No-Break">.</span></p>
			<ol>
				<li value="7">Type <a id="_idIndexMarker187"/>annotations can be added to method parameters and return values, just like we have previously done <span class="No-Break">for functions:</span><pre class="source-code">
class Product {</pre><pre class="source-code">
  constructor(public name: string, public unitPrice:     number) {</pre><pre class="source-code">
    this.name = name;</pre><pre class="source-code">
    this.unitPrice = unitPrice;</pre><pre class="source-code">
  }</pre><pre class="source-code">
  <strong class="bold">getDiscountedPrice(discount: number): number {</strong></pre><pre class="source-code">
<strong class="bold">    return this.unitPrice - discount;</strong></pre><pre class="source-code">
<strong class="bold">  }</strong></pre><pre class="source-code">
}</pre></li>
				<li>Now create an instance of the class and output its discounted price to <span class="No-Break">the console:</span><pre class="source-code">
const table = new Product("Table", 45);</pre><pre class="source-code">
console.log(table.getDiscountedPrice(5));</pre></li>
			</ol>
			<p>If you run the code, <strong class="bold">40</strong> is output to <span class="No-Break">the console.</span></p>
			<p>In summary, class properties can be given a type in a constructor or by assigning a default value. Class methods<a id="_idIndexMarker188"/> can be strongly-typed just like <a id="_idIndexMarker189"/>regular <span class="No-Break">JavaScript functions.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">For more information <a id="_idIndexMarker190"/>on classes, see the following <span class="No-Break">link: </span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes"><span class="No-Break">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes</span></a><span class="No-Break">.</span></p>
			<p>Next, we will learn how to create a type to represent a range <span class="No-Break">of values.</span></p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor066"/>Creating enumerations</h2>
			<p><strong class="bold">Enumerations</strong> allow us <a id="_idIndexMarker191"/>to declare a meaningful set of friendly names that a variable can be set to. We use the <strong class="source-inline">enum</strong> keyword, followed by the name we want to give to it, and then its possible values in <span class="No-Break">curly braces.</span></p>
			<p>Let’s explore<a id="_idIndexMarker192"/> an <a id="_idIndexMarker193"/>example in the <span class="No-Break">TypeScript Playground:</span></p>
			<ol>
				<li value="1">Start by creating the enumeration for <strong class="source-inline">Level</strong> containing <strong class="source-inline">Low</strong>, <strong class="source-inline">Medium</strong>, and <span class="No-Break"><strong class="source-inline">High</strong></span><span class="No-Break"> values:</span><pre class="source-code">
enum Level {</pre><pre class="source-code">
  Low,</pre><pre class="source-code">
  Medium,</pre><pre class="source-code">
  High</pre><pre class="source-code">
}</pre></li>
				<li>Now, create a <strong class="source-inline">level</strong> variable and assign it to the values <strong class="source-inline">Low</strong> and then <strong class="source-inline">High</strong> from the <strong class="source-inline">Level</strong> enumeration. Also, output the <strong class="source-inline">level</strong> values to <span class="No-Break">the console:</span><pre class="source-code">
let level = Level.Low;</pre><pre class="source-code">
console.log(level);</pre><pre class="source-code">
level = Level.High</pre><pre class="source-code">
console.log(level);</pre></li>
			</ol>
			<p>Notice that you get IntelliSense as you reference <span class="No-Break">the enumeration.</span></p>
			<ol>
				<li value="3">Click the <strong class="bold">Run</strong> option to execute the code and observe the <span class="No-Break">enumeration values:</span></li>
			</ol>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="image/B19051_02_23.jpg" alt="Figure 2.23 – Output of enumeration values"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.23 – Output of enumeration values</p>
			<p>By <a id="_idIndexMarker194"/>default, enumerations<a id="_idIndexMarker195"/> are zero-based numbers (this means that the first enumeration value is 0, the next is 1, the next is 2, and so on). In the preceding example, <strong class="source-inline">Level.Low</strong> is <strong class="source-inline">0</strong>, <strong class="source-inline">Level.Medium</strong> is <strong class="source-inline">1</strong>, and <strong class="source-inline">Level.High</strong> <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">2</strong></span><span class="No-Break">.</span></p>
			<ol>
				<li value="4">Instead of the default values, custom values can be explicitly defined against each enumeration item after the equals (<strong class="source-inline">=</strong>) symbol. Explicitly set the values to be between <strong class="source-inline">1</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">3</strong></span><span class="No-Break">:</span><pre class="source-code">
enum Level {</pre><pre class="source-code">
  Low = 1,</pre><pre class="source-code">
  Medium = 2,</pre><pre class="source-code">
  High = 3</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>You can rerun the code to verify <span class="No-Break">this works.</span></p>
			<ol>
				<li value="5">Now, let’s do something interesting. Assign <strong class="source-inline">level</strong> to a number greater <span class="No-Break">than 3:</span><pre class="source-code">
level = 10;</pre></li>
			</ol>
			<p>Notice that a type error <em class="italic">doesn’t</em> occur. This is a little surprising – number-based enumerations aren’t as type-safe as we <span class="No-Break">would like.</span></p>
			<ol>
				<li value="6">Instead of <a id="_idIndexMarker196"/>using number enumeration <a id="_idIndexMarker197"/>values, let’s try strings. Replace all of the current code with <span class="No-Break">the following:</span><pre class="source-code">
enum Level {</pre><pre class="source-code">
  Low = "L",</pre><pre class="source-code">
  Medium = "M",</pre><pre class="source-code">
  High = "H"</pre><pre class="source-code">
}</pre><pre class="source-code">
let level = Level.Low;</pre><pre class="source-code">
console.log(level);</pre><pre class="source-code">
level = Level.High</pre><pre class="source-code">
console.log(level);</pre></li>
			</ol>
			<p>If this code is run, we see <strong class="bold">L</strong> and <strong class="bold">H</strong> output to the console <span class="No-Break">as expected.</span></p>
			<ol>
				<li value="7">Add another line that assigns <strong class="source-inline">level</strong> to the <span class="No-Break">following strings:</span><pre class="source-code">
level = "VH";</pre><pre class="source-code">
level = "M"</pre></li>
			</ol>
			<p>We immediately see type errors raised on <span class="No-Break">these assignments:</span></p>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="image/B19051_02_24.jpg" alt="Figure 2.24 – Confirmation that string enumerations are type-safe"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.24 – Confirmation that string enumerations are type-safe</p>
			<p>In summary, enumerations <a id="_idIndexMarker198"/>are a way of representing a <a id="_idIndexMarker199"/>range of values with user-friendly names. They are zero-based numbers by default and not as type-safe as we would like. However, we can make enumerations string-based, which is <span class="No-Break">more type-safe.</span></p>
			<p>Next, we will learn about union types <span class="No-Break">in TypeScript.</span></p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor067"/>Creating union types</h2>
			<p>A <strong class="bold">union type</strong> is<a id="_idIndexMarker200"/> the <a id="_idIndexMarker201"/>mathematical union of multiple other types to create a new type. Like enumerations, union types can represent a range of values. As mentioned earlier, type aliases can be used to create <span class="No-Break">union types.</span></p>
			<p>An <a id="_idIndexMarker202"/>example of a union type is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
type Level = "H" | "M" | "L";</pre>
			<p>This <strong class="source-inline">Level</strong> type is similar to the enumeration version of the <strong class="source-inline">Level</strong> type we created earlier. The difference is that the union type only contains values (<strong class="source-inline">"H"</strong>, <strong class="source-inline">"M"</strong>, <strong class="source-inline">"L"</strong>) rather than a name (<strong class="source-inline">"High"</strong>, <strong class="source-inline">"Medium"</strong>, <strong class="source-inline">"Large"</strong>) and <span class="No-Break">a value.</span></p>
			<p>Clear any existing code in the TypeScript Playground, and let’s have a play with <span class="No-Break">union types:</span></p>
			<ol>
				<li value="1">Start by creating a type to represent <strong class="source-inline">"red"</strong>, <strong class="source-inline">"green"</strong>, <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">"blue"</strong></span><span class="No-Break">:</span><pre class="source-code">
type RGB = "red" | "green" | "blue";</pre></li>
			</ol>
			<p>Note that this type is a union of strings, but a union type can consist of any types – even <span class="No-Break">mixed types!</span></p>
			<ol>
				<li value="2">Create <a id="_idIndexMarker203"/>a variable with the <strong class="source-inline">RGB</strong> type and<a id="_idIndexMarker204"/> assign a <span class="No-Break">valid value:</span><pre class="source-code">
let color: RGB = "red";</pre></li>
				<li>Now try assigning a value outside <span class="No-Break">the type:</span><pre class="source-code">
color = "yellow";</pre></li>
			</ol>
			<p>A type error occurs, <span class="No-Break">as expected:</span></p>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="image/B19051_02_25.jpg" alt="Figure 2.25 – Type error on the union type"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.25 – Type error on the union type</p>
			<p>Union types consisting of strings are great when a type can only hold a specific set of strings, as in the <span class="No-Break">preceding example.</span></p>
			<p>Here’s a recap of what we have learned about <span class="No-Break">creating types:</span></p>
			<ul>
				<li>Objects and functions can be represented using type aliases or interfaces. They have very similar capabilities, but the type alias syntax is a little more intuitive for <span class="No-Break">representing functions.</span></li>
				<li>The <strong class="source-inline">?</strong> symbol can specify that an object property or function parameter <span class="No-Break">is optional.</span></li>
				<li>Type annotations can be added to class properties and constructor and method parameters to make <span class="No-Break">them type-safe.</span></li>
				<li>Like string-based <a id="_idIndexMarker205"/>union types, string-based <a id="_idIndexMarker206"/>enumerations are great for a specific set of strings. A string union type is the simplest approach if the strings are meaningful. If the strings aren’t meaningful, then a string enumeration can be used to make <span class="No-Break">them readable.</span></li>
			</ul>
			<p>Now that we have covered types, next, we will learn about the <span class="No-Break">TypeScript compiler.</span></p>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor068"/>Using the TypeScript compiler</h1>
			<p>In this section, we<a id="_idIndexMarker207"/> will learn how to use the TypeScript compiler to type check code and transpile it into JavaScript. First, we will use Visual Studio Code and create a simple TypeScript project containing code we have written in a previous section. We will then use the terminal within Visual Studio Code to interact with the <span class="No-Break">TypeScript compiler.</span></p>
			<p>Open Visual Studio Code in a blank folder of your choice, and carry out the <span class="No-Break">following steps:</span></p>
			<ol>
				<li value="1">In the <strong class="bold">EXPLORER</strong> panel in Visual Studio Code, create a file called <strong class="source-inline">package.json</strong> containing the <span class="No-Break">following content:</span><pre class="source-code">
{</pre><pre class="source-code">
  "name": "tsc-play",</pre><pre class="source-code">
  "dependencies": {</pre><pre class="source-code">
    "typescript": "^4.6.4"</pre><pre class="source-code">
  },</pre><pre class="source-code">
  "scripts": {</pre><pre class="source-code">
    "build": "tsc src/product.ts"</pre><pre class="source-code">
  }</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>The file defines a project name of <strong class="source-inline">tsc-play</strong> and sets TypeScript as the only dependency. The file also defines an npm script called <strong class="source-inline">build</strong> that will invoke the TypeScript compiler (<strong class="source-inline">tsc</strong>), passing it to the <strong class="source-inline">product.ts</strong> file in the <strong class="source-inline">src</strong> folder. Don’t worry that <strong class="source-inline">product.ts</strong> doesn’t exist – we will create it in <span class="No-Break"><em class="italic">step 3</em></span><span class="No-Break">.</span></p>
			<ol>
				<li value="2">Now<a id="_idIndexMarker208"/> open the Visual Studio Code terminal by selecting <strong class="bold">New Terminal</strong> from the <strong class="bold">Terminal</strong> menu, then enter the <span class="No-Break">following command:</span><pre class="source-code">
npm install</pre></li>
			</ol>
			<p>This will install all the libraries listed in the <strong class="source-inline">dependencies</strong> section of <strong class="source-inline">package.json</strong>. So, this will <span class="No-Break">install TypeScript.</span></p>
			<ol>
				<li value="3">Create a folder called <strong class="source-inline">src</strong> and then create a file called <strong class="source-inline">product.ts</strong> <span class="No-Break">within it.</span></li>
				<li>Open <strong class="source-inline">product.ts</strong> and add the <span class="No-Break">following content:</span><pre class="source-code">
class Product {</pre><pre class="source-code">
  constructor(public name: string, public unitPrice:     number) {</pre><pre class="source-code">
    this.name = name;</pre><pre class="source-code">
    this.unitPrice = unitPrice;</pre><pre class="source-code">
  }</pre><pre class="source-code">
  getDiscountedPrice(discount: number): number {</pre><pre class="source-code">
    return this.unitPrice - discount;</pre><pre class="source-code">
  }</pre><pre class="source-code">
}</pre><pre class="source-code">
const table = new Product("Table", 45);</pre><pre class="source-code">
console.log(table.getDiscountedPrice(5));</pre></li>
			</ol>
			<p>This code will be familiar from the section on using classes. The code can be copied <span class="No-Break">from </span><a href="https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter2/Section4-Using-the-compiler/src/product.ts"><span class="No-Break">https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter2/Section4-Using-the-compiler/src/product.ts</span></a><span class="No-Break">.</span></p>
			<ol>
				<li value="5">Enter the<a id="_idIndexMarker209"/> following command in <span class="No-Break">the terminal:</span><pre class="source-code">
npm run build</pre></li>
			</ol>
			<p>This will run the npm <strong class="source-inline">build</strong> script we defined in the <span class="No-Break">first step.</span></p>
			<p>After the command finishes, notice that a <strong class="source-inline">product.js</strong> file appears next to <strong class="source-inline">product.ts</strong> in the <span class="No-Break"><strong class="source-inline">src</strong></span><span class="No-Break"> folder.</span></p>
			<ol>
				<li value="6">Open the transpiled <strong class="source-inline">product.js</strong> file and read the content. It will look <span class="No-Break">as follows:</span><pre class="source-code">
var Product = /** @class */ (function () {</pre><pre class="source-code">
  function Product(name, unitPrice) {</pre><pre class="source-code">
    this.name = name;</pre><pre class="source-code">
    this.unitPrice = unitPrice;</pre><pre class="source-code">
    this.name = name;</pre><pre class="source-code">
    this.unitPrice = unitPrice;</pre><pre class="source-code">
  }</pre><pre class="source-code">
  Product.prototype.getDiscountedPrice = function     (discount) {</pre><pre class="source-code">
    return this.unitPrice - discount;</pre><pre class="source-code">
  };</pre><pre class="source-code">
  return Product;</pre><pre class="source-code">
})();</pre><pre class="source-code">
var table = new Product("Table", 45);</pre><pre class="source-code">
console.log(table.getDiscountedPrice(5));</pre></li>
			</ol>
			<p>Notice that the type annotations have been removed because they aren’t valid JavaScript. Notice also that it has been transpiled to JavaScript, capable of running in very <span class="No-Break">old browsers.</span></p>
			<p>The default <a id="_idIndexMarker210"/>configuration that the TypeScript compiler uses isn’t ideal. For example, we probably want the transpiled JavaScript in a completely separate folder, and are likely to want to target <span class="No-Break">newer browsers.</span></p>
			<ol>
				<li value="7">The TypeScript compiler can be configured using a file called <strong class="source-inline">tsconfig.json</strong>. Add a <strong class="source-inline">tsconfig.json</strong> file at the root of the project, containing the <span class="No-Break">following code:</span><pre class="source-code">
{</pre><pre class="source-code">
  "compilerOptions": {</pre><pre class="source-code">
    "outDir": "build",</pre><pre class="source-code">
    "target": "esnext",</pre><pre class="source-code">
    "module": "esnext",</pre><pre class="source-code">
    "lib": ["DOM", "esnext"],</pre><pre class="source-code">
    "strict": true,</pre><pre class="source-code">
    "jsx": "react",</pre><pre class="source-code">
    "moduleResolution": "node",</pre><pre class="source-code">
    "noEmitOnError": true</pre><pre class="source-code">
  },</pre><pre class="source-code">
  "include": ["src/**/*"],</pre><pre class="source-code">
  "exclude": ["node_modules", "build"]</pre><pre class="source-code">
}</pre></li>
			</ol>
			<p>This code can be copied <span class="No-Break">from </span><a href="https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter2/Section4-Using-the-compiler/tsconfig.json"><span class="No-Break">https://github.com/PacktPublishing/Learn-React-with-TypeScript-2nd-Edition/blob/main/Chapter2/Section4-Using-the-compiler/tsconfig.json</span></a><span class="No-Break">.</span></p>
			<p>Here’s an explanation of each setting in the <span class="No-Break"><strong class="source-inline">compilerOptions</strong></span><span class="No-Break"> field:</span></p>
			<ul>
				<li><strong class="source-inline">outDir</strong>: This is the folder that the transpiled JavaScript is <span class="No-Break">placed in.</span></li>
				<li><strong class="source-inline">target</strong>: This is the version of JavaScript we want to transpile to. The <strong class="source-inline">esnext</strong> target means the <span class="No-Break">next version.</span></li>
				<li><strong class="source-inline">Module</strong>: This is the type of module used within the code. The <strong class="source-inline">esnext</strong> module means standard <span class="No-Break">JavaScript modules.</span></li>
				<li><strong class="source-inline">Lib</strong>: Gives the standard library types included in the type checking process. <strong class="source-inline">DOM</strong> gives the browser DOM API types, and <strong class="source-inline">esnext</strong> are types for APIs in the next version <span class="No-Break">of JavaScript.</span></li>
				<li><strong class="source-inline">Strict</strong>: When set to <strong class="source-inline">true</strong>, means the strictest level of <span class="No-Break">type checking.</span></li>
				<li><strong class="source-inline">Jsx</strong>: When set to <strong class="source-inline">React</strong>, allows the compiler to transpile <span class="No-Break">React’s JSX.</span></li>
				<li><strong class="source-inline">moduleResolution</strong>: This is how dependencies are found. We want TypeScript to look in the <strong class="source-inline">node_modules</strong> folder, so we have <span class="No-Break">chosen </span><span class="No-Break"><strong class="source-inline">node</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">noEmitOnError</strong>: When set to <strong class="source-inline">true</strong>, means the transpilation won’t happen if a type error <span class="No-Break">is found.</span></li>
			</ul>
			<p>The <strong class="source-inline">include</strong> field <a id="_idIndexMarker211"/>specifies the TypeScript files to compile, and the <strong class="source-inline">exclude</strong> field specifies the files <span class="No-Break">to exclude.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">For more information <a id="_idIndexMarker212"/>on the TypeScript compiler options, see the following <span class="No-Break">link: </span><a href="https://www.typescriptlang.org/tsconfig"><span class="No-Break">https://www.typescriptlang.org/tsconfig</span></a><span class="No-Break">.</span></p>
			<ol>
				<li value="8">The TypeScript compiler configuration now specifies all files in the <strong class="source-inline">src</strong> folder to be compiled. So, remove the file path on the <strong class="source-inline">build</strong> script <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">package.json</strong></span><span class="No-Break">:</span><pre class="source-code">
{</pre><pre class="source-code">
  ...,</pre><pre class="source-code">
  "scripts": {</pre><pre class="source-code">
    "build": "<strong class="bold">tsc</strong>"</pre><pre class="source-code">
  }</pre><pre class="source-code">
}</pre></li>
				<li>Delete the previous transpiled <strong class="source-inline">product.js</strong> in the <span class="No-Break"><strong class="source-inline">src</strong></span><span class="No-Break"> folder.</span></li>
				<li>Rerun the <strong class="source-inline">build</strong> command in <span class="No-Break">the terminal:</span><pre class="source-code">
npm run build</pre></li>
			</ol>
			<p>This time the transpiled file is placed in a <strong class="source-inline">build</strong> folder. You will also notice that the transpiled JavaScript now uses classes that are supported in <span class="No-Break">modern browsers.</span></p>
			<ol>
				<li value="11">The final thing<a id="_idIndexMarker213"/> we are going to try is a type error. Open <strong class="source-inline">product.ts</strong> and update the constructor to reference an incorrect <span class="No-Break">property name:</span><pre class="source-code">
class Product {</pre><pre class="source-code">
  constructor(public name: string, public unitPrice:     number) {</pre><pre class="source-code">
    this.name = name;</pre><pre class="source-code">
    this.<strong class="bold">price</strong> = unitPrice;</pre><pre class="source-code">
  }</pre><pre class="source-code">
  ...</pre><pre class="source-code">
}</pre></li>
				<li>Delete the <strong class="source-inline">build</strong> folder to remove the previously transpiled <span class="No-Break">JavaScript file.</span></li>
				<li>Rerun the <strong class="source-inline">build</strong> command in <span class="No-Break">the terminal:</span><pre class="source-code">
npm run build</pre></li>
			</ol>
			<p>The type error is reported in the terminal. Notice that the JavaScript file is <span class="No-Break">not transpiled.</span></p>
			<p>In summary, TypeScript has a compiler, called <strong class="source-inline">tsc</strong>, that we can use to carry out type checking and transpilation as part of a continuous integration process. The compiler is very flexible and can be configured using a file called <strong class="source-inline">tsconfig.json</strong>. It is worth noting that Babel is<a id="_idIndexMarker214"/> often used to transpile TypeScript (as well as React), leaving TypeScript to focus on <span class="No-Break">type checking.</span></p>
			<p>Next, we will recap what we have learned in <span class="No-Break">this chapter.</span></p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor069"/>Summary</h1>
			<p>TypeScript complements JavaScript with a rich type system, and in this chapter, we experienced catching errors early using TypeScript’s <span class="No-Break">type checking.</span></p>
			<p>We also learned that JavaScript types, such as <strong class="source-inline">number</strong> and <strong class="source-inline">string</strong>, can be used in TypeScript, as well as types that only exist in TypeScript, such as <strong class="source-inline">Date</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">unknown</strong></span><span class="No-Break">.</span></p>
			<p>We explored union types and learned that these are great for representing a specific set of strings. We now understand that string enumerations are an alternative to string union types if the string values aren’t <span class="No-Break">very meaningful.</span></p>
			<p>New types can be created using type aliases. We learned that type aliases could be based on objects, functions, or even union types. We now know that the <strong class="source-inline">?</strong> symbol in a type annotation makes an object property or function <span class="No-Break">parameter optional.</span></p>
			<p>We also learned a fair bit about the TypeScript compiler and how it can work well in different use cases because it is very configurable. This will be important when we start to use TypeScript with React in the next chapter. There, we will learn different ways of setting up React and TypeScript projects before learning to strongly-type React props <span class="No-Break">and state.</span></p>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor070"/>Questions</h1>
			<p>Answer the following questions to check what you have learned <span class="No-Break">about TypeScript:</span></p>
			<ol>
				<li value="1">What would the inferred type be for the <strong class="source-inline">flag</strong> variable in the <span class="No-Break">following code?</span><pre class="source-code">
let flag = false;</pre></li>
				<li>What is the return type in the <span class="No-Break">following function?</span><pre class="source-code">
function log(message: string) {</pre><pre class="source-code">
  return console.log(message);</pre><pre class="source-code">
}</pre></li>
				<li>What is the type annotation for an array <span class="No-Break">of dates?</span></li>
				<li>Will a type error occur in the <span class="No-Break">following code?</span><pre class="source-code">
type Point = {x: number; y: number; z?: number};</pre><pre class="source-code">
const point: Point = { x: 24, y: 65 };</pre></li>
				<li>Use a type alias to create a number that can only hold integer values between and including 1 <span class="No-Break">and 3.</span></li>
				<li>What TypeScript compiler option can be used to prevent the transpilation process when a type error <span class="No-Break">is found?</span></li>
				<li>The following code raises a type error because <strong class="source-inline">lastSale</strong> can’t accept <span class="No-Break"><strong class="source-inline">null</strong></span><span class="No-Break"> values:</span><pre class="source-code">
type Product = {</pre><pre class="source-code">
  name: string;</pre><pre class="source-code">
  lastSale: Date;</pre><pre class="source-code">
}</pre><pre class="source-code">
const table: Product = {name: "Table", lastSale: null}</pre></li>
			</ol>
			<p>How can the <strong class="source-inline">Product</strong> type be changed to allow <strong class="source-inline">lastSale</strong> to accept <span class="No-Break"><strong class="source-inline">null</strong></span><span class="No-Break"> values?</span></p>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor071"/>Answers</h1>
			<ol>
				<li value="1">The <strong class="source-inline">flag</strong> variable would be inferred to be a <span class="No-Break"><strong class="source-inline">boolean</strong></span><span class="No-Break"> type.</span></li>
				<li>The return type in the function <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">void</strong></span><span class="No-Break">.</span></li>
				<li>An array of dates can be represented as <strong class="source-inline">Date[]</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">Array&lt;Date&gt;</strong></span><span class="No-Break">.</span></li>
				<li>A type error will not be raised on the <strong class="source-inline">point</strong> variable. It doesn’t need to include the <strong class="source-inline">z</strong> property because it <span class="No-Break">is optional.</span></li>
				<li>A type for numbers 1-3 can be created <span class="No-Break">as follows:</span><pre class="source-code">
type OneToThree = 1 | 2 | 3;</pre></li>
				<li>The <strong class="source-inline">noEmitOnError</strong> compiler option (set to <strong class="source-inline">true</strong>) can be used to prevent the transpilation process when a type error <span class="No-Break">is found.</span></li>
				<li>A union type can be used for the <strong class="source-inline">lastSale</strong> property to allow it to accept <span class="No-Break"><strong class="source-inline">null</strong></span><span class="No-Break"> values:</span><pre class="source-code">
type Product = {</pre><pre class="source-code">
  name: string;</pre><pre class="source-code">
  lastSale: Date <strong class="bold">| null</strong>;</pre><pre class="source-code">
}</pre><pre class="source-code">
const table: Product = {name: "Table", lastSale: null}</pre></li>
			</ol>
		</div>
		<div>
			<div id="_idContainer045" class="IMG---Figure">
			</div>
		</div>
	</body></html>