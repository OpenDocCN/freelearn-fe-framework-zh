- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing the Multi-SPA Pattern for Microfrontends
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine you are an architect tasked with building the frontend for a large government
    ePortal that has and provides numerous online services for individuals and businesses.
    These services include registering for health benefits, submitting accounts for
    income tax, registering a small business, and paying vehicle road tax, in addition
    to publishing a whole bunch of informational content.
  prefs: []
  type: TYPE_NORMAL
- en: Or, scenario two, imagine you have been tasked to build a banking portal that
    provides multiple online services, from managing saving accounts to buying insurance,
    to investment opportunities, loans, mortgages, credit cards, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: How would you go about planning not just your architecture but also the team
    that will be responsible for building it? Naturally, the first level of thinking
    would be to break down the large portal into multiple smaller modules or mini-apps
    and have each team focus on one of these mini-apps.
  prefs: []
  type: TYPE_NORMAL
- en: This would be the right approach, and this is also what we refer to as the multi-SPA
    pattern for building microfrontends.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will go about building our multi-SPA pattern microfrontend,
    where we will look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The high-level architecture of the multi-SPA microfrontend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Establishing routing between multi-SPAs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a shared component library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a persistent state to share state between mini apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we go through the code examples in this chapter, we will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A PC, Mac, or Linux desktop or laptop with at least 8 GB of RAM (16 GB preferred)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Intel chipset i5+ or Mac M1+ chipset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At least 256 GB of free hard disk storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You will also need the following software installed on your computer:'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js version 16+ (use **nvm** to manage different versions of Node.js if
    you have to)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Terminal: iTerm2 with OhMyZsh (you will thank me later)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'IDE: We strongly recommend VS Code as we will be making use of some of the
    plugins that come with VS Code for an improved developer experience'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: npm, yarn, or pnpm – we recommend pnpm because it’s fast and storage-efficient
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Browser: Chrome, Microsoft Edge, or Firefox (I use Firefox)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A basic understanding of Nx.dev monorepos and a basic understanding of using
    the NX Console plugin in VS Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working knowledge of React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code files for this chapter can be found here: [https://github.com/PacktPublishing/Building-Micro-Frontends-with-React](https://github.com/PacktPublishing/Building-Micro-Frontends-with-React)'
  prefs: []
  type: TYPE_NORMAL
- en: We also assume you have a basic working knowledge of Git, such as branching,
    committing code, and raising pull requests.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the multi-SPA architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The multi-SPA architecture pattern is one of the most common patterns for building
    large-scale applications. As the name suggests, in this pattern, we have a collection
    of SPAs that together form a large application. In this pattern, each SPA behaves
    as its own independent feature or module that can be directly accessed via a URL
    namespaced and mapped to the app. These SPAs also share a very thin layer of shared
    components and global state to ensure coherency and consistency between the apps.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – The multi-SPA architecture](img/Figure_4.01_B18987.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – The multi-SPA architecture
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in *Figure 4**.1*, we have four SPAs: a catalog, which will
    hold pages such as product listings, product details, search, and so on; a checkout
    SPA containing pages such as shopping cart, payments, and so on; the MyAccounts
    SPA; and the Seller/Admin SPA. You will also notice that this pattern allows us
    to easily add additional SPAs as the application grows.'
  prefs: []
  type: TYPE_NORMAL
- en: Each of these SPAs is mapped to a unique primary URL, such that users clicking
    the `/catalog` URL will be redirected to the catalog app, while users clicking
    the `/checkout` URL will go to the checkout app.
  prefs: []
  type: TYPE_NORMAL
- en: Building our Multi-SPA Microfrontend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Building a multi-SPA microfrontend essentially consists of three broad areas:
    breaking down the app into logical mini-apps, then we need to set up the routing
    between these mini-apps, and finally, we set up a global state the different mini-apps
    can read and write data to. Let us look at each of them in the subsequent sections.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our mini-apps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start with where we left off in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In case you skipped the previous chapter and are directly jumping in here, you
    can start by cloning the repo from [https://github.com/PacktPublishing/Building-Micro-Frontends-with-React/tree/main/ch3/my-mfe](https://github.com/PacktPublishing/Building-Micro-Frontends-with-React/tree/main/ch3/my-mfe).
  prefs: []
  type: TYPE_NORMAL
- en: Let us quickly run `pnpm install` (if you haven’t already done so) and serve
    the respective apps to make sure that they are running properly.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are going to build an e-commerce application, let us call our app *eBuy*.
    Feel free to rename your app folder to `ebuy`.
  prefs: []
  type: TYPE_NORMAL
- en: During active development, we would ideally be working on our own respective
    mini-app and you could easily use the NX Console to serve your respective app.
  prefs: []
  type: TYPE_NORMAL
- en: However, periodically you may want to test the entire end-to-end app flow across
    the different mini-apps and for that, it is important that you are able to run
    all the mini-apps locally. This is exactly what we are going to do next.
  prefs: []
  type: TYPE_NORMAL
- en: We first need to ensure that each mini-app runs on its own unique port. To do
    this, we need to first locate the `project.json` file located in the `apps/catalog`
    folder. You will notice it basically contains all the commands and configuration
    needed to run the various tasks on your app.
  prefs: []
  type: TYPE_NORMAL
- en: 'We navigate to the `"serve":` section and under `"options"`, add the line `"``port":
    4200`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We do the exact same thing in the `project.json` file located in the `apps/checkout`
    folder, but this time we will ensure this runs on `"port": 4201` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure that, by default, the catalog will run on port `4200` while
    the checkout app runs on port `4201`.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to inheritance, we will be able to run the app in development and production
    mode from the same ports.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will create a script command that will allow us to run all the apps
    in parallel on their respective ports.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, we go into the `package.json` file located at the root of the project
    and add a script called `"serve:all": "nx` `run-many --target=serve"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in your terminal, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You will see `nx` is starting up the webpack development server and is launching
    the two apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify it by visiting these two URLs in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Catalog app: **http://localhost:4200**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Checkout app: **http://localhost:4201**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With microfrontends, it is important that each SPA follows the same brand guidelines
    and look and feel. We ensure this by building a shared set of UI components that
    both apps make use of. In the next section, we will see how to create a shared
    component library.
  prefs: []
  type: TYPE_NORMAL
- en: Using a shared component library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you are building a series of mini-apps as part of your overall bigger app,
    we want to ensure that all these mini-apps have a consistent design – things such
    as having a consistent header and footer and a consistent way for the various
    components to behave. What is equally important is, when we make a change to some
    of these core elements, we need to ensure that it can be updated across all the
    different apps without too much trouble. This is where the `libs` folder comes
    into play.
  prefs: []
  type: TYPE_NORMAL
- en: This would also be a good time to define an NPM scope so that all these shared
    components can be imported via their scope names.
  prefs: []
  type: TYPE_NORMAL
- en: To define an NPM scope, we open up the `nx.json` file located at the root of
    the monorepo. We are going to name our scope `ebuy` but in reality, it could be
    anything – the name of your team, the name you have for your component library,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Locate the `npmScope` property in the `nx.json` file and update it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Let us use our trustworthy Nx Console to create a library. From Nx Console,
    select `generate` and then select `@nrwl/react – library` `React Library`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the **Show all options** and provide/modify the following details and
    leave the rest as the default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We can leave the rest as the default and click the run button to generate the
    `ui` folder within `libs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to creating the `ui` folder within `libs`, you will notice Nx has
    also added an entry into the `paths` object of `tsconfig.base.json` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It is this setting that will allow us to import our UI components via the scoped
    name instead of a long folder path.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s create a couple of UI components.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the awesome Semantic-UI React component library to build out our
    UI components. You can also use any other component library, such as Chakra UI,
    MUI React-Bootstrap, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s install it on the root of the monorepo using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remember you can always use **npm** or **yarn** to install npm packages as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now let’s create a couple of our common components in the `libs/ui` folder.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let us use Nx Console and create a new component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Nx** | **Generate** | **Create a** **react component**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use the following information to create the component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Name**: **header**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Project**: **ui**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flat**: Select the checkbox to ensure we have a flatter folder structure
    within'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Hit the run button and verify the **header.tsx** file is created within the
    **libs/ui/src/lib** folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the **header.tsx** file and replace the contents of it with simple markup
    for our header component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is simple React component code that will display the header with navigation
    for the catalog and checkout.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step is to export it out it from the **ui**. Locate the **/libs/ui/src/index.ts**
    file and add an entry as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will allow our header component to be importable via our shorter import
    path. Now let us import it into our catalog and checkout apps.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the **apps/catalog/src/spp/app.tsx** file and import the header component
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let us clean up some of the boilerplate code. Remove the imports for **styles**
    and **NxWelcome** and add the **Header** component in the JSX. You can also delete
    the **nx-welcome.tsx** file in the **catalog** folder. Your final code should
    look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, we import the semantic-ui’s css file and include our
    `Header` component and text that displays the name of the app.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When running in the browser, the catalog app will look something like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Catalog app with the common header menu bar](img/Figure_4.02_B18987.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Catalog app with the common header menu bar
  prefs: []
  type: TYPE_NORMAL
- en: We will make the same changes to the **apps/checkout/src/app/app.tsx** file
    within the checkout app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let us test out our code. Run **pnpm serve:all** and refresh your browser on
    **http://localhost:4200** to see our latest changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try clicking on the navigation links for the catalog or checkout and notice
    it doesn’t do anything. That is because we haven’t set up routing between our
    apps, which is exactly what we will be doing next.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Routing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we discussed earlier, from time to time, we would like to test our end-to-end
    app functionality, and although we are able to run apps in parallel on different
    ports, there are some challenges with testing end-to-end functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to ensure a consistent navigation structure for our apps both on localhost
    and on production.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apps running on different ports are treated as apps on different domains and
    hence it will not be possible to share cookies, session states, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To overcome these problems, we need to make the browser think the apps are
    running on the same port. We do this by setting up a reverse proxy. The way we
    will set up routing is each mini-app will have its own namespaced primary route,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**eBuy.com**: Home page app'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**eBuy.com/catalog**: Catalog app'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**eBuy.com/checkout**: Checkout app'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The secondary routes are generally set up within the mini-apps themselves. For
    example, the product details page for, say, apples would be `eBuy.com/catalog/apples`.
  prefs: []
  type: TYPE_NORMAL
- en: Webpack development servers and Nx come with easy-to-use proxy support that
    we can take advantage of.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the root of the catalog app, `/apps/catalog`, let us create a new file called
    `proxy.conf.json` with the following entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Next, we need to tell the catalog app to use this file for its proxy configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'We do this by adding the `proxyConfig` property to the development configuration
    under the serve object in the `apps/catalog/project.json` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Let us quickly test it out. We will need to restart our development servers
    to pick up the latest proxy configurations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `serve:all` command and try clicking on the **Checkout** and **Catalog**
    navigation links… Erm… It didn’t work and the same catalog app shows up when you
    click on the **Checkout** link... But wait – the title tag on the browser tab
    does show **Checkout**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Checkout app in the title but loading the catalog bundle](img/Figure_4.03_B18987.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Checkout app in the title but loading the catalog bundle
  prefs: []
  type: TYPE_NORMAL
- en: So, what’s happening here? If you look at the development tools, the problem
    becomes quite obvious. What’s happening here is the proxy has correctly redirected
    us to the checkout app and that’s why we see the correct `index.html` file served
    via the checkout app, however, the script’s `src` tags loading the `js` bundles
    point to the root and hence they are actually loading the `js` bundles from the
    catalog app.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing this problem is relatively easy again thanks to Nx.
  prefs: []
  type: TYPE_NORMAL
- en: 'We simply need to define the `baseRef` for the checkout app. We do this by
    adding `"baseHref": "/checkout/"` to the `/``apps/checkout/project.json` file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what your development object under the parent serve object should look
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Restart the development servers and now you will be able to navigate between
    the two applications and have the right JS bundles load in. In the next section,
    we will work toward adding a product list response to simulate the mocked response
    from a product list API call.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a mocked product list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common practice with all web development activities is to set up a mock server
    or a mocked set of API responses that the frontend apps can consume until the
    actual APIs are ready. Since our e-commerce app requires a list of products that
    will be required across all the other mini-apps, we create a shared library to
    hold our mocks.
  prefs: []
  type: TYPE_NORMAL
- en: So again, using our favorite, Nx Console, let us create another React library,
    let us call it `mocks`, and we will use the scope name `@ebuy/mocks`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the `mocks` library at `libs/mocks/src/lib`, let us create our file
    called `product-list-mocks.tsx` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us not forget to export it out from the `/libs/mocks/src/index.ts` file
    with the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Also, don’t forget to place the product images in the `catalog` app’s `src/assets`
    folder. You can find the images here [https://github.com/PacktPublishing/Building-Micro-Frontends-with-React-18/tree/main/ch4/ebuy/apps/catalog/src/assets](https://github.com/PacktPublishing/Building-Micro-Frontends-with-React-18/tree/main/ch4/ebuy/apps/catalog/src/assets).
  prefs: []
  type: TYPE_NORMAL
- en: We will now look to use this across our apps, wherever we need data from the
    product list.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the product grid and checkout components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we have a decent-looking header and an app where we can navigate from one
    mini-app to the other. However, the rest of the app doesn’t do much, so let’s
    add a product list component to the catalog app and a shopping basket component
    to the checkout app.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by creating the `ProductList` component within our `/apps/catalog/src/app`
    folder. We will name the file `product-list.tsx`. We will start by creating an
    empty shell component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We will get an error for the missing `ProductCard` component. Don’t worry –
    we will create that component in the next step. Next, we need to create our `ProductCard`
    component. We will name the file `product-card.tsx`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by defining the skeleton of our `ProductCard` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Next, let us import the `ProductList app.tsx` file of the catalog app located
    at `/apps/catalog/src/app/app.tsx`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `app.tsx` code should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If your catalog app looks like the following screenshot, that means you are
    on the right path:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Catalog app with a header and product list component](img/Figure_4.04_B18987.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Catalog app with a header and product list component
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to create our shopping basket component. So, in our `app.tsx`
    checkout file located in the `/apps/checkout/src/app` folder, let us create a
    basic skeleton with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This code should start looking familiar now. As you can see, we have a `ShoppingBasket`
    component and, for the time being, we are passing `PRODUCT_LIST_MOCKS` to it for
    the purpose of mocking.
  prefs: []
  type: TYPE_NORMAL
- en: Next up is to create that `ShoppingBasket` component, which is throwing an error
    at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let us create a `basket.tsx` file in the `/apps/checkout/src/` app folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This is all self-explanatory dummy markup content that at the moment doesn’t
    do much. In the following sections, we are going to make this all work together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your running checkout app should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Mocked up checkout app](img/Figure_4.05_B18987.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – Mocked up checkout app
  prefs: []
  type: TYPE_NORMAL
- en: With this, we have our two apps working well and displaying the right data,
    however, they are not “talking” to each other yet. The checkout app has no idea
    what items the user has added to the cart in the catalog app. In the next section,
    we will set up a global shared state that both the mini-apps can talk to and read
    from.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we proceed to the next section, let us quickly go through a checklist
    of things we’ve done so far:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensured we have the catalog and checkout apps running on different ports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensured we have the URL routing setup in the **proxy.conf.json** file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have both apps reading data from the mocked product list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a Global Shared State
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we are able to navigate between our two mini-apps, the next thing to
    tackle is setting up a shared state between these two different apps. Because
    these are two independent apps, the usual state management solutions such as the
    Context API, Redux, MobX, and so on will not work. This is because these libraries
    store the state as an object within the app and when you refresh the page or navigate
    to another app, this state is lost state. Hence, to overcome this problem, we
    resort to using some of the browser’s native features, such as local storage,
    session storage, or Index-db.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we will be using session storage. We will set up a simple
    custom hook to persist state in `sessionStorage` and have both our mini-apps read
    and write to this state.
  prefs: []
  type: TYPE_NORMAL
- en: In any large-scale app, there will be a lot of similar custom hooks that teams
    can reuse. This is also a good opportunity for us to set up another library for
    these custom hooks.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to remember that this global state should be used sparingly
    only when we need to share information between the different mini-apps. To manage
    the states within each micro app, we should use a regular state management tool
    such as the Context API or Redux, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us use Nx Console to create another library called `custom-hooks`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we’ll fill use the following information in the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name**: **custom-hooks**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Component**: **off** (Generate a default component)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**importPath**: **@ebuy/custom-hooks**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Verify that the `custom-hooks` folder is created under `libs` and also make
    sure it has been added to the `tsconfig.base.json` file at the root of the monorepo,
    which should now look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us now create our custom hook. Use the `generate` command to create a React
    component with the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name of the** **component**: **useSessionStorage**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Project**: **custom-hooks**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**fileName**: **use-session-storage**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**flat**: **Selected** (generate flat file structure)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the newly created `use-session-storage.tsx` component file, let’s replace
    the boilerplate code with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This custom hook code is part of the `usehooks-ts` library and is available
    here: [https://usehooks-ts.com/react-hook/use-session-storage](https://usehooks-ts.com/react-hook/use-session-storage)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this custom hook makes use of the `usehook-ts` library, we will install
    that npm module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to export it so that it can be imported via the scoped path.
    We do this in the `/libs/custom-hooks/src/index.ts` file by adding the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will use our newly created custom-hook in the `product-card` component
    such that every time the user adds products to or removes products from the shopping
    cart, it will store it as an array in `sessionStorage`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `/apps/catalog/src/app/productcard.tsx` file, we will start by importing
    the `useSessionStorage` hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, within the product card component, we make use of the `useSessionStorage`
    hook and add the functions to add and remove items from the basket with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we update the **Add** and **Remove** button on-click events as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s test this out by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Click on the **Add** and **Remove** buttons for some of the products and see
    the product counts work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s open up the development tools and have a look at the `sessionStorage`
    under the **Application** tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Shopping basket stored in Session Storage](img/Figure_4.06_B18987.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – Shopping basket stored in Session Storage
  prefs: []
  type: TYPE_NORMAL
- en: Once the state is present in **Session Storage**, we will need to read it from
    multiple places across different components. It is best to create it as a utility
    function that can be reused as needed.
  prefs: []
  type: TYPE_NORMAL
- en: We will create another library using Nx Console, but this time instead of creating
    a React library, we will use the `@nrwl/workspace – library` template to generate
    our generic `utils` library and use the import scope called `@ebuy/utils`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The information we fill in during the `Nx Console > generate` step is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**@****nwrl/workspace**: **library**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Name**: **utils**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**importScope**: **@ebuy/utils**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running this command will generate the `utils` folder and also create the `utils.ts`
    file. Let us rename it to `get-session-storage.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to read the values of a given key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this is a very simple function that accepts a key and returns
    the values from session storage for the given key.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will get the mini basket in the header hooked up to show the total
    items in the shopping basket. In the `header.tsx` file, let us add the necessary
    code to read and total up the items in the shopping basket.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us import the necessary functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We will create our function to calculate the total count like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, within the `Header` component, we will use a combination of `useEffects`
    and `eventListeners` to ensure that the mini basket updates every time items are
    added to or removed from the cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will update the shopping cart icon to display `{miniBasketCount}`
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Run the apps and try adding and removing items using the **Add** and **Remove**
    buttons, and see how the counts update.
  prefs: []
  type: TYPE_NORMAL
- en: The last part of this chapter is where we will complete the shopping cart component
    in the checkout app.
  prefs: []
  type: TYPE_NORMAL
- en: What we need to do is fetch the data for the `shoppingBasket` key in `sessionStorage`
    and display the products and the quantity added to the cart.
  prefs: []
  type: TYPE_NORMAL
- en: 'We open the `app.tsx` checkout file located in the `apps/checkout/src/app/app.tsx`
    file and follow these steps to get the data from `sessionStorage`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First we import `getSessionStorage` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Then within the `App` function we add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: When we run the app and have a look at the console, we will be able to see the
    array of items from `shoppingBasket`.
  prefs: []
  type: TYPE_NORMAL
- en: Since `shoppingBasket` only stored the product IDs and their quantity we will
    need to map the product IDs to the product names so that we can display names
    in the shopping basket.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us create another function to do that. We will call it `createCompleteBasket`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, finally, within our app’s component''s function, we create `completeBasket`
    by filtering and mapping the values from the product list to `shoppingbasket`
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we update the `ShoppingBasket` component to pass in this new prop like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Test your app in the browser and give it a play. Add and remove items to and
    from the basket in the catalog app and then navigate to the checkout app to see
    the shopping basket all synced up and displaying the correct list of items.
  prefs: []
  type: TYPE_NORMAL
- en: A note on the coding samples
  prefs: []
  type: TYPE_NORMAL
- en: As you must have seen, in numerous places we have used the ‘**any'** type definition
    and have skipped a few details (including unit tests). This is intentional to
    avoid overcomplicating the examples so that we stay focused on the core aspects
    of this chapter, such as routing between apps and sharing state. When building
    an app for production, we would encourage you to define the correct types and
    interfaces to take advantage of the full power of TypeScript and write relevant
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we come to the end of this rather intense section... Take a break.
    Well done!
  prefs: []
  type: TYPE_NORMAL
- en: We covered a lot here. We picked up from where we had left off in the previous
    chapter and added a shared header component to our apps. We then set up routing
    via a proxy so that we could navigate between the two different apps, but as if
    they were part of the same domain and port. We also saw how to share state between
    the two mini-apps using session storage. We then created a common custom hook
    to store and retrieve data from session storage, and while doing so we built up
    the bare bones of an e-commerce app, adding items to the cart and updating the
    cart information on the checkout app and the mini cart on the header.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This was a long chapter, so well done for staying with us until the end. We
    started off by looking at what the multi-SPA pattern looks like. We saw how this
    pattern would be most suitable for very large applications such as a banking portal,
    a government portal, or an e-commerce site. We saw the architecture pattern where
    all these different mini-apps can take advantage of a shared common library of
    components and utilities to ensure the consistency of the different apps.
  prefs: []
  type: TYPE_NORMAL
- en: We then took a deep dive into code and went about setting up our two mini-apps
    within the Nx monorepo, after which we went about creating our shared UI header
    component and used Semantic UI to build out our catalog and checkout apps. This
    was also a good opportunity for us to see how to use scoped names, which makes
    our import paths look clean and simple.
  prefs: []
  type: TYPE_NORMAL
- en: Then we went about setting up the routing so that we could navigate between
    the two different apps, and finally, we set up a custom hook to store our app
    state in session storage and saw how to have it synced between the two mini-apps.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at the micro-apps pattern where we will have
    multiple micro-apps loaded within the same page.
  prefs: []
  type: TYPE_NORMAL
