- en: Get Going with Angular
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 Angular
- en: 'On September 18, 2014, Google pushed the first public commit to the repository
    that now contains Angular. A few weeks later, at ng-europe, Igor, and Tobias,
    from the core team, gave a short overview of what were the expected features of
    the new framework. The vision at that time was far from final; however, one thing
    was certain: Angular would be an entirely different framework compared to AngularJS.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 2014 年 9 月 18 日，Google 将第一个公开提交推送到包含 Angular 的存储库。几周后，在 ng-europe 上，核心团队的 Igor
    和 Tobias 给出了一个简短的概述，介绍了新框架预期的功能。当时的愿景远未最终确定；然而，有一点是肯定的：Angular 将与 AngularJS 完全不同的框架。
- en: 'This announcement brought a lot of questions and controversies. The reasons
    behind the drastic changes were quite clear: AngularJS was no longer able to take
    full advantage of the evolved web and the requirements of large-scale JavaScript
    applications needed to be completely satisfied. A new framework would let Angular
    developers capitalize on developments in web technology in simpler, more performant,
    and productive ways. Yet, people were concerned. One of the biggest nightmares
    with backward incompatibility for developers is the migration of their current
    code bases to the new version of the third-party software they use. In Angular''s
    case, after that first announcement, migration looked daunting, even impossible.
    Later, at **ng-conf** 2015 and **ng-vegas** 2015, different migration strategies
    were introduced. The Angular community came together and shared additional ideas,
    anticipating the benefits of the new version of the framework, while preserving
    the things learned from AngularJS.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这项公告引发了许多疑问和争议。这些巨大变化的背后原因相当明确：AngularJS 已无法充分利用演进的 Web 技术以及大规模 JavaScript 应用程序的需求需要得到完全满足。一个新的框架将让
    Angular 开发者以更简单、更高效、更富有成效的方式利用 Web 技术的发展。然而，人们仍然担忧。对于开发者来说，向后不兼容的最大噩梦之一就是将他们当前的代码库迁移到他们使用的第三方软件的新版本。在
    Angular 的情况下，在那次首次公告之后，迁移看起来令人畏惧，甚至不可能。后来，在 2015 年的 **ng-conf** 和 **ng-vegas**
    上，介绍了不同的迁移策略。Angular 社区团结起来，分享了额外的想法，预计新版本的框架将带来好处，同时保留从 AngularJS 中学到的经验。
- en: This book is a part of that project. Making the upgrade to Angular is now smooth
    and is worth it. The main drivers behind the drastic changes in Angular 2 and
    its lack of backward compatibility are the evolution of the web and the lessons
    learned from the usage of AngularJS in the wild. This book will help you learn
    the new framework by making you understand how we got here and why Angular's new
    features make intuitive sense for the modern web in building high-performance,
    scalable, single-page applications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本书是该项目的一部分。将升级到 Angular 现在变得顺利且值得。Angular 2 中巨大变化及其向后不兼容的主要驱动因素是 Web 的演变以及从野外的
    AngularJS 使用中学到的经验教训。本书将帮助你通过让你了解我们是如何到达这里的以及为什么 Angular 的新功能对现代 Web 来说在构建高性能、可扩展的单页应用程序方面具有直观的意义来学习新框架。
- en: 'Some of the topics that we will discuss in this chapter are as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将讨论的一些主题如下：
- en: Using TypeScript and understanding how it extends JavaScript
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 TypeScript 并了解它如何扩展 JavaScript
- en: Building the user interface of Angular applications with a component-based architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于组件的架构构建 Angular 应用程序的用户界面
- en: Using Angular's dependency injection mechanism and delegating the business logic
    to services
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Angular 的依赖注入机制并将业务逻辑委托给服务
- en: Exploring Angular's router and forms module in depth
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入探索 Angular 的路由器和表单模块
- en: Looking at the Ahead-of-Time compilation for building lightning fast applications
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看即时编译以构建闪电般快速的应用程序
- en: The evolution of the web – time for a new framework
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web 的演变——是时候推出新框架了
- en: In the past couple of years, the web has evolved in big steps. During the implementation
    of ECMAScript 5, the ECMAScript 6 standard started its development (now known
    as **ECMAScript 2015** or **ES2015**). ES2015 introduced many changes in JavaScript,
    such as adding built-in language support for modules, block scope variable definition,
    and a lot of syntactical sugar, such as classes and destructuring.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，Web 技术经历了巨大的演变。在实施 ECMAScript 5 的过程中，ECMAScript 6 标准开始了其开发（现在称为 **ECMAScript
    2015** 或 **ES2015**）。ES2015 在 JavaScript 中引入了许多变化，例如添加内置语言支持模块、块作用域变量定义以及许多语法糖，如类和结构赋值。
- en: Meanwhile, **web components** were invented. Web components allow us to define
    custom HTML elements and attach behavior to them. Since it is hard to extend the
    existing set of HTML elements with new ones (such as dialogs, charts, and grids),
    mostly because of the time required for consolidation and standardization of their
    APIs, a better solution is to allow developers to extend the existing elements
    in the way they want. Web components provide us with a number of benefits, including
    better encapsulation, better semantics of the markup we produce, better modularity,
    and easier communication between developers and designers.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，**Web组件**被发明了。Web组件允许我们定义自定义HTML元素并将行为附加到它们上。由于很难通过添加新元素（如对话框、图表和网格）来扩展现有的HTML元素集，这主要是因为它们API的整合和标准化需要时间，因此一个更好的解决方案是允许开发者以他们想要的方式扩展现有元素。Web组件为我们提供了许多好处，包括更好的封装、我们生成的标记的更好语义、更好的模块化以及开发者与设计师之间更易沟通。
- en: As we know, JavaScript is a single-threaded language. Initially, it was developed
    for simple client-side scripting, but over time, its role has shifted quite a
    bit. Now, with HTML5, we have different APIs that allow audio and video processing,
    communication with external services through a two-directional communication channel,
    transferring and processing big chunks of raw data, and more. All these heavy
    computations in the main thread may create a poor user experience. They may introduce
    freezing of the user interface when time-consuming computations are being performed.
    This led to the development of **web workers**, which allow the execution of the
    scripts in the background that communicate with the main thread through message
    passing. This way, multithreaded programming was brought to the browser.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，JavaScript是一种单线程语言。最初，它是为了简单的客户端脚本而开发的，但随时间推移，它的角色发生了很大变化。现在，随着HTML5的出现，我们有不同的API允许音频和视频处理、通过双向通信通道与外部服务通信、传输和处理大量原始数据等。所有这些在主线程中的重计算可能会创建一个糟糕的用户体验。它们可能会在执行耗时计算时导致用户界面冻结。这导致了**Web
    Workers**的发展，它允许在后台执行与主线程通过消息传递通信的脚本。这样，多线程编程就被带到了浏览器中。
- en: 'Some of these APIs were introduced after the development of AngularJS had begun;
    that''s why the framework wasn''t built with most of them in mind. Taking advantage
    of the APIs gives developers many benefits, such as the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些API是在AngularJS开发开始之后引入的；这就是为什么框架没有考虑到大多数这些API。利用这些API为开发者带来了许多好处，例如以下内容：
- en: Significant performance improvements
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显著的性能提升
- en: Development of software with better quality characteristics
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发具有更好质量特性的软件
- en: Now, let's briefly discuss how each of these technologies has been made part
    of the Angular core and why.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们简要讨论这些技术是如何成为Angular核心的一部分以及为什么。
- en: The evolution of ECMAScript
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ECMAScript的演变
- en: Nowadays, browser vendors are releasing new features in short iterations, and
    users receive updates quite often. This helps developers take advantage of bleeding-edge
    web technologies. ES2015 is already standardized. The implementation of the latest
    version of the language has already started in the major browsers. Learning the
    new syntax and taking advantage of it will not only increase our productivity
    as developers but will also prepare us for the near future when all browsers will
    have full support for it. This makes it essential to start using the latest syntax
    now.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，浏览器厂商正以短周期迭代的方式发布新功能，用户经常收到更新。这有助于开发者利用前沿的Web技术。ES2015已经标准化。该语言最新版本的实现已经在主要浏览器中开始。学习新语法并利用它不仅能提高我们的开发效率，而且还能为不久的将来所有浏览器都将完全支持它做好准备。这使得现在开始使用最新语法变得至关重要。
- en: The requirements of some projects may enforce us to support older browsers,
    which do not support any ES2015 features. In this case, we can directly write
    ECMAScript 5, which has a different syntax, but has semantics equivalent to ES2015\.
    On the other hand, a better approach will be to take advantage of the process
    of **transpilation**. Using a transpiler in our build process allows us to take
    advantage of the new syntax by writing ES2015 and translating it to a target language
    that is supported by the browsers.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一些项目的需求可能迫使我们支持旧版浏览器，这些浏览器不支持任何ES2015功能。在这种情况下，我们可以直接编写ECMAScript 5，它具有不同的语法，但其语义与ES2015等效。另一方面，一个更好的方法将是利用**转译**过程。在我们的构建过程中使用转译器允许我们通过编写ES2015并将其转换为浏览器支持的目标语言来利用新语法。
- en: Angular has been around since 2009\. Back then, the frontend of most websites
    was powered by ECMAScript 3—the last main release of ECMAScript before ECMAScript
    5\. This automatically meant that the language used for the implementation of
    the framework was ECMAScript 3\. Taking advantage of the new version of the language
    requires porting of the entirety of AngularJS to ES2015.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Angular自2009年以来一直存在。当时，大多数网站的前端由ECMAScript 3提供动力——ECMAScript 5之前的最后一个主要版本。这自动意味着用于框架实现的编程语言是ECMAScript
    3。利用语言的新版本需要将AngularJS的全部内容移植到ES2015。
- en: From the beginning, Angular took into account the current state of the web by
    bringing the latest syntax in the framework. Angular is written with a superset
    of ES2016, called TypeScript, which we'll take a look at in [Chapter 4](c8967e3c-a8b3-40c6-900e-e9ccd07357aa.xhtml),
    *TypeScript Crash Course*. The type annotations allow us to take additional performance
    boost because they open the door for a process called **ahead-of-time** (**AOT**)
    compilation, which as part of the build process, generates efficient code for
    change detection, rendering, and dependency injection. You can find more about
    AOT compilation in [Chapter 9](b9d6c03a-d141-4201-afc6-339a41a38715.xhtml), *Tooling
    and Development Experience*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始，Angular就通过引入框架中的最新语法来考虑网络的当前状态。Angular是用ES2016的超集TypeScript编写的，我们将在[第4章](c8967e3c-a8b3-40c6-900e-e9ccd07357aa.xhtml)“TypeScript快速入门”中对其进行探讨。类型注解使我们能够获得额外的性能提升，因为它们为称为**即时编译**（**AOT**）的过程打开了大门，该过程作为构建过程的一部分，为变更检测、渲染和依赖注入生成高效的代码。你可以在[第9章](b9d6c03a-d141-4201-afc6-339a41a38715.xhtml)“工具和开发体验”中找到更多关于AOT编译的信息。
- en: Web components
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网页组件
- en: The first public draft of web components was published on May 22, 2012, about
    3 years after the release of AngularJS. As mentioned, the web components standard
    allows us to create custom elements and attach behavior to them. It sounds familiar
    because we've already used a similar concept in the development of the user interface
    with AngularJS. Web components sound like an alternative to Angular directives;
    however, they have a more intuitive API and built-in browser support. They introduced
    a few other benefits, such as better encapsulation, which is very important, for
    example, in handling CSS-style collisions.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 网页组件的第一个公开草案于2012年5月22日发布，距离AngularJS发布大约3年后。正如所述，网页组件标准允许我们创建自定义元素并将行为附加到它们上。这听起来很熟悉，因为我们已经在AngularJS开发用户界面时使用过类似的概念。网页组件听起来像是Angular指令的替代品；然而，它们具有更直观的API和内置浏览器支持。它们引入了一些其他好处，例如更好的封装，这在处理CSS样式冲突时非常重要。
- en: A possible strategy for adding web components support in AngularJS is to change
    the directives implementation and introduce primitives of the new standard in
    the DOM compiler. As Angular developers, we know how powerful and complex the
    directives API is. It includes a lot of properties, such as `postLink`, `preLink`,
    `compile`, `restrict`, `scope`, and `controller`, and of course, our favorite
    `transclude`. Approved as standard, web components will be implemented on a much
    lower level in the browsers, which introduces plenty of benefits, such as better
    performance and native API.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在AngularJS中添加网页组件支持的可能策略是更改指令实现，并在DOM编译器中引入新标准的基本元素。作为Angular开发者，我们知道指令API是多么强大和复杂。它包括许多属性，如`postLink`、`preLink`、`compile`、`restrict`、`scope`和`controller`，当然还有我们最喜欢的`transclude`。一旦被批准为标准，网页组件将在浏览器中实现得更加底层，这带来了许多好处，如更好的性能和原生API。
- en: During the implementation of web components, a lot of web specialists met with
    the same problems the AngularJS team did when developing the directives API, and
    came up with similar ideas. Good design decisions behind web components include
    the **content** element, which deals with the infamous transclusion problem in
    AngularJS. Since both the directives API and web components solve similar problems
    in different ways, keeping the directives API on top of web components would have
    been redundant and added unnecessary complexity. This is why the Angular core
    team decided to start from the beginning by building a framework compatible with
    web components and taking full advantage of the new standard. Web components involve
    new features; some of them are not yet implemented by all browsers. In case our
    application is run in a browser which does not support any of these features natively,
    Angular emulates them. An example for this is the `content` element polyfilled
    with the `ng-content` directive.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现Web组件的过程中，许多Web专家遇到了AngularJS团队在开发指令API时遇到的问题，并提出了类似的想法。Web组件背后的良好设计决策包括**内容**元素，它解决了AngularJS中臭名昭著的转译问题。由于指令API和Web组件以不同的方式解决了类似的问题，因此在Web组件之上保留指令API将是冗余的，并增加了不必要的复杂性。这就是为什么Angular核心团队决定从头开始，构建一个与Web组件兼容的框架，并充分利用新的标准。Web组件涉及新的功能；其中一些功能尚未被所有浏览器实现。如果我们的应用程序在不支持这些功能的浏览器中运行，Angular将模拟它们。一个例子是使用`ng-content`指令填充的`content`元素。
- en: Web workers
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web Workers
- en: JavaScript is known for its event loop. Usually, JavaScript programs are executed
    in a single thread and different events are scheduled by being pushed in a queue
    and processed sequentially in the order of their arrival. However, this computational
    strategy is not effective when one of the scheduled events requires a lot of computational
    time. In such cases, the event's handling will block the main thread, and all
    other events will not be handled until the time-consuming computation is complete
    and the execution passed to the next one in the queue. A simple example of this
    is a mouse click that triggers an event, in which the callback does some audio
    processing using the HTML5 audio API. If the processed audio track is big and
    the algorithm running over it is heavy; this will affect the user's experience
    by freezing the UI until the execution is complete.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript以其事件循环而闻名。通常，JavaScript程序在单个线程中执行，不同的事件通过被推入队列并按到达顺序依次处理来安排。然而，当计划中的某个事件需要大量的计算时间时，这种计算策略并不有效。在这种情况下，事件的处理将阻塞主线程，并且所有其他事件将不会处理，直到耗时的计算完成并将执行传递到队列中的下一个事件。一个简单的例子是鼠标点击触发的事件，其中回调使用HTML5音频API进行一些音频处理。如果处理的音频轨道很大，并且运行在其上的算法很重，这将通过冻结UI直到执行完成来影响用户体验。
- en: The web workers API was introduced in order to prevent such pitfalls. It allows
    execution of heavy computations inside the context of a different thread, which
    leaves the main thread execution free, capable of handling user input and rendering
    the user interface.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Web Workers API的引入是为了防止这样的陷阱。它允许在另一个线程的上下文中执行重计算，从而释放主线程的执行，使其能够处理用户输入和渲染用户界面。
- en: 'How can we take advantage of this in Angular? In order to answer this question,
    let''s think about how things work in AngularJS. What if we have an enterprise
    application, which processes a huge amount of data that needs to be rendered on
    the screen using data binding? For each binding, the framework will create a new
    watcher. Once the digest loop is run, it will loop over all the watchers, execute
    the expressions associated with them, and compare the returned results with the
    results gained from the previous iteration. We have a few slowdowns here:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在Angular中利用这一点呢？为了回答这个问题，让我们思考一下AngularJS中的工作方式。如果我们有一个企业应用程序，它处理大量需要通过数据绑定在屏幕上渲染的数据，会怎样呢？对于每个绑定，框架将创建一个新的观察者。一旦运行了消化循环，它将遍历所有观察者，执行与它们相关的表达式，并将返回的结果与上一次迭代中获得的结果进行比较。在这里我们有几个减速点：
- en: The iteration over a large number of watchers
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历大量观察者
- en: The evaluation of the expression in a given context
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在给定上下文中表达式的评估
- en: The copy of the returned result
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回结果的副本
- en: The comparison between the current result of the expression's evaluation and
    the previous one
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式评估的当前结果与之前的结果之间的比较
- en: All these steps could be quite slow, depending on the size of the input. If
    the digest loop involves heavy computations, why not move it to a web worker?
    Why not run the digest loop inside the web worker, get the changed bindings, and
    then apply them to the DOM?
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些步骤可能会相当慢，具体取决于输入的大小。如果消化循环涉及到繁重的计算，为什么不将其移动到 Web Worker 中呢？为什么不在 Web Worker
    中运行消化循环，获取已更改的绑定，然后将它们应用到 DOM 上？
- en: There were experiments by the community which aimed for this result. However,
    their integration into the framework wasn't trivial.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 社区进行了一些实验，旨在实现这一结果。然而，将它们集成到框架中并不简单。
- en: One of the main reasons behind the lack of satisfying results was the coupling
    of the framework with the DOM. Often, inside the callbacks of watchers, AngularJS
    directly manipulates the DOM, which makes it impossible to move the watchers inside
    a web worker since the web workers are executed in an isolated context, without
    access to the DOM. In AngularJS, we may have implicit or explicit dependencies
    between the different watchers, which require multiple iterations of the digest
    loop in order to get stable results. Combining the last two points, it is quite
    hard to achieve practical results in calculating the changes in threads other
    than the main thread of execution.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 导致不满意结果的主要原因之一是框架与 DOM 的耦合。通常，在观察者的回调中，AngularJS 直接操作 DOM，这使得无法将观察者移动到 Web Worker
    中，因为 Web Worker 在一个隔离的上下文中执行，没有访问 DOM 的权限。在 AngularJS 中，我们可能在不同观察者之间存在隐式或显式的依赖关系，这需要多次迭代消化循环才能得到稳定的结果。结合最后两点，在其他执行线程（除了主线程）中计算变化是非常困难的。
- en: Fixing this in AngularJS introduces a great deal of complexity into the internal
    implementation. The framework simply was not built with this in mind. Since web
    workers were introduced before the Angular design process started, the core team
    took them into consideration from the beginning.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AngularJS 中修复这个问题给内部实现引入了大量的复杂性。框架根本就没有考虑到这一点。由于 Web Worker 在 Angular 设计过程开始之前就已经引入，核心团队从一开始就考虑了它们。
- en: Lessons learned from AngularJS in the wild
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从野外的 AngularJS 中学到的经验
- en: Although the previous section listed a lot of arguments for the required re-implementation
    of the framework responding to the latest trends, it's important to remember that
    we're not starting completely from scratch. We're taking what we've learned from
    AngularJS with us. In the period since 2009, the web is not the only thing that
    evolved. We also started building more and more complex applications. Today, single-page
    applications are not something exotic, but more like a strict requirement for
    all web applications solving business problems, which are aiming for high performance
    and a good user experience.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然上一节列出了很多关于响应最新趋势所需重新实现框架的论点，但重要的是要记住，我们并不是从头开始。我们带着从 AngularJS 中学到的知识前进。自
    2009 年以来，不仅仅是网络在发展。我们还开始构建越来越多地复杂的应用程序。如今，单页应用程序不再是某种异类，而是所有解决业务问题的网络应用程序的严格要求，它们追求高性能和良好的用户体验。
- en: AngularJS helped us to efficiently build large-scale, single-page applications.
    However, by applying it in various use cases, we've also discovered some of its
    pitfalls. Learning from the community's experience, Angular's core team worked
    on new ideas aiming to answer the new requirements.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS 帮助我们高效地构建大规模的单页应用程序。然而，通过在各种用例中应用它，我们也发现了其中的一些陷阱。从社区的经验中学习，Angular
    的核心团队致力于新的想法，旨在满足新的需求。
- en: Controllers
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器
- en: AngularJS follows the **Model-View-Controller** (**MVC**) micro-architectural
    pattern. Some may argue that it looks more like **Model-View-ViewModel** (**MVVM**)
    because of the view model attached as properties to the scope or the current context
    in case of *controller as syntax*. It could be approached differently again, if
    we use the **Model-View-Presenter** (**MVP**). Because of all the different variations
    of how we can structure the logic in our applications, the core team called AngularJS
    a **Model-View-Whatever** (**MVW**) framework.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS 遵循 **模型-视图-控制器**（**MVC**）的微架构模式。有些人可能会认为它更像 **模型-视图-视图模型**（**MVVM**），因为视图模型作为属性附加到作用域或当前上下文中，在
    *控制器语法* 的情况下。如果我们使用 **模型-视图-表示者**（**MVP**），它可能又有不同的处理方式。由于我们可以在应用程序中结构化逻辑的不同变体，核心团队将
    AngularJS 称为 **模型-视图-任何**（**MVW**）框架。
- en: 'The view in any AngularJS application is supposed to be a composition of directives.
    The directives collaborate together in order to deliver fully functional user
    interfaces. Services are responsible for encapsulating the business logic of the
    applications. This is the place where we should put the communication with RESTful
    services through HTTP, real-time communication with WebSockets, and even WebRTC.
    Services are the building blocks where we should implement the domain models and
    business rules of our applications. There''s one more component, which is mostly
    responsible for handling user input and delegating the execution to the services:
    the controller.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何 AngularJS 应用程序中，视图应该是由指令组成的。这些指令协同工作，以提供功能齐全的用户界面。服务负责封装应用程序的业务逻辑。这就是我们在其中放置通过
    HTTP 与 RESTful 服务通信、通过 WebSockets 进行实时通信以及甚至 WebRTC 的地方。服务是我们应该实现应用程序领域模型和业务规则的基本构建块。还有一个组件，它主要负责处理用户输入并将执行委托给服务：控制器。
- en: Although the services and directives have well-defined roles, we can often see
    the anti-pattern of the **Massive View Controller**, which is common in iOS applications.
    Occasionally, developers are tempted to access or even manipulate the DOM directly
    from their controllers. Initially, this happens while you want to achieve something
    simple, such as changing the size of an element, or quick and dirty changing styles
    of elements. Another noticeable antipattern is the duplication of the business
    logic across controllers. Often, developers tend to copy and paste logic, which
    should be encapsulated inside services.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管服务和指令有明确的角色，但我们经常可以看到反模式“大量视图控制器”，这在 iOS 应用程序中很常见。有时，开发者会诱使从他们的控制器直接访问或甚至操作
    DOM。最初，这发生在你想要实现一些简单的事情时，比如改变元素的大小，或者快速而肮脏地改变元素样式。另一个值得注意的反模式是在控制器之间重复业务逻辑。通常，开发者倾向于复制和粘贴应该封装在服务内部的逻辑。
- en: The best practices for building AngularJS applications state that the controllers
    should not manipulate the DOM at all; instead, all DOM access and manipulations
    should be isolated in directives. If we have some repetitive logic between controllers,
    most likely we want to encapsulate it into a service and inject this service with
    the dependency injection mechanism of Angular in all the controllers that need
    that functionality.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 构建 AngularJS 应用程序的最佳实践指出，控制器不应操纵 DOM；相反，所有 DOM 访问和操作都应隔离在指令中。如果我们有一些在控制器之间的重复逻辑，我们很可能希望将其封装到服务中，并通过
    Angular 的依赖注入机制将此服务注入到所有需要该功能的所有控制器中。
- en: This is where we're coming from in AngularJS. All this said, it seems that the
    functionality of controllers could be moved into the controllers of the directive.
    Since directives support the dependency injection API, after receiving the user's
    input, we can directly delegate the execution to a specific service, already injected.
    This is the main reason why Angular now uses a different approach, by removing
    the ability to put controllers everywhere using the `ng-controller` directive.
    We'll take a look at how the responsibilities of AngularJS controllers could be
    taken from the new components and directives in [Chapter 5](1b60c28e-5f34-493d-8371-c69968f09020.xhtml),
    *Getting Started with Angular Components and Directives*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们从 AngularJS 出发的。所有这些话，似乎控制器的功能可以被移动到指令的控制器中。由于指令支持依赖注入 API，在接收到用户输入后，我们可以直接将执行委托给已经注入的特定服务。这就是为什么
    Angular 现在采用不同方法的主要原因，通过移除使用 `ng-controller` 指令将控制器放在任何地方的能力。我们将在第 5 章“使用 Angular
    组件和指令入门”中查看如何从新的组件和指令中提取 AngularJS 控制器的职责。[第 5 章](1b60c28e-5f34-493d-8371-c69968f09020.xhtml)。
- en: Scope
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作用域
- en: Data binding in AngularJS is achieved using the `scope` object. We can attach
    properties to it and explicitly declare in the template that we want to bind to
    these properties (one- or two-way). Although the idea of the scope seems clear,
    it has two more responsibilities, including event dispatching and the change detection-related
    behavior.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS 中的数据绑定是通过使用 `scope` 对象实现的。我们可以将其属性附加到它上面，并在模板中明确声明我们想要绑定到这些属性（单向或双向）。尽管作用域的概念似乎很清晰，但它还有两个额外的职责，包括事件分派和与变更检测相关的行为。
- en: 'Angular beginners have a hard time understanding what scope really is and how
    it should be used. AngularJS 1.2 introduced something called **controller as syntax**.
    It allows us to add properties to the current context inside the given controller
    (`this`), instead of explicitly injecting the `scope` object and later adding
    properties to it. This simplified syntax can be demonstrated through the following
    snippet:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Angular初学者很难理解作用域（scope）究竟是什么以及应该如何使用。AngularJS 1.2引入了一种称为**控制器作为语法（controller
    as syntax**）的概念。它允许我们在给定的控制器（`this`）内部添加属性，而不是显式地注入`scope`对象并在之后添加属性。这种简化的语法可以通过以下代码片段来演示：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The latest Angular took this even further by removing the `scope` object. All
    the expressions are evaluated in the context of the given UI component. Removing
    the entire scope API introduces higher simplicity; we don't need to explicitly
    inject it anymore, instead, we add properties to the UI components to which we
    can later bind. This API feels much simpler and more natural.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最近的Angular版本更进一步，移除了`scope`对象。所有表达式都在给定的UI组件的上下文中进行评估。移除整个作用域API引入了更高的简洁性；我们不再需要显式地注入它，相反，我们向UI组件添加属性，这些属性我们可以稍后绑定。这个API感觉更加简单和自然。
- en: We will take a more detailed look at the components and the change detection
    mechanism of Angular in [Chapter 5](1b60c28e-5f34-493d-8371-c69968f09020.xhtml),
    *Getting Started with Angular Components and Directives*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第5章](1b60c28e-5f34-493d-8371-c69968f09020.xhtml)，《Angular组件和指令入门》中更详细地探讨Angular的组件和变更检测机制。
- en: Dependency injection
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入
- en: Maybe the first framework on the market that included **Inversion of Control**
    (**IoC**) through **Dependency Injection** (**DI**) in the JavaScript world was
    AngularJS. DI provides a number of benefits, such as easier testability, better
    code organization and modularization, and simplicity. Although the DI in AngularJS
    does an amazing job, Angular took this even further. Since Angular is on top of
    the latest web standards, it uses the syntax of ECMAScript 2016 decorators for
    annotating the code for using DI. Decorators are quite similar to the decorators
    in Python or annotations in Java. They allow us to *decorate* the behavior of
    a given object, or add metadata to it, using reflection. Since decorators are
    not yet standardized and supported by major browsers, their usage requires an
    intermediate transpilation step.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 可能是市场上第一个在JavaScript世界中通过**依赖注入（DI**）实现**控制反转（IoC**）的框架是AngularJS。DI提供了一系列好处，如更易于测试、更好的代码组织和模块化，以及简洁性。尽管AngularJS中的DI做得非常出色，但Angular更进一步。由于Angular基于最新的网络标准，它使用ECMAScript
    2016装饰器的语法来注释使用DI的代码。装饰器与Python中的装饰器或Java中的注解非常相似。它们允许我们使用反射来**装饰**给定对象的行为，或向其添加元数据。由于装饰器尚未标准化且不被主流浏览器支持，它们的用法需要中间的转译步骤。
- en: The new DI is much more flexible and feature-rich. It also fixes some of the
    pitfalls of AngularJS, such as the different APIs; in the first version of the
    framework, some objects are injected by position (such as the scope, element,
    attributes, and controller in the link function of the directives) and others,
    by name (using parameters names in controllers, directives, services, and filters).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 新的依赖注入（DI）机制更加灵活且功能丰富。它还修复了AngularJS的一些缺陷，例如不同的API；在框架的第一版本中，一些对象是通过位置注入的（例如，在指令的链接函数中注入的scope、element、attributes和controller），而其他对象则是通过名称注入的（在控制器、指令、服务和过滤器中使用参数名称）。
- en: We will take a further look at the Angular's dependency injection API in [Chapter
    6](3ad730a8-f797-4fc1-b908-5a20eeffac23.xhtml), *Dependency Injection in Angular*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第6章](3ad730a8-f797-4fc1-b908-5a20eeffac23.xhtml)，《Angular依赖注入》中进一步探讨Angular的依赖注入API。
- en: Server-side rendering
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端渲染
- en: The bigger the requirements of the web are, the more complex web applications
    become. Building a real-life, single-page application requires writing a huge
    amount of JavaScript, and including all the required external libraries may increase
    the size of the scripts on our page to a few megabytes. The initialization of
    the application may take up to several seconds or even tens of seconds on a mobile
    device until all the resources get fetched from the server, the JavaScript is
    parsed and executed, the page gets rendered, and all the styles are applied. On
    low-end mobile devices that use a mobile internet connection, this process may
    make the users give up on visiting our application. Although there are a few practices
    that speed up this process, in complex applications, there's no silver bullet.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 网络需求越大，Web应用程序就越复杂。构建一个真实的单页应用程序需要编写大量的JavaScript，并且包含所有必需的外部库可能会使页面上的脚本大小增加到几兆字节。在移动设备上，应用程序的初始化可能需要几秒钟甚至几十秒钟，直到所有资源从服务器获取，JavaScript被解析和执行，页面被渲染，以及所有样式被应用。在低端移动设备上，使用移动互联网连接时，这个过程可能会让用户放弃访问我们的应用程序。尽管有一些做法可以加快这个过程，但在复杂的应用程序中，并没有一劳永逸的解决方案。
- en: In the process of trying to improve the user experience, developers discovered
    a technique called **server-side rendering**. It allows us to render the requested
    view of a single-page application on the server and directly provide the HTML
    for the page to the user. Later, once all the resources are processed, the event
    listeners and bindings can be added by the script files. This sounds like a good
    way to boost the performance of our application. One of the pioneers in this was
    React, which allowed prerendering of the user interface on the server side using
    Node.js DOM implementations. Unfortunately, the architecture of AngularJS does
    not allow this. The showstopper is the strong coupling between the framework and
    the browser APIs, the same issue we had in running the change detection in web
    workers.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试改善用户体验的过程中，开发者发现了一种名为**服务器端渲染**的技术。它允许我们在服务器上渲染单页应用程序的请求视图，并直接将HTML提供给用户。一旦所有资源都处理完毕，脚本文件可以添加事件监听器和绑定。这听起来像是一种提升我们应用程序性能的好方法。在这方面，React是先驱之一，它允许使用Node.js
    DOM实现进行服务器端用户界面的预渲染。不幸的是，AngularJS的架构不允许这样做。主要障碍是框架与浏览器API之间的强耦合，这是我们运行web workers中的更改检测时遇到的问题。
- en: Another typical use case for the server-side rendering is for building **Search
    Engine Optimization** (**SEO**)-friendly applications. There were a couple of
    hacks used in the past for making the AngularJS applications indexable by the
    search engines. One such practice, for instance, is the traversal of the application
    with a headless browser, which executes the scripts on each page and caches the
    rendered output into HTML files, making it accessible by the search engines.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端渲染的另一个典型用例是构建**搜索引擎优化**（**SEO**）友好的应用程序。过去为了使AngularJS应用程序可由搜索引擎索引，使用了一些黑客技巧。例如，其中一种做法是使用无头浏览器遍历应用程序，在每个页面上执行脚本并将渲染输出缓存到HTML文件中，使其可由搜索引擎访问。
- en: Although this workaround for building SEO-friendly applications works, server-side
    rendering solves both of the aforementioned issues, improving the user experience
    and allowing us to build SEO-friendly applications much more easily and far more
    elegantly.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种构建SEO友好应用程序的解决方案是有效的，但服务器端渲染解决了上述两个问题，提高了用户体验，并使我们能够更轻松、更优雅地构建SEO友好应用程序。
- en: The decoupling of Angular with the DOM allows us to run our Angular applications
    outside the context of the browser. We will take a further look at it in [Chapter
    9](b9d6c03a-d141-4201-afc6-339a41a38715.xhtml), *Tooling and Development Experience*.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 将Angular与DOM解耦使我们能够在浏览器之外运行Angular应用程序。我们将在第9章[工具和开发体验](b9d6c03a-d141-4201-afc6-339a41a38715.xhtml)中进一步探讨这一点。
- en: Applications that scale
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可扩展的应用程序
- en: 'MVW has been the default choice for building single-page applications since
    Backbone.js appeared. It allows separation of concerns by isolating the business
    logic from the view, allowing us to build well-designed applications. Taking advantage
    of the observer pattern, MVW allows listening for model changes in the view and
    updating it when changes are detected. However, there are some explicit and implicit
    dependencies between these event handlers, which make the data flow in our applications
    not obvious and hard to reason about. In AngularJS, we are allowed to have dependencies
    between the different watchers, which requires the digest loop to iterate over
    all of them a couple of times until the results of the expressions results get
    stable. Angular makes the data flow in one direction; this has a number of benefits:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Backbone.js出现以来，MVW（模型-视图-控制器）一直是构建单页应用的首选。它通过将业务逻辑与视图隔离来分离关注点，使我们能够构建设计良好的应用。利用观察者模式，MVW允许在视图中监听模型变化，并在检测到变化时更新它。然而，这些事件处理器之间存在一些显式和隐式的依赖关系，这使得我们应用中的数据流不明显且难以推理。在AngularJS中，我们允许不同观察者之间存在依赖关系，这要求消化循环迭代它们几次，直到表达式结果稳定。Angular使数据流向一个方向；这带来了一系列好处：
- en: More explicit data flow
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更明确的数据流
- en: No dependencies between bindings, so no **time to live** (**TTL**) of the digest
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定之间没有依赖关系，因此没有**存活时间**（**TTL**）的消化
- en: Better performance of the framework
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架的性能更好
- en: The digest loop is run only once
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消化循环只运行一次
- en: We can create apps that are friendly to immutable or observable models that
    allow us to make further optimizations
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以创建对不可变或可观察模型友好的应用，这使我们能够进行进一步的优化
- en: The change in the data flow introduces one more fundamental change in the AngularJS
    architecture.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 数据流的变化在AngularJS架构中引入了另一个根本性的变化。
- en: We may take another perspective on the scalability problem when we need to maintain
    a large code base written in JavaScript. Although JavaScript's duck typing makes
    the language quite flexible, it also makes its analysis and support by IDEs and
    text editors harder. Refactoring of large projects gets very hard and error prone
    because in most cases, the static analysis and type inference are impossible.
    The lack of compiler makes typos all too easy, which are hard to notice until
    we run our test suite or run the application.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要维护用JavaScript编写的庞大代码库时，我们可能对可扩展性问题有另一种看法。尽管JavaScript的鸭子类型使语言非常灵活，但它也使得IDE和文本编辑器的分析和支持变得更加困难。大型项目的重构变得非常困难且容易出错，因为在大多数情况下，静态分析和类型推断是不可能的。缺乏编译器使得错误拼写变得过于容易，直到我们运行测试套件或运行应用程序，这些错误才难以察觉。
- en: 'The Angular core team decided to use TypeScript because of the better tooling
    possible with it and the compile-time type checking, which help us to be more
    productive and less error prone. As the following figure shows, TypeScript is
    a superset of ECMAScript; it introduces explicit type annotations and a compiler:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Angular核心团队决定使用TypeScript，因为它提供了更好的工具和编译时类型检查，这有助于我们提高生产力并减少错误。如图所示，TypeScript是ECMAScript的超集；它引入了显式类型注解和编译器：
- en: '![](img/5c674b35-6caf-4c3c-a770-a9d6d5442985.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5c674b35-6caf-4c3c-a770-a9d6d5442985.png)'
- en: Figure 1
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图1
- en: The TypeScript language is compiled to plain JavaScript, supported by today's
    browsers. Since version 1.6, TypeScript implements the ECMAScript 2016 decorators,
    which makes it the perfect choice for Angular.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript语言被编译成普通JavaScript，受到今天浏览器的支持。自1.6版本以来，TypeScript实现了ECMAScript 2016装饰器，这使得它成为Angular的完美选择。
- en: The usage of TypeScript allows much better IDE and support of the text editors
    with static code analysis and type checking. All this increases our productivity
    dramatically by reducing the mistakes we make and simplifying the refactoring
    process. Another important benefit of TypeScript is the performance improvement
    we implicitly get by the static typing, which allows runtime optimizations by
    the JavaScript virtual machine.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript的使用允许IDE和文本编辑器提供更好的支持，包括静态代码分析和类型检查。所有这些通过减少我们犯的错误和简化重构过程，显著提高了我们的生产力。TypeScript的另一个重要好处是通过静态类型，我们隐式地获得了性能提升，这允许JavaScript虚拟机进行运行时优化。
- en: We'll be talking about TypeScript in detail in [Chapter 4](c8967e3c-a8b3-40c6-900e-e9ccd07357aa.xhtml),
    *TypeScript Crash Course*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第4章](c8967e3c-a8b3-40c6-900e-e9ccd07357aa.xhtml)“TypeScript快速入门”中详细讨论TypeScript。
- en: Templates
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板
- en: Templates are one of the key features in AngularJS. They are simple HTML and
    do not require any intermediate translation, unlike most template engines, such
    as mustache. Templates in Angular combine simplicity with power by allowing us
    to extend HTML by creating an internal **Domain-Specific Language** (**DSL**)
    inside it, with custom elements and attributes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 模板是 AngularJS 的关键特性之一。它们是简单的 HTML，并且不需要任何中间转换，与大多数模板引擎，如 mustache 不同。AngularJS
    中的模板通过允许我们在其中创建内部 **领域特定语言**（**DSL**），结合了简单性和强大功能，这些内部元素和属性是自定义的。
- en: This is one of the main purposes of web components as well. We already mentioned
    how and why Angular takes advantage of this new technology. Although AngularJS
    templates are great, they can still get better! The new Angular templates took
    the best from the past and enhanced it by fixing some of the confusing parts.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是 Web 组件的主要目的之一。我们已经提到了 Angular 如何利用这项新技术以及为什么这样做。尽管 AngularJS 模板很棒，但它们仍然可以变得更好！新的
    Angular 模板吸取了过去的精华，并通过修复一些令人困惑的部分来增强它。
- en: 'For example, let''s say we have a directive and we want to allow the user to
    pass a property to it using an attribute. In AngularJS, we can approach this in
    the following three different ways:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个指令，我们想要允许用户通过属性传递一个属性给它。在 AngularJS 中，我们可以以下三种不同的方式来处理这个问题：
- en: '[PRE1]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the `user` directive, we pass the `name` property using three different approaches.
    We can either pass a literal (in this case, the `"literal"` string), a string,
    which will be evaluated as an expression (in our case `"expression"`), or an expression
    inside, `{{ }}`. Which syntax should be used completely depends on the implementation
    of the directive, which makes its API tangled and hard to remember.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `user` 指令中，我们可以通过三种不同的方法传递 `name` 属性。我们可以传递一个字面量（在这种情况下，是 `"literal"` 字符串），一个字符串，它将被评估为一个表达式（在我们的例子中是
    `"expression"`），或者一个内部的 `{{ }}` 中的表达式。应该使用哪种语法完全取决于指令的实现，这使得它的 API 复杂且难以记忆。
- en: Dealing with a large amount of components with different design decisions on
    a daily basis is a frustrating task. By introducing a common convention, we can
    handle such problems. However, in order to have good results and consistent APIs,
    the entire community needs to agree with it.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 每天处理大量具有不同设计决策的组件是一项令人沮丧的任务。通过引入一个共同约定，我们可以处理这些问题。然而，为了获得良好的结果和一致的 API，整个社区都需要同意它。
- en: Angular deals with this problem by providing a special syntax for attributes,
    whose values need to be evaluated in the context of the current component, and
    a different syntax for passing literals.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 通过提供一种特殊的语法来处理这个问题，该语法用于属性的值，这些值需要在当前组件的上下文中进行评估，以及用于传递字面量的不同语法。
- en: 'Another thing we''re used to, based on our AngularJS experience, is the microsyntax
    in template directives, such as `ng-if` and `ng-for`. For instance, if we want
    to iterate over a list of users and display their names in AngularJS, we can use
    this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件我们习惯的事情，基于我们的 AngularJS 经验，是模板指令中的微语法，例如 `ng-if` 和 `ng-for`。例如，如果我们想在 AngularJS
    中遍历用户列表并显示他们的名字，我们可以这样做：
- en: '[PRE2]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Although this syntax looks intuitive to us, it allows limited tooling support.
    However, Angular approached this differently by bringing a little bit more explicit
    syntax with richer semantics:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种语法对我们来说看起来直观，但它只允许有限的工具支持。然而，Angular 通过引入更丰富的语义的更多显式语法来采取了不同的方法：
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding snippet explicitly defines the property, which has to be created
    in the context of the current iteration (`user`), and the one we iterate over
    (`users`).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段明确定义了属性，该属性必须在当前迭代（`user`）的上下文中创建，以及我们迭代的（`users`）。
- en: 'Since this syntax is too verbose for typing, developers can use the following
    syntax, which later gets translated to the more verbose one:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种语法在键入时过于冗长，开发者可以使用以下语法，它后来会被转换成更冗长的形式：
- en: '[PRE4]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The improvements in the new templates will also allow better tooling for advanced
    support by text editors and IDEs. We will discuss Angular's templates in [Chapter
    5](1b60c28e-5f34-493d-8371-c69968f09020.xhtml), *Getting Started with Angular
    Components and Directives*.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 新模板的改进也将允许更好的工具支持，这些工具支持高级功能。我们将在 [第 5 章](1b60c28e-5f34-493d-8371-c69968f09020.xhtml)
    中讨论 Angular 的模板，*开始使用 Angular 组件和指令*。
- en: Change detection
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变更检测
- en: In the w*eb workers* section, we already mentioned the opportunity to run the
    digest loop in the context of a different thread, instantiated as web worker.
    However, the implementation of the digest loop in AngularJS is not quite as memory-efficient
    and prevents the JavaScript virtual machine from doing further code optimizations,
    which allows for significant performance improvements. One such optimization is
    the inline caching ([http://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html](http://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html)).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在“Web Workers”部分，我们已经提到了在作为 Web Worker 实例化的不同线程上下文中运行 digest 循环的机会。然而，AngularJS
    中 digest 循环的实现并不那么内存高效，并阻止 JavaScript 虚拟机进行进一步的代码优化，这允许实现显著的性能提升。其中一种优化是内联缓存（[http://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html](http://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html)）。
- en: The Angular team did a lot of research in order to discover different ways the
    performance and efficiency of the change detection could be improved. This led
    to the development of a brand new change detection mechanism.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 团队进行了大量研究，以发现提高变更检测性能和效率的不同方法。这导致了全新的变更检测机制的诞生。
- en: As a result, Angular performs change detection in code that the framework directly
    generates from the templates of the components; the code is generated by the **Angular
    compiler**. The Angular compiler is a module of the framework which can process
    an Angular application, after that perform different optimizations on top of it,
    and in the end generate code that will perform much better than the source code
    that we have written.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Angular 在框架直接从组件模板生成的代码中执行变更检测；该代码由**Angular 编译器**生成。Angular 编译器是框架的一个模块，它可以处理
    Angular 应用程序，然后在其之上执行不同的优化，最终生成比我们编写的源代码性能更好的代码。
- en: 'There are two built-in code generation (also known as compilation) strategies:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种内置的代码生成（也称为编译）策略：
- en: '**Just-in-time (JIT) compilation**: At runtime, Angular generates code that
    performs change detection on the entire application. The generated code is optimized
    for the JavaScript virtual machine, which provides a great performance boost.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**即时编译（JIT）**：在运行时，Angular 生成在整个应用程序上执行变更检测的代码。生成的代码针对 JavaScript 虚拟机进行了优化，提供了巨大的性能提升。'
- en: '**Ahead-of-time (AOT) compilation**: This is similar to JIT, with the difference
    that the code is being generated as part of the application''s build process.
    It can be used for speeding the rendering up by not performing the compilation
    in the browser and also in environments that disallow `eval()`, such as ones with
    strict **Content-Security-Policy** (**CSP**) and Chrome extensions. We will discuss
    it further in the next sections of the book.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预编译（AOT）**：这与 JIT 类似，不同之处在于代码是作为应用程序构建过程的一部分生成的。它可以用于通过不在浏览器中执行编译来加快渲染速度，也可以用于不允许
    `eval()` 的环境，例如具有严格**内容安全策略（CSP**）和 Chrome 扩展的环境。我们将在本书的下一节中进一步讨论。'
- en: We will take a look at the new change detection mechanism and how we can configure
    it in [Chapter 5](1b60c28e-5f34-493d-8371-c69968f09020.xhtml), *Getting Started
    with Angular Components and Directives*.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第 5 章](1b60c28e-5f34-493d-8371-c69968f09020.xhtml)“使用 Angular 组件和指令入门”中查看新的变更检测机制以及如何配置它。
- en: Summary
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we considered the main reasons behind the lack of backward
    compatibility between AngularJS and Angular. We saw that the design decisions
    implemented in Angular were fueled by two things: the evolution of the web and
    the evolution of the frontend development, with the lessons learned from the development
    of AngularJS applications.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们考虑了 AngularJS 和 Angular 之间缺乏向后兼容性的主要原因。我们了解到，Angular 中实施的设计决策是由两件事推动的：Web
    的发展以及前端开发的发展，以及从 AngularJS 应用程序开发中学到的经验教训。
- en: In the first section, you learned why we need to use the latest version of the
    JavaScript language, why to take advantage of web components and web workers,
    and why it's not worth integrating all these powerful tools in AngularJS.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分，你学习了为什么我们需要使用 JavaScript 语言的最新版本，为什么利用 Web 组件和 Web Workers，以及为什么在 AngularJS
    中集成所有这些强大的工具不值得。
- en: We observed the current direction of frontend development and the lessons learned
    in the last few years. We described why the controller and scope were removed
    from Angular, and why the architecture of AngularJS was changed in order to allow
    server-side rendering for SEO-friendly, high-performance, single-page applications.
    Another fundamental topic we took a look at was building large-scale applications,
    and how that motivated single-way data flow in the framework and the choice of
    the statically typed language, TypeScript.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们观察了前端开发的当前方向和过去几年中吸取的教训。我们描述了为什么控制器和作用域被从Angular中移除，以及为什么为了允许SEO友好的高性能单页应用进行服务器端渲染，AngularJS的架构发生了变化。我们还关注了一个基本主题，即构建大规模应用，以及这是如何激励框架中的单向数据流以及选择静态类型语言TypeScript的。
- en: In the next chapter, we will take a look at the main building blocks of an Angular
    application, how they can be used, and how they relate to each other. Angular
    reuses some of the naming of the concepts introduced by AngularJS, but generally
    changes the building blocks of our single-page applications completely. We'll
    make a quick introduction to modules, directives, components, the new router,
    pipes, and services, and describe how they could be combined for building classy,
    single-page applications.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨Angular应用的主要构建块，它们如何被使用，以及它们之间的关系。Angular重用了AngularJS引入的一些概念名称，但通常完全改变了我们的单页应用的构建块。我们将快速介绍模块、指令、组件、新的路由器、管道和服务，并描述它们如何结合用于构建优雅的单页应用。
- en: Downloading the example code
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 下载示例代码
- en: You can download the example code files for this book from your account at [http://www.packtpub.com](http://www.packtpub.com).
    If you purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files emailed directly to you.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://www.packtpub.com](http://www.packtpub.com)的账户下载本书的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。
