- en: '*Chapter 5*: Use Effect to Handle Side Effects'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we learned how `useState` is designed and how to use
    it to manage state changes in `useEffect` for managing *side effects*. We will
    first introduce what a *side effect* is, and then we will walk through the data
    structure and source code behind `useEffect` and provide various scenarios for
    invoking effects. We will also demonstrate a couple of pitfalls of using `useEffect`
    and discuss some ways to avoid them. At the end of this chapter, we''ll use `useEffect`
    in two practical examples: *Finding the window size* and *Fetching an API resource*.
    The chapter also includes three bonus topics in the *Appendix* section: *React
    side* *effects, Flushing the passive effects,* and *Is a dispatch async*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a side effect?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Understanding` `useEffect` design'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test driving `useEffect`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`useEffect` examples'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions and answers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Appendix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a side effect?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following function has no side effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This function is quite pure, in the sense that if it is invoked with the same
    set of input arguments, we should get the same result – that is, `add(1, 1)` will
    return `2`. This type of *pure* function is easy to understand, test, and develop.
    The reason for this is that the function only depends on the input arguments and
    has no additional hidden dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might wonder what a hidden dependency could be? Believe it or not, it''s
    quite easy to have one. In the following code, we''ll intentionally introduce
    two lines and each will add a hidden dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first line adds an external dependency from the `c` variable. Because `c`
    is a global variable, it bypasses the input argument list. If we invoke the `add(1,
    1)` function now, it can return any number (or even a non-number). That's because
    `c` can be anything at the time when `add` is invoked. This applies to all *global*
    instances.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at another hidden dependency. Inside the `add` function, the
    first line adds an external dependency from the `console.log` function. Our intention
    here is to log the `a` and `b` variables to the screen. However, the `console.log`
    function could be anything at the runtime. For instance, if `console` doesn't
    exist, we could get an error when invoking `console.log`.
  prefs: []
  type: TYPE_NORMAL
- en: From these preceding examples, we can see that we could work with an *impure*
    function without knowing it. There's one important thing to bear in mind about
    impure functions – that is, they are prone to errors. For instance, in the preceding
    example, if someone changed any of the hidden dependencies, it would be difficult
    for the developer to know that. This can become a nightmare when it comes to refactoring
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: To make our code robust, we tend to develop strategies to *avoid* hidden dependencies,
    either by removing them or containing their impact as much as possible so that
    we can be confident when developing and maintaining our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, there are two strategies to remedy impurity of functions. One way
    is to remove it by adding the dependencies to the input arguments so that they
    are not *hidden* anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This can be a very effective approach. With the preceding code change, the `c`
    variable and the `log` function are explicitly written as input arguments. It
    should take less effort to test this in the case of `add(1, 1, 0, console.log)`.
    The only downside to this approach is that to implement it, you need to know the
    dependencies and declare them explicitly. This means the list of input arguments
    could get very long and impact the effectiveness of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'This brings us to the second strategy. Instead of removing the impurity, we
    can package and defer it to a later stage until we actually need to execute it.
    The following is an example of how we can *defer* an impurity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `addFunc` function returns an `add` function. To use the `add` function,,
    we invoke `addFunc` to get a handle (also called a callback) of our `add` function
    back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: So, what difference does this make? The dependency for `c` and `log` appears
    in the input arguments, so `addFunc` is a *pure* function. Essentially, we package
    any impurities and declare them one level up, so within the context of `addFunc`,
    the new `add` function looks and works a bit purer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a sense, we keep the original code, but we wrap it up to get a callback
    function so that we can execute it later. This helps protect the integrity of
    the main code while relocating the impurity. This deferred strategy is normally
    referred to as a *side effect*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the assignment of the `c` variable inside `add` is a
    side effect because it *changes* a global value; the assignment of the `a` variable
    is another side effect because it *reads from* a global value. From here, you
    can see that `console` is a solid side effect because it's an external service
    that writes to a terminal screen.
  prefs: []
  type: TYPE_NORMAL
- en: In a loosely connected open system, such as the web, a side effect is unavoidable.
    If you want to perform a range of actions and one action happens to not be defined
    by the internal system, then the action involves accessing an external system.
    Although we cannot avoid the side effect, we can package the side effect so that
    it accesses the external system at the right time.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing passive effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In React, a *side effect* refers to a case where we attempt to either *read
    from* or *write to* an *external system*. The external system can be a DOM element,
    an object such as a `document` or `window` object, or a fetch to a web server.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – React passive effects'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.01_B17963.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – React passive effects
  prefs: []
  type: TYPE_NORMAL
- en: Upon a user action, a *dispatch* is scheduled to trigger a *render* that is
    followed by a *commit* to form an update (as illustrated in *Figure 5.1*). During
    the update, React doesn't allow custom side effects to be invoked right away.
    Instead, React waits until the end of the commit before invoking them.
  prefs: []
  type: TYPE_NORMAL
- en: If there are two side effects encountered during the update, both are deferred
    and then invoked one by one after the *commit*. Effects such as these are referred
    to as the passive effects internally. Passive effects are one of several types
    of effects supported by React. If you are interested in the other types of effects,
    please refer to the *Appendix A – React side effects* section at the end of this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: It is referred to as *passive* due to the way it's invoked during the update.
    React allows us to invoke a passive effect in each update or to conditionally
    invoke it when responding to a value change. Therefore, the effect isn't actively
    tied as in the case of a user event, but instead, upon a value change, the effect
    gets created, queued, and then invoked later. In a way, the effect can be invoked
    through a passive "event".
  prefs: []
  type: TYPE_NORMAL
- en: A passive effect is modeled as a callback function. In this instance, let's
    say it's called `create`. Invoking the `create` function executes the effect and
    returns a `destroy` function to perform the cleanup job associated with the effect.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what a React effect is, let's dive in and see how a `useEffect`
    hook is designed to facilitate this process.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding useEffect design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'React provides a `useEffect` hook to set up a callback to be invoked after
    an update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `useEffect` function takes a callback function called `create` as its first
    input argument to define the effect. In the preceding example, the effect sets
    the `window.title` to be `Hello World` when the component is mounted.
  prefs: []
  type: TYPE_NORMAL
- en: A `create` function can return a function called `destroy` to perform the cleanup.
    The interesting thing here is that the `destroy` function is provided by the `create`
    function as a return value. In the preceding example, the cleanup reverts the
    `window.title` object back to `NoTitle` when it is unmounted.
  prefs: []
  type: TYPE_NORMAL
- en: The second parameter in the `useEffect` argument list is a dependency array
    called `deps`. If `deps` is *not given*, the effect gets invoked each time during
    each update, whereas when `deps` *is given*, the effect only gets invoked upon
    a change from the `deps` array.
  prefs: []
  type: TYPE_NORMAL
- en: The useEffect hook's data structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to explain how `useEffect` is designed by taking
    a stripped-down version of the source code as an example. First, let's take a
    look at the data structure that makes it happen.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – The data structure for the useEffect hook'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.2_B17963.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.2 – The data structure for the `useEffect` hook
  prefs: []
  type: TYPE_NORMAL
- en: 'To keep track of effects, React creates an `updateQueue` property under a fiber
    of the `UpdateQueue` type (as illustrated in *Figure 5.2*). Inside this queue,
    a list of effects is stored under the `lastEffect` property. Effects are linked
    together using a circular linked list (see *Figure 5.3*), similar to the pending
    queue that we see in `useState`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – A fiber''s update queue for useEffect'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.03_B17963.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.3 – A fiber's update queue for useEffect
  prefs: []
  type: TYPE_NORMAL
- en: Each effect in the list, it stores the effect function in the `create` property
    and the cleanup function in the `destroy` property.
  prefs: []
  type: TYPE_NORMAL
- en: The `useEffect` hook follows a typical hook setup where it takes the path of
    either `mountEffect` or `updateEffect`, depending on whether the fiber is under
    mount or update, via the `isFiberMounting` flag (as explained in [*Chapter 3*](B17963_03_Epub.xhtml#_idTextAnchor080),
    *Hooking into React*).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `useEffect` hook takes the `create` function as well as the `deps` array
    and it does not return any value.
  prefs: []
  type: TYPE_NORMAL
- en: Mounting an effect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When the component is under mount, the `mountEffect` function first creates
    a hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Once it gets a hook, it stores the effect under the hook''s `state`. The effect
    is created with the `pushEffect` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `pushEffect` function creates an effect with all of the effect information,
    such as `create`, `destroy`, `deps`, and `next`. Then, it finds the `updateQueue`
    function under the currently updating fiber. If the queue is empty, the new effect
    gets attached. Otherwise, the new effect is appended to the queue. Either way,
    it appends the new effect as the `lastEffect` object in the queue. Since it's
    a circular linked list, after all of the previous pointer operations have taken
    place, it makes sure the `lastEffect.next` object still points to the first effect
    in the list.
  prefs: []
  type: TYPE_NORMAL
- en: Updating an effect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After the component is mounted, the next time it gets updated and reaches in
    the `useEffect` hook, it goes into `updateEffect` and gets the hook by cloning
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Once we have the hook, we can check the previous effect set in the mount and
    compare whether the `deps` array has changed. If the `deps` array hasn't changed
    from the `prevDeps` object stored in `prevEffect`, it returns without pushing
    the effect to `updateQueue`.
  prefs: []
  type: TYPE_NORMAL
- en: A utility function called `areDepsEqual` is used to compare the current and
    previous dependency arrays. We will examine this function in detail in the *Creating
    effects* section later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Scheduling effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There''s something very special about effects: effects are pushed into `queue`
    under each fiber, but they are scheduled around the time the screen is about to
    change.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For each effect, there are two callback functions that need to be scheduled:
    one is `create` and one is `destroy`. Taking `create` as an example, each `create`
    function is collected into a list via the `enqueueEffect` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `enqueueEffect` function takes the fiber and the effect and pushes
    it into the `effectsCreateList` array. It then schedules the `flushEffects` callback.
    The reason why the array doesn't get processed (or flushed out) the right away
    is that it has to wait until the end of the update. Here, React uses a global
    flag (`rootDoesHaveEffects`) to make sure it only triggers this schedule once.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same process happens to each `destroy` function as well. For each update,
    we end up with two lists of effects: one for `effectCreateList` and one for `effectDestroyList`.
    Although similar, these two lists don''t necessarily contain the same list of
    effects because some effects don''t have the `destroy` callback. Moreover, when
    the component gets unmounted, the `destroy` callback needs to be added to `effectDestroyList`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `scheduleCallback` function is quite interesting. Instead of flushing and
    executing the effects right away, it does this a bit later, just like an asynchronous
    task in a new **JavaScript** task. If you are interested in the details of this,
    please refer to the *Appendix B – Flushing passive effects* section at the end
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Flushing effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is only after the screen has been updated with the DOM changes that React
    can visit the effects lists again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code goes over `effectDestroyList`, and each `destroy` function
    found, it gets invoked. After all of the `destroy` functions have been invoked,
    React flushes out the effects list for `create`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `effectCreateList` gets flushed out by invoking the `create`
    function under each `effect` object. The result of the `create` function is then
    taken as the `destroy` function.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the order in which React goes through both lists – it starts with `destroy`
    and then goes to `create`. Since both lists are collected from all of the fibers,
    there's a chance that the `create` function could contain a reference to a variable
    of a component that is going to be destroyed or cleaned up. In order to give the
    `create` function a chance to be fully aware of this situation, `destroy` functions
    need to be called before this happens. In short, all previous effects need to
    be cleaned up before new effects can be considered.
  prefs: []
  type: TYPE_NORMAL
- en: A walk-through of the useEffect hook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is hard work, and we have just gone through a stripped-down version of
    the `useEffect` hook''s source code. To help us understand this from a higher
    level, the following diagram outlines the `useEffect` hook in terms of the effects
    workflow in React (see *Figure 5.4*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – The useEffect hook and the React effects workflow'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.04_B17963.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.4 – The useEffect hook and the React effects workflow
  prefs: []
  type: TYPE_NORMAL
- en: Let's do a quick run-through of *Figure 5.4*. In an update, as a `useEffect`
    hook is invoked, if the component is under mount, it creates the effect. If the
    component is under update, it creates the effect depending on whether there are
    any dependency changes. If there's no change to the dependency array, the effect
    is skipped. In all cases when the effect is created, it gets appended to the fiber's
    `updateQueue` and stored under the hooks' `state`.
  prefs: []
  type: TYPE_NORMAL
- en: Right before the screen update, React takes all of the effects from all of the
    fibers and schedules a flush (denoted by the dotted line in *Figure 5.4*). After
    all of the fiber changes are applied to the DOM, React flushes them out by invoking
    them one by one, starting with the previous `destroy` effects and following them
    with the new `create` effects.
  prefs: []
  type: TYPE_NORMAL
- en: Creating effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An effect can be skipped. As a matter of fact, an effect needs to be created
    in an update for it to take effect. This behavior is captured by a dependency
    array called `deps`. React uses a utility function called `areDepsEqual` to help
    decide whetherthis array changes. Let''s take a closer look at this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `areDepsEqual` function is used to compare two dependency arrays between
    the previous `prevDeps` array and the current `deps` array and returns `true`
    if all of the elements match. Though this sounds easy to carry out, it can run
    into various scenarios depending on the elements of the dependency arrays. We''ll
    explain all of the scenarios in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`prevDeps` is not provided and the usage omits the array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When this happens, the `areDepsEqual` function always returns `false`, and so
    the effect gets created in each update.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`areDepsEqual` return `true` for all updates except the first one because,
    for the mount, the `deps` array still is considered to be changed from `undefined`.
    Therefore, the effect gets created once and after this, it does not get created
    anymore.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deps` are not empty, each element between the previous and current dependencies
    performs an `Object.is` comparison. We have already discussed the `Object.is`
    function in detail in [*Chapter 4*](B17963_04_Epub.xhtml#_idTextAnchor113), *Use
    State to* *Jumpstart Components*. Here, each element pair goes through this comparison
    to determine whether the array changes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Other than the mount, if any of the elements change, such as `a` or `b`, the
    effect gets created.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Creating and destroying
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If a `destroy` function is given from the effect `create` function, this case
    also needs to be taken into consideration. Remember, we have two separate arrays
    keeping track of both mounted and unmounted cases. In general, the `destroy` function
    is invoked before the `create` function is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: So, here's a quick list to summarize all of these cases.
  prefs: []
  type: TYPE_NORMAL
- en: It runs `create` once after the mount.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For any `deps` changes, it runs `destroy` and `create` once.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It runs `destroy` once after the unmount.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `destroy` function is not provided, this process reduces to a single
    case below.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It runs for any `deps` change, including the mount.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have gone through the `useEffect` hook's design as well as all of
    the scenarios of invoking the callback, let's take the `useEffect` hook for a
    test drive.
  prefs: []
  type: TYPE_NORMAL
- en: Test driving the useEffect hook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The effect callback is defined in the `useEffect` hook''s first input argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The most common way of using the `create` function can be defined by using the
    `() => {}`). For readers interested in learning more about *JavaScript ES6*, please
    see the Embracing *JavaScript ES6* section in [*Chapter 10*](B17963_10_Epub.xhtml#_idTextAnchor363),
    *Building a Website with React*.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the interesting facts about this effect function is that, thanks to
    JavaScript *closures*, it can access all of the variables defined in the functional
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `create` callback function in the preceding code references both the `a`
    variable and `text`. Without the JavaScript closure, both variables would have
    to be passed into the inline function through the input arguments explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another interesting fact about the `useEffect` hook is that the effect is a
    callback where it''s quite common to see an effect involving a state changed inside.
    Let''s take a look at one example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – A button with clickable text'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.05_B17963.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.5 – A button with clickable text
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we have a `Title` component that gets a `text` prop. Inside, it
    has a button. When this gets clicked, it can increment a `count` state. Initially,
    the `count` value is set to `0`, and whenever the `text` prop changes, it can
    reset the `count` value back to `0`. Notice that the user clicking and the `text`
    prop change could be entirely unrelated and driven by different mechanisms. The
    former comes from the user action, whereas the latter comes from the change from
    the parent components::'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To implement the described behavior, we apply `useEffect` to dispatch `setCount`
    with the `deps` array set to the `text` prop. The following code example shows
    the timeline sketch for two clicks and one text change from the `a` letter to
    the `b` letter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As the mount starts, the first update starts with the text as `a` and the `count`
    as `0`. It also creates an effect, but since the `count` value is already `0`,
    the `setCount` dispatch is skipped.
  prefs: []
  type: TYPE_NORMAL
- en: As the user makes the first click, the `onClick` event handler is invoked, therefore
    setting `count` to `1`. The same applies to the second click in order to arrive
    at the `count` value of `2`. When the parent component changes the `text` prop
    from `a` to `b`, it raises another update.
  prefs: []
  type: TYPE_NORMAL
- en: In the same update, the unchanged `count` value is printed out again. But this
    time, the dependency array of `useEffect` detects the change due to `[text]`.
    Therefore, it creates an effect to invoke `setCount(0)`. As we know that the `setCount`
    schedules another update, it will bring the `count` back to `0` afterward.
  prefs: []
  type: TYPE_NORMAL
- en: Playground – Button with parent text
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to play with this example online at [https://codepen.io/windmaomao/pen/rNGOVor](https://codepen.io/windmaomao/pen/rNGOVor).
  prefs: []
  type: TYPE_NORMAL
- en: Wow! This is how `useEffect` works. By using `setState` inside the callback,
    an additional update can be requested to update the screen. So, the effect takes
    effect in a different update. Also, to make the effect work, the `deps` array
    needs to be wired with the right state change because if we miss it, the effect
    can be stalled. Let's take a look at one example when this happens.
  prefs: []
  type: TYPE_NORMAL
- en: Missing dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s go back to a simple setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If you intend to print out `count` every time it changes, the preceding code
    misses the right dependency – the correct one should be `[count]` instead of `[]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If this example is too obvious, let''s try a less obvious one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we introduce a `text` prop and put it in the `deps`
    array. In this case, what we get is that when the `text` changes, it prints out
    `text + count`. However, if the `count` value changes due to a user''s click,
    the screen wouldn''t change. To fix this, we can add the `count` value to the
    dependency array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: A pattern seems to emerge here – if an effect callback uses a variable, that
    variable needs to be in the `deps` array. This statement is practically 99.9%
    true. If you intentionally do not want to update the screen when a variable changes,
    you can skip adding it to the dependency array. However, this is not recommended
    by React. React even adds an `eslint-plugin-react-hooks`) to help us spot the
    cases where we have missed a potential dependency.
  prefs: []
  type: TYPE_NORMAL
- en: You might wonder why React doesn't want us to miss any dependencies. This is
    because in React, every value (or state) should be in-sync with the current screen
    and there can't be exceptions to this rule by default.. In [*Chapter 8*](B17963_08_Epub.xhtml#_idTextAnchor278),
    *Use Ref to Hide Stuff*, we will show you a recommended way if you insist on keeping
    things hidden from React.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen cases that have used both effects and states , let's take
    a look at another example of when we might run into problems with them.
  prefs: []
  type: TYPE_NORMAL
- en: Infinite loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Combining *state* and *effects* can cause another interesting problem because
    an effect can change a state and therefore schedule a new update, and then the
    new update can create a new effect and change a state, and this can continue indefinitely.
    This could lead to an *infinite loop*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can demonstrate this with a quick example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, there''s an effect that increments a `count` state after
    any `count` change. After invoking `setCount`, in the next update, `useEffect`
    would detect a change from the dependency array and thereby invoke `setCount`
    again. Because every time this happens we get a new `count` number, this process
    wouldn''t stop, as you can see in the following timeline sketch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Normally, we wouldn't do this intentionally, but we can accidentally run into
    exactly this scenario in a more complex setup, especially when many different
    states and effects are involved. It's our job to avoid an infinite loop whenever
    possible since this isn't accounted for by React.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how do we deal with an infinite loop in code? We can break out of a loop
    with an `if` statement, and this is normally the most cost-effective approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, after we add the `if` statement on the first line inside
    the effect, the timeline confirms that we don''t have an infinite loop anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it's not too difficult to break out of a loop. You can think
    of this as an equilibrium state that you want to reach – the effect does need
    to be triggered for a state change, but once an equilibrium state is reached,
    it stops without continuing the loop.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have gone over how `useEffect` is used, let's take a look at two
    practical cases for applying it.
  prefs: []
  type: TYPE_NORMAL
- en: useEffect examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `useEffect` hook is normally used for any side effect – whether that is
    to read from an external object or write to an external object. In the following
    sections, we are going to see two more examples: *Finding the window size* and
    *Fetching an API resource*.'
  prefs: []
  type: TYPE_NORMAL
- en: Finding the window size
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s say that we want to know the current browser window size at runtime
    so that a greeting title can fit perfectly onto the screen (see *Figure 5.6*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Finding the window size'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.06_B17963.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.6 – Finding the window size
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be done normally with a **CSS** media query, but this time, we want
    to do it via *JavaScript*, as a runtime *JavaScript* variable obtained can be
    sent for purposes other than CSS usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `useEffect` hook is a good fit here. After the component is mounted, we
    can listen for a `resize` event provided by the `window` object. Once it starts
    to listen to the event, every time the window resizes, it kicks off a `handleResize`
    function that sets the `width` state to the new window size. We also invoke `handleResize`
    at the mount to get the initial window size.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, if the current width is greater than 600 px, we know that it
    can fit the `Hello World` string on screen. Otherwise, the `Hello` string will
    be used. This shows that we can control the display based on the window size on
    the fly with J*avaScript.*
  prefs: []
  type: TYPE_NORMAL
- en: Playground – Finding the Window Size
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to play with this online example at [https://codepen.io/windmaomao/pen/BadRoNN](https://codepen.io/windmaomao/pen/BadRoNN).
  prefs: []
  type: TYPE_NORMAL
- en: In order to prevent a memory leak, we return a `destroy` function from the `useEffect`
    callback where the registered event listener is removed when the component is
    unmounted.
  prefs: []
  type: TYPE_NORMAL
- en: There's a subtle detail to be aware of here – the dependency array has `setWidth`
    in it because we reference `setWidth` inside the `useEffect` function. If you
    remember from [*Chapter 4*](B17963_04_Epub.xhtml#_idTextAnchor113), *Use State
    to Jumpstart Components*, we know the `setWidth` function instance doesn't get
    changed after the mount, so actually, `[setWidth]` can be optional here. But React
    insists that we add this because when `setWidth` changes, the effect needs to
    be re-created.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching an API resource
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One popular use of `useEffect` is to fetch an API resource and display the
    data on screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Fetching an API resource, loading status'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.07_B17963.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.7 – Fetching an API resource, loading status
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea here is to use the `fetch` JavaScript function to get the resource.
    During loading, the screen should say `loading...` (as in *Figure 5.7*). And after
    the resource is successfully fetched, the `loading...` string should be dismissed
    and replaced with the fetched text on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we use a `text` state to store the fetched text and a
    state `loading` flag to store the loading status. A `useEffect` hook is used to
    fetch the resource and when it's successful, it updates the `text` and `loading`
    flag.
  prefs: []
  type: TYPE_NORMAL
- en: Playground – Fetching an API Resource
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to play with this online example at [https://codepen.io/windmaomao/pen/ZEJKbev](https://codepen.io/windmaomao/pen/ZEJKbev).
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the effect doesn't return anything. There's actually a cleanup
    to do in this case, but we will wait until [*Chapter 8*](B17963_08_Epub.xhtml#_idTextAnchor278),
    *Use Ref to Hide Stuff*,to explore that in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that an `if` statement is used before the `return` statement. In [*Chapter
    3*](B17963_03_Epub.xhtml#_idTextAnchor080), *Hooking into React*, we mentioned
    that `if` cannot be used in between hook statements. So, in this case, we move
    it after all of the hook statements and put it right before the last return statement.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the `if` statement acts as a short-circuit. If the `loading` status
    is `true`, it does not go any further other than returning a `loading...` string.
    This `if` statement approach is one of the most cost-effective ways to make sure
    the screen only renders material when it's available.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We really did a lot in this chapter. First, we got to know what a side effect
    is, and we dug deeper into the `useEffect` hook's design. We discovered how an
    effect can be created and then later invoked after a UI update. We also learned
    about various scenarios for creating effects based on dependency arrays. After
    that, we walked through the pitfalls of using `useEffect` with missing dependencies,
    staled values, and infinite loops. Last but not least, we learned to apply `useEffect`
    in practical components, such as the examples of finding the window size in a
    browser and fetching API resources from an online server.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discover our next hook in the React family and
    focus on how to apply an optimization to boost performance by using values from
    a previous update.
  prefs: []
  type: TYPE_NORMAL
- en: Questions and answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some questions and answers to refresh your knowledge:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a side effect?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A side effect is when a function relies on or modifies something outside of
    its input arguments. A very common side effect is the use of `console.log` inside
    a function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What is `useEffect`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `useEffect` hook is a way of defining a side effect callback to be invoked
    after a screen update in React. The effect can be invoked every time or when one
    of its dependencies changes. Therefore, the `useEffect` hook can be also used
    for listening for value changes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What are the most common uses of `useEffect`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `useEffect` hook is a common hook in the React family. If used along with
    the `useState` hook, it can easily communicate with external resources and bring
    results on screen. External resources can be web servers, DOM elements, `window`
    objects, `document` objects, or any third-party entities.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Appendix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Appendix A – React side effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to React, the most well-known effects are passive effects, as
    introduced and explained in detail in this chapter. However, React supports different
    kinds of effects, and in the future, it might add more. The two others currently
    are *mutation effects* and *layout effects*.
  prefs: []
  type: TYPE_NORMAL
- en: All effects are shared with certain features, such as getting collected from
    the fibers before the screen gets updated. But they also differ in some ways.
    Take the *mutation effects* as a first example. Under the engine, these kind of
    effects are the most important effects because each mutation effect tracks the
    addition, removal, or change of a DOM element. Therefore, all fiber reconciliation
    ends up with mutation effects that get committed to the screen. The mutation of
    the DOM elements is also part of the update, or more accurately, the *commit*
    phrase of the update. While the passive effects run after the update, all mutation
    effects happen before the passive effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'To remedy the fact that passive effects run after the update (because by then
    it might be too late to perform a certain action), the *layout effect* is created
    to be invoked a bit earlier. Everything about the layout effect is similar to
    the passive effect, except it gets invoked right after the mutation effect and
    flushes out before the end of the update. The relationships and timing between
    all three kinds of effects can be summarized in the following commit stage outlined
    in *Figure 5.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – React effects during the commit phase'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.08_B17963.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.8 – React effects during the commit phase
  prefs: []
  type: TYPE_NORMAL
- en: Note that during the commit stage, only the mutation and layout effects get
    flushed out.. The passive effects get scheduled initially and later enqueued,
    but not flushed out until after the commit. Please read on to the *Appendix B
    – Flushing passive effects* section for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Appendix B - Flushing passive effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to understand how passive effects are scheduled and flushed, we need
    to first mention *JavaScript* *tasks*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – JavaScript tasks'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.09_B17963.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.9 – JavaScript tasks
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 5.9*, we can see three *JavaScript* tasks. What is a task? A *task*
    is any *JavaScript* code that is scheduled to run by the standard mechanism. In
    the first task on the left, we finished one update. Normally, that's all we need
    to know about running *JavaScript* code.
  prefs: []
  type: TYPE_NORMAL
- en: However, because *JavaScript* is a single-thread engine, during the execution
    of the current task, there can be more work added to the pending queue. A typical
    example is a `setTimeout` call, which adds the callback to the queue instead of
    invoking it right away in the same task. API calls (like promises) normally fall
    into this category as well. This is the main reason why these callbacks are referred
    to as *asynchronous operations*.
  prefs: []
  type: TYPE_NORMAL
- en: There's no specification for how long each task should take. When one task finishes,
    it looks for all the work in the pending queue and then invokes it one task at
    a time, and after everything is done, it looks at the pending queue again. This
    process repeats itself forever. This is what the *JavaScript* engine does.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we have a very short-lived task (middle task in *Figure 5.9*) followed
    by a third task. Guess what – this is when the flushing out of passive effects
    begins. From this, we can be sure that the callback in the `useEffect` callback
    is invoked asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: We mentioned that the multiple state dispatches are also bundled and executed
    in a deferred way – so is a `setState` dispatch also an asynchronous call? To
    answer that question, please read on to the *Appendix C – Is a dispatch asynchronous?*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Appendix C – Is a dispatch asynchronous?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since passive effects are invoked in a new task, at this point, you might wonder
    whether a `setState` dispatch is run in the same task or in a new task. This is
    a very good question.
  prefs: []
  type: TYPE_NORMAL
- en: 'To answer this, we need to have a reference point in time. Let''s say we have
    an event handler, and inside it, we have a `setState` dispatch call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `onClick` event is an event that is requested as a callback via a user action.
    Let's say that the task that invokes the `onClick` event is called *Task 1*.
  prefs: []
  type: TYPE_NORMAL
- en: In React 17 (not the current version), the `setState` code is sync, which means
    it runs in the same *Task 1* for the entire update. React decides it's more efficient
    to finish them all in the same task. So, why do we say the `setState` object is
    normally deferred?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: That's because right after `setState`, the value hasn't been changed yet. Only
    the next update will set the state to the new version. But calling `setState`
    an async operation isn't exactly accurate (if not wrong) because all of this process
    is performed in the same *JavaScript* task.
  prefs: []
  type: TYPE_NORMAL
- en: What if we put `setState` in a `useEffect` hook? Does this passive effect change
    the sync or async discussion?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: By now, we know that the `useEffect` callback gets invoked in a new *JavaScript*
    task – let's say this task is called *Task 1*. And the `setState` runs in the
    same *Task 1*. This makes it behave in quite a similar way to an event handler,
    such as in the case of `onClick` discussed previously. For this reason, we could
    also think of a passive effect as an *"event"* that is more passive than an event
    handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'This doesn''t prevent us from making an async dispatch if we really want to.
    Let''s take a look at one example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, `setTimeout` is used to fire a callback in an async
    way. After the mouse click, `dispatch(5)` is invoked first. And after the update,
    `dispatch(3)` is invoked, even though the timeout duration is set to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind, if you do that, you are not only running the callback in an async
    way, but you also break out of the React scheduling cycle. The reason you might
    want to do this is that there can be conflicts during DOM changes, for example,
    during drag-and-drop handling. In order to finish our code before making the state
    change, we can push the dispatch to the next *JavaScript* task queue.
  prefs: []
  type: TYPE_NORMAL
