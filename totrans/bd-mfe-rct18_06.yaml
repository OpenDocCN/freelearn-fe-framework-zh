- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Implementing the Multi-SPA Pattern for Microfrontends
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为微前端实现多SPA模式
- en: Imagine you are an architect tasked with building the frontend for a large government
    ePortal that has and provides numerous online services for individuals and businesses.
    These services include registering for health benefits, submitting accounts for
    income tax, registering a small business, and paying vehicle road tax, in addition
    to publishing a whole bunch of informational content.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你是一名建筑师，负责构建一个大型政府电子门户的前端，该门户为个人和企业提供众多在线服务。这些服务包括注册健康福利、提交所得税申报、注册小型企业以及支付车辆道路税，此外还有大量信息内容的发布。
- en: Or, scenario two, imagine you have been tasked to build a banking portal that
    provides multiple online services, from managing saving accounts to buying insurance,
    to investment opportunities, loans, mortgages, credit cards, and so on.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，情景二，假设你被分配去构建一个提供多种在线服务的银行门户，从管理储蓄账户到购买保险，再到投资机会、贷款、抵押贷款、信用卡等等。
- en: How would you go about planning not just your architecture but also the team
    that will be responsible for building it? Naturally, the first level of thinking
    would be to break down the large portal into multiple smaller modules or mini-apps
    and have each team focus on one of these mini-apps.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你会如何规划不仅你的架构，还包括将负责构建该架构的团队？自然，首先的思考层次是将大型门户分解成多个较小的模块或微应用，并让每个团队专注于其中一个微应用。
- en: This would be the right approach, and this is also what we refer to as the multi-SPA
    pattern for building microfrontends.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是正确的做法，这也是我们所说的构建微前端的多SPA模式。
- en: 'In this chapter, we will go about building our multi-SPA pattern microfrontend,
    where we will look at the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建我们的多SPA模式微前端，我们将探讨以下内容：
- en: The high-level architecture of the multi-SPA microfrontend
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多SPA微前端的高级架构
- en: Establishing routing between multi-SPAs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多SPA之间建立路由
- en: Using a shared component library
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用共享组件库
- en: Setting up a persistent state to share state between mini apps
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置持久状态以在微应用之间共享状态
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'As we go through the code examples in this chapter, we will need the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们浏览本章中的代码示例时，我们需要以下内容：
- en: A PC, Mac, or Linux desktop or laptop with at least 8 GB of RAM (16 GB preferred)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少8 GB RAM的PC、Mac或Linux桌面或笔记本电脑（16 GB更佳）
- en: An Intel chipset i5+ or Mac M1+ chipset
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 英特尔芯片组i5+或Mac M1+芯片组
- en: At least 256 GB of free hard disk storage
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少256 GB的空闲硬盘存储空间
- en: 'You will also need the following software installed on your computer:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要在你的计算机上安装以下软件：
- en: Node.js version 16+ (use **nvm** to manage different versions of Node.js if
    you have to)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js版本16+（如果你需要管理不同版本的Node.js，请使用**nvm**）
- en: 'Terminal: iTerm2 with OhMyZsh (you will thank me later)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终端：iTerm2配合OhMyZsh（你以后会感谢我的）
- en: 'IDE: We strongly recommend VS Code as we will be making use of some of the
    plugins that come with VS Code for an improved developer experience'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IDE：我们强烈推荐VS Code，因为我们将会使用一些VS Code内置的插件来提升开发者体验
- en: npm, yarn, or pnpm – we recommend pnpm because it’s fast and storage-efficient
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: npm、yarn或pnpm – 我们推荐pnpm，因为它速度快且存储效率高
- en: 'Browser: Chrome, Microsoft Edge, or Firefox (I use Firefox)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器：Chrome、Microsoft Edge或Firefox（我使用Firefox）
- en: A basic understanding of Nx.dev monorepos and a basic understanding of using
    the NX Console plugin in VS Code
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对Nx.dev单一代码库的基本理解，以及对在VS Code中使用NX控制台插件的基本理解
- en: Working knowledge of React
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟练掌握React
- en: 'The code files for this chapter can be found here: [https://github.com/PacktPublishing/Building-Micro-Frontends-with-React](https://github.com/PacktPublishing/Building-Micro-Frontends-with-React)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在以下位置找到：[https://github.com/PacktPublishing/Building-Micro-Frontends-with-React](https://github.com/PacktPublishing/Building-Micro-Frontends-with-React)
- en: We also assume you have a basic working knowledge of Git, such as branching,
    committing code, and raising pull requests.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还假设你对Git有基本的操作知识，例如分支、提交代码和发起拉取请求。
- en: Understanding the multi-SPA architecture
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解多SPA架构
- en: The multi-SPA architecture pattern is one of the most common patterns for building
    large-scale applications. As the name suggests, in this pattern, we have a collection
    of SPAs that together form a large application. In this pattern, each SPA behaves
    as its own independent feature or module that can be directly accessed via a URL
    namespaced and mapped to the app. These SPAs also share a very thin layer of shared
    components and global state to ensure coherency and consistency between the apps.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 多 SPA 架构模式是构建大型应用程序中最常见的模式之一。正如其名所示，在这个模式中，我们有一组 SPA，它们共同构成一个大型应用程序。在这个模式中，每个
    SPA 都作为其自己的独立功能或模块运行，可以通过命名空间并映射到应用程序的 URL 直接访问。这些 SPA 还共享一个非常薄的共享组件和全局状态层，以确保应用程序之间的连贯性和一致性。
- en: '![Figure 4.1 – The multi-SPA architecture](img/Figure_4.01_B18987.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 多 SPA 架构](img/Figure_4.01_B18987.jpg)'
- en: Figure 4.1 – The multi-SPA architecture
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 多 SPA 架构
- en: 'As you can see in *Figure 4**.1*, we have four SPAs: a catalog, which will
    hold pages such as product listings, product details, search, and so on; a checkout
    SPA containing pages such as shopping cart, payments, and so on; the MyAccounts
    SPA; and the Seller/Admin SPA. You will also notice that this pattern allows us
    to easily add additional SPAs as the application grows.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在 *图 4**.1* 中所见，我们有四个 SPA：一个目录，将包含产品列表、产品详情、搜索等页面；一个包含购物车、支付等页面的结账 SPA；我的账户
    SPA；以及卖家/管理员 SPA。您还会注意到这种模式允许我们轻松地随着应用程序的增长添加额外的 SPA。
- en: Each of these SPAs is mapped to a unique primary URL, such that users clicking
    the `/catalog` URL will be redirected to the catalog app, while users clicking
    the `/checkout` URL will go to the checkout app.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些 SPA 都映射到一个唯一的初级 URL，这样用户点击 `/catalog` URL 将会被重定向到目录应用程序，而用户点击 `/checkout`
    URL 将会进入结账应用程序。
- en: Building our Multi-SPA Microfrontend
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的多 SPA 微前端
- en: 'Building a multi-SPA microfrontend essentially consists of three broad areas:
    breaking down the app into logical mini-apps, then we need to set up the routing
    between these mini-apps, and finally, we set up a global state the different mini-apps
    can read and write data to. Let us look at each of them in the subsequent sections.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个多 SPA 微前端基本上包括三个广泛领域：将应用程序分解成逻辑上的小程序，然后我们需要在这些小程序之间设置路由，最后，我们设置一个全局状态，不同的小程序可以从中读取和写入数据。让我们在接下来的章节中逐一查看。
- en: Setting up our mini-apps
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置我们的小程序
- en: We will start with where we left off in the previous chapter.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从上一章结束的地方开始。
- en: In case you skipped the previous chapter and are directly jumping in here, you
    can start by cloning the repo from [https://github.com/PacktPublishing/Building-Micro-Frontends-with-React/tree/main/ch3/my-mfe](https://github.com/PacktPublishing/Building-Micro-Frontends-with-React/tree/main/ch3/my-mfe).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您跳过了上一章并直接跳到这里，您可以从克隆 [https://github.com/PacktPublishing/Building-Micro-Frontends-with-React/tree/main/ch3/my-mfe](https://github.com/PacktPublishing/Building-Micro-Frontends-with-React/tree/main/ch3/my-mfe)
    的存储库开始。
- en: Let us quickly run `pnpm install` (if you haven’t already done so) and serve
    the respective apps to make sure that they are running properly.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速运行 `pnpm install`（如果您还没有这样做的话）并服务相应的应用程序，以确保它们运行正常。
- en: Since we are going to build an e-commerce application, let us call our app *eBuy*.
    Feel free to rename your app folder to `ebuy`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们打算构建一个电子商务应用程序，让我们把我们的应用程序命名为 *eBuy*。请随意重命名您的应用程序文件夹为 `ebuy`。
- en: During active development, we would ideally be working on our own respective
    mini-app and you could easily use the NX Console to serve your respective app.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在积极开发期间，我们理想上是在自己的小程序上工作，您可以使用 NX 控制台轻松地服务您的小程序。
- en: However, periodically you may want to test the entire end-to-end app flow across
    the different mini-apps and for that, it is important that you are able to run
    all the mini-apps locally. This is exactly what we are going to do next.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您可能需要定期测试跨越不同小程序的整个端到端应用程序流程，为此，您能够在本地上运行所有小程序非常重要。这正是我们接下来要做的。
- en: We first need to ensure that each mini-app runs on its own unique port. To do
    this, we need to first locate the `project.json` file located in the `apps/catalog`
    folder. You will notice it basically contains all the commands and configuration
    needed to run the various tasks on your app.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要确保每个小程序运行在其自己的唯一端口上。为此，我们需要首先找到位于 `apps/catalog` 文件夹中的 `project.json`
    文件。您会注意到它基本上包含运行您应用程序上各种任务所需的所有命令和配置。
- en: 'We navigate to the `"serve":` section and under `"options"`, add the line `"``port":
    4200`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '我们导航到 `"serve"` 部分，并在 `"options"` 下添加行 `"``port": 4200`：'
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We do the exact same thing in the `project.json` file located in the `apps/checkout`
    folder, but this time we will ensure this runs on `"port": 4201` like so:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '我们在 `apps/checkout` 文件夹中的 `project.json` 文件中也做同样的事情，但这次我们将确保它在 `"port": 4201`
    上运行，如下所示：'
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will ensure that, by default, the catalog will run on port `4200` while
    the checkout app runs on port `4201`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以确保，默认情况下，目录将在端口 `4200` 上运行，而结账应用将在端口 `4201` 上运行。
- en: Thanks to inheritance, we will be able to run the app in development and production
    mode from the same ports.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了继承，我们可以在相同的端口上以开发和生产模式运行应用。
- en: Next, we will create a script command that will allow us to run all the apps
    in parallel on their respective ports.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个脚本命令，允许我们在各自的端口上并行运行所有应用。
- en: 'For this, we go into the `package.json` file located at the root of the project
    and add a script called `"serve:all": "nx` `run-many --target=serve"`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '为了做到这一点，我们进入项目根目录下的 `package.json` 文件，并添加一个名为 `"serve:all": "nx run-many --target=serve"`
    的脚本：'
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, in your terminal, run the following command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在你的终端中运行以下命令：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You will see `nx` is starting up the webpack development server and is launching
    the two apps.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到 `nx` 正在启动 webpack 开发服务器并启动两个应用。
- en: 'Verify it by visiting these two URLs in the browser:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通过访问这些两个 URL 在浏览器中验证它：
- en: 'Catalog app: **http://localhost:4200**'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目录应用：**http://localhost:4200**
- en: 'Checkout app: **http://localhost:4201**'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结账应用：**http://localhost:4201**
- en: With microfrontends, it is important that each SPA follows the same brand guidelines
    and look and feel. We ensure this by building a shared set of UI components that
    both apps make use of. In the next section, we will see how to create a shared
    component library.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在微前端中，每个 SPA 遵循相同的品牌指南和外观感觉非常重要。我们通过构建一个共享的 UI 组件集来实现这一点，这两个应用都会使用这些组件。在下一节中，我们将看到如何创建共享组件库。
- en: Using a shared component library
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用共享组件库
- en: As you are building a series of mini-apps as part of your overall bigger app,
    we want to ensure that all these mini-apps have a consistent design – things such
    as having a consistent header and footer and a consistent way for the various
    components to behave. What is equally important is, when we make a change to some
    of these core elements, we need to ensure that it can be updated across all the
    different apps without too much trouble. This is where the `libs` folder comes
    into play.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你正在构建一系列作为你整体更大应用一部分的迷你应用，我们希望确保所有这些迷你应用都有一致的设计——例如，拥有一致的头尾和组件行为的一致方式。同样重要的是，当我们对一些核心元素进行更改时，我们需要确保它可以在所有不同的应用中轻松更新。这正是
    `libs` 文件夹发挥作用的地方。
- en: This would also be a good time to define an NPM scope so that all these shared
    components can be imported via their scope names.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一个定义 NPM 范围的好时机，以便所有这些共享组件都可以通过它们的范围名称导入。
- en: To define an NPM scope, we open up the `nx.json` file located at the root of
    the monorepo. We are going to name our scope `ebuy` but in reality, it could be
    anything – the name of your team, the name you have for your component library,
    and so on.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义 NPM 范围，我们打开位于单仓库根目录下的 `nx.json` 文件。我们将命名我们的范围为 `ebuy`，但实际上，它可以是任何名称——你团队的名称，你为组件库取的名称，等等。
- en: 'Locate the `npmScope` property in the `nx.json` file and update it as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `nx.json` 文件中定位 `npmScope` 属性，并按以下方式更新：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Let us use our trustworthy Nx Console to create a library. From Nx Console,
    select `generate` and then select `@nrwl/react – library` `React Library`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用我们可信赖的 Nx 控制台来创建一个库。从 Nx 控制台，选择 `generate`，然后选择 `@nrwl/react – library`
    `React Library`。
- en: 'Select the **Show all options** and provide/modify the following details and
    leave the rest as the default:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 **显示所有选项**，提供/修改以下详细信息，其余的保持默认：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can leave the rest as the default and click the run button to generate the
    `ui` folder within `libs`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其余的保持默认，并点击运行按钮以在 `libs` 中生成 `ui` 文件夹。
- en: 'In addition to creating the `ui` folder within `libs`, you will notice Nx has
    also added an entry into the `paths` object of `tsconfig.base.json` as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在 `libs` 中创建 `ui` 文件夹外，你还会注意到 Nx 还在 `tsconfig.base.json` 的 `paths` 对象中添加了一个条目，如下所示：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It is this setting that will allow us to import our UI components via the scoped
    name instead of a long folder path.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正是这个设置将允许我们通过范围名称而不是长文件夹路径导入我们的 UI 组件。
- en: Next, let’s create a couple of UI components.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一些 UI 组件。
- en: 'We will use the awesome Semantic-UI React component library to build out our
    UI components. You can also use any other component library, such as Chakra UI,
    MUI React-Bootstrap, and so on:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用令人惊叹的 Semantic-UI React 组件库来构建我们的 UI 组件。您也可以使用任何其他组件库，例如 Chakra UI、MUI
    React-Bootstrap 等：
- en: 'Let’s install it on the root of the monorepo using the following command:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用以下命令在单一代码仓库的根目录下安装它：
- en: '[PRE7]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Remember you can always use **npm** or **yarn** to install npm packages as
    follows:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记住您始终可以使用 **npm** 或 **yarn** 安装 npm 包，如下所示：
- en: '[PRE8]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now let’s create a couple of our common components in the `libs/ui` folder.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在让我们在 `libs/ui` 文件夹中创建一些我们的常用组件。
- en: 'Let us use Nx Console and create a new component:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用 Nx 控制台创建一个新的组件：
- en: '**Nx** | **Generate** | **Create a** **react component**'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**Nx** | **生成** | **创建一个** **react 组件**'
- en: 'Use the following information to create the component:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下信息创建组件：
- en: '**Name**: **header**'
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**：**header**'
- en: '**Project**: **ui**'
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目**：**ui**'
- en: '**Flat**: Select the checkbox to ensure we have a flatter folder structure
    within'
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扁平化**：选择复选框以确保我们在内部拥有更扁平的文件夹结构。'
- en: Hit the run button and verify the **header.tsx** file is created within the
    **libs/ui/src/lib** folder.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击运行按钮并验证 **header.tsx** 文件是否在 **libs/ui/src/lib** 文件夹中创建。
- en: 'Open the **header.tsx** file and replace the contents of it with simple markup
    for our header component:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **header.tsx** 文件，并用我们头部组件的简单标记替换其内容：
- en: '[PRE9]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is simple React component code that will display the header with navigation
    for the catalog and checkout.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一段简单的 React 组件代码，它将显示目录和检查的导航头部。
- en: 'The next step is to export it out it from the **ui**. Locate the **/libs/ui/src/index.ts**
    file and add an entry as follows:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是将它从 **ui** 中导出。定位到 **/libs/ui/src/index.ts** 文件，并添加以下条目：
- en: '[PRE10]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will allow our header component to be importable via our shorter import
    path. Now let us import it into our catalog and checkout apps.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将允许我们的头部组件可以通过较短的导入路径进行导入。现在让我们将其导入到我们的目录和检查应用中。
- en: 'Open the **apps/catalog/src/spp/app.tsx** file and import the header component
    as follows:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **apps/catalog/src/spp/app.tsx** 文件，并按如下方式导入头部组件：
- en: '[PRE11]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let us clean up some of the boilerplate code. Remove the imports for **styles**
    and **NxWelcome** and add the **Header** component in the JSX. You can also delete
    the **nx-welcome.tsx** file in the **catalog** folder. Your final code should
    look like this:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们清理一些样板代码。移除对 **styles** 和 **NxWelcome** 的导入，并在 JSX 中添加 **Header** 组件。您还可以删除
    **catalog** 文件夹中的 **nx-welcome.tsx** 文件。您的最终代码应如下所示：
- en: '[PRE12]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code, we import the semantic-ui’s css file and include our
    `Header` component and text that displays the name of the app.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们导入了 semantic-ui 的 CSS 文件，并包含了显示应用名称的 `Header` 组件和文本。
- en: 'When running in the browser, the catalog app will look something like this:'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在浏览器中运行时，目录应用看起来可能如下所示：
- en: '![Figure 4.2 – Catalog app with the common header menu bar](img/Figure_4.02_B18987.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – 带有通用头部菜单栏的目录应用](img/Figure_4.02_B18987.jpg)'
- en: Figure 4.2 – Catalog app with the common header menu bar
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 带有通用头部菜单栏的目录应用
- en: We will make the same changes to the **apps/checkout/src/app/app.tsx** file
    within the checkout app.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在检查应用中的 **apps/checkout/src/app/app.tsx** 文件内进行相同的更改。
- en: Let us test out our code. Run **pnpm serve:all** and refresh your browser on
    **http://localhost:4200** to see our latest changes.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们测试一下我们的代码。运行 **pnpm serve:all** 并在 **http://localhost:4200** 上刷新浏览器以查看我们的最新更改。
- en: Try clicking on the navigation links for the catalog or checkout and notice
    it doesn’t do anything. That is because we haven’t set up routing between our
    apps, which is exactly what we will be doing next.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试点击目录或检查的导航链接，注意它没有任何反应。这是因为我们还没有在我们的应用之间设置路由，这正是我们接下来将要做的。
- en: Setting up Routing
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置路由
- en: 'As we discussed earlier, from time to time, we would like to test our end-to-end
    app functionality, and although we are able to run apps in parallel on different
    ports, there are some challenges with testing end-to-end functionality:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，我们时不时地想要测试我们的端到端应用功能，尽管我们能够在不同的端口上并行运行应用，但在测试端到端功能方面存在一些挑战：
- en: We need to ensure a consistent navigation structure for our apps both on localhost
    and on production.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要确保我们的应用在本地和在生产环境中都拥有一致的导航结构。
- en: Apps running on different ports are treated as apps on different domains and
    hence it will not be possible to share cookies, session states, and so on
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同端口上运行的应用被视为不同域上的应用，因此无法共享 cookies、会话状态等。
- en: 'To overcome these problems, we need to make the browser think the apps are
    running on the same port. We do this by setting up a reverse proxy. The way we
    will set up routing is each mini-app will have its own namespaced primary route,
    for example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这些问题，我们需要让浏览器认为应用正在同一端口上运行。我们通过设置反向代理来实现这一点。我们将设置路由的方式是每个迷你应用都将有自己的命名空间主路由，例如：
- en: '**eBuy.com**: Home page app'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**eBuy.com**: 首页应用'
- en: '**eBuy.com/catalog**: Catalog app'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**eBuy.com/catalog**: 目录应用'
- en: '**eBuy.com/checkout**: Checkout app'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**eBuy.com/checkout**: 结账应用'
- en: The secondary routes are generally set up within the mini-apps themselves. For
    example, the product details page for, say, apples would be `eBuy.com/catalog/apples`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 二级路由通常在迷你应用内部设置。例如，苹果的产品详情页面将是 `eBuy.com/catalog/apples`。
- en: Webpack development servers and Nx come with easy-to-use proxy support that
    we can take advantage of.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack 开发服务器和 Nx 提供了易于使用的代理支持，我们可以利用这些支持。
- en: 'At the root of the catalog app, `/apps/catalog`, let us create a new file called
    `proxy.conf.json` with the following entries:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在目录应用的根目录 `/apps/catalog` 中，让我们创建一个名为 `proxy.conf.json` 的新文件，并包含以下条目：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Next, we need to tell the catalog app to use this file for its proxy configuration.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要告诉目录应用使用此文件进行其代理配置。
- en: 'We do this by adding the `proxyConfig` property to the development configuration
    under the serve object in the `apps/catalog/project.json` file as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在 `apps/catalog/project.json` 文件中的 serve 对象下开发配置中添加 `proxyConfig` 属性来完成此操作，如下所示：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let us quickly test it out. We will need to restart our development servers
    to pick up the latest proxy configurations.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速测试一下。我们需要重新启动我们的开发服务器以获取最新的代理配置。
- en: 'Run the `serve:all` command and try clicking on the **Checkout** and **Catalog**
    navigation links… Erm… It didn’t work and the same catalog app shows up when you
    click on the **Checkout** link... But wait – the title tag on the browser tab
    does show **Checkout**:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `serve:all` 命令并尝试点击 **结账** 和 **目录** 导航链接… 哎呀… 它没有工作，当你点击 **结账** 链接时，显示的是相同的目录应用…
    但是等等 – 浏览器标签页上的标题标签确实显示 **结账**：
- en: '![Figure 4.3 – Checkout app in the title but loading the catalog bundle](img/Figure_4.03_B18987.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3 – 标题中为结账应用但正在加载目录包](img/Figure_4.03_B18987.jpg)'
- en: Figure 4.3 – Checkout app in the title but loading the catalog bundle
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 标题中为结账应用但正在加载目录包
- en: So, what’s happening here? If you look at the development tools, the problem
    becomes quite obvious. What’s happening here is the proxy has correctly redirected
    us to the checkout app and that’s why we see the correct `index.html` file served
    via the checkout app, however, the script’s `src` tags loading the `js` bundles
    point to the root and hence they are actually loading the `js` bundles from the
    catalog app.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这里发生了什么？如果你查看开发工具，问题就变得非常明显。这里发生的情况是代理已正确地将我们重定向到结账应用，这就是为什么我们看到通过结账应用提供的正确
    `index.html` 文件，然而，脚本中的 `src` 标签加载的 `js` 包指向根目录，因此它们实际上是从目录应用加载的 `js` 包。
- en: Fixing this problem is relatively easy again thanks to Nx.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Nx 的帮助，解决这个问题相对容易。
- en: 'We simply need to define the `baseRef` for the checkout app. We do this by
    adding `"baseHref": "/checkout/"` to the `/``apps/checkout/project.json` file.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '我们只需要为结账应用定义 `baseRef`。我们通过在 `/apps/checkout/project.json` 文件中添加 `"baseHref":
    "/checkout/"` 来完成此操作。'
- en: 'This is what your development object under the parent serve object should look
    like:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你的父 serve 对象下的开发对象应该看起来像这样：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Restart the development servers and now you will be able to navigate between
    the two applications and have the right JS bundles load in. In the next section,
    we will work toward adding a product list response to simulate the mocked response
    from a product list API call.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动开发服务器，现在你将能够在两个应用之间导航，并正确加载 JS 包。在下一节中，我们将努力添加产品列表响应以模拟产品列表 API 调用的模拟响应。
- en: Setting up a mocked product list
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置模拟产品列表
- en: A common practice with all web development activities is to set up a mock server
    or a mocked set of API responses that the frontend apps can consume until the
    actual APIs are ready. Since our e-commerce app requires a list of products that
    will be required across all the other mini-apps, we create a shared library to
    hold our mocks.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有网络开发活动中，一个常见的做法是设置一个模拟服务器或一组模拟的 API 响应，直到实际的 API 准备好。由于我们的电子商务应用需要在所有其他迷你应用中使用的商品列表，我们创建了一个共享库来保存我们的模拟。
- en: So again, using our favorite, Nx Console, let us create another React library,
    let us call it `mocks`, and we will use the scope name `@ebuy/mocks`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，再次使用我们最喜欢的 Nx Console，让我们创建另一个 React 库，让我们称它为 `mocks`，我们将使用作用域名称 `@ebuy/mocks`。
- en: 'Within the `mocks` library at `libs/mocks/src/lib`, let us create our file
    called `product-list-mocks.tsx` with the following code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `mocks` 库的 `libs/mocks/src/lib` 中，让我们创建一个名为 `product-list-mocks.tsx` 的文件，并包含以下代码：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let us not forget to export it out from the `/libs/mocks/src/index.ts` file
    with the following line of code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们不要忘记从 `/libs/mocks/src/index.ts` 文件中导出它，以下是一行代码：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Also, don’t forget to place the product images in the `catalog` app’s `src/assets`
    folder. You can find the images here [https://github.com/PacktPublishing/Building-Micro-Frontends-with-React-18/tree/main/ch4/ebuy/apps/catalog/src/assets](https://github.com/PacktPublishing/Building-Micro-Frontends-with-React-18/tree/main/ch4/ebuy/apps/catalog/src/assets).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，别忘了将产品图片放在 `catalog` 应用程序的 `src/assets` 文件夹中。你可以在这里找到图片 [https://github.com/PacktPublishing/Building-Micro-Frontends-with-React-18/tree/main/ch4/ebuy/apps/catalog/src/assets](https://github.com/PacktPublishing/Building-Micro-Frontends-with-React-18/tree/main/ch4/ebuy/apps/catalog/src/assets)。
- en: We will now look to use this across our apps, wherever we need data from the
    product list.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将尝试在应用程序中使用它，无论何时我们需要从产品列表中获取数据。
- en: Adding the product grid and checkout components
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加产品网格和结账组件
- en: Now we have a decent-looking header and an app where we can navigate from one
    mini-app to the other. However, the rest of the app doesn’t do much, so let’s
    add a product list component to the catalog app and a shopping basket component
    to the checkout app.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个看起来不错的标题和一个应用程序，我们可以从一个迷你应用程序导航到另一个。然而，应用程序的其余部分并没有做什么，所以让我们向目录应用程序添加一个产品列表组件，并向结账应用程序添加一个购物篮组件。
- en: 'We will start by creating the `ProductList` component within our `/apps/catalog/src/app`
    folder. We will name the file `product-list.tsx`. We will start by creating an
    empty shell component:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先在 `/apps/catalog/src/app` 文件夹中创建 `ProductList` 组件。我们将文件命名为 `product-list.tsx`。我们将首先创建一个空壳组件：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We will get an error for the missing `ProductCard` component. Don’t worry –
    we will create that component in the next step. Next, we need to create our `ProductCard`
    component. We will name the file `product-card.tsx`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将因为缺少 `ProductCard` 组件而得到一个错误。别担心 – 我们将在下一步创建该组件。接下来，我们需要创建我们的 `ProductCard`
    组件。我们将文件命名为 `product-card.tsx`。
- en: 'We start by defining the skeleton of our `ProductCard` component:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义我们的 `ProductCard` 组件的框架：
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Next, let us import the `ProductList app.tsx` file of the catalog app located
    at `/apps/catalog/src/app/app.tsx`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们导入位于 `/apps/catalog/src/app/app.tsx` 的目录应用程序的 `ProductList app.tsx` 文件。
- en: 'Your `app.tsx` code should now look like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 `app.tsx` 代码现在应该看起来像这样：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If your catalog app looks like the following screenshot, that means you are
    on the right path:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的目录应用程序看起来像下面的截图，那么这意味着你正在正确的道路上：
- en: '![Figure 4.4 – Catalog app with a header and product list component](img/Figure_4.04_B18987.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4 – 带有标题和产品列表组件的目录应用程序](img/Figure_4.04_B18987.jpg)'
- en: Figure 4.4 – Catalog app with a header and product list component
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – 带有标题和产品列表组件的目录应用程序
- en: 'Next, we are going to create our shopping basket component. So, in our `app.tsx`
    checkout file located in the `/apps/checkout/src/app` folder, let us create a
    basic skeleton with the following code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建我们的购物篮组件。因此，在我们的 `/apps/checkout/src/app` 文件夹中的 `app.tsx` 结账文件中，让我们创建以下代码的基本框架：
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This code should start looking familiar now. As you can see, we have a `ShoppingBasket`
    component and, for the time being, we are passing `PRODUCT_LIST_MOCKS` to it for
    the purpose of mocking.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码现在应该看起来很熟悉了。正如你所见，我们有一个 `ShoppingBasket` 组件，并且目前我们正在将其传递给 `PRODUCT_LIST_MOCKS`
    以进行模拟。
- en: Next up is to create that `ShoppingBasket` component, which is throwing an error
    at the moment.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们要创建那个正在抛出错误的 `ShoppingBasket` 组件。
- en: 'So let us create a `basket.tsx` file in the `/apps/checkout/src/` app folder:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们在 `/apps/checkout/src/` 应用程序文件夹中创建一个名为 `basket.tsx` 的文件：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is all self-explanatory dummy markup content that at the moment doesn’t
    do much. In the following sections, we are going to make this all work together.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都是自解释的占位符标记内容，目前并没有做什么。在接下来的章节中，我们将使所有这些内容协同工作。
- en: 'Your running checkout app should now look like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在运行的结账应用程序现在应该看起来像这样：
- en: '![Figure 4.5 – Mocked up checkout app](img/Figure_4.05_B18987.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.5 – 模拟的结账应用程序](img/Figure_4.05_B18987.jpg)'
- en: Figure 4.5 – Mocked up checkout app
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.5 – 模拟的结账应用程序](img/Figure_4.05_B18987.jpg)'
- en: With this, we have our two apps working well and displaying the right data,
    however, they are not “talking” to each other yet. The checkout app has no idea
    what items the user has added to the cart in the catalog app. In the next section,
    we will set up a global shared state that both the mini-apps can talk to and read
    from.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的两个应用就能良好地工作并显示正确的数据，然而，它们还没有“交谈”。结账应用不知道用户在目录应用中添加了哪些商品。在下一节中，我们将设置一个全局共享状态，这两个迷你应用都可以与之交谈并读取。
- en: 'Before we proceed to the next section, let us quickly go through a checklist
    of things we’ve done so far:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入下一节之前，让我们快速回顾一下到目前为止我们已经完成的事项清单：
- en: Ensured we have the catalog and checkout apps running on different ports
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保目录应用和结账应用在不同的端口上运行
- en: Ensured we have the URL routing setup in the **proxy.conf.json** file
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保我们在`proxy.conf.json`文件中设置了URL路由
- en: We have both apps reading data from the mocked product list
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们两个应用都在从模拟的产品列表中读取数据
- en: Setting up a Global Shared State
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置全局共享状态
- en: Now that we are able to navigate between our two mini-apps, the next thing to
    tackle is setting up a shared state between these two different apps. Because
    these are two independent apps, the usual state management solutions such as the
    Context API, Redux, MobX, and so on will not work. This is because these libraries
    store the state as an object within the app and when you refresh the page or navigate
    to another app, this state is lost state. Hence, to overcome this problem, we
    resort to using some of the browser’s native features, such as local storage,
    session storage, or Index-db.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够在两个迷你应用之间导航，接下来要解决的是在这两个不同的应用之间设置共享状态。因为这些是两个独立的应用，通常的状态管理解决方案，如Context
    API、Redux、MobX等，将不起作用。这是因为这些库将状态作为应用内的一个对象存储，当你刷新页面或导航到另一个应用时，这个状态就会丢失。因此，为了克服这个问题，我们求助于使用浏览器的一些原生功能，如本地存储、会话存储或Index-db。
- en: For this example, we will be using session storage. We will set up a simple
    custom hook to persist state in `sessionStorage` and have both our mini-apps read
    and write to this state.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将使用会话存储。我们将设置一个简单的自定义钩子来在`sessionStorage`中持久化状态，并让我们的迷你应用都能读取和写入这个状态。
- en: In any large-scale app, there will be a lot of similar custom hooks that teams
    can reuse. This is also a good opportunity for us to set up another library for
    these custom hooks.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何大型应用中，都会有大量的类似自定义钩子，团队可以重用。这也是我们为这些自定义钩子设置另一个库的好机会。
- en: It is important to remember that this global state should be used sparingly
    only when we need to share information between the different mini-apps. To manage
    the states within each micro app, we should use a regular state management tool
    such as the Context API or Redux, and so on.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，这个全局状态应该仅在我们需要在不同的迷你应用之间共享信息时才少量使用。为了管理每个微应用内的状态，我们应该使用常规的状态管理工具，例如Context
    API或Redux等。
- en: 'Let us use Nx Console to create another library called `custom-hooks`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Nx控制台创建另一个名为`custom-hooks`的库：
- en: '[PRE23]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, we’ll fill use the following information in the form:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将在表单中填写以下信息：
- en: '**Name**: **custom-hooks**'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**：**custom-hooks**'
- en: '**Component**: **off** (Generate a default component)'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件**：**off**（生成默认组件）'
- en: '**importPath**: **@ebuy/custom-hooks**'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导入路径**：**@ebuy/custom-hooks**'
- en: 'Verify that the `custom-hooks` folder is created under `libs` and also make
    sure it has been added to the `tsconfig.base.json` file at the root of the monorepo,
    which should now look something like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 验证`custom-hooks`文件夹是否在`libs`下创建，并确保它已经被添加到monorepo根目录下的`tsconfig.base.json`文件中，现在它看起来应该像这样：
- en: '[PRE24]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let us now create our custom hook. Use the `generate` command to create a React
    component with the following information:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在创建我们的自定义钩子。使用`generate`命令创建一个具有以下信息的React组件：
- en: '**Name of the** **component**: **useSessionStorage**'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件名称**：**useSessionStorage**'
- en: '**Project**: **custom-hooks**'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目**：**custom-hooks**'
- en: '**fileName**: **use-session-storage**'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件名**：**use-session-storage**'
- en: '**flat**: **Selected** (generate flat file structure)'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**flat**：**Selected**（生成扁平文件结构）'
- en: 'In the newly created `use-session-storage.tsx` component file, let’s replace
    the boilerplate code with the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在新创建的`use-session-storage.tsx`组件文件中，让我们用以下代码替换样板代码：
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This custom hook code is part of the `usehooks-ts` library and is available
    here: [https://usehooks-ts.com/react-hook/use-session-storage](https://usehooks-ts.com/react-hook/use-session-storage)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个自定义钩子代码是`usehooks-ts`库的一部分，并在此处提供：[https://usehooks-ts.com/react-hook/use-session-storage](https://usehooks-ts.com/react-hook/use-session-storage)
- en: 'Since this custom hook makes use of the `usehook-ts` library, we will install
    that npm module:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个自定义钩子使用了 `usehook-ts` 库，我们将安装该 npm 模块：
- en: '[PRE26]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, we need to export it so that it can be imported via the scoped path.
    We do this in the `/libs/custom-hooks/src/index.ts` file by adding the following
    line:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将其导出，以便可以通过作用域路径导入。我们在 `/libs/custom-hooks/src/index.ts` 文件中添加以下行来执行此操作：
- en: '[PRE27]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Next, we will use our newly created custom-hook in the `product-card` component
    such that every time the user adds products to or removes products from the shopping
    cart, it will store it as an array in `sessionStorage`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在 `product-card` 组件中使用我们新创建的自定义钩子，这样每次用户向购物车添加或从购物车中删除产品时，它都会将其作为数组存储在
    `sessionStorage` 中。
- en: 'In the `/apps/catalog/src/app/productcard.tsx` file, we will start by importing
    the `useSessionStorage` hook:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `/apps/catalog/src/app/productcard.tsx` 文件中，我们将首先导入 `useSessionStorage` 钩子：
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, within the product card component, we make use of the `useSessionStorage`
    hook and add the functions to add and remove items from the basket with the following
    code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在产品卡片组件中，我们使用 `useSessionStorage` 钩子并添加以下代码来添加和从购物车中删除项目的函数：
- en: '[PRE29]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we update the **Add** and **Remove** button on-click events as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们更新 **添加** 和 **删除** 按钮的点击事件，如下所示：
- en: '[PRE30]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let’s test this out by running the following command:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过运行以下命令来测试它：
- en: '[PRE31]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Click on the **Add** and **Remove** buttons for some of the products and see
    the product counts work.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **添加** 和 **删除** 按钮来查看一些产品的产品计数。
- en: 'Let’s open up the development tools and have a look at the `sessionStorage`
    under the **Application** tab:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开开发工具并查看 **应用程序** 选项卡下的 `sessionStorage`。
- en: '![Figure 4.6 – Shopping basket stored in Session Storage](img/Figure_4.06_B18987.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.6 – 存储在会话存储中的购物车](img/Figure_4.06_B18987.jpg)'
- en: Figure 4.6 – Shopping basket stored in Session Storage
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 – 存储在会话存储中的购物车
- en: Once the state is present in **Session Storage**, we will need to read it from
    multiple places across different components. It is best to create it as a utility
    function that can be reused as needed.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦状态存在于 **会话存储** 中，我们将在不同组件的多个地方读取它。最好创建一个可按需重用的实用函数。
- en: We will create another library using Nx Console, but this time instead of creating
    a React library, we will use the `@nrwl/workspace – library` template to generate
    our generic `utils` library and use the import scope called `@ebuy/utils`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Nx Console 创建另一个库，但这次不是创建一个 React 库，而是使用 `@nrwl/workspace – library` 模板来生成我们的通用
    `utils` 库，并使用名为 `@ebuy/utils` 的导入作用域。
- en: 'The information we fill in during the `Nx Console > generate` step is as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Nx Console > generate` 步骤中我们填写的信息如下：
- en: '**@****nwrl/workspace**: **library**'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**@****nwrl/workspace**: **library**'
- en: '**Name**: **utils**'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**：**utils**'
- en: '**importScope**: **@ebuy/utils**'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**importScope**: **@ebuy/utils**'
- en: Running this command will generate the `utils` folder and also create the `utils.ts`
    file. Let us rename it to `get-session-storage.ts`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令将生成 `utils` 文件夹并创建 `utils.ts` 文件。让我们将其重命名为 `get-session-storage.ts`。
- en: 'Add the following code to read the values of a given key:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下代码以读取给定键的值：
- en: '[PRE32]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, this is a very simple function that accepts a key and returns
    the values from session storage for the given key.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这是一个非常简单的函数，它接受一个键并返回给定键的会话存储中的值。
- en: Next, we will get the mini basket in the header hooked up to show the total
    items in the shopping basket. In the `header.tsx` file, let us add the necessary
    code to read and total up the items in the shopping basket.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将获取页眉中的迷你购物车并将其连接起来以显示购物车中的总项目数。在 `header.tsx` 文件中，让我们添加必要的代码来读取和总计购物车中的项目。
- en: 'Let us import the necessary functions:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们导入必要的函数：
- en: '[PRE33]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We will create our function to calculate the total count like so:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个函数来计算总计数，如下所示：
- en: '[PRE34]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, within the `Header` component, we will use a combination of `useEffects`
    and `eventListeners` to ensure that the mini basket updates every time items are
    added to or removed from the cart:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `Header` 组件中，我们将使用 `useEffects` 和 `eventListeners` 的组合来确保每次向购物车添加或从购物车中删除项目时，迷你购物车都会更新。
- en: '[PRE35]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, we will update the shopping cart icon to display `{miniBasketCount}`
    like so:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将更新购物车图标以显示 `{miniBasketCount}`，如下所示：
- en: '[PRE36]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Run the apps and try adding and removing items using the **Add** and **Remove**
    buttons, and see how the counts update.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用并尝试使用 **添加** 和 **删除** 按钮添加和删除项目，并查看计数如何更新。
- en: The last part of this chapter is where we will complete the shopping cart component
    in the checkout app.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后部分，我们将完成结账应用中的购物车组件。
- en: What we need to do is fetch the data for the `shoppingBasket` key in `sessionStorage`
    and display the products and the quantity added to the cart.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的是从`sessionStorage`中获取`shoppingBasket`键的数据，并显示添加到购物车中的产品和数量。
- en: 'We open the `app.tsx` checkout file located in the `apps/checkout/src/app/app.tsx`
    file and follow these steps to get the data from `sessionStorage`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打开位于`apps/checkout/src/app/app.tsx`的`app.tsx`结账文件，按照以下步骤从`sessionStorage`获取数据：
- en: 'First we import `getSessionStorage` like so:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们像这样导入`getSessionStorage`：
- en: '[PRE37]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then within the `App` function we add the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`App`函数中，我们添加以下内容：
- en: '[PRE38]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: When we run the app and have a look at the console, we will be able to see the
    array of items from `shoppingBasket`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行应用并查看控制台时，我们将能够看到`shoppingBasket`中的商品数组。
- en: Since `shoppingBasket` only stored the product IDs and their quantity we will
    need to map the product IDs to the product names so that we can display names
    in the shopping basket.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`shoppingBasket`只存储产品ID及其数量，我们需要将产品ID映射到产品名称，以便在购物车中显示名称。
- en: 'Let us create another function to do that. We will call it `createCompleteBasket`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建另一个函数来完成这个任务。我们将称之为`createCompleteBasket`：
- en: '[PRE39]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'And then, finally, within our app’s component''s function, we create `completeBasket`
    by filtering and mapping the values from the product list to `shoppingbasket`
    like so:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们的应用组件函数中，我们通过过滤和映射产品列表中的值到`shoppingbasket`来创建`completeBasket`，如下所示：
- en: '[PRE40]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now we update the `ShoppingBasket` component to pass in this new prop like
    so:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将更新`ShoppingBasket`组件，传入这个新的属性，如下所示：
- en: '[PRE41]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Test your app in the browser and give it a play. Add and remove items to and
    from the basket in the catalog app and then navigate to the checkout app to see
    the shopping basket all synced up and displaying the correct list of items.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中测试您的应用，并尝试操作。在目录应用中添加和移除商品，然后导航到结账应用，查看所有同步并显示正确商品列表的购物车。
- en: A note on the coding samples
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 关于代码示例的说明
- en: As you must have seen, in numerous places we have used the ‘**any'** type definition
    and have skipped a few details (including unit tests). This is intentional to
    avoid overcomplicating the examples so that we stay focused on the core aspects
    of this chapter, such as routing between apps and sharing state. When building
    an app for production, we would encourage you to define the correct types and
    interfaces to take advantage of the full power of TypeScript and write relevant
    tests.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们在多个地方使用了“**any**”类型定义，并跳过了一些细节（包括单元测试）。这是故意的，为了避免过度复杂化示例，以便我们专注于本章的核心方面，例如应用之间的路由和状态共享。当构建用于生产的应用时，我们鼓励您定义正确的类型和接口，以充分利用TypeScript的全部功能，并编写相关的测试。
- en: With this, we come to the end of this rather intense section... Take a break.
    Well done!
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们就来到了这个相当紧张的部分的结尾...休息一下。做得好！
- en: We covered a lot here. We picked up from where we had left off in the previous
    chapter and added a shared header component to our apps. We then set up routing
    via a proxy so that we could navigate between the two different apps, but as if
    they were part of the same domain and port. We also saw how to share state between
    the two mini-apps using session storage. We then created a common custom hook
    to store and retrieve data from session storage, and while doing so we built up
    the bare bones of an e-commerce app, adding items to the cart and updating the
    cart information on the checkout app and the mini cart on the header.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做了很多工作。我们从上一章结束的地方继续，为我们的应用添加了一个共享的头部组件。然后，我们通过代理设置路由，以便在两个不同的应用之间导航，但就像它们是同一域名和端口的组成部分一样。我们还看到了如何使用会话存储在两个小程序之间共享状态。然后，我们创建了一个公共的自定义钩子来存储和检索会话存储中的数据，在这个过程中，我们构建了一个电子商务应用的骨架，包括向购物车添加商品和在结账应用以及头部的小购物车中更新购物车信息。
- en: Summary
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: This was a long chapter, so well done for staying with us until the end. We
    started off by looking at what the multi-SPA pattern looks like. We saw how this
    pattern would be most suitable for very large applications such as a banking portal,
    a government portal, or an e-commerce site. We saw the architecture pattern where
    all these different mini-apps can take advantage of a shared common library of
    components and utilities to ensure the consistency of the different apps.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一章很长的内容，所以恭喜你坚持看到最后。我们一开始是查看多-SPA 模式的外观。我们看到了这种模式对于非常大的应用程序，如银行门户、政府门户或电子商务网站来说最为合适。我们还看到了这种架构模式，其中所有这些不同的微应用程序都可以利用共享的通用组件和实用程序库，以确保不同应用程序的一致性。
- en: We then took a deep dive into code and went about setting up our two mini-apps
    within the Nx monorepo, after which we went about creating our shared UI header
    component and used Semantic UI to build out our catalog and checkout apps. This
    was also a good opportunity for us to see how to use scoped names, which makes
    our import paths look clean and simple.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后深入研究了代码，并在 Nx 单一代码库中设置了我们的两个小型应用程序，之后我们着手创建共享的 UI 标题组件，并使用 Semantic UI 构建了我们的目录和结账应用程序。这也是我们了解如何使用作用域名称的好机会，这使得我们的导入路径看起来整洁简单。
- en: Then we went about setting up the routing so that we could navigate between
    the two different apps, and finally, we set up a custom hook to store our app
    state in session storage and saw how to have it synced between the two mini-apps.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们着手设置路由，以便在两个不同的应用程序之间进行导航，最后，我们设置了一个自定义钩子来在会话存储中存储我们的应用程序状态，并了解了如何使其在两个小型应用程序之间同步。
- en: In the next chapter, we will look at the micro-apps pattern where we will have
    multiple micro-apps loaded within the same page.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨微应用程序模式，其中我们将在同一页面上加载多个微应用程序。
