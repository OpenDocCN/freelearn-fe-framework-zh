- en: Chapter 8. React Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。React设计模式
- en: In the last chapter, we looked at React on the server. We created a simple HTTP
    server followed by multiple endpoints and web sockets.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了服务器上的React。我们创建了一个简单的HTTP服务器，随后是多个端点和WebSocket。
- en: In this chapter, we will take a step back and consider the component architecture
    we have built so far. We'll look at a couple of popular React design patterns
    and how we can make subtle improvements to our architecture.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回顾一下迄今为止构建的组件架构。我们将探讨几个流行的React设计模式以及我们如何对我们的架构进行细微的改进。
- en: Where we are
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们目前的位置
- en: Let's take a look at the things we have created so far and how they interact
    with each other. If you've been following closely, this may all be familiar to
    you; but stick with it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看迄今为止我们创建的内容以及它们是如何相互作用的。如果你一直密切关注，这些可能对你来说都很熟悉；但请继续关注。
- en: 'We will talk about how these interactions are failing us and how we can improve
    them. From the moment our interface begins to render, we start to see the following
    things happen:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论这些交互是如何失败的，以及我们如何改进它们。从我们的界面开始渲染的那一刻起，我们就开始看到以下事情发生：
- en: We begin by creating a backend object. We use this as a store for the pages
    in our application. This has methods such as `add`, `edit`, `delete`, and `all`.
    It also acts as an event emitter, notifying listeners whenever pages change.
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建一个后端对象。我们使用它作为我们应用程序中页面的存储。它具有`add`、`edit`、`delete`和`all`等方法。它还充当事件发射器，在页面更改时通知监听器。
- en: We create a `PageAdmin` React component and pass the `Backend` object to it.
    The `PageAdmin` component uses the `Backend` object as a data source for other
    page components, all of which are created within the `PageAdmin` render method.
    The `PageAdmin` component listens for changes in `Backend` as soon as it is mounted.
    It stops listening after it is unmounted.
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个`PageAdmin` React组件，并将`Backend`对象传递给它。`PageAdmin`组件使用`Backend`对象作为其他页面组件的数据源，所有这些组件都是在`PageAdmin`渲染方法中创建的。`PageAdmin`组件在挂载后立即监听`Backend`的变化。在卸载后停止监听。
- en: The `PageAdmin` component has a few callbacks, which it passes down to the other
    page components it creates. These provide a way for child components to trigger
    changes in the `Backend` object.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PageAdmin`组件有几个回调，它将这些回调传递给它创建的其他页面组件。这些提供了子组件触发`Backend`对象变化的方式。'
- en: Through user interaction, components such as `PageEditor` and `PageView` trigger
    the callback functions they receive from `PageAdmin`. These then trigger changes
    in the `Backend` object.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过用户交互，`PageEditor`和`PageView`等组件触发它们从`PageAdmin`接收的回调函数。然后这些函数触发`Backend`对象的变化。
- en: Data changes in `Backend`. At the same time, `Backend` notifies event listeners
    that the data has changed and `PageAdmin` is one of those listeners.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Backend`中的数据发生变化。同时，`Backend`通知事件监听器数据已更改，而`PageAdmin`就是其中之一。'
- en: The `PageAdmin` component updates its internal state to the newest version of
    the `Backend` pages, which causes other page components to re-render.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PageAdmin`组件将其内部状态更新为`Backend`页面的最新版本，这导致其他页面组件重新渲染。'
- en: 'We can imagine this as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样想象：
- en: '![Where we are](img/5268_08_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![我们目前的位置](img/5268_08_01.jpg)'
- en: We can even reduce our existing code to the essential parts of this architecture.
    Let's re-implement listing and adding pages without styles or the build chain.
    We can use this as a starting point for the architectural improvements later in
    this chapter. This will also be a good place to recap some of the new ES6 features
    we've seen so far and learn about a few new ones.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以将现有的代码缩减到这个架构的必要部分。让我们在不使用样式或构建链的情况下重新实现列出和添加页面。我们可以将此作为本章后面进行架构改进的起点。这也会是一个回顾我们迄今为止看到的一些新ES6特性以及了解一些新特性的好地方。
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'I don''t want to repeat the whole build chain here, but we do need some help
    to use ES6 and JSX in our code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我不想在这里重复整个构建链，但我们确实需要一些帮助来在我们的代码中使用ES6和JSX：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We enable ES6/JSX transformers in `.babelrc`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`.babelrc`中启用ES6/JSX转换器：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can run this code with the following command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令运行此代码：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will transform the ES6/JSX code in `index.js` and all the files it imports.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这将转换`index.js`中的ES6/JSX代码以及它导入的所有文件。
- en: 'We began with the `src/backend.js` file:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`src/backend.js`文件开始：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`Backend` is a class with internal `id` and `pages` properties. The `id` property
    acts as an auto-increment identity value for each new page object. It has the
    `add` and `getAll` methods, which add new pages and return all pages, respectively.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`Backend` 是一个具有内部 `id` 和 `pages` 属性的类。`id` 属性作为每个新页面对象的自动递增身份值。它有 `add` 和 `getAll`
    方法，分别用于添加新页面和返回所有页面。'
- en: In ES6, we can define constants (variables which cannot be changed after they
    are defined and assigned). These are great for when we only need to define a variable
    once, as they guard against unintended changes.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES6 中，我们可以定义常量（在定义和分配后不能更改的变量）。当我们需要只定义一次变量时，它们非常有用，因为它们可以防止意外的更改。
- en: We assign the next identity value and increment the internal `id` property so
    that the next identity value will be different. ES6 template strings allow us
    to interpolate variables (like we do with the identity value) and define multiline
    strings.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们分配下一个身份值并增加内部 `id` 属性，以便下一个身份值将不同。ES6 模板字符串允许我们插入变量（就像我们对身份值所做的那样）并定义多行字符串。
- en: 'We can define objects with keys matching defined local variable names using
    the new ES6 object literal syntax. In other words, `{ title }` means the same
    as `{ title: title }`.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以使用新的 ES6 对象字面量语法定义具有与定义的局部变量名称匹配的键的对象。换句话说，`{ title }` 与 `{ title: title
    }` 的意思相同。'
- en: 'Each time a new page is added, `Backend` emits its `onAdd` event to any listeners.
    We can see all of this in action with the following code (in `index.js`):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 每次添加新页面时，`Backend` 都会向任何监听器发出 `onAdd` 事件。我们可以通过以下代码（在 `index.js` 中）看到所有这些操作：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In ES6, the `let` keyword works similarly to `var`. The difference is that
    `var` is scoped to the enclosing function, where `let` is scoped to the enclosing
    block:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES6 中，`let` 关键字与 `var` 的工作方式类似。区别在于 `var` 的作用域是包含函数，而 `let` 的作用域是包含块：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you run this `Backend` code, you should see the following output:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个 `Backend` 代码，你应该看到以下输出：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can combine this with the `PageAdmin` component (in `src/page-admin.js`):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将此与 `PageAdmin` 组件（在 `src/page-admin.js` 中）结合使用：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is a stateless function version of our previous `PageAdmin` component.
    We can use it with the following code (in `index.js`):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是之前 `PageAdmin` 组件的无状态函数版本。我们可以使用以下代码（在 `index.js` 中）：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This will generate the following output:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下输出：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, if we were rendering this into an HTML page, we would click on the **add
    page** link and a new page would be added to the list of existing pages inside
    `Backend`. We also created `PageAdmin` as a class so that we could add an event
    listener in the `componentWillMount` life cycle method. This listener would then
    update the child `Page` components with an updated array of pages.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们将其渲染到 HTML 页面中，我们会点击 **添加页面** 链接，并在 `Backend` 内部的现有页面列表中添加一个新页面。我们还创建了一个
    `PageAdmin` 类，以便我们可以在 `componentWillMount` 生命周期方法中添加事件监听器。然后，这个监听器将更新子 `Page`
    组件的页面数组。
- en: The `PageAdmin` component was used to render the `Page` components, which in
    turn rendered the `PageView` and `PageEditor` components to show and edit pages,
    respectively. We passed callback functions down through each layer so that every
    component could trigger changes in the `Backend` object without knowing how it
    stores or manipulates the data.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`PageAdmin` 组件用于渲染 `Page` 组件，这些组件反过来渲染 `PageView` 和 `PageEditor` 组件以显示和编辑页面。我们通过每一层传递回调函数，以便每个组件都可以在不知道它如何存储或操作数据的情况下触发
    `Backend` 对象中的更改。'
- en: Flux
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flux
- en: At this stage, we encounter the first design pattern (and the improvements we
    can make). Flux is a pattern proposed by Facebook that defines the flow of data
    in an interface.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们遇到了第一个设计模式（以及我们可以做出的改进）。Flux 是 Facebook 提出的一种模式，它定义了界面中数据的流动。
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Flux is not a library, but Facebook has released a few tools that help implement
    the design pattern. You don't have to use those tools to implement Flux. To install
    it, run `npm install --save flux` in addition to the previous dependencies.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Flux 不是一个库，但 Facebook 已经发布了一些工具来帮助实现设计模式。你不必使用这些工具来实现 Flux。要安装它，除了之前的依赖项外，运行
    `npm install --save flux`。
- en: We implemented something very close to Flux, but our implementation is at a
    slight disadvantage. Our `Backend` class does too much. We call it directly to
    add and fetch pages. It emits events when new pages are added. It's tightly coupled
    with the components that use it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了一个非常接近 Flux 的东西，但我们的实现存在一些劣势。我们的 `Backend` 类做得太多。我们直接调用它来添加和获取页面。当添加新页面时，它会发出事件。它与使用它的组件紧密耦合。
- en: So, we'd have a hard time replacing it with a new `Backend` class (unless the
    methods, events and return values were in the exact same format). We'd have a
    hard time using multiple data backends. We don't even really have unidirectional
    flow of data because we send *and* receive data from `Backend`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们很难用一个新的`Backend`类来替换它（除非方法、事件和返回值都完全相同格式）。我们很难使用多个数据后端。我们甚至没有真正实现单向数据流，因为我们从`Backend`发送和接收数据。
- en: Flux differs here; it defines separate objects for *making changes* and *getting
    data*. Our `Backend` class becomes a *dispatcher* for the former and a *store*
    for the latter. What's more, instructions to change application state take the
    form of message objects (called *actions*).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Flux在这里有所不同；它为*制作更改*和*获取数据*定义了单独的对象。我们的`Backend`类成为前者的*分发器*和后者的*存储*。更重要的是，更改应用程序状态的指令采用消息对象的形式（称为*操作*）。
- en: 'We can imagine this as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样想象：
- en: '![Flux](img/5268_08_02.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![Flux](img/5268_08_02.jpg)'
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: These code examples will require another library, which you can install with
    `npm install --save flux`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代码示例将需要另一个库，您可以使用`npm install --save flux`来安装。
- en: 'We can implement this design change by creating a new `PageDispatcher` object
    (in `src/page-dispatcher.js`):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建一个新的`PageDispatcher`对象来实现这个设计变更（在`src/page-dispatcher.js`中）：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `Dispatcher` class isn't too complex. It has a couple of methods, which
    we will use shortly. What's important to note is that we are exporting an instance
    of the `Dispatcher` class, not a subclass. We only need one dispatcher for our
    page operations. So, we use it as a kind of singleton, even though we've not coded
    it specifically to be a singleton.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dispatcher`类并不复杂。它有几个方法，我们很快就会用到。重要的是要注意，我们导出的是`Dispatcher`类的一个实例，而不是一个子类。我们只需要一个分发器来处理页面操作。因此，我们将其用作一种单例，尽管我们没有专门编写代码使其成为单例。'
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you're unfamiliar with the singleton pattern, you can learn about it at [https://en.wikipedia.org/wiki/Singleton_pattern](https://en.wikipedia.org/wiki/Singleton_pattern).
    The basic idea is that we create a class for something (or, in this case, use
    an existing class) but we only ever create and use a single instance of the class.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉单例模式，你可以在[https://en.wikipedia.org/wiki/Singleton_pattern](https://en.wikipedia.org/wiki/Singleton_pattern)上了解它。基本思想是我们为某物（或在这种情况下，使用现有类）创建一个类，但我们只创建和使用该类的一个实例。
- en: 'The second part of this change is a class called `PageStore`, which we create
    in `src/page-store.js`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变化的第二部分是一个名为`PageStore`的类，我们在`src/page-store.js`中创建它：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This class closely resembles the `Backend` class. One notable change is that
    we no longer emit the `onAdd` event after adding new pages. Instead, we register
    a sort of event listener on `PageDispatcher`, which is how we know to add new
    pages to `PageStore`. It''s possible to call `PageStore.add` directly, but here,
    we do that in response to actions being dispatched to `PageDispatcher`. This is
    how those actions look (in `src/index.js`):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类与`Backend`类非常相似。一个显著的变化是我们不再在添加新页面后发出`onAdd`事件。相反，我们在`PageDispatcher`上注册了一种事件监听器，这就是我们知道要将新页面添加到`PageStore`的原因。直接调用`PageStore.add`是可能的，但在这里，我们是在响应发送到`PageDispatcher`的操作时这样做。这些操作看起来是这样的（在`src/index.js`中）：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Dispatchers trigger event listeners in all registered stores. If you dispatch
    an action through a dispatcher, all stores will be notified, no matter the payload.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 分发器会在所有注册的存储中触发事件监听器。如果你通过分发器发出一个操作，无论有效负载如何，所有存储都将被通知。
- en: 'Now, stores don''t only manage collections of objects (like our pages). They''re
    not an application database. They''re meant to store all application states. Perhaps
    we should change a few methods to make this clearer, beginning in `src/page-store.js`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，存储不仅管理对象集合（如我们的页面）。它们不是一个应用程序数据库。它们旨在存储所有应用程序状态。也许我们应该更改一些方法来使其更清晰，从`src/page-store.js`开始：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We're still calling this store `PageStore`, but it can hold many other kinds
    of state besides an array of pages. It could, for instance, store filter and sorting
    state as well. For each new action, we would just need to add some code to the
    `handle` method.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然称这个存储为`PageStore`，但它可以存储除了页面数组之外的其他多种状态。例如，它可以存储过滤和排序状态。对于每个新的操作，我们只需要在`handle`方法中添加一些代码。
- en: 'We also need to adjust the calling code in `index.js`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要调整`index.js`中的调用代码：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When we run this, we should see the following output:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个程序时，我们应该看到以下输出：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, we need to implement these changes in `src/page-admin.js`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在`src/page-admin.js`中实现这些变更：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, we can update `index.js` to reflect these new changes:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以更新`index.js`以反映这些新的变化：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If we run this code, we see very similar output to the code we had before implementing
    Flux.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这段代码，我们会看到与之前实现Flux之前相同的输出。
- en: Benefits of using Flux
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Flux的好处
- en: In a sense, we're still tightly coupling the code that renders interface elements
    and the code that stores and manipulates state. We've just created a bit of a
    barrier between them. So, what do we gain from this approach?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种意义上，我们仍然紧密耦合了渲染界面元素的代码和存储及操作状态的代码。我们只是在它们之间建立了一点点障碍。那么，我们从这种方法中获得了什么？
- en: To start with, Flux is a popular design pattern for React applications. We can
    talk about actions, dispatchers, and stores and be sure that other React developers
    will know exactly what we mean. This decreases the learning curve for bringing
    new developers into React projects.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Flux是React应用程序中流行的设计模式。我们可以谈论动作、调度器和存储，并且可以确信其他React开发者会确切地知道我们的意思。这降低了将新开发者引入React项目的学习曲线。
- en: We've also separated state storage from user and system actions. We have a single,
    universal object through which we can send actions. These may result in changes
    to multiple stores, which in turn can trigger changes in multiple parts of our
    interface. We don't need of multiple stores in our simple example, but complex
    interfaces can benefit from multiple stores. In these cases, a single dispatcher
    and multiple stores work well together.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还分离了状态存储和用户及系统动作。我们有一个单一的、通用的对象，我们可以通过它发送动作。这些动作可能会导致多个存储的变化，进而触发我们界面多个部分的变化。在我们的简单示例中，我们不需要多个存储，但复杂界面可以从多个存储中受益。在这些情况下，一个调度器和多个存储可以很好地协同工作。
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's worth noting that while we've named the Flux dispatcher in such a way that
    we could have more than one dispatcher, apps usually only have one. It's also
    common to have the data backend and dispatcher act as singletons. I've chosen
    to deviate from this based on how we began our application and how we're going
    to end it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，虽然我们命名了Flux调度器，以便我们可以有多个调度器，但应用程序通常只有一个。数据后端和调度器作为单例也很常见。我选择根据我们开始和结束应用程序的方式偏离这一点。
- en: Redux
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redux
- en: Flux leads us to separate our `Backend` class into a dispatcher and a store
    as a means of decoupling from a single state store and implementation. This leads
    to quite a bit of boilerplate, and we still have some coupling (to global dispatcher
    and store objects). It's great to have some terminology to work with, but it doesn't
    feel like the best solution.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Flux引导我们将`Backend`类分离成调度器和存储，作为从单个状态存储和实现中解耦的手段。这导致了很多样板代码，我们仍然有一些耦合（到全局调度器和存储对象）。有一些术语可以工作当然很好，但这并不感觉是最好的解决方案。
- en: What if we could decouple actions and storage and remove the global objects?
    This is what Redux seeks to do along with reducing boilerplate code and bringing
    about better standards overall.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够解耦动作和存储并移除全局对象会怎样？这正是Redux试图做到的，同时减少样板代码并带来更好的整体标准。
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can download the Redux tools by running `npm install --save redux react-redux`
    in addition to the previous dependences. Redux is also just a pattern, but the
    tools in these libraries will help greatly in setting things up.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行`npm install --save redux react-redux`来下载Redux工具，除了之前的依赖项。Redux也是一个模式，但这些库中的工具将极大地帮助设置这些事情。
- en: 'Redux can be a lot to take in at first, but there are some simple underlying
    things which bind it all together. For a start, there''s the idea that all state
    is held in immutable objects. This state should only be transformed by pure functions,
    which take in the current state, and produce a new state. These pure functions
    are also sometimes called idempotent, which means they can be run many times (with
    the same input) and produce the exact same output every time. Let''s explore this
    idea with some code in `index.js`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Redux一开始可能难以理解，但有一些简单的底层事物将它们联系在一起。首先，所有状态都存储在不可变对象中的想法。这种状态应该只通过纯函数进行转换，这些纯函数接受当前状态并产生新的状态。这些纯函数有时也被称为幂等的，这意味着它们可以多次运行（使用相同的输入）并每次都产生完全相同的结果。让我们通过`index.js`中的代码来探讨这个想法：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here, we have a function that takes an initial state value and modifies it
    in the presence of the same sort of action we created for Flux. This is a pure
    function with no side-effects. A new state object is returned, and we even use
    the ES6 spread operator as a way of concatenating the pages into a new array.
    It''s really the same as doing the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个函数，它接受一个初始状态值，并在存在与为 Flux 创建的相同类型的动作的情况下修改它。这是一个没有副作用（side-effects）的纯函数。返回一个新的状态对象，我们甚至使用
    ES6 扩展运算符（spread operator）作为将页面连接到一个新数组的方式。这实际上与以下操作相同：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When we prefix an array with `...`, its values expand as if we wrote them all
    out in a row. This transformer function is called a *reducer*, named after the
    reduce part of *MapReduce* ([https://en.wikipedia.org/wiki/MapReduce](https://en.wikipedia.org/wiki/MapReduce)).
    That is, Redux defines reducers as a way of reducing an initial state by passing
    it through one or more reducers to a new state.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在数组前缀上使用 `...` 时，其值会像我们逐行写出它们一样展开。这个转换函数被称为 *还原器*，这个名字来源于 *MapReduce* 的 reduce
    部分 ([https://en.wikipedia.org/wiki/MapReduce](https://en.wikipedia.org/wiki/MapReduce))。也就是说，Redux
    将还原器定义为通过一个或多个还原器将初始状态减少到新状态的一种方式。
- en: 'We give this reducer to a store similar to the one we created for Flux:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个还原器（reducer）给一个类似于为 Flux 创建的存储：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The store also acts as a dispatcher, so this is much closer to our original
    code. We register listeners on the store, so we can be notified of changes to
    state. We can use a `PageAdmin` component similar to the one we make for Flux
    (in `src/page-admin.js`):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 存储也充当调度器，所以这更接近我们的原始代码。我们在存储上注册监听器，以便我们可以通知状态的变化。我们可以使用类似于为 Flux 创建的 `PageAdmin`
    组件（在 `src/page-admin.js` 中）：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Also, we can render all of this with a few small changes to `index.js`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们只需对 `index.js` 进行一些小的修改就可以渲染所有这些内容：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can imagine a Redux application like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以想象一个 Redux 应用程序是这样的：
- en: '![Redux](img/5268_08_03.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![Redux](img/5268_08_03.jpg)'
- en: So, we've removed the global dependencies. We've almost come full-circle—from
    our original code to Flux to Redux.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经移除了全局依赖。我们几乎回到了起点——从我们的原始代码到 Flux，再到 Redux。
- en: Using context
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用上下文
- en: As you build increasingly complex components, you may discover a frustrating
    side-effect to all this. In Redux, the store acts as a dispatcher. So, if you
    want to dispatch from components deep within a component hierarchy, you need to
    pass the store through multiple components that may not even need it themselves.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你构建越来越复杂的组件，你可能会发现所有这些做法的一个令人沮丧的副作用。在 Redux 中，存储（store）充当调度器（dispatcher）的角色。因此，如果你想从组件层次结构深处的组件中分发（dispatch）动作，你需要将存储通过多个可能甚至不需要它的组件传递。
- en: 'Consider, for a moment, building our CMS interface components to dispatch actions
    directly to the store. We may arrive at a hierarchy similar to this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时考虑构建我们的 CMS 接口组件，以便直接将动作分发到存储。我们可能会得到一个类似以下的层次结构：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Those nested components could also be part of a `render` method.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 那些嵌套组件也可以是 `render` 方法的一部分。
- en: 'It becomes tiresome passing these stores down to each component level in the
    interface. Fortunately, there is a solution to this problem. It''s called *context*,
    and it works like this. First, we create a new component and modify how things
    are rendered in `index.js`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些存储逐级传递到界面中的每个组件级别变得令人厌烦。幸运的是，有一个解决这个问题的方法。它被称为 *上下文*，它的工作方式如下。首先，我们创建一个新的组件，并修改
    `index.js` 中的渲染方式：
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The new component is called `Provider`, and it renders all nested components
    without modification. However, it does define a new life cycle method called `getChildContext`.
    This returns an object with the property values that we want nested components
    to be given. These values are similar to `props`; however, they are implicitly
    provided to nested components.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 新组件被称为 `Provider`，它渲染所有嵌套组件而不做任何修改。然而，它确实定义了一个新的生命周期方法，称为 `getChildContext`。这个方法返回一个对象，其中包含我们希望嵌套组件获得的属性值。这些值类似于
    `props`；然而，它们是隐式提供给嵌套组件的。
- en: 'Along with `getChildContext`, we also need to define `Provider.childContextTypes`.
    These `React.PropTypes` should match what we want to return from `getChildContext`.
    Similarly, we need to modify `PageAdmin`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `getChildContext` 之外，我们还需要定义 `Provider.childContextTypes`。这些 `React.PropTypes`
    应该与我们从 `getChildContext` 返回的内容相匹配。同样，我们需要修改 `PageAdmin`：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When we define `PageAdmin.contextTypes`, we allow components higher up in the
    hierarchy to provide their context to `PageAdmin`. In this case, context will
    contain a reference to the store. To that end, we change `props.store` to `context.store`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义 `PageAdmin.contextTypes` 时，我们允许层次结构中更高层的组件向 `PageAdmin` 提供它们的上下文。在这种情况下，上下文将包含对存储的引用。为此，我们将
    `props.store` 改为 `context.store`。
- en: 'This is a common occurrence in Redux architecture. It is so common that such
    a `Provider` component comes standard with the Redux tools. We can replace our
    `Provider` implementation with the one imported from *ReactRedux*:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 Redux 架构中是一个常见的现象。它如此普遍，以至于这样的 `Provider` 组件是 Redux 工具的标准组成部分。我们可以用从 *ReactRedux*
    导入的 `Provider` 实现来替换我们的 `Provider` 实现：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We don't even need to define `Provider.childContextTypes`. We do, however, still
    need to define `PageAdmin.contextTypes` to opt in to the provided context though.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至不需要定义 `Provider.childContextTypes`。然而，我们仍然需要定义 `PageAdmin.contextTypes`
    以选择加入提供的环境。
- en: Benefits of Redux
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Redux 的优势
- en: Redux is growing in popularity, and it's no surprise. It has all the benefits
    of Flux (such as true unidirectional flow of data and less coupling to a single
    backend implementation) without all of the boilerplate. There's much more to learn
    about it, but what we've covered will set you in great stead to begin architecting
    better applications!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Redux 正在变得越来越受欢迎，这并不令人惊讶。它拥有 Flux 的所有优势（例如真正的单向数据流和减少对单一后端实现的耦合）而没有所有样板代码。关于
    Redux 还有更多东西要学习，但我们所涵盖的内容将为你开始构建更好的应用程序打下坚实的基础！
- en: Note
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can learn more about Redux at [https://egghead.io/series/getting-started-with-redux](https://egghead.io/series/getting-started-with-redux).
    It's a fantastic video course by the creator of Redux.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://egghead.io/series/getting-started-with-redux](https://egghead.io/series/getting-started-with-redux)
    了解更多关于 Redux 的信息。这是一套由 Redux 创作者制作的精彩视频课程。
- en: Summary
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about modern architectural design patterns that
    we can use to build better React applications. We began with the Flux pattern
    and moved on to Redux.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了我们可以用来构建更好的 React 应用程序的现代架构设计模式。我们从 Flux 模式开始，然后转向 Redux。
- en: In the next chapter, we will look at how to create plugin-based components to
    allow our interfaces to be extended by others.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何创建基于插件的组件，以便我们的界面可以被他人扩展。
