- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Recipes – Reusability, Forms, and Caching
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 菜谱 – 可重用性、表单和缓存
- en: In the next two chapters, we will complete most of the implementation of LemonMart
    and round out our coverage of the router-first approach. In this chapter, I will
    reinforce the idea of a decoupled component architecture by creating a *reusable*
    and *routable* component that supports data binding. We will use **Angular directives**
    to reduce boilerplate code and leverage classes, interfaces, enums, validators,
    and pipes to maximize code reuse with TypeScript and ES features.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两个章节中，我们将完成LemonMart的大部分实现，并完善我们对路由优先方法的覆盖。在本章中，我将通过创建一个**可重用**和**可路由**的组件来支持数据绑定来强化解耦组件架构的概念。我们将使用**Angular指令**来减少样板代码，并利用类、接口、枚举、验证器和管道，通过TypeScript和ES功能最大化代码重用。
- en: In addition, we will create a **multi-step form** that architecturally scales
    well and supports a responsive design. Then, we will differentiate between user
    controls and components by introducing a **lemon rater** and a reusable form part
    that encapsulates the name object.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将创建一个**多步骤表单**，它在架构上具有良好的扩展性，并支持响应式设计。然后，我们将通过引入一个**柠檬评分器**和一个封装了名称对象的可重用表单部分来区分用户控件和组件。
- en: This chapter covers a lot of ground. It is organized in a recipe format, so
    you can quickly refer to a particular implementation when working on your projects.
    I will cover the implementations’ architecture, design, and major components.
    I will highlight important pieces of code to explain how the solution comes together.
    Leveraging what you’ve learned so far, I expect you to fill in routine implementation
    and configuration details. However, you can always refer to the GitHub project
    if you are stuck.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了大量的内容。它以菜谱格式组织，因此你可以在处理项目时快速参考特定的实现。我将涵盖实现架构、设计和主要组件。我将突出显示重要的代码片段来解释解决方案是如何组合在一起的。利用你迄今为止所学到的知识，我期望你填写常规实现和配置细节。然而，如果你遇到困难，你始终可以参考GitHub项目。
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下主题：
- en: Implementing CRUD services with caching
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用缓存实现CRUD服务
- en: Multi-step responsive forms
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多步骤响应式表单
- en: Reusing repeating template behavior with directives
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用指令重用重复模板行为
- en: Calculated properties and DatePicker
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算属性和DatePicker
- en: Typeahead support
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动完成支持
- en: Dynamic form arrays
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态表单数组
- en: Creating shared components
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建共享组件
- en: Reviewing and saving form data
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查和保存表单数据
- en: Scalable form architecture with reusable parts
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有可重用部分的可扩展表单架构
- en: Input masking
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入掩码
- en: Custom controls with `ControlValueAccessor`
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ControlValueAccessor`的自定义控件
- en: Layouts using a grid list
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用网格列表布局
- en: Restoring cached data
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恢复缓存数据
- en: Technical requirements
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The most up-to-date versions of the sample code for the book are on GitHub at
    the repository linked in the following steps. The repository contains the final
    and completed state of the code. You can verify your progress at the end of this
    chapter by looking at the end-of-chapter snapshot of the code under the `projects`
    folder.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 书籍的示例代码的最新版本可在以下步骤中链接的GitHub仓库中找到。该仓库包含代码的最终和完成状态。你可以在本章末尾通过查看`projects`文件夹下的代码末尾快照来验证你的进度。
- en: 'For *Chapter 8*:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*第8章*：
- en: Be sure that **lemon-mart-server** is up and running. Refer to *Chapter 7*,
    *Working with REST and GraphQL APIs*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 确保服务端**lemon-mart-server**正在运行。请参阅*第7章*，*与REST和GraphQL API一起工作*。
- en: Clone the repo at [https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart).
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[https://github.com/duluca/lemon-mart](https://github.com/duluca/lemon-mart)克隆仓库。
- en: Execute `npm install` in the root folder to install the dependencies.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根目录中执行`npm install`以安装依赖项。
- en: 'The beginning state of the project is reflected at:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目的初始状态反映在：
- en: '[PRE0]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The end state of the project is reflected at:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目的最终状态反映在：
- en: '[PRE1]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the stage name to any `ng` command to act only on that stage:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将阶段名称添加到任何`ng`命令中，以仅对该阶段执行操作：
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that the `dist/stage11` folder at the root of the repository will contain
    the compiled result.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，仓库根目录下的`dist/stage11`文件夹将包含编译结果。
- en: Beware that the source code provided in the book and the version on GitHub will
    likely differ. The ecosystem around these projects is ever-evolving. Between changes
    to how Angular CLI generates new code, bug fixes, new versions of libraries, or
    side-by-side implementations of multiple techniques, there’s a lot of variation
    impossible to account for. If you find errors or have questions, please create
    an issue or submit a pull request on GitHub.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，书中提供的源代码和 GitHub 上的版本可能会有所不同。这些项目周围的生态系统一直在不断发展。在 Angular CLI 生成新代码的方式、错误修复、库的新版本或多种技术的并行实现之间，有很多变化是无法预料的。如果您发现错误或有疑问，请创建一个
    issue 或在 GitHub 上提交一个 pull request。
- en: Let’s start with implementing a user service to retrieve data and build a form
    to display and edit profile information. Later, we will refactor this form to
    abstract out its reusable parts.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从实现一个用户服务来检索数据并构建一个用于显示和编辑个人资料信息的表单开始。稍后，我们将重构这个表单，以抽象出其可重用部分。
- en: Implementing CRUD services with caching
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现具有缓存的 CRUD 服务
- en: 'We need a service that can perform CRUD operations on a user so that we can
    implement a user profile. However, the service must be robust enough to withstand
    common errors. After all, it is very bad UX when users unintentionally lose the
    data they typed. Form data can be reset due to circumstances outside of a user’s
    control, like a network or validation error, or user errors, like hitting the
    back or refresh button by mistake. We will create a user service leveraging the
    `CacheService` we built in *Chapter 5*, *Designing Authentication and Authorization*,
    so keep a copy of user data in `localStorage` while the server processes it. The
    service will implement the following interface and, as always, reference the abstract
    `IUser` interface over the concrete user implementation:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个能够对用户执行 CRUD 操作的服务，以便我们可以实现用户资料。然而，该服务必须足够健壮，以承受常见的错误。毕竟，当用户无意中丢失他们输入的数据时，用户体验非常糟糕。表单数据可能会因为超出用户控制的情况而重置，比如网络或验证错误，或者用户错误，比如不小心点击了后退或刷新按钮。我们将创建一个利用我们在
    *第5章* 中构建的 `CacheService` 的用户服务，在服务器处理数据的同时，将用户数据保存在 `localStorage` 中。该服务将实现以下接口，并且，像往常一样，引用抽象的
    `IUser` 接口而不是具体的用户实现：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Before creating the service, start **lemon-mart-server** and set your application’s
    `AuthMode` to `CustomServer`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建服务之前，启动 **lemon-mart-server** 并将您的应用程序的 `AuthMode` 设置为 `CustomServer`。
- en: You can use `npm run start:backend` to start the database and the server.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `npm run start:backend` 来启动数据库和服务器。
- en: In this section, we will implement the `getUser` and `updateUser` functions.
    We will implement `getUsers` in *Chapter 9*, *Recipes – Master/Detail, Data Tables,
    and NgRx*, to support pagination with a data table.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现 `getUser` 和 `updateUser` 函数。我们将在 *第9章* 中实现 `getUsers`，*食谱 – 主/详细信息、数据表和
    NgRx*，以支持数据表分页。
- en: 'Start by creating the user service:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建用户服务：
- en: Create a `UserService` under `src/app/user/user`.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/app/user/user` 下创建一个 `UserService`。
- en: Declare the `IUserService` interface from the preceding snippet, excluding the
    `getUsers` function.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从前面的代码片段中声明 `IUserService` 接口，不包括 `getUsers` 函数。
- en: Ensure the `UserService` class implements `IUserService`.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保 `UserService` 类实现了 `IUserService`。
- en: 'Inject the `CacheService`, `HttpClient`, and `AuthService`, as shown here:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `CacheService`、`HttpClient` 和 `AuthService` 注入，如下所示：
- en: '[PRE4]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Implement the `getUser` function, as shown here:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现如下的 `getUser` 函数：
- en: '[PRE5]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We provide a `getUser` function that can load any user’s profile information.
    Note that the security for this function is provided in the server implementation
    with the authenticate middleware. The requestor can either get their profile or
    will need to be a manager. We use `getUser` with a resolve guard later in the
    chapter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一个可以加载任何用户个人资料信息的 `getUser` 函数。请注意，此函数的安全性由服务器实现中的 authenticate 中间件提供。请求者可以获取他们的个人资料，或者需要是管理员。我们将在本章后面使用
    `getUser` 与 resolve 守卫一起使用。
- en: Updating the cache
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新缓存
- en: 'Implement `updateUser`, which accepts an object that implements the `IUser`
    interface so that data can be sent to a PUT endpoint:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 `updateUser`，它接受一个实现 `IUser` 接口的对象，以便可以将数据发送到 PUT 端点：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note how the cache service is used with `setItem` to save user-entered data
    if the `put` call fails. When the call succeeds, we remove the cached data using
    `removeItem`. Also, note how we hydrate a user returned from the server as a `User`
    object with `map(User.Build)`, which calls the constructor of `class User`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意缓存服务是如何使用 `setItem` 来保存用户输入的数据，如果 `put` 调用失败。当调用成功时，我们使用 `removeItem` 删除缓存数据。此外，注意我们是如何使用
    `map(User.Build)` 将从服务器返回的用户作为 `User` 对象进行填充，这调用的是 `class User` 的构造函数。
- en: Hydrate is a common term for populating an object with data from a database
    or a network request. For example, the `User` JSON object we pass between components
    or receive from the server fits the `IUser` interface but is not the `class User`
    type. We serialize objects to JSON using the `toJSON` method. When we hydrate
    and instantiate a new object from JSON, we reverse and deserialize the data.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 填充是用于从数据库或网络请求中填充对象数据的常用术语。例如，我们在组件之间传递或从服务器接收的 `User` JSON 对象符合 `IUser` 接口，但不是
    `class User` 类型。我们使用 `toJSON` 方法将对象序列化为 JSON。当我们填充并从 JSON 实例化一个新对象时，我们会反转并反序列化数据。
- en: It is important to highlight that you should always stick to interfaces, not
    concrete implementations like `User` when passing data around. This is the **D**
    in **SOLID** – the **Dependency Inversion Principle**. Referencing concrete implementations
    like `User` creates a lot of risk because they change a lot, whereas an abstraction
    such as `IUser` will seldom change. After all, you wouldn’t solder a lamp directly
    to the electrical wiring in the wall. Instead, you solder the lamp to a plug and
    then use the plug to get the electricity you need.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 需要强调的是，在传递数据时，你应该始终坚持使用接口，而不是像 `User` 这样的具体实现。这是 **SOLID** 原则中的 **D**（依赖倒置原则）。引用像
    `User` 这样的具体实现会带来很多风险，因为它们经常变化，而像 `IUser` 这样的抽象则很少变化。毕竟，你不会直接将灯泡焊接在墙上的电线中。相反，你会将灯泡焊接在插头上，然后使用插头获取所需的电力。
- en: With this code completed, `UserService` can now be used for basic CRUD operations.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 代码完成后，`UserService` 现在可以用于基本的 CRUD 操作。
- en: Multi-step responsive forms
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多步骤响应式表单
- en: Overall, forms are a different beast than the rest of your application, and
    they require special architectural considerations. I don’t recommend over-engineering
    your form solution with dynamic templates or route-enabled components. By definition,
    the different parts of a form are tightly coupled. From the perspectives of maintainability
    and ease of implementation, creating one giant component is a better strategy
    than using some of the aforementioned strategies and over-engineering.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，表单与你的应用程序的其他部分不同，它们需要特殊的架构考虑。我不建议使用动态模板或启用路由的组件过度设计你的表单解决方案。根据定义，表单的不同部分是紧密耦合的。从可维护性和易于实现的角度来看，创建一个巨大的组件比使用上述一些策略和过度设计更好。
- en: We will implement a multi-step input form to capture user profile information
    in a single component. I will be covering my recommended technique to split forms
    up into multiple components later in the chapter, in the *Reusable form parts
    and scalability* section.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个多步骤输入表单，在单个组件中捕获用户配置文件信息。我将在本章的“可重用表单部分和可扩展性”部分介绍我推荐的将表单拆分为多个组件的技术。
- en: Since the implementation of the form changes dramatically between this section
    and later in the chapter, you can find the code for the initial version on GitHub
    at `projects/stage11/src/app/user/profile/profile.initial.component.ts` and `projects/stage11/src/app/user/profile/profile.initial.component.html`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于表单的实现在这部分和章节后面的部分之间发生了巨大变化，你可以在 GitHub 上的 `projects/stage11/src/app/user/profile/profile.initial.component.ts`
    和 `projects/stage11/src/app/user/profile/profile.initial.component.html` 找到初始版本的代码。
- en: 'We will also make this multi-step form responsive for mobile devices using
    media queries:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用媒体查询使这个多步骤表单对移动设备做出响应：
- en: 'Let’s start by adding some helper data that will help us display an input form
    with options:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先添加一些辅助数据，这将帮助我们显示带有选项的输入表单：
- en: '[PRE7]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add new validation rules to `common/validations.ts`:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `common/validations.ts` 中添加新的验证规则：
- en: '[PRE8]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, implement `profile.component.ts` as follows:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，按照以下方式实现 `profile.component.ts`：
- en: '[PRE9]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Upon load, we request the current user from `authService`, but this might take
    a while, so we first build an empty form with `this.buildForm()` as the first
    statement. We also store the user’s ID in the `currentUserId` property, which
    we will need later when implementing the `save` functionality.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载时，我们从`authService`请求当前用户，但这可能需要一些时间，所以我们首先使用`this.buildForm()`作为第一条语句构建一个空表单。我们还将在`currentUserId`属性中存储用户的ID，我们将在实现`save`功能时需要它。
- en: Note that we filter out `null` or `undefined` users so that we don’t try to
    build the form in an invalid state.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们过滤掉`null`或`undefined`用户，以避免尝试在无效状态下构建表单。
- en: The implementation above introduces a UX issue in the case where `authService.currentUser$`
    is retrieved from an API. If the API takes over half a second (really, 340 ms)
    to return the data, there’ll be a noticeable pop-up of new information on the
    form. This will overwrite any text the user may have already entered.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 上述实现中，如果从API获取`authService.currentUser$`时，会引入一个UX问题。如果API需要超过半秒钟（实际上，340毫秒）来返回数据，表单上会出现明显的新信息弹出。这将覆盖用户可能已经输入的任何文本。
- en: To prevent this, we could disable and reenable the form once the information
    is received. However, this component isn’t aware of where the information comes
    from; it merely subscribes to `authService.currentUser$`, which may or may not
    ever return a value. Even if we could reliably tell that we are receiving data
    from an API, we would have to implement a bespoke solution in every component.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种情况，我们可以在收到信息后禁用和重新启用表单。然而，该组件并不知道信息来自何处；它只是订阅了`authService.currentUser$`，它可能永远不会返回值。即使我们能够可靠地判断我们正在从API接收数据，我们也必须在每个组件中实现一个定制的解决方案。
- en: Using an `HttpInterceptor`, we can globally detect when API calls are triggered
    and completed; we can expose a `signal` where components can individually subscribe
    to display a loading spinner, or we can leverage the `UiService` to launch a global
    loading spinner to block the UI while data is retrieved from the server. In *Chapter
    9*, *Recipes – Master/Detail, Data Tables, and NgRx*, I cover how to implement
    a global spinner.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`HttpInterceptor`，我们可以全局检测API调用何时被触发和完成；我们可以暴露一个`signal`，让组件可以单独订阅以显示加载指示器，或者我们可以利用`UiService`来启动全局加载指示器，在从服务器获取数据时阻塞UI。在*第9章*，*食谱
    – 主/详情，数据表和NgRx*中，我介绍了如何实现全局加载指示器。
- en: A global spinner is the ultimate 80–20 solution. However, you may find that
    a global spinner is a non-starter in large applications with dozens of components
    continuously retrieving data. Complex UI requires expensive UX solutions. In this
    case, you will indeed want to implement a component-level spinner. This is demonstrated
    in the *Data tables with pagination* section of *Chapter 9*, *Recipes – Master/Detail,
    Data Tables, and NgRx*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 全局加载指示器是80-20的终极解决方案。然而，您可能会发现，在具有数十个组件持续检索数据的大型应用程序中，全局加载指示器可能不可行。复杂的UI需要昂贵的UX解决方案。在这种情况下，您确实需要实现一个组件级别的加载指示器。这在第9章的*数据表分页*部分进行了演示，*食谱
    – 主/详情，数据表和NgRx*。
- en: Later in this chapter, we will implement a resolve guard to load a user based
    on their `userId`, provided on a route to increase the reusability of this component.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将实现一个基于路由提供的`userId`来加载用户的解析守卫，以提高该组件的可重用性。
- en: Form controls and form groups
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表单控件和表单组
- en: As you may recall, `FormControl` objects are the most elemental parts of a form,
    usually representing a single input field. We can use `FormGroup` to group together
    a collection of related `FormControl` objects, such as the individual first, middle,
    and last parts of a person’s name. `FormGroup` objects can also group together
    a mix of `FormControl`, `FormGroup`, and `FormArray` objects. The latter object
    allows us to have dynamically repeating elements. `FormArray` is covered later
    in the chapter in the *Dynamic form arrays* section.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所忆，`FormControl`对象是表单的最基本部分，通常代表单个输入字段。我们可以使用`FormGroup`将一组相关的`FormControl`对象组合在一起，例如一个人的名字的单独的姓、名和姓。`FormGroup`对象也可以将`FormControl`、`FormGroup`和`FormArray`对象的混合组合在一起。后者允许我们拥有动态重复的元素。`FormArray`将在本章的*动态表单数组*部分进行介绍。
- en: Our form has many input fields, so we will use a `FormGroup` created by `this.formBuilder.group`
    to house our various `FormControl` objects. Additionally, children `FormGroup`
    objects will allow us to maintain the correct shape of the data structure.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的表单有许多输入字段，因此我们将使用由`this.formBuilder.group`创建的`FormGroup`来存放我们的各种`FormControl`对象。此外，子`FormGroup`对象将允许我们保持数据结构的正确形状。
- en: Since the implementation of the form changes dramatically between this section
    and later in the chapter, you can find the code for the initial version on GitHub
    at `projects/stage11/src/app/user/profile/profile.initial.component.ts` and `projects/stage11/src/app/user/profile/profile.initial.component.html`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于表单的实现在这部分和章节后面的部分之间有显著变化，你可以在GitHub上找到初始版本的代码，地址为`projects/stage11/src/app/user/profile/profile.initial.component.ts`和`projects/stage11/src/app/user/profile/profile.initial.component.html`。
- en: 'Start building the `buildForm` function, as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 开始构建`buildForm`函数，如下所示：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`buildForm` optionally accepts an `IUser` to prefill the form. Otherwise, all
    fields are set to their default values. The `formGroup` property itself is the
    top-level `FormGroup`. Various `FormControls` are added to it, such as `email`,
    with validators attached to them as needed.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`buildForm`可以接受一个`IUser`来预填充表单。否则，所有字段都设置为它们的默认值。`formGroup`属性本身是顶级`FormGroup`。根据需要，向其中添加各种`FormControls`，例如`email`，并附加必要的验证器。'
- en: Note how `name` and `address` are their own `FormGroup` objects. This parent-child
    relationship ensures the proper structure of the form data, when serialized to
    JSON, which fits the structure of `IUser` in a manner that the rest of our application
    and server-side code can utilize.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`name`和`address`是它们自己的`FormGroup`对象。这种父子关系确保了表单数据序列化到JSON时的正确结构，以适应`IUser`的结构，这样我们的应用程序和服务器端代码就可以利用它。
- en: You will complete the implementation of the `formGroup` independently by following
    the sample code provided for the chapter. I will review sections of the code piece
    by piece over the next few sections to explain certain key capabilities.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你将通过遵循本章提供的示例代码独立完成`formGroup`的实现。在接下来的几节中，我将逐段审查代码，解释某些关键功能。
- en: Stepper and responsive layout
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 步进器和响应式布局
- en: 'Angular Material’s stepper ships with the `MatStepperModule`. The stepper allows
    form inputs to be broken up into multiple steps so that the user is not overwhelmed
    with processing dozens of input fields simultaneously. The user can still track
    their place in the process, and as a side effect, as the developer, we break up
    our `<form>` implementation and enforce validation rules on a step-by-step basis,
    or create optional workflows where certain steps can be skipped or required. As
    with all Material user controls, the stepper has been designed with a responsive
    UX. In the next few sections, we will implement three steps covering different
    form-input techniques in the process:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Angular Material的步进器自带`MatStepperModule`。步进器允许将表单输入分成多个步骤，这样用户就不会同时处理数十个输入字段而感到不知所措。用户仍然可以跟踪他们在过程中的位置，作为副作用，作为开发者，我们可以将我们的`<form>`实现拆分，并逐步实施验证规则，或者创建可选的工作流程，其中某些步骤可以跳过或为必填项。与所有Material用户控件一样，步进器已经设计为具有响应式UX。在接下来的几节中，我们将实现三个步骤，涵盖过程中的不同表单输入技术：
- en: 'Account information:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 账户信息：
- en: Input validation
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入验证
- en: Responsive layout with media queries
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式布局与媒体查询
- en: Calculated properties
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算属性
- en: '`DatePicker`'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DatePicker`'
- en: 'Contact information:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 联系信息：
- en: Typeahead support
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动完成支持
- en: Dynamic form arrays
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态表单数组
- en: 'Review:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复习：
- en: Read-only views
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只读视图
- en: Saving and clearing data
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存和清除数据
- en: 'Let’s start by adding the Angular material dependencies:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先添加Angular material依赖项：
- en: 'Import the following Material modules in `profile.component.ts`:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`profile.component.ts`中导入以下Material模块：
- en: '[PRE11]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Import other supporting modules:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入其他支持模块：
- en: '[PRE12]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Implement a horizontal stepper with a form containing the first step:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现包含第一步的横向步进器表单：
- en: '[PRE13]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, start implementing the `name` row of the `Account Information` step in
    place of the ellipses in the preceding step:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，开始实现上一步骤中省略号的`Account Information`步骤的`name`行：
- en: '[PRE14]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Take your time understanding how the stepper and the form configuration work
    so far. You should see the first row render, pulling in data from the **lemon-mart-server**:![](img/B20960_08_01.png)
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仔细理解到目前为止的步进器和表单配置工作原理。你应该能看到第一行渲染，从**lemon-mart-server**获取数据：![](img/B20960_08_01.png)
- en: 'Figure 8.1: Multi-step form – step 1'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.1：多步表单 – 第一步
- en: 'Note that adding `fxLayout.lt-sm="column"` to a row with `fxLayout="row"` enables
    a responsive layout for the form, as shown here:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，将`fxLayout.lt-sm="column"`添加到具有`fxLayout="row"`的行中，可以为表单启用响应式布局，如下所示：
- en: '![](img/B20960_08_02.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B20960_08_02.png)'
- en: 'Figure 8.2: Multi-step form on mobile'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：移动端多步表单
- en: Before we move on to how to implement the **Date of Birth** ﬁeld, let’s reevaluate
    our strategy by implementing error messages.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续介绍如何实现**出生日期**字段之前，让我们通过实现错误消息来重新评估我们的策略。
- en: Reusing repeating template behavior with directives
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用指令重用重复的模板行为
- en: In the previous section, we implemented a `mat-error` element for every validation
    error for every field part of the `name` object. This quickly adds up to seven
    elements for three fields. In *Chapter 5*, *Designing Authentication and Authorization*,
    we implemented `common/validations.ts` to reuse validation rules. We can reuse
    the behavior we implement within `mat-error`, or any other `div` for that matter,
    using an attribute directive.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们为 `name` 对象的每个字段部分的每个验证错误都实现了一个 `mat-error` 元素。对于三个字段，这会迅速增加到七个元素。在
    *第五章*，*设计身份验证和授权* 中，我们实现了 `common/validations.ts` 以重用验证规则。我们可以使用属性指令重用我们在 `mat-error`
    中实现的行为，或者任何其他 `div`。
- en: Attribute directives
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性指令
- en: In *Chapter 1*, *Angular’s Architecture and Concepts*, I mentioned that Angular
    components represent the most basic unit of an Angular app. With components, we
    define custom HTML elements that can reuse features and functionality represented
    by a template and some TypeScript code. Conversely, a directive augments the capabilities
    of an existing element or component. In a sense, a component is a super directive
    that augments basic HTML capabilities.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第一章*，*Angular 的架构和概念* 中，我提到 Angular 组件代表 Angular 应用中最基本的单元。通过组件，我们定义可以重用模板和一些
    TypeScript 代码所表示的功能和特性的自定义 HTML 元素。相反，指令增强了现有元素或组件的功能。从某种意义上说，组件是一个增强基本 HTML 功能的超指令。
- en: 'With this view in mind, we can define three kinds of directives:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个观点，我们可以定义三种类型的指令：
- en: Components
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件
- en: Structural directives
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构性指令
- en: Attribute directives
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性指令
- en: Basically, components are directives with templates; this is the most common
    type of directive you will use. Structural directives modify the DOM by adding
    or removing elements, `*ngIf` and `*ngFor` being the canonical examples.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，组件是带有模板的指令；这是你将最常使用的指令类型。结构性指令通过添加或删除元素来修改 DOM，`*ngIf` 和 `*ngFor` 是典型的例子。
- en: 'As of Angular 17, you can use the `@`-syntax to implement control flow and
    deferrable views, replacing `*ngIf` and `*ngFor` in favor of `@if` or `@for`,
    respectively. See the code snippet below for an example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 Angular 17，你可以使用 `@`-语法来实现控制流和可延迟视图，分别用 `@if` 或 `@for` 替代 `*ngIf` 和 `*ngFor`。下面是一个示例代码片段：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Finally, attribute directives allow you to define new attributes to add to HTML
    elements or components, adding new behavior.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，属性指令允许你定义可以添加到 HTML 元素或组件中的新属性，添加新的行为。
- en: Let’s implement an attribute directive that can encapsulate field-level error
    behavior.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个可以封装字段级错误行为的属性指令。
- en: Field error attribute directive
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字段错误属性指令
- en: 'Imagine using a directive to reduce repetitive elements to display field errors.
    Consider the following example using the first name field as an example:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下使用指令来减少显示字段错误时的重复元素。以下是一个使用姓名字段作为示例的例子：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We have the standard layout structure for a Material form field, but only a
    single `mat-error` element exists. There are three new properties on `mat-error`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有 Material 表单字段的常规布局结构，但只有一个 `mat-error` 元素。`mat-error` 上有三个新属性：
- en: '`input` binds to the HTML input element that was tagged with `#name`, using
    a template reference variable so that we can tap into the blur event of the input
    element and read the `placeholder`, `aria-label`, and `formControlName` properties.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`input` 绑定到被标记为 `#name` 的 HTML 输入元素，使用模板引用变量，这样我们就可以监听输入元素的 blur 事件并读取 `placeholder`、`aria-label`
    和 `formControlName` 属性。'
- en: '`group` binds to the parent FormGroup object that contains the form control,
    so by using the `formControlName` property from input, we can retrieve the `formControl`
    object while avoiding extra code.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`group` 绑定到包含表单控件的父 `FormGroup` 对象，因此通过使用输入的 `formControlName` 属性，我们可以检索 `formControl`
    对象，同时避免额外的代码。'
- en: '`appFieldError` binds to an array of validation errors that must be checked
    against the `formControl` object, such as `required`, `minlength`, `maxlength`,
    and `invalid`.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`appFieldError` 绑定到一个数组，该数组包含必须与 `formControl` 对象（如 `required`、`minlength`、`maxlength`
    和 `invalid`）进行校验的验证错误。'
- en: Using the preceding information, we can craft a directive that can render one
    or more lines of error messages inside the `mat-error` element, effectively replicating
    the verbose method we used in the previous section.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的信息，我们可以创建一个指令，可以在 `mat-error` 元素内渲染一行或多行错误信息，有效地复制我们在上一节中使用的方法。
- en: 'Let’s go ahead and create an attribute directive named `FieldErrorDirective`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建一个名为 `FieldErrorDirective` 的属性指令：
- en: Create `FieldErrorDirective` under `src/app/user-controls`.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/app/user-controls`下创建`FieldErrorDirective`。
- en: 'Define the directive’s selector as a bindable attribute named `appFieldError`:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将指令的选择器定义为名为`appFieldError`的可绑定属性：
- en: '[PRE17]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Outside of the directive, define two new types named `ValidationError` and
    `ValidationErrorTuple`, which define the kinds of error conditions we will deal
    with and a structure that will allow us to attach a custom error message to the
    error type:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在指令之外，定义两个新类型`ValidationError`和`ValidationErrorTuple`，它们定义我们将要处理的错误条件类型以及允许我们将自定义错误消息附加到错误类型上的结构：
- en: '[PRE18]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Like the way we grouped validations, let’s define two sets of commonly occurring
    error conditions so that we don’t have to type them out over and over again:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像我们分组验证一样，让我们定义两组常见的错误条件，这样我们就不必一遍又一遍地输入它们：
- en: '[PRE19]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, let’s define the `@Input` targets for the directive:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们定义指令的`@Input`目标：
- en: '[PRE20]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that we already went over the purpose of the top three attributes. `fieldControl`
    and `fieldLabel` are optional attributes. If `input` and `group` are specified,
    the optional attributes can be auto-populated. Since they are class-wide variables,
    it made sense to expose them if the user wants to override the default behavior
    of the directive. This is an easy win to create flexible and reusable controls.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们已经讨论了前三个属性的目的。`fieldControl`和`fieldLabel`是可选属性。如果指定了`input`和`group`，则可选属性可以自动填充。由于它们是类级变量，如果用户想要覆盖指令的默认行为，则公开它们是有意义的。这是一个容易的胜利，可以创建灵活且可重用的控件。
- en: 'Import the element reference in the `constructor`, which can be later used
    by a `renderErrors` function to display error in the inner HTML of the `mat-error`
    element:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`constructor`中导入元素引用，这可以在稍后由`renderErrors`函数用于在`mat-error`元素的内部HTML中显示错误：
- en: '[PRE21]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Implement a function that can return canned error messages, depending on the
    error type:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个函数，该函数可以根据错误类型返回预定义的错误消息：
- en: '[PRE22]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that we can dynamically extract the required `minlength` or `maxlength`
    from the `fieldControl`, greatly reducing the number of custom messages we need
    to generate.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们可以从`fieldControl`动态提取所需的`minlength`或`maxlength`，这大大减少了我们需要生成的自定义消息的数量。
- en: 'Implement the algorithm that can loop through all the elements in `appFieldError`
    and the errors that need to be displayed in an array, using the `getStandardErrorMessage`
    method:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个算法，该算法可以使用`getStandardErrorMessage`方法遍历`appFieldError`中的所有元素和需要显示的错误：
- en: '[PRE23]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Ultimately, we can display the error messages using the `renderErrors` method.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最终，我们可以使用`renderErrors`方法显示错误信息。
- en: Note the use of function delegates, a technique that allows functions to be
    passed around and used as variables. Since this code will execute hundreds of
    times a minute, it is important to avoid unnecessary invocations. Function delegates
    help organize our code better while deferring the execution of their logic unless
    absolutely necessary. This pattern of coding allows for memorization techniques
    to enhance performance further. Refer to the *Further reading* section for more
    details.
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意函数委托的使用，这是一种允许函数被传递并用作变量的技术。由于此代码每分钟将执行数百次，因此避免不必要的调用很重要。函数委托有助于更好地组织我们的代码，并在绝对必要时才延迟其逻辑的执行。这种编码模式允许使用记忆技术进一步提高性能。有关更多详细信息，请参阅*进一步阅读*部分。
- en: 'Now, initialize the `fieldControl` property, which represents a `formControl`.
    We will listen to the `valueChanges` events of the control, and if the validation
    status is invalid, then we execute our custom `updateErrorMessage` logic to display
    error messages:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，初始化`fieldControl`属性，它代表一个`formControl`。我们将监听控制的`valueChanges`事件，如果验证状态无效，则执行我们的自定义`updateErrorMessage`逻辑来显示错误信息：
- en: '[PRE24]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that since we’re subscribing to `valueChanges`, we must also unsubscribe.
    We unsubscribe once with `ngOnDestroy` and again right before subscribing. This
    is because `initFieldControl` may be called multiple times. If we don’t clear
    the prior subscription, it will result in a memory leak and related performance
    issues.
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，由于我们正在订阅`valueChanges`，我们也必须取消订阅。我们使用`ngOnDestroy`取消订阅一次，然后在再次订阅之前再次取消订阅。这是因为`initFieldControl`可能会被多次调用。如果我们不清除之前的订阅，将导致内存泄漏和相关性能问题。
- en: Additionally, if we can’t bind to a `fieldControl`, we throw an error message,
    which usually points to a coding error.
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，如果我们无法绑定到`fieldControl`，我们会抛出一个错误信息，这通常指向一个编码错误。
- en: 'Finally, we configure all major attributes with the `ngOnChanges` event, which
    triggers any time an `@Input` attribute is updated. This ensures that, in the
    case where form elements could be dynamically added or removed, we will always
    consider the newest values. We call `initFieldControl` to start listening to value
    changes, implement an `onblur` event handler that triggers `updateErrorMessage()`
    for the HTML input element, and assign the value of `fieldLabel`:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用 `ngOnChanges` 事件来配置所有主要属性，该事件在 `@Input` 属性更新时触发。这确保了，在表单元素可能动态添加或删除的情况下，我们始终考虑最新的值。我们调用
    `initFieldControl` 来开始监听值的变化，实现一个触发 `updateErrorMessage()` 的 `onblur` 事件处理器，并为
    HTML 输入元素分配 `fieldLabel` 的值：
- en: '[PRE25]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note that if we can’t bind to an HTML `input` element, this usually means that
    the developer simply forgot to wire things up correctly. In this case, we throw
    a new `Error` object, which generates a helpful stack trace in the console, so
    you can pinpoint the location where the error occurs in the template.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果我们无法绑定到 HTML `input` 元素，这通常意味着开发者忘记正确连接这些元素。在这种情况下，我们抛出一个新的 `Error` 对象，这在控制台中生成一个有用的堆栈跟踪，以便你可以确定模板中错误发生的位置。
- en: 'This wraps up the implementation of the directive. Now, we need to package
    the directive in a module named `field-error.module.ts`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了指令的实现。现在，我们需要将指令打包到一个名为 `field-error.module.ts` 的模块中：
- en: '[PRE26]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, go ahead and use the directive in our existing forms:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，继续在我们的现有表单中使用这个指令：
- en: Import the module in `app.module.ts` and `user.module.ts`.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `app.module.ts` 和 `user.module.ts` 中导入该模块。
- en: Update `profile.component.html` with the new directive.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用新指令更新 `profile.component.html`。
- en: Update `login.component.html` with the new directive.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用新指令更新 `login.component.html`。
- en: Be sure to define `ErrorSets` as a public property variable in the `component`
    class so that you can use it in the template.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在 `component` 类中将 `ErrorSets` 定义为一个公共属性变量，以便你可以在模板中使用它。
- en: Test your forms to ensure that our validation messages are displayed as expected
    and there are no console errors.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 测试你的表单，以确保我们的验证消息按预期显示，并且没有控制台错误。
- en: Congratulations! You’ve learned how to inject new behavior into other elements
    and components using directives. By doing this, we can avoid a lot of repeated
    code and standardize error messages across our app.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经学会了如何使用指令将新行为注入到其他元素和组件中。通过这样做，我们可以避免大量的重复代码，并在我们的应用程序中标准化错误消息。
- en: Before moving on, finish implementing the form by looking at the implementation
    on GitHub. You can find the code for the form template at `projects/stage11/src/app/user/profile/profile.initial.component.html`
    and the `component` class at `projects/stage11/src/app/user/profile/profile.initial.component.ts`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，通过查看 GitHub 上的实现来完成表单的实现。你可以在 `projects/stage11/src/app/user/profile/profile.initial.component.html`
    中找到表单模板的代码，以及在 `projects/stage11/src/app/user/profile/profile.initial.component.ts`
    中找到 `component` 类。
- en: Do not include the `app-lemon-rater` and `app-view-user` elements, and remove
    the `mask` attribute from the phone number, which we will implement later in the
    chapter.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 不要包含 `app-lemon-rater` 和 `app-view-user` 元素，并从电话号码中移除 `mask` 属性，我们将在本章后面实现它。
- en: 'Here, you can see the User Profile as it appears on LemonMart:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到在 LemonMart 上显示的用户资料：
- en: '![](img/B20960_08_03.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B20960_08_03.png)'
- en: 'Figure 8.3: Profile component in a mostly completed state'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3：基本完成的资料组件
- en: Next, we will review the `profile` component and see how the **Date of Birth**
    ﬁeld works.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将回顾 `profile` 组件，看看 **出生日期** 字段是如何工作的。
- en: Calculated properties and DatePicker
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算属性和日期选择器
- en: 'We can display calculated properties based on user input. For example, to display
    a person’s age based on their date of birth, introduce class properties that calculate
    the age and display it as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据用户输入显示计算属性。例如，为了显示一个人的年龄，基于他们的出生日期，引入计算年龄的类属性，并如下显示：
- en: '[PRE27]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The implementation for the `age` property getter is not the most performant
    option. To calculate the age, we call the `getFullYear()` function of `this.now`
    and `this.dateOfBirth`. As a property referenced in the template, Angular’s change
    detection algorithm will call `age` up to 60 times per second, mixed with other
    elements on the screen, which can lead to major performance issues. You can resolve
    this issue by creating a **pure custom pipe** so that Angular understands only
    to check the `age` property if one of its dependent values changes.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`age`属性获取器的实现并不是最有效率的选项。为了计算年龄，我们调用`this.now`和`this.dateOfBirth`的`getFullYear()`函数。作为一个在模板中引用的属性，Angular的变更检测算法将每秒调用`age`多达60次，与其他屏幕上的元素混合，这可能导致严重的性能问题。你可以通过创建一个**纯自定义管道**来解决这个问题，这样Angular只会在其依赖值之一发生变化时检查`age`属性。'
- en: You can read more about pure pipes at [https://angular.dev/guide/pipes/change-detection](https://angular.dev/guide/pipes/change-detection).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://angular.dev/guide/pipes/change-detection](https://angular.dev/guide/pipes/change-detection)了解更多关于纯管道的信息。
- en: Another option would be to use **computed signals**. Like calculated properties,
    computed signals are read-only signals that derive their value from other signals.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是使用**计算信号**。与计算属性类似，计算信号是只读信号，其值来自其他信号。
- en: 'We could rewrite the code above like below:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将上面的代码重写如下：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We create `dateOfBirth` as a **signal** and `age` as a **computed signal**.
    With this setup, `age` will be updated if and only if `dateOfBirth` changes. As
    you can see, the implementation is straightforward, and Angular’s change detection
    algorithm will do the right thing by default.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`dateOfBirth`创建为一个**信号**，将`age`创建为一个**计算信号**。使用这种设置，只有当`dateOfBirth`发生变化时，`age`才会更新。正如你所看到的，实现很简单，Angular的变更检测算法将默认做正确的事情。
- en: Except for one wrinkle! Due to the absence of **signal-based components** and
    the requisite `FormGroup` support, we can’t readily use `dateOfBirth` or `age`
    in reactive forms.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 除了一个小问题！由于缺少**基于信号的组件**和必需的`FormGroup`支持，我们无法直接在响应式表单中使用`dateOfBirth`或`age`。
- en: This helps you appreciate how big a change signals are for Angular. Read more
    at [https://angular.dev/guide/signals#computed-signals](https://angular.dev/guide/signals#computed-signals).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这有助于你理解对于Angular来说，信号变化有多大。更多内容请参阅[https://angular.dev/guide/signals#computed-signals](https://angular.dev/guide/signals#computed-signals)。
- en: 'To validate a date within the last hundred years, implement a `minDate` class
    property:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证过去一百年内的日期，实现一个`minDate`类属性：
- en: '[PRE29]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The usage of the calculated properties in the template looks like this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 模板中计算属性的用法如下：
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Refer to the highlighted `[min]` and `[max]` attributes in the preceding snippet
    to apply the hundred-year date range.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 参考前面代码片段中突出显示的`[min]`和`[max]`属性，以应用一百年的日期范围。
- en: 'The `DatePicker` in action appears as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`DatePicker`的实际使用效果如下：'
- en: '![](img/B20960_08_04.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B20960_08_04.png)'
- en: 'Figure 8.4: Selecting a date with DatePicker'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4：使用DatePicker选择日期
- en: 'Note that dates beyond April 26, 2020 are grayed out. After the date is selected,
    the calculated age is displayed as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，4月26日之后的日期变灰。选择日期后，计算出的年龄将显示如下：
- en: '![](img/B20960_08_05.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B20960_08_05.png)'
- en: 'Figure 8.5: Calculated age property'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5：计算年龄属性
- en: Now, let’s move on to the next step, **Contact Information**, and see how we
    can enable a convenient way to display and input the state portion of the address
    field.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续下一步，**联系信息**，看看我们如何能够方便地显示和输入地址字段的状态部分。
- en: Typeahead support
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型提示支持
- en: 'In `buildForm`, we set a listener on `address.state` to support a typeahead
    filtering drop-down experience:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在`buildForm`中，我们为`address.state`设置一个监听器，以支持类型提示过滤下拉体验：
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'On the template, implement `mat-autocomplete`, bound to the filtered states
    array with an `async` pipe:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中，实现`mat-autocomplete`，通过`async`管道绑定到过滤后的状态数组：
- en: '[PRE32]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here’s how it looks when a user enters the character `V`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户输入字符`V`时，它看起来是这样的：
- en: '![](img/B20960_08_06.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B20960_08_06.png)'
- en: 'Figure 8.6: Dropdown with typeahead support'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6：具有类型提示支持的下拉菜单
- en: In the next section, let’s enable the input of multiple phone numbers.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，让我们启用多个电话号码的输入。
- en: Dynamic form arrays
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态表单数组
- en: 'Note that the `phones` property is an array, potentially allowing for many
    inputs. We can implement this by building a `FormArray` with the `this.formBuilder.array`
    function. We also define several helper functions to make it easier to build the
    `FormArray`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`phones` 属性是一个数组，可能允许有多个输入。我们可以通过使用 `this.formBuilder.array` 函数构建 `FormArray`
    来实现这一点。我们还定义了几个辅助函数，以使构建 `FormArray` 更加容易：
- en: '`buildPhoneFormControl` helps to build `FormGroup` objects of individual entries.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buildPhoneFormControl` 有助于构建单个条目的 `FormGroup` 对象。'
- en: '`buildPhoneArray` creates as many `FormGroup` objects as needed, or if the
    form is empty, it creates an empty entry.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buildPhoneArray` 会创建所需数量的 `FormGroup` 对象，或者如果表单为空，则创建一个空条目。'
- en: '`addPhone` adds a new empty `FromGroup` object to the `FormArray`.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addPhone` 向 `FormArray` 添加一个新的空 `FormGroup` 对象。'
- en: '`get phonesArray()` is a convenient property to get the `phones` control from
    the form.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get phonesArray()` 是一个方便的属性，用于从表单中获取 `phones` 控件。'
- en: 'Let’s see how the implementation comes together:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实现是如何结合在一起的：
- en: '[PRE33]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`buildPhoneArray` supports the initialization of a form with a single phone
    input or by filling it with the existing data, working in tandem with `buildPhoneFormControl`.
    The latter function comes in handy when a user clicks on an **Add** button to
    create a new row for the entry:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`buildPhoneArray` 支持使用单个电话输入初始化表单，或者通过填充现有数据来实现，与 `buildPhoneFormControl` 一起工作。当用户点击
    **Add** 按钮创建新行时，后者非常有用：'
- en: '[PRE34]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `phonesArray` property getter is a common pattern that makes accessing
    certain form properties easier. However, in this case, it is also necessary because
    `get(''phones'')` must be typecast to `FormArray` so that we can access the `length`
    property on it on the template:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`phonesArray` 属性的获取器是一个常见的模式，它使得访问某些表单属性变得更加容易。然而，在这种情况下，它也是必要的，因为 `get(''phones'')`
    必须转换为 `FormArray` 类型，这样我们才能在模板上访问其 `length` 属性：'
- en: '[PRE35]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note the highlighted `convertTypeToPhoneType` function, which converts a `string`
    to `enum PhoneType`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 注意突出显示的 `convertTypeToPhoneType` 函数，它将 `string` 转换为 `enum PhoneType`。
- en: Also highlighted in the preceding code block is how the `remove` function is
    implemented inline in the template, making it easier to read and maintain.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，还突出了 `remove` 函数是如何在模板中内联实现的，这使得它更容易阅读和维护。
- en: 'Let’s see how the dynamic array should be working:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看动态数组应该如何工作：
- en: '![](img/B20960_08_07.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B20960_08_07.png)'
- en: 'Figure 8.7: Multiple inputs using FormArray'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7：使用 FormArray 的多个输入
- en: Now that we’re done inputting data, we can move on to the last step of the stepper,
    **Review**. However, as was mentioned earlier, the **Review** step uses the `<app-view-user>`
    directive to display its data. Let’s build that view first.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了数据输入，我们可以继续到步骤器的最后一步 **Review**。然而，如前所述，**Review** 步骤使用 `<app-view-user>`
    指令来显示其数据。让我们首先构建这个视图。
- en: Creating shared components
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建共享组件
- en: Here’s a minimal implementation of the `<app-view-user>` directive, a prerequisite
    for the **Review** step.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `<app-view-user>` 指令的最小实现，这是 **Review** 步骤的先决条件。
- en: 'Create a new `viewUser` component under the `user` folder structure, as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `user` 文件夹结构下创建一个新的 `viewUser` 组件，如下所示：
- en: '[PRE36]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The preceding component uses input binding with `@Input` to get user data compliant
    with the `IUser` interface from an outside component. We implement the `ngOnChanges`
    lifecycle hook, which fires whenever the bound data changes. In this event, we
    hydrate the simple JSON object stored in the `user` property as an instance of
    the `User` class with `User.Build`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的组件使用 `@Input` 输入绑定来从外部组件获取符合 `IUser` 接口的用户数据。我们实现了 `ngOnChanges` 生命周期钩子，它在绑定数据更改时触发。在这个事件中，我们使用
    `User.Build` 将存储在 `user` 属性中的简单 JSON 对象作为 `User` 类的实例进行填充。
- en: We then assign the `User` object to the property `this.currentUser`. Even if
    we wanted to, we couldn’t directly bind to the user property, because calculated
    properties such as `fullName` can only work if data is hydrated into an instance
    of the `User` class. Angular 17.1 introduces signal-based inputs in developer
    preview. We could define user like `user = input<IUser>()` and leverage effect
    and a computed signal to streamline our implementation. In the current state of
    our code, we incur a heavy change detection penalty given the number of properties
    we’re binding to. However in signal-based component there would be no such penalty.
    I look forward to refactoring this component, when signal-based components are
    released.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are ready to complete the multi-step form.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing and saving form data
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On the last step of the multistep form, users should be able to review and
    then save the form data. As a good practice, a successful `POST` request will
    return the data that was saved back to the browser. We can then reload the form
    with the information received back from the server:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note that `updateUser` returns the saved value of the user. It is possible that
    the database returns a different version of `user` than what we had before, so
    we use `formGroup.patchValue` to update the data powering the form. The form automatically
    updates to reflect any changes.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'If there are errors when saving the data, they’ll be set to `userError` to
    be displayed on the form. Before saving the data, we present it in a compact format
    with the reusable `app-view-user` component, which we can bind the form data to:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note that we use `formGroup.getRawValue()` to extract the JSON of the form data.
    See how we bind `userError` to display error messages. Also, the **Reset** button
    uses `stepper.reset()`, which can conveniently reset all the user input.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how the final product should appear:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B20960_08_08.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.8: Review step'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Now that the user profile input is done, we are about halfway to our eventual
    goal of creating a master/detail view where a **Manager** can click on a user
    and view their profile details. We still have a lot more code to add, and along
    the way, we have fallen into a pattern of adding lots of boilerplate code to load
    the requisite data for a component.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s refactor our form to make our code reusable and scalable, so even
    if our form has dozens of fields, the code is still maintainable, and we don’t
    introduce an exponential cost increase to make changes.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Scalable form architecture with reusable parts
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in the introduction to the *Multi-step responsive forms* section,
    forms are tightly coupled beasts that can grow large, and using the wrong architectural
    pattern to scale your implementation can cause significant issues when implementing
    new features or maintaining existing ones.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate how you can break up your form into multiple parts, we will
    refactor it to extract the highlighted section in the following screenshot, the
    name `FormGroup`, as its own component. The technique to accomplish this is the
    same as you’d use when you want to put each step of your form into a separate
    component:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示如何将你的表单拆分成多个部分，我们将重构它，提取以下截图中的突出部分，即名称`FormGroup`，作为一个单独的组件。完成这一点的技术与你想要将表单的每一步放入单独组件时使用的技术相同：
- en: '![](img/B20960_08_09.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B20960_08_09.png)'
- en: 'Figure 8.9: User profile’s name part highlighted'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9：用户个人资料名称部分被突出显示
- en: By making the name `FormGroup` reusable, you will also learn about how you can
    reuse the business logic that you build into that `FormGroup` in other forms.
    We will extract the name `FormGroup` logic into a new component named `NameInputComponent`.
    In doing so, we also have an opportunity to extract some reusable form functionality
    to a `BaseFormComponent` as an `abstract` `class`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使`FormGroup`名称可重用，你还将了解如何将你构建到`FormGroup`中的业务逻辑在其他表单中重用。我们将把`FormGroup`逻辑提取到一个名为`NameInputComponent`的新组件中。在这个过程中，我们也有机会将一些可重用的表单功能提取到`BaseFormComponent`作为一个`抽象`类。
- en: There are going to be several components that are working together here, including
    `ProfileComponent`, `ViewUserComponent`, and `NameInputComponent`. We need all
    the values in these three components to be up to date as the user enters them.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这里将会有几个组件协同工作，包括`ProfileComponent`、`ViewUserComponent`和`NameInputComponent`。我们需要这三个组件中的所有值在用户输入时保持最新。
- en: '`ProfileComponent` will own the master form to which we’ll need to register
    any child form. Once we do this, all the form validation techniques you’ve learned
    so far will still apply.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProfileComponent`将拥有主表单，我们需要将任何子表单注册到这个主表单上。一旦完成注册，你之前学到的所有表单验证技术仍然适用。'
- en: 'This is a key way to make your form able to scale across many components and
    continue to be easy to work with, without introducing unnecessary validation overhead.
    Hence, it is useful to review the different interactions between these objects
    to solidify your understanding of the asynchronous and decoupled nature of their
    behavior:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种关键的方法，可以使你的表单能够在许多组件之间扩展，并且继续易于操作，同时不会引入不必要的验证开销。因此，回顾这些对象之间的不同交互对于巩固你对它们行为异步和解耦性质的理解是有用的：
- en: '![](img/B20960_08_10.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B20960_08_10.png)'
- en: 'Figure 8.10: Form component interactions'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10：表单组件交互
- en: In this section, we combine many of the concepts you’ve learned throughout the
    book. Utilize the preceding diagram to understand how the various form components
    interact.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将结合你在本书中学到的许多概念。利用前面的图来理解各种表单组件之间的交互。
- en: In the preceding diagram, properties in bold indicate data binding. Underlined
    function elements indicate event registrations. Arrows show the points of connection
    between the components.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，粗体属性表示数据绑定。下划线函数元素表示事件注册。箭头显示了组件之间的连接点。
- en: The workflow begins with the instantiation of `ProfileComponent`. The `OnInit`
    event of the component begins building the `formGroup` object, while asynchronously
    loading any potential `initialData` that may need to be patched into the forms.
    Refer to the preceding diagram for a visual representation of `initialData` coming
    in from a service or cache.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流程从`ProfileComponent`的实例化开始。组件的`OnInit`事件开始构建`formGroup`对象，同时异步加载可能需要修补到表单中的任何潜在`initialData`。参考前面的图来查看从服务或缓存中进入的`initialData`的视觉表示。
- en: '`NameInputComponent` is used in the `ProfileComponent` form as `<app-name-input>`.
    To synchronize `initialData` with the `NameInputComponent`, we bind a `nameInitialData$`
    subject using the `async` pipe, since `initialData` comes in asynchronously.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`NameInputComponent`在`ProfileComponent`表单中作为`<app-name-input>`使用。为了将`initialData`与`NameInputComponent`同步，我们使用`async`管道绑定一个`nameInitialData$`主题，因为`initialData`是异步到达的。'
- en: '`NameInputComponent` implements the `OnChanges` lifecycle hook, so whenever
    `nameInitialData$` updates, its value is patched into the `NameInputComponent`
    form.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`NameInputComponent`实现了`OnChanges`生命周期钩子，所以每当`nameInitialData$`更新时，其值就会被修补到`NameInputComponent`表单中。'
- en: Like `ProfileComponent`, `NameInputComponent` also implements the `OnInit` event
    to construct its `formGroup` object. Since this is an asynchronous event, `NameInputComponent`
    needs to expose a `formReady` event that `ProfileComponent` can subscribe to.
    Once the `formGroup` object is ready, we emit the event and the `registerForm`
    function on `ProfileComponent` triggers. `registerForm` adds the `formGroup` object
    of `NameInputComponent` as a child element to the parent `formGroup` on `ProfileComponent`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '`ViewUserComponent` is used in the `ProfileComponent` form as `<app-view-user>`.
    When the values in the parent form change, we need `<app-view-user>` to stay current.
    We bind to the `user` property on `ViewUserComponent`, which implements `OnChanges`
    to receive updates. Every time there is an update, the `User` object is hydrated
    from the `IUser` object, so calculated fields such as `fullName` can continue
    working. The updated `User` is then assigned to `currentUser`, bound to the template..'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: We will begin by building a `BaseFormComponent`, which `NameInputComponent`
    and `ProfileComponent` will then implement.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Abstract form component
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can share common functionality and standardize the implementation of all
    components that implement a form by implementing a base abstract class. An abstract
    class cannot be instantiated on its own because it wouldn’t make sense to do so,
    since it will not have a template, making it useless on its own.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Note that `BaseFormComponent` is just a `class` and not an Angular component.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '`BaseFormComponent` will standardize the following:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '`@Input initialData` and `disable` as binding targets'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@Output formReady` event
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`formGroup`, and the `FormGroup` to be used in the template’s `buildForm` function
    to build the `formGroup`'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With the preceding assumptions, the base class can provide some generic functionality:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '`patchUpdatedData` can update the data (partially or fully) in the `formGroup`
    without rebuilding it.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`registerForm` and `deregisterForm` can register or deregister child forms.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deregisterAllForms` can automatically deregister any registered child form.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hasChanged` can determine whether `initialData` has changed, given a `SimpleChange`
    object provided by the `ngOnChange` event handler.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`patchUpdatedDataIfChanged` leverages `hasChanged` and uses `patchUpdatedData`
    to update the data if, and only if, there has been an update to `initialData`
    and `formGroup` is already initialized.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a new class, `BaseFormComponent`, under `src/common` as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Let’s implement `NameInputComponent` using the `BaseFormComponent`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a reusable form part
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start by identifying the name `FormGroup` in the `profile` component code and
    template files:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the name `FormGroup` implementation:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note that when we move these validation rules to a new component, we still want
    them to be in effect when determining the overall validation status of the parent
    form. We achieve this using the `registerForm` function we implemented in the
    previous section. Once our new `FormGroup` is registered with the existing one,
    they work the same way as before our refactor.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'Next is the name `FormGroup` template:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You will be moving most of this code to the new component.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `NameInputComponent` under the `user` folder.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extend the class from `BaseFormComponent`.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inject `FormBuilder` into the `constructor`:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For components with small or limited pieces of functionality, I prefer creating
    them with an inline template and styling so that it is easier to change the code
    from one place.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Remember that the base class already implements the `formGroup`, `initialData`,
    `disable`, and `formReady` properties, so you don’t need to redefine them.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Note that we must implement the `buildForm` function, since it was defined as
    abstract. This is a great way to enforce standards across developers. Also, note
    that the implementing class can override any base function provided by simply
    redefining the function with the `override` keyword. You’ll see this in action
    when we refactor the `ProfileComponent`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `buildForm` function.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the `name` property part of the `formGroup` in `ProfileComponent` to `null`:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Implement the template by bringing over the content from `ProfileComponent`:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Implement the `ngOnInit` event handler:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Getting the `ngOnInit` event handler’s implementation right in every `BaseFormComponent`
    implementation is critical. The preceding example is fairly standard behavior
    for any `child` component you may implement.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Note that the implementation in `ProfileComponent` will be a bit different.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `ngOnChanges` event handler, leveraging the base `patchUpdatedDataIfChanged`
    behavior:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note that in `patchUpdatedDataIfChanged`, setting `onlySelf` to `false` will
    cause the parent form also to update. You can override the function if you’d like
    to optimize this behavior.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Now, you have a fully implemented `NameInputComponent` that you can integrate
    into `ProfileComponent`.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: To verify your `ProfileComponent` code going forward, refer to `projects/stage11/src/app/user/profile/profile.component.ts`
    and `projects/stage11/src/app/user/profile/profile.component.html`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Before you begin using `NameInputComponent`, perform the following refactors.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Refactor `ProfileComponent` to extend `BaseFormComponent` and conform to its
    default values as needed.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a readonly `nameInitialData$` property with the `BehaviorSubject<IName>`
    type, and initialize it with empty strings.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the content in `ProfileComponent` with the new `<app-name-input>` component:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note that the base form component function, `registerForm`, is leveraged here.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure that your `ngOnInit` is implemented correctly:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that some additional refactors are present on the updated `ProfileComponent`,
    such as the `patchUser` function seen in the following snippet. Don’t miss these
    updates when you update your component.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: It is important to update the current form’s data with `pathUpdatedData`, as
    well as `nameInitialData$`, when there’s an update to `initialData`.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure that `ngOnDestroy` is implemented correctly:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: You can leverage the base class functionality to deregister from all child forms
    automatically.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s learn about masking user input to increase our data quality.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Input masking
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Masking user input is an input UX tool and also a data quality one. I’m a fan
    of the `ngx-mask` library, which makes it easy to implement input masking in Angular.
    We will demonstrate input masking by updating the phone number input field, ensuring
    that users input a valid phone number, as shown in the following screenshot:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B20960_08_11.png)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.11: Phone number field with input masking'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up your input masking as follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Install the library via npm with `npm i ngx-mask`.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Either use the environment provider, `provideEnvironmentNgxMask()`, in `app.config.ts`
    or `provideNgxMask()` in your feature module, `user.module.ts`.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `NgxMaskDirective` in `profile.component.html`:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the `number` field in `ProfileComponent` as follows:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: And it’s that simple. You can learn more about the module and its capabilities
    on GitHub at [https://github.com/JsDaddy/ngx-mask](https://github.com/JsDaddy/ngx-mask).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Custom controls with ControlValueAccessor
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we’ve learned about forms using standard form controls and input controls
    provided by Angular Material. However, it is possible for you to create custom
    user controls. If you implement the `ControlValueAccessor` interface, then your
    custom controls will play nicely with forms and the `ControlValueAccessor` interface’s
    validation engine.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be creating the custom rater control shown in the following screenshot
    and will place it as a control on the first step of `ProfileComponent`:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B20960_08_12.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.12: The lemon rater user control'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: User controls are inherently highly reusable, tightly coupled, and customized
    components to enable rich user interactions. Let’s implement one.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a custom rating control
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Lemon Rater will dynamically highlight the number of lemons selected as
    the user interacts with the control in real time. As such, creating a high-quality
    custom control is an expensive endeavor. However, it is entirely worthwhile to
    spend the effort on elements of your application that define your brand and/or
    make up the core of the UX.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: The Lemon Rater is a modified version of Jennifer Wadella’s Galaxy Rating App
    sample found at [https://github.com/tehfedaykin/galaxy-rating-app](https://github.com/tehfedaykin/galaxy-rating-app).
    I highly recommend watching Jennifer’s Ng-Conf 2019 talk on `ControlValueAccessor`,
    linked in the *Further reading* section.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up your custom rating control as follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: Generate a new component called `LemonRater` under the `user-controls` folder.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `LemonRater`, implement the `ControlValueAccess` interface:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Add the `NG_VALUE_ACCESSOR` provider with the `multi` property set to `true`.
    This will register our component with the form’s change events, so form values
    can be updated when the user interacts with the rater:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '`forwardRef` allows us to refer to components not yet defined. There’s more
    at [https://angular.dev/api/core/forwardRef](https://angular.dev/api/core/forwardRef).'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement a custom rating scheme with a function, allowing us to set the selected
    rating based on user input:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note that by using `@ViewChild`, we’re getting the HTML element named `#displayText`
    (highlighted in the following template). Using `setSelectText`, we replace the
    `textContent` of the element.
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement the template, referring to the sample code for the contents of the
    `svg` tag:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The three most important attributes in the template are `mouseover`, `mouseout`,
    and `click`. The `mouseover` attribute displays the text for the rating the user
    is currently hovering over, `mouseout` resets the display text to the selected
    value, and `click` calls the `setRating` method we implemented to record the user’s
    selection. However, the control can have even richer user interactivity by highlighting
    the number of lemons when the user hovers over a rating or selects it. We will
    accomplish this via some CSS magic.
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement the CSS for the user control:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The most interesting bit is with `.lemons .lemon:hover~.lemon #fill-area`.
    Note that the operator `~` , or the general sibling combinator, selects a range
    of elements so that a dynamic number of lemons will be highlighted as the user
    hovers over them.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '`#fill-area` refers to a `<path>` defined within the lemon .`svg`, allowing
    the lemon’s color to be adjusted dynamically. I had to manually inject this ID
    field into the .`svg` file.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s see how you can use this new user control in a form.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Using custom controls in forms
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use the lemon rater in the `profile` component to capture the Limoncu
    level of the employee.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: Limoncu is a Turkish word for a person who grows or sells lemons, and it is
    also LemonMart’s proprietary employee engagement and performance measurement system.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s integrate the lemon rater:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: Start by importing the `LemonRaterComponent` in `profile.component.ts`.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Ensure that the level form control is initialized in `buildForm`:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Insert the lemon rater as the last element of the first `mat-step`, inside
    the `form` element:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We integrate with the custom control by implementing `formControlName` like
    any other control.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You should have a working custom control that is integrated
    with your form.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Layouts using a grid list
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Flex Layout library is great for laying out content using CSS Flexbox.
    Angular Material provides another mechanism to lay out content, using CSS Grid
    with its Grid List functionality. A good way to demonstrate this functionality
    is by implementing a helpful list of fake login information in the `LoginComponent`,
    demonstrated here:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B20960_08_13.png)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.13: Login helper with the grid list'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement your list as follows:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by defining a `roles` property that is an array of all the roles:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Import `MatExpansionModule` and `MatGridListModule` in `login.component.ts`.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement a new `mat-card-content` below the existing one:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Inside the new `mat-card-content`, put in a label to display the authentication
    mode:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Beneath the label, implement an expansion list:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'After `mat-expansion-panel-header`, in the area marked with ellipses in the
    preceding step, implement a table of roles and email addresses, along with some
    hint text regarding password length, using `mat-grid-list`, as shown in the following
    code block:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We use `colspan` to control the width of each row and cell. We leverage `fxLayoutAlign`
    to right-align the contents of the **E-mail** column. We use `@if; @else` control
    flow operators to selectively display content. Finally, a **Fill** button helps
    us to populate the login form with fake login information.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: In your application, you can use an expansion panel to communicate password
    complexity requirements to your users.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about expansion panels at [https://material.angular.io/components/expansion](https://material.angular.io/components/expansion)
    and Grid List at [https://material.angular.io/components/grid-list/overview](https://material.angular.io/components/grid-list/overview).
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: Restoring cached data
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the beginning of the chapter, when implementing the `updateUser` method
    in `UserService`, we cached the `user` object in case of any errors that may wipe
    out user-provided data:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Consider a scenario where the user may be temporarily offline when they attempt
    to save their data. In this case, our `updateUser` function will save the data.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how we can restore this data in `ProfileComponent` when loading the
    user profile:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding functions named `loadFromCache` and `clearCache` to the `ProfileComponent`
    class:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: After loading the data, we parse the data into a JSON object, using `JSON.parse`,
    and then hydrate the `User` object with `User.Build`.
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the template to call the `clearCache` function so that when the user
    resets the form, we also clear the cache:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Update `ngOnInit` to conditionally load data from the cache or the latest `currentUser$`
    from `authService`:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We leverage the `combineLatest` operator to combine the outputs of `loadFromCache`
    and `currentUser$`. We check that one of the streams returns a non-null value.
    If a cached user exists, it precedes the value received from `currentUser$`.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: 'You can test your cache by setting the network status of your browser to offline,
    as shown here:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B20960_08_14.png)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.14: Offline network status'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the network status of your browser to offline as follows:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: In Chrome DevTools, navigate to the **Network** tab.
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Offline** in the dropdown marked as **2** in the preceding screenshot.
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the form data, such as the name, and hit **Update**.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You’ll see an error reading **An unknown error has occurred**, displayed at
    the bottom of the form.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You’ll see that your PUT request has failed in the **Network** tab.
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, refresh your browser window, and observe that the new name you entered
    is still present.
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Refer to the following screenshot, which shows the toast notification you get
    after loading data from the cache:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B20960_08_15.png)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.15: Data loaded from the cache'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a great caching UX is incredibly challenging. I provided a rudimentary
    method to show what is possible. However, many edge cases can impact how caching
    in your application works.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: In my case, the cache stubbornly sticks around until we successfully save the
    data to the server. This may be frustrating for some users.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You’ve successfully implemented a sophisticated form to capture
    data from your users!
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Practice new concepts like signals and `@defer` in Angular by updating `UserService`
    and the multi-step `ProfileComponent` form:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: Update `UserService` and its related components to use `signal` instead of `BehaviorSubject`.
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `@defer` to delay the rendering of conditional views.
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement an expansion panel in `LoginComponent` to communicate password complexity
    requirements to your users.
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-423
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered forms, directives, and user control-related functionality
    for LemonMart. Using data binding, we created reusable components that can be
    embedded within another component. We showed that you can use PUT to send data
    to a server and cache data input by a user. We also created a multi-step input
    form that is responsive to changing screen sizes. We removed the boilerplate code
    from our components by leveraging reusable form parts, a base form class to house
    common functionality, and an attribute directive to encapsulate field-level error
    behavior and messages.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: We created dynamic form elements with a date picker, typeahead support, and
    form arrays. We implemented interactive controls with input masking and the lemon
    rater. Using the `ControlValueAccessor` interface, we integrated the lemon rater
    seamlessly with our form. We showed that we can scale the size and complexity
    of our forms linearly by extracting the name as its form section. Additionally,
    we covered building layouts using a grid list.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will further enhance our components to orchestrate them
    using the router. We will also implement a master/detail view and a data table
    and explore NgRx as an alternative to RxJS/BehaviorSubject.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-427
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Reactive forms*, 2024: [https://angular.dev/guide/forms/reactive-forms](https://angular.dev/guide/forms/reactive-forms)'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Attribute directives*, 2024: [https://angular.dev/guide/directives/attribute-directives](https://angular.dev/guide/directives/attribute-directives)'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Meet Angular’s New Control Flow*, 2023: [https://blog.angular.io/meet-angulars-new-control-flow-a02c6eee7843](https://blog.angular.io/meet-angulars-new-control-flow-a02c6eee7843
    )'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*rxweb: Good way to show the error messages in Angular Reactive Forms*, Ajay
    Ojha, 2019: [https://medium.com/@oojhaajay/rxweb-good-way-to-show-the-error-messages-in-angular-reactive-forms-c27429f51278](https://medium.com/@oojhaajay/rxweb-good-way-to-show-the-error-messages-in-angular-reactive-forms-c27429f51278)'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Control Value Accessor*, Jennifer Wadella, 2019: [https://www.youtube.com/watch?v=kVbLSN0AW-Y](https://www.youtube.com/watch?v=kVbLSN0AW-Y)'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*CSS Combinators*, 2020: [https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors#Combinators](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors#Combinators
    )'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Memoization in JavaScript*, Sumit Kumar Singh, 2023: [https://designtechworld.medium.com/memoization-in-javascript-282d5fad29c8](https://designtechworld.medium.com/memoization-in-javascript-282d5fad29c8
    )'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Why you should never use function calls in Angular template expressions*,
    Jurgen Van de Moere, 2019: [https://medium.com/showpad-engineering/why-you-should-never-use-function-calls-in-angular-template-expressions-e1a50f9c0496](https://medium.com/showpad-engineering/why-you-should-never-use-function-calls-in-angular-template-expressions-e1a50f9c0496)'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions as best as possible to ensure you’ve understood
    the key concepts from this chapter without googling anything. Do you know if you
    got all the answers right? Visit [https://angularforenterprise.com/self-assessment](https://angularforenterprise.com/self-assessment)
    for more:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between a component and a user control?
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an attribute directive?
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the `@`-syntax?
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of the `ControlValueAccessor` interface?
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is serialization, deserialization, and hydration?
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does it mean to patch values on a form?
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you associate two independent `FormGroup` objects with each other?
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
