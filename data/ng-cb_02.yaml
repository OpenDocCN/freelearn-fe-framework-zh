- en: '*Chapter 2*: Understanding and Using Angular Directives'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第2章*：理解和使用Angular指令'
- en: In this chapter, you'll learn about Angular directives in depth. You'll learn
    about attribute directives, with a really good real-world example of using a highlight
    directive. You'll also write your first structural directive and see how `ViewContainer`
    and `TemplateRef` services work together to add/remove elements from the **Document
    Object Model** (**DOM**), just as in the case of `*ngIf`, and you'll create some
    really cool attribute directives that do different tasks. Finally, you'll learn
    how to use multiple structural directives on the same **HyperText Markup Language**
    (**HTML**) element and how to enhance template type checking for your custom directives.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将深入了解Angular指令。您将学习关于属性指令，使用一个非常好的真实世界示例来使用高亮指令。您还将编写您的第一个结构指令，并了解`ViewContainer`和`TemplateRef`服务如何一起工作，以从**文档对象模型**（**DOM**）中添加/删除元素，就像`*ngIf`的情况一样，并创建一些真正酷炫的属性指令来执行不同的任务。最后，您将学习如何在同一个**超文本标记语言**（**HTML**）元素上使用多个结构指令，以及如何增强自定义指令的模板类型检查。
- en: 'Here are the recipes we''re going to cover in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章我们将要涵盖的食谱：
- en: Using attribute directives to handle the appearance of elements
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用属性指令来处理元素的外观
- en: Creating a directive to calculate the read time for articles
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个用于计算文章阅读时间的指令
- en: Creating a basic directive that allows you to vertically scroll to an element
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个基本指令，允许您垂直滚动到一个元素
- en: Writing your first custom structural directive
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写您的第一个自定义结构指令
- en: How to use `*ngIf` and `*ngSwitch` together
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何同时使用`*ngIf`和`*ngSwitch`
- en: Enhancing template type checking for your custom directives
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强自定义指令的模板类型检查
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For the recipes in this chapter, make sure you have **Git** and **Node.js**
    installed on your machine. You also need to have the `@angular/cli` package installed,
    which you can do with `npm install -g @angular/cli` from your terminal. The code
    for this chapter can be found at [https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter02](https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter02).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的食谱，请确保您的机器上安装了**Git**和**Node.js**。您还需要安装`@angular/cli`包，您可以在终端中使用`npm install
    -g @angular/cli`来安装。本章的代码可以在[https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter02](https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter02)找到。
- en: Using attribute directives to handle the appearance of elements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用属性指令来处理元素的外观
- en: In this recipe, you'll work with an Angular attribute directive named **highlight**.
    With this directive, you'll be able to search words and phrases within a paragraph
    and highlight them on the go. The whole paragraph's container background will
    also be changed when we have a search in action.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，您将使用名为**highlight**的Angular属性指令。使用这个指令，您将能够在段落中搜索单词和短语，并在进行搜索时将它们高亮显示。当我们进行搜索时，整个段落的容器背景也会改变。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project we are going to work with resides in `chapter02/start_here/ad-attribute-directive`,
    inside the cloned repository:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的项目位于克隆存储库中的`chapter02/start_here/ad-attribute-directive`中：
- en: Open the project in **Visual Studio Code** (**VS Code**).
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Visual Studio Code**（**VS Code**）中打开项目。
- en: Open the terminal, and run `npm install` to install the dependencies of the
    project.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，并运行`npm install`来安装项目的依赖。
- en: Once done, run `ng serve -o`.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。
- en: 'This should open the app in a new browser tab, and you should see something
    like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签中打开应用程序，你应该会看到类似这样的东西：
- en: '![Figure 2.1 – ad-attribute-directives app running on http://localhost:4200'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.1 - ad-attribute-directives应用程序运行在http://localhost:4200'
- en: '](image/Figure_2.01_B15150.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_2.01_B15150.jpg)'
- en: Figure 2.1 – ad-attribute-directives app running on http://localhost:4200
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 - 在http://localhost:4200上运行的ad-attribute-directives应用程序
- en: How to do it…
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'So far, the app has a search input box and a paragraph text. We need to be
    able to type a search query into the search box so that we can highlight the matching
    text in the paragraph. Here are the steps on how we achieve this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，该应用程序具有搜索输入框和段落文本。我们需要能够在搜索框中输入搜索查询，以便我们可以在段落中突出显示匹配的文本。以下是我们实现这一点的步骤：
- en: 'We''ll create a property named `searchText` in the `app.component.ts` file
    that we''ll use as a **model** for the search-text input:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在`app.component.ts`文件中创建一个名为`searchText`的属性，我们将用作搜索文本输入的**模型**：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, we use this `searchText` property in the `app.component.html` file with
    the search input as a `ngModel`, as follows:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在`app.component.html`文件中使用`searchText`属性作为`ngModel`的搜索输入，如下所示：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Important note
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Notice that `ngModel` doesn't work without `FormsModule`, and so we've already
    imported `FormsModule` into our `app.module.ts` file.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`ngModel`没有`FormsModule`无法工作，因此我们已经将`FormsModule`导入到我们的`app.module.ts`文件中。
- en: 'Now, we''ll create an **attribute directive** named `highlight` by using the
    following command inside our `ad-attributes-directive` project:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将通过在`ad-attributes-directive`项目中使用以下命令来创建一个名为`highlight`的**属性指令**：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding command generated a directive that has a selector called `appHighlight`.
    See the *How it works…* section for why that happens. Now that we have the directive
    in place, we''ll create two inputs for the directive to be passed from `AppComponent`
    (from `app.component.html`)—one for the search text and another for the highlight
    color. The code should look like this in the `highlight.directive.ts` file:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述命令生成了一个具有名为`appHighlight`的选择器的指令。请参阅*它是如何工作的…*部分，了解为什么会发生这种情况。现在我们已经放置了指令，我们将为指令创建两个输入，以从`AppComponent`（从`app.component.html`）传递
    - 一个用于搜索文本，另一个用于突出显示颜色。在`highlight.directive.ts`文件中，代码应如下所示：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Since we have the inputs in place now, let''s use the `appHighlight` directive
    in `app.component.html` and pass the `searchText` model from there to the `appHighlight`
    directive:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们现在已经放置了输入，让我们在`app.component.html`中使用`appHighlight`指令，并将`searchText`模型从那里传递到`appHighlight`指令：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We''ll listen to the input changes now for the `searchText` input, using `ngOnChanges`.
    Please see the *Using ngOnChanges to intercept input property changes* recipe
    in [*Chapter 1*](B15150_01_Final_JC_ePub.xhtml#_idTextAnchor014)*, Winning Components
    Communication**,* for how to listen to input changes. For now, we''ll only do
    a `console.log` when the input changes:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将监听`searchText`输入的输入更改，使用`ngOnChanges`。请参阅[*第1章*](B15150_01_Final_JC_ePub.xhtml#_idTextAnchor014)*，Winning
    Components Communication**,*中的*使用ngOnChanges拦截输入属性更改*一节，了解如何监听输入更改。现在，当输入更改时，我们只会执行`console.log`：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we''ll write some logic for what to do when we actually have something
    to search for. For this, we''ll first import the `ElementRef` service so that
    we can get access to the template element on which our directive is applied. Here''s
    how we''ll do this:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将编写一些逻辑，以便在实际有东西要搜索时该怎么做。为此，我们将首先导入`ElementRef`服务，以便我们可以访问应用指令的模板元素。以下是我们将如何做到这一点：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we''ll replace every matching text in our `el` element with a custom `<span>`
    tag with some hardcoded styles. Update your `ngOnChanges` code in `highlight.directive.ts`
    as follows, and see the result:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将用一些硬编码的样式替换`el`元素中的每个匹配文本。更新`highlight.directive.ts`中的`ngOnChanges`代码如下，并查看结果：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: You'll notice that if you type a word, it will still just show only one letter
    highlighted. That's because whenever we replace the `innerHTML` property, we end
    up changing the original text. Let's fix that in the next step.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，如果您输入一个单词，它仍然只会显示一个字母被突出显示。这是因为每当我们替换`innerHTML`属性时，我们最终会改变原始文本。让我们在下一步中修复这个问题。
- en: 'To keep the original text intact, let''s create a property name of `originalHTML`
    and assign an initial value to it on the first change. We''ll also use the `originalHTML`
    property while replacing the values:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了保持原始文本不变，让我们创建一个名为`originalHTML`的属性，并在第一次更改时为其分配一个初始值。我们还将在替换值时使用`originalHTML`属性：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we''ll write some logic to reset everything back to the `originalHTML`
    property when we remove our search query (when the search text is empty). In order
    to do so, let''s add an `else` condition, as follows:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将编写一些逻辑，当我们删除搜索查询时（当搜索文本为空时），将一切重置回`originalHTML`属性。为了这样做，让我们添加一个`else`条件，如下所示：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works…
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We create an attribute directive that takes the `highlightText` and `highlightColor`
    inputs and then listens to the input changes for the `highlightText` input using
    the `SimpleChanges` **application programming interface** (**API**) and the `ngOnChanges`
    life cycle hook.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个属性指令，接受`highlightText`和`highlightColor`输入，然后使用`SimpleChanges` **应用程序编程接口**
    (**API**) 和`ngOnChanges`生命周期钩子监听`highlightText`输入的更改。
- en: First, we make sure to save the original content of the target element by getting
    the attached element using the `ElementRef` service, using the `.nativeElement.innerHTML`
    on the element, and then saving it to `originalHTML` property of the directive.
    Then, whenever the input changes, we replace the text with an additional HTML
    element (a `<span>` element) and add the background color to this `span` element.
    We then replace the `innerHTML` property of the target element with this modified
    version of the content. That's all the magic!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们要确保通过使用`ElementRef`服务获取附加的元素来保存目标元素的原始内容，使用元素上的`.nativeElement.innerHTML`，然后将其保存到指令的`originalHTML`属性中。然后，每当输入发生变化时，我们将文本替换为一个额外的HTML元素（一个`<span>`元素），并将背景颜色添加到这个`span`元素。然后，我们用这个修改后的内容替换目标元素的`innerHTML`属性。就是这样神奇！
- en: See also
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Testing Angular attribute directives documentation ([https://angular.io/guide/testing-attribute-directives](https://angular.io/guide/testing-attribute-directives))
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试Angular属性指令文档([https://angular.io/guide/testing-attribute-directives](https://angular.io/guide/testing-attribute-directives))
- en: Creating a directive to calculate the read time for articles
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个指令来计算文章的阅读时间
- en: 'In this recipe, you''ll create an attribute directive to calculate the read
    time of an article, just like Medium. The code for this recipe is highly inspired
    by my existing repository on GitHub, which you can view at the following link:
    [https://github.com/AhsanAyaz/ngx-read-time](https://github.com/AhsanAyaz/ngx-read-time).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将创建一个属性指令来计算文章的阅读时间，就像Medium一样。这个示例的代码受到了我在GitHub上现有存储库的启发，您可以在以下链接查看：[https://github.com/AhsanAyaz/ngx-read-time](https://github.com/AhsanAyaz/ngx-read-time)。
- en: Getting ready
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project for this recipe resides in `chapter02/start_here/ng-read-time-directive`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的项目位于`chapter02/start_here/ng-read-time-directive`中：
- en: Open the project in VS Code.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中打开项目。
- en: Open the terminal, and run `npm install` to install the dependencies of the
    project.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，运行`npm install`来安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。
- en: 'This should open the app in a new browser tab, and you should see something
    like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会在新的浏览器标签中打开应用程序，您应该会看到类似于这样的东西：
- en: '![Figure 2.2 – ng-read-time-directive app running on http://localhost:4200'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.2 - ng-read-time-directive应用程序运行在http://localhost:4200'
- en: '](image/Figure_2.02_B15150.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_2.02_B15150.jpg)'
- en: Figure 2.2 – ng-read-time-directive app running on http://localhost:4200
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 - ng-read-time-directive 应用正在 http://localhost:4200 上运行
- en: How to do it…
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Right now, we have a paragraph in our `app.component.html` file for which we
    need to calculate the **read time** in minutes. Let''s get started:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的`app.component.html`文件中有一个段落，我们需要计算**阅读时间**（以分钟为单位）。让我们开始吧：
- en: 'First, we''ll create an attribute directive named `read-time`. To do that,
    run the following command:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个名为`read-time`的属性指令。为此，请运行以下命令：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding command created an `appReadTime` directive. We''ll first apply
    this directive to `div` inside the `app.component.html` file with the `id` property
    set to `mainContent`, as follows:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上面的命令创建了一个`appReadTime`指令。我们首先将这个指令应用到`app.component.html`文件中`id`属性设置为`mainContent`的`div`上，如下所示：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we''ll create a configuration object for our `appReadTime` directive.
    This configuration will contain a `wordsPerMinute` value, on the basis of which
    we''ll calculate the read time. Let''s create an input inside the `read-time.directive.ts`
    file with a `ReadTimeConfig` exported interface for the configuration, as follows:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将为我们的`appReadTime`指令创建一个配置对象。这个配置将包含一个`wordsPerMinute`值，我们将根据这个值来计算阅读时间。让我们在`read-time.directive.ts`文件中创建一个输入，其中包含一个导出的`ReadTimeConfig`接口，用于配置，如下所示：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can now move on to getting the text to calculate the read time. For this,
    we''ll use the `ElementRef` service to retrieve the `textContent` property of
    the element. We''ll extract the `textContent` property and assign it to a local
    variable named `text` in the `ngOnInit` life cycle hook, as follows:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以继续获取文本以计算阅读时间。为此，我们将使用`ElementRef`服务来检索元素的`textContent`属性。我们将提取`textContent`属性并将其分配给`ngOnInit`生命周期钩子中的一个名为`text`的局部变量，如下所示：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now that we have our text variable filled up with the element''s entire text
    content, we can calculate the time to read this text. For this, we''ll create
    a method named `calculateReadTime` by passing the `text` property to it, as follows:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们的文本变量已经填满了元素的整个文本内容，我们可以计算阅读这段文本所需的时间。为此，我们将创建一个名为`calculateReadTime`的方法，并将`text`属性传递给它，如下所示：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We''ve got the time now in minutes, but it''s not in a user-readable format
    at the moment since it is just a number. We need to show it in a way that is understandable
    for the end user. To do so, we''ll do some minor calculations and create an appropriate
    string to show on the **user interface** (**UI**). The code is shown here:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经得到了以分钟为单位的时间，但目前它还不是一个用户可读的格式，因为它只是一个数字。我们需要以一种用户可以理解的方式显示它。为此，我们将进行一些小的计算，并创建一个适当的字符串来显示在**用户界面**（**UI**）上。代码如下所示：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Note that with the code so far, you should be able to see the minutes on the
    console when you refresh the application.*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*请注意，到目前为止，当您刷新应用程序时，您应该能够在控制台上看到分钟数。*'
- en: 'Now, let''s add an `@Output()` to the directive so that we can get the read
    time in the parent component and display it on the UI. Let''s add it as follows
    in the `read-time.directive.ts` file:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在指令中添加一个`@Output()`，这样我们就可以在父组件中获取阅读时间并在UI上显示它。让我们在`read-time.directive.ts`文件中添加如下内容：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s use the `readTimeCalculated` output to emit the value of the `timeStr`
    variable from the `ngOnInit()` method when we''ve calculated the read time:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用`readTimeCalculated`输出来在我们计算出阅读时间时从`ngOnInit()`方法中发出`timeStr`变量的值：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Since we emit the read-time value using the `readTimeCalculated` output, we
    have to listen to this output''s event in the `app.component.html` file and assign
    it to a property of the `AppComponent` class so that we can show this on the view.
    But before that, we''ll create a local property in the `app.component.ts` file
    to store the output event''s value, and we''ll also create a method to be called
    upon when the output event is triggered. The code is shown here:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们使用 `readTimeCalculated` 输出来发出阅读时间值，我们必须在 `app.component.html` 文件中监听这个输出的事件，并将其分配给
    `AppComponent` 类的一个属性，以便我们可以在视图中显示它。但在此之前，我们将在 `app.component.ts` 文件中创建一个本地属性来存储输出事件的值，并且我们还将创建一个在输出事件触发时调用的方法。代码如下所示：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can now listen to the output event in the `app.component.html` file, and
    we can then call the `onReadTimeCalculated` method when the `readTimeCalculated`
    output event is triggered:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以在 `app.component.html` 文件中监听输出事件，然后当 `readTimeCalculated` 输出事件被触发时调用 `onReadTimeCalculated`
    方法：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we can finally show the read time in the `app.component.html` file, as
    follows:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在 `app.component.html` 文件中显示阅读时间，如下所示：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works…
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `appReadTime` directive is at the heart of this recipe. We use the `ElementRef`
    service inside the directive to get the native element that the directive is attached
    to, then we take out its text content. The only thing that remains then is to
    perform the calculation. We first split the entire text content into words by
    using the `/\s+/g` **regular expression** (**regex**), and thus we count the total
    words in the text content. Then, we divide the word count by the `wordsPerMinute`
    value we have in the configuration to calculate how many minutes it would take
    to read the entire text. *Easy peasy, lemon squeezy*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`appReadTime` 指令是这个示例的核心。我们在指令内部使用 `ElementRef` 服务来获取指令附加到的原生元素，然后取出它的文本内容。然后，我们只需要进行计算。我们首先使用
    `/\s+/g` **正则表达式** (**regex**) 将整个文本内容分割成单词，从而计算出文本内容中的总单词数。然后，我们将单词数除以配置中的 `wordsPerMinute`
    值，以计算阅读整个文本需要多少分钟。*轻而易举*。'
- en: See also
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Ngx Read Time library ([https://github.com/AhsanAyaz/ngx-read-time](https://github.com/AhsanAyaz/ngx-read-time))
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ngx Read Time 库 ([https://github.com/AhsanAyaz/ngx-read-time](https://github.com/AhsanAyaz/ngx-read-time))
- en: Angular attribute directives documentation ([https://angular.io/guide/testing-attribute-directives](https://angular.io/guide/testing-attribute-directives))
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 属性指令文档 ([https://angular.io/guide/testing-attribute-directives](https://angular.io/guide/testing-attribute-directives))
- en: Creating a basic directive that allows you to vertically scroll to an element
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个基本指令，允许您垂直滚动到一个元素
- en: In this recipe, you'll create a directive to allow the user to scroll to a particular
    element on the page, on click.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将创建一个指令，允许用户点击时滚动到页面上的特定元素。
- en: Getting ready
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project for this recipe resides in `chapter02/start_here/ng-scroll-to-directive`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的项目位于 `chapter02/start_here/ng-scroll-to-directive`：
- en: Open the project in VS Code.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中打开项目。
- en: Open the terminal, and run `npm install` to install the dependencies of the
    project.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，并运行 `npm install` 来安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行 `ng serve -o`。
- en: 'This should open the app in a new browser tab, and you should see something
    like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器标签中打开应用程序，您应该看到类似于这样的东西：
- en: '![Figure 2.3 – ng-scroll-to-directive app running on http://localhost:4200'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.3 – ng-scroll-to-directive 应用程序运行在 http://localhost:4200'
- en: '](image/Figure_2.03_B15150.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_2.03_B15150.jpg)'
- en: Figure 2.3 – ng-scroll-to-directive app running on http://localhost:4200
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – ng-scroll-to-directive 应用程序运行在 http://localhost:4200
- en: How to do it…
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'First off, we''ll create a `scroll-to` directive so that we can enhance our
    application with smooth scrolls to different sections. We''ll do this using the
    following command in the project:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个`scroll-to`指令，以便我们可以通过平滑滚动到不同的部分来增强我们的应用程序。我们将使用以下命令在项目中实现这一点：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we need to make the directive capable of accepting an `@Input()` that''ll
    contain the **Cascading Style Sheets** (**CSS**) **Query Selector** for our target
    section that we''ll scroll to upon the element''s `click` event. Let''s add the
    input as follows to our `scroll-to.directive.ts` file:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要使指令能够接受一个包含我们将在元素的`click`事件上滚动到的目标部分的**层叠样式表**（**CSS**）**查询选择器**的`@Input()`。让我们将输入添加到我们的`scroll-to.directive.ts`文件中，如下所示：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we''ll apply the `appScrollTo` directive to the links in the `app.component.html`
    file along with the respective targets so that we can implement the scroll logic
    in the next steps. The code should look like this:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将`appScrollTo`指令应用到`app.component.html`文件中的链接上，同时还指定了相应的目标，以便我们可以在接下来的步骤中实现滚动逻辑。代码应该如下所示：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, we''ll implement the `HostListener()` decorator to bind the `click` event
    to the element the directive is attached to. We''ll just log the `target` input
    when we click the links. Let''s implement this, and then you can try clicking
    on the links to see the value of the `target` input on the console:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将实现`HostListener()`装饰器，将`click`事件绑定到附加了指令的元素上。当我们点击链接时，我们将在控制台上记录`target`输入的值。让我们实现这个，然后你可以尝试点击链接，看看控制台上`target`输入的值：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Since we have the `click` handler set up already, we can now implement the
    logic to scroll to a particular target. For that, we''ll use the `document.querySelector`
    method, using the `target` variable''s value to get the element, and then the
    `Element.scrollIntoView()` web API to scroll the target element. With this change,
    you should have the page being scrolled to the target element already when you
    click the corresponding link:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们已经设置了`click`处理程序，现在我们可以实现滚动到特定目标的逻辑。为此，我们将使用`document.querySelector`方法，使用`target`变量的值来获取元素，然后使用`Element.scrollIntoView()`
    web API来滚动目标元素。通过这个改变，当你点击相应的链接时，页面应该已经滚动到目标元素了：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'All right—we got the scroll working. "*But what''s new, Ahsan? Isn''t this
    exactly what we were already doing with the href implementation before?*" Well,
    you''re right. But, we''re going to make the scroll super *smoooooth*. We''ll
    pass `scrollIntoViewOptions` as an argument to the `scrollIntoView` method with
    the `{behavior: "smooth"}` value to use an animation during the scroll. The code
    should look like this:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '好了，我们让滚动起作用了。"*但是，阿赫桑，有什么新鲜事吗？这不是我们以前使用href实现的吗？*" 好吧，你是对的。但是，我们将使滚动非常*平滑*。我们将使用`scrollIntoViewOptions`作为`scrollIntoView`方法的参数，使用`{behavior:
    "smooth"}`值在滚动过程中使用动画。代码应该如下所示：'
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How it works…
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The essence of this recipe is the web API that we''re using within an Angular
    directive, and that is `Element.scrollIntoView()`. We first attach our `appScrollTo`
    directive to the elements that should trigger scrolling upon clicking them. We
    also specify which element to scroll to by using the `target` input for each directive
    attached. Then, we implement the `click` handler inside the directive with the
    `scrollIntoView()` method to scroll to a particular target, and to use a smooth
    animation while scrolling, we pass the `{behavior: ''smooth''}` object as an argument
    to the `scrollIntoView()` method.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '这个食谱的精髓是我们在Angular指令中使用的web API，即`Element.scrollIntoView()`。我们首先将我们的`appScrollTo`指令附加到应该在点击时触发滚动的元素上。我们还通过为每个附加的指令使用`target`输入来指定要滚动到哪个元素。然后，我们在指令内部实现`click`处理程序，使用`scrollIntoView()`方法滚动到特定目标，并且为了在滚动时使用平滑动画，我们将`{behavior:
    ''smooth''}`对象作为参数传递给`scrollIntoView()`方法。'
- en: There's more…
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: '`scrollIntoView()` method documentation ([https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView](https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView))'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scrollIntoView()` 方法文档 ([https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView](https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView))'
- en: Angular attribute directives documentation ([https://angular.io/guide/testing-attribute-directives](https://angular.io/guide/testing-attribute-directives))
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular属性指令文档 ([https://angular.io/guide/testing-attribute-directives](https://angular.io/guide/testing-attribute-directives))
- en: Writing your first custom structural directive
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写您的第一个自定义结构指令
- en: In this recipe, you'll write your first custom structural directive named `*appIfNot`
    that will do the opposite of what `*ngIf` does—that is, you'll provide a Boolean
    value to the directive, and it will show the content attached to the directive
    when the value is `false`, as opposed to how the `*ngIf` directive shows the content
    when the value provided is `true`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将编写您的第一个自定义结构指令，名为 `*appIfNot`，它将执行与 `*ngIf` 相反的操作 - 也就是说，您将向指令提供一个布尔值，当该值为
    `false` 时，它将显示附加到指令的内容，而不是 `*ngIf` 指令在提供的值为 `true` 时显示内容。
- en: Getting ready
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project for this recipe resides in `chapter02/start_here/ng-if-not-directive`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例中的项目位于 `chapter02/start_here/ng-if-not-directive`：
- en: Open the project in VS Code.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中打开项目。
- en: Open the terminal, and run `npm install` to install the dependencies of the
    project.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，并运行 `npm install` 来安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行 `ng serve -o`。
- en: 'This should open the app in a new browser tab, and you should see something
    like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在新的浏览器选项卡中打开应用程序，您应该看到类似于这样的内容：
- en: '![Figure 2.4 – ng-if-not-directive app running on http://localhost:4200'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.4 - ng-if-not-directive 应用程序在 http://localhost:4200 上运行'
- en: '](image/Figure_2.04_B15150.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_2.04_B15150.jpg)'
- en: Figure 2.4 – ng-if-not-directive app running on http://localhost:4200
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 - ng-if-not-directive 应用程序在 http://localhost:4200 上运行
- en: How to do it…
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'First of all, we''ll create a directive using the following command in the
    project root:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将使用以下命令在项目根目录中创建一个指令：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, instead of the `*ngIf` directive in the `app.component.html` file, we
    can use our `*appIfNot` directive. We''ll also reverse the condition from `visibility
    === VISIBILITY.Off` to `visibility === VISIBILITY.On`, as follows:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `app.component.html` 文件中，我们可以使用我们的 `*appIfNot` 指令，而不是 `*ngIf` 指令。我们还将条件从
    `visibility === VISIBILITY.Off` 反转为 `visibility === VISIBILITY.On`，如下所示：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now that we have set the condition, we need to create an `@Input` inside the
    `*appIfNot` directive that accepts a Boolean value. We''ll use a **setter** to
    intercept the value changes and will log the value on the console for now:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经设置了条件，我们需要在 `*appIfNot` 指令内部创建一个接受布尔值的 `@Input`。我们将使用一个 **setter** 来拦截值的变化，并暂时将值记录在控制台上：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If you tap on the **Visibility On** and **Visibility Off** buttons now, you
    should see the values being changed and reflected on the console, as follows:![Figure
    2.5 – Console logs displaying changes for the appIfNot directive values
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果现在点击**Visibility On**和**Visibility Off**按钮，您应该看到值的变化并反映在控制台上，如下所示：![图2.5 -
    控制台日志显示appIfNot指令值的更改
- en: '](image/Figure_2.05_B15150.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_2.05_B15150.jpg)'
- en: Figure 2.5 – Console logs displaying changes for the appIfNot directive values
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 - 控制台日志显示appIfNot指令值的更改
- en: 'Now, we''re moving toward the actual implementation of showing and hiding the
    content based on the value being `false` and `true` respectively, and for that,
    we first need the `TemplateRef` service and the `ViewContainerRef` service injected
    into the constructor of `if-not.directive.ts`. Let''s add these, as follows:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将朝着根据值为 `false` 和 `true` 显示和隐藏内容的实际实现前进，为此，我们首先需要将 `TemplateRef` 服务和 `ViewContainerRef`
    服务注入到 `if-not.directive.ts` 的构造函数中。让我们按照以下方式添加这些内容：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, we can add the logic to add/remove the content from the DOM based
    on the `appIfNot` input''s value, as follows:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以添加逻辑来根据`appIfNot`输入的值添加/删除DOM中的内容，如下所示：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works…
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '**Structural directives** in Angular are special for multiple reasons. First,
    they allow you to manipulate DOM elements—that is, adding/removing/manipulating
    based on your needs. Moreover, they have this `*` prefix that binds to all the
    magic Angular does behind the scenes. As an example, `*ngIf` and `*ngFor` are
    both structural directives that behind the scenes work with the `<ng-template>`
    directive containing the content you bind the directive to and create the required
    variables/properties for you in the scope of `ng-template`. In the recipe, we
    do the same. We use the `TemplateRef` service to access the `<ng-template>` directive
    that Angular creates for us behind the scenes, containing the **host element**
    on which our `appIfNot` directive is applied. Then, based on the value provided
    to the directive as input, we decide whether to add the magical `ng-template`
    to the view or clear the `ViewContainerRef` service to remove anything inside
    it.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，**结构指令**有多个特殊之处。首先，它们允许您操作DOM元素，即根据您的需求添加/删除/操作。此外，它们具有`*`前缀，该前缀绑定到Angular在幕后执行的所有魔法。例如，`*ngIf`和`*ngFor`都是结构指令，它们在幕后使用包含您绑定指令的内容的`<ng-template>`指令，并为您在`ng-template`的作用域中创建所需的变量/属性。在这个示例中，我们做同样的事情。我们使用`TemplateRef`服务来访问Angular在幕后为我们创建的包含应用`appIfNot`指令的**宿主元素**的`<ng-template>`指令。然后，根据指令作为输入提供的值，我们决定是将神奇的`ng-template`添加到视图中，还是清除`ViewContainerRef`服务以删除其中的任何内容。
- en: See also
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Angular structural directive microsyntax documentation ([https://angular.io/guide/structural-directives#microsyntax](https://angular.io/guide/structural-directives#microsyntax))
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular结构指令微语法文档([https://angular.io/guide/structural-directives#microsyntax](https://angular.io/guide/structural-directives#microsyntax))
- en: Angular structural directives documentation ([https://angular.io/guide/structural-directives](https://angular.io/guide/structural-directives))
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular结构指令文档([https://angular.io/guide/structural-directives](https://angular.io/guide/structural-directives))
- en: Creating a structural directive by Rangle.io ([https://angular-2-training-book.rangle.io/advanced-angular/directives/creating_a_structural_directive](https://angular-2-training-book.rangle.io/advanced-angular/directives/creating_a_structural_directive))
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由Rangle.io创建结构指令([https://angular-2-training-book.rangle.io/advanced-angular/directives/creating_a_structural_directive](https://angular-2-training-book.rangle.io/advanced-angular/directives/creating_a_structural_directive))
- en: How to use *ngIf and *ngSwitch together
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何同时使用*ngIf和*ngSwitch
- en: In certain situations, you might want to use more than one structural directive
    on the same host—for example, a combination of `*ngIf` and `*ngFor` together.
    In this recipe, you'll learn how to do exactly that.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能希望在同一个宿主上使用多个结构指令，例如`*ngIf`和`*ngFor`的组合。在这个示例中，您将学习如何做到这一点。
- en: Getting ready
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project we are going to work with resides in `chapter02/start_here/multi-structural-directives`,
    inside the cloned repository:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要处理的项目位于克隆存储库内的`chapter02/start_here/multi-structural-directives`中。
- en: Open the project in VS Code.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中打开项目。
- en: Open the terminal, and run `npm install` to install the dependencies of the
    project.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，并运行`npm install`来安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。
- en: 'This should open the app in a new browser tab, and you should see something
    like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会在新的浏览器标签中打开应用程序，你应该会看到类似这样的东西：
- en: '![Figure 2.6 – multi-structural-directives app running on http://localhost:4200'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.6-多结构指令应用程序在http://localhost:4200上运行'
- en: '](image/Figure_2.06_B15150.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_2.06_B15150.jpg)'
- en: Figure 2.6 – multi-structural-directives app running on http://localhost:4200
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6-多结构指令应用程序在http://localhost:4200上运行
- en: Now that we have the app running, let's see the steps for this recipe in the
    next section.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序正在运行，让我们在下一节中看看这个食谱的步骤。
- en: How to do it…
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We''ll start by moving the element with the **No items in bucket. Add some
    fruits!** text into its own `<ng-template>` element, and we''ll give it a template
    variable called `#bucketEmptyMessage`. The code should look like this in the `app.component.html`
    file:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先将带有**桶中没有物品。添加一些水果！**文本的元素移入自己的`<ng-template>`元素，并给它一个名为`#bucketEmptyMessage`的模板变量。代码应该在`app.component.html`文件中如下所示：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Notice that we moved the entire `div` out of the `.page-section` div. Now,
    we''ll use the `ngIf-Else` syntax to either show a bucket list or an empty bucket
    message based on the bucket''s length. Let''s modify the code, as follows:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，我们将整个`div`移出了`.page-section` div。现在，我们将使用`ngIf-Else`语法根据桶的长度显示桶列表或空桶消息。让我们修改代码，如下所示：
- en: '[PRE33]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As soon as you save the preceding code, you''ll see the application breaks,
    mentioning we can''t use multiple template bindings on one element. This means
    we can''t use multiple structural directives on one element:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦保存了上述代码，您会看到应用程序崩溃，并提到我们不能在一个元素上使用多个模板绑定。这意味着我们不能在一个元素上使用多个结构指令：
- en: '![Figure 2.7 – Error on console, showing we can''t use multiple directives
    on one element'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.7 - 控制台上的错误，显示我们不能在一个元素上使用多个指令'
- en: '](image/Figure_2.07_B15150.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_2.07_B15150.jpg)'
- en: Figure 2.7 – Error on console, showing we can't use multiple directives on one
    element
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 - 控制台上的错误，显示我们不能在一个元素上使用多个指令
- en: 'Now, as a final step, let''s fix the issue by wrapping the div with `*ngFor="let
    item of bucket;"` inside an `<ng-container>` element and using the `*ngIf` directive
    on the `<ng-container>` element, as follows:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，作为最后一步，让我们通过将带有`*ngFor="let item of bucket;"`的div包装在`<ng-container>`元素内，并在`<ng-container>`元素上使用`*ngIf`指令来解决这个问题，如下所示：
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How it works…
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Since we can't use two structural directives on a single element, we can always
    use another HTML element as a parent to use the other structural directive. However,
    that adds another element to the DOM and might cause problems for your element
    hierarchy, based on your implementation. `<ng-container>`, however, is a magical
    element from Angular's core that is not added to the DOM. Instead, it just wraps
    the logic/condition that you apply to it, which makes it really easy for us to
    just add a `*ngIf` or `*ngSwitchCase` directive on top of your existing elements.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不能在单个元素上使用两个结构指令，我们总是可以使用另一个HTML元素作为父元素来使用另一个结构指令。然而，这会向DOM添加另一个元素，并根据您的实现可能会导致元素层次结构出现问题。然而，`<ng-container>`是Angular核心中的一个神奇元素，它不会添加到DOM中。相反，它只是包装您应用于它的逻辑/条件，这使得我们可以很容易地在现有元素上添加`*ngIf`或`*ngSwitchCase`指令。
- en: See also
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Group sibling elements with `<ng-container>` documentation ([https://angular.io/guide/structural-directives#group-sibling-elements-with-ng-container](https://angular.io/guide/structural-directives#group-sibling-elements-with-ng-container))
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`<ng-container>`文档对兄弟元素进行分组（[https://angular.io/guide/structural-directives#group-sibling-elements-with-ng-container](https://angular.io/guide/structural-directives#group-sibling-elements-with-ng-container)）
- en: Enhancing template type checking for your custom directives
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强自定义指令的模板类型检查
- en: In this recipe, you'll learn how to improve type checking in templates for your
    custom Angular directives using the static template guards that the recent versions
    of Angular have introduced. We'll enhance the template type checking for our `appHighlight`
    directive so that it only accepts a narrowed set of inputs.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，您将学习如何使用Angular最近版本引入的静态模板保护来改进自定义Angular指令模板的类型检查。我们将增强我们的`appHighlight`指令的模板类型检查，以便它只接受一组缩小的输入。
- en: Getting ready
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project we are going to work with resides in `chapter02/start_here/enhanced-template-type-checking`,
    inside the cloned repository:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要处理的项目位于克隆存储库中的`chapter02/start_here/enhanced-template-type-checking`中：
- en: Open the project in VS Code.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中打开项目。
- en: Open the terminal, and run `npm install` to install the dependencies of the
    project.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，并运行`npm install`来安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行`ng serve -o`。
- en: 'This should open the app in a new browser tab, and you should see something
    like this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器选项卡中打开应用程序，你应该看到类似这样的东西：
- en: '![Figure 2.8 – enhanced-template-type-checking app running on http://localhost:4200'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.8-增强模板类型检查应用程序正在http://localhost:4200上运行'
- en: '](image/Figure_2.08_B15150.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_2.08_B15150.jpg)'
- en: Figure 2.8 – enhanced-template-type-checking app running on http://localhost:4200
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8-增强模板类型检查应用程序正在http://localhost:4200上运行
- en: Now that we have the app running, let's see the steps for this recipe in the
    next section.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用程序正在运行，让我们在下一节中看看这个配方的步骤。
- en: How to do it…
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'First off, we''ll try to identify the problem, and that boils down to the ability
    to pass any string as a color to the `highlightColor` attribute/input for the
    `appHighlight` directive. Give it a try. Provide the `''#dcdcdc''` value as the
    input and you''ll have a broken highlight color, but no errors whatsoever:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将尝试识别问题，这归结为能够将任何字符串作为`appHighlight`指令的`highlightColor`属性/输入的颜色。试一试。将`'#dcdcdc'`值作为输入，你会有一个破碎的高亮颜色，但没有任何错误：
- en: '[PRE35]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Well, how do we fix it? By adding some `angularCompileOptions` to our `tsconfig.json`
    file. We''ll do this by adding a flag named `strictInputTypes` as `true`. Stop
    the app server, modify the code as follows, and rerun the `ng serve` command to
    see the changes:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好吧，我们该怎么解决呢？通过向我们的`tsconfig.json`文件添加一些`angularCompileOptions`。我们将通过将名为`strictInputTypes`的标志添加为`true`来实现这一点。停止应用程序服务器，修改代码如下，并重新运行`ng
    serve`命令以查看更改：
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You should see something like this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到类似这样的东西：
- en: '![Figure 2.9 – strictInputTypes helping with build time errors for incompatible
    type'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.9-strictInputTypes帮助构建时错误不兼容类型'
- en: '](image/Figure_2.09_B15150.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_2.09_B15150.jpg)'
- en: Figure 2.9 – strictInputTypes helping with build time errors for incompatible
    type
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9-strictInputTypes帮助构建时错误不兼容类型
- en: 'Well, great! Angular now identifies that the provided `''#dcdcdc''` value is
    not assignable to the `HighlightColor` type. But what happens if someone tries
    to provide `null` as the value? Would it still be fine? The answer is no. We would
    still have a broken experience, but no error whatsoever. To fix this, we''ll enable
    two flags for our `angularCompilerOptions`—`strictNullChecks` and `strictNullInputTypes`:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好了，太棒了！Angular现在识别出提供的`'#dcdcdc'`值不可分配给`HighlightColor`类型。但是，如果有人尝试提供`null`作为值会发生什么？还好吗？答案是否定的。我们仍然会有一个破碎的体验，但没有任何错误。为了解决这个问题，我们将为我们的`angularCompilerOptions`启用两个标志-`strictNullChecks`和`strictNullInputTypes`：
- en: '[PRE37]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Update the `app.component.html` file to provide `null` as the value for the
    `[highlightColor]` attribute, as follows:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`app.component.html`文件，将`null`作为`[highlightColor]`属性的值，如下所示：
- en: '[PRE38]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Stop the server, save the file, and rerun `ng serve`, and you'll see that we
    now have another error, as shown here:![Figure 2.10 – Error reporting with strictNullInputTypes
    and strictNullChecks in action
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止服务器，保存文件，并重新运行`ng serve`，你会看到我们现在有另一个错误，如下所示：![图2.10-使用strictNullInputTypes和strictNullChecks进行错误报告
- en: '](image/Figure_2.10_B15150.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_2.10_B15150.jpg)'
- en: Figure 2.10 – Error reporting with strictNullInputTypes and strictNullChecks
    in action
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10-使用strictNullInputTypes和strictNullChecks进行错误报告
- en: 'Now, instead of so many flags for even further cases, we can actually just
    put two flags that do all the magic for us and cover most of our applications—the
    `strictNullChecks` flag and the `strictTemplates` flag:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们不再需要为更多情况设置如此多的标志，实际上我们只需要两个标志就可以为我们完成所有的魔术并覆盖大多数应用程序——`strictNullChecks`标志和`strictTemplates`标志：
- en: '[PRE39]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally, we can import the `HighlightColor` enum into our `app.component.ts`
    file. We will add a `hColor` property to the `AppComponent` class and will assign
    it a value from the `HighlightColor` enum, as follows:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以将`HighlightColor`枚举导入到我们的`app.component.ts`文件中。我们将在`AppComponent`类中添加一个`hColor`属性，并将其赋值为`HighlightColor`枚举中的一个值，如下所示：
- en: '[PRE40]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We''ll now use the `hColor` property in the `app.component.html` file to pass
    it to the `appHighlight` directive. This should fix all the issues and make **light
    coral** the assigned highlight color for our directive:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将在`app.component.html`文件中使用`hColor`属性将其传递给`appHighlight`指令。这应该解决所有问题，并使**浅珊瑚色**成为我们指令的指定高亮颜色：
- en: '[PRE41]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: See also
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Angular structural directives documentation ([https://angular.io/guide/structural-directives](https://angular.io/guide/structural-directives))
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular结构指令文档（[https://angular.io/guide/structural-directives](https://angular.io/guide/structural-directives)）
- en: Template type checking in Angular documentation ([https://angular.io/guide/template-typecheck#template-type-checking](https://angular.io/guide/template-typecheck#template-type-checking))
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular文档中的模板类型检查（[https://angular.io/guide/template-typecheck#template-type-checking](https://angular.io/guide/template-typecheck#template-type-checking)）
- en: Troubleshooting template errors in Angular documentation ([https://angular.io/guide/template-typecheck#troubleshooting-template-errors](https://angular.io/guide/template-typecheck#troubleshooting-template-errors))
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Angular文档中排除模板错误（[https://angular.io/guide/template-typecheck#troubleshooting-template-errors](https://angular.io/guide/template-typecheck#troubleshooting-template-errors)）
