- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Building Your Own Hooks
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建您自己的钩子
- en: In the previous chapter, we learned about the limitations and rules of Hooks.
    We also learned where to call Hooks, why the order matters, and naming conventions
    for Hooks.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了钩子的限制和规则。我们还学习了在哪里调用钩子，为什么顺序很重要，以及钩子的命名约定。
- en: In this chapter, we are going to learn how to create custom Hooks by extracting
    existing code from our components. We are also going to learn how to use custom
    Hooks and how Hooks can interact with each other. Finally, we are going to learn
    how to write tests for our custom Hooks.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何通过从我们的组件中提取现有代码来创建自定义钩子。我们还将学习如何使用自定义钩子以及钩子如何相互交互。最后，我们将学习如何为我们的自定义钩子编写测试。
- en: At the end of this chapter, you will be able to create custom Hooks to encapsulate
    and re-use application logic, keeping your code clean and maintainable.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够创建自定义钩子来封装和重用应用程序逻辑，使您的代码保持整洁和可维护。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Creating a custom Theme Hook
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义主题钩子
- en: Creating a custom User Hook
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义用户钩子
- en: Creating custom API Hooks
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义API钩子
- en: Creating a Debounced History State Hook
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个防抖历史状态钩子
- en: Testing custom Hooks
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试自定义钩子
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'A fairly recent version of Node.js should already be installed. The Node Package
    Manager (`npm`) also needs to be installed (it should come with Node.js). For
    more information on how to install Node.js, please check out their official website:
    [https://nodejs.org/](https://nodejs.org/).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 应该已经安装了一个相当新的Node.js版本。还需要安装Node包管理器（`npm`）（它应该与Node.js一起安装）。有关如何安装Node.js的更多信息，请访问他们的官方网站：[https://nodejs.org/](https://nodejs.org/)
- en: 'We are going to use **Visual Studio Code** (**VS Code**) for the guides in
    this book, but everything should work similarly in any other editor. For more
    information on how to install VS Code, please refer to their official website:
    [https://code.visualstudio.com](https://code.visualstudio.com)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的指南中使用**Visual Studio Code**（**VS Code**），但任何其他编辑器都应该以类似的方式工作。有关如何安装VS
    Code的更多信息，请参阅他们的官方网站：[https://code.visualstudio.com](https://code.visualstudio.com)
- en: 'In this book, we use the following versions:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们使用以下版本：
- en: Node.js v22.14.0
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js v22.14.0
- en: '`npm` v10.9.2'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npm` v10.9.2'
- en: Visual Studio Code v1.97.2
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code v1.97.2
- en: The versions mentioned in the preceding list are the ones used in the book.
    While installing a newer version should not be an issue, please note that certain
    steps might work differently on a newer version. If you are having an issue with
    the code and steps provided in this book, please try using the mentioned versions.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 前面列表中提到的版本是书中使用的版本。虽然安装较新版本通常不会有问题，但请注意，某些步骤在较新版本上可能工作方式不同。如果您在使用本书中提供的代码和步骤时遇到问题，请尝试使用提到的版本。
- en: 'You can find the code for this chapter on GitHub: [https://github.com/PacktPublishing/Learn-React-Hooks-Second-Edition/tree/main/Chapter12](https://github.com/PacktPublishing/Learn-React-Hooks-Second-Edition/tree/main/Chapter12)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章的代码：[https://github.com/PacktPublishing/Learn-React-Hooks-Second-Edition/tree/main/Chapter12](https://github.com/PacktPublishing/Learn-React-Hooks-Second-Edition/tree/main/Chapter12)
- en: It is highly recommended that you write the code on your own. Do not simply
    run the code examples that are provided in the book. It is important to write
    the code yourself to be able to learn and understand it properly. However, if
    you run into any issues, you can always refer to the code example.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议您自己编写代码。不要简单地运行书中提供的代码示例。自己编写代码对于正确学习和理解代码非常重要。然而，如果您遇到任何问题，您始终可以参考代码示例。
- en: Creating a custom Theme Hook
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义主题钩子
- en: After getting a good grasp on the concept of Hooks by learning about the built-in
    React Hooks, community Hooks, as well as the rules of Hooks, we are now going
    to build our own Hooks.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通过学习内置的React钩子、社区钩子以及钩子的规则，我们对钩子的概念有了很好的掌握后，现在我们将构建我们自己的钩子。
- en: 'In [*Chapter 5*](Chapter_05.xhtml#_idTextAnchor127)*, Implementing React Contexts*,
    we introduced a `ThemeContext` to style blog posts in our app. We used a Context
    Hook to access the `ThemeContext` in many components. Functionality that is used
    across multiple components is usually a good opportunity for a custom Hook. As
    you might have noticed, we often do the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第5章*](Chapter_05.xhtml#_idTextAnchor127)*实现React上下文*中，我们引入了`ThemeContext`来为我们的应用中的博客文章设置样式。我们使用Context钩子在许多组件中访问`ThemeContext`。通常，跨多个组件使用的功能是创建自定义钩子的好机会。正如您可能已经注意到的，我们经常做以下事情：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We could abstract this functionality into a `useTheme` Hook, which will get
    the `theme` object from the `ThemeContext`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将此功能抽象成一个 `useTheme` 钩子，该钩子将从 `ThemeContext` 获取 `theme` 对象。
- en: Usually, it makes the most sense to first write the component, and then later
    extract a custom Hook from it if we notice that we use similar code across multiple
    components. Doing so avoids prematurely creating custom Hooks and making our project
    unnecessarily complex.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，首先编写组件，然后如果我们注意到我们在多个组件中使用了相似的代码，再从中提取自定义钩子，这样做最有意义。这样做可以避免过早创建自定义钩子，使我们的项目变得不必要地复杂。
- en: Now, let’s get started creating the custom Theme Hook.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始创建自定义主题钩子。
- en: Creating the custom Theme Hook
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义主题钩子
- en: 'Let’s get started creating a custom Theme Hook now, by extracting the existing
    code for the Context Hook into a separate function:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在开始创建自定义主题钩子，通过将现有的上下文钩子代码提取到一个单独的函数中：
- en: 'Copy the `Chapter10_3` folder to a new `Chapter12_1` folder by executing the
    following command:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令将 `Chapter10_3` 文件夹复制到一个新的 `Chapter12_1` 文件夹：
- en: '[PRE1]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Open the new `Chapter12_1` folder in VS Code.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中打开新的 `Chapter12_1` 文件夹。
- en: Create a new `src/hooks/` folder.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `src/hooks/` 文件夹。
- en: Inside it, create a new `src/hooks/theme.js` file.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中，创建一个新的 `src/hooks/theme.js` 文件。
- en: 'In this newly created file, import the `useContext` function and the `ThemeContext`:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个新创建的文件中，导入 `useContext` 函数和 `ThemeContext`：
- en: '[PRE2]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, define and export a `useTheme` function, which simply returns the Context
    Hook:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定义并导出一个 `useTheme` 函数，它简单地返回上下文钩子：
- en: '[PRE3]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It’s as simple as that, as long as we stick to the rules and naming conventions
    of Hooks, we can easily create our own custom Hooks! Let’s continue by using our
    custom Theme Hook throughout the blog app.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如此简单，只要我们坚持钩子和命名约定规则，我们就可以轻松创建我们自己的自定义钩子！让我们继续在博客应用中使用我们的自定义主题钩子。
- en: Using the custom Theme Hook
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自定义主题钩子
- en: 'To get started using our custom Theme Hook:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用我们的自定义主题钩子：
- en: 'Edit `src/components/post/Post.jsx` and *remove* the following imports:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `src/components/post/Post.jsx` 并 *移除* 以下导入：
- en: '[PRE4]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Replace* them with an import of the `useTheme` function:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*替换* 为 `useTheme` 函数的导入：'
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Replace* the existing Context Hook with our custom Theme Hook:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*替换* 现有的上下文钩子为我们的自定义主题钩子：'
- en: '[PRE6]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Edit `src/components/post/PostListItem.jsx` and *remove* the following imports:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `src/components/post/PostListItem.jsx` 并 *移除* 以下导入：
- en: '[PRE7]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Replace* them with an import of the `useTheme` function:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*替换* 为 `useTheme` 函数的导入：'
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Replace the Context Hook with our Theme Hook:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用我们的主题钩子替换上下文钩子：
- en: '[PRE9]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Run the `dev` server, as follows:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式运行 `dev` 服务器：
- en: '[PRE10]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You will see that the theme still works the same way as before, showing featured
    posts in a different color.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到主题仍然以相同的方式工作，以不同的颜色显示特色帖子。
- en: As we can see, replacing the Context Hooks with our Theme Hook simplifies the
    code a bit (requiring less imports) and allows us to easily adjust the theming
    system later. For example, if we wanted to fetch the default theme from a user
    setting instead of getting it from the context, we could implement this functionality
    in the Theme Hook and all components would automatically use this new theme system.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，用我们的主题钩子替换上下文钩子可以使代码稍微简化（需要更少的导入）并允许我们稍后轻松调整主题系统。例如，如果我们想从用户设置中获取默认主题而不是从上下文中获取，我们可以在主题钩子中实现此功能，所有组件将自动使用这个新的主题系统。
- en: '**Example code**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例代码**'
- en: The example code for this section can be found in the `Chapter12/Chapter12_1`
    folder. Check the `README.md` file inside the folder for instructions on how to
    set up and run the example.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 本节示例代码可在 `Chapter12/Chapter12_1` 文件夹中找到。请检查文件夹内的 `README.md` 文件，了解如何设置和运行示例。
- en: Now that we have successfully created a custom Theme Hook, let’s move on to
    creating a custom User Hook.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功创建了一个自定义主题钩子，让我们继续创建自定义用户钩子。
- en: Creating a custom User Hook
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义用户钩子
- en: In [*Chapter 5*](Chapter_05.xhtml#_idTextAnchor127), *Implementing React Contexts*,
    we defined a `UserContext` to store the username of the currently logged in user.
    In [*Chapter 10*](Chapter_10.xhtml#_idTextAnchor250), *Using Community Hooks*,
    we replaced the `UserContext` with a Local Storage Hook. As you may remember,
    refactoring from the Context Hook to a Local Storage Hook required us to adjust
    the code in many components.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 5 章*](Chapter_05.xhtml#_idTextAnchor127)，*实现 React 上下文*，我们定义了一个 `UserContext`
    来存储当前登录用户的用户名。在 [*第 10 章*](Chapter_10.xhtml#_idTextAnchor250)，*使用社区钩子*，我们用本地存储钩子替换了
    `UserContext`。如您所记得，从上下文钩子重构到本地存储钩子需要我们调整许多组件中的代码。
- en: To avoid such issues in the future, we can put all user related information
    and functions into a User Hook, which then exposes them to be used by other components.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免未来出现此类问题，我们可以将所有用户相关信息和函数放入一个User Hook中，然后将其暴露给其他组件使用。
- en: Creating the custom User Hook
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义User Hook
- en: 'Let’s start by extracting all of our existing code related to dealing with
    the username into a custom User Hook:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先提取所有与处理用户名相关的现有代码到一个自定义User Hook中：
- en: 'Copy the `Chapter12_1` folder to a new `Chapter12_2` folder by executing the
    following command:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令将`Chapter12_1`文件夹复制到新的`Chapter12_2`文件夹：
- en: '[PRE11]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Open the new `Chapter12_2` folder in VS Code.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中打开新的`Chapter12_2`文件夹。
- en: Create a new `src/hooks/user.js` file.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`src/hooks/user.js`文件。
- en: 'Inside it, import the `useLocalStorage` function:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中，导入`useLocalStorage`函数：
- en: '[PRE12]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Define a new `useUser` function, in which we use the Local Storage Hook:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个新的`useUser`函数，在其中我们使用Local Storage Hook：
- en: '[PRE13]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Additionally, we define a flag to tell whether the user is logged in:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们定义一个标志来告诉用户是否已登录：
- en: '[PRE14]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, define the `register`, `login`, and `logout` functions:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定义`register`、`login`和`logout`函数：
- en: '[PRE15]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Return the `username`, `isLoggedIn` flag, and the functions:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回`username`、`isLoggedIn`标志和函数：
- en: '[PRE16]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, we are not just returning the username and a function to set
    the username, but instead returning an object with various information about the
    user session, as well as functions that we can call to adjust the user state.
    Now that we have abstracted this functionality into a User Hook, we can easily
    extend it later to support full authentication (instead of just storing the username).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们不仅返回用户名和设置用户名的函数，而是返回一个包含有关用户会话的各种信息以及我们可以调用的调整用户状态的函数的对象。现在我们已经将此功能抽象为User
    Hook，我们可以轻松地扩展它以支持完整的身份验证（而不仅仅是存储用户名）。
- en: With our User Hook successfully created, let’s use it in our app.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的User Hook成功创建后，让我们在应用程序中使用它。
- en: Using the custom User Hook
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自定义User Hook
- en: 'Let’s now refactor our blog app to use the User Hook instead of directly reading
    from and writing to the Local Storage Hook:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们重构我们的博客应用程序以使用User Hook而不是直接从Local Storage Hook读取和写入：
- en: 'Edit `src/App.jsx` and *remove* the following import:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`src/App.jsx`并移除以下导入：
- en: '[PRE17]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Replace* it with an import to the `useUser` function:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 用对`useUser`函数的导入来替换它：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Replace* the Local Storage Hook with our custom User Hook, as follows:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Local Storage Hook替换为我们的自定义User Hook，如下所示：
- en: '[PRE19]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Replace* the `username` check with a check for the `isLoggedIn` flag:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用对`isLoggedIn`标志的检查替换`username`检查：
- en: '[PRE20]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Using the `isLoggedIn` flag from the Hook makes the code easier to read – before
    it may have been unclear why we are checking for the username, but now it’s clear
    that we only want to render this component when the user is logged in. Doing the
    check like this has the additional benefit that we can change the logic for checking
    if the user is logged in later by adjusting the User Hook.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Hook中的`isLoggedIn`标志可以使代码更容易阅读——之前可能不清楚为什么我们要检查用户名，但现在很清楚我们只想在用户登录时渲染这个组件。这样做的好处是，我们可以通过调整User
    Hook来更改以后检查用户是否登录的逻辑。
- en: 'Now edit `src/components/user/UserBar.jsx` and *remove* the following import:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在编辑`src/components/user/UserBar.jsx`并移除以下导入：
- en: '[PRE21]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Replace* it with an import to the `useUser` function:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 用对`useUser`函数的导入来替换它：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Replace* the Local Storage Hook with our custom User Hook, as follows:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Local Storage Hook替换为我们的自定义User Hook，如下所示：
- en: '[PRE23]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Replace* the `username` check with a check for the `isLoggedIn` flag:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`username`检查替换为对`isLoggedIn`标志的检查：
- en: '[PRE24]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next edit `src/components/user/Register.jsx` and *remove* the following import:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来编辑`src/components/user/Register.jsx`并移除以下导入：
- en: '[PRE25]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Replace* it with an import to the `useUser` function:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 用对`useUser`函数的导入来替换它：
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Replace* the Local Storage Hook with our custom User Hook, as follows:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Local Storage Hook替换为我们的自定义User Hook，如下所示：
- en: '[PRE27]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the `handleSubmit` function, *replace* the `setUsername` function with our
    new `register` function:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`handleSubmit`函数中，用我们的新`register`函数替换`setUsername`函数：
- en: '[PRE28]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Again, we are making our code easier to read by calling a function that explains
    what we actually want to do (register a new user). Before, we were just calling
    `setUsername` here. Later, we may want to actually connect this to a database,
    so having the `register` function in the User Hook will make it easier for us
    to add this functionality later.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们通过调用一个解释我们实际想要做什么的函数来使我们的代码更容易阅读（注册新用户）。之前，我们只是在这里调用`setUsername`。稍后，我们可能希望真正将其连接到数据库，因此User
    Hook中的`register`函数将使我们更容易稍后添加此功能。
- en: 'Edit `src/components/user/Login.jsx` and *remove* the following import:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `src/components/user/Login.jsx` 并 *移除* 以下导入：
- en: '[PRE29]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Replace* it with an import to the `useUser` function:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*替换* 它为对 `useUser` 函数的导入：'
- en: '[PRE30]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Replace* the Local Storage Hook with our custom User Hook, as follows:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*替换* 本地存储钩子为我们的自定义用户钩子，如下所示：'
- en: '[PRE31]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the `handleSubmit` function, *replace* the `setUsername` function with our
    new `login` function:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `handleSubmit` 函数中，*替换* `setUsername` 函数为我们的新 `login` 函数：
- en: '[PRE32]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Edit `src/components/user/Logout.jsx` and *remove* the following import:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `src/components/user/Logout.jsx` 并 *移除* 以下导入：
- en: '[PRE33]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*Replace* it with an import to the `useUser` function:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*替换* 它为对 `useUser` 函数的导入：'
- en: '[PRE34]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*Replace* the Local Storage Hook with our custom User Hook, as follows:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*替换* 本地存储钩子为我们的自定义用户钩子，如下所示：'
- en: '[PRE35]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the `handleSubmit` function, *replace* the `setUsername` function with our
    new `logout` function:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `handleSubmit` 函数中，*替换* `setUsername` 函数为我们的新 `logout` 函数：
- en: '[PRE36]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Edit `src/components/post/CreatePost.jsx` and *remove* the following import
    of the `useLocalStorage` function:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `src/components/post/CreatePost.jsx` 并 *移除* 对 `useLocalStorage` 函数的以下导入：
- en: '[PRE37]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Add an import to the `useUser` function, as follows:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加对 `useUser` 函数的导入，如下所示：
- en: '[PRE38]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*Replace* the Local Storage Hook with our custom User Hook, as follows:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*替换* 本地存储钩子为我们的自定义用户钩子，如下所示：'
- en: '[PRE39]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Being able to access the `username` from the User Hook decouples the component
    from the internal logic. For example, we may later store a whole user object,
    or an authentication token, in local storage. If we used the Local Storage Hook
    in each component, we would need to adjust every single component that uses it.
    Now, we can simply adjust the User Hook and as long as we still return the `username`
    from it, we do not need to change any components.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 能够从用户钩子中访问 `username` 将组件与内部逻辑解耦。例如，我们可能稍后会在本地存储中存储整个用户对象或身份验证令牌。如果我们每个组件都使用本地存储钩子，我们就需要调整使用它的每个组件。现在，我们只需简单地调整用户钩子，只要我们仍然从它返回
    `username`，我们就不需要更改任何组件。
- en: 'Edit `src/components/comment/CreateComment.jsx` and *remove* the following
    import:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `src/components/comment/CreateComment.jsx` 并 *移除* 以下导入：
- en: '[PRE40]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '*Replace* it with an import to the `useUser` function:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*替换* 它为对 `useUser` 函数的导入：'
- en: '[PRE41]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '*Replace* the Local Storage Hook with our custom User Hook, as follows:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*替换* 本地存储钩子为我们的自定义用户钩子，如下所示：'
- en: '[PRE42]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Edit `src/components/comment/CommentList.jsx` and *remove* the following import:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `src/components/comment/CommentList.jsx` 并 *移除* 以下导入：
- en: '[PRE43]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '*Replace* it with an import to the `useUser` function:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*替换* 它为对 `useUser` 函数的导入：'
- en: '[PRE44]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '*Replace* the Local Storage Hook with our custom User Hook, as follows:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*替换* 本地存储钩子为我们的自定义用户钩子，如下所示：'
- en: '[PRE45]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '*Replace* the `username` check with a check for the `isLoggedIn` flag:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*替换* 对 `username` 的检查为对 `isLoggedIn` 标志的检查：'
- en: '[PRE46]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As we can see, the refactored code with the User Hook is already significantly
    easier to read. Instead of doing checks on the `username`, we are checking an
    `isLoggedIn` flag. Additionally, we are calling `login`, `register` and `logout`
    functions, abstracting implementation details and allowing the components to focus
    on their features. Doing this separates concerns about the application logic into
    custom Hooks, while components focus on the user interaction.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，使用用户钩子重构的代码已经显著易于阅读。我们不再对 `username` 进行检查，而是检查 `isLoggedIn` 标志。此外，我们调用
    `login`、`register` 和 `logout` 函数，抽象实现细节，使组件能够专注于其功能。这样做将应用程序逻辑的关注点分离到自定义钩子中，而组件则专注于用户交互。
- en: 'We can now start the dev server, as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以启动开发服务器，如下所示：
- en: '[PRE47]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: You will see that all functionality of our blog still works the same way as
    before.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到我们博客的所有功能仍然与之前一样工作。
- en: '**Example code**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例代码**'
- en: The example code for this section can be found in the `Chapter12/Chapter12_2`
    folder. Check the `README.md` file inside the folder for instructions on how to
    set up and run the example.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 本节示例代码可在 `Chapter12/Chapter12_2` 文件夹中找到。请检查文件夹内的 `README.md` 文件，了解如何设置和运行示例。
- en: Now that we finished creating the custom User Hook, let’s move on to creating
    custom Hooks for API calls.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了自定义用户钩子的创建，让我们继续创建用于 API 调用的自定义钩子。
- en: Creating custom API Hooks
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义 API 钩子
- en: We can also create Hooks for the various API calls. Putting these Hooks in a
    single file allows us to adjust the API calls easily later on. We are going to
    prefix our custom API Hooks with `useAPI` so it is easy to tell which functions
    are API Hooks.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以为各种 API 调用创建钩子。将这些钩子放在一个文件中，使我们能够轻松地调整 API 调用。我们将使用 `useAPI` 作为自定义 API
    钩子的前缀，以便容易区分哪些函数是 API 钩子。
- en: Extracting custom API Hooks
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提取自定义 API 钩子
- en: 'Let’s create custom Hooks for our API now by following these steps:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤创建我们的 API 自定义钩子：
- en: 'Copy the `Chapter12_2` folder to a new `Chapter12_3` folder by executing the
    following command:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令将 `Chapter12_2` 文件夹复制到新的 `Chapter12_3` 文件夹：
- en: '[PRE48]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Open the new `Chapter12_3` folder in VS Code.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中打开新的 `Chapter12_3` 文件夹。
- en: Create a new `src/hooks/api.js` file.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `src/hooks/api.js` 文件。
- en: 'Edit `src/hooks/api.js` and import the following functions:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `src/hooks/api.js` 并导入以下函数：
- en: '[PRE49]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Define a function to fetch posts, copied over from the code we had in `src/components/post/PostFeed.jsx`:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数来获取帖子，从我们在 `src/components/post/PostFeed.jsx` 中的代码复制过来：
- en: '[PRE50]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Define a function to fetch a single post, copied over from the code we had
    in `src/components/post/Post.jsx`:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数来获取单个帖子，从我们在 `src/components/post/Post.jsx` 中的代码复制过来：
- en: '[PRE51]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Define a function to search for posts, copied over from the code we had in
    `src/components/post/PostSearchResults.jsx`:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数来搜索帖子，从我们在 `src/components/post/PostSearchResults.jsx` 中的代码复制过来：
- en: '[PRE52]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Define a function to create posts, copied over from the code we had in `src/components/post/CreatePost.jsx`:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数来创建帖子，从我们在 `src/components/post/CreatePost.jsx` 中的代码复制过来：
- en: '[PRE53]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Similarly to the User Hook, the API Hooks abstract implementation details and
    only expose the necessary information, such as the `data` or the `mutateAsync`
    function. This means that we could even swap out React Query for a different library
    later, simply by adjusting the custom API Hooks.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 与用户钩子类似，API 钩子抽象了实现细节，只暴露必要的信息，例如 `data` 或 `mutateAsync` 函数。这意味着我们甚至可以在以后简单地通过调整自定义
    API 钩子来替换 React Query 为不同的库。
- en: We can now refactor our blog app to use the custom API Hooks.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将我们的博客应用程序重构为使用自定义 API 钩子。
- en: Using custom API Hooks
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自定义 API 钩子
- en: 'Follow these steps to refactor the app to use the previously defined API Hooks:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤重构应用程序以使用先前定义的 API 钩子：
- en: 'Edit `src/components/post/PostFeed.jsx` and *remove* the following imports:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `src/components/post/PostFeed.jsx` 并 *删除* 以下导入：
- en: '[PRE54]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '*Replace* them with an import of `useAPIFetchPosts`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*替换* 它们为 `useAPIFetchPosts` 的导入：'
- en: '[PRE55]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '*Replace* the Suspense Query Hook with our API Fetch Posts Hook:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*替换* 悬挂查询钩子为我们的 API 获取帖子钩子：'
- en: '[PRE56]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Instead of having implementation details on *how* we fetch posts from the API,
    we now only provide the information that is relevant to the component (whether
    the posts are featured or not). The rest is handled internally by the custom API
    Hook and can be changed later.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是在 *如何* 从 API 获取帖子实现细节上，我们现在只提供与组件相关的信息（帖子是否为特色帖子）。其余的由自定义 API 钩子内部处理，并且可以在以后更改。
- en: 'Edit `src/components/post/Post.jsx` and *remove* the following imports:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `src/components/post/Post.jsx` 并 *删除* 以下导入：
- en: '[PRE57]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '*Replace* them with an import of `useAPIFetchPost`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*替换* 它们为 `useAPIFetchPost` 的导入：'
- en: '[PRE58]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '*Replace* the Suspense Query Hook with our API Fetch Posts Hook:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*替换* 悬挂查询钩子为我们的 API 获取帖子钩子：'
- en: '[PRE59]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Edit `src/components/post/PostSearchResults.jsx` and *remove* the following
    imports:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `src/components/post/PostSearchResults.jsx` 并 *删除* 以下导入：
- en: '[PRE60]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '*Replace* them with an import of `useAPISearchPosts`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*替换* 它们为 `useAPISearchPosts` 的导入：'
- en: '[PRE61]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '*Replace* the Suspense Query Hook with our API Fetch Posts Hook:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*替换* 悬挂查询钩子为我们的 API 获取帖子钩子：'
- en: '[PRE62]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Edit `src/components/post/CreatePost.jsx` and *remove* the following imports:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `src/components/post/CreatePost.jsx` 并 *删除* 以下导入：
- en: '[PRE63]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '*Replace* them with an import of `useAPICreatePost`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*替换* 它们为 `useAPICreatePost` 的导入：'
- en: '[PRE64]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '*Remove* the existing Mutation Hook:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*删除* 现有的突变钩子：'
- en: '[PRE65]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '*Replace* it with our API Create Post Hook:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '*替换* 它为我们的 API 创建帖子钩子：'
- en: '[PRE66]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We can now directly call the `createPost` function, as follows:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以直接调用 `createPost` 函数，如下所示：
- en: '[PRE67]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Start the dev server, and make sure that everything still works like before:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动开发服务器，并确保一切仍然像以前一样工作：
- en: '[PRE68]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Again, refactoring to use custom Hooks has made our components easier to read,
    allowing us to focus on the user interaction logic, while our custom Hooks deal
    with the application logic internally.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，重构以使用自定义钩子使我们的组件更容易阅读，使我们能够专注于用户交互逻辑，而我们的自定义钩子则处理内部的应用逻辑。
- en: '**Example code**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例代码**'
- en: The example code for this section can be found in the `Chapter12/Chapter12_3`
    folder. Check the `README.md` file inside the folder for instructions on how to
    set up and run the example.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的示例代码可以在 `Chapter12/Chapter12_3` 文件夹中找到。请检查文件夹内的 `README.md` 文件，了解如何设置和运行示例。
- en: After creating custom API Hooks, let’s move on to creating a Debounced History
    State Hook.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建自定义 API 钩子之后，让我们继续创建一个防抖历史状态钩子。
- en: Creating a Debounced History State Hook
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个防抖历史状态钩子
- en: We are now going to create a slightly more advanced Hook for debounced history
    state functionality. In [*Chapter 10*](Chapter_10.xhtml#_idTextAnchor250), *Using
    Community Hooks*, we learned about the History State Hook, which allowed us to
    implement undo/redo functionality in the `CreatePost` component. We then used
    a Debounce Hook to avoid storing every single change in the history, allowing
    us to undo/redo larger parts of the text instead of a single character at a time.
    Now, we are going to extract this combined functionality into a custom Debounced
    History State Hook.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将创建一个稍微更高级的 Hook，用于防抖历史状态功能。在 [*第 10 章*](Chapter_10.xhtml#_idTextAnchor250)
    *使用社区 Hooks* 中，我们学习了 History State Hook，它允许我们在 `CreatePost` 组件中实现撤销/重做功能。然后我们使用
    Debounce Hook 来避免将每个单独的更改存储在历史记录中，这样我们可以一次性撤销/重做更大的文本部分，而不是逐个字符。现在，我们将这个组合功能提取到一个自定义的
    Debounced History State Hook 中。
- en: While this functionality is currently only used in one component, it is a generic
    feature that could be used in other components. Also, abstracting this functionality
    into a separate Hook allows us to keep the `CreatePost` component code clean and
    concise.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个功能目前只在一个组件中使用，但它是一个通用的功能，可以在其他组件中使用。此外，将这个功能抽象成一个单独的 Hook 可以让我们保持 `CreatePost`
    组件代码的简洁和简洁。
- en: Creating the Debounced History State Hook
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Debounced History State Hook
- en: 'Let’s now get started extracting the code from the `CreatePost` component into
    a Debounced History State Hook:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始从 `CreatePost` 组件中提取代码到 Debounced History State Hook：
- en: 'Copy the `Chapter12_3` folder to a new `Chapter12_4` folder by executing the
    following command:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令将 `Chapter12_3` 文件夹复制到新的 `Chapter12_4` 文件夹：
- en: '[PRE69]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Open the new `Chapter12_4` folder in VS Code.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中打开新的 `Chapter12_4` 文件夹。
- en: Create a new `src/hooks/debouncedHistoryState.js` file.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `src/hooks/debouncedHistoryState.js` 文件。
- en: 'Inside it, import the following:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中，导入以下内容：
- en: '[PRE70]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Define a function that accepts an initial state and a timeout value for the
    debounce:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数，该函数接受初始状态和防抖超时值：
- en: '[PRE71]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now, define the History State Hook:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定义 History State Hook：
- en: '[PRE72]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Next, define a State Hook for the actively edited content:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，定义一个用于活动编辑内容的 State Hook：
- en: '[PRE73]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Then, define a Debounced Callback Hook that will set the value of the History
    State Hook:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义一个将设置 History State Hook 值的 Debounced Callback Hook：
- en: '[PRE74]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Add the Effect Hook that we had before in the `CreatePost` component:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `CreatePost` 组件中添加我们之前使用的 Effect Hook：
- en: '[PRE75]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Remember, this Effect Hook is used to sync the History State back into the actively
    edited `content` state, meaning that it will change the content of the textbox
    whenever we trigger the `undo`, `redo`, or `clear` functionality.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这个 Effect Hook 用于将历史状态同步回正在编辑的 `content` 状态，这意味着每当触发 `撤销`、`重做` 或 `清除` 功能时，它都会更改文本框的内容。
- en: 'Now, define a handler function which sets the `content` state and starts the
    debounced callback:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定义一个设置 `content` 状态并启动防抖回调的处理函数：
- en: '[PRE76]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Finally, return all the values and functions we need from the Hook:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，从 Hook 返回所有需要的值和函数：
- en: '[PRE77]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Now we have a drop-in replacement for the Debounced History State functionality,
    which we now use in the `CreatePost` component, so let’s do it!
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了 Debounced History State 功能性的直接替换品，我们现在在 `CreatePost` 组件中使用它，所以让我们开始吧！
- en: Using the Debounced History State Hook
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Debounced History State Hook
- en: 'Follow these steps to refactor the `CreatePost` component to use the Debounced
    History State Hook:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤重构 `CreatePost` 组件以使用 Debounced History State Hook：
- en: 'Edit `src/components/post/CreatePost.jsx` and *remove* the following highlighted
    imports:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `src/components/post/CreatePost.jsx` 并 *删除* 以下突出显示的导入：
- en: '[PRE78]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Add an import of the `useDebouncedHistoryState` function:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `useDebouncedHistoryState` 函数的导入：
- en: '[PRE79]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '*Remove* all of the following code:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*删除* 以下所有代码：'
- en: '[PRE80]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '*Replace* it with the Debounced History State Hook:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '*替换* 它为 Debounced History State Hook：'
- en: '[PRE81]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '*Remove* the following handler function:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*删除* 以下处理函数：'
- en: '[PRE82]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Start the dev server and ensure that creating a post and undo/redo still work:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动开发服务器并确保创建帖子以及撤销/重做功能仍然正常工作：
- en: '[PRE83]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: That’s all there is to it – now the `CreatePost` component code is much less
    cluttered!
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是全部了——现在 `CreatePost` 组件的代码变得更加简洁！
- en: '**Example code**'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例代码**'
- en: The example code for this section can be found in the `Chapter12/Chapter12_4`
    folder. Check the `README.md` file inside the folder for instructions on how to
    set up and run the example.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 本节示例代码位于 `Chapter12/Chapter12_4` 文件夹中。请检查文件夹内的 `README.md` 文件，了解如何设置和运行示例。
- en: After creating the Debounced History State Hook, let’s move on to learn about
    testing custom Hooks.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 Debounced History State Hook 之后，让我们继续学习如何测试自定义 Hooks。
- en: Testing custom Hooks
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试自定义 Hooks
- en: Now our blog application fully makes use of Hooks! We even defined custom Hooks
    for various functions to make our code more reusable, concise, and easy to read.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的博客应用完全利用了 Hooks！我们甚至为各种功能定义了自定义 Hooks，使我们的代码更具可重用性、简洁性，并且易于阅读。
- en: When creating custom Hooks, it also makes sense to write unit tests for them
    to ensure they work properly, even when we change them later on or add more options.
    We are going to use **Vitest** to write our unit tests. Vitest and Vite go very
    well together, because Vitest can read and use Vite configurations. Vitest also
    offers a Jest-compatible API. **Jest** is another very popular testing framework.
    If you are already familiar with Jest, learning Vitest will be a breeze. Additionally,
    Vitest is very fast and well equipped for modern web apps.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建自定义 Hook 时，为它们编写单元测试以确保它们正常工作也是有意义的，即使我们在以后更改它们或添加更多选项。我们将使用 **Vitest** 来编写我们的单元测试。Vitest
    和 Vite 一起使用得非常好，因为 Vitest 可以读取和使用 Vite 配置。Vitest 还提供了与 Jest 兼容的 API。**Jest** 是另一个非常流行的测试框架。如果你已经熟悉
    Jest，学习 Vitest 将会非常容易。此外，Vitest 非常快，非常适合现代 Web 应用。
- en: However, as a result of the rules of Hooks, we cannot call Hooks from the test
    functions because they can only be called inside the body of a functional React
    component. As we do not want to create a component specifically for each test,
    we are going to use the React Testing Library to test Hooks directly. This library
    actually creates a test component and provides various utility functions to interact
    with Hooks.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于 Hooks 的规则，我们无法在测试函数中调用 Hooks，因为它们只能在功能 React 组件的主体内部调用。由于我们不希望为每个测试创建一个特定的组件，我们将使用
    React 测试库直接测试 Hooks。这个库实际上创建了一个测试组件，并提供了一些实用函数来与 Hooks 交互。
- en: 'In the past, there were two libraries: The React Testing Library and the React
    Hooks Testing Library. However, nowadays the React Testing Library already includes
    support for rendering and testing Hooks out of the box, so it is the perfect fit
    for testing React components and Hooks! The React Hooks Testing Library is deprecated
    now, so we will only be using the React Testing Library.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，有两个库：React 测试库和 React Hooks 测试库。然而，如今 React 测试库已经内置了对渲染和测试 Hooks 的支持，因此它是测试
    React 组件和 Hooks 的完美选择！React Hooks 测试库现在已被弃用，所以我们只会使用 React 测试库。
- en: 'We should particularly write tests for Hooks in the following circumstances:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下，我们应该特别为 Hooks 编写测试：
- en: When writing libraries that define and export Hooks
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当编写定义和导出 Hooks 的库时
- en: When you have Hooks that are used throughout multiple components
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你有在多个组件中使用的 Hooks 时
- en: When a Hook is complex and will thus be difficult to change/refactor later
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个 Hook 复杂，因此难以在以后更改/重构时
- en: 'When you have Hooks that are specific to one component, it is often better
    to just test the component directly. However, testing React components is out
    of scope of this book. More information about testing components can be found
    on the React Testing Library website: [https://testing-library.com/docs/react-testing-library/intro/](https://testing-library.com/docs/react-testing-library/intro/)'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有特定于一个组件的 Hooks 时，通常最好是直接测试该组件。然而，测试 React 组件超出了本书的范围。有关测试组件的更多信息可以在 React
    测试库网站上找到：[https://testing-library.com/docs/react-testing-library/intro/](https://testing-library.com/docs/react-testing-library/intro/)
- en: Now, let’s get started setting up Vitest and the React Testing Library!
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始设置 Vitest 和 React 测试库！
- en: Setting up Vitest and the React Testing Library
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 Vitest 和 React 测试库
- en: 'Before we can start writing tests for our Hooks, we first need to set up Vitest
    and the React Testing Library:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以开始为我们的 Hooks 编写测试之前，我们首先需要设置 Vitest 和 React 测试库：
- en: 'Copy the `Chapter12_4` folder to a new `Chapter12_5` folder by executing the
    following command:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令将 `Chapter12_4` 文件夹复制到新的 `Chapter12_5` 文件夹：
- en: '[PRE84]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Open the new `Chapter12_5` folder in VS Code.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中打开新的 `Chapter12_5` 文件夹。
- en: 'Install Vitest, the React Testing Library, and jsdom, by executing the following
    command:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令安装 Vitest、React 测试库和 jsdom：
- en: '[PRE85]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: jsdom provides an environment to access the DOM in Node.js. Since our tests
    are not actually running in a browser, it is necessary to provide such an environment
    to be able to render React components and test Hooks.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: jsdom 为 Node.js 提供了一个访问 DOM 的环境。由于我们的测试实际上并没有在浏览器中运行，因此提供这样一个环境是必要的，以便能够渲染 React
    组件并测试 Hooks。
- en: 'Edit `package.json` and add a script for running Vitest:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `package.json` 并添加一个用于运行 Vitest 的脚本：
- en: '[PRE86]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Finally, edit `vite.config.js` and add a config for Vitest at the end of the
    file:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，编辑 `vite.config.js` 并在文件末尾添加一个 Vitest 配置：
- en: '[PRE87]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Now that we have successfully set up Vitest, we can start testing Hooks!
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功设置了 Vitest，我们可以开始测试 Hooks 了！
- en: Testing a simple Hook
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试一个简单的 Hook
- en: First of all, we are going to test a very simple Hook that does not make use
    of contexts or asynchronous code such as timeouts. To do this, we are going to
    create a new Hook called `useCounter`. Then, we are going to test various parts
    of the Hook.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将测试一个非常简单的 Hook，它不使用上下文或异步代码，如超时。为此，我们将创建一个新的 Hook，称为 `useCounter`。然后，我们将测试
    Hook 的各个部分。
- en: Creating the Counter Hook
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 Counter Hook
- en: 'The Counter Hook is going to provide a current `count` and functions to `increment`
    and `reset` the counter. Follow these steps to create it:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Counter Hook 将提供一个当前的 `count` 以及用于 `increment` 和 `reset` 计数的函数。按照以下步骤创建它：
- en: Create a new `src/hooks/counter.js` file.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `src/hooks/counter.js` 文件。
- en: 'Inside it, import the `useState` function:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中，导入 `useState` 函数：
- en: '[PRE88]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Then, define a Counter Hook, which takes an `initialCount` as argument:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义一个接受 `initialCount` 作为参数的 Counter Hook：
- en: '[PRE89]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Define a State Hook for the count:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个用于计数的 State Hook：
- en: '[PRE90]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Now, define a function to increment the count by 1:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定义一个函数来将计数增加 1：
- en: '[PRE91]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Next, define a function to reset the counter to the initial count:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，定义一个函数将计数重置为初始计数：
- en: '[PRE92]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Return the current count and the two functions:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回当前计数和两个函数：
- en: '[PRE93]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Now that we have defined a simple Hook, we can start writing our first tests.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了一个简单的 Hook，我们可以开始编写我们的第一个测试。
- en: Creating unit tests for the Counter Hook
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为 Counter Hook 创建单元测试
- en: 'Let’s now write unit tests for the Counter Hook by following these steps:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们按照以下步骤编写 Counter Hook 的单元测试：
- en: Create a new `src/hooks/counter.test.js` file.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `src/hooks/counter.test.js` 文件。
- en: 'Inside it, import the `describe`, `test` and `expect` functions from Vitest,
    as well as the `renderHook` and `act` functions from the React Testing Library:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中，从 Vitest 导入 `describe`、`test` 和 `expect` 函数，以及从 React Testing Library 导入的
    `renderHook` 和 `act` 函数：
- en: '[PRE94]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Also, import the `useCounter` function, which we are going to write tests for:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，导入 `useCounter` 函数，我们将为其编写测试：
- en: '[PRE95]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Now, we can start defining tests. In Vitest, we can use the `describe` function
    to define a group of tests. The first argument is a name for the group, the second
    argument is an options object to configure the test (we leave this as an empty
    object), and the third argument is a function in which we can define our various
    tests. Here, we create a group of tests for the Counter Hook, so let’s call it
    that:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以开始定义测试。在 Vitest 中，我们可以使用 `describe` 函数来定义一组测试。第一个参数是组名，第二个参数是一个用于配置测试的选项对象（我们将其留为空对象），第三个参数是一个函数，在其中我们可以定义我们的各种测试。在这里，我们为
    Counter Hook 创建一组测试，所以让我们称它为：
- en: '[PRE96]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Inside the group, we can now define our tests. To define a test, we use the
    `test` function. The first argument is the name of the test, the second argument
    the test options, and the third argument is a function to be executed as the test.
    In our first test, we check if the Hook returns 0 by default:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组内，我们现在可以定义我们的测试。要定义一个测试，我们使用 `test` 函数。第一个参数是测试的名称，第二个参数是测试选项，第三个参数是要执行的测试函数。在我们的第一个测试中，我们检查
    Hook 默认返回 0：
- en: '[PRE97]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'In this test, we use the `renderHook` function to simulate the Hook being rendered
    in a React component. It returns an object for us, which includes a `result`:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个测试中，我们使用 `renderHook` 函数来模拟 Hook 在 React 组件中被渲染。它返回一个对象给我们，其中包含一个 `result`：
- en: '[PRE98]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'We can now access the `count` by getting it from the `result.current` object,
    and check if it is 0:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以通过从 `result.current` 对象中获取它来访问 `count`，并检查它是否为 0：
- en: '[PRE99]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'With the `expect` function we can do tests on values. It works as follows:
    `expect(actualValue).toBe(expectedValue)`. If the `actualValue` matches the `expectedValue`,
    the test will succeed. Otherwise, it will fail.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `expect` 函数可以对值进行测试。它的工作方式如下：`expect(actualValue).toBe(expectedValue)`。如果
    `actualValue` 与 `expectedValue` 匹配，测试将成功。否则，它将失败。
- en: 'There are many kinds of matchers to be used with `expect` – `toBe` is just
    one of them! For a full list of matchers, please check out the Vitest API documentation:
    [https://vitest.dev/api/expect.html](https://vitest.dev/api/expect.html)'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `expect` 中可以使用许多种匹配器 —— `toBe` 只是其中之一！要查看匹配器的完整列表，请查看 Vitest API 文档：[https://vitest.dev/api/expect.html](https://vitest.dev/api/expect.html)
- en: If you have worked with Jest before, you will notice that the Vitest API is
    fully compatible with it, so all these functions will be familiar to you.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前使用过Jest，你会注意到Vitest API与它是完全兼容的，所以所有这些函数对你来说都很熟悉。
- en: 'Next, let’s define a test that checks if the `initialCount` argument works:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们定义一个测试来检查`initialCount`参数是否工作：
- en: '[PRE100]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Now, we define a test that checks if the increment function increments the
    counter:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们定义一个测试来检查增量函数是否增加计数器：
- en: '[PRE101]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'We can use the `act` function to trigger an action from the Hook. This function
    tells the React Testing Library that something is being triggered inside the Hook,
    causing the `result.current` value from the `renderHook` function to be updated:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`act`函数从Hook中触发一个动作。这个函数告诉React Testing Library在Hook内部正在触发某些操作，导致`renderHook`函数的`result.current`值被更新：
- en: '[PRE102]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Then, we can check if the new count is 1:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以检查新的计数是否为1：
- en: '[PRE103]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Next, let’s do a test that simulates the `initialCount` passed to the Counter
    Hook being changed by a prop change of a React component:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们进行一个测试，模拟传递给Counter Hook的`initialCount`通过React组件的属性更改而改变：
- en: '[PRE104]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'To simulate a React prop, we simply define a variable, then we define the Hook:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要模拟一个React属性，我们只需定义一个变量，然后定义一个Hook：
- en: '[PRE105]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'We can now change the prop by changing the variable and manually triggering
    a re-render of the React component, by using the `rerender` function returned
    from `renderHook`:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以通过更改变量并使用从`renderHook`返回的`rerender`函数手动触发React组件的重新渲染来更改属性：
- en: '[PRE106]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: As we have learned before, the React Testing Library creates a dummy component,
    which is used for testing the Hook. We can force this dummy component to rerender
    to simulate what would happen when props change in a real component.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所学的，React Testing Library创建了一个虚拟组件，用于测试Hook。我们可以强制这个虚拟组件重新渲染来模拟在真实组件中属性更改时会发生的情况。
- en: 'Now, we call the `reset` function and check if the count was reset to the new
    initial count:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们调用`reset`函数并检查计数是否已重置到新的初始计数：
- en: '[PRE107]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Run the tests, by executing the following command:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令来运行测试：
- en: '[PRE108]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Remember, for special scripts, such as `start` and `test`, we do not need to
    execute `npm run test`; we can simply execute `npm test`.
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记住，对于特殊的脚本，如`start`和`test`，我们不需要执行`npm run test`；我们可以简单地执行`npm test`。
- en: 'The following screenshot shows the result after executing `npm test`:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了执行`npm test`后的结果：
- en: '![Figure 12.1 – Running Vitest in watch mode](img/B31327_12_01.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1 – 在监视模式下运行Vitest](img/B31327_12_01.png)'
- en: Figure 12.1 – Running Vitest in watch mode
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 在监视模式下运行Vitest
- en: You will see that Vitest automatically runs the watch mode. This means that
    it will wait for file changes and automatically re-run tests for you. You can
    just keep running it in that mode throughout the rest of this chapter to see your
    tests executing as you write them.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到Vitest自动运行监视模式。这意味着它将等待文件更改并自动为你重新运行测试。你可以在整个章节的其余部分保持在该模式下运行，以查看你编写的测试执行情况。
- en: Testing the Theme Hook
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试Theme Hook
- en: Using the React Hooks Testing Library, we can also test more complex Hooks,
    such as those Hooks that make use of context. To test Hooks that make use of context,
    we first have to create a context wrapper, and then we can test the Hook.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 使用React Hooks Testing Library，我们还可以测试更复杂的Hooks，例如那些使用上下文的Hooks。要测试使用上下文的Hooks，我们首先必须创建一个上下文包装器，然后我们可以测试这个Hook。
- en: 'Let’s get started writing tests for the Theme Hook now:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始编写Theme Hook的测试：
- en: Create a new `src/hooks/theme.test.jsx` file. Please note that the file extension
    needs to be `.jsx`, not just `.js`, as we will be using JSX in that file.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`src/hooks/theme.test.jsx`文件。请注意，文件扩展名需要是`.jsx`，而不是`.js`，因为我们将在这个文件中使用JSX。
- en: 'Inside it, import the relevant functions from Vitest, the `renderHook` function,
    the `ThemeContext`, and the `useTheme` function:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中，从Vitest导入相关函数，包括`renderHook`函数、`ThemeContext`和`useTheme`函数：
- en: '[PRE109]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Now, define a `ThemeContextWrapper` component, which will set up the context
    provider for testing:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定义一个`ThemeContextWrapper`组件，它将为测试设置上下文提供者：
- en: '[PRE110]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The wrapper accepts `children` as a prop, which is a special property of React
    components. It will contain all other components defined inside the wrapper, such
    as `<ThemeContextWrapper>{children}</ThemeContextWrapper>`.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 包装器接受`children`作为属性，这是React组件的一个特殊属性。它将包含包装器内部定义的所有其他组件，例如`<ThemeContextWrapper>{children}</ThemeContextWrapper>`。
- en: 'Inside the `wrapper` component, define the context provider and a value for
    `primaryColor`:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`wrapper`组件内部，定义上下文提供者和`primaryColor`的值：
- en: '[PRE111]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Now, we can begin writing tests for the Theme Hook. We start by creating a
    test group:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以开始编写主题钩子的测试了。我们首先创建一个测试组：
- en: '[PRE112]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Inside the group, we define a test which checks for the primary color:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组内，我们定义一个测试，用于检查主颜色：
- en: '[PRE113]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Then render the Hook, passing the wrapper component to the `renderHook` function:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后渲染钩子，将包装组件传递给`renderHook`函数：
- en: '[PRE114]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Now, check if the primary color is the same as we defined in the wrapper component:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，检查主颜色是否与我们定义在包装组件中的一致：
- en: '[PRE115]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'If you kept Vitest running in watch mode, you should see it successfully executing
    the test we just wrote! If not, start Vitest again by executing the following
    command:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你保持Vitest在监视模式下运行，你应该看到它成功执行了我们刚才编写的测试！如果不是，请通过执行以下命令重新启动Vitest：
- en: '[PRE116]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'The following image shows how Vitest automatically executes our newly defined
    test in watch mode:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了Vitest在监视模式下自动执行我们新定义的测试：
- en: '![Figure 12.2 – Vitest automatically executing our newly defined test](img/B31327_12_02.png)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![图12.2 – Vitest自动执行我们新定义的测试](img/B31327_12_02.png)'
- en: Figure 12.2 – Vitest automatically executing our newly defined test
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – Vitest自动执行我们新定义的测试
- en: Now that we have successfully written a test for the Theme Hook, let’s move
    on to the slightly more complex User Hook.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功编写了主题钩子的测试，让我们继续进行稍微复杂一些的用户钩子。
- en: Testing the User Hook
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试用户钩子
- en: The User Hook internally uses a Local Storage Hook now. Thankfully, the `jsdom`
    environment handles mocking the LocalStorage API for us already, so we do not
    need to do any setup for that.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 用户钩子现在内部使用本地存储钩子。幸运的是，`jsdom`环境已经为我们处理了模拟LocalStorage API，因此我们不需要为此进行任何设置。
- en: 'Let’s get started writing tests for the User Hook now:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始编写用户钩子的测试：
- en: Create a new `src/hooks/user.test.js` file.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`src/hooks/user.test.js`文件。
- en: 'Inside it, import the relevant functions from Vitest, as well as the `renderHook`,
    `act` and `useUser` functions:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中，从Vitest导入相关函数，以及`renderHook`、`act`和`useUser`函数：
- en: '[PRE117]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Then, define a test group for the User Hook:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，为用户钩子定义一个测试组：
- en: '[PRE118]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'For our first test, we ensure that the user is not logged in by default:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的第一次测试，我们确保用户默认未登录：
- en: '[PRE119]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Then, we test the registration functionality:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们测试注册功能：
- en: '[PRE120]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Next, we test the login functionality:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们测试登录功能：
- en: '[PRE121]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'For the final test, we make two actions, calling login first, then logout,
    and then we check if the user is logged out:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于最后的测试，我们执行两个操作，首先调用登录，然后登出，然后检查用户是否已登出：
- en: '[PRE122]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: You will see that Vitest executed all our tests and they are all passing! Now,
    let’s move on to the Debounced History State Hook.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到Vitest执行了所有我们的测试，并且它们都通过了！现在，让我们继续到去抖动历史状态钩子。
- en: Testing asynchronous Hooks
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试异步钩子
- en: Sometimes we need to test Hooks that perform asynchronous actions. This means
    that we need to wait a certain amount of time until we check the result.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们需要测试执行异步操作的钩子。这意味着我们需要等待一段时间，直到检查结果。
- en: To write tests for these kind of Hooks, we can use the `waitFor` function from
    the React Testing Library. This function can be used to wait for the condition
    to be met, instead of trying to match it immediately. It can thus be used to test
    asynchronous operations in React components and Hooks. If the condition fails
    to match even after a certain amount of time (which can be specified with an optional
    timeout parameter), the test will fail.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 要为这类钩子编写测试，我们可以使用React Testing Library中的`waitFor`函数。这个函数可以用来等待条件满足，而不是立即尝试匹配。因此，它可以用来测试React组件和钩子中的异步操作。如果条件在一定时间后（可以通过可选的超时参数指定）仍然无法匹配，测试将失败。
- en: Earlier in this chapter, we created the Debounced History State Hook, which
    only stores changes in the history after a certain amount of time, thus making
    it an asynchronous Hook. We are now going to use the `waitFor` function to test
    the debouncing in the Debounced History State Hook.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期，我们创建了去抖动的历史状态钩子，它只在一定时间后存储历史变化，因此使其成为一个异步钩子。现在，我们将使用`waitFor`函数来测试去抖动在去抖动历史状态钩子中的效果。
- en: 'Follow these steps to get started:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤开始：
- en: Create a new `src/hooks/debouncedHistoryState.test.js` file.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`src/hooks/debouncedHistoryState.test.js`文件。
- en: 'Inside it, import the relevant functions from Vitest, as well as the `renderHook`,
    `act` and `waitFor` functions from the React Testing Library, as well as the `useDebouncedHistoryState`
    function:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中，从Vitest导入相关函数，以及从React Testing Library导入的`renderHook`、`act`和`waitFor`函数，以及`useDebouncedHistoryState`函数：
- en: '[PRE123]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Define a test group and a first test, which just checks the initial value:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个测试组和第一个测试，该测试仅检查初始值：
- en: '[PRE124]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Now, we define a test that checks if the content is updated immediately:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们定义一个测试来检查内容是否立即更新：
- en: '[PRE125]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'For the final test, we check if the Hook updates the history only after a debounce:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于最后的测试，我们检查 Hook 是否仅在去抖动后更新历史记录：
- en: '[PRE126]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'In this test, we first define the Hook:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个测试中，我们首先定义 Hook：
- en: '[PRE127]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: We kept the debounce timeout as 10ms to avoid unnecessarily slowing down our
    test.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将去抖动超时保持在 10ms，以避免不必要地减慢我们的测试速度。
- en: 'Now, we trigger a content update:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们触发内容更新：
- en: '[PRE128]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Before debouncing, the `canUndo` value should be `false`, as there is nothing
    stored in the history state yet:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在去抖动之前，`canUndo` 值应该是 `false`，因为历史状态中还没有存储任何内容：
- en: '[PRE129]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Now we use `waitFor` to wait for the `canUndo` value to be true, which should
    happen after the debounce timeout (10ms):'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们使用 `waitFor` 等待 `canUndo` 值变为 true，这应该在去抖动超时（10ms）之后发生：
- en: '[PRE130]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Vitest will automatically run our new tests and we can see that they all succeed!
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: Vitest 将自动运行我们的新测试，我们可以看到它们都成功了！
- en: 'In this case, we have a very simple timeout. However, there may be more advanced
    cases where we have to wait for a longer time. For more control over dates and
    timers when testing Hooks, you can mock the system time using fake timers in Vitest.
    Check out the mocking guide on the official Vitest docs for more information:
    [https://vitest.dev/guide/mocking.html#dates](https://vitest.dev/guide/mocking.html#dates)'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有一个非常简单的超时。然而，可能存在更复杂的情况，我们需要等待更长的时间。在测试 Hooks 时，为了更好地控制日期和计时器，您可以使用
    Vitest 中的模拟计时器来模拟系统时间。有关更多信息，请查看官方 Vitest 文档中的模拟指南：[https://vitest.dev/guide/mocking.html#dates](https://vitest.dev/guide/mocking.html#dates)
- en: We are not testing the `undo`/`redo`/`clear` functionality, because those come
    from the History State Hook from the `useHooks` library, so it is out of scope
    for our custom Hook. In most cases, it is enough to only test the logic that we
    added in our own implementation.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有测试 `undo`/`redo`/`clear` 功能，因为这些来自 `useHooks` 库的历史状态 Hook，因此它超出了我们自定义 Hook
    的范围。在大多数情况下，仅测试我们自己在实现中添加的逻辑就足够了。
- en: Since the API Hooks are mostly wrappers for TanStack Query Hooks and do not
    add their own logic, it also does not make much sense to write tests for them.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 API Hooks 主要是对 TanStack Query Hooks 的包装，并没有添加自己的逻辑，因此为它们编写测试也没有太多意义。
- en: Running all tests
  id: totrans-409
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行所有测试
- en: 'To verify that all our tests are succeeding now, let’s quit the Vitest watch
    mode by pressing the *q* key. Then, run Vitest again by executing the following
    command:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证所有测试现在是否都成功，让我们通过按 *q* 键退出 Vitest 的监视模式。然后，通过执行以下命令再次运行 Vitest：
- en: '[PRE131]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'As we can see, Vitest executed all our tests again, and they are all passing:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Vitest 再次执行了所有我们的测试，并且它们都通过了：
- en: '![Figure 12.3 – All our tests are passing!](img/B31327_12_03.png)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.3 – 所有我们的测试都通过了！](img/B31327_12_03.png)'
- en: Figure 12.3 – All our tests are passing!
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.3 – 所有我们的测试都通过了！
- en: '**Example code**'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例代码**'
- en: The example code for this section can be found in the `Chapter12/Chapter12_5`
    folder. Check the `README.md` file inside the folder for instructions on how to
    set up and run the example.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的示例代码可以在 `Chapter12/Chapter12_5` 文件夹中找到。请检查文件夹内的 `README.md` 文件，以获取设置和运行示例的说明。
- en: Summary
  id: totrans-417
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we first learned how to extract custom Hooks from existing
    code in our blog app. We defined the Theme Hook to easily access the context,
    then we defined the User Hook, which manages user state and provides functions
    to register/login/logout. Then, we created API Hooks and a more advanced Hook
    for the debounced history state functionality. Finally, we learned about writing
    tests for our custom Hooks using Vitest and the React Testing Library.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先学习了如何从我们的博客应用中的现有代码中提取自定义 Hooks。我们定义了主题 Hook 以轻松访问上下文，然后定义了用户 Hook，它管理用户状态并提供注册/登录/注销的函数。然后，我们创建了
    API Hooks 和一个更高级的用于去抖动历史状态功能的 Hook。最后，我们学习了如何使用 Vitest 和 React 测试库为我们的自定义 Hooks
    编写测试。
- en: Knowing when and how to extract custom Hooks is a very important skill in React
    development. In a larger project, you are probably going to define many custom
    Hooks, specifically tailored to your project’s needs. Custom Hooks can also make
    it easier to maintain the application, as we only need to adjust functionality
    in one place. Testing custom Hooks is very important, because if we refactor our
    custom Hooks later on, we want to make sure that they still work properly.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 了解何时以及如何提取自定义Hook是React开发中非常重要的技能。在一个较大的项目中，你可能需要定义许多针对项目需求量身定制的自定义Hooks。自定义Hooks还可以使维护应用程序变得更加容易，因为我们只需要在一个地方调整功能。测试自定义Hook非常重要，因为如果我们稍后重构自定义Hook，我们想要确保它们仍然能够正常工作。
- en: In the next chapter, we are going to learn how to migrate from class components
    to a Hook-based system. We first create a small project using class components
    and then we replace them with Hooks, taking a closer look at the differences between
    the two solutions.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何从类组件迁移到基于Hooks的系统。我们首先使用类组件创建一个小项目，然后将其替换为Hooks，更仔细地比较两种解决方案之间的差异。
- en: Questions
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'To recap what we have learned in this chapter, try to answer the following
    questions:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回顾本章所学内容，请尝试回答以下问题：
- en: How can we extract a custom Hook from existing code?
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何从现有代码中提取自定义Hook？
- en: What is the advantage of creating custom Hooks?
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建自定义Hook的优势是什么？
- en: When should we extract functionality into a custom Hook?
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该在何时将功能提取到自定义Hook中？
- en: How do we use custom Hooks?
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使用自定义Hooks？
- en: Which library can we use to test custom Hooks?
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用哪个库来测试自定义Hooks？
- en: How are actions performed by Hooks tested?
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Hooks执行的动作是如何被测试的？
- en: How can we test Hooks that make use of React Context?
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何测试利用React Context的Hooks？
- en: How can we test Hooks that perform asynchronous operations?
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何测试执行异步操作的Hooks？
- en: Further reading
  id: totrans-431
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'If you are interested in more information about the concepts that we have learned
    in this chapter, take a look at the following links:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对本章所学的概念感兴趣，请查看以下链接：
- en: 'Guide on “Reusing Logic with Custom Hooks” in the official React docs: [https://react.dev/learn/reusing-logic-with-custom-hooks](https://react.dev/learn/reusing-logic-with-custom-hooks)'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在官方React文档中关于“使用自定义Hook重用逻辑”的指南：[https://react.dev/learn/reusing-logic-with-custom-hooks](https://react.dev/learn/reusing-logic-with-custom-hooks)
- en: 'Vitest documentation: [https://vitest.dev/](https://vitest.dev/ )'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vitest文档：[https://vitest.dev/](https://vitest.dev/ )
- en: 'React Testing Library documentation: [https://testing-library.com/docs/react-testing-library/intro/](https://testing-library.com/docs/react-testing-library/intro/)'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Testing Library文档：[https://testing-library.com/docs/react-testing-library/intro/](https://testing-library.com/docs/react-testing-library/intro/)
- en: Learn more on Discord
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Discord上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入本书的Discord社区——在那里你可以分享反馈、向作者提问，并了解新版本——请扫描下面的二维码：
- en: '[https://packt.link/wnXT0](Chapter_12.xhtml)'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/wnXT0](Chapter_12.xhtml)'
- en: '![](img/image_%283%29.png)'
  id: totrans-439
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_%283%29.png)'
