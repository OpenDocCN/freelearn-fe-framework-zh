- en: Third Project - The Facebook Client
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三项目 - Facebook客户端
- en: Until now, we've mainly built applications that deal only with information provided
    by a user. However, lots of applications tend to send and receive data from other
    sources around the web. For our third and final project in this book, we will build
    an app that accesses the external Facebook API so that users can access their
    profile.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要构建了仅处理用户提供的信息的应用程序。然而，许多应用程序倾向于从网络上的其他来源发送和接收数据。在本书的第三个也是最后一个项目中，我们将构建一个可以访问外部Facebook
    API的应用程序，以便用户可以访问他们的个人资料。
- en: 'In this chapter, you will do the following things:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将完成以下任务：
- en: Plan `Friends`, our Facebook application, by deciding what key factors it should
    have
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计划我们的Facebook应用“朋友”，决定它应该具备哪些关键因素
- en: Gain access to the Facebook API and install the official SDK for both iOS and
    Android
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取访问Facebook API的权限并安装iOS和Android的官方SDK
- en: Use the Facebook API's **Login** SDK to grant the app appropriate permissions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Facebook API的**登录**SDK授予应用适当的权限
- en: Grab information from the Facebook API using `GraphRequest` and `GraphRequestManager`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`GraphRequest`和`GraphRequestManager`从Facebook API获取信息
- en: Utilize an `ActivityIndicator` to let the user visually know that data is currently
    loading
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ActivityIndicator`让用户直观地知道数据正在加载
- en: Begin building the essential features of our Facebook application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始构建我们Facebook应用的基本功能
- en: Planning the app
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规划应用
- en: '`Friends` will be the first full-fledged example we build of just how powerful
    React Native is. It will deal with a lot of moving parts, so it''s good to plan
    out the app in depth. On a basic level, accessing the Facebook **Graph** API gives
    us the following permissions:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: “朋友”将是我们将构建的第一个完整的示例，展示React Native的强大功能。它将涉及许多动态部分，因此深入规划应用是很好的。在基本层面上，访问Facebook
    **Graph** API给我们以下权限：
- en: Signing in
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录
- en: Viewing your feed
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看您的动态
- en: Viewing the list of posts on your feed along with its comments and likes
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看您动态上的帖子列表及其评论和点赞
- en: Adding new posts and comments on your feed
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的动态上添加新的帖子或评论
- en: Browsing the photos that you've uploaded to your Facebook profile along with
    their comments and likes
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览您上传到Facebook个人资料的照片及其评论和点赞
- en: Viewing the events that you have RSVPd
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看您已确认参加的活动
- en: Rediscovering the list of pages that you have liked
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新发现您喜欢的页面列表
- en: 'As in the previous chapters, we want to break this off into bite-sized accomplishments.
    By the end of this chapter, `Friends` should do the following things:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，我们希望将其分解为小规模的成就。到本章结束时，“朋友”应用应实现以下功能：
- en: Prompt the user to sign in to Facebook, if they haven't already, and save their
    authentication token automatically with the SDK
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提醒用户（如果尚未登录）登录Facebook，并使用SDK自动保存其身份验证令牌
- en: While the feed is loading, show a spinning animation to visualize that data
    is loading
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在动态加载时，显示旋转动画以可视化数据正在加载
- en: Show the user their feed
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示用户的动态
- en: For each post on the feed, render the contents of the post along with the number
    of comments and likes on the post
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于动态上的每篇帖子，显示帖子的内容以及评论和点赞的数量
- en: Upon tapping, load and show just the comment chain of that specific post
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击时，加载并显示该特定帖子的评论链
- en: Allow the reader to respond to comments on a specific post or create a new post
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许读者对特定帖子的评论进行回复或创建新的帖子
- en: About the Facebook API
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于Facebook API
- en: Before we proceed further, a note about the level of access we can gain with
    the Facebook API--you will only be able to gain information about the user who
    is logged in. The specific user's friend list is inaccessible through Facebook's
    API, but a small subset of friends who have also installed the same app is available.
    Since it's not very useful in our project, I'm purposefully omitting it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，关于我们可以通过Facebook API获得的访问级别做一个说明——您只能获取已登录用户的个人信息。具体用户的好友列表通过Facebook的API无法访问，但可以访问一小部分也安装了相同应用的好友。由于在我们的项目中这并不很有用，我故意省略了它。
- en: While the user's posts and photos will certainly have a list of comments along
    with the names and pictures of the people who posted them, accessing those friends'
    profiles is not possible using the current iteration of the Facebook API.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然用户的帖子和个人照片肯定会有一个包含发表评论的人的姓名和照片的评论列表，但使用当前版本的Facebook API无法访问这些好友的个人资料。
- en: Obtaining Facebook API credentials
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取Facebook API凭证
- en: This looks like a great starting point. However, before we can begin, we need
    to register our app with Facebook. Head over to Facebook's developer site and
    select Add a New App. At the time of writing, the URL is [https://developers.facebook.com](https://developers.facebook.com).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来是一个很好的起点。然而，在我们开始之前，我们需要将我们的应用注册到 Facebook 上。请访问 Facebook 的开发者网站并选择添加新应用。撰写本文时，网址是
    [https://developers.facebook.com](https://developers.facebook.com)。
- en: Once you have your application registered, download the Facebook SDK for iOS
    at [https://developers.facebook.com/docs/ios/](https://developers.facebook.com/docs/ios/)
    and unzip its contents to your `Documents` folder, naming it `FacebookSDK`. Keep
    this folder open; we will need it shortly.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您注册了您的应用，请从 [https://developers.facebook.com/docs/ios/](https://developers.facebook.com/docs/ios/)
    下载 iOS 的 Facebook SDK，并将其内容解压缩到您的 `Documents` 文件夹中，命名为 `FacebookSDK`。请保持此文件夹打开；我们很快就会用到它。
- en: 'After that, go to the dashboard of your application and take note of the App
    ID. You''ll also need this in a moment. You can find it here:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，前往您应用的仪表板并注意 App ID。您稍后也需要这个信息。您可以在以下位置找到它：
- en: '![](img/image_05_001.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_05_001.png)'
- en: In the following section, we'll look at how to install the official Facebook
    SDK for React Native.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何安装官方的 React Native Facebook SDK。
- en: Installing the Facebook SDK on iOS and Android
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 iOS 和 Android 上安装 Facebook SDK
- en: 'Initialize a new React Native project using the following command line:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令行初始化一个新的 React Native 项目：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Afterwards, navigate to the new project you just created using a command line.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用命令行导航到您刚刚创建的新项目。
- en: 'The Facebook SDK for React Native is available through `npm` in a package called
    `react-native-fbsdk`. We''ll install it as such:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: React Native 的 Facebook SDK 通过 `npm` 在名为 `react-native-fbsdk` 的包中提供。我们将这样安装它：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now link the SDK, as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照以下步骤链接 SDK：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, follow the detailed instructions on the `react-native-fbsdk` repo on GitHub
    found at [https://github.com/facebook/react-native-fbsdk](https://github.com/facebook/react-native-fbsdk).
    Since the installation instructions are prone to being changed at any given time,
    I highly recommend that you use the instructions found in that repo.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照 GitHub 上 `react-native-fbsdk` 仓库中的详细说明操作，该仓库位于 [https://github.com/facebook/react-native-fbsdk](https://github.com/facebook/react-native-fbsdk)。由于安装说明可能会随时更改，我强烈建议您使用该仓库中的说明。
- en: Afterward, install the `react-native-vector-icons` library that we used in `Expenses`
    using the process we saw earlier (refer to [Chapter 4](94aea5f2-1fde-4cb4-b28e-8b3c6354a298.xhtml), *Advanced
    Functionality with the Expenses App*, if you need a refresher).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，使用我们之前看到的流程（如需复习，请参阅第 4 章，*使用 Expenses 应用的高级功能*）安装 `react-native-vector-icons`
    库。
- en: Once you have initialized the app for this project and installed both the Facebook
    SDK and `react-native-vector-icons` library, it's time to start playing around.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您为该项目初始化了应用并安装了 Facebook SDK 和 `react-native-vector-icons` 库，就到了开始玩耍的时候了。
- en: Logging in with the Facebook SDK
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Facebook SDK 登录
- en: The first thing we can try in our app is logging in the user. The FBSDK has
    access to a built-in component called `LoginButton` that, on press, will send
    the user to a login screen using a `WebView` while being within the app. If the
    login is successful, an access token will be saved for your app to make use of,
    without you needing to personally track it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在应用中尝试的第一件事是登录用户。FSBDK 有一个内置的组件称为 `LoginButton`，当按下时，它将使用 `WebView` 在应用内部将用户发送到登录屏幕。如果登录成功，将为您保存一个访问令牌，供您的应用使用，而无需您亲自跟踪它。
- en: 'Start by adding the `LoginButton` snippet found in the FBSDK repository''s
    `README` to your app''s `index` file. You''ll get something like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将 FBSDK 仓库的 `README` 中的 `LoginButton` 片段添加到您的应用的 `index` 文件中。您将得到类似以下的内容：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Import the `AccessToken` and `LoginButton` modules from the `react-native-fbsdk`
    repo, using destructuring notation.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `react-native-fbsdk` 仓库导入 `AccessToken` 和 `LoginButton` 模块，使用解构符号。
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `readPermissions` prop accepts an array of strings and asks the user for
    specific read-only permissions equal to the array passed in.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`readPermissions` 属性接受一个字符串数组，并请求用户特定的只读权限，这些权限等于传入的数组。'
- en: 'The Facebook API has a lot of different permissions you can request, and for
    the purposes of this project, we will ask for the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook API 有很多不同的权限可以请求，为了本项目的目的，我们将请求以下权限：
- en: '`public_profile`: This provides access to a subset of items that are part of
    the user''s public Facebook profile. This includes their ID, name, profile picture,
    and more.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public_profile`：这提供了访问用户公共Facebook资料中的一部分内容。这包括他们的ID、姓名、个人资料图片等。'
- en: '`user_events`: This is a list of events that a person is either hosting or
    has RSVPd to.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user_events`：这是一个列表，其中包含一个人正在举办或已响应的事件。'
- en: '`user_likes`: This is the collection of Facebook pages that the user has clicked
    Like on.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user_likes`：这是用户点击赞的Facebook页面的集合。'
- en: '`user_photos`: These are the user''s uploaded or tagged photos.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user_photos`：这是用户上传或标记的照片。'
- en: '`user_posts`: These are the posts on the user''s timeline.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user_posts`：这是用户时间线上的帖子。'
- en: 'The `onLoginFinished` method is written to be asynchronous:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`onLoginFinished`方法被编写为异步的：'
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'While there are some other props available for `LoginButton`, the three presented
    in the preceding code are the only ones we will worry about. Here''s what each
    of these props refer to:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`LoginButton`还有一些其他属性可用，但在前面代码中展示的三个是我们需要关注的。以下是每个属性的含义：
- en: '`publishPermissions`: This represents the publishing permissions to request
    from the logged-in user when the button is pressed'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`publishPermissions`：这表示在按钮按下时请求登录用户的发布权限。'
- en: '`onLoginFinished`: This is a callback that gets invoked when a login request
    has either been completed or produces an error'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onLoginFinished`：这是一个在登录请求完成或产生错误时被调用的回调。'
- en: '`onLogoutFinished`: This is another `callback` that invokes itself when a logout
    request has been completed'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onLogoutFinished`：这是一个在注销请求完成后调用的回调。'
- en: 'If everything works out, you will see the following screen with the Facebook
    log in button--Log in with Facebook, in the center:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你将看到以下带有Facebook登录按钮的屏幕--居中的“使用Facebook登录”：
- en: '![](img/image_05_002-1.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_002-1.png)'
- en: By tapping on this logo, you will be taken to a login page within a `WebView`
    component that handles Facebook login.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击此标志，你将被带到`WebView`组件内的登录页面，该组件处理Facebook登录。
- en: 'After logging in, the user will see a prompt that asks for read-only permissions
    equal to the ones we asked for in the `readPermissions` array passed in as a prop
    to the `LoginButton` component:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，用户将看到一个提示，要求读取权限等于我们通过`LoginButton`组件作为属性传递的`readPermissions`数组中请求的权限：
- en: '![](img/image_05_003-1.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_003-1.png)'
- en: Once your user is authorized, you'll be able to grab data from Facebook's Graph
    API.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的用户获得授权，您将能够从Facebook的Graph API中获取数据。
- en: Using the Facebook Graph API
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Facebook Graph API
- en: The FBSDK lets us make requests to the Facebook Graph API using the `GraphRequest`
    and `GraphRequestManager` classes to create those requests and execute them.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: FBSDK允许我们使用`GraphRequest`和`GraphRequestManager`类来创建请求并执行这些请求。
- en: '`GraphRequest` is used to create a request to the Graph API, while `GraphRequestManager`
    is called to execute that request.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`GraphRequest`用于创建对Graph API的请求，而`GraphRequestManager`用于执行该请求。'
- en: GraphRequest
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GraphRequest
- en: 'To instantiate a new `GraphRequest`, we can pass up to three arguments:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要实例化一个新的`GraphRequest`，我们可以传递最多三个参数：
- en: '`graphPath`: This is a string pertaining to the endpoint in the Graph API that
    we wish to hit. For example, to get information about the logged-in user, a `graphPath`
    of `/me` will be used.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`graphPath`：这是一个与Graph API端点相关的字符串，表示我们希望触发的端点。例如，要获取登录用户的信息，将使用`graphPath`为`/me`。'
- en: '`config`: This is an optional object that can configure the request. The props
    that this object accepts are all optional:'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config`：这是一个可选的对象，可以配置请求。该对象接受的属性都是可选的：'
- en: '`httpMethod`: This is a string that describes the HTTP method for this request,
    for example, `GET` or `POST`.'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`httpMethod`：这是一个描述此请求HTTP方法的字符串，例如`GET`或`POST`。'
- en: '`version`: This is a string that describes the specific Graph API version to
    use.'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`version`：这是一个描述要使用的特定Graph API版本的字符串。'
- en: '`parameters`: This is an object containing the request''s parameters.'
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parameters`：这是一个包含请求参数的对象。'
- en: '`accessToken`: This is a stringified version of the access token used by this
    request.'
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`accessToken`：这是请求使用的访问令牌的字符串版本。'
- en: '`callback`: This is a callback function that is fired once the request has
    either been completed or has failed.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`callback`：这是一个在请求完成或失败时触发的回调函数。'
- en: 'A sample `GraphRequest` instance will look like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例`GraphRequest`实例将看起来像这样：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For this request to be executed, we will use `GraphRequestManager`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行此请求，我们将使用`GraphRequestManager`。
- en: GraphRequestManager
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`GraphRequestManager`'
- en: The `GraphRequestManager` queue requests the Facebook Graph API and executes
    it when told to do so.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`GraphRequestManager`队列请求Facebook Graph API，并在被指示时执行它。'
- en: 'It has access to the following methods:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以访问以下方法：
- en: '`addRequest`: This is a function that accepts an instance of `GraphRequest`
    and pushes the request into the queue of `GraphRequestManager`. It also pushes
    the callback into a separate `requestCallbacks` queue for execution once the request
    has been completed or failed.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addRequest`: 这是一个接受`GraphRequest`实例并将请求推入`GraphRequestManager`队列中的函数。它还将回调推入一个单独的`requestCallbacks`队列，以便在请求完成或失败时执行。'
- en: '`addBatchCallback`: This accepts an optional callback to be executed once the
    entire batch of requests has been completed. Each instance of `GraphRequestManager`
    can only accept up to one callback, and the invocation of that callback does not
    indicate that every graph request in the batch was successful--the only thing
    it is indicative of is that the entire batch has completed execution.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addBatchCallback`: 这个方法接受一个可选的回调，在请求批次完成时执行。每个`GraphRequestManager`实例只能接受一个回调，调用该回调并不表示批次中的每个图请求都成功--它唯一表明的是整个批次已完成执行。'
- en: '`start`: This accepts an optional number equal to a timeout value. The timeout
    value defaults to 0 if it''s not passed in. When `GraphRequestManager.start` is
    invoked, the `GraphRequestManager` makes a series of requests to the Facebook
    Graph API on a first-in, first-out basis and executes the callbacks for each request
    made, if applicable.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start`: 这个方法接受一个可选的数字，其值等于超时时间。如果没有传入，则默认超时时间为0。当调用`GraphRequestManager.start`时，`GraphRequestManager`将按照先入先出的顺序向Facebook
    Graph API发起一系列请求，并在适用的情况下执行每个请求的回调函数。'
- en: 'Adding to the preceding example, a `GraphRequestManager` request looks something
    like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中添加，一个`GraphRequestManager`请求看起来像这样：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This request creates a new instance of `GraphRequestManager` complete with its
    own new batch, adds the preceding `requestMyPhotos` task to the batch, and then
    starts it. From here, the Facebook Graph API will return some form of data.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此请求创建了一个新的`GraphRequestManager`实例，包括其自己的新批次，将前面的`requestMyPhotos`任务添加到批次中，然后启动它。从这里开始，Facebook
    Graph API将返回某种形式的数据。
- en: The callback passed into the instance of `requestMyPhotos` in `GraphRequest`
    will then execute, logging either an error or the result of the request.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GraphRequest`的`requestMyPhotos`实例中传递的回调将执行，记录错误或请求的结果。
- en: Creating our first request
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的第一个请求
- en: It's time to create our first request to verify that the access token we've
    received has worked.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候创建我们的第一个请求来验证我们收到的访问令牌是否有效了。
- en: 'Within your `Friends` component in `index.ios.js`, let''s do the following
    things:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在`index.ios.js`中的`Friends`组件内，让我们做以下几件事情：
- en: Create a method, called `_getFeed`, that creates a `GraphRequest` to your Facebook
    feed. This method should grab data at the `/me/feed` endpoint and reference a
    callback to be executed when that `GraphRequest` is complete. You can skip the
    optional `config` object that `GraphRequest` can optionally accept.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为`_getFeed`的方法，该方法创建一个针对您的Facebook动态的`GraphRequest`。此方法应从`/me/feed`端点获取数据，并引用一个回调函数，当该`GraphRequest`完成时执行。您可以跳过`GraphRequest`可以可选接受的`config`对象。
- en: In the same `_getFeed` function, create a new `GraphRequestManager` and add
    the `GraphRequest` instance to it; then start the `GraphRequestManager`.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在相同的方法`_getFeed`中，创建一个新的`GraphRequestManager`实例，并将`GraphRequest`实例添加到其中；然后启动`GraphRequestManager`。
- en: For the callback referenced by `_getFeed`, have it log either the error or the
    result that it receives when your `GraphRequest` is completed.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于由`_getFeed`引用的回调，当您的`GraphRequest`完成时，记录它接收到的错误或结果。
- en: Call `_getFeed` as part of the `onLoginFinished` callback in `LoginButton`.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`LoginButton`的`onLoginFinished`回调中调用`_getFeed`。
- en: 'When you have finished, the result should look somewhat like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当您完成时，结果应该看起来像这样：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Rather than alerting the access token, I am calling `_getFeed`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我不是在提醒访问令牌，而是在调用`_getFeed`。
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create a new instance of `GraphRequest` by passing it the endpoint desired
    along with the callback to be fired once the request is complete:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通过传递期望的端点和请求完成后要触发的回调来创建一个新的`GraphRequest`实例：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, create a new instance of `GraphRequestManager`, add the `infoRequest`
    object to it, and then start the request:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个新的`GraphRequestManager`实例，将`infoRequest`对象添加到其中，然后启动请求：
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When the request is completed, it will log either the result or an error if
    one was encountered:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 请求完成后，它将记录结果或遇到的错误：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With your iOS simulator and remote debugging opened, check out your browser''s
    console as you log in:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的iOS模拟器和远程调试已打开的情况下，登录时查看浏览器控制台：
- en: '![](img/image_05_004.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_004.png)'
- en: This is great! It shows that we are linked up with the Graph API and that it
    accepts the access token we've given it. Now, let's create a separate `graphMethods.js`
    utility file that we can use in different components.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这太棒了！这表明我们已经与Graph API建立了联系，并且它接受我们给出的访问令牌。现在，让我们创建一个单独的`graphMethods.js`实用文件，我们可以在不同的组件中使用。
- en: GraphMethods
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图形方法
- en: The goal of this file is to create some commonly used methods that interact
    with the Facebook Graph API and export them so that we can use them in different
    components throughout the app.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件的目标是创建一些与Facebook Graph API交互的常用方法，并将它们导出，以便我们可以在应用程序的不同组件中使用。
- en: 'Like the utility files we created for `Expenses`, this `graphMethods` file
    should live inside a `utils` folder, nested inside an `app` folder that rests
    at the root level of our project:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们为`Expenses`创建的实用文件一样，这个`graphMethods`文件应该位于一个名为`utils`的文件夹中，该文件夹位于项目根目录下的`app`文件夹内：
- en: '![](img/image_05_005.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_005.png)'
- en: 'Create this utilities file and have it do the following things:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 创建此实用文件，并让它执行以下操作：
- en: Create a function called `makeSingleGraphRequest` that accepts a request as
    an argument, creates a new instance of `GraphRequestManager`, passes in the request
    to `GraphRequestManager`, and then calls the `start` method of `GraphRequestManager`.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为`makeSingleGraphRequest`的函数，该函数接受一个请求作为参数，创建一个新的`GraphRequestManager`实例，将请求传递给`GraphRequestManager`，然后调用`GraphRequestManager`的`start`方法。
- en: Create and export a function, called `getFeed`, that accepts a callback, creates
    a new `GraphRequest` pointing to `/me/feed` with that callback, and then calls
    `makeSingleGraphRequest` with it.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建并导出一个名为`getFeed`的函数，该函数接受一个回调，创建一个新的指向`/me/feed`的`GraphRequest`，并使用该回调，然后调用`makeSingleGraphRequest`。
- en: 'Once your version is complete, check out mine below:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的版本完成，请查看下面的我的版本：
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: NavigatorIOS and App component
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NavigatorIOS和App组件
- en: 'Now, let''s create an `App` component using an `App.js` file. Create this within
    the `app` folder of your project:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`App.js`文件创建一个`App`组件。在项目的`app`文件夹中创建此文件：
- en: '![](img/image_05_006.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_006.png)'
- en: This component should contain logic similar to what we had in `index.ios.js`
    previously--we will replace the `index.ios.js` file with a `NavigatorIOS` component
    shortly.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件应包含与之前我们在`index.ios.js`中拥有的类似逻辑--我们将很快用`NavigatorIOS`组件替换`index.ios.js`文件。
- en: Your new `App` component should be a reflection of the `index.ios.js` file you
    wrote earlier in this chapter, except that it should import and use the `graphMethods`
    file instead of the component-specific `_getFeed` method.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你的新`App`组件应该是本章早期编写的`index.ios.js`文件的反映，除了它应该导入并使用`graphMethods`文件而不是特定组件的`_getFeed`方法。
- en: 'Once you have completed this task, refer to my version:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此任务后，请参考我的版本：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Since `GraphRequest` and `GraphRequestManager` are being imported within `graphMethods`,
    I can omit them from the `import` statement in the preceding code.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`GraphRequest`和`GraphRequestManager`在`graphMethods`中被导入，我可以在前面的代码中的`import`语句中省略它们。
- en: 'I am using destructuring notation to import just the `getFeed` method from
    `graphMethods`. This will come in handy in the future as that file is populated
    with more helper methods:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在使用解构符号从`graphMethods`导入`getFeed`方法。这将在未来很有用，因为该文件将填充更多的辅助方法：
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Since the callback for `GraphRequest` contains the `error` and `result` arguments,
    I pass them in so that `_responseInfoCallback` can make use of them:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`GraphRequest`的回调包含`error`和`result`参数，我传递它们，这样`_responseInfoCallback`就可以使用它们：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here is the basic styling for our `App` component:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`App`组件的基本样式：
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Great work! The next step is to refactor `index.ios.js` at your project''s
    root to do the following things:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！下一步是将项目根目录下的`index.ios.js`进行重构，执行以下操作：
- en: Import `NavigatorIOS` from the React Native SDK as well as the `App` component
    you just created
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从React Native SDK导入`NavigatorIOS`以及你刚刚创建的`App`组件
- en: Render the root `NavigatorIOS` component, passing it the `App` component as
    its initial route
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染根`NavigatorIOS`组件，将其`App`组件作为其初始路由传递
- en: 'When you have finished this part, feel free to check out my solution:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成这部分后，可以查看我的解决方案：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now it's time to create a login prompt for the user so that they only see the
    `LoginButton` component when they are not logged in.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候为用户创建一个登录提示，这样他们只有在未登录时才能看到`LoginButton`组件。
- en: Creating a login prompt
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建登录提示
- en: The first thing we should do is think about how our app will behave. When it's
    launched, we should check for an available access token using the FBSDK `AccessToken`
    API. If it's not available, then our user isn't logged in and we should show them
    the Log In button, just like we required a budget in our previous project, `Expense`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先应该考虑我们的应用将如何表现。当它启动时，我们应该使用FBSDK的`AccessToken` API检查是否有可用的访问令牌。如果没有，那么我们的用户未登录，我们应该显示登录按钮，就像我们在之前的`Expense`项目中需要预算一样。
- en: If/when the user is logged in, we should grab their feed data, load it into
    the component state, and then log it to the console to show that we have it.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果/当用户登录时，我们应该获取他们的数据源，将其加载到组件状态中，然后将其记录到控制台以显示我们已获取它。
- en: 'The first thing we should do is modify the `App` component so that:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先应该做的是修改`App`组件，使其：
- en: On the `componentWillMount` event, we use the `AccessToken` API's `getCurrentAccessToken`
    method to check and see whether the user is logged in.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`componentWillMount`事件中，我们使用`AccessToken` API的`getCurrentAccessToken`方法检查用户是否已登录。
- en: If the user is not logged in, we should alert the user that they are not logged
    in. In the next section, we will replace this part with the login screen that
    we will create.
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户未登录，我们应该提醒用户他们未登录。在下一节中，我们将用我们创建的登录界面替换这部分内容。
- en: If the user is logged in, we should call the `getFeed` method of `graphMethods`.
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户已登录，我们应该调用`graphMethods`的`getFeed`方法。
- en: Also, it should no longer render the `LoginButton`--this will go into a different
    component in a moment. Instead, let's have the `App` component render a string
    that says `'Logged In'` for the time being.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，它应该不再渲染`LoginButton`组件——这部分内容将在稍后放入不同的组件中。相反，让我们让`App`组件暂时渲染一个字符串，显示“已登录”。
- en: 'Take the time you need to make these changes, then check the code below for
    my working example:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 需要花费时间进行这些更改，然后检查下面的代码以查看我的工作示例：
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: I removed the import of `LoginButton` to `App` since it will be broken off into
    a different component.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经移除了`LoginButton`对`App`的导入，因为它将被拆分为不同的组件。
- en: 'The `componentWillMount` logic calls the `_checkLoginStatus` method:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`componentWillMount`逻辑调用`_checkLoginStatus`方法：'
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `LoginButton` component in the `render` method of `App` has been replaced
    with a `Text` block for the time being. The `_responseInfoCallback` function has
    not been changed nor removed:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`App`组件的`render`方法中的`LoginButton`组件已被替换为`Text`块。`_responseInfoCallback`函数没有更改也没有被删除：'
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `async _checkLoginStatus` function is similar to the `onLoginFinished`
    callback of the `LoginButton` component we previously rendered:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`async _checkLoginStatus`函数与之前渲染的`LoginButton`组件的`onLoginFinished`回调类似：'
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If the user is not logged in when they refresh the app, they will see this
    message:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在刷新应用时未登录，他们将看到以下消息：
- en: '![](img/image_05_007-1.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_007-1.png)'
- en: 'Great job on your progress! For the next step, create a `components` folder
    within the `app` folder, within which create a `LoginPage` folder that contains
    both an `index` and a `styles` file:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的进步上做得很好！对于下一步，在`app`文件夹中创建一个名为`components`的文件夹，在该文件夹中创建一个包含`index`和`styles`文件的`LoginPage`文件夹：
- en: '![](img/image_05_008.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_05_008.png)'
- en: 'Now, let''s modify the `App` component again while we create the `LoginPage`.
    The `App` component should do the following things:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们创建`LoginPage`的同时，让我们再次修改`App`组件。`App`组件应该执行以下操作：
- en: Import the `LoginPage` component
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入`LoginPage`组件
- en: Use the `push` method of the navigator to push the `LoginPage` component when the
    user is not logged in; replace the part in your code that alerts the user that
    they are not logged in with this logic
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户未登录时，使用导航器的`push`方法推送`LoginPage`组件；用此逻辑替换代码中提醒用户未登录的部分
- en: Pass the `_checkLoginStatus` callback to the `LoginPage` component so that,
    when the user is logged in, we can check the login status with the `App` component
    and log their list of posts within `/me/feed`
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`_checkLoginStatus`回调传递给`LoginPage`组件，以便当用户登录时，我们可以使用`App`组件检查登录状态，并在`/me/feed`中记录他们的帖子列表。
- en: 'The `LoginPage` component should do the following things:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoginPage`组件应该执行以下操作：'
- en: Contain a view that wraps around the `LoginButton` component that we rendered
    previously in this chapter.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含一个视图，该视图围绕我们在本章中之前渲染的`LoginButton`组件。
- en: 'Have an `onLoginFinished` callback that does the following things:'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个`onLoginFinished`回调，它执行以下操作：
- en: Logs an error to the console if the login action is cancelled
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果登录操作被取消，将错误记录到控制台。
- en: Calls the `getFeed` callback that was passed to it along with the `pop` method
    of the navigator if the login action is successful
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果登录操作成功，调用传递给它的`getFeed`回调以及导航器的`pop`方法。
- en: 'When you are finished, your result should look something like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成时，你的结果应该看起来像这样：
- en: '[PRE23]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Rather than alerting the user that they are not logged in, I''m now pushing
    the `LoginPage` component via the app''s navigator if the user is not logged in.
    This is how I wrote the `LoginPage` component:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是提醒用户他们未登录，我现在如果用户未登录，将通过应用导航器推送`LoginPage`组件。这是我编写的`LoginPage`组件的方式：
- en: '[PRE24]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding part logs an error if one occurred during login.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的部分如果在登录过程中发生错误，将记录错误。
- en: 'In the following code we log the fact that the user cancelled the login process:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们记录了用户取消登录过程的事实：
- en: '[PRE25]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'However, we call the `getFeed` and `navigator.pop` methods if the login was
    successful:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果登录成功，我们调用`getFeed`和`navigator.pop`方法。
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The stylesheet for `LoginPage` is the exact same as the one found in `Expenses/app/styles.js`,
    so I left it out for the sake of brevity.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoginPage`的样式表与`Expenses/app/styles.js`中找到的完全相同，因此为了简洁起见，我将其省略。'
- en: Great progress! In the next section, we will create some storage methods to
    handle the rate limit for Facebook's Graph API.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 很大的进步！在下一节中，我们将创建一些存储方法来处理Facebook的Graph API的速率限制。
- en: Optimizing for the API
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化API
- en: The current rate limit for Facebook's Graph API is 200 calls per hour per user.
    This means that if your app has 100 users, you can make 20,000 calls per hour.
    The limit is in aggregate, meaning that any single user could take up all 20,000
    calls in that given hour.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook的Graph API当前的限制是每小时每个用户200次调用。这意味着如果你的应用有100个用户，你每小时可以调用20,000次。这个限制是总体的，这意味着任何单个用户可以在那个小时内消耗掉所有的20,000次调用。
- en: To reduce the number of network calls we make to the API, we should tweak our
    `App` component to save feed data within `AsyncStorage` and only refresh its data
    when manually prompted to do so by the user.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少我们对API发出的网络调用次数，我们应该调整我们的`App`组件，将feed数据保存在`AsyncStorage`中，并且只有在用户手动提示时才刷新其数据。
- en: 'We can begin by creating methods for `AsyncStorage`, which are similar to the
    ones we had in `Expenses`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以开始创建与`Expenses`中相似的`AsyncStorage`方法：
- en: '[PRE27]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: For this app, we will be storing different key-value pairs within `AsyncStorage`;
    so, we want to explicitly pass the `getAsyncStorage` and `setAsyncStorage` methods
    a key.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个应用，我们将在`AsyncStorage`中存储不同的键值对；因此，我们希望明确传递`getAsyncStorage`和`setAsyncStorage`方法一个键。
- en: 'The `resetAsyncStorage` and `logAsyncStorage` methods remain the same from
    when we used them in `Expenses`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`resetAsyncStorage`和`logAsyncStorage`方法与我们之前在`Expenses`中使用的方法保持相同：'
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, modify the `_checkLoginStatus` method in `App.js` so that it does the
    following things:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，修改`App.js`中的`_checkLoginStatus`方法，使其执行以下操作：
- en: Calls the `getAsyncStorage` method in `storageMethods` to check for the existence
    of data within the `feed` property if the user is logged in.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户已登录，调用`storageMethods`中的`getAsyncStorage`方法来检查`feed`属性中是否存在数据。
- en: If the `feed` property exists, we should save its results to the `App` component's
    state under the same name. We will not call `getFeed` if this is the case.
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在`feed`属性，我们应该将其结果保存到`App`组件的状态中，名称相同。在这种情况下，我们不会调用`getFeed`。
- en: If the key does not exist, we should call `getFeed`.
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果键不存在，我们应该调用`getFeed`。
- en: 'Now, let''s modify the `_requestInfoCallback` method in `App.js` so that if
    it does not contain an error, it will do the following things:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们修改`App.js`中的`_requestInfoCallback`方法，以便如果它不包含错误，它将执行以下操作：
- en: Save the `response.data` array using the `setAsyncStorage` method from `storageMethods`,
    using `feed` as the key that is passed in.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`storageMethods`中的`setAsyncStorage`方法保存`response.data`数组，使用`feed`作为传入的键。
- en: Save the same array to the `App` component's local state.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将相同的数组保存到`App`组件的本地状态中。
- en: 'Here''s how my version looks:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我的版本看起来是这样的：
- en: '[PRE29]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If the `feed` array exists, set it to local state.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在`feed`数组，将其设置为本地状态。
- en: 'Otherwise, call `getFeed`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，调用`getFeed`：
- en: '[PRE30]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This change first checks for any feed data that we have saved in the app before
    resorting to making an external API call for that data. In the next chapter, we
    will explore a component that will allow us to refresh this data on demand.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更改首先检查我们在应用中保存的任何feed数据，然后再求助于为该数据发出外部API调用。在下一章中，我们将探讨一个允许我们按需刷新此数据的组件。
- en: The next step we should take is to give the user an indication that data is
    being loaded so that they don't have a static screen for too long. We will use
    the `ActivityIndicator` component to do so.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一步应该采取的措施是让用户知道数据正在加载，这样他们就不会长时间看到一个静态屏幕。我们将使用 `ActivityIndicator` 组件来实现这一点。
- en: Using ActivityIndicator
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ActivityIndicator
- en: The `ActivityIndicator` component displays a circular loading indicator that
    lets you visualize a *loading* action for the user. It's helpful for the overall
    user experience since your users shouldn't feel like their actions aren't accomplishing
    their intentions.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActivityIndicator` 组件显示一个圆形加载指示器，可以让用户可视化一个 *加载* 动作。这对于整体用户体验很有帮助，因为用户不应该感觉他们的操作没有达到他们的目的。'
- en: 'The two `ActivityIndicator` props we will use in this app are as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本应用中使用以下两个 `ActivityIndicator` 属性：
- en: '`animating`: This is a Boolean that either shows or hides the component. It
    defaults to `true`.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`animating`：这是一个布尔值，用于显示或隐藏组件。它默认为 `true`。'
- en: '`size`: This is the physical size of the component. On iOS, your options are
    one of two strings: `small` and `large`. On Android, in addition to those two
    strings, you can pass it a number. This prop defaults to `small`.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size`：这是组件的物理大小。在 iOS 上，你的选项是两个字符串之一：`small` 和 `large`。在 Android 上，除了这两个字符串外，你还可以传递一个数字。此属性默认为
    `small`。'
- en: We should modify our app to show this `ActivityIndicator` when data hasn't been
    loaded from the Graph API.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该修改我们的应用程序，以便在从 Graph API 加载数据时显示这个 `ActivityIndicator`。
- en: Let's modify the `App` component so that it conditionally renders the `ActivityIndicator`
    component when data has not yet been saved into the `feed` property of the `App`
    component's state.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改 `App` 组件，以便在数据尚未保存到 `App` 组件状态的 `feed` 属性时，条件性地渲染 `ActivityIndicator`
    组件。
- en: 'The solution I came up with is as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我想出的解决方案如下：
- en: '[PRE31]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Set the `feed` and `spinning` values in the `App` component's state upon initialization.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化时设置 `App` 组件状态中的 `feed` 和 `spinning` 值。
- en: 'Call the new `_renderView` method to conditionally determine what to render:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 调用新的 `_renderView` 方法来条件性地确定要渲染的内容：
- en: '[PRE32]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Modify `_checkLoginStatus` to set the `spinning` property to `false` when loading
    data:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 `_checkLoginStatus` 以在加载数据时将 `spinning` 属性设置为 `false`：
- en: '[PRE33]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Check to see whether the `ActivityIndicator` should still be spinning. If so,
    return the `ActivityIndicator` component. If not, return the original `Text` component
    instead:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 `ActivityIndicator` 是否仍然需要旋转。如果是，则返回 `ActivityIndicator` 组件。如果不是，则返回原始的 `Text`
    组件：
- en: '[PRE34]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Like `_checkLoginStatus`, modify `_responseInfoCallback` to set `spinning`
    to `false`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `_checkLoginStatus` 类似，修改 `_responseInfoCallback` 以将 `spinning` 设置为 `false`：
- en: '[PRE35]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, we should take the data we received and display it within a `ListView`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该将我们从 Graph API 收到的数据显示在 `ListView` 中。
- en: Creating a standard ListView
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个标准的 ListView
- en: The next step is to take the data received from the Graph API and render it
    into the view.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是获取从 Graph API 收到的数据并将其渲染到视图中。
- en: 'Right now, the `feed` array in the `App` component state contains 25 objects.
    Each object contains the following key-value pairs:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`App` 组件状态中的 `feed` 数组包含 25 个对象。每个对象包含以下键值对：
- en: '`created_time`: This is the date and time this post was made'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`created_time`：这是帖子创建的日期和时间'
- en: '`id`: This is an identifier that will let us grab the details of the post'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：这是一个标识符，它将使我们能够获取帖子的详细信息'
- en: '`story`: This an optional post description that adds context, such as whether
    the post contained a location-based check-in, whether it was a shared memory or
    link, and so on'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`story`：这是一个可选的帖子描述，它添加了上下文，例如帖子是否包含基于位置的签到，是否是共享记忆或链接等'
- en: '`message`: This an optional message that the user personally wrote for this
    post'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`message`：这是用户为这个帖子亲自写的可选消息'
- en: 'Each post contains several edges, just like a node on a graph data structure.
    For `Friends`, we will access these following edges:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 每个帖子都包含几个边，就像图数据结构中的节点一样。对于 `Friends`，我们将访问以下边：
- en: '`/likes`: This is a list of users who like this specific post'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/likes`：这是喜欢这个特定帖子的用户列表'
- en: '`/comments`: These are the comments made to this post'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/comments`：这些是对该帖子的评论'
- en: '`/attachments`: These are the media attachments associated with the said post'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/attachments`：这些是与该帖子关联的媒体附件'
- en: 'Before we can access the edges, we should render a `ListView` component that
    displays these 25 posts in a coherent manner. Take some time to create a `ListView`
    that does the following things:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以访问边之前，我们应该渲染一个 `ListView` 组件，以连贯的方式显示这 25 个帖子。花些时间创建一个 `ListView`，使其执行以下操作：
- en: Renders the 25 posts in individual rows
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以单独的行渲染 25 篇帖子
- en: Has conditional logic to show the story and message only if they exist
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有条件逻辑，仅在故事和消息存在时显示
- en: If you have gone through the first two projects in this book, the `ListView`
    is nothing new to you.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经完成了这本书中的前两个项目，`ListView` 对你来说不是什么新鲜事。
- en: Create a new component titled `FeedList` within your `components` folder. In
    this file, create a `ListView` component that takes its array from a prop passed
    into it and renders a standard `ListView`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 `components` 文件夹内创建一个名为 `FeedList` 的新组件。在这个文件中，创建一个 `ListView` 组件，它从传入的
    prop 中获取数组并渲染一个标准的 `ListView`。
- en: Then, create a new helper file, called `dateMethods`. It should contain a function
    that accepts a date string and returns a formatted date. I like to use the MomentJS
    for things like this, but feel free to do this however you like.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建一个新的辅助文件，称为 `dateMethods`。它应该包含一个接受日期字符串并返回格式化日期的函数。我喜欢用 MomentJS 做这类事情，但你可以随意这样做。
- en: Additionally, create another component titled `FeedListRow`, which will be responsible
    for rendering each individual row of the `FeedList`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，创建另一个名为 `FeedListRow` 的组件，它将负责渲染 `FeedList` 的每一行。
- en: 'Afterward, in `App.js`, import the `FeedList` component you created and render
    it where the `Text` component is currently placed within `_renderData`. Ensure
    that you pass it the `feed` array so that it has data to render. Render the `FeedList`
    instead of the old `Text` component:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，在 `App.js` 中，导入你创建的 `FeedList` 组件，并在 `_renderData` 中当前放置 `Text` 组件的位置渲染它。确保传递
    `feed` 数组，以便它有数据可以渲染。用 `FeedList` 替换旧的 `Text` 组件：
- en: '[PRE36]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`Text` is no longer imported:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`Text` 不再导入：'
- en: '[PRE37]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, the `FeedList` component takes in the `feed` array from the `App` component
    state and renders a standard `ListView`, explicitly passing in each post''s details:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`FeedList` 组件从 `App` 组件的状态中接收 `feed` 数组，并渲染一个标准的 `ListView`，明确传递每篇帖子的详细信息：
- en: '[PRE38]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Instantiate a new `ListView.DataSource` object:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化一个新的 `ListView.DataSource` 对象：
- en: '[PRE39]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Use the `feed` array passed in from `App` to render the `ListView`, as illustrated:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 使用从 `App` 传入的 `feed` 数组来渲染 `ListView`，如下所示：
- en: '[PRE40]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Render a `ListView` component using `FeedListRow` for each individual row,
    as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `FeedListRow` 为每个单独的行渲染一个 `ListView` 组件，如下所示：
- en: '[PRE41]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `separator` gets its own styling for separating each post, as shown:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`separator` 获得了自己的样式，用于分隔每一篇帖子，如下所示：'
- en: '[PRE42]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Use the date string taken from the Facebook API and then format it with `moment`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 使用从 Facebook API 获取的日期字符串，然后用 `moment` 格式化它：
- en: '[PRE43]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In `FeedListRow`, import the `getDateTimeString` method from the `dateMethods`
    file that was just created:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `FeedListRow` 中，从刚刚创建的 `dateMethods` 文件中导入 `getDateTimeString` 方法：
- en: '[PRE44]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Wrap a `TouchableHighlight` component around for future navigation purposes,
    as illustrated:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 为了未来的导航目的，将 `TouchableHighlight` 组件包裹起来，如下所示：
- en: '[PRE45]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Placeholder function for now, we will modify this later.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是一个占位函数，我们稍后会修改它。
- en: '[PRE46]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Methods to render certain parts of the post's data.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染帖子数据某些部分的方法。
- en: '[PRE47]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This is the styling I built for `FeedListRow`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为 `FeedListRow` 构建的样式：
- en: '[PRE48]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You'll notice that this component's `_navigateToPostView` method has a commented
    task to take care of. This is the basis for the next step in this exercise, and
    we will jump right to it in the next chapter.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到这个组件的 `_navigateToPostView` 方法有一个注释的任务要处理。这是本练习下一步的基础，我们将在下一章中直接跳到那里。
- en: Summary
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This was a long chapter, so thank you for staying with me! In this chapter,
    we obtained access to the Facebook Graph API, installed the Facebook SDK for iOS
    and Android, and began using the Facebook SDK to log the user into the app and
    use their access token to grab their feed data and render it onto the screen.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很长的章节，感谢你一直陪伴着我！在本章中，我们获得了访问 Facebook Graph API 的权限，为 iOS 和 Android 安装了
    Facebook SDK，并开始使用 Facebook SDK 来让用户登录应用，并使用他们的访问令牌获取他们的帖子数据并将其渲染到屏幕上。
- en: Along the way, you also used an `ActivityIndicator` component to visually communicate
    to the user that we are currently loading data.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中，你还使用了一个 `ActivityIndicator` 组件来向用户直观地传达我们正在加载数据。
- en: We will ramp up a lot more in the next chapter. See you there.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将大幅增加内容。那里见。
