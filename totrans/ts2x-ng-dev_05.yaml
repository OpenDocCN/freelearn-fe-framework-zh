- en: Advanced Custom Components with TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed the basics of component creation and usage.
    This knowledge is not enough to build robust applications. We need to delve a
    little more deeply into Angular's exciting components and see how TypeScript makes
    working with components a lot easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to address the following topics while showing some hands-on examples
    on how they work:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lifecycle hooks**: These are class methods in Angular that you can hook into.
    They are achievable by implementing a TypeScript interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ElementRef**: This involves manipulating and querying DOM safely in Angular
    using the ElementRef API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View encapsulation**: You will learn how scoped styles are applied to Angular
    components and how to change the default behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lifecycle hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most methods you will create in classes must be called somewhere by you, which
    is the expected pattern in programming. This is not the case in what Angular defines
    as lifecycle hooks. These hooks are methods that you create for Angular to call
    them internally, depending on the current state of a component/directive. They
    are created in a component's or directive's class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following hooks are available in an Angular component:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ngOnChanges`: Remember how properties are bound to components. These properties
    are reactive, meaning that, when they change, the view is updated as well. This
    lifecycle method is called when any property, bound to a view, is changed. Therefore,
    you can manipulate what happens before the changes are reflected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngOnInit`: This is the most common lifecycle. It is called after a component
    has been initialized with the default property bindings. Hence, it is called after
    the first `ngOnChanges`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngDoCheck`: Reactivity (change detection) is usually handled for you, but
    in extreme cases where it''s not, you need to handle it yourself. Use `ngDoCheck` to
    detect and act upon changes that Angular can''t or won''t detect on its own.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngAfterContentInit`: This is called after the component''s content has been
    initialized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngAfterContentChecked`: This is called after every check on the component''s
    content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngAfterViewInit`: This is called after initializing the view based on the
    component''s template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngAfterViewChecked`: This is called after checking a component''s view and
    the child views of a component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngOnDestroy`: This is called before a component is destroyed. This is a good
    place for a clean-up.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some lifecycle hooks may not make sense immediately. You shouldn't worry about
    them because it's only in extreme cases that you will need a lot of them.
  prefs: []
  type: TYPE_NORMAL
- en: An example will help clarify how they work. Let's explore the most common hook,
    which is `ngOnInit`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Angular project with the CLI command. Open the app component TypeScript
    file and update the imports to include `OnInit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`OnInit` is an interface that any class intended to implement `ngOnInit` should
    inherit. This is not technically required (see [https://angular.io/guide/lifecycle-hooks#interfaces-are-optional-technically](https://angular.io/guide/lifecycle-hooks#interfaces-are-optional-technically)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now make the `AppComponent` class implement this interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We are trying to simulate an asynchronous behavior, where values are resolved
    in the future. This kind of operation is best done when the application is initialized
    and that's why we are handling this in the `ngOnInit` method. Once the component
    is ready, Angular calls this hook, which will set the item array after three seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can bind the values to the view even before they come in. Angular will always
    update the view when the values are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To iterate over a list in Angular templates, we use the `*ngFor` **structural
    directive**, as shown in the preceding example. The `*ngIf` structural directive
    is like `*ngFor` but is used to display DOM elements based on a Boolean property
    on the component.
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, run the app with `ng serve`, and you will see the following first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb26d10d-0b15-4ab2-8574-b58bb9fa3fb3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After three seconds, the Please wait... text will disappear, and you will see
    your list of items:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2957cb42-5956-494d-80e4-428ed2e7fbb8.png)'
  prefs: []
  type: TYPE_IMG
- en: DOM manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Angular 1.x, touching the DOM seemed mysterious; not like you couldn't, but
    somehow it comes back to bite you. This is ironic because what we do as web designers/developers
    is paint the DOM, and that cannot be possible without manipulating it.
  prefs: []
  type: TYPE_NORMAL
- en: With Angular 2+, it became quite easy to do this. Angular abstracts the DOM
    and gives you the shallow copy to mess around with. It's then responsible for
    putting it back without hurting anyone. It becomes even more interesting with
    TypeScript because your editor can hint most of the DOM property methods for you.
  prefs: []
  type: TYPE_NORMAL
- en: ElementRef
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The API to achieve Dom manipulation is `ElementRef`. Let's build a tab component
    that uses this API based on the basic demo on [https://www.w3schools.com/howto/howto_js_tabs.asp](https://www.w3schools.com/howto/howto_js_tabs.asp).
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by generating a new component using the CLI generate command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the template as a child to our app component right after the `*ngFor` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, replace the component''s template with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the result on the browser, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/efe4ce64-861d-47e5-8ea6-4df5f97d0c2a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s add some styles to create a tabbed look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'With the styles, you should have the result shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d1840279-66f0-47b0-a50b-d394bb9db2f7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now is the time to start manipulating the DOM. We first need to hide all the
    tab contents with CSS by default; then, they can be activated in TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Hooking into content initialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be assured of gaining access to the DOM, we need to hook into the `ngAfterContentInit` lifecycle
    method. It''s in this method that we can use `ElementRef` to query the DOM and
    manipulate it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The class implements `AfterContentInit` as well as `OnInint`, showing how you
    can implement multiple interfaces. Then, we declare the buttons as an array of
    `HTMLElement` links. This also applies to the tab contents.
  prefs: []
  type: TYPE_NORMAL
- en: Right in the constructor, we create an instance of `ElementRef` as `el`, which
    we can use to interact with the DOM. The `ngAfterContentInit` function is called
    after the DOM contents are ready, which makes it the perfect candidate to handle
    DOM manipulations on startup. Hence, we grab a reference to the DOM there.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to show the first tab and make the first tab link active on load. Let''s
    extend `ngAfterContentInit` to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This will display the first tab, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3a5d38ec-7351-49ee-9953-c6d757d60159.png)'
  prefs: []
  type: TYPE_IMG
- en: Handling DOM events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final thing to do is add event listeners to the click events and start
    switching tabs. In the preceding template, we have click events attached to each
    button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `openTab` method is the event handler. Let''s implement it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: When the method is called, we iterate over all the tabs and hide them. We also
    iterate over the buttons and disable them by replacing the active class with an
    empty string. Then, we can display the tab we want to open and activate the button
    that was clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now when you click tab buttons, each tab content is shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a12abe97-05b9-4f8e-b94b-1872e0b45de8.png)'
  prefs: []
  type: TYPE_IMG
- en: There are different ways to solve this, and some of them are more advanced.
    The example we just showed intentionally performs DOM querying to show you how
    possible and simple it is to do DOM manipulation in Angular.
  prefs: []
  type: TYPE_NORMAL
- en: View encapsulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Components can be configured to apply styles differently. This concept is called
    encapsulation, and that's what we are going to discuss now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create another project with the CLI and add an extra component with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add this new component to the view via the app component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The child component''s template is as simple as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: That's just the minimum setup we need in order to understand view encapsulation
    strategies. Let's explore them.
  prefs: []
  type: TYPE_NORMAL
- en: Emulated
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the default strategy. Any style applied globally via HTML (not the parent
    component) as well as all the styles applied to a component will be reflected.
    In our case, if we target `h3` and apply styles to `style.css`, `app.component.css`,
    and `child.component.css`, only `style.css` and `child.component.css` will be
    reflected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following CSS is the child component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'On running the preceding code, the result on the child component''s view is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/abbb916d-1ae6-4aee-9cda-0f950dd9478c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In cases where the same styles are applied to the same element on both the
    global styles and the component itself, the component styles supersede the global
    style. For example, consider that the `style.css` file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now consider that the `child.component.css` file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The color of `h3` will be `blueviolet`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/126071d5-858e-4373-b2e1-6fc6eb4833ef.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can set this in the component decorator, though it is not necessary because
    `Emulated` is the default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Native
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This strategy is like Emulated, but it disables global styles from entering
    the component. Leaving the style in the global style as it was, set the encapsulation
    to native:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though the global style sets the `h3` color to `pinkvioletred`, the text
    color remains black because it couldn''t penetrate the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be23604f-c652-4997-8932-b8c986da9821.png)'
  prefs: []
  type: TYPE_IMG
- en: None
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the freest strategy. No matter where the style is set--child or parent--the
    styles are leaked to the other components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'With this setting, you can style the `h1` tag in the parent tag via the child
    component''s styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This reflects in the view, as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8908367d-7c8c-4bed-ac17-821dbd48db1b.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hopefully, the advanced topics discussed were not so complex or difficult to
    comprehend. You learned how to implement lifecycle hooks, control the behavior
    of component-scoped styles, and manipulate the DOM content after it has been rendered.
  prefs: []
  type: TYPE_NORMAL
- en: If you take only one thing from this chapter, let it be how to implement the
    lifecycle interfaces with TypeScript and using TypeScript decorators to configure
    a component. In the next chapter, you will learn about component communication
    and how components interact with each other via properties, events, view children,
    and content children.
  prefs: []
  type: TYPE_NORMAL
