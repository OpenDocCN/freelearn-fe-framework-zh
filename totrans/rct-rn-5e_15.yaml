- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit Testing in React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although testing is an integral part of the software development process, developers
    and companies often pay surprisingly little attention to it in reality, especially
    to automated testing. In this chapter, we will try to understand why it is important
    to pay attention to testing and what advantages it gives. We will also explore
    the basics of unit testing in ReactJS, including general testing theory, tools,
    and methods, as well as specific aspects of testing ReactJS components.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing in general
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing ReactJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files of this chapter on GitHub at [https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter14](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter14).
  prefs: []
  type: TYPE_NORMAL
- en: Testing in general
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Software testing** is a process aimed at identifying errors and verifying
    the functionality of a product to ensure its quality. Testing also allows developers
    and testers to assess the system’s behavior under various conditions and to ensure
    that new changes have not led to regression, meaning they have not disrupted existing
    functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: The testing process includes a series of actions conducted to detect and identify
    any aspects that do not meet requirements or expectations. One example of such
    an action could be **manual testing**, where a developer or tester manually checks
    the application. However, this approach is time-consuming and provides little
    guarantee that the application is secure and free of critical errors in operation.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure a higher level of application reliability while saving time on testing,
    there are **automated tests**. They allow the functionality of the application
    to be verified without human intervention.
  prefs: []
  type: TYPE_NORMAL
- en: An automated test typically consists of a set of predefined tests and a software
    product, often referred to as a **runner**, which launches these tests and analyzes
    the results to determine the success or failure of each test. In addition to this,
    automated tests can be used to check performance, stability, security, availability,
    and compatibility, allowing you to write truly stable, large, and successful projects.
    That’s why it’s never a good idea to avoid tests; on the contrary, it’s worth
    getting to know them better and trying to use them in all possible projects.
  prefs: []
  type: TYPE_NORMAL
- en: As developers, we are obviously more interested in automated testing than manual
    testing, so this chapter will focus on that. But before that, let’s briefly look
    at the approaches to testing and the types of tests that exist.
  prefs: []
  type: TYPE_NORMAL
- en: Test types and approaches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Software testing can be classified by various criteria, including the level
    of testing and the objectives it pursues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, the following types of tests are distinguished:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit testing**: Testing individual modules or components of the program for
    correct operation. Unit tests are usually written and executed by developers to
    check specific functions or methods. Such tests are generally quick to write and
    can be executed quickly, but they do not test the final application for critical
    bugs, as the tested and stable components themselves may have problems when interacting
    with each other. An example of a unit test would be checking the functionality
    of a single function, React component, or Hook.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration testing**: Testing in which we check the interaction between
    various modules or system components. The goal is to detect defects in the interfaces
    and interactions between integrated components. This type of testing is usually
    conducted on the server side to ensure that all systems work smoothly together
    and that the business logic meets the specified requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, an integration test would be one that checks that user registration
    works by making real calls to REST API endpoints and checking the returned data.
    Such a test depends less on the application’s implementation and code and more
    on checking behavior and business logic.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**End-to-end (E2E) testing**: Testing a complete and integrated software system
    to ensure that it meets specified requirements. E2E testing evaluates the program
    as a whole. This type of testing is the most reliable, as it completely abstracts
    from the application’s implementation and checks the final behavior by interacting
    directly with the application itself. In the process of such testing, for example,
    in a web application, a real browser is launched in a special environment, in
    which a script performs real actions with the application like clicking buttons,
    filling out forms, and navigating through pages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Although test types such as integration and E2E testing provide greater confidence
    in verifying the quality of an application, they come with drawbacks such as complexity
    and speed of test development, execution speed, and consequently, their costliness.
    Therefore, it is considered good practice to maintain a balance where preference
    is given to unit tests, as they are easier to maintain and faster to run. Then,
    all main business processes and logic are verified using integration tests, and
    E2E tests cover only the most critical business cases. This approach can be depicted
    in the form of a pyramid:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Picture 1](img/B19636_14_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.1: Test pyramid'
  prefs: []
  type: TYPE_NORMAL
- en: The pyramid perfectly describes the approach we have discussed above. At its
    base lies **unit** testing, which should cover the application’s source code as
    extensively as possible. It has the lowest cost of development and maintenance,
    as well as the highest test execution performance. In the middle are the **integration**
    tests, which are quite fast but more expensive to develop. At the very top, we
    have the **E2E** tests, which take the longest to execute and are the most expensive
    to develop, but they provide the maximum confidence in the quality of the product
    being tested.
  prefs: []
  type: TYPE_NORMAL
- en: Since integration and E2E tests abstract away from the implementation, and thus
    from the programming language or libraries used in the application, we are not
    going to cover those types of testing. Therefore, let’s focus in more detail on
    unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already know that unit testing is the process of verifying the correctness
    of individual “**units**” of code: namely, **functions** and **methods**. The
    goal of unit testing is to ensure that each separate unit performs its task correctly,
    which, in turn, increases confidence in the reliability of the entire application.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The above represents the most basic and simplest test of a function that adds
    two values. The test code itself is a function that calls a special method, `expect`,
    which takes a value and then has a series of methods allowing for the checking
    and comparing of results.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at this code, the first question that might come to mind is, is it really
    necessary to write another three lines of tests for such a simple three-line function?
    And why test such a function at all? I would answer with a definitive *yes*. It
    often happens that a function can be covered by a test that is larger in volume
    than the function itself, and there is nothing wrong with that. Let’s understand
    why.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing is most useful and effective when you are testing **pure functions**,
    which have no side effects and do not depend on external state. Conversely, unit
    testing is useless when the function being tested can change its behavior due
    to external factors or simply because that’s how the function was designed. For
    example, functions for requesting data from the server, getting data from `localStorage`,
    or relying on global variables might return different results for the same input.
    From this, we can conclude that in an application development approach that requires
    code coverage with tests, you will automatically strive to write **testable code**,
    meaning more modular, independent, clean, and scalable code. This becomes especially
    noticeable on large projects. If tests were written from the start, such projects
    could continue to grow without the need for major refactoring or rewriting functionality
    from scratch. Also, in projects with tests, it is easier for newcomers to understand,
    as tests can serve as additional documentation for modules, reading which one
    can understand what the module is responsible for and what behavior it possesses.
  prefs: []
  type: TYPE_NORMAL
- en: For writing unit tests, there are entire concepts and methodologies. The main
    and most popular one is the traditional coverage of tests after code development.
    The advantage of this approach is the speed of development of the main functionality,
    as tests are usually dealt with later. Hence, the problem with this approach lies
    in delaying testing, which poses a risk of accumulating code that is not covered
    by tests. Later, when writing tests, it often becomes necessary to correct the
    main code, making it more modular and cleaner, which takes additional time.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a methodology directly aimed at writing tests, called **test-driven
    development** (**TDD**). This is a software development methodology in which tests
    are written before the code itself. The benefit of this approach is that your
    code will be immediately covered by tests, meaning it will be cleaner and more
    reliable. However, this approach may not be suitable for prototyping or for projects
    where requirements often change.
  prefs: []
  type: TYPE_NORMAL
- en: The choice between TDD and testing after development depends on many factors,
    including the team’s culture, project requirements, and developers’ preferences.
    It is important to understand that neither approach is a universal solution, and
    different choices may be justified in different situations. Most importantly,
    understand the importance of testing and that one should avoid an approach in
    work where tests are not written at all as, in most cases, such code is doomed
    to be rewritten from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand what unit tests are and their importance, let’s take
    a closer look at them. Before writing tests, we should set up the environment
    in which we will run our tests.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the test environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most popular framework for writing and running unit tests is **Jest**.
    However, we will look at its more performant alternative, which is fully compatible
    with **Vite**, called **Vitest**. To install Vitest in your project, you need
    to execute this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: For basic operation, Vitest does not require any configuration, as it is fully
    compatible with the Vite configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: Next, to get started, we need to create a file with the extension `*.test.ts`.
    The location of the file is not critical; the main thing is that the file is inside
    your project. Usually, test files are associated with the files of the functions
    being tested and are placed in the same directory; for example, for the `sum`
    function located in the `sum.ts` file, a file with a test named `sum.test.ts`
    is created and located in the same folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the tests, we need to add a launch script to the `package.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to call it, just execute the command in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will start the Vitest process, which will scan the project for
    files with the `.test`. extension and then execute all the tests in each such
    file. Once all tests are completed, you will see the result in the terminal window,
    and then the process will wait for changes in the test files to rerun them. This
    is specifically designed as a mode for developing tests, where you do not need
    to constantly run the test command. For a one-time test run, you can add another
    command that will close the process upon completion of testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `run` parameter is precisely for telling Vitest that you want to run the
    tests only once.
  prefs: []
  type: TYPE_NORMAL
- en: Vitest features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s now look at the main features of Vitest and the types of tests we can
    write. Let’s start with a simple function, `squared`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This function returns the square of a number. Here is what the test for this
    function would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `test` and `expect` functions are part of the Vitest package. The test function
    takes the name of the test as its first argument and the test function itself
    as its second argument. The `expect` method serves as the basis for checking the
    expected result from the function being tested. Calling the `expect` method creates
    an object that contains a large number of methods, allowing for different ways
    to check the execution result. In our example, we explicitly compare the result
    of executing the `squared` function with the expected value.
  prefs: []
  type: TYPE_NORMAL
- en: 'By running this test, in the terminal window, we will see the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To check that the tests are working correctly, let’s change the expected value
    from `4` and see what result we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When a test fails, we can see directly in the results where the error occurred,
    what result we received, and what we expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `toBe` method is very useful for direct comparison of results, but what
    about objects and arrays? Let’s consider this test example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this test, we created two identical objects, which will not be equal as variables.
    To expect the opposite assertion, we use the additional `.not.` key, which ultimately
    gives us the statement that the two variables are not equal to each other. If
    we still want to check that the objects have the same structure, there is a method
    called `toEqual`, which recursively compares objects. This method also works similarly
    with arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'For arrays, there are also additional methods that allow checking for the presence
    of an element, which is often very useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `toContain` method can also work with strings and even DOM elements, checking
    for the presence of a class in `classList`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next big part of unit testing is working with functions. Vitest allows
    you to create **spyable fake functions**, which lets you check how and with what
    parameters this function was called. Let’s look at an example function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is created just for demonstration, but we can easily imagine
    some module or selector component that takes the `onSelect` callback, which will
    be called under some condition: in our case, three times in a row. Now let’s see
    how we can test using observable functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the test, we created the `onSelect` function using the `vi` module from
    the `Vitest` package. This function now allows us to check how many times it was
    called and with what arguments. For this, we used the methods `toBeCalledTimes`
    and `toHaveBeenLastCalledWith`. There is also a method called `toHaveBeenCalledWith`,
    which can step-by-step check which arguments were used on each call of the observed
    function. In our case, the valid checks would be these three lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Vitest also allows you to spy a real function, for which you need to use the
    `vi.spyOn` method. However, for this, the function must be accessible from an
    object. Let’s look at an example of spying on a real function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: To create an observation for a function, we call `vi.spyOn` and pass it the
    object as the first argument and the name of the method as the second. Then, we
    can work with the original function and, later, make the necessary checks working
    with the `spy` variable. In the example above, you can also notice the new method
    `toHaveReturnedWith`, which allows you to check what the observed function returned.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Moving on, I’d like to mention one of the most challenging parts of unit testing:
    namely, working with functions that have side effects or depend on external data
    or libraries. Earlier, I mentioned that testing is useless in functions with side
    effects, like calling something under the hood. Actually, that’s not entirely
    true. In some cases, it’s simply impossible to write a pure function, but that
    doesn’t mean it can’t be tested. To write tests for such functions, we can use
    **mocking**: namely, emulating external behavior or simply replacing the implementation
    of some modules or libraries.'
  prefs: []
  type: TYPE_NORMAL
- en: An example could be a function that depends on the system time of the computer,
    or a function that returns data from a server. In such cases, we can apply a fake
    instruction that can change the current date of the computer specifically for
    this test, to have a clean result that is easier to test. Similarly, it is possible
    to create a fake implementation of a network request, which will ultimately be
    executed locally with the return of predetermined values. Let’s discuss some of
    these scenarios in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the example of testing and using **timers**. In the testing environment,
    we can avoid waiting for timers and manually control them to more thoroughly test
    the behavior of the function. Let’s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We created the `executeInMinute` and `executeEveryMinute` functions for delaying
    the call of a function by one minute and for cyclic execution every minute, respectively.
    We also created a mock function that we will subsequently spy on. Here’s what
    the test will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this example, there’s a lot to discuss but let’s start with the fact that
    we didn’t use the `test` function; instead, we used `describe` and `it`. The `describe`
    function allows us to create a test suite that can have its own context and lifecycle.
    In the test suite, we can set initial parameters or mock some behavior so that
    our test cases can reuse this context and these parameters later on. In our example,
    we use the `beforeEach` and `afterEach` methods, which set up fake timers before
    each test and then restore everything back to its original state after each test.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `it` method is an alias for the `test` method and does not differ functionally
    from it. It’s only there to make the test case more readable in the results. For
    example, `describe` with ‘`delayed execution`'' and `it` with ‘`should execute
    the function`'' in the results would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'However, using `test`, we would see the result as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s look at the tests themselves. The first test uses the `executeInMinute`
    function, which, in reality, would call our observed method only after a minute,
    but in the test, we can control time. By using `vi.runAllTimers()`, we force the
    environment to start and skip all timers and immediately check the result. In
    the next test, we move time forward by 2 milliseconds using `vi.advanceTimersByTime(2)`,
    which already allows us to ensure that the original function will not be called.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s discuss the `executeEveryMinute` method, which should start a timer
    with a call to an argument every minute. In this case, we can step through each
    iteration of this timer using `advanceTimersToNextTimer`, giving us precise control
    over time without having to wait in real time.
  prefs: []
  type: TYPE_NORMAL
- en: When writing unit tests, we will often encounter that the function being tested
    will depend on some library or even a package.
  prefs: []
  type: TYPE_NORMAL
- en: Most often, you will encounter this in React Native, if a library or some method
    uses the device’s native functions. In such a case, to write a test, we need to
    create a mock version of this logic that will be called during the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider a simple example where we imagine that we have a package that
    can interact with the device and get the current number of steps. To obtain the
    steps, we’ll use the `getSteps` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As an example, the function itself will be very simple and will just return
    the value of `100`. However, in reality, such a function would interact with a
    smartphone API, which would be impossible to invoke within the scope of testing.
    Next, let’s look at what we can do when writing a test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The test and the entire example are quite primitive but they will give you
    an understanding of how mocking works. At the beginning of the file, we import
    our original package, `ios-health-kit`, then using the `beforeAll` method, we
    call `vi.mock`, passing it the path to the package as the first argument and a
    function that will return the implementation of the original file: namely, creating
    an object with the `getSteps` method as a fake function with an implementation
    that will return the value of `2000`. Then, in the test, we check that it indeed
    returns this value.'
  prefs: []
  type: TYPE_NORMAL
- en: In this test, the `vi.mock` function creates a mock of the imported package
    and replaces the original import with it, which allows us to successfully test
    this functionality.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, this example, in essence, does not test anything but merely demonstrates
    the possibility of mocking. In a real project, you will likely need to test functions
    that somewhere inside may use libraries that are important to mock. For this,
    it may be inconvenient to constantly manually write mocks before the actual test;
    to solve this, you can mock libraries and APIs at a global level. For this, you
    will need to create a configuration file or use `vi.stubGlobal`. I do not recommend
    diving so deeply right away without understanding and learning the basics, so
    let’s move on.
  prefs: []
  type: TYPE_NORMAL
- en: More information about dependency mocking via configuration can be found at
    [https://vitest.dev/guide/mocking](https://vitest.dev/guide/mocking).
  prefs: []
  type: TYPE_NORMAL
- en: 'The last but not least important example I’d like to discuss is mocking **network
    requests**. Almost any application you’ll be developing will work with data that
    needs to be fetched from a server. For a unit test, this can be a problem, as
    it’s important to test the unit abstracted from the external environment. Therefore,
    in unit tests, you should always mock server requests and provide the data necessary
    for the current test case. There’s a library called `Mock Service Worker` for
    mocking server requests. It allows you to mock REST and GraphQL requests very
    flexibly. Let’s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this test, we created a mock network request for the path `https://api.github.com/users`,
    which returns the data we need. For this, we used the `setupServer` function from
    the `Mock Service Worker` package. Next, in the lifecycle methods, we set up the
    mock server to listen to server requests and then implemented a standard test
    where data is requested using the regular Fetch API. As you can see in the results,
    we can check the status code and the returned data.
  prefs: []
  type: TYPE_NORMAL
- en: With such a mocking approach, we truly have vast possibilities for testing different
    logic depending on the data returned from the server, status codes, errors, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we’ve introduced the basics of unit tests: namely, what they
    are and why we need to write them. We’ve learned how to set up the testing environment
    and write basic tests for our future projects. Next, let’s move on to the main
    topic of our chapter, testing ReactJS compaonents.'
  prefs: []
  type: TYPE_NORMAL
- en: Testing ReactJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already know that unit testing involves checking small units, and most often,
    just functions, which perform some logic and return a result. To understand how
    testing in ReactJS works, the concept and idea remain the same. We know that at
    their core, React components are actually `createElement` functions that return
    a node, which, as a result of the `render` function, is displayed on the browser
    screen as HTML elements. In unit testing, we don’t have a browser, but this is
    not a problem for us since we know that the render target in React can be almost
    anything. As you may have already guessed, in the unit tests of ReactJS components,
    we will be rendering components into a specially created **JSDOM** format, which
    is fully identical to the DOM, and the **React Testing Library** will help us
    with this.
  prefs: []
  type: TYPE_NORMAL
- en: This library contains a set of tools that allow rendering components, simulating
    events, and then checking the results in various ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start, let’s set up the environment for testing React components.
    To do this, in a fresh Vite project, execute this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will install all the dependencies we need. Next, we need to create
    a `tests/setup.ts` file to integrate Vitest and the React Testing Library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to update the `vite.config.ts` configuration file and add the
    following code there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: These parameters tell Vitest to use an additional environment and execute our
    setup script before starting the tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step is to configure TypeScript typing, where we will specify that
    the `expect` function will now have additional methods to work with React components.
    To do this, we need to add the following code to the `src/vite-env.d.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This construction adds types for all the new methods provided by the React Testing
    Library. With this, the environment setup is complete, and we can proceed to writing
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s consider the most basic check that a component has successfully
    rendered and is present in the document. For this, we’ll create an `App` component
    that returns a title with the `Hello world` text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The test for such a component would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The structure of the test itself is the same as before and is already familiar
    to us. The main thing to note is that at the beginning of the test, we render
    the component using the `render` function from `testing-library`, and after that,
    we can perform checks. To work with the rendering result, we use the `screen`
    module. It allows us to interact with our virtual DOM tree, and search for necessary
    elements in various ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the main ones later, but in this example, we used the `getByText`
    method, which queries for an element containing the text “`Hello World`". To check
    whether this element is present in the document, we use the `toBeInTheDocument`
    method. This is how the output looks when you run the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s consider a more complex example, where we need to check that clicking
    a button adds a new `className` property to the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'By clicking the button, we update the state, which updates the component and
    adds an `active` class to it. Now, let’s write a test for this component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In this test, you first render the `ClassCheck` component, then we need to find
    the button element, and for this, we use the `screen` module with the `getByRole`
    method. This is the next method that allows query elements in the document, but
    it’s important to understand that if there is more than one `button` in the document,
    this test will produce an error. Therefore, it’s necessary to apply suitable query
    methods in different situations. Now that the button is accessible, we first ensure
    that the component does not contain the `active` class using the `toHaveClass`
    method with the `not` prefix.
  prefs: []
  type: TYPE_NORMAL
- en: To click on this button, the React Testing Library provides the `fireEvent`
    module, which allows generating click events. After clicking the button, we check
    that the required class is present in the element.
  prefs: []
  type: TYPE_NORMAL
- en: 'With `fireEvent`, it’s possible to generate all possible events such as click,
    drag, play, focus, blur, and many others. A very common event that is also important
    to test is the `change` event in an input element. Let’s discuss this using the
    `Input` component as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This component simply returns an `input` element, but in this example, I’ve
    also added a special attribute, `data-testid`. This is used for more convenient
    searching of elements in the document, as this attribute abstracts you from working
    with the content of the component or the role of the element. During the development
    of the project, you will often update your components, and the `data-testid` attribute
    will help you less frequently fix broken tests due to content updates or changes,
    say from `h1` to `h2` or `div` to a more semantic element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s write a test for this component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this test, as usual, we render the component, and then we find our element
    using the more convenient method, `getByTestId`. Next, we simulate the `change`
    event on `input` using the `fireEvent.change` method, which takes the event object,
    and at the end of the test, we assert the entered value in the expected one. In
    this way, we can now test large forms with various logic for formatting, validation,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like testing components, the React Testing Library can also test Hooks.
    This allows testing only the custom logic and abstracting away from the components.
    Let’s write a small `useCounter` Hook, which will return the current `counter`
    value and the `increment` and `decrement` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to test this Hook, instead of using the `render` function, the React
    Testing Library has a `renderHook` method. This is what a test of this Hook would
    look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Initially, we render the Hook itself and check that the initial value is zero.
    The `renderHook` method returns the `result` object, through which we can read
    the data returned from the Hook. Next, we need to test the `increment` and `decrement`
    methods. To do this, it is not enough to simply call them, as Hooks are not pure
    functions by nature and contain a lot of logic under the hood. Therefore, we need
    to call those methods wrapped in the `act` method, which will synchronously wait
    for the method to execute and the Hook to re-render. After that, we can assert
    the expectations in the usual way. The output will look the same as we saw in
    the previous example, but let’s now try to update the test to make failed results.
    Updating the first assertion from `.toBe(0)` to `.toBe(10)` will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: You will notice how Vitest highlights the part of the code where we got a failed
    assertion.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have learned how we can test components and Hooks using
    the React Testing Library.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the broad and extensive topic of testing. We became
    acquainted with the concept itself, testing types, and various approaches. Then,
    we delved into unit testing and learned what it is, and what possibilities this
    type of testing offers. After that, we learned how to set up the environment and
    write tests for regular functions and logic. At the end of the chapter, we examined
    the basic capabilities of testing React components and Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: With this chapter, we conclude our acquaintance with the amazing ReactJS library
    and will next dive deeper into the React ecosystem with the incredible opportunity
    to create mobile applications based on React Native.
  prefs: []
  type: TYPE_NORMAL
- en: Join us on Discord!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read this book alongside other users and the authors themselves. Ask questions,
    provide solutions to other readers, chat with the authors, and more. Scan the
    QR code or visit the link to join the community.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/ReactAndReactNative5e](Chapter_14.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code196803360665486921.png)'
  prefs: []
  type: TYPE_IMG
