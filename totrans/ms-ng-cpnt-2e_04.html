<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Thinking in Projects</h1>
                </header>
            
            <article>
                
<p class="mce-root">It's time to think bigger. So far, we've created everything within our application around the concept of a simple task list. However, we want to build something bigger than that. Users should be able to organize their tasks into projects. Within this chapter, we're going to introduce a frame around our task list and make it feel like a full-blown application. With the introduction of a project component, the main navigation, tabbed interfaces, and a user area, we are moving a big step closer to our final application look.</p>
<p class="mce-root">We will create a reusable in-place editor component, which we will put into action on many existing areas within our application. With the help of this editor, the user experience of our system will increase tremendously, and our users will start to feel the underlying reactive architecture.</p>
<p class="mce-root">During this chapter, we will also create a commenting system that we build in a way that allows us to place it anywhere we'd like for our users to put comments.</p>
<p class="mce-root">Application security and proper user management are not within the scope of this book. However, we're going to create a dummy user service that will help us simulate a logged-in user. This service will be used by the commenting system, and we'll refactor our existing component to make use of it too.</p>
<p>We'll cover the following topics in this chapter:</p>
<ul>
<li>Introduction of a new project component and additional container components</li>
<li>Two new RxJS operators called <kbd>switchMap</kbd> and <kbd>take</kbd></li>
<li>Creating a tabbed interface component for project detail navigation</li>
<li>Using content projection to create a navigation UI component</li>
<li>Using <kbd>contenteditable</kbd> to create an in-place editor</li>
<li>Using <kbd>@HostBinding</kbd> and <kbd>@HostListener</kbd> to bind component members to host element properties and events</li>
<li>Obtaining view elements using the <kbd>@ViewChild</kbd> decorator</li>
<li>Performing DOM operations by using the <kbd>ElementRef</kbd> DOM abstraction</li>
<li>Creating a commenting system that allows us to gather user comments in different areas of our application</li>
<li>Summarizing a simple pipe to format relative time intervals using the third-party library Moment.js</li>
<li>Creating an editor that enables users to edit text fields in-place</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Moving into projects</h1>
                </header>
            
            <article>
                
<p>Within this topic, we're going to implement the changes needed to move our simple task list into a structure that is organized by projects. For this purpose, we need to modify the main layout of our components as well as introduce a new component that represents our projects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Project service</h1>
                </header>
            
            <article>
                
<p>First, let's update our application model to include project data. For this, we're going to create a new model for a project as well as update the model of our tasks to add a project ID.</p>
<p>Open up the <kbd>src/app/model.ts</kbd> file and apply the following changes:</p>
<pre>export interface Task {<br/>  readonly id?: number;<br/>  <strong>readonly projectId?: number;</strong><br/>  readonly title: string;<br/>  readonly done: boolean;<br/>}<br/><br/>export type TaskListFilterType = 'all' | 'open' | 'done';<br/><br/><strong>export interface Project {</strong><br/><strong>  readonly id?: number;</strong><br/><strong>  readonly title: string;</strong><br/><strong>  readonly description: string;</strong><br/><strong>}</strong></pre>
<p>Each task is now including a reference to a project. The project entities are consisting of an ID, individual title, and description property. Let's also update our in-memory web API database. Open the <kbd>src/app/database.ts</kbd> file and apply the following changes:</p>
<pre>import {InMemoryDbService} from 'angular-in-memory-web-api';<br/>import {<strong>Project,</strong> Task} from './model';<br/><br/>export class Database implements InMemoryDbService {<br/>  createDb() {<br/>    <strong>const projects: Project[] = [</strong><br/><strong>      {id: 1, title: 'My first project', description: 'This is your first project.'},</strong><br/><strong>      {id: 2, title: 'My second project', description: 'This is your second project.'}</strong><br/><strong>    ];</strong><br/><br/>    const tasks: Task[] = [<br/>      {id: 1, <strong>projectId: 1,</strong> title: 'Task 1', done: false},<br/>      {id: 2, <strong>projectId: 1,</strong> title: 'Task 2', done: false},<br/>      {id: 3, <strong>projectId: 1,</strong> title: 'Task 3', done: true},<br/>      {id: 4, <strong>projectId: 1,</strong> title: 'Task 4', done: false}<br/>    ];<br/><br/>    return {<strong>projects,</strong> tasks};<br/>  }<br/>}</pre>
<p>We've added two projects to our database as well as updated all the tasks to include a reference to the first of the two projects.</p>
<p>Now, we are going to need a service to access our projects, and we should also update our task service to include a method that allows us to query for tasks that belong to a specific project.</p>
<p>First, let's apply the changes to the existing task service. Open up the <kbd>src/app/tasks/task.service.ts</kbd> file and implement the following changes. Effective changes are marked in bold, and the ellipsis character is indicating more code that is irrelevant for the changes to be applied:</p>
<pre>import {Injectable} from '@angular/core';<br/>import {HttpClient} from '@angular/common/http';<br/>import {BehaviorSubject} from 'rxjs';<br/><strong>import {map} from 'rxjs/operators';</strong><br/>import {Task} from '../model';<br/><br/>@Injectable()<br/>export class TaskService {<br/>  …<br/><br/><strong>  getProjectTasks(projectId: number) {</strong><br/><strong>    return this.tasks</strong><br/><strong>      .asObservable()</strong><br/><strong>      .pipe(</strong><br/><strong>        map((tasks) =&gt; tasks.filter((task) =&gt; task.projectId === projectId))</strong><br/><strong>      );</strong><br/><strong>  }</strong><br/>}</pre>
<p>The added <kbd>getProjectTasks</kbd> method is providing a mapped observable that takes our source tasks subject and maps each tasks array to produce a filtered tasks array that only includes tasks of a specific project.</p>
<p>Alright, now we need to create a new service that allows us to obtain information about the projects from our in-memory web API database. Let's use the Angular CLI to create a new service:</p>
<pre><strong>ng generate service --spec false project/project</strong></pre>
<p>The Angular CLI should have created our service on the path <kbd>src/app/project/project.service.ts</kbd>. Let's open that file and replace its content with the following code:</p>
<pre>import {Injectable} from '@angular/core';<br/>import {HttpClient} from '@angular/common/http';<br/>import {BehaviorSubject, Observable, combineLatest} from 'rxjs';<br/>import {map} from 'rxjs/operators';<br/>import {Project} from '../model';<br/><br/>@Injectable()<br/>export class ProjectService {<br/>  private projects = new BehaviorSubject&lt;Project[]&gt;([]);<br/>  private selectedProjectId = new BehaviorSubject&lt;number&gt;(1);<br/>  private selectedProject: Observable&lt;Project&gt;;<br/><br/>  constructor(private http: HttpClient) {<br/>    this.loadProjects();<br/>    this.selectedProject = combineLatest(this.projects, this.selectedProjectId)<br/>      .pipe(<br/>        map(([projects, selectedProjectId]) =&gt;<br/>        projects.find((project) =&gt; project.id === selectedProjectId)<br/>      )<br/>    );<br/>  }<br/><br/>  private loadProjects() {<br/>    this.http.get&lt;Project[]&gt;('/api/projects')<br/>      .subscribe((projects) =&gt; this.projects.next(projects));<br/>  }<br/><br/>  selectProject(id: number) {<br/>    this.selectedProjectId.next(id);<br/>  }<br/><br/>  getSelectedProject() {<br/>    return this.selectedProject;<br/>  }<br/>}</pre>
<p>Let's discuss the preceding code changes briefly. Our project service contains three members:</p>
<ul>
<li><strong>projects: BehaviourSubject&lt;Project[]&gt;</strong><br/>
The <kbd>projects</kbd> member behaviour subject is emitting our whole project list once loaded from our database. This subject is the basis for all operations within our service.</li>
<li><strong>selectedProjectId: BehaviourSubject&lt;number&gt;</strong><br/>
<span>Since we will need to know which of the projects is currently selected within our application, we need to store this information in our service. We're using a behaviour subject for emitting the currently selected project ID. This allows us to simply emit a project ID through <kbd>selectedProjectId</kbd> if we wish to select a given project.</span></li>
<li><strong>selectedProject: Observable&lt;Project&gt;</strong><br/>
The <kbd>selectedProject</kbd> observable will always emit the currently selected project. We'll make use of <kbd>combineLatest</kbd> to make sure if either <kbd>projects</kbd> or <kbd>selectedProjectId</kbd> emits a change. We will re-emit the updated, selected project through the <kbd>selectedProject</kbd> observable stream.</li>
</ul>
<p>Within the constructor of our service, we're first calling the <kbd>loadProjects</kbd> method to do the HTTP call to our in-memory web API database to obtain the list of projects. Within the <kbd>loadProjects</kbd> method, we're sticking to the same pattern from our task service. We're subscribing to the HTTP service observable and emitting the resulting items through our internal <kbd>projects</kbd> subject.</p>
<p>After executing the <kbd>loadProjects</kbd> method within our constructor, we will create the <kbd>selectedProject</kbd> observable. We will use <kbd>combineLatest</kbd>, which we've discussed already in the previous chapter, to combine the <kbd>projects</kbd> and the <kbd>selectedProjectId</kbd> subjects into a single observable stream. Whenever one of those two input observables emits an event, <kbd>combineLatest</kbd> will combine the latest result of both input observables into a single item that is emitted through the output observable stream. We're using the map operator to extract the selected project from the list of projects and returning it as an item into the observable output stream.</p>
<p>Finally, the <kbd>selectProject</kbd> method is merely emitting the new project ID through the <kbd>selectedProjectId</kbd> subject. Since we're using this subject within the <kbd>selectedProject</kbd> observable created with <kbd>combineLatest</kbd>, this change will cause the <kbd>selectedProject</kbd> observable to re-emit the currently selected project.</p>
<p>As the last step, we need to add our new service to the app module providers. Let's open the <kbd>src/app/app.module.ts</kbd> file and apply the following changes:</p>
<pre>…<br/><strong>import {ProjectService} from './project/project.service';</strong><br/><br/>…<br/>  providers: [<strong>ProjectService,</strong> TaskService],<br/>…</pre>
<p>Now, that's it for our project service for the moment. We've created our service in a highly reactive way, where we store all state within RxJS behavior subjects and react to change, transform streams, and emit where updates need to be communicated.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Project component</h1>
                </header>
            
            <article>
                
<p>We've already implemented all necessary changes to deal with the model, data, and state for our projects. Now, it's time to move on to the components that are required to display our projects and the tasks that belong to them.</p>
<p>Let's start by creating the project component using the Angular CLI:</p>
<pre><strong>ng generate component --spec false -ve none -cd onpush project/project</strong></pre>
<p>First, let's change the component class file located in <kbd>src/app/project/project/project.component.ts</kbd> by replacing its content with the following code:</p>
<pre>import {ChangeDetectionStrategy, Component, Input, ViewEncapsulation} from '@angular/core';<br/>import {Project} from '../../model';<br/><br/>@Component({<br/>  selector: 'mac-project',<br/>  templateUrl: './project.component.html',<br/>  styleUrls: ['./project.component.css'],<br/>  encapsulation: ViewEncapsulation.None,<br/>  changeDetection: ChangeDetectionStrategy.OnPush<br/>})<br/>export class ProjectComponent {<br/>  @Input() project: Project;<br/>}</pre>
<p>Nothing special here. We've created a simple project component that accepts a project object as input. Let's move on the template of our new component and change the content of the file in <kbd>src/app/project/project.component.ts</kbd>:</p>
<pre>&lt;header class="header"&gt;<br/>  &lt;h2 class="title"&gt;{{project.title}}&lt;/h2&gt;<br/>  {{project.description}}<br/>&lt;/header&gt;<br/>&lt;mac-task-list-container&gt;<br/>&lt;/mac-task-list-container&gt;</pre>
<p>Within our template, we first render the project header, which consists of the title and the description of our project. After the project header, we want to render all project tasks. We can just include the task list container component to do so.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating the task list container</h1>
                </header>
            
            <article>
                
<p>That's it for our project component. However, our task list container is still implemented in such a way that it deals with all available tasks and does not know anything about projects. Let's change that by modifying our component class located in <kbd>src/app/container/task-list-container.component.ts</kbd>. Changes are highlighted in bold while irrelevant parts are hidden under an ellipsis character:</p>
<pre>…<br/>import {<strong>Project,</strong> Task, TaskListFilterType} from '../../model';<br/>import {map, <strong>switchMap, take</strong>} from 'rxjs/operators';<br/><strong>import {ProjectService} from '../../project/project.service';</strong><br/><br/>@Component({<br/>  selector: 'mac-task-list-container',<br/>  templateUrl: './task-list-container.component.html',<br/>  encapsulation: ViewEncapsulation.None,<br/>  changeDetection: ChangeDetectionStrategy.OnPush<br/>})<br/>export class TaskListContainerComponent {<br/>  <strong>selectedProject: Observable&lt;Project&gt;;</strong><br/>  …<br/><br/>  constructor(private taskService: TaskService<strong>, private projectService: ProjectService</strong>) {<br/>    <strong>this.selectedProject = this.projectService.getSelectedProject();</strong><br/><br/><strong>    this.tasks = this.selectedProject.pipe(</strong><br/><strong>      switchMap((project) =&gt; this.taskService.getProjectTasks(project.id))</strong><br/><strong>    );</strong><br/><br/>    …<br/>  }<br/><br/>  …<br/><br/>  addTask(title: string) {<br/>    <strong>this.selectedProject</strong><br/><strong>      .pipe(</strong><br/><strong>        take(1)</strong><br/><strong>      )</strong><br/><strong>      .subscribe((project) =&gt; {</strong><br/><strong>        const task: Task = {</strong><br/><strong>          projectId: project.id, title, done: false</strong><br/><strong>        };</strong><br/><strong>        this.taskService.addTask(task);</strong><br/><strong>      });</strong><br/>  }<br/><br/>  …<br/>}</pre>
<p>First of all, we're introducing a new member called <kbd>selectedProject</kbd>, which is an observable stream that we obtain from our project service. Within the constructor of our component, we're injecting the project service and receiving the observable by calling the <kbd>getSelectedProject</kbd> method on our service. If you remember from the previous topic, this observable will always emit the currently selected project within our application.</p>
<p>Within the constructor, we also need to change the way we obtain our task list. Going forward, the task list that we're going to use within our container is always dependent on the selected project. To make this happen, we're going to look at a new RxJS operator called <kbd>switchMap</kbd>.</p>
<p>Let me first try to explain how <kbd>switchMap</kbd> works in one sentence. It takes an observable stream and for every item emitted, it connects a different observable stream to the output. This might sound confusing, so for you to get a better grasp on that new concept, let's look at a simplified example:</p>
<pre>import {from, interval} from 'rxjs';<br/>import {switchMap} from 'rxjs/operators';<br/><br/>const o1 = interval(1000);<br/>const o2 = from(['a', 'b']);<br/><br/>o1.pipe(<br/> switchMap(() =&gt; o2)<br/>).subscribe((item) =&gt; console.log(item));</pre>
<p>The preceding example uses <kbd>switchMap</kbd> to connect an observable <strong>(o2)</strong> to a new output observable, every time the source observable <strong>(o1)</strong> is emitting an item. We're using the <kbd>interval</kbd> helper to create an observable that is emitting an item every second. For the second observable <strong>(o2)</strong>, we're using the <kbd>from</kbd> helper to generate an observable sequence that is emitting the strings <strong>a</strong> and <strong>b</strong> as separate items. After that, we're using the <kbd>switchMap</kbd> operator, which will create a new output observable that connects our <strong>(o2)</strong> observable to the output, whenever there's a new item emitted by the source observable <strong>(o1)</strong>. The preceding example will, therefore, log the strings <strong>a</strong> and <strong>b</strong> to the console each second:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/49510bc3-69e8-4dd4-b21b-b92fe9d941cc.png" style=""/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">A stream diagram showing the behaviour of the switchMap operator</div>
<p>If you're used to Promises, then you can also think of the <kbd>switchMap</kbd> operator as building an asynchronous Promise chain by returning new Promises within the <kbd>then</kbd> function:</p>
<pre>function timer(time) {<br/>  return new Promise(resolve =&gt; setTimeout(resolve, time));<br/>}<br/><br/>timer(1000)<br/> .then(() =&gt; timer(1000))<br/> .then(() =&gt; timer(1000))<br/> .then(() =&gt; timer(1000))<br/> .then(() =&gt; console.log('After 4 seconds!'));</pre>
<p>By chaining Promises, we can perform four different asynchronous operations in sequence. The <kbd>switchMap</kbd> operator behaves almost the same, but instead, we could chain four different observables after each other:</p>
<pre>import {timer} from 'rxjs';<br/>import {switchMap} from 'rxjs/operators';<br/><br/>timer(1000).pipe(<br/> switchMap(() =&gt; timer(1000)),<br/> switchMap(() =&gt; timer(1000)),<br/> switchMap(() =&gt; timer(1000))<br/>).subscribe((item) =&gt; console.log('After 4 seconds!'));</pre>
<p>Okay, we have learned about the <kbd>switchMap</kbd> operator and how we can use it to chain multiple asynchronous operations in sequence. Now, let's go back to our task list container component and see how we can apply this concept to obtain project tasks. The following core excerpt is only showing the relevant part of the changes we have used already in our task list container component:</p>
<pre>…  <br/><strong>this.tasks = this.selectedProject.pipe(</strong><br/><strong>  switchMap((project) =&gt; this.taskService.getProjectTasks(project.id))</strong><br/><strong>);</strong><br/>…</pre>
<p>In our case, we're using the <kbd>switchMap</kbd> operator to take the <kbd>selectedProject</kbd> observable as input and switch to the observable we're obtaining by the <kbd>getProjectTasks</kbd> call. This technique allows us to chain the two asynchronous operations, obtaining the selected project and receiving tasks, together in sequence. Within the callback of the <kbd>switchMap</kbd> operator, we are receiving the selected project object, and we use the ID of the project to obtain the observable of project tasks.</p>
<p>Now, every time the <kbd>selectedProject</kbd> observable is emitting a new value, our tasks observable will also emit the latest tasks of the selected project. Nice and reactive.</p>
<p>Alright! There's only one change left to discuss. Let's focus on the changes within the <kbd>addTask</kbd> method. Since our task model is now also including a <kbd>projectId</kbd> property, we need to make sure we're adding the correct project ID every time we create a task.</p>
<p>We make use of another unknown RxJS operator, <kbd>take</kbd>, within the code changes for the <kbd>addTask</kbd> method. Don't worry. The <kbd>take</kbd> operator works much more straightforward than the <kbd>switchMap</kbd> operator. Again, let's start with a simplification:</p>
<pre>import {from} from 'rxjs';<br/>import {take} from 'rxjs/operators';<br/><br/>from([1, 2, 3]).pipe(<br/> take(1)<br/>).subscribe((item) =&gt; console.log(item));</pre>
<p>The code in the preceding example will print the number one to the console. The numbers two and three will not be emitted by the output stream after the transformation using the <kbd>take</kbd> operator. The <kbd>take</kbd> operator will create a new observable stream that will only emit the number of items specified with the parameter passed to it. After the amount of items specified are emitted, the stream will close itself, even calling for unsubscription to all parent streams:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/657f7f96-f032-41a3-9b98-d42617176005.png" style=""/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Input observable with three emissions is transformed to an output observable with one emission using the take operator</div>
<p>The <kbd>take</kbd> operator is especially impressive on our behaviour subjects, where you'd like to do some one-off actions on emitted items. Since behaviour subjects are always issuing the most recent item at a new subscription, we can use the take operator to immediately extract the latest value of the behaviour subject and do something with it.</p>
<p>Let's look at the code of our updated <kbd>addTask</kbd> method again to see how and why we're making use of the <kbd>take</kbd> operator there:</p>
<pre>…<br/>addTask(title: string) {<br/>  <strong>this.selectedProject</strong><br/><strong>    .pipe(</strong><br/><strong>      take(1)</strong><br/><strong>    )</strong><br/><strong>    .subscribe((project) =&gt; {</strong><br/><strong>      const task: Task = {</strong><br/><strong>        projectId: project.id, title, done: false</strong><br/><strong>      };</strong><br/><strong>      this.taskService.addTask(task);</strong><br/><strong>    });</strong><br/>}<br/>…</pre>
<p>First of all, we need to understand at which point in time the <kbd>addTask</kbd> method is getting called. This call happens whenever the user clicks on the add task button within the user interface. All we want to do now really is get the latest value of our <kbd>selectedProject</kbd> observable so that we can use the project ID to create our task associated with this project. However, if we'd subscribed to the <kbd>selectedProject</kbd> observable in a usual way, we'd keep those subscriptions within the <kbd>addTask</kbd> method active forever. This behaviour would mean that going forward when we call this method, let's say, ten times, on every change of the selected project, those ten subscriptions would fire again and create some unwanted duplicate tasks.</p>
<p>Using the <kbd>take</kbd> operator, we can prevent this behaviour. It allows us to create an observable stream that will be automatically unsubscribed once the desired amount of items have passed through. When we pass the number one as an item count parameter to the <kbd>take</kbd> operator, we can just take one item from the source stream and create a subscription that is only valid for this one item.</p>
<p>That's it for the changes within the task list container component. Till now, we have created a new project service, updated our existing task service, created a project component, and updated our task list container component to deal with the currently selected project. The last thing that is left to do is integrate our project component into the overall application as a top level component.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Integrating the project component</h1>
                </header>
            
            <article>
                
<p>Within this topic, we're going to integrate the changes we've applied so far to our application. Currently, our root component is rendering a task list container component directly, which we will need to change to render our projects.</p>
<p>We could go ahead and render the project UI component directly within our application root component, h<span>owever, we've learned that we should never include a top-level component without a container component to separate our state concerns from our user interface.</span></p>
<p>Let's fix this and use the Angular CLI to create a project container component:</p>
<pre><strong>ng generate component --spec false -ve none -cd onpush container/project-container</strong></pre>
<p>After the component stub has been generated, open up the <kbd>src/app/container/project-container/project-container.component.ts</kbd> file and apply the following changes:</p>
<pre>import {Component, ChangeDetectionStrategy, ViewEncapsulation} from '@angular/core';<br/>import {Observable} from 'rxjs';<br/>import {Project} from '../../model';<br/>import {ProjectService} from '../../project/project.service';<br/><br/>@Component({<br/>  selector: 'mac-project-container',<br/>  templateUrl: './project-container.component.html',<br/>  styleUrls: ['./project-container.component.css'],<br/>  encapsulation: ViewEncapsulation.None,<br/>  changeDetection: ChangeDetectionStrategy.OnPush<br/>})<br/>export class ProjectContainerComponent {<br/>  selectedProject: Observable&lt;Project&gt;;<br/><br/>  constructor(private projectService: ProjectService) {<br/>    this.selectedProject = projectService.getSelectedProject();<br/>  }<br/>}</pre>
<p>Nothing fancy here. We're using the project service to obtain the observable that is emitting the currently selected project. We're going to use this observable to render our project UI component. Let's open up the view template of our new container component located in <kbd><span>src/app/container/project-container/project-container.component.html</span></kbd> and replace the stub template with the following code:</p>
<pre>&lt;mac-project [project]="selectedProject | async"&gt;<br/>&lt;/mac-project&gt;</pre>
<p>Also, the view template is ridiculously simple. However, we should not fall into the temptation of skipping a data container component just because things look too simple to be worth a wrapper. You should always bring up the discipline to stick to the rule that every top-level component needs a container component to handle the data and state concerns. It will save you a lot of time in the future.</p>
<p>Now, it's time to include the project container component in the view of our root component. At the same time, we'll also change the layout of our application slightly, and go one step further toward our final application look.</p>
<p>Let's open up the view template of our root component located in <kbd>src/app/app.component.html</kbd> and apply the following changes:</p>
<pre>&lt;aside class="side-nav"&gt;&lt;/aside&gt;<br/>&lt;main class="main"&gt;<br/>  &lt;mac-project-container&gt;&lt;/mac-project-container&gt;<br/>&lt;/main&gt;</pre>
<p>We're adding two layout elements as well as our newly created project container component. That's it for our changes to integrate the project component into our application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Recap</h1>
                </header>
            
            <article>
                
<p>Congratulations! You've successfully implemented the first version of the project feature into our application. We've created a whole bunch of things in this topic. Besides building the model and database, services, and components, we have also integrated our feature successfully by creating and including a new project container component. Go ahead and preview our changes within your browser. I hope you're happy with the results and are looking forward to further enhancements.</p>
<p>Let's summarize what we did within this topic:</p>
<ul>
<li>Created and updated our model to include projects</li>
<li>Implemented a new project service to obtain project data and updated the existing task service to deal with project tasks</li>
<li>We've created a new project component as well as a project container component to separate our UI from state and data concerns</li>
<li>We updated the task list container component to use the active project information to display only relevant project tasks</li>
<li>We learned about the <kbd>switchMap</kbd> and <kbd>take</kbd> operators from RxJS and how to use them within our application</li>
<li>Updated our root component view to include our project container component instead of the task list container</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a tabbed interface component</h1>
                </header>
            
            <article>
                
<p>Let's introduce a new UI component to the project that will provide us with a tabbed interface that we can use for navigation purposes inside of the project component. We'd like to divide the project view into different areas that can be accessed through this tabbed interface:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5a4cb7ea-70f1-429e-8e59-664c3771e8a4.png" style=""/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Screenshot of the tabbed interface we're going to create</div>
<p>Before we create a new component to render tabs, we will update our model to declare an interface that we're using to represent an individual tab. Open the <kbd>src/app/model.ts</kbd> file and apply the following changes:</p>
<pre>…<br/><strong>export interface Tab {</strong><br/><strong>  readonly id: any;</strong><br/><strong>  readonly title: string;</strong><br/><strong>}</strong></pre>
<p>Our tabs will always consist of a title and an ID, which will be useful later when we need to distinguish between individual tabs. Next, we're going to create our tabs component. Using the Angular CLI, we can create the stub of our new component:</p>
<pre><strong>ng generate component --spec false -ve none -cd onpush ui/tabs/tabs</strong></pre>
<p class="mce-root">Let's open up the component class located in <kbd>src/app/ui/tabs/tabs.component.ts</kbd> and add the following code:</p>
<pre>import {<br/>  ChangeDetectionStrategy, Component, EventEmitter, Input, Output, ViewEncapsulation<br/>} from '@angular/core';<br/>import {Tab} from '../../model';<br/><br/>@Component({<br/>  selector: 'mac-tabs',<br/>  templateUrl: './tabs.component.html',<br/>  styleUrls: ['./tabs.component.css'],<br/>  encapsulation: ViewEncapsulation.None,<br/>  changeDetection: ChangeDetectionStrategy.OnPush<br/>})<br/>export class TabsComponent {<br/>  @Input() tabs: Tab[];<br/>  @Input() activeTab: Tab;<br/>  @Output() outActivateTab = new EventEmitter&lt;Tab&gt;();<br/><br/>  activateTab(tab: Tab) {<br/>    this.outActivateTab.emit(tab);<br/>  }<br/>}</pre>
<p>We're following the concept of simple and "pure" components and only using input to determine how we should render our tabs. Also, when a tab gets activated, we'll call the <kbd>activateTab</kbd> method that will then emit using the <kbd>outActivateTab</kbd> output. By now, you should be quite familiar with what you see in this component class and the concepts behind it. The <kbd>tabs</kbd> input is expected to be a list of tab objects, for which we've just created an interface within our model. Let's open the component view template located in <kbd>src/app/ui/tabs/tabs.component.html</kbd> and replace its content with the following code:</p>
<pre>&lt;ul class="tab-list"&gt;<br/>  &lt;li *ngFor="let tab of tabs"<br/>      class="tab-list-item"&gt;<br/>    &lt;button class="tab-button"<br/>            [class.tab-button-active]="activeTab?.id === tab.id"<br/>            (click)="activateTab(tab)"&gt;{{tab.title}}&lt;/button&gt;<br/>  &lt;/li&gt;<br/>&lt;/ul&gt;</pre>
<p>We're repeating over our list of tabs and rendering a button as the effective tab element. On the tab button, we set a class based on the condition if the current tab from the repetition is the same tab that got passed into our component as an active tab. This will make our active tab look different from the rest. When the user clicks one of the tabs, we're calling the <kbd>activateTab</kbd> method and passing the clicked tab object as a parameter. Going back to the component code, you can see that we're then emitting this tab through the <kbd>outActivateTab</kbd> output.</p>
<p>Alright, that was already everything we need for our tabs component. Let's make use of our tabs in the project component and provide a tabbed interface to access the project's details.</p>
<p>First, let's open the project component class in <kbd>src/app/project/project/project.component.ts</kbd> and update our code with the following changes:</p>
<pre>import {ChangeDetectionStrategy, Component, <strong>EventEmitter,</strong> Input, <strong>Output,</strong> ViewEncapsulation} from '@angular/core';<br/>import {Project<strong>, Tab</strong>} from '../../model';<br/><br/>…<br/>export class ProjectComponent {<br/>  @Input() project: Project;<br/><strong>  @Input() tabs: Tab[];</strong><br/><strong>  @Input() activeTab: Tab;</strong><br/><strong>  @Output() outActivateTab = new EventEmitter&lt;Tab&gt;();</strong><br/><br/><strong>  activateTab(tab: Tab) {</strong><br/><strong>    this.outActivateTab.emit(tab);</strong><br/><strong>  }</strong><br/>}</pre>
<p>We're going to use the tabs component in our project component, and therefore we need to provide the necessary input and handle the output of the tabs component. For this reason, our project component will now also contain the inputs <kbd>tabs</kbd> and <kbd>activeTab</kbd>.</p>
<p>We've learned from the previous chapter, <a href="0ae44400-ec3a-4fb6-816b-b5e808196718.xhtml">Chapter 3</a>, <em>Dealing with Data and State</em>, that our UI components should always delegate output until they reach a container component. Following this concept will ensure we're separating our state and data manipulation from our UI components, which will significantly enhance the overall maintainability of our code. Since our tabs component will notify us of a change in the active tab, we will respond to this by delegating and merely re-emitting the <kbd>outActivateTab</kbd> output.</p>
<p>Alright, let's open up the project view template located in <kbd>src/app/project/project/project.comonent.html</kbd> and edit it with the following changes:</p>
<pre>&lt;header class="header"&gt;<br/>  &lt;h2 class="title"&gt;{{project.title}}&lt;/h2&gt;<br/>  {{project.description}}<br/>&lt;/header&gt;<br/><strong>&lt;mac-tabs [tabs]="tabs"</strong><br/><strong>          [activeTab]="activeTab"</strong><br/><strong>          (outActivateTab)="activateTab($event)"&gt;</strong><br/><strong>&lt;/mac-tabs&gt;</strong><br/>&lt;mac-task-list-container<strong> *ngIf="activeTab.id === 'tasks'</strong>"&gt;<br/>&lt;/mac-task-list-container&gt;</pre>
<p>We're rendering our tabs component, passing down the tabs objects and the currently active tab we've received as input to the project component. We'll also listen for a tab activation output on the tabs component and call the <kbd>activateTab</kbd> method within the project component.</p>
<p>We're also using the information of the active tab to decide if we should render the task list container component or not. Only if the ID of the currently active tab equals to "tasks" will we render the task list.</p>
<p>Okay, now we need to make sure we're passing the data required for the tabs down to the project component. We also need to ensure that when a tab is activated, we're performing the necessary changes to our application state. The project container component renders the project component, so let's open up the component class located in <kbd>src/app/container/project-container/project-container.component.ts</kbd> and apply the following changes:</p>
<pre>…<br/>import {Project<strong>, Tab</strong>} from '../../model';<br/><br/>…<br/>export class ProjectContainerComponent {<br/>  selectedProject: Observable&lt;Project&gt;;<br/><strong>  tabs: Tab[] = [</strong><br/><strong>    {id: 'tasks', title: 'Tasks'},</strong><br/><strong>    {id: 'comments', title: 'Comments'},</strong><br/><strong>    {id: 'activities', title: 'Activities'}</strong><br/><strong>  ];</strong><br/><strong>  activeTab: Tab = this.tabs[0];</strong><br/><br/>  …<br/><strong>  activateTab(tab: Tab) {</strong><br/><strong>    this.activeTab = tab;</strong><br/><strong>  }</strong><br/>}</pre>
<p>Since we're now in a container component, it's okay to store state and perform actions on that state. We're adding a list of tab objects where we are already thinking a bit ahead. The <span class="packt_screen">Comments</span> tab will be used to switch to our commenting system that we'll be building later in this chapter. The <span class="packt_screen">Activities</span> tab will be used in a later chapter of this book.</p>
<p>We're also storing the currently active tab using the <kbd>activeTab</kbd> member and initializing it with the first tab within our tabs list.</p>
<p>The code within the <kbd>activateTab</kbd> method looks almost too simple to be right. All we're doing is accepting a tab object as a parameter and updating our <kbd>activeTab</kbd> member.</p>
<p>Now, all that's left to do for making use of our tabs component is updating the bindings within the project container component. Let's open the component view template located in <span><kbd>src/app/container/project-container/project-container.component.html</kbd> and apply the following changes:</span></p>
<pre>&lt;mac-project [project]="selectedProject | async"<br/>             <strong>[tabs]="tabs"</strong><br/><strong>             [activeTab]="activeTab"</strong><br/><strong>             (outActivateTab)="activateTab($event)"</strong>&gt;<br/>&lt;/mac-project&gt;</pre>
<p>That was easy, right? This last change was already everything required to provide a friendly tabbed interface to our project component. We'll make use of the <kbd>activeTab</kbd> property to activate more detail views of our project going forward. At the moment, the <span class="packt_screen">Tasks</span> tab is the only tab enabling something within our user interface, but as continue adding features, we'll use the other two tabs for navigation too.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building the main navigation</h1>
                </header>
            
            <article>
                
<p>In this chapter, we've already added a project feature to our application. We've also added a tabbed interface to navigate the details of a project. However, there's still no way to navigate between projects. That's what we're going to change now. In this section, we will create components to build our main navigation. We will then integrate it and use it to navigate between all existing projects within the application:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6fc4767a-93d9-4bb5-afb2-6b863d790263.png" style=""/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Screenshot of the main navigation we're going to build in this section of the book</div>
<p>We are designing our navigation components in such a way that we can quickly make use of them in any situation. For achieving this goal, we're going to look at a new concept within Angular, which is called content projection. With the use of content projection, we can achieve a new level of component composition.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Composition using content projection</h1>
                </header>
            
            <article>
                
<p>Content projection allows you to insert a view portion from a parent component into its child component. This concept is a potent tool when it comes to composition. With so-called content slots, we can mark a position within our child component where we'd like to give our parent components the opportunity to pass in a view portion.</p>
<p>Let's look at a simple content projection example that helps us understand what this is good for:</p>
<pre>@Component({ 
  selector: 'mac-reveal-content', 
  template: ` 
    &lt;h2 (click)="showContent = !showContent"&gt;{{revealTitle}}&lt;/h2&gt;<br/>    &lt;div *ngIf="showContent" class="content"&gt;<br/>      <strong>&lt;ng-content&gt;&lt;/ng-content&gt;</strong><br/>    &lt;/div&gt;
  ` 
}) 
export class RevealContentComponent {<br/>  @Input() title: string;<br/>  showContent = false;<br/>} 
 
@Component({ 
  selector: 'mac-root', 
  template: ` 
    &lt;mac-reveal-content revealTitle="Click to show more"&gt;<br/>     <strong> &lt;p&gt;I'm the content which is shown or hidden when you click the above title&lt;/p&gt;</strong><br/>    &lt;/mac-reveal-content&gt;<br/>  `<br/>})<br/>export class AppComponent {}</pre>
<p>The preceding example is showing a straightforward UI component called the reveal content component. It's showing a title that we can click on to show or hide content. This behaviour is advantageous in a lot of situations and is similar to the concept of an accordion or collapsible component.</p>
<p>There are two things in this example that are unique and should look unfamiliar to you. I've also highlighted those two lines of code for you so that you can see them popping out right away.</p>
<p>Within our reveal content component, we're using the <span> <kbd>&lt;ng-content&gt;</kbd>  element to </span>mark the position for content to be projected from a parent component. This element is also called a content projection slot, and you can have multiples of those slots within your component view.</p>
<p>The second thing, which is something we've never done so far, is within the app component of the preceding example. We put some template code between the reveal content component open and close tags. Usually, a component will eliminate any template code that is put into its host element. However, before it does so, it first checks if the child component contains content projection slots. If there are content projection slots within the child component, it will project any view portion found in the host element into the child component at the designated position. This is the position we've marked using the <kbd>&lt;ng-content&gt;</kbd> element.</p>
<div class="packt_infobox"><span>Content projection and projection slots are concepts borrowed from the web components Shadow DOM specification. Angular does not yet use Shadow DOM by default, and therefore the behaviour is emulated. However, the concept is the same. If you're familiar with Angular.js, the first version of Angular, content projection is very similar to the idea of transclusion from Angular.js.</span></div>
<p>Additionally, we can use a select attribute on the<span> </span><kbd>&lt;ng-content&gt;</kbd><span> </span>element to set a CSS-like selector. This selector will be used to<span> selectively choose that elements should be projected into the specific content slot</span>. In this way, you can have multiple content slots that cover different requirements.</p>
<p>Elements from the component host element can only be projected once, and this content projection works by going through all the<span> </span><kbd>&lt;ng-content&gt;</kbd><span> </span>elements in sequential order by projecting any matching elements. If you have multiple competing content projection slots in your template, the first one will win and receive the elements <span><span>that </span></span>get projected into your component.</p>
<p>Let's look at another example <span><span>that </span></span>illustrates this behavior:</p>
<pre>@Component({ 
  selector: 'mac-multi-projection', 
  template: `<br/>    &lt;header class="title"&gt;<br/>      &lt;ng-content select="h1"&gt;&lt;/ng-content&gt;<br/>    &lt;/header&gt;<br/>    &lt;main class="rest-content"&gt;<br/>      &lt;ng-content&gt;&lt;/ng-content&gt;<br/>    &lt;/main&gt;<br/>  `<br/>}) <br/>export class MultiProjectionComponent {}<br/><br/>@Component({<br/>  selector: 'mac-root',<br/>  template: `<br/>    &lt;mac-multi-projection&gt;<br/>      &lt;h1&gt;This title will be projected in the first slot&lt;/h1&gt;<br/>      &lt;p&gt;Any other element will be projected into the second, generic slot&lt;/p&gt;<br/>    &lt;/mac-multi-projection&gt;<br/>  `<br/>})<br/>export class AppComponent {}</pre>
<p class="packt_figure">The preceding example shows how we can use selective content projection using the <kbd>select</kbd> attribute on a <kbd>&lt;ng-content&gt;</kbd> element. The <kbd>h1</kbd> title element is projected into the first content projection slot since we're using a CSS selector that matches all <kbd>h1</kbd> elements. The second content slot does not contain a <kbd>select</kbd> attribute and therefore accepts all other elements <span><span>that </span></span>are projected into the component.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating navigation components</h1>
                </header>
            
            <article>
                
<p>We will build our navigation from three separate components. Let's look at their purpose real quick:</p>
<ul>
<li><strong>The navigation item component</strong>: Represents one navigation item within our navigation. Its responsibility is to render the title of a navigation item as well as its behavior when an item is activated.</li>
<li><strong>The navigation section component</strong>: This is used to visually separate navigation items <span><span>that </span></span>belong together. We can use this component to group navigation items under a title. This grouping makes it easier for our users to find the navigation items they are looking for.</li>
<li><strong>The navigation component</strong>: This holds the full navigation together. It's just a container <span><span>that </span></span>contains our navigation section components together.</li>
</ul>
<p>By using selective content projection, we can provide an excellent content-based API, which makes it easy to use our navigation components in any situation. The benefit of building content-based APIs is that we can compose our components together, only by including them in a view template.</p>
<p>Let's start by creating the lowest of the three components, the navigation item:</p>
<pre><strong>ng generate component --spec false -ve none -cd onpush ui/navigation-item/navigation-item</strong></pre>
<p>Let's open up the view templated located in <kbd>src/app/ui/navigation-item/navigation-item.component.html</kbd> and change its content with the following code:</p>
<pre>{{title}}</pre>
<p>Yes, I know, it looks too simple to be true. But that's all we need within the view of our navigation item component. Let's move on to the component class of the navigation item located in <span><kbd>src/app/ui/navigation-item/navigation-item.component.ts</kbd>:</span></p>
<pre>import {<br/>  ChangeDetectionStrategy, Component, EventEmitter, HostListener, Input, Output,<br/>  ViewEncapsulation<br/>} from '@angular/core';<br/><br/>@Component({<br/>  selector: 'mac-navigation-item',<br/>  templateUrl: './navigation-item.component.html',<br/>  styleUrls: ['./navigation-item.component.css'],<br/>  encapsulation: ViewEncapsulation.None,<br/>  changeDetection: ChangeDetectionStrategy.OnPush<br/>})<br/>export class NavigationItemComponent {<br/>  @Input() title: string;<br/>  @Input() navId: any;<br/>  @Output() outActivateNavigationItem = new EventEmitter&lt;any&gt;();<br/><br/>  @HostListener('click')<br/>  activateNavigationItem() {<br/>    this.outActivateNavigationItem.emit(this.navId);<br/>  }<br/>}</pre>
<p>Besides a <kbd>title</kbd> input, the component also takes an input, <kbd>navId</kbd>, to be used later during activation. This ID will help us in our parent component when detecting which of the navigation items was activated.</p>
<p>We are using a new decorator within our component that we haven't used before. The <kbd>@HostListener</kbd> decorator is a handy addition to our Angular toolset. With the help of host listeners, you can create event bindings on the component host element, but handle them within your component. Usually, the host element is not in direct control of our component. The host element always resides within the parent component where our component is placed. However, sometimes it's required to bind to properties or events of that element. Just like in our case, where we'd like to bind to the click event on the host element of our component. You can use the <kbd>@HostListener</kbd> decorator on a method to bind that method to a specific event on the host element. Pass the event name you'd like to bind to as a parameter to the decorator. In our case, we're binding to the click event on the navigation item host element. Each time the click event is fired, our <kbd>activateNavigationItem</kbd> method will be executed.</p>
<p>Inside the <kbd>activateNavigationItem</kbd><span> method, after a navigation item is clicked, we're emitting the ID of the specific navigation item through the <kbd>outActivateNavigationItem</kbd> output.</span></p>
<p>Alright, that's it for our navigation items. Let's move one level higher within our navigation component tree and create the navigation section component:</p>
<pre><strong>ng generate component --spec false -ve none -cd onpush ui/navigation-section/navigation-section</strong></pre>
<p>The navigation section component is responsible for grouping navigation items together. Let's open the view template located in <kbd>src/app/ui/navigation-section/navigation-section.component.html</kbd> first and apply the necessary changes:</p>
<pre>&lt;div class="title"&gt;{{title}}&lt;/div&gt;<br/>&lt;div class="item-list"&gt;<br/>  &lt;ng-content select="mac-navigation-item"&gt;&lt;/ng-content&gt;<br/>&lt;/div&gt;</pre>
<p>Each navigation section consists of a title as well as a list of navigation items. Now, we're making use of content projection, which we looked at in the previous section. We're marking a place within our view template where view portions from the parent component can be projected into the navigation section component. Since we know that we only want the navigation item component to be projected into our navigation section, we are using a <kbd>select</kbd> attribute on the <kbd>&lt;ng-content&gt;</kbd> element. By setting the <kbd>select</kbd> attribute to a value of <kbd>mac-navigation-item</kbd>, Angular will only project navigation item components into this content slot.</p>
<p>Let's also apply the changes to our navigation section component class located in <kbd>src/app/ui/navigation-section/navigation-section.component.ts</kbd>:</p>
<pre>import {ChangeDetectionStrategy, Component, Input, ViewEncapsulation} from '@angular/core';<br/><br/>@Component({<br/>  selector: 'mac-navigation-section',<br/>  templateUrl: './navigation-section.component.html',<br/>  styleUrls: ['./navigation-section.component.css'],<br/>  encapsulation: ViewEncapsulation.None,<br/>  changeDetection: ChangeDetectionStrategy.OnPush<br/>})<br/>export class NavigationSectionComponent {<br/>  @Input() title: string;<br/>}</pre>
<p>This component class is elementary. The only thing we do here is to provide a title input that is rendered within our navigation section view. The rest of our component logic is handled using content projection, which is providing us with a beautiful content-based API.</p>
<p>Now, we could already go ahead and use those two components in conjunction and arrange them in any view template within our application. As an example, we could write a navigation for accessing cute dog pictures:</p>
<pre>&lt;mac-navigation-section title="Dogs"&gt;<br/>  &lt;mac-navigation-item navId="pug" title="Pug"&gt;&lt;/mac-navigation-item&gt;<br/>  &lt;mac-navigation-item navId="french-bulldog" title="French Bulldog"&gt;&lt;/mac-navigation-item&gt;<br/>  &lt;mac-navigation-item navId="corgi" title="Corgi"&gt;&lt;/mac-navigation-item&gt;<br/>&lt;/mac-navigation-section&gt;</pre>
<p>That's the big strength of content-based APIs. Using content projection, we provide the ability to compose complex component trees and configure behaviour using only view templates. This comes with a significant ease of use. Not surprisingly, a lot of Angular UI libraries are using content projection to create their APIs, simply because it's just so much easier to configure everything you need declaratively using Angular templates.</p>
<p>Okay, now, let's create the last component of our three—the navigation component. The navigation component is putting a frame on our navigation and is grouping navigation sections together:</p>
<pre><strong>ng generate component --spec false -ve none -cd onpush ui/navigation/navigation</strong></pre>
<p>First, let's open the view template of the navigation component located in <kbd>src/app/ui/navgiation/navigation.component.html</kbd> and change its content to the following code:</p>
<pre>&lt;nav&gt;<br/>  &lt;ng-content select="mac-navigation-section"&gt;&lt;/ng-content&gt;<br/>&lt;/nav&gt;</pre>
<p>We're using content projection again to project elements into our navigation view. This time, we're selecting only navigation section components. Let's also change our component class in <kbd>src/app/ui/navigation/navigation.component.ts</kbd>:</p>
<pre>import {Component, ViewEncapsulation} from '@angular/core';<br/><br/>@Component({<br/>  selector: 'mac-navigation',<br/>  templateUrl: './navigation.component.html',<br/>  styleUrls: ['./navigation.component.css'],<br/>  encapsulation: ViewEncapsulation.None<br/>})<br/>export class NavigationComponent {<br/><br/>}</pre>
<p>Okay, this is as simple as a component class could be. The class is empty, and we're not providing any particular component configuration. You might wonder why we even need this component. Well, to decide about the right to exist for our components, we need to look at all parts that are defining the component. The component class might not contain any behavioral content. However, the styles and the component view could provide material that makes the component worth existing. If you're using content projection, you often end up with very little code within your classes, and that's fine. As long as the content projection or even only encapsulated styles provide us developers with a more convenient API, we should feel right about the architecture.</p>
<p>Coming back to the overall navigation component tree, things might start to get a bit confusing, which is normal when multiple levels are involved. Just to recap quickly:</p>
<ul>
<li>The navigation item is rendering a title and dealing with the behaviour when an item is getting activated</li>
<li>The navigation sections render a section title and project navigation items</li>
<li>The navigation solely projects navigation sections and acts as a container around our navigation</li>
</ul>
<p>Now, we're ready to use our navigation components and put them into action within our application!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Providing a project navigation</h1>
                </header>
            
            <article>
                
<p>Within this section, we're going to use the navigation components we've just created to provide a project navigation. For this, we're first going to introduce the necessary changes in the app component class located in <kbd>src/main/app/app.component.ts</kbd>. This is the first time we are dealing with the app or root component class. Since this is our root component, we're treating it like a container component, and it gets the privileges to deal with state and data:</p>
<pre>import {Component, ViewEncapsulation} from '@angular/core';<br/>import {Observable} from 'rxjs';<br/>import {Project} from './model';<br/>import {ProjectService} from './project/project.service';<br/><br/>@Component({<br/>  selector: 'mac-root',<br/>  templateUrl: './app.component.html',<br/>  styleUrls: ['./app.component.css'],<br/>  encapsulation: ViewEncapsulation.None<br/>})<br/>export class AppComponent {<br/>  projects: Observable&lt;Project[]&gt;;<br/>  selectedProject: Observable&lt;Project&gt;;<br/><br/>  constructor(private projectService: ProjectService) {<br/>    this.projects = projectService.getProjects();<br/>    this.selectedProject = this.projectService.getSelectedProject();<br/>  }<br/><br/>  selectProject(id: number) {<br/>    this.projectService.selectProject(id);<br/>  }<br/>}</pre>
<p>We're storing two observables within our app component. Using the project service, we're obtaining an observable that emits the list of available projects. We're also storing the observable that emits the currently selected project.</p>
<p>The <kbd>selectProject</kbd> method is accepting a project ID as a parameter and delegates the call to our project service. This will then cause all observers who subscribed to the selected project observable to receive the newly selected project. If you remember, we're already using this observable within our task list container component.</p>
<p>Let's move on to the view template of our app component located in <kbd>src/app/app.component.html</kbd> and apply the following changes:</p>
<pre>&lt;aside class="side-nav"&gt;<br/><strong>  &lt;mac-navigation&gt;</strong><br/><strong>    &lt;mac-navigation-section title="Projects"&gt;</strong><br/><strong>      &lt;mac-navigation-item *ngFor="let project of projects | async"</strong><br/><strong>                           [navId]="project.id"</strong><br/><strong>                           [title]="project.title"</strong><br/><strong>                           [class.active]="project.id === (selectedProject | async).id"</strong><br/><strong>                           (outActivateNavigationItem)="selectProject($event)"&gt;</strong><br/><strong>      &lt;/mac-navigation-item&gt;</strong><br/><strong>    &lt;/mac-navigation-section&gt;</strong><br/><strong>  &lt;/mac-navigation&gt;</strong><br/>&lt;/aside&gt;<br/>&lt;main class="main"&gt;<br/>  &lt;mac-project-container&gt;&lt;/mac-project-container&gt;<br/>&lt;/main&gt;</pre>
<p>We're using our navigation components to create a project navigation in the space that is reserved for our main navigation. At the moment, we're rendering just one navigation section that belongs to our projects. By using the <kbd>NgFor</kbd> directive, we're repeating a navigation item component for each project within the list of available projects. We're binding the project ID to the <kbd>navId</kbd> input as well as the project title to the <kbd>title</kbd> input <span>of our navigation item. Additionally, we're setting an active class on the navigation item component if the specific project is currently selected.</span></p>
<p>If one of the navigation items is activated, we call the <kbd>selectProject</kbd> method of our app component and pass the ID that is emitted by the <kbd>outActivgateNavigationItem</kbd> as <kbd>$event</kbd>.</p>
<p><span>That's it! You have successfully built a project navigation. It's a good time to preview your changes in the browser now. You should already be able to navigate between the two projects that were added into our database. Since our task list container is already making use of the selected project observable, the logic of switching between projects should already be seamless. You can try to navigate to the second project, which does not contain any tasks. Try adding tasks and switching between the two projects.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Recap</h1>
                </header>
            
            <article>
                
<p>Within this section, we've created our navigation components and used them to create our project navigation. You have learned about the following concepts:</p>
<ul>
<li>Using content projection to build a content-based API for your components</li>
<li>The idea of content projection slots and the use of <kbd>&lt;ng-content&gt;</kbd></li>
<li>Using the <kbd>select</kbd> attribute on content slots to selectively project content</li>
<li>Using the <kbd>@HostListener</kbd> decorator to bind host element events to component methods</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">One editor to rule them all</h1>
                </header>
            
            <article>
                
<p>We will be processing a lot of user input within our application. Therefore, it's crucial to provide a pleasant authoring experience to our users. Users need to be able to edit project titles, descriptions, and task titles. Within the commenting system, which we are creating later in this chapter, users also need to be able to edit their comments. We could use regular text area input and work with dialogue boxes to edit those fields, but this seems too old-fashioned for a modern user interface. Native input fields are fantastic, but sometimes they don't provide an outstanding user experience. What we're looking for is a way to edit stuff in-place:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5e38df5e-85ee-408c-92a8-55d8cd60fb35.png" style=""/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">A screenshot of our in-place editor in action, showing the save and cancel buttons</div>
<p>To build our in-place editor, we're going to use the contenteditable API that will enable a user to modify the content within HTML elements directly.</p>
<p>The following example illustrates how we can use the <kbd>contenteditable</kbd> attribute to make HTML elements editable:</p>
<pre>&lt;h1 contenteditable&gt;I'm an editable title&lt;/h1&gt; 
&lt;p&gt;I can't be edited&lt;/p&gt; </pre>
<p>Run the preceding example on a blank HTML page and click on the <kbd>h1</kbd> text. You will see that the element has become editable and you can type to modify its content.</p>
<p>Getting notified about changes within editable elements is relatively easy. There's an input event emitted on every DOM element that is editable, and this will allow us to react to change easily:</p>
<pre>const h1 = document.querySelector('h1'); 
h1.addEventListener('input', event =&gt; console.log(h1.textContent); </pre>
<p>With this example, we have already created a naive implementation of an in-place editor where we're able to monitor changes applied by the user. Within this topic, we'll use this standard technology to build a reusable component that we can use wherever we want to make things editable.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating an editor component</h1>
                </header>
            
            <article>
                
<p>First, let's create a new stub component for our editor using the Angular CLI:</p>
<pre><strong>ng generate component --spec false -ve none -cd onpush ui/editor/editor</strong></pre>
<p>After the files have been generated, so let's open up the component class located in <kbd>src/ui/editor/editor.component.ts</kbd> and apply the following code changes:</p>
<pre>import {<br/>  AfterViewInit, ChangeDetectionStrategy, Component, ElementRef, EventEmitter, HostBinding, HostListener, <br/>  Input, OnChanges, Output, SimpleChanges, ViewChild, ViewEncapsulation<br/>} from '@angular/core';<br/><br/>@Component({<br/>  selector: 'mac-editor',<br/>  templateUrl: './editor.component.html',<br/>  styleUrls: ['./editor.component.css'],<br/>  encapsulation: ViewEncapsulation.None,<br/>  changeDetection: ChangeDetectionStrategy.OnPush<br/>})<br/>export class EditorComponent implements OnChanges, AfterViewInit {<br/>  @ViewChild('editableContentElement') editableContentElement: ElementRef;<br/>  @HostBinding('class.edit-mode') editMode = false;<br/>  @Input() content: string;<br/>  @Input() showControls: boolean;<br/>  @Output() outSaveEdit = new EventEmitter&lt;string&gt;();<br/>  @Output() outCancelEdit = new EventEmitter&lt;never&gt;();<br/><br/>  ngOnChanges(changes: SimpleChanges) {<br/>    if (changes.content &amp;&amp; this.editableContentElement) {<br/>      this.setEditableContent(this.content);<br/>    }<br/>  }<br/><br/>  ngAfterViewInit() {<br/>    this.setEditableContent(this.content);<br/>  }<br/><br/>  @HostListener('click')<br/>  focusEditableContent() {<br/>    if (this.editMode) {<br/>      this.editableContentElement.nativeElement.focus();<br/>    }<br/>  }<br/><br/>  saveEdit() {<br/>    this.editMode = false;<br/>    this.outSaveEdit.emit(this.getEditableContent());<br/>  }<br/><br/>  cancelEdit() {<br/>    this.editMode = false;<br/>    this.setEditableContent(this.content);<br/>    this.outCancelEdit.emit();<br/>  }<br/><br/>  beginEdit() {<br/>    this.editMode = true;<br/>  }<br/><br/>  private getEditableContent() {<br/>    return this.editableContentElement.nativeElement.textContent;<br/>  }<br/><br/>  private setEditableContent(content: string) {<br/>    this.editableContentElement.nativeElement.textContent = content;<br/>  }<br/>}<br/> </pre>
<p>Okay, that's quite a lot of new code. Let's dissect the different parts of the editor component and go through each part step by step.</p>
<p>Within our editor component, we'll need to interact with the native DOM element, which we make editable using the contenteditable API. The easiest and also the safest method to do this is to use the <kbd>@ViewChild</kbd> decorator to retrieve a DOM element by using local view references:</p>
<pre>@ViewChild('editableContentElement') editableContentElement: ElementRef; </pre>
<p>The <kbd>@ViewChild</kbd> decorator can be used to search our component view for a specific DOM element or a component instance. When we'd like to search our view for a particular component instance, we can just pass the component class as a parameter to the decorator. When searching for a DOM element, we need to pass a string that should match a local view reference on one of the elements within our component view. Angular returns a type called <kbd>ElementRef</kbd> when we're searching our view for DOM elements. This object is just a wrapper around native DOM elements, which you can then use to access the DOM element.</p>
<p>If we want to search the component subtree for one single DOM element or component instance, we can use the <kbd>@ViewChild</kbd> decorator. We can also search for a list of DOM elements or component instances using the <kbd>@ViewChildren</kbd> decorator:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Query decorator</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>@ViewChildren</kbd> (selector)</p>
</td>
<td>
<p>Will query the current component's view for either directives or components and return an object of the type <kbd>QueryList</kbd>. If the view is dynamically updated, the list will be updated as well.</p>
<p>When the selector parameter is a directive or component type, the query decorator will search our component view for matching directives or components and return a list of directive or component instances.</p>
<p>The selector parameter can also be a string that is then used as a local view reference name to find DOM elements containing this local view reference.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>@ViewChild</kbd> (selector)</p>
</td>
<td>
<p>Will query for only the first matching component or directive instance or a DOM element containing the specific local view reference.</p>
</td>
</tr>
</tbody>
</table>
<p>If you need to communicate with view child components directly, you can use the <kbd>@ViewChild</kbd> and <kbd>@ViewChildren</kbd> decorators to get hold of those components. Sometimes, this is required, but this technique should be used carefully. Direct component communication only makes sense when you have requirements that can not be fulfilled by using component input and output.</p>
<div class="packt_tip"><span>Sometimes, you need to run some initialization code on view children after your component is initialized. In such cases, you can use the </span><kbd>AfterViewInit</kbd><span> </span>life cycle<span> hook. While the view child properties of your component class will still be undefined within the constructor of your component, they will be populated and initialized after the </span><kbd>AfterViewInit</kbd><span> </span>life cycle<span> callback.</span></div>
<p>Let's move back to our editor component code. The next thing we're going to look at is another property in our editor component called <kbd>editMode</kbd>:</p>
<pre>@HostBinding('class.edit-mode') editMode = false;</pre>
<p><span>Our editor is functioning in two modes. The </span><kbd>editMode</kbd><span> property is used inside of our component to determine if the editor is in edit mode or display mode. The default mode of the editor component is the display mode. A user can then switch an editor to edit mode, where he/she will be able to edit the content within the editor. After he/she's done editing, he/she can save or discharge the changes. This action will also switch the component back into display mode (where <kbd>editorMode</kbd> is false again).</span></p>
<p>We are using the <kbd>@HostBinding</kbd> decorator to set the CSS class <kbd>edit-mode</kbd> on the component host element conditionally. This state class will help us to style our component differently, depending on the editor mode.</p>
<p>Next, let's take a look at the input properties of our component:</p>
<pre>@Input() content: string;<br/>@Input() showControls: boolean;</pre>
<p>The <kbd>content</kbd> input property can be used to set the content of our editor from <span>the </span>parent components. This input is required to set the initial content that appears when our editor is in display mode.</p>
<p>The second input property, <kbd>showControls</kbd>, controls whether the editor should show the control functions. When this input is annoying to false, the editor does not show any controls and therefore acts in read-only mode. Three UI controls will be shown in our editor when this property is set to true:</p>
<ul>
<li><strong>Edit button</strong>: If the editor is in display mode, the edit button is the only visible control on the editor. When a user clicks this button, the editor component will switch into edit mode by setting <kbd>editMode</kbd> to true.</li>
<li><strong>Save button</strong>: This control will only be shown if the component is in edit mode. It's there to save any changes performed by the user and switch the component back to display mode.</li>
<li><strong>Cancel button</strong>: This control is shown along with the save button when the component is in edit mode. If activated, the component will switch back to display mode, reverting any changes that were typed into the editor by the user.</li>
</ul>
<p>Besides our input properties, we also need some output properties to notify the outer world about the changes within our editor. Let's quickly discuss the two output properties we're exposing on our component:</p>
<pre>@Output() outSaveEdit = new EventEmitter&lt;string&gt;();<br/>@Output() outCancelEdit = new EventEmitter&lt;never&gt;();</pre>
<p>The <kbd>outSaveEdit</kbd> output is emitting the updated content once the user applies any changes to the editor content and has clicked the save button.</p>
<p>Our editor component works in a simple way. If the component is in edit mode, it shows an element that can be edited using the contenteditable API. However, once the editor switches back to display mode, we see a different element that cannot be edited. CSS controls the visibility within the modifier class, which is set by the host element property binding to the <kbd>editMode</kbd> flag.</p>
<p>Angular has no control over the content within our editable element. We control this content manually by using native DOM operations. Let's look at how we do this:</p>
<pre>private getEditableContent() {<br/>  return this.editableContentElement.nativeElement.textContent;<br/>}<br/><br/>private setEditableContent(content: string) {<br/>  this.editableContentElement.nativeElement.textContent = content;<br/>}</pre>
<p>These two private methods can be used inside of our editor component to obtain the content of our editable DOM element or to set its content, respectively.</p>
<p>We've already discussed the <kbd>editableContentElement</kbd> property of our editor component and how we obtain a reference to the editable element within our component view using the <kbd>@ViewChild</kbd> decorator.</p>
<p>Angular does not directly provide us with a DOM element reference but a wrapper object of the type <kbd>ElementRef</kbd>. It's a wrapper around the native DOM element, which holds additional information that is relevant to Angular. Using the <kbd>nativeElement</kbd> property, we can obtain a reference to the underlying native DOM element.</p>
<div class="packt_infobox"><span>The </span><kbd>ElementRef</kbd><span> wrapper plays an integral part in Angular's platform-agnostic architecture. It allows you to run Angular in different environments (for example, on a server, native mobile, web workers, or others). It's part of an abstraction layer between the components and their views.</span></div>
<p>Let's see how we set editable content within our component view using the <kbd>setEditableContent</kbd> method. First, we want to make sure that when our view is ready, we are initializing the editable content with the text present in our <kbd>content</kbd> component input. For this, we can use the <kbd>AfterViewInit</kbd> life cycle hook. We also needed a way to react to changes to the <kbd>content</kbd> input property, and update the editable content element based on that. We can use the life cycle hook <kbd>OnChanges</kbd> for this purpose:</p>
<pre>ngOnChanges(changes: SimpleChanges) {<br/>  if (changes.content &amp;&amp; this.editableContentElement) {<br/>    this.setEditableContent(this.content);<br/>  }<br/>}<br/><br/>ngAfterViewInit() {<br/>  this.setEditableContent(this.content);<br/>}</pre>
<p>Within the <kbd>ngOnChanges</kbd> callback, once a change in the content input property is detected, we can reflect the changed content onto our editable element. It's important to check whether the <kbd>editableContentElement</kbd> input is already set before we call <kbd>setEditableContent</kbd>. Since the <kbd>OnChanges</kbd> life cycle hook is called before the <kbd>AfterViewInit</kbd> life cycle, the <kbd>editableContentElement</kbd> obtained by our <kbd>@ViewChild</kbd> query will not be available yet. Because of that, we also need to use<span> the <kbd>ngAfterViewInit</kbd> callback to set the initial content of our editable element once our component view has initialized.</span></p>
<p>Okay, so far, we've looked at how we can reflect the content input of our component into the editable element within the view of the editor component. Now, let's take a look at the implementation of the three user actions within the editor. These are the three actions for the edit, save, and cancel buttons:</p>
<pre>saveEdit() {<br/>  this.editMode = false;<br/>  this.outSaveEdit.emit(this.getEditableContent());<br/>}<br/><br/>cancelEdit() {<br/>  this.editMode = false;<br/>  this.setEditableContent(this.content);<br/>  this.outCancelEdit.emit();<br/>}<br/><br/>beginEdit() {<br/>  this.editMode = true;<br/>}</pre>
<p>When our editor is in display mode, a user can only activate edit mode. We are taking care of that using the <kbd>beginEdit</kbd> method. If a user clicks the edit button on our editor component, the only thing we need to do is switch our editor into edit mode. We can do that by merely setting the <kbd>editMode</kbd> property to <kbd>true</kbd>.</p>
<p>Whatever we've discussed thus far concerning the code is good enough for us to set up a fully functional component. However, the last part of the code, which we haven't discussed yet, relates to ensuring better accessibility of our editor. Since our editor component is a bit larger than the editable element, we also want to make sure that a click anywhere inside the editor component will cause the editable element to be focused. The following code makes this happen:</p>
<pre>@HostListener('click')<br/>focusEditableContent() {<br/>  if (this.editMode) {<br/>    this.editableContentElement.nativeElement.focus();<br/>  }<br/>}</pre>
<p>Using the <kbd>@HostListener</kbd> decorator, we are registering an event binding on our component host element that calls the <kbd>focusEditableContent</kbd> method. Inside this method, we are using the reference to the editable DOM element and triggering a focus.</p>
<p>That was the last missing piece of code to discuss within our component class. Let's look at the template of our component, which is located within the <kbd>src/app/ui/editor/editor.component.html</kbd> file, to see how the code we've just created in our component class is related to the component view:</p>
<pre>&lt;div #editableContentElement<br/>     class="editable-content"<br/>     contenteditable="true"&gt;&lt;/div&gt;<br/>&lt;div class="output"&gt;{{content || '-'}}&lt;/div&gt;<br/>&lt;div *ngIf="showControls &amp;&amp; !editMode"<br/>     class="controls"&gt;<br/>  &lt;button (click)="beginEdit()" class="icon-edit"&gt;&lt;/button&gt;<br/>&lt;/div&gt;<br/>&lt;div *ngIf="showControls &amp;&amp; editMode"<br/>     class="controls"&gt;<br/>  &lt;button (click)="saveEdit()" class="icon-save"&gt;&lt;/button&gt;<br/>  &lt;button (click)="cancelEdit()" class="icon-cancel"&gt;&lt;/button&gt;<br/>&lt;/div&gt;</pre>
<p>The logic within the editor component template is quite straightforward. If you've been following the component code, you'll now be able to identify the different elements that compose this component's view.</p>
<p>The first element within the CSS class, <kbd>editable-content</kbd>, is our editable element that has the <kbd>contenteditable</kbd> attribute. The user will be able to type into this element when the editor is in edit mode. It's important to note that we've annotated it with a local view reference, <kbd>#editableContentElement</kbd>, which we're using in our view child queries.</p>
<p>The second element within the CSS class, <kbd>output</kbd>, is only to display the editor content and is only visible when the editor is in display mode. The visibility of both the elements is controlled using CSS, based on the <kbd>edit-mode</kbd> modifier class, which, if you recall from the component class code, is set through host property binding based on the <kbd>editMode</kbd> property.</p>
<p>The three control buttons are shown conditionally using the <kbd>NgIf</kbd> directive. The <kbd>showControls</kbd> input property needs to be <kbd>true</kbd>, and depending on the <kbd>editMode</kbd> flag, the view will either show the edit button or the save and the cancel buttons.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Integrating the editor component</h1>
                </header>
            
            <article>
                
<p>Now, it's time to incorporate the editor component we've just created within our current project. We will use the editor component to make three areas in our application editable in-place:</p>
<ul>
<li>The titles of tasks within our task list</li>
<li>The title of projects</li>
<li>The description of projects</li>
</ul>
<p>Let's start by integrating our in-place editor component into our task list component and making the titles of our tasks editable. Open up the file located in <kbd>src/app/tasks/task/task.component.html</kbd> and apply the following changes:</p>
<pre>&lt;mac-checkbox [checked]="task.done"<br/>              (outCheck)="updateTask($event)"&gt;&lt;/mac-checkbox&gt;<br/>&lt;div class="title"&gt;<br/><strong>  &lt;mac-editor [content]="task.title"</strong><br/><strong>              [showControls]="true"</strong><br/><strong>              (outSaveEdit)="updateTitle($event)"&gt;&lt;/mac-editor&gt;</strong><br/>&lt;/div&gt;</pre>
<p>Instead of just rendering the task title directly, we will now use our editor component to render the task title. We're binding the task title onto the <kbd>content</kbd> input property of our editor and calling a new method called <kbd>updateTitle</kbd> when the editor is emitting a <kbd>outSaveEdit</kbd> output. The <kbd>showControls</kbd> input property needs to be set to <kbd>true</kbd>, otherwise the editor will always stay in read-only mode.</p>
<p>Let's add the new <kbd>updateTitle</kbd> method in the task component class located in <kbd>src/app/tasks/task/task.component.ts</kbd>. The following code excerpt shows the added method in bold; unchanged code parts are hidden using the ellipsis character:</p>
<pre>…<br/>export class TaskComponent {<br/>  …<br/>  <strong>updateTitle(title: string) {</strong><br/><strong>    this.outUpdateTask.emit({</strong><br/><strong>      ...this.task,</strong><br/><strong>      title</strong><br/><strong>    });</strong><br/><strong>  }</strong><br/>}</pre>
<p>The <kbd>updateTitle</kbd> method is very similar to the already present <kbd>updateTask</kbd> method. The difference is that we're emitting an updated task model which contains the updated title from out editor component. The <kbd>updateTask</kbd> method is emitting an updated task model where the done flag was updated.</p>
<p>The fact that we can re-use the <kbd>outUpdateTask</kbd> output makes our change to integrate the editor component very simple. To help you recall the data flow that is now happening within our component tree, let's look at all the different pieces involved once again:</p>
<ol>
<li>A user clicks the edit button within the editor component inside a task component</li>
<li>After editing and clicking the save button, an <kbd>outSaveEdit</kbd> output with the updated title is emitted from the editor and our <kbd>updateTitle</kbd> method is called</li>
<li>The <kbd>updateTitle</kbd> method is emitting a new task object containing the updated title using the <kbd>outUpdateTask</kbd> output</li>
<li>The task list component is delegating the <kbd>outUpdateTask</kbd> output to its parent using an output with the same name.</li>
<li>The task list container component is catching the updated task and calls the <kbd>updateTask</kbd> method on our task list service</li>
<li>After the service has updated the data in our in-memory web API database, the updated task list will be passed down the component tree again until the task we've just updated arrives at the specific task component again, where it will also update the <kbd>content</kbd> input of our editor</li>
</ol>
<p>Once again, our reactive and unidirectional data flow pays off when it comes to state architecture. With minimal changes, we've added a new feature to make our task titles editable in-place. Also, the way our data flows has not increased in complexity by implementing this change.</p>
<p>Let's apply similar changes to make our project title and description editable. Let's start by implementing changes to the template of our project component located in <kbd>src/app/project/project/project.component.html</kbd>. Again, changes are in bold and unchanged parts are hidden using the ellipsis character:</p>
<pre>&lt;header class="header"&gt;<br/>  &lt;h2 class="title"&gt;<br/>  <strong>  &lt;mac-editor [content]="project.title"</strong><br/><strong>                [showControls]="true"</strong><br/><strong>                (outSaveEdit)="updateTitle($event)"&gt;&lt;/mac-editor&gt;</strong><br/>  &lt;/h2&gt;<br/><strong>  &lt;mac-editor [content]="project.description"</strong><br/><strong>              [showControls]="true"</strong><br/><strong>              (outSaveEdit)="updateDescription($event)"&gt;&lt;/mac-editor&gt;</strong><br/>&lt;/header&gt;<br/>…</pre>
<p>This time, we're using two editors, one for our project title and one for the description. The rest of the changes are very similar to the changes we've applied to our task component. We're using two new methods called <kbd>updateTitle</kbd> and <kbd>updateDescription</kbd>, which we now need to add in the project component class located in <kbd>src/app/project/project/project.component.ts</kbd>:</p>
<pre>…<br/>export class ProjectComponent {<br/>  …<br/>  <strong>@Output() outUpdateProject = new EventEmitter&lt;Project&gt;();</strong><br/><br/>  activateTab(tab: Tab) {<br/>    this.outActivateTab.emit(tab);<br/>  }<br/><br/>  <strong>updateTitle(title: string) {</strong><br/><strong>    this.outUpdateProject.emit({</strong><br/><strong>      ...this.project,</strong><br/><strong>      title</strong><br/><strong>    });</strong><br/><strong>  }</strong><br/><br/><strong>  updateDescription(description: string) {</strong><br/><strong>    this.outUpdateProject.emit({</strong><br/><strong>      ...this.project,</strong><br/><strong>      description</strong><br/><strong>    });</strong><br/><strong>  }</strong><br/>}</pre>
<p>Since we did not have anything to update in our project component as of yet, we first need to add a new output called <kbd>outUpdateProject</kbd> to notify our parent component about an updated project. The two methods <kbd>updateTitle</kbd> and <kbd>updateDescription</kbd> are both emitting an updated version of the project data using the updated information.</p>
<p>Now, we need to update our project container component to handle the newly introduced project updates. Let's start by changing the view template located in <kbd>src/app/container/project-container/project-container.component.html</kbd>:</p>
<pre>&lt;mac-project [project]="selectedProject | async"<br/>             [tabs]="tabs"<br/>             [activeTab]="activeTab"<br/>             (outActivateTab)="activateTab($event)"<br/>             <strong>(outUpdateProject)="updateProject($event)"</strong>&gt;<br/>&lt;/mac-project&gt;</pre>
<p>We're handing the new <kbd>outUpdateProject</kbd> output of our project component and calling a new method called <kbd>updateProject</kbd>. Let's look at the implementation of this method in the project container component class located in <span><kbd>src/app/container/project-container/project-container.component.ts</kbd>:</span></p>
<pre>…<br/>export class ProjectContainerComponent {<br/>  …<br/>  <strong>updateProject(project: Project) {</strong><br/><strong>    this.projectService.updateProject(project);</strong><br/><strong>  }</strong><br/>}</pre>
<p class="packt_figure">Within the newly added method, we're calling the <kbd>updateProject</kbd> method on the project service and passing the project object that was initially emitted by the project UI component.</p>
<p>Finally, let's implement the <kbd>updateProject</kbd> method within our project service to update project data using the Angular HTTP service. Let's open the <kbd>src/app/project/project.service.ts</kbd> file and apply the following changes:</p>
<pre>…<br/>export class ProjectService {<br/>  …<br/>  <strong>updateProject(project: Project) {</strong><br/><strong>    this.http.post(`/api/projects/${project.id}`, project)</strong><br/><strong>      .subscribe(() =&gt; this.loadProjects());</strong><br/><strong>  }</strong><br/>}</pre>
<p>Nothing new here. We're using the Angular HTTP service to execute a post request to the in-memory web API. After a successful call, we're calling the <kbd>loadProjects</kbd> method on our service, which will emit an updated project list using the <kbd>projects</kbd> behavior subject. This will cause all of our reactive subscriptions to receive the updated list of projects and update accordingly.</p>
<p>Congratulations! You've successfully created and integrated our editor component to make project titles, descriptions, and task titles editable. Now is a great time to preview your changes in the browser and play around with the editing capabilities we've added using the editor component. Using an in-place editor, we've simplified the authoring process within our application for our users. Also, by using a reactive data architecture, the editing feels very responsive and intuitive.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Recap</h1>
                </header>
            
            <article>
                
<p>Within this building block, we have created an in-place editor component, which we can use to make things editable for any content within our application. It allows us to provide the user with contextual editing capabilities, which will result in a fantastic overall user experience.</p>
<p>We have also learned about the following topics:</p>
<ul>
<li>Using the <kbd>contenteditable</kbd> HTML5 attribute to enable in-place editing</li>
<li>Using <kbd>@ViewChild</kbd> and <kbd>@ViewChildren</kbd> to query view child elements</li>
<li>Using the <kbd>ElementRef</kbd> dependency to perform native DOM operations</li>
<li>Implementing the logic, using the <kbd>OnChange</kbd> as well as the <kbd>AfterViewInit</kbd> life cycle hooks, to reflect data between Angular and content that is not in immediate control of Angular</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dealing with users</h1>
                </header>
            
            <article>
                
<p>Going forward, we'll start dealing with user-generated content within our application and therefore require a minimal setup <span>that </span>allows us to deal with users correctly. We're creating a model to represent users as well as a simple user service <span>that </span>will tell us about the currently logged in user. Our service will just act as a mock user service and concerns like registration, login, and authentication are not within the scope of this book.</p>
<p>Let's stick to the practice we've established within this book and start by introducing the model for our users. Let's open the <kbd>src/app/model.ts</kbd> file and add the following interface at the end of the file:</p>
<pre>export interface User {<br/>  readonly id?: number;<br/>  readonly name: string;<br/>  readonly pictureUrl: string;<br/>}</pre>
<p>Let's keep this as minimal as possible. Our users will consist of only an ID, name, and a URL to a profile picture. As a next step, let's add a new users resource to our in-memory web API database. Open up the <kbd>src/app/database.ts</kbd> file and apply the following changes. Updated content is marked in bold while the ellipsis character indicates unchanged, hidden parts of the code:</p>
<pre>import {InMemoryDbService} from 'angular-in-memory-web-api';<br/>import {Project, Task<strong>, User</strong>} from './model';<br/><br/>export class Database implements InMemoryDbService {<br/>  createDb() {<br/>    <strong>const users: User[] = [</strong><br/><strong>      {id: 1, name: 'You', pictureUrl: '/assets/user.svg'}</strong><br/><strong>    ];</strong><br/><br/>    …<br/><br/>    return {<strong>users,</strong> projects, tasks};<br/>  }<br/>}</pre>
<p>We've used our newly created user model to add a new users resource to the in-memory database. Currently, we'll only store one user within the users resource.</p>
<p>You can see from the <kbd>pictureUrl</kbd> inside of the added user object that we're referencing a path called <kbd>/assets/user.svg</kbd>. You can download this resource from this book's online resource repository. Please find the exact download link in the Download section of <a href="">Chapter 13</a>, <em>Task Management Application Source Code</em>.</p>
<p>You can also choose your personal profile picture instead of the generic profile picture that is available in the book resources. Either way, after preparing the image, you need to store it on the path <kbd>src/assets/</kbd> and set the filename to match what is specified in our user object within the in-memory database.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">User service</h1>
                </header>
            
            <article>
                
<p>Alright, we've prepared our model and database for handling users within our application. Now, we can create a new service <span>that </span>we are using in our container components to obtain the currently logged in user. Let's create a user service using the Angular CLI:</p>
<pre><strong>ng generate service --spec false user/user</strong></pre>
<p>Let's open the stub service generated on the <kbd> src/app/user/user.service.ts</kbd> path and replace its content with the following code:</p>
<pre>import {Injectable} from '@angular/core';<br/>import {HttpClient} from '@angular/common/http';<br/>import {User} from '../model';<br/><br/>@Injectable()<br/>export class UserService {<br/>  constructor(private http: HttpClient) {<br/><br/>  }<br/><br/>  getCurrentUser() {<br/>    return this.http.get&lt;User&gt;('/api/users/1');<br/>  }<br/>}</pre>
<p>We're keeping things simple here. The only method we're providing from our service is the <kbd>getCurrentUser</kbd> method, which will execute a call to our in-memory web API and return the first user in the users resource.</p>
<p>That's already everything for our user service. Next up, we're going to create two simple UI components to display the logged in user within our application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">User area component</h1>
                </header>
            
            <article>
                
<p>We've already created the data structures required to represent users within our application. We'll now make use of this to create a user area <span>that </span>shows the user profile of the currently logged in user. The user area will be placed above the main navigation within the left-hand side area in our application layout:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e786b6fe-c402-4b8b-8f96-94c0fcdfa639.png" style=""/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">The user area component will be positioned above our main navigation</div>
<p>First of all, we will be creating a reusable component to render user profile pictures. Let's use the Angular CLI to generate the stub of our profile picture component:</p>
<pre><strong>ng generate component --spec false -ve none -cd onpush user/profile-picture/profile-picture</strong></pre>
<p>Alright, let's open the component class file located in <kbd>src/app/user/profile-picture/profile-picture.component.ts</kbd> and change its content to the following code:</p>
<pre>import {<br/>  Component, ViewEncapsulation, ChangeDetectionStrategy, Input, SimpleChanges,<br/>  OnChanges<br/>} from '@angular/core';<br/>import {User} from '../../model';<br/>import {DomSanitizer, SafeResourceUrl} from '@angular/platform-browser';<br/><br/>@Component({<br/>  selector: 'mac-profile-picture',<br/>  templateUrl: './profile-picture.component.html',<br/>  styleUrls: ['./profile-picture.component.css'],<br/>  encapsulation: ViewEncapsulation.None,<br/>  changeDetection: ChangeDetectionStrategy.OnPush<br/>})<br/>export class ProfilePictureComponent implements OnChanges {<br/>  @Input() user: User;<br/>  pictureSafeUrl: SafeResourceUrl;<br/><br/>  constructor(private sanitizer: DomSanitizer) {<br/><br/>  }<br/><br/>  ngOnChanges(changes: SimpleChanges) {<br/>    if (changes.user) {<br/>      this.pictureSafeUrl = this.sanitizer<br/>        .bypassSecurityTrustResourceUrl(this.user.pictureUrl);<br/>    }<br/>  }</pre>
<p>Our profile picture component has one straightforward responsibility: to render the profile picture of a user. It accepts an input <kbd>user</kbd> of our model type <kbd>User</kbd>.</p>
<p>The Angular framework is concerned about security, and when we are rendering security relevant HTML, we need to tell Angular that this specific operation should be considered as trusted. In our case, we will render the image source attribute to display user profile pictures dynamically using Angular. Image source attributes are considered vulnerable because they execute get requests, can contain user-generated content, and therefore could also contain some attack vectors.</p>
<p><span>When we're using plain string URLs within HTML resource elements, like image, script, or link elements, Angular will raise an error. </span>If we want to render an expression to an image source attribute within an Angular template, we need to use Angular's DOM sanitizer to create a trusted URL first.</p>
<p>Let's look at the different use cases for using the Angular <kbd>DomSanitizer</kbd> to mark vulnerable resources as trusted:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td><strong>Use-case</strong></td>
<td><strong>Component class</strong></td>
<td><strong>Template usage</strong></td>
</tr>
<tr>
<td>Render HTML</td>
<td>
<pre class="mce-root">safeHtml: SafeHtml = <br/>  bypassSecurityTrustHtml(<br/>    '&lt;strong&gt;Important&lt;/strong&gt;'<br/>  );</pre></td>
<td>
<pre>&lt;div [innerHtml]="safeHtml"&gt;<br/>&lt;/div&gt;</pre></td>
</tr>
<tr>
<td>Render Styles</td>
<td>
<pre class="mce-root">safeStyle: SafeStyle = <br/>  bypassSecurityTrustStyle(<br/>    'url(/assets/image.jpg)'<br/>  );</pre></td>
<td>
<pre>&lt;div [style.background]="safeStyle"&gt;<br/>&lt;/div&gt;</pre></td>
</tr>
<tr>
<td>Render links</td>
<td>
<pre class="mce-root">safeUrl: SafeUrl = <br/>  bypassSecurityTrustUrl(<br/>    'https://google.com'<br/>  );</pre></td>
<td>
<pre>&lt;a [href]="safeUrl"&gt;Google&lt;/a&gt;</pre></td>
</tr>
<tr>
<td>Resources</td>
<td>
<pre class="mce-root">safeUrl: SafeResourceUrl = <br/>  bypassSecurityTrustResourceUrl(<br/>    '/assets/image.jpg'<br/>  );</pre></td>
<td>
<pre>&lt;img [attr.src]="safeUrl" src=""&gt;</pre></td>
</tr>
</tbody>
</table>
<div class="packt_infobox">Note that bypassing security is not always a good solution. If you're rendering user-generated content <span>that </span>could contain attack vectors, you should consider sanitizing this content. The <kbd>DomSanitizer</kbd> of Angular provides a <kbd>sanitize</kbd> method <span>that </span>allows you to sanitize content for different contexts. It will strip out and escape security relevant parts of the content and return a sanitized version of it.</div>
<p><span>Inside of our profile picture component class, we are using the DOM sanitizer to create a trusted resource URL that we can then use within our template. We're sanitizing the user profile picture URL inside of the </span><kbd>OnChanges</kbd><span> life cycle hook. This way, if we're changing the user input, the trusted resource URL will also be updated.</span></p>
<p>Let's open the template of our profile picture component located in <kbd>src/app/user/profile-picture/profile-picture.component.html</kbd> and replace the content with the following code:</p>
<pre>&lt;img [attr.src]="pictureSafeUrl" src=""&gt;</pre>
<p><span>This is all we need in our profile picture component template. We can now use the trusted picture URL inside the <kbd>src</kbd> attribute, binding on an image element.</span></p>
<p>Alright, let's move on to the main component we'd like to create for our user area within the left-hand side area of our application layout. We're using Angular CLI again to create the stub of our user area component:</p>
<pre><strong>ng generate component --spec false -ve none -cd onpush user/user-area/user-area</strong></pre>
<p>Let's jump right into the component class file located in <kbd>src/app/user/user-area/user-area.component.ts</kbd> and replace the content with the following code:</p>
<pre>import {Component, ViewEncapsulation, ChangeDetectionStrategy, Input} from '@angular/core';<br/>import {User} from '../../model';<br/><br/>@Component({<br/>  selector: 'mac-user-area',<br/>  templateUrl: './user-area.component.html',<br/>  encapsulation: ViewEncapsulation.None,<br/>  changeDetection: ChangeDetectionStrategy.OnPush<br/>})<br/>export class UserAreaComponent {<br/>  @Input() user: User;<br/>  @Input() openTasksCount: number;<br/>}</pre>
<p>Nothing special here. The user area component accepts a <kbd>user</kbd> input to render the profile information of a specific user. Also, we're adding an <kbd>openTasksCount</kbd> input to the component. This will be used to show a message about how many open tasks currently exist overall in the projects within the application.</p>
<p>Let's modify the user area component template located in <kbd>src/app/user/user-area/user-area.component.html</kbd> and replace the content with the following code:</p>
<pre>&lt;div class="profile"&gt;<br/>  &lt;mac-profile-picture [user]="user"&gt;&lt;/mac-profile-picture&gt;<br/>&lt;/div&gt;<br/>&lt;div class="information"&gt;<br/>  &lt;p class="welcome-text"&gt;Hi {{user.name}}!&lt;/p&gt;<br/>  &lt;p *ngIf="openTasksCount !== 0"&gt;You got &lt;strong&gt;{{openTasksCount}}&lt;/strong&gt; open tasks.&lt;/p&gt;<br/>  &lt;p *ngIf="openTasksCount === 0"&gt;No open tasks. Hooray!&lt;/p&gt;<br/>&lt;/div&gt;</pre>
<p>First, we're rendering the users' profile picture by using our newly created profile picture component. We're just forwarding the user object <span>that </span>we provided as an input to our user area component down to the profile picture component.</p>
<p>Inside of the information container DIV element, we're rendering a welcome message for our user as well as a message to show the number of open tasks.</p>
<p>That wasn't too complicated. We've just created two UI components for our user feature. The user area UI component is rendering a section within the side area of our primary layout to show some profile information about the currently logged in user. We've also built a reusable profile picture component, which is rendering a user's profile image based on a user object.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Integrating the user area component</h1>
                </header>
            
            <article>
                
<p>Now, it's time to incorporate our user component into our main layout. For this, we're going to modify our root application component, which is acting as our outermost container component.</p>
<p>Let's open the component class of our app component located in <kbd>src/app/app.component.ts</kbd> and apply the following changes:</p>
<pre>…<br/><strong>import {map} from 'rxjs/operators';</strong><br/><strong>import {UserService} from './user/user.service';</strong><br/>import {Project, Task<strong>, User</strong>} from './model';<br/>…<br/>export class AppComponent {<br/><strong>  openTasksCount: Observable&lt;number&gt;;</strong><br/><strong>  user: Observable&lt;User&gt;;</strong><br/>  projects: Observable&lt;Project[]&gt;;<br/>  selectedProject: Observable&lt;Project&gt;;<br/><br/>  constructor(taskListService: TaskService,<br/><strong>              userService: UserService,</strong><br/>              private projectService: ProjectService) {<br/><strong>    this.openTasksCount = taskListService.getTasks()</strong><br/><strong>      .pipe(</strong><br/><strong>        map((tasks: Task[]) =&gt; {</strong><br/><strong>          return tasks</strong><br/><strong>            .filter((task) =&gt; !task.done)</strong><br/><strong>            .length;</strong><br/><strong>        })</strong><br/><strong>      );</strong><br/>    this.projects = projectService.getProjects();<br/>    this.selectedProject = this.projectService.getSelectedProject();<br/><strong>    this.user = userService.getCurrentUser();</strong><br/>  }<br/><br/>  selectProject(id: number) {<br/>    this.projectService.selectProject(id);<br/>  }<br/>}</pre>
<p>We've introduced two new observables within our app component.</p>
<p>The <kbd>openTasksCount</kbd> observable is based on the task list observable we obtain by calling <kbd>getTasks</kbd> on our task list service. The task list observable is emitting the most recent list of all tasks within our application. Based on that, we're using the RxJS map operator to map the list of tasks as input to the count of open tasks as output. This results in an observable stream <span>that </span>always emits the most recent number of open tasks within our application.</p>
<p>The second observable, <kbd>user</kbd>, is obtained merely by calling the <kbd>getCurrentUser</kbd> method on our recently created user service.</p>
<p>Let's take a look at the changes within our app component template. Open the <kbd>src/app/app.component.html</kbd> file and apply the following changes. Effective changes are highlighted in bold while some unchanged code parts are hidden using the ellipsis character. Make sure that you only update the highlighted parts of your code:</p>
<pre>&lt;aside class="side-nav"&gt;<br/>  <strong>&lt;mac-user-area [user]="user | async"</strong><br/><strong>                 [openTasksCount]="openTasksCount | async"&gt;</strong><br/><strong>  &lt;/mac-user-area&gt;</strong><br/>  …<br/>&lt;/aside&gt;<br/>…</pre>
<p>We're rendering a user area component and passing the required inputs by subscribing to our observables directly in the view using the <kbd>async</kbd> pipe. Now, as soon as the logged in user or the amount of open tasks changes, our user area component will receive the updated values as input.</p>
<p>Well done! You've successfully created a user area component <span>that </span>you can now preview in your browser. Try to mark tasks as done and watch the user that is being updated based on the overall amount of open tasks.</p>
<p>Our main layout of the application is now complete, and all further enhancements will build on that basic layout.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building a commenting system</h1>
                </header>
            
            <article>
                
<p>In this chapter, we've created our main project components, a reusable editor component, and within the previous topic, we've created and integrated a user area component. Within this topic, we're going to create a commenting system that enables users to write comments on projects. The commenting system will use our editor component to make existing comments editable. We're also using our user feature and the profile picture component to visualize user comments. Based on the authoring user of comments, we will decide if existing comments are editable for the logged in user:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1e4d56bd-64f9-43b4-9b44-54a57d54411c.png" style=""/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">An illustration of the component subtree of our commenting system</div>
<p>The preceding diagram illustrates the architecture of the component tree within the commenting system that we are about to create.</p>
<p>The comments component will be responsible for listing all the existing comments, as well as creating new comments. A comment component represents each comment itself. Comment components use an editor that enables users to edit comments once they are created.</p>
<p>The editor component emits an output called <kbd>outSaveEdit</kbd> once editable content is saved using the control buttons of the editor. In the comment component, we will capture the output and propagate a new output upwards to our comments component. From there, we will delegate the output further to a new project comments container component <span>that </span>we're creating in this topic. The project comments container will be responsible for storing and retrieving comments using the project service.</p>
<p>The comments component will also be responsible for providing the necessary UI logic to create new comments. The creation of further comments will also be communicated to the project comments container using component output. There, we will use the project service to add the newly created comment.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing a model for comments</h1>
                </header>
            
            <article>
                
<p>Before we move on to creating more components within our application, let's first define the model and data we're using to represent comments.</p>
<p>Let's open up our model file located in <kbd>src/app/model.ts</kbd> and apply the following changes:</p>
<pre>…<br/><br/>export interface Project {<br/>  readonly id?: number;<br/>  readonly title: string;<br/>  readonly description: string;<br/>  <strong>readonly comments: Comment[];</strong><br/>}<br/><br/>…<br/><br/><strong>export interface Comment {</strong><br/><strong>  readonly time: number;</strong><br/><strong>  readonly user: User;</strong><br/><strong>  readonly content: string;</strong><br/><strong>}</strong><br/><br/><strong>export interface CommentUpdate {</strong><br/><strong>  readonly index: number;</strong><br/><strong>  readonly comment: Comment;</strong><br/><strong>}<br/></strong></pre>
<p>We've added two new interfaces to represent our comments. The <kbd>Comment</kbd> interface consists of a <kbd>time</kbd> property <span>that </span>holds a number timestamp of the time the comment was created. We also store the user who commented and of course the comment itself using a property named <kbd>content</kbd>.</p>
<p>The <kbd>CommentUpdate</kbd> interface is used for communicating comment updates across components and services.</p>
<p>We've also updated the model of our projects to include an additional field called <kbd>comments</kbd>. That's where all project comments will be stored.</p>
<p>Since we're changing the <kbd>Project</kbd> interface to include a new property called <kbd>comments</kbd>, we also need to make sure our database is updated with this change. Let's open our database located in the <kbd>src/app/database.ts</kbd> file and apply the following changes:</p>
<pre>import {InMemoryDbService} from 'angular-in-memory-web-api';<br/>import {Project, Task, User} from './model';<br/><br/>export class Database implements InMemoryDbService {<br/>  createDb() {<br/>    …<br/><br/>    const projects: Project[] = [<br/>      {id: 1, title: 'My first project', description: 'This is your first project.'<strong>, comments: []</strong>},<br/>      {id: 2, title: 'My second project', description: 'This is your second project.'<strong>, comments: []</strong>}<br/>    ];<br/><br/>    …<br/>  }<br/>}</pre>
<p>The only difference in this file is that we've added the new <kbd>comments</kbd> property on our project objects. For both projects, we're just adding an empty array with no pre-existing comments.</p>
<p>Alright, that's all the changes required in our data and model for now. Let's move on to the creation of our commenting system.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building the comment component</h1>
                </header>
            
            <article>
                
<p>Let's start making our commenting system by fleshing out the comment component first. In addition to the comment itself, we'd like to display the user's profile, who commented, and the time of the comment.</p>
<p>To display the time, we will make use of relative time formatting, as this will give our users a better feel of time. Relative time formatting presents timestamps in the format "5 minutes ago" or "1 month ago", in contrast to absolute timestamps, such<br/>
as "25.12.2015 18:00". Using a famous third-party library called Moment.js, we'll create a view pipe that we can use within component templates to convert timestamps and dates into a relative time format.</p>
<p>View pipes are a great way to enrich the template language of Angular. They allow you to create helper functions <span>that </span>you can then use within the view inside of your component templates. So far, we've only used one view pipe, the <kbd>AsyncPipe</kbd>, which was used to subscribe to observable streams directly inside of the component view. Within this section, we'll create our view pipe, which can be used to format dates using the Moment.js library.</p>
<p>First of all, we need to install Moment.js as a production dependency to our project. Open up a terminal within the root folder of your project and execute the following command:</p>
<pre><strong>npm install --save moment@2.19.3</strong></pre>
<p>After Moment.js is installed, we can go ahead and create our first view pipe. We can also use the Angular CLI to generate the stub code of our pipe for us:</p>
<pre><strong>ng generate pipe --spec false pipes/from-now</strong></pre>
<p>Alright, the Angular CLI should have created a new view pipe for us with the name <kbd>fromNow</kbd>. Let's open the view pipe code located in the <kbd>src/app/pipes/from-now.pipe.ts</kbd> file and change its content to the following code:</p>
<pre>import {Pipe, PipeTransform} from '@angular/core';<br/>import * as moment from 'moment';<br/><br/>@Pipe({<br/>  name: 'fromNow'<br/>})<br/>export class FromNowPipe implements PipeTransform {<br/>  transform(value: any) {<br/>    return moment(value).fromNow();<br/>  }<br/>}</pre>
<p>All view pipes need to be decorated using Angular's <kbd>@Pipe</kbd> decorator. Inside of the configuration object, we can pass this to the decorator factory, and specify the name of the pipe. This name is how we address the view pipe within our component templates.</p>
<p>View pipe classes should always implement an interface called <kbd>PipeTransform</kbd>. This interface will ensure that the mandatory method, <kbd>transform</kbd>, is implemented within our pipe class. The transform method is the central piece of every view pipe. This function will be called when a pipe is used within the view template of a component. Let's look at a basic example of how a view pipe is used inside of a template:</p>
<pre>&lt;div&gt;{{name | toUpperCase}}&lt;/div&gt;</pre>
<p>In this essential case, we're using a view pipe with the name <kbd>toUpperCase</kbd>. Angular will take the value on the left-hand side of the expression and pass it to the <kbd>transform</kbd> method of the <kbd>toUpperCase</kbd> pipe as the first parameter. The value <span>that </span>is returned from the <kbd>transform</kbd> method is then evaluated and rendered into the view. We can also compose multiple view pipes by chaining them after each other:</p>
<pre>&lt;div&gt;{{name | reverse | toUpperCase}}&lt;/div&gt;</pre>
<p>In this example, the name will be passed to the <kbd>transform</kbd> method of the <kbd>reverse</kbd> pipe. The returned value of the <kbd>reverse</kbd> pipe's <kbd>transform</kbd> method will then be passed as the first parameter to the <kbd>transform</kbd> method of the <kbd>toUpperCase</kbd> pipe. Like this, you can chain an indefinite amount of pipes onto each other to transform component properties directly in your component view template.</p>
<div class="packt_infobox">View pipes are treated as stateless by default. Angular uses this assumption to perform some optimizations in the background. If pipes and their <kbd>transform</kbd> methods can be considered stateless and pure, Angular can cache the results of pipe transformations and re-use the cached values later on. This behaviour is okay in most cases, and we don't want to miss out on that performance optimization. However, sometimes it's required to rely on some services or other sources of state to determine the result of a pipe transformation. In such a case, the <kbd>transform</kbd> method of a pipe is not pure, and therefore cannot be cached. To tell Angular that our pipe is not pure, you can use an additional configuration property on pipes called <kbd>pure</kbd>. If you set this property to false, your pipe transformations will not be cached, and Angular will execute your <kbd>transform</kbd> method every time your view is rendered.</div>
<p>Let's use our newly created <kbd>fromNow</kbd> pipe to format the timestamp of comments within our comment component. We're using the Angular CLI again to create the structure for the comment component:</p>
<pre><strong>ng generate component --spec false -ve none -cd onpush comments/comment/comment</strong></pre>
<p>Let's open the component template file located in <kbd>src/app/comments/comment/comment.component.html</kbd> and replace its content with the following code:</p>
<pre>&lt;div class="meta"&gt;<br/>  &lt;div class="user-picture"&gt;<br/>    &lt;mac-profile-picture [user]="comment.user"&gt;&lt;/mac-profile-picture&gt;<br/>  &lt;/div&gt;<br/>  &lt;div class="user-name"&gt;{{comment.user.name}}&lt;/div&gt;<br/>  &lt;div class="time"&gt;<br/>    {{comment.time | fromNow}}<br/>  &lt;/div&gt;<br/>&lt;/div&gt;<br/>&lt;div class="main"&gt;<br/>  &lt;div class="content"&gt;<br/>    &lt;mac-editor [content]="comment.content"<br/>                [showControls]="comment.user.id === user.id"<br/>                (outSaveEdit)="updateComment($event)"&gt;<br/>    &lt;/mac-editor&gt;<br/>  &lt;/div&gt;<br/>&lt;/div&gt;</pre>
<p>We're reusing our profile picture component to render the comment author user. To display the time of the comment in a relative format, we'll use the <kbd>fromNow</kbd> pipe that we created earlier.</p>
<p>Finally, we will make use of the in-place editor component to display the content of the comment and make it editable at the same time. We will bind the comment content property to the <kbd>content</kbd> input property of the editor. At the same time, we will listen for the <kbd>outSaveEdit</kbd> output of the editor and call the <kbd>updateComment</kbd> method on our comment component class.</p>
<p>We're also deciding if the currently logged in user passed into our component as <kbd>user</kbd> input is the authoring user of the given comment and then use this information to either enable or disable the controls on our editor using the <kbd>showControls</kbd> input property. This way, the current user is only allowed to edit a comment if he/she's also the author of that comment.</p>
<p>Let's also create our component class and open the <kbd>src/app/comments/comment/comment.component.ts</kbd> file to replace its content with the following code:</p>
<pre>import {<br/>  Component, ViewEncapsulation, ChangeDetectionStrategy, Input, Output, EventEmitter<br/>} from '@angular/core';<br/>import {Comment, User} from '../../model';<br/><br/>@Component({<br/>  selector: 'mac-comment',<br/>  templateUrl: './comment.component.html',<br/>  styleUrls: ['./comment.component.css'],<br/>  encapsulation: ViewEncapsulation.None,<br/>  changeDetection: ChangeDetectionStrategy.OnPush<br/>})<br/>export class CommentComponent {<br/>  @Input() comment: Comment;<br/>  @Input() user: User;<br/>  @Output() outUpdateComment = new EventEmitter&lt;Comment&gt;();<br/><br/>  updateComment(content: string) {<br/>    this.outUpdateComment.emit({<br/>      ...this.comment,<br/>      content<br/>    });<br/>  }<br/>}</pre>
<p>The component code is pretty straightforward. As input, we expect a user object that is passed along to the <kbd>user</kbd> input property. This property represents the currently logged in user and is used within our template to determine if a user should be able to edit the comment. The <kbd>comment</kbd> input property is expected to be an object of type <kbd>Comment</kbd>. From there, we gather the comment content, the time of creation, and the comment author user.</p>
<p>Going back to the view template of our comment component, we can observe that the <kbd>outSaveEdit</kbd> output on the editor component will call the <kbd>updateComment</kbd> method in our comment component. Inside of the <kbd>updateComment</kbd> method, we're creating a copy of our comment object and updating its content with the editor output. This copy is then emitted using the <kbd>outUpdateComment</kbd> output of the comment component.</p>
<p>That's all we need for our comment component. Next up, we're going to create the comments component, which represents a list of comments and embraces the necessary UI element to create new comments.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building the comments component</h1>
                </header>
            
            <article>
                
<p>The last missing piece of the puzzle for our commenting system is the comments component, which will list all the comments and provide the UI to create new comments:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7960e916-5e1f-4b48-b681-8743f531e4d2.png" style=""/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">The comments component allows users to add comments to projects</div>
<p>Let's use the Angular CLI to create the structure for our comments component:</p>
<pre><strong>ng generate component --spec false -ve none -cd onpush comments/comments/comments</strong></pre>
<p>First, let's edit the template of our comments component located in <kbd>src/app/comments/comments/comments.component.html</kbd>:</p>
<pre>&lt;div class="title"&gt;Add new comment&lt;/div&gt;<br/>&lt;div class="add-comment-section"&gt;<br/>  &lt;div #commentContentEditable<br/>       class="add-comment-box"<br/>       contenteditable="true"&gt;<br/>  &lt;/div&gt;<br/>  &lt;button (click)="createComment()"<br/>          class="button" &gt;Add comment&lt;/button&gt;<br/>&lt;/div&gt;<br/><br/>&lt;ng-container *ngIf="comments.length &gt; 0"&gt;<br/>  &lt;div class="title"&gt;All comments&lt;/div&gt;<br/>  &lt;mac-comment *ngFor="let comment of comments; let index = index"<br/>               [comment]="comment"<br/>               [user]="user"<br/>               (outUpdateComment)="updateComment(index, $event)"&gt;<br/>  &lt;/mac-comment&gt;<br/>&lt;/ng-container&gt;</pre>
<p>To allow users to create new comments, we're making use of the contenteditable API by adding a DIV element <span>that </span>contains the <kbd>contenteditable</kbd> attribute. We're using a local view reference called <kbd>#commentContentEditable</kbd> on that element so that we can quickly reference it from within our component class.</p>
<p>To add a new comment, we will use a button with a click event binding that calls the <kbd>createComment</kbd> method on our component class.</p>
<p>Below the section where users can add new comments, we will create another section that will list all the existing comments. If no comments exist, we just don't render the section.</p>
<p>We're using a particular view element called <kbd>&lt;ng-container&gt;</kbd> to group our <span class="packt_screen">All comments</span> title together with the list of comments. This container element is handy in situations where you're using template elements, like with the use of <kbd>NgIf</kbd>, but you don't want to create an artificial HTML element for that purpose. Using an <kbd>&lt;ng-container&gt;</kbd> element in conjunction with <kbd>NgIf</kbd> allows you to show or hide a list of elements conditionally, but without the need to have a common parent HTML element.</p>
<p>With the help of the <kbd>NgFor</kbd> directive, we are repeating over all existing comments and rendering a comment component for each repetition. We are binding the comment object to our comment component and also adding an output binding to handle updated comments.</p>
<p>Let's create the class of our comments component by changing the content of the <kbd>src/app/comments/comments/comments.component.ts</kbd> file:</p>
<pre>import {<br/>  Component, ViewEncapsulation, ChangeDetectionStrategy, Input, Output,<br/>  EventEmitter, ViewChild, ElementRef<br/>} from '@angular/core';<br/>import {Comment, CommentUpdate, User} from '../../model';<br/><br/>@Component({<br/>  selector: 'mac-comments',<br/>  templateUrl: './comments.component.html',<br/>  styleUrls: ['./comments.component.css'],<br/>  encapsulation: ViewEncapsulation.None,<br/>  changeDetection: ChangeDetectionStrategy.OnPush<br/>})<br/>export class CommentsComponent {<br/>  @Input() user: User;<br/>  @Input() comments: Comment[];<br/>  @Output() outUpdateComment = new EventEmitter&lt;CommentUpdate&gt;();<br/>  @Output() outCreateComment = new EventEmitter&lt;Comment&gt;();<br/>  @ViewChild('commentContentEditable') commentContentEditable: ElementRef;<br/><br/>  createComment() {<br/>    this.outCreateComment.emit({<br/>      user: this.user,<br/>      time: +new Date(),<br/>      content: this.commentContentEditable.nativeElement.textContent<br/>    });<br/>    this.commentContentEditable.nativeElement.textContent = '';<br/>  }<br/><br/>  updateComment(index: number, comment: Comment) {<br/>    this.outUpdateComment.next({<br/>      index,<br/>      comment<br/>    });<br/>  }<br/>}</pre>
<p>Our component class has two inputs. The <kbd>user</kbd> input is expected to be set to the currently logged in user. The comments input is a list of comments <span>that </span>is used in our component view to iterate over and render comment components.</p>
<p>We also have two outputs in our component. The fist one, <kbd>outUpdateComment</kbd>, is used to tell our parent that one of the comments has been updated. The output value is of type <kbd>CommentUpdate</kbd>, which holds the index of the comment <span>that </span>got updated and the comment object itself. Inside of the <kbd>updateComment</kbd> method, which is called from the binding on comment components in our view, we're constructing a comment update object and emitting it through the <kbd>outUpdateComment</kbd> output.</p>
<p>The <kbd>outCreateComment</kbd> output is used to tell our parent that a new comment should be created. The <kbd>createComment</kbd> method is used to create a new comment object and emit it through that output. Additionally, we're using a view query to get hold of the editable DOM element within our component view and store it into the member property <kbd>commentContentEditable</kbd>.  When a new comment is created using the <kbd>createComment</kbd> method, after we've emitted the newly created comment object, we're using the reference to the editable item to reset its text content. This way, after creating a new comment, the editable content element will be blank again.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Integrating the commenting system into projects</h1>
                </header>
            
            <article>
                
<p>So far, we've created our comments model and updated our in-memory web API database. We've created the comment and comments components along with a new view pipe called <kbd>fromNow</kbd> to format relative times in our comment view template. The only missing part is to integrate our comments component in our project. For this, we are making use of the second tab on our project component, which we've already prepared for for our commenting system. To keep our data flow tight, we're introducing a final component to fill the gap between our projects and the comments component.</p>
<p>Let's use Angular CLI to create the project comments container component:</p>
<pre><strong>ng generate component --spec false -ve none -cd onpush container/project-comments-container</strong></pre>
<p>After the component files have been generated, let's open the class file located in <kbd>src/app/container/project-comments-container/project-comments-container.component.ts</kbd> and replace its content with the following code:</p>
<pre>import {Component, ViewEncapsulation, ChangeDetectionStrategy} from '@angular/core';<br/>import {ProjectService} from '../../project/project.service';<br/>import {UserService} from '../../user/user.service';<br/>import {Observable} from 'rxjs';<br/>import {Comment, CommentUpdate, Project, User} from '../../model';<br/>import {map, take} from 'rxjs/operators';<br/><br/>@Component({<br/>  selector: 'mac-project-comments-container',<br/>  templateUrl: './project-comments-container.component.html',<br/>  styleUrls: ['./project-comments-container.component.css'],<br/>  encapsulation: ViewEncapsulation.None,<br/>  changeDetection: ChangeDetectionStrategy.OnPush<br/>})<br/>export class ProjectCommentsContainerComponent {<br/>  user: Observable&lt;User&gt;;<br/>  selectedProject: Observable&lt;Project&gt;;<br/>  projectComments: Observable&lt;Comment[]&gt;;<br/><br/>  constructor(private projectService: ProjectService, private userService: UserService) {<br/>    this.user = userService.getCurrentUser();<br/>    this.selectedProject = projectService.getSelectedProject();<br/>    this.projectComments = this.selectedProject<br/>      .pipe(<br/>        map((project) =&gt; project.comments)<br/>      );<br/>  }<br/><br/>  createComment(comment: Comment) {<br/>    this.selectedProject<br/>      .pipe(<br/>        take(1)<br/>      )<br/>      .subscribe((project) =&gt; this.projectService.updateProject({<br/>        ...project,<br/>        comments: [...project.comments, comment]<br/>      }));<br/>  }<br/><br/>  updateComment(update: CommentUpdate) {<br/>    this.selectedProject<br/>      .pipe(<br/>        take(1)<br/>      )<br/>      .subscribe((project) =&gt; {<br/>        const updatedComments = project.comments.slice();<br/>        updatedComments[update.index] = update.comment;<br/>        this.projectService.updateProject({<br/>          ...project,<br/>          comments: updatedComments<br/>        });<br/>      });<br/>  }<br/>}</pre>
<p>Within our project comments container, we're storing three different observables. Let's take a look at each of them and their purposes.</p>
<p>The <kbd>user</kbd> observable emits the currently logged in user. Within the constructor of our container component, we're calling the <kbd>getCurrentUser</kbd> method on the user service to obtain the observable.</p>
<p>The <kbd>selectedProject</kbd> observable is obtained by calling <kbd>getSelectedProject</kbd> on our project service. This observable will always emit the currently selected project. If we're choosing a different project in our main navigation, the newly selected project is emitted through this observable.</p>
<p>Finally, the <kbd>projectComments</kbd> observable is a transformed observable with the <kbd>selectedProject</kbd> observable as a source. We would like to access the project comments directly so we can use them as input to our commenting system. By using the <kbd>map</kbd> operator inside a pipe transformation, we can select the <kbd>comments</kbd> field of the selected project and create a new output observable <span>that </span>is always emitting the comments list of the selected project.</p>
<p>Finally, we're providing two methods, <kbd>createComment</kbd> and <kbd>updateComment</kbd>, to create or update comments using the project service. We're obtaining the latest value of the <kbd>selectedProject</kbd> observable by utilizing the <kbd>take</kbd> operator and updating an existing or adding a new comment using the project service, respectively.</p>
<p>That's it for the code of our component class. You should be reasonably familiar with the logic inside of our container component. The patterns we're using are very similar to those from our existing task list container, or the ones present in our app component.</p>
<p>Let's open the view template of our project comments container component located in <span><kbd>src/app/container/project-comments-container/project-comments-container.component.html</kbd> and change its content to the following code:</span></p>
<pre>&lt;mac-comments [user]="user | async"<br/>              [comments]="projectComments | async"<br/>              (outCreateComment)="createComment($event)"<br/>              (outUpdateComment)="updateComment($event)"&gt;<br/>&lt;/mac-comments&gt;</pre>
<p>There is nothing we wouldn't expect from a regular container component template. We're merely rendering a comments UI component and binding all inputs and outputs of the component to the logic and data within our container component class. Again, we're making our comments UI component highly reusable by separating the state and data concerns with the use of a container component.</p>
<p>Alright, we're almost finished integrating our commenting system. The last missing bit is to include our project comments container component within our project component. Let's open the view template <span>of the project component </span>located in <kbd>src/app/project/project/project.component.html</kbd> and apply the necessary changes to render our commenting system:</p>
<pre>&lt;header class="header"&gt;<br/>  &lt;h2 class="title"&gt;<br/>    &lt;mac-editor [content]="project.title"<br/>                [showControls]="true"<br/>                (outSaveEdit)="updateTitle($event)"&gt;&lt;/mac-editor&gt;<br/>  &lt;/h2&gt;<br/>  &lt;mac-editor [content]="project.description"<br/>              [showControls]="true"<br/>              (outSaveEdit)="updateDescription($event)"&gt;&lt;/mac-editor&gt;<br/>&lt;/header&gt;<br/>&lt;mac-tabs [tabs]="tabs"<br/>          [activeTab]="activeTab"<br/>          (outActivateTab)="activateTab($event)"&gt;<br/>&lt;/mac-tabs&gt;<br/>&lt;mac-task-list-container *ngIf="activeTab.id === 'tasks'"&gt;<br/>&lt;/mac-task-list-container&gt;<br/><strong>&lt;mac-project-comments-container *ngIf="activeTab.id === 'comments'"&gt;</strong><br/><strong>&lt;/mac-project-comments-container&gt;</strong></pre>
<p>We're just reusing the same logic we've already used to render our task list container. We ensure that our tabbed interface within the project component activates the project comments container component by placing an <kbd>NgIf</kbd> with the respective condition.</p>
<p>There you go! That wasn't too complicated, was it? We've finally created and integrated a commenting system on our projects. Due to the way we've built our commenting system, we can integrate comments in any other location we want to.</p>
<p>Preview your changes in the browser and play around with the commenting functionality a bit to get familiar with what you've just built:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/09c1e366-895d-482f-ae50-97f2acc364a6.png" style=""/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Screenshot of the commenting system that is integrated within our project component</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Recap</h1>
                </header>
            
            <article>
                
<p>Within this topic, we have successfully created a fully-fledged commenting system that can be placed in various areas of our application to enable commenting. Users can interact with in-place editors to edit the content in comments, which gives them a great user experience.</p>
<p>While writing the code for our commenting system, we learned about the following topics:</p>
<ul>
<li>Creating a re-usable commenting system <span>that </span>can be used to add commenting functionality in every area of our application</li>
<li>Implementing a simple pipe using the <kbd>@Pipe</kbd> decorator and the Moment.js library to provide relative time formatting</li>
<li>Using the <kbd>&lt;ng-container&gt;</kbd> element to group elements for use within a template directive</li>
<li>Re-using the editor component as an in-place editor within the comment component</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>The main topic of this chapter was the introduction of projects. We've created the necessary model and data layer to deal with projects to group individual tasks. We've also created UI components to display project information <span>and a tabbed user interface component that we can reuse wherever we need it. We learned about the concept of content projection, which allows us to build beautiful content-based APIs for our components.</span></p>
<p>We've further structured our main layout and introduced some navigation components <span>that </span>we're currently using to provide a project navigation.</p>
<p>We created a simple in-place editor that provides an excellent authoring experience within our application. Going forward, we can use the editor component wherever we want to make content editable for our users. They will not have to jump into disturbing dialogues or separate configuration pages, and will be able to edit directly within their current context. This is an excellent tool for enhancing the experience of our users.</p>
<p>Besides our shiny new editor component, we created a whole commenting system that can be easily included in areas of our application where we'd like to provide commenting capabilities. We have added the commenting system within our project and users can now comment on projects by navigating to the <span class="packt_screen">Comments</span> tab on the project details.</p>
<p>The project navigation and the tabbed interface we've <span>built</span> are both great. However, it would be nice to think that the concern of navigation could be separated from our regular application composition. We also want to leverage the browser's location URL and the native functionality of the browser history. Within the next chapter, we're going to address this and learn everything required to integrate the Angular router into our application.</p>


            </article>

            
        </section>
    </body></html>