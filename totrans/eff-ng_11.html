<html><head></head><body>
<div id="_idContainer041">
<h1 class="chapter-number" id="_idParaDest-183"><a id="_idTextAnchor200"/><span class="koboSpan" id="kobo.1.1">11</span></h1>
<h1 id="_idParaDest-184"><a id="_idTextAnchor201"/><span class="koboSpan" id="kobo.2.1">Testing Angular Applications</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Writing automated tests for your applications is just as important as writing the application code. </span><span class="koboSpan" id="kobo.3.2">Many developers don’t like to write tests or skip them altogether because they feel it’s too time-consuming, but as your applications and workspace grow, having automated tests becomes ever more critical. </span><span class="koboSpan" id="kobo.3.3">When working on an extensive application, the chances are significant that your changes will impact many things throughout the application. </span><span class="koboSpan" id="kobo.3.4">Small changes can affect many things, which becomes even more apparent when you’re making changes in a library used in many applications. </span><span class="koboSpan" id="kobo.3.5">You’ll often find yourself in a scenario where you make changes and don’t even know every application surface your changes will impact. </span><span class="koboSpan" id="kobo.3.6">Because you don’t want to break features, you don’t want to work on or manually test the entire workspace each time you make a change; you need automated tests that can test all affected code for you. </span><span class="koboSpan" id="kobo.3.7">Automated tests will help you look at your code differently; they can help you write better, more sturdy code. </span><span class="koboSpan" id="kobo.3.8">Automated tests will also catch bugs at an early stage and should give you the confidence to safely release code changes to production once all tests have </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">successfully passed.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">This chapter will dive into different types of automated tests and their purpose within your Angular applications. </span><span class="koboSpan" id="kobo.5.2">Next, you will dive deeper into the topic of unit testing and get some hands-on experience by writing unit tests for our Nx monorepo using Jest. </span><span class="koboSpan" id="kobo.5.3">Lastly, you will learn more about end-to-end testing and gain some experience writing end-to-end tests using Cypress. </span><span class="koboSpan" id="kobo.5.4">By the end of this chapter, you will understand why you need automated tests and how to write them for your </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">Angular applications.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">This chapter will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">Different types of </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">application testing</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Unit testing of Angular applications </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">using Jest</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">End-to-end testing of Angular applications </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">using Cypress</span></span></li>
</ul>
<h1 id="_idParaDest-185"><a id="_idTextAnchor202"/><span class="koboSpan" id="kobo.15.1">Different types of application testing</span></h1>
<p><span class="koboSpan" id="kobo.16.1">In a world where software plays</span><a id="_idIndexMarker1021"/><span class="koboSpan" id="kobo.17.1"> an increasingly important role and the applications we build are growing more complex, automated testing is becoming more critical. </span><span class="koboSpan" id="kobo.17.2">Companies are constantly looking to improve their applications to give users a better experience. </span><span class="koboSpan" id="kobo.17.3">To achieve this, many companies aim for continuous delivery of their software, meaning their updates can be automatically released to production at any given time. </span><span class="koboSpan" id="kobo.17.4">To ensure you can safely release updates without breaking things in production, you need automated tests that can run in your build pipelines to automatically test your software before releasing changes to your testing, acceptance, and </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">production environments.</span></span></p>
<p><span class="koboSpan" id="kobo.19.1">As applications become more complex, manually testing all changes becomes too time-consuming, and the chances of not testing something affected by your code changes increase significantly. </span><span class="koboSpan" id="kobo.19.2">Manual testing is also much slower, repetitive, and boring. </span><span class="koboSpan" id="kobo.19.3">Tasks that are time-consuming, tedious, and repetitive tend to get skipped and lead to mistakes. </span><span class="koboSpan" id="kobo.19.4">All that manual labor is also a considerable expense for the business, so having a sound automated testing system in place is </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">a necessity.</span></span></p>
<p><span class="koboSpan" id="kobo.21.1">Besides speeding up the testing process and making it less error-prone, automated tests should give you the confidence that any code you merge will not break the existing application code. </span><span class="koboSpan" id="kobo.21.2">If you’ve ever merged a large code change in an environment without a good testing suite, you know what a nerve-wracking experience it is and that you never really feel confident that your changes didn’t break anything. </span><span class="koboSpan" id="kobo.21.3">If there are tests, they will catch bugs and help you think differently about how you implement your code, but having the ability to release changes confidently is the real goal we’re trying to achieve when writing </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">automated tests.</span></span></p>
<p><span class="koboSpan" id="kobo.23.1">When it comes to automated tests for your Angular applications, you can divide them into four </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">major types:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.25.1">Unit tests</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.26.1">End-to-end tests</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.27.1">Component tests</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.28.1">Integration tests</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.29.1">Let’s learn about these four types of tests, how they are used in Angular applications, and the differences </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">between them.</span></span></p>
<h2 id="_idParaDest-186"><a id="_idTextAnchor203"/><span class="koboSpan" id="kobo.31.1">Understanding unit tests</span></h2>
<p><span class="koboSpan" id="kobo.32.1">One of the fundamental</span><a id="_idIndexMarker1022"/><span class="koboSpan" id="kobo.33.1"> aspects of software</span><a id="_idIndexMarker1023"/><span class="koboSpan" id="kobo.34.1"> testing is </span><strong class="bold"><span class="koboSpan" id="kobo.35.1">unit testing</span></strong><span class="koboSpan" id="kobo.36.1">. </span><span class="koboSpan" id="kobo.36.2">Simply put, unit tests validate small units of code, commonly individual functions, properties, or methods. </span><span class="koboSpan" id="kobo.36.3">Unit tests are used to test the update behavior of properties and the implementation of functions under different scenarios. </span><span class="koboSpan" id="kobo.36.4">Given a specified input, you expect the function to return a specific value and update certain properties. </span><span class="koboSpan" id="kobo.36.5">Unit tests run in isolation from the rest of your application, so you can test small units of code without them being affected by other parts of the application code; that way, you can quickly identify whether the function works as intended based on </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">its implementation.</span></span></p>
<p><span class="koboSpan" id="kobo.38.1">A common and popular technique</span><a id="_idIndexMarker1024"/><span class="koboSpan" id="kobo.39.1"> for developing applications is </span><strong class="bold"><span class="koboSpan" id="kobo.40.1">test-driven development</span></strong><span class="koboSpan" id="kobo.41.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.42.1">TDD</span></strong><span class="koboSpan" id="kobo.43.1">). </span><span class="koboSpan" id="kobo.43.2">In simple terms, when you use TDD to develop your applications, you first write the test scenarios and then the code implementations. </span><span class="koboSpan" id="kobo.43.3">Developing your code this way allows you to look at your code implementations from another perspective. </span><span class="koboSpan" id="kobo.43.4">Writing tests helps you to look at your code implementations differently in general. </span><span class="koboSpan" id="kobo.43.5">Still, when you first write all the possible test scenarios you want to cover and write the code implementation afterward, it changes </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">your perspective.</span></span></p>
<p><span class="koboSpan" id="kobo.45.1">In Angular applications, unit tests</span><a id="_idIndexMarker1025"/><span class="koboSpan" id="kobo.46.1"> are commonly</span><a id="_idIndexMarker1026"/><span class="koboSpan" id="kobo.47.1"> implemented using frameworks such as </span><strong class="bold"><span class="koboSpan" id="kobo.48.1">Jest</span></strong><span class="koboSpan" id="kobo.49.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.50.1">Karma</span></strong><span class="koboSpan" id="kobo.51.1"> and typically test specific Angular components, services, pipes, or directives. </span><span class="koboSpan" id="kobo.51.2">These tests are essential for verifying that each unit of code behaves as expected, adhering to its defined specifications and requirements. </span><span class="koboSpan" id="kobo.51.3">By isolating each unit of code, developers can identify and address bugs and issues early in development, promoting a more robust and </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">stable application.</span></span></p>
<p><span class="koboSpan" id="kobo.53.1">The primary purpose of unit tests in Angular applications is to give developers confidence in their code implementations, ensuring properties are updated and functions work as expected. </span><span class="koboSpan" id="kobo.53.2">By thoroughly testing individual units of code under different scenarios, developers can ensure that each line of code functions as intended, even as the codebase evolves and changes over time. </span><span class="koboSpan" id="kobo.53.3">This confidence is crucial to enabling developers to make changes and enhancements to the application with the assurance that existing functionalities </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">remain intact.</span></span></p>
<p><span class="koboSpan" id="kobo.55.1">A characteristic of unit tests is that they are quick to run, allowing developers to run them multiple times during the development process, making it easy to identify unintended side effects and bugs early. </span><span class="koboSpan" id="kobo.55.2">Unit tests also aim to cover a specific percentage of the codebase. </span><span class="koboSpan" id="kobo.55.3">Typically, companies like to test between 80% and 100% of the lines of code, functions, and branches (or paths) of the code; most unit test frameworks can enforce these thresholds, so you can’t merge the code if you don’t have enough </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">testing coverage.</span></span></p>
<p><span class="koboSpan" id="kobo.57.1">To summarize, unit tests are used to test small units of code such as functions, methods, and properties. </span><span class="koboSpan" id="kobo.57.2">With unit tests, you test code implementations under different scenarios to give you confidence that the code behaves as expected given a specified input. </span><span class="koboSpan" id="kobo.57.3">Commonly, you try to achieve a code testing coverage of between 80% and 100% for unit tests; so, compared to the other testing types (end-to-end, component, and integration), your unit tests will have the most test cases. </span><span class="koboSpan" id="kobo.57.4">Unit tests are fast to run and rarely fail because</span><a id="_idIndexMarker1027"/><span class="koboSpan" id="kobo.58.1"> of your environment</span><a id="_idIndexMarker1028"/><span class="koboSpan" id="kobo.59.1"> because they run </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">in isolation.</span></span></p>
<p><span class="koboSpan" id="kobo.61.1">Now that you have a good idea of what unit tests are and why they are useful, let’s dive into the next type of tests: </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">end-to-end tests.</span></span></p>
<h2 id="_idParaDest-187"><a id="_idTextAnchor204"/><span class="koboSpan" id="kobo.63.1">Understanding end-to-end tests</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.64.1">End-to-end</span></strong><span class="koboSpan" id="kobo.65.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.66.1">e2e</span></strong><span class="koboSpan" id="kobo.67.1">) tests are an integral part</span><a id="_idIndexMarker1029"/><span class="koboSpan" id="kobo.68.1"> of the testing</span><a id="_idIndexMarker1030"/><span class="koboSpan" id="kobo.69.1"> strategy for Angular applications. </span><span class="koboSpan" id="kobo.69.2">They offer a comprehensive approach to validating the application’s behavior and functionality from the user’s perspective. </span><span class="koboSpan" id="kobo.69.3">Unlike unit tests, which focus on testing individual units of code in isolation, e2e tests simulate real user interactions with the application, spanning multiple components and services to ensure that the application functions correctly as </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">a whole.</span></span></p>
<p><span class="koboSpan" id="kobo.71.1">In the context of Angular applications, e2e tests</span><a id="_idIndexMarker1031"/><span class="koboSpan" id="kobo.72.1"> are commonly</span><a id="_idIndexMarker1032"/><span class="koboSpan" id="kobo.73.1"> implemented</span><a id="_idIndexMarker1033"/><span class="koboSpan" id="kobo.74.1"> using frameworks such as </span><strong class="bold"><span class="koboSpan" id="kobo.75.1">Cypress</span></strong><span class="koboSpan" id="kobo.76.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.77.1">Playwright</span></strong><span class="koboSpan" id="kobo.78.1">, or </span><strong class="bold"><span class="koboSpan" id="kobo.79.1">Protractor</span></strong><span class="koboSpan" id="kobo.80.1">. </span><span class="koboSpan" id="kobo.80.2">These frameworks provide helpful tools to automate browser interactions, allowing them to simulate user actions such as clicking buttons, entering text, and navigating between pages. </span><span class="koboSpan" id="kobo.80.3">By automating these interactions, developers can thoroughly test the application’s user interface and workflow, identifying and addressing issues that may arise during </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">real-world usage.</span></span></p>
<p><span class="koboSpan" id="kobo.82.1">The primary goal of e2e tests is verifying that the applications work as expected from the perspective of the user, encompassing the application’s functional and non-functional aspects. </span><span class="koboSpan" id="kobo.82.2">e2e tests serve and render the application (or specific libraries or modules of the application) in a real browser (you can also run them headless without opening a browser), visit a specific URL, and interact with the application as a user would. </span><span class="koboSpan" id="kobo.82.3">With e2e tests, you are testing whether components render correctly and whether features such as form submission, data retrieval and display, models, and error handling work as intended. </span><span class="koboSpan" id="kobo.82.4">By testing the application end-to-end, developers can ensure that multiple components and services work together seamlessly to deliver a cohesive </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">user experience.</span></span></p>
<p><span class="koboSpan" id="kobo.84.1">One of the main advantages of e2e tests is their ability to detect issues that may be absent when testing individual units of code in isolation. </span><span class="koboSpan" id="kobo.84.2">By exercising the entire application stack during the tests, including the frontend user interface, external dependencies, and (optionally) backend services, e2e tests can uncover issues related to data flow, communication between components, and interoperability with third-party services. </span><span class="koboSpan" id="kobo.84.3">This holistic approach to testing helps developers identify and address potential bottlenecks and failure points within the application, leading to a more robust and reliable </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">software product.</span></span></p>
<p><span class="koboSpan" id="kobo.86.1">However, while e2e tests</span><a id="_idIndexMarker1034"/><span class="koboSpan" id="kobo.87.1"> offer many benefits, they also come with certain challenges</span><a id="_idIndexMarker1035"/><span class="koboSpan" id="kobo.88.1"> and considerations that developers must address. </span><span class="koboSpan" id="kobo.88.2">The setup for e2e tests is more challenging than unit tests, and e2e tests are more prone to fail because of issues in the test environment. </span><span class="koboSpan" id="kobo.88.3">Nx already handles most of the setup for us, making starting with our e2e </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">tests easier.</span></span></p>
<p><span class="koboSpan" id="kobo.90.1">With e2e tests, you also don’t have an easy way to detect code coverage, so they require more planning and coordination to ensure you’re testing everything within your application and handling different scenarios and </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">use cases.</span></span></p>
<p><span class="koboSpan" id="kobo.92.1">Furthermore, e2e tests can be more time-consuming and resource-intensive to execute than unit tests due to their reliance on browser automation and the need to simulate real user behavior. </span><span class="koboSpan" id="kobo.92.2">As a result, developers must strike a balance between the depth and scope of e2e test coverage and the practical constraints of test execution time </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">and resources.</span></span></p>
<p><span class="koboSpan" id="kobo.94.1">Despite these challenges, e2e tests play a crucial role in ensuring Angular applications’ overall quality and reliability, complementing other testing techniques such as unit tests and integration tests. </span><span class="koboSpan" id="kobo.94.2">By thoroughly testing the application from end to end, developers can gain confidence in its behavior and functionality, identify and address issues early in the development process, and ultimately deliver a high-quality user experience to </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">their customers.</span></span></p>
<p><span class="koboSpan" id="kobo.96.1">To summarize, e2e tests are designed to test your application from the user’s perspective and interact with your application in a real browser. </span><span class="koboSpan" id="kobo.96.2">They ensure your application (or specific libraries or modules) works as a whole and responds in the intended way to user interactions. </span><span class="koboSpan" id="kobo.96.3">e2e tests, while more time-consuming to write and execute than unit tests, provide the assurance that the user can interact with your applications</span><a id="_idIndexMarker1036"/><span class="koboSpan" id="kobo.97.1"> as you intended, fostering a stronger connection</span><a id="_idIndexMarker1037"/><span class="koboSpan" id="kobo.98.1"> with your </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">end users.</span></span></p>
<p><span class="koboSpan" id="kobo.100.1">Now that you know what e2e tests are and how they differ from unit tests, I will briefly explain component and </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">integration testing.</span></span></p>
<h2 id="_idParaDest-188"><a id="_idTextAnchor205"/><span class="koboSpan" id="kobo.102.1">Understanding component tests</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.103.1">Component testing</span></strong><span class="koboSpan" id="kobo.104.1"> is a relatively new concept</span><a id="_idIndexMarker1038"/><span class="koboSpan" id="kobo.105.1"> compared</span><a id="_idIndexMarker1039"/><span class="koboSpan" id="kobo.106.1"> to unit and e2e testing. </span><span class="koboSpan" id="kobo.106.2">In modern frontend frameworks such as Angular, we develop applications using </span><strong class="bold"><span class="koboSpan" id="kobo.107.1">components</span></strong><span class="koboSpan" id="kobo.108.1">. </span><span class="koboSpan" id="kobo.108.2">Components can be simple components, such as buttons, or more complex ones, such as tables </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">or forms.</span></span></p>
<p><span class="koboSpan" id="kobo.110.1">Using component tests, frameworks such as Cypress provide a new approach for testing component-based applications. </span><span class="koboSpan" id="kobo.110.2">Instead of visiting a URL and running the entire application, component tests mount individual components and test those components in isolation. </span><span class="koboSpan" id="kobo.110.3">Component testing is like unit testing of  e2e testing. </span><span class="koboSpan" id="kobo.110.4">You still mount the component and show it in a browser to interact with the component like a user would, but you test it in isolation from the rest of your application. </span><span class="koboSpan" id="kobo.110.5">Testing components in isolation allows you to test the component from a user interaction perspective without worrying about the rest of </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.112.1">One thing to keep in mind is that even if all your component tests are passing, it does not automatically mean your application is working as expected. </span><span class="koboSpan" id="kobo.112.2">Components can work in isolation but fail when they’re combined or have to interact with other components in your application. </span><span class="koboSpan" id="kobo.112.3">Compared to e2e tests, component tests don’t need the entire system to be executed, so they can run faster and rarely fail due to issues with your </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">test environment.</span></span></p>
<p><span class="koboSpan" id="kobo.114.1">If you and your team want to implement component tests, it is up to you; these tests can help reduce the number of e2e tests you need to write. </span><span class="koboSpan" id="kobo.114.2">I like to write more e2e tests as opposed to component tests. </span><span class="koboSpan" id="kobo.114.3">Component tests still need to be adopted as an industry standard; most companies only require unit, e2e, and </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">integration tests.</span></span></p>
<p><span class="koboSpan" id="kobo.116.1">To summarize, component tests test individual components from the user’s perspective. </span><span class="koboSpan" id="kobo.116.2">Component tests ensure a component works in isolation but don’t ensure the component works within the context of your entire application. </span><span class="koboSpan" id="kobo.116.3">Component tests are easier to set up than e2e tests as they don’t need to run the entire application. </span><span class="koboSpan" id="kobo.116.4">You can think of component testing</span><a id="_idIndexMarker1040"/><span class="koboSpan" id="kobo.117.1"> as a mix between unit</span><a id="_idIndexMarker1041"/><span class="koboSpan" id="kobo.118.1"> and </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">e2e testing.</span></span></p>
<p><span class="koboSpan" id="kobo.120.1">Now that you know what component tests are and how they differ from e2e tests, we will finish this section on different testing types by explaining </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">integration tests.</span></span></p>
<h2 id="_idParaDest-189"><a id="_idTextAnchor206"/><span class="koboSpan" id="kobo.122.1">Understanding integration tests</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.123.1">Integration tests</span></strong><span class="koboSpan" id="kobo.124.1"> are used to test whether different modules</span><a id="_idIndexMarker1042"/><span class="koboSpan" id="kobo.125.1"> and elements</span><a id="_idIndexMarker1043"/><span class="koboSpan" id="kobo.126.1"> of your software integrate without breaking. </span><span class="koboSpan" id="kobo.126.2">They are generally the final testing stage before you release your changes to production. </span><span class="koboSpan" id="kobo.126.3">So, unit tests focus on testing individual units of code in isolation, end-to-end tests simulate and test user interactions for specific application libraries and modules, and integration tests are used to test the interactions between various modules and elements within </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.128.1">Integration tests can be used and written for different integration levels within an application. </span><span class="koboSpan" id="kobo.128.2">For example, you can write functional tests comparable to unit tests. </span><span class="koboSpan" id="kobo.128.3">Still, instead of testing code implementations for an isolated component or service, you test whether your functionality and implementations work as expected for a group of components or services that work together. </span><span class="koboSpan" id="kobo.128.4">You can also write integration tests from the user’s perspective, similar to e2e tests. </span><span class="koboSpan" id="kobo.128.5">When you write integration tests from the user’s perspective, you can test whether your frontend works together with your API or whether your deployed application is composed of multiple Angular applications. </span><span class="koboSpan" id="kobo.128.6">You can also test whether the different applications can work together when everything </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">is deployed.</span></span></p>
<p><span class="koboSpan" id="kobo.130.1">When you create integration tests from the user’s perspective, you commonly run the tests in an environment that mirrors the production environment. </span><span class="koboSpan" id="kobo.130.2">You test with an actual deployed application with real APIs and data. </span><span class="koboSpan" id="kobo.130.3">By testing on a deployed system, you can test whether all elements of your software work together as expected without </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">any boundaries.</span></span></p>
<p><span class="koboSpan" id="kobo.132.1">Now you know about unit, e2e, component, and integration tests, it’s time to get our hands dirty and write some tests ourselves. </span><span class="koboSpan" id="kobo.132.2">We will skip the integration tests because we don’t have a large system or a deployed version with different elements that integrate. </span><span class="koboSpan" id="kobo.132.3">We will start by writing and running unit tests for our Angular application using the Jest testing</span><a id="_idIndexMarker1044"/><span class="koboSpan" id="kobo.133.1"> framework. </span><span class="koboSpan" id="kobo.133.2">After writing</span><a id="_idIndexMarker1045"/><span class="koboSpan" id="kobo.134.1"> our unit test, we will finish the chapter by writing e2e tests using the Cypress </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">testing framework.</span></span></p>
<h1 id="_idParaDest-190"><a id="_idTextAnchor207"/><span class="koboSpan" id="kobo.136.1">Unit testing of Angular applications using Jest</span></h1>
<p><span class="koboSpan" id="kobo.137.1">When you add an Angular project to your Nx monorepo, the application</span><a id="_idIndexMarker1046"/><span class="koboSpan" id="kobo.138.1"> is set up to use Jest as a test runner by default. </span><span class="koboSpan" id="kobo.138.2">Jest is a testing framework commonly used to write and run automated unit tests for JavaScript and TypeScript-based applications. </span><span class="koboSpan" id="kobo.138.3">This section will give you hands-on experience writing unit tests for your Angular application using Jest. </span><span class="koboSpan" id="kobo.138.4">Before you start writing tests, let’s expand upon the default configuration Nx provided to make your testing </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">experience better.</span></span></p>
<h2 id="_idParaDest-191"><a id="_idTextAnchor208"/><span class="koboSpan" id="kobo.140.1">Setting the coverage threshold</span></h2>
<p><span class="koboSpan" id="kobo.141.1">The first thing you want to add in the Jest configuration</span><a id="_idIndexMarker1047"/><span class="koboSpan" id="kobo.142.1"> is a coverage threshold for the minimum required percentage of lines, functions, and branches that unit tests should cover. </span><span class="koboSpan" id="kobo.142.2">A commonly used percentage is 80%, but you can set the coverage percentages to whatever you and your team deem enough to make you confident that new changes won’t break existing code. </span><span class="koboSpan" id="kobo.142.3">You can add the global configurations for testing coverage inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">jest.preset.js</span></strong><span class="koboSpan" id="kobo.144.1"> file in the root of your Nx monorepo. </span><span class="koboSpan" id="kobo.144.2">Additionally, you can set specific configurations for each project in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">jest.config.ts</span></strong><span class="koboSpan" id="kobo.146.1"> file at the root of each project. </span><span class="koboSpan" id="kobo.146.2">I will only add the following configurations in </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">jest.preset.js</span></strong><span class="koboSpan" id="kobo.148.1"> in the root of the </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">Nx monorepo:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.150.1">
coverageThreshold: {
  global: {
      lines: 80,
      functions: 80,
      branches: 80
  },
},
collectCoverage : true,
coverageReporters: [
  "cobertura",
  "lcov",
  "text",
]</span></pre> <p><span class="koboSpan" id="kobo.151.1">The preceding configuration ensures that all branches, functions, and lines have a minimum test coverage of 80%. </span><span class="koboSpan" id="kobo.151.2">The configuration also tells Jest to collect the coverage results and present you with a text-based coverage report. </span><span class="koboSpan" id="kobo.151.3">In the coverage report, you can see how much of your code is covered, what lines, functions, and branches are missing, and their respective</span><a id="_idIndexMarker1048"/><span class="koboSpan" id="kobo.152.1"> page </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">line numbers.</span></span></p>
<p><span class="koboSpan" id="kobo.154.1">Now that you have configured your test coverage reports, it’s time to add a testing module </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">for Transloco.</span></span></p>
<h2 id="_idParaDest-192"><a id="_idTextAnchor209"/><span class="koboSpan" id="kobo.156.1">Adding additional configurations</span></h2>
<p><span class="koboSpan" id="kobo.157.1">The testing module makes</span><a id="_idIndexMarker1049"/><span class="koboSpan" id="kobo.158.1"> it easy to import the correct configuration to test components using Transloco. </span><span class="koboSpan" id="kobo.158.2">In the root of your </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">expenses-registration</span></strong><span class="koboSpan" id="kobo.160.1"> project, you can create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">transloco-testing.module.ts</span></strong><span class="koboSpan" id="kobo.162.1"> file and add the </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">following content:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.164.1">
import { TranslocoTestingModule, TranslocoTestingOptions } from '@ngneat/transloco';
import en from '../assets/i18n/en.json';
import nl from '../assets/i18n/nl.json';
export function getTranslocoModule(options: TranslocoTestingOptions = {}) {
  return TranslocoTestingModule.forRoot({
    langs: { en, nl },
    translocoConfig: {
      availableLangs: ['en', 'nl'],
      defaultLang: 'en',
    },
    preloadLangs: true,
    ...options
  });
}</span></pre> <p><span class="koboSpan" id="kobo.165.1">In the preceding example, we created</span><a id="_idIndexMarker1050"/><span class="koboSpan" id="kobo.166.1"> a </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">getTranslocoModule()</span></strong><span class="koboSpan" id="kobo.168.1"> function. </span><span class="koboSpan" id="kobo.168.2">This function will be used inside our unit test files to add the necessary Transloco configuration for the test setup. </span><span class="koboSpan" id="kobo.168.3">It’s simply a function returning the </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">TranslocoTestingModule</span></strong><span class="koboSpan" id="kobo.170.1"> class provided by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">Transloco</span></strong><span class="koboSpan" id="kobo.172.1"> library. </span><span class="koboSpan" id="kobo.172.2">At the top of the file, we import two JSON files containing our translations. </span><span class="koboSpan" id="kobo.172.3">If you want to import these two JSON files without trouble, you need to add the following configurations inside your </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">tsconfig.base.json</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.174.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.175.1">
"resolveJsonModule": true,
"esModuleInterop": true,</span></pre> <p><span class="koboSpan" id="kobo.176.1">After adding the preceding configuration and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">transloco-testing.module.ts</span></strong><span class="koboSpan" id="kobo.178.1"> file with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">getTranslocoModule()</span></strong><span class="koboSpan" id="kobo.180.1"> function, we are almost done with our addition to the default Jest setup Nx provided us with. </span><span class="koboSpan" id="kobo.180.2">Lastly, we need to update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">transformIgnorePatterns</span></strong><span class="koboSpan" id="kobo.182.1"> configuration inside our </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">jest.config.ts</span></strong><span class="koboSpan" id="kobo.184.1"> files to </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.186.1">
transformIgnorePatterns: ['node_modules/?!(.*\\.mjs$|@ngneat)'],</span></pre> <p><span class="koboSpan" id="kobo.187.1">When you change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">transformIgnorePatterns</span></strong><span class="koboSpan" id="kobo.189.1"> configuration, you ensure Jest will not start to complain about missing imports and packages inside your </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">node_modules</span></strong><span class="koboSpan" id="kobo.191.1"> folder. </span><span class="koboSpan" id="kobo.191.2">There already are </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">transformIgnorePatterns</span></strong><span class="koboSpan" id="kobo.193.1"> configurations inside each </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">jest.config.ts</span></strong><span class="koboSpan" id="kobo.195.1"> file in your Nx monorepo, but in many cases, you need to adjust them or else your tests might fail based on things inside your </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">node_modules</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.197.1"> folder.</span></span></p>
<p><span class="koboSpan" id="kobo.198.1">That is all the additional setup we will be doing. </span><span class="koboSpan" id="kobo.198.2">You can always add additional configurations as needed. </span><span class="koboSpan" id="kobo.198.3">You can find all additional</span><a id="_idIndexMarker1051"/><span class="koboSpan" id="kobo.199.1"> Jest configurations in their official documentation </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">at </span></span><a href="https://jestjs.io/docs/configuration"><span class="No-Break"><span class="koboSpan" id="kobo.201.1">https://jestjs.io/docs/configuration</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.202.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.203.1">Now that you have added the configuration needed to test Transloco and obtained testing coverage reports, let’s start to write and run unit tests for our </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">Angular application.</span></span></p>
<h2 id="_idParaDest-193"><a id="_idTextAnchor210"/><span class="koboSpan" id="kobo.205.1">Writing and running unit tests</span></h2>
<p><span class="koboSpan" id="kobo.206.1">You write your</span><a id="_idIndexMarker1052"/><span class="koboSpan" id="kobo.207.1"> unit tests inside </span><strong class="bold"><span class="koboSpan" id="kobo.208.1">spec</span></strong><span class="koboSpan" id="kobo.209.1"> files using the Jest</span><a id="_idIndexMarker1053"/><span class="koboSpan" id="kobo.210.1"> testing</span><a id="_idIndexMarker1054"/><span class="koboSpan" id="kobo.211.1"> framework. </span><span class="koboSpan" id="kobo.211.2">When we created our Nx monorepo, Nx already configured everything we needed to write and run tests using Jest. </span><span class="koboSpan" id="kobo.211.3">Additionally, every time we used the Nx generator to create a component, service, pipe, or directive, Nx created a </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">.spec.ts</span></strong><span class="koboSpan" id="kobo.213.1"> file for the created resource. </span><span class="koboSpan" id="kobo.213.2">These </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">.spec.ts</span></strong><span class="koboSpan" id="kobo.215.1"> files contain the default-generated </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">unit tests.</span></span></p>
<p><span class="koboSpan" id="kobo.217.1">Let’s take the </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">expenses-registration</span></strong><span class="koboSpan" id="kobo.219.1"> Angular application as our example. </span><span class="koboSpan" id="kobo.219.2">When you generated the application, Nx generated an </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">AppComponent</span></strong><span class="koboSpan" id="kobo.221.1"> class for you and an </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">app.component.spec.ts</span></strong><span class="koboSpan" id="kobo.223.1"> file where the default generated unit test for </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">AppComponent</span></strong><span class="koboSpan" id="kobo.225.1"> resides. </span><span class="koboSpan" id="kobo.225.2">Additionally, we created </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">ExpensesOverviewPageComponent</span></strong><span class="koboSpan" id="kobo.227.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">ExpensesApprovalPageComponent</span></strong><span class="koboSpan" id="kobo.229.1"> inside the </span><em class="italic"><span class="koboSpan" id="kobo.230.1">expenses-registration application</span></em><span class="koboSpan" id="kobo.231.1">; for both these components, Nx also generated </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">.spec.ts</span></strong><span class="koboSpan" id="kobo.233.1"> files. </span><span class="koboSpan" id="kobo.233.2">Let’s start with </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">these files.</span></span></p>
<h3><span class="koboSpan" id="kobo.235.1">Fixing the generated spec files</span></h3>
<p><span class="koboSpan" id="kobo.236.1">If you currently run the tests</span><a id="_idIndexMarker1055"/><span class="koboSpan" id="kobo.237.1"> inside these spec files, they will fail. </span><span class="koboSpan" id="kobo.237.2">The tests will fail because we haven’t touched the spec files since they have been generated, but we did adjust the component classes. </span><span class="koboSpan" id="kobo.237.3">So before we try to run the tests, let’s fix the spec files one by one. </span><span class="koboSpan" id="kobo.237.4">We will also write some new tests and explain what Nx generated for us. </span><span class="koboSpan" id="kobo.237.5">Starting with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">app.component.spec.ts</span></strong><span class="koboSpan" id="kobo.239.1"> file, let’s see what Nx has generated inside the </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">spec file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.241.1">
describe('AppComponent', () =&gt; {
  beforeEach(async () =&gt; { …… });
  it(‹should render title›, () =&gt; { …… });
  it(`should have as title ‹finance-expenses-registration›`, () =&gt; { …… });
});</span></pre> <p><span class="koboSpan" id="kobo.242.1">Nx generated the preceding code for you. </span><span class="koboSpan" id="kobo.242.2">As you can see, there are </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">describe()</span></strong><span class="koboSpan" id="kobo.244.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">beforeEach()</span></strong><span class="koboSpan" id="kobo.246.1">, and two </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">it()</span></strong><span class="koboSpan" id="kobo.248.1"> functions. </span><span class="koboSpan" id="kobo.248.2">All of these functions have some additional code inside their respective callback functions, but we will ignore that for now. </span><span class="koboSpan" id="kobo.248.3">Let’s first explain what </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">describe()</span></strong><span class="koboSpan" id="kobo.250.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">beforeEach()</span></strong><span class="koboSpan" id="kobo.252.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">it()</span></strong><span class="koboSpan" id="kobo.254.1"> functions are </span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">used for:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">describe()</span></strong><span class="koboSpan" id="kobo.257.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">describe()</span></strong><span class="koboSpan" id="kobo.259.1"> function is used to group multiple tests together and describe what element we are testing. </span><span class="koboSpan" id="kobo.259.2">You provide the </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">describe()</span></strong><span class="koboSpan" id="kobo.261.1"> function with two parameters: a string with a description of what we’re writing tests for—in our example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">AppComponent</span></strong><span class="koboSpan" id="kobo.263.1">—and a callback function where we will write out specific </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">test cases.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">beforeEach()</span></strong><span class="koboSpan" id="kobo.266.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">beforeEach()</span></strong><span class="koboSpan" id="kobo.268.1"> function is used to perform specific steps before each test, commonly configurations such as setting up </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">TestBed</span></strong><span class="koboSpan" id="kobo.270.1">, creating the component, service, pipe, or directive we are testing, and any additional configuration we want to do before each test </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">we run.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">it()</span></strong><span class="koboSpan" id="kobo.273.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">it()</span></strong><span class="koboSpan" id="kobo.275.1"> functions define each test case. </span><span class="koboSpan" id="kobo.275.2">An </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">it()</span></strong><span class="koboSpan" id="kobo.277.1"> function takes in two parameters: a string containing a description of the test case and a callback function containing the </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">testing logic.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.279.1">Now that you know what </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">describe()</span></strong><span class="koboSpan" id="kobo.281.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">beforeEach()</span></strong><span class="koboSpan" id="kobo.283.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">it()</span></strong><span class="koboSpan" id="kobo.285.1"> functions are, let’s replace the generated</span><a id="_idIndexMarker1056"/><span class="koboSpan" id="kobo.286.1"> code of your </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">app.component.spec.ts</span></strong><span class="koboSpan" id="kobo.288.1"> file with something that reflects the current state of the </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">app component.</span></span></p>
<h3><span class="koboSpan" id="kobo.290.1">Defining our test cases</span></h3>
<p><span class="koboSpan" id="kobo.291.1">Before we start adjusting</span><a id="_idIndexMarker1057"/><span class="koboSpan" id="kobo.292.1"> the code inside the spec file, let’s first clarify</span><a id="_idIndexMarker1058"/><span class="koboSpan" id="kobo.293.1"> what we want </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">to test.</span></span></p>
<p><span class="koboSpan" id="kobo.295.1">If you look inside your </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">AppComponent</span></strong><span class="koboSpan" id="kobo.297.1"> class, you find two properties: a </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">translationService</span></strong><span class="koboSpan" id="kobo.299.1"> and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">navItems</span></strong><span class="koboSpan" id="kobo.301.1"> property. </span><span class="koboSpan" id="kobo.301.2">Additionally, inside the HTML template of your app component, you’ll find the navbar component with some inputs and an output for when the selected language changes. </span><span class="koboSpan" id="kobo.301.3">As we mentioned before, when writing unit tests, you want to test a single unit of code in isolation—in this case, our app component. </span><span class="koboSpan" id="kobo.301.4">So, what functionalities are related to the </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">app component?</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.303.1">Defining the component </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">class properties.</span></span></li>
<li><span class="koboSpan" id="kobo.305.1">Calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">setActiveLanguage</span></strong><span class="koboSpan" id="kobo.307.1"> method on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">translationService</span></strong><span class="koboSpan" id="kobo.309.1"> property of the navbar to emit a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">languageChange</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.311.1"> event.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.312.1">The aforementioned points are the only component logic related to the app component; checking whether the navbar inputs are correctly handled and whether the navbar renders correctly is logic related to the navbar and should be tested in the spec file of the navbar component. </span><span class="koboSpan" id="kobo.312.2">If we were to check these things inside the spec file of the app component, we would be testing whether the navbar and app components integrate correctly. </span><span class="koboSpan" id="kobo.312.3">For the same reason, we do not check whether </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">TranslationService</span></strong><span class="koboSpan" id="kobo.314.1"> actually adjusts the active language after we call the method. </span><span class="koboSpan" id="kobo.314.2">This would test the integration between the app component and </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">TranslationService</span></strong><span class="koboSpan" id="kobo.316.1">. </span><span class="koboSpan" id="kobo.316.2">From the perspective of the app component, we are only interested if the app component actually makes the function call. </span><span class="koboSpan" id="kobo.316.3">Now we know what we will be testing, let’s define what </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">it()</span></strong><span class="koboSpan" id="kobo.318.1"> statements we will be creating inside our </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">spec file:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.320.1">They should create the component and set the component properties with the </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">expected values.</span></span></li>
<li><span class="koboSpan" id="kobo.322.1">They should call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">setActiveLanguage</span></strong><span class="koboSpan" id="kobo.324.1"> method when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">languageChange</span></strong><span class="koboSpan" id="kobo.326.1"> event </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">is emitted.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.328.1">Now that we have defined the </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">it()</span></strong><span class="koboSpan" id="kobo.330.1"> statements we’re about to define</span><a id="_idIndexMarker1059"/><span class="koboSpan" id="kobo.331.1"> inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">app.component.spec.ts</span></strong><span class="koboSpan" id="kobo.333.1"> file, let’s start to adjust the file step by step so we can actually test these </span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">statements successfully.</span></span></p>
<h3><span class="koboSpan" id="kobo.335.1">Adjusting the code inside the spec file</span></h3>
<p><span class="koboSpan" id="kobo.336.1">We defined the test cases</span><a id="_idIndexMarker1060"/><span class="koboSpan" id="kobo.337.1"> we wanted to write and learned</span><a id="_idIndexMarker1061"/><span class="koboSpan" id="kobo.338.1"> about the three main functions inside the spec files. </span><span class="koboSpan" id="kobo.338.2">Now, let’s write our test cases and learn</span><a id="_idIndexMarker1062"/><span class="koboSpan" id="kobo.339.1"> how to configure your testing modules, make assertions for your test cases, and actually run </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">the tests.</span></span></p>
<h4><span class="koboSpan" id="kobo.341.1">The describe() function</span></h4>
<p><span class="koboSpan" id="kobo.342.1">We will start by removing</span><a id="_idIndexMarker1063"/><span class="koboSpan" id="kobo.343.1"> all the code inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">describe()</span></strong><span class="koboSpan" id="kobo.345.1"> function so we can start fresh. </span><span class="koboSpan" id="kobo.345.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">describe()</span></strong><span class="koboSpan" id="kobo.347.1"> function itself can remain as it was generated for you. </span><span class="koboSpan" id="kobo.347.2">After you remove the generated code, start by defining three properties inside the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">describe()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.349.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.350.1">
let component: AppComponent;
let fixture: ComponentFixture&lt;AppComponent&gt;;
const mockTranslationService = {
  setActiveLanguage: jest.fn(),
  getLanguages: jest.fn().mockReturnValue([]),
};</span></pre> <p><span class="koboSpan" id="kobo.351.1">As you can see in the preceding code snippet, we added </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">component</span></strong><span class="koboSpan" id="kobo.353.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">fixture</span></strong><span class="koboSpan" id="kobo.355.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">mockTranslationService</span></strong><span class="koboSpan" id="kobo.357.1"> properties inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">describe()</span></strong><span class="koboSpan" id="kobo.359.1"> function. </span><span class="koboSpan" id="kobo.359.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">component</span></strong><span class="koboSpan" id="kobo.361.1"> variable will hold an instance of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">AppComponent</span></strong><span class="koboSpan" id="kobo.363.1"> class, </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">fixture</span></strong><span class="koboSpan" id="kobo.365.1"> will be an element containing a test harness that can be used to debug and interact with the app component (the class, native element, element ref, lifecycle methods, etc.), and </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">mockTranslationService</span></strong><span class="koboSpan" id="kobo.367.1"> will be used as a value for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">TranslationService</span></strong><span class="koboSpan" id="kobo.369.1"> injectable we use inside the app component. </span><span class="koboSpan" id="kobo.369.2">We use this mock version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">TranslationService</span></strong><span class="koboSpan" id="kobo.371.1"> to simplify the setup we need to do inside our spec file. </span><span class="koboSpan" id="kobo.371.2">Because we don’t want to test the integration between our app component and </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">TranslationService</span></strong><span class="koboSpan" id="kobo.373.1">, we want to test the app component in isolation. </span><span class="koboSpan" id="kobo.373.2">After you have defined these three properties, it’s time to add the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">before</span><a id="_idTextAnchor211"/><span class="koboSpan" id="kobo.375.1">Each()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.376.1"> function.</span></span></p>
<h4><span class="koboSpan" id="kobo.377.1">The beforeEach() function</span></h4>
<p><span class="koboSpan" id="kobo.378.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">beforeEach()</span></strong><span class="koboSpan" id="kobo.380.1"> function will be added underneath</span><a id="_idIndexMarker1064"/><span class="koboSpan" id="kobo.381.1"> the three properties we added just now and will be used to configure </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">TestBed</span></strong><span class="koboSpan" id="kobo.383.1"> and assign our </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">component</span></strong><span class="koboSpan" id="kobo.385.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">fixture</span></strong><span class="koboSpan" id="kobo.387.1"> properties before each test. </span><span class="koboSpan" id="kobo.387.2">Let’s start simply by defining the </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">beforeEach()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.389.1">method itself:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.390.1">
beforeEach(async () =&gt; {});</span></pre> <p><span class="koboSpan" id="kobo.391.1">Now inside the callback of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">beforeEach()</span></strong><span class="koboSpan" id="kobo.393.1"> function, we start by configuring the testing module using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">TestBed.configureTestingModule()</span></strong><span class="koboSpan" id="kobo.395.1"> method. </span><span class="koboSpan" id="kobo.395.2">The testing module requires everything needed to create our </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">app component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.397.1">
await TestBed.configureTestingModule({
  imports: [AppComponent, RouterTestingModule, getTranslocoModule()],
  providers: [{
      provide: TranslationService,
      useValue: mockTranslationService,
  }]
}).compileComponents();</span></pre> <p><span class="koboSpan" id="kobo.398.1">As you can see in the preceding code, we need to import three classes and define a provider to configure the testing module. </span><span class="koboSpan" id="kobo.398.2">You need to import the </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">AppComponent</span></strong><span class="koboSpan" id="kobo.400.1"> class because </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">AppComponent</span></strong><span class="koboSpan" id="kobo.402.1"> is a standalone component, </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">RouterTestingModule</span></strong><span class="koboSpan" id="kobo.404.1"> because we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">RouterOutlet</span></strong><span class="koboSpan" id="kobo.406.1"> inside the app component template, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">TranslocoTestingModule</span></strong><span class="koboSpan" id="kobo.408.1"> using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">getTranslocoModule()</span></strong><span class="koboSpan" id="kobo.410.1"> function we defined in the </span><em class="italic"><span class="koboSpan" id="kobo.411.1">Adding additional configurations</span></em><span class="koboSpan" id="kobo.412.1"> section of this chapter. </span><span class="koboSpan" id="kobo.412.2">Besides the imports, you need to create a provider for </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">TranslationService</span></strong><span class="koboSpan" id="kobo.414.1"> so that the app component uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">mockTranslationService</span></strong><span class="koboSpan" id="kobo.416.1"> during the tests. </span><span class="koboSpan" id="kobo.416.2">At the end of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">configureTestingModule()</span></strong><span class="koboSpan" id="kobo.418.1"> method, you need to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">compileComponents()</span></strong><span class="koboSpan" id="kobo.420.1"> methods so that Jest will compile everything we defined inside the testing </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">module configuration.</span></span></p>
<p><span class="koboSpan" id="kobo.422.1">After the </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">TestBed</span></strong><span class="koboSpan" id="kobo.424.1"> t</span><a id="_idTextAnchor212"/><span class="koboSpan" id="kobo.425.1">esting module</span><a id="_idIndexMarker1065"/><span class="koboSpan" id="kobo.426.1"> is configured, we will assign the </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">component</span></strong><span class="koboSpan" id="kobo.428.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">fixture</span></strong><span class="koboSpan" id="kobo.430.1"> properties. </span><span class="koboSpan" id="kobo.430.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">fixture</span></strong><span class="koboSpan" id="kobo.432.1"> property will be assigned using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">TestBed.createComponent()</span></strong><span class="koboSpan" id="kobo.434.1"> method. </span><span class="koboSpan" id="kobo.434.2">Calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">createComponent()</span></strong><span class="koboSpan" id="kobo.436.1"> function on </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">TestBed</span></strong><span class="koboSpan" id="kobo.438.1"> will freeze the current </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">TestBed</span></strong><span class="koboSpan" id="kobo.440.1"> class, meaning you can’t call </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">TestBed</span></strong><span class="koboSpan" id="kobo.442.1"> configuration methods anymore. </span><span class="koboSpan" id="kobo.442.2">It will also return a test harness that can be used to interact with the component created inside your </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">test cases:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.444.1">
fixture = TestBed.createComponent(AppComponent);</span></pre> <p><span class="koboSpan" id="kobo.445.1">After assigning </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">fixture</span></strong><span class="koboSpan" id="kobo.447.1">, you assign the </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">component</span></strong><span class="koboSpan" id="kobo.449.1"> variable using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">componentInstance</span></strong><span class="koboSpan" id="kobo.451.1"> property of </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">fixture</span></strong><span class="koboSpan" id="kobo.453.1">. </span><span class="koboSpan" id="kobo.453.2">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">componentInstance</span></strong><span class="koboSpan" id="kobo.455.1"> property is an object containing all the properties and functions of the component you’re testing—in our </span><span class="No-Break"><span class="koboSpan" id="kobo.456.1">case, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">AppComponent</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.459.1">
component = fixture.componentInstance;</span></pre> <p><span class="koboSpan" id="kobo.460.1">Lastly, you need to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">detectChanges()</span></strong><span class="koboSpan" id="kobo.462.1"> method on </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">fixture</span></strong><span class="koboSpan" id="kobo.464.1"> so that change detection will run for the created </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">app component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.466.1">
fixture.detectChanges();</span></pre> <p><span class="koboSpan" id="kobo.467.1">Now that you have defined</span><a id="_idIndexMarker1066"/><span class="koboSpan" id="kobo.468.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">beforeEach()</span></strong><span class="koboSpan" id="kobo.470.1"> function and configured </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">TestBed</span></strong><span class="koboSpan" id="kobo.472.1">, we can start with our first </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">it()</span></strong><span class="koboSpan" id="kobo.474.1"> function and define the first </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">test case.</span></span></p>
<h4><span class="koboSpan" id="kobo.476.1">The first it() function and test case</span></h4>
<p><span class="koboSpan" id="kobo.477.1">You can define</span><a id="_idIndexMarker1067"/><span class="koboSpan" id="kobo.478.1"> your </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">it()</span></strong><span class="koboSpan" id="kobo.480.1"> function</span><a id="_idIndexMarker1068"/><span class="koboSpan" id="kobo.481.1"> underneath the </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">beforeEach()</span></strong><span class="koboSpan" id="kobo.483.1"> function. </span><span class="koboSpan" id="kobo.483.2">In our case, the first test case should test whether the component is successfully created and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">navItems</span></strong><span class="koboSpan" id="kobo.485.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">translationService</span></strong><span class="koboSpan" id="kobo.487.1"> properties are </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">correctly assigned:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.489.1">
it('should create the component and set the component properties with the expected values', () =&gt; {
  expect(component).toBeDefined();
  expect(component.navItems).toEqual([{ label: 'expenses approval', route: '/expenses-approval' }]);
  expect(component[‹translationService›]).toEqual(mockTranslationService);
});</span></pre> <p><span class="koboSpan" id="kobo.490.1">As you can see in the preceding code, we start with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">it()</span></strong><span class="koboSpan" id="kobo.492.1"> function and provide the function with a description. </span><span class="koboSpan" id="kobo.492.2">Then, in the callback function, we assess what we want to test using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">expect()</span></strong><span class="koboSpan" id="kobo.494.1"> function combined with an assertion method. </span><span class="koboSpan" id="kobo.494.2">You provide the </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">expect()</span></strong><span class="koboSpan" id="kobo.496.1"> method with the value you want to test and expect to be or not to be something. </span><span class="koboSpan" id="kobo.496.2">In our case, we first expect the component property (which is assigned without a component instance inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">beforeEach()</span></strong><span class="koboSpan" id="kobo.498.1"> function) to be defined. </span><span class="koboSpan" id="kobo.498.2">Next, we expect the </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">navItems</span></strong><span class="koboSpan" id="kobo.500.1"> property of the component to equal the object we defined inside the component class for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">navItems</span></strong><span class="koboSpan" id="kobo.502.1"> property. </span><span class="koboSpan" id="kobo.502.2">Lastly, we expect </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">translationService</span></strong><span class="koboSpan" id="kobo.504.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.505.1">equal </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">mockTranslationService</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.508.1">Now you have defined the </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">beforeEach()</span></strong><span class="koboSpan" id="kobo.510.1"> function, configured </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">TestBed</span></strong><span class="koboSpan" id="kobo.512.1">, created the component inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">beforeEach()</span></strong><span class="koboSpan" id="kobo.514.1"> function, and written your first testing case. </span><span class="koboSpan" id="kobo.514.2">You can run the test inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">app.component.spec.ts</span></strong><span class="koboSpan" id="kobo.516.1"> file. </span><span class="koboSpan" id="kobo.516.2">You run unit tests by running the following command in the root of your </span><span class="No-Break"><span class="koboSpan" id="kobo.517.1">Nx monorepo:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.518.1">
npx nx run &lt;project-name&gt;:test</span></pre> <p><span class="koboSpan" id="kobo.519.1">In the preceding Terminal command, you need to replace the </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">&lt;project-name&gt;</span></strong><span class="koboSpan" id="kobo.521.1"> placeholder with the actual name of the project you want to run tests for. </span><span class="koboSpan" id="kobo.521.2">You can find the project name inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">project.json</span></strong><span class="koboSpan" id="kobo.523.1"> file of each application or library within your Nx monorepo. </span><span class="koboSpan" id="kobo.523.2">To run the unit tests for a specific file, add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">–test-file</span></strong><span class="koboSpan" id="kobo.525.1"> flag at the end of the command. </span><span class="koboSpan" id="kobo.525.2">For example, to run the unit tests for our </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">app.component.spec.ts</span></strong><span class="koboSpan" id="kobo.527.1"> file, you run the </span><span class="No-Break"><span class="koboSpan" id="kobo.528.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.529.1">
npx nx run finance-expenses-registration:test --test-file=app.component.spec.ts</span></pre> <p><span class="koboSpan" id="kobo.530.1">The preceding command</span><a id="_idIndexMarker1069"/><span class="koboSpan" id="kobo.531.1"> will run the tests</span><a id="_idIndexMarker1070"/><span class="koboSpan" id="kobo.532.1"> inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">app.component.spec.ts</span></strong><span class="koboSpan" id="kobo.534.1"> file. </span><span class="koboSpan" id="kobo.534.2">After running the tests, you’ll notice that your test case is failing with the following error message: </span><strong class="bold"><span class="koboSpan" id="kobo.535.1">Can’t bind to ‘navbarItems’ since it isn’t a known property of ‘bt-libs-navbar’</span></strong><span class="koboSpan" id="kobo.536.1">. </span><span class="koboSpan" id="kobo.536.2">This is because we’re using Angular signal inputs inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">NavbarComponent</span></strong><span class="koboSpan" id="kobo.538.1"> and Jest doesn’t support signal inputs (at the time </span><span class="No-Break"><span class="koboSpan" id="kobo.539.1">of writing).</span></span></p>
<p><span class="koboSpan" id="kobo.540.1">As a workaround, you can create a simplified replica of </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">NavbarComponent</span></strong><span class="koboSpan" id="kobo.542.1"> that is used for unit testing components that use </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">NavbarComponent</span></strong><span class="koboSpan" id="kobo.544.1"> in their template. </span><span class="koboSpan" id="kobo.544.2">Such a replica</span><a id="_idIndexMarker1071"/><span class="koboSpan" id="kobo.545.1"> is commonly named a </span><strong class="bold"><span class="koboSpan" id="kobo.546.1">stub</span></strong><span class="koboSpan" id="kobo.547.1">. </span><span class="koboSpan" id="kobo.547.2">Using a stub component will not only fix the signal input issue but also ensure that you test the </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">AppComponent</span></strong><span class="koboSpan" id="kobo.549.1"> functionality in isolation instead of having it integrated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">NavbarComponent</span></strong><span class="koboSpan" id="kobo.551.1">. </span><span class="koboSpan" id="kobo.551.2">You create the navbar stub component in your </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">common-components</span></strong><span class="koboSpan" id="kobo.553.1"> library inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">navbar</span></strong><span class="koboSpan" id="kobo.555.1"> folder by adding a </span><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">navbar.component.stub.ts</span></strong><span class="koboSpan" id="kobo.557.1"> file with the </span><span class="No-Break"><span class="koboSpan" id="kobo.558.1">following content:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.559.1">
@Component({
  selector: "bt-libs-navbar",
  standalone: true,
  template: ‹›,
})
export class StubNavbarComponent {
  @Input() navbarItems = [];
  @Input() languages = [];
  @Output() languageChange = new EventEmitter();
}</span></pre> <p><span class="koboSpan" id="kobo.560.1">After creating the stub</span><a id="_idIndexMarker1072"/><span class="koboSpan" id="kobo.561.1"> component, export</span><a id="_idIndexMarker1073"/><span class="koboSpan" id="kobo.562.1"> it in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">index.ts</span></strong><span class="koboSpan" id="kobo.564.1"> file of your </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">common-components</span></strong><span class="koboSpan" id="kobo.566.1"> library so you can access the stub component in your spec files. </span><span class="koboSpan" id="kobo.566.2">Now, inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">beforeEach()</span></strong><span class="koboSpan" id="kobo.568.1"> function of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">app.component.spec.ts</span></strong><span class="koboSpan" id="kobo.570.1"> file, you can ensure the app component uses the stub navbar component during the tests instead of the regular navbar component. </span><span class="koboSpan" id="kobo.570.2">You can achieve this by changing the navbar component import for the stub navbar component using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">TestBed.overrideComponent()</span></strong><span class="koboSpan" id="kobo.572.1"> method. </span><span class="koboSpan" id="kobo.572.2">You need to simply remove the </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">NavbarComponent</span></strong><span class="koboSpan" id="kobo.574.1"> import and add the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">StubNavbarComponent</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.576.1"> import:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.577.1">
TestBed.overrideComponent(AppComponent, {
  add: {
    imports: [</span><strong class="bold"><span class="koboSpan" id="kobo.578.1">StubNavbarComponent</span></strong><span class="koboSpan" id="kobo.579.1">],
  },
  remove: {
    imports: [</span><strong class="bold"><span class="koboSpan" id="kobo.580.1">NavbarComponent</span></strong><span class="koboSpan" id="kobo.581.1">],
  },
});</span></pre> <p><span class="koboSpan" id="kobo.582.1">As you can see in the preceding code, we remove the </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">NavbarComponent</span></strong><span class="koboSpan" id="kobo.584.1"> import from </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">AppComponent</span></strong><span class="koboSpan" id="kobo.586.1"> and add </span><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">StubNavbarComponent</span></strong><span class="koboSpan" id="kobo.588.1">. </span><span class="koboSpan" id="kobo.588.2">It’s important that you overwrite the component imports before you call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">TestBed.createComponent()</span></strong><span class="koboSpan" id="kobo.590.1"> method and freeze </span><strong class="source-inline"><span class="koboSpan" id="kobo.591.1">TestBed</span></strong><span class="koboSpan" id="kobo.592.1">; otherwise, your override will not be included </span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">TestBed</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.595.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.596.1">Using stub components and services can be helpful in cases like this, where Jest still needs to add support for specific features. </span><span class="koboSpan" id="kobo.596.2">Additionally, stubs ensure that you’re not integration testing but focusing on units of code in isolation. </span><span class="koboSpan" id="kobo.596.3">If you want to unit test the navbar, for example, you should do so in the spec file of the navbar component and not in the spec file of the app component. </span><span class="koboSpan" id="kobo.596.4">Additionally, using stub components can simplify the setup you need in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">beforeEach()</span></strong><span class="koboSpan" id="kobo.598.1"> method to ensure Jest can create the component or service you want to </span><span class="No-Break"><span class="koboSpan" id="kobo.599.1">unit test.</span></span></p>
<p><span class="koboSpan" id="kobo.600.1">Suppose you rerun the app component</span><a id="_idIndexMarker1074"/><span class="koboSpan" id="kobo.601.1"> unit tests after adding the stub navbar</span><a id="_idIndexMarker1075"/><span class="koboSpan" id="kobo.602.1"> component. </span><span class="koboSpan" id="kobo.602.2">In that case, you’ll see that the test case we defined in the spec file is passing, meaning the test successfully creates </span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">componentInstance</span></strong><span class="koboSpan" id="kobo.604.1">. </span><span class="koboSpan" id="kobo.604.2">Still, the test run fails because we don’t meet the configured coverage requirements of 80%. </span><span class="koboSpan" id="kobo.604.3">If you look at the coverage report in your terminal, you’ll see that the coverages of your </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">app.component.ts</span></strong><span class="koboSpan" id="kobo.606.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">app.component.html</span></strong><span class="koboSpan" id="kobo.608.1"> files are 100%, but the coverage of your </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">translation.service.ts</span></strong><span class="koboSpan" id="kobo.610.1"> file is 0%, bringing the total testing coverage under the </span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">required 80%.</span></span></p>
<p><span class="koboSpan" id="kobo.612.1">So, why is the testing coverage including </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">translation.service.ts</span></strong><span class="koboSpan" id="kobo.614.1">, and should you care? </span><span class="koboSpan" id="kobo.614.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">translation.service.ts</span></strong><span class="koboSpan" id="kobo.616.1"> file is included in your coverage report because, by default, Jest (and other test runners) will consist of all files in the coverage report you import and use within the class you’re testing—in this case, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">AppComponent</span></strong><span class="koboSpan" id="kobo.618.1"> class. </span><span class="koboSpan" id="kobo.618.2">Should you care, and do you need to fix this shortfall in your </span><span class="No-Break"><span class="koboSpan" id="kobo.619.1">coverage percentage?</span></span></p>
<p><span class="koboSpan" id="kobo.620.1">The answer is it depends on how you run the tests. </span><span class="koboSpan" id="kobo.620.2">If you’re running the tests for a single file, as we are doing now, you shouldn’t care and should only focus on the files related to the unit you’re testing—in our case, the app component. </span><span class="koboSpan" id="kobo.620.3">After all, you want to write shallow unit tests that only test a single unit of code in isolation, so if you have a testing coverage of 80% or higher for the files related to the unit you’re testing, everything is good! </span><span class="koboSpan" id="kobo.620.4">However, if you’re running the unit test for an entire project by omitting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">–test-file</span></strong><span class="koboSpan" id="kobo.622.1"> flag, you should care about the coverage percentage. </span><span class="koboSpan" id="kobo.622.2">For your entire project, you should have enough coverage. </span><span class="koboSpan" id="kobo.622.3">In this example, the code related to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">translation.service.ts</span></strong><span class="koboSpan" id="kobo.624.1"> file should be tested in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">translation.service.spec.ts</span></strong><span class="koboSpan" id="kobo.626.1"> file. </span><span class="koboSpan" id="kobo.626.2">If you run the unit tests for the entire project and you cover the logic of your </span><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">translation.service.ts</span></strong><span class="koboSpan" id="kobo.628.1"> file inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">translation.service.spec.ts</span></strong><span class="koboSpan" id="kobo.630.1"> file, you will not have the shortfall </span><a id="_idIndexMarker1076"/><span class="koboSpan" id="kobo.631.1">in your coverage report and the test</span><a id="_idIndexMarker1077"/><span class="koboSpan" id="kobo.632.1"> run will succeed. </span><span class="koboSpan" id="kobo.632.2">Now that we have clarified that, let’s add our second </span><strong class="source-inline"><span class="koboSpan" id="kobo.633.1">it()</span></strong><span class="koboSpan" id="kobo.634.1"> function </span><span class="No-Break"><span class="koboSpan" id="kobo.635.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">app.component.spec.ts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.637.1">.</span></span></p>
<h4><span class="koboSpan" id="kobo.638.1">The second it() function</span></h4>
<p><span class="koboSpan" id="kobo.639.1">While we have 100% testing coverage</span><a id="_idIndexMarker1078"/><span class="koboSpan" id="kobo.640.1"> for our app-component-related files, our test might not give us the confidence we need that everything works as expected. </span><span class="koboSpan" id="kobo.640.2">We don’t test whether the app component class calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.641.1">setActiveLanguage</span></strong><span class="koboSpan" id="kobo.642.1"> method when the navbar emits a </span><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">languageChange</span></strong><span class="koboSpan" id="kobo.644.1"> event, so let’s add a test for this. </span><span class="koboSpan" id="kobo.644.2">You can add the following code to test whether the app component calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">setActiveLanguage</span></strong><span class="koboSpan" id="kobo.646.1"> method when it receives the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.647.1">languageChange</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.648.1"> event:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.649.1">
it('should call the setActiveLanguage method when the languageChange event is emitted', () =&gt; {
  const setActiveLanguage = jest.spyOn(component['translationService'], 'setActiveLanguage');
  const navbarElement = fixture.debugElement.query(By.directive(StubNavbarComponent));
  navbarElement.triggerEventHandler('languageChange', 'nl');
  expect(setActiveLanguage).toHaveBeenCalledWith('nl');
});</span></pre> <p><span class="koboSpan" id="kobo.650.1">In the preceding code, quite a lot is happening, so let’s examine each </span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">line carefully.</span></span></p>
<p><span class="koboSpan" id="kobo.652.1">First, we define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.653.1">it()</span></strong><span class="koboSpan" id="kobo.654.1"> function and provide it with a description of our test case. </span><span class="koboSpan" id="kobo.654.2">Inside the callback function, we start by creating a </span><span class="No-Break"><span class="koboSpan" id="kobo.655.1">spy element.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.656.1">Spy elements</span></strong><span class="koboSpan" id="kobo.657.1"> are commonly used to spy on a specific function</span><a id="_idIndexMarker1079"/><span class="koboSpan" id="kobo.658.1"> and check whether the spied-on function is called, how many times, and with what parameters. </span><span class="koboSpan" id="kobo.658.2">We will use our spy element to check whether the </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">setActiveLanguage</span></strong><span class="koboSpan" id="kobo.660.1"> method of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">translationService</span></strong><span class="koboSpan" id="kobo.662.1"> property is called. </span><span class="koboSpan" id="kobo.662.2">Create the spy object by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">jest.spyOn()</span></strong><span class="koboSpan" id="kobo.664.1"> function. </span><span class="koboSpan" id="kobo.664.2">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">jest.spyOn()</span></strong><span class="koboSpan" id="kobo.666.1"> function, first provide the object containing the function you want to spy on and then, as a string, the function name you want to </span><span class="No-Break"><span class="koboSpan" id="kobo.667.1">spy on.</span></span></p>
<p><span class="koboSpan" id="kobo.668.1">After creating the spy object, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">debugElement</span></strong><span class="koboSpan" id="kobo.670.1"> of </span><strong class="source-inline"><span class="koboSpan" id="kobo.671.1">fixture</span></strong><span class="koboSpan" id="kobo.672.1"> to access </span><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">StubNavbarComponent</span></strong><span class="koboSpan" id="kobo.674.1"> inside our HTML template and save it in a constant named </span><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">navBarElement</span></strong><span class="koboSpan" id="kobo.676.1">. </span><span class="koboSpan" id="kobo.676.2">Next, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.677.1">triggerEventHandler</span></strong><span class="koboSpan" id="kobo.678.1"> method on </span><strong class="source-inline"><span class="koboSpan" id="kobo.679.1">navBarElement</span></strong><span class="koboSpan" id="kobo.680.1"> to trigger the </span><strong class="source-inline"><span class="koboSpan" id="kobo.681.1">languageChange</span></strong><span class="koboSpan" id="kobo.682.1"> event and provide </span><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">nl</span></strong><span class="koboSpan" id="kobo.684.1"> as the </span><span class="No-Break"><span class="koboSpan" id="kobo.685.1">event data.</span></span></p>
<p><span class="koboSpan" id="kobo.686.1">After triggering the </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">languageChange</span></strong><span class="koboSpan" id="kobo.688.1"> event, we expect that </span><strong class="source-inline"><span class="koboSpan" id="kobo.689.1">setActiveLanguage()</span></strong><span class="koboSpan" id="kobo.690.1"> is called with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">nl</span></strong><span class="koboSpan" id="kobo.692.1"> parameter. </span><span class="koboSpan" id="kobo.692.2">We check whether this is correct by providing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">expect()</span></strong><span class="koboSpan" id="kobo.694.1"> function with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">setActiveLanguage</span></strong><span class="koboSpan" id="kobo.696.1"> spy object and calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">toHaveBeenCalledWith('nl')</span></strong><span class="koboSpan" id="kobo.698.1"> assertion method on the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">expect()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.700.1"> function.</span></span></p>
<p><span class="koboSpan" id="kobo.701.1">After adding your second testing case to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">app.component.spec.ts</span></strong><span class="koboSpan" id="kobo.703.1"> file, you can run the tests again, and you’ll notice that both test cases </span><span class="No-Break"><span class="koboSpan" id="kobo.704.1">are successful.</span></span></p>
<p><span class="koboSpan" id="kobo.705.1">To summarize, you learned that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">describe()</span></strong><span class="koboSpan" id="kobo.707.1"> function is used to group test cases and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.708.1">beforeEach()</span></strong><span class="koboSpan" id="kobo.709.1"> function is used to configure </span><strong class="source-inline"><span class="koboSpan" id="kobo.710.1">TestBed</span></strong><span class="koboSpan" id="kobo.711.1"> and define values before each test case runs. </span><span class="koboSpan" id="kobo.711.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.712.1">it()</span></strong><span class="koboSpan" id="kobo.713.1"> functions are used to define your test cases, and inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">it()</span></strong><span class="koboSpan" id="kobo.715.1"> functions, you use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.716.1">expect()</span></strong><span class="koboSpan" id="kobo.717.1"> function combined with assertion methods to perform your test statements. </span><span class="koboSpan" id="kobo.717.2">You can create and use spy objects to validate whether functions are called. </span><span class="koboSpan" id="kobo.717.3">When writing unit tests, you should write shallow unit tests that focus on a single unit of code instead of testing the integration of different components and services. </span><span class="koboSpan" id="kobo.717.4">You can write shallow unit tests and prevent issues with unsupported features by creating stub components and services, which are simplified replicas used within your </span><span class="No-Break"><span class="koboSpan" id="kobo.718.1">unit tests.</span></span></p>
<p><span class="koboSpan" id="kobo.719.1">Now that you have a better understanding of unit tests and you’ve created your first tests, we will fix the additional spec files of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.720.1">expenses-registration</span></strong><span class="koboSpan" id="kobo.721.1"> component so we can do a successful test run for the application. </span><span class="koboSpan" id="kobo.721.2">Additionally, you will learn how to run unit tests</span><a id="_idIndexMarker1080"/><span class="koboSpan" id="kobo.722.1"> for multiple projects in your </span><span class="No-Break"><span class="koboSpan" id="kobo.723.1">Nx monorepo.</span></span></p>
<h2 id="_idParaDest-194"><a id="_idTextAnchor213"/><span class="koboSpan" id="kobo.724.1">Adding additional unit tests for the expenses-registration application</span></h2>
<p><span class="koboSpan" id="kobo.725.1">We will now start writing</span><a id="_idIndexMarker1081"/><span class="koboSpan" id="kobo.726.1"> some additional unit tests</span><a id="_idIndexMarker1082"/><span class="koboSpan" id="kobo.727.1"> for the </span><em class="italic"><span class="koboSpan" id="kobo.728.1">expenses-registration application</span></em><span class="koboSpan" id="kobo.729.1"> so you can successfully run the unit tests for the entire application without specifying the </span><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">–test-file</span></strong><span class="koboSpan" id="kobo.731.1"> flag. </span><span class="koboSpan" id="kobo.731.2">To start, we will remove the </span><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">expenses-approval-page.component.spec.ts</span></strong><span class="koboSpan" id="kobo.733.1"> file because we haven’t added any code yet inside the expenses approval component. </span><span class="koboSpan" id="kobo.733.2">After removing </span><strong class="source-inline"><span class="koboSpan" id="kobo.734.1">expenses-approval-page.component.spec.ts</span></strong><span class="koboSpan" id="kobo.735.1">, we will adjust the tests inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.736.1">expenses-overview-page.component.spec.ts</span></strong><span class="koboSpan" id="kobo.737.1">. </span><span class="koboSpan" id="kobo.737.2">We made quite some adjustments to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.738.1">ExpensesOverviewPageComponent</span></strong><span class="koboSpan" id="kobo.739.1"> class, so fixing the related spec file will be a bit more work compared to the spec file </span><span class="No-Break"><span class="koboSpan" id="kobo.740.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.741.1">AppComponent</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.742.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.743.1">Let’s start by running the unit tests with the following command and see what </span><span class="No-Break"><span class="koboSpan" id="kobo.744.1">pops up:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.745.1">
npx nx run finance-expenses-registration:test --test-file=expenses-overview-page.component.spec.ts</span></pre> <p><span class="koboSpan" id="kobo.746.1">It might come as no surprise that the test run fails. </span><span class="koboSpan" id="kobo.746.2">Let’s fix the issues with the spec file one by one, starting with the import of </span><strong class="source-inline"><span class="koboSpan" id="kobo.747.1">ExpensesOverviewPageComponent</span></strong><span class="koboSpan" id="kobo.748.1"> inside the </span><span class="No-Break"><span class="koboSpan" id="kobo.749.1">spec file.</span></span></p>
<h3><span class="koboSpan" id="kobo.750.1">Adjusting the code inside our other spec file</span></h3>
<p><span class="koboSpan" id="kobo.751.1">Because we changed</span><a id="_idIndexMarker1083"/><span class="koboSpan" id="kobo.752.1"> the export of </span><strong class="source-inline"><span class="koboSpan" id="kobo.753.1">ExpensesOverviewPageComponent</span></strong><span class="koboSpan" id="kobo.754.1"> to a default export, we also need to adjust the import inside the </span><span class="No-Break"><span class="koboSpan" id="kobo.755.1">spec file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.756.1">
import ExpensesOverviewPageComponent from './expenses-overview-page.component';</span></pre> <p><span class="koboSpan" id="kobo.757.1">After changing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.758.1">import</span></strong><span class="koboSpan" id="kobo.759.1"> statement, you need to adjust the spec file so </span><strong class="source-inline"><span class="koboSpan" id="kobo.760.1">TestBed</span></strong><span class="koboSpan" id="kobo.761.1"> can successfully create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.762.1">expenses-overview</span></strong><span class="koboSpan" id="kobo.763.1"> component. </span><span class="koboSpan" id="kobo.763.2">Just like the app component, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.764.1">expenses-overview</span></strong><span class="koboSpan" id="kobo.765.1"> component uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.766.1">TranslationService</span></strong><span class="koboSpan" id="kobo.767.1">, so we will make a mock object for this service (alternatively, you can create a stub service for it and also use that inside the spec file of the </span><span class="No-Break"><span class="koboSpan" id="kobo.768.1">app component):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.769.1">
const mockTranslationService = {
  translocoService: { translate: jest.fn() },
  translationsLoaded: signal(false) as WritableSignal&lt;boolean&gt;,
};</span></pre> <p><span class="koboSpan" id="kobo.770.1">As you can see in the preceding code, </span><strong class="source-inline"><span class="koboSpan" id="kobo.771.1">mockTranslationService</span></strong><span class="koboSpan" id="kobo.772.1"> for this spec file differs from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.773.1">mockTranslationService</span></strong><span class="koboSpan" id="kobo.774.1"> class we created for the spec file of the app component. </span><span class="koboSpan" id="kobo.774.2">The mock objects</span><a id="_idIndexMarker1084"/><span class="koboSpan" id="kobo.775.1"> differ because we only include what we use inside the component we are about to test in the mock object; in this case, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.776.1">expenses-overview</span></strong><span class="koboSpan" id="kobo.777.1"> component only uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.778.1">translocoService</span></strong><span class="koboSpan" id="kobo.779.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.780.1">translationsLoaded</span></strong><span class="koboSpan" id="kobo.781.1"> properties of the service. </span><span class="koboSpan" id="kobo.781.2">Besides </span><strong class="source-inline"><span class="koboSpan" id="kobo.782.1">mockTranslationService</span></strong><span class="koboSpan" id="kobo.783.1">, we also need a stub for </span><strong class="source-inline"><span class="koboSpan" id="kobo.784.1">ExpensesFacade</span></strong><span class="koboSpan" id="kobo.785.1">. </span><span class="koboSpan" id="kobo.785.2">You can copy </span><strong class="source-inline"><span class="koboSpan" id="kobo.786.1">StubExpensesFacade</span></strong><span class="koboSpan" id="kobo.787.1"> from the GitHub repository for this book. </span><span class="koboSpan" id="kobo.787.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.788.1">expenses.facade.stub.ts</span></strong><span class="koboSpan" id="kobo.789.1"> file is located next to the regular </span><strong class="source-inline"><span class="koboSpan" id="kobo.790.1">expenses.facade.ts</span></strong><span class="koboSpan" id="kobo.791.1"> file inside the finance </span><strong class="source-inline"><span class="koboSpan" id="kobo.792.1">data-access</span></strong><span class="koboSpan" id="kobo.793.1"> library. </span><span class="koboSpan" id="kobo.793.2">After creating the mock and stub objects we need for our unit tests, we can create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.794.1">beforeEach()</span></strong><span class="koboSpan" id="kobo.795.1"> function and set </span><span class="No-Break"><span class="koboSpan" id="kobo.796.1">up </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.797.1">TestBed</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.798.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.799.1">
beforeEach(async () =&gt; {
  await TestBed.configureTestingModule({
    imports: [ExpensesOverviewPageComponent, getTranslocoModule()],
    providers: [
      { provide: ExpensesFacade, useClass: StubExpensesFacade },
      { provide: TranslationService, useValue: mockTranslationService, },
      provideTranslocoLocale({
        langToLocaleMapping: { en: 'en-US', nl: 'nl-NL' }
      })
    ]
  }).compileComponents();
  fixture = TestBed.createComponent(ExpensesOverviewPageComponent);
  component = fixture.componentInstance;
  fixture.detectChanges();
});</span></pre> <p><span class="koboSpan" id="kobo.800.1">As you can see in the preceding code, we import </span><strong class="source-inline"><span class="koboSpan" id="kobo.801.1">ExpensesOverviewPageComponent</span></strong><span class="koboSpan" id="kobo.802.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.803.1">TranslocoTestingModule</span></strong><span class="koboSpan" id="kobo.804.1"> using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.805.1">getTranslocoModule()</span></strong><span class="koboSpan" id="kobo.806.1"> function. </span><span class="koboSpan" id="kobo.806.2">After the imports for the testing module, we added some providers that needed to configure the testing module. </span><span class="koboSpan" id="kobo.806.3">We provide </span><strong class="source-inline"><span class="koboSpan" id="kobo.807.1">ExpensesFacade</span></strong><span class="koboSpan" id="kobo.808.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.809.1">TranslationService</span></strong><span class="koboSpan" id="kobo.810.1"> with the mock and stub values, and we provide the </span><strong class="source-inline"><span class="koboSpan" id="kobo.811.1">TranslocoLocale</span></strong><span class="koboSpan" id="kobo.812.1"> configuration because we use the localization pipes inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.813.1">expenses-overview</span></strong><span class="koboSpan" id="kobo.814.1"> page. </span><span class="koboSpan" id="kobo.814.2">After configuring the imports and providers for the testing module, we created and assigned the </span><strong class="source-inline"><span class="koboSpan" id="kobo.815.1">fixture</span></strong><span class="koboSpan" id="kobo.816.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.817.1">component</span></strong><span class="koboSpan" id="kobo.818.1"> properties and called </span><strong class="source-inline"><span class="koboSpan" id="kobo.819.1">detectChanges()</span></strong><span class="koboSpan" id="kobo.820.1"> on </span><strong class="source-inline"><span class="koboSpan" id="kobo.821.1">fixture</span></strong><span class="koboSpan" id="kobo.822.1">. </span><span class="koboSpan" id="kobo.822.2">Now we have configured everything needed to create the component inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.823.1">TestBed</span></strong><span class="koboSpan" id="kobo.824.1">, let’s remove all </span><strong class="source-inline"><span class="koboSpan" id="kobo.825.1">it()</span></strong><span class="koboSpan" id="kobo.826.1"> functions</span><a id="_idIndexMarker1085"/><span class="koboSpan" id="kobo.827.1"> and write our own </span><span class="No-Break"><span class="koboSpan" id="kobo.828.1">test cases.</span></span></p>
<h3><span class="koboSpan" id="kobo.829.1">Writing the test cases</span></h3>
<p><span class="koboSpan" id="kobo.830.1">We will create</span><a id="_idIndexMarker1086"/><span class="koboSpan" id="kobo.831.1"> the following </span><span class="No-Break"><span class="koboSpan" id="kobo.832.1">test cases:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.833.1">The test should create the component and initialize the </span><span class="No-Break"><span class="koboSpan" id="kobo.834.1">properties correctly.</span></span></li>
<li><span class="koboSpan" id="kobo.835.1">It should fetch expenses </span><span class="No-Break"><span class="koboSpan" id="kobo.836.1">on </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.837.1">init</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.838.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.839.1">It should translate the title if translations </span><span class="No-Break"><span class="koboSpan" id="kobo.840.1">are loaded.</span></span></li>
<li><span class="koboSpan" id="kobo.841.1">It should change </span><strong class="source-inline"><span class="koboSpan" id="kobo.842.1">summaryBtnText</span></strong><span class="koboSpan" id="kobo.843.1"> if </span><strong class="source-inline"><span class="koboSpan" id="kobo.844.1">onSummaryChange</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.845.1">is called.</span></span></li>
<li><span class="koboSpan" id="kobo.846.1">It should call </span><strong class="source-inline"><span class="koboSpan" id="kobo.847.1">addExpense</span></strong><span class="koboSpan" id="kobo.848.1"> on the expenses facade with the correct values when </span><strong class="source-inline"><span class="koboSpan" id="kobo.849.1">onAddExpense</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.850.1">is called.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.851.1">Now that we have defined our test cases, let’s create them one </span><span class="No-Break"><span class="koboSpan" id="kobo.852.1">by one:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.853.1">
it('should create the component and initialize the properties correctly', () =&gt; {
  expect(component).toBeTruthy();
  expect(component[‹expensesFacade›]).toBeInstanceOf(StubExpensesFacade);
  expect(component[‹translationService›]).toEqual(mockTranslationService);
  expect(component.translationEventsEffect).toBeDefined();
  expect(component.expenses()).toEqual(component[‹expensesFacade›].expenses());
  expect(component.showAddExpenseModal()).toBeFalsy();
  expect(component.showSummary()).toBeFalsy();
  expect(component.summaryBtnText()).toEqual('Show summary');
});</span></pre> <p><span class="koboSpan" id="kobo.854.1">As you can see in the preceding</span><a id="_idIndexMarker1087"/><span class="koboSpan" id="kobo.855.1"> code, this test is really straightforward; we simply check whether the component variable is defined and whether each component property is initialized with the value we expect. </span><span class="koboSpan" id="kobo.855.2">As you may have noticed, we used some new assertion methods here, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.856.1">toBeFalsy()</span></strong><span class="koboSpan" id="kobo.857.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.858.1">toBeInstanceOf()</span></strong><span class="koboSpan" id="kobo.859.1">. </span><span class="koboSpan" id="kobo.859.2">These assertion methods can be used to check whether a value is false in a Boolean context and whether an object is an instance of a specific class. </span><span class="koboSpan" id="kobo.859.3">Besides </span><strong class="source-inline"><span class="koboSpan" id="kobo.860.1">toBeFalsy()</span></strong><span class="koboSpan" id="kobo.861.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.862.1">toBeInstanceOf()</span></strong><span class="koboSpan" id="kobo.863.1">, we did nothing new in this test, so let’s move on to our next </span><span class="No-Break"><span class="koboSpan" id="kobo.864.1">test case:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.865.1">
it('should fetch expenses on init', () =&gt; {
  const fetchExpenses = jest.spyOn(component['expensesFacade'], 'fetchExpenses');
  component.ngOnInit();
  expect(fetchExpenses).toHaveBeenCalled();
});</span></pre> <p><span class="koboSpan" id="kobo.866.1">In the preceding test, we create a spy object to spy on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.867.1">fetchExpenses()</span></strong><span class="koboSpan" id="kobo.868.1"> function of </span><strong class="source-inline"><span class="koboSpan" id="kobo.869.1">ExpensesFacade</span></strong><span class="koboSpan" id="kobo.870.1">. </span><span class="koboSpan" id="kobo.870.2">After that, we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.871.1">ngOnInit()</span></strong><span class="koboSpan" id="kobo.872.1"> for the component we are testing—in this case, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.873.1">expenses-overview</span></strong><span class="koboSpan" id="kobo.874.1"> page component—and at the end of our test, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.875.1">expect()</span></strong><span class="koboSpan" id="kobo.876.1"> function to check whether the </span><strong class="source-inline"><span class="koboSpan" id="kobo.877.1">fetchExpenses()</span></strong><span class="koboSpan" id="kobo.878.1"> function is called. </span><span class="koboSpan" id="kobo.878.2">As you can see, calling a method declared in the component we are testing is super straightforward; you simply use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.879.1">component</span></strong><span class="koboSpan" id="kobo.880.1"> variable and call the method you want to run. </span><span class="koboSpan" id="kobo.880.2">Now that we’ve also covered this test, let’s move on to the next test case </span><span class="No-Break"><span class="koboSpan" id="kobo.881.1">we defined:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.882.1">
it('should translate title if translations are loaded', fakeAsync(() =&gt; {
  const translateSpy = jest.spyOn(component['translationService'].translocoService, 'translate');
  expect(component[‹translationService›].translationsLoaded()).toBeFalsy();
  expect(translateSpy).not.toHaveBeenCalled();
  mockTranslationService.translationsLoaded.set(true);
  tick();
  expect(translateSpy).toHaveBeenCalledWith(‹expenses_overview_page.title›);
}));</span></pre> <p><span class="koboSpan" id="kobo.883.1">In the preceding test, a bit more</span><a id="_idIndexMarker1088"/><span class="koboSpan" id="kobo.884.1"> is going on, and we used some new techniques. </span><span class="koboSpan" id="kobo.884.2">Let’s explore what we do here in more detail. </span><span class="koboSpan" id="kobo.884.3">Because we are testing a signal effect in this test and signal effect are asynchronous, we wrapped the callback of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.885.1">it()</span></strong><span class="koboSpan" id="kobo.886.1"> function inside a </span><strong class="source-inline"><span class="koboSpan" id="kobo.887.1">fakeAsync()</span></strong><span class="koboSpan" id="kobo.888.1"> function. </span><span class="koboSpan" id="kobo.888.2">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.889.1">fakeAsync()</span></strong><span class="koboSpan" id="kobo.890.1"> function, times are synchronous. </span><span class="koboSpan" id="kobo.890.2">You can manually execute microtasks by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.891.1">flushMicroTasks()</span></strong><span class="koboSpan" id="kobo.892.1"> and simulating time passing with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.893.1">tick()</span></strong><span class="koboSpan" id="kobo.894.1"> function. </span><span class="koboSpan" id="kobo.894.2">After using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.895.1">fakeAsync()</span></strong><span class="koboSpan" id="kobo.896.1"> function, we first define a spy object. </span><span class="koboSpan" id="kobo.896.2">Then, we check whether the </span><strong class="source-inline"><span class="koboSpan" id="kobo.897.1">translationsLoaded</span></strong><span class="koboSpan" id="kobo.898.1"> signal has a false value and that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.899.1">translate()</span></strong><span class="koboSpan" id="kobo.900.1"> function that we use inside our signal effect isn’t called. </span><span class="koboSpan" id="kobo.900.2">Next, we set the value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.901.1">translationsLoaded</span></strong><span class="koboSpan" id="kobo.902.1"> signal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.903.1">true</span></strong><span class="koboSpan" id="kobo.904.1">. </span><span class="koboSpan" id="kobo.904.2">This should trigger the signal effect again, and this time, we should reach the part where we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.905.1">translate()</span></strong><span class="koboSpan" id="kobo.906.1"> function. </span><span class="koboSpan" id="kobo.906.2">Because the signal effect is asynchronous, we first call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.907.1">tick()</span></strong><span class="koboSpan" id="kobo.908.1"> function to simulate the passing of time, and after that, we check whether our spy object is called with the correct </span><span class="No-Break"><span class="koboSpan" id="kobo.909.1">translation key.</span></span></p>
<p><span class="koboSpan" id="kobo.910.1">Now that we have explained the </span><strong class="source-inline"><span class="koboSpan" id="kobo.911.1">fakeAsync()</span></strong><span class="koboSpan" id="kobo.912.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.913.1">tick()</span></strong><span class="koboSpan" id="kobo.914.1"> functions used in our last test case, let’s continue and add the next </span><span class="No-Break"><span class="koboSpan" id="kobo.915.1">test case:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.916.1">
it('should change the summaryBtnText if onSummaryChange is called', () =&gt; {
  expect(component.showSummary()).toBeFalsy();
  expect(component.summaryBtnText()).toEqual('Show summary');
  component.onSummaryChange();
  expect(component.showSummary()).toBeTruthy();
  expect(component.summaryBtnText()).toEqual('Hide summary');
});</span></pre> <p><span class="koboSpan" id="kobo.917.1">As you can see in the preceding</span><a id="_idIndexMarker1089"/><span class="koboSpan" id="kobo.918.1"> code, this is a simple test. </span><span class="koboSpan" id="kobo.918.2">We first check whether the </span><strong class="source-inline"><span class="koboSpan" id="kobo.919.1">showSummary</span></strong><span class="koboSpan" id="kobo.920.1"> signal is false and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.921.1">summaryBtnText</span></strong><span class="koboSpan" id="kobo.922.1"> computed signal returns </span><strong class="bold"><span class="koboSpan" id="kobo.923.1">Show summary</span></strong><span class="koboSpan" id="kobo.924.1">. </span><span class="koboSpan" id="kobo.924.2">Next, we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.925.1">onSummaryChange()</span></strong><span class="koboSpan" id="kobo.926.1"> function and check whether the </span><strong class="source-inline"><span class="koboSpan" id="kobo.927.1">showSummary</span></strong><span class="koboSpan" id="kobo.928.1"> signal and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.929.1">summaryBtnText</span></strong><span class="koboSpan" id="kobo.930.1"> computed signal are adjusted correctly. </span><span class="koboSpan" id="kobo.930.2">After adding the preceding test, there is only one test case to add to our </span><span class="No-Break"><span class="koboSpan" id="kobo.931.1">spec file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.932.1">
it('should call addExpense on the expenses facade with the correct values when onAddExpense is called', () =&gt; {
  const addExpense = jest.spyOn(component['expensesFacade'], 'addExpense');
  const expenseToAdd = { description: 'test', amount: { value: 50, vatPercentage: 20 }, date: '2019-01-04', tags: ['printer'], id: 999 };
  component.onAddExpense(expenseToAdd);
  expect(addExpense).toHaveBeenCalledWith(expenseToAdd);
  expect(component.expenses().expenses).toContainEqual(expenseToAdd);
});</span></pre> <p><span class="koboSpan" id="kobo.933.1">In the preceding test, we first create a spy object to spy on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.934.1">addExpense()</span></strong><span class="koboSpan" id="kobo.935.1"> function of </span><strong class="source-inline"><span class="koboSpan" id="kobo.936.1">ExpensesFacade</span></strong><span class="koboSpan" id="kobo.937.1">. </span><span class="koboSpan" id="kobo.937.2">After creating the spy object, we create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.938.1">expense</span></strong><span class="koboSpan" id="kobo.939.1"> object to provide to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.940.1">onAddExpense()</span></strong><span class="koboSpan" id="kobo.941.1"> method. </span><span class="koboSpan" id="kobo.941.2">After creating </span><strong class="source-inline"><span class="koboSpan" id="kobo.942.1">expense</span></strong><span class="koboSpan" id="kobo.943.1">, we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.944.1">onAddExpense()</span></strong><span class="koboSpan" id="kobo.945.1"> method and provide it with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.946.1">expenseToAdd</span></strong><span class="koboSpan" id="kobo.947.1"> property. </span><span class="koboSpan" id="kobo.947.2">After we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.948.1">onAddExpense()</span></strong><span class="koboSpan" id="kobo.949.1"> method, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.950.1">addExpense()</span></strong><span class="koboSpan" id="kobo.951.1"> function of the facade should be called with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.952.1">expenseToAdd</span></strong><span class="koboSpan" id="kobo.953.1"> property as a function parameter. </span><span class="koboSpan" id="kobo.953.2">We verify that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.954.1">addExpense()</span></strong><span class="koboSpan" id="kobo.955.1"> function is called with the correct parameter using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.956.1">toHaveBeenCalledWith()</span></strong><span class="koboSpan" id="kobo.957.1"> assertion method. </span><span class="koboSpan" id="kobo.957.2">Lastly, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.958.1">toContainEqual()</span></strong><span class="koboSpan" id="kobo.959.1"> assertion method to check whether </span><strong class="source-inline"><span class="koboSpan" id="kobo.960.1">expense</span></strong><span class="koboSpan" id="kobo.961.1"> is added to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.962.1">expenses</span></strong><span class="koboSpan" id="kobo.963.1"> signal of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.964.1">expenses-overview</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.965.1">page component.</span></span></p>
<p><span class="koboSpan" id="kobo.966.1">After adding the last test</span><a id="_idIndexMarker1090"/><span class="koboSpan" id="kobo.967.1"> case, you can run the tests again using the </span><span class="No-Break"><span class="koboSpan" id="kobo.968.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.969.1">
npx nx run finance-expenses-registration:test --test-file=expenses-overview-page.component.spec.ts</span></pre> <p><span class="koboSpan" id="kobo.970.1">After you run the tests again, you’ll find that all tests are passing and you have 100% coverage for the files related to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.971.1">expenses-overview</span></strong><span class="koboSpan" id="kobo.972.1"> component. </span><span class="koboSpan" id="kobo.972.2">You can write some additional tests to test the template, but this will also be covered with the e2e tests we will write in the next section. </span><span class="koboSpan" id="kobo.972.3">Now that you know how to run the unit tests for your individual spec file, let’s examine how to run unit tests for one or more projects within your </span><span class="No-Break"><span class="koboSpan" id="kobo.973.1">Nx monorepo.</span></span></p>
<h3><span class="koboSpan" id="kobo.974.1">Running unit tests for one or more projects</span></h3>
<p><span class="koboSpan" id="kobo.975.1">We ran the unit tests</span><a id="_idIndexMarker1091"/><span class="koboSpan" id="kobo.976.1"> for the spec files one by one, so now let’s run them for the entire </span><strong class="source-inline"><span class="koboSpan" id="kobo.977.1">finance-expenses-registration</span></strong><span class="koboSpan" id="kobo.978.1"> project. </span><span class="koboSpan" id="kobo.978.2">When you run the unit tests for an entire project, it will run the tests in all spec files found inside that Nx project. </span><span class="koboSpan" id="kobo.978.3">Note that this will not include any library projects you use inside the project. </span><span class="koboSpan" id="kobo.978.4">For example, to run the test for all spec files inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.979.1">finance-expenses-registration</span></strong><span class="koboSpan" id="kobo.980.1"> project, you use the following </span><span class="No-Break"><span class="koboSpan" id="kobo.981.1">Terminal command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.982.1">
npx nx run finance-expenses-registration:test</span></pre> <p><span class="koboSpan" id="kobo.983.1">When you run the preceding command, you’ll notice that the test run fails because we do not meet the coverage threshold of 80%. </span><span class="koboSpan" id="kobo.983.2">This is because we do not test the </span><strong class="source-inline"><span class="koboSpan" id="kobo.984.1">translation.service.ts</span></strong><span class="koboSpan" id="kobo.985.1"> file. </span><span class="koboSpan" id="kobo.985.2">As an exercise, you can create the spec file for </span><strong class="source-inline"><span class="koboSpan" id="kobo.986.1">TranslationService</span></strong><span class="koboSpan" id="kobo.987.1"> yourself; alternatively, you can lower the </span><span class="No-Break"><span class="koboSpan" id="kobo.988.1">coverage threshold.</span></span></p>
<p><span class="koboSpan" id="kobo.989.1">Besides running the unit tests for a single project, you can also run unit tests for multiple projects at the same time using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.990.1">run-many</span></strong><span class="koboSpan" id="kobo.991.1"> command. </span><span class="koboSpan" id="kobo.991.2">When using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.992.1">run-many</span></strong><span class="koboSpan" id="kobo.993.1"> command without any additional parameters, you will run the unit tests for projects found in your entire </span><span class="No-Break"><span class="koboSpan" id="kobo.994.1">Nx monorepo:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.995.1">
nx run-many -t test</span></pre> <p><span class="koboSpan" id="kobo.996.1">Furthermore, you can add specific project names at the end of the terminal command to only run the unit tests for </span><span class="No-Break"><span class="koboSpan" id="kobo.997.1">specific projects:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.998.1">
nx run-many -t test -p proj1 proj2</span></pre> <p><span class="koboSpan" id="kobo.999.1">You can also run the unit tests for all projects and exclude specific projects from the test run using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1000.1">–</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1001.1">exclude</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1002.1"> flag:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1003.1">
nx run-many -t test --exclude excluded-app</span></pre> <p><span class="koboSpan" id="kobo.1004.1">Lastly, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1005.1">affected</span></strong><span class="koboSpan" id="kobo.1006.1"> terminal command. </span><span class="koboSpan" id="kobo.1006.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1007.1">affected</span></strong><span class="koboSpan" id="kobo.1008.1"> command can be used to run the unit tests for all projects affected by your changes. </span><span class="koboSpan" id="kobo.1008.2">Nx will look at its cache and check what projects have changed since the last time the unit tests ran. </span><span class="koboSpan" id="kobo.1008.3">Any project affected by changes made after the latest cached test run will be run when using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1009.1">affected</span></strong><span class="koboSpan" id="kobo.1010.1"> command. </span><span class="koboSpan" id="kobo.1010.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1011.1">affected</span></strong><span class="koboSpan" id="kobo.1012.1"> command is particularly useful when you run your unit tests on a build pipeline and want to test your code each time you’re </span><span class="No-Break"><span class="koboSpan" id="kobo.1013.1">merging code:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1014.1">
nx affected -t test</span></pre> <p><span class="koboSpan" id="kobo.1015.1">To summarize, you can run tests</span><a id="_idIndexMarker1092"/><span class="koboSpan" id="kobo.1016.1"> for individual spec files, for one or more Nx projects, or for projects affected by your changes. </span><span class="koboSpan" id="kobo.1016.2">Unit tests are meant to test isolated units and should make you confident that your changes will not break your existing code implementations. </span><span class="koboSpan" id="kobo.1016.3">Unit tests consist of three main parts, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1017.1">describe()</span></strong><span class="koboSpan" id="kobo.1018.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1019.1">beforeEach()</span></strong><span class="koboSpan" id="kobo.1020.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1021.1">it()</span></strong><span class="koboSpan" id="kobo.1022.1"> functions, and inside your test cases, you assert them using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1023.1">expect()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1024.1"> function.</span></span></p>
<p><span class="koboSpan" id="kobo.1025.1">Now that you know how to write and run unit tests, it’s time to dive deeper into the topic of </span><span class="No-Break"><span class="koboSpan" id="kobo.1026.1">e2e tests.</span></span></p>
<h1 id="_idParaDest-195"><a id="_idTextAnchor214"/><span class="koboSpan" id="kobo.1027.1">End-to-end testing of Angular applications using Cypress</span></h1>
<p><span class="koboSpan" id="kobo.1028.1">When you create an application</span><a id="_idIndexMarker1093"/><span class="koboSpan" id="kobo.1029.1"> using the Nx CLI or Nx console, two projects</span><a id="_idIndexMarker1094"/><span class="koboSpan" id="kobo.1030.1"> are created for you: a regular application (in our case, an Angular application) and an e2e project configured to test the generated application project using the Cypress testing framework. </span><span class="koboSpan" id="kobo.1030.2">For example, when we created the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1031.1">expenses-registration</span></strong><span class="koboSpan" id="kobo.1032.1"> project, Nx also created an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1033.1">expenses-registration-e2e</span></strong><span class="koboSpan" id="kobo.1034.1"> project. </span><span class="koboSpan" id="kobo.1034.2">The folder for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1035.1">expenses-registration-e2e</span></strong><span class="koboSpan" id="kobo.1036.1"> project is located next to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1037.1">expenses-registration</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1038.1">project folder.</span></span></p>
<p><span class="koboSpan" id="kobo.1039.1">Before we start writing our own e2e tests, let’s see what Nx generated for us inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1040.1">expenses-registration-e2e</span></strong><span class="koboSpan" id="kobo.1041.1"> folder. </span><span class="koboSpan" id="kobo.1041.2">When you open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1042.1">expenses-registration-e2e</span></strong><span class="koboSpan" id="kobo.1043.1"> folder, you find some folders and four files. </span><span class="koboSpan" id="kobo.1043.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1044.1">.eslintrc.json</span></strong><span class="koboSpan" id="kobo.1045.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1046.1">cypress.config.ts</span></strong><span class="koboSpan" id="kobo.1047.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1048.1">project.json</span></strong><span class="koboSpan" id="kobo.1049.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1050.1">tsconfig.json</span></strong><span class="koboSpan" id="kobo.1051.1"> files are all meant to configure Cypress and the e2e project. </span><span class="koboSpan" id="kobo.1051.2">We want to adjust one small thing inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1052.1">tsconfig.json</span></strong><span class="koboSpan" id="kobo.1053.1"> file; you can leave the rest of the files untouched. </span><span class="koboSpan" id="kobo.1053.2">Inside this </span><strong class="source-inline"><span class="koboSpan" id="kobo.1054.1">tsconfig.json</span></strong><span class="koboSpan" id="kobo.1055.1"> file, you’ll find an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1056.1">include</span></strong><span class="koboSpan" id="kobo.1057.1"> array; inside this </span><strong class="source-inline"><span class="koboSpan" id="kobo.1058.1">include</span></strong><span class="koboSpan" id="kobo.1059.1"> array, add the </span><span class="No-Break"><span class="koboSpan" id="kobo.1060.1">following string:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1061.1">
"src/**/*.cy.ts"</span></pre> <p><span class="koboSpan" id="kobo.1062.1">Besides the configurations created</span><a id="_idIndexMarker1095"/><span class="koboSpan" id="kobo.1063.1"> by Nx, you also want</span><a id="_idIndexMarker1096"/><span class="koboSpan" id="kobo.1064.1"> to add one small thing inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1065.1">.eslintrc.json</span></strong><span class="koboSpan" id="kobo.1066.1"> file at the root of your Nx monorepo. </span><span class="koboSpan" id="kobo.1066.2">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1067.1">.eslintrc.json</span></strong><span class="koboSpan" id="kobo.1068.1"> file at the root of your Nx monorepo, you’ll find a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1069.1">project</span></strong><span class="koboSpan" id="kobo.1070.1"> array; inside this array, add the </span><span class="No-Break"><span class="koboSpan" id="kobo.1071.1">following value:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1072.1">
"apps/*/*/tsconfig.json"</span></pre> <p><span class="koboSpan" id="kobo.1073.1">Without the two aforementioned additions to your configuration, you will run into some ESLint parsing errors. </span><span class="koboSpan" id="kobo.1073.2">After adding the additional configurations, let’s see what else Nx has generated inside the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1074.1">expenses-registration-e2e</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1075.1"> project.</span></span></p>
<p><span class="koboSpan" id="kobo.1076.1">You’ll see a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1077.1">cypress</span></strong><span class="koboSpan" id="kobo.1078.1"> folder and an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1079.1">src</span></strong><span class="koboSpan" id="kobo.1080.1"> folder inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1081.1">expenses-registration-e2e</span></strong><span class="koboSpan" id="kobo.1082.1"> folder. </span><span class="koboSpan" id="kobo.1082.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1083.1">cypress</span></strong><span class="koboSpan" id="kobo.1084.1"> folder can be ignored; inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1085.1">src</span></strong><span class="koboSpan" id="kobo.1086.1"> folder, you’ll find </span><strong class="source-inline"><span class="koboSpan" id="kobo.1087.1">e2e</span></strong><span class="koboSpan" id="kobo.1088.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1089.1">fixtures</span></strong><span class="koboSpan" id="kobo.1090.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1091.1">support</span></strong><span class="koboSpan" id="kobo.1092.1"> folders that have the </span><span class="No-Break"><span class="koboSpan" id="kobo.1093.1">following purposes:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1094.1">e2e</span></strong><span class="koboSpan" id="kobo.1095.1">: Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1096.1">e2e</span></strong><span class="koboSpan" id="kobo.1097.1"> folder, you’ll add the files containing your e2e tests. </span><span class="koboSpan" id="kobo.1097.2">Nx already generated an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1098.1">app.cy.ts</span></strong><span class="koboSpan" id="kobo.1099.1"> file inside this folder. </span><span class="koboSpan" id="kobo.1099.2">As you can see, the file name ends with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1100.1">cy.ts</span></strong><span class="koboSpan" id="kobo.1101.1">. </span><span class="koboSpan" id="kobo.1101.2">This is a naming convention for the files containing your Cypress e2e tests. </span><span class="koboSpan" id="kobo.1101.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1102.1">cy</span></strong><span class="koboSpan" id="kobo.1103.1"> at the end of your file is short </span><span class="No-Break"><span class="koboSpan" id="kobo.1104.1">for Cypress.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1105.1">fixtures</span></strong><span class="koboSpan" id="kobo.1106.1">: Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1107.1">fixture</span></strong><span class="koboSpan" id="kobo.1108.1"> folder, you can add JSON files containing the mock data you want to use inside your e2e test. </span><span class="koboSpan" id="kobo.1108.2">Using fixtures is useful when you want to use specific data for e2e tests. </span><span class="koboSpan" id="kobo.1108.3">Additionally, you often won’t have an API or mocking service you can or want to use during your e2e tests. </span><span class="koboSpan" id="kobo.1108.4">Adding mocking services or APIs in your e2e tests often requires a lot of additional setup in both your local environment and in your pipelines where you want to run the e2e tests. </span><span class="koboSpan" id="kobo.1108.5">Besides additional setup, using a real API or the same mocking service as your development environment can lead to more instability for your </span><span class="No-Break"><span class="koboSpan" id="kobo.1109.1">e2e test.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1110.1">support</span></strong><span class="koboSpan" id="kobo.1111.1">: Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1112.1">support</span></strong><span class="koboSpan" id="kobo.1113.1"> folder, you’ll find everything you need to write and run your e2e tests. </span><span class="koboSpan" id="kobo.1113.2">Some things you place inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1114.1">support</span></strong><span class="koboSpan" id="kobo.1115.1"> folder are a file containing all the imports you use inside the e2e project, a file containing page objects used inside your </span><strong class="source-inline"><span class="koboSpan" id="kobo.1116.1">.cy.ts</span></strong><span class="koboSpan" id="kobo.1117.1"> files, additional setup files, or files with custom </span><span class="No-Break"><span class="koboSpan" id="kobo.1118.1">Cypress commands.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1119.1">Now that you have an idea of what Nx generated</span><a id="_idIndexMarker1097"/><span class="koboSpan" id="kobo.1120.1"> for you and what the files</span><a id="_idIndexMarker1098"/><span class="koboSpan" id="kobo.1121.1"> and folders inside your e2e project are used for, let’s start to write and run e2e tests for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1122.1">expenses-registration</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1123.1"> project.</span></span></p>
<h2 id="_idParaDest-196"><a id="_idTextAnchor215"/><span class="koboSpan" id="kobo.1124.1">Writing your first e2e test</span></h2>
<p><span class="koboSpan" id="kobo.1125.1">Start by removing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1126.1">app.cy.ts</span></strong><span class="koboSpan" id="kobo.1127.1"> file and replacing</span><a id="_idIndexMarker1099"/><span class="koboSpan" id="kobo.1128.1"> it with an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1129.1">expenses-registration.cy.ts</span></strong><span class="koboSpan" id="kobo.1130.1"> file. </span><span class="koboSpan" id="kobo.1130.2">Inside this </span><strong class="source-inline"><span class="koboSpan" id="kobo.1131.1">expenses-registration.cy.ts</span></strong><span class="koboSpan" id="kobo.1132.1"> file, we will write the e2e tests that will test the </span><em class="italic"><span class="koboSpan" id="kobo.1133.1">expenses-registration application</span></em><span class="koboSpan" id="kobo.1134.1">. </span><span class="koboSpan" id="kobo.1134.2">As we did with the unit tests, we define a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1135.1">describe()</span></strong><span class="koboSpan" id="kobo.1136.1"> function. </span><span class="koboSpan" id="kobo.1136.2">You use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1137.1">describe()</span></strong><span class="koboSpan" id="kobo.1138.1"> function for grouping multiple e2e tests, similar to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1139.1">describe()</span></strong><span class="koboSpan" id="kobo.1140.1"> function we used for the unit tests. </span><span class="koboSpan" id="kobo.1140.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1141.1">describe()</span></strong><span class="koboSpan" id="kobo.1142.1"> function takes two arguments: a description and a </span><span class="No-Break"><span class="koboSpan" id="kobo.1143.1">callback function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1144.1">
describe('finance-expenses-registration', () =&gt; {});</span></pre> <p><span class="koboSpan" id="kobo.1145.1">Now, inside the callback function of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1146.1">describe()</span></strong><span class="koboSpan" id="kobo.1147.1"> function, we will add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1148.1">beforeEach()</span></strong><span class="koboSpan" id="kobo.1149.1"> function. </span><span class="koboSpan" id="kobo.1149.2">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1150.1">beforeEach()</span></strong><span class="koboSpan" id="kobo.1151.1"> function, you can define the steps you want to perform before each e2e test. </span><span class="koboSpan" id="kobo.1151.2">Some common steps defined inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1152.1">beforeEach()</span></strong><span class="koboSpan" id="kobo.1153.1"> function are visiting the URL of your application, setting up interceptors, logging in as a user, and closing the cookie consent message. </span><span class="koboSpan" id="kobo.1153.2">In our case, we will only visit the URL of the application, and later, we will create an interceptor to demonstrate how you can use the fixtures to provide </span><span class="No-Break"><span class="koboSpan" id="kobo.1154.1">mocked data:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1155.1">
beforeEach(() =&gt; {
  cy.visit('');
});</span></pre> <p><span class="koboSpan" id="kobo.1156.1">In the preceding code, we defined the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1157.1">beforeEach()</span></strong><span class="koboSpan" id="kobo.1158.1"> function, and inside the callback, we visited the base URL of our application using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1159.1">visit()</span></strong><span class="koboSpan" id="kobo.1160.1"> method on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1161.1">cy</span></strong><span class="koboSpan" id="kobo.1162.1"> object. </span><span class="koboSpan" id="kobo.1162.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1163.1">cy</span></strong><span class="koboSpan" id="kobo.1164.1"> object is a global helper object provided to you by the Cypress framework used for all sorts of things, such as visiting pages, accessing page and window objects, reacting to events, setting up interceptors, and waiting for requests. </span><span class="koboSpan" id="kobo.1164.2">In the preceding example, we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1165.1">visit()</span></strong><span class="koboSpan" id="kobo.1166.1"> method. </span><span class="koboSpan" id="kobo.1166.2">We provided it with an empty string as a function parameter to indicate Cypress should visit the base URL of </span><span class="No-Break"><span class="koboSpan" id="kobo.1167.1">our application.</span></span></p>
<p><span class="koboSpan" id="kobo.1168.1">After defining the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1169.1">beforeEach()</span></strong><span class="koboSpan" id="kobo.1170.1"> function and visiting your application base URL, let’s add our first simple e2e test. </span><span class="koboSpan" id="kobo.1170.2">As with unit tests, your test cases are defined using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1171.1">it()</span></strong><span class="koboSpan" id="kobo.1172.1"> function. </span><span class="koboSpan" id="kobo.1172.2">Similar to the unit tests, your </span><strong class="source-inline"><span class="koboSpan" id="kobo.1173.1">it()</span></strong><span class="koboSpan" id="kobo.1174.1"> functions receive a description and a callback function. </span><span class="koboSpan" id="kobo.1174.2">Inside the callback function, you write the code for your test cases. </span><span class="koboSpan" id="kobo.1174.3">Let’s start simple and write an e2e test to check whether the application redirects to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1175.1">expenses-overview</span></strong><span class="koboSpan" id="kobo.1176.1"> route when we visit the </span><span class="No-Break"><span class="koboSpan" id="kobo.1177.1">base URL:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1178.1">
it('should redirect to the expenses-overview page when we load the root application route', () =&gt; {
  cy.url().should(‹equal', 'http://localhost:4200/expenses-overview');
});</span></pre> <p><span class="koboSpan" id="kobo.1179.1">As you can see in the preceding</span><a id="_idIndexMarker1100"/><span class="koboSpan" id="kobo.1180.1"> code, we describe the test case and then write the logic for our test case inside the callback of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1181.1">it()</span></strong><span class="koboSpan" id="kobo.1182.1"> function. </span><span class="koboSpan" id="kobo.1182.2">For the prior test case, we only need one line of logic. </span><span class="koboSpan" id="kobo.1182.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1183.1">beforeEach()</span></strong><span class="koboSpan" id="kobo.1184.1"> function will open the application on the base URL. </span><span class="koboSpan" id="kobo.1184.2">When we open our app on the base URL, we should be redirected to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1185.1">expenses-overview</span></strong><span class="koboSpan" id="kobo.1186.1"> route, so when we reach the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1187.1">it()</span></strong><span class="koboSpan" id="kobo.1188.1"> function, the application should be redirected to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1189.1">expenses-overview</span></strong><span class="koboSpan" id="kobo.1190.1"> route. </span><span class="koboSpan" id="kobo.1190.2">In this test case, you only have to assert whether the current URL equals </span><strong class="source-inline"><span class="koboSpan" id="kobo.1191.1">http://localhost:4200/expenses-overview</span></strong><span class="koboSpan" id="kobo.1192.1">. </span><span class="koboSpan" id="kobo.1192.2">In your Cypress tests, you generally get a page or window element and interact with them or assert the text, CSS classes, or attributes; in this case, you get the browser URL and assert whether the URL equals the text </span><span class="No-Break"><span class="koboSpan" id="kobo.1193.1">you expect.</span></span></p>
<p><span class="koboSpan" id="kobo.1194.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1195.1">cy</span></strong><span class="koboSpan" id="kobo.1196.1"> object exposes most window</span><a id="_idIndexMarker1101"/><span class="koboSpan" id="kobo.1197.1"> objects by default; if you want to access elements from within the HTML structure of your application, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1198.1">.get()</span></strong><span class="koboSpan" id="kobo.1199.1"> method on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1200.1">cy</span></strong><span class="koboSpan" id="kobo.1201.1"> object. </span><span class="koboSpan" id="kobo.1201.2">In our example, we are interested in the URL, which is located in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1202.1">location.href</span></strong><span class="koboSpan" id="kobo.1203.1"> property of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1204.1">window</span></strong><span class="koboSpan" id="kobo.1205.1"> object. </span><span class="koboSpan" id="kobo.1205.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1206.1">cy</span></strong><span class="koboSpan" id="kobo.1207.1"> object exposes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1208.1">location.href</span></strong><span class="koboSpan" id="kobo.1209.1"> property by default using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1210.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1211.1">URL()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1212.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.1213.1">After you get the element you want to assert, you can chain the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1214.1">.should()</span></strong><span class="koboSpan" id="kobo.1215.1"> assertion method to make the assertion you want to make. </span><span class="koboSpan" id="kobo.1215.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1216.1">.should()</span></strong><span class="koboSpan" id="kobo.1217.1"> method takes in two parameters: an assertion type and a value with which to perform the assertion. </span><span class="koboSpan" id="kobo.1217.2">In our case, we provided the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1218.1">.should()</span></strong><span class="koboSpan" id="kobo.1219.1"> method with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1220.1">equal</span></strong><span class="koboSpan" id="kobo.1221.1"> assertion type and provided the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1222.1">http://localhost:4200/expenses-overview</span></strong><span class="koboSpan" id="kobo.1223.1"> value to check whether our provided value equals the element we want to assert—in this instance, </span><span class="No-Break"><span class="koboSpan" id="kobo.1224.1">the URL.</span></span></p>
<p><span class="koboSpan" id="kobo.1225.1">You can find a list of all assertion</span><a id="_idIndexMarker1102"/><span class="koboSpan" id="kobo.1226.1"> types in the official Cypress </span><span class="No-Break"><span class="koboSpan" id="kobo.1227.1">documentation: </span></span><a href="https://docs.cypress.io/guides/references/assertions"><span class="No-Break"><span class="koboSpan" id="kobo.1228.1">https://docs.cypress.io/guides/references/assertions</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1229.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1230.1">Now that we’ve written the first e2e tests and explained how everything works, let’s run the e2e test and see whether the test will succeed. </span><span class="koboSpan" id="kobo.1230.2">You can start your e2e tests by running the following terminal command at the root of your </span><span class="No-Break"><span class="koboSpan" id="kobo.1231.1">Nx monorepo:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1232.1">
nx e2e &lt;project-name&gt;</span></pre> <p><span class="koboSpan" id="kobo.1233.1">In the preceding command, you need to replace </span><strong class="source-inline"><span class="koboSpan" id="kobo.1234.1">&lt;project-name&gt;</span></strong><span class="koboSpan" id="kobo.1235.1"> with the name found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1236.1">project.json</span></strong><span class="koboSpan" id="kobo.1237.1"> file of the e2e project you want to run. </span><span class="koboSpan" id="kobo.1237.2">Just as with the unit tests, you can also run the e2e tests for multiple projects using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1238.1">run-many</span></strong><span class="koboSpan" id="kobo.1239.1"> command or for affected projects with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1240.1">affected</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1241.1"> command.</span></span></p>
<p><span class="koboSpan" id="kobo.1242.1">When running one of the aforementioned commands, the e2e tests will run headlessly, meaning no browser will be opened to execute your e2e tests. </span><span class="koboSpan" id="kobo.1242.2">Running your e2e tests headlessly is ideal if you want to run your tests in a build pipeline or another environment where you don’t have access to </span><span class="No-Break"><span class="koboSpan" id="kobo.1243.1">a browser.</span></span></p>
<p><span class="koboSpan" id="kobo.1244.1">It is nice to see Cypress executing</span><a id="_idIndexMarker1103"/><span class="koboSpan" id="kobo.1245.1"> the tests in a real browser during the development process. </span><span class="koboSpan" id="kobo.1245.2">When Cypress executes the tests in a real live browser, you can better understand why tests are failing. </span><span class="koboSpan" id="kobo.1245.3">There is a nice user interface allowing you to easily spot what tests are failing and navigate to the specific steps in which they’re failing. </span><span class="koboSpan" id="kobo.1245.4">To run the e2e tests in a real live browser, you can use the </span><span class="No-Break"><span class="koboSpan" id="kobo.1246.1">following command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1247.1">
nx e2e &lt;project-name&gt; --watch</span></pre> <p><span class="koboSpan" id="kobo.1248.1">So let’s change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1249.1">&lt;project-name&gt;</span></strong><span class="koboSpan" id="kobo.1250.1"> placeholder with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1251.1">finance-expenses-registration-e2e</span></strong><span class="koboSpan" id="kobo.1252.1"> and run the test </span><span class="No-Break"><span class="koboSpan" id="kobo.1253.1">we created:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1254.1">
nx e2e finance-expenses-registration-e2e --watch</span></pre> <p><span class="koboSpan" id="kobo.1255.1">As shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1256.1">Figure 11</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1257.1">.1</span></em><span class="koboSpan" id="kobo.1258.1">, the Cypress UI will be started and ask you to choose a browser when you run the preceding </span><span class="No-Break"><span class="koboSpan" id="kobo.1259.1">terminal command:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer038">
<span class="koboSpan" id="kobo.1260.1"><img alt="Figure 11.1: Cypress UI start screen" src="image/B21625_11_001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1261.1">Figure 11.1: Cypress UI start screen</span></p>
<p><span class="koboSpan" id="kobo.1262.1">Select the </span><strong class="bold"><span class="koboSpan" id="kobo.1263.1">Chrome</span></strong><span class="koboSpan" id="kobo.1264.1"> browser</span><a id="_idIndexMarker1104"/><span class="koboSpan" id="kobo.1265.1"> and click on </span><strong class="bold"><span class="koboSpan" id="kobo.1266.1">Start e2e Testing in Chrome</span></strong><span class="koboSpan" id="kobo.1267.1">, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1268.1">Figure 11</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1269.1">.1</span></em><span class="koboSpan" id="kobo.1270.1">. </span><span class="koboSpan" id="kobo.1270.2">After starting the e2e tests in the Chrome browser, a new Chrome browser will be opened for you, showcasing all your e2e specs. </span><span class="koboSpan" id="kobo.1270.3">The e2e specs are the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1271.1">.cy.ts</span></strong><span class="koboSpan" id="kobo.1272.1"> files located inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1273.1">e2e</span></strong><span class="koboSpan" id="kobo.1274.1"> folder of your e2e project; in our case, we only have one file, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1275.1">expenses-registration.cy.ts</span></strong><span class="koboSpan" id="kobo.1276.1"> file. </span><span class="koboSpan" id="kobo.1276.2">When you click on the file name, Cypress will run the e2e tests for that specific file. </span><span class="koboSpan" id="kobo.1276.3">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1277.1">Figure 11</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1278.1">.2</span></em><span class="koboSpan" id="kobo.1279.1">, you can see what the test run looks like for our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1280.1">expenses-registration.cy.ts</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1281.1"> file:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer039">
<span class="koboSpan" id="kobo.1282.1"><img alt="Figure 11.2: Cypress UI test run screen" src="image/B21625_11_002.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1283.1">Figure 11.2: Cypress UI test run screen</span></p>
<p><span class="koboSpan" id="kobo.1284.1">As seen in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1285.1">Figure 11</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1286.1">.2</span></em><span class="koboSpan" id="kobo.1287.1">, on the left side, you can see the tests that are being executed and whether they pass or fail, and on the right side, you can see the application and what Cypress is doing inside </span><span class="No-Break"><span class="koboSpan" id="kobo.1288.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.1289.1">To summarize, Nx creates an e2e project for each application you generate using the Nx cli or Nx console. </span><span class="koboSpan" id="kobo.1289.2">You create </span><strong class="source-inline"><span class="koboSpan" id="kobo.1290.1">.cy.ts</span></strong><span class="koboSpan" id="kobo.1291.1"> files inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1292.1">e2e</span></strong><span class="koboSpan" id="kobo.1293.1"> folder to define your test cases. </span><span class="koboSpan" id="kobo.1293.2">Test cases are grouped using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1294.1">describe()</span></strong><span class="koboSpan" id="kobo.1295.1"> function and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1296.1">beforeEach()</span></strong><span class="koboSpan" id="kobo.1297.1"> function, which can be used to execute logic before each e2e test. </span><span class="koboSpan" id="kobo.1297.2">The test cases themselves are defined using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1298.1">it()</span></strong><span class="koboSpan" id="kobo.1299.1"> function, and inside the callback of your </span><strong class="source-inline"><span class="koboSpan" id="kobo.1300.1">it()</span></strong><span class="koboSpan" id="kobo.1301.1"> function, you define the test logic. </span><span class="koboSpan" id="kobo.1301.2">You can get elements using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1302.1">cy</span></strong><span class="koboSpan" id="kobo.1303.1"> object and assert values using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1304.1">.should()</span></strong><span class="koboSpan" id="kobo.1305.1"> method combined with an assertion type and a value to assert. </span><span class="koboSpan" id="kobo.1305.2">When you define your tests, you can execute them in a real browser or headlessly if you want to run them inside an environment where you don’t have access to </span><span class="No-Break"><span class="koboSpan" id="kobo.1306.1">a browser.</span></span></p>
<p><span class="koboSpan" id="kobo.1307.1">Now that you have learned</span><a id="_idIndexMarker1105"/><span class="koboSpan" id="kobo.1308.1"> the basics of e2e testing, created your first test, and run your test using the Cypress UI, let’s add some extra e2e tests to learn about additional concepts and patterns commonly used within </span><span class="No-Break"><span class="koboSpan" id="kobo.1309.1">e2e testing.</span></span></p>
<h2 id="_idParaDest-197"><a id="_idTextAnchor216"/><span class="koboSpan" id="kobo.1310.1">Defining page objects for e2e testing</span></h2>
<p><span class="koboSpan" id="kobo.1311.1">A common pattern</span><a id="_idIndexMarker1106"/><span class="koboSpan" id="kobo.1312.1"> in e2e testing</span><a id="_idIndexMarker1107"/><span class="koboSpan" id="kobo.1313.1"> is the </span><strong class="bold"><span class="koboSpan" id="kobo.1314.1">page object pattern</span></strong><span class="koboSpan" id="kobo.1315.1">. </span><span class="koboSpan" id="kobo.1315.2">When using the page object pattern, you abstract</span><a id="_idIndexMarker1108"/><span class="koboSpan" id="kobo.1316.1"> the selection of page elements away from the actual tests, resulting in more readable and maintainable tests. </span><span class="koboSpan" id="kobo.1316.2">To demonstrate the page object pattern, let’s first create a new e2e test without using the page object pattern and then adjust the new test by using the page object pattern. </span><span class="koboSpan" id="kobo.1316.3">The new test case will check whether the </span><strong class="bold"><span class="koboSpan" id="kobo.1317.1">Show summary</span></strong><span class="koboSpan" id="kobo.1318.1"> button is shown by default, and when we click the button, the summary will be shown. </span><span class="koboSpan" id="kobo.1318.2">Additionally, the test checks whether the button text is changed to </span><strong class="bold"><span class="koboSpan" id="kobo.1319.1">Hide summary</span></strong><span class="koboSpan" id="kobo.1320.1"> and whether the summary disappears if we click on the </span><span class="No-Break"><span class="koboSpan" id="kobo.1321.1">button again.</span></span></p>
<p><span class="koboSpan" id="kobo.1322.1">To create this test case, let’s start by defining the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1323.1">it()</span></strong><span class="koboSpan" id="kobo.1324.1"> function and provide it with a description for the </span><span class="No-Break"><span class="koboSpan" id="kobo.1325.1">test case:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1326.1">
it('should toggle the summary and adjust the button text', () =&gt; {});</span></pre> <p><span class="koboSpan" id="kobo.1327.1">Now that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1328.1">it()</span></strong><span class="koboSpan" id="kobo.1329.1"> function has been defined and we have provided a fitting description, we need to add the testing logic inside the callback of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1330.1">it()</span></strong><span class="koboSpan" id="kobo.1331.1"> function. </span><span class="koboSpan" id="kobo.1331.2">First, we need to get the button we used to toggle the summary. </span><span class="koboSpan" id="kobo.1331.3">As mentioned before, you can get elements from within your application using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1332.1">cy.get()</span></strong><span class="koboSpan" id="kobo.1333.1">. </span><span class="koboSpan" id="kobo.1333.2">You provide the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1334.1">.get()</span></strong><span class="koboSpan" id="kobo.1335.1"> method with a query selector; these selectors work identically to </span><span class="No-Break"><span class="koboSpan" id="kobo.1336.1">jQuery selectors:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1337.1">
cy.get('business-tools-monorepo-expenses-overview-page &gt; div &gt; div &gt; div &gt; button:nth-child(2)');</span></pre> <p><span class="koboSpan" id="kobo.1338.1">In the preceding code snippet, you can see we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1339.1">cy.get()</span></strong><span class="koboSpan" id="kobo.1340.1"> and provide it with the query selector to get the </span><strong class="bold"><span class="koboSpan" id="kobo.1341.1">Show summary</span></strong><span class="koboSpan" id="kobo.1342.1"> button. </span><span class="koboSpan" id="kobo.1342.2">If you’re not familiar with jQuery selectors, you can alternatively copy the selector through the </span><strong class="bold"><span class="koboSpan" id="kobo.1343.1">DevTools</span></strong><span class="koboSpan" id="kobo.1344.1"> of the Chrome browser. </span><span class="koboSpan" id="kobo.1344.2">Simply inspect the HTML page, find the element you want to use inside your Cypress test in your </span><strong class="bold"><span class="koboSpan" id="kobo.1345.1">DevTools</span></strong><span class="koboSpan" id="kobo.1346.1">, right-click on the element, and select </span><strong class="bold"><span class="koboSpan" id="kobo.1347.1">Copy</span></strong><span class="koboSpan" id="kobo.1348.1"> | </span><strong class="bold"><span class="koboSpan" id="kobo.1349.1">Copy selector</span></strong><span class="koboSpan" id="kobo.1350.1">. </span><span class="koboSpan" id="kobo.1350.2">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1351.1">Figure 11</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1352.1">.3</span></em><span class="koboSpan" id="kobo.1353.1">, you can see where you can copy </span><span class="No-Break"><span class="koboSpan" id="kobo.1354.1">the selector:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer040">
<span class="koboSpan" id="kobo.1355.1"><img alt="Figure 11.3: DevTools Copy selector" src="image/B21625_11_003.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1356.1">Figure 11.3: DevTools Copy selector</span></p>
<p><span class="koboSpan" id="kobo.1357.1">The selectors copied</span><a id="_idIndexMarker1109"/><span class="koboSpan" id="kobo.1358.1"> using the </span><strong class="bold"><span class="koboSpan" id="kobo.1359.1">DevTools</span></strong><span class="koboSpan" id="kobo.1360.1"> always start</span><a id="_idIndexMarker1110"/><span class="koboSpan" id="kobo.1361.1"> at the root of your HTML document and can be simplified by removing the beginning of the selector. </span><span class="koboSpan" id="kobo.1361.2">Now that you know how to select elements so you can use them within your tests, let’s write the rest of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1362.1">test logic:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1363.1">
it('should toggle the summary and adjust the button text', () =&gt; {
  const button = () =&gt; cy.get('business-tools-monorepo-expenses-overview-page &gt; div &gt; div &gt; div &gt; button:nth-child(2)');
  const summary = () =&gt; cy.get('table &gt; tr.summary &gt; td');
  button().should(‹contain›, ‹Show summary›);
  summary().should(‹not.exist');
  button().click();
  button().should(‹contain›, ‹Hide summary›);
  summary().should(‹exist›);
  button().click();
  button().should(‹contain›, ‹Show summary›);
  summary().should(‹not.exist');
});</span></pre> <p><span class="koboSpan" id="kobo.1364.1">In the preceding code, we first define two constants, one for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1365.1">button</span></strong><span class="koboSpan" id="kobo.1366.1"> and one for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1367.1">summary</span></strong><span class="koboSpan" id="kobo.1368.1">. </span><span class="koboSpan" id="kobo.1368.2">As you can see, we use a function that returns the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1369.1">cy.get()</span></strong><span class="koboSpan" id="kobo.1370.1"> method. </span><span class="koboSpan" id="kobo.1370.2">Directly assigning the return value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1371.1">cy.get()</span></strong><span class="koboSpan" id="kobo.1372.1"> to a variable is an anti-pattern because you can modify the return value during your tests. </span><span class="koboSpan" id="kobo.1372.2">Commonly, when you get the button, you want to get it unmodified, so we create a function that returns the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1373.1">cy.get()</span></strong><span class="koboSpan" id="kobo.1374.1"> function call and assign that to </span><span class="No-Break"><span class="koboSpan" id="kobo.1375.1">our variables.</span></span></p>
<p><span class="koboSpan" id="kobo.1376.1">After defining the two constants, we check whether the button contains the </span><strong class="bold"><span class="koboSpan" id="kobo.1377.1">Show summary</span></strong><span class="koboSpan" id="kobo.1378.1"> text and whether the summary element doesn’t exist yet. </span><span class="koboSpan" id="kobo.1378.2">Afterward, we click the button and check whether the button text is changed to </span><strong class="bold"><span class="koboSpan" id="kobo.1379.1">Hide summary</span></strong><span class="koboSpan" id="kobo.1380.1"> and whether the summary element exists. </span><span class="koboSpan" id="kobo.1380.2">Lastly, we click the button again and see if everything is toggled back to its </span><span class="No-Break"><span class="koboSpan" id="kobo.1381.1">initial state.</span></span></p>
<p><span class="koboSpan" id="kobo.1382.1">If you run your e2e tests</span><a id="_idIndexMarker1111"/><span class="koboSpan" id="kobo.1383.1"> now, you’ll find that the test</span><a id="_idIndexMarker1112"/><span class="koboSpan" id="kobo.1384.1"> succeeds. </span><span class="koboSpan" id="kobo.1384.2">While there is nothing wrong with this test, there are some things we can do to clean it up a bit. </span><span class="koboSpan" id="kobo.1384.3">First, we can simplify the selectors by adding a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1385.1">data-test-id</span></strong><span class="koboSpan" id="kobo.1386.1"> attribute on the HTML elements we want to select. </span><span class="koboSpan" id="kobo.1386.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1387.1">data-test-id</span></strong><span class="koboSpan" id="kobo.1388.1"> attribute is a simple HTML attribute commonly added to elements you want to use in your e2e tests. </span><span class="koboSpan" id="kobo.1388.2">So, let’s add the attribute to the button and summary element inside your </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1389.1">expenses-overview-page.component.html</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1390.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1391.1">
&lt;button </span><strong class="bold"><span class="koboSpan" id="kobo.1392.1">data-test-id</span></strong><span class="koboSpan" id="kobo.1393.1">="show-summary-btn" (click)="onSummaryChange()"&gt;{{summaryBtnText()}}&lt;/button&gt;</span></pre> <p><span class="koboSpan" id="kobo.1394.1">In the preceding code, you can see we’ve added the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1395.1">data-test-id</span></strong><span class="koboSpan" id="kobo.1396.1"> attribute to the button and provided it with a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1397.1">show-summary-btn</span></strong><span class="koboSpan" id="kobo.1398.1">. </span><span class="koboSpan" id="kobo.1398.2">Next, we will do the same for the element where we show </span><span class="No-Break"><span class="koboSpan" id="kobo.1399.1">the summary:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1400.1">
&lt;td </span><strong class="bold"><span class="koboSpan" id="kobo.1401.1">data-test-id</span></strong><span class="koboSpan" id="kobo.1402.1">="summary"&gt;Total: {{expensesVm.total}}&lt;/td&gt;</span></pre> <p><span class="koboSpan" id="kobo.1403.1">Now you’ve added the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1404.1">data-test-id</span></strong><span class="koboSpan" id="kobo.1405.1"> attributes, you can simplify the selectors used inside your e2e test. </span><span class="koboSpan" id="kobo.1405.2">Instead of the long selector used to select the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1406.1">button</span></strong><span class="koboSpan" id="kobo.1407.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1408.1">summary</span></strong><span class="koboSpan" id="kobo.1409.1"> elements, you can use the </span><span class="No-Break"><span class="koboSpan" id="kobo.1410.1">following syntax:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1411.1">
cy.get('[data-test-id="show-summary-btn"]');
cy.get('[data-test-id="summary"]')</span></pre> <p><span class="koboSpan" id="kobo.1412.1">As you can see, this dramatically simplifies the selectors for your HTML elements. </span><span class="koboSpan" id="kobo.1412.2">Besides simplifying the selectors by introducing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1413.1">data-test-id</span></strong><span class="koboSpan" id="kobo.1414.1"> attributes, you can create a function that checks the button text and checks whether the summary element exists. </span><span class="koboSpan" id="kobo.1414.2">You don’t have to repeat it three times inside </span><span class="No-Break"><span class="koboSpan" id="kobo.1415.1">your test.</span></span></p>
<p><span class="koboSpan" id="kobo.1416.1">Now that we have defined</span><a id="_idIndexMarker1113"/><span class="koboSpan" id="kobo.1417.1"> the logic for the test case, it’s time</span><a id="_idIndexMarker1114"/><span class="koboSpan" id="kobo.1418.1"> to improve it and move some logic to the page object file. </span><span class="koboSpan" id="kobo.1418.2">Start by removing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1419.1">app.po.ts</span></strong><span class="koboSpan" id="kobo.1420.1"> file from the support folder and adding a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1421.1">new expenses-overview.po.ts</span></strong><span class="koboSpan" id="kobo.1422.1"> file. </span><span class="koboSpan" id="kobo.1422.2">As you might have figured out, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1423.1">.po.ts</span></strong><span class="koboSpan" id="kobo.1424.1"> is short for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1425.1">.page-object.ts</span></strong><span class="koboSpan" id="kobo.1426.1">. </span><span class="koboSpan" id="kobo.1426.2">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1427.1">expenses-overview.po.ts</span></strong><span class="koboSpan" id="kobo.1428.1"> file, you will define all the logic to get the elements needed for the e2e tests for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1429.1">expenses-overview</span></strong><span class="koboSpan" id="kobo.1430.1"> page. </span><span class="koboSpan" id="kobo.1430.2">By abstracting the element selection to this page object file, you can easily reuse them, making your e2e tests smaller and easier to read, write, and maintain. </span><span class="koboSpan" id="kobo.1430.3">Currently, we only have two elements we can move to the page object file—the summary button and the </span><span class="No-Break"><span class="koboSpan" id="kobo.1431.1">summary element:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1432.1">
export const showHideSummaryBtn = () =&gt; cy.get('[data-test-id="show-summary-btn"]');
export const summaryValue = () =&gt; cy.get('[data-test-id="summary"]');</span></pre> <p><span class="koboSpan" id="kobo.1433.1">In the preceding code snippet, you can see that we moved the two constants defined inside the test case to the page object file and exported them so they can be accessed inside the e2e tests. </span><span class="koboSpan" id="kobo.1433.2">We also gave the two constants a more descriptive name. </span><span class="koboSpan" id="kobo.1433.3">Now, inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1434.1">expenses-registration.cy.ts</span></strong><span class="koboSpan" id="kobo.1435.1"> file, import the two constants and adjust the e2e test to use the imported constants. </span><span class="koboSpan" id="kobo.1435.2">If you now need the button or summary type in another e2e test, you can simply use the one defined inside the page object file instead of redefining the logic to get </span><span class="No-Break"><span class="koboSpan" id="kobo.1436.1">the element.</span></span></p>
<p><span class="koboSpan" id="kobo.1437.1">Inside the page object file, we can also add the function to check the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1438.1">toggle summary button</span></strong><span class="koboSpan" id="kobo.1439.1"> text and the visibility of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1440.1">summary itself:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1441.1">
export function summaryIsShwon(isShown: boolean) {
  showHideSummaryBtn().should('contain', isShown ? </span><span class="koboSpan" id="kobo.1441.2">'Hide summary' : 'Show summary');
  summaryValue().should(isShown ? </span><span class="koboSpan" id="kobo.1441.3">'exist' : 'not.exist');
}</span></pre> <p><span class="koboSpan" id="kobo.1442.1">After adding the preceding function, let’s update the e2e test to use the function and see the final result after adding the page </span><span class="No-Break"><span class="koboSpan" id="kobo.1443.1">object file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1444.1">
it('should toggle the summary and adjust the button text', () =&gt; {
  summaryIsShwon(false);
  showHideSummaryBtn().click();
  summaryIsShwon(true);
  showHideSummaryBtn().click();
  summaryIsShwon(false);
});</span></pre> <p><span class="koboSpan" id="kobo.1445.1">As you can see in the preceding code, now that we use the page object pattern, the test is much easier to understand and needs fewer lines of code; besides that, the code is easier to reuse in new </span><span class="No-Break"><span class="koboSpan" id="kobo.1446.1">test cases.</span></span></p>
<p><span class="koboSpan" id="kobo.1447.1">To summarize, you select elements using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1448.1">cy.get()</span></strong><span class="koboSpan" id="kobo.1449.1"> method combined with selectors identical to jQuery selectors. </span><span class="koboSpan" id="kobo.1449.2">To simplify your selectors, you can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1450.1">data-test-id</span></strong><span class="koboSpan" id="kobo.1451.1"> attributes, and by using the page object pattern, you can abstract the element selection logic away from your test cases, making your tests easier to read, write, and maintain. </span><span class="koboSpan" id="kobo.1451.2">Now that you have a better grasp of how to select elements and how the page object pattern</span><a id="_idIndexMarker1115"/><span class="koboSpan" id="kobo.1452.1"> can help you write</span><a id="_idIndexMarker1116"/><span class="koboSpan" id="kobo.1453.1"> better e2e tests, let’s learn how to intercept requests and use mock data from your fixtures inside your </span><span class="No-Break"><span class="koboSpan" id="kobo.1454.1">e2e tests.</span></span></p>
<h2 id="_idParaDest-198"><a id="_idTextAnchor217"/><span class="koboSpan" id="kobo.1455.1">Using fixtures in your e2e tests</span></h2>
<p><span class="koboSpan" id="kobo.1456.1">Fixtures are used to provide</span><a id="_idIndexMarker1117"/><span class="koboSpan" id="kobo.1457.1"> your e2e tests with specific mock</span><a id="_idIndexMarker1118"/><span class="koboSpan" id="kobo.1458.1"> data. </span><span class="koboSpan" id="kobo.1458.2">Using mock data for your e2e tests ensures that you have stable data with which to run your e2e tests. </span><span class="koboSpan" id="kobo.1458.3">Often, you need to run your e2e tests in an environment where you don’t have access to an API or mocking service; in this case, you can use the data defined in your fixtures. </span><span class="koboSpan" id="kobo.1458.4">Another common scenario is that you run your e2e tests in your test or acceptance environment, and the data on these environments isn’t always stable and might change over time, resulting in failing tests. </span><span class="koboSpan" id="kobo.1458.5">So, depending on your environment, fixtures can provide you with additional stability, ensuring that your tests don’t fail based on the data but only fail if you actually break something within your </span><span class="No-Break"><span class="koboSpan" id="kobo.1459.1">application code.</span></span></p>
<p><span class="koboSpan" id="kobo.1460.1">Let’s first run the e2e tests in production mode to demonstrate why you need fixtures. </span><span class="koboSpan" id="kobo.1460.2">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1461.1">mock.interceptor.ts</span></strong><span class="koboSpan" id="kobo.1462.1"> file will not return the mock data if we serve a production build of our application. </span><span class="koboSpan" id="kobo.1462.2">You can use the following terminal command to run the e2e tests with a production build of </span><span class="No-Break"><span class="koboSpan" id="kobo.1463.1">the application:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1464.1">
nx e2e finance-expenses-registration-e2e --watch --configuration=production</span></pre> <p><span class="koboSpan" id="kobo.1465.1">After running the preceding command, you’ll notice the application doesn’t have any data to display during the e2e tests. </span><span class="koboSpan" id="kobo.1465.2">For our current test cases, this is no issue, but when you have more tests, this will most likely result in some failing tests. </span><span class="koboSpan" id="kobo.1465.3">Instead of relying on </span><strong class="source-inline"><span class="koboSpan" id="kobo.1466.1">mock.interceptor.ts</span></strong><span class="koboSpan" id="kobo.1467.1">, we can use the fixtures to provide data during the </span><span class="No-Break"><span class="koboSpan" id="kobo.1468.1">e2e tests.</span></span></p>
<p><span class="koboSpan" id="kobo.1469.1">To use the data from your fixtures, you first need to add a file with mock data inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1470.1">fixtures</span></strong><span class="koboSpan" id="kobo.1471.1"> folder. </span><span class="koboSpan" id="kobo.1471.2">We will use the same mock data as we use for our mock interceptor, so start by copying the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1472.1">expenses.json</span></strong><span class="koboSpan" id="kobo.1473.1"> file inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1474.1">assets/api</span></strong><span class="koboSpan" id="kobo.1475.1"> folder from your </span><em class="italic"><span class="koboSpan" id="kobo.1476.1">expenses-registration application</span></em><span class="koboSpan" id="kobo.1477.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1478.1">fixtures</span></strong><span class="koboSpan" id="kobo.1479.1"> folder of your </span><span class="No-Break"><span class="koboSpan" id="kobo.1480.1">e2e project.</span></span></p>
<p><span class="koboSpan" id="kobo.1481.1">After copying the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1482.1">expenses.json</span></strong><span class="koboSpan" id="kobo.1483.1"> file, you need to adjust the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1484.1">beforeEach()</span></strong><span class="koboSpan" id="kobo.1485.1"> function inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1486.1">expenses-registration.cy.ts</span></strong><span class="koboSpan" id="kobo.1487.1"> file. </span><span class="koboSpan" id="kobo.1487.2">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1488.1">beforeEach()</span></strong><span class="koboSpan" id="kobo.1489.1"> function, you need to set up an interceptor to intercept the API request we make to get the expenses and provide it with a file from </span><span class="No-Break"><span class="koboSpan" id="kobo.1490.1">your fixtures:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1491.1">
beforeEach(() =&gt; {
  cy.intercept('GET', '**/api/expenses', { fixture: 'expenses.json' }).as('getExpenses');
  cy.visit('');
  cy.wait('@getExpenses');
});</span></pre> <p><span class="koboSpan" id="kobo.1492.1">In the preceding code, you can see we set up the interceptor using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1493.1">cy.intercept()</span></strong><span class="koboSpan" id="kobo.1494.1"> method. </span><span class="koboSpan" id="kobo.1494.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1495.1">cy.intercept()</span></strong><span class="koboSpan" id="kobo.1496.1"> method first takes a string to define what type of API request you want to intercept; in our case, we want to intercept a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1497.1">GET</span></strong><span class="koboSpan" id="kobo.1498.1"> request. </span><span class="koboSpan" id="kobo.1498.2">Next, you need to provide the API URL you want to intercept, and lastly, you need to provide an object with a fixture property assigned with the fixture file you want to use as a response for the intercepted request. </span><span class="koboSpan" id="kobo.1498.3">At the end of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1499.1">cy.intercept()</span></strong><span class="koboSpan" id="kobo.1500.1"> method, we chain the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1501.1">.as()</span></strong><span class="koboSpan" id="kobo.1502.1"> method and provide that with an alias for the interceptor; in this case, we </span><span class="No-Break"><span class="koboSpan" id="kobo.1503.1">used </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1504.1">getExpenses</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1505.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1506.1">After setting up the interceptor, we define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1507.1">cy.visit()</span></strong><span class="koboSpan" id="kobo.1508.1"> method to visit the application page, just like we did before. </span><span class="koboSpan" id="kobo.1508.2">After the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1509.1">cy.visit()</span></strong><span class="koboSpan" id="kobo.1510.1"> method, we define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1511.1">cy.wait()</span></strong><span class="koboSpan" id="kobo.1512.1"> method, indicating that Cypress must wait for the interceptor we set up. </span><span class="koboSpan" id="kobo.1512.2">Then, provide the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1513.1">cy.wait()</span></strong><span class="koboSpan" id="kobo.1514.1"> method with the interceptor alias prefixed with an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1515.1">@</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1516.1">sign.</span></span></p>
<p><span class="koboSpan" id="kobo.1517.1">The preceding steps involve</span><a id="_idIndexMarker1119"/><span class="koboSpan" id="kobo.1518.1"> everything required to use the fixture file</span><a id="_idIndexMarker1120"/><span class="koboSpan" id="kobo.1519.1"> for your mock data during the e2e tests. </span><span class="koboSpan" id="kobo.1519.2">If you need to set up the same interceptor and visit the same page for multiple testing files, you can abstract the logic away into a function and call that function inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1520.1">beforeEach()</span></strong><span class="koboSpan" id="kobo.1521.1"> callback so that you don’t have to repeat yourself </span><span class="No-Break"><span class="koboSpan" id="kobo.1522.1">multiple times.</span></span></p>
<p><span class="koboSpan" id="kobo.1523.1">You can test whether the interceptor and fixture work by running the e2e tests in production using the </span><span class="No-Break"><span class="koboSpan" id="kobo.1524.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1525.1">
nx e2e finance-expenses-registration-e2e --watch --configuration=production</span></pre> <p><span class="koboSpan" id="kobo.1526.1">After running the preceding command, you’ll notice that the application shows data again when running the </span><span class="No-Break"><span class="koboSpan" id="kobo.1527.1">e2e tests.</span></span></p>
<p><span class="koboSpan" id="kobo.1528.1">To summarize, you learned </span><a id="_idIndexMarker1121"/><span class="koboSpan" id="kobo.1529.1">that fixtures can be used to provide mock data</span><a id="_idIndexMarker1122"/><span class="koboSpan" id="kobo.1530.1"> during your e2e tests. </span><span class="koboSpan" id="kobo.1530.2">Using mock data can provide your tests with additional stability and help you run them in an environment where you don’t have access to an API or mocking service. </span><span class="koboSpan" id="kobo.1530.3">You use fixtures by setting up an interceptor in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1531.1">beforeEach()</span></strong><span class="koboSpan" id="kobo.1532.1"> function of your tests and providing the interceptor with the </span><span class="No-Break"><span class="koboSpan" id="kobo.1533.1">fixture file.</span></span></p>
<h1 id="_idParaDest-199"><a id="_idTextAnchor218"/><span class="koboSpan" id="kobo.1534.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1535.1">In this chapter, you learned about automated application testing. </span><span class="koboSpan" id="kobo.1535.2">You learned that unit tests are used to test small code units in isolation to ensure the code implantation works as expected. </span><span class="koboSpan" id="kobo.1535.3">e2e testing tests applications from the user’s perspective and checks whether the correct values are displayed and user interactions are processed and rendered correctly in the application view. </span><span class="koboSpan" id="kobo.1535.4">Component testing is a relatively new concept, comparable to e2e testing, but instead of compiling and testing an entire application, component testing focuses on testing a single component from the perspective of a user. </span><span class="koboSpan" id="kobo.1535.5">Lastly, integration tests are used to check how different modules and elements of your software integrate together. </span><span class="koboSpan" id="kobo.1535.6">Integration tests can be implemented on various levels, for example, to check whether code implementation remains working when you combine multiple components and services or whether your application still works when you combine and deploy various Angular applications and backend APIs as a single product for </span><span class="No-Break"><span class="koboSpan" id="kobo.1536.1">your customers.</span></span></p>
<p><span class="koboSpan" id="kobo.1537.1">After learning about the different types of tests, you created your own unit and e2e tests. </span><span class="koboSpan" id="kobo.1537.2">You learned about the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1538.1">describe()</span></strong><span class="koboSpan" id="kobo.1539.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1540.1">beforeEach()</span></strong><span class="koboSpan" id="kobo.1541.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1542.1">its()</span></strong><span class="koboSpan" id="kobo.1543.1"> functions and how they can be used for e2e and unit tests. </span><span class="koboSpan" id="kobo.1543.2">You learned how to use mock data in e2e tests and stub components and services in your unit tests. </span><span class="koboSpan" id="kobo.1543.3">Asserting values in unit tests is done using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1544.1">expect()</span></strong><span class="koboSpan" id="kobo.1545.1"> function, and in e2e tests, you use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1546.1">cy.should()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1547.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.1548.1">Lastly, you learned about different terminal commands to run tests for individual files, single projects, multiple projects, or projects that are affected by your changes. </span><span class="koboSpan" id="kobo.1548.2">In the next and final chapter of this book, you’ll add the finishing touches and learn about the different steps you need to take to deploy Angular applications in your </span><span class="No-Break"><span class="koboSpan" id="kobo.1549.1">Nx monorepo.</span></span></p>
</div>
</body></html>