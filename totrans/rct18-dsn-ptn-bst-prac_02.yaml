- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introducing TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter assumes that you have prior experience with JavaScript and are
    interested in improving the quality of your code by learning **TypeScript**. TypeScript
    is a typed superset of JavaScript that compiles to JavaScript. In other words,
    TypeScript is essentially JavaScript with some additional features.
  prefs: []
  type: TYPE_NORMAL
- en: Designed by Anders Hejlsberg, the creator of C# at Microsoft, TypeScript is
    an open-source language that enhances the capabilities of JavaScript. By introducing
    static typing and other advanced features, TypeScript helps developers write more
    reliable and maintainable code.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore the features of TypeScript and how to convert
    existing JavaScript code to TypeScript. By the end of this chapter, you will have
    a solid understanding of TypeScript’s benefits and how to leverage them to create
    more robust and scalable applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript’s features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convert JavaScript code into TypeScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending interfaces and types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing interfaces and types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Merging interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enums
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Template literal types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript configuration file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To work through the contents of this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js 19+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript’s features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeScript, a popular open-source programming language developed and maintained
    by Microsoft, is rapidly gaining popularity among developers worldwide. It was
    introduced as a superset of JavaScript, aiming to facilitate larger-scale applications
    while enhancing code quality and maintainability. TypeScript leverages static
    typing and compiles to clean, simple JavaScript code, ensuring compatibility with
    existing JavaScript environments.
  prefs: []
  type: TYPE_NORMAL
- en: This robust language brings a host of powerful features that set it apart and
    make it an appealing choice for many programmers. Notably, TypeScript infuses
    strong typing into JavaScript, providing better error checking and reducing runtime
    bugs. Moreover, it fully supports object-oriented programming with advanced features
    like classes, interfaces, and inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Since any valid JavaScript code is also TypeScript, transitioning from JavaScript
    to TypeScript can be done gradually, with developers introducing types to their
    codebase progressively. This makes TypeScript a flexible, scalable solution for
    both small and large-scale projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will summarize the essential features of TypeScript that
    you should take advantage of:'
  prefs: []
  type: TYPE_NORMAL
- en: '**TypeScript is JavaScript**: TypeScript is a superset of JavaScript, which
    means that any JavaScript code you write will work with TypeScript. If you already
    know how to use JavaScript, you have all the knowledge you need to use TypeScript.
    You just need to learn how to add types to your code. All TypeScript code is transformed
    into JavaScript in the end.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JavaScript is TypeScript**: This just means that you can rename any valid
    `.js` file with the `.ts` extension, and it will work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error checking**: TypeScript compiles the code and checks for errors, which
    helps identify issues before running the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strong typing**: By default, JavaScript is not strongly typed. With TypeScript,
    you can add types to all your variables and functions, and even specify the return
    value types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Object-oriented programming supported**: TypeScript supports advanced concepts
    such as classes, interfaces, inheritance, and more. This allows for better organization
    of code and enhances its maintainability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After having discussed the key features of TypeScript, let us delve into a practical
    demonstration of converting JavaScript code into TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: Converting JavaScript code into TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will see how to transform some JavaScript code into TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s suppose we have to check whether a word is a palindrome. The JavaScript
    code for this algorithm will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can name this file `palindrome.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we are receiving a `string` variable (`word`), and we are returning
    a `boolean` value. So, how will this be translated into TypeScript?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You’re probably thinking, “Great, I just specified the `string` type as `word`
    and the `boolean` type to the function returned value, but now what?”
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to run the function with some value that is different from `string`,
    you will get a TypeScript error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'So, if you try to pass a number to the function, you will get the following
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18414_02_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: Type number is not assignable to parameter of type string'
  prefs: []
  type: TYPE_NORMAL
- en: That’s why TypeScript is very useful, because it will force you to be stricter
    and more explicit with your code.
  prefs: []
  type: TYPE_NORMAL
- en: Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the last example, we saw how to specify some primitive types for our function
    parameter and returned value, but you’re probably wondering how you can describe
    an object or array with more details. Types can help us to describe our objects
    or arrays in a better way. For example, let’s suppose you want to describe a `User`
    type to save the information into the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following error if we forget to add one of the nodes or put an invalid
    value in one of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B18414_02_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: Age is missing in type User but is required'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need optional nodes, you can always put a `?` next to the age of the
    node, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can name `type` as you want, but a good practice to follow is to add a prefix
    of `T`. For example, the `User` type will become `TUser`. In this way, you can
    quickly recognize that it is `type` and you don’t get confused thinking it is
    a class or a React component.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Interfaces** are very similar to types and sometimes developers don’t know
    the differences between them. Interfaces can be used to describe the shape of
    an object or function signature just like types, but the syntax is different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can name an interface as you want, but a good practice to follow is to add
    a prefix of `I`. For example, the `User` interface will become `IUser`. In this
    way, you can quickly recognize that it is an interface, and you don’t get confused
    thinking it is a class or a React component.
  prefs: []
  type: TYPE_NORMAL
- en: An interface can also be extended, implemented, and merged.
  prefs: []
  type: TYPE_NORMAL
- en: Extending interfaces and types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An interface or type can also be extended, but again, the syntax will differ
    as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, by using the `&` character, you can extend a type, while you
    extend an interface using the `extends` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the extension of interfaces and types paves the way for us to
    delve into their implementation. Let us transition to illustrating how classes
    in TypeScript can implement these interfaces and types while keeping in mind the
    inherent constraints when dealing with union types.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing interfaces and types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A class can implement an interface or type alias in the exact same way. But
    it cannot implement (or extend) a *type alias* that names a `union type`. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you write the preceding code, you will get the following error in your editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B18414_02_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: A class can only implement an object type or intersection of object
    types with statically known members'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, you are not able to implement a union type.
  prefs: []
  type: TYPE_NORMAL
- en: Merging interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unlike a type, an interface can be defined multiple times and will be treated
    as a single interface (all declarations will be merged), as shown in the following
    code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is very useful when you need to extend your interfaces in different scenarios
    by just redefining the same interface.
  prefs: []
  type: TYPE_NORMAL
- en: Enums
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Enums** are one of the few features TypeScript has that is not a *type*-level
    extension of JavaScript. Enums permit a developer to define a set of **named constants**.
    Using enums can make it easier to document intent or create a set of distinct
    cases.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enums can store numeric or string values and are normally used to provide predefined
    values. Personally, I like to use them to define a palette of colors in a theming
    system, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table  Description automatically generated](img/B18414_02_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: Enums used for color palette'
  prefs: []
  type: TYPE_NORMAL
- en: Moving on to another useful feature of TypeScript, let’s explore namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have heard of **namespaces** in other programming languages, such as
    Java or C++. In JavaScript, namespaces are simply named objects in the global
    scope. They serve as a region in which variables, functions, interfaces, or classes
    are organized and grouped together within a local scope to avoid naming conflicts
    between components in the global scope.
  prefs: []
  type: TYPE_NORMAL
- en: While modules are also used for code organization, namespaces are more straightforward
    to implement for simple use cases. However, modules offer additional benefits
    such as code isolation, bundling support, re-exporting components, and renaming
    components that namespaces do not provide.
  prefs: []
  type: TYPE_NORMAL
- en: 'In my own projects, I find namespaces useful for grouping styles when using
    `styled-components`, for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then when I need to use it, I consume it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is very useful because I don’t need to worry about exporting multiple styled
    components. I just export the CSS namespace and I can use all the styled components
    defined inside that namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Template literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In TypeScript, **template literals** are based on **string literal types**
    and can be expanded into multiple strings using **unions**. These types are useful
    for defining a *theme name*, for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`Theme` is a union type that can only be assigned one of the two string literal
    types: `''light''` or `''dark''`. This provides type safety and prevents runtime
    errors caused by passing an invalid value as the theme name.'
  prefs: []
  type: TYPE_NORMAL
- en: Using this approach, you can define a set of possible values for a variable,
    argument, or parameter and ensure that only valid values are used at compile time.
    This makes your code more reliable and easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript configuration file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The presence of a `tsconfig.json` file in a directory indicates that the directory
    is the root of a TypeScript project. The `tsconfig.json` file specifies the root
    files and the compiler options required to compile the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check all the compiler options at the official TypeScript site: [https://www.typescriptlang.org/tsconfig](https://www.typescriptlang.org/tsconfig).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the `tsconfig.json` file that I normally use in my projects. I’ve always
    separated them into two files: the `tsconfig.common.json` file will contain all
    the shared compiler options, and the `tsconfig.json` file will extend the `tsconfig.common.json`
    file and add some specific options for that project. This is very useful when
    you work with **MonoRepos**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'My `tsconfig.common.json` file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And my `tsconfig.json` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In *Chapter 14*, I will explain how to create a MonoRepos architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the basics of TypeScript, including creating basic
    types and interfaces, extending them, and using enums, namespaces, and template
    literals. We also explored setting up our first TypeScript configuration file
    (`tsconfig.json`) and splitting it into two parts – one for sharing and the other
    for extending `tsconfig.common.json`. This approach is particularly useful when
    working with MonoRepos.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will delve into using JSX/TSX code and explore various
    configurations that can be applied to improve your code style. You will learn
    how to leverage the power of TypeScript to create efficient and maintainable React
    applications.
  prefs: []
  type: TYPE_NORMAL
