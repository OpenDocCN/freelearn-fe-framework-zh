- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React Query – Introducing, Installing, and Configuring It
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React Query is a library created to make it easier for React developers to manage
    their server state. It makes it easier for developers to overcome all the challenges
    that come with server state while making their applications faster, easier to
    maintain, and reducing many lines in their code.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will be introduced to React Query and understand why it
    was created.
  prefs: []
  type: TYPE_NORMAL
- en: You will also get to know the main concepts of React Query – **queries** and
    **mutations**.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have been introduced to React Query, we’ll install it in our application
    and identify the initial configurations we need to make in our code to get ready
    to use it fully.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will know all about React Query Devtools so
    that you can have a better developer experience while using React Query.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is React Query?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing React Query
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring React Query
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding React Query Devtools to your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will add React Query v4 to our application. To do so, there
    are a couple of things we need:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your browser needs to be compatible with the following configurations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Google Chrome version needs to be at least version 73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The Mozilla Firefox version needs to be at least version 78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The Microsoft Edge version needs to be at least version 79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The Safari version needs to be at least version 12.0
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The Opera version needs to be at least version 53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A React project after version 16.8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_3](https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_3%0D)
  prefs: []
  type: TYPE_NORMAL
- en: What is React Query?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React Query is a protocol-agnostic collection of hooks for fetching, caching,
    and updating server state in React.
  prefs: []
  type: TYPE_NORMAL
- en: It was created by Tanner Linsley and is part of a collection of open source
    libraries called TanStack.
  prefs: []
  type: TYPE_NORMAL
- en: By default, React Query can also work with React Native out of the box, and
    it is written in TypeScript so that you can benefit from all its advantages, such
    as type narrowing and type inference.
  prefs: []
  type: TYPE_NORMAL
- en: Since version 4, React Query has been embedded in a collection of libraries
    called TanStack Query. TanStack Query made it possible to propagate all the amazing
    features of React Query to other frameworks and libraries, such as Vue, Solid,
    and Svelte.
  prefs: []
  type: TYPE_NORMAL
- en: React Query leverages queries and mutations to handle your server state. Upon
    reading this last sentence, you might wonder what queries and mutations are. I’ll
    show you some code in subsequent chapters so that you can see how React Query
    handles them, but first, let us learn about queries and mutations.
  prefs: []
  type: TYPE_NORMAL
- en: Query
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A query is a request you make to an asynchronous source to fetch your data.
    Queries can be performed in React Query as long as you have a function that triggers
    the data-fetching request.
  prefs: []
  type: TYPE_NORMAL
- en: By allowing us to wrap our requests inside of promise-returning functions, React
    Query supports REST, GraphQL, and any other asynchronous data-fetching clients.
  prefs: []
  type: TYPE_NORMAL
- en: In React Query, the `useQuery` custom hook allows you to subscribe to queries.
  prefs: []
  type: TYPE_NORMAL
- en: Mutation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A mutation is an operation that allows you to create, update, or delete your
    server state.
  prefs: []
  type: TYPE_NORMAL
- en: Like queries, as long as you have a function that triggers a mutation, React
    Query supports REST, GraphQL, and any other asynchronous data-fetching clients.
  prefs: []
  type: TYPE_NORMAL
- en: In React Query, the `useMutation` custom hook allows you to perform a mutation.
  prefs: []
  type: TYPE_NORMAL
- en: How does React Query solve my server state challenges?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*What if I told you that all the challenges presented in the previous chapter
    could be solved by* *React Query?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Out of the box and with zero configurations, React Query supports all the following
    amazing features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Caching**: After each query, data will be cached during a configurable time
    and can be reused throughout your application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Query cancelation**: Your queries can be canceled, and you can perform an
    action after this cancelation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optimistic updates**: During a mutation, you can easily update your state
    so that you can provide a better user experience to your users. You are also able
    to easily revert to a previous state if the mutation fails.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parallel queries**: If you need to execute one or more queries simultaneously,
    you can do so without any difficulty or impacting your cache.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependent queries**: Sometimes, we need to execute a query after another
    one finishes. React Query makes this simple and avoids chaining promises.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Paginated queries**: This UI pattern is made easier with React Query. You’ll
    find that using a paginated API, changing pages, and rendering the fetched data
    is super simple.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Infinite queries**: Another UI pattern that is made easier by React Query.
    You can implement infinite scrolls into your UI and trust React Query to make
    your life easier when fetching data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scroll restoration**: Have you ever navigated from a page and, when navigated
    back, found that the page was scrolled to the exact point where you were before
    you navigated away? This is scroll restoration, and as long as your query results
    are cached, it will work out of the box.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data refetching**: Need to trigger a refetch for your data? React Query allows
    you to do this with pretty much a line of code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data prefetching**: Sometimes, you can identify ahead of time what the needs
    and next actions of your users are. When this happens, you can trust React Query
    to help you prefetch that data ahead of time and cache it for you. This way, your
    user experience will be improved, and you will have happier users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tracking network mode and offline support**: Have you ever had to deal with
    scenarios where your user lost their internet connection while using your application?
    Well, don’t worry because React Query can track the current state of your network,
    and if a query fails because the user lost connection, it will be retried once
    the network returns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking at this list is amazing, right?
  prefs: []
  type: TYPE_NORMAL
- en: Just having caching out of the box is a super, great timesaver because it is
    definitely one of the hardest things to implement when dealing with server state.
  prefs: []
  type: TYPE_NORMAL
- en: Before React Query, it was much harder to handle the server state in our applications.
    We tried, but our solutions ended up growing more complex and with less maintainable
    code. Often, these implementations would even end up impacting the user experience
    because our applications would get less responsive.
  prefs: []
  type: TYPE_NORMAL
- en: With React Query, you are now able to greatly reduce the number of lines in
    your code, make your application much easier to read and simple, and at the same
    time, make your application faster and much more responsive.
  prefs: []
  type: TYPE_NORMAL
- en: I won’t get into more technical details right now because, hopefully, in the
    following chapters, you will see all these features working and start understanding
    why React Query makes your life so much easier.
  prefs: []
  type: TYPE_NORMAL
- en: For now, let us start by installing React Query in our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Installing React Query
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you are aware of React Query, you are probably thinking, *wow, I really
    need to add this to my project.* Wait no more – here is what you need to do to
    install React Query.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on your project type, you can install React Query in several ways.
  prefs: []
  type: TYPE_NORMAL
- en: npm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are running npm in your project, then this is what you need to do to
    install React Query.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your terminal, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Yarn
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If Yarn is what you prefer, then this is what you need to do to install React
    Query.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your terminal, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: pnpm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are a fan of a new package manager, such as pnpm, and are using it in
    your project, then this is what you need to do to install React Query.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your terminal, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Script tag
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Not using a package manager? Don’t worry, because React Query can be added to
    your application by using a global build that is hosted on a **content** **delivery
    network**.
  prefs: []
  type: TYPE_NORMAL
- en: Content delivery network (CDN)
  prefs: []
  type: TYPE_NORMAL
- en: A CDN is a geographically distributed group of servers that work together to
    allow for faster delivery of content on the internet.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add React Query to your application, add the next `script` tag at the end
    of your HTML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You should now have React Query installed in your project.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to do the initial configurations on our projects to be able to
    use all the core functionalities of React Query.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring React Query
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React Query has a very fast and simple configuration. This improves the developer
    experience and can prepare you to start migrating your server state to React Query
    as soon as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add React Query to your application, there are only two things you need
    to know:'
  prefs: []
  type: TYPE_NORMAL
- en: '**QueryClient**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**QueryClientProvider**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: QueryClient
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you should be aware right now, caching is one of the most important things
    React Query makes easier for developers. In React Query, there are two mechanisms
    used to handle this cache called **QueryCache** and **MutationCache**.
  prefs: []
  type: TYPE_NORMAL
- en: '`QueryCache` is responsible for storing all the data related to your queries.
    This can be the data of your query as well as its current state.'
  prefs: []
  type: TYPE_NORMAL
- en: '`MutationCache` is responsible for storing all the data related to your mutations.
    This can be the data of your mutation as well as its current state.'
  prefs: []
  type: TYPE_NORMAL
- en: To make it easier for a developer to abstract from both caches, React Query
    created `QueryClient`. This is responsible for being the interface between a developer
    and a cache.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you should do when setting your application with React Query
    is to create a `QueryClient` instance. To do so, you need to import it from the
    `@tanstack/react-query` package and instantiate it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we create a new `QueryClient` object. As we don’t
    pass any argument when instantiating the object, `QueryClient` will assume all
    the defaults.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four options we can send as arguments when creating our `QueryClient`.
    They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`queryCache`: The query cache that this client will use throughout our application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mutationCache`: The mutation cache that this client will use throughout our
    application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`logger`: The logger that this client will use to display errors, warnings,
    and useful information for debugging. When nothing is specified, then React Query
    will use the console object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`defaultOptions`: The default options that all queries and mutations will use
    throughout our application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, you might be wondering when you should manually set each one of these arguments
    instead of using the default ones. The following subsections will tell you when.
  prefs: []
  type: TYPE_NORMAL
- en: QueryCache and MutationCache
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here is a small spoiler that hopefully you will review and understand better
    in the following chapters, but it is essential to understand when you should manually
    configure either `QueryCache` or `MutationCache` – all queries and mutations can
    execute some code whenever there is an error, or when its execution succeeds.
    This code is represented by the `onSuccess` and `onError` functions. Also, in
    the case of mutations, you can also execute some code before the mutation executes.
    In this scenario, the function that represents this is called `onMutate`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of `QueryCache`, this is how it would look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Before explaining the preceding snippet, let’s look at the very similar `MutationCache`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, both snippets are similar, except for the `onMutate` function
    on `MutationCache`.
  prefs: []
  type: TYPE_NORMAL
- en: By default, these functions don’t have any behavior, but if, for some reason,
    you intend on always doing something whenever you perform a mutation or a query,
    then you can do this configuration inside the respective function of the respective
    object when instantiating the cache object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you can send this object to `QueryClient` when instantiating it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we instantiated a new `QueryClient` with our custom
    `MutationCache` and `QueryCache` functions.
  prefs: []
  type: TYPE_NORMAL
- en: Logger
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Are you using `logger` outside of the `console` object in your project? Then,
    you might want to configure it in your `QueryClient`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what you need to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we created a `logger` object. This object has three
    functions that React Query will call whenever it needs to `log` an error, `warn`
    about an error, or display `error`. You can override these functions and add your
    custom logger.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, all you need to do is pass this `logger` object to your `QueryClient`
    when instantiating it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we instantiated a new `QueryClient` with our custom
    logger.
  prefs: []
  type: TYPE_NORMAL
- en: defaultOptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are options that are used as defaults for all the mutations or queries
    that you execute throughout your application. `defaultOptions` allows you to override
    these defaults. There are many defaults, and I’ll avoid showing all of them to
    avoid spoilers for the next chapters, but don’t worry – I’ll do a callback to
    these options when the right time arrives.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how you override your `defaultOptions`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: What we did in the preceding snippet was create a `defaultOptions` object and,
    inside it, a `queries` object. Inside this `queries` object, we specified that
    `staleTime` for all queries will be `Infinity`. Once again, don’t worry about
    not having a definition for this yet. You will understand it in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Once this setup is done, all you need to do is pass this `defaultOptions` object
    to your `QueryClient` when instantiating it, and all the queries will have the
    `staleTime` property set to `Infinity`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we instantiated a new `QueryClient` with our custom
    `defaultOptions` object.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, so now you are aware of `QueryClient` and should understand its role as
    the brain of React Query.
  prefs: []
  type: TYPE_NORMAL
- en: So, you might be thinking, considering that React Query is based on hooks for
    doing the queries and mutations, do we need to always pass our `QueryClient` to
    all our hooks?
  prefs: []
  type: TYPE_NORMAL
- en: Imagine if this was the case! We all would be sick and tired of all the prop
    drilling in our application even before we used our second or third hook.
  prefs: []
  type: TYPE_NORMAL
- en: Let us now see the way that React Query saves us some time by introducing `QueryClientProvider`.
  prefs: []
  type: TYPE_NORMAL
- en: QueryClientProvider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make the process of sharing our `QueryClient` easier for every developer,
    React Query resorted to something we learned about in [*Chapter 1*](B18501_01.xhtml#_idTextAnchor016),
    and that is React Context. By creating its custom provider called `QueryClientProvider`,
    React Query allows you to share `QueryClient` with all the custom hooks it provides
    automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet shows you how to use React Query’s `QueryClientProvider`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding snippet, all you need to do is import your `QueryClientProvider`
    from the `@tanstack/react-query` package, wrap your main component with it, and
    pass it to `queryClient` as a prop.
  prefs: []
  type: TYPE_NORMAL
- en: Your application is now ready to start using React Query.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us see how we can add and use React Query-dedicated developer tools.
  prefs: []
  type: TYPE_NORMAL
- en: Adding React Query Devtools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When debugging our applications, we often find ourselves thinking how amazing
    it would be to have a way to visualize what is happening inside our application.
    Well, with React Query, you don’t have to worry because it has its own developer
    tools, or devtools.
  prefs: []
  type: TYPE_NORMAL
- en: React Query Devtools allows you to see and understand the current state of all
    your queries and mutations. This will save you a lot of time debugging and avoid
    polluting all your code with unnecessary log functions, even if temporarily.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the type of project, you can install React Query Devtools in several
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are running npm in your project, run the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you are using Yarn, run the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you are using pnpm, run the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, you should have React Query Devtools installed in your application. Let’s
    now see how we can add them to our code.
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways to use Devtools. They are Floating Mode and Embedded Mode.
  prefs: []
  type: TYPE_NORMAL
- en: Floating Mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Floating Mode will render the React Query logo floating in the corner of your
    screen. By clicking on it, you can toggle Devtools on or off.
  prefs: []
  type: TYPE_NORMAL
- en: 'The logo that will show up in the corner of your screen is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_3.1_B18501.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – The React Query Devtools logo
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you toggle it, then you will see Devtools:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_3.2_B18501.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – React Query Devtools’ Floating Mode
  prefs: []
  type: TYPE_NORMAL
- en: Devtools will be rendered in your **DOM tree** inside a separate HTML element.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_3.3_B18501.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – React Query Devtools’ Floating Mode on the DOM
  prefs: []
  type: TYPE_NORMAL
- en: 'To add Devtools in Floating Mode to your application, you need to import it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Once imported, just add it as close to your `QueryClientProvider` as you can:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Embedded Mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Embedded Mode will add Devtools embedded as a regular component in your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how it looks on your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_3.4_B18501.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – React Query Devtools’ Embedded Mode
  prefs: []
  type: TYPE_NORMAL
- en: If you look at your DOM tree, you will see that Devtools is rendered like a
    regular component.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_3.5_B18501.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – React Query Devtools’ Embedded Mode on the DOM
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Devtools in Embedded Mode in your application, you need to import it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Once they are imported, just add them as close to your `QueryClientProvider`
    as possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: By default, Devtools is not included in production builds. Nevertheless, you
    might want to load them in production to help you debug something. In the next
    section, we’ll see how to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling Devtools in your production build
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you decide to load Devtools in your production environment, you must delay
    loading it and instead load it dynamically. This is important to help reduce your
    application bundle size. It is also important to lazy load Devtools because when
    using our application in production, we might never want to use it, so we want
    to avoid adding stuff to our build that we will end up not using at all. To lazy
    load components in React, we can use `React.lazy`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how we can import Devtools using `React.lazy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet wraps a `React.lazy` and assigns the return of the promise
    to `ReactQueryDevtoolsProduction`, so that we can lazily load it in our production
    environment without increasing our bundle size.
  prefs: []
  type: TYPE_NORMAL
- en: What is a dynamic import?
  prefs: []
  type: TYPE_NORMAL
- en: A dynamic import allows you to load a module from any place in your code asynchronously.
    This import will return a promise that, when fulfilled, returns an object containing
    the exports from the module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous snippet should work with all bundlers. If you are using a more
    modern bundler that supports package exports, then instead you can dynamically
    import your module like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, we change the path from where we will import our module to
    one that will work with more modern bundlers.
  prefs: []
  type: TYPE_NORMAL
- en: When using `React.lazy` and trying to render the component we just lazy loaded,
    React requires that the component should be wrapped with a **Suspense** component.
    This is important in a scenario where we want to show a fallback while our lazy-loaded
    component is pending.
  prefs: []
  type: TYPE_NORMAL
- en: What is Suspense?
  prefs: []
  type: TYPE_NORMAL
- en: '`Suspense` allows you to render a loading indication in your UI while the component
    inside of it is not ready to be rendered yet.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see what we need to do to load our `ReactQueryDevtoolsProduction` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the snippet, we wrap our `ReactQueryDevtoolsProduction` component
    with `Suspense` so it can be lazy loaded. You can also see that we didn’t provide
    any fallback since what we are trying to load are Devtools, and we don’t need
    to add any pending state while the module is loading.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we don’t want to automatically load Devtools whenever we render our component.
    What we want is a way to toggle them in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Since this is a production build, we don’t want to include a button there that
    might confuse our users. So, a potential way to handle this is by creating a function
    inside our `window` object called `toggleDevtools`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how the React Query documentation suggests we do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is what we are doing in the preceding snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a state variable to hold the current state of the Devtools. This state
    variable is updated whenever the user toggles the Devtools on or off.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Running an effect where we assign the toggle function to our `window`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside our return, when our `showDevtools` is toggled on, since we are lazy
    loading our `ReactQueryDevtoolsProduction` component, we need to wrap it with
    `Suspense` to be able to render it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, you have all that you need to start using React Query in your
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about TanStack Query and how React Query fits into
    it. By now, you should be able to identify the primary way React Query makes server
    state management easier and how it uses queries and mutations.
  prefs: []
  type: TYPE_NORMAL
- en: You learned about `QueryClient` and `QueryClientProvider` and understood how
    they are fundamental to running React Query in your application. You also learned
    how you can customize your own `QueryClient` if you need to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you got to meet the React Query Devtools and learned how to configure
    it in your project. Also, you are now able to load it into production for those
    special scenarios when you need to do some extra debugging.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 4*](B18501_04.xhtml#_idTextAnchor091), *Fetching Data with React
    Query*, you will get to know your best friend for dealing with queries, the `useQuery`
    custom hook. You’ll understand how it works, how to use it, and how it can cache
    data. You will also learn the ways you can trigger query refetches and how to
    build dependent queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: Managing Server State with React Query'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When dealing with server state, many challenges are attached to how we read
    from it. From caching to pagination, we will understand how the React Query custom
    hook called `useQuery` makes this work while giving an amazing combined developer
    and user experience.
  prefs: []
  type: TYPE_NORMAL
- en: As well as the challenges of how we read our server state, creating, updating,
    and deleting it brings about another set of challenges. Luckily, React Query has
    another custom hook that comes to the rescue called `useMutation`.
  prefs: []
  type: TYPE_NORMAL
- en: After understanding the pillars of React Query, you might be wondering whether
    popular server-side frameworks such as Next.js and Remix allow you to use React
    Query. Spoiler alert – they do, and you will learn how here.
  prefs: []
  type: TYPE_NORMAL
- en: To wrap up and make sure that you will be able to sleep well at night, you will
    learn a set of recipes you can use to test your React Query, using components
    and custom hooks by levering Mock Service Worker and the React Testing Library.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part includes the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 4*](B18501_04.xhtml#_idTextAnchor091), *Fetching Data with React
    Query*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B18501_05.xhtml#_idTextAnchor140), *More Data-Fetching Challenges*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B18501_06.xhtml#_idTextAnchor159), *Performing Data Mutations
    with React Query*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B18501_07.xhtml#_idTextAnchor173), *Server-Side Rendering with
    Next.js or Remix*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B18501_08.xhtml#_idTextAnchor184), *Testing React Query Hooks
    and Components*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
