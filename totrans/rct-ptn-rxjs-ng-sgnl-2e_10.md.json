["```js\nexport class RecipesService {\nrecipes$ = this.http.get<Recipe[]>(`${BASE_PATH}/recipes`);\n}\n```", "```js\nexport class RecipesService {\nrecipes$ =\nthis.http.get<Recipe[]>(`${BASE_PATH}/recipes`).pipe(\nshareReplay(1));\n}\n```", "```js\nimport { switchMap, shareReplay, timer } from 'rxjs/operators';\nconst REFRESH_INTERVAL = 50000;\nconst timer$ = timer(0, REFRESH_INTERVAL);\nexport class RecipesService {\nrecipes$ = timer$.pipe(\n    switchMap(_ =>\n    this.http.get<Recipe[]>(`${BASE_PATH}/recipes`)),\n    shareReplay(1)\n  );\n}\n```", "```js\nfunction shareReplay<T>(config: ShareReplayConfig): MonoTypeOperatorFunction<T>;\n```", "```js\ninterface ShareReplayConfig {\n  refCount: boolean;\n  bufferSize?: number;\n  windowTime?: number;\n  scheduler?: SchedulerLike;\n}\n```", "```js\nimport { switchMap, shareReplay, timer } from 'rxjs/operators';\nconst REFRESH_INTERVAL = 50000;\nconst timer$ = timer(0, REFRESH_INTERVAL);\nexport class RecipesService {\nrecipes$ = timer$.pipe(\n    switchMap(_ =>\n    this.http.get<Recipe[]>(`${BASE_PATH}/recipes`)),\n    shareReplay({bufferSize: 1, refCount: true })\n  );\n}\n```", "```js\n  recipes$ = timer$.pipe(\n    switchMap(_ =>\n      this.http.get<Recipe[]>(`${BASE_PATH}/recipes`)),\n    share({\n      connector: () => new ReplaySubject(),\n      resetOnRefCountZero: true,\n      resetOnComplete: true,\n      resetOnError: true\n    })\n  );\n```", "```js\nimport {map, from } from 'rxjs';\nimport { tap } from 'rxjs/operators';\nconst stream$ = from([1, 2, 'Hello', 5]);\nstream$\n  .pipe(\n    tap((value) => console.log(value)),\n    map((element) => {\n      if (isNaN(element as number)) {\n        throw new Error(element + ' is not a number');\n      }\n      return (element as number) * 2;\n    })\n  )\n  .subscribe({\n    next: (message) => console.log(message),\n    error: (error) => console.log(error),\n    complete: () => console.log('Stream Completed'),\n  });\n//console output\n1\n2\n2\n4\nHello\nError\n```"]