- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Performing Data Mutations with React Query
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用React Query执行数据突变
- en: When building applications, you won’t always need to fetch data. Sometimes,
    you will want to create, update, or delete it. When doing these actions, your
    server state will have to change.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建应用程序时，你并不总是需要获取数据。有时，你可能想要创建、更新或删除数据。在这些操作中，你的服务器状态将需要改变。
- en: React Query allows you to change your server state by using mutations. To perform
    mutations, you can leverage another of React Query’s custom hooks, called `useMutation`.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: React Query允许你通过使用突变来更改你的服务器状态。要执行突变，你可以利用React Query的另一个自定义钩子，称为`useMutation`。
- en: In this chapter, you will be introduced to the `useMutation` hook and understand
    how React Query allows you to create, update, and delete your server state. Similar
    to [*Chapter 4*](B18501_04.xhtml#_idTextAnchor091), during this process, you will
    learn about all the defaults used in your mutations. You will also be introduced
    to some options you can use to improve your `useMutation` experience.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将介绍`useMutation`钩子，并了解React Query如何允许你创建、更新和删除你的服务器状态。类似于[*第4章*](B18501_04.xhtml#_idTextAnchor091)，在这个过程中，你将了解你在突变中使用的所有默认值。你还将了解一些可以用来改进你的`useMutation`体验的选项。
- en: Once you are familiar with `useMutation`, you will get to know how you can leverage
    some of its options to perform some side-effect patterns, such as manually updating
    your data or forcing a query to update after performing a mutation.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你熟悉了`useMutation`，你将了解如何利用它的一些选项来执行一些副作用模式，例如手动更新数据或强制查询在执行突变后更新。
- en: 'At the end of this chapter, we will put together all we have learned so far
    and apply it to do something that might improve your user experience considerably:
    optimistic updates.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们将把到目前为止所学的一切整合起来，并将其应用于做一些可能显著提高用户体验的事情：乐观更新。
- en: 'In this chapter, we’ll be covering the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is `useMutation` and how does it work?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`useMutation`是什么以及它是如何工作的？'
- en: Performing side-effect patterns after mutations
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 突变后的副作用模式
- en: Performing optimistic updates
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行乐观更新
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_6](https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_6).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码示例都可以在GitHub上找到，地址为[https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_6](https://github.com/PacktPublishing/State-management-with-React-Query/tree/feat/chapter_6)。
- en: What is useMutation and how does it work?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`useMutation`是什么以及它是如何工作的？'
- en: You must be aware by now that mutations allow you to perform updates to your
    server state. These updates can be things such as creating data, removing data,
    or editing your data.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你必须已经意识到突变允许你对服务器状态进行更新。这些更新可以是创建数据、删除数据或编辑数据等操作。
- en: To allow you to perform mutations on your server data, React Query created a
    hook called `useMutation`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你能够在服务器数据上执行突变，React Query创建了一个名为`useMutation`的钩子。
- en: Now, unlike `useQuery`, which under the default circumstances runs your query
    automatically as soon as the component using it renders or some dependencies of
    it change, `useMutation` will only run your mutation when you call one of the
    functions it returns from the hook instantiation called `mutate`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，与默认情况下会自动运行查询的`useQuery`不同，`useMutation`只有在调用从钩子实例化返回的一个函数（称为`mutate`）时才会运行你的突变。
- en: 'To use the `useMutation` hook, you have to import it like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`useMutation`钩子，你必须像这样导入它：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once it is imported, you can use it to define your mutation. Here is the `useMutation`
    syntax:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦导入，你就可以用它来定义你的突变。以下是`useMutation`的语法：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see from the preceding snippet, the `useMutation` hook only needs
    one required parameter for it to work, the mutation function.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的代码片段中看到的，`useMutation`钩子只需要一个必需参数才能工作，即突变函数。
- en: What is the mutation function?
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 突变函数是什么？
- en: The mutation function is a function that returns a promise responsible for performing
    an asynchronous task. In this scenario, this asynchronous task will be our mutation.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 突变函数是一个返回负责执行异步任务的promise的函数。在这种情况下，这个异步任务将是我们的突变。
- en: The same principle we previously saw with the query function also applies to
    the mutation function. This means that, as we saw with query functions, since
    this function only needs to return a promise, it allows us again to use any asynchronous
    client of our choice. This means that REST and GraphQL are still supported, so
    you can use both options simultaneously if you desire.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到的与查询函数相同的原理也适用于mutation函数。这意味着，正如我们看到的查询函数一样，由于这个函数只需要返回一个promise，它再次允许我们使用我们选择的任何异步客户端。这意味着REST和GraphQL仍然受支持，所以如果你愿意，你可以同时使用这两个选项。
- en: 'Let us now look at an example of a mutation function using GraphQL and another
    using REST. These mutation functions will be leveraged to create a new user on
    our server state:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一个使用GraphQL和REST的mutation函数的示例。这些mutation函数将被用来在我们的服务器状态中创建新用户：
- en: Mutation with GraphQL
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GraphQL的mutation
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding snippet shows an example of using React Query to create a mutation
    with GraphQL. Here is what we are doing:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段展示了使用React Query创建GraphQL mutation的示例。以下是我们的操作：
- en: We start by creating our GraphQL mutation and assigning it to our `customQuery`
    variable.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建我们的GraphQL mutation，并将其分配给我们的`customQuery`变量。
- en: We then create the `createUserGQL` function, which will be our mutation function.
    This function will also receive as a parameter the `user` data to be used by our
    mutation to create the data on the server.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们创建`createUserGQL`函数，这个函数将成为我们的mutation函数。这个函数也将接收作为参数的`user`数据，这些数据将被我们的mutation用于在服务器上创建数据。
- en: In our `useMutation` hook, we pass our `createUserGQL` function as the mutation
    function to the hook.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`useMutation`钩子中，我们将`createUserGQL`函数作为mutation函数传递给钩子。
- en: 'Let us now see how to do this using REST:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用REST来完成这个操作：
- en: Mutation with REST
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用REST的mutation
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding snippet, we can see an example of using React Query to create
    a mutation with REST. Here is what we are doing:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们可以看到一个使用React Query创建REST的mutation的示例。以下是我们的操作：
- en: We start by creating the `createUser` function, which will be our mutation function.
    This function will receive as a parameter the `user` data used by our mutation
    to create the data on the server. Here, we know we are going to be creating data
    on the server due to the use of the `POST` method.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建`createUser`函数，这个函数将成为我们的mutation函数。这个函数将接收作为参数的`user`数据，这些数据用于我们的mutation在服务器上创建数据。在这里，我们知道我们将使用`POST`方法在服务器上创建数据。
- en: In our `useMutation` hook, we pass to the hook our `createUser` function as
    the mutation function.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`useMutation`钩子中，我们将`createUser`函数作为mutation函数传递给钩子。
- en: 'In the preceding example, we used `axios`, but if you prefer using `fetch`
    over `axios`, all you have to do is inside the `createUser` function, replace
    `axios` with `fetch` and apply the required changes for `fetch` to work. Here
    is an example of what you would need to do to use `fetch`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用了`axios`，但如果你更喜欢使用`fetch`而不是`axios`，你只需要在`createUser`函数内部将`axios`替换为`fetch`，并对`fetch`进行必要的修改以使其工作。以下是一个使用`fetch`的示例：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding snippet, we can see an example of our `createUser` function
    shown previously, but this time, we used `fetch` instead of `axios`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们可以看到之前展示的`createUser`函数的示例，但这次我们使用了`fetch`而不是`axios`。
- en: Now that we are familiar with the mutation function, we need to understand how
    the `useMutation` hook leverages this function to allow us to perform our mutations.
    In the next section, we will learn about how the `mutate` function enables us
    to do this, as well as other things `useMutation` returns.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了mutation函数，我们需要了解`useMutation`钩子如何利用这个函数来允许我们执行mutations。在下一节中，我们将学习`mutate`函数如何使我们能够这样做，以及`useMutation`返回的其他内容。
- en: What does useMutation return?
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: useMutation返回什么？
- en: Like `useQuery`, when using the `useMutation` hook, it returns a couple of values.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 和`useQuery`一样，当使用`useMutation`钩子时，它返回几个值。
- en: As mentioned throughout this chapter so far, to perform mutations, we need to
    leverage `mutate`. Now, `mutate` is not the only way to perform mutations and
    is also not the only thing `useMutation` returns.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所述，要执行mutations，我们需要利用`mutate`。现在，`mutate`不是执行mutations的唯一方式，也不是`useMutation`返回的唯一内容。
- en: 'In this section, we’ll review the following returns of the `useMutation` hook:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾`useMutation`钩子的以下返回值：
- en: '`mutate`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mutate`'
- en: '`mutateAsync`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mutateAsync`'
- en: '`data`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`数据`'
- en: '`error`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`错误`'
- en: '`reset`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`重置`'
- en: '`status`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`状态`'
- en: '`isPaused`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isPaused`'
- en: mutate
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`mutate`'
- en: After creating your mutation with your `useMutation` hook, you need a way to
    trigger it. `mutate` is the function you will need almost every time to do so.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用你的 `useMutation` 钩子创建你的变更后，你需要一种方法来触发它。`mutate` 是你几乎每次都需要用来做到这一点的函数。
- en: 'Here is how you can use `mutate`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何使用 `mutate`：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this snippet, we do the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们做以下操作：
- en: We destructure our `mutate` function from our `useMutation` hook.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从 `useMutation` 钩子中解构出我们的 `mutate` 函数。
- en: We call the `mutate` function with the variables our mutation function is expecting
    to receive to perform our mutation.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `mutate` 函数并传递变量，这些变量是我们期望 `mutate` 函数接收以执行我们的变更。
- en: That’s it; that is how you can perform mutations with React Query. You create
    your mutation function, pass it to your `useMutation` hook, destructure `mutate`
    from it, and call it with the required parameters to perform your mutation whenever
    you want.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样；这就是你如何使用 React Query 来执行变更。你创建你的变更函数，将其传递给你的 `useMutation` 钩子，从其中解构出 `mutate`，并使用所需的参数调用它以执行你的变更。
- en: 'Now, the preceding snippet serves to show how you can trigger mutations by
    using `mutate` but isn’t a very practical example. To help you create a mental
    model of how you can use `mutate` to perform mutations, you can refer to the following
    snippet:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，前面的代码片段旨在展示如何通过使用 `mutate` 来触发变更，但这不是一个非常实用的例子。为了帮助你构建如何使用 `mutate` 来执行变更的心理模型，你可以参考以下代码片段：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the preceding snippet, we can see an example of a simple form using a controlled
    component. This is what is happening in the preceding snippet:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们可以看到一个使用受控组件的简单表单示例。这就是前面代码片段中发生的事情：
- en: We create the `createUser` mutation function, which will receive a `user` object
    with some data.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个 `createUser` 变更函数，它将接收一个包含一些数据的 `user` 对象。
- en: Inside this function, we return the invocation of the `axios` client’s `post`
    method, which will return the promise that `useMutation` expects to receive for
    its mutation function.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数内部，我们返回 `axios` 客户端的 `post` 方法的调用，这将返回 `useMutation` 期望接收的用于变更函数的承诺。
- en: 'Inside our `SimpleMutation` component, we do the following:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 `SimpleMutation` 组件内部，我们做以下操作：
- en: We create a state variable to control the state of our input.
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个状态变量来控制输入的状态。
- en: We create our mutation using the `createUser` function as the mutation function
    and destructure `mutate` from it.
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `createUser` 函数作为变更函数来创建我们的变更，并从其中解构出 `mutate`。
- en: We create a `submitForm` function. This function will receive the event from
    the form and prevent it from propagating so your page is not refreshed. After
    handling the event, it triggers the mutation and passes it the `name` state variable
    as part of the `user` object by calling `mutate`.
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个 `submitForm` 函数。这个函数将接收表单的事件并阻止其传播，这样你的页面就不会刷新。在处理事件后，它通过调用 `mutate`
    触发变更，并将 `name` 状态变量作为 `user` 对象的一部分传递。
- en: Inside our form, we create our input to handle our `name` and have React control
    its state.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的表单内部，我们创建我们的输入来处理 `name` 并让 React 控制其状态。
- en: We create a button with an `onClick` event to fire our `submitForm` function.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个带有 `onClick` 事件的按钮来触发我们的 `submitForm` 函数。
- en: As you should understand from the preceding explanation and code, whenever we
    click on the `POST` request to our URL with the current value of our input.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你应该从前面的解释和代码中理解的那样，每当我们点击使用当前输入值的 `POST` 请求到我们的 URL 时。
- en: One thing you’ll also see while proceeding with this chapter is that `mutate`
    can also receive some options to perform side effects if you desire to. But let’s
    leave these details for later.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续本章的过程中，你还会看到 `mutate` 也可以接收一些选项来执行副作用，如果你需要的话。但让我们把这些细节留到以后再说。
- en: 'While `mutate` is the staple for performing mutations in React Query, there
    is also another function you can use if you so desire: `mutateAsync`.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `mutate` 是在 React Query 中执行变更的基础，但如果你愿意，你也可以使用另一个函数：`mutateAsync`。
- en: mutateAsync
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: mutateAsync
- en: While in most scenarios you will use `mutate`, sometimes you might want to access
    the promise that contains the result of your mutation. In these scenarios, you
    can use `mutateAsync`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你会使用 `mutate`，但有时你可能想访问包含你变更结果的承诺。在这些情况下，你可以使用 `mutateAsync`。
- en: One thing to keep in mind while using `mutateAsync` is that you need to handle
    the promise yourself. This means that in an error scenario, you need to catch
    the error.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `mutateAsync` 时，需要注意的一点是你需要自己处理承诺。这意味着在错误场景中，你需要捕获错误。
- en: 'Here is how you can use the `mutateAsync` function:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何使用 `mutateAsync` 函数：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding snippet, we destructure the `mutateAsync` function from the
    `useMutation` hook:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们从`useMutation`钩子中解构了`mutateAsync`函数：
- en: We need to handle potential error scenarios, so we wrap our `mutateAsync` call
    with a `try-catch` statement. Since this is an asynchronous function, we must
    wait for the data to be returned.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要处理潜在的错误场景，因此我们将`mutateAsync`调用用`try-catch`语句包裹起来。由于这是一个异步函数，我们必须等待数据返回。
- en: If there is an error, we catch it and show an error in our console.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果出现错误，我们会捕获它并在我们的控制台中显示错误。
- en: 'The preceding snippet shows how you can trigger mutations by using `mutateAsync`;
    as we showed in `mutate`, it doesn’t seem to be a very practical example. To help
    you create a mental model of how you can use `mutateAsync` to perform mutations,
    you can see the following snippet:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段显示了如何使用`mutateAsync`触发突变；正如我们在`mutate`中所示，这似乎不是一个非常实用的例子。为了帮助你创建如何使用`mutateAsync`执行突变的心理模型，你可以看到以下代码片段：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding snippet, we can see an example of a simple form using a controlled
    component where we leverage `mutateAsync` to perform concurrent mutations. This
    is what is happening in the code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们可以看到一个使用受控组件的简单表单示例，其中我们利用`mutateAsync`执行并发突变。这就是代码中发生的事情：
- en: We create a state variable to control the state of our input.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个状态变量来控制输入的状态。
- en: We create our first mutation using the `createUser` function as the mutation
    function and destructure `mutateAsync` as `mutateAsyncOne` from it.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`createUser`函数作为突变函数来创建我们的第一个突变，并从其中解构`mutateAsync`为`mutateAsyncOne`。
- en: We create our second mutation using the `registerUser` function as the mutation
    function and destructure `mutateAsync` as `mutateAsyncTwo` from it.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`registerUser`函数作为突变函数来创建我们的第二个突变，并从其中解构`mutateAsync`为`mutateAsyncTwo`。
- en: 'We create a `submitForm` function:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个`submitForm`函数：
- en: This function will receive the event from the form and prevent it from propagating
    so your page is not refreshed.
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数将接收来自表单的事件并阻止其传播，这样你的页面就不会刷新。
- en: We assign the promise returned from the call of `mutationAsyncOne` with `name`
    as a parameter to our `mutationOne` variable.
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将调用`mutationAsyncOne`并传递`name`作为参数返回的承诺分配给我们的`mutationOne`变量。
- en: We assign the promise returned from the call of `mutationAsyncTwo` with `name`
    as a parameter to our `mutationTwo` variable.
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将调用`mutationAsyncTwo`并传递`name`作为参数返回的承诺分配给我们的`mutationTwo`变量。
- en: We leverage the `Promise.all` method and pass it to our `mutationOne` and `mutationTwo`
    promises so they can be performed concurrently.
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们利用`Promise.all`方法并将其传递给我们的`mutationOne`和`mutationTwo`承诺，以便它们可以并发执行。
- en: Inside our form, we create our input to handle our name and have React control
    its state.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的表单内部，我们创建输入来处理我们的名称，并让React控制其状态。
- en: We create a button with an `onClick` event to fire our `submitForm` function.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个带有`onClick`事件的按钮来触发我们的`submitForm`函数。
- en: Now that you are familiar with how you can perform mutations, let’s review a
    variable that is impacted by the success of a mutation, `data`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经熟悉了如何执行突变，让我们回顾一下受突变成功影响的变量，`data`。
- en: data
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: data
- en: This variable is the last successfully resolved `data` of the mutation returned
    from your mutation function.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变量是突变函数返回的最后成功解析的`data`。
- en: 'Here is how you can use the `data` variable:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何使用`data`变量的示例：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this snippet, we do the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们做了以下操作：
- en: We destructure our `data` variable from our `useMutation` hook.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从`useMutation`钩子中解构了我们的`data`变量。
- en: On our component return, we check whether we already have `data` from our mutation.
    If we do, we render it.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的组件返回时，我们检查是否已经从我们的突变中获取了`data`。如果是，我们就渲染它。
- en: When the hook renders initially, this `data` will be undefined. Once the mutation
    triggers and finishes executing, and the promise returned from the mutation function
    successfully resolves our data, we will have access to the `data`. If for some
    reason our mutation function promise rejects, we can use the next variable, the
    `error` one.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当钩子最初渲染时，这个`data`将是未定义的。一旦突变触发并完成执行，并且突变函数返回的承诺成功解析了我们的数据，我们就可以访问`data`。如果由于某种原因突变函数的承诺被拒绝，我们可以使用下一个变量，即`error`变量。
- en: error
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: error
- en: The `error` variable lets you access the `error` object returned from your mutation
    function after failing.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`error`变量让你可以访问突变函数返回的失败后的`error`对象。'
- en: 'Here is how you can use the `error` variable:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何使用`error`变量的示例：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the preceding snippet, we do the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们做了以下操作：
- en: We destructure our `error` variable from our `useQuery` hook.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从`useQuery`钩子中解构我们的`error`变量。
- en: On our component return, we check whether we have any errors. If we do, we render
    the error message.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的组件返回时，我们检查是否有任何错误。如果有，我们将渲染错误信息。
- en: When the hook renders initially, the `error` value will be null. If, after a
    mutation, for some reason the mutation function rejects and throws an error, then
    this error will be assigned to our `error` variable. It is important to mention
    here that this only applies if you are using `mutate`. If you use `mutateAsync`,
    you must catch the error and handle it yourself.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当钩子最初渲染时，`error`值将是null。如果在突变之后，由于某种原因突变函数拒绝并抛出错误，那么这个错误将被分配给我们的`error`变量。在这里重要的是要提到，这仅适用于你使用`mutate`的情况。如果你使用`mutateAsync`，你必须自己捕获错误并处理它。
- en: When using the `error` variable, there will be times for the sake of user experience
    when you want to clear your errors. In those scenarios, the `reset` function will
    be your best friend.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`error`变量时，有时为了用户体验，你可能想要清除你的错误。在这些情况下，`reset`函数将成为你的最佳选择。
- en: reset
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: reset
- en: The `reset` function allows you to reset `error` and `data` to their initial
    state.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`reset`函数允许你将`error`和`data`重置到它们的初始状态。'
- en: This function is useful if you need to clear the current value of data or errors
    after running a mutation.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数在你需要在运行突变后清除当前数据或错误值时很有用。
- en: 'Here is how you can use the `reset` function:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你可以使用`reset`函数的方法：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this snippet, we do the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们做了以下操作：
- en: We destructure our `data` and `error` variables and the `reset` function from
    our `useMutation` hook.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从`useMutation`钩子中解构`data`、`error`变量和`reset`函数。
- en: On our component return, we check whether we already have data or errors from
    our mutation. When and if we do, we render them.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的组件返回时，我们检查是否已经从我们的突变中获得了数据或错误。当且仅当我们这样做时，我们将渲染它们。
- en: We also render a button with an `onClick` event. When clicked, this button will
    trigger our `reset` function to clear our `data` and `error` values.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还渲染了一个带有`onClick`事件的按钮。当点击这个按钮时，它将触发我们的`reset`函数来清除我们的`data`和`error`值。
- en: Now, to use the `error` and `data` variables, we just check in the code whether
    they are defined to allow us to render them. To make this easier and once again
    help you craft a better user experience in your application, you can resort to
    using the `status` variable.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了使用`error`和`data`变量，我们只需在代码中检查它们是否已定义，以便我们可以渲染它们。为了使这更容易，并且再次帮助你为你的应用程序制作更好的用户体验，你可以求助于使用`status`变量。
- en: status
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: status
- en: Like queries, when performing a mutation, the mutation can go through several
    states. These states help you to give more feedback to your users. For you to
    know what the current state of your mutation is, the `status` variable was created.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 就像查询一样，当执行突变时，突变可以经过几个状态。这些状态帮助你向用户提供更多反馈。为了知道你的突变当前的状态，我们创建了`status`变量。
- en: 'Here are the states that the `status` variable can have:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`status`变量可以具有以下状态：'
- en: '`idle`: This is the initial status of your mutation before being executed.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`idle`：这是你的突变在执行之前的初始状态。'
- en: '`loading`: This indicates if your mutation is currently executing.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loading`：这表示你的突变是否正在执行。'
- en: '`error`: This indicates that there was an error while performing the last mutation.
    Whenever this is the status, the `error` property will receive the error returned
    from the mutation function.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error`：这表示在执行最后一个突变时出现了错误。每当这是状态时，`error`属性将接收从突变函数返回的错误。'
- en: '`success`: Your last mutation was successful, and it has returned data. Whenever
    this is the status, the `data` property will receive the successful data from
    the mutation function.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`success`：你的最后一个突变是成功的，并且它已经返回了数据。每当这是状态时，`data`属性将接收从突变函数返回的成功数据。'
- en: 'Here is how you can use the `status` variable:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你可以使用`status`变量的方法：
- en: '[PRE12]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the preceding snippet, we are leveraging the `status` variable to create
    a better user experience for our users. Here is what we are doing:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，我们正在利用`status`变量来为我们的用户提供更好的用户体验。以下是我们在做些什么：
- en: We create a state variable to handle our controlled form.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个状态变量来处理我们的受控表单。
- en: We create our mutation and destructure `status` from the `useMutation` hook.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建我们的突变并从`useMutation`钩子中解构`status`。
- en: We create a `submitForm` function to handle our mutation submission.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个`submitForm`函数来处理我们的突变提交。
- en: 'We leverage our `status` variables to do the following in our component return:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们利用我们的`status`变量在我们的组件返回中执行以下操作：
- en: If `status` is `idle`, we render a message letting the user know our mutation
    hasn’t run.
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`status`是`idle`，我们将渲染一条消息，让用户知道我们的突变尚未运行。
- en: If `status` equals `error`, we must destructure our `error` variable and display
    the error message.
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`status`等于`error`，我们必须解构我们的`error`变量并显示错误消息。
- en: If `status` equals `success`, we must destructure our `data` variable and display
    it to our user.
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`status`等于`success`，我们必须解构我们的`data`变量并将其显示给我们的用户。
- en: If `status` equals `loading`, it means we are executing a mutation, so we use
    this to make sure we disable our **Add** button and avoid the user clicking it
    again while the mutation runs.
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`status`等于`loading`，这意味着我们正在执行一个突变，因此我们使用这个选项来确保我们禁用我们的**添加**按钮，避免在突变运行期间用户再次点击它。
- en: 'Now, you know how to use the `status` variable. For convenience, React Query
    also introduced some Boolean variants to help identify each state. They are as
    follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您知道了如何使用`status`变量。为了方便，React Query还引入了一些布尔变体，以帮助识别每个状态。它们如下所示：
- en: '`isIdle`: Your `status` variable is in the idle state'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isIdle`：您的`status`变量处于空闲状态'
- en: '`isLoading`: Your `status` variable is in the loading state'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isLoading`：您的`status`变量处于加载状态'
- en: '`isError`: Your `status` variable is in the error state'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isError`：您的`status`变量处于错误状态'
- en: '`isSuccess`: Your `status` variable is in the success state'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isSuccess`：您的`status`变量处于成功状态'
- en: 'Let’s now rewrite our previous snippet leveraging our `status` Boolean variants:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在重写我们之前的代码片段，利用我们的`status`布尔变体：
- en: '[PRE13]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, the code is similar. All we had to do was replace our `status`
    variable with `isLoading`, `isError`, `isSuccess`, and `isIdle` in the destructuring
    part and then use these variables in the respective status check.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，代码是相似的。我们只需在解构部分将我们的`status`变量替换为`isLoading`、`isError`、`isSuccess`和`isIdle`，然后在相应的状态检查中使用这些变量。
- en: Unlike queries, mutations don’t have a `fetchStatus` variable. Now, this doesn’t
    mean that your mutation cannot suffer from a sudden loss of internet connection.
    To give more feedback to your users, the `isPaused` variable was created.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 与查询不同，突变没有`fetchStatus`变量。这并不意味着您的突变不能因突然断开互联网连接而受到影响。为了给用户提供更多反馈，我们创建了`isPaused`变量。
- en: isPaused
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: isPaused
- en: As you should remember from [*Chapter 4*](B18501_04.xhtml#_idTextAnchor091),
    React Query introduced a new property called `networkMode`. When used in online
    mode, you can access a new variable in your `useMutation` hook called `isPaused`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如您应从[*第4章*](B18501_04.xhtml#_idTextAnchor091)中记住，React Query引入了一个名为`networkMode`的新属性。当在线模式下使用时，您可以在`useMutation`钩子中访问一个新变量，称为`isPaused`。
- en: This Boolean variable identifies whether your mutation is currently paused due
    to a lost connection.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个布尔变量标识您的突变是否因断开连接而当前暂停。
- en: 'Let us see how to use the `isPaused` variable:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`isPaused`变量：
- en: '[PRE14]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding snippet, we leverage the `isPaused` variable to craft a better
    user experience in our application:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们利用`isPaused`变量来在我们的应用程序中创建更好的用户体验：
- en: We destructure our `isPaused` variable from our `useMutation` hook.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从`useMutation`钩子中解构我们的`isPaused`变量。
- en: In our component return, we check whether `isPaused` is `true`. If so, we render
    a message to let our users know. We also assign it to disable our **Add** button
    to avoid the user accidentally triggering another mutation.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的组件返回中，我们检查`isPaused`是否为`true`。如果是，我们渲染一条消息让我们的用户知道。我们还将其分配给禁用我们的**添加**按钮，以避免用户意外触发另一个突变。
- en: Now that we know some of the values our `useMutation` hook returns, let’s see
    how we can customize this hook with some options.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了`useMutation`钩子返回的一些值，让我们看看我们如何使用一些选项来自定义这个钩子。
- en: Commonly used mutation options explained
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常用突变选项解释
- en: Like the `useQuery` hook, more options can be passed into our `useMutation`
    hook than just its mutation function. These options will also help us craft a
    better developer and user experience.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 与`useQuery`钩子类似，我们可以向`useMutation`钩子传递比其突变函数更多的选项。这些选项也将帮助我们创建更好的开发者和用户体验。
- en: In this section, we’ll see some options that are more common and very important
    for you to be aware of.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到一些更常见且非常重要的选项。
- en: 'Here are the options we’ll look at:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们将要查看的选项：
- en: '`cacheTime`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cacheTime`'
- en: '`mutationKey`'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mutationKey`'
- en: '`retry`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`retry`'
- en: '`retryDelay`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`retryDelay`'
- en: '`onMutate`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onMutate`'
- en: '`onSuccess`'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onSuccess`'
- en: '`onError`'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onError`'
- en: '`onSettled`'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onSettled`'
- en: cacheTime
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: cacheTime
- en: The `cacheTime` option is the duration in milliseconds that the data in your
    cache that is inactive remains in memory. Once this time passes, the data will
    be garbage collected. Note that this does not work the same way as it does with
    queries. If you perform a mutation, the returned data is cached, but if you perform
    the same mutation again while this mutation is pending, `useMutation` won’t return
    the previous mutation data. In mutations, this option is mostly useful for preventing
    previous mutation data from being held in `MutationCache` indefinitely.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`cacheTime`选项是您的缓存中不活跃数据在内存中保持的时间（以毫秒为单位）。一旦这个时间过去，数据将被垃圾回收。请注意，这与查询的方式不同。如果您执行了一个突变，返回的数据将被缓存，但如果在突变挂起期间再次执行相同的突变，`useMutation`将不会返回之前的突变数据。在突变中，此选项主要用于防止之前的突变数据无限期地保留在`MutationCache`中。'
- en: 'Here is how to use the `cacheTime` option:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何使用`cacheTime`选项：
- en: '[PRE15]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this snippet, we define that after our mutation is inactive for one minute,
    the data will be garbage collected.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们定义了在突变不活跃一分钟之后，数据将被垃圾回收。
- en: mutationKey
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: mutationKey
- en: Sometimes you will want to set some defaults for all your mutations by leveraging
    your `queryClient` `setMutationDefaults`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您会想通过利用您的`queryClient`的`setMutationDefaults`来为所有突变设置一些默认值。
- en: The `mutationKey` option allows React Query to know whether it needs to apply
    previously configured defaults to this mutation.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`mutationKey`选项允许React Query知道是否需要将之前配置的默认值应用于此突变。'
- en: 'Here is how to use the `mutationKey` option:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何使用`mutationKey`选项：
- en: '[PRE16]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding snippet, we create a mutation with `["myUserMutation"]` as
    the mutation key. If any defaults were configured to be applied to any mutation
    with `["myUserMutation"]` as the mutation key, they would now be applied.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用`["myUserMutation"]`作为突变键创建了一个突变。如果为任何具有`["myUserMutation"]`作为突变键的突变配置了默认值，它们现在将被应用。
- en: retry
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重试
- en: The `retry` option is a value that indicates whether your mutation will retry
    or not when it fails. When `true`, it will retry until it succeeds. When `false`,
    it won’t retry.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`retry`选项是一个值，表示当突变失败时，您的突变是否会重试。当为`true`时，它会重试直到成功。当为`false`时，它不会重试。'
- en: This property can also be a number. When it is a number, the mutation will retry
    that specified number of times.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性也可以是一个数字。当它是一个数字时，突变将重试指定次数。
- en: '*By default, React Query will not retry a mutation* *on error.*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，React Query不会在出错时重试突变。
- en: 'Here is how to use the `retry` option:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何使用`retry`选项：
- en: '[PRE17]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the snippet, we set the `retry` option to `2`. This means that when failing
    to perform a mutation, this hook will retry performing the mutation two times.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们将`retry`选项设置为`2`。这意味着当执行突变失败时，此钩子将重试执行突变两次。
- en: retryDelay
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: retryDelay
- en: The `retryDelay` option is the delay to apply before the next retry attempt
    in milliseconds.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`retryDelay`选项是在下一次重试尝试之前应用的延迟（以毫秒为单位）。'
- en: By default, React Query uses an exponential backoff delay algorithm to define
    the retry timing between retries.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，React Query使用指数退避延迟算法来定义重试之间的时间间隔。
- en: 'Here is how to use the `retryDelay` option:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何使用`retryDelay`选项：
- en: '[PRE18]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the snippet, we define a linear backoff function as our `retryDelay` option.
    Every time there is a retry, this function receives the attempt number and multiplies
    it by 2,000\. This means that the time between every retry will be two seconds
    longer.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码片段中，我们定义了一个线性退避函数作为我们的`retryDelay`选项。每次重试时，此函数都会接收尝试次数并将其乘以2,000。这意味着每次重试之间的时间将增加两秒。
- en: onMutate
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: onMutate
- en: The `onMutate` option is a function that will be triggered before your mutation
    function is fired. This function also receives the variables your mutation function
    will receive.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`onMutate`选项是一个在您的突变函数被触发之前会调用的函数。此函数还会接收您的突变函数将接收的变量。'
- en: 'You can return values from this function that will be passed to your `onError`
    and `onSettled` callback functions:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从这个函数返回值，这些值将被传递到您的`onError`和`onSettled`回调函数中：
- en: '[PRE19]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this snippet, we pass an arrow function to our `onMutate` option. When our
    mutation is triggered, this function assigned to the `onMutate` option will be
    called with the variables your mutation function will receive. We then use these
    variables to show a notification to the user about the pending mutation.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们将一个箭头函数传递到我们的`onMutate`选项中。当我们的突变被触发时，分配给`onMutate`选项的函数将使用这些变量调用，然后我们使用这些变量向用户显示有关挂起突变的提示。
- en: onSuccess
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: onSuccess
- en: The `onSuccess` option is a function that will be triggered when your mutation
    is successful.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`onSuccess`选项是一个函数，当你的突变成功时将被触发。'
- en: If a promise is returned from this function, it will be awaited and resolved.
    This means your mutation status will be in a loading state until the promise resolves.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此函数返回一个承诺，它将被等待并解决。这意味着你的突变状态将处于加载状态，直到承诺解决。
- en: 'This is how to use the `onSuccess` option:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何使用`onSuccess`选项的方法：
- en: '[PRE20]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the snippet, we pass an arrow function to our `onSuccess` option. When our
    mutation performs successfully, this function assigned to the `onSuccess` option
    will be called with our data. We then use this data to log a message to our console.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码片段中，我们向`onSuccess`选项传递一个箭头函数。当我们的突变成功执行时，分配给`onSuccess`选项的此函数将使用我们的数据被调用。然后我们使用这些数据在我们的控制台中记录一条消息。
- en: onError
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: onError
- en: The `onError` option is a function that will be triggered when your mutation
    fails.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`onError`选项是一个函数，当你的突变失败时将被触发。'
- en: If a promise is returned from this function, it will be awaited and resolved.
    This means your mutation status will be in a loading state until the promise resolves.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此函数返回一个承诺，它将被等待并解决。这意味着你的突变状态将处于加载状态，直到承诺解决。
- en: 'This is how to use the `onError` option:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何使用`onError`选项的方法：
- en: '[PRE21]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the snippet, we pass an arrow function to our `onError` option. When the
    mutation fails, this function assigned to the `onError` option will be called
    with the thrown error. We then log the error in our console.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码片段中，我们向`onError`选项传递一个箭头函数。当突变失败时，分配给`onError`选项的此函数将使用抛出的错误被调用。然后我们在我们的控制台中记录错误。
- en: onSettled
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: onSettled
- en: The `onSettled` option is a function that will be triggered when your mutation
    is either successful or fails.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`onSettled`选项是一个函数，当你的突变成功或失败时将被触发。'
- en: If a promise is returned from this function, it will be awaited and resolved.
    This means your mutation status will be in a loading state until the promise resolves.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此函数返回一个承诺，它将被等待并解决。这意味着你的突变状态将处于加载状态，直到承诺解决。
- en: 'This is how to use the `onSettled` option:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何使用`onSettled`选项的方法：
- en: '[PRE22]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the snippet, we pass an arrow function to our `onSettled` option. When the
    mutation fails or succeeds, this function assigned to the `onSettled` option will
    be called with the thrown error or the resolved data. We then log a message in
    our console.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码片段中，我们向`onSettled`选项传递一个箭头函数。当突变成功或失败时，分配给`onSettled`选项的此函数将使用抛出的错误或解决的数据被调用。然后我们在我们的控制台中记录一条消息。
- en: By now, you should be familiar with how the `useMutation` hook works and should
    be able to start using it to create, update, or delete your server state data.
    Now, let us see how we can leverage this hook and some of its options to perform
    some common side-effect patterns.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该已经熟悉了`useMutation`钩子的用法，并且应该能够开始使用它来创建、更新或删除你的服务器状态数据。现在，让我们看看我们如何利用这个钩子和一些选项来执行一些常见的副作用模式。
- en: Performing side-effect patterns after mutations
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在突变之后执行副作用模式
- en: 'As you read this section title, you might have been wondering whether you’ve
    seen how to perform side effects after your mutations previously. The answer is
    yes, you already did. To perform side effects after a mutation, you can leverage
    any of these options:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当你阅读这个标题时，你可能想知道你是否以前见过如何在突变之后执行副作用。答案是肯定的，你已经做到了。要执行突变后的副作用，你可以利用这些选项中的任何一个：
- en: '`onMutate`'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onMutate`'
- en: '`onSuccess`'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onSuccess`'
- en: '`onError`'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onError`'
- en: '`onSettled`'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onSettled`'
- en: Now, what you haven’t seen is how you can leverage these side effects to do
    some amazing things that might improve your user experience, such as performing
    multiple side effects, refetching a query, or even updating your query data after
    a mutation.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能还没有看到如何利用这些副作用来做一些可能改善用户体验的惊人事情，比如执行多个副作用、重新获取查询，甚至在突变后更新查询数据。
- en: In this section, we will review some ways we leverage the callback functions
    of our `useMutation` hook and more to perform the previously mentioned side effects.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾一些我们如何利用`useMutation`钩子的回调函数以及更多内容来执行之前提到的副作用。
- en: How to perform an additional side effect
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何执行额外的副作用
- en: During development, a scenario may come up where it would be useful if you could
    perform two `onSuccess` callbacks. Now, you can definitely add as much logic as
    you want to your `useMutation` hook callback, but what if you wanted to split
    the logic or only execute this specific logic on one single mutation? This would
    indeed be useful because you could separate the concerns and logic. Well, you
    can definitely do it!
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，可能会出现一个场景，如果你能够执行两个 `onSuccess` 回调将会很有用。现在，你当然可以在你的 `useMutation` 钩子回调中添加你想要的任何逻辑，但如果你想要拆分逻辑或者只在一个单独的变异上执行这个特定的逻辑呢？这确实很有用，因为你可以分离关注点和逻辑。嗯，你当然可以做到！
- en: The `mutate` function allows you to create your own callback functions that
    will execute after your `useMutation` callbacks.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`mutate` 函数允许你创建自己的回调函数，这些函数将在你的 `useMutation` 回调之后执行。'
- en: You just need to be aware that your `useMutation` callbacks run first, and then
    your `mutate` function callbacks. This is important to know because sometimes
    if you do something that causes your hook to unmount on your `useMutation` callback,
    your `mutate` function callbacks might not be called after.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要意识到你的 `useMutation` 回调先执行，然后是你的 `mutate` 函数回调。这一点很重要，因为有时候如果你在 `useMutation`
    回调中做了某些导致钩子卸载的操作，你的 `mutate` 函数回调可能不会执行。
- en: 'Here is an example of how to use the `mutate` callback functions:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个如何使用 `mutate` 回调函数的例子：
- en: '[PRE23]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the preceding snippet, we leverage the `mutate` callback functions to perform
    some extra side effects. Here is what we are doing:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们利用 `mutate` 回调函数来执行一些额外的副作用。以下是我们的操作：
- en: We create our mutation with `useMutation`.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `useMutation` 创建我们的变异。
- en: Inside this mutation, we leverage the `onSuccess` callback, which will receive
    the resolved data and display a toast to the user to let them know that data was
    created.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个变异内部，我们利用 `onSuccess` 回调，它将接收解析后的数据并向用户显示一个提示，告诉他们数据已被创建。
- en: We then create a `submitForm` function that will be given to an `onSubmit` event
    later on in our code.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们随后创建一个 `submitForm` 函数，该函数将在我们的代码中的某个 `onSubmit` 事件中被提供。
- en: When triggered, this function will prevent the received event from propagating.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当被触发时，这个函数将阻止接收的事件传播。
- en: This function will also trigger our mutation by calling `mutate`. In this `mutate`,
    we leverage its `onSuccess` callback to trigger a route change.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数将通过调用 `mutate` 来触发我们的变异。在这个 `mutate` 中，我们利用它的 `onSuccess` 回调来触发路由更改。
- en: Now that we know how to use the `mutate` callback functions to perform some
    extra side effects, let’s see how we can retrigger a query after performing a
    mutation.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何使用 `mutate` 回调函数来执行一些额外的副作用，让我们看看如何在执行变异后重新触发查询。
- en: How to retrigger a query refetch after mutation
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何在变异后重新触发查询的重新获取
- en: When performing mutations that will change the data of a query you are currently
    displaying to your users, it is recommended that you refetch that query. This
    is because, at this time, you know that this data has changed, but if your query
    is still marked as fresh internally, React Query won’t refetch it; therefore,
    you must do it yourself.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行将改变你当前向用户显示的查询数据的变异时，建议你重新获取该查询。这是因为，在这个时候，你知道数据已经改变，但如果你的查询仍然被标记为内部新鲜，React
    Query 不会重新获取它；因此，你必须自己来做。
- en: Having read the previous two chapters, when you read this section title, something
    must have come to your mind, and that is query invalidation!
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读了前面的两个章节后，当你阅读这个标题时，你肯定会有所思考，那就是查询无效化！
- en: 'Here is how you can leverage the `onSuccess` callback to retrigger a query
    refetch:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何利用 `onSuccess` 回调来重新触发查询的重新获取：
- en: '[PRE24]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the preceding snippet, we leverage our `onSuccess` callback to retrigger
    a query after a successful mutation. Here is what we are doing:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们利用 `onSuccess` 回调在变异成功后重新触发查询。以下是我们的操作：
- en: We get access to `queryClient`.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以访问 `queryClient`。
- en: We create our query with `["allUsers"]` as a query key.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `["allUsers"]` 作为查询键创建我们的查询。
- en: We create our mutation. In this mutation `onSuccess` callback, we leverage our
    `queryClient` `invalidateQueries` method to trigger a refetch of our query with
    `["allUsers"]` as the query key.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建我们的变异。在这个变异的 `onSuccess` 回调中，我们利用我们的 `queryClient` 的 `invalidateQueries`
    方法来触发带有 `["allUsers"]` 作为查询键的查询的重新获取。
- en: 'As mentioned at the beginning of this section, this is a recommended practice,
    and you should do it every time you are mutating data your user sees on the page.
    Now, you might be thinking: if our mutation was successful, it might have returned
    the new data, so can’t we just manually update our query data and avoid an extra
    request?'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节开头所述，这是一个推荐的做法，每次你正在变异用户在页面上看到的数据时，都应该这样做。现在，你可能正在想：如果我们的变异是成功的，它可能已经返回了新数据，所以我们不能只是手动更新我们的查询数据并避免额外的请求吗？
- en: How to perform an update to our query data after a mutation
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何在变异后更新我们的查询数据
- en: You can definitely manually update your query data. All you need is access to
    `queryClient` and the query key of the query you want to update.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你当然可以手动更新你的查询数据。你所需要的是访问`queryClient`以及你想要更新的查询的查询键。
- en: While this might be a practice that might save some bandwidth on the user side,
    it doesn’t guarantee that the data you end up displaying to your user is accurate.
    What if someone else using the same application changes your data?
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能在用户端节省一些带宽，但它并不能保证你最终显示给用户的数据是准确的。如果其他人使用相同的应用程序更改了你的数据怎么办？
- en: Now, if there are guarantees that there is no one else able to update this server
    state, then feel free to try. Just be sure that your query refetches somewhere
    in between to guarantee that all the data is up to date.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果有保证没有其他人能够更新这个服务器状态，那么请随意尝试。但请确保你的查询在某个地方重新获取，以确保所有数据都是最新的。
- en: 'Here is how you can perform an update to your query data after a successful
    mutation:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何在成功变异后更新你的查询数据的方法：
- en: '[PRE25]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the previous snippet, we leverage our `onSuccess` callback to update our
    query data and avoid refetching it. Here is what we are doing:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码片段中，我们利用`onSuccess`回调来更新我们的查询数据，并避免重新获取它。以下是我们的操作：
- en: We get access to `queryClient`.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们获取对`queryClient`的访问权限。
- en: We create our query with `["allUsers"]` as a query key.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`["allUsers"]`作为查询键创建我们的查询。
- en: We create our mutation. In this mutation `onSuccess` callback, we leverage our
    `queryClient` `setQueryData` function to manually update the data of the query
    with `["allUsers"]` as the query key.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建我们的变异。在这个变异的`onSuccess`回调中，我们利用`queryClient`的`setQueryData`函数来手动更新带有`["allUsers"]`作为查询键的查询数据。
- en: In this update, we create a new array that combines our created data and our
    previous data to create the new query data.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这次更新中，我们创建了一个新数组，该数组结合了我们创建的数据和之前的数据，以创建新的查询数据。
- en: 'As you can see, there are a couple of patterns you can apply to improve your
    user experience after performing mutations. Now, when speaking about mutations
    often, one topic shows up every time, which is the topic that will close this
    chapter: optimistic updates!'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你可以应用一些模式来改善在执行变异后的用户体验。现在，当经常提到变异时，每次都会出现一个话题，这个话题将结束本章：乐观更新！
- en: Performing optimistic updates
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行乐观更新
- en: As we saw in [*Chapter 2*](B18501_02.xhtml#_idTextAnchor049), an optimistic
    update is a pattern used during an ongoing mutation where we update our UI to
    show how it will look after our mutation is finished, although our mutation is
    still not confirmed as complete.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第二章*](B18501_02.xhtml#_idTextAnchor049)中看到的，乐观更新是在一个正在进行的变异期间使用的一种模式，我们更新我们的UI以显示变异完成后将如何显示，尽管我们的变异尚未被确认完成。
- en: Well, React Query allows you to perform optimistic updates, and it makes it
    extremely simple. All you need is to use the callback functions we saw in the
    previous sections.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，React Query允许你执行乐观更新，并且这使得它变得极其简单。你所需要做的就是使用我们在上一节中看到的回调函数。
- en: 'Here is how to perform an optimist update using the `useMutation` hook:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何使用`useMutation`钩子执行乐观更新的方法：
- en: '[PRE26]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the preceding snippet, we put our gained knowledge about mutations into
    practice to create a better user experience for our users using optimistic updates.
    Here is what we are doing:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们将我们对变异的知识应用到实践中，以创建更好的用户体验。以下是我们的操作：
- en: We define the needed imports for our code.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为我们的代码定义所需的导入。
- en: Create the `fetchAllData` query function. This function will trigger a `GET`
    request to our endpoint to fetch the user data.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`fetchAllData`查询函数。这个函数将触发一个`GET`请求到我们的端点以获取用户数据。
- en: Create the `createUser` mutation function. This function will receive the user
    and perform a `POST` request to our endpoint to create it.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`createUser`变异函数。这个函数将接收用户并执行一个`POST`请求到我们的端点以创建它。
- en: 'Inside our `Mutation` component, we do the following:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`Mutation`组件内部，我们执行以下操作：
- en: We get access to `queryClient`.
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们获取对`queryClient`的访问权限。
- en: Create state variables and respective setters for the name and age inputs.
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建姓名和年龄输入的状态变量及其相应的设置器。
- en: Create our query using `["allUsers"]` as the query key and `fetchAllData` as
    the query function.
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`["allUsers"]`作为查询键和`fetchAllData`作为查询函数创建我们的查询。
- en: 'Create our mutation using `createUser` as the mutation function. Inside this
    mutation, we define some callbacks:'
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`createUser`作为突变函数创建我们的突变。在这个突变内部，我们定义了一些回调：
- en: 'On the `onMutate` callback, we do our optimistic update:'
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onMutate`回调中，我们执行乐观更新：
- en: We make sure we cancel any ongoing queries for our query with `["allUsers"]`
    as the query key. To do this, we use our `queryClient` `cancelQueries` method.
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们确保取消任何针对我们的查询（以`["allUsers"]`作为查询键）的正在进行中的查询。为此，我们使用我们的`queryClient` `cancelQueries`方法。
- en: We save our previous data cached under the `["allUsers"]` query key just in
    case we need to roll back. To do this, we leverage our `queryClient` `getQueryData`
    function.
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将之前缓存的数据保存在`["allUsers"]`查询键下，以防需要回滚。为此，我们利用我们的`queryClient` `getQueryData`函数。
- en: We perform our optimistic update by merging our new data with our previous data
    and updating the data cached under the `["allUsers"]` query key. To do this, we
    leverage our `queryClient` `setQueryData` function.
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过合并我们的新数据与我们的旧数据，并更新`["allUsers"]`查询键下的缓存数据来执行乐观更新。为此，我们利用我们的`queryClient`
    `setQueryData`函数。
- en: We return our `previousUsers` data in case we need to roll back.
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要回滚，我们返回我们的`previousUsers`数据。
- en: 'On the `onError` callback, in case of an error, we need to roll back our data:'
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onError`回调中，如果发生错误，我们需要回滚我们的数据：
- en: As a good practice, we let our users know something went wrong with our mutation.
    In this scenario, we are displaying a toast notification.
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一种良好的实践，我们让我们的用户知道我们的突变操作出现了问题。在这种情况下，我们显示一个吐司通知。
- en: To do the rollback, we access our context parameter and leverage the `previousUsers`
    data returned from the `onMutate` callback. We then use this variable to override
    the cached data under the `["allUsers"]` query key. To do this, we use our `queryClient`
    `setQueryData` function.
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了进行回滚，我们访问我们的上下文参数，并利用`onMutate`回调返回的`previousUsers`数据。然后我们使用这个变量来覆盖`["allUsers"]`查询键下的缓存数据。为此，我们使用我们的`queryClient`
    `setQueryData`函数。
- en: 'On the `onSettled` callback, when our mutation settles, we need to refetch
    our data:'
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onSettled`回调中，当我们的突变完成时，我们需要重新获取我们的数据：
- en: To refetch our data, we leverage our `queryClient` `invalidateQueries` and invalidate
    the query with `["allUsers"]` as the query key.
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了重新获取我们的数据，我们利用我们的`queryClient` `invalidateQueries`并使用`["allUsers"]`作为查询键来使查询无效。
- en: 'In our component return, we create a `div` element with the following:'
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的组件返回中，我们创建一个`div`元素，如下所示：
- en: We use the `data` variable from our query to display our users’ data.
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用查询的`data`变量来显示用户的资料。
- en: We create our controlled form with our name and age inputs.
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用我们的姓名和年龄输入创建受控表单。
- en: We also create a button that, when pressed, fires its `onClick` event and consequentially
    triggers our mutation with our name and age values.
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还创建了一个按钮，当按下时，会触发它的`onClick`事件，从而触发我们的带有姓名和年龄值的突变。
- en: 'Having seen how you build an optimistic update, here is the flow of our created
    optimistic update:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 看过你如何构建乐观更新后，以下是我们的创建的乐观更新的流程：
- en: Our component renders, and our query fetches our data and caches it.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的组件渲染，我们的查询获取我们的数据并将其缓存。
- en: When we click on the **Add** button, the data returned from the query is automatically
    updated to include the new user and reflects this change on the UI immediately.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们点击**添加**按钮时，查询返回的数据会自动更新，包括新用户，并且立即在UI上反映这一变化。
- en: If there is an error, we roll back to our previous data.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果发生错误，我们将回滚到之前的数据。
- en: When our mutation settles, we refetch the data for the query we just performed
    the optimistic update on to ensure our query is updated.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们的突变完成时，我们重新获取我们刚刚执行乐观更新的查询的数据，以确保我们的查询已更新。
- en: 'With this knowledge under your belt, you now have all the knowledge you need
    to take your mutation game to the next level with the help of your new ally: `useMutation`!'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这些知识，你现在拥有了所有你需要用你的新盟友`useMutation`将突变游戏提升到下一个级别的知识！
- en: Summary
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how React Query allows us to perform mutations by
    using the `useMutation` hook. By now, you should be able to create, delete, or
    update your server state. To make these changes, you resort to the mutation function,
    which, like your query function, supports any client and allows you to use GraphQL
    or REST as long it returns a promise.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了React Query如何通过使用`useMutation`钩子来执行突变。到目前为止，你应该能够创建、删除或更新你的服务器状态。为了进行这些更改，你求助于突变函数，这个函数就像你的查询函数一样，支持任何客户端，并允许你使用GraphQL或REST，只要它返回一个承诺即可。
- en: You learned about some things the `useMutation` hook returns, such as the `mutate`
    and `mutateAsync` functions. Similar to `useQuery`, `useMutation` also returns
    the mutation `data` and `error` variables and gives you access to some statuses
    you can use to craft a better user experience. For your convenience, `useMutation`
    also returns a `reset` function to clear your state and an `isPaused` variable
    in case your mutation enters a paused state.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 你了解了一些`useMutation`钩子返回的内容，例如`mutate`和`mutateAsync`函数。与`useQuery`类似，`useMutation`也返回突变`data`和`error`变量，并为你提供一些你可以用来构建更好用户体验的状态。为了你的方便，`useMutation`还返回一个`reset`函数来清除你的状态，以及一个`isPaused`变量，以防你的突变进入暂停状态。
- en: For you to customize your developer experience, you learned about some commonly
    used options that allow you to customize your `useMutation` hook experience. We
    then leveraged four of these options to teach you how to perform some side effects
    after your mutation runs.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你能够自定义开发者体验，你了解了一些常用的选项，这些选项允许你自定义`useMutation`钩子的体验。然后我们利用这四个选项中的四个来教你如何在突变运行后执行一些副作用。
- en: Finally, you used some of the knowledge you learned to perform optimistic updates
    and craft a better experience for your application users.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你使用了一些你学到的知识来执行乐观更新，并为你的应用程序用户提供更好的体验。
- en: In [*Chapter 7*](B18501_07.xhtml#_idTextAnchor173), *Server-Side Rendering with
    Next.js or Remix*, we’ll understand how we can leverage React Query even in a
    scenario where we are using a server-side framework. You will learn how you can
    fetch your data in the server and provision React Query on your client side to
    make it work and craft a better experience.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第7章*](B18501_07.xhtml#_idTextAnchor173) *使用Next.js或Remix进行服务器端渲染*中，我们将了解我们如何在即使我们使用服务器端框架的情况下利用React
    Query。你将学习你如何在服务器上获取数据，并在客户端配置React Query以使其工作并构建更好的体验。
