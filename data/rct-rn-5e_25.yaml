- en: '23'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '23'
- en: Responding to User Gestures
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应用户手势
- en: All of the examples that you’ve implemented so far in this book have relied
    on user gestures. In traditional web applications, you mostly deal with mouse
    events. However, touchscreens rely on the user manipulating elements with their
    fingers, which is fundamentally different from the mouse.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这本书中迄今为止实现的全部示例都依赖于用户手势。在传统的网络应用中，你主要处理鼠标事件。然而，触摸屏依赖于用户用手指操纵元素，这与鼠标操作有根本的不同。
- en: In this chapter, first, you’ll learn about scrolling. This is probably the most
    common gesture, besides touch. Then, you’ll learn about giving the user the appropriate
    level of feedback when they interact with your components. Finally, you’ll implement
    components that can be swiped.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，首先，你将学习滚动。这可能是除了触摸之外最常见的手势。然后，你将学习在用户与你的组件交互时提供适当的反馈级别。最后，你将实现可滑动的组件。
- en: The goal of this chapter is to show you how the **gesture response system**
    inside React Native works and some of the ways in which this system is exposed
    via components.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是向你展示 React Native 内部的 **手势响应系统** 如何工作，以及该系统通过组件暴露的一些方式。
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Scrolling with your fingers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用手指滚动
- en: Giving touch feedback
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供触觉反馈
- en: Using Swipeable and cancellable components
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可滑动和可取消的组件
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter2](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter25)3.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上找到本章的代码文件，地址为 [https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter2](https://github.com/PacktPublishing/React-and-React-Native-5E/tree/main/Chapter25)。
- en: Scrolling with your fingers
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用手指滚动
- en: Scrolling in web applications is done by using the mouse pointer to drag the
    scrollbar back and forth or up and down, or by spinning the mouse wheel. This
    doesn’t work on mobile devices because there’s no mouse. Everything is controlled
    by gestures on the screen.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络应用中，滚动是通过使用鼠标指针来回拖动滚动条或上下滚动，或者通过旋转鼠标滚轮来完成的。这在移动设备上不起作用，因为没有鼠标。所有操作都由屏幕上的手势控制。
- en: For example, if you want to scroll down, you use your thumb or index finger
    to pull the content up by physically moving your finger over the screen.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想向下滚动，你用你的拇指或食指通过在屏幕上移动手指来物理地向上拉内容。
- en: Scrolling like this is difficult to implement, but it gets more complicated.
    When you scroll on a mobile screen, the velocity of the dragging motion is taken
    into consideration. You drag the screen fast, then let go, and the screen continues
    to scroll based on how fast you moved your finger. You can also touch the screen
    while this is happening to stop it from scrolling.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的滚动很难实现，但它变得更复杂。当你在一个移动屏幕上滚动时，会考虑拖动动作的速度。你快速拖动屏幕，然后放手，屏幕会根据你移动手指的速度继续滚动。你也可以在滚动过程中触摸屏幕来停止滚动。
- en: Thankfully, you don’t have to handle most of this stuff. The `ScrollView` component
    handles much of the scrolling complexity for you. In fact, you’ve already used
    the `ScrollView` component back in *Chapter 20*, *Rendering Item Lists*. The `ListView`
    component has `ScrollView` baked into it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你不必处理大部分这些事情。`ScrollView` 组件为你处理了大部分滚动复杂性。实际上，你已经在 *第 20 章*，*渲染项目列表* 中使用了
    `ScrollView` 组件。`ListView` 组件已经内置了 `ScrollView`。
- en: You can adjust the low-level parts of user interactions by implementing gesture
    life cycle methods. You’ll probably never need to do this, but if you’re interested,
    you can read about it at [https://reactnative.dev/docs/gesture-responder-system](https://reactnative.dev/docs/gesture-responder-system).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过实现手势生命周期方法来调整用户交互的低级部分。你可能永远不需要这样做，但如果你对此感兴趣，你可以在 [https://reactnative.dev/docs/gesture-responder-system](https://reactnative.dev/docs/gesture-responder-system)
    上阅读有关内容。
- en: 'You can use `ScrollView` outside of `ListView`. For example, if you’re just
    rendering arbitrary content such as text and other widgets: not a list, in other
    words: you can just wrap it in `<ScrollView>`. Here’s an example:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `ListView` 之外使用 `ScrollView`。例如，如果你只是渲染任意内容，如文本和其他小部件：不是列表，换句话说：你只需将其包裹在
    `<ScrollView>` 中。以下是一个例子：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `ScrollView` component isn’t of much use on its own: it’s there to wrap
    other components. It needs height in order to function correctly. Here’s what
    the scroll style looks like:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScrollView` 组件本身并不很有用：它存在是为了包裹其他组件。它需要高度才能正确地工作。以下是滚动样式的样子：'
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `height` property is set to `1`, but the stretch value of `alignSelf` allows
    the items to display properly. Here’s what the end result looks like:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`height`属性设置为`1`，但`alignSelf`的拉伸值允许项目正确显示。以下是最终结果的样子：'
- en: '![](img/B19636_23_01.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19636_23_01.png)'
- en: 'Figure 23.1: ScrollView'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图23.1：ScrollView
- en: There’s a vertical scrollbar on the right-hand side of the screen as you drag
    the content down. If you run this example, you can play around with making various
    gestures, such as making content scroll on its own and then making it stop.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当你向下拖动内容时，屏幕右侧有一个垂直滚动条。如果你运行这个示例，你可以尝试各种手势，比如让内容自动滚动然后停止。
- en: When the user scrolls through content on the screen, they receive visual feedback.
    Users should also receive visual feedback when they touch certain elements on
    the screen.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在屏幕上滚动内容时，他们会收到视觉反馈。用户在触摸屏幕上的某些元素时也应该收到视觉反馈。
- en: Giving touch feedback
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供触摸反馈
- en: The React Native examples you’ve worked with so far in this book have used plain
    text to act as buttons or links. In web applications, to make text look like something
    that can be clicked, you just wrap it with the appropriate link. There’s no link
    component in React Native, so you can style your text to look like a button.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，你迄今为止使用的React Native示例已经使用了纯文本作为按钮或链接。在Web应用程序中，为了让文本看起来可以点击，你只需用适当的链接将其包裹起来。React
    Native中没有链接组件，所以你可以将文本样式设置为按钮样式。
- en: The problem with trying to style text as links on mobile devices is that they’re
    too hard to press. Buttons provide a bigger target for fingers, and they’re easier
    to apply touch feedback on.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在移动设备上将文本样式设置为链接的问题在于它们太难按了。按钮提供了更大的目标供手指操作，并且更容易应用触摸反馈。
- en: 'Let’s style some text as a button. This is a great first step as it makes the
    text look touchable. But you also want to give visual feedback to the user when
    they start interacting with the button. React Native provides several components
    to help with this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给一些文本设置按钮样式。这是一个很好的第一步，因为它使文本看起来可以触摸。但你也想当用户开始与按钮交互时给用户提供视觉反馈。React Native提供了几个组件来帮助实现这一点：
- en: '`TouchableOpacity`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TouchableOpacity`'
- en: '`TouchableHighlight`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TouchableHighlight`'
- en: Pressable API
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可按压API
- en: 'But before diving into the code, let’s take a look at what these components
    look like visually when users interact with them, starting with `TouchableOpacity`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 但在深入代码之前，让我们看看当用户与这些组件交互时，它们在视觉上看起来是什么样子，从`TouchableOpacity`开始：
- en: '![Picture 2](img/B19636_23_02.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片2](img/B19636_23_02.png)'
- en: 'Figure 23.2: TouchableOpacity'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图23.2：TouchableOpacity
- en: There are three buttons being rendered here. The top one, labeled **Opacity**,
    is currently being pressed by the user. The opacity of the button is dimmed when
    pressed, which provides important visual feedback for the user.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这里渲染了三个按钮。顶部的一个，标有**不透明度**，当前正被用户按下。按钮在被按下时变暗，这为用户提供重要的视觉反馈。
- en: 'Let’s see what the **Highlight** button looks like when pressed:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当按下**高亮**按钮时它看起来是什么样子：
- en: '![Picture 3](img/B19636_23_03.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片3](img/B19636_23_03.png)'
- en: 'Figure 23.3: TouchableHighlight'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图23.3：可触摸高亮
- en: Instead of changing the opacity when pressed, the `TouchableHighlight` component
    adds a highlight layer over the button. In this case, it’s highlighted using a
    more transparent version of the slate gray that’s being used in the font and border
    colors.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 与在按下时改变不透明度不同，`TouchableHighlight`组件在按钮上添加了一个高亮层。在这种情况下，它使用的是比字体和边框颜色中使用的板岩灰色更透明的版本。
- en: 'The last example of a button is provided by the `Pressable` component. The
    Pressable API has been introduced as a core component wrapper and allows different
    stages of press interaction on any of its defined children. With such components,
    we can handle `onPressIn`, `onPressOut` (which we explore in the next chapter),
    and `onLongPress` callbacks and implement any touchable feedback that we want.
    Let’s take a look at how `PressableButton` looks when we click on it:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个按钮的例子是由`Pressable`组件提供的。Pressable API被引入作为核心组件包装器，允许对其定义的任何子组件的不同按下交互阶段。使用这样的组件，我们可以处理`onPressIn`、`onPressOut`（我们将在下一章中探讨）和`onLongPress`回调，并实现我们想要的任何触摸反馈。让我们看看点击`PressableButton`时它看起来是什么样子：
- en: '![Picture 4](img/B19636_23_04.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片4](img/B19636_23_04.png)'
- en: 'Figure 23.4: Pressable button'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图23.4：可按压按钮
- en: 'If we continue to keep our finger on this button, we get an `onLongPress` event
    and the button will update:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们继续按住这个按钮，我们将得到一个`onLongPress`事件，按钮将更新：
- en: '![Picture 5](img/B19636_23_05.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片5](img/B19636_23_05.png)'
- en: 'Figure 23.5: Long Pressed button'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图23.5：长按按钮
- en: It doesn’t really matter which approach you use. The important thing is that
    you provide the appropriate touch feedback for your users as they interact with
    your buttons. In fact, you might want to use all the approaches in the same app,
    but for different things.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上使用哪种方法并不重要。重要的是，你为用户提供了适当的触摸反馈，让他们在与按钮交互时感到舒适。实际上，你可能会在同一个应用中使用所有这些方法，但用于不同的事情。
- en: 'Let’s create an `OpacityButton` and `HighlightButton` component, which makes
    it easy to use the first two approaches:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`OpacityButton`和`HighlightButton`组件，这使得使用前两种方法变得容易：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here are the styles that were used to create this button:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是创建此按钮所使用的样式：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now let’s take a look at the button based on the Pressable API:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看基于Pressable API的按钮：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here’s how you can put those buttons into the main app module:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何将这些按钮放入主应用模块中的：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Note that the `onPress` callbacks don’t actually do anything: we’re passing
    them because they’re a required property.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`onPress` 回调实际上并没有做任何事情：我们传递它们是因为它们是一个必需的属性。
- en: In the following section, you’ll learn about providing feedback when the user
    swipes elements across the screen.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将了解当用户在屏幕上滑动元素时提供反馈。
- en: Using Swipeable and Cancellable components
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用可滑动和可取消组件
- en: Part of what makes native mobile applications easier to use than mobile web
    applications is that they feel more intuitive. Using gestures, you can quickly
    get a handle on how things work. For example, swiping an element across the screen
    with your finger is a common gesture, but the gesture has to be discoverable.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 与移动网页应用相比，原生移动应用更容易使用的一部分原因是它们感觉更直观。使用手势，你可以快速了解事物的工作方式。例如，用手指在屏幕上滑动一个元素是一个常见的动作，但这个动作必须是可发现的。
- en: Let’s say that you’re using an app, and you’re not exactly sure what something
    on the screen does. So, you press down with your finger and try dragging the element.
    It starts to move. Unsure of what will happen, you lift your finger up, and the
    element moves back into place. You’ve just discovered how part of this application
    works.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在使用一个应用，并且你并不完全确定屏幕上的某个功能是什么。所以，你用手指按下并尝试拖动元素。它开始移动。不确定会发生什么，你抬起手指，元素就回到了原位。你刚刚发现了这个应用程序的一部分是如何工作的。
- en: 'You’ll use the `Scrollable` component to implement **swipeable** and **cancellable**
    behaviors like this. You can create a somewhat generic component that allows the
    user to swipe text off the screen and, when that happens, call a callback function.
    Let’s look at the code that will render the swipeables before we look at the generic
    component itself:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用`Scrollable`组件来实现这种**可滑动**和**可取消**的行为。你可以创建一个相对通用的组件，允许用户将文本从屏幕上滑动掉，当这种情况发生时，调用回调函数。在我们查看通用组件本身之前，让我们看看将渲染滑动组件的代码：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will render 10 `<Swipeable>` components on the screen. Let’s see what
    this looks like:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在屏幕上渲染10个`<Swipeable>`组件。让我们看看这会是什么样子：
- en: '![Picture 6](img/B19636_23_06.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片6](img/B19636_23_06.png)'
- en: 'Figure 23.6: Screen with Swipeable components'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图23.6：带有可滑动组件的屏幕
- en: 'Now, if you start to swipe one of these items to the left, it will move. Here’s
    what this looks like:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你开始向左滑动这些项目之一，它就会移动。下面是这个动作的样子：
- en: '![Picture 7](img/B19636_23_07.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片7](img/B19636_23_07.png)'
- en: 'Figure 23.7: Swiped component'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图23.7：已滑动的组件
- en: If you don’t swipe far enough, the gesture will be canceled and the item will
    move back into place, as expected. If you swipe it all the way, the item will
    be removed from the list completely and the items on the screen will fill the
    empty space.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有滑动足够远，手势将被取消，项目将回到原位，正如预期的那样。如果你完全滑动，项目将从列表中完全移除，屏幕上的项目将填充空出的空间。
- en: 'Now, let’s take a look at the `Swipeable` component itself:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`Swipeable`组件本身：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The component accepts the `width` property to specify the width itself, `snapToInterval`
    to create paging-like behavior with swipe canceling, and handling the distance
    where we can call the `onSwipe` callback to remove items from the list.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 组件接受`width`属性来指定宽度本身，`snapToInterval`来创建具有滑动取消的翻页行为，以及处理我们可以在其中调用`onSwipe`回调以从列表中删除项目的距离。
- en: 'To enable swipe to the left, we need to add a blank component beside the component
    with text in it. Here are the styles that are used for this component:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用向左滑动，我们需要在包含文本的组件旁边添加一个空白组件。以下是用于此组件的样式：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `swipeItemBlank` style has the same height as `swipeItem`, but nothing else.
    It’s invisible.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`swipeItemBlank`样式与`swipeItem`具有相同的高度，但除此之外没有其他内容。它是不可见的。'
- en: We have now covered all the topics in this chapter.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经涵盖了本章的所有主题。
- en: Summary
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we were introduced to the idea that gestures on native platforms
    make a significant difference compared to mobile web platforms. We started off
    by looking at the `ScrollView` component, and how it makes life much simpler by
    providing native scrolling behavior for wrapped components.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了在原生平台上的手势与移动网页平台相比有显著差异的观点。我们首先查看`ScrollView`组件，以及它如何通过为包装组件提供原生滚动行为来简化生活。
- en: Next, we spent some time implementing buttons with touch feedback. This is another
    area that’s tricky to get right on the mobile web. We learned how to use the `TouchableOpacity`,
    `TouchableHighlight`, and Pressable API components to do this.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们花了一些时间来实现带有触觉反馈的按钮。这是在移动网页上正确实现的一个棘手领域。我们学习了如何使用`TouchableOpacity`、`TouchableHighlight`和`Pressable`
    API组件来完成这项工作。
- en: Finally, we implemented a generic `Swipeable` component. Swiping is a common
    mobile pattern, and it allows the user to discover how things work without feeling
    intimidated.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们实现了一个通用的`Swipeable`组件。滑动是一个常见的移动模式，它允许用户发现事物的工作方式，而不会感到害怕。
- en: In the next chapter, we’ll learn how to control animation using React Native.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用React Native控制动画。
