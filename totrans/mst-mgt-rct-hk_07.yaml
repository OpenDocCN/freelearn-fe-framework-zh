- en: '*Chapter 5*: Sharing Component State with Context and Subscription'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous two chapters, we learned how to use Context and Subscription
    for a global state. Each has different benefits: Context allows us to provide
    different values for different subtrees, while Subscriptions prevent extra re-renders.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn a new approach: combining React Context and
    Subscriptions. The combination will give us the benefits of each, which means:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Context can provide a global state to a subtree and the Context provider can
    be nested. Context allows us to control a global state in the React component
    lifecycle like the `useState` hook.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, Subscriptions allow us to control re-renders, which is not
    possible with a single Context.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having the benefits of both can be a good solution for larger apps – because,
    as mentioned, this means we can have different values in different subtrees, and
    we can also avoid extra re-renders.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: This approach is useful for mid to large apps. In such apps, having different
    values in different subtrees can happen, and we can avoid extra re-renders, which
    can be very important for our apps.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the limitations of module state
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding when to use Context
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Context and Subscription pattern
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You are expected to have moderate knowledge of React, including React Hooks.
    Refer to the official site, [https://reactjs.org](https://reactjs.org), to learn
    more.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: In some code, we use TypeScript ([https://www.typescriptlang.org](https://www.typescriptlang.org)),
    and you should have basic knowledge of it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'The code in this chapter is available on GitHub: [https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_05](https://github.com/PacktPublishing/Micro-State-Management-with-React-Hooks/tree/main/chapter_05).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: To run code snippets, you need a React environment, for example, Create React
    App ([https://create-react-app.dev](https://create-react-app.dev)) or CodeSandbox
    ([https://codesandbox.io](https://codesandbox.io)).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the limitations of module state
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Because module state resides outside React components, there''s a limitation:
    the module state defined globally is a singleton, and you can''t have different
    states for different component trees or subtrees.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s revisit our `createStore` implementation from [*Chapter 4*](B17780_04_Final_VK_ePub.xhtml#_idTextAnchor066),
    *Sharing Module State with Subscription*:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Using this `createStore`, let''s define a new `store`. We define a `store`
    with a property `count`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that this `store` is defined outside the React component.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'To use `store` in a React component, we use `useStore`. The following is an
    example with two components that show the shared count from the same `store` variable.
    We use `useStore`, which was defined in [*Chapter 4*](B17780_04_Final_VK_ePub.xhtml#_idTextAnchor066),
    *Sharing Module State with Subscription*:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We have the component `Counter`, which is to show the `count` number in the
    `store` object, and a `button` to update the `count` value. Because this `Counter`
    component is reusable, `Component` can have two `Counter` instances. This will
    show a pair of two counters sharing the same state.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Now, suppose we want to show another pair of counters. We would like to have
    two new components in `Component`, but the new pair should show different counters
    from the first set.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new `count` value. We could add a new property to the `store`
    object we already defined, but we assume there are other properties and want to
    isolate stores. Therefore, we create `store2`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Because `createStore` is reusable, creating a new `store2` object is straightforward.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'We then need to create components to use `store2`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You may notice the similarity between `Counter` and `Counter2` – that they are
    both 14 lines of code, and the only difference is the `store` variable they are
    referencing – `store` for `Counter` and `store2` for `Counter2`. We would need
    `Counter3` or `Counter4` to support more stores. Ideally, `Counter` should be
    reusable. But, as module state is defined outside React, it's not possible. This
    is the limitation of module state.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: You may notice we can make the `Counter` component reusable if we put `store`
    in `props`. However, that will require prop drilling when components are deeply
    nested, and the primary reason for introducing module state is to avoid prop drilling.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'It would be nice to reuse the `Counter` component for different stores. The
    pseudocode would be as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you look at the code, you will notice that `Component`, `Component2`, and
    `Component3` are mostly the same. The only difference is the `Provider` components.
    This is exactly where React Context fits in. We will discuss this in more detail
    in the *Implementing the Context and Subscription pattern* section.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Now you understand the limitation of module state and the ideal patterns for
    multiple stores. Next up, we'll recap React Context and explore the usage of Context.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Understanding when to use Context
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before diving into learning the way to combine Context and Subscription, let's
    recap how Context works.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a simple Context example with a theme. So, we specify a default
    value for `createContext`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: What `useContext(ThemeContext)` returns depends on the Context in the component
    tree.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'To change the Context value, we use a `Provider` component in Context as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this case, `Component` will show the theme as `dark`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'The provider can be nested. It will use the value from the innermost provider:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If there are no providers in the component tree, it will use the default value.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here, we assume `Root` is a component at the root:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this case, `Component` will show the theme as `light`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example that has a provider to provide the same default value
    at the root:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this case too, `Component` will show the theme as `light`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s discuss when to use Context. To do this, think of our example: what
    is the difference between this example with a provider and the previous example
    without a provider? We can say that there is no difference. Using the default
    value gives the same result.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Having a proper default value for Context is important. The Context provider
    can be seen as a method to override the default Context value or a value provided
    by the parent provider if it exists.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: In the case of `ThemeContext`, if we have the proper default value, then what's
    the point of using a provider? It will be required to provide a different value
    for a subtree of the entire component tree. Otherwise, we can just use the default
    value from `Context`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: For a global state with Context, you may only use one provider at the root.
    This is a valid use case, but this use case can be covered by module state with
    Subscription, which we learned about in [*Chapter 4*](B17780_04_Final_VK_ePub.xhtml#_idTextAnchor066),
    *Sharing Module State with Subscription*. Given that module state covers the use
    case with one Context provider at the root, Context for a global state is only
    required if we need to provide different values for different subtrees.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we revisited React Context and learned when to use it. Next
    up, we will learn how to combine Context and Subscription.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Context and Subscription pattern
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we learned, using one Context to propagate a global state value has a limitation:
    it causes extra re-renders.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'Module state with Subscription doesn''t have such a limitation, but there is
    another: it only provides a single value for the entire component tree.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'We would like to combine Context and Subscription to overcome both limitations.
    Let''s implement this feature. We''ll start with `createStore`. This is exactly
    the same implementation we developed in [*Chapter 4*](B17780_04_Final_VK_ePub.xhtml#_idTextAnchor066),
    *Sharing Module State with Subscription*:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In [*Chapter 4*](B17780_04_Final_VK_ePub.xhtml#_idTextAnchor066), *Sharing Module
    State with Subscription*, we used `createStore` for module state. This time, we'll
    use `createStore` for the `Context` value.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code to create a Context. The default value is passed
    to `createContext`, which we refer to as a default store:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this case, the default store has a state with two properties: `count` and
    `text`.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'To provide different stores for subtrees, we implement `StoreProvider`, which
    is a tiny wrapper around `StoreContext.Provider`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`useRef` is used to make sure that the store object is initialized only once
    at the first render.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a store object, we implement a hook called `useSelector`. Unlike `useStoreSelector`,
    defined in the *Working with a selector and useSubscription* section in [*Chapter
    4*](B17780_04_Final_VK_ePub.xhtml#_idTextAnchor066), *Sharing Module State with
    Subscription*, `useSelector` doesn''t take a `store` object in its arguments.
    It takes a `store` object from `StoreContext` instead:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Using `useContext` together with `useSubscription` is the key point of this
    pattern. This combination allows us the benefits of both Context and Subscription.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike module state, we need to provide a way to update the state with Context.
    `useSetState` is a simple hook to return the `setState` function in `store`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, let''s use what we have implemented. The following is a component that
    shows `count` in `store`, along with `button` to increment `count`. We define
    `selectCount` outside the `Component`, otherwise, we would need to wrap the function
    with `useCallback`, which introduces extra work:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It's important to note here that this `Component` component is not tied to any
    specific store object. The `Component` component can be used for different stores.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also have `Component` in various places:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Outside any providers
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the first provider
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the second provider
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following `App` component includes the `Component` components in three
    places: 1) outside of `StoreProvider`, 2) inside the first `StoreProvider` component,
    and 3) inside the second nested `StoreProvider` component. The `Component` components
    in different `StoreProvider` components share different `count` values:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Each `Component` component using the same `store` object will share the `store`
    object and show the same `count` value. In this case, the components in different
    component tree levels use a different `store`, hence the components show a different
    `count` value in various places. When you run this app, you will see something
    like the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Screenshot of the running app  ](img/Figure_5.1_B17780.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Screenshot of the running app
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: If you click the **+1** button in **Using default store**, you will see two
    counts in **Using default store** are updated together. If you click the **+1**
    button in **Using store provider**, you will see two counts in **Using store provider**
    are updated together. The same applies to **Using inner store provider**.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to implement a global state with Context and
    Subscription, taking advantage of the related benefits. We can isolate state in
    a subtree thanks to Context, and we can avoid extra re-renders thanks to Subscription.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we learned a new approach: combining React Context and Subscription.
    It provides the benefits of both: providing isolated values in subtrees and avoiding
    extra re-renders. This approach is useful for mid to large apps. In such apps,
    having different values in different subtrees can happen, and we can avoid extra
    re-renders, which can be very important for our apps.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了一种新的方法：结合 React Context 和 Subscription。这种方法提供了两者的好处：在子树中提供隔离的值，并避免额外的重新渲染。这种方法对于中等到大型应用非常有用。在这些应用中，不同的子树可能具有不同的值，我们可以避免额外的重新渲染，这对我们的应用可能非常重要。
- en: Starting from the next chapter, we will dive into various global state libraries.
    We will learn how those libraries are based on what we have learned so far.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 从下一章开始，我们将深入探讨各种全局状态库。我们将学习这些库是如何基于我们迄今为止所学的内容构建的。
