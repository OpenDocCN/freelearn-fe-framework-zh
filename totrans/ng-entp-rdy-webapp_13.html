<html><head></head><body>
  <div id="_idContainer726">
    <h1 class="chapterNumber">13</h1>
    <h1 class="chapterTitle" id="_idParaDest-444">Highly Available Cloud Infrastructure on AWS</h1>
    <p class="normal">The web is a hostile environment. There are good and bad actors. Bad actors can try to poke holes in your security or try to bring down your website with a <strong class="bold">Distributed Denial-of-Service</strong> (<strong class="bold">DDoS</strong>)<a id="_idIndexMarker1463"/><a id="_idIndexMarker1464"/> attack. Good actors, if you're lucky, will love your website and won't stop using it. They'll shower you with recommendations to improve your site, but they may also run into bugs and may be so enthusiastic that your site may slow down to a crawl due to high traffic. Real-world deployments on the web require a lot of expertise to get them right. As a full-stack developer, you can only know about so many nuances of hardware, software, and networking. Luckily, with the advent of cloud service providers, a lot of this expertise has been translated into software configurations, with the difficult hardware and networking concerns taken care of by the provider.</p>
    <p class="normal">One of the best features of a cloud service provider is cloud scalability, which refers to your server automatically scaling out to respond to high volumes of unexpected traffic and scaling down to save costs when the traffic returns back to normal levels. <strong class="bold">Amazon Web Services</strong> (<strong class="bold">AWS</strong>)<a id="_idIndexMarker1465"/><a id="_idIndexMarker1466"/> goes beyond basic cloud scalability and introduces high-availability and fault-tolerant concepts, allowing resilient local and global deployments. I have chosen to introduce you to AWS because of its vast capabilities, which go way beyond what I will touch on in this book. With Route 53, you can get free DDoS protection; with API Gateway, you create API keys; with <a id="_idIndexMarker1467"/><a id="_idIndexMarker1468"/>AWS Lambda, you can handle millions of transactions for only a few dollars a month; and with CloudFront, you can cache your content at secret edge locations that are scattered around major cities of the world. In addition, blue-green deployments allow you to achieve no-downtime deployments of your software.</p>
    <p class="normal">Overall, the tools and techniques you will learn about in this chapter are adaptable to any cloud provider and are fast becoming critical knowledge for any full-stack developer. We will be going over the following topics:</p>
    <ul>
      <li class="list">Creating and protecting AWS accounts</li>
      <li class="list">Right-sizing infrastructure, including simple load testing to optimize instances</li>
      <li class="list">Configuring and deploying to AWS<ul>
          <li class="Bullet-Within-Bullet--PACKT-">ECS Fargate scripted blue-green deployments</li>
          <li class="Bullet-Within-Bullet-End--PACKT-">Billing</li>
        </ul>
      </li>
    </ul>
    <p class="normal">The most up-to-date versions of the sample code for the book are on GitHub at the following repository link. The repository contains the final and complete state of the code. Each section contains information boxes to help direct you to the correct filename or branch on GitHub that you can use to verify your progress.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">The sample code for <em class="italics">Chapter 13</em> removes all optional and alternate implementations from previous chapters and only enables auth with <strong class="bold">lemon-mart-server</strong>. This is so that readers can reference a clean implementation of the <strong class="bold">lemon-mart</strong> project.</p>
    </div>
    <p class="normal">For <em class="italics">Chapter 13</em> examples based on <strong class="bold">lemon-mart</strong>:</p>
    <ol>
      <li class="list">Clone the repo at <a href="https://github.com/duluca/lemon-mart"><span class="url">https://github.com/duluca/lemon-mart</span></a>.</li>
      <li class="list">Use <code class="Code-In-Text--PACKT-">config.docker-integration.yml</code> to verify your <code class="Code-In-Text--PACKT-">config.yml</code> implementation.</li>
      <li class="list">Execute <code class="Code-In-Text--PACKT-">npm install</code> on the root folder to install dependencies.</li>
      <li class="list">To run the CircleCI Docker integration configuration, execute <code class="Code-In-Text--PACKT-">git checkout deploy_aws</code>. Refer to the pull request at <a href="https://github.com/duluca/lemon-mart/pull/27"><span class="url">https://github.com/duluca/lemon-mart/pull/27</span></a>.</li>
      <li class="list">The code sample for this chapter is under the sub-folder:
        <pre class="programlisting"><code class="hljs">projects/ch13
</code></pre>
      </li>
      <li class="list">To run the Angular app for this chapter, execute:
        <pre class="programlisting"><code class="hljs nginx"><span class="hljs-attribute">npx</span> ng serve ch13
</code></pre>
      </li>
      <li class="list">To run Angular unit tests for this chapter, execute:
        <pre class="programlisting"><code class="hljs bash">npx ng <span class="hljs-built_in">test</span> ch13 --watch=<span class="hljs-literal">false</span>
</code></pre>
      </li>
      <li class="list">To run Angular e2e tests for this chapter, execute:
        <pre class="programlisting"><code class="hljs nginx"><span class="hljs-attribute">npx</span> ng e2e ch13
</code></pre>
      </li>
      <li class="list" value="9">To build a production-ready Angular app for this chapter, execute:
        <pre class="programlisting"><code class="hljs ada">npx ng build ch13 <span class="hljs-comment">--prod</span>
</code></pre>
      </li>
    </ol>
    <div class="packt_tip">
      <p>Note that the <code class="Code-In-Text--PACKT-">dist/ch13</code> folder at the root of the repository will contain the compiled result.</p>
    </div>
    <div class="note">
      <p class="Information-Box--PACKT-">Beware that the source code in the book or on GitHub may not always match the code generated by the Angular CLI. There may also be slight differences in implementation between the code in the book and what's on GitHub because the ecosystem is ever-evolving. It is natural for the sample code to change over time. Also on GitHub, expect to find corrections, fixes to support newer versions of libraries, or side-by-side implementations of multiple techniques for you to observe. You are only expected to implement the ideal solution recommended in the book. If you find errors or have questions, please create an issue or submit a pull request on GitHub for the benefit of all readers. </p>
    </div>
    <div class="packt_tip">
      <p>You can read more about updating Angular in <em class="italics">Appendix C</em>, <em class="italics">Keeping Angular and Tools Evergreen</em>. You can find this appendix online from <a href="https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen."><span class="url">https://static.packt-cdn.com/downloads/9781838648800_Appendix_C_Keeping_Angular_and_Tools_Evergreen.pdf</span></a> or at <a href="https://expertlysimple.io/stay-evergreen"><span class="url">https://expertlysimple.io/stay-evergreen</span></a>.</p>
    </div>
    <p class="normal">AWS is an extremely popular service and AWS accounts are even more popular targets for hacking attempts. Let's begin by creating a secure AWS account.</p>
    <h1 class="title" id="_idParaDest-445">Creating a secure <a id="_idIndexMarker1469"/><a id="_idIndexMarker1470"/>AWS account</h1>
    <p class="normal">Account access and control is of paramount importance in any cloud service, and this includes AWS as well. After initial account creation, you will have your root credentials, which is your email and password combination.</p>
    <p class="normal">Let's start by creating an AWS account:</p>
    <ol>
      <li class="list" value="1">Start by navigating to <a href="https://console.aws.amazon.com"><span class="url">https://console.aws.amazon.com</span></a>.</li>
      <li class="list">If you don't have one, create a new account.</li>
      <li class="list">If you are new to AWS, you can get 12 months of free tier access to various services, as shown on the sign-up screen here:<figure class="mediaobject"><img alt="" src="../Images/B14091_13_01.png"/></figure>
        <p class="packt_figref">Figure 13.1: AWS account sign up</p>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">Your AWS billing is tied to your root credentials. If compromised, a lot of damage can be done on your account before you can regain access.</p>
      </li>
      <li class="list">Ensure that you enable 2FA on your root credentials.<div class="note">
          <p class="Information-Box--PACKT-">To add another layer of security, going forward, you need to stop logging in to your AWS account using your root credentials. You can create user accounts using the AWS <strong class="bold">Identity and Access Management</strong> (<strong class="bold">IAM</strong>) module. If these accounts get compromised, unlike your root account, you can easily and quickly delete or replace them.</p>
        </div>
      </li>
      <li class="list">Navigate to the <strong class="screen-text">IAM module</strong>.</li>
      <li class="list">Create a new user account with global admin rights.</li>
      <li class="list">Log in to the AWS console using these credentials.</li>
      <li class="list">You should enable 2FA for these credentials as well.</li>
      <li class="list" value="9">A secure account setup looks as follows, with every status reported as green:<figure class="mediaobject"><img alt="" src="../Images/B14091_13_02.png"/></figure>
        <p class="packt_figref">Figure 13.2: AWS IAM module after secure setup</p>
      </li>
    </ol>
    <p class="normal">The major benefit of working with user accounts is programmatic access. For each user account, you can create a public access ID and private access key pair. When you're working with third parties, such as hosted continuous integration services, your own application code, or CLI tools, you use your programmatic access keys to connect to your AWS resources. When, inevitably, the access keys leak, it is quick and convenient to disable access to the old keys and create new ones.</p>
    <p class="normal">Furthermore, user account access can be tightly controlled by very granular permissions. You can also create roles with a group of permissions and further control communication between AWS services and some external services.</p>
    <p class="normal">When creating user accounts and roles, always err on the side of minimal permissions. This can be an exercise in frustration when working with clients, contractors, or colleagues who are unfamiliar with AWS; however, it is a worthwhile exercise.</p>
    <p class="normal">You're only as secure and reliable as your weakest link, so you must plan for failures and, most importantly, practice recovery plans on a regular basis.</p>
    <h2 class="title" id="_idParaDest-446">Securing secrets</h2>
    <p class="normal">Password and private key leaks occur more commonly than you may think. Your keys may be compromised on unsecured public Wi-Fi networks; you may accidentally check them into your code repository or use superbly insecure communication methods like email.</p>
    <p class="normal">Accidental code check-ins, however, are the biggest issue, since most junior developers don't realize that deletion isn't an option in source control systems.</p>
    <p class="normal">As a developer, there are a few noteworthy best practices to follow to safeguard your secrets:</p>
    <ol>
      <li class="list" value="1">Always use a VPN service on public Wi-Fi, such as <a href="http://tunnelbear.com"><span class="url">tunnelbear.com</span></a>.</li>
      <li class="list">Leverage the <code class="Code-In-Text--PACKT-">.aws/credentials</code> file located under your user's home folder, to create profiles and store access keys.</li>
      <li class="list">As a team norm, create an <code class="Code-In-Text--PACKT-">.env</code> file in the root of your project that is in <code class="Code-In-Text--PACKT-">.gitignore</code> to store any secrets that your CI server may later inject.</li>
      <li class="list">Always review commits before pushing them.</li>
      <li class="list" value="5">Consider signing up for a service that can monitor your repos for secrets, like GitGurdian at <a href="https://gitguardian.com/"><span class="url">https://gitguardian.com/</span></a>, which is free for open source projects.</li>
    </ol>
    <div class="note">
      <p class="Information-Box--PACKT-">Note that GitGuardian flags Firebase and OpenWeather API keys as leaks. This is a false positive, because the keys in question are public keys and must be published for your app to function correctly.</p>
    </div>
    <p class="normal">Following these conventions every single time will get you into the good habit of never checking in your secrets to a code repository. In the next section, we will delve into resource considerations for your cloud environment.</p>
    <h1 class="title" id="_idParaDest-447">Right-sizing infrastructure</h1>
    <p class="normal">The point of optimizing your infrastructure is to protect your company's revenue while minimizing the cost of operating your infrastructure. Your goal should be to ensure that users don't encounter high latency, otherwise known as bad performance or, worse, unfulfilled or dropped requests, all the while making your venture a sustainable endeavor.</p>
    <p class="normal">The three pillars of web application performance are as follows:</p>
    <ol>
      <li class="list" value="1">CPU utilization</li>
      <li class="list">Memory usage</li>
      <li class="list" value="3">Network bandwidth</li>
    </ol>
    <p class="normal">I have intentionally left disk access out of the key consideration metrics, since only particular workloads executed on an application server or data store are affected by it. Disk access would rarely ever impact the performance of serving a web application as long as application assets are delivered by a <strong class="bold">Content Delivery Network</strong> (<strong class="bold">CDN</strong><strong class="bold"><a id="_idIndexMarker1471"/><a id="_idIndexMarker1472"/></strong>). That said, still keep an eye on any unexpected runaway disk access, such as the high-frequency creation of temp and log files. Docker, for example, can spit out logs that can easily fill up a drive.</p>
    <p class="normal">In an ideal scenario, CPU, memory, and network bandwidth use should be utilized evenly at around 60-80% of available capacity. If you encounter performance issues due to various other factors, such as disk I/O, a slow third-party service, or inefficient code, most likely one of your metrics will peak at or near maximum capacity, while the other two are idling or severely underutilized. This is an opportunity to use more CPU, memory, or bandwidth to compensate for the performance issue and also evenly utilize available resources.</p>
    <p class="normal">The reason behind targeting 60-80% utilization is to allow some time for a new instance (server or container) to be provisioned and ready to serve users. After your predefined threshold has been crossed, while a new instance is provisioned, you can continue serving an increasing number of users, thus minimizing unfulfilled requests.</p>
    <div class="packt_tip">
      <p>Throughout this book, I have discouraged over-engineering or perfect solutions. In today's complicated IT landscape, it is nearly impossible to predict where you will encounter performance bottlenecks. Your engineering may, very easily, take $100,000+ worth of engineering hours, where the solution to your problem may be a few hundred dollars of new hardware, whether it be a network switch, solid state drive, CPU, or more memory.</p>
    </div>
    <p class="normal">If your CPU is too busy, you may want to introduce more bookkeeping logic to your code, via indexes, hash tables, or dictionaries that you can cache in memory to speed up subsequent or intermediary steps of your logic. For example, if you are constantly running array lookup operations to locate particular properties of a record, you can perform an operation on that record, saving the ID and/or the property of the record in a hash table that you keep in memory, reducing your runtime cost from <em class="italics">O(n)</em> down to <em class="italics">O(1)</em>.</p>
    <p class="normal">Following the preceding example, you may end up using too much memory with hash tables. In this case, you may want to more aggressively offload or transfer caches to slower but more plentiful data stores using your spare network bandwidth, such as a Redis instance.</p>
    <p class="normal">If your network utilization is too high, you may want to investigate the use of CDNs with expiring links, client-side caching, throttling requests, and API access limits for customers abusing their quotas, or optimize your instances to have disproportionately more network capacity compared to their CPU or memory capacity.</p>
    <h2 class="title" id="_idParaDest-448">Optimizing instances</h2>
    <p class="normal">In an earlier example, I demonstrated the use of my <code class="Code-In-Text--PACKT-">duluca/minimal-node-web-server</code> Docker image to host our Angular apps. Even though Node.js is a very lightweight server, it is simply not optimized to just be a web server. In addition, Node.js has a single-threaded execution environment, making it a poor choice for serving static content to many concurrent users at once.</p>
    <p class="normal">You can observe the resource that a Docker image is utilizing by executing <code class="Code-In-Text--PACKT-">docker stats</code>:</p>
    <pre class="programlisting"><code class="hljs angelscript">$ docker stats
CONTAINER ID  CPU %  MEM USAGE / LIMIT  MEM %  NET I/O  BLOCK I/O    PIDS
<span class="hljs-number">27</span>d431e289c9  <span class="hljs-number">0.00</span>%  <span class="hljs-number">1.797</span>MiB / <span class="hljs-number">1.9</span>GiB  <span class="hljs-number">0.09</span>%  <span class="hljs-number">13.7</span>kB / <span class="hljs-number">285</span>kB  <span class="hljs-number">0</span>B / <span class="hljs-number">0</span>B  <span class="hljs-number">2</span>
</code></pre>
    <p class="normal">Here are comparative results of the system resources that Node and NGINX-based servers utilize at rest:</p>
    <table class="No-Table-Style _idGenTablePara-1" id="table001-2">
      <colgroup>
        <col/>
        <col/>
        <col/>
      </colgroup>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <strong class="heading">Server</strong>
          </td>
          <td class="No-Table-Style">
            <strong class="heading">Image Size</strong>
          </td>
          <td class="No-Table-Style">
            <strong class="heading">Memory Usage</strong>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="content"><code class="Code-In-Text--PACKT-">duluca/minimal-nginx-web-server</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="content">16.8 MB</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">1.8 MB</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="content"><code class="Code-In-Text--PACKT-">duluca/minimal-node-web-server</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="content">71.8 MB</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">37.0 MB</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">However, at rest values only tell a portion of the story. To get a better understanding, we must perform a simple load test to see memory and CPU utilization under load.</p>
    <h2 class="title" id="_idParaDest-449">Simple load testing</h2>
    <p class="normal">To get a better understanding of the performance characteristics of our server, let's put them under some load and stress them:</p>
    <ol>
      <li class="list" value="1">Start your container using <code class="Code-In-Text--PACKT-">docker run</code>:
        <pre class="programlisting"><code class="hljs elixir"><span class="hljs-variable">$ </span>docker run --name &lt;imageName&gt; -d -p <span class="hljs-number">8080</span><span class="hljs-symbol">:&lt;internal_port&gt;</span>
&lt;imageRepo&gt;
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">If you're using npm scripts for Docker, execute the following command to start your container:</p>
        <pre class="programlisting"><code class="hljs routeros">$ npm <span class="hljs-builtin-name">run</span> docker:<span class="hljs-builtin-name">debug</span>
</code></pre>
      </li>
      <li class="list">Execute the following bash script to start the load test:
        <pre class="programlisting"><code class="hljs elixir"><span class="hljs-variable">$ </span>curl -L <span class="hljs-symbol">http:</span>/<span class="hljs-regexp">/bit.ly/load</span>-test-bash | bash -s <span class="hljs-number">100</span> <span class="hljs-string">"http://localhost:8080"</span>
</code></pre>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">This script will send <code class="Code-In-Text--PACKT-">100</code> requests per second to the server until you terminate it.</p>
      </li>
      <li class="list" value="3">Execute <code class="Code-In-Text--PACKT-">docker stats</code> to observe the performance characteristics.</li>
    </ol>
    <p class="normal">Here are high-level observations of CPU and memory utilization:</p>
    <table class="No-Table-Style" id="table002-2">
      <colgroup>
        <col/>
        <col/>
        <col/>
        <col/>
        <col/>
      </colgroup>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <strong class="heading"><strong class="bold">CPU utilization statistics</strong></strong>
          </td>
          <td class="No-Table-Style">
            <strong class="heading"><strong class="bold">Low</strong></strong>
          </td>
          <td class="No-Table-Style">
            <strong class="heading"><strong class="bold">Mid</strong></strong>
          </td>
          <td class="No-Table-Style">
            <strong class="heading"><strong class="bold">High</strong></strong>
          </td>
          <td class="No-Table-Style">
            <strong class="heading"><strong class="bold">Max memory</strong></strong>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="content"><code class="Code-In-Text--PACKT-">duluca/minimal-nginx-web-server</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="content">2%</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">15%</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">60%</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">2.4 MB</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="content"><code class="Code-In-Text--PACKT-">duluca/minimal-node-web-server</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="content">20%</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">45%</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">130%</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">75 MB</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">As you can see, there's a significant performance difference between the two servers serving the exact same content. Note that this kind of testing based on requests per second is good for comparative analysis and does not necessarily reflect real-world usage.</p>
    <p class="normal">It is clear that our NGINX server will give us the best bang for our buck. Armed with an optimal solution, let's deploy the application on AWS.</p>
    <h1 class="title" id="_idParaDest-450">Deploying to AWS ECS Fargate</h1>
    <p class="normal">AWS <strong class="bold">Elastic Container Service</strong> (<strong class="bold">ECS</strong>) Fargate is a cost-effective and easy-to-configure way to deploy your container in the cloud.</p>
    <p class="normal">ECS consists of four major parts:</p>
    <ol>
      <li class="list" value="1">A container repository, <strong class="bold">Elastic Container Registry</strong> (<strong class="bold">ECR</strong>), where you publish your Docker images.</li>
      <li class="list">Services, tasks, and task definitions, where you define runtime parameters and port mappings for your container as a task definition that a service runs as tasks.</li>
      <li class="list">A cluster, a collection of EC2 instances, where tasks can be provisioned and scaled out or in.</li>
      <li class="list" value="4">Fargate, a managed cluster service that abstracts away EC2 instances, load balancer, and security group concerns.</li>
    </ol>
    <div class="note">
      <p class="Information-Box--PACKT-">In the top right corner of the AWS console, be sure to select the region that is closest to your users. For me, this is the us-east-1 region.</p>
    </div>
    <p class="normal">Our goal is to create a highly available blue-green deployment, meaning that at least one instance of our application will be up and running in the event of a server failure or even during a deployment. These concepts are explored in detail in <em class="italics">Chapter 14</em>, <em class="italics">Google Analytics and Advanced Cloud Ops</em>, in the <em class="italics">Cost per user in a scalable environment</em> section.</p>
    <h2 class="title" id="_idParaDest-451">Configuring <a id="_idIndexMarker1473"/><a id="_idIndexMarker1474"/>ECS Fargate</h2>
    <p class="normal">You can access ECS functions under the AWS <strong class="bold">Services</strong> menu, selecting the <strong class="bold">Elastic Container Service</strong> link.</p>
    <div class="packt_tip">
      <p>If this is your first time logging in, you must go through a tutorial, where you will be forced to create a sample app. I would recommend going through the tutorial and deleting your sample app afterward. In order to delete a service, you need to update your service's number of tasks to 0. In addition, delete the default cluster to avoid any unforeseen charges.</p>
    </div>
    <h3 class="title" id="_idParaDest-452">Creating a Fargate cluster</h3>
    <p class="normal">Let's start by configuring a Fargate cluster, which acts as an anchor point when configuring other AWS services. Our cluster will eventually run a cluster service, which we will gradually build up in the following sections.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">AWS Fargate is great choice to implement a scalable container orchestration solution in the cloud. In recent years, Kubernetes has gained prevalence as a go-to solution. Kubernetes is an open source alternative to AWS ECS with richer capabilities for container orchestration with on-premises, cloud, and cloud-hybrid deployments. AWS does offer Amazon Elastic Container Service for Kubernetes (Amazon EKS), however RedHat's open source OpenShift platform is easier to use and comes with batteries included compared to vanilla Kubernetes.</p>
    </div>
    <p class="normal">Let's create the cluster:</p>
    <ol>
      <li class="list" value="1">Navigate to <strong class="screen-text">Elastic Container Service</strong>.</li>
      <li class="list">Click on <strong class="screen-text">Clusters</strong> | <strong class="screen-text">Create Cluster</strong>.</li>
      <li class="list">Select the <strong class="screen-text">Networking only... Powered by AWS Fargate</strong> template.</li>
      <li class="list">Click on the <strong class="screen-text">Next step</strong> and you'll see the <strong class="screen-text">Create Cluster</strong> step, as shown:<figure class="mediaobject"><img alt="" src="../Images/B14091_13_03.png"/></figure>
        <p class="packt_figref">Figure 13.3: AWS ECS Create Cluster</p>
      </li>
      <li class="list">Enter <strong class="screen-text">Cluster name</strong> as <code class="Code-In-Text--PACKT-">fargate-cluster</code>.</li>
      <li class="list">Create a <strong class="screen-text">VPC</strong> to isolate your resources from other AWS resources.</li>
      <li class="list" value="7">Click on <strong class="screen-text">Create Cluster</strong> to finish the setup.</li>
    </ol>
    <p class="normal">You will see the summary of your actions, as follows:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14091_13_04.png"/></figure>
    <p class="packt_figref">Figure 13.4: AWS ECS Fargate cluster</p>
    <p class="normal">Now that you have created a cluster within its own <strong class="bold">Virtual Private Cloud</strong> (<strong class="bold">VPC</strong>), you can view it under <strong class="screen-text">Elastic Container Service</strong> | <strong class="screen-text">Clusters</strong>.</p>
    <h3 class="title" id="_idParaDest-453">Creating a container repository</h3>
    <p class="normal">Next, we need to set up a repository where we can publish the container images we build in our local or CI environment:</p>
    <div class="note">
      <p class="Information-Box--PACKT-">This section presumes that you have set up Docker and npm scripts for Docker as detailed in <em class="italics">Chapter 9</em>, <em class="italics">DevOps Using Docker</em>. You can get the latest version of these scripts by executing <code class="Code-In-Text--PACKT-">npm i -g mrm-task-npm-docker</code> and applying them with <code class="Code-In-Text--PACKT-">npx mrm npm-docker</code>.</p>
    </div>
    <ol>
      <li class="list" value="1">Navigate to <strong class="screen-text">Elastic Container Service</strong>.</li>
      <li class="list">Click on <strong class="screen-text">Repositories</strong> | <strong class="screen-text">Create Repository</strong>.</li>
      <li class="list">Enter the repository name as <code class="Code-In-Text--PACKT-">lemon-mart</code>.</li>
      <li class="list">Copy the <strong class="screen-text">Repository URI</strong> generated on the screen.</li>
      <li class="list">Paste the URI in the <code class="Code-In-Text--PACKT-">package.json</code> file of your application as the new <code class="Code-In-Text--PACKT-">imageRepo</code> variable:
        <pre class="programlisting"><code class="hljs jboss-cli"><strong>package.json</strong>
<span class="hljs-string">...</span>
<span class="hljs-string">"config"</span>: {
  <span class="hljs-string">"imageRepo"</span>: <span class="hljs-string">"000000000000.dkr.ecr.us-east-1.amazonaws.com/lemon-mart"</span>,
  <span class="hljs-string">...</span>
}
</code></pre>
      </li>
      <li class="list">Click on <strong class="screen-text">Create Repository</strong>.</li>
      <li class="list" value="7">Click on <strong class="screen-text">Next step</strong> and then on <strong class="screen-text">Done</strong> to finish the setup.</li>
    </ol>
    <p class="normal">On the summary screen, you will get further instructions on how to use your repository with Docker. Later in the chapter, we will go over scripts that will take care of this for us:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14091_13_05.png"/></figure>
    <p class="packt_figref">Figure 13.5: AWS ECS repository</p>
    <p class="normal">You can view your new repository under <strong class="screen-text">Elastic Container Service</strong> | <strong class="screen-text">Repositories</strong>.</p>
    <div class="packt_tip">
      <p>We will go over how to publish your image in the upcoming <em class="italics">npm scripts for AWS</em> section.</p>
    </div>
    <p class="normal">Let's continue with the setup of ECS.</p>
    <h3 class="title" id="_idParaDest-454">Creating a task definition</h3>
    <p class="normal">With a container target defined in our repository, we can define a task definition, which contains the necessary metadata to run our container, such as port mappings, reserved CPU, and memory allocations:</p>
    <ol>
      <li class="list" value="1">Navigate to <strong class="screen-text">Elastic Container Service</strong>.</li>
      <li class="list">Click on <strong class="screen-text">Task Definitions</strong> | <strong class="screen-text">Create new Task Definition</strong>.</li>
      <li class="list">Select <strong class="screen-text">Fargate</strong> launch type compatibility.</li>
      <li class="list">Enter <strong class="screen-text">Task Definition Name</strong> as <code class="Code-In-Text--PACKT-">lemon-mart-task</code>.</li>
      <li class="list">Select <strong class="screen-text">Task role</strong> as none (you can add one later to enable access to other AWS services).</li>
      <li class="list">Enter <strong class="screen-text">Task Memory</strong> as <code class="Code-In-Text--PACKT-">0.5 GB</code>.</li>
      <li class="list">Enter <strong class="screen-text">Task CPU</strong> as <code class="Code-In-Text--PACKT-">0.25 CPU</code>.</li>
      <li class="list">Click on <strong class="screen-text">Add Container</strong>:<ul>
          <li class="Bullet-Within-Bullet--PACKT-">Enter <strong class="screen-text">Container name</strong> as <code class="Code-In-Text--PACKT-">lemon-mart</code>.</li>
          <li class="Bullet-Within-Bullet--PACKT-">For <strong class="screen-text">Image</strong>, paste the image repo URI from earlier, but append the <code class="Code-In-Text--PACKT-">:latest</code> tag to it so that it always pulls the latest image in the repository, such as <code class="Code-In-Text--PACKT-">000000000000.dkr.ecr.us-east-1.amazonaws.com/lemon-mart:latest</code>.</li>
          <li class="Bullet-Within-Bullet--PACKT-">Set a <strong class="screen-text">Soft limit</strong> of <code class="Code-In-Text--PACKT-">128 MB</code> for NGINX or <code class="Code-In-Text--PACKT-">256 MB</code> for Node.js.</li>
          <li class="Bullet-Within-Bullet--PACKT-">Under <strong class="screen-text">Port mappings</strong>, specify <strong class="screen-text">Container port</strong> as <code class="Code-In-Text--PACKT-">80</code> for NGINX or <code class="Code-In-Text--PACKT-">3000</code> for Node.js.</li>
        </ul>
      </li>
      <li class="list">Accept the remaining defaults.</li>
      <li class="list">Click on <strong class="screen-text">Add</strong>; this is how your task definition will look before creating it:<figure class="mediaobject"><img alt="" src="../Images/B14091_13_06.png"/></figure>
        <p class="packt_figref">Figure 13.6: AWS ECS task deﬁnition</p>
      </li>
      <li class="list" value="11">Click on <strong class="screen-text">Create</strong> to finish the setup.</li>
    </ol>
    <p class="normal">View your new <strong class="screen-text">Task Definition</strong> under <strong class="screen-text">Elastic Container Service</strong> | <strong class="screen-text">Task Definitions</strong>.</p>
    <p class="normal">Note that the default settings will enable AWS CloudWatch logging, which is a way you can retroactively access the console logs of your container instance. In this example, a CloudWatch log group named <code class="Code-In-Text--PACKT-">/ecs/lemon-mart-task</code> will be created.</p>
    <p class="normal">View your new log group under <strong class="screen-text">Cloud Watch</strong> | <strong class="screen-text">Logs</strong>.</p>
    <div class="packt_tip">
      <p>If you're adding a container that needs to persist data, the task definition allows you to define a volume and mount a folder to your Docker container. I've published a guide for configuring AWS <strong class="bold">Elastic File System</strong> (<strong class="bold">EFS</strong>) with your ECS container at <a href="https://bit.ly/mount-aws-efs-ecs-container"><span class="url">https://bit.ly/mount-aws-efs-ecs-container</span></a>. </p>
    </div>
    <h3 class="title" id="_idParaDest-455">Creating an elastic load balancer</h3>
    <p class="normal">In a highly available deployment, you want to be running two instances of your container, as defined by the task definition we just created, across two different <strong class="bold">Availability Zones</strong> (<strong class="bold">AZs</strong>). For this kind of dynamic scaling out and scaling in, we need to configure an <strong class="bold">Application Load Balancer</strong> (<strong class="bold">ALB</strong>) to handle request routing and draining:</p>
    <ol>
      <li class="list" value="1">On a separate tab, navigate to <strong class="screen-text">EC2</strong> | <strong class="screen-text">Load Balancers</strong> | <strong class="screen-text">Create Load Balancer</strong>.</li>
      <li class="list">Create an <strong class="screen-text">Application Load Balancer</strong>.</li>
      <li class="list">Enter <strong class="screen-text">Name</strong> as <code class="Code-In-Text--PACKT-">lemon-mart-alb</code>.<div class="note">
          <p class="Information-Box--PACKT-">In order to support SSL traffic under listeners, you can add a new listener for HTTPS on port <code class="Code-In-Text--PACKT-">443</code>. An SSL setup can be achieved conveniently via AWS services and wizards. During the ALB configuration process, AWS offers links to these wizards to create your certificates. However, it is an involved process and one that can vary depending on your existing domain hosting and SSL certification setup. I will be skipping over SSL-related configuration in this book. You can find SSL related steps in the guide I've published at <a href="https://bit.ly/setupAWSECSCluster"><span class="url">https://bit.ly/setupAWSECSCluster</span></a>.</p>
        </div>
      </li>
      <li class="list">Under <strong class="screen-text">Availability Zones</strong>, select the <strong class="screen-text">VPC</strong> that was created for your <strong class="screen-text">fargate-cluster</strong>.</li>
      <li class="list">Select all AZs listed.</li>
      <li class="list">Expand <strong class="screen-text">Tags</strong> and add a key/value pair to be able to identify the ALB, like <code class="Code-In-Text--PACKT-">"App": "LemonMart"</code>.</li>
      <li class="list">Click on <strong class="screen-text">Next: Configure Security Settings</strong>.<div class="note">
          <p class="Information-Box--PACKT-">If you added an HTTPS listener, you will see options to configure a certificate.</p>
          <p class="Information-Box--PACKT-">If configuring a certificate, click on <strong class="screen-text">Choose a certificate from ACM</strong> (AWS Certificate Manager) and select the <strong class="screen-text">Default ELB security policy</strong>.</p>
          <p class="Information-Box--PACKT-">If you never created a certificate, click on the <strong class="screen-text">Request a new certificate from ACM </strong>link to create one. If you have created a certificate before, then go to <strong class="screen-text">Certificate Manager</strong> to create a new one. Then, refresh and select your certificate.</p>
        </div>
      </li>
      <li class="list">Click on <strong class="screen-text">Next: Configure Security Groups</strong>.</li>
      <li class="list">Create a new cluster-specific security group, <code class="Code-In-Text--PACKT-">lemon-mart-sg</code>, only allowing port <code class="Code-In-Text--PACKT-">80</code> inbound or <code class="Code-In-Text--PACKT-">443</code> if using HTTPS.<div class="note">
          <p class="Information-Box--PACKT-">When creating your cluster service in the next section, ensure that the security group created here is the one selected during service creation. Otherwise, your ALB won't be able to connect to your instances.</p>
        </div>
      </li>
      <li class="list">Click on <strong class="screen-text">Next: Configure Routing</strong>.</li>
      <li class="list">Name a new <strong class="screen-text">Target group</strong> as <code class="Code-In-Text--PACKT-">lemon-mart-target-group</code>.</li>
      <li class="list">Change the protocol type from <code class="Code-In-Text--PACKT-">instance</code> to <code class="Code-In-Text--PACKT-">ip</code>.</li>
      <li class="list">Under <strong class="screen-text">Health check</strong>, keep the default route, <code class="Code-In-Text--PACKT-">/</code>, if serving a website on HTTP.<p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">Health checks are critical for scaling and deployment operations to work. This is the mechanism that AWS can use to check whether an instance has been created successfully or not.</p>
        <div class="packt_tip">
          <p class="Tip-Within-Bullet--PACKT-">If deploying an API and/or redirecting all HTTP calls to HTTPS, ensure that your app defines a custom route that is not redirected to HTTPS. On an HTTP server, <code class="Code-In-Text--PACKT-">GET /healthCheck</code> returns a simple 200 message saying <code class="Code-In-Text--PACKT-">I'm healthy</code> and verifying that this does not redirect to HTTPS. Otherwise, you will go through a lot of pain and suffering trying to figure out what's wrong, as all health checks fail and deployments inexplicably fail. <code class="Code-In-Text--PACKT-">duluca/minimal-node-web-server</code> provides HTTPS redirection, along with an HTTP-only <code class="Code-In-Text--PACKT-">/healthCheck</code> endpoint out of the box. With <code class="Code-In-Text--PACKT-">duluca/minimal-nginx-web-server</code>, you will need to provide your own configuration.</p>
        </div>
      </li>
      <li class="list">Click on <strong class="screen-text">Next: Register Targets</strong>.</li>
      <li class="list">Do <em class="italics">not</em> register any <strong class="screen-text">Targets</strong> or <strong class="screen-text">IP Ranges</strong>. ECS Fargate will magically manage this for you. If you do so yourself, you will provision a semi-broken infrastructure.</li>
      <li class="list">Click on <strong class="screen-text">Next: Review</strong>; your ALB settings should look similar to the ones shown:<figure class="mediaobject"><img alt="" src="../Images/B14091_13_07.png"/></figure>
        <p class="packt_figref">Figure 13.7: AWS Application Load Balancer settings</p>
      </li>
      <li class="list" value="17">Click on <strong class="screen-text">Create</strong> to finish the setup.</li>
    </ol>
    <p class="normal">You will be using <code class="Code-In-Text--PACKT-">lemon-mart-alb</code> when creating your cluster service in the next section.</p>
    <h3 class="title" id="_idParaDest-456">Creating a cluster service</h3>
    <p class="normal">Now, we will bring it all together by creating a service in our cluster using the task definition and the ALB we created:</p>
    <ol>
      <li class="list" value="1">Navigate to <strong class="screen-text">Elastic Container Service</strong>.</li>
      <li class="list">Click on <strong class="screen-text">Clusters</strong> | <strong class="screen-text">fargate-cluster</strong>.</li>
      <li class="list">Under the <strong class="screen-text">Services</strong> tab, click on <strong class="screen-text">Create</strong>.</li>
      <li class="list">Select <code class="Code-In-Text--PACKT-">Fargate</code> for <strong class="screen-text">Launch type</strong>.</li>
      <li class="list">Select the task definition you created earlier.<p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">Note that task definitions are versioned, such as <code class="Code-In-Text--PACKT-">lemon-mart-task:1</code>. If you were to make a change to the task definition, AWS would create <code class="Code-In-Text--PACKT-">lemon-mart-task:2</code>. You would need to update the service with this new version for your changes to take effect.</p>
      </li>
      <li class="list">Enter <strong class="screen-text">Service name</strong> as <code class="Code-In-Text--PACKT-">lemon-mart-service</code>.</li>
      <li class="list">For <strong class="screen-text">Number of tasks</strong>, select <code class="Code-In-Text--PACKT-">2</code>.</li>
      <li class="list">For <strong class="screen-text">Minimum healthy percent</strong>, select <code class="Code-In-Text--PACKT-">50</code>.</li>
      <li class="list">For <strong class="screen-text">Maximum percent</strong>, select <code class="Code-In-Text--PACKT-">200</code>.<p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">Stick with the <strong class="screen-text">Rolling update</strong> deployment type, as we'll implement our own blue/green deployment strategy.</p>
      </li>
      <li class="list">Click on <strong class="screen-text">Next</strong> <strong class="screen-text">step</strong>.<div class="packt_tip">
          <p class="Tip-Within-Bullet--PACKT-">Set <strong class="screen-text">Minimum healthy percent</strong> to <code class="Code-In-Text--PACKT-">100</code> for high availability even during deployment. Fargate pricing is based on usage per second, so while deploying your application, you will be charged extra for the additional instances, while the old ones are being deprovisioned.</p>
        </div>
      </li>
      <li class="list">Under <strong class="screen-text">Configure network</strong>, select the same <code class="Code-In-Text--PACKT-">VPC</code> as your cluster from earlier.</li>
      <li class="list">Select all subnets that are available; there should be at least two for high availability.</li>
      <li class="list">Select the security group you created in the previous section, named <code class="Code-In-Text--PACKT-">lemon-mart-sg</code>. (If you can't see it, refresh the page.)</li>
      <li class="list">Select the <strong class="screen-text">Load Balancer</strong> type as <strong class="screen-text">Application Load Balancer</strong>.</li>
      <li class="list">Select the <strong class="screen-text">lemon-mart-alb</strong> option.</li>
      <li class="list">Add <strong class="screen-text">Container port</strong> to the ALB, such as <code class="Code-In-Text--PACKT-">80</code> or <code class="Code-In-Text--PACKT-">3000</code>, by clicking on the <strong class="screen-text">Add to Load Balancer</strong> button.</li>
      <li class="list">Select the <strong class="screen-text">Production listener port</strong> that you have already defined.</li>
      <li class="list">Select the <strong class="screen-text">Target group</strong> you have already defined, <code class="Code-In-Text--PACKT-">lemon-mart-target-group</code>.</li>
      <li class="list">Uncheck <strong class="screen-text">Enable service discovery integration</strong>.</li>
      <li class="list">Click on <strong class="screen-text">Next step</strong>.</li>
      <li class="list">If you'd like your instances to scale out and in automatically, when their capacities reach a certain limit, then set <strong class="screen-text">Auto Scaling</strong>.<p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">I would recommend skipping the setup of auto scaling during the initial setup of your service to make it easier to troubleshoot any potential configuration issues. You can come back and set it up later. Automatic task scaling policies rely on alarms, such as CPU utilization. In <em class="italics">Chapter 14</em>, <em class="italics">Google Analytics and Advanced Cloud Ops</em>, in the <em class="italics">Cost per user in scalable environment</em> section, you can read about calculating your optimum target server utilization and set your alarms based on this number.</p>
      </li>
      <li class="list">Click on <strong class="screen-text">Next step</strong> and review your changes, as illustrated:<figure class="mediaobject"><img alt="" src="../Images/B14091_13_08.png"/></figure>
        <p class="packt_figref">Figure 13.8: AWS Fargate cluster service settings</p>
      </li>
      <li class="list" value="23">Finally, click on <strong class="screen-text">Create Service</strong> to finish the setup.</li>
    </ol>
    <p class="normal">Observe your new service under <strong class="screen-text">Elastic Container Service</strong> | <strong class="screen-text">Clusters</strong> | <strong class="screen-text">fargate-cluster</strong> | <strong class="screen-text">lemon-mart-service</strong>. Until you publish an image to your container repository, your AWS service won't be able to provision an instance, since the health check will continually fail. After you publish an image, you will want to ensure that there are no errors present in the <strong class="screen-text">Events</strong> tab for your service.</p>
    <p class="normal">AWS is a complicated beast and with Fargate, you can avoid a lot of complexity. However, if you're interested in setting up your own ECS cluster using your own EC2 instances, you can get significant discounts with reserved instances of 1-3 years. I have a 75+ step setup guide available at <a href="https://bit.ly/setupAWSECSCluster"><span class="url">https://bit.ly/setupAWSECSCluster</span></a>.</p>
    <p class="normal">We have executed a lot of steps manually to create our cluster. AWS CloudFormation resolves this issue by offering configuration templates that you can customize to your needs or script your own templates from scratch. If you would like to get serious about AWS, this kind of code-as-infrastructure setup is definitely the way to go.</p>
    <p class="normal">For production deployments, ensure that your configuration is defined by a CloudFormation template, so it can be easily re-provisioned not if, but when a deployment-related faux pas occurs.</p>
    <h3 class="title" id="_idParaDest-457">Configuring the DNS</h3>
    <p class="normal">To connect a domain or a subdomain name to your app, you must configure your DNS to point to the ALB. AWS offers the Route 53 service to manage your domain.</p>
    <p class="normal">Route 53 makes it easy to assign a domain or a subdomain to an ALB dynamically:</p>
    <ol>
      <li class="list" value="1">Navigate to <strong class="screen-text">Route 53</strong> | <strong class="screen-text">Hosted Zones</strong>.</li>
      <li class="list">If you already have a domain registered, select it; otherwise, register it with <strong class="screen-text">Create Hosted Zone</strong>.<p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">Note that you would need to re-assign the nameservers of your domain to the AWS one for this to take effect.</p>
      </li>
      <li class="list">Click on <strong class="screen-text">Create record set</strong>.</li>
      <li class="list">Enter <strong class="screen-text">Name</strong> as <code class="Code-In-Text--PACKT-">lemonmart</code>.</li>
      <li class="list">Set <strong class="screen-text">Alias</strong> to <code class="Code-In-Text--PACKT-">yes</code>.</li>
      <li class="list">Select <strong class="screen-text">lemon-mart-alb</strong> from the load balancer list.</li>
      <li class="list" value="7">Click on <strong class="screen-text">Create</strong> to finish the setup:<figure class="mediaobject"><img alt="" src="../Images/B14091_13_09.png"/></figure>
        <p class="packt_figref">Figure 13.9: Route 53 – Create Record Set</p>
      </li>
    </ol>
    <p class="normal">Now, your site will be reachable on the subdomain you just defined, for example, <a href="http://lemonmart.angularforenterprise.com"><span class="url">http://lemonmart.angularforenterprise.com</span></a>.</p>
    <p class="normal">If you don't use Route 53, don't panic. On your domain provider's website, edit the <code class="Code-In-Text--PACKT-">Zone</code> file to create an A record to the ALB's DNS address and you're done.</p>
    <h4 class="title">Getting the ALB DNS name</h4>
    <p class="normal">In order to get your load balancer's DNS address, perform these steps:</p>
    <ol>
      <li class="list" value="1">Navigate to <strong class="screen-text">EC2</strong> | <strong class="screen-text">Load Balancers</strong>.</li>
      <li class="list">Select <strong class="screen-text">lemon-mart-alb</strong>.</li>
      <li class="list" value="3">In the <strong class="screen-text">Description</strong> tab, note the DNS name; consider this example:
        <pre class="programlisting"><code class="hljs css"><span class="hljs-selector-tag">DNS</span> <span class="hljs-selector-tag">name</span>:
<span class="hljs-selector-tag">lemon-mart-alb-1871778644</span><span class="hljs-selector-class">.us-east-1</span><span class="hljs-selector-class">.elb</span><span class="hljs-selector-class">.amazonaws</span><span class="hljs-selector-class">.com</span> (<span class="hljs-selector-tag">A</span> <span class="hljs-selector-tag">Record</span>)
</code></pre>
      </li>
    </ol>
    <p class="normal">Now that we configured AWS <a id="_idIndexMarker1475"/><a id="_idIndexMarker1476"/>ECS Fargate, let's prep our Angular app to be deployed to AWS.</p>
    <h2 class="title" id="_idParaDest-458">Adding <a id="_idIndexMarker1477"/><a id="_idIndexMarker1478"/>npm scripts for AWS</h2>
    <p class="normal">Just like npm scripts for Docker, I have developed a set of scripts, called <strong class="bold">npm scripts for AWS</strong>, that work on Windows 10 and macOS. These scripts will allow you to upload and release your Docker images in spectacular, no-downtime, blue/green fashion. You can get the latest version of these scripts and automatically configure them in your project by executing the following steps:</p>
    <div class="note">
      <p class="Information-Box--PACKT-">We are configuring these settings on the <strong class="bold">lemon-mart</strong> project.</p>
    </div>
    <ol>
      <li class="list" value="1">Install the npm scripts for the AWS ECS task:
        <pre class="programlisting"><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i -g mrm-task-<span class="hljs-built_in">npm</span>-aws
</code></pre>
      </li>
      <li class="list" value="2">Apply the npm scripts for Docker configuration:
        <pre class="programlisting"><code class="hljs coffeescript">npx mrm <span class="hljs-built_in">npm</span>-aws
</code></pre>
      </li>
    </ol>
    <p class="normal">Now let's configure the scripts:</p>
    <ol>
      <li class="list" value="1">Ensure that <code class="Code-In-Text--PACKT-">mrm-task-npm-docker</code> scripts are set up in your project.</li>
      <li class="list">Create a <code class="Code-In-Text--PACKT-">.env</code> file and set <code class="Code-In-Text--PACKT-">AWS_ACCESS_KEY_ID</code> and <code class="Code-In-Text--PACKT-">AWS_SECRET_ACCESS_KEY</code>:
        <pre class="programlisting"><code class="hljs routeros"><strong>.env</strong>
<span class="hljs-attribute">AWS_ACCESS_KEY_ID</span>=your_own_key_id
<span class="hljs-attribute">AWS_SECRET_ACCESS_KEY</span>=your_own_secret_key
</code></pre>
      </li>
      <li class="list">Ensure that your <code class="Code-In-Text--PACKT-">.env</code> file is in your <code class="Code-In-Text--PACKT-">.gitignore</code> file to protect your secrets.</li>
      <li class="list">Install or upgrade to the latest AWS CLI:<ul>
          <li class="Bullet-Within-Bullet--PACKT-">On macOS, <code class="Code-In-Text--PACKT-">brew install awscli</code></li>
          <li class="Bullet-Within-Bullet-End--PACKT-">On Windows, <code class="Code-In-Text--PACKT-">choco install awscli</code></li>
        </ul>
      </li>
      <li class="list">Log in to the AWS CLI with your credentials:<ol>
          <li class="Numbered-Bullet-Within-Bullet--PACKT-">Run <code class="Code-In-Text--PACKT-">aws configure</code>.</li>
          <li class="Numbered-Bullet-Within-Bullet--PACKT-">You'll need your <strong class="screen-text">Access Key ID</strong> and <strong class="screen-text">Secret Access Key</strong> from when you configured your IAM account.</li>
          <li class="Numbered-Bullet-Within-Bullet-End--PACKT-">Set <strong class="screen-text">Default region name</strong> as <code class="Code-In-Text--PACKT-">us-east-1</code>.</li>
        </ol>
      </li>
      <li class="list">Update <code class="Code-In-Text--PACKT-">package.json</code> to add a new <code class="Code-In-Text--PACKT-">config</code> property with the following configuration properties:
        <pre class="programlisting"><code class="hljs jboss-cli"><strong>package.json</strong>
  <span class="hljs-string">...</span>
  <span class="hljs-string">"config"</span>: {
    <span class="hljs-string">...</span>
    <span class="hljs-string">"awsRegion"</span>: <span class="hljs-string">"us-east-1"</span>,
    <span class="hljs-string">"awsEcsCluster"</span>: <span class="hljs-string">"fargate-cluster"</span>,
    <span class="hljs-string">"awsService"</span>: <span class="hljs-string">"lemon-mart-service"</span>
  },
<span class="hljs-string">...</span>
</code></pre>
        <div class="packt_tip">
          <p>Ensure that you update <code class="Code-In-Text--PACKT-">package.json</code> from when you configured npm scripts for Docker so that the <code class="Code-In-Text--PACKT-">imageRepo</code> property has the address of your new ECS repository.</p>
        </div>
      </li>
      <li class="list">Ensure AWS scripts have been added to <code class="Code-In-Text--PACKT-">package.json</code>, as illustrated:
        <pre class="programlisting"><code class="hljs stata"><strong>package.json</strong>
...
<span class="hljs-string">"scripts"</span>: {
  ...
  <span class="hljs-string">"aws:login:win"</span>: "<span class="hljs-keyword">cross</span>-<span class="hljs-keyword">conf</span>-env 
     aws ecr get-login --<span class="hljs-keyword">no</span>-<span class="hljs-keyword">include</span>-email --region 
     <span class="hljs-variable">$npm_package_config_awsRegion</span> &gt; 
     dockerLogin.cmd &amp;&amp; call dockerLogin.cmd &amp;&amp; 
     del dockerLogin.cmd",
  <span class="hljs-string">"aws:login:mac"</span>: "eval $(aws ecr get-login 
     --<span class="hljs-keyword">no</span>-<span class="hljs-keyword">include</span>-email --region <span class="hljs-variable">$npm_package_config_awsRegion</span>)",
    <span class="hljs-string">"aws:login"</span>: <span class="hljs-string">"run-p -cs aws:login:win aws:login:mac"</span>, 
}
</code></pre>
      </li>
    </ol>
    <div class="note">
      <p class="Information-Box--PACKT-">Check your AWS CLI version by executing <code class="Code-In-Text--PACKT-">aws --version</code>. Depending on your version, your <code class="Code-In-Text--PACKT-">aws:login</code> needs to be different. The preceding script shows login scripts for AWS CLI v1. If you have v2, your login commands will look like the following scripts:</p>
      <p class="Information-Box--PACKT-"><strong class="bold">On macOS / Linux</strong>:</p>
      <p class="Information-Box--PACKT-">aws ecr get-login-password --region $npm_package_config_awsRegion | docker login --username AWS --password-stdin $npm_package_config_imageRepo </p>
      <p class="Information-Box--PACKT-"><strong class="bold">On Windows</strong>:</p>
      <p class="Information-Box--PACKT-">(Get-ECRLoginCommand).Password | docker login --username AWS --password-stdin $npm_package_config_imageRepo:latest </p>
    </div>
    <p class="normal"><code class="Code-In-Text--PACKT-">npm run aws:login</code> calls platform-specific commands that automate an otherwise multi-step action to get a <code class="Code-In-Text--PACKT-">docker login</code> command from the AWS CLI tool, as shown:</p>
    <pre class="programlisting"><code class="hljs gams"><strong>example</strong>
<span class="hljs-symbol">$</span> npm run aws:login 
<span class="hljs-function"><span class="hljs-title">docker</span></span> login -u AWS -p eyJwYXl..<span class="hljs-number">.3</span>ODk1fQ== https:<span class="hljs-comment">//00000000000.dkr.ecr.us-east-1.amazonaws.com</span>
<span class="hljs-symbol">$</span> docker login -u AWS -p eyJwYXl..<span class="hljs-number">.3</span>ODk1fQ== https:<span class="hljs-comment">//00000000000.dkr.ecr.us-east-1.amazonaws.com</span>
WARNING! <span class="hljs-keyword">Using</span> --password via the CLI is insecure. Use --password-stdin.
Login Succeeded
</code></pre>
    <p class="normal">You first execute <code class="Code-In-Text--PACKT-">aws ecr get-login</code> and then copy-paste the resulting <code class="Code-In-Text--PACKT-">docker login</code> command and execute it so that your local Docker instance is pointed to AWS ECR. Now let's see how we can deploy a built container:</p>
    <pre class="programlisting"><code class="hljs routeros"><strong>package.json</strong>
<span class="hljs-built_in">..</span>.
<span class="hljs-string">"scripts"</span>: {
<span class="hljs-built_in">..</span>.
<span class="hljs-string">"aws:deploy"</span>: <span class="hljs-string">"cross-conf-env docker run 
   --env-file ./.env silintl/ecs-deploy
   -c <span class="hljs-variable">$npm_package_config_awsEcsCluster</span> 
   -n <span class="hljs-variable">$npm_package_config_awsService</span> 
   -i <span class="hljs-variable">$npm_package_config_imageRepo</span>:latest 
   -r <span class="hljs-variable">$npm_package_config_awsRegion</span> --timeout 1000"</span>, 
}
<span class="hljs-built_in">..</span>.
example
$ docker image build . -f nginx.Dockerfile 
   -t 000000000.dkr.ecr.us-east-1.amazonaws.com/lemon-mart:latest
$ npm <span class="hljs-builtin-name">run</span> docker:publish
$ npm <span class="hljs-builtin-name">run</span> aws:deploy
Using image name: 0000000.dkr.ecr.us-east-1.amazonaws.com/lemon-mart:latest
Current task definition: arn:aws:ecs:us-east-1: 0000000:task-definition/lemon-mart-task:7
New task definition: arn:aws:ecs:us-east-1: 0000000:task-definition/lemon-mart-task:8<span class="hljs-built_in">
Service </span>updated successfully, new task definition running.
Waiting <span class="hljs-keyword">for</span><span class="hljs-built_in"> service </span>deployment <span class="hljs-keyword">to</span> complete<span class="hljs-built_in">..</span>.<span class="hljs-built_in">
Service </span>deployment successful.
</code></pre>
    <p class="normal">We first build the NGINX version of the Docker image for our web app because we're listening to port <code class="Code-In-Text--PACKT-">80</code> on ECS. Then, publish the container to ECR and finally execute <code class="Code-In-Text--PACKT-">npm run aws:deploy</code>, which uses the <code class="Code-In-Text--PACKT-">silintl/ecs-deploy</code> Docker container that runs a blue/green deployment.</p>
    <div class="packt_tip">
      <p>The details of how blue/green deployment works using ECS commands are beyond the scope of this book. To see more examples using native AWS ECS commands, refer to the <code class="Code-In-Text--PACKT-">aws-samples</code> repository at <a href="https://github.com/aws-samples/ecs-blue-green-deployment"><span class="url">https://github.com/aws-samples/ecs-blue-green-deployment</span></a>.</p>
    </div>
    <p class="normal">We can group our commands together to execute them as a singular <code class="Code-In-Text--PACKT-">release</code> command, as shown here:</p>
    <pre class="programlisting"><code class="hljs jboss-cli"><strong>package.json</strong>
<span class="hljs-string">...</span>
<span class="hljs-string">"scripts"</span>: {
  <span class="hljs-string">...</span>
  <span class="hljs-string">"aws:release"</span>: <span class="hljs-string">"run-s -cs aws:login docker:publish aws:deploy"</span>
}
<span class="hljs-string">...</span>
</code></pre>
    <p class="normal">Finally, <code class="Code-In-Text--PACKT-">npm run aws:release</code> simply runs <code class="Code-In-Text--PACKT-">aws:login, docker:publish</code> from the npm scripts for Docker and <code class="Code-In-Text--PACKT-">aws:deploy</code> commands in the right order.</p>
    <h2 class="title" id="_idParaDest-459">Publish</h2>
    <p class="normal">Your project is configured to be deployed on AWS. You mostly need to use two of the commands we created to build and publish an image:</p>
    <ol>
      <li class="list" value="1">Execute <code class="Code-In-Text--PACKT-">docker:debug</code> to test, build, tag, run, tail, and launch your app in a browser to test the image:
        <pre class="programlisting"><code class="hljs routeros">$ npm <span class="hljs-builtin-name">run</span> docker:<span class="hljs-builtin-name">debug</span>
</code></pre>
      </li>
      <li class="list" value="2">Execute <code class="Code-In-Text--PACKT-">aws:release</code> to configure Docker login with AWS, publish your latest image build, and release it on ECS:
        <pre class="programlisting"><code class="hljs arduino">$ npm <span class="hljs-built_in">run</span> aws:<span class="hljs-built_in">release</span>
</code></pre>
        <div class="packt_tip">
          <p>Note that when running multiple commands back to back and one of the commands exits with status <code class="Code-In-Text--PACKT-">1</code>, then npm considers this a failure. However, this doesn't necessarily mean that your action failed. Always scroll through the terminal outputs to see if any real errors were thrown.</p>
        </div>
      </li>
      <li class="list">Verify that your tasks are up and running at the <strong class="bold">Service</strong> level:<figure class="mediaobject"><img alt="" src="../Images/B14091_13_10.png"/></figure>
        <p class="packt_figref">Figure 13.10: AWS ECS service</p>
        <div class="packt_tip">
          <p>Ensure that <strong class="screen-text">Running count</strong> and <strong class="screen-text">Desired count</strong> are the same. A mismatch or a deploy taking a very long time usually means that the health check on your new container is failing. Check out the <strong class="screen-text">Events</strong> tab for more information. Your container is either failing to start up or you're likely listening to the wrong port.</p>
        </div>
      </li>
      <li class="list" value="4">Verify that your instances are running at the <strong class="screen-text">Task</strong> level:<figure class="mediaobject"><img alt="" src="../Images/B14091_13_11.png"/></figure>
        <p class="packt_figref">Figure 13.11: AWS ECS task instance</p>
        <p class="Bullet-Without-Bullet-Within-Bullet--PACKT-">Note the <strong class="screen-text">Public IP</strong> address and navigate to it; for example, <code class="Code-In-Text--PACKT-">http://54.164.92.137</code>, and you should see your application or LemonMart running.</p>
      </li>
      <li class="list">Verify that the <strong class="screen-text">Load Balancer</strong> setup is correct at the DNS level.</li>
      <li class="list">Navigate to the <strong class="screen-text">ALB DNS address</strong>, for example <a href="http://lemon-mart-alb-681490029.us-east-1.elb.amazonaws.com"><span class="url">http://lemon-mart-alb-681490029.us-east-1.elb.amazonaws.com</span></a>, and confirm that the app renders as follows:<figure class="mediaobject"><img alt="" src="../Images/B14091_13_12.png"/></figure>
        <p class="packt_figref">Figure 13.12: LemonMart running on AWS Fargate</p>
      </li>
    </ol>
    <p class="normal">Et voilà! Your site should be up and running.</p>
    <p class="normal">In subsequent releases, following your first, you will be able to observe blue-green deployment in action, as shown:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14091_13_13.png"/></figure>
    <p class="packt_figref">Figure 13.13: AWS Service during blue-green deployment</p>
    <p class="normal">There are two tasks running, with two new ones being provisioned. While the new tasks are being verified, <strong class="screen-text">Running count</strong> will rise up to four tasks. After the new tasks are verified and the connections from old ones are drained, <strong class="screen-text">Running count</strong> will return to two.</p>
    <p class="normal">You can automate your deployments by configuring CircleCI with your AWS credentials, using a container that has the <code class="Code-In-Text--PACKT-">awscli</code> tool installed and running npm scripts for AWS. With this technique, you can achieve continuous deployment to a staging environment or continuous delivery to a production environment.</p>
    <h2 class="title" id="_idParaDest-460">Deploying to AWS using <a id="_idIndexMarker1479"/><a id="_idIndexMarker1480"/>CircleCI</h2>
    <p class="normal">In <em class="italics">Chapter 9</em>, <em class="italics">DevOps Using Docker</em>, we implemented a CircleCI pipeline based on a multi-stage <code class="Code-In-Text--PACKT-">Dockerfile</code>, which resulted in a tar and gzipped Docker image. We also covered how to implement a deploy step using CircleCI. Leveraging what we learned in this chapter, we can combine the two strategies so we can deploy to AWS using CircleCI.</p>
    <p class="normal">For an AWS deployment, you can use the <code class="Code-In-Text--PACKT-">aws-cli</code> orb and a <code class="Code-In-Text--PACKT-">deploy</code> job. The <code class="Code-In-Text--PACKT-">deploy</code> job will have steps to restore the built Docker image from the cache, log in to AWS, and push the image to your AWS ECS container repository.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">On the <strong class="bold">lemon-mart</strong> repo, the <code class="Code-In-Text--PACKT-">config.yml</code> file for this section is named <code class="Code-In-Text--PACKT-">.circleci/config.docker-integration.yml</code>. You can also find a pull request that executes the YML file from this chapter on CircleCI at <a href="https://github.com/duluca/lemon-mart/pull/27"><span class="url">https://github.com/duluca/lemon-mart/pull/27</span></a> using the branch <code class="Code-In-Text--PACKT-">deploy_aws</code>.</p>
    </div>
    <p class="normal">For pushing the containers, we then deploy by running <code class="Code-In-Text--PACKT-">npm run aws:deploy</code>. Let's add a new <code class="Code-In-Text--PACKT-">deploy</code> job to our <code class="Code-In-Text--PACKT-">config.yml</code> file.</p>
    <p class="normal">Under <strong class="screen-text">CircleCI Account Settings</strong> or <strong class="screen-text">Organization Settings</strong>, add a new <strong class="screen-text">context</strong> named <code class="Code-In-Text--PACKT-">aws</code>. Set the <code class="Code-In-Text--PACKT-">AWS_ACCOUNT_ID</code>, <code class="Code-In-Text--PACKT-">AWS_ACCESS_KEY_ID</code>, <code class="Code-In-Text--PACKT-">AWS_SECRET_ACCESS_KEY</code>, and <code class="Code-In-Text--PACKT-">AWS_DEFAULT_REGION</code> environment variables as a part of the context.</p>
    <p class="normal">See the configuration changes here: </p>
    <pre class="programlisting"><code class="hljs routeros"><strong>.circleci/config.yml</strong>
version: 2.1
orbs:
  <strong>aws-cli: circleci/aws-cli@1.0.0</strong>
<span class="hljs-built_in">..</span>.
jobs:
  <span class="hljs-built_in">..</span>.
  <strong>deploy:</strong>
<strong>    executor: aws-cli<span class="hljs-built_in">/default</span></strong><span class="hljs-built_in">
</span>    working_directory: ~/repo
    steps:
      - attach_workspace:
          at: /tmp/workspace
      - checkout
      - setup_remote_docker
      - aws-cli/setup
      - run: npm ci
      - run:
          name: Restore .env files
          command: |
            <span class="hljs-builtin-name">set</span> +H
            <span class="hljs-attribute">DOT_ENV</span>=AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID\\nAWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY
            echo -e <span class="hljs-variable">$DOT_ENV</span> &gt; .env
      - run:
          name: Sign Docker into AWS ECR
          command: |
            aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin <span class="hljs-variable">$AWS_ACCOUNT_ID</span>.dkr.ecr.us-east-1.amazonaws.com/lemon-mart
      - run:
          name: Push it <span class="hljs-keyword">to</span> ECR
          command: |
            docker load &lt; /tmp/workspace/built-image.tar.gz
            <span class="hljs-attribute">ECR_URI</span>=<span class="hljs-variable">$AWS_ACCOUNT_ID</span>.dkr.ecr.us-east-1.amazonaws.com/lemon-mart
            docker image tag lemon-mart:<span class="hljs-variable">$CIRCLE_BRANCH</span> <span class="hljs-variable">$ECR_URI</span>:<span class="hljs-variable">$CIRCLE_BRANCH</span>
            docker image tag <span class="hljs-variable">$ECR_URI</span>:<span class="hljs-variable">$CIRCLE_BRANCH</span> <span class="hljs-variable">$ECR_URI</span>:latest
            docker image push <span class="hljs-variable">$ECR_URI</span>:<span class="hljs-variable">$CIRCLE_BRANCH</span>
            docker image push <span class="hljs-variable">$ECR_URI</span>:latest      
      - run:
          name: Deploy
          <strong>command: npm <span class="hljs-builtin-name">run</span> aws:deploy</strong>
</code></pre>
    <p class="normal">We configure the <code class="Code-In-Text--PACKT-">aws-cli</code> orb with the <code class="Code-In-Text--PACKT-">aws-cli/setup</code> job. We then execute <code class="Code-In-Text--PACKT-">npm ci</code>, so we can run our npm script later on. We restore the <code class="Code-In-Text--PACKT-">.env</code> file using CircleCI environment variables. We configure Docker with our AWS ECR login information, so we can push containers to it. We store <code class="Code-In-Text--PACKT-">built-image.tar.gz</code> from the prior step and load it using the <code class="Code-In-Text--PACKT-">docker load</code> comment. We tag and push the image to ECR. Finally, we execute <code class="Code-In-Text--PACKT-">npm run aws:deploy</code>, which triggers our blue/green deployment.</p>
    <p class="normal">Last, but not least, we update <code class="Code-In-Text--PACKT-">workflows</code> to include the <code class="Code-In-Text--PACKT-">deploy</code> job and configure the <code class="Code-In-Text--PACKT-">aws context</code> we defined earlier: </p>
    <pre class="programlisting"><code class="hljs yaml"><strong><span class="hljs-string">.circleci/config.yml</span></strong>
<span class="hljs-string">...</span>
<span class="hljs-attr">workflows:</span>
  <span class="hljs-attr">version:</span> <span class="hljs-number">2</span>
  <span class="hljs-attr">build-and-deploy:</span>
    <span class="hljs-attr">jobs:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">build</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">deploy:</span>
          <strong><span class="hljs-attr">context:</span> <span class="hljs-string">aws</span></strong>
          <span class="hljs-attr">requires:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">build</span>
</code></pre>
    <div class="note">
      <p class="Information-Box--PACKT-">Getting the context configured in CircleCI correctly is critically important. If misconfigured, you will find yourself in a Kafkaesque labyrinth of errors, bad documentation, and misery. Don't say that I didn't warn you.</p>
    </div>
    <p class="normal">See the screenshot of a successful deployment here:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B14091_13_14.png"/></figure>
    <p class="packt_figref">Figure 13.14: Successful CircleCI deployment to an AWS Fargate cluster</p>
    <div class="packt_tip">
      <p>Note that the deploy step takes nearly 7 minutes. This is because the blue/green deployment makes sure that our new deployment is healthy and then it drains connections from existing containers to the new ones, which with the default settings takes 5 minutes. If the new deployment is not healthy, the deploy step will timeout and fail after 10 minutes.</p>
    </div>
    <p class="normal">Congratulations! Now we can continuously deploy to AWS in spectacular no-downtime, blue/green fashion. This is all great, but how much does a basic highly available configuration cost? </p>
    <div class="packt_tip">
      <p>To avoid charges, delete <code class="Code-In-Text--PACKT-">lemon-mart-service</code>. To do this, you need to update your service's number of tasks to 0 first. In addition, delete the default cluster created for you to avoid any unforeseen charges.</p>
    </div>
    <p class="normal">Let's examine the costs in the next section.</p>
    <h1 class="title" id="_idParaDest-461"><a id="_idIndexMarker1481"/><a id="_idIndexMarker1482"/>AWS billing</h1>
    <p class="normal">My highly-available deployment of LemonMart on AWS Fargate costs roughly $45 a month. Here's the breakdown:</p>
    <table class="No-Table-Style" id="table003-1">
      <colgroup>
        <col/>
        <col/>
      </colgroup>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <strong class="heading">Description</strong>
          </td>
          <td class="No-Table-Style">
            <strong class="heading">Cost</strong>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="content">Amazon Simple Storage Service (S3)</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">$0.01</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="content">AWS Data Transfer</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">$0.02</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="content">Amazon CloudWatch</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">$0.00</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="content">Amazon EC2 Container Service (ECS Fargate)</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">$27.35</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="content">Amazon Elastic Compute Cloud (EC2 Load Balancer instances)</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">$16.21</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="content">Amazon EC2 Container Registry (ECR)</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">$0.01</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="content">Amazon Route 53</p>
          </td>
          <td class="No-Table-Style">
            <p class="content">$0.50</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <strong class="heading">Total</strong>
          </td>
          <td class="No-Table-Style">
            <strong class="heading">$44.10</strong>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">Note that the bill is very detailed, but it does accurately break down all the AWS services we end up using. The major costs are running two instances of our web server on <strong class="bold">EC2 Container Service</strong> (<strong class="bold">ECS</strong>) and running load balancers on <strong class="bold">Elastic Compute Cloud</strong> (<strong class="bold">EC2</strong>). Objectively speaking, $45/month may seem like a lot of money to host one web application. It is possible to get a lot more for your money if you're willing to set up your own cluster with dedicated EC2 servers where you can pay in 1 or 3-year increments and get cost savings of up to 50%. A similar, highly available deployment with two instances on Heroku starts at $50/month with other rich features you can get access to. Similarly, two instances on Vercel Now will cost $30/month. Note that both Heroku and Vercel Now don't give you access to physically diverse availability zones. Digital Ocean, on the other hand, allows you to provision servers in different data centers; however, you must code your own infrastructure. For $15/month, you can set up your own highly available cluster across three servers and be able to host multiple sites on it.</p>
    <h1 class="title" id="_idParaDest-462">Summary</h1>
    <p class="normal">In this chapter, you learned about the nuances and various security considerations in properly protecting your AWS account. We went over the concepts of right-sizing your infrastructure. You conducted simple load testing in an isolated manner to find out relative differences in performance between two web servers. Armed with an optimized web server, you configured an AWS ECS Fargate cluster to achieve a highly available cloud infrastructure. Using npm scripts for AWS, you learned how to script repeatable and reliable no-downtime blue/green deployments. Finally, you became aware of the basic costs of running your infrastructure on AWS and other cloud providers such as Heroku, Vercel Now, and Digital Ocean.</p>
    <p class="normal">In the next and final chapter, we will complete our coverage of the breadth of topics that a full-stack web developer should know about when deploying applications on the web. We will add Google Analytics to LemonMart to measure user behavior, leverage advanced load testing to understand the financial impact of deploying a well-configured scalable infrastructure, and measure the actual use of important application features with custom analytics events.</p>
    <h1 class="title" id="_idParaDest-463">Exercise</h1>
    <p class="normal">Deploy LemonMart's server infrastructure, using its <code class="Code-In-Text--PACKT-">docker-compse.yml</code> file, to AWS ECS. As a bonus, configure AWS ECS with AWS <strong class="bold">Elastic Filesystem</strong> (<strong class="bold">EFS</strong>) to persist your MongoDB data:</p>
    <ol>
      <li class="li" value="1">Install the ECS CLI from <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ECS_CLI_installation.html"><span class="url">https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ECS_CLI_installation.html</span></a>.</li>
      <li>Add <code class="Code-In-Text--PACKT-">mrm-task-npm-aws</code> scripts to the root of <code class="Code-In-Text--PACKT-">lemon-mart-server</code>.</li>
      <li>Create a new <code class="Code-In-Text--PACKT-">docker-compose.aws.yml</code> at version 3.0 and update it to refer to already published versions of your containers.</li>
      <li>Using the <code class="Code-In-Text--PACKT-">npm run aws:publish:compose</code> command, deploy your app.</li>
    </ol>
    <p class="normal">You can use the Minimal MEAN project and the linked GitHub gists as a guide at <a href="https://github.com/duluca/minimal-mean#continuous-integration-and-hosting"><span class="url">https://github.com/duluca/minimal-mean#continuous-integration-and-hosting</span></a>.</p>
    <h1 class="title" id="_idParaDest-464">Further reading</h1>
    <ul>
      <li class="list"><em class="italics">AWS Certified Solutions Architect Official Study Guide</em>, Joe Baron, Hisham Baz, et al. 2016, ISBN-13: 978-1119138556.</li>
      <li class="list"><em class="italics">Configuring AWS ECS to have access to AWS EFS</em>, 2018, Doguhan Uluca, <a href="https://bit.ly/mount-aws-efs-ecs-container"><span class="url">https://bit.ly/mount-aws-efs-ecs-container</span></a>.</li>
      <li class="list"><em class="italics">BlueGreenDeployment</em>, Martin Fowler, 2010, <a href="https://martinfowler.com/bliki/BlueGreenDeployment.html"><span class="url">https://martinfowler.com/bliki/BlueGreenDeployment.html</span></a>.</li>
    </ul>
    <h1 class="title" id="_idParaDest-465">Questions</h1>
    <p class="normal">Answer the following questions as best as you can to ensure that you've understood the key concepts from this chapter without Googling. Do you need help answering the questions? See <em class="italics">Appendix D</em>, <em class="italics">Self-Assessment Answers</em> online at <a href="https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf"><span class="url">https://static.packt-cdn.com/downloads/9781838648800_Appendix_D_Self-Assessment_Answers.pdf</span></a> or visit <a href="https://expertlysimple.io/angular-self-assessment"><span class="url">https://expertlysimple.io/angular-self-assessment</span></a>.</p>
    <ol>
      <li class="list" value="1">What are the benefits of right-sizing your infrastructure?</li>
      <li>What is the benefit of using AWS ECS Fargate over AWS ECS?</li>
      <li>Did you remember to turn off your AWS infrastructure to avoid getting billed extra?</li>
      <li>What is blue/green deployment?</li>
    </ol>
  </div>
</body></html>