- en: <st c="0">11</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="3">Refactoring and Improving Angular Code through TDD</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="54">Refactoring your Angular code</st> <st c="85">using</st> **<st c="91">test-driven
    development</st>** <st c="114">(</st>**<st c="116">TDD</st>**<st c="119">) is
    a systematic and effective approach to improving the quality of your code.</st>
    <st c="200">TDD involves writing tests before writing the actual code, thus ensuring
    that the code addresses the desired requirements and is robust, maintainable,
    and reliable.</st> <st c="365">This methodology is particularly beneficial for
    Angular applications, where it ensures that the code is well structured, efficient,
    and easy</st> <st c="506">to maintain.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="518">In this section, we delve into the significance of adopting a “tests
    first” strategy, exploring the advantages of TDD during refactoring processes,
    selecting the optimal tests to create, understanding what</st> <st c="724">constitutes</st>
    **<st c="737">code smells</st>**<st c="748">, emphasizing the importance of addressing
    code smells within Angular projects, and identifying prevalent code smells in</st>
    <st c="869">Angular applications.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="890">In summary, here are the main topics that will be covered in</st>
    <st c="952">this chapter:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="965">Refactoring Angular code</st> <st c="991">through TDD</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1002">Identifying code smells and areas for improvement in</st> <st c="1056">Angular
    applications</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1076">Iterative improvement – red-green-refactor cycle for continuous</st>
    <st c="1141">code enhancement</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1157">Technical requirements</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="1180">To follow along with the examples and exercises in this chapter,
    you will need to have a basic understanding of Angular and TypeScript, as well
    as the following</st> <st c="1342">technical requirements:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1365">Node.js and npm installed on</st> <st c="1395">your computer</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1408">Angular CLI</st> <st c="1421">installed globally</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1439">A code editor, such as Visual Studio Code, installed on</st> <st
    c="1496">your computer</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1509">The code files required for this chapter can be found</st> <st
    c="1564">at</st> [<st c="1567">https://github.com/PacktPublishing/Mastering-Angular-Test-Driven-Development/tree/main/Chapter%2011</st>](https://github.com/PacktPublishing/Mastering-Angular-Test-Driven-Development/tree/main/Chapter%2011)<st
    c="1666">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1667">Refactoring Angular code with TDD</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="1701">Refactoring existing</st> <st c="1722">code in complex Angular
    applications can be a nerve-wracking task.</st> <st c="1790">You want to improve
    the</st> <st c="1813">code’s structure and organization without accidentally breaking
    existing functionalities.</st> <st c="1904">This is where TDD comes into play,
    offering a structured approach to navigate refactoring with confidence.</st> <st
    c="2011">In this section, we’ll see the power of the test-first approach, the
    benefits of TDD in refactoring, and how to choose the right tests</st> <st c="2146">to
    write.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2155">The power of the test-first approach</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="2192">TDD flips</st> <st c="2202">the traditional coding script.</st>
    <st c="2234">Instead of writing code first and then testing it, TDD emphasizes
    writing tests before making any modifications to the code.</st> <st c="2359">These
    tests essentially define the expected behavior of the code you intend to refactor.</st>
    <st c="2448">Here’s how</st> <st c="2459">it works:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="2468">The red state</st>**<st c="2482">: You start by writing a test
    for a specific functionality within the code you want to refactor.</st> <st c="2580">This
    initial test will likely fail, signifying that the desired behavior isn’t yet
    implemented.</st> <st c="2676">This</st> *<st c="2681">red</st>* <st c="2684">state
    acts as a</st> <st c="2701">starting point.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="2716">The green state</st>**<st c="2732">: With the failing test as
    your guide, you write just enough code to make the test pass.</st> <st c="2822">This
    initial implementation might be basic, but the focus is on ensuring it accurately
    reflects the intended behavior defined by the test.</st> <st c="2961">Now, the
    test is in a</st> *<st c="2983">green</st>* <st c="2988">state, indicating</st>
    <st c="3007">successful implementation.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="3033">Refactor</st>**<st c="3042">: Here’s where the magic happens.</st>
    <st c="3077">With the safety net of a passing test, you can now refactor the code
    to improve its readability, maintainability, and efficiency.</st> <st c="3207">This
    might involve</st> <st c="3226">the following:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="3240">Breaking down long methods into smaller,</st> <st c="3282">well-defined
    functions</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="3304">Extracting reusable components or services from</st> <st c="3353">large
    components</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="3369">Applying design patterns for better</st> <st c="3406">code organization</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="3423">Simplifying logic to</st> <st c="3445">enhance clarity</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="3460">Throughout</st> <st c="3471">this refactoring stage, the passing
    test ensures that these changes don’t introduce any unintended side effects.</st>
    <st c="3585">Essentially, you’re improving the code’s internal workings without
    altering its external behavior as verified by the test.</st> <st c="3708">As an
    example, let’s start with this block of code from our</st> `<st c="3768">calculator.component.ts</st>`
    <st c="3791">component in the</st> `<st c="3809">Chapter 9</st>` <st c="3818">folder
    (</st>[<st c="3827">https://github.com/PacktPublishing/Mastering-Angular-Test-Driven-Development/tree/main/Chapter%209/getting-started-angular-</st><st
    c="3951">tdd</st>](https://github.com/PacktPublishing/Mastering-Angular-Test-Driven-Development/tree/main/Chapter%209/getting-started-angular-tdd)<st
    c="3955">):</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: <st c="4634">Here is the</st> <st c="4647">source code for the tests corresponding
    to this function in our</st> `<st c="4711">calculator.component.spec.ts</st>`
    <st c="4739">file:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: <st c="6629">As a reminder, all</st> <st c="6649">tests are green, as shown
    in the following screenshot of Karma launched on</st> <st c="6724">a browser:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Calculator component test succeeded in the terminal](img/B21146_11_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="7953">Figure 11.1 – Calculator component test succeeded in the terminal</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="8018">We will now</st> <st c="8031">refactor the</st> <st c="8044">code</st>
    <st c="8048">of our</st> `<st c="8056">calculate()</st>` <st c="8067">function
    in the</st> `<st c="8084">calculator.component.ts</st>` <st c="8107">component</st>
    <st c="8118">as follows:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: <st c="8672">Now, what’s</st> <st c="8685">going on with our tests?</st> <st
    c="8710">They’re still all green as the following</st> <st c="8751">screenshot
    shows:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Green tests](img/B21146_11_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="10014">Figure 11.2 – Green tests</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10039">This means that our refactoring is correct because if it wasn’t,
    our tests would be red.</st> <st c="10129">We now understand the importance of
    TDD, because we can concentrate on refactoring our methods with peace of mind.</st>
    <st c="10244">In the next section, we’ll learn some benefits of TDD</st> <st c="10298">in
    refactoring.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10313">Benefits of TDD in refactoring</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="10344">This section delves</st> <st c="10364">into the rewarding benefits
    of utilizing TDD during Angular code refactoring.</st> <st c="10443">Here are
    some</st> <st c="10457">of them:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="10465">Increased confidence</st>**<st c="10486">: The passing test
    acts as a safety net, allowing you to experiment with different refactoring techniques
    without worrying about breaking existing functionality.</st> <st c="10649">This
    boosts your confidence during</st> <st c="10684">the process.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="10696">Improved design</st>**<st c="10712">: Thinking about the tests
    first encourages you to write modular code with well-defined functions.</st> <st
    c="10812">This leads to cleaner and more maintainable code in the</st> <st c="10868">long
    run.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="10877">Enhanced maintainability</st>**<st c="10902">: A comprehensive
    test suite becomes a living documentation of the code’s expected behavior.</st>
    <st c="10996">This simplifies future modifications and bug fixes, as you can rely
    on the tests to</st> <st c="11080">catch regressions.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="11098">Better code coverage</st>**<st c="11119">: TDD naturally encourages
    you to focus on covering various code paths with tests.</st> <st c="11203">This
    results in more robust applications with fewer</st> <st c="11255">hidden bugs.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="11267">Examples in action</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="11286">Let’s see how</st> <st c="11300">TDD can be applied to common
    refactoring scenarios</st> <st c="11352">in Angular:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="11363">Refactoring a long service method</st>**<st c="11397">: Imagine
    a service method responsible for fetching and processing a massive amount of data.</st>
    <st c="11491">You can write a test that focuses on a specific aspect of the data
    processing logic.</st> <st c="11576">Initially, the test would fail.</st> <st
    c="11608">Then, you’d refactor the service method to extract that logic into a
    separate, well-tested function.</st> <st c="11709">This improves code readability
    and maintainability while the test ensures the core functionality</st> <st c="11806">remains
    intact.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="11821">Transforming a god component</st>**<st c="11850">: A “god component”
    refers to an overly complex component, often violating the single responsibility
    principle by handling too many responsibilities or functionalities within itself.</st>
    <st c="12034">This term is used to highlight the negative aspects of having components
    that grow too large and become difficult to manage, test, and understand.</st>
    <st c="12181">Such components tend to inject numerous services, perform multiple
    tasks, and can lead to significant maintenance challenges o</st><st c="12307">ver
    time.</st> <st c="12318">This type of component performing a large number of tasks
    can therefore be redesigned by creating services dedicated to specific functionalities.</st>
    <st c="12464">Tests can be written to verify the behavior of the refactored component
    and the newly</st> <st c="12550">created services.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="12567">Choosing the right tests to write</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="12601">When prioritizing</st> <st c="12619">tests for refactoring with
    TDD, consider</st> <st c="12661">these strategies:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="12678">Focus on pain points</st>**<st c="12699">: Start with functionalities
    that are causing problems in your codebase, such as areas prone to errors or difficult</st>
    <st c="12816">to understand.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="12830">Start small</st>**<st c="12842">: Begin with smaller, well-defined
    tests that target specific functionalities.</st> <st c="12922">This allows for
    quicker iterations through the</st> <st c="12969">red-green-refactor cycle.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="12994">Test integration points</st>**<st c="13018">: When refactoring
    components that interact with services or other components, write tests that verify
    these interactions alongside the</st> <st c="13154">component itself.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="13172">In the next section, we’ll explain how to identify code smells
    and areas for improvement in</st> <st c="13265">Angular applications.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="13286">Identifying code smells and areas for improvement in Angular applications</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="13360">While your</st> <st c="13372">Angular application might seem functional
    on the surface, there could be underlying issues waiting to erupt.</st> <st c="13481">These
    issues, known as code smells, don’t necessarily cause immediate problems but indicate
    areas in your codebase</st> <st c="13596">that could benefit from refactoring.</st>
    <st c="13633">Just like a cluttered room can be stressful and unproductive, smelly
    code can make it difficult to maintain, understand, and extend your application.</st>
    <st c="13783">This section delves into</st> <st c="13807">the world of code smells
    in Angular applications.</st> <st c="13858">We’ll explore what they are, why they
    matter, and how to identify them proactively.</st> <st c="13942">By understanding
    these code smells, you’ll be equipped to prioritize refactoring efforts using
    TDD, ultimately leading to a cleaner, more maintainable, and robust</st> <st c="14105">code
    base.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14115">What are code smells?</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="14137">Imagine</st> <st c="14146">walking into a kitchen where dirty
    dishes are piled up high in the sink, spices are scattered across the counter,
    and expired food lingers in the fridge.</st> <st c="14300">This unpleasant scene
    might not prevent you from cooking a basic meal, but it certainly wouldn’t be
    an enjoyable or efficient experience.</st> <st c="14438">Code smells are analogous
    to this messy kitchen in the software</st> <st c="14502">development world.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="14520">Coined by Martin Fowler in his book,</st> *<st c="14558">Refactoring:
    Improving the Design of Existing Code</st>*<st c="14608">, code smells are indicators
    of potential problems within your code base.</st> <st c="14682">They don’t necessarily
    represent functional bugs that cause the application to crash.</st> <st c="14768">Instead,
    they signify</st> <st c="14790">areas that could be improved for better readability,
    maintainability, and long-term health of</st> <st c="14884">your code.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14894">Code smells are not bugs, but they can attract bugs in the future.</st>
    <st c="14962">They act like red flags, warning you of potential trouble spots
    that could become problematic as your</st> <st c="15064">application evolves.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15084">Why should we care about code smells in Angular?</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="15133">Ignoring a messy kitchen might lead to unpleasant odors, fruit
    flies, and frustration when you need to cook a meal.</st> <st c="15250">Similarly,
    neglecting code smells in your Angular application can</st> <st c="15315">have
    several</st> <st c="15329">negative consequences:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="15351">Decreased maintainability</st>**<st c="15377">: Smelly code
    becomes difficult to understand and modify over time.</st> <st c="15446">As your
    application grows and features are added, the complexity of tangled code can make
    changes cumbersome and</st> <st c="15559">error prone.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="15571">Increased debugging time</st>**<st c="15596">: When bugs arise
    in smelly code, it can be challenging to pinpoint the root cause.</st> <st c="15681">The
    lack of clear structure and organization makes it like searching for a needle
    in a haystack, wasting valuable</st> <st c="15795">developer time.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="15810">Reduced team productivity</st>**<st c="15836">: Working with
    smelly code can be frustrating and demotivating for developers.</st> <st c="15916">The
    cognitive overhead of deciphering tangled logic slows down development and</st>
    <st c="15995">hinders collaboration.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="16017">Technical debt</st>**<st c="16032">: Unattended code smells
    accumulate over time, creating a technical debt that needs to be addressed eventually.</st>
    <st c="16145">This debt can become a significant burden, requiring dedicated resources
    and potentially delaying new</st> <st c="16247">feature development.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="16267">By proactively</st> <st c="16283">identifying and refactoring
    code smells, you can do</st> <st c="16335">the following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="16349">Improve code readability</st>**<st c="16374">: Clean and well-structured
    code is easier to understand for both you and other developers working on the
    project.</st> <st c="16490">This reduces onboarding time for new team members
    and fosters</st> <st c="16552">better collaboration.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="16573">Enhance maintainability</st>**<st c="16597">: Refactored code
    is easier to modify and adapt as your</st> <st c="16654">application’s requirements
    evolve.</st> <st c="16689">This allows you to introduce new features and bug fixes</st>
    <st c="16745">more efficiently.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="16762">Reduce debugging time</st>**<st c="16784">: Cleaner code with
    a clear separation of concerns makes it easier to isolate and fix problems when</st>
    <st c="16885">bugs arise.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="16896">Boost team productivity</st>**<st c="16920">: Working with
    well-structured code improves developer experience and satisfaction.</st> <st
    c="17005">This leads to higher productivity and a more positive</st> <st c="17059">development
    environment.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="17083">Minimize technical debt</st>**<st c="17107">: By addressing
    code smells early on, you prevent them from accumulating and becoming a significant
    burden in</st> <st c="17218">the future.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="17229">In essence, prioritizing code smell refactoring is an investment
    in the long-term health and maintainability of your</st> <st c="17347">Angular
    application.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17367">Identifying the most common code smells in Angular applications</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="17431">Now that we</st> <st c="17443">understand the importance</st>
    <st c="17470">of identifyi</st><st c="17482">ng code smells, let’s take a look
    at some of the most common offenses you might encounter in your</st> <st c="17581">Angular
    application:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="17601">The long and winding method</st>**<st c="17629">: Imagine a
    method in your service that stretches across dozens of lines, handling various
    tasks.</st> <st c="17728">This is a prime example of a long method, a code smell
    suggesting a lack of modularity.</st> <st c="17816">These methods can be difficult
    to understand, test, and modify.</st> <st c="17880">Refactoring involves breaking
    down such behemoths into smaller, well-defined functions, each focusing on a specific
    task.</st> <st c="18002">This enhances code readability</st> <st c="18033">and
    maintainability.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="18053">The god component</st>**<st c="18071">: Have you encountered
    a component overloaded with responsibilities?</st> <st c="18141">This is a “god
    component,” handling everything from data fetching to complex UI logic.</st> <st
    c="18228">Such components become maintenance nightmares as changes in one area
    can ripple through the entire component, causing</st> <st c="18346">unintended
    consequences.</st> <st c="18371">Refactoring can involve</st> <st c="18395">the
    following:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="18409">Creating dedicated services</st>**<st c="18437">: Extract functionalities
    related to data access, business logic, or calculations into separate services.</st>
    <st c="18544">These services can be reused</st> <st c="18572">by multiple components,
    promoting</st> <st c="18607">better organization.</st>'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="18627">Splitting the component</st>**<st c="18651">: Break down the
    god component into smaller, more focused components, each handling a specific
    aspect of the UI</st> <st c="18764">or functionality.</st>'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="19648">10</st>` <st c="19650">used for pagination but its purpose is
    unclear.</st> <st c="19699">Refactoring involves replacing these magic numbers
    with named variables or constants.</st> <st c="19785">For example, use</st> `<st
    c="19802">ITEMS_PER_PAGE</st>` <st c="19816">instead of</st> `<st c="19828">10</st>`<st
    c="19830">, making the code more self-documenting and easier</st> <st c="19881">to
    understand.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="19895">The spaghetti code maze</st>**<st c="19919">: Imagine code
    that winds and twists, lacking clear structure and organization.</st> <st c="20000">This
    is spaghetti code, making it a challenge to navigate, understand, and modify.</st>
    <st c="20083">TDD can be a powerful tool to combat spaghetti code.</st> <st c="20136">By</st>
    <st c="20138">writing tests first and then refactoring the code to meet those
    tests, you can introduce structure and improve the overall organization of your</st>
    <st c="20283">code base.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '<st c="20293">In the next section, we</st> <st c="20318">will learn about iterative
    improvement: the red-green-refactor cycle for continuous</st> <st c="20402">code
    enhancement.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20419">Iterative improvement – red-green-refactor cycle for continuous
    code enhancement</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="20500">Refactoring</st> <st c="20513">existing code in Angular applications
    can be a daunting task.</st> <st c="20575">You want to improve the code’s structure
    and organization, but the fear of introducing regressions (bugs) often looms large.</st>
    <st c="20700">This is where TDD steps in, offering a structured and iterative
    approach to</st> <st c="20775">navigate refactoring with confidence.</st> <st
    c="20814">At the heart of TDD lies the “red-green-refactor” cycle, a</st> <st
    c="20873">powerful technique for making incremental improvements to your code
    base while ensuring its functionality</st> <st c="20979">remains intact.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20994">Imagine you’re a sculptor working on a large block of marble.</st>
    <st c="21057">The red-green-refactor cycle is like your roadmap to transforming
    that raw material into a masterpiece.</st> <st c="21161">Here’s a breakdown of
    each stage and its significance in the context of refactoring</st> <st c="21245">Angular
    code:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21258">Red – setting the stage with failing tests</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="21301">The cycle begins</st> <st c="21319">with red, signifying a failing
    test.</st> <st c="21356">This might seem counterintuitive – why write a</st> <st
    c="21403">test that’s destined to fail?</st> <st c="21433">The purpose of this
    initial red test is to define the desired behavior of the code you intend to refactor.</st>
    <st c="21540">Think of it as a blueprint outlining the functionality you want
    to achieve.</st> <st c="21616">He</st><st c="21618">re’s what creating a red</st>
    <st c="21644">test entails:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="21657">Identify the refactoring target</st>**<st c="21689">: Start
    by pinpointing a specific area of your Angular application that exhibits code
    smells or requires improvement.</st> <st c="21808">This could be a long method
    in service, a god component handling numerous tasks, or duplicated</st> <st c="21903">code
    snippets.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="21917">Define the expected outcome</st>**<st c="21945">: Clearly outline
    what the refactored code should do.</st> <st c="22000">What data should it process?</st>
    <st c="22029">How should it interact with the UI?</st> <st c="22065">Write a test
    that reflects this expected behavior.</st> <st c="22116">Remember, this test will
    initially fail, as the desired functio</st><st c="22179">nality isn</st><st c="22190">’t</st>
    <st c="22194">implemented yet.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="22210">A failing red test</st> <st c="22229">serves a critical purpose.</st>
    <st c="22257">It establishes a baseline – a clear understanding of the functionality
    that’s currently missing.</st> <st c="22354">This provides a safety net during
    the refactoring process.</st> <st c="22413">As you make code changes, the failing
    test ensures you’re on the right track and haven’t accidentally broken</st> <st
    c="22522">existing functionalities.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22547">Green – making the test pass with minimal code</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="22594">Once you</st> <st c="22604">have your red test in place, it’s
    time to move to the green stage.</st> <st c="22671">Here, the objective is to
    write just enough code to make the failing test pass.</st> <st c="22751">Don’t
    get caught up in writing perfectly optimized or elegant code at this point.</st>
    <st c="22833">Focus on the core functionality defined by the test.</st> <st c="22886">Here
    are some key considerations for the</st> <st c="22927">green stage:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="22939">Simple implementations</st>**<st c="22962">: The initial code
    you write to make the test pass might be basic.</st> <st c="23030">It doesn’t
    have to be the most efficient or well-structured solution yet.</st> <st c="23104">The
    priority is to get the test passing and establish a baseline</st> <st c="23169">for
    refactoring.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="23185">Focus on functionality</st>**<st c="23208">: Ensure the code
    you write fulfills the specific behavior outlined in the test.</st> <st c="23290">Don’t
    introduce unnecessary f</st><st c="23319">eatures or</st> <st c="23330">logic
    at</st> <st c="23340">this stage.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="23351">A passing green test signifies a crucial milestone.</st> <st c="23404">It
    verifies that the core functionality you’re refactoring is now implemented, albeit
    potentially in a basic form.</st> <st c="23519">This green test acts as a safety
    net throughout the refactoring process.</st> <st c="23592">As you make further
    code changes, you can rely on the test to ensure you haven’t strayed from the</st>
    <st c="23690">desired outcome.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23706">Refactor – transforming the code with confidence</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="23755">With a</st> <st c="23763">passing green test as your safety net,
    you’ve reached the heart of the cycle – the refactor stage.</st> <st c="23862">Here’s
    where you can unleash your refactoring skills to improve the code’s readability,
    maintainability, and efficiency.</st> <st c="23983">Here are some potential areas
    you might want to focus on</st> <st c="24040">during refactoring:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="24059">Modularize long methods</st>**<st c="24083">: Break down those
    long, monolithic methods into smaller, well-defined functions.</st> <st c="24166">This
    enhances code readability and makes it easier to understand the</st> <st c="24235">logic
    flow.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="24246">Extract reusable components and services</st>**<st c="24287">:
    If your component has become a god component handling numerous tasks, consider
    extracting functionalities into dedicated services or reusable components.</st>
    <st c="24444">This promotes better organization and separation</st> <st c="24493">of
    concerns.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="24505">Eliminate duplication</st>**<st c="24527">: Identify and refactor
    repetitive code snippets into reusable components, services, or utility functions.</st>
    <st c="24635">This reduces code redundancy and</st> <st c="24668">simplifies maintenance.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="24691">Apply design patterns</st>**<st c="24713">: Consider incorporating
    design patterns that promote better code structure and organization.</st> <st
    c="24808">This can make your code more maintainable and easier to understand for</st>
    <st c="24879">other developers.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="24896">Simplify logic</st>**<st c="24911">: Look for opportunities
    to streamline complex logic and enhance code clarity.</st> <st c="24991">This
    can involve using more descriptive variable names, breaking down complex conditional
    statements, or utilizing</st> <st c="25106">helper functions.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="25123">Throughout the refactoring process, keep the green test in mind.</st>
    <st c="25189">Repeat this cycle iteratively, tackling one aspect of the code at
    a time.</st> <st c="25263">Each completed cycle leaves you with cleaner, more
    maintainable code, with robust tests guaranteeing its continued functionality.</st>
    <st c="25393">The emphasis on small, incremental changes promotes a more controlled,
    less error-prone</st> <st c="25481">refactoring process.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25501">Summary</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="25509">In conclusion, refactoring and improving Angular code through
    TDD is a powerful approach to enhancing the quality, maintainability, and efficiency
    of your Angular applications.</st> <st c="25687">By following the TDD methodology,
    developers can ensure that their code is robust, well structured, and easy to
    understand.</st> <st c="25811">This approach not only helps in identifying and
    addressing code smells but also in developing a solid foundation for future enhancements
    and modifications.</st> <st c="25967">TDD encourages developers to write tests
    before writing the actual code, ensuring that the code meets the defined requirements
    and behaves as expected.</st> <st c="26119">This iterative process of writing
    tests, making them pass, and then refactoring the code for improvement is at the
    heart of TDD.</st> <st c="26248">It fosters a culture of continuous improvement,
    where code is always in a state that is ready for</st> <st c="26346">further development.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26366">Moreover, TDD facilitates the development of isolated, testable
    units of code, making it easier to identify and fix issues early in the development
    process.</st> <st c="26524">This is particularly beneficial in Angular applications,
    where components, services, and modules often have complex dependencies and interactions.</st>
    <st c="26671">By testing these units in isolation, developers can ensure that
    each part of the application works correctly before integrating them into the</st>
    <st c="26813">larger system.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26827">Furthermore, TDD promotes the development of high-quality, maintainable
    code by encouraging developers to write clear, concise, and well-documented tests.</st>
    <st c="26983">These tests serve as documentation, making it easier for other developers
    (or even the original developers in the future) to understand the purpose and
    functionality of</st> <st c="27152">the code.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27161">In the context of Angular, TDD can be particularly effective in
    developing services, components, and pipes, as demonstrated in the examples provided.</st>
    <st c="27312">By starting with a clear definition of what the code should do,
    developers can write tests that guide the implementation process, ensuring that
    the code meets the desired specifications.</st> <st c="27499">This approach not
    only leads to better-designed code but also makes the development process more
    efficient</st> <st c="27606">and enjoyable.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27620">In summary, refactoring and improving Angular code through TDD
    is a valuable practice that can significantly enhance the quality of your Angular
    applications.</st> <st c="27780">By adopting TDD, developers can ensure that their
    code is robust, maintainable, and ready for future enhancements.</st> <st c="27895">This
    approach not only benefits the current development cycle but also sets a solid
    foundation for future development efforts, making it a worthwhile investment for
    any</st> <st c="28064">Angular developer.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="28082">This is the end of the book.</st> <st c="28112">This book serves
    as a comprehensive guide for developers looking to adopt or improve their TDD
    practices in Angular projects.</st> <st c="28238">By following the principles
    and techniques described in this book, developers can significantly improve the
    reliability, performance, and maintainability of their Angular applications.</st>
    <st c="28423">The book emphasizes the value of a thorough testing strategy, the
    importance of using the right tools and practices, and the benefits of adopting
    a test-first approach to development.</st> <st c="28607">Whether you’re new to
    Angular or an experienced developer looking to hone your skills, this book offers
    valuable insights and practical advice for mastering TDD</st> <st c="28768">in
    Angular.</st>
  prefs: []
  type: TYPE_NORMAL
