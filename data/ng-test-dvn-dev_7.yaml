- en: Chapter 7. Flip Flop
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。翻转
- en: At this point, we should be confident about performing the initial implementation
    of an Angular application using TDD. Also, we should be familiar with using the test-first
    approach. The test-first approach is very good for the learning stage, but sometimes
    it's a time suck when we get a lot of errors. For simple and known behavior, it
    may not be good to go for the test-first approach.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们应该对使用TDD进行Angular应用程序的初始实现感到自信。此外，我们应该熟悉使用先测试的方法。先测试的方法在学习阶段非常好，但有时当我们遇到很多错误时会耗费时间。对于简单和已知的行为，可能不适合采用先测试的方法。
- en: We have already seen how the test-first approach works, so we can skip those
    steps by checking any feature without creating those components. Besides that,
    we can go one step further to make us more confident in writing our components
    faster. We can have our components ready and then write end-to-end test specs
    to test the expected behavior. If the e2e test fails, we can trigger an error
    in the Protractor debugger.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了先测试的方法是如何工作的，所以我们可以通过检查任何功能来跳过这些步骤，而不创建这些组件。除此之外，我们可以更进一步，让我们更有信心更快地编写我们的组件。我们可以准备好我们的组件，然后编写端到端的测试规范来测试预期的行为。如果端到端测试失败，我们可以在Protractor调试器中触发错误。
- en: 'In this chapter, we will continue to expand our knowledge of applying TDD (but
    not the test-first approach) with Angular. We will not discuss the details of
    the basic Angular component ecosystem here; rather, we will go a step ahead and include more
    Angular features. We will take our knowledge further by looking at the following
    topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续扩展我们对Angular应用TDD（但不是先测试的方法）的知识。我们不会在这里讨论基本的Angular组件生态系统的细节；相反，我们将更进一步，包括更多的Angular特性。我们将通过以下主题进一步扩展我们的知识：
- en: Angular routes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular路由
- en: Navigating to routes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航到路由
- en: Communicating with route parameter data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与路由参数数据通信
- en: "Protractor location references with CSS and \LHTML elements"
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CSS和HTML元素的Protractor定位器的位置引用
- en: Fundamentals of TDD
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TDD的基础知识
- en: 'In this chapter, we will walk-through applying TDD to routes and navigation
    for a search application. Before getting into the walk-through, we need to be
    aware of some of the techniques, configurations, and functions that will be used
    throughout this chapter, which include the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将演示如何将TDD应用于搜索应用程序的路由和导航。在进行实例演练之前，我们需要了解本章中将使用的一些技术、配置和函数，包括以下内容：
- en: Protractor locators
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Protractor定位器
- en: Headless browser testing
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无头浏览器测试
- en: After reviewing these concepts, we can move on to the walk-through.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在回顾了这些概念之后，我们可以继续进行实例演练。
- en: Protractor locators
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Protractor定位器
- en: Protractor locators are key components where everybody should spend some time
    to learn. In the previous Protractor chapters, we understood some commonly used
    locators with working examples. We will provide some examples of the Protractor
    `Locator` here.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Protractor定位器是每个人都应该花一些时间学习的关键组件。在之前的Protractor章节中，我们了解了一些常用的定位器，并提供了工作示例。我们将在这里提供一些Protractor
    `Locator`的示例。
- en: 'Protractor locators allow us to find elements within an HTML page. In this
    chapter, we will see the CSS, HTML, and Angular-specific locators in action. Locators
    are passed to the `element` function. The `element` function will find and return
    the elements on a page. The generic locator syntax is as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Protractor定位器允许我们在HTML页面中查找元素。在本章中，我们将看到CSS、HTML和Angular特定的定位器的实际应用。定位器被传递给`element`函数。`element`函数将在页面上查找并返回元素。通用的定位器语法如下：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, `<LOCATOR>` is a placeholder. The following sections
    describe a couple of these locators.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，`<LOCATOR>`是一个占位符。以下部分描述了其中的一些定位器。
- en: CSS locators
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CSS定位器
- en: 'CSS is used to add layout, color, formatting, and style to an HTML page. From
    an end-to-end testing perspective, the look and style of an element may be part
    of a specification. As an example, consider the following HTML snippet:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 用于向 HTML 页面添加布局、颜色、格式和样式。从端到端测试的角度来看，元素的外观和样式可能是规范的一部分。例如，考虑以下 HTML 片段：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: All these four selections will select the `div` element.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这四个选择都将选择 `div` 元素。
- en: Button and link locators
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按钮和链接定位器
- en: 'Besides being able to select and interpret the way something looks, it is also
    important to be able to find buttons and links within a page. This will allow
    a test to interact with the site easily. Here are a couple of examples:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 除了能够选择和解释某物的外观方式之外，能够在页面内找到按钮和链接也很重要。这将使测试能够轻松地与网站进行交互。以下是一些示例：
- en: '`buttonText` locator:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buttonText` 定位器：'
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`linkText` locator:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`linkText` 定位器：'
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: URL location references
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: URL 位置引用
- en: 'When testing Angular routes, we need to be able to test the URL of our test.
    By adding tests around the URL and location, we have to ensure that the application
    works with specific routes. This is important because routes provide an interface
    to our application. Here is how to get the URL reference in a Protractor test:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试 Angular 路由时，我们需要能够测试我们测试的 URL。通过在 URL 和位置周围添加测试，我们必须确保应用程序能够使用特定路由。这很重要，因为路由为我们的应用程序提供了一个接口。以下是如何在
    Protractor 测试中获取 URL 引用的方法：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that we have seen how to use the different locators, it is time to put the
    knowledge to use.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何使用不同的定位器，是时候将知识付诸实践了。
- en: Preparing an Angular project
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备一个 Angular 项目
- en: It is important to get a process and method to set up your projects quickly.
    The less time you spend on thinking about the structure of the directory and the
    required tools, the more time you can spend developing!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要有一个快速设置项目的过程和方法。您花在思考目录结构和所需工具的时间越少，您就可以花更多时间开发！
- en: For this reason, in the previous chapters, we looked at how to get simple existing
    projects for Angular developed as `quickstart` projects ([https://github.com/angular/quickstart](https://github.com/angular/quickstart)).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在之前的章节中，我们看了如何获取 Angular 的简单现有项目，开发为 `quickstart` 项目 ([https://github.com/angular/quickstart](https://github.com/angular/quickstart))。
- en: However, some people use the `angular2-seed` ([https://github.com/mgechev/angular2-seed](https://github.com/angular/angular-seed))
    project, Yeoman, or create a custom template. Although these techniques are useful
    and have their merits, when starting out in Angular, it is essential to understand
    what it takes to build an application from the ground up. By building the directory
    structure and installing tools by ourselves, we will understand Angular better.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有些人使用 `angular2-seed` ([https://github.com/mgechev/angular2-seed](https://github.com/angular/angular-seed))
    项目，Yeoman，或者创建一个自定义模板。虽然这些技术很有用并且有其优点，但在开始学习 Angular 时，了解如何从零开始构建应用是至关重要的。通过自己构建目录结构和安装工具，我们将更好地理解
    Angular。
- en: You will be able to make layout decisions based on your specific application
    and needs, as opposed to fitting them into some other module. As you grow and
    become a better Angular developer, this step may not be needed and will become
    second nature to you.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您将能够根据您特定的应用程序和需求做出布局决策，而不是将它们适应其他模块。随着您的成长和成为更好的 Angular 开发人员，这一步可能不再需要，并且会成为您的第二天性。
- en: Loading the existing project
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载现有项目
- en: 'To start off, we will clone the project from the Angular `quickstart` project
    at [https://github.com/angular/quickstart](https://github.com/angular/quickstart),
    rename it as `angular-flip-flop`, and our project folder structure will look as
    follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从 Angular 的 `quickstart` 项目 [https://github.com/angular/quickstart](https://github.com/angular/quickstart)
    克隆项目，将其重命名为 `angular-flip-flop`，我们的项目文件夹结构如下：
- en: '![Loading the existing project](graphics/image_07_001.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![加载现有项目](graphics/image_07_001.jpg)'
- en: In the previous chapters, we discussed how to set up the project, understood the
    different components involved, and walked through the entire process. We will
    skip these details and assume that you can recall how to perform the necessary
    installation.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们讨论了如何设置项目，理解了涉及的不同组件，并走过了整个过程。我们将跳过这些细节，并假设您可以回忆起如何执行必要的安装。
- en: Preparing the project
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备项目
- en: 'This `quickstart` project doesn''t included the base `href` in the project''s
    landing page (`index.html`). We will need that to proceed perfectly with routing,
    so let''s add a single line (`base href`) to the `<head>` section of `index.html`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`quickstart`项目在项目的首页（`index.html`）中没有包含基本的`href`。我们需要这样做才能完美地进行路由，因此让我们在`index.html`的`<head>`部分添加一行（`base
    href`）：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, our bootstrapping component is in the application component and the HTML
    template is in the component itself. We should separate the template to a new
    file before proceeding.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们的引导组件在应用程序组件中，HTML模板在组件本身中。在继续之前，我们应该将模板分离到一个新文件中。
- en: 'For that, we will update our application component (`app/app.component.ts`),
    as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将更新我们的应用程序组件（`app/app.component.ts`），如下所示：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s create our separate template file at `app/app.component.html`. And the
    code will look like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`app/app.component.html`中创建我们单独的模板文件。代码将如下所示：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Running the project
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行项目
- en: 'Let''s proceed with it and get ready to run using the following commands:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续进行，并准备使用以下命令运行：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To confirm the installation and run the project, the application will automatically
    run in the web browser.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要确认安装并运行项目，应用程序将自动在Web浏览器中运行。
- en: 'Here is the expected output after running the project:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行项目后，预期的输出如下：
- en: '![Running the project](graphics/image_07_002.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![运行项目](graphics/image_07_002.jpg)'
- en: Restructuring the project
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构项目
- en: Let's change the project structure a bit, not much though. By default, it has
    included unit testing in the same location as the components file and separated
    the e2e testing file outside the `app/` folder in the `e2e/` folder.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微改变项目结构，不过不多。默认情况下，它在相同位置包括了单元测试和组件文件，并将e2e测试文件分离到`app/`文件夹之外的`e2e/`文件夹中。
- en: However, we will keep all the tests in the same location, that is, outside of
    `app`; we will keep all the tests as `spec/e2e` and `spec/unit`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们将保持所有测试在相同的位置，也就是在`app`之外；我们将把所有测试保存在`spec/e2e`和`spec/unit`中。
- en: The goal is to separate the test specs from the component. This way, we can
    keep our unit tests file outside in the `spec/unit` folder.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是将测试规范与组件分开。这样，我们可以将我们的单元测试文件保存在`spec/unit`文件夹之外。
- en: 'So, our current folder structure will look like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们当前的文件夹结构将如下所示：
- en: '![Restructuring the project](graphics/image_07_003.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![重构项目](graphics/image_07_003.jpg)'
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As long as we have changed the path for both unit and e2e tests, we should have
    to change the path in the Karma configuration and Protractor configuration files.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们已经改变了单元测试和e2e测试的路径，我们就必须在Karma配置和Protractor配置文件中更改路径。
- en: Setting up headless browser testing for Karma
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Karma设置无头浏览器测试
- en: In the previous chapters, we were running Karma using the default configuration.
    The default Chrome configuration launches Chrome on every test. Testing against
    the actual code and browser that the application will run in is a powerful tool.
    However, when launching, a browser may not always know how you want it to behave.
    From a unit test perspective, you may not want the browser to be launched in a
    window. The reason could be that tests may take a long time to run or you may
    not always have a browser installed.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们使用默认配置运行Karma。默认的Chrome配置在每次测试时都会启动Chrome。针对应用程序将在其中运行的实际代码和浏览器进行测试是一个强大的工具。然而，在启动时，浏览器可能并不总是知道你希望它如何行为。从单元测试的角度来看，你可能不希望浏览器在窗口中启动。原因可能是测试可能需要很长时间运行，或者你并不总是安装了浏览器。
- en: Luckily, Karma comes equipped with the ability to easily configure PhantomJS,
    a headless browser. A headless browser runs in the background and will not display
    web pages in a UI. The PhantomJS headless browser is a really great tool to use
    for testing. It can even be set up to take screenshots of your tests! Read more
    about how this is done and about the WebKit used on the PhantomJS site at [http://phantomjs.org/](http://phantomjs.org/).
    The following setup configuration will show us how to set up PhantomJS with Karma
    for headless browser testing.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Karma配备了轻松配置PhantomJS的能力，一个无界面浏览器。无界面浏览器在后台运行，不会在UI中显示网页。PhantomJS无界面浏览器是一个非常好用的测试工具。它甚至可以设置为对你的测试进行截图！在PhantomJS网站上阅读更多关于如何做到这一点以及使用的WebKit的信息，网址是[http://phantomjs.org/](http://phantomjs.org/)。以下设置配置将展示如何在Karma中设置PhantomJS进行无界面浏览器测试。
- en: Preconfiguration
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预配置
- en: When Karma is installed, it automatically includes the PhantomJS browser plugin.
    For further reference, the plugin is located at [https://github.com/karma-runner/karma-phantomjs-launcher](https://github.com/karma-runner/karma-phantomjs-launcher).
    There shouldn't be any more installation or configuration required.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当Karma被安装时，它会自动包含PhantomJS浏览器插件。有关更多信息，请参考插件位于[https://github.com/karma-runner/karma-phantomjs-launcher](https://github.com/karma-runner/karma-phantomjs-launcher)。不应该需要任何更多的安装或配置。
- en: 'However, if your setup states that it is missing `karma-phantomjs-launcher`,
    you can easily install it using `npm`, like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你的设置显示缺少`karma-phantomjs-launcher`，你可以很容易地使用`npm`进行安装，就像这样：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Configuration
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置
- en: 'PhantomJS is configured in the `browsers` section of the Karma configuration.
    Open the `karma.conf.js` file and update it with the following details:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: PhantomJS被配置在Karma配置的`browsers`部分。打开`karma.conf.js`文件，并使用以下细节进行更新：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Do that in the `plugins` option as well:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 同样在`plugins`选项中进行：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now that the project has been initialized and configured with headless browser
    testing, you can see it in action through the following walk-throughs.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在项目已经初始化并配置了无界面浏览器测试，你可以通过以下教程看到它的运行情况。
- en: Walk-through of Angular routes and navigation
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular路由和导航的教程
- en: This walk-through will leverage Angular routes. Routes are an extremely useful
    feature of Angular, as they were in Angular 1.x before it, but more powerful.
    They allow us to control certain aspects of the application using different components.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程将利用Angular路由。路由是Angular的一个非常有用的特性，在Angular 1.x之前也是如此，但更加强大。它们允许我们使用不同的组件来控制应用程序的某些方面。
- en: 'This walk-through will flip between components to show us how to use TDD to
    build routes. The following are the specifications. There will be a navigation
    menu, which has two menu items, **View1** and **View2**:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程将在不同的组件之间切换，以展示如何使用TDD来构建路由。以下是规格说明。将有一个导航菜单，其中有两个菜单项，**View1**和**View2**：
- en: In the navigation menu, click on label **View1**
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在导航菜单中，点击标签**View1**
- en: The content area (router outlet) will load/flip **View1** content
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容区域（路由器出口）将加载/翻转**View1**内容
- en: 'And here''s the second part:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是第二部分：
- en: In the navigation menu, click on label **View2**
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在导航菜单中，单击标签**View2**
- en: The content area (router outlet) will load/flip **View2** content
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容区域（路由器出口）将加载/翻转**View2**内容
- en: Essentially, this will be an application that does a flip/flop between two views.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这将是一个在两个视图之间进行翻转的应用程序。
- en: Setting up Angular routes
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Angular路由
- en: The router is an optional service in Angular, so it's not included in the Angular
    core. If we need to use the router, we will have to install the Angular `router`
    service in our application.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器是Angular中的可选服务，因此它不包含在Angular核心中。如果我们需要使用路由器，我们将需要在应用程序中安装Angular `router`服务。
- en: 'As long as we have cloned our project from `quickstart`, we should be okay
    because it has recently added the Angular router to its dependencies, but we should check
    and confirm. If it doesn''t have `@angular/router` in its dependencies in `package.json`,
    we can install the Angular router using `npm`, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们从`quickstart`克隆了我们的项目，我们应该没问题，因为它最近已将Angular路由器添加到其依赖项中，但我们应该检查并确认。如果在`package.json`中的依赖项中没有`@angular/router`，我们可以使用`npm`安装Angular路由器，如下所示：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Defining directions
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义方向
- en: A route specifies a location and expects a result. From an Angular perspective,
    the routes must first be specified and then associated with certain components.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 路由指定了位置并期望结果。从Angular的角度来看，路由必须首先指定，然后与某些组件关联。
- en: To implement a router in our application, we will need to import the router
    module in the application module, where it will register the router in the application.
    After that, we will need to configure all the routes and pass that configuration
    to the application module.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的应用程序中实现路由器，我们需要在应用程序模块中导入路由器模块，其中它将在应用程序中注册路由器。之后，我们将需要配置所有路由并将该配置传递给应用程序模块。
- en: The router module
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路由器模块
- en: 'To implement a router in the application, we will need to import the `RouterModule`
    in our application module, located at `app/app.module.ts`, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要在应用程序中实现路由器，我们需要在应用程序模块中导入`RouterModule`，位于`app/app.module.ts`，如下所示：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This will just make the `router` module available in the application system,
    but we will have to have a router configuration to define all the possible routers
    in the entire application and then import that configuration to the application
    ecosystem via the application module.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这将只是在应用程序系统中使`router`模块可用，但我们必须有一个路由器配置来定义整个应用程序中所有可能的路由器，然后通过应用程序模块将该配置导入应用程序生态系统。
- en: Configuring routes
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置路由
- en: A router is useless until we configure it, and to do so, we first need to import
    the `router` component. Configuration will mainly contain a list of arrays, where
    route paths and related components live as key-value pairs. We can add the configuration
    array to the application module, or we can create a separate configuration file
    and include the app module in it. We will go for the second option so that route
    configuration will be separated from the app module.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器在配置之前是无用的，为了配置它，我们首先需要导入`router`组件。配置主要包含一个数组列表，其中路由路径和相关组件作为键值对存在。我们可以将配置数组添加到应用程序模块中，或者我们可以创建一个单独的配置文件并将应用模块包含在其中。我们将选择第二个选项，以便路由配置与应用模块分离。
- en: 'Let''s create the router configuration file in the application root as `app/app.routes.ts`.
    There, at first, we will need to import the Angular `Routes` from the Angular
    service, as shown here:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在应用程序根目录中创建路由器配置文件`app/app.routes.ts`。在那里，首先，我们需要从Angular服务中导入Angular `Routes`，如下所示：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'From the router config file, we will need to export the configuration array,
    as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 从路由器配置文件中，我们需要导出配置数组，如下所示：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Routers in the application
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用程序中的路由
- en: We've already imported the `router` module to our application module, located
    at `app/app.module.ts`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将`router`模块导入到了位于`app/app.module.ts`的应用程序模块中。
- en: 'Then, we will need to import the router configuration file (`rootRouterConfig`)
    to this application module file, as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要将路由配置文件（`rootRouterConfig`）导入到这个应用程序模块文件中，如下所示：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the application module, we know `NgModule` imports the optional modules to
    the application ecosystem, and similarly, to include the router in the application,
    `RouterModule` has a function known as `RouterModule.forRoot(RouterConfig)`, which
    accepts the `routerConfiguration` to implement a router in the entire application.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序模块中，我们知道`NgModule`导入了可选模块到应用程序生态系统中，类似地，为了在应用程序中包含路由，`RouterModule`有一个名为`RouterModule.forRoot(RouterConfig)`的函数，接受`routerConfiguration`来实现整个应用程序中的路由。
- en: 'The application module (`app/app.module.ts`) will import that `RouterModule`
    as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序模块（`app/app.module.ts`）将导入`RouterModule`如下：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Routes in the config
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置中的路由
- en: Now, let's add some routes to our `Routes` configuration array, which is located
    at `app/app.routes.ts`. The route configuration array contains some objects as
    key-value pairs, with mostly two to three elements in every object.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们向位于`app/app.routes.ts`的`Routes`配置数组中添加一些路由。路由配置数组包含一些对象作为键值对，每个对象中大多有两到三个元素。
- en: The first element in the array object contains the `path`, and the second one
    contains the relevant `component` to load for that `path`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 数组对象中的第一个元素包含“路径”，第二个元素包含与该“路径”对应的要加载的“组件”。
- en: 'Let''s add two routes to our configuration array, as shown here:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向配置数组中添加两个路由，如下所示：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, two routes, `view1` and `view2`, are defined, and two components have
    been assigned to load for that route.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，定义了两个路由，`view1`和`view2`，并分配了两个组件以加载该路由。
- en: In some cases, we may need to redirect from one route to another. For example,
    for the root path of the application (`''`), we may plan to redirect to the `view1`
    route. For that, we have to set the `redirectTo` element in the object and assign
    some route name as its value. We will also need to add one extra element as `pathMatch`
    and set its value to `full` so it will match the full path before redirecting
    to some other route.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能需要从一个路由重定向到另一个路由。例如，对于应用程序的根路径（''），我们可能计划重定向到`view1`路由。为此，我们必须在对象中设置`redirectTo`元素，并将一些路由名称分配为其值。我们还需要添加一个额外的元素作为`pathMatch`，并将其值设置为`full`，以便在重定向到其他路由之前匹配完整路径。
- en: 'The code will look as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下所示：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'So, yes, our initial route configuration is ready to go. Now, the full configuration
    will look like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，是的，我们的初始路由配置已经准备就绪。现在，完整的配置将如下所示：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: I should mention here that we have to import the `view1` and `view2` components
    as we have used them in the router config.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里应该提到，我们必须导入`view1`和`view2`组件，因为我们在路由配置中使用了它们。
- en: To learn more in detail about Angular routes, refer to [https://angular.io/docs/ts/latest/guide/router.html](https://angular.io/docs/ts/latest/guide/router.html).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要详细了解Angular路由，请参考[https://angular.io/docs/ts/latest/guide/router.html](https://angular.io/docs/ts/latest/guide/router.html)。
- en: Hands-on routes
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实践路由
- en: So far, we have installed and imported a router module, configured routes, and
    included things in the application ecosystem. We still need to do some related
    tasks, such as creating a router outlet, creating navigation, and creating the
    component defined in the route, to have hands-on experience with routes.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经安装和导入了路由模块，配置了路由，并在应用程序生态系统中包含了一些内容。我们仍然需要做一些相关的任务，比如创建路由出口，创建导航，以及创建路由中定义的组件，以便亲身体验路由。
- en: Defining the router outlet
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义路由出口
- en: As long as the route is configured in `appComponent`, we need a placeholder
    to load the route's navigated components, which Angular defines as the route outlet.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 只要路由在`appComponent`中配置，我们就需要一个占位符来加载路由导航的组件，Angular将其定义为路由出口。
- en: A `RouterOutlet` is a placeholder that Angular dynamically fills based on the
    application's route.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`RouterOutlet`是一个占位符，Angular根据应用程序的路由动态填充它。'
- en: 'For our application, we will place the `router-outlet` in the `appComponent`
    template, located at (`/app/app.component.html`), like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序，我们将在`appComponent`模板中放置`router-outlet`，位于(`/app/app.component.html`)，就像这样：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Preparing the navigation
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备导航
- en: In the route configuration, we have set two paths, `/view1` and `/view2`, for
    our application. Now, let's create the navigation menu with two route paths to
    make navigation easy. For that, we can create a separate simple component so that
    navigation can be isolated for the entire application component.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在路由配置中，我们为我们的应用程序设置了两个路径，`/view1`和`/view2`。现在，让我们创建具有两个路由路径的导航菜单，以便进行简单的导航。为此，我们可以创建一个单独的简单组件，以便为整个应用程序组件隔离导航。
- en: 'Create a new component file for the `NavbarComponent` at `/app/nav/navbar.component.ts`,
    as shown here:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在`/app/nav/navbar.component.ts`中为`NavbarComponent`创建一个新的组件文件，如下所示：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Also, create a template for the navigation component at (`/app/nav/navbar.component.html`),
    as shown here:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在`/app/nav/navbar.component.html`中为导航组件创建一个模板，如下所示：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Don't bother about the `members` link in in the navigation for now; I'll tell
    you what it is in a later section.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在不要担心导航中的`members`链接；我会在后面的部分告诉你它是什么。
- en: 'Let''s create the basic CSS style for the navigation component for a better
    look at `/app/nav/navbar.component.css`, as shown here:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为导航组件创建基本的CSS样式，以便更好地查看`/app/nav/navbar.component.css`，如下所示：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We have a navigation component. Now we will have to bind that to our app component,
    which is our application landing page.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个导航组件。现在我们需要将其绑定到我们的应用组件，也就是我们的应用程序登陆页面。
- en: 'To do so, we have to append the following to the `appComponent` template, located
    at `/app/app.component.html`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这样做，我们必须将以下内容附加到位于`/app/app.component.html`的`appComponent`模板中：
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Preparing the components
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备组件
- en: For each defined route, we will need to create an individual component as every
    route will be associated with a component.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个定义的路由，我们需要创建一个单独的组件，因为每个路由都将与一个组件相关联。
- en: Here, we have two defined routes, and we will need to create two individual
    components to work on the routes' navigation. We will create `View1Component`
    and `View2Component` as per our requirement.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有两个定义的路由，我们需要创建两个单独的组件来处理路由导航。根据我们的需求，我们将创建`View1Component`和`View2Component`。
- en: 'Create a new component file for the `View 1` component at `/app/view/view1.component.ts`,
    as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在`/app/view/view1.component.ts`中为`View 1`组件创建一个新的组件文件，如下所示：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create another component file for the `View 2` component (`/app/view/view2.component.ts`):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为`View 2`组件创建另一个组件文件(`/app/view/view2.component.ts`)：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We are ready with our routes and related components (`Navigation`, `View1`,
    and `View2`). Hopefully, everything's working as expected and we can see the application
    output in the browser.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好了我们的路由和相关组件（`导航`，`View1`和`View2`）。希望一切都按预期工作，我们可以在浏览器中看到应用程序的输出。
- en: Wait, before looking at the expected output in the browser, let's test the expected
    result with end-to-end testing. Now we know the expected behavior, and we will
    write out the e2e test specs based on our expectation. Once we're ready with the
    e2e test specs, we will see how it fulfills our expectation.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看浏览器中的预期输出之前，让我们通过端到端测试来测试预期结果。现在我们知道了预期的行为，我们将根据我们的期望编写端到端测试规范。一旦我们准备好了端到端测试规范，我们将看到它如何满足我们的期望。
- en: Assembling the flip/flop test
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组装翻转/翻转测试
- en: 'Following the first of the 3 As, *assemble*, these steps will show us how to
    assemble the test:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在3A中的第一个*A*，*assemble*之后，这些步骤将向我们展示如何组装测试：
- en: 'Start with the Protractor base template, as follows:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Protractor基本模板开始，如下所示：
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Navigate to the root of the application using the following code:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码导航到应用程序的根目录：
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `beforeEach` method needs to confirm that the correct component''s view
    is being displayed. This can be done using a CSS locator to look for the `div`
    tag of `view1`. The expectation will look as follows:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`beforeEach`方法需要确认正确的组件视图正在显示。这可以通过使用CSS定位器来查找`view1`的`div`标签来完成。期望将如下所示：'
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, add an expectation that `view2` is not visible:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加一个期望，即`view2`不可见：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then add further confirmation by getting the entire text of the `view1` component:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后通过获取`view1`组件的整个文本来进一步确认：
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Flipping to the next view
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 翻转到下一个视图
- en: 'The preceding test needs to confirm that when the `view2` link will be clicked
    in the navigation, the `view2` component''s content will load. In order to test
    this, we can use the `by.linkText` locator. Here is what it will look like:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的测试需要确认，当在导航中点击`view2`链接时，`view2`组件的内容将会加载。为了测试这一点，我们可以使用`by.linkText`定位器。它将如下所示：
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `beforeEach` function is now complete and looks like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`beforeEach`函数现在已经完成，看起来像这样：'
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Next, we will add the assertion.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加断言。
- en: Asserting a flip
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 断言翻转
- en: 'The assertion will again use Protractor''s CSS locator, as shown here, to find
    whether `view2` is available:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 断言将再次使用Protractor的CSS定位器，如下所示，来查找`view2`是否可用：
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We also need to confirm that `view1` is no longer available. Add the expectation
    that `view1` should not exist, as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要确认`view1`不再可用。添加`view1`不应存在的期望，如下所示：
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Also, to make sure, we can check whether the `view2` contents have been loaded,
    as shown here:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，为了确保，我们可以检查`view2`的内容是否已加载，如下所示：
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As we have the test about to switch from the `view1` to `view2` component by
    clicking on the `view2` link in the navigation, let''s go back to the `view1`
    component by clicking on the `view1` link in the navigation, hoping things work
    as expected:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们即将进行的测试将从导航中点击`view2`链接切换到`view1`组件，让我们通过点击导航中的`view1`链接返回到`view1`组件，希望事情能如预期般工作：
- en: '[PRE38]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The test has now been assembled.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 测试现在已经组装完成。
- en: Running the flip/flop test
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行翻转/反转测试
- en: Our test spec is ready, and it's time to run it and see the result.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试规范已经准备好，现在是运行测试并查看结果的时候了。
- en: 'First, we will have to keep our project running via the HTTP server, with the
    following command:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将通过以下命令保持项目在HTTP服务器上运行：
- en: '[PRE39]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, we have to run Protractor. Be sure about the port number of the running
    application and Protractor configuration file; just to be sure, update the running
    server port in the configuration. To run Protractor, use the following command:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须运行Protractor。确保运行应用程序和Protractor配置文件的端口号；为了确保，更新配置中运行服务器端口。要运行Protractor，请使用以下命令：
- en: '[PRE40]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The results should be as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该如下所示：
- en: '[PRE41]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The Protractor tests have passed as per our expectations. Now we can have a
    look at the browser to check whether things are working the same way as the e2e
    test results.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的期望，Protractor测试已经通过。现在我们可以查看浏览器，检查事情是否与端到端测试结果一样。
- en: Opening the app in a browser
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在浏览器中打开应用程序
- en: As long as we've run the `npm start` command for e2e testing, our application
    could run on a specific port, `3000`,  on the localhost. By default, it will open
    in the browser.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们已经运行了用于端到端测试的`npm start`命令，我们的应用程序就可以在本地主机的特定端口`3000`上运行。默认情况下，它将在浏览器中打开。
- en: 'The expected output is shown in the following screenshot:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出如下截图所示：
- en: '![Opening the app in a browser](graphics/B05405_07_04-1.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![在浏览器中打开应用程序](graphics/B05405_07_04-1.jpg)'
- en: Searching the TDD way
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以TDD方式进行搜索
- en: 'This walk-through will show us how to build a simple search application. It has
    two components: the first discusses a search query component, and the second uses
    routes to display search result details.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个演练将向我们展示如何构建一个简单的搜索应用程序。它有两个组件：第一个讨论了搜索查询组件，第二个使用路由来显示搜索结果的详细信息。
- en: Walk-through of the search query
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索查询的演练
- en: 'The application being built is a search application. The first step is to set
    up the search area with search results. Imagine that I am performing a search.
    In this case, the following actions will occur:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 正在构建的应用程序是一个搜索应用程序。第一步是设置带有搜索结果的搜索区域。想象一下，我正在进行搜索。在这种情况下，将发生以下操作：
- en: A search query is typed in
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入搜索查询
- en: The results are displayed at the bottom of the search box
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果将显示在搜索框底部
- en: This piece of the application is very similar to the test, layout, and approach
    we have seen in [Chapter 6](ch06.html "Chapter 6. The First Step"), *The* *First
    Step*. The application will need to use an input, respond to a click, and confirm
    the resulting data. Since the tests and code use the same functionality as the
    previous example, it is not worth providing a complete walk-through of the search
    functionality. Instead, the following subsections will show the required code
    with a few explanations.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分应用程序与我们在[第6章](ch06.html "第6章。第一步")中看到的测试、布局和方法非常相似，*第一步*。应用程序将需要使用输入，响应点击，并确认结果数据。由于测试和代码使用与之前示例相同的功能，因此不值得提供完整的搜索功能演练。相反，以下小节将展示所需的代码并附带一些解释。
- en: The search query test
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索查询测试
- en: 'The following code represents the test for the search query functionality:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码代表了搜索查询功能的测试：
- en: '[PRE42]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We should notice a parallel to the previous tests. The functionality is written
    to mirror the behavior of a user typing in the search box. The test finds the
    input field, types a value, and then selects the button that says **Search**.
    The assertion confirms that the result contains a single value.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该注意到与之前的测试有相似之处。功能被编写成模仿用户在搜索框中输入的行为。测试找到输入字段，输入一个值，然后选择写着**搜索**的按钮。断言确认结果包含一个单一值。
- en: The search application
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索应用程序
- en: To perform a search operation, we will need to create a search component that
    will contain an input field to accept the user input (search query) and a button
    to perform user action with a click event. Besides that, it may have a placeholder
    to contain the search result.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行搜索操作，我们需要创建一个搜索组件，其中包含一个输入字段来接受用户输入（搜索查询）和一个按钮来执行用户操作并触发点击事件。此外，它可能有一个占位符来包含搜索结果。
- en: As long as our application already has the router included, we can place the
    search component for a specific route.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们的应用程序已经包含了路由器，我们就可以为特定路由放置搜索组件。
- en: Note that we have called our search component as `MembersComponent`, since we
    worked with some member data in the search component. And routes will be configured
    based on that as well.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将我们的搜索组件称为`MembersComponent`，因为我们在搜索组件中使用了一些成员数据。路由也将根据这个进行配置。
- en: 'So, in our existing `app.routes.ts` file, we will add the following search
    routes:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们现有的`app.routes.ts`文件中，我们将添加以下搜索路由：
- en: '[PRE43]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The search component
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索组件
- en: The search component (`MembersComponent`) will be the main class for the search
    functionality here. It will perform a search and return the search result.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索组件（`MembersComponent`）将是这里搜索功能的主要类。它将执行搜索并返回搜索结果。
- en: During the initial loading of the search component, it will not have any search
    query, so we have set the behavior to return all the data. Then, after the search
    trigger, it will return data based on a search query.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在搜索组件的初始加载期间，它将没有任何搜索查询，因此我们已经设置了行为以返回所有数据。然后，在搜索触发后，它将根据搜索查询返回数据。
- en: 'The search component will be placed in `app/members/members.compoennt.ts`.
    In the code, at first, we will have to import the required Angular services, as
    shown here:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索组件将放置在`app/members/members.compoennt.ts`中。在代码中，首先，我们将不得不导入所需的Angular服务，如下所示：
- en: '[PRE44]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We will use the `Http` service for the AJAX call, and by default, in Angular,
    the `Http` service returns an observable object. However, it''s easier to handle
    a promise than an observable object. So, we will convert this observable object
    to a promise. Angular suggests using the `rxjs` module, which has the `toPromise`
    method, used to convert an observable object to a promise. So, we will import
    the `rxjs` module, as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`Http`服务进行AJAX调用，默认情况下，在Angular中，`Http`服务返回一个可观察对象。但是，处理承诺比处理可观察对象更容易。因此，我们将把这个可观察对象转换为一个承诺。Angular建议使用`rxjs`模块，该模块具有`toPromise`方法，用于将可观察对象转换为承诺。因此，我们将导入`rxjs`模块，如下所示：
- en: '[PRE45]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Angular introduced the `ngOnInit()` method to be executed while initializing
    the component, similar to the contractor method in any class, but it's helpful
    to run the test spec. For that, we have imported the `OnInit` interface from the
    Angular core, and the `Component` class will implement the `OnInit` interface
    to get the `ngOnInit` method.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Angular引入了`ngOnInit()`方法，在初始化组件时执行，类似于任何类中的构造方法，但对于运行测试规范很有帮助。为此，我们从Angular核心中导入了`OnInit`接口，`Component`类将实现`OnInit`接口以获取`ngOnInit`方法。
- en: 'Besides that, the `Component` class should inject the required module, such
    as `Http` and `Router`, as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，`Component`类应注入所需的模块，例如`Http`和`Router`，如下所示：
- en: '[PRE46]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As discussed, we will use the `ngOnInit()` method, and from that, we will initialize
    the searching mechanism, like this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将使用`ngOnInit()`方法，并从中初始化搜索机制，如下所示：
- en: '[PRE47]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Here, we will apply the `search` feature on a member list, and for that, we
    have some dummy data at `app/data/people.json`. We will retrieve the data from
    here and perform a search operation on the data. Let''s see how:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将在成员列表上应用“搜索”功能，为此，我们在`app/data/people.json`中有一些虚拟数据。我们将从这里检索数据并对数据执行搜索操作。让我们看看如何：
- en: The `getData()` method will retrieve the data from the API and will return a
    promise.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getData()`方法将从API检索数据并返回一个承诺。'
- en: '[PRE48]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `searchQuery()` method will resolve the returned promise and will make
    a data array based on the search query. If no search query is provided, it will
    return the complete dataset as an array:'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`searchQuery()`方法将解析返回的承诺，并根据搜索查询创建一个数据数组。如果没有提供搜索查询，它将返回完整的数据集作为数组：'
- en: '[PRE49]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `search()` method will prepare the dataset for the template to bind to
    in the frontend:'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`search()`方法将为模板准备数据集，以便在前端绑定：'
- en: '[PRE50]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We have one more optional method here, which is used to navigate to the member
    details component. We''ve called that the `person` component. Here, the `viewDetails()`
    method will pass the member ID, and the `router.navigate()` method will navigate
    the application to the `person` component with the ID as a parameter, as shown
    here:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个可选的方法，用于导航到成员详细信息组件。我们称之为`person`组件。在这里，`viewDetails()`方法将传递成员ID，`router.navigate()`方法将应用程序导航到带有ID参数的`person`组件，如下所示：
- en: '[PRE51]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The complete code of `MembersComponent` will be as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`MembersComponent`的完整代码如下：'
- en: '[PRE52]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `search` component template contains the search form and the list of search
    results when there are results to show.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`search`组件模板包含搜索表单和搜索结果列表（当有结果要显示时）。'
- en: 'The template looks as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 模板如下所示：
- en: '[PRE53]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The preceding Angular components are similar to what has already been shown
    in the previous chapters.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的Angular组件与前几章中已经展示的内容类似。
- en: We are using a dummy dataset from the `people.json` file, which contains information
    about people with addresses. We want to split the information in two parts, one
    as summary information and the other with address details. As we will work with
    this dataset, it will be easy to make an object model for this dataset.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用`people.json`文件中的虚拟数据集，其中包含有关带地址的人的信息。我们希望将信息分为两部分，一部分是摘要信息，另一部分是地址详细信息。由于我们将使用这个数据集，因此很容易为这个数据集创建一个对象模型。
- en: The summary dataset will be defined as a `Person` object, and address details
    will be defined as `Address`. Let's create a person object at `app/members/person/person.component.ts`
    and place both object models in the same file.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要数据集将被定义为`Person`对象，地址详细信息将被定义为`Address`。让我们在`app/members/person/person.component.ts`中创建一个人员对象，并将两个对象模型放在同一个文件中。
- en: 'The two object model classes for `Person` and `Address` look like this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person`和`Address`两个对象模型类如下：'
- en: '[PRE54]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Show me the search results!
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示搜索结果！
- en: Now that the **Search** button is set with the required features, the result
    should contain the data only based on the search query, instead of everything.
    Let's look at the user specification.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，**搜索**按钮已经设置了所需的功能，结果应该只包含基于搜索查询的数据，而不是所有数据。让我们看一下用户规范。
- en: 'Given a set of search results:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一组搜索结果：
- en: We will have the member list based on the search query
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将根据搜索查询得到成员列表
- en: We will click on any member's name and navigate to the details component for
    details
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将点击任何成员的名字并导航到详细组件以获取详细信息
- en: Following the top-down approach, the first step will be the Protractor test,
    followed by the necessary steps to get the application fully functional.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 按照自上而下的方法，第一步将是Protractor测试，然后是使应用程序完全功能的必要步骤。
- en: Testing the search results
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试搜索结果
- en: 'As the specification states, we will need to leverage the existing search results.
    Instead of creating a test from scratch, we can add to the existing search query
    test. Start with a base test embedded in the search query test, as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 根据规范，我们需要利用现有的搜索结果。我们可以在现有的搜索查询测试中添加内容，而不是从头开始创建一个测试。从搜索查询测试中嵌入一个基本测试，如下所示：
- en: '[PRE55]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The next step is building the test.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是构建测试。
- en: Assembling the search result test
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组装搜索结果测试
- en: In this case, the search results are already available from the search query
    test. We don't have to add any more setup steps for the test.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，搜索结果已经可以从搜索查询测试中获得。我们不必为测试添加任何其他设置步骤。
- en: Selecting a search result
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择搜索结果
- en: 'The object under testing is the result. The test is that the result is selected
    and the application must then do something. The steps to writing this in Protractor
    are as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 正在测试的对象是结果。测试是结果被选择后，应用程序必须执行某些操作。编写这个测试的步骤如下：
- en: 'Select the `resultItem`. As we will be representing the details using a route,
    we will create a link to the details page and click on the link. Here is how to
    create a link:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`resultItem`。由于我们将使用路由来表示详细信息，我们将创建一个指向详细页面的链接并点击该链接。以下是创建链接的方法：
- en: 'Select the link within the `resultItem`. This uses the currently selected element
    and then finds any subelements that meet the criteria. The code for this is as
    follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 选择`resultItem`内的链接。这使用当前选择的元素，然后找到符合条件的任何子元素。代码如下：
- en: '[PRE56]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, to select the link, add the following code:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，要选择链接，请添加以下代码：
- en: '[PRE57]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Confirming a search result
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确认搜索结果
- en: 'Now that the search item has been selected, we will need to verify that the
    result details page is visible. The simplest solution at this point is to ensure
    that the details view is visible. This can be done using Protractor''s CSS locator
    to look for the search detail view. The following is the code to be added for
    confirming a search result:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在搜索项已被选中，我们需要验证结果详情页面是否可见。在这一点上，最简单的解决方案是确保详情视图是可见的。这可以通过使用 Protractor 的 CSS
    定位器来查找搜索详情视图来实现。以下是用于确认搜索结果的代码：
- en: '[PRE58]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Here is the complete test:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是完整的测试：
- en: '[PRE59]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Now that the test is set up, we can continue to the next phase of the life cycle
    and run it.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试已经设置好，我们可以继续到生命周期的下一个阶段并运行它。
- en: The search result component
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索结果组件
- en: The search result component (the one we named `Person`) will route to accept
    the person ID from the `params` route and will search data based on that ID.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索结果组件（我们命名为 `Person`）将路由以接受来自 `params` 路由的 person ID，并将根据该 ID 搜索数据。
- en: 'The search result component will be placed in `app/members/person/person.component.ts`.
    In the code, at first, we will have to import the required Angular services, as
    shown here:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索结果组件将放置在 `app/members/person/person.component.ts` 中。在代码中，首先我们将需要导入所需的 Angular
    服务，如下所示：
- en: '[PRE60]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We''ve already seen some of these Angular services in the `members` component.
    Here, we will mainly discuss the `ActivatedRoute`, as it''s new. This is an Angular
    router module, which is used to interact with the current/activated route: when
    we need to access the `params` in the current route, we''ll access them through this.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 `members` 组件中看到了一些这些 Angular 服务。在这里，我们将主要讨论 `ActivatedRoute`，因为它是新的。这是一个用于与当前/激活路由交互的
    Angular 路由模块：当我们需要访问当前路由中的 `params` 时，我们将通过它来访问它们。
- en: 'As we discussed, we will need `ActivatedRoute` while initializing the component;
    therefore, we have called `ActivatedRoute` on the `ngOnInit()` method. It will
    provide the current route params for us, and we will have our expected ID, which
    will be used to retrieve that specific `Person` from the demo members dataset,
    as shown here:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们讨论过的，我们在初始化组件时将需要 `ActivatedRoute`；因此，我们在 `ngOnInit()` 方法中调用了 `ActivatedRoute`。它将为我们提供当前路由参数，并且我们将使用它来从演示成员数据集中检索特定的
    `Person`，如下所示：
- en: '[PRE61]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We have some dummy data at `app/data/people.json`. This is the same data used
    in the `members` component. We will retrieve the data based on the selected ID,
    like this:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `app/data/people.json` 中有一些虚拟数据。这是 `members` 组件中使用的相同数据。我们将根据所选的 ID 检索数据，就像这样：
- en: '[PRE62]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The `getData()` method will retrieve the data from the API and will return
    a promise:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`getData()` 方法将从 API 中检索数据并返回一个 promise：'
- en: '[PRE63]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `getPerson()` method will resolve the returned promise and will return the
    `Person` object based on the selected ID.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`getPerson()` 方法将解析返回的 promise，并根据所选的 ID 返回 `Person` 对象。'
- en: 'The complete code regarding `PersonComponent` will be as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `PersonComponent` 的完整代码如下：
- en: '[PRE64]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The `search` component template contains the search form and the list of search
    results when there are some results to show.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`search` 组件模板包含搜索表单和搜索结果列表（当有结果要显示时）。'
- en: 'The template looks as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 模板如下所示：
- en: '[PRE65]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Search results in the route
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由中的搜索结果
- en: We have the search result/`Person` component, but we forgot to include that
    in the router configuration. Without that, we will have an exception as it will
    not be possible to navigate to the `Person` component from the `members` list
    without having it in the route.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有搜索结果/`Person` 组件，但我们忘记在路由配置中包含它。没有它，我们将会有一个异常，因为在没有在路由中包含它的情况下，无法从 `members`
    列表导航到 `Person` 组件。
- en: 'So, in our existing `app.routes.ts` file, we will add the following search
    routes:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们现有的 `app.routes.ts` 文件中，我们将添加以下搜索路由：
- en: '[PRE66]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Running the search wheel
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行搜索轮
- en: Our application is ready with the restructure, route configuration, e2e testing,
    and components with their child components. We will look at the current file structure
    and output of the project.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序已经准备好进行重构、路由配置、e2e测试以及它们的子组件。我们将查看当前文件结构和项目的输出。
- en: App structure
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用结构
- en: We have two major folders in our application, one is the `app` directory and
    the other is the `spec/test` directory.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序有两个主要的文件夹，一个是`app`目录，另一个是`spec/test`目录。
- en: 'Let''s see the current structure of our `app` directory:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们`app`目录的当前结构：
- en: '![App structure](graphics/B05405_07_05.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![应用结构](graphics/B05405_07_05.jpg)'
- en: 'And here''s the `test` directory:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`test`目录：
- en: '![App structure](graphics/B05405_07_06.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![应用结构](graphics/B05405_07_06.jpg)'
- en: Let's run
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让我们运行
- en: Our search feature is ready to run. If we run `npm start`, our application will
    run in the browser on the port `3000` by default. Let's navigate to **Members**
    to get the output of the search feature. The search feature URL is `http://localhost:3000/members`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的搜索功能已经准备就绪。如果我们运行`npm start`，我们的应用程序将在默认端口`3000`上在浏览器中运行。让我们导航到**成员**以获取搜索功能的输出。搜索功能的URL是`http://localhost:3000/members`。
- en: 'When we land on the **Members** page, it will actually load all the data as
    the search input is empty, which means there is no search query. The output should
    look as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们登陆**成员**页面时，实际上会加载所有数据，因为搜索输入为空，这意味着没有搜索查询。输出应该如下所示：
- en: '![Let''s run](graphics/image_07_007.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![让我们运行](graphics/image_07_007.jpg)'
- en: 'Now let''s check the **Members** page with a search query. If we type `Thomas`
    as the query and search, it will give us only one data row, as shown here:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们用一个搜索查询来检查**成员**页面。如果我们将查询输入为`Thomas`并进行搜索，它将给我们只有一行数据，如下所示：
- en: '![Let''s run](graphics/image_07_008.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![让我们运行](graphics/image_07_008.jpg)'
- en: 'We have one row in the data list. Now it''s time to see the details of the
    data. After clicking on **Thomas**, we will see detailed information about Thomas,
    with the address, as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在数据列表中有一行。现在是时候看数据的详细信息了。点击**Thomas**后，我们将看到关于Thomas的详细信息，包括地址，如下所示：
- en: '![Let''s run](graphics/image_07_009.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![让我们运行](graphics/image_07_009.jpg)'
- en: Hurray! The complete application is running in the browser as expected.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 万岁！完整的应用程序如预期般在浏览器中运行。
- en: How's e2e now!
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现在e2e怎么样！
- en: The project is running in the browser, and we've done e2e testing for every
    component. Let's see how the e2e test reacts when we run the whole application's
    e2e test together.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 项目在浏览器中运行，我们已经为每个组件进行了e2e测试。让我们看看当我们一起运行整个应用程序的e2e测试时，e2e测试的反应如何。
- en: 'Let''s run `npm run e2e`; the output is as shown here:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行`npm run e2e`；输出如下所示：
- en: '![How''s e2e now!](graphics/B05405_07_10.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![现在e2e怎么样！](graphics/B05405_07_10.jpg)'
- en: Self-test questions
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自测问题
- en: Q1\. Which custom placeholder is used to load the component after navigation?
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: Q1\. 在导航后使用哪个自定义占位符来加载组件？
- en: '[PRE67]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Q2\. Given the following Angular component, how would you select the `element`
    and simulate a click?
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: Q2\. 给定以下的Angular组件，你将如何选择`element`并模拟点击？
- en: '[PRE68]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Q3\. When using routes with Angular, you need to install `@angular/router`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: Q3\. 在Angular中使用路由时，你需要安装`@angular/router`。
- en: 'True'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误
- en: Summary
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter showed us how to use TDD to build an Angular application. The approach,
    up to this point, has focused on the specification from a user perspective and
    using TDD with a top-down approach. This technique helps us get usable and small
    components tested and completed for the users.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向我们展示了如何使用TDD来构建一个Angular应用程序。到目前为止，这种方法侧重于从用户角度进行规范，并使用自顶向下的TDD方法。这种技术帮助我们测试并完成了可用的小组件。
- en: As applications grow, so does their complexity. In the next chapter, we will
    explore the bottom-up approach and see when to use that technique over the top-down
    approach.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序的增长，它们的复杂性也在增加。在下一章中，我们将探讨自下而上的方法，并看看何时使用这种技术而不是自上而下的方法。
- en: This chapter showed us how TDD can be used to develop a component-based application
    with navigation by routers. Routes allow us to get a nice separation of our components
    and views. We looked at the usage of several Protractor locators, from CSS to
    repeaters, link text, and inner locators. Besides using Protractor, we also learned
    how to configure Karma with a headless browser, and we got to see it in action.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向我们展示了如何使用TDD来开发具有路由导航的基于组件的应用程序。路由允许我们很好地分离我们的组件和视图。我们研究了几种Protractor定位器的用法，从CSS到重复器，链接文本和内部定位器。除了使用Protractor，我们还学习了如何配置Karma与无头浏览器，并看到它的实际应用。
