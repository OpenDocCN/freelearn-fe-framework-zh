- en: Creating ReasonReact Components
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建ReasonReact组件
- en: 'Now that we''ve set up our development environment, we''re ready to get started
    with ReasonReact—the future of ReactJS. Both ReasonML and ReasonReact were built
    by the same person who built ReactJS. ReasonReact is just Reason, much like how
    ReactJS is just JavaScript. Throughout the rest of this book, we will be working
    with an application that we will start building in this chapter. The following
    are screenshots of what we''ll have built by the end of this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了我们的开发环境，我们就可以开始使用ReasonReact了——ReactJS的未来。ReasonML和ReasonReact都是由构建ReactJS的同一个人构建的。ReasonReact就是Reason，就像ReactJS就是JavaScript一样。在本书的其余部分，我们将使用一个应用程序，我们将在本章开始构建。以下是本章结束时我们将构建的内容的截图：
- en: '![](img/b88262e1-bf4b-4508-aa96-84b090a76664.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b88262e1-bf4b-4508-aa96-84b090a76664.png)'
- en: To follow along, clone this book's GitHub repository and start from `Chapter03/start`.
    Throughout the rest of this book, each directory shares the same development environment
    as the one we set up at the end of [Chapter 2](4e4e3057-fca6-4c81-b6a7-05575aeeace3.xhtml),
    *Setting Up a Development Environm**ent*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟上进度，请克隆本书的GitHub仓库，并从`Chapter03/start`开始。在本书的其余部分，每个目录都与我们设置的开发环境相同，即在[第2章](4e4e3057-fca6-4c81-b6a7-05575aeeace3.xhtml)的*设置开发环境*结束时设置的环境。
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We'll first explore ReasonReact, and at about halfway through this chapter,
    we'll shift to the `Chapter03/app-start` directory, where we'll start building
    an application with ReasonReact's built-in router.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将探索ReasonReact，在本章大约一半的时候，我们将转向`Chapter03/app-start`目录，在那里我们将开始使用ReasonReact的内置路由构建应用程序。
- en: 'In this chapter, we will do the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将进行以下操作：
- en: Explore creating stateless and stateful ReasonReact components
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索创建无状态和有状态ReasonReact组件
- en: Create an application that includes navigation and routing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个包含导航和路由的应用程序
- en: See how so many of the ReactJS concepts you're already familiar with map nicely
    to ReasonReact
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看您已经熟悉的许多ReactJS概念如何很好地映射到ReasonReact
- en: Learn how ReasonReact can help us create more robust components thanks to Reason's
    type system
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何利用Reason的类型系统，ReasonReact可以帮助我们创建更健壮的组件
- en: Component creation basics
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件创建基础
- en: 'Let''s start by analyzing a simple stateless component. In `App.re`, let''s
    render a `<div />` element with some text:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从分析一个简单的无状态组件开始。在`App.re`中，让我们渲染一个带有文本的`<div />`元素：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And in `Index.re`, render the component to a DOM element with an ID of `"root"`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Index.re`中，将组件渲染到具有ID `"root"`的DOM元素中：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Due to Reason's module system, we do not need an `import` statement in `Index.re` nor
    an export statement in `App.re`. Every Reason file is a module, and every Reason
    module is globally available. Later in this book, we will see how a module's implementation
    details can be hidden so that users of your component only access things they
    are supposed to access.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Reason的模块系统，我们不需要在`Index.re`中声明`import`语句，也不需要在`App.re`中声明导出语句。每个Reason文件都是一个模块，每个Reason模块都是全局可用的。在本书的后面部分，我们将看到如何隐藏模块的实现细节，以便您的组件用户只能访问他们应该访问的内容。
- en: Component templates
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件模板
- en: 'In ReasonReact, all components are created with one of the following four functions:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在ReasonReact中，所有组件都是通过以下四个函数之一创建的：
- en: '`ReasonReact.statelessComponent`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReasonReact.statelessComponent`'
- en: '`ReasonReact.statelessComponentWithRetainedProps`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReasonReact.statelessComponentWithRetainedProps`'
- en: '`ReasonReact.reducerComponent`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReasonReact.reducerComponent`'
- en: '`ReasonReact.reducerComponentWithRetainedProps`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReasonReact.reducerComponentWithRetainedProps`'
- en: 'Each of the four functions accepts a `string` and returns a `record` corresponding
    to a different component template. The `string` argument is only for debugging
    purposes. The component gets its name (`<App />`) from its filename (`App.re`).
    The fields the returned record contains are dependent on which of the functions
    was used. In the case of our previous example, we have the following fields that
    we can override:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个函数中的每一个都接受一个`string`并返回一个对应不同组件模板的`record`。`string`参数仅用于调试目的。组件从其文件名（`App.re`）中获取其名称（`<App
    />`）。返回的记录中的字段取决于使用了哪个函数。在我们的上一个例子中，我们有以下字段可以覆盖：
- en: '`render`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`render`'
- en: '`didMount`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`didMount`'
- en: '`willReceiveProps`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`willReceiveProps`'
- en: '`shouldUpdate`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shouldUpdate`'
- en: '`willUpdate`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`willUpdate`'
- en: '`didUpdate`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`didUpdate`'
- en: '`willUnmount`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`willUnmount`'
- en: Aside from the `render` field, the rest are just familiar ReactJS life cycle
    events. To override a field, add that field within the `make` function's returned
    `record`. In the preceding example, the component template's `render` field was
    replaced with the custom `render` function.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `render` 字段外，其余的都是熟悉的 ReactJS 生命周期事件。要覆盖字段，请在 `make` 函数返回的 `record` 中添加该字段。在先前的例子中，组件模板的
    `render` 字段被替换为自定义的 `render` 函数。
- en: The `make` function accepts `props` as arguments, and returns a `record` of
    the same shape as the one that was initially created by one of the four component
    creation functions. The last argument to the `make` function must be the `children` prop.
    You may have noticed that `children` is prefixed with an `_` in the preceding
    example. If your component does not need a reference to the children prop, then
    prefixing the argument with an `_` prevents a compiler warning for the unused
    binding.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`make` 函数接受 `props` 作为参数，并返回一个与最初由四个组件创建函数之一创建的形状相同的 `record`。`make` 函数的最后一个参数必须是
    `children` 属性。你可能已经注意到，在先前的例子中 `children` 前面有一个下划线 `_`。如果你的组件不需要对 `children` 属性的引用，那么在参数前加上下划线
    `_` 可以防止编译器警告未使用的绑定。'
- en: It may not appear immediately obvious, but the `make` function's curly braces
    belong to the returned `record` literal. The `...component` expression spreads
    the contents of the original `record` in this new `record` so that individual
    fields can be overridden without having to explicitly set each field.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 可能一开始并不明显，但 `make` 函数的大括号属于返回的 `record` 文字。`...component` 表达式将原始 `record` 的内容扩展到这个新
    `record` 中，这样就可以在不显式设置每个字段的情况下覆盖单个字段。
- en: self
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: self
- en: 'The `render` field holds a callback function that accepts an argument called
    `self`, and returns a value of type `ReasonReact.reactElement`. The three fields
    of the `self` record are the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`render` 字段包含一个接受名为 `self` 的参数的回调函数，并返回类型为 `ReasonReact.reactElement` 的值。`self`
    记录的三个字段如下：'
- en: '`state`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`state`'
- en: '`handle`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handle`'
- en: '`send`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`send`'
- en: By choice, ReasonReact does not have the concept of JavaScript's `this`. Instead,
    `self` holds the necessary information and is provided to callbacks that need
    it. We'll see more of `self` when using stateful components.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 出于选择，ReasonReact 没有JavaScript的 `this` 的概念。相反，`self` 包含必要的信息，并提供给需要它的回调函数。当使用有状态组件时，我们将看到更多关于
    `self` 的内容。
- en: Event handlers
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件处理器
- en: 'In our render function, we can attach event listeners to DOM elements the same
    way that we would in ReactJS. For example, to listen for the click event, we add
    an `onClick` attribute and set its value to an event handler:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的渲染函数中，我们可以像在 ReactJS 中一样将事件监听器附加到 DOM 元素上。例如，为了监听点击事件，我们添加一个 `onClick` 属性并将其值设置为事件处理器：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: However, this callback function must accept exactly one argument (corresponding
    to a JavaScript DOM event) and mustreturn a type called `unit`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个回调函数必须接受恰好一个参数（对应于一个 JavaScript DOM 事件）并且必须返回一个名为 `unit` 的类型。
- en: unit
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元
- en: 'In Reason, `unit` is a type that means "nothing." A function whose return type
    is `unit` cannot return anything other than `unit`. There is exactly one value
    of type `unit`: `()` (that is, a pair of empty parentheses, which is also called
    `unit`).'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Reason 中，`unit` 是一个表示 "无" 的类型。其返回类型为 `unit` 的函数不能返回除 `unit` 之外的其他任何内容。`unit`
    类型的值只有一个：`()`（即一对空括号，也称为 `unit`）。
- en: 'In contrast, there are exactly two values of type `bool`: `true` and `false`.
    There are an infinite number of values of type `int`.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`bool` 类型的值正好有两个：`true` 和 `false`。`int` 类型的值有无限多个。
- en: As discussed in [Chapter 1](75c7a9ae-b7e6-4ba7-97d0-eaa5cad2967c.xhtml), *Introduction to
    ReasonML*, the idiomatic way to represent a nullable value in Reason is with the
    `option` type. The major difference between the `option` type and the `unit` type
    is that a value of type `option` could be nothing, or it could be some value where
    as a value of type `unit` is always `()`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [第 1 章](75c7a9ae-b7e6-4ba7-97d0-eaa5cad2967c.xhtml) 所述，在 ReasonML 的 *介绍* 中，表示
    Reason 中可空值的惯用方法是使用 `option` 类型。`option` 类型与 `unit` 类型的主要区别在于，`option` 类型的值可以是空值，也可以是某个值，而
    `unit` 类型的值总是 `()`。
- en: A function that accepts and/or returns `unit` likely causes side effects. For
    example, `Js.log` is a function that returns `unit`. The `onClick` event handler
    is also a function that returns `unit`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 接受和/或返回 `unit` 的函数可能引起副作用。例如，`Js.log` 是一个返回 `unit` 的函数。`onClick` 事件处理器也是一个返回
    `unit` 的函数。
- en: '`Random.bool` is an example of a function that accepts `unit` as its argument
    and returns a `bool`. The syntax for calling a function with `unit` is quite familiar:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`Random.bool` 是一个接受 `unit` 作为参数并返回 `bool` 的函数示例。调用带有 `unit` 的函数的语法相当熟悉：'
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Since `onClick` needs a function that returns `unit`, the following will result
    in a type error:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `onClick` 需要一个返回 `unit` 的函数，以下将导致类型错误：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The type error is shown here:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 类型错误在这里显示：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the error message, `This expression` refers to `42`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在错误信息中，`This expression` 指的是 `42`。
- en: JSX
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSX
- en: 'Reason comes with the JSX syntax. One difference in ReasonReact''s version
    of JSX is that we cannot do the following in ReasonReact:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Reason 提供了 JSX 语法。ReasonReact 版本的 JSX 中的一个区别是我们不能在 ReasonReact 中做以下操作：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Instead, we need to convert the `string` to a `ReasonReact.reactElement` with
    the `ReasonReact.string` function:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们需要使用 `ReasonReact.string` 函数将 `string` 转换为 `ReasonReact.reactElement`：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'However, this still doesn''t work. We need to also wrap the expression with
    `{ }` to help the parser differentiate between multiple possible children:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这仍然不起作用。我们还需要将表达式包裹在 `{ }` 中，以帮助解析器区分多个可能的子元素：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You''re free to create an alias that is less verbose and use that instead:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以自由地创建一个更简洁的别名来使用：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When a custom component is invoked in JSX, its `make` function is called. The `<App
    />` syntax desugars to the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 JSX 中调用自定义组件时，它的 `make` 函数会被调用。`<App />` 语法会解构为以下形式：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When a component will receive new props, its `make` function will again be called
    with the new props as arguments. The `make` function is like a combination of
    ReactJS's `constructor` and ReactJS's `componentWillReceiveProps`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个组件将接收新的属性时，它的 `make` 函数将再次被调用，并将新属性作为参数。`make` 函数类似于 ReactJS 的 `constructor`
    和 ReactJS 的 `componentWillReceiveProps` 的组合。
- en: Props
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性
- en: 'Let''s add a few props to our `<App />` component:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `<App />` 组件中添加一些属性：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After compiling, we get a compiler error, because in `Index.re` we aren''t
    providing the required `greeting` and `name` props:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后，我们会得到一个编译错误，因为在 `Index.re` 中我们没有提供所需的 `greeting` 和 `name` 属性：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`greeting` and `name` are **labelled arguments** of the `make` function, meaning
    that they can be provided in any order. To convert an argument to a labelled argument,
    prefix it with a tilde (`~`). Reason also supports optional arguments as well
    as arguments with defaults. Let''s give `greeting` a default value and make `name`
    optional:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`greeting` 和 `name` 是 `make` 函数的 **标记参数**，这意味着它们可以以任何顺序提供。要将一个参数转换为标记参数，在其前加上波浪号
    (`~`)。Reason 还支持可选参数以及具有默认值的参数。让我们给 `greeting` 设置一个默认值，并使 `name` 可选：'
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Since `name` is an optional argument, it's wrapped in an `option` type, and
    we can then pattern match on its value. Of course, this is just a long-winded
    way of providing `name` with a default argument of `""`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `name` 是一个可选参数，它被包裹在 `option` 类型中，然后我们可以根据其值进行模式匹配。当然，这仅仅是一种提供 `name` 默认值为
    `""` 的冗长方式。
- en: 'Now, our example compiles even if `<App />` isn''t provided with any props:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，即使 `<App />` 没有提供任何属性，我们的示例也能编译成功：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If we then decide to remove the name prop, the compiler will tell us where we
    need to update the usage of `<App />`. This gives us the freedom to refactor our
    components without worrying about forgetting to update an area of our codebase.
    The compiler has our back!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定移除 `name` 属性，编译器会告诉我们需要更新 `<App />` 的使用位置。这给了我们自由重构组件而不必担心忘记更新代码库中的某个区域。编译器是我们的后盾！
- en: Children
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子元素
- en: The last argument to the `make` function is always the `children` prop—it's
    mandatory. Just like other props, children can be any data structure. As long
    as the component allows it, we can use the render prop pattern that is popular
    in ReactJS. Importantly, ReasonReact always wraps children in an array, so we
    need to unwrap the array with the `...` syntax if we don't want this wrapping.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`make` 函数的最后一个参数总是 `children` 属性——这是强制性的。和其他属性一样，`children` 可以是任何数据结构。只要组件允许，我们就可以使用在
    ReactJS 中流行的渲染属性模式。重要的是，ReasonReact 总是会将 `children` 包裹在一个数组中，所以如果我们不想有这种包裹，我们需要使用
    `...` 语法来解包数组。'
- en: 'In `App.re`, we''ll remove all props except for the required `children` prop.
    In the render function, we invoke children with our hardcoded greeting:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `App.re` 中，我们将移除所有属性，除了必需的 `children` 属性。在渲染函数中，我们使用硬编码的问候语调用 `children`：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And in `Index.re`, we add a function as a child of `<App />` that accepts the
    provided greeting and returns JSX (which is of type `ReasonReact.reactElement`).
    Notice the `...` syntax used to unwrap the array that all ReasonReact children
    are wrapped with:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Index.re` 中，我们添加了一个函数作为 `<App />` 的子代，该函数接受提供的问候语并返回 JSX（类型为 `ReasonReact.reactElement`）。注意使用
    `...` 语法来展开所有 ReasonReact 子代都被包裹的数组：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If we forget the `...`, the compiler will kindly let us know:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们忘记了 `...`，编译器会友好地提醒我们：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We'll even get a similar compiler message if we don't include any children (that
    is, just `<App />`), since that translates into an empty array. This means that
    we're guaranteed that users of our component have to provide a function of type
    `string => ReasonReact.reactElement` as a child of `<App />` if it's going to
    type check.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不包含任何子代（即仅 `<App />`），我们甚至还会得到类似的编译器消息，因为这相当于一个空数组。这意味着我们保证我们的组件用户必须提供一个类型为
    `string => ReasonReact.reactElement` 的函数作为 `<App />` 的子代，以便进行类型检查。
- en: 'We can also mandate that our component accepts other children types, for example,
    a tuple of two strings:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以强制我们的组件接受其他子代类型，例如，两个字符串的元组：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Reason is able to infer that children must be a tuple of type `(string, string)`
    because of its use in `App.re`. For example, consider the following usage:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在 `App.re` 中的使用，Reason 能够推断出子代必须是类型为 `(string, string)` 的元组。例如，考虑以下用法：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will result in a friendly compiler error because the `App` component requires
    its children to be a tuple but the `App` component's children is not a tuple.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致友好的编译器错误，因为 `App` 组件要求其子代必须是元组，但 `App` 组件的子代不是元组。
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is incredibly powerful. Since we get these guarantees at compile time,
    we don't have to worry about runtime checks on the shape of our component's children.
    Similarly, we are guaranteed that props type check at compile time. Refactoring
    components is much less stressful because the compiler guides us along the way.
    What's more, thanks to Reason's powerful type inference, we haven't had to explicitly
    annotate any types so far.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常强大。由于我们在编译时获得这些保证，所以我们不必担心组件子代形状的运行时检查。同样，我们保证在编译时进行 props 类型检查。重构组件的压力大大减轻，因为编译器在这个过程中为我们提供指导。更重要的是，多亏了
    Reason 强大的类型推断，我们迄今为止还没有需要显式注释任何类型。
- en: Life cycles
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生命周期
- en: 'ReasonReact supports the familiar ReactJS life cycle events. We will get a
    closer look at some of the life cycle events as we build our app, but, for now,
    let''s see how we can implement ReactJS''s `componentDidMount` life cycle hook
    for `<App />`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ReasonReact 支持熟悉的 ReactJS 生命周期事件。随着我们构建应用程序，我们将更深入地了解一些生命周期事件，但就目前而言，让我们看看我们如何实现
    ReactJS 的 `componentDidMount` 生命周期钩子为 `<App />`：
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Instead of `componentDidMount`, we use `didMount`. Again, `didMount` is just
    a field within a record returned by the component's `make` function. The type
    of `didMount` is `self => unit`, which is a function that accepts `self` and returns
    `unit`. Since it returns `unit`, it's likely that `didMount` causes a side effect,
    and in our example it does. Running this in the browser results in `mounted` logged
    to the console.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不使用 `componentDidMount`，而是使用 `didMount`。再次强调，`didMount` 是组件 `make` 函数返回的记录中的一个字段。`didMount`
    的类型是 `self => unit`，这是一个接受 `self` 并返回 `unit` 的函数。由于它返回 `unit`，因此 `didMount` 很可能引起副作用，在我们的例子中确实如此。在浏览器中运行此代码会在控制台输出
    `mounted`。
- en: Subscriptions helper
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订阅助手
- en: 'To make writing cleanup code more convenient and easier to remember, ReasonReact
    provides `self.onUnmount`, which can be used directly within a component''s `didMount`
    life cycle (or anywhere that has access to `self`). This allows you to write the
    cleanup code alongside its complement instead of separately, within `willUnmount`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使编写清理代码更加方便和易于记忆，ReasonReact 提供了 `self.onUnmount`，它可以直接在组件的 `didMount` 生命周期（或任何可以访问
    `self` 的地方）中使用。这允许你将清理代码与其对应的代码一起编写，而不是在 `willUnmount` 中单独编写：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Stateful components
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有状态组件
- en: So far, we've only used the `ReasonReact.statelessComponent` template. To create
    a stateful component, we switch out the component template to `ReasonReact.reducerComponent`
    and override some additional fields within the record returned by its `make` function.
    As we'll soon see, we'll also need to declare custom type definitions for use
    in these additional fields. It's called `reducerComponent` because it has the
    concept of state, actions, and reducers built in—just like Redux, except state,
    actions, and reducers are local to the component.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只使用了 `ReasonReact.statelessComponent` 模板。要创建一个有状态的组件，我们将组件模板切换到 `ReasonReact.reducerComponent`
    并覆盖其 `make` 函数返回的记录中的某些附加字段。因为它内置了状态、动作和 reducer 的概念，所以被称为 `reducerComponent`——就像
    Redux 一样，只是状态、动作和 reducer 是局部于组件的。
- en: 'A simple counter component with buttons to increment and decrement the current
    count is shown here:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了一个简单的计数器组件，它带有用于增加和减少当前计数的按钮：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The ReactJS Fragment syntax (`<>` and `</>`) is used here to wrap the `<button>`
    and `<span>` elements without adding an unnecessary DOM node.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用 ReactJS 片段语法（`<>` 和 `</>`）来包裹 `<button>` 和 `<span>` 元素，而不添加不必要的 DOM 节点。
- en: State, action, and reducer
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态、动作和 reducer
- en: 'Let''s break this down. At the top of the file, we see two type declarations,
    one for state and one for actions. The names `state` and `action` are a convention,
    but you can use any name you like:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下。在文件顶部，我们看到两个类型声明，一个是状态，另一个是动作。`state` 和 `action` 的名称是一个约定，但你可以使用任何你喜欢的名称：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Just as in Redux, events trigger actions that are sent to a reducer that then
    updates state. Next, the button''s click event triggers a `Decrement` action that
    gets sent to the component''s reducer via `self.send`. Remember, the render function
    is provided `self` as its argument:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在 Redux 中一样，事件触发动作，这些动作被发送到 reducer，然后更新状态。接下来，按钮的点击事件触发一个 `Decrement` 动作，并通过
    `self.send` 发送到组件的 reducer。记住，渲染函数将 `self` 作为其参数提供：
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `state` type declaration defines the shape of our state. In this case,
    our state is just an integer that holds the component''s current count. The component''s
    initial state is `0`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`state` 类型声明定义了我们的状态形状。在这种情况下，我们的状态只是一个整数，它持有组件的当前计数。组件的初始状态是 `0`：'
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`initialState` requires a function of type `unit => state`.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`initialState` 需要一个类型为 `unit => state` 的函数。'
- en: 'When triggered by an action, the reducer function accepts that action as well
    as the current state, and returns a new state. Pattern matching is used on the
    current action, and `ReasonReact.Update` is used to return a new state:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当被某个动作触发时，reducer 函数接受该动作以及当前状态，并返回一个新的状态。在当前动作上使用模式匹配，并使用 `ReasonReact.Update`
    来返回一个新的状态：
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To help keep your ReasonReact apps ready for the coming ReactJS Fiber release,
    ensure that everything in `reducer` is pure. One way to trigger side effects indirectly
    while keeping `reducer` pure is by using `ReasonReact.UpdateWithSideEffects`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助确保你的 ReasonReact 应用准备好即将到来的 ReactJS Fiber 发布，请确保 `reducer` 中的所有内容都是纯的。在保持
    `reducer` 纯的同时间接触发副作用的一种方法是通过使用 `ReasonReact.UpdateWithSideEffects`：
- en: '[PRE30]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The return value of `reducer` must be one of the following variant constructors:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`reducer` 的返回值必须是以下变体构造函数之一：'
- en: '`ReasonReact.NoUpdate`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReasonReact.NoUpdate`'
- en: '`ReasonReact.Update(state)`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReasonReact.Update(state)`'
- en: '`ReasonReact.SideEffects(self => unit)`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReasonReact.SideEffects(self => unit)`'
- en: '`ReasonReact.UpdateWithSideEffects(state, self => unit)`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReasonReact.UpdateWithSideEffects(state, self => unit)`'
- en: 'We can trigger new actions from within our side effects, since we''re again
    provided with `self`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在副作用内部触发新的动作，因为我们再次提供了 `self`：
- en: '[PRE31]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: After incrementing, the `reducer` triggers a side-effect that triggers the `Decrement`
    action after one second.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在增加计数后，`reducer` 触发一个副作用，该副作用在一秒后触发 `Decrement` 动作。
- en: Refactoring
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构
- en: 'Let''s imagine we now need our stateful component to display a message that
    congratulates the user when they get to a count of 10, and once the message is
    displayed, the user can close the message by clicking a close button. Thanks to
    our helpful compiler, we can follow these steps:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们现在需要我们的有状态组件显示一条消息，当用户计数达到 10 时，恭喜用户，一旦消息显示，用户可以通过点击关闭按钮来关闭消息。多亏了我们有帮助的编译器，我们可以遵循以下步骤：
- en: Update the shape of `state`
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `state` 的形状
- en: Update the available `actions`
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新可用的 `actions`
- en: Step through the compiler errors
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 步骤通过编译器错误
- en: Update the `render` function
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `render` 函数
- en: 'The compiler messages will remind us to update the component''s initial state
    and reducer. Since we now need to also keep track of whether or not to display
    a message, let''s change the shape of `state` to this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器消息会提醒我们更新组件的初始状态和 reducer。由于我们现在需要跟踪是否显示消息，让我们将 `state` 的形状更改为以下内容：
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'For our actions, let''s combine `Increment` and `Decrement` into one constructor
    that accepts an `int`, and we''ll have a new constructor to toggle the message:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的动作，让我们将 `Increment` 和 `Decrement` 合并成一个接受 `int` 的构造函数，我们将有一个新的构造函数来切换消息：
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now, instead of `Increment` and `Decrement`, we have `UpdateCount`, which holds
    an integer representing the amount to change the current count by.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不再有 `Increment` 和 `Decrement`，而是 `UpdateCount`，它包含一个表示当前计数增加或减少的整数值。
- en: 'After compiling, we see a friendly error letting us know that our previous
    action `Decrement` cannot be found:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后，我们看到一个友好的错误消息，告诉我们之前的动作 `Decrement` 无法找到：
- en: '[PRE34]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the `render` function, replace  `Increment`  with `UpdateCount(+1)` and
    `Decrement` with `UpdateCount(-1)`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `render` 函数中，将 `Increment` 替换为 `UpdateCount(+1)`，将 `Decrement` 替换为 `UpdateCount(-1)`：
- en: '[PRE35]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Compiling again, we''re informed that in our reducer, `Increment` does not
    belong to type `action`. Let''s update our reducer to handle both `UpdateCount`
    and `ToggleMessage`. If we were to forget a constructor, the compiler would let
    us know that the switch expression in the reducer is not exhaustive:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 再次编译，我们被告知在我们的 reducer 中，`Increment` 不属于 `action` 类型。让我们更新我们的 reducer 来处理 `UpdateCount`
    和 `ToggleMessage`。如果我们忘记了一个构造函数，编译器会告诉我们 reducer 中的 switch 表达式不是详尽的：
- en: '[PRE36]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'There are few things to mention regarding the preceding code snippet:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前面的代码片段，有几件事情要说明：
- en: In `UpdateCount`, we're declaring a binding `count` that reflects the new count.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `UpdateCount` 中，我们声明了一个绑定 `count`，它反映了新的计数。
- en: We're using `...` to override just a portion of the state record.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `...` 来覆盖状态记录的一部分。
- en: 'Thanks to record punning support, we can write `{...state, count}` instead
    of `{...state, count: count}`.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '由于记录 punning 支持功能，我们可以写 `{...state, count}` 而不是 `{...state, count: count}`。'
- en: '`UpdateCount` is using `UpdateWithSideEffects` to trigger a `ToggleMessage`
    action when the count reaches 10; we could have instead done this:'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UpdateCount` 使用 `UpdateWithSideEffects` 在计数达到 10 时触发一个 `ToggleMessage` 动作；我们本可以这样做：'
- en: '[PRE37]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: I prefer using `UpdateWithSideEffects` so that `UpdateCount` only ever has to
    worry about its count field, and if some other field needs to get updated, `UpdateCount`
    can trigger the right action for that to happen, without needing to know how it
    needs to happen.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢使用 `UpdateWithSideEffects`，这样 `UpdateCount` 只需要关心其计数字段，如果其他字段需要更新，`UpdateCount`
    可以触发正确的动作来实现这一点，而无需知道它应该如何实现。
- en: 'After compiling here, we get an interesting compiler error:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里编译后，我们得到了一个有趣的编译器错误：
- en: '[PRE38]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The compiler sees `state` in `state.count` on line 18 (shown previously) as
    having type `int` instead of type `state`. This is because our render function
    is using `string_of_int(self.state)` instead of `string_of_int(self.state.count)`.
    After updating our render function to reflect this, we get another similar message
    complaining that type `int` and type `state` are incompatible. That's because
    our initial state is still returning `0` instead of a record of type `state`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将第 18 行（之前显示）的 `state.count` 中的 `state` 视为 `int` 类型而不是 `state` 类型。这是因为我们的
    `render` 函数正在使用 `string_of_int(self.state)` 而不是 `string_of_int(self.state.count)`。在更新我们的
    `render` 函数以反映这一点后，我们得到了另一个类似的错误消息，抱怨 `int` 类型与 `state` 类型不兼容。这是因为我们的初始状态仍然返回
    `0` 而不是 `state` 类型的记录。
- en: 'After updating initial state, the code finally compiles successfully:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 更新初始状态后，代码最终编译成功：
- en: '[PRE39]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, we''re ready to update the render function to display a message when the
    count reaches 10:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备更新 `render` 函数以在计数达到 10 时显示消息：
- en: '[PRE40]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Since `if/else` is an expression in Reason, we can use it within JSX to either
    render markup or `ReasonReact.null` (which has type `ReasonReact.reactElement`).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `if/else` 是 Reason 中的一个表达式，我们可以在 JSX 中使用它来渲染标记或 `ReasonReact.null`（它具有 `ReasonReact.reactElement`
    类型）。
- en: Instance variables
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例变量
- en: Although our example correctly shows the message when count reaches 10 for the
    first time, there is nothing preventing our `ToggleMessage` action from getting
    fired again within the `UpdateCount` case in the reducer. If a user gets to 10,
    then decrements and then increments, the message is toggled again. To ensure that
    `UpdateCount` only ever triggers the `ToggleMessage` action once, we can use an
    **instance variable** in state.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的示例在计数器第一次达到10时正确显示了消息，但没有任何东西可以阻止我们的`ToggleMessage`操作在`UpdateCount`案例中的reducer中再次触发。如果用户达到10，然后递减再递增，消息会再次切换。为了确保`UpdateCount`只触发一次`ToggleMessage`操作，我们可以在状态中使用一个**实例变量**。
- en: In ReactJS, every time something in state changes, the component gets re-rendered.
    In ReasonReact, instance variables never trigger a re-render, and can be correctly
    placed within a component's state.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在ReactJS中，每当状态中的某个东西发生变化时，组件都会重新渲染。在ReasonReact中，实例变量永远不会触发重新渲染，并且可以正确地放置在组件的状态中。
- en: 'Let''s add an instance variable to keep track of whether the user has already
    seen the message:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个实例变量来跟踪用户是否已经看到了消息：
- en: '[PRE41]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Ref and mutable records
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用和可变记录
- en: The difference between ReasonReact instance variables and normal state variables
    is the use of `ref`. Previously, we saw that `state.userHasSeenMessage` is of
    type `ref(bool)` instead of `bool`. That makes `state.userHasSeenMessage` an instance
    variable.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ReasonReact实例变量和普通状态变量之间的区别在于`ref`的使用。之前，我们看到`state.userHasSeenMessage`的类型是`ref(bool)`而不是`bool`。这使得`state.userHasSeenMessage`成为一个实例变量。
- en: Since `ref` is just syntactic sugar for a record type with a mutable field,
    let's first discuss mutable record fields.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`ref`只是具有可变字段的记录类型的语法糖，让我们首先讨论可变记录字段。
- en: 'To allow a record field to be mutable, prefix the field''s name with `mutable`.
    Then, those fields can be updated in place using the `=` operator:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要允许记录字段可变，请在该字段名称前加上`mutable`前缀。然后，可以使用`=`运算符就地更新这些字段：
- en: '[PRE42]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'However, the type declaration is already included in Reason''s standard library,
    so we can omit it, and the rest of the preceding code would still work, declaring
    it shadowed the original type declaration. We can prove this by shadowing the
    `ref` type with an immutable record:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，类型声明已经包含在Reason的标准库中，因此我们可以省略它，前面的其余代码仍然可以工作，声明它覆盖了原始类型声明。我们可以通过用一个不可变记录覆盖`ref`类型来证明这一点：
- en: '[PRE43]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The compiler fails with the following error:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器失败，出现以下错误：
- en: '[PRE44]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In addition to having a built-in type definition, `ref` also has some built-in
    functions. Namely, `ref` is used to create a record of type `ref`, and `^` is
    used to get the contents of a `ref`, and `:=` is used to set the contents of a
    ref:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 除了具有内置的类型定义外，`ref`还有一些内置函数。具体来说，`ref`用于创建类型为`ref`的记录，`^`用于获取`ref`的内容，而`:=`用于设置`ref`的内容：
- en: '[PRE45]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s go back to our ReasonReact example, and let''s use our new `userHasSeenMessage`
    instance variable. After updating the shape of our state, we need to also update
    the component''s initial state:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的ReasonReact示例，并使用我们新的`userHasSeenMessage`实例变量。在更新状态的形状后，我们还需要更新组件的初始状态：
- en: '[PRE46]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, our code again compiles, and we can update `reducer` to use this instance
    variable:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的代码再次编译成功，我们可以更新`reducer`以使用这个实例变量：
- en: '[PRE47]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now, the message is correctly displayed once and only once.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，消息正确显示了一次，而且只显示了一次。
- en: Navigation menu
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航菜单
- en: Let's use what we've learned so far as a foundation to build upon while creating
    an application with a navigation menu and client-side routing. On touch devices,
    users will be able to swipe to close the menu, and the menu will respond in real
    time to the user's touch. If the user swipes the menu when it's more than 50%
    closed and then releases, the menu will close; otherwise, it will remain open.
    The one exception is if the user swipes the menu closed with a high enough velocity;
    it will always close.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用到目前为止所学的内容作为基础，在创建一个带有导航菜单和客户端路由的应用程序时进行构建。在触摸设备上，用户将能够滑动来关闭菜单，并且菜单将实时响应用户的触摸。如果用户在菜单超过50%关闭时滑动并释放，菜单将关闭；否则，它将保持打开。唯一的例外是如果用户以足够高的速度滑动关闭菜单，它总是会关闭。
- en: 'We will be working with this application throughout the rest of the book. To
    follow along, clone the GitHub repo and navigate to the directory representing
    the start of this chapter:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的其余部分使用这个应用程序。要跟上，请克隆GitHub仓库并导航到代表本章开始的目录：
- en: '[PRE48]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Let''s take a moment to see what we have to work with. You will see the following
    directory structure:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间看看我们有什么可以工作的。您将看到以下目录结构：
- en: '[PRE49]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Our `bsconfig.json` is set up to place compiled `.bs.js` files within `lib/es6/src`, and
    we've configured webpack to look for `lib/es6/src/Index.bs.js` as an entry point.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `bsconfig.json` 已配置为将编译的 `.bs.js` 文件放置在 `lib/es6/src` 中，并且我们已经配置了 webpack
    以查找 `lib/es6/src/Index.bs.js` 作为入口点。
- en: Run `npm install` and then `npm start` to serve our app at `http://localhost:3000` with
    both bsb and webpack in watch mode.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `npm install` 然后运行 `npm start` 以在 `http://localhost:3000` 上以 bsb 和 webpack
    的监视模式提供我们的应用。
- en: Currently, our app displays a blue navigation bar with a hamburger icon. Clicking
    on the icon opens a menu and clicking outside the menu closes it.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的应用显示一个带有汉堡图标的天蓝色导航栏。点击图标会打开菜单，点击菜单外部会关闭它。
- en: 'In `App.re`, our state is currently a single field record that keeps track
    of the menu''s state:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `App.re` 中，我们的状态目前是一个单字段记录，用于跟踪菜单的状态：
- en: '[PRE50]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We have one action:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个动作：
- en: '[PRE51]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'And our reducer takes care of updating the menu''s state:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 reducer 负责更新菜单的状态：
- en: '[PRE52]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Although Reason supports record punning, it does not work for single field records,
    since Reason treats `{isOpen}` as a block instead of a record.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Reason 支持记录欺骗，但它不适用于单字段记录，因为 Reason 将 `{isOpen}` 视为一个块而不是一个记录。
- en: 'Our render function renders a `<div />` element with a conditional class name
    depending on the current state:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的渲染函数根据当前状态渲染一个带有条件类名的 `<div />` 元素：
- en: '[PRE53]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '`App.scss` uses the `overlay` class to display a dark overlay behind the navigation
    menu only when it''s open:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`App.scss` 使用 `overlay` 类在导航菜单打开时在其后面显示一个深色覆盖层：'
- en: '[PRE54]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Notice how the `transition` property is defined for both  `.App:after`  and  `.App.overly:after`,
    the former includes a transition on the `transform` property with a `450ms` delay
    while the latter removes that transition. This has the effect of allowing a smooth
    transition even when the menu is closed.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `transition` 属性是如何在 `.App:after` 和 `.App.overlay:after` 上定义的，前者在 `transform`
    属性上包含一个 `450ms` 的延迟过渡，而后者则移除了这个过渡。这允许在菜单关闭时也能实现平滑过渡。
- en: Bindings
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定
- en: 'Let''s inspect the binding to JavaScript''s `require` function at the top of `App.re`. Since
    we''re going to dive deeper into BuckleScript in [Chapter 4](201d7348-8175-4caf-b4f3-285b669b9cf1.xhtml),
    *BuckleScript, Belt, and Interoperability*, let''s defer discussing the details
    and just briefly see what this binding is doing:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查 `App.re` 顶部对 JavaScript 的 `require` 函数的绑定。由于我们将在第 4 章 [BuckleScript, Belt,
    and Interoperability](201d7348-8175-4caf-b4f3-285b669b9cf1.xhtml) 中更深入地探讨 BuckleScript，让我们先暂时不讨论细节，只简要看看这个绑定做了什么：
- en: '[PRE55]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `external` keyword creates a new binding, similar to the `let` keyword.
    After binding to JavaScript''s `require` function, we can use it in Reason, as
    long as we''re using the BuckleScript compiler. We use it to require `App.scss`
    as well as a few images. Inspecting the compiled output at `lib/es6/src/App.bs.js`
    shows that the preceding Reason code compiles to the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`external` 关键字创建了一个新的绑定，类似于 `let` 关键字。绑定到 JavaScript 的 `require` 函数后，只要我们使用
    BuckleScript 编译器，我们就可以在 Reason 中使用它。我们用它来引入 `App.scss` 以及一些图片。检查 `lib/es6/src/App.bs.js`
    中的编译输出显示，前面的 Reason 代码编译成了以下内容：'
- en: '[PRE56]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Webpack handles the rest from there.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack 从那里处理其余部分。
- en: Events
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件
- en: Since the top-level `<div />` element has a click event handler that always
    closes the menu, any clicks on its children also fire that top-level click event
    handler. To allow the menu to open (or remain open), we need to call `event.stopPropagation()`
    on click events for some of its child elements.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 由于顶级 `<div />` 元素有一个始终关闭菜单的点击事件处理器，因此对其子元素的任何点击也会触发该顶级点击事件处理器。为了允许菜单打开（或保持打开），我们需要在部分子元素的点击事件上调用
    `event.stopPropagation()`。
- en: 'In ReasonReact, we can do this with the `ReactEvent` module:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ReasonReact 中，我们可以使用 `ReactEvent` 模块来做这件事：
- en: '[PRE57]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `ReactEvent` module has submodules corresponding to each of ReactJS''s
    synthetic events:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReactEvent` 模块有与 ReactJS 的每个合成事件对应的子模块：'
- en: Clipboard events
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剪贴板事件
- en: Composition events
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合事件
- en: Keyboard events
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键盘事件
- en: Focus events
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 焦点事件
- en: Form events
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单事件
- en: Mouse events
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鼠标事件
- en: Pointer events
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针事件
- en: Selection events
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择事件
- en: Touch events
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触摸事件
- en: UI events
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI 事件
- en: Wheel events
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滚轮事件
- en: Media events
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 媒体事件
- en: Image events
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图片事件
- en: Animation events
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画事件
- en: Transition events
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过渡事件
- en: For more information on ReactJS's synthetic events, visit [https://reactjs.org/docs/events.html](https://reactjs.org/docs/events.html).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于 ReactJS 的合成事件的信息，请访问 [https://reactjs.org/docs/events.html](https://reactjs.org/docs/events.html)。
- en: To get values such as `event.changedTouches.item(0).clientX` from a touch event,
    we use a combination of ReasonReact and BuckleScript.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要从触摸事件中获取 `event.changedTouches.item(0).clientX` 这样的值，我们使用 ReasonReact 和 BuckleScript
    的组合。
- en: Js.t Object
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Js.t 对象
- en: BuckleScript allows us to access arbitrary JavaScript object fields using the
    `##` syntax. We can use syntax on any `Js.t` type, which is a Reason type for
    arbitrary JavaScript objects. We'll learn more about this and other interoperability
    features in [Chapter 4](201d7348-8175-4caf-b4f3-285b669b9cf1.xhtml), *BuckleScript,
    Belt, and Interoperability*.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: BuckleScript 允许我们使用 `##` 语法访问任意 JavaScript 对象字段。我们可以使用任何 `Js.t` 类型，这是一个表示任意
    JavaScript 对象的 Reason 类型。我们将在 [第 4 章](201d7348-8175-4caf-b4f3-285b669b9cf1.xhtml)，*BuckleScript,
    Belt, 和互操作性* 中了解更多关于这一点和其他互操作性功能。
- en: 'Since `ReactEvent.Touch.changedTouches(event)` returns a plain old JavaScript
    object, we can access its fields using the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `ReactEvent.Touch.changedTouches(event)` 返回一个普通的 JavaScript 对象，我们可以使用以下方式访问其字段：
- en: '[PRE58]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Looking in the compiled output, we see that it is what we want:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译输出中查看，我们看到这正是我们想要的：
- en: '[PRE59]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We'll use this to add the touch feature to our menu so that users can swipe
    the menu closed and see the menu move as they swipe.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个功能将触摸功能添加到我们的菜单中，以便用户可以滑动菜单关闭，并看到菜单在滑动时移动。
- en: Adding actions
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加动作
- en: 'Let''s start by adding actions for `TouchStart`, `TouchMove`, and `TouchEnd`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从添加 `TouchStart`、`TouchMove` 和 `TouchEnd` 的动作开始：
- en: '[PRE60]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We'll need the touch event's `clientX` property only for `TouchStart` and `TouchMove`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要在 `TouchStart` 和 `TouchMove` 中使用触摸事件的 `clientX` 属性。
- en: 'Let''s add the event listeners on the top-level `<div />` component:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在顶层 `<div />` 组件上添加事件监听器：
- en: '[PRE61]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In our reducer, let''s just log those `clientX` values for now:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 reducer 中，现在我们只记录那些 `clientX` 值：
- en: '[PRE62]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: To figure out the overall direction of a user's swipe, we need the first and
    last `clientX` values for that swipe. The menu should move in proportion to the
    difference of the first and last `clientX` values, but only if the user is swiping
    in the direction that would close the menu.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定用户滑动的整体方向，我们需要该滑动的第一个和最后一个 `clientX` 值。菜单应该按照第一个和最后一个 `clientX` 值的差值成比例移动，但只有当用户向关闭菜单的方向滑动时。
- en: 'Our state now includes a `touches` record that holds the value for the first
    and last `clientX` values:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的状态现在包含一个 `touches` 记录，它保存了第一个和最后一个 `clientX` 值：
- en: '[PRE63]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Since we cannot nest record type definitions, we define the `touches` type separately
    and include it in `state`. You'll notice `state.touches.first` is of type `option(float)`
    because it's possible that the user isn't using a touch device or that the user
    hasn't yet interacted.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们无法嵌套记录类型定义，我们单独定义了 `touches` 类型并将其包含在 `state` 中。你会注意到 `state.touches.first`
    是 `option(float)` 类型，因为用户可能没有使用触摸设备，或者用户还没有进行交互。
- en: 'Changing the shape of our state requires us to also change the initial state:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 改变我们状态的结构需要我们同时改变初始状态：
- en: '[PRE64]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In the reducer, if the menu is open, we update `state.touches` with a fresh
    new record in the `TouchStart` case, but in the `TouchMove` case, we only update
    `state.touches.last`. If the menu is not currently open, `ReasonReact.NoUpdate` is
    returned:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在 reducer 中，如果菜单是打开的，我们在 `TouchStart` 情况下使用一个新的记录更新 `state.touches`，但在 `TouchMove`
    情况下，我们只更新 `state.touches.last`。如果菜单当前没有打开，则返回 `ReasonReact.NoUpdate`：
- en: '[PRE65]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We'll soon use this state to conditionally set an inline style on the `<nav
    />` element.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快将使用这个状态来有条件地设置 `<nav />` 元素的内联样式。
- en: Inline styles
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内联样式
- en: 'In ReasonReact, we can add inline styles via `ReactDOMRe.Style.make`, which
    accepts CSS properties as optional labelled arguments. Since they are all optional,
    passing `unit` is necessary to call the function:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ReasonReact 中，我们可以通过 `ReactDOMRe.Style.make` 添加内联样式，它接受 CSS 属性作为可选的标签化参数。由于它们都是可选的，传递
    `unit` 是必要的来调用该函数：
- en: '[PRE66]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Applying this to our `<nav />` element, we can conditionally add a style if
    we have both a first and last touch in state:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 将此应用于我们的 `<nav />` 元素，如果我们有状态中的第一个和最后一个触摸，我们可以有条件地添加一个样式：
- en: '[PRE67]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Within the `transform` property, we concatenate with `"0px"` instead of just
    `"px"` since the `float` type always includes a decimal point, but it''s possible
    that the user swipes a distance of exactly one hundred pixels, and `transform:
    translateX(100.px)` is not valid CSS, but `transform: translateX(100.0px)` is.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '在 `transform` 属性中，我们使用 `"0px"` 而不是仅仅 `"px"` 进行拼接，因为 `float` 类型总是包含小数点，但用户可能滑动了一个正好为一百像素的距离，`transform:
    translateX(100.px)` 不是一个有效的 CSS，但 `transform: translateX(100.0px)` 是。'
- en: 'Running this on a touch device shows that we''re able to get the menu''s position
    to change based on the user''s swipe. Now, let''s focus on the `TouchEnd` case
    within the reducer. For now, let''s set the menu to remain open if the user swipes
    the menu less than half way closed, and close it otherwise. If `state.touches.last` is `None`,
    then the user did not swipe, and we don''t update `state`:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在触摸设备上运行此代码显示，我们能够根据用户的滑动改变菜单的位置。现在，让我们专注于 reducer 中的 `TouchEnd` 情况。目前，让我们设置如果用户将菜单滑动不到一半就保持打开，否则关闭它。如果
    `state.touches.last` 是 `None`，则用户没有滑动，我们不更新 `state`：
- en: '[PRE68]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Notice that we reset `state.touches` to a fresh new record with `{first: None,
    last: None}`, which results in an empty style prop on the `<nav />` element.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '注意我们将 `state.touches` 重置为一个新的记录 `{first: None, last: None}`，这导致 `<nav />` 元素上的样式属性为空。'
- en: This current implementation assumes that the width of the navigation is `300px`.
    Instead of assuming, we can use a React ref to get a reference to the DOM node,
    and then get its `clientWidth`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当前实现假设导航的宽度为 `300px`。而不是假设，我们可以使用 React 引用来获取 DOM 节点的引用，然后获取它的 `clientWidth`。
- en: React ref
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React 引用
- en: 'The React ref is just an instance variable of `state`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: React 引用只是 `state` 的一个实例变量：
- en: '[PRE69]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We attach the React ref on the `<nav />` element by setting the `ref` property
    to the result of `self.handle((ref, self) => ...)`:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将 `ref` 属性设置为 `self.handle((ref, self) => ...)` 的结果，在 `<nav />` 元素上附加 React
    引用：
- en: '[PRE70]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Since a React ref could be `null` in JavaScript, we convert it to an option
    and pattern match on its value.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 React 引用在 JavaScript 中可能是 `null`，我们将它转换为选项并对它的值进行模式匹配。
- en: The type of the React ref depends on whether it is a DOM element or a React
    component. The former's type is `Dom.element`, and the latter's is `ReasonReact.reactRef`.
    To convert a `ReasonReact.reactRef` to a JavaScript object, use `ReasonReact.refToJsObj`
    instead of `ReactDOMRe.domElementToObj`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: React 引用的类型取决于它是一个 DOM 元素还是一个 React 组件。前者的类型是 `Dom.element`，后者的类型是 `ReasonReact.reactRef`。要将
    `ReasonReact.reactRef` 转换为 JavaScript 对象，请使用 `ReasonReact.refToJsObj` 而不是 `ReactDOMRe.domElementToObj`。
- en: Then, in the reducer, we can use `state.width` instead of `300.0` as the menu's
    width. Since the `TouchStart` and `TouchMove` actions always update state when
    the menu is open, the `<App />` component is always re-rendered, which causes
    our React ref function to re-run, and we can be reasonably sure that the menu's
    width is always correct.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 reducer 中，我们可以使用 `state.width` 而不是 `300.0` 作为菜单的宽度。由于 `TouchStart` 和 `TouchMove`
    动作在菜单打开时总是更新状态，因此 `<App />` 组件总是重新渲染，这导致我们的 React 引用函数重新运行，我们可以合理地确信菜单的宽度始终是正确的。
- en: Velocity
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 速度
- en: 'To get the velocity of a user''s swipe, we''ll need to also store the current
    time along with the touch event''s `clientX`. Let''s bind to the browser''s `performance.now()`
    method:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取用户滑动速度，我们需要存储当前时间以及触摸事件的 `clientX`。让我们绑定到浏览器的 `performance.now()` 方法：
- en: '[PRE71]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'And we''ll make some room for the touch''s current time in the `touches` type:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `touches` 类型中为触摸的当前时间留出一些空间：
- en: '[PRE72]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: In the reducer, we then change `Some(clientX)` to `Some((clientX, now()))`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在 reducer 中，我们将 `Some(clientX)` 更改为 `Some((clientX, now()))`。
- en: 'Now, we can calculate the velocity of a user''s swipe in the `TouchEnd` case:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在 `TouchEnd` 情况下计算用户滑动的速度：
- en: '[PRE73]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: A velocity of `-0.3` pixels per millisecond feels right to me, but feel free
    to use whatever feels right for you.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`-0.3` 像素每毫秒的速度对我来说感觉是正确的，但请随意使用您觉得合适的感觉。'
- en: Notice how we can use pattern matching to destructure `(x, t)`, which creates
    two bindings in scope. Also, `x'` is a valid name for a binding in Reason and
    is commonly pronounced *x prime*. Lastly, notice how our state is shadowed to
    prevent writing duplicate code.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何可以使用模式匹配来解构 `(x, t)`，这会在作用域中创建两个绑定。此外，`x'` 是 Reason 中一个绑定的有效名称，通常读作 *x
    prime*。最后，注意我们的状态是如何被阴影覆盖以防止编写重复代码的。
- en: 'To finish the velocity feature, we update the `style` property in the render
    function to treat both `state.touches.first` and `state.touches.last` as tuples:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成速度功能，我们在渲染函数中更新 `style` 属性，将 `state.touches.first` 和 `state.touches.last`
    都视为元组：
- en: '[PRE74]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Now, when open, the menu responds nicely to a touch—super cool!
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当打开时，菜单对触摸反应良好——超级酷！
- en: Client-side routing
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端路由
- en: 'ReasonReact comes with a built-in router found in the `ReasonReact.Router`
    module. It is quite unopinionated and therefore flexible. The public API has only
    four functions:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ReasonReact 包含一个内置的路由器，位于 `ReasonReact.Router` 模块中。它相当无偏见，因此很灵活。公共 API 只包含四个函数：
- en: '`ReasonReact.Router.watchUrl: (url => unit) => watcherID`'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReasonReact.Router.watchUrl: (url => unit) => watcherID`'
- en: '`ReasonReact.Router.unwatchUrl: watcherID => unit`'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReasonReact.Router.push: string => unit`'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReasonReact.Router.dangerouslyGetInitialUrl: unit => url`'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `watchUrl` function starts watching the URL for changes. When changed, the
    `url => unit` callback is called. The `unwatchUrl` function stops watching the
    URL.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: The `push` function sets the URL, and the `dangerouslyGetInitialUrl` function
    gets a record of type `url`. The `dangerouslyGetInitialUrl` function is meant
    to be used only within the `didMount` lifecycle hook, alongside `watchUrl`, to
    prevent issues with stale information.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'The `url` type is defined as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: We'll learn more about the `list` type constructor in [Chapter 4](201d7348-8175-4caf-b4f3-285b669b9cf1.xhtml),
    *BuckleScript, Belt, and Interoperability*. The `path` field in the `url` record
    is of type `list(string)`. If the value of `window.location.pathname` is `"/book/title/edit"`,
    the value of `url.path` will be `["book", "title", "edit"]`, which is a list of
    strings. The syntax makes it look like a JavaScript array, but there are some
    differences. Briefly, Reason lists are singly linked lists that are immutable
    and homogeneous, meaning all elements must be of the same type.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: The `watcherID` type is an **abstract type**. We'll learn more about abstract
    types in [Chapter 6](a6ac6581-d3bd-49f3-ad4d-bfed965287ca.xhtml),  *CSS-in-JS
    (in Reason)*. The only way to get a value of type `watcherID` is as the return
    value of `ReasonReact.Router.watchUrl`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a router component that wraps our `<App />` component and provides
    it with a `currentRoute` prop. What follows was inspired by an example from Khoa
    Nguyen (`@thangngoc89`).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create placeholder components for `<Home />`, `<Page1 />`, `<Page2
    />`, and `<Page3 />`. Then, within `Router.re`, let''s create a type that represents
    a route along with a list of routes:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Each route has an `href`, `title`, and an associated `component`, which will
    be rendered within `<App />` if that route is the current route.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Current route
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In `Index.re`, let''s wrap `<App />` within a router component that provides
    the `currentRoute` prop:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'In `Router.re`, we define three components—`<WithRouter />`, `<Link />`, and
    `<NavLink />`—using the `module` syntax. Since each file is also a module, those
    three components are nested under the `Router` module, and in `Index.re` we need
    to tell the compiler to look for `<WithRouter />` within the `Router` module:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: We've seen all of these concepts before. `<WithRouter />` is just a reducer
    component. The component's state is the same route type defined earlier and there
    is only one action to change the route. Once `<WithRouter />` is mounted, `ReasonReact.Router`
    begins watching the URL, and whenever it changes, the `ChangeRoute` action is
    triggered, which calls the reducer, which then updates state, which then re-renders
    `<App />` with an updated `currentRoute` prop.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure that our menu closes whenever `<App />` receives a fresh `currentRoute`
    prop, we add a `willReceiveProps` lifecycle hook for `<App />`:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保每次 `<App />` 接收到新的 `currentRoute` 属性时，我们的菜单都会关闭，我们为 `<App />` 添加了一个 `willReceiveProps`
    生命周期钩子：
- en: '[PRE79]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Helper functions
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 辅助函数
- en: 'Since `url.path` of `ReasonReact.Router` is a list of strings, and our `Router.route.href`
    is a string, we need a way to convert from string to a list of strings:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `ReasonReact.Router` 的 `url.path` 是一个字符串列表，而我们的 `Router.route.href` 是一个字符串，我们需要一种方法将字符串转换为字符串列表：
- en: '[PRE80]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: We'll discuss Reason's pipe operator (`|>`) and JavaScript interoperability in
    [Chapter 4](201d7348-8175-4caf-b4f3-285b669b9cf1.xhtml), *BuckleScript, Belt,
    and Interoperability*.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 4 章 [BuckleScript、Belt 和互操作性](201d7348-8175-4caf-b4f3-285b669b9cf1.xhtml)
    中讨论 Reason 的管道操作符 (`|>`) 和 JavaScript 互操作性。
- en: 'We also need a way to convert a `url` to a `route` for use in initial state,
    as well as within the callback function of `watchUrl`:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一种方法将 `url` 转换为 `route`，用于初始状态以及 `watchUrl` 的回调函数中：
- en: '[PRE81]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: In [Chapter 4](201d7348-8175-4caf-b4f3-285b669b9cf1.xhtml), *BuckleScript, Belt,
    and Interoperability*, we will dive deeper into BuckleScript, Belt, and JavaScript
    interoperability. The `urlToRoute` function tries to find a `route` within the
    `routes` list whose `url.path` is structurally equal to `route.href` after it's
    converted to a list of strings.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 4 章 [BuckleScript、Belt 和互操作性](201d7348-8175-4caf-b4f3-285b669b9cf1.xhtml)
    中，我们将更深入地探讨 BuckleScript、Belt 和 JavaScript 互操作性。`urlToRoute` 函数尝试在 `routes` 列表中找到一个
    `route`，其 `url.path` 在转换为字符串列表后与 `route.href` 结构上相等。
- en: If no such `route` exists, it returns the first `route` from the `routes` list,
    which is the one associated with the `<Home />` component. Otherwise, the matching
    `route` is returned.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不存在这样的 `route`，它将返回 `routes` 列表中的第一个 `route`，这是与 `<Home />` 组件关联的。否则，返回匹配的
    `route`。
- en: 'The `<Link />` component is a simple stateless component that renders an anchor
    link. Note how the click handler prevents the default browser behavior and updates
    the URL:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`<Link />` 组件是一个简单的无状态组件，用于渲染锚点链接。注意点击处理程序如何阻止默认的浏览器行为并更新 URL：'
- en: '[PRE82]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The `<NavLink />` component wraps the `<Link />` component, and is provided
    with the current route as a prop that it uses to conditionally set an `active`
    class:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`<NavLink />` 组件包装了 `<Link />` 组件，并提供了当前路由作为属性，它使用该属性有条件地设置一个 `active` 类：'
- en: '[PRE83]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Usage
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用方法
- en: 'Now that we''ve defined the router, we can rewrite our navigation menu links
    to use the `<NavLink />` component instead of the raw anchor link directly:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了路由器，我们可以将我们的导航菜单链接重写为使用 `<NavLink />` 组件而不是直接使用原始的锚点链接：
- en: '[PRE84]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Wherever we want to display the current page''s title, we can simply access
    the `title` field on the current route:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们想在何处显示当前页面的标题，我们都可以简单地访问当前路由上的 `title` 字段：
- en: '[PRE85]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'And, we can render a route''s associated component in a similar way:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以以类似的方式渲染与路由关联的组件：
- en: '[PRE86]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: It's important to emphasize that ReasonReact's router does not dictate what
    the callback of `watchUrl` should do. In our case, we trigger an action that updates
    the current route, which is just an arbitrary record. It's completely reasonable
    for the route type to be something entirely different. Also, there is no law that
    says the router should be the top-level component. There is a lot of room for
    creativity here and I'm personally excited to see what the community comes up
    with.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 强调这一点很重要，即 ReasonReact 的路由器并不规定 `watchUrl` 的回调应该做什么。在我们的例子中，我们触发一个更新当前路由的动作，这只是一个任意的记录。路由类型完全不同是完全合理的。也没有法律规定路由器应该是顶级组件。这里有很大的创意空间，我个人很期待看到社区会提出什么。
- en: Summary
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how ReasonReact is a simpler, safer way to build React
    components. Having Reason's type system enforcing correct component usage at compile
    time is a huge win. Also, it makes refactoring safer, cheaper, and a much more
    pleasant experience. ReasonReact is *just* Reason, much like how ReactJS is *just*
    JavaScript. All of what we've done so far is just Reason and ReasonReact without
    any third-party libraries such as Redux or React Router.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了 ReasonReact 是构建 React 组件的一种更简单、更安全的方法。Reason 的类型系统在编译时强制执行正确的组件使用，这是一个巨大的胜利。它还使重构更安全、更便宜，并且体验更加愉快。ReasonReact
    就是 Reason，就像 ReactJS 就是 JavaScript 一样。我们迄今为止所做的一切都是 Reason 和 ReasonReact，没有任何第三方库，如
    Redux 或 React Router。
- en: As we'll see in [Chapter 4](201d7348-8175-4caf-b4f3-285b669b9cf1.xhtml), *BuckleScript,
    Belt, and Interoperability*, we also have the option to use existing JavaScript
    (and ReactJS) solutions within Reason. After getting more comfortable with BuckleScript,
    the Belt standard library, and JavaScript interoperability, we'll add route transitions.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第4章](201d7348-8175-4caf-b4f3-285b669b9cf1.xhtml)，“BuckleScript、Belt和互操作性”中所见，我们也有在Reason中使用现有的JavaScript（和ReactJS）解决方案的选项。在更加熟悉BuckleScript、Belt标准库和JavaScript互操作性之后，我们将添加路由转换。
