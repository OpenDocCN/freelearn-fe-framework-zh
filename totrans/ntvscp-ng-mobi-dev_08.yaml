- en: Building an Audio Recorder
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 Audio Recorder
- en: Recording audio is the most performance-intensive operation our app must handle.
    It is also the one feature where having access to native APIs will be the most
    rewarding. We want our users to be able to record with the lowest latency possible
    for the mobile device in order to achieve the highest fidelity of sound. Additionally,
    this recording should optionally happen over the top of an existing mix of pre-recorded
    tracks all playing in sync .
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 录音是我们应用必须处理的性能最密集的操作。它也是拥有访问原生API将最有回报的功能之一。我们希望用户能够以尽可能低的延迟记录，以实现最高的音质保真度。此外，此录音可以选择性地在现有的同步播放的预录音轨混合之上发生。
- en: Since this phase of our app development will dive the deepest into platform-specific
    native APIs, we will split our implementations into two phases. We will first
    build out the iOS-specific details of the recording features, followed by Android.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们应用开发的这一阶段将最深入地挖掘平台特定的原生API，我们将我们的实现分为两个阶段。我们首先构建记录功能的iOS特定细节，然后是Android。
- en: 'In this chapter, we will cover the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Building a feature rich cross-platform audio recorder for iOS and Android with
    a consistent API
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一致的API为iOS和Android构建功能丰富的跨平台音频录音器
- en: Integrating iOS framework libraries, such as AudioKit ([http://audiokit.io](http://audiokit.io)),
    which was built entirely with Swift
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成iOS框架库，例如完全用Swift构建的AudioKit ([http://audiokit.io](http://audiokit.io))
- en: How to convert Swift/Objective C methods to NativeScript
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将 Swift/Objective C 方法转换为 NativeScript
- en: Building custom reusable NativeScript view components based on native APIs,
    as well as how to use them inside Angular
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于 native APIs 构建 custom reusable NativeScript 视图组件，以及如何在 Angular 中使用它们
- en: Configuring a reusable Angular Component that can both be used via routing and opened
    via a popup modal
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置一个可重用的Angular组件，该组件可以通过路由使用，也可以通过弹出模态打开
- en: Integrate Android Gradle libraries
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成Android Gradle库
- en: How to convert Java methods to NativeScript
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将Java方法转换为NativeScript
- en: Using multiple item templates with NativeScript's ListView
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 NativeScript 的 ListView 与多个项目模板
- en: Phase 1 – Building an audio recorder for iOS
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一阶段 – 为iOS构建音频录音器
- en: The audio capabilities of the iOS platform are impressive, to say the least.
    A group of wonderfully talented audiophiles and software engineers have collaborated
    on building an open source framework layer on top of the platform's audio stack. This
    world class engineering effort is the awe inspiring AudioKit ([http://audiokit.io/](http://audiokit.io/)),
    led by the fearless Aurelius Prochazka, a true pioneer in audio technology.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: iOS平台的音频功能令人印象深刻。一群才华横溢的音频爱好者和软件工程师合作，在平台的音频堆栈之上构建了一个开源框架层。这一世界级的工程努力是令人敬畏的
    AudioKit ([http://audiokit.io/](http://audiokit.io/))，由无畏的 Aurelius Prochazka
    领导，他是音频技术的真正先驱。
- en: The AudioKit framework is written entirely with Swift, which introduces a couple
    of interesting surface-level challenges when integrating with NativeScript.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: AudioKit 框架完全用 Swift 编写，当与 NativeScript 集成时，引入了一些有趣的表面级挑战。
- en: Challenge detour – Integrate Swift based library into NativeScript
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挑战绕行 – 将基于 Swift 的库集成到 NativeScript 中
- en: "At the time of this writing, NativeScript can work with Swift if the codebase properly\
    \ exposes the classes and types to Objective-C via what's called a **bridging\
    \ header**, allowing both the languages to be mixed or matched. You can learn\
    \ more about what a bridging header is here: [https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html](https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html).\
    \ [](https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html)\
    \ This bridging header is auto generated when the Swift codebase is compiled into\
    \ a framework. Swift offers rich language features, some of which do not have\
    \ a direct correlation to Objective C. Full featured support for the latest Swift\
    \ language enhancements will likely come to NativeScript eventually however at\
    \ the time of this writing there are a couple considerations to keep in mind.\uFEFF"
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，如果代码库通过所谓的桥接头正确地将类和类型暴露给 Objective-C，NativeScript 可以与 Swift 一起工作。你可以在这里了解更多关于桥接头的信息：[https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html](https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html)。
    [](https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html)
    这个桥接头在 Swift 代码库编译成框架时自动生成。Swift 提供了丰富的语言特性，其中一些与 Objective C 没有直接关联。然而，在撰写本文时，可能需要考虑一些因素，尽管
    NativeScript 最终可能会提供对最新 Swift 语言增强的全面支持。
- en: 'AudioKit utilizes the best of what the Swift language has to offer, including
    enriched **enum** capabilities. You can learn more about the expanded enum features
    in the Swift language here:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: AudioKit 利用 Swift 语言所能提供的最佳特性，包括增强的 `enum` 功能。你可以在这里了解更多关于 Swift 语言中扩展的 `enum`
    功能：
- en: '[https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html)'
- en: 'In particular, there is this from the documentation: "t*hey adopt many features
    traditionally supported only by classes, such as computed properties to provide
    additional information about the enumeration’s current value, and instance methods
    to provide functionality related to the values the enumeration represents.*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是在文档中有这样的描述：“它们采用了许多传统上仅由类支持的特性，例如计算属性，以提供有关枚举当前值的额外信息，以及实例方法，以提供与枚举表示的值相关的功能。”
- en: Such *enums* are foreign to Objective C and, therefore, cannot be made available
    in the bridging header. Any code that uses Swift's exotic *enums* will be simply
    ignored when the bridging header is generated at compile time, resulting in Objective
    C not being able to interact with those sections of the code. This means you will
    not be able to use a method from a Swift codebase in NativeScript which utilizes
    these enhanced constructs out of the box (*at the time of this writing*).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这种 `enum` 在 Objective C 中是陌生的，因此不能在桥接头中提供。任何使用 Swift 的异构 `enum` 的代码在编译时生成桥接头时将被简单地忽略，导致
    Objective C 无法与这些代码部分交互。这意味着你将无法在 NativeScript 中使用 Swift 代码库中的方法，这些方法直接使用这些增强结构（*在撰写本文时*）。
- en: 'To remedy this, we will fork the AudioKit framework and flatten the exotic
    enums used in the `AKAudioFile` extension files, which provide a powerful and
    convenient export method we will want to use to save our recorded audio files.
    The exotic *enum* we need to modify looks like this ([https://github.com/audiokit/AudioKit/blob/master/AudioKit/Common/Internals/Audio%20File/AKAudioFile%2BProcessingAsynchronously.swift](https://github.com/audiokit/AudioKit/blob/master/AudioKit/Common/Internals/Audio%20File/AKAudioFile%2BProcessingAsynchronously.swift)):'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '为了解决这个问题，我们将分叉 AudioKit 框架，并将 `AKAudioFile` 扩展文件中使用的异构枚举扁平化，这些扩展文件提供了一个强大且方便的导出方法，我们希望用它来保存我们的录音音频文件。我们需要修改的异构
    `enum` 看起来是这样的 ([https://github.com/audiokit/AudioKit/blob/master/AudioKit/Common/Internals/Audio%20File/AKAudioFile%2BProcessingAsynchronously.swift](https://github.com/audiokit/AudioKit/blob/master/AudioKit/Common/Internals/Audio%20File/AKAudioFile%2BProcessingAsynchronously.swift)):'
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is unlike any *enum* you may be familiar with; as you can see, it includes
    properties in addition to what enums have. When this code is compiled and the
    bridging header is generated to mix or match with Objective-C, the bridging header will
    then exclude any code that uses this construct. We will flatten this out to look
    like the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这与您可能熟悉的任何*枚举*不同；如您所见，它除了枚举拥有的属性外还包括其他属性。当此代码编译并生成桥接头与Objective-C混合或匹配时，桥接头将排除使用此构造的任何代码。我们将将其扁平化，如下所示：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We will then adjust the portions of the `AKAudioFile` extension to use our flattened
    properties. This will allow us to manually build `AudioKit.framework` we can use
    in our app, exposing the method we want to use: `exportAsynchronously`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将调整`AKAudioFile`扩展的部分，以使用我们的扁平化属性。这将允许我们手动构建可以在应用中使用的`AudioKit.framework`，暴露我们想要使用的方法：`exportAsynchronously`。
- en: We won't go over the details of manually building `AudioKit.framework`, as it
    is well documented here: [https://github.com/audiokit/AudioKit/blob/master/Frameworks/INSTALL.md#building-universal-frameworks-from-scratch](https://github.com/audiokit/AudioKit/blob/master/AudioKit/Common/Internals/Audio%20File/AKAudioFile%2BProcessingAsynchronously.swift).
    With our custom-built framework, we are now ready to integrate it into our app.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细介绍手动构建`AudioKit.framework`的细节，因为它在这里有很好的文档：[https://github.com/audiokit/AudioKit/blob/master/Frameworks/INSTALL.md#building-universal-frameworks-from-scratch](https://github.com/audiokit/AudioKit/blob/master/AudioKit/Common/Internals/Audio%20File/AKAudioFile%2BProcessingAsynchronously.swift)。使用我们自定义构建的框架，我们现在已准备好将其集成到我们的应用中。
- en: Integrating a custom-built iOS framework into NativeScript
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将自定义构建的iOS框架集成到NativeScript
- en: 'We can now create an internal plugin to integrate this iOS framework into our
    app. Take the custom `AudioKit.framework` we have built and create a `nativescript-audiokit` directory
    at the root of our app. We then add a `platforms/ios` folder inside to drop the
    framework into. This will let NativeScript know how to build these iOS-specific
    files into the app. As we want this internal plugin to be treated like any standard
    npm plugin, we will also add `package.json` directly inside the `nativescript-audiokit`
    folder with the following contents:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建一个内部插件，将这个iOS框架集成到我们的应用中。将我们构建的定制`AudioKit.framework`放入我们应用的根目录下创建一个`nativescript-audiokit`目录。然后我们在其中添加一个`platforms/ios`文件夹，将框架放入。这将让NativeScript知道如何将这些iOS特定文件构建到应用中。由于我们希望这个内部插件像任何标准npm插件一样被处理，我们还将直接在`nativescript-audiokit`文件夹中添加`package.json`文件，内容如下：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will now use the following command to add it to our app (NativeScript will
    look locally first and find the **nativescript-audiokit** plugin):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将使用以下命令将其添加到我们的应用中（NativeScript将首先在本地查找，然后找到**nativescript-audiokit**插件）：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will properly add the custom-built iOS framework into our app.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这将正确地将自定义构建的iOS框架添加到我们的应用中。
- en: 'However, we need two more very important items:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还需要两个非常重要的项目：
- en: 'Since AudioKit is a Swift-based framework, we want to ensure our app includes
    the proper supporting Swift libraries. Add a new file, `nativescript-audiokit/platforms/ios/build.xcconfig`:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于AudioKit是基于Swift的框架，我们希望确保我们的应用包含适当的支持Swift库。添加一个新文件，`nativescript-audiokit/platforms/ios/build.xcconfig`：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Since we will be engaging with the user''s microphone, we will want to ensure
    the microphone usage is indicated in our app''s property list. We will also take
    this opportunity to add two additional property settings to enhance our app''s
    abilities. So, in total, we will add three property keys for the following purposes:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将使用用户的麦克风，我们希望确保在应用属性列表中指示麦克风的使用。我们也将借此机会添加两个额外的属性设置来增强我们应用的能力。因此，总共我们将添加三个属性键，用于以下目的：
- en: Let the device know our app needs access to the microphone and ensure the user's
    permission is requested on first access.
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让设备知道我们的应用需要访问麦克风，并确保在首次访问时请求用户的权限。
- en: Continue playing audio if the app is placed into the background.
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果应用被放置到后台，继续播放音频。
- en: Provide the ability to see the app's `documents` folder in iTunes when the phone
    is connected to a computer. This will allow you to view recorded files right inside
    of iTunes via the app's Documents. This could be useful for integration into a
    desktop audio editing software.
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当手机连接到计算机时，提供查看应用`documents`文件夹的能力。这将允许您通过应用文档直接在iTunes中查看记录的文件。这对于集成到桌面音频编辑软件可能很有用。
- en: 'Add a new file, `nativescript-audiokit/platforms/ios/Info.plist`, with the
    following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个新文件，`nativescript-audiokit/platforms/ios/Info.plist`，内容如下：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here is a screenshot to better illustrate the internal plugin structure in
    our app:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个截图，更好地说明了我们应用中内部插件的架构：
- en: '![](img/00036.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00036.jpeg)'
- en: 'Now, when NativeScript builds the iOS app, it will ensure `AudioKit.framework`
    is included as a library and merge the contents of `build.xcconfig` and `Info.plist`
    into our app''s configuration. Any time we make changes to the files inside this
    internal plugin folder (`nativescript-audiokit`), we want to ensure our app picks
    up those changes. To do so, we can simply remove and add the plugin back, so let''s
    do that now:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当 NativeScript 构建iOS应用时，它将确保 `AudioKit.framework` 被包含为一个库，并将 `build.xcconfig`
    和 `Info.plist` 的内容合并到我们的应用配置中。每次我们更改这个内部插件文件夹（`nativescript-audiokit`）内的文件时，我们都想确保我们的应用能够获取这些更改。为此，我们可以简单地移除并重新添加插件，所以现在让我们这么做：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We are now ready to build our audio recorder using the AudioKit API for iOS.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备使用 iOS 的 AudioKit API 来构建我们的音频录制器。
- en: Setting up native API type checking and generate AudioKit TypeScript definitions
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置原生 API 类型检查并生成 AudioKit TypeScript 定义
- en: 'The first thing we want to do is install `tns-platform-declarations`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先想做的事情是安装 `tns-platform-declarations`：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we create a new file in the root of the project called `references.d.ts`
    with the following contents:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在项目的根目录中创建一个名为 `references.d.ts` 的新文件，其内容如下：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This provides us with full type checking and intellisense support for iOS and
    Android APIs.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了对 iOS 和 Android API 的完整类型检查和智能感知支持。
- en: 'We now want to generate typings for the AudioKit framework itself. We can execute
    this command to generate the typings for the included `AudioKit.framework`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要为 AudioKit 框架本身生成类型定义。我们可以执行以下命令来生成包含的 `AudioKit.framework` 的类型定义：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We are setting the environment variable `TNS_TYPESCRIPT_DECLARATIONS_PATH` to
    the present working directory (`pwd`) with a folder prefix of `typings`. When
    NativeScript creates the iOS build, it will also generate type definition files
    for all the native APIs available to our app, including third-party libraries.
    We will now see a `typings` folder appear in our project, containing two folders:
    `i386` and `x86_64`. One is for the Simulator architecture and the other the device.
    Both will contain the same output, so we can just focus on one. Open the `i386`
    folder and you will find an `objc!AudioKit.d.ts` file.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在设置环境变量 `TNS_TYPESCRIPT_DECLARATIONS_PATH` 为当前工作目录（`pwd`），并带有 `typings` 文件夹前缀。当
    NativeScript 创建 iOS 构建时，它还将为我们的应用可用的所有原生 API 生成类型定义文件，包括第三方库。我们现在将看到在项目中出现一个 `typings`
    文件夹，其中包含两个文件夹：`i386` 和 `x86_64`。一个是用于模拟器架构的，另一个是用于设备的。两者都将包含相同的内容，所以我们可以只关注其中一个。打开
    `i386` 文件夹，你会找到一个 `objc!AudioKit.d.ts` 文件。
- en: 'We want to use only that file, so move it to the root of the `typings` folder:
    `typings/objc!AudioKit.d.ts`. We can then remove both the `i386` and `x86_64` folders,
    as we will no longer need them (the other API definition files are provided via
    `tns-platform-declarations`). We just generated these typings to get TypeScript
    definitions for the AudioKit library. This is a one-time thing, done to integrate
    easily with this native library, so you are safe to add this custom `typings`
    folder to source control.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只想使用那个文件，所以将其移动到 `typings` 文件夹的根目录：`typings/objc!AudioKit.d.ts`。然后我们可以删除 `i386`
    和 `x86_64` 文件夹，因为我们不再需要它们（其他 API 定义文件通过 `tns-platform-declarations` 提供）。我们只是生成这些类型定义来获取
    AudioKit 库的类型定义。这是一次性的事情，为了方便与这个本地库集成，所以你可以安全地将这个自定义 `typings` 文件夹添加到源控制中。
- en: 'Double-check `tsconfig.json` and ensure you have the `"skipLibCheck": true`
    option enabled. We can now modify our `references.d.ts` file to include the additional
    types for the AudioKit library:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '请再次检查 `tsconfig.json` 并确保已启用 `"skipLibCheck": true` 选项。我们现在可以修改我们的 `references.d.ts`
    文件，以包含 AudioKit 库的附加类型：'
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Our project structure should now look like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目结构现在应该看起来像这样：
- en: '![](img/00037.jpeg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00037.jpeg)'
- en: Build recorder with AudioKit
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 AudioKit 构建录制器
- en: We will begin by creating a model around our interaction with AudioKit's recording
    APIs. You could just start writing directly against these APIs right from your
    Angular component or service, but since we want to provide a consistent API across
    iOS and Android, there's a smarter way to architect this. Instead, we will abstract a
    simple API, usable across both platforms, which will tap into the correct native
    implementations under the hood.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个模型，围绕我们与 AudioKit 记录 API 的交互。你可以直接从你的 Angular 组件或服务开始直接编写针对这些 API 的代码，但由于我们希望提供跨
    iOS 和 Android 的一致 API，所以有一个更智能的方式来设计这个架构。相反，我们将抽象出一个简单的 API，可以在两个平台上使用，它将在底层调用正确的原生实现。
- en: 'There will be a lot of interesting details related to AudioKit going on here,
    but create `app/modules/recorder/models/record.model.ts` with the following and
    we will explain some of the bits in a moment:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里将会有很多与 AudioKit 相关的有趣细节，但请创建 `app/modules/recorder/models/record.model.ts`，如下所示，我们将在稍后解释一些细节：
- en: Later, we will add the `.ios.ts` suffix to this model, since it will contain
    iOS-specific implementation details. However, here in Phase 1, we will use the
    model directly (omitting the platform suffix) while we develop our iOS recorder.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将为此模型添加 `.ios.ts` 后缀，因为它将包含 iOS 特定的实现细节。然而，在第一阶段，我们将直接使用该模型（省略平台后缀）来开发我们的
    iOS 录音器。
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`RecordModel` will behave a bit like a state machine, where the only states
    it could be in are the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`RecordModel` 将表现得有点像状态机，它可能处于以下状态之一：'
- en: '`readyToRecord`: Default starting state. Must be in this state to enter the
    recording state.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readyToRecord`: 默认起始状态。必须处于此状态才能进入录音状态。'
- en: '`recording`: Quiet in the studio! Recording in process.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recording`: 工作室安静！正在录音中。'
- en: '`readyToPlay`: User has stopped recording and now has a recorded file to play
    back with the mix.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readyToPlay`: 用户停止了录音，现在有一个可以与混音一起播放的录音文件。'
- en: '`playing`: User is playing back the recorded file with the mix.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playing`: 用户正在播放带有混音的录音文件。'
- en: '`saved`: User chose to save the recording, that should kick off actions to
    save the new track with the active composition.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`saved`: 用户选择保存录音，这将启动保存新曲目与活动组合的操作。'
- en: '`finish`: Once the save actions are complete, the recorder should shut down.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`finish`: 保存操作完成后，记录器应关闭。'
- en: We then define the shape of the events the recorder will provide with `IRecordEvents`.
    In this case, we will have a single event, `stateChange`, which will notify any
    listeners when the state changes (*see the state setter*). Our model will extend
    NativeScript's `Observable` class (hence, `RecordModel extends Observable`), which
    will provide us with the notify API to dispatch our events.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着定义记录器将通过 `IRecordEvents` 提供的事件形状。在这种情况下，我们将有一个单独的事件，`stateChange`，当状态改变时会通知任何监听者（*参见状态设置器*）。我们的模型将扩展
    NativeScript 的 `Observable` 类（因此，`RecordModel extends Observable`），这将为我们提供通知 API
    来分发我们的事件。
- en: 'We then set up several references to the various AudioKit bits we will use.
    Most of what is designed is directly from this AudioKit example on recording:
    [https://github.com/audiokit/AudioKit/blob/master/Examples/iOS/RecorderDemo/RecorderDemo/ViewController.swift](https://github.com/audiokit/AudioKit/blob/master/Examples/iOS/RecorderDemo/RecorderDemo/ViewController.swift).
    We even use the same state enum setup (with a few extras). In their example, AudioKit''s `AKAudioPlayer`
    is used for playback; but, with our design, we will load our recorded files into our
    multitrack player design to play them back with our mix. We could work `AKAudioPlayer`
    into `TrackPlayerModel` for iOS; but, `TNSPlayer` (from the **nativescript-audio**
    plugin) is cross-platform compatible and will work just fine. We''ll cover the
    details of how we load these new recorded files into our design shortly, but notifying
    listeners of the recorder''s state will provide us all the flexibility we need
    to handle all that when we get there.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着设置了对我们将使用的各种 AudioKit 组件的多个引用。大部分设计直接来自这个 AudioKit 录音示例：[https://github.com/audiokit/AudioKit/blob/master/Examples/iOS/RecorderDemo/RecorderDemo/ViewController.swift](https://github.com/audiokit/AudioKit/blob/master/Examples/iOS/RecorderDemo/RecorderDemo/ViewController.swift)。我们甚至使用了相同的状态枚举设置（添加了一些额外的设置）。在他们示例中，使用了
    AudioKit 的 `AKAudioPlayer` 进行播放；但，在我们的设计中，我们将加载我们的录音文件到我们的多轨播放器设计中以进行播放。我们可以在
    iOS 的 `TrackPlayerModel` 中工作 `AKAudioPlayer`；但，`TNSPlayer`（来自 `nativescript-audio`
    插件）是跨平台兼容的，并且可以正常工作。我们将在稍后详细说明如何将这些新录音文件加载到我们的设计中，但通知监听者记录器的状态将为我们提供处理所有这些所需的所有灵活性。
- en: 'You may wonder why we type-cast this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么我们进行类型转换：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Good question. AudioKit provides Extensions to Core Foundation classes such
    as `AVAudioFile`. These were known as `Categories` in Objective C: [https://developer.apple.com/library/content/documentation/General/Conceptual/DevPedia-CocoaCore/Category.html](https://developer.apple.com/library/content/documentation/General/Conceptual/DevPedia-CocoaCore/Category.html);
    however, in Swift, they are referred to as `Extensions`: [https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Extensions.html](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Extensions.html).'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 好问题。AudioKit 为 Core Foundation 类如 `AVAudioFile` 提供扩展。这些在 Objective-C 中被称为 `Categories`：[https://developer.apple.com/library/content/documentation/General/Conceptual/DevPedia-CocoaCore/Category.html](https://developer.apple.com/library/content/documentation/General/Conceptual/DevPedia-CocoaCore/Category.html)；然而，在
    Swift 中，它们被称为 `Extensions`：[https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Extensions.html](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Extensions.html)。
- en: If you recall, we generated TypeScript definitions for AudioKit; but, we only
    kept the `objc!AudioKit.d.ts` file to reference. If we had looked in the foundation
    definitions, we would have seen the extension to `AVAudioFile`. However, since
    we did not keep those definitions around and instead are relying on the default
    `tns-platform-declarations` definitions, this `Extension` is not known to our
    TypeScript compiler, so we simply type-cast it, as we know AudioKit provides this.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，我们为 AudioKit 生成 TypeScript 定义；但我们只保留了 `objc!AudioKit.d.ts` 文件以供参考。如果我们查看基础定义，我们会看到对
    `AVAudioFile` 的扩展。然而，由于我们没有保留这些定义，而是依赖于默认的 `tns-platform-declarations` 定义，这个 `Extension`
    对我们的 TypeScript 编译器来说是未知的，所以我们简单地进行了类型转换，因为我们知道 AudioKit 提供了这个。
- en: 'It''s also critical `RecordModel` sets the audio session to `PlayAndRecord`,
    as this will allow us to record while playing our mix at the same time:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 同样重要的是 `RecordModel` 将音频会话设置为 `PlayAndRecord`，因为这将允许我们在播放混音的同时进行录音：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You may also be curious why some classes use `init()` and others `init(null)`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也好奇为什么一些类使用 `init()` 而另一些使用 `init(null)`：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Some of the initializers for AudioKit's classes take an optional argument, for
    example, `AKMixer` takes an optional `NSArray` of `AVAudioNode` to connect. However,
    our TypeScript definitions have those defined as required, so we are just passing
    `null` to that argument and instead using the `connect` node API directly.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: AudioKit 类的一些初始化器接受一个可选参数，例如，`AKMixer` 接受一个可选的 `NSArray` 参数，用于连接 `AVAudioNode`。然而，我们的
    TypeScript 定义将这些参数定义为必需的，所以我们只是传递 `null` 给这个参数，并直接使用 `connect` 节点 API。
- en: How to convert Swift/ObjC methods to NativeScript
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何将 Swift/ObjC 方法转换为 NativeScript
- en: 'The last point of interest from `RecordModel` might be the `save` method, which
    will export our recording from the app''s `tmp` directory to the app''s `documents`
    folder while converting it to the smaller filesize `.m4a` audio format:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 `RecordModel` 的最后一个有趣点可能是 `save` 方法，它将我们的录音从应用的 `tmp` 目录导出到应用的 `documents`
    文件夹，同时将其转换为更小的文件大小 `.m4a` 音频格式：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Long method name, right? Yes, indeed; some Swift/ObjC parameterized method
    names collapse to become very long. That particular method in Swift is defined
    as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 方法名很长，对吧？是的，确实如此；一些 Swift/ObjC 参数化方法名在合并时会变得非常长。Swift 中定义的特定方法如下：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Since we had the TypeScript definitions generated for AudioKit, they helped
    us out here. However, sometimes, you don't have that luxury. A Swift/ObjC method
    with various parameters for arguments collapse into each other while adding `With` in
    between the start of the method name and the start of the parameter argument names,
    while capitalizing the first character upon collapsing each.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们为 AudioKit 生成 TypeScript 定义，它们在这里帮了我们大忙。然而，有时你并没有这样的便利。在 Swift/ObjC 方法中，各种参数在方法名开始和参数名开始之间添加
    `With` 时会合并在一起，并且在合并时首字母大写。
- en: Building custom reusable NativeScript view for native audio Waveform display
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为原生音频波形显示构建自定义可重用 NativeScript 视图
- en: Instead of creating an Angular Component for our Waveform display, we will create
    a custom NativeScript view component, that taps into native APIs, that we can
    then register with Angular to use in our components. The reason for doing this
    is due to NativeScript's powerful `view` base class that we can extend, which
    provides a nice API when using underlying native APIs for the `view`. This Waveform
    display will work in tandem with the `RecordModel` we just created to bring to
    life our real-time Waveform feedback display of the device's microphone. It would
    also be amazing to reuse this Waveform display as a static audio file waveform
    rendering on our track list, as an alternate view for our main composition view.
    AudioKit provides classes and APIs to do all this.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会为我们的波形显示创建Angular组件，而是创建一个自定义的NativeScript视图组件，该组件可以访问原生API，然后我们可以将其注册到Angular中，以便在我们的组件中使用。这样做的原因是由于NativeScript强大的`view`基类，我们可以扩展它，它为使用底层的原生API提供了良好的API。这个波形显示将与我们刚刚创建的`RecordModel`协同工作，以实现设备麦克风的实时波形反馈显示。这也将非常棒，可以将这个波形显示作为我们的曲目列表上的静态音频文件波形渲染，作为我们主要合成视图的备用视图。AudioKit提供了类和API来完成所有这些。
- en: Since we want to be able to use this anywhere in our app, we will create it
    inside the shared module directory; however, keep in mind that it could live anywhere.
    It doesn't matter so much here, since this is not an Angular component that needs
    to be declared in `NgModule`. Additionally, since this will specifically work
    with native APIs, let's create it inside a new `native` folder to potentially
    house other NativeScript-specific view components.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望能够在我们的应用程序的任何地方使用它，我们将在共享模块目录中创建它；然而，请注意，它可以存在于任何地方。在这里这并不那么重要，因为这不是一个需要在`NgModule`中声明的Angular组件。此外，由于这将专门与原生API一起工作，让我们在新的`native`文件夹中创建它，以可能容纳其他NativeScript特定的视图组件。
- en: 'Create `app/modules/shared/native/waveform.ts` with the following contents,
    which we will explain in a moment:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`app/modules/shared/native/waveform.ts`，内容如下，我们将在稍后解释：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We are creating several properties using NativeScript's `Property` class, which
    will add great conveniences when exposing native view properties through the view
    binding properties. One such convenience in defining these properties with the
    `Property` class, these setters will only be called when `nativeView` is defined,
    avoiding double invoked property setters (one via a pure JS property setter, which
    is the alternative, and potentially another for when the underlying `nativeView`
    is ready).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用NativeScript的`Property`类创建几个属性，这将大大方便通过视图绑定属性公开原生视图属性。使用`Property`类定义这些属性的一个便利之处在于，这些设置器只会在`nativeView`定义时被调用，避免了双重调用的属性设置器（一个是通过纯JS属性设置器，这是另一种选择，以及当底层的`nativeView`准备好时的另一个设置器）。
- en: When wanting to expose native view properties that could be bound via your custom
    component, define several `Property` classes for them, referencing the name you'd
    like to use for the view binding.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想通过自定义组件公开可以绑定到视图的本地视图属性时，为它们定义几个`Property`类，并引用你希望用于视图绑定的名称。
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'By setting up these `Property` instances, we can now do this in our view component
    class:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置这些`Property`实例，我们现在可以在我们的视图组件类中这样做：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This will only be invoked once `nativeView` is ready, which is exactly what
    we want. You can read more about this particular syntax and notation in this draft
    written by core team member Alex Vakrilov:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这只会在`nativeView`准备好时调用一次，这正是我们想要的。你可以在这个由核心团队成员Alex Vakrilov撰写的草稿中了解更多关于这个特定语法和记法的信息：
- en: '[https://gist.github.com/vakrilov/ca888a1ea410f4ea7a4c7b2035e06b07#registering-the-property](https://gist.github.com/vakrilov/ca888a1ea410f4ea7a4c7b2035e06b07#registering-the-property).'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://gist.github.com/vakrilov/ca888a1ea410f4ea7a4c7b2035e06b07#registering-the-property](https://gist.github.com/vakrilov/ca888a1ea410f4ea7a4c7b2035e06b07#registering-the-property).'
- en: 'Then, at the bottom of our class (after it''s defined), we register the class
    with the `Property` instances:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的类定义之后，我们在`Property`实例中注册了该类：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Okay, with that explained, let's look at some other elements to this implementation.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，解释到这里，让我们来看看这个实现的其他元素。
- en: 'We are also introducing a helpful interface here, which we will apply to `RecordModel`
    in a moment:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还引入了一个有用的接口，我们将在稍后将其应用于`RecordModel`：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This will help define a shape for other models to implement, ensuring they
    conform to an API the Waveform display expects:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这将帮助定义其他模型要实现的形状，确保它们符合波形显示期望的API：
- en: '`target`: Defines the key input to be used with the native class.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target`：定义了与本地类一起使用的键输入。'
- en: '`dispose()`: Each model should provide this method to handle any clean up when
    the view is destroyed.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dispose()`: 每个模型都应该提供此方法来处理视图销毁时的任何清理操作。'
- en: 'This is the custom NativeScript 3.x View Life cycle call execution order:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这是自定义 NativeScript 3.x 视图生命周期调用执行顺序：
- en: '`createNativeView()`: `AnyNativeView;`  // Create your native view.'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`createNativeView()`: `AnyNativeView;`  // 创建你的原生视图。'
- en: '`initNativeView()`: `void;`  // Init your native view.'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`initNativeView()`: `void;`  // 初始化你的原生视图。'
- en: '`disposeNativeView()`: `void;`  // Clean up your native view.'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`disposeNativeView()`: `void;`  // 清理你的原生视图。'
- en: 'The `createNativeView` method overridden from NativeScript''s `View` class
    is likely the most interesting:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 从 NativeScript 的 `View` 类中重写的 `createNativeView` 方法可能是最有趣的：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we allow the `type` property to determine which type of Waveform display
    it should render.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们允许 `type` 属性确定应该渲染哪种类型的 Waveform 显示。
- en: In the case of `mic`, we utilize AudioKit's `AKNodeOutputPlot` (which actually
    extends `EZAudioPlot` under the hood) to initialize a waveform (that is, `audioplot`)
    using our model's target, which will end up being our RecordModel's microphone.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `mic` 的情况下，我们利用 AudioKit 的 `AKNodeOutputPlot`（实际上在底层扩展了 `EZAudioPlot`）来使用我们模型的目标初始化一个波形（即
    `audioplot`），这将最终成为我们的 RecordModel 的麦克风。
- en: In the case of `file`, we utilize AudioKit's `EZAudioPlot` directly to create
    a static waveform representing an audio file.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `file` 的情况下，我们直接利用 AudioKit 的 `EZAudioPlot` 创建一个表示音频文件的静态波形。
- en: The `initNativeView` method, also overridden from NativeScript's `View` class,
    is called second in its life cycle and provides a way to initialize your native
    view. You might find it interesting that we call the setters again here. The setters
    are called first when the component bindings are set via the XML and the class
    instantiates, which is *before* `createNativeView` and `initNativeView` are called.
    This why we cache the values in private references. However, we also want these
    setters to modify `nativeView` with Angular's view bindings (when changed dynamically),
    which is why we also have `if (this.nativeView)` inside the setters to change
    `nativeView` dynamically when available.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`initNativeView` 方法，也是从 NativeScript 的 `View` 类中重写的，在其生命周期中第二个被调用，并提供了一种初始化你的原生视图的方式。你可能会发现我们在这里再次调用了设置器。设置器在通过
    XML 设置组件绑定并实例化类时首先被调用，即在 `createNativeView` 和 `initNativeView` 被调用之前。这就是为什么我们在私有引用中缓存值的原因。然而，我们还想让这些设置器在
    Angular 的视图绑定（当动态变化时）中修改 `nativeView`，这就是为什么我们在设置器中也有 `if (this.nativeView)` 的原因，以便在可用时动态更改
    `nativeView`。'
- en: The `disposeNativeView` method (you guessed it, also overridden from the `{N}`
    of the `View` class) is called when `View` gets destroyed, which is where we call
    the model's `dispose` method if available.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `View` 被销毁时，会调用 `disposeNativeView` 方法（正如你所猜到的，这也是从 `View` 类的 `{N}` 中重写的），这是调用模型
    `dispose` 方法的位置，如果有的话。
- en: Integrate a custom NativeScript view into our Angular app
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将自定义 NativeScript 视图集成到我们的 Angular 应用中
- en: 'To use our NativeScript Waveform view within Angular, we need to first register
    it. You can do this in the root module, root app component, or another place that
    is initialized at boot time (usually, not in a lazy-loaded module). To be tidy,
    we will register it within `SharedModule` in the same directory, so add the following
    in `app/modules/shared/shared.module.ts`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Angular 中使用我们的 NativeScript Waveform 视图，我们首先需要注册它。你可以在根模块、根应用程序组件或另一个在启动时初始化的地方（通常不在懒加载模块中）做这件事。为了整洁，我们将在同一目录下的
    `SharedModule` 中注册它，所以请在 `app/modules/shared/shared.module.ts` 中添加以下内容：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `registerElement` method allows us to define the name of the Component we
    want to use within Angular components as the first argument, and takes a resolver
    function that should return the NativeScript `View` class to use for it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`registerElement` 方法允许我们定义在 Angular 组件中想要使用的组件名称，作为第一个参数，并接受一个解析函数，该函数应该返回用于它的
    NativeScript `View` 类。'
- en: Let's now use our new `IWaveformModel` and clean up some of `RecordModel` to
    use it, as well as prepare to create our Android implementation next. Let's refactor
    a couple things out of `RecordModel` into a common file to share code between
    our iOS and Android (coming soon!) models.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来使用我们新的 `IWaveformModel` 并清理一些 `RecordModel` 以便使用它，同时为创建我们的 Android 实现（即将推出！）做准备。让我们将
    `RecordModel` 中的几件事情重构到一个公共文件中，以便在 iOS 和 Android（即将推出！）模型之间共享代码。
- en: 'Create `app/modules/recorder/models/record-common.ts`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `app/modules/recorder/models/record-common.ts`：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This contains most of what was at the top of `RecordModel`, with the addition
    of the `IRecordModel` interface, which extends `IWaveformModel`. Since we built
    out our iOS implementation, we now have a model shape we would like our Android
    implementation to adhere to. Abstracting that shape into an interface will provide
    us a clear path to follow when we move to Android momentarily.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这包含了`RecordModel`顶部的几乎所有内容，增加了`IRecordModel`接口，该接口扩展了`IWaveformModel`。由于我们已经构建了iOS实现，我们现在有一个模型形状，我们希望我们的Android实现遵循这个形状。将这个形状抽象成一个接口将为我们提供一个清晰的路径，当我们暂时转移到Android时可以遵循。
- en: 'For convenience, let''s also create an index for our models, which would also
    expose this common file, in `app/modules/recorder/models/index.ts`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，我们还在`app/modules/recorder/models/index.ts`中为我们的模型创建了一个索引，这将也会暴露这个常用文件：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can now modify `RecordModel` to import these common items, as well as implement
    this new `IRecordModel` interface. Since this new interface also *extends* `IWaveformModel`,
    it will immediately tell us we need to implement the `readonly target`getter and
    the `dispose()`method, as required to be used with our Waveform view:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以修改`RecordModel`以导入这些常用项，以及实现这个新的`IRecordModel`接口。由于这个新接口也*扩展*了`IWaveformModel`，它将立即告诉我们我们需要实现`readonly
    target`获取器和`dispose()`方法，这是与我们的波形视图一起使用所必需的：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `target` of `RecordModel` will be the microphone that the Waveform view
    will use. Our `dispose` method will stop the AudioKit engine while doing reference
    clean up, as well as ensuring to clean out any temporary files created while recording.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`RecordModel`的`target`将是波形视图将使用的麦克风。我们的`dispose`方法将在进行参考清理的同时停止AudioKit引擎，并确保清理在录音过程中创建的任何临时文件。'
- en: Creating the Recorder View layout
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建录音视图布局
- en: When the user taps on Record in the top right corner of the app, it prompts
    the user to authenticate, after which the app routes to the record view. Additionally,
    it would be nice to reuse this record view in a modal popup to show when the composition
    contains tracks, so the user doesn't feel like they are leaving the composition
    while recording. However, when the composition is new, it's fine to navigate to
    the record view via routing. We will show how this can be done, but let's first
    set up our layout using the new fancy Waveform view and our powerful new `RecordModel`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在应用程序右上角点击录音时，它会提示用户进行身份验证，然后应用程序路由到录音视图。此外，如果组合中包含轨道，最好在模态弹出窗口中重用这个录音视图以显示，这样用户就不会感觉在录音时离开了组合。然而，当组合是新的时，通过路由导航到录音视图是完全可以的。我们将展示如何做到这一点，但首先让我们使用新的花哨的波形视图和我们的强大新`RecordModel`来设置我们的布局。
- en: 'Add the following to `app/modules/recorder/components/record.component.html`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app/modules/recorder/components/record.component.html`中添加以下内容：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We are using `FlexboxLayout` because we want our Waveform view to stretch to
    cover the full available vertical space, leaving only the recorder's controls
    positioned at the bottom. `FlexboxLayout` is a very versatile layout container,
    which provides most of the same CSS styling attributes found with the the flexbox
    model on the web.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`FlexboxLayout`是因为我们希望波形视图能够扩展以覆盖全部可用的垂直空间，只留下录音控制位于底部。`FlexboxLayout`是一个非常灵活的布局容器，它提供了与网页上flexbox模型相同的大多数CSS样式属性。
- en: Interestingly, we show a Cancel button inside a `GridLayout` container only
    when displayed as a modal, since we need a way to close the modal. ActionBars
    are ignored and not displayed when the view is opened via a modal.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，我们只在以模态形式显示时在`GridLayout`容器内显示一个取消按钮，因为我们需要一个关闭模态的方式。当视图通过模态打开时，会忽略`ActionBar`并且不显示。
- en: ActionBars are ignored when the view is opened via a modal, so they are not
    displayed in the modal. `ActionBar` is shown on navigated views only.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当视图通过模态打开时，会忽略`ActionBar`，因此在模态中不显示。`ActionBar`仅在导航视图中显示。
- en: Furthermore, our `ActionBar` setup is rather interesting here and is one of
    the areas of NativeScript view layouts where iOS and Android differ the most.
    On iOS, `NavigationButton` has a default behavior, that automatically pops the
    view from the stack and animates back to the previous view. Additionally, any
    tap events on `NavigationButton` on iOS are completely ignored, whereas on Android,
    the tap event is triggered on `NavigationButton`. Because of this crucial difference,
    we want to completely ignore `NavigationButton` of `ActionBar` by using `visibility="collapsed"`
    to ensure it is never shown. Instead, we use `ActionItem` with an explicit tap
    event to ensure the correct logic is triggered on our component for both platforms.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们的`ActionBar`设置在这里相当有趣，并且是iOS和Android在NativeScript视图布局中差异最大的领域之一。在iOS上，`NavigationButton`有一个默认行为，会自动从堆栈中弹出视图并动画回到前一个视图。此外，iOS上`NavigationButton`上的任何点击事件都被完全忽略，而在Android上，点击事件会在`NavigationButton`上触发。由于这个关键差异，我们想通过使用`visibility="collapsed"`来完全忽略`ActionBar`的`NavigationButton`，以确保它永远不会显示。相反，我们使用具有显式点击事件的`ActionItem`，以确保在两个平台上都能触发我们组件的正确逻辑。
- en: '`NavigationButton` behavior on iOS and Android is different:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: iOS和Android上的`NavigationButton`行为不同：
- en: '**iOS**: `NavigationButton` ignores (tap) events, and this button appears by
    default when navigating to a view.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iOS**：`NavigationButton`忽略（点击）事件，当导航到视图时，此按钮默认出现。'
- en: '**Android**: `NavigationButton` (tap) events are triggered.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Android**：`NavigationButton`（点击）事件被触发。'
- en: You can see our Waveform (the custom NativeScript) view in use here. We use
    Angular's binding syntax when binding the model, since it's an object. For the
    other properties, we specify their values directly, since they are primitive values.
    We could, however, use Angular's binding syntax on those as well if we wanted
    to change those values dynamically via user interaction. For example, we could
    show a fun color picker, which would allow the user to change the color (`plotColor`)
    of the waveform on the fly.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里看到我们使用的波形（自定义NativeScript）视图。由于它是一个对象，我们使用Angular的绑定语法来绑定模型。对于其他属性，我们直接指定它们的值，因为它们是原始值。然而，如果我们想通过用户交互动态更改这些值，我们也可以使用Angular的绑定语法。例如，我们可以显示一个有趣的颜色选择器，允许用户实时更改波形的颜色（`plotColor`）。
- en: 'We''ll provide a component-specific stylesheet for our record component, `app/modules/recorder/components/record.component.css`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为我们的记录组件提供特定的样式表，`app/modules/recorder/components/record.component.css`：
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Some of these CSS properties may look familiar if you''ve used the flexbox
    model on the web. A great and fun resource to learn more about flexbox styling
    is Flexbox Zombies by Dave Geddes: [http://flexboxzombies.com](http://flexboxzombies.com.).'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经在网页上使用过flexbox模型，一些CSS属性可能看起来很熟悉。一个学习更多关于flexbox样式的极好和有趣资源是Dave Geddes的Flexbox
    Zombies：[http://flexboxzombies.com](http://flexboxzombies.com.)。
- en: At this point, our CSS is starting to grow and we could clean things up a lot
    with SASS. We will do exactly that, coming up soon, so hang in there!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的CSS开始增长，我们可以用SASS清理很多东西。我们将很快做到这一点，所以请耐心等待！
- en: 'Now, let''s take a look at the Component at `app/modules/recorder/components/record.component.ts`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`app/modules/recorder/components/record.component.ts`中的组件：
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Starting from the bottom of that file, you'll probably wonder what the heck
    `invokeOnRunLoop` is*.* This is a handy way to ensure thread safety in conditions
    where the thread might rear its ugly head. In this case, AudioKit's engine is
    started from the UI thread in `RecordModel`, since NativeScript marshals native
    calls on the UI thread. However, when our record view closes (whether it be from
    a modal our navigating back), some background threads are invoked. Wrapping our
    handling of closing this view with `invokeOnRunLoop` helps solve this transient
    exception. It's the answer to how to use iOS `dispatch_async(dispatch_get_main_queue(…))`
    with NativeScript.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 从该文件的底部开始，你可能想知道`invokeOnRunLoop`是什么东西*.* 这是一种确保线程安全的好方法，在这些情况下，线程可能会露出其丑陋的一面。在这种情况下，AudioKit的引擎是从`RecordModel`中的UI线程启动的，因为NativeScript在UI线程上封装了原生调用。然而，当我们的记录视图关闭时（无论是从模态还是导航回退），一些后台线程被调用。用`invokeOnRunLoop`封装我们处理关闭此视图的方式有助于解决这个短暂的异常。这是如何在NativeScript中使用iOS的`dispatch_async(dispatch_get_main_queue(…))`的答案。
- en: 'Working our way up the file, we''ll encounter `this.recorderService.state$.subscribe((state:
    number) => …`. In a moment, we''ll be implementing a way to observe the recording
    `state$` as an observable, so our view can simply react to its state changes.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '在文件中向上工作时，我们会遇到`this.recorderService.state$.subscribe((state: number) => …`)。在不久的将来，我们将实现一种方法来观察录制`state$`作为可观察对象，这样我们的视图就可以简单地对其状态变化做出反应。'
- en: Also of note, it is a handy way to collapse `RecordState enum` into properties
    we can use as view bindings to compare against the current state (`this.state
    = state;`).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得注意的点是，将`RecordState`枚举折叠到我们可以用作视图绑定的属性中，以与当前状态进行比较（`this.state = state;`）。
- en: When the component is constructed, `recorderService.setupNewRecording()` will
    prepare our service for a brand new recording each time this view appears.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件被构建时，`recorderService.setupNewRecording()`将为每次此视图出现时准备我们的服务进行全新录制。
- en: 'Lastly, take note of the injection of `@Optional()private params: ModalDialogParams`*.*
    Earlier, we mentioned that *it would be nice to reuse this record view in a modal
    popup*. The interesting part is that `ModalDialogParams` is only provided to a
    component when it is opened in a modal. In other words, Angular''s dependency
    injection doesn''t know anything about a `ModalDialogParams` service unless the
    component is explicitly opened via NativeScript''s `ModalService`, so this would
    break our ability to route to this component as we had originally set up, since
    Angular''s DI would fail to recognize such a provider by default. In order to
    allow this component to continue working as a routing component, we will simply
    mark that argument as `@Optional()`, which will just set its value to null when
    not available instead of throwing a dependency injection error.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，请注意注入`@Optional()private params: ModalDialogParams`*.* 之前，我们提到过*在模态弹出窗口中复用这个记录视图会很好*。有趣的部分在于`ModalDialogParams`只有在组件以模态打开时才提供给组件。换句话说，Angular的依赖注入不知道任何关于`ModalDialogParams`服务的信息，除非组件通过NativeScript的`ModalService`明确打开，所以这将破坏我们原本设置的将此组件路由到的能力，因为Angular的DI默认无法识别这样的提供者。为了允许这个组件继续作为路由组件工作，我们将简单地标记该参数为`@Optional()`，这样当不可用时会将其值设置为null，而不是抛出依赖注入错误。'
- en: This will allow our component to be routed to, as well as be opened in a modal!
    Reuse in full swing!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许我们的组件被路由到，以及在一个模态中打开！全面复用！
- en: In order to conditionally navigate to this component via routing, or open it
    in a modal, we can make a few small adjustments, bearing in mind that `RecorderModule`
    is lazy loaded, so we'll want to lazily load the module before opening it as a
    modal.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过路由有条件地导航到这个组件，或者以模态打开它，我们可以进行一些小的调整，记住`RecorderModule`是懒加载的，因此我们希望在打开它作为模态之前懒加载该模块。
- en: 'Open `app/modules/mixer/components/action-bar/action-bar.component.ts` and
    make the following modifications:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`app/modules/mixer/components/action-bar/action-bar.component.ts`并做出以下修改：
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here, we conditionally emit an event using `EventEmitter` with a Component
    `Output` decorator if the composition contains tracks; otherwise we navigate to
    the record view. We then adjust `Button` in the view template to use the method:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果组合中包含轨道，我们使用带有组件装饰器`Output`的`EventEmitter`有条件地发出一个事件；否则，我们导航到记录视图。然后我们在视图模板中调整`Button`以使用该方法：
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can now modify `app/modules/mixer/components/mixer.component.html` to use
    `Output` by its name as a normal event:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以修改`app/modules/mixer/components/mixer.component.html`以使用名称作为正常事件来使用`Output`：
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now for the fun part. Since we'd love to be able to open any component in a
    modal, whether it's part of a lazy loaded module or not, let's add a new method
    to `DialogService` that can be used anywhere.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候进行有趣的部分了。由于我们希望能够打开任何组件在模态中，无论它是否是懒加载模块的一部分，让我们向`DialogService`添加一个新方法，可以在任何地方使用。
- en: 'Make the following changes to `app/modules/core/services/dialog.service.ts`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对`app/modules/core/services/dialog.service.ts`做出以下修改：
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, we inject `ModalDialogService` and `NgModuleFactoryLoader` (which is actually `NSModuleFactoryLoader`,
    since, if you recall, we provided for in [Chapter 5](part0064.html#1T1400-289fe2426d594f99a90e4363b2c9c34d),
    *Routing and Lazy Loading*) to load any module on demand to open a Component (declared
    in that lazy loaded module) in a modal. *It also works for components that do
    not need to be lazy loaded*. In other words, it will optionally lazily load any
    module by its path, if provided, and then use its `NgModuleFactory` to get a module
    reference, which we can pass along as an option (via the `moduleRef` key) to `this.modalService.showModal`
    to open a Component declared in that lazily-loaded module.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们注入`ModalDialogService`和`NgModuleFactoryLoader`（实际上它是`NSModuleFactoryLoader`，因为如果你还记得，我们在[第5章](part0064.html#1T1400-289fe2426d594f99a90e4363b2c9c34d)，*路由和懒加载*中提供了它）来按需加载任何模块以在模态中打开一个组件（在该懒加载的模块中声明）。*它也适用于不需要懒加载的组件*。换句话说，如果提供了路径，它将可选地懒加载任何模块，然后使用其`NgModuleFactory`获取模块引用，我们可以将其作为选项（通过`moduleRef`键）传递给`this.modalService.showModal`以打开在该懒加载模块中声明的组件。
- en: 'This will come in handy again later; however, let''s put it to use now by making
    the following changes to `app/modules/mixer/components/mixer.component.ts`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在以后再次派上用场；然而，让我们现在就通过以下修改`app/modules/mixer/components/mixer.component.ts`来使用它：
- en: '[PRE34]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This will lazily load `RecorderModule` and then open `RecordComponent` in a
    popup modal. Cool!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这将懒加载`RecorderModule`并在弹出模态中打开`RecordComponent`。酷！
- en: Finishing implementation with RecorderService
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RecorderService完成实现
- en: 'Now, let''s finish this implementation with `RecorderService` in `app/modules/recorder/services/recorder.service.ts`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`RecorderService`在`app/modules/recorder/services/recorder.service.ts`中完成这个实现：
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The pinnacle of our recording service is its ability to react to the model''s
    state changes. This, in turn, emits an Observable stream notifying observers (our
    `RecordComponent`) when the state changes, as well as internally doing the work
    necessary to control `RecordModel` along with `PlayerService`. The critical key
    to our design is we want our active composition''s tracks to play in the background
    while we record, so we can play along with the mix. This case is important:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们录制服务的巅峰是其对模型状态变化的反应能力。这反过来又发出一个Observable流，通知观察者（我们的`RecordComponent`）状态变化，以及内部执行控制`RecordModel`和`PlayerService`所需的工作。我们设计的关键是我们希望我们的活动作品曲目在录制时在后台播放，这样我们就可以与混合一起播放。这个情况很重要：
- en: '[PRE36]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'When `RecordModel` is `readyToPlay`, we know that a recording has been created
    and is now ready to play. We stop the playing mix, get a reference to the recorded
    file''s path. Then, we update `PlayerService` to queue up this new track to be
    played back. We will show the updated `PlayerService` in a moment, which handles
    adding the new file to the mix, but it adds a new `TrackPlayer` like everything
    else in our mix. However, the file points to a temporary recorded file at the
    moment, as we don''t want to save the composition until the user decides to officially
    commit and save the recording. The recording session will allow the user to re-record
    again if they are not happy with the recording. This is why we hold a reference
    to `_trackId`. If a recording had already been added to the mix, we use that `_trackId`
    to exclude it when re-recording, since we would not want to hear back the recording
    we are re-recording over:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当`RecordModel`处于`readyToPlay`状态时，我们知道已创建录制，现在可以播放。我们停止播放混合，获取录制文件的路径引用。然后，我们更新`PlayerService`以排队播放这条新曲目。我们稍后将展示更新的`PlayerService`，它负责将新文件添加到混合中，但它像我们混合中的其他一切一样添加一个新的`TrackPlayer`。然而，文件目前指向一个临时录制文件，因为我们不希望在用户决定正式提交并保存录制之前保存作品。录制会话将允许用户在录制不满意时重新录制。这就是为什么我们保留对`_trackId`的引用。如果录制已经添加到混合中，我们使用那个`_trackId`在重新录制时排除它，因为我们不希望听到我们正在重新录制的录制：
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We also use it to clean up after ourselves if the user chose to cancel instead
    of saving:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还用它来清理用户选择取消而不是保存的情况：
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s take a look at the modifications to `PlayerService` we need to make
    in order to support our recording:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们需要对`PlayerService`进行哪些修改以支持我们的录制：
- en: '[PRE39]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: These changes will support our recorder's ability to interact with the active
    composition.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改将支持我们的录制器与活动作品交互的能力。
- en: 'Note: Considerations when reusing a Component to lazy load in a modal as well
    as allow lazy loading via routing.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：考虑在模态中重用组件进行懒加载以及通过路由进行懒加载时的注意事项。
- en: 'Angular services must be provided *only* at the *root* level *if they are intended
    to be singletons* shared across all lazy loaded modules, as well as the root module.
    `RecorderService` is lazy loaded with `RecordModule` when it is navigated to,
    as well as being opened in a modal. Since we are now injecting `PlayerService`
    into our `RecorderService` (which is lazily loaded) and `PlayerService` now injects
    `MixerService` (which is also lazily loaded as the root route in our app), we
    will have to create a problem where our services are no longer singletons. In
    fact, you may even see an error like this if you were to try and navigate to `RecordComponent`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Angular 服务旨在在所有懒加载模块以及根模块中共享为单例，则必须在 *根* 级别提供它们。`RecorderService` 在导航到时与
    `RecordModule` 懒加载，同时在模态中打开。由于我们现在将 `PlayerService` 注入到我们的 `RecorderService`（它是懒加载的）中，而
    `PlayerService` 现在注入 `MixerService`（它也是作为我们应用中的根路由懒加载的），我们将不得不创建一个问题，即我们的服务不再是单例。实际上，如果你尝试导航到
    `RecordComponent`，你甚至可能会看到这样的错误：
- en: 'JS: ERROR Error: Uncaught (in promise): Error: No provider for PlayerService!'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 'JS: 错误 Error: Uncaught (in promise): Error: No provider for PlayerService!'
- en: 'To solve this, we will drop the providers from `PlayerModule` and `MixerModule`
    (since those modules are both lazily loaded) and instead provide those services
    only in our `CoreModule`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将从 `PlayerModule` 和 `MixerModule` 中删除提供者（因为这两个模块都是懒加载的）并在我们的 `CoreModule`
    中仅提供这些服务：
- en: 'The modified `app/modules/player/player.module.ts` is as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 修改后的 `app/modules/player/player.module.ts` 如下：
- en: '[PRE40]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The modified `app/modules/mixer/mixer.module.ts` is as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 修改后的 `app/modules/mixer/mixer.module.ts` 如下：
- en: '[PRE41]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Updated to provide these services as true singletons from `CoreModule` only,
    the code for `app/modules/core/core.module.ts` is as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 更新为仅从 `CoreModule` 提供这些服务作为真正的单例，`app/modules/core/core.module.ts` 的代码如下：
- en: '[PRE42]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This is how you can solve these types of issues; but, this is exactly the reason
    why we recommend using Ngrx in  [Chapter 10](https://cdp.packtpub.com/mastering_nativescript_mobile_development/wp-admin/post.php?post=104&action=edit#post_361), *@ngrx/store
    + @ngrx/effects for State Management*, coming up soon, as it can help alleviate
    these dependency injection issues.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是解决这些类型问题的方法；但这正是我们为什么建议在第 10 章 [Chapter 10](https://cdp.packtpub.com/mastering_nativescript_mobile_development/wp-admin/post.php?post=104&action=edit#post_361)
    中使用 Ngrx 的原因，即将推出的 `@ngrx/store + @ngrx/effects for State Management`，因为它可以帮助缓解这些依赖注入问题。
- en: At this point, our setup works nicely; but, it can be greatly improved and even
    simplified when we start integrating ngrx for a more Redux-style architecture.
    We have done a few reactive things here, such as our `RecordComponent` reacting
    to our service's `state$` observable; but, we needed to inject `MixerService`
    into `PlayerService`, which feels slightly wrong architecturally, since `PlayerModule`
    should not really have a dependency on anything `MixerModule` provides. Again,
    *this technically works just fine,* but when we start working with ngrx in [Chapter
    10](part0121.html#3JCK20-289fe2426d594f99a90e4363b2c9c34d), *@ngrx/store + @ngrx/effects
    for State Management*, you'll see how we can reduce our dependency mixing throughout
    the whole codebase.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们的设置运行得很好；但是，当我们开始集成 ngrx 以实现更 Redux 风格的架构时，它可以得到极大的改进和简化。我们已经在这里做了一些反应式的事情，例如我们的
    `RecordComponent` 对服务中的 `state$` 可观察对象做出反应；但是，我们需要将 `MixerService` 注入到 `PlayerService`
    中，这在架构上感觉有点不合适，因为 `PlayerModule` 实际上不应该依赖于 `MixerModule` 提供的任何东西。再次强调，*这技术上确实可以正常工作*，但是当我们开始在第
    10 章 [Chapter 10](part0121.html#3JCK20-289fe2426d594f99a90e4363b2c9c34d) 中使用 ngrx
    时，你将看到我们如何在整个代码库中减少依赖混合。
- en: 'Let''s take a moment though, relax, and pat ourselves on the back, as this
    has been an impressive amount of work. Take a look at what the fruits of our labor
    are producing:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间放松一下，拍拍自己的背，因为这是一项令人印象深刻的成果。看看我们辛勤工作的成果：
- en: '![](img/00038.jpeg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00038.jpeg)'
- en: Phase 2 – Building an audio recorder for Android
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二阶段 – 为 Android 构建音频录音器
- en: 'Believe it or not we''ve actually done most of the heavy lifting to make this
    work on Android already! That''s the beauty of NativeScript. Designing an API
    that makes sense, as well as an architecture that can plug/play underlying native
    APIs, is key to NativeScript development. At this point, we just need to plug
    in the Android pieces into the shape we have designed. So, to summarize, we now
    have the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 信不信由你，我们实际上已经完成了大部分繁重的工作，让这一切在 Android 上工作！这就是 NativeScript 的美妙之处。设计一个有意义的 API，以及一个可以插入/播放底层原生
    API 的架构，对于 NativeScript 开发至关重要。在这个阶段，我们只需要将 Android 的组件插入到我们设计的形状中。所以，总结一下，我们现在有以下内容：
- en: '`RecorderService` that works in tandem with `PlayerService` to coordinate our
    multitrack handling abilities'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与`PlayerService`协同工作的`RecorderService`，以协调我们的多轨处理能力
- en: A Waveform view that is flexible and ready to provide an Android implementation
    under the hood
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个灵活的波形视图，准备好在底层提供Android实现
- en: '`RecordModel` that should tap into the appropriate underlying target platform
    APIs and be ready for Android details to be plugged into'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RecordModel`应该调用适当的底层目标平台API，并准备好将Android的详细信息插入其中'
- en: Built interfaces defining the shape of the model, for Android models to simply
    implement to know which API they should define
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义了模型形状的接口，Android模型只需实现即可知道它们应该定义哪些API
- en: Let's get to work.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始工作。
- en: 'We want to rename `record.model.ts` to `record.model.ios.ts`, since it''s specific
    to iOS, but before doing so, we will want a TypeScript definition file (`.d.ts`)
    for it, so our codebase can continue importing as `''record.model''`. There are
    several ways this could be done, including just manually writing one out. However,
    the tsc compiler has a handy `-d` flag, which will generate definition files for
    us:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将`record.model.ts`重命名为`record.model.ios.ts`，因为它仅针对iOS，但在这样做之前，我们希望有一个TypeScript定义文件（`.d.ts`），以便我们的代码库可以继续导入为`'record.model'`。这可以通过几种方式完成，包括手动编写一个。然而，tsc编译器有一个方便的`-d`标志，它可以为我们生成定义文件：
- en: '[PRE43]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This will spit out a ton of TypeScript warnings and errors; but, it doesn't
    matter in this case, since our definition file will be generated correctly. We
    don't need to generate JavaScript, just the definition, so you can ignore the
    wall of issues that results.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生大量的TypeScript警告和错误；但在这个情况下，这并不重要，因为我们的定义文件将正确生成。我们不需要生成JavaScript，只需要定义，所以你可以忽略由此产生的问题墙。
- en: 'We now have two new files:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个新文件：
- en: '`record-common.model.d.ts` (*you can delete this as we won''t need it*)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`record-common.model.d.ts`（你可以删除它，因为我们不再需要它）'
- en: '`record.model.d.ts`'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`record.model.d.ts`'
- en: 'The `record-common.model` file is imported by `RecordModel`, which is why a
    definition was generated for it as well; but, you can *delete* that. Now, we have
    the definition file, but we want to modify it slightly. We don''t need any of
    the `private` declarations and/or any native types it included; you would notice
    it contained the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`RecordModel`导入`record-common.model`文件，这就是为什么也为它生成了定义；但你可以*删除*它。现在，我们有了定义文件，但我们想稍作修改。我们不需要任何`private`声明和/或它包含的任何本地类型；你会注意到它包含了以下内容：'
- en: '[PRE44]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Since those are iOS-specific, we''ll want to type those as *any*, so it''s
    applicable to both iOS and Android. This is what things look like with our modifications:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些是iOS特有的，我们将想要将它们类型化为*any*，这样它们就适用于iOS和Android。这是我们的修改后的样子：
- en: '[PRE45]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Perfect, now rename `record.model.ts` to `record.model.ios.ts`. We have now
    finalized our iOS implementation, as well as ensured maximum code reuse to turn
    our focus to Android. NativeScript will use the target platform suffix files at
    build time, so you don't ever need to worry that iOS-only code would end up on
    Android and vice versa.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 完美，现在将`record.model.ts`重命名为`record.model.ios.ts`。我们现在已经完成了iOS的实现，并确保了最大程度的代码复用来将我们的重点转向Android。NativeScript将在构建时使用目标平台后缀文件，所以你永远不需要担心iOS特有的代码会出现在Android上，反之亦然。
- en: The `.d.ts` definition file we generated previously will be used at JavaScript
    transpilation time by the TypeScript compiler, whereas the runtime will use the
    platform-specific JS files (without the extension).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前生成的`.d.ts`定义文件将在TypeScript编译器进行JavaScript转换时使用，而运行时将使用特定平台的JS文件（不带扩展名）。
- en: 'Okay, now create `app/modules/recorder/models/record.model.android.ts`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在创建`app/modules/recorder/models/record.model.android.ts`：
- en: '[PRE46]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This may look a whole lot like the iOS side, and that's because it will be nearly
    the same! In fact, this setup works great, so now we just want to fill in the
    Android specifics.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来非常像iOS端，这是因为它们几乎相同！实际上，这种设置非常出色，所以现在我们只想填写Android的具体细节。
- en: Using nativescript-audio's TNSRecorder for Android in our RecordModel
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的RecordModel中使用nativescript-audio的TNSRecorder为Android
- en: 'We could use some fancy Android APIs and/or libraries for our recorder, but
    in this case, the **nativescript-audio** plugin we''re using for our cross-platform
    multitrack player also provides a cross-platform recorder. We could have even
    used it with iOS, but we wanted to specifically work with AudioKit''s powerful
    APIs there. However, here on Android, let''s use the recorder from the plugin
    and make the following modifications to `record.model.android.ts`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一些花哨的Android API和/或库来为我们的录音器，但在这个案例中，我们用于跨平台多轨播放器的**nativescript-audio**插件也提供了一个跨平台录音器。我们甚至可以用它来配合iOS，但我们想在那里特别使用AudioKit强大的API。然而，在这里的Android上，让我们使用插件中的录音器并对`record.model.android.ts`进行以下修改：
- en: '[PRE47]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Wow! Okay, a lot of interesting things going on here. Let''s get one necessary
    thing out of the way for Android and ensure for API level 23+ that permissions
    are properly handled. For this, you can install the permissions plugin:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！好的，这里有很多有趣的事情在进行。让我们先解决一个必要的事情，确保对于API级别23+的Android，权限得到正确处理。为此，你可以安装权限插件：
- en: '[PRE48]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We also want to ensure our manifest file contains the proper permission key.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还想要确保我们的清单文件包含正确的权限键。
- en: 'Open `app/App_Resources/Android/AndroidManifest.xml` and add the following
    in the correct place:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`app/App_Resources/Android/AndroidManifest.xml`并在正确位置添加以下内容：
- en: '[PRE49]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We use the nativescript-audio plugin's `TNSRecorder` as our implementation and
    wire things up accordingly to its API. `AudioRecorderOptions` provides a `metering`
    option, allowing the ability to monitor the microphone's meters via an interval.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用nativescript-audio插件的`TNSRecorder`作为我们的实现，并相应地将其API连接起来。`AudioRecorderOptions`提供了一个`metering`选项，允许通过间隔监控麦克风的音量计。
- en: What is most versatile about our overall design is that our model's target can
    literally be anything. In this case, we create a RxJS Subject observable as `_target$`,
    which is then returned as our target getter. This allows us to emit the microphone's
    meter value through the `Subject` observable for consumption by our Waveform.
    You will see in a moment how we will take advantage of this.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们整体设计最灵活的地方在于，我们的模型的目标可以是任何东西。在这种情况下，我们创建了一个RxJS Subject可观察对象作为`_target$`，然后将其作为我们的目标获取器返回。这允许我们通过`Subject`可观察对象发射麦克风的音量计值，以便我们的波形使用。你很快就会看到我们如何利用这一点。
- en: We are now ready to move on to our Waveform implementation for Android.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好继续进行Android的波形实现。
- en: Just like we did for the model, we will want to refactor the common bits into
    a shared file and handle the suffix.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们对模型所做的那样，我们希望将公共部分重构到一个共享文件中并处理后缀。
- en: 'Create `app/modules/shared/native/waveform-common.ts`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`app/modules/shared/native/waveform-common.ts`：
- en: '[PRE50]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Then, just adjust `app/modules/shared/native/waveform.ts` to use it:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，只需调整`app/modules/shared/native/waveform.ts`以使用它：
- en: '[PRE51]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Before renaming our waveform to contain an `.ios` suffix, let''s generate a
    TypeScript definition file for it first:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在将我们的波形重命名为包含`.ios`后缀之前，让我们先为它生成一个TypeScript定义文件：
- en: '[PRE52]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'You may again see TypeScript errors or warnings, but we don''t need to worry
    about those, as it should have still generated a `waveform.d.ts` file. Let''s
    simplify it slightly to contain only the parts that are applicable to both iOS
    and Android:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会再次看到TypeScript的错误或警告，但我们不需要担心这些，因为它应该仍然生成了一个`waveform.d.ts`文件。让我们稍微简化一下，只包含适用于iOS和Android的部分：
- en: '[PRE53]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Okay, now, rename `waveform.ts` to `waveform.ios.ts` and create `app/modules/shared/native/waveform.android.ts`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在，将`waveform.ts`重命名为`waveform.ios.ts`并创建`app/modules/shared/native/waveform.android.ts`：
- en: '[PRE54]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Okay, excellent! This is the barebones setup we will need, *but what native
    Android view should we use?*
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，太棒了！这是我们需要的最基本设置，*但我们应该使用哪种原生的Android视图？*
- en: 'If you''re looking around for open source Android libs, you may come across
    a group of very talented developers with **Yalantis**, a fantastic mobile development
    company based out of Ukraine. Roman Kozlov and his team created an open source
    project, **Horizon**, which provides beautiful audio visualizations:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在寻找开源的Android库，你可能会遇到一群非常出色的开发者，他们来自乌克兰的**Yalantis**，一家出色的移动开发公司。Roman Kozlov和他的团队创建了一个开源项目，**Horizon**，它提供了美丽的音频可视化：
- en: '[https://github.com/Yalantis/Horizon](https://github.com/Yalantis/Horizon)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/Yalantis/Horizon](https://github.com/Yalantis/Horizon)'
- en: '[https://yalantis.com/blog/horizon-open-source-library-for-sound-visualization/](https://yalantis.com/blog/horizon-open-source-library-for-sound-visualization/)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://yalantis.com/blog/horizon-open-source-library-for-sound-visualization/](https://yalantis.com/blog/horizon-open-source-library-for-sound-visualization/)'
- en: 'Just like for iOS, we also want to prepare for a multifaceted Waveform view
    that can also render a static waveform for just a file. Looking further through
    the open source options, we may come across another wonderfully talented team
    with **Semantive**, based in Warsaw, the sprawling capital of Poland. They created
    an incredibly powerful Waveform view for Android:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 就像iOS一样，我们也想为可以渲染静态波形文件的Waveform视图做好准备。进一步查看开源选项，我们可能会遇到另一支才华横溢的团队——位于波兰广阔首都华沙的**Semantive**。他们为Android创建了一个功能强大的Waveform视图：
- en: '[https://github.com/Semantive/waveform-android](https://github.com/Semantive/waveform-android)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/Semantive/waveform-android](https://github.com/Semantive/waveform-android)'
- en: Let's integrate both of these libraries for our Android Waveform integration.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这两个库集成到我们的Android Waveform集成中。
- en: 'Similar to how we integrated AudioKit for iOS, let''s create a folder in the
    root called `android-waveform-libs` with the following setup, that provides `include.gradle`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于我们为iOS集成的AudioKit，让我们在根目录下创建一个名为`android-waveform-libs`的文件夹，并按照以下设置提供`include.gradle`：
- en: '![](img/00039.jpeg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00039.jpeg)'
- en: Why deviate from the `nativescript-` prefix when including native libs?
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么在包含本地库时偏离`nativescript-`前缀？
- en: The prefix is a good way to go if you plan to refactor the internal plugin into
    an open source plugin published via npm for the community down the road, using
    [https://github.com/NathanWalker/nativescript-plugin-seed](https://github.com/NathanWalker/nativescript-plugin-seed)
    for instance.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划将来将内部插件重构为通过npm发布的开源插件，以便社区使用，例如使用[https://github.com/NathanWalker/nativescript-plugin-seed](https://github.com/NathanWalker/nativescript-plugin-seed)，那么使用前缀是一个不错的选择。
- en: Sometimes, you just need to integrate several native libs for a specific platform,
    as we are in this case, so we don't really need the `nativescript-` prefix on
    our folder.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能只需要为特定平台集成几个本地库，就像我们在这个案例中一样，所以我们不需要在我们的文件夹上使用`nativescript-`前缀。
- en: 'We make sure to add `package.json`, so we can add these native libs like we
    would any other plugin:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确保添加`package.json`，这样我们就可以像添加任何其他插件一样添加这些本地库：
- en: '[PRE55]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, we simply add them as a plugin to our project:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需将它们作为插件添加到我们的项目中：
- en: '[PRE56]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We are now ready to integrate these libs into our Waveform view.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已准备好将这些库集成到我们的Waveform视图中。
- en: 'Let''s make the following modifications to the `app/modules/shared/native/waveform.android.ts` file:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对`app/modules/shared/native/waveform.android.ts`文件进行以下修改：
- en: '[PRE57]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We begin our Android implementation by defining the `const` references to the
    various packaged classes we need to access, to alleviate having to reference the
    fully qualified package location each time in our Waveform. Just like on the iOS
    side, we design a dual-purpose Waveform by allowing the type (`'mic'` or `'file'`)
    to drive which rendering to use. This allows us to reuse this with our record
    view for real-time microphone visualization and the other to statically render
    our tracks as Waveforms (more on that soon!).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始我们的Android实现，通过定义对需要访问的各种打包类的`const`引用，以减轻在Waveform中每次都要引用完全限定包位置的需要。就像在iOS端一样，我们通过允许类型（`'mic'`或`'file'`）驱动使用哪种渲染来设计一个双用途的Waveform。这使我们能够将这个功能用于我们的实时麦克风可视化记录视图，另一个用于将我们的音轨作为Waveform静态渲染（更多内容将在后面介绍！）。
- en: 'The Horizon lib utilizes Android''s `GLSurfaceView` as the primary rendering,
    hence:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Horizon库利用Android的`GLSurfaceView`作为主要渲染，因此：
- en: '[PRE58]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: During development, we found that `GLSurfaceView` requires at least a height
    to constrain it, otherwise it would render at full screen height. Therefore, we
    explicitly set a reasonable `height` of `200` to the custom NativeScript view,
    which will automatically handle measuring the native view for us. Interestingly,
    we also found that sometimes our model setter would fire *before* `initNativeView`
    and other times *after*. Because the model is a critical binding for initializing
    our Horizon view, we designed a custom internal `_initView` method with the appropriate
    conditional, which could be called from `initNativeView`, as well as after our
    model setter fired. The condition (`!this._initialized && this.nativeView && this.model`)
    ensures it's only ever initialized once though. This is the way to handle any
    potential race conditions around the sequence of these method calls.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，我们发现`GLSurfaceView`至少需要一个高度来限制它，否则它将以全屏高度渲染。因此，我们明确地将自定义NativeScript视图的`height`设置为合理的`200`，这将自动为我们处理原生视图的测量。有趣的是，我们还发现有时我们的模型设置器会在`initNativeView`之前触发，有时会在之后。因为模型是初始化我们的Horizon视图的关键绑定，我们设计了一个自定义的内部`_initView`方法，其中包含适当的条件，可以从`initNativeView`调用，也可以在我们模型设置器触发后调用。条件(`!this._initialized
    && this.nativeView && this.model`)确保它只初始化一次。这是处理这些方法调用顺序中任何潜在竞争条件的方法。
- en: 'The native `Horizon.java` class provides an `update` method that expects a
    Java byte array with a signature:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 本地`Horizon.java`类提供了一个`update`方法，该方法期望一个具有以下签名的Java字节数组：
- en: '[PRE59]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'What we do in NativeScript for this is retain a reference to a construct that
    will represent this native Java byte array with the following:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在NativeScript中，我们保留了一个表示这个本地Java字节数组的结构的引用：
- en: '[PRE60]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Utilizing Android's `android.media.AudioRecord` class, in conjunction with the
    various recorder settings that we set up, we are able to gather an initial `bufferSize`,
    that we use to initialize our byte array size.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用Android的`android.media.AudioRecord`类以及我们设置的各个录音设置，我们能够收集到一个初始的`bufferSize`，我们用它来初始化我们的字节数组大小。
- en: 'We then take advantage of our overall versatile design, wherein our model''s
    target in this implementation is an rxjs Subject Observable, allowing us to subscribe
    to its event stream. For the `''mic''` type, this stream will be the metering
    value changes from the recorder, which we use to fill our byte array and in turn
    update the `Horizon` view:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后利用我们整体灵活的设计，其中在这个实现中我们的模型目标是rxjs Subject Observable，这使得我们可以订阅其事件流。对于`'mic'`类型，这个流将是录音的计数值变化，我们用它来填充我们的字节数组，并相应地更新`Horizon`视图：
- en: '[PRE61]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This provides our recorder a nice visualization, which will animate as the
    input level changes. Here''s a preview; however, the style is still a little ugly,
    since we have not applied any CSS polish just yet:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了记录器一个很好的可视化效果，它将随着输入级别的变化而动画化。这里是一个预览；然而，风格仍然有点丑，因为我们还没有应用任何CSS润色：
- en: '![](img/00040.jpeg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00040.jpeg)'
- en: For our static audio file waveform rendering, we initialize `WaveformView` with
    the Android context. We then use its API to configure it for our use during construction
    in `createNativeView`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的静态音频文件波形渲染，我们在`createNativeView`构造过程中使用Android上下文初始化`WaveformView`。然后我们使用其API对其进行配置，以便在我们的使用中。
- en: 'During initialization, we create an instance of `CheapSoundFile` as required
    by `WaveformView`, and interestingly, we use `setSoundFile` inside `setTimeout`,
    alongside a call to `this.nativeView.invalidate()`, which is calling invalidate
    on `WaveformView`. This causes the native view to update with the processed file,
    as follows (again, we will address the styling polish later):'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化过程中，我们创建了一个`CheapSoundFile`实例，这是`WaveformView`所要求的，并且有趣的是，我们在`setTimeout`内部使用`setSoundFile`，同时调用`this.nativeView.invalidate()`，这是在调用`WaveformView`的invalidate。这导致原生视图使用处理后的文件进行更新，如下所示（再次，我们将在稍后解决风格润色问题）：
- en: '![](img/00041.jpeg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00041.jpeg)'
- en: Summary
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has introduced a wealth of powerful concepts and techniques on
    how to work with native APIs on iOS and Android. Knowing how to work with open
    source native libraries is fundamental to getting the most out of your app development
    and achieving the feature set you are after. Direct access to these APIs right
    from TypeScript gives you the luxury of never leaving your preferred development
    environment, as well as engaging with the languages you love in a fun and accessible
    way.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了大量关于如何在 iOS 和 Android 上使用原生 API 的工作的强大概念和技术。了解如何使用开源原生库对于充分利用您的应用程序开发并实现您所追求的功能集至关重要。直接从
    TypeScript 访问这些 API，让您享受从未离开您首选的开发环境的奢侈，同时以有趣和易于访问的方式与您所爱的语言互动。
- en: Additionally, learning solid practices around how/when to create custom NativeScript
    views and interworking them throughout your Angular app are among the key elements
    to leverage the most of this tech stack.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，学习如何/何时创建自定义 NativeScript 视图，并在您的 Angular 应用程序中与之交互，是充分利用这个技术栈的关键要素之一。
- en: In the next chapter, we will provide some extra goodies by empowering our track
    list view with more bells and whistles, leveraging some of what you've learned
    here.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过增强我们的播放列表视图，添加更多功能，利用在这里学到的一些知识，提供一些额外的精彩内容。
