- en: Entity Modeling with JHipster Domain Language
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JHipster 领域语言进行实体建模
- en: In the previous chapter, we saw how we can use JHipster to generate a production-grade
    web application with a lot of awesome features, such as i18n, administration modules,
    account management, and so on. In this chapter, we will see how we can enrich
    that application with business entities and a model.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何使用 JHipster 生成一个具有许多出色功能的生产级 Web 应用程序，例如 i18n、管理模块、账户管理等。在本章中，我们将看到如何通过业务实体和模型来丰富该应用程序。
- en: 'We will learn about the following in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: '**JHipster Domain Language **(**JDL**)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JHipster 领域语言（JDL**）(**JDL**)'
- en: JDL studio
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDL 工作室
- en: Entity and relationship modeling with JDL
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JDL 进行实体和关系建模
- en: Entity generation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体生成
- en: Introduction to JDL
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JDL 简介
- en: JDL ([http://www.jhipster.tech/jdl/](http://www.jhipster.tech/jdl/)) is used
    to create the domain model for a JHipster application. It provides a simple and
    user-friendly DSL to describe the entities and their relationships (for SQL databases
    only).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: JDL ([http://www.jhipster.tech/jdl/](http://www.jhipster.tech/jdl/)) 用于创建 JHipster
    应用程序的领域模型。它提供了一个简单且用户友好的 DSL 来描述实体及其关系（仅适用于 SQL 数据库）。
- en: JDL is the recommended way to create entities for an application and can replace
    the entity generator provided by JHipster, which can be difficult to use when
    creating a lot of entities. The JDL is normally written in one or more files with
    a `.jh` extension.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: JDL 是为应用程序创建实体的推荐方式，可以替代 JHipster 提供的实体生成器，在创建大量实体时使用起来可能比较困难。JDL 通常在具有 `.jh`
    扩展名的一个或多个文件中编写。
- en: Visit [http://www.jhipster.tech/jdl/](http://www.jhipster.tech/jdl/) for complete
    documentation on JDL.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 [http://www.jhipster.tech/jdl/](http://www.jhipster.tech/jdl/) 获取 JDL 的完整文档。
- en: If you prefer to work with UML and UML modeling tools, then check out JHipster-UML
    ([http://www.jhipster.tech/jhipster-uml/](http://www.jhipster.tech/jhipster-uml/)),
    a tool that can create entities from popular UML tools.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢使用 UML 和 UML 建模工具，那么请查看 JHipster-UML ([http://www.jhipster.tech/jhipster-uml/](http://www.jhipster.tech/jhipster-uml/))，这是一个可以从流行的
    UML 工具创建实体的工具。
- en: DSL grammar for JDL
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JDL 的 DSL 语法
- en: 'Now, let''s see the JDL grammar. At the time of writing, JDL supports generating
    complete entity models with relationships and options such as DTO, service layer,
    and so on. The grammar can be broken down into the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 JDL 语法。在撰写本文时，JDL 支持生成带有关系和选项（如 DTO、服务层等）的完整实体模型。语法可以分解为以下内容：
- en: Entity declaration
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体声明
- en: Relationship declaration
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系声明
- en: Options declaration
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选项声明
- en: In the following syntax, `[]` denotes optional and `*` denotes more than one
    can be specified.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下语法中，`[]` 表示可选，`*` 表示可以指定多个。
- en: Javadocs can be added to entity declarations and `/** */` Java comments can
    be added to fields and relationship declarations. JDL only comments can be added
    using `//` syntax.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将 Javadocs 添加到实体声明中，并将 `/** */` Java 注释添加到字段和关系声明中。可以使用 `//` 语法添加 JDL 仅注释。
- en: It is also possible to define numerical constants in JDL, for example, `DEFAULT_MIN_LENGTH
    = 1`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JDL 中也可以定义数值常量，例如，`DEFAULT_MIN_LENGTH = 1`。
- en: Entity modeling with JDL
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JDL 进行实体建模
- en: 'The entity declaration is done using the following syntax:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 实体声明使用以下语法进行：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`<entity name>` is the name of the entity and will be used for class names
    and table names. Table names can be overridden using the optional `<table name>`
    parameter.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`<entity name>` 是实体的名称，将用于类名和表名。表名可以使用可选的 `<table name>` 参数进行覆盖。'
- en: '`<field name>` is the name of the fields (attributes) you want for the entity
    and `<type>` is the field type, as in String, Integer, and so on. Refer to [http://www.jhipster.tech/jdl/#available-types-and-constraints](http://www.jhipster.tech/jdl/#available-types-and-constraints)
    for all supported field types. The ID field will be automatically created and
    hence need not be specified in JDL.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`<field name>` 是你想要为实体添加的字段（属性）的名称，而 `<type>` 是字段类型，例如 String、Integer 等。有关所有支持的字段类型，请参阅
    [http://www.jhipster.tech/jdl/#available-types-and-constraints](http://www.jhipster.tech/jdl/#available-types-and-constraints)。ID
    字段将自动创建，因此不需要在 JDL 中指定。'
- en: '`<validation>` is optional and one or more `<validation>` for the fields can
    be specified depending on the validation supported by the field type. For validations
    such as max length and pattern, values can be specified in braces.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`<validation>` 是可选的，并且可以根据字段类型支持的验证指定一个或多个 `<validation>` 字段。对于如最大长度和模式这样的验证，值可以在大括号中指定。'
- en: 'An example entity declaration would look like the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例实体声明可能如下所示：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Enumerations can also be declared using the following syntax:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下语法声明枚举：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here is an example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Relationship management
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关系管理
- en: 'The relationship between entities can be declared using this syntax:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用此语法声明实体之间的关系：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `<type>` is one from `OneToMany`, `ManyToOne`, `OneToOne`, or `ManyToMany`
    and as the name suggests, declares the relationship type between `<from entity>`
    and `<to entity>`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`<type>` 是 `OneToMany`、`ManyToOne`、`OneToOne` 或 `ManyToMany` 中的一个，正如其名，它声明了
    `<from entity>` 和 `<to entity>` 之间的关系类型。'
- en: '`<from entity>` is the name of the owner entity of the relationship or the
    source. `<to entity>` is the destination of the relationship.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`<from entity>` 是关系或源的所有者实体的名称。`<to entity>` 是关系的目的地。'
- en: '`<relationship name>` is optional and can be used to specify the field names
    to create for the relationship in the domain object. `<display field>` can be
    specified in braces to control the field of the entity to be shown in the drop-down
    menu on the generated web page, by default the ID field will be used. `<validation>`
    can be specified on the `<from entity>` or `<to entity>` and is optional. Currently,
    only required is supported.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`<relationship name>` 是可选的，可以用来指定在领域对象中创建的关系的字段名。`<display field>` 可以在括号中指定，以控制要在生成的网页上的下拉菜单中显示的实体字段，默认情况下将使用
    ID 字段。`<validation>` 可以在 `<from entity>` 或 `<to entity>` 上指定，是可选的。目前只支持必需的。'
- en: '`OneToMany` and `ManyToMany` relationships are always bidirectional in JHipster.
    In case of `ManyToOne` and `OneToOne` relationships, it is possible to create
    both bidirectional and unidirectional relationships. For unidirectional relationships,
    just skip the `<relationship name>` on the destination/to entity.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`OneToMany` 和 `ManyToMany` 关系在 JHipster 中总是双向的。在 `ManyToOne` 和 `OneToOne` 关系的情况下，可以创建双向和单向关系。对于单向关系，只需在目的地/实体上跳过
    `<relationship name>` 即可。'
- en: Multiple relationships of the same type can be declared within the same block,
    separated by a comma.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 同一类型的多个关系可以在同一块中声明，用逗号分隔。
- en: 'An example relationship declaration would look like the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例关系声明可能看起来像以下这样：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The user is an existing entity in JHipster and it is possible to have certain
    relationships with the user. Many-to-many and one-to-one relations can be declared,
    but the other entity must be the source or owner. Many-to-one relations are also
    possible with a user entity.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 用户是 JHipster 中的一个现有实体，可以与用户有某些关系。可以声明多对多和一对一关系，但其他实体必须是源或所有者。也可以与用户实体有多个一对一关系。
- en: DTO, service, and pagination options
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DTO、服务和分页选项
- en: 'JDL also allows us to declare entity related options easily. Options currently
    supported are:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: JDL 还允许我们轻松声明与实体相关的选项。当前支持的选项包括：
- en: '`service`: By default, JHipster generates REST Resource classes that call the
    entity repositories directly. This is the simplest option, but in real-world scenarios,
    we might need a service layer to handle business logic. This option lets us create
    a service layer with a simple Spring service bean class or with a traditional
    interface and implementation for the service bean. Possible values are `serviceClass`
    and`serviceImpl`. Choosing the latter will create an interface and implementation,
    which is preferred by some people.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`service`：默认情况下，JHipster 生成直接调用实体存储库的 REST 资源类。这是一个最简单的选项，但在现实世界的场景中，我们可能需要一个服务层来处理业务逻辑。此选项让我们可以创建一个简单的
    Spring 服务 bean 类或使用传统的接口和实现来创建服务 bean。可能的值是 `serviceClass` 和 `serviceImpl`。选择后者将创建一个接口和实现，这是某些人所偏好的。'
- en: '`dto`:  By default, domain objects are directly used in the REST endpoints
    created, which may not be desirable in some situations and you might want to use
    an intermediatory **Data Transfer Object** (**DTO**) to have more control. JHipster
    lets us generate the DTO layer using Mapstruct ([http://mapstruct.org/](http://mapstruct.org/)),
    an annotation preprocessor library that automatically generates the DTO classes.
    It is advisable to use a service layer when using DTO. A possible value is `mapstruct`.
    For more info visit: [http://www.jhipster.tech/using-dtos/](http://www.jhipster.tech/using-dtos/).'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dto`：默认情况下，领域对象直接用于创建的 REST 端点，这在某些情况下可能不是所希望的，你可能想使用一个中间的**数据传输对象**（**DTO**）来获得更多控制。JHipster
    允许我们使用 Mapstruct ([http://mapstruct.org/](http://mapstruct.org/)) 生成 DTO 层，Mapstruct
    是一个注解预处理库，它可以自动生成 DTO 类。当使用 DTO 时，建议使用服务层。可能的值是 `mapstruct`。更多信息请访问：[http://www.jhipster.tech/using-dtos/](http://www.jhipster.tech/using-dtos/)。'
- en: '`filter`: This option lets us enable JPA based filtering capabilities for the
    entity. This works only when a service layer is used. For more details, visit: [http://www.jhipster.tech/entities-filtering/](http://www.jhipster.tech/entities-filtering/).'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter`: 此选项允许我们为实体启用基于 JPA 的过滤功能。这仅在使用了服务层时才有效。更多详情请访问：[http://www.jhipster.tech/entities-filtering/](http://www.jhipster.tech/entities-filtering/)。'
- en: '`paginate`: This option lets us enable pagination for an entity. This enables
    pagination on the Resource layer and also implements a paging option on the client
    side. Possible values are pager, pagination, and infinite-scroll.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`paginate`: 此选项允许我们为实体启用分页功能。这将在资源层上启用分页，并在客户端实现分页选项。可能的值有 pager、pagination
    和 infinite-scroll。'
- en: '`noFluentMethod`: This lets us disable Fluent API style setters for the generated
    entity domain objects.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`noFluentMethod`: 这允许我们禁用为生成的实体域对象启用的 Fluent API 风格的设置器。'
- en: '`skipClient`/`skipServer`: These options let us either skip the client-side
    code or server-side code during generation.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skipClient`/`skipServer`: 这些选项允许我们在生成过程中跳过客户端代码或服务器端代码。'
- en: '`angularSuffix`: This option lets us specify a suffix for the folder and class
    names in the frontend code.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`angularSuffix`: 此选项允许我们为前端代码中的文件夹和类名指定后缀。'
- en: The general syntax for option declaration is `<OPTION> <ENTITIES | * | all> [with
    <VALUE>] [except <ENTITIES>]`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 选项声明的通用语法是 `<OPTION> <ENTITIES | * | all> [with <VALUE>] [except <ENTITIES>]`。
- en: 'The following are some possible options and different syntax in which they
    can be declared:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些可能的选项和它们可以声明的不同语法：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: JDL Studio
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JDL Studio
- en: 'We will be using JDL Studio ([https://start.jhipster.tech/jdl-studio/](https://start.jhipster.tech/jdl-studio/)) to
    create our JDL file. It is an online web application built by the JHipster team
    for creating JDL files in a visual editor. The tool shows a visual representation
    of the created entity model and also lets you import/export JDL and capture image
    snapshots:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 JDL Studio ([https://start.jhipster.tech/jdl-studio/](https://start.jhipster.tech/jdl-studio/))
    来创建我们的 JDL 文件。这是一个由 JHipster 团队构建的在线网络应用程序，用于在可视化编辑器中创建 JDL 文件。该工具显示了创建的实体模型的视觉表示，并允许您导入/导出
    JDL 和捕获图像快照：
- en: '![](img/2759a4bc-38aa-48fc-a2ac-043b42be3fe1.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2759a4bc-38aa-48fc-a2ac-043b42be3fe1.png)'
- en: The tool also provides features such as syntax highlighting, auto-completion,
    error reporting, and Sublime Text-style keyboard shortcuts.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 工具还提供诸如语法高亮、自动完成、错误报告和 Sublime Text 风格的键盘快捷键等功能。
- en: Navigate your favorite browser to [https://start.jhipster.tech/jdl-studio/](https://start.jhipster.tech/jdl-studio/)
    to open the application.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您喜欢的浏览器导航到 [https://start.jhipster.tech/jdl-studio/](https://start.jhipster.tech/jdl-studio/)
    以打开应用程序。
- en: Please note that by default this application stores the JDL in your browser's
    local storage. You can create an account with JHipster online if you want to save
    your JDL files to the cloud.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，默认情况下，此应用程序将 JDL 存储在您的浏览器本地存储中。如果您想将 JDL 文件保存到云端，可以使用 JHipster 在线创建账户。
- en: Use case entity model with explanation
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例实体模型及解释
- en: Now, let's look at our use case and the entity model. Before that, clear the
    default JDL in the JDL Studio editor.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们的用例和实体模型。在那之前，请清除 JDL Studio 编辑器中的默认 JDL。
- en: Entities
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体
- en: 'Let''s start by defining our entities:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义我们的实体：
- en: 'Copy the following snippet for `Product` and `ProductCategory` into the JDL
    Studio editor:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下片段复制到 `Product` 和 `ProductCategory` 的 JDL Studio 编辑器中：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `Product` entity is the core of the domain model; it holds product information
    such as `name`, `description`, `price`, `size`, and `image` which is a Blob. `name`,
    `price`, and `size` are required fields. `price` also has a min value validation.
    The `size` field is an enum with defined values.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`Product` 实体是域模型的核心；它包含产品信息，如 `name`、`description`、`price`、`size` 和 `image`（这是一个
    Blob）。`name`、`price` 和 `size` 是必填字段。`price` 还有一个最小值验证。`size` 字段是一个具有定义值的枚举类型。'
- en: The `ProductCategory` entity is used to group products together. It has `name`
    and `description` where `name` is a required field.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductCategory` 实体用于将产品分组在一起。它有 `name` 和 `description`，其中 `name` 是必填字段。'
- en: 'Add the following snippet for `Customer` into the JDL Studio editor:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下片段添加到 JDL Studio 编辑器的 `Customer` 中：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `Customer` entity holds details of the customers using the online shopping
    portal. Most of the fields are marked as required, the `email` field has regex
    pattern validation. The `gender` field is an `enum`. This entity is related to
    the system user which we will see in detail soon.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`Customer` 实体包含使用在线购物门户的客户的详细信息。大多数字段都被标记为必填项，`email` 字段有正则表达式模式验证。`gender`
    字段是一个枚举类型。此实体与我们将很快详细了解的系统用户相关。'
- en: 'Add the following snippet for `ProductOrder` and `OrderItem` into the JDL Studio
    editor:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下关于`ProductOrder`和`OrderItem`的片段添加到JDL Studio编辑器中：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `ProductOrder` and `OrderItem` entities are used to track product orders
    made by customers. `ProductOrder` holds the `placedDate` and `status`, and `code`
    of the order, which are all required fields, while `OrderItem` holds information
    about the `quantity`, `totalPrice`, and `status` of individual items. All fields
    are required and the `quantity` and `totalPrice` fields have min value validation.
    `OrderStatus` and `OrderItemStatus` are `enum` fields.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductOrder`和`OrderItem`实体用于跟踪客户制作的产品订单。`ProductOrder`包含订单的`placedDate`、`status`和`code`，这些都是必需字段，而`OrderItem`包含关于单个项目的`quantity`、`totalPrice`和`status`的信息。所有字段都是必需的，而`quantity`和`totalPrice`字段有最小值验证。`OrderStatus`和`OrderItemStatus`是枚举字段。'
- en: 'Add the following snippet for `Invoice` and `Shipment` into the JDL Studio
    editor:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下关于`Invoice`和`Shipment`的片段添加到JDL Studio编辑器中：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `Invoice` and `Shipment` entities are used to track the invoice and shipping
    for the product orders, respectively. Most of the fields in `Invoice` are required
    and the `status` and `paymentMethod` fields are enums.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`Invoice`和`Shipment`实体分别用于跟踪产品订单的发票和运输。`Invoice`中的大多数字段是必需的，而`status`和`paymentMethod`字段是枚举类型。'
- en: The enumerations are being used to contain the scope of certain fields, which
    gives more granular control over those fields.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举被用来包含某些字段的范围，这为这些字段提供了更细粒度的控制。
- en: Relationships
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关系
- en: 'Now that we have defined our entities, let''s add relationships between them:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的实体，让我们在它们之间添加关系：
- en: 'Add the following snippet for relationships into the JDL Studio editor:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下关于关系片段添加到JDL Studio编辑器中：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The first relationship declared is a unidirectional `OneToOne` between a `Customer`
    entity and the inbuilt `User` entity:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先声明的关系是一个`Customer`实体和内置的`User`实体之间的单向`OneToOne`关系：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It means the `Customer` entity knows about the `User` and is the owner of the
    relationship but the `User` doesn't know about the `Customer` and hence we will
    not be able to obtain customers from a `User`. This lets us map customers to the
    `User` entity and use that for authorization purposes later ensuring one customer
    can be mapped only to one system user.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`Customer`实体了解`User`并且是关系的所有者，但`User`并不知道`Customer`，因此我们无法从`User`中获取客户。这使我们能够将客户映射到`User`实体，并在以后用于授权目的，确保一个客户只能映射到一个系统用户。
- en: 'Add this snippet for relationships into the JDL Studio editor:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下关于关系的片段添加到JDL Studio编辑器中：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This one declares a unidirectional `ManyToOne` relationship from `OrderItem`
    to `Product`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个声明定义了从`OrderItem`到`Product`的单向`ManyToOne`关系：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It means the `OrderItem` knows their `Product` but `Product` does not know about
    `OrderItem`. This keeps the design clean as we don't want to know about orders
    from products for this use case. In the future, if we want to know the orders
    made for a product we could make this bi-directional.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`OrderItem`了解它们的`Product`，但`Product`并不知道`OrderItem`。这样设计保持了代码的整洁性，因为我们不希望在这个用例中从产品中了解订单。将来，如果我们想了解为某个产品制作的订单，我们可以使这种关系双向。
- en: 'Add the following snippet for relationship into the JDL Studio editor:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下关于关系片段添加到JDL Studio编辑器中：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This declaration is interesting, as we have multiple `OneToMany` declarations:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个声明很有趣，因为我们有多个`OneToMany`声明：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: They are all bidirectional, meaning both the source entity and destination entity
    know about each other.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都是双向的，意味着源实体和目标实体都知道对方。
- en: We declare that a `Customer` can have multiple ProductOrders, `ProductOrder` can
    have multiple OrderItems and Invoices, `Invoice` can have many `Shipment`, and
    `ProductCategory` can have many Products. From the destination entity, the source
    entities are mapped as `ManyToOne`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明一个`Customer`可以有多个`ProductOrder`，`ProductOrder`可以有多个`OrderItem`和发票，`Invoice`可以有多个`Shipment`，而`ProductCategory`可以有多个`Product`。从目标实体出发，源实体被映射为`ManyToOne`。
- en: Options for entities
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体选项
- en: 'Add the following snippet for options into the JDL Studio editor:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下关于选项片段添加到JDL Studio编辑器中：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the options, we keep it simple and declare that we want a service class for
    all entities. We also enabled pagination for some of the entities that may get
    a lot of entries over time.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在选项中，我们保持简单，声明我们想要为所有实体创建服务类。我们还为可能随着时间的推移获得大量条目的某些实体启用了分页。
- en: 'The diagram shows the complete model, with all the entities and their relationships
    as shown in JDL Studio:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图表显示了完整的模型，包括所有实体及其在JDL Studio中显示的关系：
- en: '![](img/383158ed-4758-42c6-8d8c-142ef607bdc3.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/383158ed-4758-42c6-8d8c-142ef607bdc3.jpg)'
- en: 'Now, let''s download this JDL file to our file system:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将此 JDL 文件下载到我们的文件系统中：
- en: Click on the download button in the upper-right-hand corner of the JDL Studio
    application.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 JDL Studio 应用程序右上角的下载按钮。
- en: Save the file with the name `online-store.jh` inside the `online-store` directory
    where we created our application in the previous chapter.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件以 `online-store.jh` 的名称保存在我们在上一章创建应用程序的 `online-store` 目录中。
- en: Entity generation with JHipster
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JHipster 生成实体
- en: Now, it's time to generate the domain model with our JDL. We will use the `import-jdl`
    command from JHipster for this.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候使用我们的 JDL 生成领域模型了。我们将使用 JHipster 的 `import-jdl` 命令来完成此操作。
- en: 'Open your favorite Terminal application and navigate to the `online-store`
    folder where we created the application earlier. Then, execute the `import-jdl`
    command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你喜欢的终端应用程序，导航到我们之前创建应用程序的 `online-store` 文件夹。然后，执行 `import-jdl` 命令：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This will trigger the entity creation process and you will be asked to confirm
    the overwriting of existing files with changes. Take a look at the following screenshot:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这将触发实体创建过程，你将被要求确认覆盖现有文件以应用更改。请查看以下截图：
- en: '![](img/73967f25-9074-43e2-9b36-4b9423d5728b.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/73967f25-9074-43e2-9b36-4b9423d5728b.png)'
- en: 'Enter *a* to confirm the overwrite of all files with changes. Once the files
    are generated, JHipster will trigger a `yarn webpack:build` step to rebuild the
    client side code. Once done you will see a success message like the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 *a* 以确认覆盖所有带有更改的文件。一旦文件生成，JHipster 将触发一个 `yarn webpack:build` 步骤来重新构建客户端代码。完成后，你将看到如下所示的成功消息：
- en: '![](img/4aafe021-078c-491f-b99b-7957d9e4a44a.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4aafe021-078c-491f-b99b-7957d9e4a44a.png)'
- en: 'Running `git status` on the Terminal shows us that five files were modified
    and a lot of new files added. Let''s commit the changes to Git. Execute the commands
    shown here:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端上运行 `git status` 显示我们修改了五个文件，并添加了许多新文件。让我们将更改提交到 Git。执行这里显示的命令：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Generated code walkthrough
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成代码流程
- en: Now let's take a look at what has been generated. Let's open the application
    code in our favorite IDE/editor. Let's take a look at what has been generated
    for the `Product` entity.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看生成了什么。让我们在我们的首选 IDE/编辑器中打开应用程序代码。让我们看看为 `Product` 实体生成了什么。
- en: 'You might have noticed that there is a `.jhipster` folder at the root of the
    project and if you look into it you will see a bunch of JSON files. Let''s look
    at `Product.json`. It holds metadata about the generated entity and is used by
    JHipster to regenerate and edit an entity when needed:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到项目根目录中有一个 `.jhipster` 文件夹，如果你查看它，你会看到一些 JSON 文件。让我们看看 `Product.json`。它包含有关生成实体的元数据，并由
    JHipster 在需要时用于重新生成和编辑实体：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Server-side source code
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端源代码
- en: Now let's look at the server-side code generated.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看生成的服务器端代码。
- en: Domain class for the entity
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体领域类
- en: 'In the `src/main/java/com/mycompany/store/domain` folder, you will find the
    entity domain object. Open `Product.java`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `src/main/java/com/mycompany/store/domain` 文件夹中，你会找到实体领域对象。打开 `Product.java`：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The entity class defines the fields and relationships.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 实体类定义了字段和关系。
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This annotation is used by Swagger to show useful documentation when the entity
    is used in an endpoint:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个注解由 Swagger 使用，当实体在端点中使用时显示有用的文档：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'These are JPA annotations declaring the POJO as an entity and mapping it to
    an SQL table:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 JPA 注解，它们声明 POJO 为实体并将其映射到 SQL 表：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This is a Hibernate annotation, which lets us enable level 2 cache for this
    entity. In our case using Hazelcast:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 Hibernate 注解，它允许我们为这个实体启用二级缓存。在我们的案例中，使用 Hazelcast：
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `id` field is special and is mapped as a generated value field. Depending
    on the DB, this field will use a native generation technique or a sequence provided
    by Hibernate. Since we are using MySQL, it will use the native DB primary key
    generation technique:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`id` 字段是特殊的，它被映射为一个生成值字段。根据数据库的不同，这个字段将使用原生生成技术或 Hibernate 提供的序列。由于我们使用 MySQL，它将使用原生的数据库主键生成技术：'
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This JPA annotation is used to map columns to fields and it can also be used
    to declare properties such as nullable, precision, scale, unique, and so on for
    the field:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 JPA 注解用于将列映射到字段，并且也可以用于声明字段的属性，如 nullable、precision、scale、unique 等：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'These are Bean validation annotations enabling validation for the fields:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 Bean 验证注解，用于对字段进行验证：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The image field is a Blob and it is marked by the Lob type since we are using
    MySQL. It also has an additional field to hold the content type information:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图片字段是一个Blob，由于我们使用MySQL，它被标记为Lob类型。它还有一个额外的字段来存储内容类型信息：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The Enumerated annotation is used to map Enum fields. These are stored as simple varchar
    fields in the DB:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用枚举注解映射枚举字段。这些字段在数据库中存储为简单的`varchar`字段：
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The relationships are mapped using annotations such as `@ManyToOne`, `@OneToMany`,
    `@OneToOne`, and `@ManyToMany`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 关系使用`@ManyToOne`、`@OneToMany`、`@OneToOne`和`@ManyToMany`等注解进行映射。
- en: 'Here, `ProductCategory` is mapped as `ManyToOne`; on the other side of the
    relationship Product is mapped as `OneToMany` as shown here:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`ProductCategory`被映射为`ManyToOne`；在关系的另一侧，`Product`被映射为`OneToMany`，如下所示：
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As you can see, the relationship also specifies a cache for it. It tells Jackson
    to ignore the field while converting to JSON to avoid a circular reference since `ProductCategory`
    is already mapped in `Product` entity:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，关系还指定了一个缓存。它告诉Jackson在转换为JSON时忽略该字段，以避免循环引用，因为`ProductCategory`已经在`Product`实体中进行了映射：
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This is a fluent setter generated by default along with the standard setter.
    This can be turned off by specifying the `noFluentMethod` for the entity in JDL.
    Fluent methods are handy as they let us chain setters as follows for more concise
    code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个默认生成的流畅设置器，与标准设置器一起生成。可以通过在JDL中指定实体的`noFluentMethod`来关闭它。流畅方法很方便，因为它们允许我们像以下这样链式设置设置器，以编写更简洁的代码：
- en: '[PRE33]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The corresponding table definitions and constraints are created using Liquibase
    and can be found in `src/main/resources/config/liquibase/changelog` with the file
    names `<timestamp>_added_entity_Product` and `<timestamp>_added_entity_constraints_Product.xml`,
    which automatically get applied to the database when we reload or start the application
    again.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的表定义和约束使用Liquibase创建，可以在`src/main/resources/config/liquibase/changelog`中找到，文件名为`<timestamp>_added_entity_Product`和`<timestamp>_added_entity_constraints_Product.xml`，这些文件在重新加载或再次启动应用程序时自动应用于数据库。
- en: Repository interface for the entity
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体的仓库接口
- en: 'In the `src/main/java/com/mycompany/store/repository` folder, you will find
    the entity repository service. Open `ProductRepository.java`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/main/java/com/mycompany/store/repository`文件夹中，你可以找到实体仓库服务。打开`ProductRepository.java`：
- en: '[PRE34]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The repository service is just an empty interface that extends the `JpaRepository`
    class. Since it is a Spring Data repository, the implementation is automatically
    created, allowing us to do all CRUD actions using this simple interface declaration.
    Additional repository methods can be added here easily. We will see about that
    in the next chapter.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库服务只是一个空的接口，它扩展了`JpaRepository`类。由于它是一个Spring Data仓库，实现是自动创建的，允许我们使用这个简单的接口声明执行所有CRUD操作。可以轻松地在此处添加额外的仓库方法。我们将在下一章中看到这一点。
- en: Service class for the entity
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体的服务类
- en: 'Since we opted to generate service classes for our entities, let''s look at
    one. In the `src/main/java/com/mycompany/store/service` folder, you will find
    the entity repository service. Open `ProductService.java`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们选择为我们的实体生成服务类，让我们看看其中一个。在`src/main/java/com/mycompany/store/service`文件夹中，你可以找到实体仓库服务。打开`ProductService.java`：
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The service uses constructor injection to get its dependencies, which are automatically
    injected by Spring during bean instantiation. The service is also marked as `@Transactional`
    to enable transaction management for data access. The service defines CRUD action
    methods. For example, the `findAll` method calls the equivalent repository method
    while adding a read-only transaction rule to it. You can see that the method already
    supports pagination and returns the results as `Page`. The `Page` and `Pageable`
    objects are provided by Spring and let us easily control pagination:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务使用构造函数注入来获取其依赖项，这些依赖项由Spring在bean实例化期间自动注入。该服务也被标记为`@Transactional`，以启用数据访问的事务管理。该服务定义了CRUD操作方法。例如，`findAll`方法调用等效的仓库方法，同时向其中添加只读事务规则。你可以看到该方法已经支持分页，并以`Page`的形式返回结果。`Page`和`Pageable`对象由Spring提供，使我们能够轻松控制分页：
- en: '[PRE36]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Resource class for the entity
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体的资源类
- en: 'In the `src/main/java/com/mycompany/store/web/rest` folder you will find the
    entity resource service. Open `ProductResource.java`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/main/java/com/mycompany/store/web/rest`文件夹中，你可以找到实体资源服务。打开`ProductResource.java`：
- en: '[PRE37]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The resource acts as the controller layer and in our case, it serves the REST
    endpoints to be used by our client-side code. The endpoint has a base mapping
    to `"/api"`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '资源充当控制器层，在我们的案例中，它为客户端代码提供 REST 端点。端点有一个基础映射到 `"/api"`:'
- en: '[PRE38]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: All the CRUD actions have equivalent mapping methods here, for example, the
    `getAllProducts` maps to the `findAll` from our service. The resource also handles
    pagination by adding appropriate headers for pagination.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 CRUD 动作都有等效的映射方法，例如，`getAllProducts` 映射到服务中的 `findAll`。资源还通过添加适当的分页头处理分页。
- en: Client side
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端
- en: The client-side resources for the entity are created in the `src/main/webapp/app/entities`
    folder. Let's take a look at the code created for the `Product` entity in the
    `product` folder.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 实体的客户端资源在 `src/main/webapp/app/entities` 文件夹中创建。让我们看看在 `product` 文件夹中为 `Product`
    实体创建的代码。
- en: TypeScript model class for the entity
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体的 TypeScript 模型类
- en: 'Let''s look at the TypeScript model generated in `product.model.ts`. This maps
    directly to the domain object:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在 `product.model.ts` 中生成的 TypeScript 模型。它直接映射到域对象：
- en: '[PRE39]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The fields are all optional making it possible to create an object instance
    without any values. You will also see that the enums are also generated alongside
    the model in the file.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 字段都是可选的，这使得在没有任何值的情况下创建对象实例成为可能。你还会看到枚举也在文件中的模型旁边生成。
- en: Angular services for the entity
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体的 Angular 服务
- en: 'The `ProductService` is an Angular service that interacts with our REST endpoints
    and created in `product.service.ts`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductService` 是一个与我们的 REST 端点交互的 Angular 服务，并在 `product.service.ts` 中创建：'
- en: '[PRE40]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As you can see, the service has a constructor with dependencies injected following
    a similar pattern as our server-side code. There are methods mapping all the CRUD
    actions to the backend REST Resource. The HTTP calls make use of RxJS Observables
    to provide an asynchronous streaming API, which is much better than a Promise
    based API.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，服务有一个构造函数，其中注入了依赖项，遵循与我们的服务器端代码类似的模式。有方法映射所有 CRUD 动作到后端 REST 资源。HTTP 调用利用
    RxJS Observables 提供异步流式 API，这比基于 Promise 的 API 要好得多。
- en: There is also `ProductPopupService` defined in `product-popup.service.ts`, a
    utility service to open popup dialogs for entity editing and deletion.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 同样在 `product-popup.service.ts` 中定义了 `ProductPopupService`，这是一个用于打开弹出对话框进行实体编辑和删除的实用服务。
- en: Angular components of the entity
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体的 Angular 组件
- en: For an entity, there are six component classes generated in four files and four
    HTML files that are used in the components.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个实体，有六个组件类在四个文件和四个 HTML 文件中生成，这些文件用于组件。
- en: '`ProductComponent`, defined in `product.component.ts` handles the main listing
    screen. It uses `product.component.html`, as the template. The component manages
    the view and their actions. It also calls multiple services to fetch data and
    to do other actions such as alerts and event broadcasts:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `product.component.ts` 中定义的 `ProductComponent` 处理主列表屏幕。它使用 `product.component.html`
    作为模板。该组件管理视图及其动作。它还调用多个服务来获取数据以及执行其他动作，如警报和事件广播：
- en: '[PRE41]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`product-dialog.component.ts` defines `ProductDialogComponent` and `ProductPopupComponent`,
    which handle the create/edit dialog page using `template product-dialog.component.html`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`product-dialog.component.ts` 定义了 `ProductDialogComponent` 和 `ProductPopupComponent`，它们使用
    `template product-dialog.component.html` 处理创建/编辑对话框页面：'
- en: '[PRE42]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`ProductDetailComponent` handles the detail view screen using `product-detail.component.html`
    as the template and is defined in `product-detail.component.ts`.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductDetailComponent` 使用 `product-detail.component.html` 作为模板来处理详细视图屏幕，并在
    `product-detail.component.ts` 中定义。'
- en: '`ProductDeleteDialogComponent` and `ProductDeletePopupComponent` defined in `product-delete-dialog.component.ts`
    manages the delete popup dialog using `product-delete-dialog.component.html` as
    the template.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `product-delete-dialog.component.ts` 中定义的 `ProductDeleteDialogComponent` 和
    `ProductDeletePopupComponent` 使用 `product-delete-dialog.component.html` 作为模板来管理删除弹出对话框。
- en: Angular route for the entity
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体的 Angular 路由
- en: We need a route declaration so that we can access the entity pages. This is
    declared in `product.route.ts`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个路由声明，以便我们可以访问实体页面。这已在 `product.route.ts` 中声明。
- en: 'For example, this declares the detail view of the entity:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这声明了实体的详细视图：
- en: '[PRE43]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The data attribute is used to pass metadata such as allowed roles and page
    titles to the component. The `UserRouteAccessService` defined in the `canActivate` attribute
    decides whether a user has the authorization to view the page and uses the authorities
    metadata and authentication details to verify. Routes having a popup, declares
    the `outlet: ''popup''` attribute.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '数据属性用于传递元数据，例如允许的角色和页面标题到组件。在 `canActivate` 属性中定义的 `UserRouteAccessService`
    决定用户是否有权限查看页面，并使用权限元数据和认证详情进行验证。具有弹出窗口的路由声明了 `outlet: ''popup''` 属性。'
- en: Angular module for the entity
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体的 Angular 模块
- en: 'Finally, we have a module for the entity. Angular modules can be used to consolidate
    all components, directives, pipes, and services of an entity so that they can
    be imported into other modules easily. The `StoreProductModule` module is defined
    in `product.module.ts`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个用于实体的模块。Angular 模块可以用来整合实体的所有组件、指令、管道和服务，以便它们可以轻松地导入到其他模块中。`StoreProductModule`
    模块在 `product.module.ts` 中定义：
- en: '[PRE44]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The module declares the components and registers services provided by it. The
    module also imports shared modules so that it can access shared services and components.
    The module is imported by the `StoreEntityModule` defined in `entity.module.ts`
    under `src/main/webapp/app/entities`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块声明了组件并注册了它提供的服务。该模块还导入共享模块，以便它可以访问共享服务和组件。该模块由 `entity.module.ts` 下的 `StoreEntityModule`
    在 `src/main/webapp/app/entities` 中导入。
- en: Generated pages
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成的页面
- en: 'Let''s start the application to view the generated pages. In the Terminal,
    execute the Gradle command the follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启动应用程序以查看生成的页面。在终端中执行以下 Gradle 命令：
- en: '[PRE45]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This will start the server in development mode locally. Since the `import-jdl`
    step already compiled the frontend code, we don't have to run `yarn start` just
    to see the new pages, but please note that for further development it is better
    to use `yarn start` along with the preceding command. If you had the server already
    running while generating the entities, then no need to run this command, instead
    just compile the source again using the `./gradlew compileJava` command. Using
    your IDE and Spring devtools will hot reload the application for you. If you had
    `yarn start` running then a hot reload will take place on the client side as well,
    otherwise, it will just refresh the page. We will see more about hot reloading
    in the next chapter.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在本地以开发模式启动服务器。由于 `import-jdl` 步骤已经编译了前端代码，我们不需要运行 `yarn start` 只是为了查看新页面，但请注意，为了进一步开发，最好使用
    `yarn start` 与前面的命令一起使用。如果你在生成实体时服务器已经运行，那么不需要运行此命令，而是只需使用 `./gradlew compileJava`
    命令重新编译源代码。使用你的 IDE 和 Spring devtools 将为你热重载应用程序。如果你有 `yarn start` 运行，客户端也将进行热重载，否则，它只会刷新页面。我们将在下一章中了解更多关于热重载的信息。
- en: 'Once you see the following message, the server is ready and we can navigate
    to the URL `http://localhost:8080` in our favorite browser:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你看到以下消息，服务器就准备好了，我们可以通过我们喜欢的浏览器导航到 URL `http://localhost:8080`：
- en: '[PRE46]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If you are not already logged in, sign in using the default admin user with
    the password `admin` by clicking on the Sign in link on the home page. Once logged
    in, click on the Entities link in the menu and you will see all our entities listed
    there:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有登录，请使用默认管理员用户 `admin` 和密码通过点击主页上的登录链接进行登录。登录后，点击菜单中的实体链接，你将看到所有我们的实体都列在那里：
- en: '![](img/8bfb4e57-74ce-4d6d-816b-4ba5702bb321.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8bfb4e57-74ce-4d6d-816b-4ba5702bb321.png)'
- en: 'Click on the Product and you will see the Products listing screen. It doesn''t
    have any items yet as we haven''t created any:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 点击产品，你将看到产品列表屏幕。目前还没有任何项目，因为我们还没有创建任何：
- en: '![](img/202a2acd-6872-49dd-94b6-1f84b625a5b0.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/202a2acd-6872-49dd-94b6-1f84b625a5b0.png)'
- en: 'Let''s create an entity, click on the Create a new Product button on the screen
    and you will see the Create or edit a Product popup dialog:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个实体，点击屏幕上的创建新产品按钮，你将看到创建或编辑产品的弹出对话框：
- en: '![](img/43c697e8-5b03-455d-9f97-80897e761feb.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/43c697e8-5b03-455d-9f97-80897e761feb.png)'
- en: 'Enter `Name`, `Description`, `Price`, and `Size`. Choose an image by clicking
    on the Choose file button. Don''t worry about Product Category as we haven''t
    created any yet. Now click on Save and the popup will disappear and the listing
    screen will be refreshed with the success message:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 `名称`、`描述`、`价格` 和 `大小`。通过点击选择文件按钮选择一个图片。不用担心产品类别，因为我们还没有创建任何类别。现在点击保存，弹出窗口将消失，并且列表屏幕将刷新并显示成功消息：
- en: '![](img/117792dc-54ac-46cb-9a11-656c4191fec6.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/117792dc-54ac-46cb-9a11-656c4191fec6.png)'
- en: The Products screen now shows our new entity with buttons for View, Edit, and
    Delete. There are also pagination links on the bottom. Explore the View, Edit, and Delete
    buttons by clicking on each of them.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 产品屏幕现在显示我们的新实体，并带有查看、编辑和删除按钮。底部还有分页链接。通过点击每个按钮来探索查看、编辑和删除按钮。
- en: Running generated tests
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行生成的测试
- en: Let's run all the tests to make sure the generated test code works fine.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行所有测试以确保生成的测试代码运行良好。
- en: 'Let''s run the server-side unit/integration tests, client-side Karma unit tests,
    and Protractor e2e tests using the command-line. In a new Terminal, navigate to
    the application source folder and execute these commands. They should finish with
    a success message. Make sure you have the application running, as e2e tests will
    need it. If the application is not running first start it by running `./gradlew`
    in a Terminal:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令行运行服务器端单元/集成测试、客户端 Karma 单元测试和 Protractor 端到端测试。在一个新的终端中，导航到应用程序源文件夹并执行以下命令。它们应该以成功消息结束。确保应用程序正在运行，因为端到端测试需要它。如果应用程序尚未运行，请先通过在终端中运行
    `./gradlew` 来启动它：
- en: '[PRE47]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Summary
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how to model and create entities using JDL. We also
    walked through important aspects of the created source code. We also browsed through
    the created entity modules and saw them in action. In the next chapter, we will
    see how we can utilize JHipster to further develop the application and include
    specific business logic and tweaks. We will also learn about some of the technologies
    used in more depth.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何使用 JDL 来建模和创建实体。我们还探讨了创建源代码的重要方面。我们还浏览了创建的实体模块，并看到了它们在实际中的应用。在下一章中，我们将看到如何利用
    JHipster 进一步开发应用程序，并包括特定的业务逻辑和调整。我们还将深入了解所使用的某些技术。
