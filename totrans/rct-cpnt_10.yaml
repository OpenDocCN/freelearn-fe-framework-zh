- en: Chapter 10. Testing Components
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。测试组件
- en: In the last chapter, we looked at ways of making our components friendly for
    plugin developers. We saw a few of the benefits of dependency injection and how
    AdonisJS Fold can help us achieve it with minimal effort.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一章，我们探讨了使我们的组件对插件开发者友好的方法。我们看到了依赖注入的一些好处以及AdonisJS Fold如何帮助我们以最小的努力实现它。
- en: In this chapter, we will learn about testing—automated testing, effective testing,
    before-you-make-a-mess-of-your-code testing. We will learn about the benefits
    of testing and the different kinds of tests.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习关于测试——自动化测试、有效测试、在编写代码之前进行测试。我们将学习测试的好处和不同类型的测试。
- en: Eat your vegetables
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 吃你的蔬菜
- en: Is there something you really don't like to eat? Perhaps it's a kind of vegetable
    or fruit. When I was a kid, there were many things I didn't like to eat. I couldn't
    even remember what many of them tasted like, and they didn't hurt me. I just made
    up my mind that they were bad, and I didn't like them.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你真的不喜欢吃某样东西吗？可能是一种蔬菜或水果。当我还是个孩子的时候，有很多我不喜欢吃的食物。我甚至记不起它们是什么味道的，它们也没有伤害到我。我只是下定决心认为它们不好，我不喜欢它们。
- en: Some developers have similar habits. Are there things you don't like to do as
    a developer? Not because they're difficult or bad, but just because...
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者有类似的习惯。作为开发者，你不喜欢做什么？不是因为它们困难或不好，只是因为...
- en: For me, testing was one of those things. I learned about testing many years
    after I started programming, and it's still something I need to actively work
    on. I know why it's good, and why the common arguments against testing are bad.
    Still, I need to convince myself to continually test my work well.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，测试就是这样一件事。我在开始编程多年后才了解到测试，而且这仍然是我需要积极努力的事情。我知道为什么它好，为什么反对测试的常见论点是错误的。尽管如此，我仍需要说服自己不断对我的工作进行良好的测试。
- en: I had to learn that it's not enough just to click through an interface, that
    testing isn't really testing unless it can be run automatically, that testing
    isn't really useful unless it happens continuously, and that testing is often
    very useful as part of a design phase before any implementation happens.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须学会，仅仅点击界面是不够的，测试除非可以自动运行，否则不是真正的测试，测试除非是持续进行的，否则不是真正有用的，而且测试通常在实施之前作为设计阶段的一部分非常有用。
- en: Here are some reasons why I believe these things. Perhaps you'll find them useful
    as you learn about testing or even as you try to convince people why they should
    plan and budget for testing.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些我认为的理由。也许你在学习测试或试图说服人们为什么他们应该为测试制定计划和预算时，会发现它们有用。
- en: Note
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: I can't stress enough on the importance of testing. The concepts we look at
    here are just the tip of the iceberg. If you really want to learn about testing
    and writing testable code, I highly recommend that you read *Clean Code* (by Robert
    C. Martin).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我无法强调测试的重要性。我们在这里探讨的概念只是冰山一角。如果你真的想了解测试和编写可测试的代码，我强烈推荐你阅读*《代码整洁之道》*（罗伯特·C·马丁著）。
- en: Design by testing
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过测试进行设计
- en: Testing can be a powerful design tool for code as much as wireframes can be
    for interactive interfaces. Sometimes, it's good to make a rapid prototype of
    the code you think can work for you. But once you know how you want your code
    to behave, it's useful to write some assertions for this behavior.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 测试可以是代码的强大设计工具，就像线框可以是交互式界面的设计工具一样。有时，快速制作你认为可以为你工作的代码原型是好的。但一旦你知道你希望你的代码如何表现，为这种行为编写一些断言是有用的。
- en: Put the prototype to one side and start creating a checklist of the behavior
    you now know your code should have. Perhaps this is a good time to involve the
    product owners, as you essentially create a contract of functionality you have
    yet to implement.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 把原型放在一边，开始创建一个清单，列出你现在知道你的代码应该具有的行为。也许这是一个好时机让产品负责人参与，因为你实际上创建了一个尚未实现的功能合同。
- en: This kind of a testing-first approach is often referred to as **test-driven
    development** (**TDD**). Tests are useful whether or not you write them first.
    But if you do write them first, they can help you shape the behavior of your code
    at a critical stage of a project.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这种先测试后开发的方法通常被称为**测试驱动开发**（**TDD**）。测试的有用性不在于你是否先编写它们。但如果你先编写它们，它们可以帮助你在项目的关键阶段塑造代码的行为。
- en: Documentation by testing
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过测试进行文档编写
- en: Unless you have a folder of examples or extensive documentation, tests may be
    the only way for you to demonstrate what your code is supposed to do and how it
    is supposed to do it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你有示例文件夹或广泛的文档，否则测试可能是你展示代码应该做什么以及如何做的唯一方式。
- en: You (or the developers who work with your code) may know little of what your
    code is supposed to do, but if you write good tests, they can learn interesting
    things about it. Tests can reveal the parameters of functions, the ways in which
    functions break, and even what code is unused.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你（或与你代码一起工作的开发者）可能对你的代码应该做什么知之甚少，但如果你编写了好的测试，他们可以从中了解到一些有趣的事情。测试可以揭示函数的参数、函数崩溃的方式，甚至是不再使用的代码。
- en: Sleep by testing
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过测试来睡眠
- en: Few things set me on edge quite like deploying critical code changes to large
    production systems. Does your team follow the "never deploy on a Friday" rule?
    If you had a good suite of tests, you could deploy fearlessly.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎没有什么事情能像将关键代码更改部署到大型生产系统那样让我感到紧张。你们团队是否遵循“周五永不部署”的规则？如果你有一套好的测试，你就可以毫无畏惧地部署。
- en: Tests are an excellent way to discover regressions in code. Want to know if
    a change you're making will affect other parts of the application? If the application
    is well tested, you'll know the moment it does.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是发现代码中回归的绝佳方式。想知道你做的更改是否会影响到应用程序的其他部分吗？如果应用程序经过良好的测试，你会在它发生的那一刻就知道。
- en: In summary, a good test suite will help you keep your code doing what it should
    and let you know when you've broken it. Tests are great.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，一个好的测试套件将帮助你保持代码按照预期运行，并在你破坏它时通知你。测试是极好的。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Whether you write tests before or after the rest of your application code, having
    any tests is usually better than having no tests. You don't have to follow TDD
    principles, but they have been known to improve the design of code. And grown-ups
    know to try broccoli before dismissing it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是在编写应用程序代码之前还是之后编写测试，有测试通常比没有测试要好。你不必遵循TDD原则，但它们已被证明可以改善代码的设计。成年人知道在拒绝西兰花之前先尝试一下。
- en: Types of tests
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试类型
- en: Many books can (and have been) filled with the intricacies of testing. There's
    a lot of jargon and we could go on for quite some time. Instead, I want to focus
    on a handful of terms, which I think will be most useful to us. There are two
    common kinds of tests we can write.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 许多书籍可以（并且已经被）充满测试的复杂性。有很多术语，我们可以讨论很长时间。相反，我想专注于一些我认为对我们最有用的术语。我们可以编写两种常见的测试。
- en: Unit tests
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: Unit tests are tests that focus on one small, practical unit of work at a time.
    Given a non-trivial class or component, a unit test will focus on just one method
    or even just a single part of that method (if the method does many things).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是专注于一次一个小型、实际工作单元的测试。给定一个非平凡的类或组件，单元测试将专注于一个方法，甚至只是这个方法的一部分（如果这个方法做了很多事情）。
- en: 'To illustrate this, consider the following example code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，考虑以下示例代码：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In previous chapters, we created a workflow for being able to run the ES6 code
    through Node.js. I recommend that you recreate this setup for some of the code
    in this chapter, or use a site such as [http://jsbin.com/](http://jsbin.com/).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们创建了一个工作流程，可以通过Node.js运行ES6代码。我建议你为本章的一些代码重新创建这个设置，或者使用像[http://jsbin.com/](http://jsbin.com/)这样的网站。
- en: 'A unit test for the `Page` component could be something like this: given an
    instance of this component, and an object with a title `"Home"` and content `"A
    welcome message"`, when I call something such as `ReactDOMServer.render`, I see
    markup containing an `h1` element with the same title and a few `data-reactid`
    attributes.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Page`组件的单元测试可能如下：给定这个组件的一个实例，一个包含标题`"Home"`和内容`"欢迎信息"`的对象，当我调用类似`ReactDOMServer.render`的操作时，我可以看到包含具有相同标题的`h1`元素和一些`data-reactid`属性的标记。
- en: We test a small, practical unit of work. In this case, `Page` has a single method
    with a small focus. We can test the whole component at once, assured that we're
    testing something small and focused.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测试一个小型、实际的工作单元。在这种情况下，`Page`有一个单一的方法，具有小的关注点。我们可以一次性测试整个组件，确保我们测试的是小而专注的东西。
- en: 'On the other hand, a unit test for `Pages` can be something like this: given
    an instance of this component with the `pages` property containing an array of
    well-formed page objects, when I call `getPageComponents`, the `getPageComponent`
    method is called once for each page object with the correct properties each time.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`Pages`的单元测试可能如下：给定一个包含一个包含良好格式化页面对象的`pages`属性的组件实例，当我调用`getPageComponents`时，`getPageComponent`方法对每个页面对象调用一次，每次都带有正确的属性。
- en: We would write separate tests for each method since they have different focuses
    and produce different results. We wouldn't test all of the pages together in a
    unit test.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会为每个方法编写单独的测试，因为它们有不同的焦点和产生不同的结果。我们不会在单元测试中将所有页面一起测试。
- en: Functional tests
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能测试
- en: 'As compared to unit tests, functional tests are less concerned with such a
    narrow focus. Functional tests still test more areas, but they don''t require
    as much unit isolation as unit tests. We can test the whole `Pages` component
    in a single functional test, perhaps, as follows: given an instance of this component
    with the `pages` property containing an array of well-formed page objects, when
    I call something such as `ReactDOMServer.render`, I see markup containing all
    pages and their correct properties.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 与单元测试相比，功能测试不太关注如此狭窄的焦点。功能测试仍然测试更多区域，但它们不需要像单元测试那样多的单元隔离。我们可以在单个功能测试中测试整个`Pages`组件，例如：给定一个包含一个包含良好格式化页面对象的`pages`属性的组件实例，当我调用类似于`ReactDOMServer.render`的操作时，我看到包含所有页面及其正确属性的标记。
- en: We can test a lot more in a shorter period of time using functional tests. The
    downside to this is that the causes of errors are harder to pinpoint. Unit tests
    immediately point to the causes of smaller errors, while functional tests often
    only show that the group of functionality isn't working as expected.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用功能测试，我们可以在更短的时间内测试更多内容。缺点是错误的原因更难定位。单元测试立即指向较小错误的根源，而功能测试通常只显示功能组没有按预期工作。
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All of this is to say—the more accurately and granularly you test your code,
    the easier it will be to pinpoint the causes of errors. You can write a single
    functional test or 20 unit tests for the same code. So you need to balance the
    available time with the importance of detailed testing.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是为了说明——你测试代码越准确、越细致，定位错误原因就越容易。你可以为同一代码编写一个功能测试或20个单元测试。因此，你需要平衡可用时间和详细测试的重要性。
- en: Testing with assertions
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用断言进行测试
- en: 'Assertions are the spoken/written language constructs made in the code. They
    look and function similar to how I''ve been speaking about them. In fact, most
    tests are structured in the same way we''ve been describing tests:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 断言是代码中的口语/书面语言结构。它们看起来和功能与我之前描述的相似。事实上，大多数测试都是按照我们描述测试的方式构建的：
- en: Given some pre-conditions
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一些前置条件
- en: When something happens
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当发生某些事情时
- en: We see some post-conditions
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以看到一些后置条件
- en: 'The first two points happen as we create objects and components and call their
    various methods. Assertions happen in the third point. Node.js ships with a few
    basic assertion methods, which we can use to write our first tests:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 前两点发生在我们创建对象和组件并调用它们的各种方法时。断言发生在第三点。Node.js自带一些基本的断言方法，我们可以使用它们来编写我们的第一个测试：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There are quite a few assertion methods we can use:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用相当多的断言方法：
- en: '`assert(condition), assert.ok(condition)`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert(condition), assert.ok(condition)`'
- en: '`assert.equal(actual, expected)`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert.equal(actual, expected)`'
- en: '`assert.notEqual(actual, expected)`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert.notEqual(actual, expected)`'
- en: '`assert.strictEqual(actual, expected)`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert.strictEqual(actual, expected)`'
- en: '`assert.notStrictEqual(actual, expected)`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert.notStrictEqual(actual, expected)`'
- en: '`assert.deepEqual(actual, expected)`…'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert.deepEqual(actual, expected)`…'
- en: '`assert.notDeepStrictEqual(actual, expected)`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert.notDeepStrictEqual(actual, expected)`'
- en: '`assert.throws(function, type)`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assert.throws(function, type)`'
- en: You can add an optional custom message string to the parameters for any of these
    methods. The custom message will be displayed in place of the default error messages
    for each of these.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为这些方法的参数添加一个可选的自定义消息字符串。自定义消息将替换每个方法的默认错误消息。
- en: We can write these quite simply—creating a `tests.js` file, importing classes
    and components, and making assertions against their methods and markup.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以非常简单地编写这些测试——创建一个`tests.js`文件，导入类和组件，并对它们的方法和标记进行断言。
- en: 'If you prefer a more expressive syntax, consider installing the `assertthat`
    library:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢更丰富的语法，考虑安装`assertthat`库：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can then write tests similar to the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以编写类似的测试：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The example code for this chapter includes tests that you can inspect and run.
    I''ve also created a BabelJS-powered way to use ES6 and JSX in the tests. You
    can run the tests with the following command:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码包括您可以检查和运行的测试。我还创建了一种使用BabelJS的方式，可以在测试中使用ES6和JSX。您可以使用以下命令运行测试：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This runs the NPM script defined as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这将运行以下定义的NPM脚本：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Don't be alarmed if you see nothing after running that. The tests are set up
    in such a way that you'll only see errors if the tests fail. If you see no errors,
    everything is OK!
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行后您什么也没看到，请不要惊慌。测试被设置为这样的方式，只有当测试失败时您才会看到错误。如果您没有看到错误，那么一切正常！
- en: Testing for immutability and idempotence
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试不可变性和幂等性
- en: 'When we looked at Flux and Redux, one of the interesting things we saw is that
    they recommend immutable types and idempotent functionality (like in reducers).
    If we were to test for these qualities, we can! Let''s install a helper library:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看Flux和Redux时，我们看到的一个有趣的事情是他们推荐使用不可变类型和幂等功能（如在reducers中）。如果我们想要测试这些特性，我们可以！让我们安装一个辅助库：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, let''s consider the following example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们考虑以下示例：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If this is unfamiliar to you, refer back to the chapter on design patterns ([Chapter
    8](ch08.html "Chapter 8. React Design Patterns"), *React Design Patterns*).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这对你来说不熟悉，请参阅关于设计模式的章节([第8章](ch08.html "第8章。React设计模式")，*React设计模式*)。
- en: Here, we have an example reducer, store, and assertion. The reducer handles
    a single action—adding new pages. When we dispatch an `ADD_PAGE` action to the
    store, the reducer adds a new page to the `pages` state array. This reducer is
    not idempotent—it cannot be run with the same input and always produce the same
    output.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个示例reducer、store和断言。该reducer处理单个动作——添加新页面。当我们向store发送`ADD_PAGE`动作时，reducer会将新页面添加到`pages`状态数组中。这个reducer不是幂等的——它不能使用相同的输入运行并总是产生相同的输出。
- en: 'We can see this by freezing the default state:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过冻结默认状态来查看这一点：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When we run this, we should see an error such as `Can''t add property 0, object
    is not extensible`. Remember that we can fix this problem by returning a new,
    modified state object from our reducer:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个时，我们应该会看到一个错误，例如`无法添加属性0，对象不可扩展`。请记住，我们可以通过从我们的reducer返回一个新的、修改后的状态对象来解决这个问题：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, we can dispatch the same actions and always get the same results. We're
    no longer modifying the state in-place, but rather returning a new, modified state.
    The particulars of idempotence and immutability are better explained elsewhere;
    but the important thing to note is how we test for idempotence.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以发送相同的动作并总是得到相同的结果。我们不再就地修改状态，而是返回一个新的、修改后的状态。幂等性和不可变性的具体细节在其他地方有更好的解释；但重要的是要注意我们如何测试幂等性。
- en: We can freeze the objects/arrays we want to remain idempotent and be assured
    that we're not modifying the things we don't want to modify.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以冻结我们想要保持幂等的对象/数组，并确信我们没有修改我们不希望修改的东西。
- en: Connecting to Travis
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接到Travis
- en: Having tests is a great first step toward better code, but it's also important
    to run them often. There are many ways to do this (such as Git hooks or build
    steps), but the way I prefer is to connect my projects to *Travis*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有测试是迈向更好代码的伟大第一步，但经常运行它们也很重要。有许多方法可以做到这一点（例如Git钩子或构建步骤），但我更喜欢将我的项目连接到*Travis*。
- en: Travis is a continuous integration service, meaning that Travis watches for
    changes in a GitHub repository ([https://github.com](https://github.com)) and
    triggers tests for those changes.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Travis是一个持续集成服务，这意味着Travis会监视GitHub仓库([https://github.com](https://github.com))中的更改，并为这些更改触发测试。
- en: '![Connecting to Travis](img/5268_10_01.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![连接到Travis](img/5268_10_01.jpg)'
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We will look at how to connect Travis to a GitHub repository, which means we
    need a GitHub repository already set up. I will not go into detail about how to
    use GitHub, but you can find an excellent tutorial at [https://guides.github.com/activities/hello-world](https://guides.github.com/activities/hello-world).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨如何将Travis连接到GitHub仓库，这意味着我们需要一个已经设置好的GitHub仓库。我不会详细介绍如何使用GitHub，但您可以在[https://guides.github.com/activities/hello-world](https://guides.github.com/activities/hello-world)找到一个优秀的教程。
- en: 'You can sign in to Travis by logging into your GitHub account and clicking
    on one of the **Sign in with GitHub** buttons. Hover over your profile and click
    on **Accounts**:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过登录GitHub账户并点击一个**使用GitHub登录**按钮来登录Travis。将鼠标悬停在您的个人资料上，然后点击**账户**：
- en: '![Connecting to Travis](img/5268_10_02.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![连接到Travis](img/5268_10_02.jpg)'
- en: 'Enable the repositories you would like Travis to check. In addition, you need
    to create a configuration file called `.travis.yml`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 启用你希望Travis检查的仓库。此外，你还需要创建一个名为`.travis.yml`的配置文件：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This tells Travis to test this project as a Node.js project and to test it
    against version 5.5\. By default, Travis will run `npm install` before any tests.
    It will also run `npm test` to run the actual tests. We can enable this command
    by adding the following to `package.json`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉Travis将此项目作为Node.js项目进行测试，并针对版本5.5进行测试。默认情况下，Travis将在任何测试之前运行`npm install`。它还会运行`npm
    test`来执行实际的测试。我们可以通过在`package.json`中添加以下内容来启用此命令：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you've put your tests in another file, you'll need to adjust that command
    to reflect what you type to run your tests. It's nothing more than a common alias.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将测试放在了另一个文件中，你需要调整该命令以反映你运行测试时输入的内容。这不过是一个常见的别名。
- en: After you commit code to your repository, Travis should test that code for you.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在你将代码提交到你的仓库后，Travis应该会为你测试这些代码。
- en: '![Connecting to Travis](img/5268_10_03.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![连接到Travis](img/5268_10_03.jpg)'
- en: Note
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can learn more about Travis at [https://docs.travis-ci.com/user/for-beginners](https://docs.travis-ci.com/user/for-beginners).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://docs.travis-ci.com/user/for-beginners](https://docs.travis-ci.com/user/for-beginners)了解更多关于Travis的信息。
- en: End-to-end testing
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 端到端测试
- en: You may also want to try testing your application as a normal user would. You
    already do this as you click through the application you're developing to check
    whether things you just typed work as you expect. Why not automate the process?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还希望尝试以普通用户的方式测试你的应用程序。当你点击你正在开发的应用程序以检查你刚刚输入的内容是否按预期工作的时候，你已经在做这件事了。为什么不自动化这个过程呢？
- en: There are quite a few tools for this. The one I've enjoyed using is called *Protractor*.
    It can be a little tricky to set up, but there's an excellent tutorial on the
    subject at [http://www.joelotter.com/2015/04/18/protractor-reactjs.html](http://www.joelotter.com/2015/04/18/protractor-reactjs.html).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多这样的工具。我最喜欢使用的是名为*Protractor*的工具。设置起来可能有点棘手，但关于这个主题有一个非常优秀的教程，可以在[http://www.joelotter.com/2015/04/18/protractor-reactjs.html](http://www.joelotter.com/2015/04/18/protractor-reactjs.html)找到。
- en: Summary
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about the benefits of writing tests and running
    them often. We created a few tests for our classes and components and made assertions
    about their behavior.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了编写测试和经常运行测试的好处。我们为我们的类和组件创建了一些测试，并对它们的行为做出了断言。
- en: We've now covered all the topics I want to share with you. Hopefully, they've
    given you all the tools to start creating interfaces with confidence. We've learned
    so much together; covering topics such as single component designs and states,
    how components talk to each other (through things such as context), how to structure
    and decorate the whole system, and even how to test it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经涵盖了我想与你分享的所有主题。希望它们为你提供了开始自信地创建界面的所有工具。我们一起学到了很多；涵盖了单组件设计和管理状态、组件如何相互通信（通过如上下文这样的方式）、如何构建和装饰整个系统，甚至如何对其进行测试。
- en: The React community is just beginning, and you can join it and influence it.
    All it will take is for you to spend a bit of time building things with React
    and talking to others about your experiences doing so.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: React社区才刚刚开始，你可以加入其中并影响它。你所需要做的只是花一点时间用React构建一些东西，并与他人分享你的经验。
