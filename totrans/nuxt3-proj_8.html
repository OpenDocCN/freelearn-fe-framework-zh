<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer094">
			<h1 id="_idParaDest-166" class="chapter-number"><a id="_idTextAnchor165"/>8</h1>
			<h1 id="_idParaDest-167"><a id="_idTextAnchor166"/>Creating a Custom Translation Module in a Nuxt 3 Monorepo</h1>
			<p>In <a href="B19760_08.xhtml#_idTextAnchor165"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, we will learn how to build a custom <strong class="source-inline">translation</strong> module within a Nuxt 3 monorepo. This chapter is designed to guide you through the complexities of monorepo setup and modular development, providing a complete foundation for managing large-scale <span class="No-Break">projects efficiently.</span></p>
			<p>We will start by setting up a monorepo using <strong class="source-inline">pnpm</strong> workspaces, emphasizing the benefits of centralized management for multiple interlinked projects. You will also learn how to craft a custom <strong class="source-inline">translation</strong> module, embedding it seamlessly into a Nuxt application, by detailing the steps to create, configure, and extend this module with additional functionality through components <span class="No-Break">and plugins.</span></p>
			<p>This chapter demonstrates the modularity and reusability that monorepos facilitate. Each section aims to equip you with the skills to enhance your Nuxt applications with scalable and maintainable modules, preparing you for future projects that require advanced <span class="No-Break">architecture solutions.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Setting up a <span class="No-Break">Nuxt monorepo</span></li>
				<li>Developing a custom <span class="No-Break"><strong class="source-inline">translation</strong></span><span class="No-Break"> module</span></li>
				<li>Configuring <strong class="source-inline">translation</strong> <span class="No-Break">module options</span></li>
				<li>Expanding the module with plugins, components, <span class="No-Break">and composables</span></li>
				<li><span class="No-Break">Future directions</span></li>
			</ul>
			<h1 id="_idParaDest-168"><a id="_idTextAnchor167"/>Technical requirements</h1>
			<p>The code files for this chapter can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Nuxt-3-Projects"/><a href="https://github.com/PacktPublishing/Nuxt-3-Projects/tree/main/chapter08"/><span class="No-Break">.</span></p>
			<p>The CiA video for this chapter can be found <span class="No-Break">on </span><a href="https://packt.link/kdT64"><span class="No-Break">https://packt.link/kdT64</span></a></p>
			<h1 id="_idParaDest-169"><a id="_idTextAnchor168"/>Essential background – fundamentals of testing</h1>
			<p>In this chapter, we’re diving into setting up a Nuxt 3 monorepo for creating a custom <strong class="source-inline">translation</strong> module. A monorepo is a strategy where you manage all your project’s parts within <a id="_idIndexMarker448"/>a single repository. It’s like keeping all your development eggs in one basket, which simplifies many aspects of development, especially for large projects. In our setup, the monorepo will include not just a Nuxt application but a series of packages and apps, each contributing different functionalities to the <span class="No-Break">overarching system.</span></p>
			<p>Monorepos are valuable for the <span class="No-Break">following reasons:</span></p>
			<p><strong class="bold">Unified version control</strong>: Everything <a id="_idIndexMarker449"/>from code to documentation is stored in one place, making it easier to track changes and <span class="No-Break">maintain versions.</span></p>
			<ul>
				<li><strong class="bold">Simplified dependency management</strong>: All parts of the project use the same dependencies, which <a id="_idIndexMarker450"/>means <a id="_idIndexMarker451"/>they all get updated at once, reducing <span class="No-Break">compatibility issues.</span></li>
				<li><strong class="bold">Enhanced code reusability</strong>: Monorepos allow teams to easily share common <a id="_idIndexMarker452"/>code and resources across multiple projects within the same repository. This facilitates reusing packages, reducing redundancy, and enhancing consistency across <span class="No-Break">different applications.</span></li>
			</ul>
			<p>Now we understand monorepos’ role in handling complex projects efficiently, we’ve set the stage for exploring how they facilitate the development of <span class="No-Break">extensive applications.</span></p>
			<h1 id="_idParaDest-170"><a id="_idTextAnchor169"/>Setting up a Nuxt monorepo</h1>
			<p>In this <a id="_idIndexMarker453"/>chapter, we begin by establishing the foundational structure for our Nuxt monorepo. Instead of starting with the typical Nuxt project creation command, we’ll approach this setup by first crafting a dedicated environment that supports a <span class="No-Break">multi-package architecture.</span></p>
			<p>Let’s start by creating a new directory specifically for this chapter’s project to keep our workspace organized and separate from <span class="No-Break">other projects:</span></p>
			<pre class="console">
$ mkdir chapter08
$ cd chapter08</pre>			<p>Then, use <strong class="source-inline">pnpm</strong> to initialize a new project. This step involves creating a <strong class="source-inline">package.json</strong> file that will define our workspace and manage our <span class="No-Break">project’s dependencies:</span></p>
			<pre class="console">
$ pnpm init</pre>			<p>Now, you can open the newly created project directory in Visual Studio Code or your <span class="No-Break">preferred IDE.</span></p>
			<p>To designate <a id="_idIndexMarker454"/>our directory as a monorepo, we introduce a <strong class="source-inline">pnpm-workspace.yaml</strong> file. This configuration file plays a crucial role in managing multiple packages within a single repository efficiently. In this, we specify where the packages of our monorepo are located. The structure we’ve chosen categorizes our workspace into two <span class="No-Break">primary directories:</span></p>
			<ul>
				<li><strong class="source-inline">packages/*</strong>: This directory is reserved for shared libraries or modules that can be reused across multiple applications within the monorepo. In our case, this is where the <strong class="source-inline">translation</strong> module <span class="No-Break">will reside.</span></li>
				<li><strong class="source-inline">apps/*</strong>: Dedicated to housing applications that may depend on any shared modules. Our Nuxt application demonstrating the use of the <strong class="source-inline">translation</strong> module will be <span class="No-Break">placed here.</span></li>
			</ul>
			<p>Here is the code of <span class="No-Break">the file:</span></p>
			<pre class="source-code">
# pnpm-workspace.yaml
packages:
  - 'packages/*'
  - 'apps/*'</pre>			<p>Now, we’re ready to set up the website application that we’ll use to include the custom Nuxt module <span class="No-Break">inside it.</span></p>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor170"/>Creating a website application</h2>
			<p>To set up our <a id="_idIndexMarker455"/>project directories properly within the monorepo, begin by creating an <span class="No-Break"><strong class="source-inline">apps</strong></span><span class="No-Break"> directoy:</span></p>
			<pre class="console">
$ mkdir apps
$ cd apps</pre>			<p>Within the <strong class="source-inline">apps</strong> directory, we’ll establish a new Nuxt application using the latest version of <span class="No-Break">Nuxt 3:</span></p>
			<pre class="console">
$ pnpm dlx nuxi@latest init demo-website</pre>			<p>After initializing the Nuxt application, you can typically start the application by navigating into the <strong class="source-inline">demo-website</strong> directory and running <strong class="source-inline">pnpm dev</strong>. However, leveraging the full capability of our monorepo setup facilitated by <strong class="source-inline">pnpm</strong> workspaces, we can streamline this process. First, ensure the project name within the <strong class="source-inline">apps/demo-website/package.json</strong> file is set appropriately to reflect our <span class="No-Break">specific setup:</span></p>
			<pre class="source-code">
// apps/demo-website/package.json
{
  "name": "demo-website"
  // ...rest of the file
}</pre>			<p>After updating the project name, you can now execute commands from the root of the monorepo. This is done using <strong class="source-inline">pnpm</strong>’s <strong class="source-inline">--filter</strong> option, which targets specific subprojects. To run our Nuxt application from the monorepo root, use the <span class="No-Break">following command:</span></p>
			<pre class="console">
$ pnpm --filter demo-website dev</pre>			<p>This command tells <strong class="source-inline">pnpm</strong> to apply the <strong class="source-inline">dev</strong> script specifically to the <strong class="source-inline">demo-website</strong> project, allowing you to manage and run multiple projects within your monorepo seamlessly from a <span class="No-Break">central location.</span></p>
			<p>Going further, you can create a custom script in the root <strong class="source-inline">package.json</strong> file, which calls this command under <span class="No-Break">the hood:</span></p>
			<pre class="source-code">
// package.json
{
  "scripts": {
    "website:dev": "pnpm --filter demo-website dev"
  },
}</pre>			<p>Then, run this <a id="_idIndexMarker456"/>command in the <span class="No-Break">root folder:</span></p>
			<pre class="console">
$ pnpm website:dev</pre>			<p>The application should start, and you should see a welcome page as usual. With our application set up, let’s continue to create a <span class="No-Break"><strong class="source-inline">translation</strong></span><span class="No-Break"> module.</span></p>
			<h1 id="_idParaDest-172"><a id="_idTextAnchor171"/>Developing a custom translation module</h1>
			<p>As we continue creating our custom <strong class="source-inline">translation</strong> module, the first step in this process is <a id="_idIndexMarker457"/>to set up a dedicated directory for our shared packages. Navigate to the root of your monorepo and create a directory named <strong class="source-inline">packages</strong>. This directory will host all our shared logic, including the new <span class="No-Break"><strong class="source-inline">translation</strong></span><span class="No-Break"> module:</span></p>
			<pre class="console">
$ mkdir packages
$ cd packages</pre>			<p>Once inside the <strong class="source-inline">packages</strong> directory, we will use Nuxt’s module template to kickstart our <span class="No-Break"><strong class="source-inline">translation</strong></span><span class="No-Break"> module:</span></p>
			<pre class="console">
$ pnpm dlx nuxi init -t module translation</pre>			<p>This command sets up a new module with a starter template provided by Nuxt, complete with several essential directories <span class="No-Break">and files:</span></p>
			<ul>
				<li><strong class="source-inline">module.ts</strong>: This is the core file where our module is defined. It acts as the entry point and defines the configuration and setup of <span class="No-Break">the module.</span></li>
				<li><strong class="source-inline">runtime/plugin.ts</strong>: This file serves as an example plugin. It’s a place to extend the module with additional functionalities such as Vue plugins and <span class="No-Break">helper functions.</span></li>
				<li><strong class="source-inline">playground/</strong>: Contains a Nuxt application with our module already installed. This environment is useful for testing and demonstrating the <span class="No-Break">module’s functionality.</span></li>
				<li><strong class="source-inline">test/</strong>: A directory set up for writing tests for the module to ensure its functionality <span class="No-Break">and stability.</span></li>
			</ul>
			<p>Let’s <a id="_idIndexMarker458"/>discover the <strong class="source-inline">module.ts</strong> file to understand its structure <span class="No-Break">and components:</span></p>
			<pre class="source-code">
import { defineNuxtModule, addPlugin, createResolver } from '@nuxt/kit'
export interface ModuleOptions {}
export default defineNuxtModule&lt;ModuleOptions&gt;({
  meta: {
    name: 'my-module',
    configKey: 'myModule',
  },
  defaults: {},
  setup(_options, _nuxt) {
    const resolver = createResolver(import.meta.url)
    addPlugin(resolver.resolve('./runtime/plugin'))
  },
})</pre>			<p>This script outlines the basic structure of a Nuxt <strong class="source-inline">pnpm</strong> module using <strong class="source-inline">defineNuxtModule</strong>. The <strong class="source-inline">meta</strong> property defines the module’s name and configuration key. The <strong class="source-inline">setup</strong> function is where module-specific logic is added, such as registering plugins, using Nuxt hooks, adding an auto import directory, or even <span class="No-Break">extending routes.</span></p>
			<p>The <strong class="source-inline">createResolver</strong> function helps in resolving paths correctly, ensuring that any URL is <a id="_idIndexMarker459"/>added without issues related to <span class="No-Break">path resolution.</span></p>
			<p>Next, let’s use this module in <span class="No-Break">our application.</span></p>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor172"/>Installing the module in our application</h2>
			<p>First, rename <a id="_idIndexMarker460"/>the newly created module directory from <strong class="source-inline">my-module</strong> to <strong class="source-inline">translation</strong> to better reflect its purpose. This involves updating the name in <span class="No-Break">the module:</span></p>
			<pre class="source-code">
// packages/translation/src/module.ts
export default defineNuxtModule&lt;ModuleOptions&gt;({  meta: {
    name: 'translation',
    configKey: 'translation'
  }
  // … rest of code
})</pre>			<p>Also, update the name in the <span class="No-Break">package configuration:</span></p>
			<pre class="source-code">
// packages/translation/package.json
{
  "name": "translation",
  // Rest of configuration
}</pre>			<p>Then, ensure that build files of the modules are generated. To do so, run the following command in <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">translation</strong></span></p>
			<p> module <span class="No-Break">root folder:</span></p>
			<pre class="console">
Packages/translation&gt; $ pnpm dev:prepare</pre>			<p>This prepares local files <span class="No-Break">for development.</span></p>
			<p>With the module configured, you can now add it to our demo website. From the root of your monorepo, run the following command to link the module locally to <span class="No-Break">your application:</span></p>
			<pre class="console">
$ pnpm --filter demo-website add --workspace translation</pre>			<p>The <strong class="source-inline">--workspace</strong> flag tells <strong class="source-inline">pnpm</strong> to resolve the translation package from the local workspace instead of fetching it from an external registry. This setup ensures that the web app <a id="_idIndexMarker461"/>recognizes our packages and that any changes to the module are immediately available to the application <span class="No-Break">during development.</span></p>
			<p>To ensure that the module was added successfully, check the <strong class="source-inline">package.json</strong> file of your <span class="No-Break">demo website:</span></p>
			<pre class="source-code">
// apps/demo-website/package.json
{
  "dependencies": {
    "nuxt": "^3.11.2",
    "translation": "workspace:^",
    "vue": "^3.4.21",
    "vue-router": "^4.3.0"
  }
}</pre>			<p>The <strong class="source-inline">translation</strong> dependency should now be listed and pointing to your <span class="No-Break">local workspace.</span></p>
			<p>Finally, add the module to your Nuxt configuration to activate it within <span class="No-Break">your project:</span></p>
			<pre class="source-code">
// apps/demo-website/nuxt.config.ts
export default defineNuxtConfig({
  devtools: { enabled: true },
  modules: ['translation'],
})</pre>			<p>Then, start your application to see the module <span class="No-Break">in action:</span></p>
			<pre class="console">
$ pnpm website:dev</pre>			<p>Look for the <a id="_idIndexMarker462"/>console output or other indicators from the module’s default setup to confirm that <span class="No-Break">it’s functioning:</span></p>
			<div>
				<div id="_idContainer087" class="IMG---Figure">
					<img src="image/B19760_08_01.jpg" alt="Figure 8.1: Translation plugin injected" width="307" height="128"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1: Translation plugin injected</p>
			<p>This message, if visible, confirms that the <strong class="source-inline">translation</strong> module’s example plugin is actively injecting functionality into your <span class="No-Break">Nuxt application.</span></p>
			<p>With these steps completed, your demo website now successfully incorporates the <strong class="source-inline">translation</strong> module. We’re now ready to customize the module further and define specific options specified to our <span class="No-Break">project’s needs.</span></p>
			<h1 id="_idParaDest-174"><a id="_idTextAnchor173"/>Configuring translation module options</h1>
			<p>Before we <a id="_idIndexMarker463"/>start adding options for our <strong class="source-inline">translation</strong> module, it’s essential to understand how Nuxt modules typically offer configuration flexibility. Similar to how the official Nuxt <strong class="source-inline">i18n</strong> module allows configuration of <strong class="source-inline">defaultLocale</strong> and <strong class="source-inline">locales</strong> through the Nuxt config, we aim to provide a similar configurability in our custom module. This setup will enable users to define and manage locales dynamically through the <span class="No-Break">module’s options.</span></p>
			<p>In our <strong class="source-inline">translation</strong> module, we begin by defining the expected options for configuration. This involves setting up an interface in <strong class="source-inline">types.ts</strong> that outlines the structure of the <span class="No-Break">configuration options:</span></p>
			<pre class="source-code">
// packages/translation/src/types.ts
export type ModuleOptions = {
  defaultLocale: string;
  locales?: LocaleOption[];
};
export type LocaleOption = {
  name: string;
  file: string;
};</pre>			<p>Here, <strong class="source-inline">ModuleOptions</strong> allows for specifying a <strong class="source-inline">defaultLocale</strong> instance and an array of <strong class="source-inline">locales</strong> instances, each with a name and a file path pointing to the translations. We’ll discuss later on how to import <span class="No-Break">these files.</span></p>
			<p>The next <a id="_idIndexMarker464"/>step involves integrating these types into the main module file. Import the defined types into <strong class="source-inline">module.ts</strong> and use them to strongly type the module’s configuration. Make sure to remove the empty <span class="No-Break">defined interface:</span></p>
			<pre class="source-code">
// module.ts
import type { ModuleOptions } from './types';
export default defineNuxtModule&lt;ModuleOptions&gt;({
  meta: {
    name: 'translation',
    configKey: 'translation',
  },
  defaults: {
    defaultLocale: 'en',
    locales: [],
  },
  setup(options, nuxt) {
    // Module setup logic here
  },
});</pre>			<p>The <strong class="source-inline">defaults</strong> object is updated to provide a fallback for <strong class="source-inline">defaultLocale</strong> and an empty array for locales, ensuring that the module can initialize even if specific configurations are <span class="No-Break">not provided.</span></p>
			<p>To utilize <a id="_idIndexMarker465"/>the module’s capabilities fully, add it to the <strong class="source-inline">nuxt.config.ts</strong> file of your Nuxt application, specifying the options <span class="No-Break">like so:</span></p>
			<pre class="source-code">
// nuxt.config.ts
export default defineNuxtConfig({
  devtools: { enabled: true },
  modules: ['translation'],
  translation: {},
})</pre>			<p>Upon specifying these options, Nuxt’s intelligent configuration handling should offer autocomplete suggestions for <strong class="source-inline">translation</strong> options, reflecting the integration of our module options into the <span class="No-Break">Nuxt ecosystem:</span></p>
			<div>
				<div id="_idContainer088" class="IMG---Figure">
					<img src="image/B19760_08_02.jpg" alt="Figure 8.2: IntelliSense translation options" width="455" height="176"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2: IntelliSense translation options</p>
			<p>When <a id="_idIndexMarker466"/>adjusting settings in the Nuxt configuration file, you should be able to see IntelliSense suggestions that validate the correct integration of our module options, confirming that the setup is recognized <span class="No-Break">by Nuxt.</span></p>
			<p>After setting up basic configuration handling in our module, the subsequent task involves implementing logic within the module to dynamically load and apply the specified locales based on the provided <span class="No-Break">configuration options.</span></p>
			<h2 id="_idParaDest-175"><a id="_idTextAnchor174"/>Reading local files inside the module</h2>
			<p>Let’s integrate local file reading capabilities into our Nuxt module to handle translations effectively. This <a id="_idIndexMarker467"/>functionality will enable our module to dynamically load translation files specified in the <span class="No-Break">module’s configuration.</span></p>
			<p>Begin by defining the expected structure of the translation files. Assume each file contains flat key-value pairs representing localized strings. For instance, set up the English and French localization files within the <span class="No-Break">demo website:</span></p>
			<ul>
				<li>English <span class="No-Break">localization file:</span><pre class="source-code">
// apps/demo-website/locales/en.json
{
  "welcome": "Welcome"
}</pre></li>				<li>French <span class="No-Break">localization file:</span><pre class="source-code">
// apps/demo-website/locales/fr.json
{
  "welcome": "Bienvenue"
}</pre></li>			</ul>
			<p>Then, modify <a id="_idIndexMarker468"/>your Nuxt configuration file and add these files to the <span class="No-Break"><strong class="source-inline">locales</strong></span><span class="No-Break"> array:</span></p>
			<pre class="source-code">
// nuxt.config.ts
export default defineNuxtConfig({
  // other options
  translation: {
    locales: [
      { name: 'en', file: 'locales/en.json' },
      { name: 'fr', file: 'locales/fr.json' },
    ],
  },
})</pre>			<p>Now, let’s go back to the module to process these files. Start by defining a type for <span class="No-Break">the messages:</span></p>
			<pre class="source-code">
// packages/translation/types.ts
// other types
export type Messages = {
  [key: string]: string;
};</pre>			<p>Remember that we’re assuming the <strong class="source-inline">locales</strong> translation files will be a flat key-value pair. You can handle nested objects, but to simplify the process, we’ll only use one level <span class="No-Break">of keys.</span></p>
			<p>Finally, update <a id="_idIndexMarker469"/>your module’s <strong class="source-inline">setup</strong> function to loop through the locales, resolve their paths, read their contents, and then parse them into a usable format. Here’s how you can <span class="No-Break">do this:</span></p>
			<pre class="source-code">
// packages/translation/module.ts
import { readFileSync } from 'node:fs'
import { defineNuxtModule, createResolver } from '@nuxt/kit'
import type { Messages, ModuleOptions } from './types'
export default defineNuxtModule&lt;ModuleOptions&gt;({
  meta: {
    name: 'translation',
    configKey: 'translation',
  },
  defaults: {
    defaultLocale: 'en',
  },
  async setup(options<a id="_idTextAnchor175"/>, nuxt) {
    const localesResolver =
      createResolver(nuxt.options.srcDir)
    const messages: Messages = {}
    for (const locale of options.locales ?? []) {
      const filePath = localesResolver.resolve(locale.file)
      const fileContents = await readFileSync(filePath,
        'utf-8')
      const _messages = JSON.parse(fileContents)
      messages[locale.name] = _messages
    }
    nuxt.options.runtimeConfig.public.translation = {
      ...options,
      messages,
    }
  }
});</pre>			<p>Here’s <a id="_idIndexMarker470"/>a <span class="No-Break">code breakdown:</span></p>
			<ul>
				<li><strong class="source-inline">localesResolver</strong>: Resolves paths relative to the project’s source directory, which is stored <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">nuxt.options.srcDir</strong></span></li>
				<li><strong class="source-inline">readFileSync</strong>: Synchronously reads the content of the file at the <span class="No-Break">resolved path</span></li>
				<li><strong class="source-inline">JSON.parse</strong>: Converts the JSON string from the file into a <span class="No-Break">JavaScript object</span></li>
				<li><strong class="source-inline">nuxt.options.runtimeConfig.public.translation</strong>: Stores messages in the Nuxt runtime config, making them accessible throughout the application via the <span class="No-Break"><strong class="source-inline">useRuntimeConfig()</strong></span><span class="No-Break"> composable</span></li>
			</ul>
			<p>To verify the integration, modify the main application component to display the <span class="No-Break">loaded messages:</span></p>
			<pre class="source-code">
&lt;!-- apps/demo-website/app.vue --&gt;
&lt;template&gt;
  &lt;div&gt;{{ translation }}&lt;/div&gt;
&lt;/template&gt;
&lt;script setup lang="ts"&gt;
const config = useRuntimeConfig();
const translation = config.public.translation;
&lt;/script&gt;</pre>			<p>Restart your <a id="_idIndexMarker471"/>Nuxt application and navigate to the home page. You should now see the translation options displayed, as well as the <span class="No-Break">localization messages:</span></p>
			<div>
				<div id="_idContainer089" class="IMG---Figure">
					<img src="image/B19760_08_03.jpg" alt="Figure 8.3: Displaying translation array output" width="709" height="284"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3: Displaying translation array output</p>
			<p>Now that our module can load translation messages, we’ll enhance its functionality by adding a plugin to create a global helper function. This function will allow us to easily retrieve and display translated strings throughout the <span class="No-Break">Nuxt application.</span></p>
			<h1 id="_idParaDest-176"><a id="_idTextAnchor176"/>Expanding the module with plugins, composables, and components</h1>
			<p>We’ll start by developing a composable that manages the user’s preferred language. This <a id="_idIndexMarker472"/>composable will help in retrieving <a id="_idIndexMarker473"/>the correct locale <a id="_idIndexMarker474"/>from cookies or default to the configured locale from our <span class="No-Break">module options.</span></p>
			<p>Inside the module, create a new file for the <span class="No-Break">composable: </span><span class="No-Break"><strong class="source-inline">runtime/composables/useTranslation.ts</strong></span><span class="No-Break">.</span></p>
			<p>Develop the composable function <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
import { computed, useCookie, useRuntimeConfig } from '#imports'
export default () =&gt; {
  const config = useRuntimeConfig()
  const translation = config.public.translation
  const locale = useCookie('defaultLocale')
  const locales = translation.locales
  if (!locale.value) locale.value =
    translation.defaultLocale
  const messages = computed(() =&gt; {
    const key = locale.value || translation.defaultLocale
    return translation.messages[key]
  })
  return { locale, locales, messages }
}</pre>			<p>Here’s <a id="_idIndexMarker475"/>a <span class="No-Break">code breakdown:</span></p>
			<ul>
				<li><strong class="source-inline">useRuntimeConfig</strong>: Accesses <a id="_idIndexMarker476"/>runtime configuration, which includes <span class="No-Break">translation settings</span></li>
				<li><strong class="source-inline">useCookie</strong>: A <strong class="source-inline">ref</strong> that <a id="_idIndexMarker477"/>manages cookie values: <strong class="source-inline">get</strong> – <strong class="source-inline">set</strong>, particularly for storing user’s <span class="No-Break">locale preference</span></li>
				<li><strong class="source-inline">computed</strong>: Reactively calculates the correct messages to use based on the <span class="No-Break">current locale</span></li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">When developing a Nuxt module, it’s essential to import any function or composable that is auto-imported by default in a Nuxt app explicitly from <strong class="source-inline">#imports</strong>. This approach ensures that the module can utilize Nuxt’s auto-import feature, which is not inherently available in the module’s scope as it would be within a <span class="No-Break">Nuxt application.</span></p>
			<p>To ensure our composable is easily accessible within the Nuxt app, we’ll automate its import. Update the <strong class="source-inline">module.ts</strong> file to auto-import the <span class="No-Break"><strong class="source-inline">composables</strong></span><span class="No-Break"> directory:</span></p>
			<pre class="source-code">
import { defineNuxtModule, createResolver, addImportsDir } from '@nuxt/kit';
export default defineNuxtModule({
  meta: {
    name: 'translation',
    configKey: 'translation',
  },
  setup(options, nuxt) {
    // Existing setup code...
    const resolver = createResolver(import.meta.url);
    addImportsDir(resolver.resolve('runtime/composables'));
  }
});</pre>			<p><strong class="source-inline">addImportsDir</strong> automatically imports files from the specified directory, making the composables <a id="_idIndexMarker478"/>readily available <a id="_idIndexMarker479"/>to the Nuxt app <a id="_idIndexMarker480"/>without manual <strong class="source-inline">import</strong> statements. Thus, this folder will act exactly like the <strong class="source-inline">composables</strong> folder, which is inside your <span class="No-Break">Nuxt application!</span></p>
			<p>With the composable ready, let’s test its functionality. Update <strong class="source-inline">app.vue</strong> <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
&lt;template&gt;
  {{ messages.welcome }}
&lt;/template&gt;
&lt;script setup lang="ts"&gt;
const { messages } = useTranslation();
&lt;/script&gt;</pre>			<p>This setup should display a welcome message based on the default or user-defined locale. Because we didn’t update the default locale, the module will use <strong class="source-inline">'en'</strong> as the default value, as it is configured in the <span class="No-Break">module file:</span></p>
			<div>
				<div id="_idContainer090" class="IMG---Figure">
					<img src="image/B19760_08_04.jpg" alt="Figure 8.4: Messages array based on the default locale" width="709" height="306"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4: Messages array based on the default locale</p>
			<p>Now, let’s <a id="_idIndexMarker481"/>ensure that our module <a id="_idIndexMarker482"/>can respect locale <a id="_idIndexMarker483"/>overrides specified in the <span class="No-Break">Nuxt configuration:</span></p>
			<pre class="source-code">
// nuxt.config.ts
export default defineNuxtConfig({
  translation: {
    defaultLocale: 'fr',
    locales: [
      { name: 'en', file: 'locales/en.json' },
      { name: 'fr', file: 'locales/fr.json' }
    ]
  }
});</pre>			<p>By setting <strong class="source-inline">defaultLocale</strong> to <strong class="source-inline">'fr'</strong> and accessing the app in a private window (to clear previous cookies), a French translation should appear, demonstrating the flexibility and dynamic capability of our <span class="No-Break"><strong class="source-inline">translation</strong></span><span class="No-Break"> module:</span></p>
			<div>
				<div id="_idContainer091" class="IMG---Figure">
					<img src="image/B19760_08_05.jpg" alt="Figure 8.5: Messages array based on the default locale" width="710" height="280"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5: Messages array based on the default locale</p>
			<p>Now, let’s <a id="_idIndexMarker484"/>move forward <a id="_idIndexMarker485"/>to enhance the module <a id="_idIndexMarker486"/>with a plugin that provides a global <strong class="source-inline">$t</strong> global function for fetching translated messages directly. This will simplify the use of translations throughout <span class="No-Break">the application.</span></p>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor177"/>Creating a $t helper function</h2>
			<p>First, we create <a id="_idIndexMarker487"/>a new <strong class="source-inline">translate.ts</strong> file <a id="_idIndexMarker488"/>inside the <strong class="source-inline">runtime/plugins</strong> directory of the module. This file will contain the logic for our translation function. Here’s how to write a plugin to <span class="No-Break">fetch translations:</span></p>
			<pre class="source-code">
import useTranslation from '../composables/useTranslation'
import { defineNuxtPlugin } from '#imports'
export default defineNuxtPlugin(async () =&gt; {
  const { messages } = useTranslation()
  // Translator function
  const t = (key: string) =&gt; {
    return messages.value[key] || key  // Return the
                                          translated string
                                          or key if not
                                          found
  }
  return {
    provide: { t }
  }
})</pre>			<p>Here’s a <a id="_idIndexMarker489"/><span class="No-Break">code breakdown:</span></p>
			<ul>
				<li>We’re <a id="_idIndexMarker490"/>importing <strong class="source-inline">useTranslation</strong>, which manages the translation state and provides translations based on the <span class="No-Break">current locale.</span></li>
				<li>We’re defining plugins using <strong class="source-inline">defineNuxtPlugin</strong>. The <strong class="source-inline">#imports</strong> alias is used here to automatically resolve to the correct utility versions provided <span class="No-Break">by Nuxt.</span></li>
				<li>We’re implementing a <strong class="source-inline">t</strong> translator function that takes a key as an argument. It attempts to retrieve the translation for this key from the <strong class="source-inline">messages</strong> object obtained from <strong class="source-inline">useTranslation</strong>. If a translation for the key doesn’t exist, it defaults back to the <span class="No-Break">key itself.</span></li>
				<li>We’re providing <strong class="source-inline">Translator</strong> as a global helper function by adding <strong class="source-inline">return { provide: { t } }</strong> to the end of the plugin definition function. By providing <strong class="source-inline">t</strong>, any component within the application can use this function to render translated text using: <strong class="source-inline">$t</strong>. Nuxg automatically add <strong class="source-inline">$</strong> to any function provided by nuxt module to access <span class="No-Break">it globally.</span></li>
			</ul>
			<p>Next, integrate <a id="_idIndexMarker491"/>this plugin into <a id="_idIndexMarker492"/>our Nuxt module by updating the <span class="No-Break"><strong class="source-inline">module.ts</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
import {
  defineNuxtModule,
  addPlugin,
  createResolver,
  addImportsDir,
} from '@nuxt/kit'
export default defineNuxtModule({
  setup(_options, nuxt) {
   // …previous setup
    addPlugin(resolver.resolve('./runtime/plugins/translate'))
  },
})</pre>			<p>Finally, update your application’s main component, <strong class="source-inline">app.vue</strong>, to use the <strong class="source-inline">$</strong><span class="No-Break"><strong class="source-inline">t</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
&lt;template&gt;
  &lt;div&gt;{{ $t('welcome') }}&lt;/div&gt;
&lt;/template&gt;</pre>			<p>Once <a id="_idIndexMarker493"/>implemented, test by running <a id="_idIndexMarker494"/>your application and navigating. You should see the translated strings<a id="_idTextAnchor178"/> rendering based on the <span class="No-Break">active locale:</span></p>
			<div>
				<div id="_idContainer092" class="IMG---Figure">
					<img src="image/B19760_08_06.jpg" alt="Figure 8.6: $t function output" width="957" height="420"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.6: $t function output</p>
			<p>For the final expansion, we’ll create a component that allows users to switch languages directly from their <span class="No-Break">web interface.</span></p>
			<h2 id="_idParaDest-178"><a id="_idTextAnchor179"/>Setting up a language switcher component</h2>
			<p>We’ll create <a id="_idIndexMarker495"/>a language switcher component <a id="_idIndexMarker496"/>using the menu component from the <strong class="source-inline">@nuxt/ui</strong> package. Firstly, install the <strong class="source-inline">@nuxt/ui</strong> package within our module’s scope. From the root of your project, run the <span class="No-Break">following command:</span></p>
			<pre class="console">
$ pnpm --filter translation add @nuxt/ui</pre>			<p>In the <strong class="source-inline">module.ts</strong> file, verify and install <strong class="source-inline">@nuxt/ui</strong> if it’s not already present in the host application, and ensure to auto-import the new <strong class="source-inline">components</strong> directory. Nuxt Kit provides various helper functions to <span class="No-Break">achieve this:</span></p>
			<ul>
				<li><strong class="source-inline">hasNuxtModule</strong>: Checks whether <strong class="source-inline">@nuxt/ui</strong> is already installed in the <span class="No-Break">host application</span></li>
				<li><strong class="source-inline">installModule</strong>: Dynamically installs <strong class="source-inline">@nuxt/ui</strong> if it is <span class="No-Break">not found</span></li>
				<li><strong class="source-inline">addComponentsDir</strong>: Adds the directory containing our custom components to Nuxt’s auto-import feature, allowing these components to be used without <span class="No-Break">manual import</span></li>
			</ul>
			<p>Here’s <a id="_idIndexMarker497"/>the updated version of the <strong class="source-inline">module.ts</strong> <span class="No-Break">setup </span><span class="No-Break"><a id="_idIndexMarker498"/></span><span class="No-Break">function:</span></p>
			<pre class="source-code">
export default defineNuxtModule({
  async setup(_options, nuxt) {
  // other configuration
    if (!hasNuxtModule('@nuxt/ui')) {
      await installModule('@nuxt/ui')
    }
    const resolver = createResolver(import.meta.url)
    addComponentsDir({
      path: resolver.resolve('runtime/components')
    })
  }
})</pre>			<p>Now, create a new <strong class="source-inline">LanguageSwitcher.vue</strong> component within the <strong class="source-inline">runtime/components</strong> directory. This component will utilize the <strong class="source-inline">USelectMenu</strong> UI component from <strong class="source-inline">@nuxt/ui</strong> to render a dropdown for <span class="No-Break">language selection:</span></p>
			<pre class="source-code">
&lt;template&gt;
  &lt;USelectMenu
    v-model="locale"
    :options="locales"
    value-attribute="name"
    option-attribute="name"
  /&gt;
&lt;/template&gt;
&lt;script setup lang="ts"&gt;
import useTranslation from '../composables/useTranslation'
const { locale, locales } = useTranslation()
&lt;/script&gt;</pre>			<p>Here’s <a id="_idIndexMarker499"/>an explanation of <span class="No-Break">the components:</span></p>
			<ul>
				<li><strong class="source-inline">USelectMenu</strong>: A UI component from <strong class="source-inline">@nuxt/ui</strong> that renders a dropdown menu. It <a id="_idIndexMarker500"/>binds to the <strong class="source-inline">locale</strong> reactive variable and updates it based on <span class="No-Break">user selection.</span></li>
				<li><strong class="source-inline">locales</strong>: An array of available languages that populate the <span class="No-Break">dropdown options.</span></li>
			</ul>
			<p>To ensure the <strong class="source-inline">LanguageSwitcher</strong> component is functioning correctly, run the <span class="No-Break">following command:</span></p>
			<pre class="console">
$ pnpm --filter translation dev:prepare</pre>			<p>This prepares the module with the new component. Then, update the <strong class="source-inline">app.vue</strong> file in your Nuxt application to use the <span class="No-Break"><strong class="source-inline">LanguageSwitcher</strong></span><span class="No-Break"> component:</span></p>
			<pre class="source-code">
&lt;!-- apps/demo-website/app.vue --&gt;
&lt;template&gt;
  &lt;div&gt;{{ $t('welcome') }}&lt;/div&gt;
  &lt;LanguageSwitcher /&gt;
&lt;/template&gt;</pre>			<p>Refresh your browser to test the functionality. You should see a welcome message as well as <a id="_idIndexMarker501"/>a select menu that contains two locales: <strong class="source-inline">en</strong> and <strong class="source-inline">fr</strong>. Changing the language using the dropdown should dynamically update <a id="_idIndexMarker502"/>the welcome message, demonstrating the reactive translation updates across <span class="No-Break">the application:</span></p>
			<div>
				<div id="_idContainer093" class="IMG---Figure">
					<img src="image/B19760_08_07.jpg" alt="Figure 8.7: LanguageSelector component" width="957" height="574"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.7: LanguageSelector component</p>
			<p>Note that we managed to use the <strong class="source-inline">@nuxt/ui</strong> package within the module without direct installation in the host application, exemplifying the flexibility of Nuxt modules. We can still install this package in our host application, and this won’t result in any error due to the <strong class="source-inline">hasNuxtModule</strong> <span class="No-Break">checker function.</span></p>
			<p>Now that we’ve finished implementing our custom modules in Nuxt 3, let’s look ahead to how we can further refine and expand these concepts in <span class="No-Break">real-world applications.</span></p>
			<h1 id="_idParaDest-179"><a id="_idTextAnchor180"/>Future directions</h1>
			<p>As we conclude this chapter, it’s important to reflect on the underlying principles that guided our journey through building a custom <strong class="source-inline">i18n</strong> module within a monorepo structure. The focus was not on the aesthetics of the application but on the architecture—specifically, the creation of a module system. This approach is particularly beneficial for large-scale projects where managing complexity efficiently <span class="No-Break">is crucial.</span></p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor181"/>POS system example</h2>
			<p>In real-world scenarios, especially in enterprise environments, applications are rarely simple. They often <a id="_idIndexMarker503"/>consist of numerous interconnected parts, such as a <strong class="bold">point-of-sale</strong> (<strong class="bold">POS</strong>) system, which might include modules for handling orders, promotions, customer management, and more. Each of these modules can be designed to <a id="_idIndexMarker504"/>operate independently, containing its own pages, logic, components, and <span class="No-Break">state management.</span></p>
			<p>In such a system, different modules can be developed and maintained independently. For instance, a promotions module might handle all promotional offers and discount logic. If the business decided to overhaul its promotions strategy, only the promotions module would need to be updated or replaced, minimizing risk and disruption to other parts of <span class="No-Break">the system.</span></p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor182"/>E-commerce platform example</h2>
			<p>Modular systems are particularly beneficial in complex e-commerce platforms, where different <a id="_idIndexMarker505"/>functionalities such as product catalog management, order processing, payment integrations, and user profiles are essential yet distinct components. Each module can be separately developed, tested, and deployed, allowing for flexible updates <span class="No-Break">and scalability.</span></p>
			<p>For example, the payment integration module might support various payment gateways and handle all the complexities of transactions. If new payment methods need to be added or existing ones need updates due to regulatory changes, developers can focus solely on <a id="_idIndexMarker506"/>this module. This modular approach speeds up development and deployment and ensures that updates in one area, such as payment processing, do not inadvertently affect unrelated parts such as the product catalog or user <span class="No-Break">management systems.</span></p>
			<h2 id="_idParaDest-182"><a id="_idTextAnchor183"/>Final thoughts</h2>
			<p>The goal of this chapter was to underscore the transformative impact of modular architecture <a id="_idIndexMarker507"/>on the development and scalability of large-scale applications. By adopting a modular approach, developers can efficiently manage complex systems, facilitating easier updates, testing, and expansion. Moving forward, apply the strategies explored here to structure your <span class="No-Break">projects effectively.</span></p>
			<p>Additionally, this journey highlighted the great developer experience provided by Nuxt, which simplifies the creation of custom modules. Nuxt’s framework supports extensive customization, allowing for seamless integration of options, components, plugins, and composables. This flexibility ensures our applications meet current needs while also being well prepared for future advancements <span class="No-Break">and integrations.</span></p>
			<h1 id="_idParaDest-183"><a id="_idTextAnchor184"/>Summary</h1>
			<p>In this chapter, we spotlit the creation of a custom <strong class="source-inline">translation</strong> module within a Nuxt 3 monorepo, designed to streamline the management of large-scale projects. We began by establishing a monorepo setup using <strong class="source-inline">pnpm</strong>, which allowed us to structure our project into separate but interconnected workspaces. This foundation supported the development of our <strong class="source-inline">translation</strong> module, starting from a basic Nuxt module template. By configuring module options, we customized the module to handle <span class="No-Break">multiple languages.</span></p>
			<p>Further enhancing the module, we integrated plugins, components, and composables, providing a dynamic and user-friendly way to switch languages and <span class="No-Break">manage translations.</span></p>
			<p>This practical application demonstrated how modular architecture enhances code reuse while also simplifying enhancements and scalability. The concluding discussion on future directions explored the potential for where we can use this modular approach in other domains, such as e-commerce or enterprise systems, illustrating the broad applicability and flexibility of the <span class="No-Break">techniques learned.</span></p>
			<p>This chapter serves as a blueprint for developers looking to fully utilize Nuxt’s modular capabilities in <span class="No-Break">their projects.</span></p>
			<h1 id="_idParaDest-184"><a id="_idTextAnchor185"/>Practice questions</h1>
			<ul>
				<li>Describe the process of setting up a monorepo with <strong class="source-inline">pnpm</strong> for a Nuxt <span class="No-Break">3 project.</span></li>
				<li>What are the key benefits of using a monorepo structure in large-scale Nuxt <span class="No-Break">3 projects?</span></li>
				<li>How do you initiate a new Nuxt 3 module within <span class="No-Break">a monorepo?</span></li>
				<li>How can you add a Nuxt module to a Nuxt application within the <span class="No-Break">same monorepo?</span></li>
				<li>What does the <strong class="source-inline">addPlugin</strong> function do within a <span class="No-Break">Nuxt module?</span></li>
				<li>What is the role of <strong class="source-inline">runtimeConfig</strong> in a <span class="No-Break">Nuxt module?</span></li>
				<li>Describe the purpose of using <strong class="source-inline">createResolver</strong> within a <span class="No-Break">Nuxt module.</span></li>
				<li>Explain how the <strong class="source-inline">hasNuxtModule</strong> and <strong class="source-inline">installModule</strong> functions are used in a <span class="No-Break">module setup.</span></li>
				<li>How do you add and use a composable within a <span class="No-Break">Nuxt module?</span></li>
				<li>How can you configure a Nuxt module to automatically import components from a specified directory when the module is used in <span class="No-Break">a project?</span></li>
			</ul>
			<h1 id="_idParaDest-185"><a id="_idTextAnchor186"/>Further reading</h1>
			<ul>
				<li>Nuxt <span class="No-Break">modules: </span><a href="https://nuxt.com/docs/guide/concepts/modules"><span class="No-Break">https://nuxt.com/docs/guide/concepts/modules</span></a></li>
				<li>Module author <span class="No-Break">guide: </span><a href="https://nuxt.com/docs/guide/going-further/modules/"><span class="No-Break">https://nuxt.com/docs/guide/going-further/modules/</span></a></li>
				<li><strong class="source-inline">pnpm</strong> <span class="No-Break">workspaces: </span><a href="https://pnpm.io/workspaces"><span class="No-Break">https://pnpm.io/workspaces</span></a></li>
				<li>Nuxt lifecycle <span class="No-Break">hooks: </span><a href="https://nuxt.com/docs/guide/going-further/hooks"><span class="No-Break">https://nuxt.com/docs/guide/going-further/hooks</span></a></li>
				<li>Nuxt auto-imports <span class="No-Break">concept: </span><a href="https://nuxt.com/docs/guide/concepts/auto-imports"><span class="No-Break">https://nuxt.com/docs/guide/concepts/auto-imports</span></a></li>
			</ul>
		</div>
	</div>
</div>
</body></html>