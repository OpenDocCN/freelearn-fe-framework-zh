- en: Server-Side Rendering
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端渲染
- en: Universal JavaScript, or isomorphic JavaScript, are different names for a feature
    that we are going to implement in this chapter. To be more exact, we will develop
    our app and render the app's pages on both the server and client side. It will
    be different to **Angular1** or Backbone single-page apps which are mainly rendered
    on the client side. Our approach is more complicated in technological terms as
    you need to deploy your full-stack skills which work on server-side rendering,
    but having this experience will make you a more desirable programmer so you can
    advance your career to the next level--you will be able to charge more for your
    skills on the market.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 全局 JavaScript，或同构 JavaScript，是我们要在本章中实现的功能的不同名称。更准确地说，我们将开发我们的应用，并在服务器和客户端上渲染应用页面。它将不同于主要在客户端渲染的
    **Angular1** 或 Backbone 单页应用程序。从技术角度来看，我们的方法更复杂，因为你需要部署你的全栈技能，这些技能在服务器端渲染上工作，但拥有这种经验将使你成为一个更受欢迎的程序员，你可以将你的技能在市场上提升到下一个水平——你将能够为你的技能收取更高的费用。
- en: When the server side is worth implementing
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当服务器端值得实施时
- en: Server-side rendering is a very useful feature in text content (like news portals)
    start-ups/companies, because it helps achieve better indexing by different search
    engines. It's an essential feature for any news and content-heavy website, because
    it helps grow organic traffic. In this chapter, we will also run our app with
    server-side rendering. Other companies where server-side rendering may be useful
    are entertainment businesses where users have less patience and they might close
    the browser if a webpage is loading slowly. In general, all **B2C** (consumer
    facing) apps should use server-side rendering to improve the experience for the
    people who visit their websites.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端渲染是文本内容（如新闻门户）初创公司/公司的非常有用的功能，因为它有助于通过不同的搜索引擎实现更好的索引。对于任何新闻和内容丰富的网站来说，这是一个基本功能，因为它有助于增长有机流量。在本章中，我们还将使用服务器端渲染运行我们的应用。其他可能有用服务器端渲染的公司是娱乐业务，其中用户对网页加载缓慢的情况耐心较少，他们可能会关闭浏览器。总的来说，所有
    **B2C**（面向消费者）的应用程序都应该使用服务器端渲染来改善访问其网站的人们的体验。
- en: 'Our focus in this chapter will include the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将关注的重点包括以下内容：
- en: Making the whole server-side code rearrangements to prepare for the server-side
    rendering
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对整个服务器端代码进行重新排列以准备服务器端渲染
- en: Starting to use react-dom/server and its `renderToString` method
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用 react-dom/server 及其 `renderToString` 方法
- en: '`RoutingContext` and match for the react-router working on the server side'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RoutingContext` 和在服务器端工作的 react-router 的匹配'
- en: Improving the client-side application so it will be optimized for an isomorphic
    JavaScript application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化客户端应用程序，使其适用于同构 JavaScript 应用程序
- en: Are you ready? Our first step is to mock the database's response on the backend
    (we will create a real DB query after whole server-side rendering works correctly
    on the mocked data).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你准备好了吗？我们的第一步是在后端模拟数据库的响应（在服务器端渲染在模拟数据上正确工作后，我们将创建一个真实的数据库查询）。
- en: Mocking the database response
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟数据库响应
- en: 'First of all, we will mock our database response on the backend in order to
    prepare to go into server-side rendering directly; we will change it later in
    this chapter:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将模拟后端数据库响应，以便为直接进入服务器端渲染做准备；我们将在本章稍后更改它：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `fetchServerSide.js` file will consist of all functions that will fetch
    data from our database in order to make the server side work.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetchServerSide.js` 文件将包含所有从我们的数据库获取数据以使服务器端工作的函数。'
- en: 'As mentioned earlier, we will mock it for now, with the following code in `fetchServerSide.js`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们现在将使用以下 `fetchServerSide.js` 中的代码进行模拟：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The goal of making this mocked object is that we will be able to see if our
    server-side rendering works correctly after implementation because, as you have
    probably already spotted, we have added `SERVER-SIDE` at the beginning of each
    title and content--so it will help us to learn if our app is getting the data
    from server-side rendering. Later, this function will be replaced with a query
    to MongoDB.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这个模拟对象的目标是，在实施后，我们能够看到我们的服务器端渲染是否正确工作，因为你可能已经注意到了，我们在每个标题和内容的开头都添加了`SERVER-SIDE`——这将帮助我们了解我们的应用是否从服务器端渲染获取数据。稍后，这个功能将被替换为对MongoDB的查询。
- en: The next thing that will help us implement the server-side rendering is to make
    a `handleServerSideRender` function that will be triggered each time a request
    hits the server.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助我们实现服务器端渲染的下一件事是创建一个 `handleServerSideRender` 函数，该函数将在每次请求击中服务器时被触发。
- en: 'In order to make the `handleServerSideRender` trigger every time the frontend
    calls our backend, we need to use Express middleware using `app.use`. So far,
    we have used some external libraries such as:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使`handleServerSideRender`在每次前端调用我们的后端时触发，我们需要使用Express中间件`app.use`。到目前为止，我们已经使用了一些外部库，例如：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: For the first time in this book, we will write our own, small, middleware function
    that behaves in a similar way to `cors` or `bodyParser` (the external `libs` that
    are also middleware).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们第一次将编写自己的、小的中间件函数，其行为类似于`cors`或`bodyParser`（也是中间件的外部`libs`）。
- en: 'Before doing so, let''s import the dependencies that are required in React''s
    server-side rendering (`server/server.js`):'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样做之前，让我们导入React服务器端渲染所需的依赖项（`server/server.js`）：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So, after adding all those imports of `server/server.js`, the file will look
    as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在添加了所有这些`server/server.js`的导入之后，文件将如下所示：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Most of that stuff explained here is similar to client-side development in previous
    chapters. What is important is to import history in the given way, as in the example: `import
    * as hist from 'history'`. The `RoutingContext`, match is a way of using `React-Router`
    on the server side. The `renderToStaticMarkup` function is going to generate an
    HTML markup for us on the server side.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里解释的大部分内容与上一章中的客户端开发类似。重要的是以给定方式导入history，例如在示例中：`import * as hist from 'history'`。`RoutingContext`和`match`是使用`React-Router`在服务器端的一种方式。`renderToStaticMarkup`函数将在服务器端为我们生成HTML标记。
- en: 'After we have added the new imports, then under Falcor''s middleware setup:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们添加了新的导入之后，然后在Falcor的中间件设置下：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Under that `model.json` code, add the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个`model.json`代码下，添加以下内容：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `app.use(handleServerSideRender)` event is fired each time the server side
    receives a request from a client''s application. Then we will prepare the empty
    functions that we will use:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.use(handleServerSideRender)`事件在服务器端每次收到客户端应用程序的请求时被触发。然后我们将准备我们将要使用的空函数：'
- en: '`handleServerSideRender`: It will use `renderToString` in order to create a
    valid server-side HTML markup'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handleServerSideRender`：它将使用`renderToString`来创建有效的服务器端HTML标记。'
- en: '`renderFullHtml`: It is a helper function that will embed our new React''s
    HTML markup into a whole HTML document as we will see later'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`renderFullHtml`：这是一个辅助函数，它将我们的新React HTML标记嵌入到整个HTML文档中，正如我们稍后将会看到的。'
- en: The handleServerSideRender function
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理服务器端渲染的函数
- en: First, we are going to create a new Redux store instance that will be created
    on every call to the backend. The main goal of this is to give the initial state
    information to our application so it can create a valid markup based on the current
    request.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个新的Redux存储实例，该实例将在每次调用后端时创建。这个主要目的是向我们的应用程序提供初始状态信息，以便它可以根据当前请求创建有效的标记。
- en: We will use the `Provider` component that we have already used in our client-side's
    app that will be wrapping the `Root` component. That will make the store available
    to all our components.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用已经在我们的客户端应用中使用的`Provider`组件，它将包装`Root`组件。这将使存储对所有组件可用。
- en: The most important part here is `ReactDOMServer.renderToString()` to render
    the initial HTML markup of our application, before we send the markup to the client
    side.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最重要的部分是`ReactDOMServer.renderToString()`，用于渲染我们应用程序的初始HTML标记，在我们将标记发送到客户端之前。
- en: The next step is to get the initial state from the Redux store by using the `store.getState()`
    function. The initial state will be passed along in our `renderFullHtml` function,
    as you will learn in a moment.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用`store.getState()`函数从Redux存储中获取初始状态。初始状态将通过我们的`renderFullHtml`函数传递，你将在稍后了解这一点。
- en: 'Before we work on the two new functions (`handleServerSideRender` and `renderFullHtml`),
    replace this in `server.js`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们处理两个新函数（`handleServerSideRender`和`renderFullHtml`）之前，在`server.js`中替换以下内容：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Replace with the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 替换为以下内容：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: That's everything in our `dist` project. It will be available as a static file
    under the localhost address (`http://localhost:3000/static/app.js*`). This will
    help us make a single-page app after initial server-side rendering.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的`dist`项目中的所有内容。它将作为静态文件在本地地址（`http://localhost:3000/static/app.js*`）下可用。这将帮助我们创建一个单页应用程序，在初始服务器端渲染之后。
- en: 'Also make sure that `app.use(''/static'', express.static(''dist''));` is placed
    directly under `app.use(bodyParser.urlencoded({extended: false }));`. Otherwise
    it may not work if you misplace this in the `server/server.js` file.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '确保将`app.use(''/static'', express.static(''dist''));`直接放置在`app.use(bodyParser.urlencoded({extended:
    false }));`之下。否则，如果在这个`server/server.js`文件中放置不当，它可能不会工作。'
- en: 'After you are done with the preceding work of `express.static`, let''s make
    this function more complete:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成`express.static`的前面工作后，让我们使这个函数更加完整：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Replace the preceding empty function with the following improved version:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下改进的版本替换前面的空函数：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In short, this HTML code will be sent by our server when a user hits the website
    for the first time so we need to create the HTML markup with a body and head in
    order to make it work. The server-side publishing app''s header is here just temporarily,
    to check if we are fetching the server-side HTML template correctly. Later you
    can find `$html` with the following command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，当用户第一次访问网站时，我们的服务器将发送这段HTML代码，因此我们需要创建带有body和head的HTML标记，以便使其工作。服务器端发布应用的header只是临时性的，用于检查我们是否正确地获取了服务器端HTML模板。稍后你可以使用以下命令找到`$html`：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice that we are using ES6 templates (Google ES6 template literals) syntax
    with `&grave;`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在使用带有`&grave;`的ES6模板（Google ES6模板字面量）语法。
- en: In this, we will later put the value that is generated by the `renderToStaticMarkup`
    function. The last step in the `renderFullPage` function is to give the initial,
    server-side rendering state in the window with `window.INITIAL_STATE = ${JSON.stringify(initialState)}`
    so the app can work correctly on the client-side with data fetched on the backend
    when the first request to the server has been made.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们稍后会放置由`renderToStaticMarkup`函数生成的值。`renderFullPage`函数的最后一步是在窗口中提供初始的服务器端渲染状态，使用`window.INITIAL_STATE
    = ${JSON.stringify(initialState)}`，这样应用就可以在客户端正确地使用从后端获取的数据工作，当第一次向服务器发出请求时。
- en: 'Okay, next let''s focus on the `handleServerSideRender` function by replacing
    the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，接下来让我们专注于`handleServerSideRender`函数，通过替换以下内容：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Replace with the more complete version of the function as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下更完整的函数版本替换：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `let initMOCKstore = fetchServerSide();` expression is fetching data from
    MongoDB (mocked for now, to be improved later). Next, we create a server-side's
    Redux story with `store = createStore(rootReducer, initMOCKstore)`. We also need
    to prepare a correct location for our app's user consumable by the react-router
    with `location = hist.createLocation(req.path)` (in `req.path` there is a simple
    path which is in the browser; `/register` or `/login` or simply `main page /`).
    The function `match` is provided by the react-router in order to match the correct
    route on the server side.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`let initMOCKstore = fetchServerSide();`表达式正在从MongoDB（目前是模拟的，稍后将进行改进）获取数据。接下来，我们使用`store
    = createStore(rootReducer, initMOCKstore)`创建服务器端的Redux store。我们还需要为我们的应用的用户准备一个正确的地方，以便react-router可以使用`location
    = hist.createLocation(req.path)`（在`req.path`中有一个简单的路径，位于浏览器中；`/register`或`/login`或简单的`main
    page /`）。`match`函数由react-router提供，用于在服务器端匹配正确的路由。'
- en: 'When we have matched the route on the server side, we will see the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在服务器端匹配了路由后，我们将看到以下内容：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see here, we are creating the server-side HTML markup with `renderToStaticMarkup`.
    Inside this function, there is a Provider with the store that has previously been
    fetched with the `let initMOCKstore = fetchServerSide()`. Inside the Redux Provider
    we have `RoutingContext` which simply passes all required props down into our
    app so we can have a correctly-created markup server side.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们正在使用`renderToStaticMarkup`创建服务器端的HTML标记。在这个函数内部，有一个使用之前通过`let initMOCKstore
    = fetchServerSide()`获取的store的Provider。在Redux Provider内部，我们有`RoutingContext`，它简单地传递所有必要的props到我们的应用，这样我们就可以在服务器端创建正确的标记。
- en: After all that, we only need to prepare `initialState` of our Redux Store with
    `const initialState = store.getState();` and later `let fullHTML = renderFullPage(html,
    initialState);` to have everything we need to send it to the client with `res.send(fullHTML)`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成所有这些之后，我们只需要用`const initialState = store.getState();`来准备我们的Redux Store的`initialState`，然后使用`let
    fullHTML = renderFullPage(html, initialState);`来获取发送给客户端所需的一切，使用`res.send(fullHTML)`。
- en: We are done with server-side preparations.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了服务器端的准备工作。
- en: Double-check server/server.js
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新检查server/server.js
- en: 'Before we go forward with the client-side development, we will double-check
    `server/server.js` as the order of our code is important and this is one of the
    error-prone files:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始进行客户端开发之前，我们将对`server/server.js`进行双重检查，因为我们的代码顺序很重要，而且这是一个容易出错的文件：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here you have everything you need for the server-side rendering on the backend.
    Let's move on to the frontend side improvements.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你就有在服务器端进行渲染所需的一切。让我们继续进行前端方面的改进。
- en: Frontend tweaks to make the server-side rendering work
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前端调整以使服务器端渲染工作
- en: 'We need some tweaks to the frontend. First of all, go to the file in `src/layouts/CoreLayout.js`
    and add the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对前端进行一些调整。首先，转到`src/layouts/CoreLayout.js`文件，并添加以下内容：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'From the preceding code, the new thing to add is:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，需要添加的新内容是：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Besides this, improve the `render` function and export `default` to:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，改进`render`函数并将`default`导出为：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We need the changes in the `CoreLayout` component because the Material UI design
    by default is checking on what browser you run it in and as you can predict, there
    is no browser on the server side so we need to provide the information in our
    app on whether `{ userAgent: ''all'' }` is set to `all`. It will help avoid warnings
    in the console about the server-side HTML markup being different from the one
    generated by the client-side browser.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '我们需要在`CoreLayout`组件中进行更改，因为Material UI设计默认情况下会检查你在哪个浏览器上运行它，正如你可以预测的，服务器端没有浏览器，因此我们需要在我们的应用程序中提供有关`{
    userAgent: ''all'' }`是否设置为`all`的信息。这将有助于避免控制台中的警告，关于服务器端HTML标记与客户端浏览器生成的标记不同。'
- en: 'We also need to improve our component `WillMount/_fetch` function in the publishing
    app''s component, so it will be fired only on the frontend. Go to the `src/layouts/PublishingApp.js` file
    then replace this old code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要改进发布应用程序组件中的`WillMount/_fetch`函数，使其仅在前端触发。然后转到`src/layouts/PublishingApp.js`文件，替换以下旧代码：
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Replace it with the new improved code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下新改进的代码替换它：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: That `if(typeof window !== 'undefined')` statement checks if there is a window
    (on the server-side, the window will be undefined). If yes then it starts fetching
    data via Falcor (when on the client side).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这条`if(typeof window !== 'undefined')`语句检查是否存在窗口（在服务器端，窗口将是未定义的）。如果存在，则通过Falcor开始获取数据（当在客户端时）。
- en: 'Next, go to the `containers/Root.js` file and change it to the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开`containers/Root.js`文件并将其更改为以下内容：
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As you can see, we have deleted this part of the code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们已经删除了这部分代码：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And we have changed this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经做了以下更改：
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 变为以下内容：
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Why do we need to do all this? It helps us to get rid of the `/#/` sign from
    our client-side browser's URL so next time when we hit, for example, `http://localhost:3000/register`
    then our `server.js` can see the user's current URL with the `req.path` (in our
    case when hitting the `http://localhost:3000/register` the `req.path` is then
    equal to `/register`) that we use in the `handleServerSideRender` function.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么要做所有这些？这有助于我们从客户端浏览器URL中去除`/#/`标志，因此下次当我们点击例如`http://localhost:3000/register`时，我们的`server.js`可以看到用户当前的URL，即我们在`handleServerSideRender`函数中使用的`req.path`（在我们的情况下，当点击`http://localhost:3000/register`时，`req.path`等于`/register`）。
- en: 'After all that, you will then be able to see the following in your client browser:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成所有这些之后，你将在客户端浏览器中看到以下内容：
- en: '![](img/00027.jpeg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00027.jpeg)'
- en: 'After 1-2 seconds it will change to the following because of firing the real
    `this._fetch()` function in the `PublishingApp.js`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在1-2秒后，它将变为以下内容，因为`PublishingApp.js`中触发了真实的`this._fetch()`函数：
- en: '![](img/00028.jpeg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00028.jpeg)'
- en: 'Of course, you can see the server-rendered markup when you go to the page''s
    HTML source:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以通过查看页面HTML源代码来查看服务器端渲染的标记：
- en: '![](img/00029.jpeg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00029.jpeg)'
- en: Summary
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have done the basic server-side rendering, as you can see in the screenshots.
    The only missing piece in the server-side rendering is to fetch real data from
    our MongoDB--that will be implemented in the next chapter (we will unlock this
    fetching in `server/fetchServerSide.js`).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了基本的服务器端渲染，正如你在屏幕截图中所看到的。服务器端渲染中唯一缺少的部分是从我们的MongoDB获取真实数据--这将在下一章中实现（我们将在`server/fetchServerSide.js`中解锁此获取）。
- en: After unmocking the server side's database query, we will start working on improving
    the whole look of our app and implement some key features that are important for
    us such as adding/editing/deleting an article.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在取消模拟服务器端数据库查询后，我们将开始改进应用程序的整体外观并实现一些对我们来说非常重要的关键功能，例如添加/编辑/删除文章。
