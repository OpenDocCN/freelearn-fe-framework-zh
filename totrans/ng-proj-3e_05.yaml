- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Building a WYSIWYG Editor for the Desktop Using Electron
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用电子构建桌面WYSIWYG编辑器
- en: Web applications are traditionally built with HTML, CSS, and JavaScript. Their
    use has also widely spread to server development using **Node.js**. Various tools
    and frameworks have emerged in recent years that use HTML, CSS, and JavaScript
    to create applications for desktop and mobile. In this chapter, we will investigate
    how to create desktop applications using Angular and **Electron**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序传统上是用HTML、CSS和JavaScript构建的。它们的使用也广泛扩展到使用**Node.js**的服务器开发。近年来，出现了各种工具和框架，它们使用HTML、CSS和JavaScript来创建桌面和移动应用程序。在本章中，我们将探讨如何使用Angular和**电子**创建桌面应用程序。
- en: 'Electron is a JavaScript framework used to build native desktop applications
    with web technologies. Combining it with the Angular framework allows us to create
    fast and highly performant web applications. In this chapter, we will build a
    desktop **WYSIWYG** editor and cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 电子是一个JavaScript框架，用于使用Web技术构建原生桌面应用程序。结合Angular框架，我们可以创建快速且高性能的Web应用程序。在本章中，我们将构建一个桌面**WYSIWYG**编辑器，并涵盖以下主题：
- en: Adding a WYSIWYG editor library for Angular
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Angular添加WYSIWYG编辑器库
- en: Integrating Electron in the workspace
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在工作区中集成电子
- en: Communicating between Angular and Electron
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular与电子之间的通信
- en: Packaging a desktop application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包桌面应用程序
- en: Essential background theory and context
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 必要的背景理论和上下文
- en: Electron is a cross-platform framework used to build Windows, Linux, and Mac
    desktop applications. Many popular applications, such as Visual Studio Code, Skype,
    and Slack, are made with Electron. The Electron framework is built on top of Node.js
    and Chromium. Web developers can leverage their existing HTML, CSS, and JavaScript
    skills to create desktop applications without learning a new language like C++
    or C#.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 电子框架是一个跨平台框架，用于构建Windows、Linux和Mac桌面应用程序。许多流行的应用程序，如Visual Studio Code、Skype和Slack，都是使用电子框架制作的。电子框架建立在Node.js和Chromium之上。Web开发者可以利用他们现有的HTML、CSS和JavaScript技能来创建桌面应用程序，而无需学习新的语言，如C++或C#。
- en: Electron applications have many similarities with PWA applications. Consider
    building an Electron application for scenarios such as advanced filesystem manipulation
    or when you need a more native look and feel for your application. Another use
    case is when you build a complementary tool for your primary desktop product and
    want to ship them together.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 电子应用程序与PWA应用程序有许多相似之处。考虑为以下场景构建电子应用程序，如高级文件系统操作或当你需要为你的应用程序提供更原生的外观和感觉时。另一个用例是当你为你的主要桌面产品构建补充工具并希望将它们一起发布时。
- en: 'An Electron application consists of two processes:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 电子应用程序由两个进程组成：
- en: '**Main**: This interacts with the native local resources using the Node.js
    API.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主进程**：这通过Node.js API与本地资源进行交互。'
- en: '**Renderer**: This is responsible for managing the user interface of the application.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**渲染器**：负责管理应用程序的用户界面。'
- en: An Electron application can have only one main process that communicates with
    one or more renderer processes. Each renderer process operates in complete isolation
    from the others.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 电子应用程序只能有一个主进程，该进程与一个或多个渲染进程进行通信。每个渲染进程与其他进程完全隔离运行。
- en: The Electron framework provides the **ipcMain** and **ipcRenderer** interfaces,
    which we can use to interact with these processes. The interaction is accomplished
    using **Inter-Process Communication (IPC)**, a mechanism that exchanges messages
    securely and asynchronously over a common channel via a Promise-based API.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 电子框架提供了**ipcMain**和**ipcRenderer**接口，我们可以使用这些接口与这些进程进行交互。交互是通过**进程间通信（IPC）**完成的，这是一种通过基于Promise的API在公共通道上安全异步交换消息的机制。
- en: Project overview
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: 'In this project, we will build a desktop WYSIWYG editor that keeps its content
    local to the filesystem. Initially, we will build it as an Angular application
    using **ngx-wig**, a popular WYSIWYG Angular library. We will then convert it
    to a desktop application using Electron and learn how to synchronize content between
    Angular and Electron. We will also see how to persist the content of the editor
    into the filesystem. Finally, we will package our application as a single executable
    file that can be run in a desktop environment. The following diagram describes
    an architectural overview of the project:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在此项目中，我们将构建一个桌面 WYSIWYG 编辑器，其内容保留在文件系统中。最初，我们将使用 **ngx-wig**，一个流行的 WYSIWYG Angular
    库，将其构建为 Angular 应用程序。然后，我们将使用 Electron 将其转换为桌面应用程序，并学习如何在 Angular 和 Electron 之间同步内容。我们还将了解如何将编辑器的内容持久化到文件系统中。最后，我们将打包我们的应用程序为一个可执行的单一文件，该文件可以在桌面环境中运行。以下图表描述了项目的架构概述：
- en: '![Εικόνα που περιέχει διάγραμμα  Περιγραφή που δημιουργήθηκε αυτόματα](img/B18465_05_01.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![包含图表的图片 自动生成的描述](img/B18465_05_01.png)'
- en: Figure 5.1 – Project architecture
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 项目架构
- en: 'Build time: 1 hour.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 构建时间：1 小时。
- en: Getting started
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用
- en: 'The following software tools are required to complete this project:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此项目所需的软件工具如下：
- en: '**Angular CLI**: A command-line interface for Angular that you can find at
    [https://angular.io/cli](https://angular.io/cli).'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Angular CLI**：Angular 的命令行界面，您可以在 [https://angular.io/cli](https://angular.io/cli)
    找到。'
- en: '**Visual Studio Code**: A code editor that you can download from [https://code.visualstudio.com](https://code.visualstudio.com).'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio Code**：一个代码编辑器，您可以从 [https://code.visualstudio.com](https://code.visualstudio.com)
    下载。'
- en: '**GitHub material**: The code for this chapter can be found in the `Chapter05`
    folder at [https://github.com/PacktPublishing/Angular-Projects-Third-Edition](https://github.com/PacktPublishing/Angular-Projects-Third-Edition).'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GitHub 材料**：本章的代码可以在 [https://github.com/PacktPublishing/Angular-Projects-Third-Edition](https://github.com/PacktPublishing/Angular-Projects-Third-Edition)
    的 `Chapter05` 文件夹中找到。'
- en: Adding a WYSIWYG editor library for Angular
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 Angular 添加 WYSIWYG 编辑器库
- en: 'We will kick off our project by creating a WYSIWYG editor as a Angular application.
    Use the Angular CLI to create a new Angular application from scratch:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过创建一个作为 Angular 应用程序的 WYSIWYG 编辑器来启动我们的项目。使用 Angular CLI 从头开始创建一个新的 Angular
    应用程序：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We pass the following options to the `ng new` command:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以下选项传递给 `ng new` 命令：
- en: '`my-editor`: Defines the name of the application'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`my-editor`: 定义应用程序的名称'
- en: '`--defaults`: Defines CSS as the preferred stylesheet format of the application
    and disables routing because our application will consist of a single component
    that will host the editor'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--defaults`: 定义CSS为应用程序的首选样式表格式，并禁用路由，因为我们的应用程序将仅由一个包含编辑器的组件组成'
- en: 'A WYSIWYG editor is a rich text editor, such as Microsoft Word. We could create
    one from scratch using the Angular framework, but it would be time-consuming,
    and we would only reinvent the wheel. The Angular ecosystem contains a wide variety
    of libraries for this purpose. One of them is the ngx-wig library, which has no
    external dependencies, just Angular! Let’s add the library to our application
    and learn how to use it:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: WYSIWYG 编辑器是一种富文本编辑器，例如 Microsoft Word。我们可以使用 Angular 框架从头开始创建一个，但这将非常耗时，我们只会重蹈覆辙。Angular
    生态系统包含大量用于此目的的库。其中之一是 ngx-wig 库，它没有外部依赖，只有 Angular！让我们将库添加到我们的应用程序中，并学习如何使用它：
- en: 'Use the `npm` client to install `ngx-wig` from the npm package registry:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `npm` 客户端从 npm 包注册库安装 `ngx-wig`：
- en: '[PRE1]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Open the `app.module.ts` file and add `NgxWigModule` to the `imports` array
    of the `@NgModule` decorator:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `app.module.ts` 文件，并将 `NgxWigModule` 添加到 `@NgModule` 装饰器的 `imports` 数组中：
- en: '[PRE2]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`NgxWigModule` is the main module of the ngx-wig library.'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`NgxWigModule` 是 ngx-wig 库的主要模块。'
- en: 'Create a new Angular component that will host our WYSIWYG editor:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Angular 组件，该组件将托管我们的 WYSIWYG 编辑器：
- en: '[PRE3]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Open the template file of the newly generated component, `editor.component.html`,
    and replace its content with the following HTML snippet:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开新创建的组件的模板文件，`editor.component.html`，并用以下 HTML 片段替换其内容：
- en: '[PRE4]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`NgxWigModule` exposes a set of Angular services and components we can use
    in our application. The main component of the module is the `<ngx-wig>` component,
    which displays the actual WYSIWYG editor. It exposes a collection of input properties
    that we can set, such as the placeholder of the editor.'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`NgxWigModule` 提供了一组 Angular 服务和组件，我们可以在应用程序中使用。该模块的主要组件是 `<ngx-wig>` 组件，它显示实际的
    WYSIWYG 编辑器。它公开了一组我们可以设置的输入属性，例如编辑器的占位符。'
- en: 'Open the `app.component.html` file and replace its content with the `<app-editor>`
    component:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`app.component.html`文件，并用`<app-editor>`组件替换其内容：
- en: '[PRE5]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Open the `styles.css` file, which contains global styles for the Angular application,
    and add the following styles to make the editor dockable and take up the full
    page:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`styles.css`文件，该文件包含Angular应用程序的全局样式，并添加以下样式以使编辑器可停靠并占满整个页面：
- en: '[PRE6]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Open the main HTML file of the Angular application, `index.html`, and remove
    the `<base>` tag from the `<head>` element. The browser uses the `<base>` tag
    to reference scripts and CSS files with a relative URL. Leaving it as is will
    make our desktop application fail because it will load all necessary assets directly
    from the local filesystem. We will learn more in the *Integrating Angular with
    Electron* section.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Angular应用程序的主要HTML文件`index.html`，并从`<head>`元素中移除`<base>`标签。浏览器使用`<base>`标签通过相对URL引用脚本和CSS文件。保留它将使我们的桌面应用程序失败，因为它将直接从本地文件系统中加载所有必要的资源。我们将在*集成Angular与Electron*部分了解更多。
- en: 'Let’s see what we have achieved so far. Run `ng serve` and navigate to `http://localhost:4200`
    to preview the application:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们已经取得了哪些成果。运行`ng serve`并导航到`http://localhost:4200`以预览应用程序：
- en: '![Figure 5.1 – Application output](img/B18465_05_02.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1 – 应用程序输出](img/B18465_05_02.png)'
- en: Figure 5.2 – Application output
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – 应用程序输出
- en: 'Our application consists of the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序包括以下内容：
- en: A toolbar with buttons that allows us to apply different styles to the content
    of the editor
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有按钮的工具栏，允许我们应用不同的样式到编辑器的内容
- en: A text area that is used as the main container to add content to the editor
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用作编辑器主要容器的文本区域，用于添加内容
- en: We have now created a web application using Angular with a fully operational
    WYSIWYG editor. In the following section, we will learn how to convert it into
    a desktop one using Electron.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经使用Angular创建了一个具有完全可操作的WYSIWYG编辑器的Web应用程序。在下一节中，我们将学习如何使用Electron将其转换为桌面应用程序。
- en: Integrating Electron in the workspace
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在工作空间中集成Electron
- en: 'The Electron framework is an npm package that we can install using the following
    command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Electron框架是一个我们可以使用以下命令安装的npm包：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The previous command will install the latest version of the `electron` npm package
    in the Angular CLI workspace. It will also add a respective entry into the `devDependencies`
    section of the `package.json` file of our project.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将在Angular CLI工作空间中安装最新版本的`electron` npm包。它还将在我们的项目`package.json`文件的`devDependencies`部分添加相应的条目。
- en: Electron is added to the `devDependencies` section of the `package.json` file
    because it is a development dependency of our application. It is used only to
    prepare and build our application as a desktop one and not during runtime.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Electron被添加到`package.json`文件的`devDependencies`部分，因为它是我们应用程序的开发依赖项。它仅用于将我们的应用程序作为桌面应用程序准备和构建，而不是在运行时使用。
- en: 'Electron applications run on the Node.js runtime and use the Chromium browser
    to render. A Node.js application has at least a JavaScript file, usually called
    `index.js` or `main.js`, which is the main entry point of the application. Since
    we are using Angular and TypeScript as our development stack, we will start by
    creating a separate TypeScript file that will be finally compiled in JavaScript:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Electron应用程序在Node.js运行时上运行，并使用Chromium浏览器进行渲染。一个Node.js应用程序至少有一个JavaScript文件，通常称为`index.js`或`main.js`，它是应用程序的主要入口点。由于我们使用Angular和TypeScript作为我们的开发堆栈，我们将首先创建一个单独的TypeScript文件，最终将其编译成JavaScript：
- en: Create a folder named `electron` inside the `src` folder of the Angular CLI
    workspace. The `electron` folder will contain any source code that is related
    to Electron.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Angular CLI工作空间的`src`文件夹内创建一个名为`electron`的文件夹。`electron`文件夹将包含任何与Electron相关的源代码。
- en: We can think of our application as two different platforms. The web platform
    is the Angular application, which resides in the `src\app` folder. The desktop
    platform is the Electron application, which resides in the `src\electron` folder.
    This approach has many benefits, including that it enforces the separation of
    concerns in our application and allows each one to develop independently from
    the other. From now on, we will refer to them as the Angular and Electron applications.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以将我们的应用程序视为两个不同的平台。Web平台是Angular应用程序，位于`src\app`文件夹中。桌面平台是Electron应用程序，位于`src\electron`文件夹中。这种方法有许多优点，包括它强制我们在应用程序中分离关注点，并允许它们独立于彼此独立开发。从现在起，我们将它们称为Angular和Electron应用程序。
- en: 'Create a `main.ts` file inside the `electron` folder with the following content:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`electron`文件夹内创建一个`main.ts`文件，并包含以下内容：
- en: '[PRE8]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code, we first import the `BrowserWindow` and `app` artifacts
    from the `electron` npm package. The `BrowserWindow` class is used to create a
    desktop window for our application. We define the window dimensions, passing an
    `options` object in its constructor that sets the `width` and `height` values
    of the window. We then call the `loadFile` method, passing the HTML file we want
    to load inside the window as a parameter.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先从`electron` npm包中导入`BrowserWindow`和`app`模块。`BrowserWindow`类用于为我们的应用程序创建桌面窗口。我们通过构造函数传递一个`options`对象来定义窗口的尺寸，该对象设置了窗口的`width`和`height`值。然后我们调用`loadFile`方法，将作为参数传递我们想要在窗口内加载的HTML文件。
- en: The `index.html` file that we pass in the `loadFile` method is the main HTML
    file of the Angular application. It is loaded using the **file** protocol, which
    is why we removed the `<base>` tag in the *Adding a WYSIWYG editor library for
    Angular* section.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在`loadFile`方法中传递的`index.html`文件是Angular应用程序的主HTML文件。它是使用**文件**协议加载的，这就是为什么我们在*为Angular添加WYSIWYG编辑器库*部分中移除了`<base>`标签。
- en: The `app` object is the global object of our desktop application, just like
    the `window` object on a web page. It exposes a `whenReady` Promise that, when
    resolved, allows us to run any initialization logic for our application, including
    creating the window.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`app`对象是我们桌面应用程序的全局对象，就像网页上的`window`对象一样。它暴露了一个`whenReady` Promise，当它解析时，允许我们运行应用程序的任何初始化逻辑，包括创建窗口。'
- en: 'Create a `tsconfig.json` file inside the `electron` folder and add the following
    contents:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`electron`文件夹内创建一个`tsconfig.json`文件，并添加以下内容：
- en: '[PRE9]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `main.ts` file must be compiled into JavaScript because browsers do not
    understand TypeScript. The compilation process is called **transpilation** and
    requires a TypeScript configuration file. The configuration file contains options
    that drive the TypeScript **transpiler**, which is responsible for the transpilation
    process.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`main.ts`文件必须编译成JavaScript，因为浏览器不理解TypeScript。编译过程称为**转译**，需要一个TypeScript配置文件。配置文件包含驱动TypeScript
    **转译器**的选项，转译器负责转译过程。'
- en: The preceding TypeScript configuration file defines the path of the Electron
    source code files, using the `include` property, and sets the `importHelpers`
    property to `false`.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述TypeScript配置文件使用`include`属性定义了Electron源代码文件的路径，并将`importHelpers`属性设置为`false`。
- en: If we enable the `importHelpers` flag, it will include helpers from the **tslib**
    library in our application, resulting in a larger bundle size.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们启用`importHelpers`标志，它将包括来自**tslib**库的帮助程序，从而导致包的大小更大。
- en: 'Run the following command to install the **Webpack CLI**:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以安装**Webpack CLI**：
- en: '[PRE10]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The Webpack CLI invokes **webpack**, a popular module bundler, from the command
    line. We will use webpack to build and bundle our Electron application.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Webpack CLI从命令行调用流行的模块打包器**webpack**。我们将使用webpack来构建和打包我们的Electron应用程序。
- en: 'Install the `ts-loader` npm package using the following command:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令安装`ts-loader` npm包：
- en: '[PRE11]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The **ts-loader** library is a webpack plugin that can load TypeScript files.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**ts-loader**库是一个webpack插件，可以加载TypeScript文件。'
- en: 'We have created all the pieces needed to convert our Angular application into
    a desktop one using Electron. We only need to put them together to build and run
    our desktop application. The main piece that orchestrates the Electron application
    is the webpack configuration file that we need to create in the root folder of
    our Angular CLI workspace:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了将我们的Angular应用程序转换为桌面应用程序所需的全部组件，使用Electron。我们只需要将它们组合起来以构建和运行我们的桌面应用程序。协调Electron应用程序的主要组件是我们需要在Angular
    CLI工作区的根目录中创建的webpack配置文件：
- en: '`webpack.config.js`'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`webpack.config.js`'
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding file configures webpack in our application using the following
    options:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的文件使用以下选项配置了我们的应用程序中的webpack：
- en: '`mode`: Indicates that we are currently running in a `development` environment.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mode`：指示我们当前正在`开发`环境中运行。'
- en: '`devtool`: Enables source map file generation for debugging purposes.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`devtool`：启用源映射文件生成，用于调试目的。'
- en: '`entry`: Indicates the main entry point of the Electron application, which
    is the `main.ts` file.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entry`：指示Electron应用程序的主入口点，即`main.ts`文件。'
- en: '`output`: Defines the path and the filename of the Electron bundle that will
    be generated from webpack. The `path` property points to the same folder used
    by the Angular CLI to create the bundle of the Angular application. The `filename`
    property is set to `shell.js` because the default one generated from webpack is
    `main.js`, and it will cause a conflict with the `main.js` file generated from
    the Angular application.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`输出`: 定义了从webpack生成的Electron包的路径和文件名。`path`属性指向Angular CLI创建Angular应用包所使用的相同文件夹。`filename`属性设置为`shell.js`，因为webpack默认生成的文件名为`main.js`，这将会与Angular应用生成的`main.js`文件冲突。'
- en: '`module`: Instructs webpack to load the `ts-loader` plugin to handle TypeScript
    files.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`module`: 指示webpack加载`ts-loader`插件来处理TypeScript文件。'
- en: '`target`: Indicates that we are currently running in the main process of Electron.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target`: 表示我们目前正在Electron的主进程中运行。'
- en: 'The webpack module bundler now contains all the information needed to build
    and bundle the Electron application. On the other hand, the Angular CLI takes
    care of building the Angular application. Let’s see how we can combine them and
    run our desktop application:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack模块打包器现在包含了构建和打包Electron应用所需的所有信息。另一方面，Angular CLI负责构建Angular应用。让我们看看我们如何将它们结合起来并运行我们的桌面应用：
- en: 'Run the following command to install the `concurrently` npm package:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来安装`concurrently`npm包：
- en: '[PRE13]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The **concurrently** library enables us to execute multiple processes together.
    In our case, it will allow us to run the Angular and Electron applications in
    parallel.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**concurrently**库使我们能够同时执行多个进程。在我们的案例中，它将允许我们并行运行Angular和Electron应用。'
- en: 'Open the `package.json` file and add a new entry in the `scripts` property:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`package.json`文件，并在`scripts`属性中添加一个新条目：
- en: '[PRE14]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `start:desktop` script builds the Angular application, using the `ng build`
    command of the Angular CLI, and the Electron application, using the `webpack`
    command. Both applications run in watch mode using the `--watch` option, so every
    time we change the code, the application will rebuild to reflect the change.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`start:desktop`脚本使用Angular CLI的`ng build`命令构建Angular应用，并使用`webpack`命令构建Electron应用。两个应用都使用`--watch`选项以监视模式运行，所以每次我们更改代码，应用都会重新构建以反映更改。'
- en: The Angular CLI will delete the `dist` folder by default whenever we modify
    the Angular application. We can prevent this behavior using the `--delete-output-path=false`
    option because the Electron application is also built in the same folder.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们修改Angular应用时，Angular CLI默认会删除`dist`文件夹。我们可以使用`--delete-output-path=false`选项来防止这种行为，因为Electron应用也是在同一个文件夹中构建的。
- en: We did not pass the webpack configuration file to the `webpack` command because
    it assumes the `webpack.config.js` filename by default.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们没有将webpack配置文件传递给`webpack`命令，因为它默认假设文件名为`webpack.config.js`。
- en: 'Click on the **Run** menu that exists in the sidebar of Visual Studio Code:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击Visual Studio Code侧边栏中存在的**运行**菜单：
- en: '![Figure 5.2 – Run menu](img/B18465_05_03.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2 – 运行菜单](img/B18465_05_03.png)'
- en: Figure 5.3 – Run menu
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – 运行菜单
- en: 'In the **RUN AND DEBUG** pane that appears, select the **Add Configuration…**
    option from the drop-down menu:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在出现的**运行和调试**面板中，从下拉菜单中选择**添加配置…**选项：
- en: '![](img/B18465_05_04.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18465_05_04.png)'
- en: Figure 5.4 – RUN AND DEBUG pane
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 – 运行和调试面板
- en: 'Visual Studio Code will open a drop-down menu that allows us to select the
    environment to run our application. Select the **{} Node.js: Electron Main** configuration.'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Visual Studio Code将打开一个下拉菜单，允许我们选择运行应用的环境。选择**{} Node.js: Electron Main**配置。'
- en: In the `launch.json` file that opens, set the value of the `program` property
    to `${workspaceFolder}/dist/my-editor/shell.js`. The `program` property points
    to the absolute path of the Electron bundle file.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在打开的`launch.json`文件中，将`program`属性的值设置为`${workspaceFolder}/dist/my-editor/shell.js`。`program`属性指向Electron包文件的绝对路径。
- en: 'We are now ready to run our desktop application and preview it. Run the following
    command to build the application:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好运行我们的桌面应用并预览它。运行以下命令来构建应用：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The previous command will first build the Electron application and then the
    Angular one. Wait for the Angular build to finish, select the **Electron Main**
    option from the drop-down menu of the **RUN AND DEBUG** pane, and click the *Play*
    button to preview the application:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将首先构建Electron应用，然后是Angular应用。等待Angular构建完成，从**运行和调试**面板的下拉菜单中选择**Electron
    Main**选项，然后点击*播放*按钮来预览应用：
- en: '![Figure 5.4 – Application window](img/B18465_05_05.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图5.4 – 应用程序窗口](img/B18465_05_05.png)'
- en: Figure 5.5 – Application window
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 应用程序窗口
- en: 'In the preceding screenshot, we can see that our Angular application with the
    WYSIWYG editor is hosted inside a native desktop window. It contains the following
    characteristics that we usually find in desktop applications:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们可以看到我们的带有 WYSIWYG 编辑器的 Angular 应用程序托管在原生桌面窗口中。它包含以下我们在桌面应用程序中通常会发现的特点：
- en: The header with an icon
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有图标的标题
- en: The main menu
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主菜单
- en: The minimize, maximize, and close buttons
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化、最大化和关闭按钮
- en: The Angular application is rendered inside the Chromium browser. To verify that,
    click the **View** menu item and select the **Toggle Developer Tools** option.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 应用程序在 Chromium 浏览器内部渲染。为了验证这一点，点击 **视图** 菜单项并选择 **切换开发者工具** 选项。
- en: Well done! You have successfully managed to create your own desktop WYSIWYG
    editor. In the following section, we will learn how to interact between Angular
    and Electron.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！你已经成功创建了自己的桌面 WYSIWYG 编辑器。在下一节中，我们将学习如何进行 Angular 和 Electron 之间的交互。
- en: Communicating between Angular and Electron
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 和 Electron 之间的通信
- en: According to the specifications of the project, the content of the WYSIWYG editor
    needs to be persisted in the local filesystem. Additionally, the content will
    be loaded from the filesystem upon application startup.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 根据项目的规格，WYSIWYG 编辑器的内容需要保存在本地文件系统中。此外，内容将在应用程序启动时从文件系统加载。
- en: 'The Angular application handles any interaction between the WYSIWYG editor
    and its data using the renderer process, whereas the Electron application manages
    the filesystem with the main process. Thus, we need to establish an IPC mechanism
    to communicate between the two Electron processes as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 应用程序使用渲染进程处理 WYSIWYG 编辑器与数据之间的任何交互，而 Electron 应用程序使用主进程管理文件系统。因此，我们需要建立一个
    IPC 机制，以便在两个 Electron 进程之间进行通信，如下所示：
- en: Configuring the Angular CLI workspace
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 Angular CLI 工作区
- en: Interacting with the editor
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与编辑器交互
- en: Interacting with the filesystem
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与文件系统交互
- en: Let’s start by setting up the Angular CLI project to support the desired communication
    mechanism.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先设置 Angular CLI 项目以支持所需的通信机制。
- en: Configuring the Angular CLI workspace
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 Angular CLI 工作区
- en: 'We need to modify several files to configure the workspace of our application:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修改几个文件来配置我们应用程序的工作区：
- en: 'Open the `main.ts` file that exists in the `src\electron` folder and set the
    `webPreferences` property in the `BrowserWindow` constructor accordingly:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开位于 `src\electron` 文件夹中的 `main.ts` 文件，并在 `BrowserWindow` 构造函数中相应地设置 `webPreferences`
    属性：
- en: '[PRE16]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding flags will enable Node.js in the renderer process and expose the
    `ipcRenderer` interface, which we will need to communicate with the main process.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之前的标志将在渲染进程中启用 Node.js 并公开 `ipcRenderer` 接口，这是我们与主进程通信所需的。
- en: 'Run the following command to install the `ngx-electronyzer` npm package:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来安装 `ngx-electronyzer` npm 包：
- en: '[PRE17]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The **ngx-electronyzer** library allows us to integrate the Electron API into
    an Angular application.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**ngx-electronyzer** 库允许我们将 Electron API 集成到 Angular 应用程序中。'
- en: The Angular and Electron applications are now ready to interact with each other
    using the IPC mechanism. Let’s start implementing the necessary logic in the Angular
    application first.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 和 Electron 应用程序现在已准备好通过 IPC 机制相互交互。让我们首先在 Angular 应用程序中实现必要的逻辑。
- en: Interacting with the editor
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与编辑器交互
- en: 'The Angular application is responsible for managing the WYSIWYG editor. The
    content of the editor is kept in sync with the filesystem using the renderer process
    of Electron. Let’s find out how to use the renderer process:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 应用程序负责管理 WYSIWYG 编辑器。编辑器的内容通过 Electron 的渲染进程与文件系统保持同步。让我们了解如何使用渲染进程：
- en: 'Create a new Angular service using the following command of the Angular CLI:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下 Angular CLI 命令创建一个新的 Angular 服务：
- en: '[PRE18]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Open the `editor.service.ts` file and inject the `ElectronService` class from
    the `ngx-electronyzer` npm package:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `editor.service.ts` 文件，并从 `ngx-electronyzer` npm 包中注入 `ElectronService` 类：
- en: '[PRE19]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `ElectronService` class exposes part of the Electron API, including the
    `ipcRenderer` interface we are currently interested in.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ElectronService` 类公开了部分 Electron API，包括我们目前感兴趣的 `ipcRenderer` 接口。'
- en: 'Create a method that will be called to get the content of the editor from the
    filesystem:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个方法，该方法将被调用来从文件系统获取编辑器的内容：
- en: '[PRE20]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We use the `invoke` method of the `ipcRenderer` property, passing the name of
    the communication channel as a parameter. The result of the `getContent` method
    is a `Promise` object of the `string` type, since the content of the editor is
    raw text data. The `invoke` method initiates a connection with the main process
    through the `getContent` channel. In the *Interacting with the filesystem* section,
    we will see how to set up the main process to respond to the `invoke` method call
    in that channel.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用 `ipcRenderer` 属性的 `invoke` 方法，将通信通道的名称作为参数传递。`getContent` 方法的返回值是一个 `Promise`
    对象，其类型为 `string`，因为编辑器的内容是原始文本数据。`invoke` 方法通过 `getContent` 通道与主进程建立连接。在 *与文件系统交互*
    部分，我们将看到如何设置主进程以响应该通道中的 `invoke` 方法调用。
- en: 'Create a method that will be called to save the content of the editor to the
    filesystem:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个方法，当需要将编辑器的内容保存到文件系统时将被调用：
- en: '[PRE21]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `setContent` method calls the `invoke` method of the `ipcRenderer` object
    again but with a different channel name. It also uses the second parameter of
    the `invoke` method to pass data to the main process. In this case, the `content`
    parameter will contain the content of the editor. We will see how to configure
    the main process to handle data in the *Interacting with the filesystem* section.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`setContent` 方法再次调用 `ipcRenderer` 对象的 `invoke` 方法，但使用不同的通道名称。它还使用 `invoke`
    方法的第二个参数将数据传递给主进程。在这种情况下，`content` 参数将包含编辑器的内容。我们将在 *与文件系统交互* 部分看到如何配置主进程以处理数据。'
- en: 'Open the `editor.component.ts` file and create a `myContent` property to hold
    editor data. Also, inject `EditorService` in the `constructor` of the `EditorComponent`
    class, and add the `OnInit` interface from the `@angular/core` npm package:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `editor.component.ts` 文件并创建一个 `myContent` 属性来保存编辑器数据。同时，在 `EditorComponent`
    类的 `constructor` 中注入 `EditorService`，并添加来自 `@angular/core` npm 包的 `OnInit` 接口：
- en: '[PRE22]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create a method that calls the `getContent` method of the `editorService` variable
    and executes it inside the `ngOnInit` method:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个方法，该方法调用 `editorService` 变量的 `getContent` 方法，并在 `ngOnInit` 方法内部执行它：
- en: '[PRE23]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We use the `async`/`await` syntax, which allows the synchronous execution of
    our code in Promise-based method calls.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用 `async`/`await` 语法，它允许我们在基于 Promise 的方法调用中同步执行我们的代码。
- en: 'Create a method that calls the `setContent` method of the `editorService` variable:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个方法，该方法调用 `editorService` 变量的 `setContent` 方法：
- en: '[PRE24]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let’s bind those methods that we have created with the template of the component.
    Open the `editor.component.html` file and add the following bindings:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将我们创建的方法与组件的模板绑定起来。打开 `editor.component.html` 文件并添加以下绑定：
- en: '[PRE25]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We use the `ngModel` directive to bind the model of the editor to the `myContent`
    component property, which will be used to display the content initially. We also
    use the `contentChange` event binding to save the content of the editor whenever
    it changes, that is, while the user types.
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用 `ngModel` 指令将编辑器的模型绑定到 `myContent` 组件属性，该属性将用于最初显示内容。我们还使用 `contentChange`
    事件绑定，以便在编辑器内容更改时（即用户输入时）保存编辑器的内容。
- en: 'The `ngModel` directive is part of the `@angular/forms` npm package. Import
    `FormsModule` into the `app.module.ts` file to use it:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ngModel` 指令是 `@angular/forms` npm 包的一部分。将 `FormsModule` 导入到 `app.module.ts`
    文件中以便使用：'
- en: '[PRE26]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We have implemented all the logic for our Angular application to communicate
    with the main process. It is time to implement the other end of the communication
    mechanism, the Electron application, and its main process.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了 Angular 应用程序与主进程通信的所有逻辑。现在是时候实现通信机制的另一端，即 Electron 应用程序及其主进程了。
- en: Interacting with the filesystem
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与文件系统交互
- en: 'The main process interacts with the filesystem using the **fs** library, which
    is built into the Electron framework. Let’s see how we can use it:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 主进程通过内置在 Electron 框架中的 **fs** 库与文件系统进行交互。让我们看看如何使用它：
- en: 'Open the `main.ts` file that exists in the `src\electron` folder and import
    the following artifacts:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开位于 `src\electron` 文件夹中的 `main.ts` 文件并导入以下组件：
- en: '[PRE27]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `fs` library is responsible for interacting with the filesystem. The `path`
    library provides utilities for working with file and folder paths. The `ipcMain`
    object allows us to work with the main process of Electron.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`fs` 库负责与文件系统交互。`path` 库提供了用于处理文件和文件夹路径的实用工具。`ipcMain` 对象允许我们与 Electron 的主进程进行交互。'
- en: 'Create a variable that holds the path of the file containing the content of
    the editor:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个变量来保存包含编辑器内容的文件路径：
- en: '[PRE28]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The file that keeps the content of the editor is the `content.html` file that
    exists inside the reserved `userData` folder. The `userData` folder is an alias
    for a special purpose system folder, different for each OS, and it is used to
    store application-specific files such as configuration. You can find more details
    about the `userData` folder and other system folders at [https://www.electronjs.org/docs/api/app#appgetpathname](https://www.electronjs.org/docs/api/app#appgetpathname).
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 保存编辑器内容的文件是位于预留的 `userData` 文件夹中的 `content.html` 文件。`userData` 文件夹是一个特殊用途的系统文件夹的别名，每个操作系统不同，用于存储特定于应用程序的文件，如配置。您可以在
    [https://www.electronjs.org/docs/api/app#appgetpathname](https://www.electronjs.org/docs/api/app#appgetpathname)
    找到有关 `userData` 文件夹和其他系统文件夹的更多详细信息。
- en: The `getPath` method of the `app` object works cross-platform and is used to
    get the path of special folders, such as the home directory of a user or the application
    data.
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`app` 对象的 `getPath` 方法是跨平台的，用于获取特殊文件夹的路径，例如用户的家目录或应用程序数据。'
- en: 'Call the `handle` method of the `ipcMain` object to start listening for requests
    in the `getContent` channel:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `ipcMain` 对象的 `handle` 方法以在 `getContent` 通道中开始监听请求：
- en: '[PRE29]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When the main process receives a request in this channel, it uses the `existsSync`
    method of the `fs` library to check whether the file with the content of the editor
    exists already. If it exists, it reads it using the `readFileSync` method and
    returns its content to the renderer process.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当主进程接收到此通道的请求时，它使用 `fs` 库的 `existsSync` 方法检查包含编辑器内容的文件是否已存在。如果存在，它将使用 `readFileSync`
    方法读取它，并将内容返回给渲染进程。
- en: 'Call the `handle` method again, but this time for the `setContent` channel:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次调用 `handle` 方法，但这次是为 `setContent` 通道：
- en: '[PRE30]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now that we have connected the Angular and the Electron application, it is
    time to preview our WYSIWYG desktop application:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经连接了 Angular 和 Electron 应用程序，是时候预览我们的 WYSIWYG 桌面应用程序了：
- en: Execute the `start:desktop` npm script, and press *F5* to run the application.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 `start:desktop` npm 脚本，并按 *F5* 运行应用程序。
- en: 'Use the editor and its toolbar to enter some content, such as the following:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用编辑器和其工具栏输入一些内容，例如以下内容：
- en: '![Figure 5.5 – Editor content](img/B18465_05_06.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5 – 编辑器内容](img/B18465_05_06.png)'
- en: Figure 5.6 – Editor content
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 编辑器内容
- en: Close the application window and rerun the application. If everything worked
    correctly, you should see the content you entered inside the editor.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭应用程序窗口并重新运行应用程序。如果一切正常，您应该看到编辑器中输入的内容。
- en: Congratulations! You have enriched your WYSIWYG editor by adding persistence
    capabilities to it. In the following section, we will take the last step toward
    creating our desktop application and learn how to package and distribute it.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已经通过向其添加持久性功能来丰富了您的 WYSIWYG 编辑器。在下一节中，我们将采取创建桌面应用程序的最后一步，并学习如何打包和分发它。
- en: Packaging a desktop application
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包桌面应用程序
- en: 'Web applications are usually bundled and deployed to a hosting web server.
    On the other hand, desktop applications are bundled and packaged as a single executable
    file that can be easily distributed. Packaging our WYSIWYG application requires
    the following steps:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用程序通常被打包并部署到托管服务器。另一方面，桌面应用程序被打包并打包成一个可轻松分发的单个可执行文件。打包我们的 WYSIWYG 应用程序需要以下步骤：
- en: Configuring webpack for production mode
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置生产模式下的 webpack
- en: Using an Electron bundler
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Electron 打包器
- en: We will look at them in more detail in the following sections.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中更详细地介绍它们。
- en: Configuring webpack for production
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置生产环境下的 webpack
- en: 'We have already created a webpack configuration file for the development environment.
    We now need to create a new one for production. Both configuration files will
    share some functionality, so let’s start by creating a common one:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为开发环境创建了一个 webpack 配置文件。我们现在需要为生产环境创建一个新的配置文件。这两个配置文件将共享一些功能，所以让我们先创建一个通用的配置文件：
- en: 'Create a `webpack.dev.config.js` file in the root folder of the Angular CLI
    workspace with the following content:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Angular CLI 工作区的根目录中创建一个 `webpack.dev.config.js` 文件，内容如下：
- en: '[PRE31]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Remove the `mode`, `devtool`, and `output` properties from the `webpack.config.js`
    file.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `webpack.config.js` 文件中移除 `mode`、`devtool` 和 `output` 属性。
- en: 'Open the `package.json` file and pass the new webpack development configuration
    file at the `start:desktop` script:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `package.json` 文件，并在 `start:desktop` 脚本中传递新的 webpack 开发配置文件：
- en: '[PRE32]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Create a `webpack.prod.config.js` file in the root folder of the Angular CLI
    workspace with the following content:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Angular CLI 工作区的根目录中创建一个 `webpack.prod.config.js` 文件，内容如下：
- en: '[PRE33]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The main difference with the webpack configuration file for the development
    environment is that we changed the `filename` of the `output` bundle to `main.js`.
    The Angular CLI adds a hashed number in the `main.js` file of the Angular application
    in production, so there will be no conflicts.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与开发环境的 webpack 配置文件相比，主要区别在于我们将 `output` 包的 `filename` 改为了 `main.js`。Angular
    CLI 在生产环境中向 Angular 应用的 `main.js` 文件中添加一个哈希数字，因此不会发生冲突。
- en: 'Add a new entry in the `scripts` property of the `package.json` file to build
    our application in production mode:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `package.json` 文件的 `scripts` 属性中添加一个新的条目，以在生产模式下构建我们的应用程序：
- en: '[PRE34]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `build:electron` script builds the Angular and Electron application in production
    mode simultaneously.
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`build:electron` 脚本同时以生产模式构建 Angular 和 Electron 应用程序。'
- en: We have completed all the configurations needed to package our desktop application.
    In the following section, we will learn how to convert it into a single bundle
    specific to each OS.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了打包桌面应用程序所需的所有配置。在下一节中，我们将学习如何将其转换为针对每个操作系统的单个包。
- en: Using an Electron bundler
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Electron 打包器
- en: 'The Electron framework has various tools created and maintained by the open-source
    community. One of these tools is the **electron-packager** library, which we can
    use to package our desktop application as a single executable file for each OS
    (Windows, Linux, and macOS). Let’s see how we can integrate it into our development
    workflow:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Electron 框架拥有开源社区创建和维护的各种工具。其中之一是 **electron-packager** 库，我们可以使用它将我们的桌面应用程序打包成每个操作系统（Windows、Linux
    和 macOS）的单个可执行文件。让我们看看如何将其集成到我们的开发工作流程中：
- en: 'Run the following command to install `electron-packager` as a development dependency
    for our project:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令将 `electron-packager` 作为我们的项目的开发依赖项安装：
- en: '[PRE35]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Add a new entry in the `scripts` property of the `package.json` file to package
    our application:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `package.json` 文件的 `scripts` 属性中添加一个新的条目以打包我们的应用程序：
- en: '[PRE36]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the preceding script, `electron-packager` will read all files in the `dist/my-editor`
    folder, package them, and output the final bundle in the `dist` folder. The `--asar`
    option instructs the packager to archive all files in the **ASAR** format, similar
    to a ZIP or TAR file.
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的脚本中，`electron-packager` 将读取 `dist/my-editor` 文件夹中的所有文件，将它们打包，并将最终的包输出到 `dist`
    文件夹。`--asar` 选项指示打包器将所有文件存档为 **ASAR** 格式，类似于 ZIP 或 TAR 文件。
- en: 'Create a `package.json` file in the `src\electron` folder and add the following
    content:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src\electron` 文件夹中创建一个 `package.json` 文件，并添加以下内容：
- en: '[PRE37]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `electron-packager` library requires a `package.json` file to be present
    in the output folder, which points to the main entry file of the Electron application.
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`electron-packager` 库要求输出文件夹中存在一个 `package.json` 文件，该文件指向 Electron 应用程序的主入口文件。'
- en: 'Open the `webpack.prod.config.js` file and add the `CopyWebpackPlugin` in the
    `plugins` property:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `webpack.prod.config.js` 文件，并在 `plugins` 属性中添加 `CopyWebpackPlugin`：
- en: '[PRE38]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We use the `CopyWebpackPlugin` to copy the `package.json` file from the `src\electron`
    folder into the `dist\my-editor` folder while building the application in production
    mode.
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用 `CopyWebpackPlugin` 在生产模式下构建应用程序时将 `package.json` 文件从 `src\electron` 文件夹复制到
    `dist\my-editor` 文件夹。
- en: 'Run the following command to build the application in production mode:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以在生产模式下构建应用程序：
- en: '[PRE39]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now run the following `npm` command to package it:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行以下 `npm` 命令来打包它：
- en: '[PRE40]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The preceding command will package the application for the OS you currently
    run on, which is the default behavior of the `electron-packager` library. You
    can alter this behavior by passing additional options, which you will find in
    the GitHub repository of the library, listed in the *Further reading* section.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的命令将为当前运行的操作系统打包应用程序，这是 `electron-packager` 库的默认行为。您可以通过传递额外的选项来更改此行为，这些选项可以在库的
    GitHub 仓库中找到，列在 *进一步阅读* 部分。
- en: 'Navigate to the `dist` folder of the Angular CLI workspace. You will find a
    folder called `my-editor-{OS}`, where `{OS}` is your current OS and its architecture.
    For example, in Windows, it will be `my-editor-win32-x64`. Open the folder, and
    you will get the following files:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 Angular CLI 工作区的 `dist` 文件夹。您将找到一个名为 `my-editor-{OS}` 的文件夹，其中 `{OS}` 是您的当前操作系统及其架构。例如，在
    Windows 上，它将是 `my-editor-win32-x64`。打开文件夹，您将得到以下文件：
- en: '![Figure 5.6 – Application package (Windows)](img/B18465_05_07.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – 应用程序包（Windows）](img/B18465_05_07.png)'
- en: Figure 5.7 – Application package (Windows)
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 – 应用程序包（Windows）
- en: In the preceding screenshot, the `my-editor.exe` file is the executable file
    of our desktop application. Our application code is not included in this file
    but in the `app.asar` file, which exists in the `resources` folder.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，`my-editor.exe` 文件是我们桌面应用程序的可执行文件。我们的应用程序代码不包含在这个文件中，而是在 `resources`
    文件夹中的 `app.asar` 文件中。我们的应用程序代码不包含在这个文件中，而是在 `resources` 文件夹中的 `app.asar` 文件中。
- en: Run the executable file, and the desktop application should open normally. You
    can take the whole folder and upload it to a server, or distribute it by any other
    means. Your WYSIWYG editor can now reach many more users, such as those that are
    offline most of the time. Awesome!
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 运行可执行文件，桌面应用程序应该可以正常打开。您可以整个文件夹上传到服务器，或者通过其他任何方式分发。现在，您的 WYSIWYG 编辑器可以触及更多用户，例如那些大部分时间都在离线状态的用户。太棒了！
- en: Summary
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we built a WYSIWYG editor for the desktop using Angular and
    Electron. Initially, we created an Angular application and added `ngx-wig`, a
    popular Angular WYSIWYG library. Then, we learned how to build an Electron application
    and implemented a communication mechanism to exchange data between the Angular
    and Electron applications. Finally, we learned how to bundle our application for
    packaging and get it ready for distribution.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用 Angular 和 Electron 构建了一个桌面 WYSIWYG 编辑器。最初，我们创建了一个 Angular 应用程序，并添加了
    `ngx-wig`，一个流行的 Angular WYSIWYG 库。然后，我们学习了如何构建 Electron 应用程序，并实现了 Angular 和 Electron
    应用程序之间的数据交换通信机制。最后，我们学习了如何打包我们的应用程序以进行打包，并准备好分发。
- en: In the next chapter, we will learn how to build a mobile photo geotagging application
    with Angular and Ionic.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用 Angular 和 Ionic 构建一个移动照片地理标记应用程序。
- en: Practice questions
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践问题
- en: 'Let’s take a look at a few practice questions:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个实践问题：
- en: Which class is responsible for creating a desktop window in Electron?
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个类负责在 Electron 中创建桌面窗口？
- en: How do we communicate between the main and renderer processes in Electron?
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在 Electron 中的主进程和渲染进程之间进行通信？
- en: Which flags enable the use of Node.js in the renderer process?
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些标志可以启用在渲染进程中使用 Node.js？
- en: How do we load Electron in an Angular application?
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在 Angular 应用程序中加载 Electron？
- en: Which interface do we use to interact with Electron in an Angular application?
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在 Angular 应用程序中与 Electron 交互时使用哪个接口？
- en: How do we pass data to the main Electron process from an Angular application?
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何从 Angular 应用程序向主 Electron 进程传递数据？
- en: Which package do we use for filesystem manipulation in Electron?
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在 Electron 中使用哪个包进行文件系统操作？
- en: Which library do we use to package an Electron application?
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用哪个库来打包 Electron 应用程序？
- en: Further reading
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Here are some links to build upon what we learned in the chapter:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些链接，可以帮助我们巩固本章所学的内容：
- en: 'Electron: [https://www.electronjs.org](https://www.electronjs.org)'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Electron: [https://www.electronjs.org](https://www.electronjs.org)'
- en: 'Electron quick start: [https://www.electronjs.org/docs/tutorial/quick-start](https://www.electronjs.org/docs/tutorial/quick-start)'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Electron 快速入门：[https://www.electronjs.org/docs/tutorial/quick-start](https://www.electronjs.org/docs/tutorial/quick-start)
- en: '`ngx-wig`: [https://www.npmjs.com/package/ngx-wig](https://www.npmjs.com/package/ngx-wig)'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngx-wig`: [https://www.npmjs.com/package/ngx-wig](https://www.npmjs.com/package/ngx-wig)'
- en: 'Webpack configuration: [https://webpack.js.org/configuration](https://webpack.js.org/configuration)'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Webpack 配置：[https://webpack.js.org/configuration](https://webpack.js.org/configuration)
- en: '`ts-loader`: [https://webpack.js.org/guides/typescript](https://webpack.js.org/guides/typescript)'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ts-loader`: [https://webpack.js.org/guides/typescript](https://webpack.js.org/guides/typescript)'
- en: '`ngx-electronyzer`: [https://www.npmjs.com/package/ngx-electronyzer](https://www.npmjs.com/package/ngx-electronyzer)'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngx-electronyzer`: [https://www.npmjs.com/package/ngx-electronyzer](https://www.npmjs.com/package/ngx-electronyzer)'
- en: 'Filesystem API: [https://nodejs.org/api/fs.html](https://nodejs.org/api/fs.html)'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '文件系统 API: [https://nodejs.org/api/fs.html](https://nodejs.org/api/fs.html)'
- en: '`electron-packager`: [https://www.npmjs.com/package/electron-packager](https://www.npmjs.com/package/electron-packager)'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`electron-packager`: [https://www.npmjs.com/package/electron-packager](https://www.npmjs.com/package/electron-packager)'
- en: '`concurrently`: [https://www.npmjs.com/package/concurrently](https://www.npmjs.com/package/concurrently)'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`concurrently`: [https://www.npmjs.com/package/concurrently](https://www.npmjs.com/package/concurrently)'
