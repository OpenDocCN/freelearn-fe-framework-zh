- en: 9\. Working with Vuex – State, Getters, Actions, and Mutations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to use Vuex to build more complex Vue applications.
    You'll learn the specifics concerning how to add Vuex to a Vue application, how
    to define state with the Vuex store, and then use getters, actions, and mutations
    to read data from, and update it in, the store. By the end of the chapter, you
    will have seen multiple examples of how Vuex transforms your Vue applications,
    preparing them to grow much more complex in a much more manageable fashion.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, you learned how to use the Event Bus pattern to help
    solve an important problem: communicating events back and forth between complex
    and highly nested sets of components. The Event Bus pattern provided a simple
    **pub and sub** system by which any component could emit an event and any component
    could then listen to that event as well. While writing your own solution to this
    problem is a great way to keep your coding skills sharp, it would be better, in
    this case, to use an already developed, well-tested solution already in use in
    the Vue community—**Vuex** ([https://vuex.vuejs.org/](https://vuex.vuejs.org/)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1: The Vuex home page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_09_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.1: The Vuex home page'
  prefs: []
  type: TYPE_NORMAL
- en: Vuex is a core part of the Vue ecosystem and provides what we already built
    in the previous chapter along with much more. Let's take a high-level look at
    the main features of Vuex.
  prefs: []
  type: TYPE_NORMAL
- en: Store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At a high level, a Vuex instance, or one use of Vuex, is considered a **store**.
    The store is the top-level container employing everything described in the following
    subsections.
  prefs: []
  type: TYPE_NORMAL
- en: State
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most important aspect of Vuex is the **state**, or data, that it represents.
    This is the *single source of truth* that all components can rely on. As the state
    changes, every component making use of the state can be assured its copy will
    always be in sync. Imagine a Vue application that lets you edit blog entries.
    The store could consist of the blog entries themselves as well as values for the
    current blog entry you're editing. As blog entries are edited in one place, any
    other place using them gets updated immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Getters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While Vue can directly read state data from a Vuex instance, sometimes you may
    need to provide additional logic or an abstraction to the data itself. Much like
    how Vue provides a `computed` property for virtual or derived data, **getters**
    provide an abstraction to the state for cases where you need to manipulate the
    data before it is returned. Returning to our previous example of working with
    blog entries, imagine a getter that returns the top blog entries by views. The
    getter abstracts away the logic of how "popular" blog entries are and lets you
    easily change that logic in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Mutations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Components making use of state data in Vuex never directly modify that data.
    Instead, a component can execute a **mutation**. Think of it as an order from
    the component for Vuex to perform a change to its state. By using mutations to
    wrap changes to state, Vuex can ensure every component making use of that state
    is kept up to date on changes.
  prefs: []
  type: TYPE_NORMAL
- en: Actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Actions** are like mutations, except that they must be used to handle asynchronous
    changes. Asynchronous actions are any logic that takes an indeterminate amount
    of time to finish. The most common example would be a network call to a remote
    API. Synchronous calls are those that execute and finish immediately. It will
    make more sense when you see them being used, but generally, anything asynchronous
    should be done via actions while synchronous logic can be done via mutations.
    Actions will typically chain to mutations once they have completed whatever asynchronous
    work they need to do.'
  prefs: []
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last aspect of Vuex this chapter will cover is modules. **Modules** are
    simply a way to package more complex sets of data for larger applications. While
    one simple state may be fine for a typical application, a much larger application
    can have a much more complex state that needs better organization via modules.
    In *Chapter 11*, *Working with Vuex – Organizing Larger Stores*, you will see
    how modules can be used to better organize the Vuex instance.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Vuex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two main methods of using Vuex, depending on the type of Vue application
    you''re building. If you are not using the CLI to scaffold out an application
    and simply added Vue via a script tag, you can include Vuex the same way. Assuming
    you''ve downloaded both Vue and Vuex to a folder named `js`, you would load them
    both like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also load both Vue and Vuex via **Content Delivery Networks** (**CDNs**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is important that Vuex is loaded after Vue. Doing so makes Vuex available
    to your Vue code without any other configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you created an application using the CLI, remember first that the CLI itself
    will prompt you during creation if you want to add Vuex:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2: Selecting Vuex during application scaffolding'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_09_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.2: Selecting Vuex during application scaffolding'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you didn''t do this though, you can still add Vuex later using the CLI:
    `vue add vuex`. When Vuex is added (or selected during scaffolding), your Vue
    application is modified in the ways we''ll discuss now.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, a new folder, `store`, is added, containing one file, `index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is an empty store with spots prepared for your state, mutations, actions,
    and modules. Note that there isn't a place for getters defined here, but you can
    absolutely add them. This is just the default layout for a new store, and you
    can modify it as you see fit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, `main.js` is modified to load and install this store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Again, this is how the CLI scaffolds using Vuex, and if you prefer to use another
    method (perhaps a different folder name than `store`), you are free to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Working with State
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the lowest level in a Vuex store, you will find the actual data (the state)
    that Vuex manages. All components have access to the state via a special `$store`
    variable. While there''s more within this variable, to read the state, you can
    use `$store.state.someStateValue`. So, for example: `Hello, my name is {{ $store.state.name
    }}` would output the name value from your Vuex store in a component. For simple
    operations reading from the store, that''s all you need.'
  prefs: []
  type: TYPE_NORMAL
- en: We will now learn how to display state values in the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.01: Displaying State Values'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you will create an empty Vue application using Vuex. The previous
    section described how that was done via the CLI, and if you followed along, you've
    got one ready to go. If not, go ahead and create one now, ensuring you enable
    Vuex. In this exercise, we'll simply set a few values in the state and display
    them in a component.
  prefs: []
  type: TYPE_NORMAL
- en: To access the code files for this exercise, refer to [https://packt.live/32s4RkN](https://packt.live/32s4RkN).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve scaffolded the application, open `store/index.js` and modify the
    `state` block to add three new values. The data here is arbitrary and can be anything
    that JavaScript can handle (strings, numbers, arrays, and so on):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we need to modify the component to display the values from the state. Open
    up `App.vue` and modify it like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, edit the `HelloWorld.vue` component to also display a value from the state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To see your application, type `npm run serve` in your terminal. When the CLI
    is done, you can then open the URL displayed in your browser to see your application,
    which should appear as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, both the main component and the child component have access
    to the state and see the same values. This shouldn't be a surprise, but it's always
    nice to confirm that things are working as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'While directly accessing state values makes things easy, let''s look at a more
    complex usage: derived values with getters.'
  prefs: []
  type: TYPE_NORMAL
- en: Applying Getters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous exercise, you saw how simple it was to directly access state,
    but there are times when you may need more complex views of your state. To make
    this easier, Vuex supports a feature called **getters**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Getters have their own block within the store, and you can define as many as
    necessary. Each getter is passed the state as an argument, which lets you use
    whatever you need to create your value. Finally, the name of the getter is how
    it will be exposed. Consider this simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This store defines three state values (`name`, `gender`, and `job`), and also
    provides a "virtual" property named `bio` that returns a description of the data.
    Note that the getter only uses two of the state values, and that's totally fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'To reference the getter in your component, you use `$store.getters.name`, where
    `name` is the name of the getter. So, to access the bio getter defined in the
    preceding code, you would use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Along with being passed the state, getters are passed *other* getters as their
    second argument, which allows one getter to call another getter, if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, we will see an example of putting this to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.02: Adding Getters to a Vuex Store'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you will build an example that makes use of the Getters feature.
    You will add Getters to a Vuex store and add a call to it from the main Vue application.
  prefs: []
  type: TYPE_NORMAL
- en: To access the code files for this exercise, refer to [https://packt.live/36ixlyf](https://packt.live/36ixlyf).
  prefs: []
  type: TYPE_NORMAL
- en: Scaffold a new application, remembering to use Vuex in the settings (and if
    you forget, just use `vue add vuex`). Type `npm run serve` to start the application
    and open the URL in your browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open your store file (`store/index.js`) and then modify it to define two state
    values and a getter that will return both:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now open `App.vue` and modify it such that you make use of the `name` getter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you can see in the following screenshot, this will show the complete name
    based on the logic used in the getter:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: While rather simple, hopefully, you can see the power of what Getters achieves
    here. Right now, we have a concept of a name that consists of a first and last
    name. That isn't terribly complex logic, but by placing it within the Vuex store,
    we defined it as one place that's available to all components within our application.
    If this name definition changed (perhaps with the last name listed first, separated
    by a comma), you could modify it once and be done.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, we'll consider how to enhance Getters with additional logic.
  prefs: []
  type: TYPE_NORMAL
- en: Getters with Parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While Getters can be accessed directly via `$store.getters` properties, you
    may run into situations where you need a bit more control over how the getter
    works. Parameters provide a way to customize how Getters works. Consider the following store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: There's only one state value in this store, and it's an array of books. Each
    book has a type (nonfiction or fiction), title, and page count. To make it easy
    to get one book versus another, two getters are used. They filter by either fiction
    or nonfiction books.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how you could use this in a component. First, we iterate over the `fiction`
    getter and then the `nonfiction` one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding template, two unordered lists are used to iterate over each
    type of book. The result can be seen as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3: Rendering fiction and non-fiction books via getters'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_09_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.3: Rendering fiction and non-fiction books via getters'
  prefs: []
  type: TYPE_NORMAL
- en: Okay, so far so good. But what if you want to get books based on their page
    count? That isn't a simple boolean or string property, but rather a number. But,
    because getters can accept parameters, we can create a new getter that lets us
    ask for a maximum number of pages. (We could support more than one parameter,
    so, if you wanted a getter that asked for books within a range of values, you
    could support both a min and max number of pages.) In order to create a getter
    that accepts a parameter, your code itself must return a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example where we define a getter that returns a portion of the full
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting getter can then be used with the `length` parameter: `{{ $store.getters.shortName(10)
    }}`.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, you'll build an application that makes use of the Getter
    with the parameters feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.03: Employing a Getter with Parameters'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will test out this feature in the following exercise. By adding parameters
    to a getter, you'll be able to build more flexible getters that are more useful
    across different components. In this exercise, you will create a getter that takes
    one parameter.
  prefs: []
  type: TYPE_NORMAL
- en: To access the code files for this exercise, refer to [https://packt.live/2Ioi2vy](https://packt.live/2Ioi2vy).
  prefs: []
  type: TYPE_NORMAL
- en: 'Scaffold yet another application using Vuex and, once open, edit the store
    to include a set of books and getters for fiction, non-fiction, and page size.
    This is found in the store directory in `index.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now edit `App.vue` to use all three getters – first the fiction and nonfiction
    getters, and then books that have `150` or fewer pages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once done, you can see the result by starting your Vue application (type `npm
    run serve` in your terminal) and opening the URL in your browser. Here is what
    you should see:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.4: The parameterized getter in action'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_09_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.4: The parameterized getter in action'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we learned how to use more powerful getters that use parameters.
    This makes them flexible and more adaptable to what your components may need.
    Now that you've seen multiple ways of reading data from a Vuex store, it's time
    to look at how to modify state.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying State with Mutations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, you've seen how to read data from a Vuex store, both with direct access
    to state and by using getters. But to actually change the state of a store, Vuex
    supports the idea of mutations. Mutations are methods you define in your store
    that handle changing state. So, for example, instead of your component simply
    setting a new value in the state, your component will ask the store to perform
    a mutation, and the store handles that logic itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, the store has two values in its state, `totalCats`
    and `name`. Two mutations exist to allow you to change these values. All mutations
    are passed a state object that gives you direct access to read and change values.
    The first mutation, `newCat`, simply increments the `totalCats` value. The second
    mutation, `setName`, shows an example of a mutation that takes an argument. In
    this case, you could use `setName` to change the name value in the store.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to execute a mutation, your components will use the `commit` method.
    See the following, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You can also pass multiple values if you pass them as an object instead of a
    simple value. In the next exercise, you'll get a chance to practice building your
    own mutations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.04: Working with Mutations'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you will build an application that uses mutations to modify
    state data in Vuex. Scaffold a new application and, once ready, open up the store
    file located in `store/index.js`. Your store is going to be somewhat based on
    the preceding examples.
  prefs: []
  type: TYPE_NORMAL
- en: To access the code files for this exercise, refer to [https://packt.live/3kcARiN](https://packt.live/3kcARiN).
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a `totalCats` state variable and name state value, then three mutations
    to work with them – one mutation to increase the number of cats, one to reduce
    it, and one final one to set the name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, you will build a simple interface to work with this store. The template
    needs to have a UI to report on the name and the number of cats. You also need
    a text field and button to handle updating the name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open `App.vue` and update it to include outputting the current values from
    the store as well as providing a simple form to allow updates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build the `Cat` component. This component will have simple buttons to execute
    the mutations we defined to both increase and decrease the number of cats:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once done, start up your application as you have before with `npm run serve`
    and open the displayed URL in your browser. Your application should look like so:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.5: Vue application with mutation support'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_09_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.5: Vue application with mutation support'
  prefs: []
  type: TYPE_NORMAL
- en: While this was a trivial exercise, there are a few important things to note.
    First, notice how both the root and child components have no problems interacting
    with the store. Your component hierarchy can be incredibly deep, and it simply
    just works. Secondly, notice how the Vue application is simpler because the logic
    of working with the data is in the store. The two components we worked with simply
    display data and handle passing off mutation calls to the store. If our logic
    ever needs to update, we can handle it in the store, and everything will be updated
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: So far, you've seen how to implement changes to your store in an immediate,
    synchronous way. You'll now learn how to handle asynchronous updates.
  prefs: []
  type: TYPE_NORMAL
- en: Using Actions for Asynchronous State Changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Actions in Vuex are the primary way of handling asynchronous logic for your
    store. Mutations have to be synchronous, but actions can be asynchronous if they
    choose. The other difference is that actions get a `context` object that represents
    the store itself. This lets actions call mutations or work with the state directly.
    In general, most developers will call mutations from their actions.
  prefs: []
  type: TYPE_NORMAL
- en: This probably seems a bit confusing, but in general, think of actions as your
    asynchronous support for your store. It will make sense once we see an example
    or two.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a sample action. The following snippet contains one mutation
    and an asynchronous action that will make use of the mutation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Looking at `loadBooks`, you can see it makes a network request, and when done,
    it makes a call to the preceding mutation and lets it store the result data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling an action is slightly different than mutations; instead of a `commit`
    call, you use `dispatch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Like mutations, actions can take arguments that get passed to the action method
    as the second argument. Next, you'll build an example of this in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.05: Using Actions for Asynchronous Logic'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you will build an example of an action requiring asynchronous
    logic in order to complete. This closely resembles many real-world scenarios where
    the data required for the application is found on a remote API. You'll implement
    the network call and work with the results in your Vuex store.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, you will set up a JSON resource available in your `public`
    folder under a subdirectory named `data`. When Vue builds your code, it will copy
    anything in the `public` folder to the application, making it available at runtime.
    The JSON file contains an array of four books. Each book has a type, title, and
    number of pages.
  prefs: []
  type: TYPE_NORMAL
- en: To access the code files for this exercise, refer to [https://packt.live/3eE6KQd](https://packt.live/3eE6KQd).
  prefs: []
  type: TYPE_NORMAL
- en: 'While not necessary, this is how the JSON data looks. Feel free to build your
    own:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In a new store (located in the usual place at `store/index.js`), set up an
    empty array for books, and then define an action that will use the Fetch API to
    retrieve the JSON content. (You''ll see more examples of using APIs in *Chapter
    10*, *Working with Vuex - Fetching Remote Data*, as well as a more powerful way
    of doing HTTP, in the form of the `Axios` library.) When the data is retrieved,
    it should then call a mutation to store the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In order to call this action, add a `dispatch` call in your component to run
    the actions and then add code to display the books:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In *Figure 9.6*, you can see the result of the asynchronous action requesting
    its data:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.6: An example of data loaded asynchronously'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B15218_09_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.6: An example of data loaded asynchronously'
  prefs: []
  type: TYPE_NORMAL
- en: Now you've seen an example of working with asynchronous operations in your Vuex
    store. Note that you can use actions even if your code is synchronous. This may
    be a good idea in general if you aren't sure whether your data is going to be
    asynchronous in the future. Now let's look at a nice way to simplify some boilerplate
    Vuex syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying with mapState and mapGetters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As one of the last features we'll cover with Vuex, let's look at `mapState`
    and `mapGetters`. These are handy utilities that help map state values and getters
    into your component's computed property. As a practical matter, it makes your
    HTML templates simpler. So instead of `{{ $store.state.firstName }}`, you can
    simply use `{{ firstName }}`. Instead of using `{{ $store.getters.name }}`, you
    can just use `{{ name }}`.
  prefs: []
  type: TYPE_NORMAL
- en: Both `mapState` and `mapGetters` can either take an array of values to map or
    an object where each key represents the name you wish to use in your component
    and the value is the `state value` or `getter` in the Vuex store. They are both
    used with your Vue application's `computed` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this first example, two state values and three getters are mapped by their
    name alone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'But if those names were perhaps too generic, or perhaps conflicted with existing
    data, you could specify other names for them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to use both `mapState` and `mapGetters`, you will need to import them first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Usage of both these features will definitely help reduce the amount of code
    you write to work with Vuex.
  prefs: []
  type: TYPE_NORMAL
- en: You will learn how to add `mapState` and `mapGetters` with the help of the following
    exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.06: Adding mapState and mapGetters'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's look at a simple example of this. In *Exercise 9.02*, we used getters
    to create a shortcut for getting a name value. We can simplify that code by applying
    what we just learned. We can use the map functions to simplify our code.
  prefs: []
  type: TYPE_NORMAL
- en: To access the code files for this exercise, refer to [https://packt.live/3ldBxpb](https://packt.live/3ldBxpb).
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Vue application with Vuex and then copy over the store (located
    at `store/index.js`) into this new version. You will need state values for the
    first and last name, and a getter that returns the complete name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit the main component. You will want to edit all three values from the store
    (both the state values and the getter), but make use of `mapState` and `mapGetters`
    to simplify it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you can see, by using `mapState` and `mapGetters`, we''ve provided a way
    for the template portion of the app to make use of the data somewhat simpler:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When done, you should see exactly the same output as you've seen before. The
    important part is that the amount of code you needed to write was reduced!
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll briefly talk about `mapMutations` and `mapActions`.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying with mapMutations and mapActions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final features we''ll cover are very similar to the previous one: `mapMutations`
    and `mapActions`. As you can probably guess, these two features work very similarly
    to `mapState` and `mapGetters`, in that they provide a shorthand way to connect
    your code to Vuex mutations and actions without writing boilerplate code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'They follow the exact same format in that you can specify a list of items to
    map or specify a list while also providing a different name, as in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'These can be used in your Vue component''s `methods` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This then allows your Vue code to call either `setBooks` or `loadBooks` without
    specifying the `store` object, or `dispatch` and `commit`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's try to create a simple shopping cart and a price calculator on our
    own.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 9.01: Creating a Simple Shopping Cart and Price Calculator'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine a hypothetical corporate hardware site that lets employees select products
    they need shipping to their office. This cart is much simpler than a typical e-commerce
    site as it doesn't need to process credit cards or even ask the person where they
    are (IT knows where you sit!). It still needs to present you with a list of items,
    let you select how much you want, and then provide you with a total price that
    will be billed to your department.
  prefs: []
  type: TYPE_NORMAL
- en: In this activity, you need to build a Vuex store that represents the available
    products and their prices. You will need multiple components to handle the different
    aspects of the application and properly interact with the store data.
  prefs: []
  type: TYPE_NORMAL
- en: '**Steps:**'
  prefs: []
  type: TYPE_NORMAL
- en: Build a store and define an array of products and a cart in the state. Every
    product will have `name` and `price` properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a component that lists out each product and price.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the component to have buttons to add, or remove, one of the products
    from your cart.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a second component that shows the current cart (every product and quantity).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a third component that displays the total cart price and has a button to
    complete the checkout. The total price is the sum of each product in the cart
    multiplied by the quantity of the product. For this activity, the `checkout` button
    should simply alert the user that the checkout process is done but take no other steps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should get the following output initially, showing an empty cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7: Initial display of the cart'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_09_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.7: Initial display of the cart'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you add and remove items, you''ll see the cart and totals update in real
    time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8: The cart with items of multiple quantities added'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15218_09_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.8: The cart with items of multiple quantities added'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, as products are added, the cart display updates to show quantity
    values and the total in the `Checkout` section accurately reflects the total price.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found via [this link](B15218_Solution_Final_SZ_ePub.xhtml#_idTextAnchor399).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have seen most of Vuex's features and should now have an
    idea of how to both read from and write to the store. You employed mutations for
    synchronous changes and actions for asynchronous modifications. You created getters
    to provide access to virtual values based on your state. You have also seen how
    components look when working with the store. They've got less logic and simply
    hand off that part to the store. In larger Vue applications, this will become
    even more important. Your components will handle the UI and UX, but let the store
    handle the data layer. Having the store as a single source of truth, then, relieves
    you of so much "grunt" work that you will come to greatly appreciate Vuex, even
    in smaller applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about using remote data with Vuex stores.
    Working with remote APIs is a common need in modern web applications. Integrating
    these APIs in Vuex will make it easier for the rest of your Vue application to
    use the data provided by remote services.
  prefs: []
  type: TYPE_NORMAL
