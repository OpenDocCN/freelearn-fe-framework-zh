<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer015">
<h1 class="chapter-number" id="_idParaDest-50"><a id="_idTextAnchor049"/>3</h1>
<h1 id="_idParaDest-51"><a id="_idTextAnchor050"/>Building and Documenting Components</h1>
<p>In React, everything is a component. This paradigm allows us to split user interfaces into smaller parts, thus making it easier to develop applications. It also enables component reusability since we can reuse the same components in <span class="No-Break">multiple places.</span></p>
<p>In this chapter, we will build some components that we will use as the application’s user interface base. This will make the application UI more consistent and easier to understand and maintain. We will also learn how to document the components with Storybook, a great tool that can serve as a catalog of common <span class="No-Break">application components.</span></p>
<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
<ul>
<li><span class="No-Break">Chakra UI</span></li>
<li><span class="No-Break">Building components</span></li>
<li><span class="No-Break">Storybook</span></li>
<li><span class="No-Break">Documenting components</span></li>
</ul>
<p>By the end of this chapter, we will learn how to create and document reusable components that we can use for <span class="No-Break">the application.</span></p>
<h1 id="_idParaDest-52"><a id="_idTextAnchor051"/>Technical requirements</h1>
<p>Before we get started, we need to set up the project. To be able to develop the project, you will need the following things installed on <span class="No-Break">your computer:</span></p>
<ul>
<li><strong class="bold">Node.js</strong> version 16 or above and <strong class="bold">npm</strong> version 8 <span class="No-Break">or above.</span></li>
</ul>
<p>There are multiple ways to install Node.js and npm. Here is a great article that goes into <span class="No-Break">more detail:</span></p>
<p><a href="https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js"><span class="No-Break">https://www.nodejsdesignpatterns.com/blog/5-ways-to-install-node-js</span></a></p>
<ul>
<li><strong class="bold">VSCode</strong> (optional) is currently the most popular editor/IDE for JavaScript/TypeScript, so we will be using it. It is open source, has great integration with TypeScript, and you can extend its features via extensions. It can be downloaded from <span class="No-Break">here: </span><a href="https://code.visualstudio.com/"><span class="No-Break">https://code.visualstudio.com/</span></a><span class="No-Break">.</span></li>
</ul>
<p>The code files for this chapter can be found <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/React-Application-Architecture-for-Production"><span class="No-Break">https://github.com/PacktPublishing/React-Application-Architecture-for-Production</span></a><span class="No-Break">.</span></p>
<p>The repository can be cloned locally with the <span class="No-Break">following command:</span></p>
<pre class="console">
git clone https://github.com/PacktPublishing/React-Application-Architecture-for-Production.git</pre>
<p>Once the repository is cloned, we need to install the <span class="No-Break">application’s dependencies:</span></p>
<pre class="console">
npm install</pre>
<p>We also need to provide the <span class="No-Break">environment variables:</span></p>
<pre class="console">
cp .env.example .env</pre>
<p>Once the dependencies have been installed, we need to select the right stage of the code base that matches this chapter. We can do that by executing the <span class="No-Break">following command:</span></p>
<pre class="console">
npm run stage:switch</pre>
<p>This command will prompt us with a list of stages for <span class="No-Break">each chapter:</span></p>
<pre class="console">
? What stage do you want to switch to? (Use arrow
 keys)
❯ chapter-02
  chapter-03
  chapter-03-start
  chapter-04
  chapter-04-start
  chapter-05
  chapter-05-start
(Move up and down to reveal more choices)</pre>
<p>This is the third chapter, so you can select <strong class="source-inline">chapter-03-start</strong> if you want to follow along or <strong class="source-inline">chapter-03</strong> to see the final results of <span class="No-Break">the chapter.</span></p>
<p>Once the chapter has been selected, all files required to follow along with the chapter <span class="No-Break">will appear.</span></p>
<p>To follow along with this chapter, you don’t need to make any changes to the code. You can use it as a reference to help get a better overview of the <span class="No-Break">code base.</span></p>
<p>For more information about the setup details, check out the <span class="No-Break"><strong class="source-inline">README.md</strong></span><span class="No-Break"> file.</span></p>
<h1 id="_idParaDest-53"><a id="_idTextAnchor052"/>Chakra UI</h1>
<p>Whenever we build a UI for an application, we must decide what to use for styling our components. In addition, we must also consider whether we want to make all components from scratch or use a component library with <span class="No-Break">pre-made components.</span></p>
<p>The advantage of using a component library is that it gives us a productivity boost as we don’t have to implement components that have already been implemented, such as buttons, dialogs, and tabs. Also, some libraries come with great accessibility defaults out of the box, so we don’t have to think about it as much as we would if we built everything from scratch. These libraries can come with costs, such as difficult customizability or a significant impact on the final bundle size. On the other hand, they save us a lot of <span class="No-Break">development time.</span></p>
<p>For our application, we will<a id="_idIndexMarker131"/> use <strong class="bold">Chakra UI</strong>, a component library built on top of a combination of <strong class="bold">emotion</strong> and <strong class="bold">styled-system</strong>, which will allow us to write CSS in JavaScript in a <span class="No-Break">consistent way.</span></p>
<h2 id="_idParaDest-54"><a id="_idTextAnchor053"/>Chakra UI setup</h2>
<p>We already have the Chakra UI <a id="_idIndexMarker132"/>library installed, and now we need to <span class="No-Break">configure it.</span></p>
<p>To use <a id="_idIndexMarker133"/>Chakra UI, first, we need to configure its theme provider to enable styles for its components. Since all our providers and wrappers are defined in <strong class="source-inline">src/providers/app.tsx</strong>, we can add <span class="No-Break"><strong class="source-inline">ChakraProvider</strong></span><span class="No-Break"> there:</span></p>
<pre class="source-code">
<strong class="bold">import {</strong>
<strong class="bold">  ChakraProvider,</strong>
<strong class="bold">  GlobalStyle,</strong>
<strong class="bold">} from '@chakra-ui/react';</strong>
import { ReactNode } from 'react';
<strong class="bold">import { theme } from '@/config/theme';</strong>
type AppProviderProps = {
  children: ReactNode;
};
export const AppProvider = ({
  children,
}: AppProviderProps) =&gt; {
  return (
    <strong class="bold">&lt;ChakraProvider theme={theme}&gt;</strong>
      <strong class="bold">&lt;GlobalStyle /&gt;</strong>
      {children}
    <strong class="bold">&lt;/ChakraProvider&gt;</strong>
  );
};</pre>
<p>Here, we are wrapping the entire application with the provider to apply theming and styles to all Chakra UI components. We are also rendering the <strong class="source-inline">GlobalStyles</strong> component, which will take any global styles from our theme and apply it to <span class="No-Break">the application.</span></p>
<p>Chakra UI settings <a id="_idIndexMarker134"/>and components are very customizable and can be configured in a custom theme, which we can pass to the provider. It will override the default theme configuration. Let’s configure the theme in <strong class="source-inline">src/config/theme.ts</strong> by adding <span class="No-Break">the following:</span></p>
<pre class="source-code">
import { extendTheme } from '@chakra-ui/react';
const colors = {
  primary: '#1a365d',
  primaryAccent: '#ffffff',
};
const styles = {
  global: {
    'html, body': {
      height: '100%',
      bg: 'gray.50',
    },
    '#__next': {
      height: '100%',
      bg: 'gray.50',
    },
  },
};
export const theme = extendTheme({ colors, styles });</pre>
<p>We are defining some global styles that will be injected via the <strong class="source-inline">GlobalStyles</strong> component, which we have already added in <strong class="source-inline">AppProvider</strong>. We also define the theme colors we want to have available in the components. Then, we combine these configurations with the default theme values by using the <strong class="source-inline">extendTheme</strong> utility, which will merge all configurations and <a id="_idIndexMarker135"/>give us the complete <span class="No-Break">theme object.</span></p>
<p>It is useful to centralize theme configuration since it is easy to use and change if the branding of the application changes. For example, we can easily change the primary color value in one place and apply it to the entire application without any <span class="No-Break">additional changes.</span></p>
<h1 id="_idParaDest-55"><a id="_idTextAnchor054"/>Building components</h1>
<p>Now that the <a id="_idIndexMarker136"/>Chakra UI setup is in place, we can build the components. In the starting files for this chapter, we already have some default components exported. For now, we can render them on the landing page defined in <strong class="source-inline">src/pages/index.tsx</strong> <span class="No-Break">as follows:</span></p>
<pre class="source-code">
import { Button } from '@/components/button';
import { InputField } from '@/components/form';
import { Link } from '@/components/link';
const LandingPage = () =&gt; {
  return (
    &lt;&gt;
      &lt;Button /&gt;
      &lt;br /&gt;
      &lt;InputField /&gt;
      &lt;br /&gt;
      &lt;Link /&gt;
    &lt;/&gt;
  );
};
export default LandingPage;</pre>
<p>To start the application development server, we need to run <span class="No-Break">the following:</span></p>
<pre class="console">
npm run dev</pre>
<p>This will make the newly created page available at <strong class="source-inline">http://localhost:3000</strong>. The development server will listen to any changes we make and auto-refresh the page with the <span class="No-Break">latest changes.</span></p>
<p>The landing page will display the <a id="_idIndexMarker137"/>components. If we open <strong class="source-inline">http://localhost:3000</strong>, we should see <span class="No-Break">the following:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer012">
<img alt="Figure 3.1 – Preview of the initial components on the landing page " height="686" src="image/B17297_03_01.jpg" width="1211"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Preview of the initial components on the landing page</p>
<p>The components aren’t doing much right now, so we need to work on <span class="No-Break">their implementation.</span></p>
<h2 id="_idParaDest-56"><a id="_idTextAnchor055"/>Button</h2>
<p>Let’s start by implementing<a id="_idIndexMarker138"/> the <strong class="source-inline">Button</strong> component, one of the <a id="_idIndexMarker139"/>most common components in every application. The component is already created in <strong class="source-inline">src/components/button/button.tsx</strong>, but we need to <span class="No-Break">modify it.</span></p>
<p>Let’s start by importing <span class="No-Break">its dependencies:</span></p>
<pre class="source-code">
import { Button as ChakraButton } from '@chakra-ui/react';
import { MouseEventHandler, ReactNode } from 'react';</pre>
<p>Now, we can create the <strong class="source-inline">variants</strong> object, which will hold all styling properties of our button and they will be applied accordingly to the default Chakra UI <span class="No-Break"><strong class="source-inline">Button</strong></span><span class="No-Break"> component:</span></p>
<pre class="source-code">
const variants = {
  solid: {
    variant: 'solid',
    bg: 'primary',
    color: 'primaryAccent',
    _hover: {
      opacity: '0.9',
    },
  },
  outline: {
    variant: 'outline',
    bg: 'white',
    color: 'primary',
  },
};</pre>
<p>Then, we can type the props for the <span class="No-Break"><strong class="source-inline">Button</strong></span><span class="No-Break"> component:</span></p>
<pre class="source-code">
export type ButtonProps = {
  children: ReactNode;
  type?: 'button' | 'submit' | 'reset';
  variant?: keyof typeof variants;
  isLoading?: boolean;
  isDisabled?: boolean;
  onClick?: MouseEventHandler&lt;HTMLButtonElement&gt;;
  icon?: JSX.Element;
};</pre>
<p>Typing the component’s props is a great way to describe its API, which is very useful as it documents how it should <span class="No-Break">be used.</span></p>
<p>And now, we can <a id="_idIndexMarker140"/>create the <strong class="source-inline">Button</strong> component, which is just a<a id="_idIndexMarker141"/> wrapper around the default <strong class="source-inline">Button</strong> component provided by <span class="No-Break">Chakra UI:</span></p>
<pre class="source-code">
export const Button = ({
  variant = 'solid',
  type = 'button',
  children,
  icon,
  ...props
}: ButtonProps) =&gt; {
  return (
    &lt;ChakraButton
      {...props}
      {...variants[variant]}
      type={type}
      leftIcon={icon}
    &gt;
      {children}
    &lt;/ChakraButton&gt;
  );
};</pre>
<p>Then, we can<a id="_idIndexMarker142"/> update<a id="_idIndexMarker143"/> the <strong class="source-inline">Button</strong> component usage in <strong class="source-inline">src/pages/index.tsx</strong> <span class="No-Break">as follows:</span></p>
<pre class="source-code">
&lt;Button variant="solid" type="button"&gt;
  Click Me
&lt;/Button&gt;</pre>
<h2 id="_idParaDest-57"><a id="_idTextAnchor056"/>InputField</h2>
<p>The <a id="_idIndexMarker144"/>input field <a id="_idIndexMarker145"/>component is an input component that we want to use when building our forms. Let’s <span class="No-Break">change </span><span class="No-Break"><strong class="source-inline">src/components/form/input-field.tsx</strong></span><span class="No-Break">.</span></p>
<p>First, we need to import <span class="No-Break">all dependencies:</span></p>
<pre class="source-code">
import {
  FormControl,
  FormHelperText,
  FormLabel,
  forwardRef,
  Input,
  Textarea,
} from '@chakra-ui/react';
import {
  FieldError,
  UseFormRegister,
} from 'react-hook-form';</pre>
<p>Then, we define types for the <span class="No-Break">component’s props:</span></p>
<pre class="source-code">
export type InputFieldProps = {
  type?: 'text' | 'email' | 'password' | 'textarea';
  label?: string;
  error?: FieldError;
} &amp; Partial&lt;
  ReturnType&lt;UseFormRegister&lt;Record&lt;string, unknown&gt;&gt;&gt;
&gt;;</pre>
<p>Finally, we<a id="_idIndexMarker146"/> implement<a id="_idIndexMarker147"/> the <span class="No-Break">component itself:</span></p>
<pre class="source-code">
export const InputField = forwardRef(
  (props: InputFieldProps, ref) =&gt; {
    const {
      type = 'text',
      label,
      error,
      ...inputProps
    } = props;
    return (
      &lt;FormControl&gt;
        {label &amp;&amp; &lt;FormLabel&gt;{label}&lt;/FormLabel&gt;}
        {type === 'textarea' ? (
          &lt;Textarea
            bg="white"
            rows={8}
            {...inputProps}
            ref={ref}
          /&gt;
        ) : (
          &lt;Input
            bg="white"
            type={type}
            {...inputProps}
            ref={ref}
          /&gt;
        )}
        {error &amp;&amp; (
          &lt;FormHelperText color="red"&gt;
            {error.message}
          &lt;/FormHelperText&gt;
        )}
      &lt;/FormControl&gt;
    );
  }
);</pre>
<p>As you can see, we<a id="_idIndexMarker148"/> are building an input field component that we can use with the <strong class="source-inline">react-hook-form</strong> library to create forms, and we will learn how to do that in the upcoming <a id="_idIndexMarker149"/>chapters. Notice how we are wrapping the component with <strong class="source-inline">forwardRef</strong>. This will allow us to pass references to the component <span class="No-Break">if necessary.</span></p>
<p>Let’s update its usage <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">src/pages/index.tsx</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
&lt;InputField label="Name" /&gt;</pre>
<h2 id="_idParaDest-58"><a id="_idTextAnchor057"/>Link</h2>
<p>For the<a id="_idIndexMarker150"/> links, we will use<a id="_idIndexMarker151"/> the <strong class="source-inline">Link</strong> component provided by Next.js. However, we want to centralize the configuration and styling and use it everywhere. Let’s <span class="No-Break">modify </span><span class="No-Break"><strong class="source-inline">src/components/link/link.tsx</strong></span><span class="No-Break">:</span></p>
<p>First, let’s import <span class="No-Break">all dependencies:</span></p>
<pre class="source-code">
import { Button } from '@chakra-ui/react';
import NextLink from 'next/link';
import { ReactNode } from 'react';</pre>
<p>Similar to what we did with the <strong class="source-inline">Button</strong> component, we want to allow the link to accept some variants, which will apply additional styling props to <span class="No-Break">the component:</span></p>
<pre class="source-code">
const variants = {
  link: {
    variant: 'link',
    color: 'primary',
  },
  solid: {
    variant: 'solid',
    bg: 'primary',
    color: 'primaryAccent',
    _hover: {
      opacity: '0.9',
    },
  },
  outline: {
    variant: 'outline',
    color: 'primary',
    bg: 'white',
  },
};</pre>
<p>Then, we define the type of the <span class="No-Break">component’s props:</span></p>
<pre class="source-code">
export type LinkProps = {
  href: string;
  children: ReactNode;
  variant?: keyof typeof variants;
  icon?: JSX.Element;
  shallow?: boolean;
};</pre>
<p>And here is<a id="_idIndexMarker152"/> the implementation of the <strong class="source-inline">Link</strong> component. Notice how we are<a id="_idIndexMarker153"/> using the <strong class="source-inline">Link</strong> component from Next.js, which we use to wrap the <strong class="source-inline">Button</strong> component from <span class="No-Break">Chakra UI:</span></p>
<pre class="source-code">
export const Link = ({
  href,
  children,
  variant = 'link',
  icon,
  shallow = false,
}: LinkProps) =&gt; {
  return (
    &lt;NextLink shallow={shallow} href={href} passHref&gt;
      &lt;Button
        leftIcon={icon}
        as="a"
        {...variants[variant]}
      &gt;
        {children}
      &lt;/Button&gt;
    &lt;/NextLink&gt;
  );
};</pre>
<p>Why are we using the <strong class="source-inline">Button</strong> component instead of <strong class="source-inline">Link</strong> from Chakra UI? We could have used <strong class="source-inline">Link</strong>, but we want most of our links to look and feel like buttons, so the reason is just the style <a id="_idIndexMarker154"/>preference. Notice how we are passing <strong class="source-inline">as="a"</strong> to <strong class="source-inline">Button</strong>. This <a id="_idIndexMarker155"/>will make the element an anchor, which is correct from the accessibility standpoint, and the component will be rendered as a link element in <span class="No-Break">the DOM.</span></p>
<p>Let’s update its usage <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">src/pages/index.tsx</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
&lt;Link href="/"&gt;Home&lt;/Link&gt;</pre>
<p>Note that we can’t predict and build all shared components upfront. Sometimes we realize that something needs to be abstracted while we are developing it. It is also challenging to anticipate all edge cases of a component, so abstracting it too early might complicate things in the <span class="No-Break">long run.</span></p>
<p>For now, we have abstracted the most generic components we will surely use as <span class="No-Break">they are.</span></p>
<p>Remember, the implementation details of each component don’t matter. If you don’t understand everything they are doing and how they work, it’s okay. The key takeaway is that we want to abstract the most common components so we can reuse them <span class="No-Break">when needed.</span></p>
<p>Since most component<a id="_idIndexMarker156"/> libraries are very generic, with many options to fit everyone’s needs, it is a good idea to make our wrappers around their default components to reduce the default API surface and adapt them to the application’s needs. This will reduce the overhead of components with too many configuration options and props we will never use. Also, it will bring consistency since developers are constrained to using <span class="No-Break">fewer options.</span></p>
<p>Let’s look at our index page where the components <span class="No-Break">are rendered:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer013">
<img alt="Figure 3.2 – Preview of the components on the landing page " height="481" src="image/B17297_03_02.jpg" width="849"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – Preview of the components on the landing page</p>
<p>Great! Now go ahead and try to play around with different props and see how the <span class="No-Break">components behave.</span></p>
<p>Our components are working correctly and are ready to be used in the application. However, there are a<a id="_idIndexMarker157"/> couple <span class="No-Break">of issues:</span></p>
<ul>
<li>We are occupying the index route. What happens when we want to use it for something meaningful, such as the landing page? We will not be able to use that page for previewing our components. Sure, we can create and use another page that will never be used, but that is not a very good <span class="No-Break">option either.</span></li>
<li>We don’t want to display all components together as it is messy, and it would be better to try them out <span class="No-Break">in isolation.</span></li>
<li>We want to <a id="_idIndexMarker158"/>play around with the component props, which is impossible with the current approach since we would have to modify <span class="No-Break">the code.</span></li>
</ul>
<p>Let’s see in the next section how we can solve these issues and develop and try components in isolation without changing our <span class="No-Break">application’s code.</span></p>
<h1 id="_idParaDest-59"><a id="_idTextAnchor058"/>Storybook</h1>
<p><strong class="bold">Storybook</strong> is a <a id="_idIndexMarker159"/>tool that allows us to develop and test UI components in isolation. We can think of it as a tool for making catalogs of all the components we have. It is great for documenting components. A couple of benefits of using Storybook include <span class="No-Break">the following:</span></p>
<ul>
<li>Storybook <a id="_idIndexMarker160"/>allows developing components in isolation without the need to reproduce the exact state of the application, allowing developers to focus on the things they <span class="No-Break">are building</span></li>
<li>Storybook serves as a catalog of UI components allowing all stakeholders to try out the components without using them in <span class="No-Break">the application</span></li>
</ul>
<p>Storybook is configured by using the <span class="No-Break">following command:</span></p>
<pre class="console">
npx storybook init</pre>
<p>This command will install all required dependencies and set up the configuration that resides in the <strong class="source-inline">.storybook</strong> folder at the root of <span class="No-Break">the project.</span></p>
<h2 id="_idParaDest-60"><a id="_idTextAnchor059"/>Storybook configuration</h2>
<p>We already <a id="_idIndexMarker161"/>have Storybook installed, so let’s look at the configuration, which has <span class="No-Break">two files.</span></p>
<p>The first file contains the <a id="_idIndexMarker162"/>main configuration, which controls how the Storybook server behaves and how it processes our stories. It lives <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">.storybook/main.js</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
const path = require('path');
const TsconfigPathsPlugin = require('tsconfig-paths-webpack-plugin');
module.exports = {
  stories: ['../src/**/*.stories.tsx'],
  addons: [
    '@storybook/addon-links',
    '@storybook/addon-essentials',
    '@storybook/addon-interactions',
    '@chakra-ui/storybook-addon',
  ],
  features: {
    emotionAlias: false,
  },
  framework: '@storybook/react',
  core: {
    builder: '@storybook/builder-webpack5',
  },
  webpackFinal: async (config) =&gt; {
    config.resolve.plugins = config.resolve.plugins || [];
    config.resolve.plugins.push(
      new TsconfigPathsPlugin({
        configFile: path.resolve(
          __dirname,
          '../tsconfig.json'
        ),
      })
    );
    return config;
  },
};</pre>
<p>The main configuration<a id="_idIndexMarker163"/> contains the <span class="No-Break">following properties:</span></p>
<ul>
<li><strong class="source-inline">stories</strong>: An array of globs that indicates the locations of <span class="No-Break">our stories.</span></li>
<li><strong class="source-inline">addons</strong>: A list of add-ons used to enhance the default behavior <span class="No-Break">of Storybook.</span></li>
<li><strong class="source-inline">features</strong>: Enables Storybook’s <span class="No-Break">additional features.</span></li>
<li><strong class="source-inline">framework</strong>: <span class="No-Break">Framework-specific configurations.</span></li>
<li><strong class="source-inline">core</strong>: Internal <span class="No-Break">feature configuration.</span></li>
<li><strong class="source-inline">webpackFinal</strong>: Configuration for extending default webpack configuration. We are enabling absolute imports by telling Storybook to use paths from the <span class="No-Break"><strong class="source-inline">tsconfig.json</strong></span><span class="No-Break"> file.</span></li>
</ul>
<p>The second configuration file controls how the stories are rendered in the UI. This configuration lives <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">.storybook/preview.js</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
import { theme } from '../src/config/theme';
export const parameters = {
  actions: { argTypesRegex: '^on[A-Z].*' },
  controls: {
    matchers: {
      color: /(background|color)$/i,
      date: /Date$/,
    },
  },
  controls: { expanded: true },
  chakra: {
    theme,
  },
};</pre>
<p>Notice how we are <a id="_idIndexMarker164"/>passing the theme to the <strong class="source-inline">chakra</strong> property in <strong class="source-inline">parameters</strong>. This will enable Chakra theming to be applied to our components <span class="No-Break">in Storybook.</span></p>
<p>We can optionally export decorators, which will wrap all the stories. It is useful if the components rely on some providers that we want to have available in <span class="No-Break">all stories.</span></p>
<h2 id="_idParaDest-61"><a id="_idTextAnchor060"/>Storybook scripts</h2>
<p>Our Storybook setup has two <a id="_idIndexMarker165"/><span class="No-Break">npm scripts:</span></p>
<ul>
<li>Running Storybook <span class="No-Break">in development</span></li>
</ul>
<p>To start the development server, we can execute the <span class="No-Break">following command:</span></p>
<pre class="console">
npm run storybook</pre>
<p>The command will open Storybook <span class="No-Break">at </span><span class="No-Break"><strong class="source-inline">http://localhost:6006/</strong></span><span class="No-Break">.</span></p>
<ul>
<li>Building Storybook <span class="No-Break">for production</span></li>
</ul>
<p>We can also generate and deploy the stories to be visible without running the development server. To build the stories, we can execute the <span class="No-Break">following command:</span></p>
<pre class="console">
npm run storybook:build</pre>
<p>Generated files can <a id="_idIndexMarker166"/>then be found in the <strong class="source-inline">storybook-static</strong> folder, and they can be <span class="No-Break">deployed anywhere.</span></p>
<p>Now that we have familiarized ourselves with the setup, it’s time to write the stories for <span class="No-Break">the components.</span></p>
<h1 id="_idParaDest-62"><a id="_idTextAnchor061"/>Documenting components</h1>
<p>If we recall from the <a id="_idIndexMarker167"/>previous section, the configuration in <strong class="source-inline">.storybook/main.js</strong> has the <strong class="source-inline">stories</strong> property <span class="No-Break">as follows:</span></p>
<pre class="source-code">
stories: ['../src/**/*.stories.tsx']</pre>
<p>This means that any file in the <strong class="source-inline">src</strong> folder that ends with <strong class="source-inline">.stories.tsx</strong> should be picked by Storybook and treated as a story. With that said, we will co-locate stories next to the components, so the structure for every component will look something <span class="No-Break">like this:</span></p>
<pre class="source-code">
components
  my-component
    my-component.stories.tsx
    my-component.tsx
    index.ts</pre>
<p>We will create our stories based<a id="_idIndexMarker168"/> on <strong class="bold">Component Story Format</strong> (<strong class="bold">CSF</strong>), an open standard for writing <span class="No-Break">component examples.</span></p>
<p>But first, what is a story? According to the CSF standard, a story should represent a single source of truth for a component. We can think of a story as a user story where a component is presented in the <span class="No-Break">corresponding state.</span></p>
<p>CSF requires <span class="No-Break">the following:</span></p>
<ul>
<li>Default exports should<a id="_idIndexMarker169"/> define metadata about a component, including the component itself, the component’s name, decorators, <span class="No-Break">and parameters</span></li>
<li>Named exports should define <span class="No-Break">all stories</span></li>
</ul>
<p>Let’s now create the stories for <span class="No-Break">the components.</span></p>
<h2 id="_idParaDest-63"><a id="_idTextAnchor062"/>Button stories</h2>
<p>To create stories<a id="_idIndexMarker170"/> for the <strong class="source-inline">Button</strong> component, we need to <a id="_idIndexMarker171"/>create an <span class="No-Break"><strong class="source-inline">src/components/button/button.stories.tsx</strong></span><span class="No-Break"> file.</span></p>
<p>Then, we can start by adding the <span class="No-Break">required imports:</span></p>
<pre class="source-code">
import { PlusSquareIcon } from '@chakra-ui/icons';
import { Meta, Story } from '@storybook/react';
import { Button, ButtonProps } from './button';</pre>
<p>Then, we create the meta <span class="No-Break">configuration object:</span></p>
<pre class="source-code">
const meta: Meta = {
  title: 'Components/Button',
  component: Button,
};
export default meta;</pre>
<p>Notice that we are exporting it as a default export. This is what Storybook requires, according <span class="No-Break">to CSF.</span></p>
<p>Since we can have multiple stories, we must create a <span class="No-Break">story template:</span></p>
<pre class="source-code">
const Template: Story&lt;ButtonProps&gt; = (props) =&gt; (
  &lt;Button {...props} /&gt;
);</pre>
<p>And then we can export the <span class="No-Break">first story:</span></p>
<pre class="source-code">
export const Default = Template.bind({});
Default.args = {
  children: 'Click Me',
};</pre>
<p>We can pass any props we need to the <strong class="source-inline">args</strong> object attached to the story, which will be reflected in our stories <span class="No-Break">in Storybook.</span></p>
<p>We can do the same thing for another story where we want to have a version of <strong class="source-inline">Button</strong> that has <span class="No-Break">an icon:</span></p>
<pre class="source-code">
export const WithIcon = Template.bind({});
WithIcon.args = {
  children: 'Click Me',
  icon: &lt;PlusSquareIcon /&gt;,
};</pre>
<p>To see the <a id="_idIndexMarker172"/>story, let’s execute the <span class="No-Break">following</span><span class="No-Break"><a id="_idIndexMarker173"/></span><span class="No-Break"> command:</span></p>
<pre class="console">
npm run storybook</pre>
<p>Now, let’s <span class="No-Break">visit </span><span class="No-Break"><strong class="source-inline">http://localhost:6006/</strong></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer014">
<img alt="Figure 3.3 – Button component story " height="900" src="image/B17297_03_03.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – Button component story</p>
<p>And there, we have <a id="_idIndexMarker174"/>the <strong class="source-inline">Button</strong> component previewed in isolation. Notice <a id="_idIndexMarker175"/>the control panel at the bottom. This gives us a friendly interface to play with the component’s props without touching <span class="No-Break">the code.</span></p>
<p>Isn’t this much nicer than what we had first with rendering components on the index page? We can deploy stories anywhere and allow non-technical people to experiment with the components without <span class="No-Break">coding knowledge.</span></p>
<h2 id="_idParaDest-64"><a id="_idTextAnchor063"/>Exercises</h2>
<p>To solidify your understanding of Storybook, let’s have a go at some exercises. Go ahead and create stories for the <span class="No-Break">following components:</span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline">InputField</strong></span><span class="No-Break">:</span><ul><li><span class="No-Break">Default story</span></li><li>With <span class="No-Break">error story</span></li></ul></li>
<li><span class="No-Break"><strong class="source-inline">Link</strong></span><span class="No-Break">:</span><ul><li><span class="No-Break">Default story</span></li><li>With <span class="No-Break">icon story</span></li></ul></li>
</ul>
<h1 id="_idParaDest-65"><a id="_idTextAnchor064"/>Summary</h1>
<p>In this chapter, our focus was on building base components that we will reuse in <span class="No-Break">our application.</span></p>
<p>We started by configuring the Chakra UI provider and theming. Then we displayed the components on the landing page for testing purposes. They were not doing much, so we implemented them. The point of defining shared components is that we can reuse them anywhere, which makes development easier in the long run. What the components are doing here is not very important. The important thing is to think about creating shared components as a base for <span class="No-Break">the application.</span></p>
<p>We then needed to preview the components somewhere and since doing that on a page is not a very elegant solution, we chose Storybook. We covered its configuration, and then we defined a couple of stories for the <strong class="source-inline">Button</strong> component. The stories are written in <strong class="bold">Component Story Format</strong> (<strong class="bold">CSF</strong>), which is a standard for how to write <span class="No-Break">component examples.</span></p>
<p>As an exercise at the end of this chapter, there were further stories to implement, which should solidify all learnings <span class="No-Break">so far.</span></p>
<p>In the next chapter, we will use these components when we start creating <span class="No-Break">our pages.</span></p>
</div>
</div></body></html>