- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Understanding the Essentials of JavaScript and TypeScript
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解JavaScript和TypeScript的基本知识
- en: Since React Native apps are written in JavaScript, it is important to have a
    very good understanding of this language to build high-quality apps. JavaScript
    is very easy to learn, but very hard to master, because it allows you to do nearly
    everything without giving you a hard time. However, just because you can do everything
    does not mean that you should.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 由于React Native应用程序是用JavaScript编写的，因此对这种语言有非常深入的理解对于构建高质量的应用程序至关重要。JavaScript非常容易学习，但很难掌握，因为它允许你几乎可以做任何事情而不会给你带来太多麻烦。然而，仅仅因为你能够做任何事情并不意味着你应该这样做。
- en: The overall goal of this chapter is to show important underlying concepts for
    avoiding the most common mistakes, bad patterns, and very expensive *don’ts*.
    You will get useful tips, learn best practices, and repeat the most important
    basics to use JavaScript in your apps.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的整体目标是展示避免最常见的错误、不良模式和非常昂贵的“不要”的重要基础概念。你将获得有用的提示，学习最佳实践，并重复使用JavaScript在应用程序中最重要的一些基本知识。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Exploring modern JavaScript
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索现代JavaScript
- en: JavaScript knowledge for React Native development
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Native开发的JavaScript知识
- en: Working with asynchronous JavaScript
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与异步JavaScript一起工作
- en: Using typed JavaScript
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类型化JavaScript
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: There are no technical requirements except a browser to run the examples of
    this chapter. Just go to [https://jsfiddle.com/](https://jsfiddle.com/) or [https://codesandbox.io/](https://codesandbox.io/)
    and type and run your code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 除了需要一个浏览器来运行本章的示例之外，没有其他技术要求。只需访问[https://jsfiddle.com/](https://jsfiddle.com/)或[https://codesandbox.io/](https://codesandbox.io/)，输入并运行你的代码即可。
- en: 'To access the code for this chapter, follow this link to the book’s GitHub
    repository:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本章的代码，请通过以下链接访问本书的GitHub仓库：
- en: This chapter is not a complete tutorial. If you are not familiar with the JavaScript
    basics, please have a look at [https://javascript.info](https://javascript.info),
    which is the JavaScript tutorial I would recommend to start.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不是一个完整的教程。如果你不熟悉JavaScript基础知识，请查看[https://javascript.info](https://javascript.info)，这是我推荐开始学习的JavaScript教程。
- en: Exploring modern JavaScript
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索现代JavaScript
- en: When we speak of modern **JavaScript**, this refers to ECMAScript 2015 (which
    also is known as ES6) or newer. It contains a lot of useful features, which are
    not included in older JavaScript versions. Since 2015 there has been an update
    to the specification released every year.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论现代**JavaScript**时，这指的是ECMAScript 2015（也称为ES6）或更新的版本。它包含了许多有用的功能，这些功能不包括在较旧的JavaScript版本中。自2015年以来，每年都会发布一次更新规范。
- en: You can have a look at the features that were implemented in previous releases
    in the TC39 GitHub repository ([https://bit.ly/prn-js-proposals](https://bit.ly/prn-js-proposals)).
    You can also find a lot of information about upcoming features and release plans
    there.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在TC39 GitHub仓库([https://bit.ly/prn-js-proposals](https://bit.ly/prn-js-proposals))中查看之前版本中实现的功能。你还可以在那里找到有关即将推出的功能和发布计划的大量信息。
- en: Let’s start our journey to understand the most important parts of JavaScript
    by having a look under the hood. To truly understand modern JavaScript and the
    tooling around it, we have to take a little look at the basics and the history
    of the language. JavaScript is a script language, which can run nearly everywhere.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看内部结构来开始我们的旅程，以理解JavaScript最重要的部分。为了真正理解现代JavaScript及其周围的工具，我们必须稍微了解一下语言的基础和历史。JavaScript是一种脚本语言，几乎可以在任何地方运行。
- en: The most common use case clearly is building dynamic frontends for the web browser,
    but it also runs on the server (Node.js), as part of other software, on microcontrollers,
    or (most importantly for us) in apps.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的用例显然是构建用于网页浏览器的动态前端，但它也可以作为其他软件的一部分在服务器（Node.js）上运行，在微控制器上运行，或者（对我们来说最重要的是）在应用程序中运行。
- en: Every place where JavaScript runs has to have a JavaScript engine, which is
    responsible for executing the JavaScript code. In older browsers, the engines
    were only simple interpreters that transformed the code to executable bytecode
    at runtime without any optimizations.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript运行的地方都必须有一个JavaScript引擎，它负责执行JavaScript代码。在旧浏览器中，引擎只是简单的解释器，在运行时将代码转换为可执行的字节码，而不进行任何优化。
- en: Today there is a lot of optimization going on inside the different JS engines,
    depending on which metrics are important for the engine’s use case. The Chromium
    V8 engine, for example, introduced just-in-time compilation, which resulted in
    a huge performance boost while executing JavaScript.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，不同的 JS 引擎内部正在进行大量的优化，这取决于对引擎用例重要的哪些指标。例如，Chromium V8 引擎引入了即时编译，这在执行 JavaScript
    时带来了巨大的性能提升。
- en: To be able to have a common understanding of what JavaScript is on all those
    platforms and between all those engines, JavaScript has a standardized specification
    called ES. This specification is constantly evolving as more and more features
    (such as improved asynchrony or a cleaner syntax) are introduced to JavaScript.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在所有这些平台和所有这些引擎之间对 JavaScript 有一个共同的理解，JavaScript 有一个称为 ES 的标准化规范。随着越来越多的功能（如改进的异步或更简洁的语法）被引入
    JavaScript，这个规范不断演变。
- en: This constantly evolving feature set is awesome for developers but introduced
    a big problem. To be able to use the new features of the ES language specification,
    the JavaScript engine in question has to implement the new features and then the
    new version of the engine has to be rolled out to all users.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个不断发展的功能集对于开发者来说很棒，但也引入了一个大问题。为了能够使用 ES 语言规范的新功能，相关的 JavaScript 引擎必须实现这些新功能，然后必须将引擎的新版本推出给所有用户。
- en: This is a big problem especially when it comes to browsers, since a lot of companies
    rely on very old browsers for their infrastructure. This would make it impossible
    for developers to use the new features for years.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是当涉及到浏览器时，这是一个大问题，因为许多公司依赖于非常旧的浏览器作为其基础设施。这将使得开发者多年内无法使用新功能。
- en: This is where transcompilers such as Babel ([https://babeljs.io](https://babeljs.io))
    come into play. These transcompilers convert modern JavaScript into a backward-compatible
    version, which can be executed by older JavaScript engines. This transcompilation
    is an important step of the build process in modern web applications as well as
    in React Native apps.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是像 Babel ([https://babeljs.io](https://babeljs.io)) 这样的转译编译器发挥作用的地方。这些转译编译器将现代
    JavaScript 转换为向后兼容的版本，这样较旧的 JavaScript 引擎就可以执行。这种转编译是现代网络应用程序以及 React Native 应用程序构建过程中的一个重要步骤。
- en: 'When writing modern JavaScript applications, it works like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写现代 JavaScript 应用程序时，它的工作方式是这样的：
- en: You write your code in modern JavaScript.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你使用现代 JavaScript 编写代码。
- en: A transcompiler converts your code to pre-ES6 JavaScript.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转译编译器将你的代码转换为预 ES6 的 JavaScript。
- en: A JavaScript engine interprets your code and transforms it into bytecode, which
    is then executed on the machine.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JavaScript 引擎解释你的代码并将其转换为字节码，然后在该机器上执行。
- en: Modern JavaScript engines optimize execution with features such as just-in-time
    compilation.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现代 JavaScript 引擎通过诸如即时编译等特性优化执行。
- en: When it comes to React Native, you can choose from different JavaScript engines
    with different strengths and weaknesses. You can read more on this in [*Chapter
    8*](B16694_08.xhtml#_idTextAnchor268), *JavaScript Engines and Hermes*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到 React Native 时，你可以选择具有不同优势和劣势的不同 JavaScript 引擎。你可以在[*第 8 章*](B16694_08.xhtml#_idTextAnchor268)中了解更多信息，*JavaScript
    引擎和 Hermes*。
- en: In this section, you learned what modern JavaScript is and how it works under
    the hood. Let’s continue with the specific parts of JavaScript required when developing
    with React Native.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了现代 JavaScript 是什么以及它在底层是如何工作的。让我们继续学习在开发 React Native 时所需的 JavaScript
    的具体部分。
- en: Exploring JavaScript for React Native development
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 JavaScript 以进行 React Native 开发
- en: In this section, you will learn some basic JavaScript concepts, all of which
    are important to truly understand how to work with React Native. Again, this is
    not a complete tutorial; it includes only the most important things that you have
    to keep in mind if you don’t want to run into errors that are very hard to debug.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习一些基本的 JavaScript 概念，所有这些概念对于真正理解如何使用 React Native 都非常重要。再次强调，这并不是一个完整的教程；它只包括如果你不想遇到难以调试的错误，你必须牢记的最重要的事情。
- en: Tip
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: When you are not sure how JavaScript behaves in a special scenario, just create
    an isolated example and try it on [https://jsfiddle.com/](https://jsfiddle.com/)
    or [https://codesandbox.io/](https://codesandbox.io/).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当你不确定 JavaScript 在特定场景中的行为时，只需创建一个隔离的示例并在 [https://jsfiddle.com/](https://jsfiddle.com/)
    或 [https://codesandbox.io/](https://codesandbox.io/) 上尝试它。
- en: Understanding the assigning and passing of objects
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解对象的分配和传递
- en: Assigning or passing data is one of the most basic operations in any programming
    language. You do it a lot in every project. When working with JavaScript, there
    is a difference when working with primitive types (Boolean, number, string, and
    so on) or with objects (or arrays, which are basically objects).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何编程语言中，分配或传递数据是最基本的操作之一。你在每个项目中都会做很多次。当使用 JavaScript 时，处理原始类型（布尔值、数字、字符串等）和处理对象（或数组，它们基本上是对象）之间存在差异。
- en: Primitives are assigned and passed by values, while objects are assigned and
    passed by references. This means for primitives, a real copy of the value is created
    and stored, while for objects, only a new reference to the same object is created
    and stored.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 原始类型是通过值分配和传递的，而对象是通过引用分配和传递的。这意味着对于原始类型，会创建并存储值的真正副本，而对于对象，只会创建并存储对同一对象的引用。
- en: This is important to keep in mind, because when you edit an assigned or passed
    object, you also edit the initial object.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点非常重要，因为当您编辑分配或传递的对象时，您也在编辑初始对象。
- en: 'This will be clearer in the following code example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例将使这一点更加清晰：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `paintRed` function does not return anything and we do not write anything
    in `bus` after initializing it as a blue bus. So, what happens? The `bus` object
    is passed as a reference. This means the `vehicle` variable in the `paintRed`
    function and the `bus` variable outside of the function reference the same object
    in storage.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`paintRed` 函数不返回任何内容，我们在初始化为蓝色公交车后不在 `bus` 中写入任何内容。那么会发生什么？`bus` 对象是通过引用传递的。这意味着
    `paintRed` 函数中的 `vehicle` 变量和函数外部的 `bus` 变量引用存储中的相同对象。'
- en: When changing the color of `vehicle`, we change the color of the object that
    is also referenced by `bus`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当改变 `vehicle` 的颜色时，我们也改变了 `bus` 引用的对象的颜色。
- en: This is expected behavior, but you should avoid using it in most cases. In larger
    projects, code can get very hard to read (and debug) when objects are passed down
    a lot of functions and are then changed. As Robert C. Martin already wrote in
    the book *Clean Code*, functions should have no side effects, which means they
    should not change values outside of the function’s scope.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是预期的行为，但您应该尽量避免在大多数情况下使用它。在较大的项目中，当对象在许多函数中传递并更改时，代码可能会变得非常难以阅读（和调试）。正如罗伯特·C·马丁在《Clean
    Code》一书中已经写到的，函数应该没有副作用，这意味着它们不应该改变函数作用域之外的价值。
- en: 'If you want to change an object in a function, I recommend using a return value
    in most cases. This is much easier to understand and read. The following example
    shows the code from the previous example, but without side effects:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在函数中更改对象，我建议在大多数情况下使用返回值。这更容易理解和阅读。以下示例显示了上一个示例中的代码，但没有副作用：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this code example, it is absolutely clear that `bus` is a new object, which
    was created by the `paintRed` function.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中，`bus` 是一个新对象，这是由 `paintRed` 函数创建的这一点非常清楚。
- en: Please keep this in mind when working on your projects. It really can cost you
    a lot of time when you have to debug a change in your object, but you don’t know
    where it’s coming from.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的工作项目中请记住这一点。当您必须调试对象中的更改，但不知道它从何而来时，这真的可能花费您很多时间。
- en: Creating real copies of an object
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建对象的真正副本
- en: 'A very common problem that results from the previous point is that you have
    to clone an object. There are multiple ways to do that, each with different limitations.
    Three options are shown in the following code example:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由前一点导致的一个非常常见的问题是您必须克隆一个对象。有多种方法可以做到这一点，每种方法都有不同的限制。以下代码示例中展示了三种选项：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We create an object with different types as properties. This is important, because
    the different ways to clone the object will not work for all properties. We use
    a string for `color`, an object for `extras`, a date for `sellingDate`, and a
    function in `writeColor` to return a string with the color of the car.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个具有不同类型属性的对象。这很重要，因为克隆对象的不同方法并不适用于所有属性。我们使用字符串作为 `color`，对象作为 `extras`，日期作为
    `sellingDate`，并在 `writeColor` 中使用函数来返回带有汽车颜色的字符串。
- en: In the next lines, we use three different ways to clone the object. After creating
    the `_car`, `_car2`, and `_car3` cloned objects, we change `extras` in the initial
    `car` object. We then log all three objects.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几行中，我们使用三种不同的方法来克隆对象。在创建 `_car`、`_car2` 和 `_car3` 克隆对象后，我们更改初始 `car` 对象中的
    `extras`。然后我们记录所有三个对象。
- en: 'We will now have a detailed look at the different options regarding how to
    clone objects in JavaScript. These are the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将详细探讨有关如何在 JavaScript 中克隆对象的多种选项。这些选项包括以下内容：
- en: Spread operator and `Object.assign`
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展运算符和`Object.assign`
- en: '`JSON.stringify` and `JSON.parse`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JSON.stringify`和`JSON.parse`'
- en: Real deepclone
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真正的深克隆
- en: We’ll start with spread operator and `Object.assign`, which basically work the
    same way.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从扩展运算符和`Object.assign`开始，它们基本上以相同的方式工作。
- en: Spread operator and Object.assign
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展运算符和`Object.assign`
- en: The three dots we use to create `_car` is called a `car`. In line 14, we did
    a very similar thing; we assigned all properties of `car` to a new empty object
    with `Object.assign`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来创建`_car`的三个点称为`car`。在第14行，我们做了非常类似的事情；我们使用`Object.assign`将`car`的所有属性赋值给一个新的空对象。
- en: In fact, lines 13 and 14 work the same way. They create a **shallow clone**,
    which means they clone all property values of the object.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，第13行和第14行的工作方式相同。它们创建了一个**浅克隆**，这意味着它们克隆了对象的所有属性值。
- en: This works great for values, but it doesn’t for complex data types, because,
    again, objects are assigned by reference. So, these ways of creating a copy of
    a complex object only clone the references to the data of the properties of the
    object and don’t create real copies of every property.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于值来说效果很好，但对于复杂的数据类型则不行，因为，再次强调，对象是通过引用分配的。因此，这些创建复杂对象副本的方法只克隆了对象属性数据的引用，而没有创建每个属性的真正副本。
- en: In our example, we wouldn’t create a real copy of `extras`, `sellingDate`, and
    `writeColor`, because the values of the properties in the `car` object are only
    references to the objects. This means that by changing `_car.extras` in line 17,
    we also change `_car2.extras`, because it references the same object.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们不会创建`extras`、`sellingDate`和`writeColor`的实际副本，因为`car`对象中属性的值只是对对象的引用。这意味着当我们修改第17行的`_car.extras`时，也会修改`_car2.extras`，因为它们引用的是同一个对象。
- en: So these ways of cloning objects work fine for objects with just one level.
    As soon as there is an object with multiple levels, cloning with the spread operator
    or `Object.assign` can create serious problems in your application.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这些克隆对象的方法对于只有一层的对象来说效果很好。一旦有一个多层的对象，使用扩展运算符或`Object.assign`克隆可能会在你的应用程序中引起严重问题。
- en: Stringify and parse again
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 再次进行序列化和解析
- en: A very common pattern to clone objects is to use the built-in `JSON.stringify`
    and `JSON.parse` features of JavaScript. This converts the object to a primitive
    type (a JSON string) and creates a new object by parsing the string again.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一种非常常见的克隆对象模式是使用JavaScript内置的`JSON.stringify`和`JSON.parse`功能。这会将对象转换为原始类型（JSON字符串），并通过再次解析字符串来创建一个新的对象。
- en: This forces a **deepclone**, which means even sub-objects are copied by value.
    The downside of this approach is that it only works for values that have an equivalent
    in JSON.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这将强制进行**深克隆**，这意味着甚至子对象也会按值复制。这种方法的缺点是它只适用于在JSON中有等效值的值。
- en: So, you will lose all functions, properties that are undefined, and values such
    as infinity that do not exist in JSON. Other things such as date objects will
    be simplified as strings, resulting in a lost time zone. So, this solution works
    great for deep objects with primitive values.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你将丢失所有函数、未定义的属性以及JSON中不存在的值，如无穷大。其他事物，如日期对象，将被简化为字符串，导致时区丢失。因此，这个解决方案非常适合具有原始值的深对象。
- en: Real deepclone
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 真正的深克隆
- en: When you want to create a real deepclone of an object, you have to get creative
    and write your own function. There are a lot of different approaches when you
    search the web. I would recommend using a well-tested and maintained library such
    as Lodash ([https://lodash.com/](https://lodash.com/)). It offers a simple `cloneDeep`
    function, which does the work for you.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想创建一个真正的深克隆对象时，你必须发挥创意并编写自己的函数。在网上搜索时，有很多不同的方法。我建议使用经过良好测试和维护的库，例如Lodash ([https://lodash.com/](https://lodash.com/))。它提供了一个简单的`cloneDeep`函数，它会为你完成工作。
- en: You can use all solutions, but you have to keep in mind the limitations of every
    single approach. You should also have a look at the performance of the different
    solutions when you use them. In most cases, all cloning methods are fast enough
    to use, but when you’re experiencing performance issues in your application, you
    should have a closer look at which method you are using.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用所有解决方案，但你要记住每种方法的局限性。当使用它们时，你也应该查看不同解决方案的性能。在大多数情况下，所有克隆方法都足够快，可以用来使用，但当你应用程序中遇到性能问题时，你应该更仔细地查看你使用的方法。
- en: 'Please find a summary in the following table:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请在以下表格中查找摘要：
- en: '![Figure 2.1 – Comparison of JavaScript cloning solutions'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.1 – JavaScript克隆解决方案的比较](img/B16694_02_01.jpg)'
- en: '](img/B16694_02_01.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.1 – JavaScript克隆解决方案的比较](img/B16694_02_01.jpg)'
- en: Figure 2.1 – Comparison of JavaScript cloning solutions
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – JavaScript克隆解决方案的比较
- en: Knowing how to clone objects in certain situations is very important, because
    using the wrong cloning technique can lead to errors that are very hard to debug.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下知道如何克隆对象非常重要，因为使用错误的克隆技术可能会导致难以调试的错误。
- en: After understanding how to clone objects, let’s have a look at destructuring
    objects.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解了如何克隆对象之后，让我们看看如何解构对象。
- en: Working with destructuring in JavaScript
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在JavaScript中使用解构
- en: Another thing you will need to do a lot when working with React Native is destructuring
    objects and arrays. Destructuring basically means *unpacking* the properties of
    objects or the elements of arrays. Especially when working with Hooks, this is
    something you have to know very well. Let’s start with arrays.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用React Native时，你还需要经常做的一件事是解构对象和数组。解构基本上意味着*展开*对象属性或数组元素。尤其是在使用Hooks时，这是你必须非常清楚的事情。让我们从数组开始。
- en: Destructuring arrays
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解构数组
- en: 'Have a look at the following code example, which shows how an array gets destructured:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下代码示例，它展示了数组是如何被解构的：
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can see an array with two elements. In the second line, we *destructure*
    the `name` array by assigning `name` to an array with two variables inside. The
    first variable gets assigned the first value of the array, and the second variable
    the second value. This can also be done with more than two values.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到一个包含两个元素的数组。在第二行，我们通过将`name`数组赋值给包含两个变量的数组来*解构*`name`数组。第一个变量被分配数组的第一个值，第二个变量被分配第二个值。这也可以用于超过两个值的情况。
- en: Array destructuring is used, for example, every time you work with a `useState`
    Hook (more on this in [*Chapter 3*](B16694_03.xhtml#_idTextAnchor061)*, Hello
    React Native*).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 数组解构在每次你使用`useState`Hook时都会用到（更多内容请参阅[*第3章*](B16694_03.xhtml#_idTextAnchor061)*，Hello
    React Native*)。
- en: Now that you know how to destructure an array, let’s go on to destructuring
    objects.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何解构数组，让我们继续学习如何解构对象。
- en: Destructuring objects
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解构对象
- en: 'The following code example shows how to destructure an object:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例展示了如何解构一个对象：
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Object destructuring works the same way as destructuring arrays. But please
    note the curly brackets in line 6 of the code example. This is important when
    destructuring objects instead of arrays. You *can* get all properties of the object
    just by using the key in the destructuring, but you don’t have to use all properties.
    In our example, we only use `firstName` and `age`, but not `lastName`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对象解构与解构数组的工作方式相同。但请注意代码示例的第6行中的花括号。在解构对象而不是数组时，这一点非常重要。你*可以*仅通过在解构中使用键来获取对象的所有属性，但你不必使用所有属性。在我们的例子中，我们只使用了`firstName`和`age`，而没有使用`lastName`。
- en: When working with destructuring, you can also collect all the elements that
    weren’t specified during the destructuring. This is done with the spread operator,
    as described in the following section.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用解构时，你还可以收集在解构期间未指定的所有元素。这通过以下章节中描述的扩展运算符来完成。
- en: Using the spread operator during destructuring
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在解构时使用扩展运算符
- en: 'The spread operator can be used as shown in the following code example:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例展示了如何使用扩展运算符：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When destructuring arrays or objects, you can use the spread operator to collect
    all elements that weren’t included in the destructuring. In the code example,
    we use `firstName` and `age` in the destructuring.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当解构数组或对象时，你可以使用扩展运算符来收集在解构中未指定的所有元素。在代码示例中，我们在解构时使用了`firstName`和`age`。
- en: All other properties, in this example `lastName` and `height`, are collected
    in a new object, the `rest` variable. This is used a lot in React and React Native,
    for example when passing properties (or props) down to components and destructuring
    these props.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，所有其他属性，例如`lastName`和`height`，都被收集到一个新的对象`rest`变量中。这在React和React Native中用得很多，例如在将属性（或props）传递到组件并解构这些props时。
- en: When you work with React or React Native, especially with functional components
    and Hooks, destructuring is something that you will use in every component. Basically,
    it is nothing more than *unpacking* the properties of an object or elements of
    an array.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用React或React Native，尤其是与函数组件和Hooks一起工作时，解构是你在每个组件中都会用到的东西。基本上，它不过是*展开*对象属性或数组元素。
- en: Now that we understand destructuring, let’s move on to another important topic
    – the `this` keyword and its scope in JavaScript.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了解构，让我们继续学习另一个重要的话题——JavaScript中的`this`关键字及其作用域。
- en: Understanding this in JavaScript
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解JavaScript中的`this`
- en: JavaScript has quite a unique behavior when it comes to the `this` keyword.
    It does not always refer to the function or scope where it is used. By default,
    `this` is bound to the global scope. This can be changed via implicit or explicit
    binding.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到`this`关键字时，JavaScript有着相当独特的行为。它并不总是指向使用它的函数或作用域。默认情况下，`this`绑定到全局作用域。这可以通过隐式或显式绑定来改变。
- en: Implicit and explicit binding
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隐式和显式绑定
- en: '`this` always refers to the object. `this` to another context. This is something
    that was used a lot in React and React Native to bind `this` in the handlers of
    class components.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`this`始终指向对象。`this`指向另一个上下文。这是React和React Native中经常使用的一种方法，用于在类组件的处理程序中绑定`this`。'
- en: 'Please have a look at the following code example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下代码示例：
- en: '[PRE6]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, we bind the `this` value of the class explicitly to the
    `handlePress` function. This is necessary, because if we don’t do it, `this` would
    be implicitly bound to the object where it is called, which in this case would
    be anywhere in the `Pressable` component. Since we want to have access to the
    data of our `MyClass` component in our `handlePress` function in most cases, this
    explicit binding is needed.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们明确地将类的`this`值绑定到`handlePress`函数上。这是必要的，因为我们如果不这样做，`this`将隐式地绑定到调用它的对象上，在这种情况下，它将是`Pressable`组件中的任何地方。由于在大多数情况下，我们希望在`handlePress`函数中访问`MyClass`组件的数据，因此这种显式绑定是必要的。
- en: You can see this kind of code in a lot of applications, because for a long time
    it was the only method to access class properties from inside a function. This
    led to a lot of explicit binding statements in constructors, especially in larger
    class components. Fortunately, today there is a much better solution – arrow functions!
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在很多应用中看到这种代码，因为长期以来，这是从函数内部访问类属性的唯一方法。这导致了构造函数中，特别是在较大的类组件中，有很多显式绑定语句。幸运的是，今天有一个更好的解决方案——箭头函数！
- en: Arrow functions to the rescue
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 箭头函数拯救
- en: 'In modern JavaScript, there is another solution that makes this implicit/explicit
    binding redundant: `this` keyword is bound. Instead of writing `function myFunction(param1){}`,
    you simply write `const myFunction = (param1) => {}`.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代JavaScript中，还有一个解决方案使得隐式/显式绑定变得多余：`this`关键字被绑定。你不需要写`function myFunction(param1){}`，只需简单地写`const
    myFunction = (param1) => {}`。
- en: The important thing here is that arrow functions always use the lexical scope
    of `this`, which means they won’t rebind `this` implicitly.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这里重要的是箭头函数始终使用`this`的词法作用域，这意味着它们不会隐式地重新绑定`this`。
- en: 'The following example shows how to use arrow functions to make explicit binding
    statements redundant:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何使用箭头函数来使显式绑定语句变得多余：
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, we use an arrow function to define `handlePress`. Because of
    this, we don’t have to do an explicit binding like in the code example before.
    We simply can use `this` inside the `handlePress` function to access states and
    props of other properties of our `MyClass` component. This makes the code easier
    to write, read, and maintain.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们使用箭头函数来定义`handlePress`。正因为如此，我们不需要像之前的代码示例那样进行显式绑定。我们只需在`handlePress`函数内部使用`this`来访问`MyClass`组件的其他属性的状态和props。这使得代码更容易编写、阅读和维护。
- en: Important note
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Please keep in mind that regular functions and arrow functions are not only
    syntactically different, but they also change the way `this` is bound.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，普通函数和箭头函数不仅在语法上不同，它们还改变了`this`的绑定方式。
- en: Understanding the scope of `this` is crucial to avoid costly errors such as
    undefined object references. When it comes to app development, these undefined
    object references can hard-crash your app. So, keep in mind the scope you are
    referring to when using the `this` keyword.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 理解`this`的作用域对于避免昂贵的错误，如未定义的对象引用至关重要。当涉及到应用开发时，这些未定义的对象引用可能会导致应用崩溃。因此，在使用`this`关键字时，请记住你引用的作用域。
- en: These are the most important things you must truly understand when using JavaScript
    to develop large-scale applications. If you don’t, you will make costly errors.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是在使用JavaScript开发大型应用时你必须真正理解的最重要的事情。如果你不这样做，你将犯下昂贵的错误。
- en: The next thing that is very important when developing apps with React Native
    is asynchronous programming.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用React Native开发应用时，下一件非常重要的事情是异步编程。
- en: Working with asynchronous JavaScript
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用异步JavaScript
- en: Because of the architecture of React Native (more on this in [*Chapter 3*](B16694_03.xhtml#_idTextAnchor061),
    *Hello React Native*) and the typical use cases of apps, understanding asynchronous
    JavaScript is crucial. A typical example of an asynchronous call is a call to
    an API.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于React Native的架构（更多内容请参阅[*第3章*](B16694_03.xhtml#_idTextAnchor061)，*Hello React
    Native*)以及应用的典型用例，理解异步JavaScript至关重要。异步调用的典型例子是对API的调用。
- en: In a synchronous world, after making the call, the application would be blocked
    until the answer from the API is received. This is, obviously, unexpected behavior.
    The application should respond to user interaction while it waits for the response.
    This means the call to the API has to be done asynchronously.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在同步世界中，在发出调用后，应用程序将被阻塞，直到收到API的响应。这显然是不期望的行为。应用程序应该在等待响应的同时响应用户交互。这意味着API调用必须是异步的。
- en: There are multiple ways of working with asynchronous calls in JavaScript. The
    first one is callbacks.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中处理异步调用有多种方式。第一种是回调。
- en: Exploring callbacks
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索回调
- en: Callbacks are the most basic way to work with asynchrony in JavaScript. I would
    recommend using them as little as possible, because there are better alternatives.
    But since a lot of libraries rely on callbacks, you have to have a good understanding
    of them.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 回调是处理JavaScript中异步操作的最基本方式。我建议尽可能少地使用它们，因为还有更好的替代方案。但是，由于许多库依赖于回调，你必须对它们有一个很好的理解。
- en: 'A callback is a JavaScript function A that is passed as an argument to another
    function B. At some point in function B, function A is called. This behavior is
    called a **callback**. The following code shows a simple callback example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 回调是一个JavaScript函数A，它作为参数传递给另一个函数B。在函数B的某个点，函数A被调用。这种行为被称为**回调**。以下代码展示了简单的回调示例：
- en: '[PRE8]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When you look at the code, function A is called. It logs some text and then
    calls the callback. This callback is the function passed to function A as a property
    when function A was called – in this example, function B.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看代码时，函数A被调用。它记录了一些文本，然后调用回调。这个回调是在函数A被调用时作为属性传递给函数A的函数 – 在这个例子中，函数B。
- en: 'So, function B is called at the end of function A. Function B then logs some
    more text. As a result of this code, you will see two lines of text: first, the
    one logged by function A, and second, the one logged by function B.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，函数B在函数A的末尾被调用。函数B随后记录了一些更多的文本。由于这段代码，你将看到两行文本：首先，函数A记录的文本，其次，函数B记录的文本。
- en: While callbacks can be a little hard to understand, let’s have a look at what’s
    happening under the hood.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然回调可能有点难以理解，但让我们看看底层发生了什么。
- en: Understanding the implementation
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解实现
- en: 'To be able to truly understand callbacks, we’ll have to dig a little into the
    implementation of a JavaScript engine. JavaScript is single-threaded, so inside
    of the JavaScript code execution, asynchrony won’t be possible. The following
    figure shows the important parts of a JavaScript engine and how they work together
    to achieve asynchrony:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正理解回调，我们不得不稍微深入到JavaScript引擎的实现中。JavaScript是单线程的，所以在JavaScript代码执行过程中，异步是不可能的。以下图显示了JavaScript引擎的重要部分以及它们如何协同工作以实现异步：
- en: '![Figure 2.2 – JavaScript engine asynchronous code execution'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.2 – JavaScript引擎异步代码执行'
- en: '](img/B16694_02_02.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.2 – JavaScript引擎异步代码执行'
- en: Figure 2.2 – JavaScript engine asynchronous code execution
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – JavaScript引擎异步代码执行
- en: Your commands will be pushed to the **callstack** and processed in a last-in,
    first-out order. To achieve asynchrony, JavaScript engines provide APIs that are
    called from within your JavaScript code. These APIs execute code on another thread.
    Most of these APIs expect a callback passed as an argument.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你的命令将被推送到**调用栈**，并按照后进先出的顺序进行处理。为了实现异步，JavaScript引擎提供了一些API，这些API可以从你的JavaScript代码中调用。这些API在另一个线程上执行代码。大多数这些API期望一个作为参数传递的回调。
- en: When this code execution on the second thread is finished, this callback will
    be pushed to the **message queue**. The message queue is monitored by the **event
    loop**. As soon as the callstack is empty and the message queue is not, the event
    loop takes the first item of the message queue and pushes it on the callstack.
    Now we are back in our JavaScript context and the JavaScript code execution continues
    with the given callback.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当第二个线程上的代码执行完成后，此回调将被推送到**消息队列**。消息队列由**事件循环**监控。一旦调用栈为空且消息队列不为空，事件循环就会从消息队列中取出第一个项目并将其推入调用栈。现在我们回到了JavaScript上下文，JavaScript代码执行继续进行，并使用给定的回调。
- en: What’s better than callbacks? Promises!
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比回调更好的是什么？Promises！
- en: With ES 2015, promises were introduced. Under the hood, they work quite similar
    to callbacks, except that there is another queue called a job or microtask queue.
    This queue works like the message queue but has a higher priority when getting
    processed by the event loop.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES 2015中，引入了promises。在底层，它们的工作方式与回调非常相似，只是还有一个名为作业或微任务队列的另一个队列。这个队列的工作方式类似于消息队列，但在事件循环处理时具有更高的优先级。
- en: The difference from callbacks is that promises have a much cleaner syntax. While
    you can pass any number of callbacks to a function, a promise returns a function
    with exactly one or two arguments – `resolve` and (optionally) `reject`. `resolve`
    is called when the promise is processed successfully, and `reject` if there was
    an error while processing the promise.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 与回调相比，promises具有更简洁的语法。虽然您可以将任意数量的回调传递给一个函数，但promise返回一个具有确切一个或两个参数的函数——`resolve`和（可选的）`reject`。当promise成功处理时，调用`resolve`，如果在处理promise时发生错误，则调用`reject`。
- en: 'The following code shows a generic example of a promise and how it is used:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了promise的通用示例及其使用方法：
- en: '[PRE9]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The promise is created with `new Promise` and then called. Inside the promise,
    there is a 500 ms delay before the promise is resolved. When the promise is resolved,
    the function inside `.then` is called.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: promise是通过`new Promise`创建的，然后被调用。在promise内部，在promise解决之前有一个500毫秒的延迟。当promise解决时，`.then`内部的函数被调用。
- en: One of the simplest examples of this asynchronous behavior using a promise is
    fetching data from a server. You can use the Fetch API in JavaScript. This API
    contacts the server and waits for an answer.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用promise的这种异步行为的一个简单示例是从服务器获取数据。您可以使用JavaScript中的Fetch API。此API会联系服务器并等待响应。
- en: 'As soon as the answer is received, `resolve` or `reject` is pushed to the queue
    and processed by the event loop. The following example shows the code for a simple
    fetch:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦收到响应，`resolve`或`reject`就会被推送到队列中，并由事件循环处理。以下示例显示了简单fetch的代码：
- en: '[PRE10]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This code example even contains two promises:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码示例甚至包含两个promises：
- en: The `fetch` operation, which returns the server response
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetch`操作，它返回服务器响应'
- en: The unwrapping of the JSON data, which is included in the response
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含在响应中的JSON数据的解包
- en: If one of the promises is rejected, the `catch` block is called with some error
    information.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其中一个promise被拒绝，`catch`块会调用并带有一些错误信息。
- en: Tip
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: You should always catch your errors and promise rejections and handle – or at
    least report – them. While unhandled promise rejections don’t crash your application
    in most cases, it indicates that something went wrong. It can be very hard to
    realize and debug this error without proper error reporting in place. It is always
    a good idea to use reporting tools such as Sentry or Bugsnag. You can read more
    on this in *Chapter 14*, *Tips, Tricks, and Best Practices*.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该始终捕获错误和promise拒绝，并处理它们——或者至少报告它们。虽然未处理的promise拒绝在大多数情况下不会使您的应用程序崩溃，但它表明出了问题。如果没有适当的错误报告，这个错误可能很难发现和调试。始终使用报告工具，如Sentry或Bugsnag是一个好主意。您可以在*第14章*，*技巧、窍门和最佳实践*中了解更多相关信息。
- en: Promises also provide some interesting features such as `Promises.all` and `Promises.first`,
    which make it possible to work with multiple promises. If you want to learn more
    about this, you can have a look at [bit.ly/prn-promises](http://bit.ly/prn-promises).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Promises还提供了一些有趣的功能，例如`Promises.all`和`Promises.first`，这使得处理多个promises成为可能。如果您想了解更多关于这方面的信息，可以查看[bit.ly/prn-promises](http://bit.ly/prn-promises)。
- en: Improved syntax with async/await
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用async/await改进的语法
- en: With ES 2017, the `async` and `await` keywords were introduced to work with
    Promises. This is the syntax I recommend you use in your projects because it makes
    the code easy to read and understand. Instead of chaining `.then` with a callback
    function to the promise call, you can simply `await` the promise.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES 2017中，引入了`async`和`await`关键字来处理Promises。这是我在你的项目中推荐使用的语法，因为它使得代码易于阅读和理解。你不需要将`.then`与回调函数链接到promise调用上，你只需简单地`await`promise。
- en: 'The only requirement is that the function you write code in is declared as
    an async function. You can also wrap the call with a `try/catch` block. This is
    similar to `.catch` in the regular promise syntax. The following example shows
    how to work with `async/await` property:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的要求是，你编写的代码函数必须声明为异步函数。你也可以用`try/catch`块来包装调用。这类似于常规的promise语法中的`.catch`。以下示例展示了如何使用`async/await`属性：
- en: '[PRE11]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We specify `fetchData` as an `async` function with the `async` keyword. Inside
    the async function, we use `try`/`catch` for proper error handling. Inside the
    `try` block, we await the `fetch` call and the unpacking of the JSON body with
    the `await` keyword.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`async`关键字将`fetchData`指定为异步函数。在异步函数内部，我们使用`try`/`catch`进行适当的错误处理。在`try`块内部，我们使用`await`关键字等待`fetch`调用和JSON主体的解包。
- en: Basically, every promise can be used with the async/await syntax. Also, an async
    function can be handled as a Promise with `.then` and `.catch`. Again, this is
    the syntax I would recommend for use in large-scale projects. Since it is compatible
    with Promises, you can use a lot of libraries with it out of the box. But when
    you have to work with a library that relies on promises in its API, you will have
    to patch it.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，每个promise都可以与async/await语法一起使用。此外，异步函数可以用`.then`和`.catch`作为Promise来处理。再次强调，这是我在大型项目中推荐使用的语法。由于它与Promises兼容，你可以直接使用很多库。但是，当你必须与依赖于其API中的promises的库一起工作时，你必须修补它。
- en: Patching callback libraries
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 补丁回调库
- en: 'When working with React Native, you will find some libraries that work with
    callbacks in their JavaScript. This is because the transfer between the JavaScript
    and React Native contexts relies on callbacks in most cases. I would recommend
    patching these libraries and reworking them to provide a promise API, which you
    can then use with async/await in your project. This is quite simple and improves
    the code quality a lot. A very simple example is shown in the following code block:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用React Native时，你会发现一些库在它们的JavaScript中使用回调函数。这是因为JavaScript和React Native上下文之间的传输在大多数情况下依赖于回调函数。我建议修补这些库并重新工作，以提供promise
    API，然后你可以在你的项目中使用async/await。这很简单，并且大大提高了代码质量。以下代码块展示了一个非常简单的示例：
- en: '[PRE12]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this code example, we have a library that provides a function that expects
    a `successCallback` and an `errorCallback`. We create a promise, which just calls
    this function and passes `resolve` as `successCallback` and `reject` as `errorCallback`.
    That’s all, now we can work with async/await to call our promise, which then calls
    the library function for us.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中，我们有一个提供函数的库，该函数期望一个`successCallback`和一个`errorCallback`。我们创建了一个promise，它只是调用这个函数，并将`resolve`作为`successCallback`，将`reject`作为`errorCallback`。就是这样，现在我们可以使用async/await来调用我们的promise，然后它为我们调用库函数。
- en: Tip
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Try to use async/await syntax over promises wherever possible. This makes your
    code easier to read and understand.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能地使用async/await语法而不是promise。这使得你的代码更容易阅读和理解。
- en: In this section, you learned how asynchrony is implemented in JavaScript, how
    callbacks and promises work, and why you should rely on async/await, especially
    in large-scale projects.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了JavaScript中异步的实现方式，回调和promise是如何工作的，以及为什么你应该依赖async/await，尤其是在大型项目中。
- en: This leads to the last section of this chapter, which is also very important
    when working on large-scale projects – static type checking in JavaScript.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了本章的最后一节，这在大型项目中工作也非常重要——JavaScript中的静态类型检查。
- en: Using typed JavaScript
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类型化JavaScript
- en: JavaScript is a dynamically typed language. This means you can change the type
    of a variable after its initialization. While this can be very handy for small
    scripts, it can lead to difficult problems when working on large-scale projects.
    Debugging such errors, especially in apps with a lot of users, can get really
    messy.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是一种动态类型语言。这意味着你可以在变量初始化后更改其类型。虽然这对于小型脚本来说可能非常有用，但在大型项目中工作可能会导致难以解决的问题。在拥有大量用户的app中调试此类错误可能会变得非常混乱。
- en: This is where extensions to JavaScript come into play. There are multiple solutions
    to extend JavaScript to be a typed language. This not only prevents errors; it
    also enables better refactoring and code completion as well as pointing out problems
    directly when writing the code.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是JavaScript扩展发挥作用的地方。有多个解决方案可以将JavaScript扩展为强类型语言。这不仅防止了错误，还使代码重构和代码补全以及直接在编写代码时指出问题成为可能。
- en: This speeds up the development process a lot. I would definitely recommend using
    typed JavaScript and I want to introduce the two most popular solutions here.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这大大加快了开发过程。我肯定会推荐使用强类型JavaScript，并且我想在这里介绍两种最流行的解决方案。
- en: Flow
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Flow
- en: Created and open sourced by Facebook, Flow is a static type checker that works
    with normal JavaScript. It was created as a command-line tool that scans your
    files for type safety and reports errors to the console. Nowadays, all common
    JavaScript IDEs have Flow support built in or offer it via excellent plugins.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 由Facebook创建并开源的Flow是一个与普通JavaScript一起工作的静态类型检查器。它最初是一个命令行工具，用于扫描您的文件以检查类型安全性并向控制台报告错误。如今，所有常见的JavaScript
    IDE都内置了Flow支持或通过优秀的插件提供支持。
- en: To enable static type checking with Flow, you just have to add the `// @flow`
    annotation to the top of your file. This tells the Flow type checker to include
    the file in the check. Then you can directly add your types behind the declaration
    of variables and parameters (inline), or you can declare more complex types and
    use these types to specify the type of a variable when it is declared.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用Flow的静态类型检查，您只需在文件顶部添加`// @flow`注释即可。这告诉Flow类型检查器将文件包含在检查中。然后您可以直接在变量和参数的声明后面添加类型（内联），或者您可以声明更复杂的类型，并使用这些类型在声明变量时指定变量的类型。
- en: 'This is shown in the following code block:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这在下面的代码块中显示：
- en: '[PRE13]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We created a `Person` type, which is then used to create a person, `john`. If
    we had missed one of the properties or had assigned a value with the wrong type,
    the Flow IDE integration would have given us an error.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个`Person`类型，然后使用它来创建一个人物，`john`。如果我们遗漏了某个属性或者分配了错误类型的值，Flow IDE集成会给我们一个错误。
- en: Since Flow isn’t a separate language but only a tool on top of JavaScript, we
    have to transform our files from Flow annotated files back to *normal* JavaScript
    files. This basically means, we have to use a transformer to remove all the Flow
    annotations from our files. Flow provides a Babel plugin for this, which has to
    be installed for your project to work.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Flow不是一个独立的语言，而只是在JavaScript之上的一个工具，我们必须将我们的文件从Flow注释文件转换回*普通*JavaScript文件。这基本上意味着，我们必须使用一个转换器来从我们的文件中移除所有的Flow注释。Flow提供了一个Babel插件来完成这项工作，这个插件必须安装到您的项目中才能工作。
- en: Flow can be configured via a `.flowconfig` file. Here you can define which files
    and folders should be checked and which shouldn’t, as well as specifying some
    options, such as how to deal with imports, but also how many workers Flow can
    start in parallel to check your code or how much memory Flow is allowed to use.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Flow可以通过`.flowconfig`文件进行配置。在这里，您可以定义哪些文件和文件夹应该被检查，哪些不应该被检查，以及指定一些选项，例如如何处理导入，以及Flow可以并行启动多少个工作线程来检查您的代码或Flow允许使用多少内存。
- en: If you want to have a deeper look at Flow, please visit the website at [https://flow.org/](https://flow.org/).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想深入了解Flow，请访问[https://flow.org/](https://flow.org/)网站。
- en: TypeScript
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TypeScript
- en: Another option for typed JavaScript is TypeScript. It is an open source language
    on top of JavaScript that is developed and maintained by Microsoft. It also has
    awesome integrations for all common JavaScript IDEs and works very similar to
    Flow.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对于强类型JavaScript的另一种选择是TypeScript。它是由微软开发和维护的一个开源语言，它建立在JavaScript之上。它也为所有常见的JavaScript
    IDE提供了出色的集成，并且与Flow非常相似。
- en: Your TypeScript code will be transformed into plain JavaScript via the TypeScript
    transpiler or Babel, before you are able to execute it in production. Even the
    syntax of the annotations is nearly the same. The example code in the *Flow* section
    would work perfectly fine in TypeScript.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在您能够在生产环境中执行之前，TypeScript代码将通过TypeScript编译器或Babel转换为纯JavaScript。甚至注释的语法也几乎相同。在*Flow*部分的示例代码在TypeScript中也能完美运行。
- en: If you want to have a deeper look at TypeScript, please visit the website at
    [www.typescriptlang.org](http://www.typescriptlang.org).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想深入了解TypeScript，请访问[www.typescriptlang.org](http://www.typescriptlang.org)网站。
- en: In general, I prefer TypeScript over Flow, because it is used much more widely
    with much larger support from the community. The docs are better and so are the
    IDE integration and code completion. If you start a new project, I recommend going
    with TypeScript. But Flow is also a good solution. If you have a working Flow
    integration in your project, there is no need to migrate to TypeScript at the
    moment.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '通常情况下，我更倾向于使用 TypeScript 而不是 Flow，因为 TypeScript 的使用范围更广，社区支持也更大。文档质量更好，IDE
    集成和代码补全也更好。如果你开始一个新的项目，我建议选择 TypeScript。但 Flow 也是一个不错的解决方案。如果你在你的项目中已经有了工作的 Flow
    集成，目前没有必要迁移到 TypeScript。 '
- en: Important note
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you work on a large-scale project, I would definitely recommend using Flow
    or TypeScript. Even if you have some overhead at the beginning, it will save you
    much more time and money in the end.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你参与一个大规模项目，我肯定会推荐使用 Flow 或 TypeScript。即使你一开始有一些开销，最终它能为你节省更多的时间和金钱。
- en: Summary
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how modern JavaScript works, along with some especially
    important basics for when working with React Native, and how asynchrony works
    in JavaScript. You have acquired a basic understanding of the underlying technology,
    as well as how misuse can lead to costly errors and how to avoid them.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了现代 JavaScript 的工作原理，以及在与 React Native 一起工作时的一些特别重要的基础知识，还有 JavaScript
    中的异步是如何工作的。你已经对底层技术有了基本的了解，以及误用可能导致昂贵的错误以及如何避免它们。
- en: In the next chapter, we will learn about React, how it works internally, and
    which parts of React it is important to know well when working with React Native.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习关于 React 的内容，它内部是如何工作的，以及在与 React Native 一起工作时，哪些 React 的部分是重要的，需要深入了解。
