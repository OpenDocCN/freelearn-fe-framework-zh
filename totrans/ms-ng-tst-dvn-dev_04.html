<html><head></head><body>
		<div id="_idContainer087">
			<h1 id="_idParaDest-61" class="chapter-number"><a id="_idTextAnchor108"/><st c="0">4</st></h1>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor109"/><st c="2">Mocking and Stubbing Dependencies in Angular Tests</st></h1>
			<p><st c="52">To write effective and reliable tests for Angular applications, it’s essential to understand how to handle dependencies. </st><st c="174">Dependencies can often introduce complexity and make testing difficult. </st><st c="246">However, by taking advantage of techniques such as mocking and stubbing, we can better control our tests and ensure the accuracy and stability of </st><span class="No-Break"><st c="392">our application.</st></span></p>
			<p><st c="408">In this chapter, we’ll explore the concept of spies and method substitutes. </st><st c="485">Spies allow us to monitor and verify the behavior of dependencies during testing. </st><st c="567">We’ll learn how to create spies using the Jasmine test framework and use them to find out whether certain methods have been called, how many times they’ve been called, and with what parameters. </st><st c="761">In addition, we’ll discover the power of method substitutes, which allow us to replace the implementation of a method with our own </st><span class="No-Break"><st c="892">custom logic.</st></span></p>
			<p><st c="905">Next, we’ll take a look at </st><strong class="source-inline"><st c="933">TestBed</st></strong><st c="940"> providers and how they allow us to inject simulated dependencies into our tests. </st><st c="1022">TestBed is a powerful Angular testing utility that allows us to create a test module and configure it with the necessary dependencies. </st><st c="1157">We’re going to learn how to create and configure </st><a id="_idTextAnchor110"/><st c="1206">TestBed providers to replace real dependencies with simulated versions. </st><st c="1278">This technique allows us to isolate the component or service under test and control the behavior of </st><span class="No-Break"><st c="1378">its dependencies.</st></span></p>
			<p><st c="1395">Finally, we’ll explore how to handle asynchronous operations and complex scenarios when setting up dependencies. </st><st c="1509">We’ll discover the </st><strong class="source-inline"><st c="1528">async</st></strong><st c="1533"> and </st><strong class="source-inline"><st c="1538">fakeAsync</st></strong><st c="1547"> utilities provided by the Angular testing framework and see how to use them to manage asynchronous code in our tests. </st><st c="1666">In addition, we’ll discuss strategies for handling complex scenarios, such as dependencies with multiple methods or dependencies that require specific </st><span class="No-Break"><st c="1817">initialization steps.</st></span></p>
			<p><st c="1838">In summary, here are the main topics that will be covered in </st><span class="No-Break"><st c="1900">this chapter:</st></span></p>
			<ul>
				<li><st c="1913">Monitoring and controlling dependency calls using method stubs </st><span class="No-Break"><st c="1977">and stubs</st></span></li>
				<li><st c="1986">Injecting mocked dependencies using </st><span class="No-Break"><st c="2023">TestBed providers</st></span></li>
				<li><st c="2040">Handling async operations and </st><span class="No-Break"><st c="2071">complex scenarios</st></span></li>
			</ul>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor111"/><st c="2088">Technical requirements</st></h1>
			<p><st c="2111">To follow along with the examples and exercises in this chapter, you will need to have a basic understanding of Angular and TypeScript. </st><st c="2248">You will also need </st><span class="No-Break"><st c="2267">the following:</st></span></p>
			<ul>
				<li><st c="2281">Node.js and npm installed on </st><span class="No-Break"><st c="2311">your computer</st></span></li>
				<li><st c="2324">Angular CLI </st><span class="No-Break"><st c="2337">installed globally</st></span></li>
				<li><st c="2355">A code editor, such as Visual Studio Code, installed on </st><span class="No-Break"><st c="2412">your computer</st></span></li>
			</ul>
			<p><st c="2425">The code files of this chapter can be found </st><span class="No-Break"><st c="2470">at </st></span><a href="https://github.com/PacktPublishing/Mastering-Angular-Test-Driven-Development/tree/main/Chapter%204"><span class="No-Break"><st c="2473">https://github.com/PacktPublishing/Mastering-Angular-Test-Driven-Development/tree/main/Chapter%204</st></span></a><span class="No-Break"><st c="2571">.</st></span></p>
			<h1 id="_idParaDest-64"><a id="_idTextAnchor112"/><st c="2572">Monitoring and controlling dependency calls using method stubs and spies</st></h1>
			<p><st c="2645">One crucial aspect</st><a id="_idIndexMarker168"/><st c="2664"> of testing </st><a id="_idIndexMarker169"/><st c="2676">in Angular applications is the ability to monitor and control dependency calls. </st><st c="2756">Dependencies are external resources or services that a piece of code relies on to function correctly. </st><st c="2858">Monitoring and controlling these dependency calls allows developers to ensure that their code interacts correctly with external systems and handles different </st><span class="No-Break"><st c="3016">scenarios gracefully.</st></span></p>
			<p><st c="3037">Spies and method stubs are two powerful techniques within Angular’s testing framework that enable developers to achieve this level of control. </st><st c="3181">Spies allow developers to monitor function calls, record information about those calls, and assert expectations about their usage. </st><st c="3312">On the other hand, method stubs provide a way to replace real dependencies with simplified versions, allowing developers to control the behavior of those dependencies </st><span class="No-Break"><st c="3479">during testing.</st></span></p>
			<p><st c="3494">By using spies, developers can verify that the correct functions are called with the right parameters and that they are called the expected number of times. </st><st c="3652">This is particularly useful when testing code that interacts with external APIs or databases</st><a id="_idTextAnchor113"/><st c="3744">. Method stubs, on the other hand, enable developers to simulate different scenarios and provide predefined responses to method calls. </st><st c="3879">This allows for thorough testing of edge cases and ensures the </st><span class="No-Break"><st c="3942">code’s robustness.</st></span></p>
			<p><st c="3960">In this section, we’ll explore the concepts of spies and method stubs in the Angular testing framework. </st><st c="4065">We’ll dive into their applications and show their usefulness in monitoring and controlling dependency calls. </st><st c="4174">Still based on our project related to a calculator application, we’ll demonstrate how spies and method substitutes can be used to create reliable and complete </st><a id="_idIndexMarker170"/><st c="4333">tests, with </st><a id="_idIndexMarker171"/><st c="4345">an emphasis on the </st><a id="_idIndexMarker172"/><st c="4364">principles of </st><strong class="bold"><st c="4378">test-driven </st></strong><span class="No-Break"><strong class="bold"><st c="4390">development</st></strong></span><span class="No-Break"><st c="4401"> (</st></span><span class="No-Break"><strong class="bold"><st c="4403">TDD</st></strong></span><span class="No-Break"><st c="4406">).</st></span></p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor114"/><st c="4409">Method stubs and spies</st></h2>
			<p><st c="4432">Method stubs, also</st><a id="_idIndexMarker173"/><st c="4451"> known as fake or dummy objects, are used to replace real dependencies with simplified versions during testing. </st><st c="4563">By providing predefined responses to method calls, method substitutes enable developers to isolate and control the behavior of the code </st><span class="No-Break"><st c="4699">under test.</st></span></p>
			<p><st c="4710">In the calculator application, let’s consider a scenario in which the user performs a division operation with a divisor equal to zero. </st><st c="4846">We want to make sure that the application handles this scenario correctly. </st><st c="4921">By creating a method plug for the divide function, we can simulate the divide-by-zero scenario and check that the application displays an appropriate </st><span class="No-Break"><st c="5071">error message.</st></span></p>
			<p><st c="5085">At present, our calculator’s division operation does not handle the exception related to division </st><span class="No-Break"><st c="5184">by zero.</st></span></p>
			<p><st c="5192">In our </st><strong class="source-inline"><st c="5200">calculator.component.spec.ts</st></strong><st c="5228"> test file, we’re going to add the test that allows us to raise this exception. </st><st c="5308">Since we’re following TDD principles, the test should </st><span class="No-Break"><st c="5362">fail naturally.</st></span></p>
			<p><st c="5377">After running our test, we notice that the test has indeed failed, as shown in the </st><span class="No-Break"><st c="5461">following screenshot:</st></span></p>
			<div>
				<div id="_idContainer067" class="IMG---Figure">
					<img src="image/B21146_04_1.jpg" alt="Figure 4.1 – Division-by-zero test case"/><st c="5482"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="5745">Figure 4.1 – Division-by-zero test case</st></p>
			<div>
				<div id="_idContainer068" class="IMG---Figure">
					<img src="image/B21146_04_2.jpg" alt="Figure 4.2 – Division-by-zero test case failed"/><st c="5784"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="6446">Figure 4.2 – Division-by-zero test case failed</st></p>
			<p><st c="6492">To correct this, we need to update our </st><strong class="source-inline"><st c="6532">CalculatorService</st></strong><st c="6549">. In our present scenario, there’s a clever approach to refrain from direct interaction with our core service and ensure</st><a id="_idIndexMarker174"/><st c="6669"> that everything is operational prior to any such action. </st><st c="6727">This approach involves the utilization of a method </st><span class="No-Break"><st c="6778">stub concept.</st></span></p>
			<p><st c="6791">Basically, we’ll point our </st><strong class="source-inline"><st c="6819">CalculatorService</st></strong><st c="6836"> ser</st><a id="_idTextAnchor115"/><st c="6840">vice at a fake service that will enable us to check the correctness of the logic we want to implement before modifying the service itself. </st><st c="6980">In fact, this fake service will simply be a stub method that replaces the classic division of our basic </st><strong class="source-inline"><st c="7084">CalculatorService</st></strong><st c="7101"> service. </st><st c="7111">To start with, you’ll need to com</st><a id="_idTextAnchor116"/><st c="7144">ment out all the tests linked to other operators in our </st><strong class="source-inline"><st c="7201">calculator.component.spec.ts</st></strong><st c="7229"> file, if you already have some. </st><st c="7262">Next, we’ll declare this </st><span class="No-Break"><st c="7287">stub method:</st></span></p>
			<pre class="source-code"><st c="7299">
const calculatorServiceStub = {
  divide: (a: number, b: number) =&gt; {
        if (b === 0) {
      throw</st><a id="_idTextAnchor117"/><st c="7388"> new Error('Cannot divide by zero');
    }
    return a / b;
  },
};</st></pre>			<p><st c="7446">Then, in the </st><strong class="source-inline"><st c="7460">describe</st></strong><st c="7468"> method, within the </st><strong class="source-inline"><st c="7488">configureTestingModule</st></strong><st c="7510"> method, we will replace our </st><strong class="source-inline"><st c="7539">CalculatorService</st></strong><st c="7556"> provider with </st><span class="No-Break"><st c="7571">the following:</st></span></p>
			<pre class="source-code"><st c="7585">
providers: [
        { provide: CalculatorService, useValue: calculatorServiceStub },
      ],</st></pre>			<p><st c="7666">Finally, here is </st><a id="_idIndexMarker175"/><st c="7684">the test case for our fake </st><strong class="source-inline"><st c="7711">calculatorServiceStub</st></strong><st c="7732"> service, which contains our stub </st><span class="No-Break"><strong class="source-inline"><st c="7766">divide</st></strong></span><span class="No-Break"><st c="7772"> method:</st></span></p>
			<pre class="source-code"><st c="7780">
 it('should raise an exception when dividing by zero', () =&gt; {
    spyOn(calculatorService, 'divide').and.callThrough()</st><a id="_idTextAnchor118"/><st c="7895">;
    expect(() =&gt; calculator.divide(10, 0)).toThrowError(
      'Cannot divide by zero'
    )</st><a id="_idTextAnchor119"/><st c="7976">;
    expect(calculatorService.divide).toHaveBeenCalledWith(10, 0);
  });</st></pre>			<p><st c="8044">Here’s the complete code for implementing our </st><span class="No-Break"><st c="8091">fake service:</st></span></p>
			<pre class="source-code"><st c="8104">
i</st><a id="_idTextAnchor120"/><st c="8106">mport { ComponentFixture, TestBed } from '@angular/core/testing';
import { CalculatorComponent } from './calculator.component';
import { CalculatorService } from 'src/core/services/calculator.service';
import { ColorChangeDirective } from 'src/core/directives/color-change.directive';
const calculatorServiceStub = {
  divide: (a: number, b: number) =&gt; {
    if (b === 0) {
      thro</st><a id="_idTextAnchor121"/><st c="8478">w new Error('Cannot divide by zero');
    }
    return a / b;
  },</st><a id="_idTextAnchor122"/><st c="8535">
};
describe('CalculatorComponent', () =&gt; {
  let calculator: CalculatorComponent;
  let fixture: ComponentFixture&lt;CalculatorComponent&gt;;
  let calculatorService: CalculatorService;
  beforeEach(async () =&gt; {
    await TestBed.configureTestingModule({
      declarations: [CalculatorComponent, ColorChangeDirective],
      providers: [
  </st><a id="_idTextAnchor123"/><st c="8846">      { provide: CalculatorService, useValue: calculatorServiceStub },
      ],
    }).compileComponents();
    fixture = TestBed.createComponent(CalculatorComponent);
    calculator = fixture.componentInstance;
    calculatorService = TestBed.inject(CalculatorService);
    fixture.detectChanges();
  })</st><a id="_idTextAnchor124"/><st c="9116">;
  it('should create', () =&gt; {
    expect(calculator).toBeTruthy();
  });</st><a id="_idTextAnchor125"/><st c="9183">
  it('should initialize result to 0', () =&gt; {
    calculator.ngOnInit();
    expect(calculator.result).toEqual(0);
  })</st><a id="_idTextAnchor126"/><st c="9291">;
  it('should divide two numbers correctly', () =&gt; {
    spyOn(calculatorService, 'divide').and.callThrough();
    calculator.divide(4, 2)</st><a id="_idTextAnchor127"/><st c="9421">;
    expect(calculatorService.divide).toHaveBeenCalledWith(4, 2);
    expect(calculator.result).toBe(2);
  })</st><a id="_idTextAnchor128"/><st c="9522">;
  it('should raise an exception when dividing by zero', () =&gt; {
    spyOn(calculatorService, 'divide').and.callThrough()</st><a id="_idTextAnchor129"/><st c="9639">;
    expect(() =&gt; calculator.divide(10, 0)).toThrowError(
      'Cannot divide by zero'
    )</st><a id="_idTextAnchor130"/><st c="9720">;
    expect(calculatorService.divide).toHaveBeenCalledWith(10, 0);
  });
});</st></pre>			<p><st c="9792">Let’s go through </st><span class="No-Break"><st c="9810">the code.</st></span></p>
			<p><st c="9819">The </st><strong class="source-inline"><st c="9824">calculatorServiceStub</st></strong><st c="9845"> object is created to mock the </st><strong class="source-inline"><st c="9876">divide</st></strong><st c="9882"> method of the </st><strong class="source-inline"><st c="9897">CalculatorService</st></strong><st c="9914"> service. </st><st c="9924">The </st><strong class="source-inline"><st c="9928">divide</st></strong><st c="9934"> method takes two parameters, </st><strong class="source-inline"><st c="9964">a</st></strong><st c="9965"> and </st><strong class="source-inline"><st c="9970">b</st></strong><st c="9971">, and performs the division operation. </st><st c="10010">In this case, the stub checks whether </st><strong class="source-inline"><st c="10048">b</st></strong><st c="10049"> is equal to zero. </st><st c="10068">If it is, an </st><a id="_idIndexMarker176"/><st c="10081">error is thrown to simulate the </st><span class="No-Break"><st c="10113">division-by-zero scenario.</st></span></p>
			<p><st c="10139">The last </st><strong class="source-inline"><st c="10149">expect</st></strong><st c="10155"> statement checks whether the </st><strong class="source-inline"><st c="10185">result</st></strong><st c="10191"> property of the component is equal to </st><strong class="source-inline"><st c="10230">'Division by zero'</st></strong><st c="10248">. This verifies that the error message is correctly displayed when division by </st><span class="No-Break"><st c="10327">zero occurs.</st></span></p>
			<p><st c="10339">Notice that our test execution has failed. </st><st c="10383">This is a typing problem, as </st><strong class="source-inline"><st c="10412">result</st></strong><st c="10418"> is of the type </st><strong class="source-inline"><st c="10434">number</st></strong><st c="10440"> and </st><span class="No-Break"><st c="10445">not </st></span><span class="No-Break"><strong class="source-inline"><st c="10449">string</st></strong></span><span class="No-Break"><st c="10455">.</st></span></p>
			<p><st c="10456">So, we’re going to write the minimum amount of code we need in our </st><strong class="source-inline"><st c="10524">CalculatorComponent</st></strong><st c="10543"> to solve </st><span class="No-Break"><st c="10553">the problem:</st></span></p>
			<div>
				<div id="_idContainer069" class="IMG---Figure">
					<img src="image/B21146_04_3.jpg" alt="Figure 4.3 – Updating the declaration of the result property"/><st c="10565"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="10592">Figure 4.3 – Updating the declaration of the result property</st></p>
			<p><st c="10652">After running the tests, notice that all the tests have turned green, as shown in </st><span class="No-Break"><st c="10735">our screenshot:</st></span></p>
			<div>
				<div id="_idContainer070" class="IMG---Figure">
					<img src="image/B21146_04_4.jpg" alt="Figure 4.4 – Division-by-zero test case succeeded"/><st c="10750"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="11130">Figure 4.4 – Division-by-zero test case succeeded</st></p>
			<p><st c="11179">Now we’re going to refactor, as required by the principles of TDD. </st><st c="11247">We’re going to create a </st><strong class="source-inline"><st c="11271">stubs</st></strong><st c="11276"> folder in our project’s </st><strong class="source-inline"><st c="11301">core</st></strong><st c="11305"> folder and create a </st><strong class="source-inline"><st c="11326">calculator.service.stub.ts</st></strong><st c="11352"> file </st><span class="No-Break"><st c="11358">in it.</st></span></p>
			<div>
				<div id="_idContainer071" class="IMG---Figure">
					<img src="image/B21146_04_5.jpg" alt="Figure 4.5 – calculator.service.stub.ts file arborescence"/><st c="11364"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="11443">Figure 4.5 – calculator.service.stub.ts file arborescence</st></p>
			<p><st c="11500">Once the file has</st><a id="_idIndexMarker177"/><st c="11518"> been created, we will move the source code of our fake stub-based service from </st><strong class="source-inline"><st c="11598">calculator.component.spec.ts</st></strong><st c="11626"> into our </st><strong class="source-inline"><st c="11636">calculator.service.stub.ts</st></strong><st c="11662"> file </st><span class="No-Break"><st c="11668">like this:</st></span></p>
			<div>
				<div id="_idContainer072" class="IMG---Figure">
					<img src="image/B21146_04_6.jpg" alt="Figure 4.6 – calculator.service.stub.ts code source"/><st c="11678"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="11891">Figure 4.6 – calculator.service.stub.ts code source</st></p>
			<p><st c="11942">Since it’s a service, we’ll be using the dependency injection technique, as we’ll see in more detail in the next section. </st><st c="12065">At this stage, here’s what we’ll do in a couple </st><span class="No-Break"><st c="12113">of steps:</st></span></p>
			<ol>
				<li><st c="12122">Create a class in </st><strong class="source-inline"><st c="12141">calculator.service.stub.ts</st></strong> <span class="No-Break"><st c="12167">called </st></span><span class="No-Break"><strong class="source-inline"><st c="12175">CalculatorServiceStub</st></strong></span><span class="No-Break"><st c="12196">.</st></span></li>
				<li><st c="12197">Implement all the operator methods of our </st><span class="No-Break"><st c="12240">calculator application.</st></span><p class="list-inset"><st c="12263">Here’s what </st><a id="_idIndexMarker178"/><st c="12276">the source code </st><span class="No-Break"><st c="12292">looks like:</st></span></p><pre class="source-code"><st c="12303">
export class CalculatorServiceStub</st><a id="_idTextAnchor131"/><st c="12338"> {
  add(a: number, b: number): number {
    return a + b;
  }
  substract(a: number, b: number): number {
    return a - b;
  }</st><a id="_idTextAnchor132"/><st c="12450">
  multiply(a: number, b: number): number {
    return a * b;
  }</st><a id="_idTextAnchor133"/><st c="12507">
  divide(a: number, b: number): number | Error {
    if (b === 0) {
      throw</st><a id="_idTextAnchor134"/><st c="12575"> new Error('Cannot divide by zero');
    }
    return a / b;
  }
}</st></pre></li>				<li><st c="12631">After updating our fake service, we’ll go into our </st><strong class="source-inline"><st c="12683">calculator.component.spec.ts</st></strong><st c="12711"> test file to replace the provider </st><span class="No-Break"><st c="12746">like this:</st></span><pre class="source-code"><st c="12756">
import { CalculatorServiceStub } from 'src/core/stubs/calculator.service.stub';
...
</st><st c="12841">providers: [
        { provide: CalculatorService, useClass: CalculatorServiceStub },
      ],
...</st></pre></li>				<li><st c="12925">Now we can uncomment all the methods in our </st><strong class="source-inline"><st c="12970">calculator.component.spec.ts</st></strong><st c="12998"> file, except</st><a id="_idTextAnchor135"/><st c="13011"> the </st><strong class="source-inline"><st c="13016">it('should display error message for division by zero')</st></strong><st c="13071"> test case. </st><st c="13083">Notice that all </st><a id="_idIndexMarker179"/><st c="13099">our tests are green, as shown in the </st><span class="No-Break"><st c="13136">following figure:</st></span></li>
			</ol>
			<div>
				<div id="_idContainer073" class="IMG---Figure">
					<img src="image/B21146_04_7.jpg" alt="Figure 4.7 – CalculatorComponent succeeded using CalculatorServiceStub test cases"/><st c="13153"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="13646">Figure 4.7 – CalculatorComponent succeeded using CalculatorServiceStub test cases</st></p>
			<p><st c="13727">Spies and method stubs are powerful tools in Angular’s testing framework that enable developers to monitor and control the behavior of dependencies in their applications. </st><st c="13899">By incorporating these techniques into the TDD process, developers can write more comprehensive and reliable tests, ensuring the functionality and stability of their Angular applications. </st><st c="14087">The calculator app example illustrates how spies and method stubs can be applied to simulate different scenarios and validate the behavior of the code under test. </st><st c="14250">In the next section, we’ll take a closer look at how to inject mocked dependencies</st><a id="_idIndexMarker180"/><st c="14332"> using </st><span class="No-Break"><st c="14339">TestBed providers.</st></span></p>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor136"/><st c="14357">Injecting mocked dependencies using TestBed providers</st></h1>
			<p><st c="14411">Mocked dependencies</st><a id="_idIndexMarker181"/><st c="14431"> are simplified </st><a id="_idIndexMarker182"/><st c="14447">versions of external services or resources that mimic the behavior of the actual dependencies. </st><st c="14542">By injecting these mocked dependencies using TestBed providers, developers can control their behavior during testing, ensuring reliable and thorough testing without relying on </st><span class="No-Break"><st c="14718">external systems.</st></span></p>
			<p><st c="14735">In this section, we will explore the concept of TestBed providers in Angular’s testing framework. </st><st c="14834">We will delve into their applications and showcase how they enable developers to inject mocked dependencies into their code. </st><st c="14959">By doing so, we can create isolated and controlled testing environments, adhering to the principles </st><span class="No-Break"><st c="15059">of TDD.</st></span></p>
			<p><st c="15066">By injecting mocked dependencies using TestBed providers, developers can focus on testing specific units of code without worrying about the complexities of the actual dependencies. </st><st c="15248">This approach allows for easier debugging, improved test coverage, and better overall </st><span class="No-Break"><st c="15334">code quality.</st></span></p>
			<p><st c="15347">Throughout this section, we will emphasize the principles of TDD and demonstrate the usage of TestBed providers in a practical example, using our calculator app. </st><st c="15510">By understanding and utilizing TestBed providers effectively, developers can write reliable, maintainable, and thoroughly tested </st><span class="No-Break"><st c="15639">Angular applications.</st></span></p>
			<p><st c="15660">Let’s consider adding the ability to calculate the square root of a number to our calculator application, while still relying on our </st><strong class="source-inline"><st c="15794">CalculatorService</st></strong><st c="15811"> service. </st><st c="15821">In this case, we’ll focus on the square root functionality of the </st><span class="No-Break"><st c="15887">calculator application.</st></span></p>
			<p><st c="15910">First, we need to create a mock service that mimics the behavior of the actual square root service. </st><st c="16011">We can create a simple class that returns predefined square root values for different inputs. </st><st c="16105">This class, named </st><strong class="source-inline"><st c="16123">MockSquareRootService</st></strong><st c="16144">, will be created in the </st><strong class="source-inline"><st c="16169">mocks</st></strong><st c="16174"> folder, which we’ll create at the same arborescence level as the </st><strong class="source-inline"><st c="16240">stubs</st></strong><st c="16245"> folder, as demonstrated in the </st><span class="No-Break"><st c="16277">following screenshot:</st></span></p>
			<div>
				<div id="_idContainer074" class="IMG---Figure">
					<img src="image/B21146_04_8.jpg" alt="Figure 4.8 – mock-square-root.service.mock.ts file arborescence"/><st c="16298"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="16373">Figure 4.8 – mock-square-root.service.mock.ts file arborescence</st></p>
			<p><st c="16436">Here’s an example of a mock square </st><span class="No-Break"><st c="16472">root service:</st></span></p>
			<pre class="source-code"><st c="16485">
export class MockSquareRootService {
  calculateSquareRoot(value: number): number {
    // Perform a predefined square root calculation based on the input value
    return Math.sqrt(value);
  }
}</st></pre>			<p><st c="16669">Next, we </st><a id="_idIndexMarker183"/><st c="16679">will</st><a id="_idIndexMarker184"/><st c="16683"> configure the test module using TestBed providers to replace the real square root service with the simulated version in </st><strong class="source-inline"><st c="16804">calculator.component.spec.ts</st></strong><st c="16832">. Here’s an example of how to configure the </st><span class="No-Break"><st c="16876">test module:</st></span></p>
			<pre class="source-code"><st c="16888">
import { MockSquareRootService } from './mock-square-root.service';
...
</st><st c="16961">beforeEach(async () =&gt; {
    await TestBed.configureTestingModule({
     ...
     </st><st c="17029">pr</st><a id="_idTextAnchor137"/><st c="17031">oviders: [{ provide: CalculatorService, useClass: MockSquareRootService }]
    }).compileComponents();</st></pre>			<p><st c="17130">In the preceding code, we provide the </st><strong class="source-inline"><st c="17169">CalculatorService</st></strong><st c="17186"> service token and specify the </st><strong class="source-inline"><st c="17217">useClass</st></strong><st c="17225"> property with </st><strong class="source-inline"><st c="17240">MockSquareRootService</st></strong><st c="17261"> service. </st><st c="17271">This configuration tells TestBed to use the mock service whenever the code under test requests an instance of the actual square </st><span class="No-Break"><st c="17399">root service.</st></span></p>
			<p><st c="17412">Now, when we run our tests for the calculator app, any code that depends on the square root service will receive an instance of the mocked service. </st><st c="17561">We can control the behavior of the service during testing, ensuring that the calculator app correctly performs square root calculations under different scenarios. </st><st c="17724">Here’s some example code for the </st><strong class="source-inline"><st c="17757">MockSquareRootService</st></strong><st c="17778"> service that mimics the behavior of the </st><strong class="source-inline"><st c="17819">CalculatorService</st></strong><st c="17836"> service </st><a id="_idIndexMarker185"/><st c="17845">by </st><a id="_idIndexMarker186"/><st c="17848">returning predefined square root values for </st><span class="No-Break"><st c="17892">different inputs:</st></span></p>
			<pre class="source-code"><st c="17909">
export class MockSquareRootService {
  calculateSquareRoot(value: number): number {
    // Perform a predefined square root calculation based on the input value
    if (value === 4) {
      return 2;
    } else if (value === 9) {
      return 3;
    } else if (value === 16) {
      return 4;
    } else {
      throw new Error('Invalid input');
    }
  }
}</st></pre>			<p><st c="18215">Let’s finish writing our test on the square roots of numbers by adding this sequence to our test </st><span class="No-Break"><st c="18313">file, </st></span><span class="No-Break"><strong class="source-inline"><st c="18319">calculator.component</st><a id="_idTextAnchor138"/><st c="18339">.spec.ts</st></strong></span><span class="No-Break"><st c="18347">:</st></span></p>
			<pre class="source-code"><st c="18349">
 it('should calculate the square root correctly', () =&gt; {
   spyOn(calculatorService, 'squareRoot').and.callThrough();
   calculator.squareRo</st><a id="_idTextAnchor139"/><st c="18484">ot(16);
   expect(calculatorService.squareRoot).toHaveBeenCalledWith(16);
   expect(calculator.result).toBe(4);
  });</st></pre>			<p><st c="18594">To make it functional, you need to add the </st><strong class="source-inline"><st c="18638">squareRoot()</st></strong><st c="18650"> method to </st><strong class="source-inline"><st c="18661">calculator.component.ts</st></strong><st c="18684"> and </st><strong class="source-inline"><st c="18689">calculator.service.ts</st></strong><st c="18710">. I won’t do this in the current project, as the aim is to show how to set up a </st><span class="No-Break"><st c="18790">mock briefly.</st></span></p>
			<p><st c="18803">TestBed providers in Angular allow you to inject mocked dependencies into your tests. </st><st c="18890">This is a </st><a id="_idIndexMarker187"/><st c="18900">powerful </st><a id="_idIndexMarker188"/><st c="18909">feature that enables you to control the behavior of external dependencies and isolate the code </st><span class="No-Break"><st c="19004">under test.</st></span></p>
			<p><st c="19015">When configuring the testing module using </st><strong class="source-inline"><st c="19058">TestBed.configureTestingModule</st></strong><st c="19088">, you can provide a list of providers that specify the tokens for the dependencies you want to mock. </st><st c="19189">You can then use either the </st><strong class="source-inline"><st c="19217">useClass</st></strong><st c="19225"> or </st><strong class="source-inline"><st c="19229">useValue</st></strong><st c="19237"> property to provide a mock or stub implementation for </st><span class="No-Break"><st c="19292">each dependency.</st></span></p>
			<p><st c="19308">By providing a mock implementation, you can define the behavior of the dependency during testing. </st><st c="19407">This allows you to simulate different scenarios and control the return values or error conditions of the dependency. </st><st c="19524">You can also verify the interaction between the code under test and the dependency by using spies or other </st><span class="No-Break"><st c="19631">testing techniques.</st></span></p>
			<p><st c="19650">Injecting mocked dependencies using TestBed providers helps to improve the reliability and stability of your tests. </st><st c="19767">It allows you to focus on testing the specific functionality of your code without relying on the actual implementation of external dependencies. </st><st c="19912">This makes your tests more deterministic and less prone to failures caused by changes in the behavior of </st><span class="No-Break"><st c="20017">the dependencies.</st></span></p>
			<p><st c="20034">Overall, TestBed providers provide a convenient way to inject mocked dependencies into your Angular tests. </st><st c="20142">They allow you to control the behavior of external dependencies and isolate the code under test, resulting in more reliable and focused tests. </st><st c="20285">We’ll be taking a hands-on approach in the chapters to come. </st><st c="20346">The aim here is to understand the relevance of asynchronous </st><a id="_idIndexMarker189"/><st c="20406">tasks and </st><a id="_idIndexMarker190"/><st c="20416">why we need to be careful when implementing tests about them. </st><st c="20478">In the next section, we will manage asynchronous operations and </st><span class="No-Break"><st c="20542">complex scenarios.</st></span></p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor140"/><st c="20560">Handling async operations and complex scenarios</st></h1>
			<p><st c="20608">Testing asynchronous </st><a id="_idIndexMarker191"/><st c="20630">operations and complex scenarios is a crucial part of ensuring the reliability and functionality of modern software applications. </st><st c="20760">In today’s software development landscape, applications often rely on asynchronous operations, such as promises and observables, to handle data fetching, processing, and user interactions. </st><st c="20949">Additionally, complex scenarios, involving intricate workflows, conditional logic, and multiple dependencies, need to be thoroughly tested to ensure the application behaves as expected in </st><span class="No-Break"><st c="21137">various scenarios.</st></span></p>
			<p><st c="21155">Testing these asynchronous operations and complex scenarios requires the use of specialized techniques and tools to handle the unique challenges they present. </st><st c="21315">In the context of Angular, a popular JavaScript framework, developers have access to a comprehensive testing framework that provides powerful utilities for testing </st><span class="No-Break"><st c="21479">such scenarios.</st></span></p>
			<p><st c="21494">In this section, we will explore the importance of testing asynchronous operations, such as promises and observables, and complex scenarios in Angular applications. </st><st c="21660">We will delve into various techniques and best practices for effectively testing these scenarios, ensuring reliable and comprehensive </st><span class="No-Break"><st c="21794">test coverage.</st></span></p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor141"/><st c="21808">Understanding asynchronous operations</st></h2>
			<p><st c="21846">Asynchronous </st><a id="_idIndexMarker192"/><st c="21860">operations are tasks that can be executed independently of the main program flow. </st><st c="21942">They are typically used to handle time-consuming operations, such as network requests, file I/O, or database queries. </st><st c="22060">Instead of waiting for these operations to complete, the program can continue executing other tasks, improving overall performance </st><span class="No-Break"><st c="22191">and responsiveness.</st></span></p>
			<p><st c="22210">One common approach to handling asynchronous operations is through callbacks. </st><st c="22289">A callback is a function that is passed to another function as an argument and executed once the asynchronous operation is complete. </st><st c="22422">This allows us to define what should happen after the operation finishes. </st><st c="22496">However, managing callbacks can lead to callback hell, making the code hard to read and maintain. </st><st c="22594">To solve this problem, </st><strong class="source-inline"><st c="22617">promises</st></strong> <span class="No-Break"><st c="22625">were born.</st></span></p>
			<p><st c="22636">Promises provide a more structured way to handle asynchronous operations. </st><st c="22711">A promise represents the eventual completion or failure of an asynchronous operation and allows us to attach callbacks to handle these outcomes. </st><st c="22856">Promises offer a more readable and maintainable way to work with asynchronous code by chaining methods,</st><a id="_idTextAnchor142"/><st c="22959"> such as </st><strong class="source-inline"><st c="22968">.then()</st></strong> <span class="No-Break"><st c="22975">and </st></span><span class="No-Break"><strong class="source-inline"><st c="22980">.catch()</st></strong></span><span class="No-Break"><st c="22988">.</st></span></p>
			<p><st c="22989">However, a new way of implementing promises has been introduced in new versions of JavaScript. </st><strong class="source-inline"><st c="23085">async</st></strong><st c="23090">/</st><strong class="source-inline"><st c="23092">await</st></strong><st c="23097"> is a clean and concise syntax for working with asynchronous operations. </st><st c="23170">It allows us to write asynchronous code that looks like synchronous code, making it easier to reason about and maintain. </st><st c="23291">Using the </st><strong class="source-inline"><st c="23301">async</st></strong><st c="23306"> keyword, we can define functions that can pause and resume execution using the </st><strong class="source-inline"><st c="23386">await</st></strong><st c="23391"> keyword, which waits for a promise to be resolved </st><span class="No-Break"><st c="23442">or rejected.</st></span></p>
			<p><st c="23454">In addition, another </st><a id="_idIndexMarker193"/><st c="23476">approach to asynchronous operations is to pass observables. </st><st c="23536">Observables are a powerful tool for managing data flows and asynchronous operations in reactive programming. </st><st c="23645">They represent a sequence of values that can be observed over time. </st><st c="23713">Observables can output multiple values asynchronously and provide a wide range of operators for transforming, filtering, and combining data streams. </st><st c="23862">They are commonly used in frameworks such as Angular to handle events, HTTP requests, and other asynchronous operations </st><span class="No-Break"><st c="23982">with RxJS.</st></span></p>
			<p><st c="23992">Asynchronous operations and observables also enable concurrency and parallelism in our code. </st><st c="24086">Concurrency refers to the ability to execute multiple tasks at the same time, while parallelism </st><a id="_idIndexMarker194"/><st c="24182">refers to executing tasks simultaneously across multiple processors or threads. </st><st c="24262">Asynchronous programming and observables allow us to handle multiple operations concurrently, improving performance in applications that require heavy computation </st><span class="No-Break"><st c="24425">or I/O.</st></span></p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor143"/><st c="24432">Handling asynchronous operations</st></h2>
			<p><st c="24465">Let’s consider that our </st><a id="_idIndexMarker195"/><st c="24490">calculator application that performs addition, subtraction, multiplication, and division now has a service that performs these operations and returns the result as </st><span class="No-Break"><st c="24654">an observable.</st></span></p>
			<p><st c="24668">First, let’s assume we have another calculator service called </st><strong class="source-inline"><st c="24731">CalculatorAsyncService</st></strong><st c="24753">, which we’ll create in the </st><strong class="source-inline"><st c="24781">services</st></strong><st c="24789"> folder. </st><st c="24798">We need to execute this command line in the terminal once in the </st><span class="No-Break"><strong class="source-inline"><st c="24863">services</st></strong></span><span class="No-Break"><st c="24871"> folder:</st></span></p>
			<pre class="console">
<strong class="bold"><st c="24879">$ ng g s calculator-async</st></strong></pre>			<p><st c="24905">After executing the command, here’s what we should have in the </st><span class="No-Break"><strong class="source-inline"><st c="24969">services</st></strong></span><span class="No-Break"><st c="24977"> folder:</st></span></p>
			<div>
				<div id="_idContainer075" class="IMG---Figure">
					<img src="image/B21146_04_9.jpg" alt="Figure 4.9 – Creation of the CalculatorAsyncService"/><st c="24985"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="25066">Figure 4.9 – Creation of the CalculatorAsyncService</st></p>
			<p><st c="25117">As opposed to the previous service we had to create, here we’ll essentially be doing asynchronous operations, in keeping with the subject we’re exploring. </st><st c="25273">Our service’s methods will be based on the same principle, that is, receiving the two operands related to our calculation as parameters, then performing them as observables (which emphasizes the asynchronous aspect) and returning the result at the end. </st><st c="25526">Based on the principles of TDD, we’ll look at what to expect using the </st><strong class="source-inline"><st c="25597">add()</st></strong><st c="25602"> method as an example. </st><st c="25625">In our </st><strong class="source-inline"><st c="25632">calculator-async.service.spec.ts</st></strong><st c="25664"> test file, we’ll add</st><a id="_idTextAnchor144"/><st c="25685"> this </st><span class="No-Break"><st c="25691">test case:</st></span></p>
			<pre class="source-code"><st c="25701">
  it('should add two numbers', fakeAsync(() =&gt; {
    let result = 0;
    service.add(1, 2).subscribe((val) =&gt; {
      result = val;
    });
    expect(result).toBe(3);
  }));</st></pre>			<p><st c="25850">The preceding code snippet is a unit test for a service method that adds two numbers using Angular’s </st><strong class="source-inline"><st c="25952">fakeAsync</st></strong><st c="25961"> utility to handle asynchronous operations synchronously. </st><st c="26019">Here is the </st><span class="No-Break"><st c="26031">code breakdown:</st></span></p>
			<ul>
				<li><strong class="source-inline"><st c="26046">fakeAsync</st></strong><st c="26056">: This is an Angular utility function that lets you write tests that rely on asynchronous operations synchronously. </st><st c="26173">It is useful for testing code that uses observables, promises, or other </st><span class="No-Break"><st c="26245">asynchronous operations</st><a id="_idTextAnchor145"/><st c="26268">.</st></span></li>
				<li><strong class="source-inline"><st c="26269">service.add(1, 2).</st><a id="_idTextAnchor146"/><st c="26288">subscribe((val) =&gt;</st><a id="_idTextAnchor147"/><st c="26307"> { result = val ; });</st></strong><st c="26328">: This line calls a service’s </st><strong class="source-inline"><st c="26359">add</st></strong><st c="26362"> method, passing two numbers (</st><strong class="source-inline"><st c="26392">1</st></strong><st c="26394"> and </st><strong class="source-inline"><st c="26399">2</st></strong><st c="26400">). </st><st c="26403">The </st><strong class="source-inline"><st c="26407">add()</st></strong><st c="26412"> method is supposed to return an observable that outputs the result of the addition. </st><st c="26497">The </st><strong class="source-inline"><st c="26501">subscribe</st></strong><st c="26510"> method is used to subscribe to this observable and manage the emitted value. </st><st c="26588">In this case, the output value is assigned to the </st><span class="No-Break"><st c="26638">result variable.</st></span></li>
			</ul>
			<p><st c="26654">Now we can run</st><a id="_idIndexMarker196"/><st c="26669"> our favorite </st><strong class="source-inline"><st c="26683">ng test</st></strong><st c="26690"> command from our </st><span class="No-Break"><st c="26708">project terminal:</st></span></p>
			<div>
				<div id="_idContainer076" class="IMG---Figure">
					<img src="image/B21146_04_10.jpg" alt="Figure 4.10 – Error in our test case related to the add method on the terminal"/><st c="26725"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="27076">Figure 4.10 – Error in our test case related to the add method on the terminal</st></p>
			<p><st c="27154">As we can see, our test failed. </st><st c="27187">This is normal, as this is the red phase. </st><st c="27229">We have </st><span class="No-Break"><st c="27237">two errors:</st></span></p>
			<ul>
				<li><st c="27248">The no</st><a id="_idTextAnchor148"/><st c="27255">n-existence of the </st><strong class="source-inline"><st c="27275">add()</st></strong><st c="27280"> method in </st><span class="No-Break"><st c="27291">our </st></span><span class="No-Break"><strong class="source-inline"><st c="27295">CalculatorAsyncService</st></strong></span></li>
				<li><st c="27317">The absence of the type of our </st><span class="No-Break"><strong class="source-inline"><st c="27349">val</st></strong></span><span class="No-Break"><st c="27352"> variable</st></span></li>
			</ul>
			<p><st c="27361">To fix this, here’s what we’ll do. </st><st c="27397">First, our </st><strong class="source-inline"><st c="27408">val</st></strong><st c="27411"> variable is the result of our calculation. </st><st c="27455">It is therefore of the type number. </st><st c="27491">So, we’ll d</st><a id="_idTextAnchor149"/><st c="27502">o </st><span class="No-Break"><st c="27505">the following:</st></span></p>
			<pre class="source-code"><st c="27519">
  it('should add two numbers', fakeAsync(() =&gt; {
    let result = 0;
    service.add(1, 2).subscribe((val: number) =&gt; {
      result = val;
    });
    expect(result).toBe(3);
  }));</st></pre>			<p><st c="27676">Here’s how it looks on </st><span class="No-Break"><st c="27700">the terminal:</st></span></p>
			<div>
				<div id="_idContainer077" class="IMG---Figure">
					<img src="image/B21146_04_11.jpg" alt="Figure 4.11 – Error in our test case related to the add method on the terminal"/><st c="27713"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="27910">Figure 4.11 – Error in our test case related to the add method on the terminal</st></p>
			<p><st c="27988">The error related to</st><a id="_idIndexMarker197"/><st c="28009"> the </st><strong class="source-inline"><st c="28014">val</st></strong><st c="28017"> variable has now disappeared, but the error relate</st><a id="_idTextAnchor150"/><st c="28068">d to our service’s </st><strong class="source-inline"><st c="28088">add()</st></strong><st c="28093"> method remains. </st><st c="28110">This is normal because our </st><strong class="source-inline"><st c="28137">CalculatorAsyncService</st></strong><st c="28159"> d</st><a id="_idTextAnchor151"/><st c="28161">oesn’t yet have an </st><strong class="source-inline"><st c="28180">add()</st></strong><st c="28185"> method. </st><st c="28194">Now we’re going to write the minimum code required for our test to pass. </st><a id="_idTextAnchor152"/><st c="28267">As a reminder, our </st><strong class="source-inline"><st c="28286">add()</st></strong><st c="28291"> method must return an observable. </st><st c="28326">Here’</st><a id="_idTextAnchor153"/><st c="28331">s the code for the </st><strong class="source-inline"><st c="28351">add()</st></strong><st c="28356"> method to be added to </st><span class="No-Break"><st c="28379">our </st></span><span class="No-Break"><strong class="source-inline"><st c="28383">Calcula</st><a id="_idTextAnchor154"/><st c="28390">torAsyncService</st></strong></span><span class="No-Break"><st c="28406">:</st></span></p>
			<pre class="source-code"><st c="28408">
  add(a: number, b: number): Observable&lt;nu</st><a id="_idTextAnchor155"/><st c="28449">mber&gt; {
    return of(a + b);
  }</st></pre>			<p><st c="28477">Here is a breakdown of t</st><a id="_idTextAnchor156"/><st c="28502">he </st><span class="No-Break"><st c="28506">p</st><a id="_idTextAnchor157"/><st c="28507">receding cod</st><a id="_idTextAnchor158"/><st c="28519">e:</st></span></p>
			<ul>
				<li><strong class="source-inline"><st c="28522">add(a :</st><a id="_idTextAnchor159"/><st c="28530"> number, b : number) : Observable&lt;number&gt;</st></strong><st c="28571">: This is the method signature. </st><st c="28604">Th</st><a id="_idTextAnchor160"/><st c="28606">e method is called </st><strong class="source-inline"><st c="28626">add()</st></strong><st c="28631"> and takes two parameters, </st><strong class="source-inline"><st c="28658">a</st></strong><st c="28659"> and </st><strong class="source-inline"><st c="28664">b</st></strong><st c="28665">, both of which are numbers. </st><st c="28694">The method returns an observable, which</st><a id="_idTextAnchor161"/><st c="28733"> outputs a number. </st><st c="28752">This indicates that the method is asynchronous and will produce a value at some point in </st><span class="No-Break"><st c="28841">th</st><a id="_idTextAnchor162"/><st c="28843">e future</st><a id="_idTextAnchor163"/><st c="28852">.</st></span></li>
				<li><strong class="source-inline"><st c="28853">return of(a + b);</st></strong><st c="28871">: This line uses RxJS’s </st><strong class="source-inline"><st c="28896">of</st></strong><st c="28898"> function to create an observable that outputs a single value and terminates. </st><st c="28976">The value emitted is the result </st><a id="_idTextAnchor164"/><st c="29008">of adding </st><strong class="source-inline"><st c="29018">a</st></strong><st c="29019"> and </st><strong class="source-inline"><st c="29024">b</st></strong><st c="29025">. The </st><strong class="source-inline"><st c="29031">of</st></strong><st c="29033"> function is a utility function that converts the given arguments into an observable sequence. </st><st c="29128">In this case, it is used to create an observable that outputs the sum of </st><strong class="source-inline"><st c="29201">a</st></strong><st c="29202"> and </st><strong class="source-inline"><st c="29207">b</st></strong><st c="29208">. Don’t forget to </st><span class="No-Break"><st c="29226">import it.</st></span></li>
			</ul>
			<p><st c="29236">Afte</st><a id="_idTextAnchor165"/><st c="29241">r implementing the </st><strong class="source-inline"><st c="29261">add()</st></strong><st c="29266"> method, here’s the result in </st><span class="No-Break"><st c="29296">our terminal:</st></span></p>
			<div>
				<div id="_idContainer078" class="IMG---Figure">
					<img src="image/B21146_04_12.jpg" alt="Figure 4.12 – add asynchronous method test case succeeded on the terminal"/><st c="29309"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="29360">Figure 4.12 – add asynchronous method test case succeeded on the terminal</st></p>
			<p><st c="29433">And in our b</st><a id="_idTextAnchor166"/><st c="29446">rowser running on Karma, we </st><span class="No-Break"><st c="29475">have this:</st></span></p>
			<div>
				<div id="_idContainer079" class="IMG---Figure">
					<img src="image/B21146_04_13.jpg" alt="Figure 4.13 – add asynchronous method test case succeede﻿d in the browser"/><st c="29485"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="29555">Figure 4.13 – add asynchronous method test case succeede</st><a id="_idTextAnchor167"/><st c="29611">d in the browser</st></p>
			<p><st c="29628">Well done! </st><st c="29640">We’ve just </st><a id="_idIndexMarker198"/><st c="29651">implemented our calculator’s first asynchronous method using TDD principles. </st><st c="29728">We’ll now do the same with subtraction, multiplication, </st><span class="No-Break"><st c="29784">and division.</st></span></p>
			<p><st c="29797">In our </st><strong class="source-inline"><st c="29805">calculator-async.service.spec.ts</st></strong><st c="29837"> test file, we’re going to write the expected tests related to our subtraction, multiplication, and division operators. </st><st c="29957">Usually, we’d do these separately, but as we’ve alre</st><a id="_idTextAnchor168"/><st c="30009">ady seen with the </st><strong class="source-inline"><st c="30028">add()</st></strong><st c="30033"> method, we’ll do them all at once. </st><st c="30069">Here’</st><a id="_idTextAnchor169"/><st c="30074">s what </st><span class="No-Break"><st c="30082">we’ll get:</st></span></p>
			<pre class="source-code"><st c="30092">
it('should subtract two numbers', fakeAsync(() =&gt; {
    let result = 0;
    ser</st><a id="_idTextAnchor170"/><st c="30164">vice.subtract(5, 3).subscribe((val: number) =&gt; {
      result = val;
    });
    expect(result).to</st><a id="_idTextAnchor171"/><st c="30249">Be(2);
  }));
  it('should multiply two numbers', fakeAsync(() =&gt; {
    let result = 0;
    ser</st><a id="_idTextAnchor172"/><st c="30333">vice.multiply(3, 4).subscribe((val: number) =&gt; {
      result = val;
    });
    expect(result).toB</st><a id="_idTextAnchor173"/><st c="30419">e(12);
  }));
  it('should divide two numbers', fakeAsync(() =&gt; {
    let result = 0;
    se</st><a id="_idTextAnchor174"/><st c="30500">rvice.divide(10, 2).subscribe((val: number) =&gt; {
      result = val;
    });
    expect(result).toBe(5);
  }));</st></pre>			<p><st c="30596">As you may have </st><a id="_idIndexMarker199"/><st c="30613">noticed in your terminal, we have </st><span class="No-Break"><st c="30647">these errors:</st></span></p>
			<div>
				<div id="_idContainer080" class="IMG---Figure">
					<img src="image/B21146_04_14.jpg" alt="Figure 4.14 – Error in our test case related to the subtract, multiply, and divide methods on the terminal"/><st c="30660"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="31246">Figure 4.14 – Error in our test case related to the subtract, multiply, and divide methods on the terminal</st></p>
			<p><st c="31352">These errors are due to the absence of the </st><strong class="source-inline"><st c="31396">subtract</st></strong><st c="31404">, </st><strong class="source-inline"><st c="31406">multiply</st></strong><st c="31414">, and </st><strong class="source-inline"><st c="31420">divide</st></strong><st c="31426"> methods in our </st><strong class="source-inline"><st c="31442">CalculatorAsyncService</st></strong><st c="31464">. As we had to do for the </st><strong class="source-inline"><st c="31490">add</st></strong><st c="31493"> method, we’ll add the minimum amount of code needed to make our tests go green. </st><st c="31574">In our </st><strong class="source-inline"><st c="31581">CalculatorAsyncService</st></strong><st c="31603">, we’ll add</st><a id="_idTextAnchor175"/> <span class="No-Break"><st c="31614">these methods:</st></span></p>
			<pre class="source-code"><st c="31629">
  subtract(a: number, b: number): Observable&lt;num</st><a id="_idTextAnchor176"/><st c="31676">ber&gt; {
    return o</st><a id="_idTextAnchor177"/><st c="31692">f(a - b);
  }
  multiply(a: number, b: number): Observable&lt;num</st><a id="_idTextAnchor178"/><st c="31751">ber&gt; {
    return o</st><a id="_idTextAnchor179"/><st c="31767">f(a * b);
  }
  divide(a: number, b: number): Observable&lt;num</st><a id="_idTextAnchor180"/><st c="31824">ber&gt; {
    return of(a / b);
  }</st></pre>			<p><st c="31851">On our terminal, we</st><a id="_idIndexMarker200"/><st c="31871"> have </st><span class="No-Break"><st c="31877">the following:</st></span></p>
			<div>
				<div id="_idContainer081" class="IMG---Figure">
					<img src="image/B21146_04_15.jpg" alt="Figure 4.15 – subtract, multiply, and divide asynchronous methods test cases succeeded on the terminal"/><st c="31891"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="32320">Figure 4.15 – subtract, multiply, and divide asynchronous methods test cases succeeded on the terminal</st></p>
			<p><st c="32422">And in our browser, we have </st><span class="No-Break"><st c="32451">the following:</st></span></p>
			<div>
				<div id="_idContainer082" class="IMG---Figure">
					<img src="image/B21146_04_16.jpg" alt="Figure 4.16 – subtract, multiply, and divide asynchronous methods test cases succeeded on the browser"/><st c="32465"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="32615">Figure 4.16 – subtract, multiply, and divide asynchronous methods test cases succeeded on the browser</st></p>
			<p><st c="32716">All our tests </st><span class="No-Break"><st c="32731">are green!</st></span></p>
			<p><st c="32741">However, there’s one case we haven’t yet tested at the divi</st><a id="_idTextAnchor181"/><st c="32801">sion level. </st><st c="32814">It’s </st><strong class="source-inline"><st c="32819">division by zero</st></strong><st c="32835">. As with the </st><strong class="source-inline"><st c="32849">CalculatorService</st></strong><st c="32866"> service previously, we also need to handle division by 0 by raising an exception or returning an error message. </st><st c="32979">So, at the </st><strong class="source-inline"><st c="32990">CalculatorAsyncService</st></strong><st c="33012"> level, we’re going to add a second test case related to division, which handles the case where we don’t try to divide </st><a id="_idTextAnchor182"/><st c="33131">a number </st><span class="No-Break"><st c="33140">by 0:</st></span></p>
			<pre class="source-code"><st c="33145">
  it('should throw an error when dividing by zero', fakeAsync(() =&gt; {</st><a id="_idTextAnchor183"/><st c="33213">
    let err</st><a id="_idTextAnchor184"/><st c="33221">or = { message: '' }; ;
    ser</st><a id="_idTextAnchor185"/><st c="33249">vice.divide(10, 0).subscribe({
      error: (err) =&gt; (error = err),
    });
    expect(error).toBeTruthy();
    expect(error.message).toBe('Cannot divide by zero');
  }));</st></pre>			<p><st c="33401">Here’s a </st><a id="_idIndexMarker201"/><st c="33411">breakdown of </st><span class="No-Break"><st c="33424">the code:</st></span></p>
			<ul>
				<li><strong class="source-inline"><st c="33433">se</st><a id="_idTextAnchor186"/><st c="33436">rvice.divid</st><a id="_idTextAnchor187"/><st c="33448">e(10, 0).subscribe({ error : (err</st><a id="_idTextAnchor188"/><st c="33482">) =</st><a id="_idTextAnchor189"/><st c="33486">&gt; (error = err), });</st></strong><st c="33507">: This line calls a service’s </st><strong class="source-inline"><st c="33538">divide</st></strong><st c="33544"> method with arguments </st><strong class="source-inline"><st c="33567">10</st></strong><st c="33569"> and </st><strong class="source-inline"><st c="33574">0</st></strong><st c="33575">. The </st><strong class="source-inline"><st c="33581">divide</st></strong><st c="33587"> method is expected to return an observable. </st><st c="33632">The </st><strong class="source-inline"><st c="33636">subscribe</st></strong><st c="33645"> method is used to subscribe to the observable. </st><st c="33693">The object passed to </st><strong class="source-inline"><st c="33714">subscribe</st></strong><st c="33723"> specifies how to handle the case of an error. </st><st c="33770">If an error occurs during division (which will happen, since division by zero is not defined), the error-handling function </st><strong class="source-inline"><st c="33893">(err) =&gt; (error = err)</st></strong><st c="33915"> is executed, assigning the error message to the </st><span class="No-Break"><strong class="source-inline"><st c="33964">error</st></strong></span><span class="No-Break"><st c="33969"> variable.</st></span></li>
				<li><strong class="source-inline"><st c="33979">expect(</st><a id="_idTextAnchor190"/><st c="33987">error).toBeTruthy();</st></strong><st c="34008">: This line asserts that the </st><strong class="source-inline"><st c="34038">error</st></strong><st c="34043"> variable is true, that is, that it has a value. </st><st c="34092">This is a basic check to ensure that an error has </st><span class="No-Break"><st c="34142">been triggered.</st></span></li>
				<li><strong class="source-inline"><st c="34157">expect(error.message).toBe('Cann</st><a id="_idTextAnchor191"/><st c="34190">ot divide by zero');</st></strong><st c="34211">: This line asserts that the </st><strong class="source-inline"><st c="34241">message</st></strong><st c="34248"> property of the </st><strong class="source-inline"><st c="34265">error</st></strong><st c="34270"> object is equal to the </st><strong class="source-inline"><st c="34294">'Cannot divide by zero'</st></strong> <strong class="source-inline"><st c="34317">string</st></strong><st c="34324">. This is the specific error message expected when attempting to divide </st><span class="No-Break"><st c="34396">by zero.</st></span></li>
			</ul>
			<p><st c="34404">After adding our test case, let’s see what happens on </st><span class="No-Break"><st c="34459">our terminal:</st></span></p>
			<div>
				<div id="_idContainer083" class="IMG---Figure">
					<img src="image/B21146_04_17.jpg" alt="Figure 4.17 – Asynchronous division-by-0 test case failed on the terminal"/><st c="34472"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="35418">Figure 4.17 – Asynchronous division-by-0 test case failed on the terminal</st></p>
			<p><st c="35491">And in our </st><a id="_idIndexMarker202"/><st c="35503">browser, we have </st><span class="No-Break"><st c="35520">the following:</st></span></p>
			<div>
				<div id="_idContainer084" class="IMG---Figure">
					<img src="image/B21146_04_18.jpg" alt="" role="presentation"/><st c="35534"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="36779">Figure 4.18 – Asynchronous division-by-0 test case failed in the browser</st></p>
			<p><st c="36851">This error is to be expected because we haven’t yet handled it in our </st><strong class="source-inline"><st c="36922">CalculatorAsyncService</st></strong><st c="36944"> service. </st><st c="36954">We’re now going to write the minimal code needed to resolve this error. </st><st c="37026">In our </st><strong class="source-inline"><st c="37033">CalculatorAsyncService</st></strong><st c="37055"> service, we’re going to modify ou</st><a id="_idTextAnchor192"/><st c="37089">r </st><span class="No-Break"><strong class="source-inline"><st c="37092">divide</st></strong></span><span class="No-Break"><st c="37098"> method:</st></span></p>
			<pre class="source-code"><st c="37106">
divide(a: number, b: number): Observable&lt;number&gt; {
    if (b === 0) {
      return thro</st><a id="_idTextAnchor193"/><st c="37184">wError(() =&gt; new Error('Cannot divide by zero'));
</st><a id="_idTextAnchor194"/><st c="37235">    }
  </st><a id="_idTextAnchor195"/><st c="37237">  return of(a / b).pipe(
      catchError((error) =&gt; {
        return throwError(() =&gt; error);
      })
    );
  }</st></pre>			<p><st c="37323">Here’s a breakdown of </st><span class="No-Break"><st c="37346">the code:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="37355">Error handling for division by zero</st></strong><st c="37391">: The method first checks whether </st><strong class="source-inline"><st c="37426">b</st></strong><st c="37427"> is equal to 0 using </st><strong class="source-inline"><st c="37448">if (b === 0)</st></strong><st c="37460">. If </st><strong class="source-inline"><st c="37465">b</st></strong><st c="37466"> is equal to 0, it returns an observable that immediately throws an error with the message </st><strong class="source-inline"><st c="37557">Cannot divide by zero</st></strong><st c="37578">. To do this, we use RxJS’s </st><strong class="source-inline"><st c="37606">throwError</st></strong><st c="37616"> function, which creates an observable that emits no elements and immediately issues an </st><span class="No-Break"><st c="37704">error notification.</st></span></li>
				<li><strong class="bold"><st c="37723">Execute division</st></strong><st c="37740">: If </st><strong class="source-inline"><st c="37746">b</st></strong><st c="37747"> is not 0, the method performs the </st><strong class="source-inline"><st c="37782">a / b</st></strong><st c="37787"> division operation and wraps </st><a id="_idIndexMarker203"/><st c="37817">the result in an observable using the RxJS </st><strong class="source-inline"><st c="37860">of</st></strong><st c="37862"> function. </st><st c="37873">This function creates an observable that outputs the specified value, </st><span class="No-Break"><st c="37943">then terminates.</st></span></li>
				<li><strong class="bold"><st c="37959">Handling other errors</st></strong><st c="37981">: The </st><strong class="source-inline"><st c="37988">divide</st></strong><st c="37994"> operation is then routed through the </st><strong class="source-inline"><st c="38032">catchError</st></strong><st c="38042"> operator. </st><st c="38053">This operator catches any errors that occur during the execution of the observable chain and allows you to handle them. </st><st c="38173">In this case, the </st><strong class="source-inline"><st c="38191">catchError</st></strong><st c="38201"> operator is used to catch any errors that may occur during the </st><strong class="source-inline"><st c="38265">divide</st></strong><st c="38271"> operation and throw them back using the </st><strong class="source-inline"><st c="38312">throwError</st></strong><st c="38322"> function. </st><st c="38333">This ensures that if an error occurs (other than division by zero, which is explicitly handled), the observable will issue an </st><span class="No-Break"><st c="38459">error notification.</st></span></li>
				<li><strong class="bold"><st c="38478">Observable return</st></strong><st c="38496">: Finally, the method returns the observable created by the </st><strong class="source-inline"><st c="38557">of</st></strong><st c="38559"> function, which outputs the result of the division operation, or the observable created by the </st><strong class="source-inline"><st c="38655">throwError</st></strong><st c="38665"> function in the event of </st><span class="No-Break"><st c="38691">an error.</st></span></li>
			</ul>
			<p><st c="38700">After adding our test case, let’s see what happens on </st><span class="No-Break"><st c="38755">our terminal:</st></span></p>
			<div>
				<div id="_idContainer085" class="IMG---Figure">
					<img src="image/B21146_04_19.jpg" alt="Figure 4.19 – Asynchronous division-by-0 test case succeeded on the terminal"/><st c="38768"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="38924">Figure 4.19 – Asynchronous division-by-0 test case succeeded on the terminal</st></p>
			<p><st c="39000">And in our browser, we have </st><span class="No-Break"><st c="39029">the following:</st></span></p>
			<div>
				<div id="_idContainer086" class="IMG---Figure">
					<img src="image/B21146_04_20.jpg" alt="Figure 4.20 – Asynchronous division-by-0 test case succeeded on the browser"/><st c="39043"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="39234">Figure 4.20 – Asynchronous division-by-0 test case succeeded on the browser</st></p>
			<p><st c="39309">Error handling is an essential part of working with asynchronous operations. </st><st c="39387">In our calculator application, if an error occurs while retrieving data or performing calculations, we can display an</st><a id="_idIndexMarker204"/><st c="39504"> error message to the user and provide options for retrying or handling the error in an elegant way. </st><st c="39605">The RxJS module provides error-handling mechanisms, such as the use of the </st><span class="No-Break"><strong class="source-inline"><st c="39680">catchError</st></strong></span><span class="No-Break"><st c="39690"> operator.</st></span></p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor196"/><st c="39700">Emphasizing the importance of testing async operations</st></h2>
			<p><st c="39755">In a calculator app, async </st><a id="_idIndexMarker205"/><st c="39783">operations can include fetching data from an API, performing calculations asynchronously, or handling user input events. </st><st c="39904">Properly testing these async operations is essential to ensure that the app functions correctly, provides accurate results, and handles </st><span class="No-Break"><st c="40040">errors gracefully.</st></span></p>
			<p><st c="40058">Unit testing is a fundam</st><a id="_idTextAnchor197"/><st c="40083">ental approach to testing individual components or functions in isolation. </st><st c="40159">In the context of async operations in Angular, unit tests play a crucial role in verifying the behavior of code that handles async tasks. </st><st c="40297">For example, you can write unit tests to verify that an API service correctly fetches exchange rates or that a calculation service accurately performs </st><span class="No-Break"><st c="40448">calculations asynchronously.</st></span></p>
			<p><st c="40476">To effectively test async operations, it is essential to mock dependencies, such as API services or calculation functions. </st><st c="40600">By mocking these dependencies, you can control the behavior of external services or functions during testing, allowing you to focus on the specific code that handles async operations. </st><st c="40784">Angular provides tools such as TestBed and Jasmine spies to mock </st><span class="No-Break"><st c="40849">dependencies effectively.</st></span></p>
			<p><st c="40874">Testing async operations often involves dealing with timing issues. </st><st c="40943">For example, when testing a function that performs an async calculation, you need to ensure that the test waits for the calculation to be completed before making assertions. </st><st c="41117">Angular provides utilities, such as </st><strong class="source-inline"><st c="41153">fakeAsync</st></strong><st c="41162">, that allow you to control the timing of async operations in your tests, making it easier to write accurate and </st><span class="No-Break"><st c="41275">deterministic tests.</st></span></p>
			<p><st c="41295">While unit testing is essential, it is equally important to perform integration testing to validate the interaction between different components in your calculator app. </st><st c="41465">Integration tests can verify that async operations, such as fetching data and performing calculations, are correctly integrated into the overall functionality of the app. </st><st c="41636">For example, you can write integration tests to ensure that the UI is updated correctly when async operations </st><span class="No-Break"><st c="41746">are complete.</st></span></p>
			<p><st c="41759">Testing error handling is crucial in async operations. </st><st c="41815">For example, when fetching data from an API, you need to test scenarios where the API returns an error response. </st><st c="41928">By simulating error conditions in your tests, you can verify that the app handles errors gracefully, displays appropriate error messages, and provides fallback mechanisms. </st><st c="42100">Angular’s </st><strong class="source-inline"><st c="42110">HttpClient</st></strong><st c="42120"> module provides mechanisms for mocking API responses and testing different </st><span class="No-Break"><st c="42196">error scenarios.</st></span></p>
			<p><strong class="bold"><st c="42212">End-to-end</st></strong><st c="42223"> (</st><strong class="bold"><st c="42225">E2E</st></strong><st c="42228">) testing is</st><a id="_idIndexMarker206"/><st c="42241"> essential to validate the entire system’s behavior, including the async operations in your calculator app. </st><st c="42349">E2E tests simulate real-world user interactions and validate the app’s functionality from a user’s perspective. </st><st c="42461">By writing E2E tests that </st><a id="_idIndexMarker207"/><st c="42487">cover scenarios involving async operations, you can ensure that the app functions correctly and provides a seamless </st><span class="No-Break"><st c="42603">user experience.</st></span></p>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor198"/><st c="42619">Summary</st></h1>
			<p><st c="42627">In this chapter, we covered three important topics related to testing in Angular: method stubs and spies, TestBed providers, and handling async operations and </st><span class="No-Break"><st c="42787">complex scenarios.</st></span></p>
			<p><st c="42805">Firstly, we explored the concept of method stubs and spies, which allowed us to monitor and control the calls to dependencies in our tests. </st><st c="42946">We learned how to create method stubs using Jasmine’s </st><strong class="source-inline"><st c="43000">spyOn</st></strong><st c="43005"> function, which enabled us to replace a method’s implementation with our own custom behavior. </st><st c="43100">This allowed us to test our code in isolation and ensure that it behaved </st><span class="No-Break"><st c="43173">as expected.</st></span></p>
			<p><st c="43185">Next, we delved into TestBed providers, which are used to inject mocked dependencies into our tests. </st><st c="43287">We learned how to use the </st><strong class="source-inline"><st c="43313">TestBed.configureTestingModule</st></strong><st c="43343"> method to configure our test module and provide mocked instances of dependencies. </st><st c="43426">This technique allowed us to control the behavior of dependencies and focus on testing specific scenarios without relying on </st><span class="No-Break"><st c="43551">real implementations.</st></span></p>
			<p><st c="43572">Lastly, we tackled the challenges of handling async operations and complex scenarios in our tests. </st><st c="43672">We explored techniques such as using the fakeAsync function to handle asynchronous code. </st><st c="43761">These techniques enabled us to write reliable tests for scenarios involving asynchronous operations and </st><a id="_idTextAnchor199"/><span class="No-Break"><st c="43865">complex dependencies.</st></span></p>
			<p><st c="43886">In the next chapter, we’ll learn how to test Angular’s pipes, forms, and </st><span class="No-Break"><st c="43960">reactive programming.</st></span></p>
		</div>
	<div id="charCountTotal" value="43981"/></body></html>