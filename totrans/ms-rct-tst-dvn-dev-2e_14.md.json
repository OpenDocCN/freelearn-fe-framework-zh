["```js\ncombineReducers({\n  script: scriptReducer\n})\n```", "```js\ncombineReducers({\n  script: withUndoRedo(scriptReducer)\n})\n```", "```js\n    import {\n      withUndoRedo\n    } from \"../../src/reducers/withUndoRedo\";\n    describe(\"withUndoRedo\", () => {\n      let decoratedReducerSpy;\n      let reducer;\n      beforeEach(() => {\n        decoratedReducerSpy = jest.fn();\n        reducer = withUndoRedo(decoratedReducerSpy);\n      });\n      describe(\"when initializing state\", () => {\n        it(\"calls the decorated reducer with undefined state and an action\", () => {\n          const action = { type: \"UNKNOWN\" };\n          reducer(undefined, action);\n          expect(decoratedReducerSpy).toBeCalledWith(\n            undefined,\n            action);\n        });\n      });\n    });\n    ```", "```js\n    export const withUndoRedo = (reducer) => {\n      return (state, action) => {\n        reducer(state, action);\n      };\n    };\n    ```", "```js\n    it(\"returns a value of what the inner reducer returns\", () => {\n      decoratedReducerSpy.mockReturnValue({ a: 123 });\n      expect(reducer(undefined)).toMatchObject(\n        { a : 123 }\n      );\n    });\n    ```", "```js\n    export const withUndoRedo = (reducer) => {\n      return (state, action) => {\n    return reducer(state, action);\n      };\n    }\n    ```", "```js\n    it(\"cannot undo\", () => {\n      expect(reducer(undefined)).toMatchObject({\n        canUndo: false\n      });\n    });\n    it(\"cannot redo\", () => {\n      expect(reducer(undefined)).toMatchObject({\n        canRedo: false\n      });\n    });\n    ```", "```js\n    export const withUndoRedo = (reducer) => {\n      return (state, action) => {\n        return {\n          canUndo: false,\n          canRedo: false,\n          ...reducer(state, action)\n        };\n      };\n    }\n    ```", "```js\n    describe(\"performing an action\", () => {\n      const innerAction = { type: \"INNER\" };\n      const present = { a: 123 };\n      const future = { b: 234 };\n      beforeEach(() => {\n        decoratedReducerSpy.mockReturnValue(future);\n      });\n      it(\"can undo after a new present has been provided\", () => {\n        const result = reducer(\n          { canUndo: false, present },\n          innerAction\n        );\n        expect(result.canUndo).toBeTruthy();\n      });\n    });\n    ```", "```js\n    export const withUndoRedo = (reducer) => {\n      return (state, action) => {\n        if (state === undefined)\n          return {\n            canUndo: false,\n            canRedo: false,\n            ...reducer(state, action)\n          };\n        return {\n          canUndo: true\n        };\n      };\n    };\n    ```", "```js\n    it(\"forwards action to the inner reducer\", () => {\n      reducer(present, innerAction);\n      expect(decoratedReducerSpy).toBeCalledWith(\n        present,\n        innerAction\n      );\n    });\n    ```", "```js\n    if (state === undefined)\n      ...\n    reducer(state, action);\n    return {\n      canUndo: true\n    };\n    ```", "```js\n    it(\"returns the result of the inner reducer\", () => {\n      const result = reducer(present, innerAction);\n      expect(result).toMatchObject(future);\n    });\n    ```", "```js\n    const newPresent = reducer(state, action);\n    return {\n      ...newPresent,\n      canUndo: true\n    };\n    ```", "```js\n    const present = { a: 123, nextInstructionId: 0 };\n    const future = { b: 234, nextInstructionId: 1 };\n    ...\n    it(\"returns the previous state if nextInstructionId does not increment\", () => {\n      decoratedReducerSpy.mockReturnValue({\n        nextInstructionId: 0\n      });\n      const result = reducer(present, innerAction);\n      expect(result).toBe(present);\n    });\n    ```", "```js\n    const newPresent = reducer(state, action);\n    if (\n      newPresent.nextInstructionId !=\n      state.nextInstructionId\n    ) {\n      return {\n        ...newPresent,\n        canUndo: true \n      };\n    }\n    return state;\n    ```", "```js\n    describe(\"withUndoRedo\", () => {\n      const undoAction = { type: \"UNDO\" };\n      const innerAction = { type: \"INNER\" };\n      const present = { a: 123, nextInstructionId: 0 };\n      const future = { b: 234, nextInstructionId: 1 };\n      ...\n    });\n    ```", "```js\n    describe(\"undo\", () => {\n     let newState;\n      beforeEach(() => {\n        decoratedReducerSpy.mockReturnValue(future);\n        newState = reducer(present, innerAction);\n      });\n      it(\"sets present to the latest past entry\", () => {\n        const updated = reducer(newState, undoAction);\n        expect(updated).toMatchObject(present);\n      });\n    });\n    ```", "```js\n    export const withUndoRedo = (reducer) => {\n      let past;\n      return (state, action) => {\n        if (state === undefined)\n          ...\n        switch(action.type) {\n          case \"UNDO\":\n    return past; \n          default:\n            const newPresent = reducer(state, action);\n            if (\n              newPresent.nextInstructionId !=\n              state.nextInstructionId\n            ) {\n              past = state;\n              return {\n                ...newPresent,\n                canUndo: true\n              };\n            }\n            return state;\n        }\n      };\n    };\n    ```", "```js\n    it(\"can undo multiple levels\", () => {\n      const futureFuture = {\n        c: 345, nextInstructionId: 3\n      };\n      decoratedReducerSpy.mockReturnValue(futureFuture);\n      newState = reducer(newState, innerAction);\n      const updated = reducer(\n        reducer(newState, undoAction),\n        undoAction\n      );\n\n      expect(updated).toMatchObject(present);\n    });\n    ```", "```js\n    export const withUndoRedo = (reducer) => {\n      let past = [];\n      return (state, action) => {\n        if (state === undefined)\n          ... \n        switch(action.type) {\n          case \"UNDO\":\n            const lastEntry = past[past.length - 1];\n            past = past.slice(0, -1);\n            return lastEntry;\n          default:\n            const newPresent = reducer(state, action);\n            if (\n              newPresent.nextInstructionId !=\n              state.nextInstructionId\n            ) {\n              past = [ ...past, state ];\n              return {\n                ...newPresent,\n                canUndo: true\n              };\n            }\n            return state;\n        }\n      };\n    };\n    ```", "```js\n    it(\"sets canRedo to true after undoing\", () => {\n      const updated = reducer(newState, undoAction);\n      expect(updated.canRedo).toBeTruthy();\n    });\n    ```", "```js\n    case \"UNDO\":\n      const lastEntry = past[past.length - 1];\n      past = past.slice(0, -1);\n      return {\n        ...lastEntry,\n        canRedo: true\n      };\n    ```", "```js\n    describe(\"withUndoRedo\", () => {\n      const undoAction = { type: \"UNDO\" };\n      const redoAction = { type: \"REDO\" };\n      ...\n    });\n    ```", "```js\n    describe(\"redo\", () => {\n      let newState;\n      beforeEach(() => {\n        decoratedReducerSpy.mockReturnValueOnce(future);\n        newState = reducer(present, innerAction);\n        newState = reducer(newState, undoAction);\n      });\n      it(\"sets the present to the latest future entry\", () => {\n        const updated = reducer(newState, redoAction);\n        expect(updated).toMatchObject(future);\n      });\n    });\n    ```", "```js\n    let past = [], future;\n    ```", "```js\n      case \"UNDO\":\n        const lastEntry = past[past.length - 1];\n        past = past.slice(0, -1);\n        future = state;\n    ```", "```js\n    case \"UNDO\":\n      ...\n    case \"REDO\":\n      return future;\n    default:\n      ...\n    ```", "```js\n    const future = { b: 234, nextInstructionId: 1 };\n    const futureFuture = { c: 345, nextInstructionId: 3 };\n    ```", "```js\n    beforeEach(() => {\n      decoratedReducerSpy.mockReturnValueOnce(future);\n      decoratedReducerSpy.mockReturnValueOnce(\n        futureFuture\n      );\n      newState = reducer(present, innerAction);\n      newState = reducer(newState, innerAction);\n      newState = reducer(newState, undoAction);\n      newState = reducer(newState, undoAction);\n    });\n    ```", "```js\n    it(\"can redo multiple levels\", () => {\n      const updated = reducer(\n        reducer(newState, redoAction),\n        redoAction\n      );\n      expect(updated).toMatchObject(futureFuture);\n    });\n    ```", "```js\n    let past = [], future = [];\n    ```", "```js\n    case \"UNDO\":\n      const lastEntry = past[past.length - 1];\n      past = past.slice(0, -1);\n      future = [ ...future, state ];\n    ```", "```js\n    case \"REDO\":\n      const nextEntry = future[future.length - 1];\n      future = future.slice(0, -1);\n      return nextEntry;\n    ```", "```js\n    it(\"returns to previous state when followed by an undo\", () => {\n      const updated = reducer(\n        reducer(newState, redoAction),\n        undoAction\n      );\n      expect(updated).toMatchObject(present);\n    });\n    ```", "```js\n    case \"REDO\":\n      const nextEntry = future[future.length - 1];\n      past = [ ...past, state ];\n      future = future.slice(0, -1);\n      return nextEntry;\n    ```", "```js\nit(\"return undefined when attempting a do, undo, do, redo sequence\", () => {\n  decoratedReducerSpy.mockReturnValue(future);\n  let newState = reducer(present, innerAction);\n  newState = reducer(newState, undoAction);\n  newState = reducer(newState, innerAction);\n  newState = reducer(newState, redoAction);\n  expect(newState).not.toBeDefined();\n});\n```", "```js\n    if (\n      newPresent.nextInstructionId !=\n      state.nextInstructionId\n    ) {\n      past = [ ...past, state ];\n      future = [];\n      return {\n        ...newPresent,\n        canUndo: true\n      };\n    }\n    ```", "```js\n    import {\n      withUndoRedo\n    } from \"./reducers/withUndoRedo\";\n    export const configureStore = (\n      storeEnhancers = [],\n      initialState = {}\n    ) => {\n      return createStore(\n        combineReducers({\n          script: withUndoRedo(scriptReducer)\n        }),\n        initialState,\n        compose(...storeEnhancers)\n      );\n    };\n    ```", "```js\n    describe(\"undo button\", () => {\n      it(\"renders\", () => {\n        renderWithStore(<MenuButtons />);\n        expect(buttonWithLabel(\"Undo\")).not.toBeNull();\n      });\n    });\n    ```", "```js\n    export const MenuButtons = () => {\n      ...\n      return (\n        <>\n          <button>Undo</button>\n          <button\n            onClick={() => dispatch(reset())}\n            disabled={!canReset}\n          >\n            Reset\n          </button>\n        </>\n      );\n    };\n    ```", "```js\n    it(\"is disabled if there is no history\", () => {\n      renderWithStore(<MenuButtons />);\n      expect(\n        buttonWithLabel(\"Undo\").hasAttribute(\"disabled\")\n      ).toBeTruthy();\n    });\n    ```", "```js\n    <button disabled={true}>Undo</button>\n    ```", "```js\n    it(\"is enabled if an action occurs\", () => {\n      renderWithStore(<MenuButtons />);\n      dispatchToStore({\n        type: \"SUBMIT_EDIT_LINE\",\n        text: \"forward 10\\n\"\n      });\n      expect(\n        buttonWithLabel(\"Undo\").hasAttribute(\"disabled\")\n      ).toBeFalsy();\n    });\n    ```", "```js\n    export const MenuButtons = () => {\n      const {\n        canUndo, nextInstructionId\n      } = useSelector(({ script }) => script);\n      ...\n      const canReset = nextInstructionId !== 0;\n      return (\n        <>\n          <button disabled={!canUndo}>Undo</button>\n          <button\n            onClick={() => dispatch(reset())}\n            disabled={!canReset}\n          >\n            Reset\n          </button>\n        </>\n      );\n      }\n    );\n    ```", "```js\n    it(\"dispatches an action of UNDO when clicked\", () => {\n      renderWithStore(<MenuButtons />);\n      dispatchToStore({\n        type: \"SUBMIT_EDIT_LINE\",\n        text: \"forward 10\\n\"\n      });\n      click(buttonWithLabel(\"Undo\"));\n      return expectRedux(store)\n        .toDispatchAnAction()\n        .matching({ type: \"UNDO\" });\n    });\n    ```", "```js\n    const reset = () => ({ type: \"RESET\" });\n    const undo = () => ({ type: \"UNDO\" });\n    export const MenuButtons = () => {\n      ...\n      return (\n        <>\n          <button\n            onClick={() => dispatch(undo())}\n            disabled={!canUndo}\n          >\n            Undo\n          </button>\n          ...\n        </>\n      );\n    };\n    ```", "```js\n    import {\n      save\n    } from \"../../src/middleware/localStorage\";\n    describe(\"localStorage\", () => {\n      const data = { a: 123 };\n      let getItemSpy = jest.fn();\n      let setItemSpy = jest.fn();\n      beforeEach(() => {\n        Object.defineProperty(window, \"localStorage\", {\n          value: {\n            getItem: getItemSpy,\n            setItem: setItemSpy\n          }});\n      });\n    });\n    ```", "```js\n    describe(\"save middleware\", () => {\n      const name = \"script name\";\n      const parsedTokens = [\"forward 10\"];\n      const state = { script: { name, parsedTokens } };\n      const action = { type: \"ANYTHING\" };\n      const store = { getState: () => state };\n      let next;\n      beforeEach(() => {\n        next = jest.fn();\n      });\n      const callMiddleware = () =>\n        save(store)(next)(action);\n      it(\"calls next with the action\", () => {\n        callMiddleware();\n        expect(next).toBeCalledWith(action);\n      });\n    });\n    ```", "```js\n    export const save = store => next => action => {\n      next(action);\n    };\n    ```", "```js\n    it(\"returns the result of next action\", () => {\n      next.mockReturnValue({ a : 123 });\n      expect(callMiddleware()).toEqual({ a: 123 });\n    });\n    ```", "```js\n    export const save = store => next => action => {\n    return next(action);\n    };\n    ```", "```js\n    it(\"saves the current state of the store in localStorage\", () => {\n      callMiddleware();\n      expect(setItemSpy).toBeCalledWith(\"name\", name);\n      expect(setItemSpy).toBeCalledWith(\n        \"parsedTokens\",\n        JSON.stringify(parsedTokens)\n      );\n    });\n    ```", "```js\n    export const save = store => next => action => {\n      const result = next(action);\n      const {\n        script: { name, parsedTokens }\n      } = store.getState();\n      localStorage.setItem(\"name\", name);\n      localStorage.setItem(\n        \"parsedTokens\",\n        JSON.stringify(parsedTokens)\n      );\n      return result;\n    };\n    ```", "```js\n    import {\n    load, save\n    } from \"../../src/middleware/localStorage\";\n    ...\n    describe(\"load\", () => {\n      describe(\"with saved data\", () => {\n        beforeEach(() => {\n          getItemSpy.mockReturnValueOnce(\"script name\");\n          getItemSpy.mockReturnValueOnce(\n            JSON.stringify([ { a: 123 } ])\n          );\n        });\n        it(\"retrieves state from localStorage\", () => {\n          load();\n          expect(getItemSpy).toBeCalledWith(\"name\");\n          expect(getItemSpy).toHaveBeenLastCalledWith(\n            \"parsedTokens\"\n          );\n        });\n      });\n    });\n    ```", "```js\n    export const load = () => {\n      localStorage.getItem(\"name\");\n      localStorage.getItem(\"parsedTokens\");\n    };\n    ```", "```js\n    describe(\"load\", () => {\n      let parserSpy;\n      describe(\"with saved data\", () => {\n        beforeEach(() => {\n          parserSpy = jest.fn();\n          parser.parseTokens = parserSpy;\n          ...\n        });\n        it(\"calls to parsedTokens to retrieve data\", () => {\n          load();\n          expect(parserSpy).toBeCalledWith(\n            [ { a: 123 } ],\n            parser.emptyState\n          );\n        });\n      });\n    });\n    ```", "```js\n    import * as parser from \"../parser\";\n    export const load = () => {\n      localStorage.getItem(\"name\");\n      const parsedTokens = JSON.parse(\n        localStorage.getItem(\"parsedTokens\")\n      );\n      parser.parseTokens(parsedTokens, parser.emptyState);\n    };\n    ```", "```js\n    it(\"returns re-parsed draw commands\", () => {\n      parserSpy.mockReturnValue({ drawCommands: [] });\n      expect(\n        load().script\n      ).toHaveProperty(\"drawCommands\", []);\n    });\n    ```", "```js\n    export const load = () => {\n      localStorage.getItem(\"name\");\n      const parsedTokens = JSON.parse(\n        localStorage.getItem(\"parsedTokens\")\n      );\n      return {\n        script: parser.parseTokens(\n          parsedTokens, parser.emptyState\n        )\n      };\n    };\n    ```", "```js\n    it(\"returns name\", () => {\n      expect(load().script).toHaveProperty(\n        \"name\",\n        \"script name\"\n      );\n    });\n    ```", "```js\n    export const load = () => {\n      const name = localStorage.getItem(\"name\");\n      const parsedTokens = JSON.parse(\n        localStorage.getItem(\"parsedTokens\")\n      );\n      return {\n        script: {\n          ...parser.parseTokens(\n            parsedTokens, parser.initialState\n          ),\n          name\n        }\n      };\n    };\n    ```", "```js\n    it(\"returns undefined if there is no state saved\", () => {\n      getItemSpy.mockReturnValue(null);\n      expect(load()).not.toBeDefined();\n    });\n    ```", "```js\n    if (parsedTokens && parsedTokens !== null) {\n      return {\n        ...\n      };\n    }\n    ```", "```js\n    ...\n    import {\n      save, load\n    } from \"./middleware/localStorage\";\n    export const configureStore = (\n      storeEnhancers = [],\n      initialState = {}\n    ) => {\n      return createStore(\n        combineReducers({\n          script: withUndoRedo(scriptReducer)\n        }),\n        initialState,\n        compose(\n          ...[\n            applyMiddleware(save),\n            ...storeEnhancers\n          ]\n        )\n      );\n    };\n    export const configureStoreWithLocalStorage = () =>\n      configureStore(undefined, load());\n    ```", "```js\n    import {\n      configureStoreWithLocalStorage\n    } from \"./store\";\n    ReactDOM.createRoot(\n      document.getElementById(\"root\")\n    ).render(\n      <Provider store={configureStoreWithLocalStorage()}>\n        <App />\n      </Provider>\n    );\n    ```", "```js\nforward 100\nright 90\nto drawSquare\n  repeat 4 [ forward 100 right 90 ]\nend\ndrawSquare\n```", "```js\n    import {\n      environmentReducer as reducer\n    } from \"../../src/reducers/environment\";\n    describe(\"environmentReducer\", () => {\n      it(\"returns default state when existing state is undefined\", () => {\n        expect(reducer(undefined, {})).toEqual({\n          promptFocusRequest: false\n        });\n      });\n    });\n    ```", "```js\n    const defaultState = {\n      promptFocusRequest: false\n    };\n    export const environmentReducer = (\n      state = defaultState,\n      action) => {\n      return state;\n    };\n    ```", "```js\n    it(\"sets promptFocusRequest to true when receiving a PROMPT_FOCUS_REQUEST action\", () => {\n      expect(\n        reducer(\n          { promptFocusRequest: false},\n          { type: \"PROMPT_FOCUS_REQUEST\" }\n        )\n      ).toEqual({\n        promptFocusRequest: true\n      });\n    });\n    ```", "```js\n    export const environmentReducer = (\n      state = defaultState,\n      action\n    ) => {\n      switch (action.type) {\n        case \"PROMPT_FOCUS_REQUEST\":\n          return { promptFocusRequest: true };\n      }\n      return state;\n    };\n    ```", "```js\n    it(\"sets promptFocusRequest to false when receiving a PROMPT_HAS_FOCUSED action\", () => {\n      expect(\n        reducer(\n          { promptFocusRequest: true},\n          { type: \"PROMPT_HAS_FOCUSED\" }\n        )\n      ).toEqual({\n        promptFocusRequest: false\n      });\n    });\n    ```", "```js\n    export const environmentReducer = (...) => {\n      switch (action.type) {\n        ...,\n        case \"PROMPT_HAS_FOCUSED\":\n          return { promptFocusRequest: false };\n      }\n      ...\n    }\n    ```", "```js\n    ...\n    import {\n      environmentReducer\n    } from \"./reducers/environment\";\n    export const configureStore = (\n      storeEnhancers = [],\n      initialState = {}\n    ) => {\n      return createStore(\n        combineReducers({\n          script: withUndoRedo(logoReducer),\n          environment: environmentReducer\n        }),\n        ...\n      );\n    };\n    ```", "```js\n    describe(\"prompt focus\", () => {\n      it(\"sets focus when component first renders\", () => {\n        renderInTableWithStore(<Prompt />);\n        expect(\n          document.activeElement\n        ).toEqual(textArea());\n      });\n    });\n    ```", "```js\n    import\n      React, { useEffect, useRef, useState }\n    from \"react\";\n    export const Prompt = () => {\n      ...\n      const inputRef = useRef();\n      useEffect(() => {\n        inputRef.current.focus();\n      }, [inputRef]);\n      return (\n        ...\n        <textarea\n          ref={inputRef}\n        />\n        ...\n      );\n    };\n    ```", "```js\n    import {\n      ...,\n      dispatchToStore,\n    } from \"./reactTestExtensions\";\n    ```", "```js\n    const jsdomClearFocus = () => {\n      const node = document.createElement(\"input\");\n      document.body.appendChild(node);\n      node.focus();\n      node.remove();\n    }\n    it(\"calls focus on the underlying DOM element if promptFocusRequest is true\", async () => {\n      renderInTableWithStore(<Prompt />);\n      jsdomClearFocus();\n      dispatchToStore({ type: \"PROMPT_FOCUS_REQUEST\" });\n      expect(document.activeElement).toEqual(textArea());\n    });\n    ```", "```js\n    export const Prompt = () => {\n      const nextInstructionId = ...\n      const promptFocusRequest = useSelector(\n        ({ environment: { promptFocusRequest } }) =>\n          promptFocusRequest\n      );\n      ...\n    };\n    ```", "```js\n    useEffect(() => {\n      inputRef.current.focus();\n    }, [promptFocusRequest]);\n    ```", "```js\n    it(\"dispatches an action notifying that the prompt has focused\", () => {\n      renderWithStore(<Prompt />);\n      dispatchToStore({ type: \"PROMPT_FOCUS_REQUEST\" });\n      return expectRedux(store)\n        .toDispatchAnAction()\n        .matching({ type: \"PROMPT_HAS_FOCUSED\" });\n    });\n    ```", "```js\n    const submitEditLine = ...\n    const promptHasFocused = () => (\n      { type: \"PROMPT_HAS_FOCUSED\" }\n    );\n    ```", "```js\n    useEffect(() => {\n      inputRef.current.focus();\n      dispatch(promptHasFocused());\n    }, [promptFocusRequest]);\n    ```", "```js\n    it(\"dispatches a prompt focus request\", () => {\n       return expectRedux(store)\n         .toDispatchAnAction()\n         .matching({ type: \"PROMPT_FOCUS_REQUEST\" });\n    });\n    ```", "```js\n    const submitScriptName = ...\n    const promptFocusRequest = () => ({\n      type: \"PROMPT_FOCUS_REQUEST\",\n    });\n    ```", "```js\n    const completeEditingScriptName = () => {\n      if (editingScriptName) {\n        toggleEditingScriptName();\n        dispatch(submitScriptName(updatedScriptName));\n        dispatch(promptFocusRequest());\n      }\n    };\n    ```"]