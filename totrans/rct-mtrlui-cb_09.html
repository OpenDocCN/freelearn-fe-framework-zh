<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Snackbars - Temporary Messages</h1>
                </header>
            
            <article>
                
<p>In this chapter, you'll learn about the following:</p>
<ul>
<li>Snackbar content</li>
<li>Controlling visibility with state</li>
<li>Snackbar transitions</li>
<li>Positioning Snackbars</li>
<li>Error boundaries and error Snackbars</li>
<li>Snackbars with actions</li>
<li>Queuing Snackbars</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>Material-UI<span> comes with a </span><kbd>Snackbar</kbd><span> component that's used to display messages for users. These messages are brief, short-lived, and don't interfere with the main application components.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Snackbar content</h1>
                </header>
            
            <article>
                
<p>Text is the most common form of <kbd>Snackbar</kbd> message content that you'll display for your users. Because of this, the <kbd>Snackbar</kbd> component makes it straightforward to set message content and display the snackbar.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>The <kbd>message</kbd> property of the <kbd>Snackbar</kbd> component accepts a string value, or any other valid <kbd>React</kbd> element. Here's the code that shows you how to set the content of the <kbd>Snackbar</kbd> component and display it:</p>
<pre>import React from 'react';<br/>import Snackbar from '@material-ui/core/Snackbar';<br/><br/>const MySnackbarContent = () =&gt; &lt;Snackbar open={true} message="Test" /&gt;;<br/>export default MySnackbarContent;</pre>
<p>When the page first loads, you'll see a snackbar that looks like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bc06a237-9745-43d4-a248-8c6f9981fffa.png" style="width:26.42em;height:4.58em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p><span>By default, a snackbar is nothing fancy, but it renders your text content as specified in the <kbd>message</kbd> property. The <kbd>open</kbd> property is set to true because any other value hides the snackbar.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>The <kbd>Snackbar</kbd> components use <kbd>SnackbackContent</kbd> components to render the actual content that's displayed. In turn, <kbd>SnackbarContent</kbd> uses <kbd>Paper</kbd>, which uses <kbd>Typography</kbd>. It's kind of tricky to navigate through all of this indirection, but, thankfully, you don't have to. Instead, you can pass properties all the way to the <kbd>Typography</kbd> component from <kbd>Snackbar</kbd> via the <kbd>ContentProps</kbd> property.</p>
<p>Let's say that you wanted to use the <kbd>h6</kbd> typography variant. Here's how you could do this:</p>
<pre>import React from 'react';<br/>import Snackbar from '@material-ui/core/Snackbar';<br/><br/>const MySnackbarContent () =&gt; (<br/>  &lt;Snackbar<br/>    open={true}<br/>    message="Test"<br/>    ContentProps={{ variant: 'h6' }}<br/>  /&gt;<br/>);<br/><br/>export default MySnackbarContent;</pre>
<p>Any properties that you want to pass to the component used by <kbd>Paper</kbd> can be set by <kbd>ContentProps</kbd>. Here, you're passing the <kbd>variant</kbd> property—which results in the following visual change:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e10fdf00-cbab-41a8-a9b1-2de68451df9b.png" style="width:19.08em;height:4.00em;"/></p>
<p>The end result is larger text and a wider margin. The aim of this example isn't this particular typography change, but rather the idea that you can customize <kbd>Snackbar</kbd> text in the exact same way as you would <kbd>Typography</kbd> components.</p>
<div class="packt_tip">You can put as many or as few components as you want into your snackbar content. For example, you can pass child components to <kbd>Snackbar</kbd> instead of in the <kbd>message</kbd> property. However, I would advise keeping your snackbar content as simple as possible. The last place where you want to go down a design rabbit hole is in a component that's already been designed to handle simple text.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><kbd>Snackbar</kbd> demos: <a href="https://material-ui.com/demos/snackbars/">https://material-ui.com/demos/snackbars/</a></li>
<li><kbd>Snackbar</kbd> API documentation: <a href="https://material-ui.com/api/snackbar/">https://material-ui.com/api/snackbar/</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Controlling visibility with state</h1>
                </header>
            
            <article>
                
<p>Snackbars are displayed in response to something. For example, if a new resource in your application is created, then using a <kbd>Snackbar</kbd> component to relay this information to the user is a good choice. If you need to control the state of your snackbars, then you need to add a state that controls the visibility of the snackbar.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>The <kbd>open</kbd> property is used to control the visibility of the snackbar. All you need in order to control this property value is a state value that's passed to it. Then, when this state changes, so does the visibility of the snackbar. Here's some code that illustrates the basic idea of state-controlling snackbars:</p>
<pre>import React, { Fragment, useState } from 'react';<br/><br/>import Button from '@material-ui/core/Button';<br/>import Snackbar from '@material-ui/core/Snackbar';<br/><br/>export default function ControllingVisibilityWithState() {<br/>  const [open, setOpen] = useState(false);<br/><br/>  const showSnackbar = () =&gt; {<br/>    setOpen(true);<br/>  };<br/><br/>  return (<br/>    &lt;Fragment&gt;<br/>      &lt;Button variant="contained" onClick={showSnackbar}&gt;<br/>        Show Snackbar<br/>      &lt;/Button&gt;<br/>      &lt;Snackbar open={open} message="Visible Snackbar!" /&gt;<br/>    &lt;/Fragment&gt;<br/>  );<br/>}</pre>
<p>When you first load the screen, all you'll see is a <span class="packt_screen">SHOW SNACKBAR</span> button:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c500fa7d-3e9b-4916-b2d4-8e23d05a8e02.png" style="width:11.58em;height:3.50em;"/></p>
<p>Clicking on this button shows the snackbar:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5c17cca7-da80-40a3-a894-455b920c859b.png" style="width:24.92em;height:4.08em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The component has an <kbd>open</kbd> state that determines the visibility of the snackbar. The value of <kbd>open</kbd> is passed to the <kbd>open</kbd> property of <kbd>Snackbar</kbd>. When the user clicks on the <span class="packt_screen">SHOW SNACKBAR</span> button, the <kbd>showSnackbar()</kbd> function sets the <kbd>open</kbd> state to true. As a result, the true value is passed to the <kbd>open</kbd> property of <kbd>Snackbar</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Once you've displayed a snackbar, you're going to need to be able to close it somehow. Once again, the <kbd>open</kbd> state can hide the snackbar. But how do you change the open state back to false? The typical pattern with snackbar messages is to have them appear only briefly, after which they're automatically hidden.</p>
<p>By passing two more properties to <kbd>Snackbar</kbd>, you can enhance this example so that the snackbar automatically hides itself after a certain time. Here's the updated code:</p>
<p> </p>
<pre>import React, { Fragment, useState } from 'react';<br/><br/>import Button from '@material-ui/core/Button';<br/>import Snackbar from '@material-ui/core/Snackbar';<br/><br/>export default function ControllingVisibilityWithState() {<br/>  const [open, setOpen] = useState(false);<br/>  <br/>  const showSnackbar = () =&gt; {<br/>    setOpen(true);<br/>  };<br/>  const hideSnackbar = () =&gt; {<br/>    setOpen(false);<br/>  };<br/><br/>  return (<br/>    &lt;Fragment&gt;<br/>      &lt;Button variant="contained" onClick={showSnackbar}&gt;<br/>        Show Snackbar<br/>      &lt;/Button&gt;<br/>      &lt;Snackbar<br/>        open={open}<br/>        onClose={hideSnackbar}<br/>        autoHideDuration={5000}<br/>        message="Visible Snackbar!"<br/>      /&gt;<br/>    &lt;/Fragment&gt;<br/>  );<br/>}</pre>
<p>A new function—<kbd>hideSnackbar()</kbd>—was added to the component. This is passed to the <kbd>onClose</kbd> property of <kbd>Snackbar</kbd>. The <kbd>autoHideDuration</kbd> component is the number of milliseconds that you want the snackbar to stay visible. In this example, after five seconds, the <kbd>Snackbar</kbd> component will call the function passed to its <kbd>onClose</kbd> property. This sets the <kbd>open</kbd> state to false, which is in turn passed to the <kbd>open</kbd> property of <kbd>Snackbar</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><kbd>Snackbar</kbd> demos: <a href="https://material-ui.com/demos/snackbars/">https://material-ui.com/demos/snackbars/</a></li>
<li><kbd>Snackbar</kbd> API documentation: <a href="https://material-ui.com/api/snackbar/">https://material-ui.com/api/snackbar/</a></li>
<li><kbd>Button</kbd> API documentation: <a href="https://material-ui.com/api/button/">https://material-ui.com/api/button/</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Snackbar transitions</h1>
                </header>
            
            <article>
                
<p>You can control the transitions used by <kbd>Snackbar</kbd> components when it is displayed and hidden. The <kbd>Snackbar</kbd> component directly supports transition customization through properties, so you don't have to spend too much time thinking about how to implement your snackbar transitions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let's say that you want to make it easier to change the transition used by snackbars throughout your application. You could create a thin wrapper component around <kbd>Snackbar</kbd> that takes care of setting the appropriate properties. Here's what the code looks like:</p>
<pre class="mce-root">import React, { Fragment, useState } from 'react';<br/><br/>import Grid from '@material-ui/core/Grid';<br/>import Button from '@material-ui/core/Button';<br/>import Snackbar from '@material-ui/core/Snackbar';<br/>import Slide from '@material-ui/core/Slide';<br/>import Grow from '@material-ui/core/Grow';<br/>import Fade from '@material-ui/core/Fade';<br/><br/>const MySnackbar = ({ transition, direction, ...rest }) =&gt; (<br/>  &lt;Snackbar<br/>    TransitionComponent={<br/>      { slide: Slide, grow: Grow, fade: Fade }[transition]<br/>    }<br/>    TransitionProps={{ direction }}<br/>    {...rest}<br/>  /&gt;<br/>);<br/><br/>export default function SnackbarTransitions() {<br/>  const [first, setFirst] = useState(false);<br/>  const [second, setSecond] = useState(false);<br/>  const [third, setThird] = useState(false);<br/>  const [fourth, setFourth] = useState(false);<br/><br/>  return (<br/>    &lt;Fragment&gt;<br/>      &lt;Grid container spacing={8}&gt;<br/>        &lt;Grid item&gt;<br/>          &lt;Button variant="contained" onClick={() =&gt; setFirst(true)}&gt;<br/>            Slide Down<br/>          &lt;/Button&gt;<br/>        &lt;/Grid&gt;<br/>        &lt;Grid item&gt;<br/>          &lt;Button variant="contained" onClick={() =&gt; setSecond(true)}&gt;<br/>            Slide Up<br/>          &lt;/Button&gt;<br/>        &lt;/Grid&gt;<br/>        &lt;Grid item&gt;<br/>          &lt;Button variant="contained" onClick={() =&gt; setThird(true)}&gt;<br/>            Grow<br/>          &lt;/Button&gt;<br/>        &lt;/Grid&gt;<br/>        &lt;Grid item&gt;<br/>          &lt;Button variant="contained" onClick={() =&gt; setFourth(true)}&gt;<br/>            Fade<br/>          &lt;/Button&gt;<br/>        &lt;/Grid&gt;<br/>      &lt;/Grid&gt;<br/>      &lt;MySnackbar<br/>        open={first}<br/>        onClose={() =&gt; setFirst(false)}<br/>        autoHideDuration={5000}<br/>        message="Slide Down"<br/>        transition="slide"<br/>        direction="down"<br/>      /&gt;<br/>      &lt;MySnackbar<br/>        open={second}<br/>        onClose={() =&gt; setSecond(false)}<br/>        autoHideDuration={5000}<br/>        message="Slide Up"<br/>        transition="slide"<br/>        direction="up"<br/>      /&gt;<br/>      &lt;MySnackbar<br/>        open={third}<br/>        onClose={() =&gt; setThird(false)}<br/>        autoHideDuration={5000}<br/>        message="Grow"<br/>        transition="grow"<br/>      /&gt;<br/>      &lt;MySnackbar<br/>        open={fourth}<br/>        onClose={() =&gt; setFourth(false)}<br/>        autoHideDuration={5000}<br/>        message="Fade"<br/>        transition="fade"<br/>      /&gt;<br/>    &lt;/Fragment&gt;<br/>  );<br/>}</pre>
<p>This code renders four buttons and four snackbars. When you first load the screen, you'll only see buttons:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/dedee27e-04ff-445e-b341-67407a1e9064.png" style="width:21.08em;height:2.75em;"/></p>
<p>Clicking on each of these buttons will display their corresponding <kbd>Snackbar</kbd> component at the bottom of the screen. If you pay attention to the transitions used when each of the snackbars is displayed, you'll notice the difference depending on the buttons you press. For example, clicking on the <span class="packt_screen">Fade</span> button will use the <kbd>fade</kbd> transition, resulting in the following snackbar:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b9daca37-2d08-4039-9988-b0cdd6defdb6.png" style="width:22.08em;height:3.67em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Let's start by looking at the <kbd>MySnackbar</kbd> component that was created in this example:</p>
<pre>const MySnackbar = ({ transition, direction, ...rest }) =&gt; (<br/>  &lt;Snackbar<br/>    TransitionComponent={<br/>      { slide: Slide, grow: Grow, fade: Fade }[transition]<br/>    }<br/>    TransitionProps={{ direction }}<br/>    {...rest}<br/>  /&gt;<br/>);</pre>
<p>There are two properties of interest here. The first is the <kbd>transition</kbd> string. This is used to look up the transition component to use. For example, the string <kbd>slide</kbd> will use the <kbd>Slide</kbd> component. The resulting component is used by the <kbd>TransitionComponent</kbd> property. The <kbd>Snackbar</kbd> components will use this component internally to apply the desired transition to your snackbars. The <kbd>direction</kbd> property is used with the <kbd>Slide</kbd> transition, which is why this property is passed to <kbd>TransitionProps</kbd>. These property values are passed directly to the component that's passed to <kbd>TransitionComponent</kbd>.</p>
<p>The alternative to using <kbd>TransitionProps</kbd> is to create a higher-order component that wraps its own property customization values. But since <kbd>Snackbar</kbd> is already set up to help you pass properties, there's no need to create yet another component if you want to avoid doing so.</p>
<p>Next, let's look at the component state and the functions that change it:</p>
<pre>const [first, setFirst] = useState(false);<br/>const [second, setSecond] = useState(false);<br/>const [third, setThird] = useState(false);<br/>const [fourth, setFourth] = useState(false);</pre>
<p>The <kbd>first</kbd>, <kbd>second</kbd>, <kbd>third</kbd>, and <kbd>fourth</kbd> states correspond to their own <kbd>Snackbar</kbd> components. These state values control the visibility of each function, and their corresponding setter functions show or hide the snackbars.</p>
<p>Finally, let's look at two of the <kbd>MySnackbar</kbd> components being rendered:</p>
<pre>&lt;MySnackbar<br/>  open={first}<br/>  onClose={() =&gt; setFirst(false)}<br/>  autoHideDuration={5000}<br/>  message="Slide Down"<br/>  transition="slide"<br/>  direction="down"<br/>/&gt;<br/>&lt;MySnackbar<br/>  open={second}<br/>  onClose={() =&gt; setSecond(false)}<br/>  autoHideDuration={5000}<br/>  message="Slide Up"<br/>  transition="slide"<br/>  direction="up"<br/>/&gt;</pre>
<p>Both of these instances use the <kbd>slide</kbd> transition. However, the <kbd>direction</kbd> property is different for each. The <kbd>MySnackbar</kbd> abstraction makes it a little simpler for you to specify transitions and transition arguments. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><kbd>Snackbar</kbd> demos: <a href="https://material-ui.com/demos/snackbars/">https://material-ui.com/demos/snackbars/</a></li>
<li><kbd>Snackbar</kbd> API documentation: <a href="https://material-ui.com/api/snackbar/">https://material-ui.com/api/snackbar/</a></li>
<li><kbd>Slide</kbd> API documentation: <a href="https://material-ui.com/api/slide/">https://material-ui.com/api/slide/</a></li>
<li><kbd>Grow</kbd> API documentation: <a href="https://material-ui.com/api/grow/">https://material-ui.com/api/grow/</a></li>
<li><kbd>Fade</kbd> API documentation: <a href="https://material-ui.com/api/fade/">https://material-ui.com/api/fade/</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Positioning snackbars</h1>
                </header>
            
            <article>
                
<p>Material-UI Snackbar components have an <kbd>anchorOrigin</kbd> property that allows you to change the position of the snackbar when it's displayed. You might be fine using the default positioning of snackbars, but sometimes you'll need this level of customization to stay consistent with other parts of your application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>While you can't arbitrarily position snackbars on the screen, there are a number of options that allow you to change the position of the snackbar. Here's some code that allows you to play around with the <kbd>anchorOrigin</kbd> property values:</p>
<pre>import React, { Fragment, useState } from 'react';<br/><br/>import { makeStyles } from '@material-ui/styles';<br/>import Snackbar from '@material-ui/core/Snackbar';<br/>import Radio from '@material-ui/core/Radio';<br/>import RadioGroup from '@material-ui/core/RadioGroup';<br/>import FormControlLabel from '@material-ui/core/FormControlLabel';<br/>import FormControl from '@material-ui/core/FormControl';<br/>import FormLabel from '@material-ui/core/FormLabel';<br/><br/>const useStyles = makeStyles(theme =&gt; ({<br/>  formControl: {<br/>    margin: theme.spacing(3)<br/>  }<br/>}));<br/><br/>export default function PositioningSnackbars() {<br/>  const classes = useStyles();<br/>  const [vertical, setVertical] = useState('bottom');<br/>  const [horizontal, setHorizontal] = useState('left');<br/><br/>  const onVerticalChange = event =&gt; {<br/>    setVertical(event.target.value);<br/>  };<br/><br/>  const onHorizontalChange = event =&gt; {<br/>    setHorizontal(event.target.value);<br/>  };<br/><br/>  return (<br/>    &lt;Fragment&gt;<br/>      &lt;FormControl<br/>        component="fieldset"<br/>        className={classes.formControl}<br/>      &gt;<br/>        &lt;FormLabel component="legend"&gt;Vertical&lt;/FormLabel&gt;<br/>        &lt;RadioGroup<br/>          name="vertical"<br/>          className={classes.group}<br/>          value={vertical}<br/>          onChange={onVerticalChange}<br/>        &gt;<br/>          &lt;FormControlLabel<br/>            value="top"<br/>            control={&lt;Radio /&gt;}<br/>            label="Top"<br/>          /&gt;<br/>          &lt;FormControlLabel<br/>            value="bottom"<br/>            control={&lt;Radio /&gt;}<br/>            label="Bottom"<br/>          /&gt;<br/>        &lt;/RadioGroup&gt;<br/>      &lt;/FormControl&gt;<br/>      &lt;FormControl<br/>        component="fieldset"<br/>        className={classes.formControl}<br/>      &gt;<br/>        &lt;FormLabel component="legend"&gt;Horizontal&lt;/FormLabel&gt;<br/>        &lt;RadioGroup<br/>          name="horizontal"<br/>          className={classes.group}<br/>          value={horizontal}<br/>          onChange={onHorizontalChange}<br/>        &gt;<br/>          &lt;FormControlLabel<br/>            value="left"<br/>            control={&lt;Radio /&gt;}<br/>            label="Left"<br/>          /&gt;<br/>          &lt;FormControlLabel<br/>            value="center"<br/>            control={&lt;Radio /&gt;}<br/>            label="Center"<br/>          /&gt;<br/>          &lt;FormControlLabel<br/>            value="right"<br/>            control={&lt;Radio /&gt;}<br/>            label="Right"<br/>          /&gt;<br/>        &lt;/RadioGroup&gt;<br/>      &lt;/FormControl&gt;<br/>      &lt;Snackbar<br/>        anchorOrigin={{<br/>          vertical,<br/>          horizontal<br/>        }}<br/>        open={true}<br/>        message="Positioned Snackbar"<br/>      /&gt;<br/>    &lt;/Fragment&gt;<br/>  );<br/>}</pre>
<p>When the screen first loads, you'll see controls for changing the position of the snackbar, and the <kbd>Snackbar</kbd> component in its default position:</p>
<p class="mce-root"/>
<p class="CDPAlignCenter CDPAlign"><img src="assets/29816333-2b70-4315-8640-ab8ea3bd3a35.png" style="width:27.00em;height:20.08em;"/></p>
<p>If you change any of the position control values, the snackbar will move to the new position. For example, if you changed the vertical anchor to top and the horizontal anchor to the right, here's what you'd see:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2e4851ae-c7fb-46d4-b028-9a224197965f.png" style="width:31.58em;height:13.58em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The two radio button groups in this example are only used to illustrate the different position value combinations that are available. In a real application where you show snackbars, you wouldn't have the configurable state to change the positioning of your snackbars. Instead, you should think of a value passed to the <kbd>anchorOrigin</kbd> property as a configuration value that is set once during startup.</p>
<p>It isn't good to rely on state values, as is the case in this example:</p>
<pre>&lt;Snackbar<br/>  anchorOrigin={{<br/>    vertical,<br/>    horizontal<br/>  }}<br/>  open={true}<br/>  message="Positioned Snackbar"<br/>/&gt;</pre>
<p>Instead, you would set the <kbd>anchorOrigin</kbd> values statically:</p>
<pre>&lt;Snackbar<br/>  anchorOrigin={{<br/>    vertical: 'top'<br/>    horizontal: 'right'<br/>  }}<br/>  open={true}<br/>  message="Positioned Snackbar"<br/>/&gt;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Once you know where you want to position your snackbars, you can create your own <kbd>Snackbar</kbd> component that has the <kbd>anchorOrigin</kbd> values defined. Here's an example:</p>
<pre>const MySnackbar = props =&gt; (<br/>  &lt;Snackbar<br/>    anchorOrigin={{<br/>      vertical: 'top',<br/>      horizontal: 'right'<br/>    }}<br/>    {...props}<br/>  /&gt;<br/>);</pre>
<p>Anywhere in your app that <kbd>MySnackbar</kbd> is used, the snackbars will be displayed in the top-right corner of the screen. Otherwise, <kbd>MySnackbar</kbd> is just like a regular <kbd>Snackbar</kbd> component.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><kbd>Snackbar</kbd> demos: <a href="https://material-ui.com/demos/snackbars/">https://material-ui.com/demos/snackbars/</a></li>
<li><kbd>Snackbar</kbd> API documentation: <a href="https://material-ui.com/api/snackbar/">https://material-ui.com/api/snackbar/</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Error boundaries and error snackbars</h1>
                </header>
            
            <article>
                
<p><strong>Error boundaries</strong> in React enable you to capture errors that happen when your components attempt to render. You can use the <kbd>Snackbar</kbd> components in your error boundaries to display captured errors. Furthermore, you can style snackbars so that errors are visually distinctive from normal messages.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let's say that you have an error boundary at the top level of your application and you want to use the <kbd>Snackbar</kbd> component to display error messages to users. Here's an example that shows how you can do this:</p>
<pre>import React, { Fragment, Component } from 'react';<br/><br/>import { withStyles } from '@material-ui/core/styles';<br/>import Snackbar from '@material-ui/core/Snackbar';<br/>import Button from '@material-ui/core/Button';<br/><br/>const styles = theme =&gt; ({<br/>  error: {<br/>    backgroundColor: theme.palette.error.main,<br/>    color: theme.palette.error.contrastText<br/>  }<br/>});<br/><br/>const ErrorBoundary = withStyles(styles)(<br/>  class extends Component {<br/>    state = { error: null };<br/><br/>    onClose = () =&gt; {<br/>      this.setState({ error: null });<br/>    };<br/><br/>    componentDidCatch(error) {<br/>      this.setState({ error });<br/>    }<br/><br/>    render() {<br/>      const { classes } = this.props;<br/><br/>      return (<br/>        &lt;Fragment&gt;<br/>          {this.state.error === null &amp;&amp; this.props.children}<br/>          &lt;Snackbar<br/>            open={Boolean(this.state.error)}<br/>            message={<br/>              this.state.error !== null &amp;&amp; this.state.error.toString()<br/>            }<br/>            ContentProps={{ classes: { root: classes.error } }}<br/>          /&gt;<br/>        &lt;/Fragment&gt;<br/>      );<br/>    }<br/>  }<br/>);<br/><br/>const MyButton = () =&gt; {<br/>  throw new Error('Random error');<br/>};<br/><br/>export default () =&gt; (<br/>  &lt;ErrorBoundary&gt;<br/>    &lt;MyButton /&gt;<br/>  &lt;/ErrorBoundary&gt;<br/>);</pre>
<p>When you load this screen, the <kbd>MyButton</kbd> component throws an error when it is rendered. Here's what you'll see:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/bead05ef-fa91-4b44-bb5e-71077ede8232.png" style="width:25.25em;height:4.17em;"/></p>
<div class="packt_infobox">It explicitly throws an error so that you can see the error boundary mechanism in action. In a real application, the error could be triggered by any function that's called during the rendering process.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Let's start by taking a closer look at the <kbd>ErrorBoundary</kbd> component. It has an <kbd>error</kbd> state that is initially null. The <kbd>componentDidCatch()</kbd> life cycle method changes this state when an error happens:</p>
<pre>componentDidCatch(error) {<br/>  this.setState({ error });<br/>}</pre>
<p>Next, let's take a closer look at the <kbd>render()</kbd> method:</p>
<pre>render() {<br/>  const { classes } = this.props;<br/><br/>  return (<br/>    &lt;Fragment&gt;<br/>      {this.state.error === null &amp;&amp; this.props.children}<br/>      &lt;Snackbar<br/>        open={Boolean(this.state.error)}<br/>        message={<br/>          this.state.error !== null &amp;&amp; this.state.error.toString()<br/>        }<br/>        ContentProps={{ classes: { root: classes.error } }}<br/>      /&gt;<br/>    &lt;/Fragment&gt;<br/>  );<br/>}</pre>
<p>It uses the <kbd>error</kbd> state to determine whether children should be rendered. When the <kbd>error</kbd> state is non-null, it doesn't make sense to render child components because you'll be stuck in an infinite loop of error being thrown and handled. The <kbd>error</kbd> state is also used as the <kbd>open</kbd> property to determine whether the snackbar should be displayed, and as the message text.</p>
<p>The <kbd>ContentProps</kbd> property is used to style the snackbar so that it looks like an error. The <kbd>error</kbd> class uses <kbd>theme</kbd> values to change the background and text color:</p>
<pre>const styles = theme =&gt; ({<br/>  error: {<br/>    backgroundColor: theme.palette.error.main,<br/>    color: theme.palette.error.contrastText<br/>  }<br/>});</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>The error boundary used in this example covered the entire application. This is good in the sense that you can blanket the entire application with error handling in one shot. But this is also bad, because the entire user interface vanishes, as the error boundary has no idea which component failed.</p>
<p>Because error boundaries are components, you can place as many of them as you like at any level of your component tree. This way, you can show Material-UI <kbd>error</kbd> snackbars while keeping the parts of the UI that haven't failed visible on the screen.</p>
<p>Let's change the scope of the error boundary used in the example. First, you can change the <kbd>MyButton</kbd> implementation so that it only throws an error when a Boolean property is <kbd>true</kbd>:</p>
<pre>const MyButton = ({ label, throwError }) =&gt; {<br/>  if (throwError) {<br/>    throw new Error('Random error');<br/>  }<br/>  return &lt;Button&gt;{label}&lt;/Button&gt;;<br/>};</pre>
<p>Now you can render a button with a given label. If <kbd>throwError</kbd> is <kbd>true</kbd>, then nothing is rendering due to the error. Next, let's change the markup of the example to include multiple buttons and multiple <kbd>error</kbd> boundaries:</p>
<pre>export default () =&gt; (<br/>  &lt;Fragment&gt;<br/>    &lt;ErrorBoundary&gt;<br/>      &lt;MyButton label="First Button" /&gt;<br/>    &lt;/ErrorBoundary&gt;<br/>    &lt;ErrorBoundary&gt;<br/>      &lt;MyButton label="Second Button" throwError /&gt;<br/>    &lt;/ErrorBoundary&gt;<br/>  &lt;/Fragment&gt;<br/>);</pre>
<p>The first button renders without any issues. However, if the error boundary were all-encompassing as was the case earlier, then this button wouldn't be displayed. The second button throws an error because the <kbd>throwError</kbd> property is true. Because this button has its own error boundary, it doesn't prevent other parts of the UI that are working fine from rendering. Here's what you'll see when you run the example now:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d99b7b87-8bdd-4a81-a7de-f75153243672.png" style="width:39.00em;height:10.92em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>React <kbd>error</kbd> boundaries: <a href="https://reactjs.org/docs/error-boundaries.html">https://reactjs.org/docs/error-boundaries.html</a></li>
<li><kbd>Snackbar</kbd> demos:<a href="https://material-ui.com/demos/snackbars/"> https://material-ui.com/demos/snackbars/</a></li>
<li><kbd>Snackbar</kbd> API documentation: <a href="https://material-ui.com/api/snackbar/">https://material-ui.com/api/snackbar/</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Snackbars with actions</h1>
                </header>
            
            <article>
                
<p>The purpose of Material-UI snackbars is to display brief messages for the user. Additionally, you can embed the next course of action for the user in the snackbar.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let's say that you want a simple button in your snackbar that closes the snackbar. This could be useful for closing the snackbar before it automatically closes. Alternatively, you might want to require the user to explicitly acknowledge the message by having to close it manually. Here's the code to add a close button to a <kbd>Snackbar</kbd> component:</p>
<pre>import React, { Fragment, useState } from 'react';<br/>import { Route, Link } from 'react-router-dom';<br/><br/>import Snackbar from '@material-ui/core/Snackbar';<br/>import Button from '@material-ui/core/Button';<br/>import IconButton from '@material-ui/core/IconButton';<br/>import Typography from '@material-ui/core/Typography';<br/><br/>import CloseIcon from '@material-ui/icons/Close';<br/><br/>export default function Snackbars() {<br/>  const [open, setOpen] = useState(false);<br/><br/>  return (<br/>    &lt;Fragment&gt;<br/>      &lt;Button onClick={() =&gt; setOpen(true)}&gt;Do Something&lt;/Button&gt;<br/>      &lt;Snackbar<br/>        open={open}<br/>        onClose={() =&gt; setOpen(false)}<br/>        message="All done doing the thing"<br/>        action={[<br/>          &lt;IconButton color="inherit" onClick={() =&gt; setOpen(false)}&gt;<br/>            &lt;CloseIcon /&gt;<br/>          &lt;/IconButton&gt;<br/>        ]}<br/>      /&gt;<br/>    &lt;/Fragment&gt;<br/>  );<br/>}</pre>
<p>When the screen first loads, you'll only see a button:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a61bb63f-4c29-47b1-8335-33d0566a7e9d.png" style="width:9.33em;height:2.75em;"/></p>
<p>Clicking on this button will display the snackbar:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8d5f0fca-e179-4564-a0cd-eb26271e5357.png" style="width:24.83em;height:5.25em;"/></p>
<p>The close icon button on the right side of the snackbar, when clicked on, closes the snackbar.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The close button is added to the <kbd>Snackbar</kbd> component via the <kbd>action</kbd> property, which accepts either a node or an array of nodes. The <kbd>SnackbarContent</kbd> component takes care of applying styles to align the actions within the snackbar.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>When users create new resources in your application, you probably want to let them know when the resource is created successfully. Snackbars are a good tool for this because they don't force the user away from anything that they might be in the middle of. What would be nice is if you included an action button in the snackbar that linked to the newly created resource.</p>
<p>Let's modify this example so that, when the user clicks on the <span class="packt_screen">CREATE</span> button, they'll see a snackbar with the following:</p>
<ul>
<li>A brief message</li>
<li>A close action</li>
<li>A link to the new resource</li>
</ul>
<p>Let's add routes from <kbd>react-router-dom</kbd> and then add the link to the snackbar. Here's the new markup:</p>
<pre>&lt;Fragment&gt;<br/>  &lt;Route<br/>    exact<br/>    path="/"<br/>    render={() =&gt; (<br/>      &lt;Button onClick={() =&gt; setOpen(true)}&gt;create thing&lt;/Button&gt;<br/>    )}<br/>  /&gt;<br/>  &lt;Route<br/>    exact<br/>    path="/thing"<br/>    render={() =&gt; &lt;Typography&gt;The Thing&lt;/Typography&gt;}<br/>  /&gt;<br/>  &lt;Snackbar<br/>    open={open}<br/>    onClose={() =&gt; setOpen(false)}<br/>    message="Finished creating thing"<br/>    action={[<br/>      &lt;Button<br/>        color="secondary"<br/>        component={Link}<br/>        to="/thing"<br/>        onClick={() =&gt; setOpen(false)}<br/>      &gt;<br/>        The Thing<br/>      &lt;/Button&gt;,<br/>      &lt;IconButton color="inherit" onClick={() =&gt; setOpen(false)}&gt;<br/>        &lt;CloseIcon /&gt;<br/>      &lt;/IconButton&gt;<br/>    ]}<br/>  /&gt;<br/>&lt;/Fragment&gt;</pre>
<p>The first route is for the index page, so, when the screen first loads, the user will see the button that's rendered by this route:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7991362c-463f-4c48-ad8e-66e363af3fac.png" style="width:8.42em;height:2.92em;"/></p>
<p>When you click on this button, you'll see the snackbar that includes a link to the newly-created resource:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/99462ff9-de18-4dae-821e-da1340720b9e.png" style="width:26.58em;height:5.08em;"/></p>
<p>Now you've given the user an easy way to navigate to the resource without disrupting what they're currently doing.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>React router guide: <a href="https://reacttraining.com/react-router/web/guides/quick-start">https://reacttraining.com/react-router/web/guides/quick-start</a></li>
<li><kbd>Snackbar</kbd> demos: <a href="https://material-ui.com/demos/snackbars/">https://material-ui.com/demos/snackbars/</a></li>
<li><kbd>Snackbar</kbd> API documentation: <a href="https://material-ui.com/api/snackbar/">https://material-ui.com/api/snackbar/</a></li>
<li><kbd>Button</kbd> API documentation: <a href="https://material-ui.com/api/button/">https://material-ui.com/api/button/</a></li>
<li><kbd>IconButton</kbd> API documentation: <a href="https://material-ui.com/api/icon-button/">https://material-ui.com/api/icon-button/</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Queuing snackbars</h1>
                </header>
            
            <article>
                
<p>With larger Material-UI applications, you're likely to find yourself in a situation where more than one snackbar message is sent in a very short period of time. To deal with this, you can create a queue for all snackbar messages so that only the most recent notification is displayed, and so that the transitions are handled properly.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let's say that you have several components throughout your application that need to send snackbar messages to your users. Having to manually render <kbd>Snackbar</kbd> components everywhere would be cumbersome—especially if all you're trying to do is display simple text snackbars.</p>
<p>One alternative approach is to implement a higher-order component that wraps your components with the ability to display messages by calling a function and then passing the text as the argument. Then, you can wrap any components that need the snackbar capability. Here's what the code looks like:</p>
<pre>import React, { Fragment, useState } from 'react';<br/><br/>import Snackbar from '@material-ui/core/Snackbar';<br/>import Button from '@material-ui/core/Button';<br/>import IconButton from '@material-ui/core/IconButton';<br/><br/>import CloseIcon from '@material-ui/icons/Close';<br/><br/>const withMessage = Wrapped =&gt;<br/>  function WithMessage(props) {<br/>    const [queue, setQueue] = useState([]);<br/>    const [open, setOpen] = useState(false);<br/>    const [message, setMessage] = useState('');<br/><br/>    const sendMessage = msg =&gt; {<br/>      const newQueue = [...queue, msg];<br/>      if (newQueue.length === 1) {<br/>        setOpen(true);<br/>        setMessage(msg);<br/>      }<br/>    };<br/><br/>    const onClose = () =&gt; {<br/>      setOpen(false);<br/>    };<br/><br/>    const onExit = () =&gt; {<br/>      const [msg, ...rest] = queue;<br/><br/>      if (msg) {<br/>        setQueue(rest);<br/>        setOpen(true);<br/>        setMessage(msg);<br/>      }<br/>    };<br/><br/>    return (<br/>      &lt;Fragment&gt;<br/>        &lt;Wrapped message={sendMessage} {...props} /&gt;<br/>        &lt;Snackbar<br/>          key={message}<br/>          open={open}<br/>          message={message}<br/>          autoHideDuration={4000}<br/>          onClose={onClose}<br/>          onExit={onExit}<br/>        /&gt;<br/>      &lt;/Fragment&gt;<br/>    );<br/>  };<br/><br/>const QueuingSnackbars = withMessage(({ message }) =&gt; {<br/>  const [counter, setCounter] = useState(0);<br/><br/>  const onClick = () =&gt; {<br/>    const newCounter = counter + 1;<br/>    setCounter(newCounter);<br/>    message(`Message ${newCounter}`);<br/>  };<br/><br/>  return &lt;Button onClick={onClick}&gt;Message&lt;/Button&gt;;<br/>});<br/><br/>export default QueuingSnackbars;</pre>
<p>When the screen first loads, you'll see a message button. Clicking on it will display a snackbar message that looks like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/785de96d-5cee-4ab8-a83f-7c2c6f825242.png" style="width:22.92em;height:3.83em;"/></p>
<p>Clicking on the message button again will clear the current snackbar by visually transitioning it off of the screen before transitioning the new snackbar onto the screen. Even if you click the button several times in rapid succession, everything works smoothly and you'll always see the latest message:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c7740450-84b3-44e7-9951-8ff3ab18688d.png" style="width:23.33em;height:3.83em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Let's start by looking at the <kbd>QueuingSnackbars</kbd> component that renders the button that sends messages when clicked:</p>
<pre>const QueuingSnackbars = withMessage(({ message }) =&gt; {<br/>  const [counter, setCounter] = useState(0);<br/><br/>  const onClick = () =&gt; {<br/>    const newCounter = counter + 1;<br/>    setCounter(newCounter);<br/>    message(`Message ${newCounter}`);<br/>  };<br/><br/>  return &lt;Button onClick={onClick}&gt;Message&lt;/Button&gt;;<br/>});</pre>
<p>The <kbd>withMessage()</kbd> wrapper provides the component with a <kbd>message()</kbd> function as a property. If you look at the <kbd>onClick()</kbd> handler, you can see the <kbd>message()</kbd> function in action.</p>
<p>Next, let's break down the <kbd>withMessage()</kbd> higher-order component. We'll start with the markup and work our way downward:</p>
<pre>&lt;Fragment&gt;<br/>  &lt;Wrapped message={sendMessage} {...props} /&gt;<br/>  &lt;Snackbar<br/>    key={message}<br/>    open={open}<br/>    message={message}<br/>    autoHideDuration={4000}<br/>    onClose={onClose}<br/>    onExit={onExit}<br/>  /&gt;<br/>&lt;/Fragment&gt;</pre>
<p>The <kbd>Wrapped</kbd> component is the component that <kbd>withMessage()</kbd> was called on. It's passed the normal props that it would be called with normally, plus the <kbd>message()</kbd> function. Adjacent to this is the <kbd>Snackbar</kbd> component. There are two interesting properties that are worth pointing out here:</p>
<ul>
<li><kbd>key</kbd>: This value is used internally by <kbd>Snackbar</kbd> to determine whether a new message is being displayed. It should be a unique value.</li>
<li><kbd>onExit</kbd>: This is called when the transition of a snackbar that is closing completes.</li>
</ul>
<p class="mce-root"/>
<p>Next, let's look at the <kbd>sendMessage()</kbd> function:</p>
<pre>const sendMessage = msg =&gt; {<br/>  const newQueue = [...queue, msg];<br/>  if (newQueue.length === 1) {<br/>    setOpen(true);<br/>    setMessage(msg);<br/>  }<br/>};</pre>
<p>This function is called whenever a component wants to display a snackbar message. It puts the <kbd>message</kbd> string into the queue. If the message is the only item in the queue, then the <kbd>open</kbd> and <kbd>message</kbd> states are updated right away.</p>
<p>Next, let's look at the <kbd>onClose()</kbd> function. This is called when the snackbar is closed:</p>
<pre>const onClose = () =&gt; {<br/>  setOpen(false);<br/>};</pre>
<p>The only job of this function is to make sure that the open state is false.</p>
<p>Lastly, let's look at the <kbd>onExit()</kbd> function that's called when a snackbar has completed its exit transition:</p>
<pre>const onExit = () =&gt; {<br/>  const [msg, ...rest] = queue;<br/><br/>  if (msg) {<br/>    setQueue(rest);<br/>    setOpen(true);<br/>    setMessage(msg);<br/>  }<br/>};</pre>
<p>The fist message in the queue is assigned to the <kbd>message</kbd> constant. If there's a message, it becomes the active message state and the next snackbar is opened. The item is also removed from the queue at this point.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><kbd>Snackbar</kbd> demos: <a href="https://material-ui.com/demos/snackbars/">https://material-ui.com/demos/snackbars/</a></li>
<li><kbd>Snackbar</kbd> API documentation: <a href="https://material-ui.com/api/snackbar/">https://material-ui.com/api/snackbar/</a></li>
<li><kbd>Button</kbd> API documentation: <a href="https://material-ui.com/api/button/">https://material-ui.com/api/button/</a></li>
<li><kbd>IconButton</kbd> API documentation: <a href="https://material-ui.com/api/icon-button/">https://material-ui.com/api/icon-button/</a></li>
</ul>


            </article>

            
        </section>
    </body></html>