- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introducing Test-Driven Development with React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to a chapter that could potentially revolutionize your approach to React
    development – **test-driven development** (or **TDD** for short). If you’ve been
    building React applications, you know how complex and intricate they can get.
    With various states to manage, components to juggle, and user interactions to
    facilitate, ensuring the reliability of your code base can be challenging. That’s
    where TDD comes in.
  prefs: []
  type: TYPE_NORMAL
- en: In the ever-changing landscape of software development, where features are continuously
    added or modified, TDD serves as a lighthouse that guides you safely through the
    rough seas of bugs and regressions. By writing tests before your actual code,
    you not only confirm that your code does what it’s supposed to, but you also create
    a safety net that makes future changes less risky.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter aims to deepen your understanding of TDD and how to implement it
    effectively in React applications. We’ll introduce the core principles of TDD,
    explore various styles, including unit test-driven development, **acceptance test-driven
    development** (**ATDD**), and **behavior-driven development** (**BDD**), and even
    examine the nuanced differences between the Chicago and London styles of TDD.
  prefs: []
  type: TYPE_NORMAL
- en: But we won’t stop at theory – to make these concepts come alive, we’ll walk
    you through a practical example of creating a pizza store menu page. From setting
    up the initial structure to managing complex features, we’ll guide you through
    each step with the TDD approach. By the end of this chapter, you’ll have a firm
    grasp of TDD’s capabilities, and you’ll be well equipped to start writing more
    reliable, robust React applications.
  prefs: []
  type: TYPE_NORMAL
- en: So, get ready to dive into a world where tests lead the way and code follows,
    creating a harmonious balance that results in better, more reliable software.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding TDD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing tasking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the online pizza store application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breaking down the application requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the application headline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the menu list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the shopping cart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding items to the shopping cart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring the shopping cart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A GitHub repository has been created to host all the code we’ll discuss in this
    book. For this chapter, you can find the recommended structure at [https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch7](https://github.com/PacktPublishing/React-Anti-Patterns/tree/main/code/src/ch7).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding TDD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TDD isn’t exactly a new kid on the block. Originating from **Extreme Programming**
    (**XP**), a software development methodology that encourages frequent releases
    in short cycles, TDD has roots going back to the late 1990s. It was Kent Beck,
    one of the original signatories of the Agile Manifesto, who popularized this practice
    as a core part of XP. The practice has since grown beyond the realm of XP and
    is now commonly utilized in various methodologies and frameworks, React included.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the heart of TDD is a very simple, yet profoundly effective cycle known
    as the **Red-Green-Refactor loop**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1: The Red-Green-Refactor loop](img/B31103_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: The Red-Green-Refactor loop'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, there are essentially three steps when practicing TDD:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Red**: At this stage, you write a test that defines a function or improvements
    of a function. This test should initially fail because the function isn’t implemented
    yet. In most test frameworks (for example, Jest), there will be some red text
    to indicate the failure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Green**: At this stage, you write the minimum amount of code necessary to
    pass the test. The key here is to write as little code as possible to make the
    test pass and make the text turn green – no more than that.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Refactor**: Finally, you need to clean up the code while keeping it functional.
    The refactor phase is about making the code efficient, readable, and understandable
    without changing its behavior. The tests that are written should still pass after
    the refactoring.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When developers first encounter TDD, it often feels counter-intuitive, as the
    practice of writing tests before the actual code contradicts traditional development
    instincts. However, once you get past the initial discomfort, the advantages of
    TDD become hard to ignore:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Focused problem-solving**: By writing a test for a specific functionality
    first, you focus your attention solely on solving one problem at a time, making
    the development process less overwhelming.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Predictable next steps**: When you follow a test-driven approach, you always
    know what to do next: make the test pass. This reduces the cognitive load, making
    it easier to focus on the task at hand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simple, maintainable design**: The process naturally encourages the simplest
    code necessary to pass tests, resulting in a design that is as minimal as possible,
    and thereby easier to understand and maintain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Facilitates mental flow**: The loop provides a structured approach to coding
    that helps maintain a “mental flow,” helping you stay focused on tasks by reducing
    the constant context-switching that interrupts a productive coding session.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automatic test coverage**: TDD ensures that your application has robust test
    coverage by default. You’re not adding tests as an afterthought; they’re integral
    to the development process, ensuring a more stable codebase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TDD is a practice deeply rooted in the principles of Agile and XP but has found
    relevance far beyond those methodologies. With its structured Red-Green-Refactor
    loop, TDD provides a solid framework for writing high-quality code. Although it
    may appear counter-intuitive initially, adopting TDD can result in more focused
    problem-solving, predictable development, simpler design, enhanced productivity,
    and robust test coverage.
  prefs: []
  type: TYPE_NORMAL
- en: Different styles of TDD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The core principles of TDD have been adapted and extended into various styles,
    each offering different perspectives on how best to approach testing and development.
    Let’s explore some of these styles to understand how they can be applied to React
    development.
  prefs: []
  type: TYPE_NORMAL
- en: The original form of TDD, simply referred to as TDD, mainly focuses on unit
    tests. In this style, you write tests for the smallest pieces of your code – often
    individual methods or functions. The aim is to ensure that each part of your code
    base works as expected in isolation. While this is powerful for testing logic
    and algorithms, it may not fully capture how various parts interact, especially
    in a complex UI framework such as React.
  prefs: []
  type: TYPE_NORMAL
- en: 'ATDD extends TDD by beginning the development process with user acceptance
    tests. This means that before writing any code, you define what “done” looks like
    from a user’s perspective, often in collaboration with stakeholders. These acceptance
    tests are then used as the foundation for developing features. ATDD is particularly
    useful for ensuring that you’re building what the user needs and wants:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2: The ATDD loop](img/B31103_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.2: The ATDD loop'
  prefs: []
  type: TYPE_NORMAL
- en: Note that when you write an acceptance test, it can usually be broken down into
    smaller unit tests. For example, a user logging into the system can be an acceptance
    test, but there will be forgotten passwords, incorrect passwords or usernames,
    remember me functions, and more to cover in the lower-level unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: BDD is a further refinement of TDD and ATDD, focusing on the behavior of an
    application for a given input. Rather than writing tests that check if a particular
    method returns an expected value, BDD tests check if a system behaves as expected
    when subjected to certain conditions. BDD often uses more descriptive language
    to define tests, making it easier for non-technical stakeholders to understand
    what is being tested.
  prefs: []
  type: TYPE_NORMAL
- en: 'BDD often makes use of tools such as **Cucumber** to define behavior specifications
    in a human-readable format. In a Cucumber test, you specify behavior using a plaintext
    language called **Gherkin**. Here’s a simple example of a BDD test case using
    Cucumber for a pizza ordering feature (we will continue working on this pizza
    example later in this chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This Gherkin file defines the expected behavior of the pizza ordering functionality.
    Each line is called a step and can be interpreted as a statement in the test.
    The scenarios describe the test’s behavior in terms of the steps to be performed
    and the expected outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: Gherkin syntax is more than just readable documentation – it’s executable. Tools
    such as Cucumber can parse the Gherkin files and execute tests based on them –
    for example, `cypress.visit("`[http://pizzashop.com](http://pizzashop.com)"`)`.
    This ensures that the software behaves exactly as described in the feature files,
    making it a source of truth that evolves along with the application.
  prefs: []
  type: TYPE_NORMAL
- en: BDD feature files (Gherkin) serve as a form of living documentation that gets
    updated as the application changes. This makes them incredibly valuable for new
    team members, or even for seasoned developers, to understand the expected behavior
    of the application quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Focusing on user value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Regardless of the style you choose, when working with React, it’s crucial to
    focus on the user’s perspective. React components are pieces of UI that users
    interact with, so your tests should reflect that interaction. The user doesn’t
    care about how your state is managed or how efficient your life cycle methods
    are; they care about whether clicking a button shows a dropdown, or whether a
    form submission produces the expected result.
  prefs: []
  type: TYPE_NORMAL
- en: Kent C. Dodds, the creator of the React Testing Library, said “*The more your
    tests resemble the way your software is used, the more confidence they can give
    you.*” This principle is universally applicable, irrespective of the framework
    or library you’re using. The focus should always be on the user’s experience.
  prefs: []
  type: TYPE_NORMAL
- en: This user-centric approach aligns well with BDD and ATDD, where the focus is
    on the result of an interaction, not the minutiae of the implementation. By adhering
    to these principles, you can ensure your React components not only work well but
    also deliver the user experience you aim to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve understood what TDD is and how its various styles can aid in
    delivering value to our customers, the next question to tackle is: how do we go
    about implementing it?'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing tasking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Tasking** is an essential step in the TDD process that involves breaking
    down a feature or user story into small, manageable tasks, which then serve as
    the basis for your test cases. The goal of tasking is to create a clear roadmap
    for what you’re going to code, how you’ll test it, and in what order you’ll proceed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Breaking the big requirement into smaller chunks has a lot of benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**It clarifies scope**: Breaking down a feature into tasks helps establish
    a better understanding of what needs to be done and how to approach it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It simplifies the problem**: By dissecting a complex problem into smaller
    tasks, you make it easier to tackle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It prioritizes work**: Once the tasks have been laid out, they can be prioritized
    to deliver the most value first or to build logically upon one another'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It focuses effort**: Tasking ensures that each test you write serves a clear,
    immediate purpose, making your TDD cycle more efficient'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It facilitates collaboration**: Team members can pick up individual tasks,
    safe in the knowledge that they are all contributing to a cohesive whole'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, you might be wondering, if it is so good and helpful, how can we do tasking?
    It’s not anything fancy – you might have already done it without noticing. You
    just follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Review the user story or requirement**: Understand the user story or feature
    you are supposed to implement.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Identify logical components**: Break the story down into its logical components,
    which often correspond to domain concepts, business rules, or individual steps
    in a user workflow.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Create a task list**: Write down a list of tasks. These tasks should be small
    enough that you can write a few test cases and the corresponding implementation
    code in a short amount of time (say, 15 to 30 minutes).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Sequence the tasks**: Determine the most logical order for completing these
    tasks, often starting with the “happy path” – the default scenario where everything
    goes as expected, without encountering any errors – and then moving on to edge
    cases and error handling.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Map the tasks to tests**: For each task, identify the tests that will verify
    that part of the functionality. You don’t need to write the tests at this stage;
    you’re simply identifying what they’ll be.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tasking might be a part of your daily workflow without you even realizing it.
    It’s a systematic approach to problem-solving that involves breaking down a requirement
    into manageable, sequential tasks. These tasks should ideally be completable within
    a few minutes to an hour.
  prefs: []
  type: TYPE_NORMAL
- en: The process of TDD is akin to the art of painting. You begin with a sketch or
    draft, outlining basic shapes and lines with a pencil, much like framing the initial
    structure of your code. In the beginning, the vision might be vague, a mere idea
    or concept in your mind. But as you draw – or write tests and code – the image
    begins to take shape. More elements are added, details emerge, and adjustments
    are made, allowing for continuous refinement. With each layer or iteration, clarity
    emerges, yet the exact final appearance remains a mystery until the very last
    stages. Just as an artist crafts a masterpiece through gradual development, TDD
    shapes a robust and elegant piece of software.
  prefs: []
  type: TYPE_NORMAL
- en: All right, we have covered a lot of theory so far. Let’s look into a concrete
    example to fully understand how to do tasking and use tasks as a guideline for
    applying the Red-Green-Refactor loop.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the online pizza store application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we’ll be diving into the TDD process through a deliciously
    practical example: *The Code Oven*, an online pizza store. Named to celebrate
    the fusion of coding and culinary arts, The Code Oven aims to serve both your
    appetite and your intellectual curiosity. This digital storefront will offer us
    a comprehensive sandbox where we can apply all the TDD principles and techniques
    we discuss.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what you can expect to see in The Code Oven:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pizza menu**: At the heart of The Code Oven is an appetizing menu of eight
    delectable pizzas. Each pizza is presented with its name and cost, designed to
    whet your appetite and inform your choice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**An Add button**: Beside each mouth-watering option is an **Add** button.
    This enables users to start the ordering process by adding their chosen pizzas
    to a virtual shopping cart.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shopping cart**: A designated section on the screen shows users their current
    shopping cart, complete with the names and prices of each selected pizza.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modify cart**: Should you get second thoughts or just want more pizza, The
    Code Oven allows you to modify your cart by adding or removing items dynamically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Order total**: There’s no need for manual calculations – The Code Oven’s
    cart automatically computes and displays the total price of your chosen items.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A Place my order button**: A prominent **Place my order** button serves as
    the final step, which would, in a real-world application, process the order for
    delivery or pick-up:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 7.3: The Code Oven](img/B31103_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: The Code Oven'
  prefs: []
  type: TYPE_NORMAL
- en: As we build out The Code Oven, we’ll be applying TDD at every stage to ensure
    that our virtual pizzeria is not just functional but robust and easily maintainable.
    Get ready to roll up your sleeves, both for coding and for some virtual pizza-making!
  prefs: []
  type: TYPE_NORMAL
- en: Breaking down the application requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There isn’t a universal right way to break down the requirements of the application
    you are making; however, there are typically two different styles – the bottom-up
    style and the top-down style.
  prefs: []
  type: TYPE_NORMAL
- en: In the **bottom-up** style of TDD, developers start by writing tests and implementing
    functionality for the smallest and most fundamental components of the system.
    This approach emphasizes the construction of individual units or classes, thoroughly
    testing them before integrating them into higher-level components. It provides
    strong validation for the underlying parts of the system and helps in creating
    a robust foundation.
  prefs: []
  type: TYPE_NORMAL
- en: However, this style might lead to challenges in integrating the components if
    the bigger picture and interactions between the units are not carefully considered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to the online pizza store, we can break the whole page down into the following
    tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Implement a single `PizzaItem` component with a pizza name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a price to `PizzaItem`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a button to `PizzaItem`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a `PizzaList` component (render three items in a row, for example)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a simple `ShoppingCart` component with a button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support the ability to add/remove items to the `ShoppingCart` component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a calculation for the total number of pizzas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement the whole application with these individual standalone components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, each task focuses on an individual component at a time. The
    components start simple, with only the minimal function; then, we incrementally
    add more features to them, including test cases to cover the functionality required,
    as well as other reasonable edge cases.
  prefs: []
  type: TYPE_NORMAL
- en: So, we start from a single `PizzaItem` component (which only has a name in it)
    and then give it a price, and then a button. After the individual items are built,
    we start to implement `PizzaList`, and then `ShoppingCart`. Then, once `PizzaList`
    and `ShoppingCart` are done, we integrate them and test a few overall functions
    from the user’s perspective.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, as demonstrated in the following screenshot, we might start with
    a `PizzaItem` component, implementing the component gradually without worrying
    about anything else in the application. Once we have a full implementation of
    `PizzaItem` (with an image, name, price and `ShoppingCart`:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figu\uFEFFre 7.4: The bottom-up style](img/B31103_07_04.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.4: The bottom-up style'
  prefs: []
  type: TYPE_NORMAL
- en: The **top-down** style of TDD takes the opposite approach, beginning with the
    high-level architecture and overall functionality of the system. Developers first
    write tests and implement features for the main components and then gradually
    work their way down to the more detailed and specific functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: 'This style helps ensure that the system’s primary objectives and workflow are
    established early on, providing a clear roadmap for the development process. It
    can foster better integration and alignment with the overall goals but may sometimes
    require the use of temporary “stubs” or “mocks” to simulate lower-level components
    before they are developed. For instance, we could break the feature down into
    the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the page title
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a menu list containing the pizza names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a `ShoppingCart` component with only a button (disabled by default)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add an item to `ShoppingCart` when the button is clicked, after which the `ShoppingCart`
    button is enabled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a price to the `ShoppingCart` component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a total number of selected items to `ShoppingCart`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove an item from `ShoppingCart`, with the total number changing accordingly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the top-down approach, we don’t have a clear picture of the individual units
    but the working application as a whole – so we see the application from outside
    without knowing the implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: For example, there isn’t a `PizzaItem` component at the beginning, and the smaller
    components are gradually extracted from the bigger component when we find that
    the component is too big. This means we will always have functional software running
    (even if we don’t have the small well-designed components up-front), allowing
    us to stop at any time without breaking the functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'A possible breakdown with the top-down approach is shown in the following diagram.
    We start with an empty list, then a list with pizza names, and then a shopping
    cart that allows users to add items and proceed to the next step:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5: The top-down style](img/B31103_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.5: The top-down style'
  prefs: []
  type: TYPE_NORMAL
- en: (The textual detail in the previous figure is minimized and is not directly
    relevant to your understanding of it. If you would like to see the textual detail,
    please refer to the free downloadable eBook.)
  prefs: []
  type: TYPE_NORMAL
- en: Both styles have contributed to the rich variety of methodologies in modern
    software development, and neither is definitively “right” or “wrong.” Instead,
    they offer different perspectives and tools that developers can choose from based
    on their particular needs and preferences.
  prefs: []
  type: TYPE_NORMAL
- en: In the following parts of this chapter, we are going to use the top-down style
    as it forces us to think from the user’s perspective. We’ll explore the bottom-up
    approach in more detail in the following chapters when we introduce other design
    patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the application headline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s start with the implementation of the pizza store application. If you have
    cloned the repository mentioned in the *Technical requirements* section, simply
    go to the `react-anti-patterns-code/src/ch7` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we’re applying TDD, the first thing to do here is to write a test that fails.
    In the previous section, we mentioned what we want to test: implement the page
    title.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s create a file called `App.test.tsx` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We’re writing a test for the yet-to-be-created `PizzaShopApp` React component.
    Using the React Testing Library, we will render this component and verify whether
    it includes a heading labeled `expect(heading).toBeInTheDocument();` assertion
    confirms that the heading is successfully rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s run the test with the following command in your terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'An error will appear in the terminal saying `ReferenceError: PizzaShopApp is
    not defined`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6: The failed test](img/B31103_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.6: The failed test'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re in the red stage of the Red-Green-Refactor loop now, so we need to make
    the code pass using the simplest code possible. A static component that returns
    `PizzaShopApp`, in the test file that returns just the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When we re-run the test, it passes since `PizzaShopApp` does exactly the thing
    the test expects – it shows **The Code Oven**. Now, we’re at the green stage of
    the Red-Green-Refactor loop. Next, we can look into opportunities for improvement.
  prefs: []
  type: TYPE_NORMAL
- en: 'We don’t want to write all our code inside the test file – instead, we can
    use the `PizzaShopApp` into a separate file called `App.tsx`. Now, the implementation
    lives in its own file, allowing us to change the test and the component separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Awesome! With that, we have done a complete Red-Green-Refactor loop. We can
    now remove that task from our task list and move on to the next one.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The code doesn’t have to be perfect at the beginning as we know TDD is an iterative
    process; we always have a chance to make the code better as we have good tests
    protecting us.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the menu list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even a basic menu list featuring just the names of pizzas can be valuable for
    customers who are looking to browse and decide what to eat. While The Code Oven
    may not be set up for online ordering yet, it serves as a useful starting point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the second task on our list, we can write our second test like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This test starts by rendering the component. Then, it identifies the HTML element
    tagged with the `list` role from the rendered component. Using the `within` function,
    it narrows down the search to only that list and locates all items within it tagged
    with `listitem`. Finally, it asserts that the number of such items should be equal
    to `8` (the number of items the pizza shop has to offer). Essentially, we want
    eight list items to show up on the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the test has failed. To make the test pass easily, we can hard-code eight
    empty list items on the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It doesn’t look too good, but it makes the test pass all the same. This is important
    to remember – during TDD, we always want to make the test pass first and then
    look for opportunities to improve afterward. The advantage of this mindset forces
    us to think about delivery and production readiness; we should be able to stop
    coding at any point and release the app to production – even if the code isn’t
    perfect yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, re-run the test to see if it passes; if so, we can start refactoring it.
    To reduce the long hard-coded `<li>` (the list item tag in HTML), we can use an
    array with eight elements and use `map` to generate the `<li>` dynamically inside
    an ordered list (`<ol>`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Inside this list, an array with eight elements (all initialized to 0) is mapped
    over, generating eight empty list items (`<li>`). This matches the test criteria
    of having a menu list with eight items and the tests pass with the new structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, we’ve done another Red-Green-Refactor loop. Now, we can verify that
    the pizza names are displayed correctly. Let’s add a few more lines to the second
    test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To make all the newly added lines pass, we’ll need to define a list of pizza
    names in `PizzaShopApp`, and then use the `map` function in the `pizzas` array
    to map through these names into list items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The tests are now successfully passing. While the code may be overly simplified,
    the passing tests give us the confidence to make further changes without having
    to worry about any accidental feature breaks.
  prefs: []
  type: TYPE_NORMAL
- en: It’s great to have a menu list, but the purpose of The Code Oven is to help
    users order online. So, let’s look into how we can create a shopping cart.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the shopping cart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To develop a `ShoppingCart` component, we will start with a simple test that
    expects an empty container to show on the page. Inside the container, there should
    be a button for the user to place their order.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we will start with a test that simply checks that the container
    and button are present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The Jest test renders the `PizzaShopApp` component and then locates a shopping
    cart container by its `data-testid`. Within this container, it looks for a button
    element by its role. The test concludes by using the `toBeInTheDocument()` matcher
    to verify that this button is present in the rendered output.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this test pass, we can add an empty `div` as a container with `data-testid`,
    and put an empty button inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As the tests pass, we can add more details to the test, checking if the button
    is disabled by default.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Observe how we oscillate between the test code and the actual implementation,
    especially in the beginning. As you become more accustomed to the Red-Green-Refactor
    cycle, you’ll be able to write increasingly complex tests and adjust your code
    to pass them. The key objective initially is to establish this rapid feedback
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should now add a few more details to the test, to check the button text
    and the disabled status by default – we want to make sure users cannot interact
    with the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'With the new assertions added, the test failed again, waiting for us to add
    more details to the implementation. It’s straightforward to make the test pass
    by adding the text and `disabled` status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The tests are all passing again, so that’s another task to tick off (note how
    maintaining a task list can help us focus and gradually shape our application
    code).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at the next task – adding items from the menu to the shopping
    cart.
  prefs: []
  type: TYPE_NORMAL
- en: Adding items to the shopping cart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we have the basic structure of the `ShoppingCart` component, we need to
    add a few more assertions to verify it works. We will start by adding one item
    to the cart, which can be done with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This test renders the `PizzaShopApp` component, fetches the menu list, and
    grabs all the list items within it. Then, it simulates a user clicking the **Add**
    button of the first menu item. Next, it locates the shopping cart container and
    checks two things:'
  prefs: []
  type: TYPE_NORMAL
- en: The added item, **Margherita Pizza**, appears in the cart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Place My Order** button is enabled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s add the button to a menu item first, and then add a state to manage the
    user selection and enable the **Place My Order** button according to the selection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `PizzaShopApp` function component uses React’s `useState` Hook to manage
    an array of `cartItems`. It defines a function, `addItem`, to add items to this
    cart. The component renders a list of pizzas, each with an `addItem` function,
    adding the corresponding pizza to the `cartItems` array.
  prefs: []
  type: TYPE_NORMAL
- en: The shopping cart displays the items in `cartItems` in a list. The `cartItems`
    array. Specifically, the button is disabled when the cart is empty – `(cartItems.length
    ===` `0)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation looks great, but if we run the tests, something weird happens.
    The test failed in the terminal with the following error message: `TestingLibraryElementError:
    Found multiple elements with the role "list"`. This is because we have two lists
    (one in the menu and the other in the shopping cart) on the screen now, and the
    React Testing Library is confused about which one should look for the `data-testid`
    to the menu list and modifying the test accordingly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, let’s change our `PizzaShopApp` component and move the first `<ol>`
    (the ordered list tag) into a `div` element attributed with `data-testid="menu-list"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we must modify the test so that it looks as follows (note that we explicitly
    ask the React Testing Library to search inside `menu-list` for all list items):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'When we re-run the test, it fails again with this message: `TestingLibraryElementError:
    Unable to find an element with the text: Margherita Pizza`. This could be because
    the text is broken up by multiple elements. In this case, you can provide a function
    for your text matcher to make your matcher more flexible.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The expected `cartItems` state. But when React detects the state change and
    re-renders, the test isn’t waiting for that to happen. In other words, it’s too
    early for the test to see the updated `cartItems`. We need to give React a bit
    of time to digest the change and re-render. We can mark the test case as `async`
    and wait for `userEvent.click` to make the state change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this code snippet, the use of `async` and `await` ensures that the asynchronous
    operations are completed before they move on to the next step in the test. The
    test function itself is marked as async, making it return a Promise, which Jest
    will wait for before considering the test complete.
  prefs: []
  type: TYPE_NORMAL
- en: The `await userEvent.click(addButton);` line is particularly important here.
    `userEvent.click` simulates a real user clicking a button and might trigger state
    updates or effects in your React component. Using `await` ensures that all associated
    updates and effects are fully completed before moving on to the subsequent lines
    of the test.
  prefs: []
  type: TYPE_NORMAL
- en: By ensuring that `userEvent.click` has been fully processed, the test will then
    safely proceed to query and assert against the updated DOM or state. This is crucial
    for preventing false negatives, where the test might fail not because the code
    is incorrect, but because the test is checking the DOM before all updates have
    occurred.
  prefs: []
  type: TYPE_NORMAL
- en: Since all the tests are passing again, it’s time to look into other opportunities
    for improvement.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code we have now isn’t too hard to understand, but it has some room for
    improvement. Let’s quickly look at what we have got so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s make some changes. Firstly, we could use the `x` to `item`, to make
    it a bit more meaningful. Also, there is a warning in the terminal now, saying
    `Warning: Each child in a list should have a unique "key" prop` – as React expects
    a unique key for each item it renders, we need to have a key for each `<li>` element.
    For now, we can use the item (the pizza name) as the key to fix this issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As another change, the menu item list looks pretty self-contained and doesn’t
    depend on anything out of the context it lives in, so we can extract a new component
    here to encapsulate that logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `MenuList` component takes a single prop, `onAddMenuItem`, which is a function
    that accepts a string argument representing a menu item. The component renders
    a list of pizzas, which presumably is an array of strings. For each pizza, it
    creates a list item and an `onAddMenuItem` function is called with the corresponding
    pizza name as an argument. The component uses the `data-testid="menu-list"` attribute
    to make it easier to query this section during testing. Overall, this is a presentational
    component that’s designed to display a list of pizzas and handle the addition
    of menu items through the provided callback.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can extract a new component for the shopping cart, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `ShoppingCart` component takes an array of `cartItems` as its prop. This
    array holds the names of the items that have been added to the shopping cart.
    The component renders an ordered list (`<ol>`) where each list item (`<li>`) corresponds
    to an item in the cart. It uses the `data-testid="shopping-cart"` attribute to
    make it easier to identify this component in tests. Additionally, a `cartItems`
    array is empty, meaning there are no items in the cart. Overall, this component
    is designed to display the items in the shopping cart and provide an option to
    place an order.
  prefs: []
  type: TYPE_NORMAL
- en: 'After these extractions, we can use these components in the main component,
    `PizzaShopApp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: During these relatively big changes, our tests always stay in the green state
    – meaning no functions are broken. We haven’t implemented all the tasks we have
    broken down, but I believe you have got the idea of the Red-Green-Refactor loop.
    You can use the remaining tasks as exercises, making sure you always write the
    test first, with only the minimal code, and looking for improvements after the
    test passes.
  prefs: []
  type: TYPE_NORMAL
- en: You may initially find this coding approach challenging as it requires you to
    resist the temptation to immediately delve into implementation. Instead, take
    incremental steps and savor the journey. You’ll soon discover the strength that
    lies in taking small steps, as well as how maintaining a steady rhythm can enhance
    your focus and productivity.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter on TDD, we’ve explored various forms of TDD, emphasizing the
    importance of breaking down complex problems into manageable tasks through tasking.
    We delved into two key approaches – top-down and bottom-up, each with its distinct
    merits and use cases. To illustrate these concepts, we used a practical example
    of building a pizza shop application.
  prefs: []
  type: TYPE_NORMAL
- en: This hands-on example helped solidify the theories and methodologies we discussed,
    providing a comprehensive understanding of how TDD can be employed effectively
    in different scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming chapter, we’ll delve deeper into the intricate world of data
    management in React applications. Specifically, we’ll explore various design patterns
    that are commonly adopted for efficient data access and manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: Unveiling Business Logic and Design Patterns'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This part looks at business logic and design patterns, which are essential in
    tackling common challenges in state management and adhering to principles, such
    as the single responsibility principle, in order to maintain a clean and efficient
    code base.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part contains the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B21103_08.xhtml#_idTextAnchor212), *Exploring Data Management
    in React*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B21103_09.xhtml#_idTextAnchor227), *Applying Design Principles
    in React*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B21103_10.xhtml#_idTextAnchor251), *Diving Deep into Composition
    Patterns*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
