<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Diving Headfirst into ReactJS"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Diving Headfirst into ReactJS</h1></div></div></div><p>Welcome dear reader! In this book, you'll find a set of blueprints that you can use to develop modern web apps with ReactJS.</p><p>This chapter will introduce you to ReactJS and cover how to work with a component-based architecture. You will learn all the important concepts in ReactJS, such as creating and mounting components, working with props and states, understanding the life cycle methods, and setting up a development workflow for efficient development.</p><p>In this chapter we will:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Introduce ReactJS</li><li class="listitem" style="list-style-type: disc">Explore the props and states</li><li class="listitem" style="list-style-type: disc">Learn all about the important life cycle methods</li><li class="listitem" style="list-style-type: disc">Walk through synthetic events and the virtual DOM</li><li class="listitem" style="list-style-type: disc">Learn the modern JavaScript developer's workflow</li><li class="listitem" style="list-style-type: disc">Composition</li><li class="listitem" style="list-style-type: disc">Create a basic scaffolding for all our apps</li></ul></div><p>Even if you have previous experience with ReactJS, it's worth reading through this chapter, especially the scaffolding part, as we'll be using this scaffold for the majority of the blueprints in this book.</p><p>Let's begin!</p><div class="section" title="Introducing ReactJS"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Introducing ReactJS</h1></div></div></div><p>To efficiently develop with <a class="indexterm" id="id0"/>ReactJS, it is vital to understand what it is and is not. ReactJS is not a framework. ReactJS describes itself as the <span class="strong"><strong>V</strong></span> in the <span class="strong"><strong>MVC</strong></span> (<span class="strong"><strong>Model-View-Controller</strong></span>) design <a class="indexterm" id="id1"/>pattern. It's a view library that you can combine with<a class="indexterm" id="id2"/> frameworks such as <span class="strong"><strong>AngularJS</strong></span>, <span class="strong"><strong>Ember</strong></span>, and <span class="strong"><strong>Meteor</strong></span> or <a class="indexterm" id="id3"/>even in conjunction with other popular JavaScript libraries, such<a class="indexterm" id="id4"/> as <span class="strong"><strong>Knockout</strong></span>.</p><p>Many people <a class="indexterm" id="id5"/>use <span class="strong"><strong>React</strong></span> on its own and combine it with a data flow pattern called <span class="strong"><strong>Flux</strong></span>. The idea<a class="indexterm" id="id6"/> behind Flux is to establish unidirectional data flow, meaning that data <a class="indexterm" id="id7"/>should originate at a single point in your app and flow downwards. We'll look more closely into this pattern in <a class="link" href="ch02.html" title="Chapter 2. Creating a Web Shop">Chapter 2</a>, <span class="emphasis"><em>Creating a Web Shop</em></span>.</p><div class="section" title="Modern JavaScript development"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec06"/>Modern JavaScript development</h2></div></div></div><p>In 2015, JavaScript <a class="indexterm" id="id8"/>got its first major upgrade in many years. The syntax is JavaScript 2015. You may know it as EcmaScript 6. The EcmaScript committee decided on a name change in mid-2015, and from now on, JavaScript is going to be updated yearly. Modern browsers are slowly implementing support for the new features.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>A note on the code you'll be seeing in this book. We will be using JavaScript 2015 throughout the book. Evergreen browsers such as Firefox, Chrome, and Microsoft Edge will implement the new functionality on their own timeline, which means that some browsers may support new features before others, while some features may not be implemented at all.</p></div></div><p>You will most likely find yourself in a situation where you'd like to take advantage of new language features without wanting to wait for it to be implemented. Backwards compatibility is also an issue because you don't want to leave your users behind.</p><p>The solution to both of these concerns is to use a transpiler to generate a baseline EcmaScript-5-compatible code, such<a class="indexterm" id="id9"/> as <span class="strong"><strong>Traceur</strong></span> or <span class="strong"><strong>Babel</strong></span>. Since Babel was partly built with ReactJS in <a class="indexterm" id="id10"/>mind, I suggest that you go with this one, and throughout the book, we'll be depending on Babel for our transpiling needs.</p><p>We'll be exploring the modern developer's workflow in this book by developing and iterating a scaffolding or a basic setup that we can use when starting new projects. When setting up and using this scaffolding, we'll rely heavily on the terminal, <code class="literal">Node.js</code> and <code class="literal">npm</code>. Don't worry if this is unfamiliar ground for you. We'll go slow.</p></div></div></div>
<div class="section" title="Component specification"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Component specification</h1></div></div></div><p>ReactJS<a class="indexterm" id="id11"/> components have a built-in set of methods and properties that you'll come to<a class="indexterm" id="id12"/> rely on. Some of them are for debugging, such as <code class="literal">displayName</code> and <code class="literal">propTypes</code>; some for setting initial data, such as <code class="literal">getInitialState</code> and <code class="literal">getDefaultProps</code>; and finally, there are a number of methods dealing with the component life cycle, such as <code class="literal">componentDidMount</code>, <code class="literal">componentShouldUpdate</code>, and more.</p><div class="section" title="Props and states"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Props and states</h2></div></div></div><p>Data within a component can come from the outside (<span class="emphasis"><em>props</em></span>) or be instantiated from the inside (<span class="emphasis"><em>states</em></span>).</p><p>For testability and<a class="indexterm" id="id13"/> immutability concerns, it's desirable to rely on data that is passed to components as much as possible rather than working with an internal state. However, there are lots of reasons why you'd want to use an internal state, so let's take a detailed look at props and states and when you want to use which.</p><div class="section" title="Props"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec01"/>Props</h3></div></div></div><p>Let's look at a simple<a class="indexterm" id="id14"/> component:</p><div class="informalexample"><pre class="programlisting">import React from 'react';
import { render } from 'react-dom';

const App = React.createClass({
  render() {
    return (
      &lt;div&gt;My first component&lt;/div&gt;
    );
  }
});

render(&lt;App /&gt;, document.querySelector('#app'));</pre></div><p>When you execute this component, you will see the words <span class="strong"><strong>My first component</strong></span> in your browser window.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>Note that the app renders to <code class="literal">div</code> with the <code class="literal">id</code> app.</p></div></div><p>The corresponding HTML file needs to look something like this:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;body&gt;
  &lt;div id="app"&gt;&lt;/div&gt;
&lt;/body&gt;

&lt;script type="text/javascript" src="app.js"&gt;&lt;/script&gt;</pre></div><p>This component defines a constant called <code class="literal">app</code>, which creates a React component with the built-in <code class="literal">createClass</code> method.</p><p>The <code class="literal">rende</code>r method is the only required method in a ReactJS component. You can eschew all other methods, but<a class="indexterm" id="id15"/> this one. In <code class="literal">render</code>, you can either write a combination of HTML and JavaScript called <span class="strong"><strong>JSX</strong></span> or compose your HTML code using ReactJS elements.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>JavaScript doesn't understand JSX, so when you write JSX code, you need to convert it to JavaScript before executing it in the JavaScript environment. The easiest way to convert JSX is using the Babel transpiler because it will do this automatically.</p></div></div><p>Whichever way you decide to do it, the following JSX code will be transformed:</p><div class="informalexample"><pre class="programlisting">&lt;div&gt;My first component&lt;/div&gt;</pre></div><p>It will be transformed to this:</p><div class="informalexample"><pre class="programlisting">React.createElement("div", null, "My first component");</pre></div><p>The <code class="literal">createElement()</code> method accepts three parameters: the <code class="literal">html</code> tag, a <code class="literal">null</code> field, and the HTML code. The second field is actually an object with properties (or <code class="literal">null</code>). We'll get back to this a little bit later.</p><p>Let's introduce the concept of properties and make this component a bit more interesting:</p><div class="informalexample"><pre class="programlisting">const App = React.createClass ({
  render() {
    return (
      &lt;div&gt;{this.props.greeting}&lt;/div&gt;
    );
  }
});

render(&lt;App greeting="Hello world!"/&gt;,
document.querySelector('#app'));</pre></div><p>All component properties are available for use by accessing <code class="literal">this.props</code>. Here, we set an initial message, <span class="strong"><strong>Hello World!</strong></span>, and now, this is what you see when you execute the component:</p><div class="mediaobject"><img alt="Props" src="graphics/B04943_01_01.jpg"/></div><p>Props cannot be modified<a class="indexterm" id="id16"/> and should be treated as immutable.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>Note that props are sent together with the call to the component.</p></div></div><p>You can send as many properties as you want, and they are always available under <code class="literal">this.props</code>.</p><p>If you have multiple properties that you want to send, just add them sequentially to the component call:</p><div class="informalexample"><pre class="programlisting">&lt;App greeting="Hello world" message="Enjoy the day" /&gt;</pre></div><p>You can set a component's initial props by calling <code class="literal">getDefaultProps</code>. This can be helpful when you anticipate that a prop will be used, but it's not available until a later point in the component's life cycle:</p><div class="informalexample"><pre class="programlisting">getDefaultProps() {
  return {
    greeting: ""
  }
}</pre></div><p>If you call the component by adding a greeting, the component will simply show an empty page. If you don't have<a class="indexterm" id="id17"/> an initial prop, React will throw an error and complain that you're referencing a property that doesn't exist.</p></div><div class="section" title="States"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec02"/>States</h3></div></div></div><p>States are similar to <a class="indexterm" id="id18"/>props, but are meant for variables that are only available within the component. You can set a state in the same way as props:</p><div class="informalexample"><pre class="programlisting">setInitialState() {
  return {
    greeting: "Hello world!"
  }
}</pre></div><p>Also, you can call the variable with <code class="literal">this.state</code>:</p><div class="informalexample"><pre class="programlisting">render() {
  return (
    &lt;div&gt;{this.state.greeting}&lt;/div&gt;
   );
}</pre></div><p>Similar to props, if you try to use a nonexisting state variable, ReactJS will throw an error.</p><p>A state is primarily used when you make changes that only make sense within the component. Let's look at an example to understand this:</p><div class="informalexample"><pre class="programlisting">getInitialState: function () {
  return {
    random_number: 0
  }
},
componentDidMount(){
  setInterval(()=&gt;{
    this.setState({
      random_number: Math.random()*100
    });
  },1000)
},
render() {
  return (
    &lt;div&gt;{this.state.random_number}&lt;/div&gt;
  );
}</pre></div><p>Here, we set a <code class="literal">random_number</code> variable to <code class="literal">0</code>. We access the built-in <code class="literal">componentDidMount</code> method and start an interval that sets a new random number for this variable every second. In<a class="indexterm" id="id19"/> the render, we simply output the variable. Every time the state changes, ReactJS responds by re-rendering the output. Whenever you run <code class="literal">setState</code>, ReactJS triggers a re-render of the component. It's worth taking care to limit the number of times you apply <code class="literal">setState</code>, as you may run into performance issues if you're liberal with the use of them.</p></div></div><div class="section" title="render"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>render</h2></div></div></div><p>This is the only required <a class="indexterm" id="id20"/>method in a component. It should return a single child element, such as a JSX structure, but if you don't want to render anything, it can also return <code class="literal">null</code> or <code class="literal">false</code> to indicate that you don't want anything rendered:</p><div class="informalexample"><pre class="programlisting">render(){
  return (&lt;div&gt;My component&lt;/div&gt;);
}</pre></div></div><div class="section" title="statics"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>statics</h2></div></div></div><p>This object can be <a class="indexterm" id="id21"/>used to define static methods that can be called on the component:</p><div class="informalexample"><pre class="programlisting">import React from 'react';
const App = React.createClass ({
  statics: {
    myMethod: (foo) =&gt; {
      return foo == "bar";
    }
  },
  render() {
    return null;
  }
});
console.log(App.myMethod('bar'));  // true</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>Note that static methods don't have access to the props or state of your components.</p></div></div></div><div class="section" title="propTypes"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>propTypes</h2></div></div></div><p>This object allows you to validate props being passed to your components. This is an optional tool to help you <a class="indexterm" id="id22"/>when developing your apps and will show up in your console log if the props you pass to a component do not match your specifications:</p><div class="informalexample"><pre class="programlisting">propTypes: {
  myOptionalObject: React.PropTypes.object,
  aRequiredString: React.PropTypes.string.isRequired,
  anOptionalNumber: React.PropTypes.number,
  aValueOfAnyKind: React.PropTypes.any,
  customProp: function(props, propName, componentName) {
    if (!/matchme/.test(props[propName])) {
      return new Error('Validation failed!');
    }
  }
}</pre></div><p>The final example creates a custom validator, which you can use to validate even more complex data values.</p></div><div class="section" title="displayName"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>displayName</h2></div></div></div><p>This value is set automatically<a class="indexterm" id="id23"/> if you don't set it explicitly, and it is used for debugging purposes:</p><div class="informalexample"><pre class="programlisting">displayName: "My component Name"</pre></div></div></div>
<div class="section" title="Life cycle methods"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Life cycle methods</h1></div></div></div><p>Life cycle methods are a set <a class="indexterm" id="id24"/>of functions that you can override in your component. Initially, all but <code class="literal">shouldComponentUpdate</code> (which defaults to <code class="literal">true</code>) is empty.</p><div class="section" title="componentDidMount"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>componentDidMount</h2></div></div></div><p>This is one of the most <a class="indexterm" id="id25"/>common methods you'll employ in your apps. Here's where you place any functions you want to run directly after the <a class="indexterm" id="id26"/>component has been rendered for the first time.</p><p>You have access to the current contents of states and props in this method, but take care to never run <code class="literal">setState</code> in here, as that will trigger an endless update loop.</p><p>It's worth noting that if you're making a server-side app, this component will not be called. In this case, you'll <a class="indexterm" id="id27"/>have to rely on <code class="literal">componentWillMount</code> instead:</p><div class="informalexample"><pre class="programlisting">componentDidMount() {
  // Executed after the component is mounted
}</pre></div></div><div class="section" title="componentWillMount"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>componentWillMount</h2></div></div></div><p>This method will be<a class="indexterm" id="id28"/> executed before the component is rendered for the first time. You have access to the current component's state and props here, and <a class="indexterm" id="id29"/>unlike <code class="literal">componentDidMount</code>, it's safe to run <code class="literal">setState</code> here (ReactJS will understand that state changes in this method should be set immediately and not trigger a re-render).</p><p>This method is executed on both server-side and client-side apps:</p><div class="informalexample"><pre class="programlisting">componentWillMount() {
  // Executed before the component is mounted 
}</pre></div></div><div class="section" title="shouldComponentUpdate"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>shouldComponentUpdate</h2></div></div></div><p>This method is invoked <a class="indexterm" id="id30"/>whenever the component receives new props or a change in state occurs.</p><p>By default, <code class="literal">shouldComponentUpdate</code> returns a <code class="literal">true</code> value. If you override it and return <code class="literal">false</code>, the component <a class="indexterm" id="id31"/>will never be updated despite receiving updated props or a new state. This can be useful if you create a component that should only be updated if certain conditions are met or if it should never be updated at all. You can benefit from speed increases if you set this to <code class="literal">false</code> when you have a component that should never be updated. However, you should take great care when using this method because careless use can lead to bugs that can be very hard to track down.</p></div><div class="section" title="componentWillReceiveProps"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec15"/>componentWillReceiveProps</h2></div></div></div><p>This method lets you <a class="indexterm" id="id32"/>compare the incoming props and can <a class="indexterm" id="id33"/>be used as an opportunity to react to a prop transition before the render method is called. Invoke this method with <code class="literal">componentWillReceiveProps(object nextProps)</code> in order to access the incoming props with <code class="literal">nextProps</code>.</p><p>It's worth noting that if you call <code class="literal">setState</code> here, an additional re-render will not be triggered. It's not called for the initial render.</p><p>There's no analogous method to react to a pure state change, but you can use <code class="literal">componentWillUpdate</code> if you<a class="indexterm" id="id34"/> need a way to react to state changes before they are rendered.</p><p>This method is not executed on the initial render:</p><div class="informalexample"><pre class="programlisting">componentWillReceiveProps(nextProps) {
  // you can compare nextProps with this.props
  // and optionally set a new state or execute functions
  // based on the new props

}</pre></div></div><div class="section" title="componentWillUpdate"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec16"/>componentWillUpdate</h2></div></div></div><p>This method is<a class="indexterm" id="id35"/> executed before the rendering, when the <a class="indexterm" id="id36"/>component receives new props or states but not on the initial render.</p><p>Invoke this method with <code class="literal">componentWillUpdate(object nextProps, object nextState)</code> in order to access the incoming props and states with <code class="literal">nextProps</code> and <code class="literal">nextState</code>.</p><p>Since you can evaluate a new state in this method, calling <code class="literal">setState</code> here will trigger an endless loop. This means that you cannot use <code class="literal">setState</code> in this method. If you want to run <code class="literal">setState</code> based on a prop change, use <code class="literal">componentWillReceiveProps</code> instead:</p><div class="informalexample"><pre class="programlisting">componentWillUpdate (nextProps) {
  // you can compare nextProps with this.props 
  // or nextState with this.state
}</pre></div></div><div class="section" title="componentDidUpdate"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec17"/>componentDidUpdate</h2></div></div></div><p>This method is executed<a class="indexterm" id="id37"/> whenever the component receives new <a class="indexterm" id="id38"/>props or states and the render method has been executed:</p><div class="informalexample"><pre class="programlisting">componentDidUpdate() {
  // Execute functions after the component has been updated
}</pre></div></div><div class="section" title="componentWillUnmount"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec18"/>componentWillUnmount</h2></div></div></div><p>The final life cycle <a class="indexterm" id="id39"/>method is <code class="literal">componentWillUnmount</code>. This is invoked just before the component is unmounted from the DOM. If you need to clean up memory or invalidate timers, this is the place to do it:</p><div class="informalexample"><pre class="programlisting">componentWillUnmount() {
  // Execute functions before the component is unmounted
  // from the DOM
}</pre></div></div></div>
<div class="section" title="Synthetic events and the Virtual DOM"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Synthetic events and the Virtual DOM</h1></div></div></div><p>Let's explore the<a class="indexterm" id="id40"/> differences between the regular DOM and the virtual DOM and what you need to consider when writing your code.</p><div class="section" title="The DOM"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec19"/>The DOM</h2></div></div></div><p>The <span class="strong"><strong>Document Object Model</strong></span> (<span class="strong"><strong>DOM</strong></span>) is a programming API for HTML documents. Whenever you ask a browser to render HTML, it parses what you have written and turns it into a DOM and then <a class="indexterm" id="id41"/>displays it in the browser. It is very forgiving, so you can write invalid HTML and still get the result you want without even knowing you made a mistake.</p><p>For instance, say, you write the following line of code and parse it with a web browser:</p><div class="informalexample"><pre class="programlisting">       &lt;p&gt;I made a new paragraph! :)</pre></div><p>After this, the DOM will show the following structure:</p><div class="mediaobject"><img alt="The DOM" src="graphics/B04943_01_02.jpg"/></div><p>The closing <code class="literal">&lt;/p&gt;</code> tag is automatically inserted for you, and a DOM element for the <code class="literal">&lt;p&gt;</code> tag has been created with all its associated properties.</p><p>ReactJS is not as <a class="indexterm" id="id42"/>forgiving. If you write the same HTML in your <code class="literal">render</code> method, it will fail to render and throw an <code class="literal">«Unterminated JSX contents»</code> error. This is because JSX requires a strict match between opening and closing tags. This is actually a good thing because it helps you with writing syntactically correct HTML.</p></div><div class="section" title="The virtual DOM"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec20"/>The virtual DOM</h2></div></div></div><p>The virtual DOM is basically a simpler implementation of the real DOM.</p><p>ReactJS doesn't work directly with the DOM. It uses a concept of virtual DOM, whereby it maintains a smaller<a class="indexterm" id="id43"/> and more simplified internal set of elements, and only pushes changes to the visible DOM when there has been a change of state in the set of elements. This enables you to switch out parts of your visible elements without the other elements being affected, and in short, this makes the process of DOM updates very efficient. The best part of this is that you get it all for free. You don't have to worry about it because ReactJS handles everything in the background.</p><p>It does, however, mean<a class="indexterm" id="id44"/> that you cannot look for changes in the DOM and make changes directly, like you would normally do with libraries, such as<a class="indexterm" id="id45"/> <span class="strong"><strong>jQuery</strong></span>, or native JavaScript functions, such as <code class="literal">getElementById()</code>.</p><p>Instead, you need to attach a reference named <code class="literal">refs</code> to the elements you want to target. You can do this by adding <code class="literal">ref="myReference"</code> to your element. The reference is now available through a call to <code class="literal">React.findDOMNode(this.refs.myReference)</code>.</p></div><div class="section" title="Synthetic event handlers"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec21"/>Synthetic event handlers</h2></div></div></div><p>Whenever you call an event handler within ReactJS, they are passed an instance of <span class="strong"><strong>SyntheticEvent</strong></span> instead of the <a class="indexterm" id="id46"/>native event handler. This has the same interface as the native event handler's, except it's cross-browser compatible so you can use it without worrying whether you need to make exceptions in your code for different browser implementations.</p><p>The events are triggered in a bubbling phase. This means that the event is first captured down to the deepest target and then propagated to outer elements.</p><p>Sometimes, you may find yourself wanting to capture the event immediately. In such cases, adding <code class="literal">Capture</code> behind the event can achieve this. For instance, to capture <code class="literal">onClick</code> immediately, use <code class="literal">onClickCapture</code> and so on.</p><p>You can stop propagation by calling <code class="literal">event.stopPropagation()</code> or <code class="literal">event.preventDefault()</code> where appropriate.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note07"/>Note</h3><p>A complete list of the<a class="indexterm" id="id47"/> available event handlers is available at <a class="ulink" href="https://facebook.github.io/react/docs/events.html">https://facebook.github.io/react/docs/events.html</a>.</p></div></div></div><div class="section" title="Putting it all together"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec22"/>Putting it all together</h2></div></div></div><p>When we put all<a class="indexterm" id="id48"/> this together, we can extend the sample app with referenced elements and an event handler:</p><div class="informalexample"><pre class="programlisting">import React from 'react';
import {render} from 'react-dom';

const App = React.createClass ({

  getInitialState() {
    return {
      greeting: "",
      message: ""
    }
  },

  componentWillMount() {
    this.setState ({
      greeting: this.props.greeting
    });
  },

  componentDidMount() {
    this.refs.input.focus();
  },

  handleClear: function (event) {
    this.refs.input.value="";
    this.setState ({
      message: ""
    });
  },

  handleChange: function (event) {
    this.setState ({
      message: event.target.value
    });
  },

  render: function () {
    return (
      &lt;div&gt;
        &lt;h1&gt;Refs and data binding&lt;/h1&gt;
        &lt;h2&gt;{this.state.greeting}&lt;/h2&gt;
        Type a message:
        &lt;br/&gt;
        &lt;input type="text" ref="input"
          onChange={this.handleChange} /&gt;
        &lt;br/&gt;
        Your message: {this.state.message}
        &lt;br/&gt;
        &lt;input type="button"
          value="Clear"
          onClick={this.handleClear}
        /&gt;
      &lt;/div&gt;

    );
  }

});

render (
  &lt;App greeting="Let's bind some values" /&gt;,
    document.getElementById('#app')
);</pre></div><p>Let's start at the end. As we did earlier, we initialize our app by rendering a single ReactJS component called <span class="strong"><strong>app</strong></span> with <a class="indexterm" id="id49"/>a single prop onto the element with the <code class="literal">#app</code> ID.</p><p>Before the app mounts, we set initial values for our two state values: <code class="literal">greeting</code> and <code class="literal">message</code>. Before the app mounts, we set the state for greeting to be the same value as the greeting property passed to the app.</p><p>We then add the input <a class="indexterm" id="id50"/>box and a clear button as well as some text in our <code class="literal">render</code> method and attach an <code class="literal">onChange</code> handler and an <code class="literal">onClick</code> handler to these. We also add <code class="literal">ref</code> to the input box.</p><p>After the component has mounted, we locate the message box by its <code class="literal">ref</code> parameter and tell the browser to focus on it.</p><p>Finally, we can go the event handlers. The <code class="literal">onChange</code> handler is bound to <code class="literal">handleChange</code>. It will activate on every key press and save a new message state, which is the current content of the input box. ReactJS will then re-render the content in the <code class="literal">render</code> method. In the reconciliation process, it will note that the value in the input box is different from the last render, and it will make sure that this box is rendered with the updated value. At the same time, ReactJS will also populate the empty text element after <span class="strong"><strong>Your message:</strong></span> with the state value.</p><p>The <code class="literal">handleClear</code> method simply resets the message state and clears the input box using <code class="literal">refs</code>.</p><p>This example is slightly contrived. It could be shortened quite a bit, and storing props as states is generally something you should avoid, unless you have a very good reason for doing so. In my experience, working with a local state is the single most bug-prone code you will encounter and the hardest code to write tests for.</p></div></div>
<div class="section" title="Composition"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Composition</h1></div></div></div><p>Composition is the act of combining things together to make more complex things and then putting these things together to make even more complex things, and so on.</p><p>Knowing how to put<a class="indexterm" id="id51"/> together ReactJS components is vital when creating apps that go beyond Hello World. An app composed of many small parts is more manageable than a single large monolith app.</p><p>Composing apps is very simple with ReactJS. For instance, the Hello World app we just created can be imported into a new component with the following code:</p><div class="informalexample"><pre class="programlisting">const HelloWorld = require("./helloworld.jsx");
const HelloWorld = require("./helloworld.jsx");</pre></div><p>In your new component, you can use the <code class="literal">HelloWorld</code> variable like this:</p><div class="informalexample"><pre class="programlisting">render() {
  return &lt;div&gt;
  &lt;HelloWorld /&gt;
&lt;/div&gt;
}</pre></div><p>Every component you created can be imported and used in this manner, and this is one of the many compelling reasons for choosing ReactJS.</p></div>
<div class="section" title="Developing with modern frontend tools"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Developing with modern frontend tools</h1></div></div></div><p>It's hard to overstate the<a class="indexterm" id="id52"/> importance of <code class="literal">Node.js</code> and <code class="literal">npm</code> in modern JavaScript development. These key pieces of technology are central to the development of JavaScript web apps, and we'll be relying on <code class="literal">Node.js</code> and <code class="literal">npm</code> for the applications that we will be developing in this book.</p><p>Node.js is available for Windows, Mac, and Linux, and is a breeze to install. We'll be using <code class="literal">Node.js</code> and <code class="literal">npm</code> for all of the examples in this book. We'll also be using EcmaScript 2015 and a transpiler to convert the code to a baseline JavaScript code that is compatible with older browsers.</p><p>If you haven't been using this workflow before, get ready to be excited because not only will it make you more productive, it will also open a world of developer goodness.</p><p>Let's begin.</p><div class="section" title="Browserify"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec23"/>Browserify</h2></div></div></div><p>The traditional method of<a class="indexterm" id="id53"/> developing for the Web had you manually adding<a class="indexterm" id="id54"/> scripts to your <code class="literal">index.html</code> file. It usually consisted of a mix of frameworks or libraries topped off with your own code, which you then added sequentially so that it was loaded and executed in the correct order. There are a few drawbacks to this method of development. Version control becomes difficult because you have no good way of controlling whether newer versions of your external libraries are compatible with the rest of your code. As a consequence, many web apps ship with old JavaScript libraries. Organizing your scripts is another problem because you have to add and remove old versions manually when upgrading. File size is also problematic because many libraries ship with more bells and whistles than you need.</p><p>Wouldn't it be nice if <a class="indexterm" id="id55"/>we had tools that could keep your dependencies up to date, inform you when there are incompatibility issues, and remove code you don't use? The answer to all of this is yes, and fortunately, such utilities exist.</p><p>The only drawback is that you have to change the way you write your code. Instead of writing scripts that rely on global environment variables, you write modular code that is self-contained, and you always specify your dependencies up front. If you think that this doesn't sound like much of a drawback, you're right. In fact, it's a huge improvement because this makes it very easy to read and understand code and allows easy dependency injection when writing tests.</p><p>Two of the most popular tools for assembling modular code are <span class="strong"><strong>Browserify</strong></span> and <span class="strong"><strong>Webpack</strong></span>.</p><p>In the beginning, we'll focus on <a class="indexterm" id="id56"/>
<span class="strong"><strong>Browserify</strong></span> for the simple reason that<a class="indexterm" id="id57"/> it's very easy to work with and has excellent plugin support. We'll look at <span class="strong"><strong>Webpack</strong></span> in <a class="link" href="ch06.html" title="Chapter 6. Advanced React">Chapter 6</a>, <span class="emphasis"><em>Advanced React</em></span>. Both of these tools will analyze your application, figure out which modules you're using, and assemble a JavaScript file that contains everything you need to load the code in a browser.</p><p>In order for this to work, you need a base file, a starting point for your application. In our scaffold, we'll call this <code class="literal">app.jsx</code>. This file will contain references to your modules and the components that it uses. When you create new components and connect them to <code class="literal">app.jsx</code> or the children of <code class="literal">app.jsx</code>, <span class="strong"><strong>Browserify</strong></span> will add them to the bundle.</p><p>A number of tools exist to enhance the bundle generation with Browserify. For EcmaScript 2015 and newer JavaScript code, we'll <a class="indexterm" id="id58"/>use <span class="strong"><strong>Babelify</strong></span>. It's a handy tool that in addition to converting JavaScript to EcmaScript 5 will also to convert React-specific code such as JSX. In other words, you don't have to use a separate JSX transformer in order to use JSX.</p><p>We'll also be<a class="indexterm" id="id59"/> using <span class="strong"><strong>Browser-sync</strong></span>, which is a tool that auto reloads your code while you edit. This speeds up the development process immensely, and after using it for a while, you'll never want to go back to refreshing your app manually.</p></div><div class="section" title="Scaffolding our React app"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec24"/>Scaffolding our React app</h2></div></div></div><p>These are the steps<a class="indexterm" id="id60"/> we'll be taking to set up our development workflow:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create an <code class="literal">npm</code> project.</li><li class="listitem">Install dependencies.</li><li class="listitem">Create a server file.</li><li class="listitem">Create a development directory.</li><li class="listitem">Create our base <code class="literal">app.jsx</code> file.</li><li class="listitem">Run the server.</li></ol></div><p>First of all, make sure that you have <a class="indexterm" id="id61"/>
<code class="literal">npm</code> installed. If not, head over to <a class="ulink" href="https://nodejs.org/download/">https://nodejs.org/download/</a> and download the installer. The detailed explanation of the preceding steps is as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a directory where you want the app to be sorted and open a terminal window and <code class="literal">cd</code> in this folder.<p>Initialize your app by typing <code class="literal">npm init</code> followed by the <span class="emphasis"><em>Enter</em></span> key. Give the project a name and answer the few questions that follow or just leave them empty.</p></li><li class="listitem">We're going to grab a few packages from <code class="literal">npm</code> to get started. Issuing the following command will get the packages and add the dependencies to your newly created <code class="literal">package.json</code> file:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>npm install –-save babelify@7.2.0 browserify-middleware@7.0.0 express@4.13.3 react@0.14.3 reactify@1.1.1 browser-sync@2.10.0 babel-preset-react@6.3.13 babel-preset-es2015@6.3.13 browserify@12.0.1 react-dom@0.14.3 watchify@3.6.1</strong></span>
</pre></div><p>Babel requires a configuration file called <code class="literal">.babelrc</code>. Add it to the following code:</p><div class="informalexample"><pre class="programlisting">{
  "presets": ["es2015","react"]
}</pre></div></li><li class="listitem">Create a new text file with your favorite text editor, add the following code, and save it as <code class="literal">server.js</code>:<div class="informalexample"><pre class="programlisting">var express = require("express");
var browserify  = require('browserify-middleware');
var babelify = require("babelify");
var browserSync = require('browser-sync');
var app = express();
var port = process.env.PORT || 8080;</pre></div><p>This segment sets up our app using <a class="indexterm" id="id62"/>
<span class="strong"><strong>express</strong></span> as our web server. It also initalizes <code class="literal">browserify</code>, <code class="literal">babelify</code>, and <code class="literal">browser-sync</code>. Finally, we set up our app to run on port <code class="literal">8080</code>. The line <code class="literal">process.env.PORT || 8080</code> simply means that you can override the port by prefixing the server script with <code class="literal">PORT 8085</code> to run on port <code class="literal">8085</code> or any other port you'd like to use:</p><div class="informalexample"><pre class="programlisting">browserify.settings ({
  transform: [babelify.configure({
  })],
  presets: ["es2015", "react"],
  extensions: ['.js', '.jsx'],
  grep: /\.jsx?$/
});</pre></div><p>This sets up <a class="indexterm" id="id63"/>Browserify to transform all code with that of the file extension <code class="literal">.jsx</code> with Babelify. The stage <code class="literal">0</code> configuration means that we want to use experimental code that has yet to be approved by the EcmaScript committee:</p><div class="informalexample"><pre class="programlisting">// serve client code via browserify
app.get('/bundle.js', browserify(__dirname+'/source/app.jsx'));</pre></div><p>We want to reference our JavaScript bundle with <code class="literal">&lt;script src="bundle.js"&gt;&lt;/script&gt;</code> in our <code class="literal">index.html</code> file. When the web server notices a call for this file, we tell the server to send the browserified <code class="literal">app.jsx</code> file in our <code class="literal">source</code> folder instead:</p><div class="informalexample"><pre class="programlisting">// resources
app.get(['*.png','*.jpg','*.css','*.map'], function (req, res) {
  res.sendFile(__dirname+"/public/"+req.path);
});</pre></div><p>With this configuration, we tell the web server to serve any of the listed files from <code class="literal">public.folder</code>:</p><div class="informalexample"><pre class="programlisting">// all other requests will be routed to index.html
app.get('*', function (req, res) {
  res.sendFile(__dirname+"/public/index.html");
});</pre></div><p>This line instructs the web server to serve <code class="literal">index.html</code> if the user accesses the root path:</p><div class="informalexample"><pre class="programlisting">// Run the server
app.listen(port,function() {
  browserSync ({
    proxy: 'localhost:' + port,
        files: ['source/**/*.{jsx}','public/**/*.{css}'],
    options: {
      ignored: 'node_modules'
    }
  });
});</pre></div><p>Finally, this runs<a class="indexterm" id="id64"/> the web server with <code class="literal">browser-sync</code>, proxying your app at the port you choose. This means that if you specify port <code class="literal">8080</code> as your port, your front-facing port will be a proxy port (usually <code class="literal">3000</code>), which will access <code class="literal">8080</code> on your behalf.</p><p>We tell <code class="literal">browser-sync</code> to monitor all JSX files in our <code class="literal">source/</code> folder and our CSS files in our <code class="literal">public/</code> folder. Whenever these change, <code class="literal">browser-sync</code> will update and refresh the page. We also tell it to ignore all the files in the <code class="literal">node_modules/</code> folder. This is generally wise to do because the folder will often contain thousands of files, and you don't want to waste time waiting for these files to be scanned.</p></li><li class="listitem">Next, create two a directories called <code class="literal">public</code> and <code class="literal">source</code>. Add the following three files: <code class="literal">index.html</code> and <code class="literal">app.css</code> to your public folder and <code class="literal">app.jsx</code> to your <code class="literal">source</code> folder.<p>Write this in the <code class="literal">index.html</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;ReactJS Blueprints&lt;/title&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;link rel="stylesheet" href="app.css" /&gt;

  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="container"&gt;&lt;/div&gt;
      &lt;script src="bundle.js"&gt;&lt;/script&gt;
  &lt;/body&gt;

&lt;/html&gt;</pre></div><p>Write this in the <code class="literal">app.css</code> file:</p><div class="informalexample"><pre class="programlisting">body {
  background:#eee;
  padding:22px;
}
br {
  line-height: 2em;
}
h1 {
  font-size:24px;
}
h2 {
  font-size:18px;
}</pre></div><p>Write this in the <code class="literal">app.jsx</code> file:</p><div class="informalexample"><pre class="programlisting">'use strict';
import React from 'react';
import { render } from 'react-dom';
const App = React.createClass({
  render() {
    return (
      &lt;section&gt;
        &lt;h1&gt;My scaffold&lt;/h1&gt;
        &lt;p&gt;Hello world&lt;/p&gt;
      &lt;/section&gt;
    );
  }
});

render (
  &lt;App /&gt;,
    document.getElementById('container')
);</pre></div><p>Your file <a class="indexterm" id="id65"/>structure should now look like this:</p><div class="mediaobject"><img alt="Scaffolding our React app" src="graphics/B04943_01_03.jpg"/></div></li></ol></div></div><div class="section" title="Running the app"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec25"/>Running the app</h2></div></div></div><p>Go the root of the app, type <code class="literal">node server</code>, and then press <span class="emphasis"><em>Enter</em></span>. This will start a node server and in a few seconds,	 <code class="literal">browser-sync</code> will open a web browser with the location <code class="literal">http://localhost:3000</code>. If you <a class="indexterm" id="id66"/>have any other web servers or processes running on port <code class="literal">3000</code>, <code class="literal">browser-sync</code> will choose a different port. Take a look at the console output to make sure which port it has chosen.</p><p>You will see the contents of your render method from <code class="literal">app.jsx</code> on the screen. In the background, Browserify has employed Babelify to convert your JSX and ES2015 code as well as your imported dependencies to a single <code class="literal">bundle.js</code> file that is served on <code class="literal">http://localhost:3000</code>. The app and CSS code will be refreshed every time you make a change in the code while this server is running, so I urge you to experiment with the code, implement a few life cycle methods, try working with states and props, and generally get a feel of working with ReactJS.</p><p>If this is your first time working with this kind of setup, I'd imagine you feel quite a rush surging through you right now. This setup is very empowering and fun to work with, and best of all, it's almost effortless to scaffold.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Summary</h1></div></div></div><p>In this chapter, we looked at all the important concepts you will come to work with when you develop applications with ReactJS. We looked at the component specification, how to compose components, and life cycle methods before we went to look at how to set up and structure a ReactJS app. Finally, we went through the scaffolding that we'll be using for the blueprints in this book.</p><p>In the next chapter, we'll go through our first blueprint and create a web shop. We'll explore the concept of unidirectional data flow by taking advantage of the Flux pattern.</p></div></body></html>