- en: Introduction to Microservice Server-Side Technologies
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务服务器端技术简介
- en: Wasn't it easy to develop a production-ready monolithic application with JHipster?
    So far, we have created an application from scratch, added a few entities with
    JDL Studio, and then deployed it to the production environment along with tests.
    We have also added a continuous integration and continuous delivery pipeline.
    Wasn't the experience faster, easier, and better than coding everything from scratch?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JHipster开发一个生产就绪的单体应用不是很容易吗？到目前为止，我们已经从头开始创建了一个应用，使用JDL Studio添加了一些实体，然后将其与测试一起部署到生产环境中。我们还添加了持续集成和持续交付管道。这种体验不是更快、更简单、更好吗？
- en: So what's next? Yes, you guessed it right—**microservices**!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，接下来是什么？是的，你猜对了——**微服务**！
- en: Microservices is the buzzword everywhere these days. Many companies out there
    are trying to solve their problems with microservices. We already saw an overview
    of the benefits of microservices in [Chapter 1](498dbd6d-b882-4551-92dd-97cdde4b62ac.xhtml), *Introduction
    to Modern Web Application Development*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务现在是到处都在谈论的热门词汇。许多公司都在尝试用微服务来解决他们的问题。我们已经在[第一章](498dbd6d-b882-4551-92dd-97cdde4b62ac.xhtml)“现代Web应用开发简介”中看到了微服务的好处概述。
- en: 'In this chapter, we will look at the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下内容：
- en: Benefits of microservices over monoliths
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务相对于单体应用的好处
- en: Components that we need for building a complete microservices architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要构建完整的微服务架构的组件
- en: In this chapter, we will see how the monolithic application we created earlier
    can be converted into a microservice application.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到我们之前创建的单体应用如何被转换成一个微服务应用。
- en: After that, we will see how easy it is to create a microservice architecture
    using the options JHipster provides.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将看到使用JHipster提供的选项创建微服务架构是多么容易。
- en: Microservice applications versus monoliths
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务应用与单体应用对比
- en: The benefits of microservice architectures can be better understood by comparing
    them with monolithic architectures.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过与单体架构的比较，可以更好地理解微服务架构的好处。
- en: The benefits of microservices over monoliths are phenomenal when they are designed
    and deployed correctly.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当它们被正确设计和部署时，微服务相对于单体应用的好处是惊人的。
- en: It is not as simple as splitting a monolithic application based on structure,
    component, or functionality and then deploying them as individual services. This
    will not work out. Converting a monolithic application or even a monolithic design
    into microservices needs a clear vision of the product. It includes knowledge
    of what part of the project will change and what part will be consistent. We must
    have low-level details, such as which entities we should group together and those
    that can be separated.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不像根据结构、组件或功能将单体应用拆分，然后作为独立服务部署那么简单。这行不通。将单体应用或甚至单体设计转换为微服务需要一个清晰的产品愿景。这包括了解项目的哪些部分会改变，哪些部分会保持一致。我们必须有低级别的细节，比如我们应该将哪些实体分组在一起，哪些可以分离。
- en: This clearly illustrates the need for an ever-evolving model. It is much easier
    to split the technologies used in the application, but not the interdependent
    models or the business logic of the application. So it is essential to place the
    project's primary focus on core domain and its logic.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这清楚地说明了需要一个不断发展的模型的需求。拆分应用中使用的技术比拆分相互依赖的模型或应用的业务逻辑要容易得多。因此，将项目的主要重点放在核心领域及其逻辑上至关重要。
- en: Microservices should be independent. They will fail when a component is tightly
    coupled with another. The trickiest part is identifying and segregating the components.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务应该是独立的。当一个组件与另一个组件紧密耦合时，它们会失败。最棘手的部分是识别和隔离组件。
- en: When we have done that, it offers the following benefits over monolithic applications.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成这个任务后，它相对于单体应用有以下好处。
- en: The monolithic code is a single unit. Thus, all parts of the application share
    the same memory. For a bigger system, we need to have a bigger infrastructure.
    When the application grows, we need to scale the infrastructure as needed. The
    scaling of an already bigger infrastructure is always a difficult and costlier
    task for operations.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 单体代码是一个单一单元。因此，应用的所有部分共享相同的内存。对于更大的系统，我们需要更大的基础设施。当应用增长时，我们需要根据需要扩展基础设施。对已经较大的基础设施进行扩展总是对运营来说既困难又昂贵的任务。
- en: Even though they have all the necessary code to handle anything in the product
    at a single place (no need to worry about latency or availability), it is difficult
    to handle the resources that it consumes to run and it is definitely not scalable.
    If any one part of the application fails, then the whole product will be impacted.
    When any one thread or query of the product clings on to the memory, then the
    impact will be seen by millions of our customers.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们在单个地方拥有处理产品中任何事物的所有必要代码（无需担心延迟或可用性），但处理其运行所消耗的资源却很困难，而且肯定不可扩展。如果应用程序的任何一部分失败，整个产品都会受到影响。当产品的任何线程或查询粘附在内存上时，影响将会被数百万客户看到。
- en: Microservices, on the other hand, require less memory to run since we are splitting
    the application into smaller components, which in turn reduces the infrastructure's
    cost. For example, it is cheaper to run 10 2GB instances (costs ~$170 per month
    on AWS) than running a single 16 GB instance (costs ~$570 per month on AWS). Each
    component runs in its own environment, which makes microservices much more developer-friendly
    and cloud-native. Similarly, microservices also increase the throughput across
    services. A memory intensive operation on one service will not affect any other
    service.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，微服务由于我们将应用程序拆分为更小的组件，因此运行时所需的内存更少。这反过来又降低了基础设施的成本。例如，运行10个2GB实例（在AWS上的成本约为每月170美元）比运行单个16GB实例（在AWS上的成本约为每月570美元）更便宜。每个组件都在自己的环境中运行，这使得微服务对开发者和云原生更加友好。同样，微服务也增加了服务之间的吞吐量。一个服务上的内存密集型操作不会影响任何其他服务。
- en: Monolithic architecture, over a period of time, will remove the agility of a
    team, which will delay the application rollout. This means people will tend to
    invest more time to find a workaround to fix a problem when a new feature is added,
    or something in the existing feature breaks. The monolithic architecture will
    bring a greater amount of inefficiency that in turn increases the technical debt.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，单体架构将消除团队的敏捷性，从而延迟应用程序的发布。这意味着当添加新功能或现有功能中的某些内容出现问题时，人们往往会花更多的时间来寻找解决方案以解决问题。单体架构将带来更多的低效，从而增加技术债务。
- en: Microservices, on the other hand, reduce the technical debt in terms of architecture
    since everything is reduced to individual components. Teams tend to be more agile
    and they will find handling changes easier.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，微服务在架构方面减少了技术债务，因为一切都被简化为单个组件。团队往往更加敏捷，他们会发现处理变更更容易。
- en: The less code there is, the fewer bugs there are, meaning less pain and a shorter
    time to fix.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 代码越少，错误越少，意味着痛苦更少，修复时间更短。
- en: Monolithic applications are more time consuming to work with. Imagine there
    is a big monolithic application and you have to reverse an *if condition* in your
    service layer. After changing the code, it has to be built, which usually takes
    a few minutes, and then you must test the entire application, which will reduce
    the team's performance.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 单体应用程序的工作量更大。想象一下有一个大型的单体应用程序，你需要在服务层中撤销一个*if条件*。在更改代码后，通常需要几分钟来构建，然后你必须测试整个应用程序，这将降低团队的表现。
- en: You can reboot or reload an application in seconds for a microservice architecture.
    When you have to reverse an *if condition*, you need not wait for minutes to build
    and deploy the application to test, you can do it in seconds. This will decrease
    the time it takes to do mundane tasks.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于微服务架构，你可以几秒钟内重新启动或重新加载应用程序。当你需要撤销一个*if条件*时，你不需要等待几分钟来构建和部署应用程序以进行测试，你可以在几秒钟内完成。这将减少执行日常任务所需的时间。
- en: Faster iterations/releases and decreased downtime are the key things to increase
    user engagement and user retention, which in turn results in better revenue.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 更快的迭代/发布和减少停机时间是提高用户参与度和用户保留率的关键，这反过来又会导致更好的收入。
- en: A human mind (unless you are superhuman) can handle only a limited amount of
    information. So cognitively, microservices help people to reduce the clutter and
    focus on the functionality. This enables better productivity and faster rollouts.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 人类大脑（除非你是超人）只能处理有限的信息量。因此，从认知角度来看，微服务帮助人们减少杂乱，专注于功能。这使生产力更高，部署更快。
- en: 'Embracing microservices will:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 采用微服务将：
- en: Maximize productivity
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大化生产力
- en: Improve agility
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提升敏捷性
- en: Improve customer experience
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提升客户体验
- en: Speed up development/unit testing (if designed properly)
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加速开发/单元测试（如果设计得当）
- en: Improve revenue
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提升收入
- en: Building blocks of a microservice architecture
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务架构的构建块
- en: 'Running a microservice architecture requires a lot of components/features and
    involves a lot of advanced concepts. For the sake of understanding these concepts,
    imagine we have a microservice-based application for our e-commerce shopping website.
    This includes the following services:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 运行微服务架构需要许多组件/功能，并涉及许多高级概念。为了理解这些概念，想象我们有一个基于微服务的应用程序，用于我们的电子商务购物网站。这包括以下服务：
- en: 'Pricing services: Responsible for giving us the price of the product based
    on demand'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定价服务：负责根据需求给出产品的价格
- en: 'Demand services: Responsible for calculating the demand for the product based
    on the sales and stocks left'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需求服务：负责根据销售和剩余库存计算产品的需求
- en: 'Inventory services: Responsible for tracking the quantity left in the inventory'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库存服务：负责跟踪库存中剩余的数量
- en: Many other services
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多其他服务
- en: 'Some of the concepts we will see in this section are:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节中看到的一些概念是：
- en: Service registry
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务注册表
- en: Service discovery
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务发现
- en: Health check
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 健康检查
- en: Dynamic routing and resiliency
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态路由和弹性
- en: Security (authentication and authorization)
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性（身份验证和授权）
- en: Fault tolerance and failover
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容错和故障转移
- en: Service registry
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务注册表
- en: Microservices are independent, but many use cases will need them to be interdependent.
    This means for some services to work properly they need data from another service,
    which in turn may or may not depend on other services or sources.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是独立的，但许多用例将需要它们相互依赖。这意味着某些服务要正常工作，需要从另一个服务获取数据，而该服务可能或可能不依赖于其他服务或来源。
- en: For example, our pricing service will directly depend on the demand service,
    which in turn depends on the inventory service. But these three services are completely
    independent, that is they can be deployed on any host, port, or location and scaled
    at will.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们的定价服务将直接依赖于需求服务，而需求服务又依赖于库存服务。但这三个服务是完全独立的，也就是说，它们可以部署在任何主机、端口或位置，并且可以随意扩展。
- en: If the pricing service wants to communicate with the demand service, it has
    to know the exact location to which it can send requests to get the required information.
    Similarly, the demand service should know about the inventory service's details
    in order to communicate.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果定价服务想要与需求服务通信，它必须知道确切的位置，可以向其发送请求以获取所需信息。同样，需求服务也应该了解库存服务的详细信息，以便进行通信。
- en: So we need a service registry that registers all other services and their locations.
    All services should register themselves to this registry service when the service
    is started and deregister itself when the service goes down.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要一个服务注册表来注册所有其他服务和它们的位置。所有服务在服务启动时应自行注册到该注册表服务，当服务关闭时应自行注销。
- en: The service registry should act as a database of services, recording all the
    available instances and their details.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 服务注册表应充当服务数据库，记录所有可用的实例及其详细信息。
- en: Service discovery
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务发现
- en: The service registry has details of the services available. But in order to
    find out where the required service is and which services to connect, we need
    to have service discovery.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 服务注册表有服务的详细信息。但为了找出所需服务的位置以及要连接哪些服务，我们需要进行服务发现。
- en: When the pricing service wants to communicate with the demand service, it needs
    to know the network location of the demand service. In the case of traditional
    architecture, this is a fixed physical address but in the microservices world,
    this is a dynamic address that is assigned and updated dynamically.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当定价服务想要与需求服务通信时，它需要知道需求服务的网络位置。在传统架构的情况下，这是一个固定的物理地址，但在微服务世界中，这是一个动态地址，它被动态分配和更新。
- en: The pricing service (client) will have to locate the demand service in the service
    registry and determine the location and then load balance the request o the available
    demand service. The demand service, in turn, will respond to the request of the
    requested client (pricing service).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 定价服务（客户端）必须在服务注册表中定位需求服务，确定位置，然后对可用的需求服务进行负载均衡。反过来，需求服务将响应请求客户端（定价服务）的请求。
- en: Service discovery is used to discover the exact service to which the client
    should connect to, in order to get the necessary details.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 服务发现用于发现客户端应连接的确切服务，以获取必要的详细信息。
- en: Service discovery helps the API gateway to discover the right endpoint for a
    request.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 服务发现帮助API网关发现请求的正确端点。
- en: They will also have a load balancer, which regulates the traffic and ensures
    the high availability of the services.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 他们还将有一个负载均衡器，它调节流量并确保服务的高可用性。
- en: 'Based on the location where load balancing happens, the service discovery is
    classified into:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 根据负载均衡发生的地点，服务发现被分为：
- en: '**Client-side discovery pattern**'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端端发现模式**'
- en: The load balancing will happen on the client service side. The client service
    will determine where to send the request and the logic of load balancing will
    be in the client service. For example, Netflix Eureka ([https://github.com/Netflix/eureka](https://github.com/Netflix/eureka))
    is a service registry. It provides endpoints to register and discover the services.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 负载均衡将在客户端服务端发生。客户端服务将确定请求发送到何处，负载均衡的逻辑将位于客户端服务中。例如，Netflix Eureka ([https://github.com/Netflix/eureka](https://github.com/Netflix/eureka))
    是一个服务注册表。它提供注册和发现服务的端点。
- en: When the pricing service wants to invoke the demand service, it will connect
    to the service registry and then find the available services. Then, based on the
    load balancing logic configured, the pricing service (client) will determine which
    demand service to request.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当定价服务想要调用需求服务时，它将连接到服务注册表，然后找到可用的服务。然后，根据配置的负载均衡逻辑，定价服务（客户端）将确定请求哪个需求服务。
- en: 'The services will then do an intelligent and application-specific load balancing.
    On the downside, this adds an extra layer of load balancing in every service,
    which is an overhead:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 服务将进行智能和特定于应用的负载均衡。缺点是，这为每个服务添加了一个额外的负载均衡层，这增加了开销：
- en: '**Server-side discovery pattern**'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器端发现模式**'
- en: The pricing service will request the load balancer to connect to the demand
    service. Then, the load balancer will connect to the service registry to determine
    the available instance, and then route the request based on the load balancing
    configured.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 定价服务将请求负载均衡器连接到需求服务。然后，负载均衡器将连接到服务注册表以确定可用的实例，然后根据配置的负载均衡路由请求。
- en: For example, in Kubernetes, each pod will have its own server or proxy. All
    the requests are sent through this proxy (which has a dedicated IP and port associated
    with it).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在Kubernetes中，每个Pod都有自己的服务器或代理。所有请求都通过这个代理（它有一个与之关联的专用IP和端口）发送。
- en: The load balancing logic is moved away from the service and isolated into a
    separate service. On the downside, it requires yet another highly available service
    to handle the requests.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 负载均衡逻辑从服务中移除，并隔离到一个单独的服务中。缺点是，它需要一个额外的、高度可用的服务来处理请求。
- en: Health check
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 健康检查
- en: In the microservices world, instances can start, change, update, and stop at
    random. They can also scale up and down based on their traffic and other settings.
    This requires a health check service that will constantly monitor the availability
    of the services.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务世界中，实例可以随机启动、更改、更新和停止。它们也可以根据流量和其他设置进行上下伸缩。这需要一个健康检查服务，它将不断监控服务的可用性。
- en: Services can send their status periodically to this health check service, and
    this keeps a track of the health of the services. When a service goes down, the
    health check service will stop getting the heartbeat from the service. Then, the
    health check service will mark the service down and cascade the information to
    the service registry. Similarly, when the service resumes, the heartbeat is sent
    to the health check service. Upon receiving a few positive heartbeats, the service
    is marked UP and then the information is sent to the service registry.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 服务可以定期向这个健康检查服务发送它们的状态，这有助于跟踪服务状态。当一个服务宕机时，健康检查服务将停止从该服务接收心跳。然后，健康检查服务将标记该服务为宕机，并将信息级联到服务注册表。同样，当服务恢复时，心跳将被发送到健康检查服务。在接收到几个积极的心跳后，服务将被标记为UP，然后信息被发送到服务注册表。
- en: 'The health check service can check for health in two ways:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 健康检查服务可以通过两种方式检查健康：
- en: '**Push configuration**: All the services will send their heartbeat periodically
    to the health check service'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**推送配置**：所有服务将定期向健康检查服务发送心跳。'
- en: '**Pull configuration**: A single health check service instance will query for
    the availability of the systems periodically'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拉取配置**：单个健康检查服务实例将定期查询系统的可用性。'
- en: This also requires a **high availability system**. All the services should connect
    to this service to share their heartbeat and this has to connect to the service
    registry to tell them whether a service is available or not.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这也要求有一个**高可用性系统**。所有服务都应该连接到这个服务以共享它们的心跳，并且这个服务必须连接到服务注册表以告诉它们服务是否可用。
- en: Dynamic routing and resiliency
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态路由和弹性
- en: The health check services will track the health of available services and send details
    to the service registry about the health of services.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 健康检查服务将跟踪可用服务的健康状态，并将有关服务健康状态的详细信息发送到服务注册表。
- en: Based on this, services should intelligently route requests to healthy instances
    and shut down the traffic to unhealthy instances.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，服务应智能地将请求路由到健康实例，并关闭不健康实例的流量。
- en: Since the services dynamically change their location (address /port), every
    time a client wants to connect to the service, it should first check for the availability
    of the services from the service registry. Every connection to the client will
    also need to have a timeout added to it, beyond which the request has to be served
    or it has to be retried (configured) to another instance. This way we can minimize
    the *cascading failure*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于服务动态更改其位置（地址/端口），每次客户端想要连接到服务时，它都应该首先检查服务注册表中的服务可用性。每个客户端连接也需要添加一个超时时间，在此时间之后，请求必须被服务或重试（配置）到另一个实例。这样我们可以最小化*级联故障*。
- en: Security
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全性
- en: When a client invokes the available service, we need to validate the request.
    In order to prevent unwanted requests from piling up, we should have an additional
    layer of **security**. The requests from the client should be authenticated and
    authorized to call the other service, to prevent unauthorized calls to the service.
    The service should, in turn, decrypt the request, understand whether it is valid
    or invalid, and do the rest.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端调用可用服务时，我们需要验证请求。为了防止不想要的请求堆积，我们应该有一个额外的**安全层**。客户端的请求应该经过认证和授权才能调用其他服务，以防止对服务的未授权调用。服务反过来应该解密请求，了解它是否有效或无效，并完成剩余的操作。
- en: 'In order to provide secure microservices, it should have the following characteristics:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供安全的微服务，它应该具有以下特征：
- en: 'Confidentiality: Allow only the authorized clients to access and consume the
    information.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机密性：仅允许授权客户端访问和消费信息。
- en: 'Integrity: Can guarantee the integrity of the information that it receives
    from the client and ensure that it is not modified by a third-party (for example,
    when a gateway and a service is talking to each other, no party can tamper with
    or alter the messages that are sent between them. This a classic man-in-the-middle
    attack).'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整性：可以保证从客户端接收到的信息的完整性，并确保它不会被第三方修改（例如，当网关和服务相互通信时，任何一方都不能篡改或更改它们之间发送的消息。这是一种经典的中间人攻击）。
- en: 'Availability: A secure API service should be highly available.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用性：安全的API服务应该具有高度的可用性。
- en: 'Reliability: Should handle the requests and process them reliably.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可靠性：应该可靠地处理请求并处理它们。
- en: For more information on MITM, or man-in-the-middle attacks check, the following
    link: [https://www.owasp.org/index.php/Man-in-the-middle_attack.](https://www.owasp.org/index.php/Man-in-the-middle_attack)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 关于中间人攻击（MITM）的更多信息，请查看以下链接：[https://www.owasp.org/index.php/Man-in-the-middle_attack.](https://www.owasp.org/index.php/Man-in-the-middle_attack)
- en: Fault tolerance and failover
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容错和故障转移
- en: 'In a microservice architecture, there might be many reasons for a fault. It
    is important to handle faults or failovers gracefully, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，可能有许多故障原因。优雅地处理故障或故障转移非常重要，如下所示：
- en: When the request takes a long time to complete, have a predetermined timeout
    instead of waiting for the service to respond.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当请求需要很长时间才能完成时，应设置一个预定的超时时间，而不是等待服务响应。
- en: When the request fails, identify the server, notify the service registry, and
    stop connecting to the server. This way, we can prevent other requests from going
    to that server.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当请求失败时，识别服务器，通知服务注册表，并停止连接到该服务器。这样，我们可以防止其他请求发送到该服务器。
- en: Shut down the service when it is not responding and start a new service to make
    sure services are working as expected.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当服务没有响应时，关闭服务并启动一个新的服务以确保服务按预期工作。
- en: 'This can be achieved using the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过以下方式实现：
- en: '**Fault tolerance** libraries, which prevent cascading failures by isolating
    the remote instance and services that are not responding or taking a longer time
    than in the SLA to respond. This prevents other services from calling the failed
    or unhealthy instances.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容错**库，通过隔离不响应或响应时间超过服务等级协议（SLA）的远程实例和服务来防止级联故障。这防止其他服务调用失败的或不健康的实例。'
- en: '**Distributed tracing system** libraries help to trace the timing and latency
    of the service or system, and highlight any discrepancies with the agreed SLA.
    They also help you to understand where the performance bottleneck is so that you
    can act on this.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式跟踪系统**库有助于跟踪服务或系统的时序和延迟，并突出显示与协议SLA的任何差异。它们还帮助您了解性能瓶颈在哪里，以便您可以采取行动。'
- en: 'JHipster provides options to fulfill many of the preceding concepts. The most
    important of them are as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster提供了实现许多先前概念的选项。其中最重要的包括以下内容：
- en: JHipster Registry
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JHipster注册表
- en: HashiCorp Consul
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HashiCorp Consul
- en: JHipster Gateway
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JHipster网关
- en: JHipster console
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JHipster控制台
- en: Prometheus
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Prometheus
- en: JHipster UAA server
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JHipster UAA服务器
- en: JHipster Registry
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JHipster注册表
- en: JHipster provides JHipster Registry ([http://www.jhipster.tech/jhipster-registry/](http://www.jhipster.tech/jhipster-registry/))
    as the default **service registry**. The JHipster Registry is a runtime application
    that all microservice applications register with and get their configuration from.
    It also provides additional features such as monitoring and health check dashboards.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster提供了JHipster Registry ([http://www.jhipster.tech/jhipster-registry/](http://www.jhipster.tech/jhipster-registry/))
    作为默认的**服务注册表**。JHipster Registry是一个运行时应用程序，所有微服务应用程序都会注册并从中获取其配置。它还提供了监控和健康检查仪表板等附加功能。
- en: 'JHipster Registry is made up of the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster注册表由以下内容组成：
- en: Netflix Eureka server
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Netflix Eureka服务器
- en: Spring cloud config server
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Cloud配置服务器
- en: Netflix Eureka server
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Netflix Eureka服务器
- en: 'Eureka ([https://github.com/Netflix/eureka](https://github.com/Netflix/eureka))
    consists of the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Eureka ([https://github.com/Netflix/eureka](https://github.com/Netflix/eureka))
    包括以下内容：
- en: The Eureka server
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eureka服务器
- en: Eureka is a REST-based service. It is used for locating services for load balancing
    and failover middle tiers.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Eureka是一个基于REST的服务。它用于定位用于负载均衡和故障转移中间层的服务。
- en: Eureka servers help to load balance among the instances. They are more useful
    in a cloud-based environment where the availability is intermittent. On the other
    hand, traditional load balancers help in load balancing the traffic between known
    and fixed instances.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Eureka服务器帮助在实例之间进行负载均衡。它们在可用性间歇的云环境中更有用。另一方面，传统的负载均衡器有助于在已知和固定实例之间进行流量负载均衡。
- en: The Eureka client
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eureka客户端
- en: Eureka provides a Eureka client, which makes the interaction between servers
    seamless. It is a Java-based client.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Eureka提供了一个Eureka客户端，使得服务器之间的交互无缝。它是一个基于Java的客户端。
- en: Eureka acts as a **middle tier** *load balancer* that helps to load balance
    the host of a middle-tier services. They provide a simple round robin-based load
    balancing by default. The load balancing algorithm can be customized as needed
    with a wrapper.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Eureka充当一个**中间层**负载均衡器，帮助负载均衡中间层服务的宿主。它们默认提供基于轮询的简单负载均衡。可以根据需要使用包装器自定义负载均衡算法。
- en: They cannot provide sticky sessions. They also fit perfectly for client-based
    load balancing scenarios (as seen earlier).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 它们不能提供粘性会话。它们也非常适合基于客户端的负载均衡场景（如前所述）。
- en: Eureka has no restriction on the communication technology. We can use anything,
    such as Thrift, HTTP, or any RPC mechanisms, for communication.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Eureka对通信技术没有限制。我们可以使用任何东西，例如Thrift、HTTP或任何RPC机制进行通信。
- en: Imagine our application is in different AWS Availability Zones. We register
    a Eureka cluster in each of the zones that holds information about available services
    in that region only and start the Eureka server in each zone to handle zone failures.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的应用程序位于不同的AWS可用区。我们在每个区域注册一个Eureka集群，该集群只包含该区域可用的服务信息，并在每个区域启动Eureka服务器以处理区域故障。
- en: All the services will register themselves to the Eureka server and send their
    heartbeats. When the client no longer sends a heartbeat, the service is taken
    out of the registry itself and the information is passed across the Eureka nodes
    in the cluster. Then, any client from any zone will look up the registry information
    to locate it and then make any remote calls. Also, we need to ensure that Eureka
    clusters between regions do not communicate with each other.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 所有服务都将注册到 Eureka 服务器并发送心跳。当客户端不再发送心跳时，服务将从注册表中移除，并且信息将在集群中的 Eureka 节点之间传递。然后，任何区域的任何客户端都可以查找注册信息以定位它，然后进行任何远程调用。此外，我们还需要确保区域之间的
    Eureka 集群之间不相互通信。
- en: Eureka prefers availability over consistency. That is when the services are
    connected to the Eureka server and it shares the complete configuration between
    the services. This enables services to run even when the Eureka server goes down.
    In production, we have to run Eureka in a high availability cluster for better
    consistency.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Eureka 更倾向于可用性而不是一致性。这就是当服务连接到 Eureka 服务器并共享服务之间的完整配置时。这使得服务即使在 Eureka 服务器关闭的情况下也能运行。在生产中，我们必须在高度可用集群中运行
    Eureka 以获得更好的一致性。
- en: Eureka also has the ability to add or remove the servers on the fly. This makes
    it the right choice for service registry and service discovery.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Eureka 还具有动态添加或删除服务器的能力。这使得它成为服务注册和服务发现的正确选择。
- en: Spring cloud config server
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring 云配置服务器
- en: In a microservice architecture, the services are dynamic in nature. They will
    go down and come up based on traffic or any other configuration. Due to this dynamic
    nature, there should be a separate, *highly available* server that holds the essential
    configuration details that all the servers need to know.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，服务本质上是动态的。它们将根据流量或任何其他配置进行上下文切换。由于这种动态特性，应该有一个单独的、 *高度可用* 的服务器来保存所有服务器都需要知道的基本配置细节。
- en: For example, our pricing service will need to know where the registry service
    is and how it has to communicate to the registry service. The registry service,
    on the other hand, should be highly available. If for any reason the server has
    to go down, we will spin up a new server. The pricing service needs to communicate
    with the config service in order to find out about the registry service. On the
    other hand, when the registry service is changed, it has to communicate the changes
    to the config server, which will then cascade the information to all the necessary
    services.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们的定价服务需要知道注册服务在哪里以及它如何与注册服务通信。另一方面，注册服务应该是高度可用的。如果出于任何原因服务器必须关闭，我们将启动一个新的服务器。定价服务需要与配置服务通信，以了解注册服务。另一方面，当注册服务发生变化时，它必须将更改通知给配置服务器，然后配置服务器将信息级联到所有必要的服务中。
- en: Spring cloud config server ([https://github.com/spring-cloud/spring-cloud-config](https://github.com/spring-cloud/spring-cloud-config))
    provides server and client-side support for external configuration.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 云配置服务器 ([https://github.com/spring-cloud/spring-cloud-config](https://github.com/spring-cloud/spring-cloud-config))
    为外部配置提供了服务器和客户端支持。
- en: With the cloud config server, we have a central place to manage all our external
    properties across all environments. The concept is similar to Spring-based environment
    property source abstractions on both client and server. They fit for any application
    running in any language.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用云配置服务器，我们有一个中心位置来管理所有环境中的外部属性。这个概念类似于客户端和服务器上基于 Spring 的环境属性源抽象。它们适用于任何用任何语言运行的应用程序。
- en: They are also helpful for carrying the configuration data between various (development/test/production)
    environments and help to migrate much easier.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 它们还有助于在各个（开发/测试/生产）环境之间传输配置数据，并有助于更容易地进行迁移。
- en: Spring config server has a HTTP, resource-based API for external configuration.
    They will encrypt and decrypt property values. They bind to the config server
    and initialize a Spring environment with remote property sources. The configuration
    can be stored in a Git repository or in a file system.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 配置服务器提供了一个基于 HTTP、资源型的 API 用于外部配置。它们将加密和解密属性值。它们绑定到配置服务器并使用远程属性源初始化 Spring
    环境。配置可以存储在 Git 仓库或文件系统中。
- en: HashiCorp Consul
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HashiCorp Consul
- en: Consul ([https://www.consul.io/](https://www.consul.io/)) is primarily a service
    discovery client from Hashicorp. It focuses on consistency. Consul is completely
    written in Go.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Consul ([https://www.consul.io/](https://www.consul.io/)) 主要是由 Hashicorp 提供的服务发现客户端。它侧重于一致性。Consul
    完全是用 Go 编写的。
- en: This means it will have a lower memory footprint. Added to that, we can also
    use Consul with services written in any programming language.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着它将具有更小的内存占用。除此之外，我们还可以使用Consul与用任何编程语言编写的服务一起使用。
- en: 'The main advantages of using Consul are as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Consul的主要优势如下：
- en: It has a lower memory footprint
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有更小的内存占用
- en: It can be used with services that are written in any programming language
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以与用任何编程语言编写的服务一起使用
- en: It focuses on consistency rather than availability
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它侧重于一致性而非可用性
- en: Consul also provides service discovery, failure detection, multi-data center
    configuration, and storage.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Consul还提供服务发现、故障检测、多数据中心配置和存储。
- en: This is an alternative option to JHipster Registry. There is an option to choose
    between JHipster Registry and Consul during application creation.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这是JHipster注册的一个替代选项。在应用程序创建期间，可以选择使用JHipster注册或Consul。
- en: Eureka (JHipster Registry) requires each application to use its APIs for registering
    and discovering themselves. It focuses on availability over consistency. It supports
    only applications or services written in Spring Boot.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Eureka（JHipster注册）要求每个应用程序使用其API进行注册和发现自身。它侧重于可用性而非一致性。它仅支持用Spring Boot编写的应用程序或服务。
- en: On the other hand, Consul runs as an agent in the services, and checks the health
    information and a few other extra operations listed previously.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Consul作为服务中的一个代理运行，检查健康信息和之前列出的其他一些额外操作。
- en: Service discovery
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务发现
- en: Consul can provide a service and other clients can use Consul to discover the
    providers of a given service. Using either DNS or HTTP, applications can easily
    find the services that they depend on.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Consul可以提供服务，其他客户端可以使用Consul来发现特定服务的提供者。通过DNS或HTTP，应用程序可以轻松找到它们所依赖的服务。
- en: Health discovery
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 健康发现
- en: Consul clients can provide any number of health checks, either associated with
    a given service or with the local node. This information can be used by a health
    check service to monitor services' health, and it is in turn used to discover
    the service components and route traffic away from unhealthy hosts and towards
    the healthy hosts.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Consul客户端可以提供任意数量的健康检查，这些检查可以与特定的服务相关联，也可以与本地节点相关联。这些信息可以被健康检查服务用来监控服务的健康状态，反过来，这些信息也被用来发现服务组件并将流量从不健康的节点路由到健康的节点。
- en: K/V store
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: K/V存储
- en: Consul has an easy-to-use HTTP API that makes it simple for applications to
    use Consul's key/value store for dynamically configuring services, electing the
    leader when the current leader goes down, and segregating containers based on
    features.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Consul提供了一个易于使用的HTTP API，这使得应用程序能够简单地使用Consul的键/值存储来动态配置服务、在当前领导者宕机时选举领导者，以及根据功能隔离容器。
- en: Multiple data centers
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多数据中心
- en: Consul supports multiple data centers out of the box. This means you do not
    have to worry about building additional layers of abstraction to grow to multiple
    regions.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Consul支持开箱即用的多数据中心。这意味着你不必担心构建额外的抽象层来扩展到多个区域。
- en: Consul should be a distributed and highly available service. Every node that
    provides services to Consul runs a consul agent, which is mainly responsible for
    health checking. These agents will then talk with one or more Consul servers,
    which collect and add this information. These servers will also elect a leader
    among themselves.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Consul应该是一个分布式且高度可用的服务。为Consul提供服务的每个节点都运行一个consul代理，主要负责健康检查。这些代理将与一个或多个Consul服务器通信，这些服务器收集并添加这些信息。这些服务器之间也会选举出一个领导者。
- en: Thus, Consul serves as a service registry, service discovery, health check,
    and K/V store.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Consul充当服务注册、服务发现、健康检查和K/V存储。
- en: JHipster Gateway
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JHipster网关
- en: In a microservice architecture, we need an entry point to access all the running
    services. So we need a service that acts as a gateway. This will proxy or route
    clients' requests to the respective services. In JHipster, we provide JHipster
    Gateway for that.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，我们需要一个入口点来访问所有运行中的服务。因此，我们需要一个充当网关的服务。这将代理或路由客户端的请求到相应的服务。在JHipster中，我们为此提供了JHipster网关。
- en: JHipster Gateway is a microservice application that can be generated. It integrates
    Netflix Zuul and Hystrix in order to provide routing, filtering, security, circuit
    breaking, and so on.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster网关是一个可以生成的微服务应用程序。它集成了Netflix Zuul和Hystrix，以提供路由、过滤、安全、断路器等功能。
- en: Netflix Zuul
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Netflix Zuul
- en: In a microservice architecture, Zuul is a front door for all the requests (gatekeeper).
    It acts as an edge service application. Zuul is built to enable *dynamic routing,
    monitoring, resiliency, and security *among the services. It also has the ability
    to dynamically route requests as needed.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，Zuul 是所有请求的前门（门卫）。它充当边缘服务应用。Zuul 是为了在服务之间实现动态路由、监控、弹性和安全性而构建的。它还具有根据需要动态路由请求的能力。
- en: 'Trivia: In *Ghostbusters*, Zuul is the gatekeeper.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 冷知识：在 *Ghostbusters* 中，Zuul 是门卫。
- en: Zuul works based on different types of filter that enable us to quickly and
    nimbly apply functionality to our edge service.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Zuul 的工作基于不同类型的过滤器，使我们能够快速灵活地将功能应用于我们的边缘服务。
- en: 'These filters help us to perform the following functions:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这些过滤器帮助我们执行以下功能：
- en: 'Authentication and security: To identify each resource''s authentication requirements
    and to reject requests that do not satisfy the requirements'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份验证和安全：识别每个资源的身份验证要求，并拒绝不符合要求的请求
- en: 'Insights and monitoring: To track data and statistics at the edge and to give
    an insight into the production application'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 洞察和监控：在边缘跟踪数据和统计信息，并深入了解生产应用
- en: 'Dynamic routing: To dynamically route requests to different backend clusters
    as needed based on health and other factors'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态路由：根据健康和其他因素，根据需要动态地将请求路由到不同的后端集群
- en: 'Multi-regional resiliency (AWS): To route requests across AWS regions in order
    to diversify our Elastic Load Balancer usage and move our edge closer to our members'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多区域弹性（AWS）：为了多样化我们的弹性负载均衡器使用，并将我们的边缘更靠近我们的成员，跨 AWS 区域路由请求
- en: For even more information on Zuul, please check [https://github.com/Netflix/zuul/wiki.](https://github.com/Netflix/zuul/wiki)
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如需更多关于 Zuul 的信息，请查看 [https://github.com/Netflix/zuul/wiki.](https://github.com/Netflix/zuul/wiki)
- en: Hystrix
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hystrix
- en: Hystrix ([https://github.com/Netflix/Hystrix](https://github.com/Netflix/Hystrix))
    is a latency and fault tolerance library designed to isolate points of access
    to remote systems, services, and third-party libraries, stop cascading failures;
    and enable resilience in complex distributed systems where failure is inevitable.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Hystrix ([https://github.com/Netflix/Hystrix](https://github.com/Netflix/Hystrix))
    是一个用于隔离远程系统、服务和第三方库访问点的延迟和容错库，旨在停止级联故障；并在不可避免失败的复杂分布式系统中实现弹性。
- en: 'Hystrix is designed to do the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Hystrix 设计来完成以下任务：
- en: Stop failure cascades in a complex distributed system
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在复杂的分布式系统中停止故障级联
- en: Protect the system from the failures of dependencies over the network
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护系统免受网络依赖项故障的影响
- en: Control the latency of the system
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制系统的延迟
- en: Recover rapidly and fail faster to prevent cascading
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速恢复并快速失败以防止级联
- en: Fall back and gracefully degrade when possible
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可能的情况下进行回退和优雅降级
- en: Enable near-real-time monitoring, alerting, and operational control
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用近乎实时的监控、警报和操作控制
- en: Applications in complex distributed architectures have a lot of dependencies,
    each of which will inevitably fail at some point. If the host application is not
    isolated from these external failures, it risks being taken down with them.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在复杂的分布式架构中，应用程序有许多依赖项，每个依赖项最终都会在某些时候失败。如果主机应用程序没有从这些外部故障中隔离，它可能会被它们拖垮。
- en: JHipster Console
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JHipster 控制台
- en: The JHipster Console ([https://github.com/jhipster/jhipster-console](https://github.com/jhipster/jhipster-console))
    is a monitoring solution for microservices built using the ELK stack. It comes
    bundled with preset dashboards and configuration. It is provided as a runtime
    component in the form of a Docker image.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster 控制台 ([https://github.com/jhipster/jhipster-console](https://github.com/jhipster/jhipster-console))
    是一个用于微服务的监控解决方案，它使用 ELK Stack 构建。它附带预设的仪表板和配置。它以 Docker 镜像的形式提供作为运行时组件。
- en: The ELK Stack is made up of Elasticsearch, Logstash, and Kibana.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ELK Stack 由 Elasticsearch、Logstash 和 Kibana 组成。
- en: Logstash can be used to normalize the data (usually from logs) and then Elasticsearch
    is used to process the same data faster. Finally, Kibana is used to visualize
    the data.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Logstash 可以用来标准化数据（通常来自日志），然后使用 Elasticsearch 来更快地处理相同的数据。最后，使用 Kibana 来可视化数据。
- en: Elasticsearch
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Elasticsearch
- en: Elasticsearch is a widely used search engine in data analytics. It helps you
    to extract data really fast from data haystacks. It also helps to provide real-time
    analytics and data extraction. It is highly scalable, available, and multi-tenanted.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Elasticsearch 是数据分析中广泛使用的搜索引擎。它帮助您从数据堆中快速提取数据。它还帮助提供实时分析和数据提取。它具有高度可扩展性、可用性和多租户性。
- en: It also provides full text-based searches saved as a document. These documents,
    in turn, will be updated and modified based on any changes to the data. This,
    in turn, will provide a faster search and analyze the data.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 它还提供了基于全文搜索的文档保存选项。这些文档将根据数据的任何更改进行更新和修改。这反过来将提供更快的搜索并分析数据。
- en: Logstash
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Logstash
- en: Logstash ([https://www.elastic.co/products/logstash](https://www.elastic.co/products/logstash))
    will take the logs, process them, and convert them into output. They can read
    any type of logs, such as system logs, error logs, and app logs. They are the
    **heavy working** component of this stack, which helps to store, query, and analyze
    the logs.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Logstash ([https://www.elastic.co/products/logstash](https://www.elastic.co/products/logstash))
    会接收日志，处理它们，并将它们转换为输出。它们可以读取任何类型的日志，如系统日志、错误日志和应用程序日志。它们是这个堆栈的**重工作**组件，有助于存储、查询和分析日志。
- en: They act as a pipeline for event processing and are capable of processing huge
    amounts of data with the filters and, along with Elasticsearch, deliver results
    really fast. JHipster makes sure that the logs are in the correct format so that
    they can be grouped and visualized in the correct way.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 它们作为事件处理的管道，能够通过过滤器处理大量数据，并与 Elasticsearch 一起快速交付结果。JHipster 确保日志以正确的格式存储，以便可以正确地分组和可视化。
- en: Kibana
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kibana
- en: Kibana ([https://www.elastic.co/products/kibana](https://www.elastic.co/products/kibana))
    forms the frontend of the ELK stack. It is used for data visualization. It is
    merely a log data dashboard. It is helpful in visualizing the trends and patterns
    in data that are otherwise tedious to read and interpret. It also provides an
    option to share/save, which makes visualization of the data more useful.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Kibana ([https://www.elastic.co/products/kibana](https://www.elastic.co/products/kibana))
    构成了 ELK 堆栈的前端。它用于数据可视化。它仅仅是一个日志数据仪表板。它有助于可视化那些否则难以阅读和解释的数据趋势和模式。它还提供了一个分享/保存的选项，这使得数据可视化更有用。
- en: Zipkin
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Zipkin
- en: Zipkin ([https://zipkin.io/](https://zipkin.io/)) is a distributed tracing system.
    Microservice architecture always has latency problems, and a system is needed
    to troubleshoot the latency problem. Zipkin helps to solve the problem by collecting
    timing data. Zipkin also helps to search the data.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Zipkin ([https://zipkin.io/](https://zipkin.io/)) 是一个分布式跟踪系统。微服务架构总是存在延迟问题，需要一个系统来排查延迟问题。Zipkin
    通过收集时间数据来帮助解决问题。Zipkin 还帮助搜索数据。
- en: All registered services will report timing data to Zipkin. Zipkin creates a
    dependency diagram based on the received traced requests for each of the applications
    or services. Then, it can be used to analyze, spot an application that takes a
    long time to resolve, and fix it as needed.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 所有注册的服务都将报告时间数据到 Zipkin。Zipkin 根据接收到的跟踪请求为每个应用程序或服务创建一个依赖关系图。然后，它可以用来分析、找出处理时间较长的应用程序，并根据需要进行修复。
- en: When a request is made, the trace instrumentation will record tags, add the
    trace headers to the request, and finally record the timestamp. Then, the request
    is sent to the original destination and the response is sent back to the trace
    instrumentation, which then records the duration and shares the result with the
    Zipkin collector, which is responsible for storing the information.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当发起请求时，跟踪度量将记录标签，将跟踪头添加到请求中，并最终记录时间戳。然后，请求被发送到原始目的地，响应被发送回跟踪度量，然后记录持续时间并与 Zipkin
    收集器共享结果，Zipkin 负责存储信息。
- en: By default, JHipster will generate the application with Zipkin disabled, but
    this can be enabled in the application-`<env>.yml` file.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，JHipster 会生成一个禁用了 Zipkin 的应用程序，但可以在应用程序的 `<env>.yml` 文件中启用它。
- en: Prometheus
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Prometheus
- en: In a microservice architecture, we need to monitor our services continuously
    and any issues should cause alerts immediately. We need a separate service that
    will continuously monitor and alert us whenever something weird happens.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，我们需要持续监控我们的服务，任何问题都应立即触发警报。我们需要一个独立的服务，它可以持续监控并在发生任何异常时立即通知我们。
- en: 'Prometheus consists of the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus 由以下部分组成：
- en: Prometheus server, which is responsible for scraping and storing the time series
    data
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Prometheus 服务器，负责抓取和存储时间序列数据
- en: Libraries to instrument the application code
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于对应用程序代码进行度量的库
- en: A push gateway for supporting short-lived jobs
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于支持短期作业的推送网关
- en: An exporter to Grafana to visualize data
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于在 Grafana 中可视化数据的导出器
- en: An alert manager
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个警报管理器
- en: Other support tools
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他支持工具
- en: Prometheus is an alternative to JHipster console. It provides monitoring and
    alerting support. This requires running a Prometheus server separately for more
    information. To get started with Prometheus, visit [https://prometheus.io/.](https://prometheus.io/)
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus 是 JHipster 控制台的替代品。它提供监控和警报支持。这需要单独运行 Prometheus 服务器以获取更多信息。要开始使用
    Prometheus，请访问 [https://prometheus.io/](https://prometheus.io/)。
- en: It provides multi-dimensional data models, which are time series and are identified
    by metric name and key-value pair. It has a flexible dynamic query language. It
    supports pulling time series out of the box and pushing time series via an intermediary
    gateway. It has multiple modes of graphing and dashboard support.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 它提供多维数据模型，这些模型是时间序列的，由指标名称和键值对标识。它具有灵活的动态查询语言。它支持开箱即用的时间序列提取，并通过中介网关推送时间序列。它具有多种图表和仪表板支持模式。
- en: It is helpful in finding out problems when there is an outage. Since it is autonomous
    and does not depend on any remote services, the data is sufficient for finding
    where the infrastructure is broken.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当出现故障时，它有助于发现问题。由于它是自主的，不依赖于任何远程服务，因此数据足以找到基础设施损坏的位置。
- en: It is helpful in recording the time series data and monitoring either via machine
    or highly dynamic Service Oriented Architecture.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 它有助于记录时间序列数据并通过机器或高度动态的服务导向架构进行监控。
- en: 'Some things to consider when choosing Prometheus over JHipster Console are
    as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择 Prometheus 而不是 JHipster 控制台时，需要考虑以下事项：
- en: Prometheus is very good at exploiting the metrics of your application and will
    not monitor logs or traces. JHipster console, on the other hand, uses the ELK
    stack and monitors the logs, traces, and metrics of your application.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Prometheus 非常擅长利用应用程序的指标，而不会监控日志或跟踪。另一方面，JHipster 控制台使用 ELK 堆栈，并监控应用程序的日志、跟踪和指标。
- en: Prometheus can be used to query a huge amount of time series data. ELK on JHipster
    console is much more versatile in terms of tracking and searching the metrics
    and logs.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Prometheus 可以用于查询大量时间序列数据。在 JHipster 控制台上，ELK 在跟踪和搜索指标和日志方面更加灵活。
- en: JHipster console uses Kibana to visualize the data while Prometheus uses Grafana ([https://grafana.com/](https://grafana.com/))
    to visualize the metrics.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JHipster 控制台使用 Kibana 可视化数据，而 Prometheus 使用 Grafana ([https://grafana.com/](https://grafana.com/))
    可视化指标。
- en: JHipster UAA server
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JHipster UAA 服务器
- en: JHipster user accounting and authorizing (UAA) services are merely an OAuth2
    server that can be used for *centralized identity management*. In order to access
    the protected resource and also to avoid unwanted access to the APIs, there has
    to be an authorization server that authorizes the request and provides access
    to the resource.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster 用户账户和授权（UAA）服务仅是一个 OAuth2 服务器，可用于**集中式身份管理**。为了访问受保护资源并避免对 API 的未授权访问，必须有一个授权服务器来授权请求并提供对资源的访问。
- en: OAuth2 is an authorization framework that provides access to the request based
    on tokens. Clients request access to a service; if the user is authorized, the
    application receives an authorization grant. After receiving the grant, the client
    requests a token from the authorization server. Once the token is received, the
    client will then request the resource server gets the necessary information.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth2 是一个授权框架，它根据令牌提供对请求的访问。客户端请求访问服务；如果用户被授权，应用程序将收到授权许可。在收到许可后，客户端从授权服务器请求令牌。一旦收到令牌，客户端将请求资源服务器获取必要的信息。
- en: JHipster supports both standard LDAP protocols and is invoked via JSON APIs.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster 支持标准 LDAP 协议，并通过 JSON API 调用。
- en: JHipster UAA is a user accounting and authorizing service for securing JHipster
    microservices using the OAuth2 authorization protocol.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster UAA 是一个用户账户和授权服务，用于通过 OAuth2 授权协议确保 JHipster 微服务的安全性。
- en: JHipster UAA is a JHipster generated application consisting of user and role
    management. It also has a full-fledged OAuth2 authorization server. This is flexible
    and completely customizable.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster UAA 是一个由 JHipster 生成的应用程序，包括用户和角色管理。它还拥有一个完整的 OAuth2 授权服务器。这是灵活的，并且可以完全自定义。
- en: Security is essential in a microservice architecture. The following are the
    basic requirements for securing microservices.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，安全性至关重要。以下是为确保微服务安全的基本要求。
- en: They should be authenticated in one place. Users should experience the entire
    experience as a single unit. Once the end user logs in to the application, they
    should be able to access whatever they have access to. They should hold session-related
    information throughout the time they are logged in to the system.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 它们应该在同一个地方进行身份验证。用户应该将整个体验视为一个单一单元。一旦最终用户登录到应用程序，他们应该能够访问他们有权访问的内容。他们应该在登录到系统的整个时间内持有会话相关信息。
- en: The security service should be stateless. Irrespective of the service, the security
    service should be capable of providing authentication for requests.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 安全服务应该是无状态的。无论服务如何，安全服务都应该能够为请求提供身份验证。
- en: They also need to have the ability to provide authentication to machines and
    users. They should be able to distinguish them and trace them. Their function
    should be authorizing the incoming request rather than identifying the end user.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 它们还需要有能力为机器和用户提供身份验证。它们应该能够区分它们并追踪它们。它们的功能应该是授权传入的请求，而不是识别最终用户。
- en: Since the underlying services are scalable, security services should also have
    the ability to scale up and down based on requirements.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 由于底层服务是可扩展的，安全服务也应该有能力根据需求进行扩展和缩减。
- en: They should, of course, be safe from attacks. Any known vulnerability should
    be fixed and updated as and when required.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，它们应该免受攻击。任何已知的漏洞都应该在需要时得到修复和更新。
- en: The previous requirements were satisfied by using the OAuth2 protocol.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的要求是通过使用OAuth2协议来满足的。
- en: JHipster UAA is a centralized server that helps to authenticate and authorize
    users. They also have session-related information and the role-based access control
    with the help of a user and role management that is available inside the system.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: JHipster UAA是一个集中式服务器，有助于对用户进行身份验证和授权。它们还有会话相关信息，以及系统内部可用的用户和角色管理帮助下的基于角色的访问控制。
- en: The OAuth2 protocol, in general, provides the token for authenticating based
    on the details provided, which makes them stateless and able to authenticate a
    request from any source.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth2协议通常提供基于提供的详细信息的令牌进行身份验证，这使得它们无状态并且能够从任何来源验证请求。
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: So far, we have seen the benefits of a microservice architecture over monolithic
    applications, and the components that we need to run a microservice application
    such as JHipster Registry, Consul, Zuul, Zipkin, the ELK stack, Hystrix, Prometheus,
    and the JHipster UAA server. In our next chapter, we will see how to build microservices
    using JHipster. We will also learn how we can choose the previous components and
    how easy it is to set them up with JHipster.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了微服务架构相对于单体应用程序的优势，以及我们需要运行微服务应用程序（如JHipster Registry、Consul、Zuul、Zipkin、ELK堆栈、Hystrix、Prometheus和JHipster
    UAA服务器）所需的组件。在我们下一章中，我们将看到如何使用JHipster构建微服务。我们还将了解我们如何选择之前的组件，以及使用JHipster设置它们有多容易。
