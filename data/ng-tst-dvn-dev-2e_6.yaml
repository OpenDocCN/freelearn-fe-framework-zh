- en: Chapter 6. The First Step
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章。第一步
- en: The first step is always the most difficult. This chapter provides an initial
    introductory walk-through of how to use TDD to build an Angular application with
    a component, class, and model. We will be able to begin the TDD journey and see
    the fundamentals in action. Up to this point, this book has focused on a foundation
    of TDD and the tools required for it. Now, we will switch gear and dive into TDD
    with Angular.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步总是最困难的。本章提供了一个使用组件、类和模型通过 TDD 构建 Angular 应用程序的初步介绍性概述。我们将能够开始 TDD 之旅，并看到基础原理的实际应用。到目前为止，这本书一直专注于
    TDD 的基础和所需的工具。现在，我们将换挡，深入 Angular 的 TDD。
- en: 'This chapter will be the first step of TDD. We have already seen how to install
    Karma and Protractor, in addition to small examples and a walk-through on how
    to apply them. In this chapter, we will focus on:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将是 TDD 的第一步。我们已经看到了如何安装 Karma 和 Protractor，以及一些小例子和如何应用它们的概述。在本章中，我们将专注于：
- en: Creating a simple comments application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的评论应用程序
- en: Integrating Karma and Protractor with the application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Karma 和 Protractor 集成到应用程序中
- en: Covering the components of testing and its associated classes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 涵盖测试组件及其相关类
- en: Preparing the application's specifications
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备应用程序的规范
- en: 'Create an application to enter comments. The specifications of the application
    are as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个用于输入评论的应用程序。该应用程序的规范如下：
- en: If I am posting a new comment, when I click on the **Submit** button, the comment
    should be added to the comment list
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我在发表新评论时，点击 **提交** 按钮，评论应该被添加到评论列表中
- en: For a comment, when I click on the **Like** button, the number of likes for
    the comment should increase
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于评论，当我点击 **点赞** 按钮时，评论的点赞数应该增加
- en: 'Now that we have the specifications of the application, we can create our development
    to-do list. It won''t be easy to create an entire to-do list of the whole application.
    Based on the user specifications, we have an idea of what needs to be developed.
    Here is a rough sketch of the UI:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了应用程序的规范，我们可以创建我们的开发待办事项列表。创建整个应用程序的待办事项列表并不容易。根据用户规范，我们有一个关于需要开发什么内容的想法。以下是
    UI 的初步草图：
- en: '![Preparing the application''s specifications](img/image_06_001-1.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![准备应用程序的规范](img/image_06_001-1.jpg)'
- en: Hold back from jumping into the implementation and thinking about how we will
    use a component class, `*ngFor`, and so on. Resist, resist, resist! Although we
    can think of how this will be developed in the future, it is never clear until
    we delve into the code, and that is where we will start getting into trouble.
    TDD and its principles are here to help us get our mind and focus in the right
    place.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在跳入实现并思考我们将如何使用组件类、`*ngFor` 等之前，先忍住。忍住，忍住，忍住！虽然我们可以想象未来会如何开发，但直到我们深入研究代码，这永远是不清晰的，而且那正是我们将开始遇到麻烦的地方。TDD
    及其原则就在这里帮助我们把思想和注意力放在正确的位置。
- en: Setting up the Angular project
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Angular 项目
- en: In previous chapters, we discussed in detail how a project should be set up,
    looked at the different components involved, and walked through the entire process
    of testing. We will skip these details and provide a list in the following section
    for the initial actions to get the project set up and ready with a test configuration
    for unit and end-to-end testing.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们详细讨论了如何设置项目，查看涉及的不同组件，并走过了整个测试过程。我们将跳过这些细节，并在下一节提供一个列表，列出初始操作以设置项目并准备好单元测试和端到端测试的配置。
- en: Loading an existing project
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载现有项目
- en: We will get a simple Angular project from the Angular team's examples and modify it for
    our implementation.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 Angular 团队的示例中获取一个简单的 Angular 项目，并对其进行修改以适应我们的实现。
- en: We will clone the `quickstart` project from the Angular GitHub repo and start
    with that one. We should have Git installed globally besides `node`/`npm`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 Angular GitHub 仓库克隆 `quickstart` 项目，并从这个项目开始。除了 `node`/`npm` 之外，我们还应该全局安装
    Git。
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will copy the project locally as `angular-project`; this project may contain
    some extra files (they may be updated continuously), but we will try to keep our
    project folder structure looking like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把项目复制到本地，命名为 `angular-project`；这个项目可能包含一些额外的文件（它们可能会持续更新），但我们将努力保持我们的项目文件夹结构如下：
- en: '![Loading an existing project](img/image_06_002.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![加载现有项目](img/image_06_002.jpg)'
- en: We will keep it simple initially, and then, we will add our required files step
    by step. This will make us more confident.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初会保持简单，然后逐步添加我们需要的文件。这将使我们更有信心。
- en: 'Let''s proceed with it and run the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续进行并运行以下命令：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `npm install` command will install the required modules for project dependencies
    that are defined in the `package.json` file that is in the project's root.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm install` 命令将安装项目根目录中 `package.json` 文件中定义的项目依赖所需的模块。'
- en: Setting up the directory
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置目录
- en: In previous examples, we put the component, unit test spec, and e2e test spec
    in the same folder just to keep it simpler. For a larger project, it's difficult
    to manage all in the same folder.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，我们只是为了保持简单，将组件、单元测试规范和端到端测试规范放在同一个文件夹中。对于更大的项目，将所有内容放在同一个文件夹中很难管理。
- en: To make that manageable, we will put the test spec in a separate folder. Here,
    our sample `quickstart` project has already put test specs in the default folder,
    but we will have a new structure and will put our test files in the new structure.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于管理，我们将测试规范放在一个单独的文件夹中。在这里，我们的示例 `quickstart` 项目已经将测试规范放在了默认文件夹中，但我们将有一个新的结构，并将测试文件放在新的结构中。
- en: 'Let''s start setting up the project directory:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始设置项目目录：
- en: 'Navigate to the project''s root folder:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到项目根目录：
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Initialize the test (`spec`) directory:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化测试（`spec`）目录：
- en: '[PRE3]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Initialize the `unit` test directory:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化 `unit` 测试目录：
- en: '[PRE4]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Initialize the end-to-end (`e2e`) test directory:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化端到端（`e2e`）测试目录：
- en: '[PRE5]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once the initialization is complete, our folder structure should look as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化完成后，我们的文件夹结构应该如下所示：
- en: '![Setting up the directory](img/image_06_003.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![设置目录](img/image_06_003.jpg)'
- en: Setting up Karma
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 Karma
- en: The details for Karma can be found in [Chapter 3](ch03.html "Chapter 3. The
    Karma Way"), *The Karma Way*. Here, we will mostly take a look at the Karma configuration
    file.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Karma 的详细信息可以在 [第 3 章](ch03.html "第 3 章。Karma 方式") *Karma 方式* 中找到。在这里，我们将主要查看
    Karma 配置文件。
- en: In this `quickstart` project, we have already installed and configured Karma,
    and we have the `karma.conf.js` file in the project directory.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `quickstart` 项目中，我们已安装并配置了 Karma，并在项目目录中拥有 `karma.conf.js` 文件。
- en: 'To confirm that we have Karma in the system, let''s install it globally using
    the following command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认系统中已安装 Karma，让我们使用以下命令全局安装它：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As mentioned before, we already have Karma configured in this project as part
    of a `quickstart` project, and we have the `karma.conf.js` file in the project
    directory.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们已经在 `quickstart` 项目中配置了 Karma，作为项目的一部分，并在项目目录中拥有 `karma.conf.js` 文件。
- en: Now we will look at some basic configuration options that everyone should know.
    In this configuration file, there are some advanced options, such as test reporting
    and bug reporting. We will skip those as they are not very important to know at
    this initial stage.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将查看一些每个人都应该知道的基本配置选项。在这个配置文件中，有一些高级选项，如测试报告和错误报告。我们将跳过这些，因为它们在这个初始阶段并不是很重要。
- en: Let's know more about a few of the configurations that we will need to proceed
    further.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地了解一些我们将需要进一步进行的配置。
- en: The `basePath` should be updated when we have a custom path for the project
    in the server. For now, it's `''`, as this project is running in the root path.
    The next option is the `frameworks`; by default, we are using `jasmine` here,
    but we can change the framework name if we want to use others, such as `mocha`.
    One point to remember is that if we plan for a different framework, we will have
    to add the relevant plugin.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在服务器中有项目的自定义路径时，应该更新 `basePath`。目前它是 `''`，因为这个项目是在根路径上运行的。下一个选项是 `frameworks`；默认情况下，我们在这里使用
    `jasmine`，但如果我们想使用其他框架，如 `mocha`，我们可以更改框架名称。需要记住的一点是，如果我们计划使用不同的框架，我们必须添加相关的插件。
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Plugins are required, as Karma will use these `npm` modules inside to perform
    the actions; for example, if we plan to use PhantomJS as the browser, we will
    need to add `''karma-phantomjs-launcher''` to the list:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 需要插件，因为 Karma 将使用这些 `npm` 模块来执行操作；例如，如果我们计划使用 PhantomJS 作为浏览器，我们需要将 `'karma-phantomjs-launcher'`
    添加到列表中：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The next and most important option is `files[]`; with this, Karma will include
    all the required files for testing. It loads a file based on dependency. We will
    have all the required files in the `files[]` array.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个最重要的选项是 `files[]`；通过这个选项，Karma 将包含所有测试所需的文件。它根据依赖关系加载文件。我们将所有所需的文件放在 `files[]`
    数组中。
- en: First, we will add `System.js` since we use `systemjs` as the module loader
    in the app. Then, add `polyfills` for shim support on all browsers, `zone.js`
    for Async support in the app, RxJS as the reactive library, Angular library files,
    shim for Karma test, the components file, and, finally, the test specs. There
    might be some other files in the list for debug and reporting; we are skipping
    their explanations.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将添加 `System.js`，因为我们在这个应用程序中使用 `systemjs` 作为模块加载器。然后，添加 `polyfills` 以支持所有浏览器的shim，`zone.js`
    以支持应用程序中的异步操作，RxJS 作为响应式库，Angular 库文件，Karma 测试的shim，组件文件，最后是测试规范。列表中可能还有一些其他文件用于调试和报告；我们将跳过它们的解释。
- en: 'This is what our `files[]` array will look like:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的 `files[]` 数组看起来像：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: That's all we need to know for now in the `karma.conf` file. We will proceed
    by updating these settings if needed.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们只需要在 `karma.conf` 文件中了解这些。如果需要，我们将通过更新这些设置来继续。
- en: 'Let''s take a look at the complete `karma.conf.js` file:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下完整的 `karma.conf.js` 文件：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Test directory updated
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试目录已更新
- en: We have seen details of `karma-test-shim.js` in [Chapter 3](ch03.html "Chapter 3. The
    Karma Way"), *The Karma Way*. This is needed to run unit testing via Karma.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '我们在[第3章](ch03.html "第3章。Karma 方式")中看到了 `karma-test-shim.js` 的详细内容，*Karma 方式*。这是通过
    Karma 运行单元测试所需的。 '
- en: We have changed the test specs directory/location, and `karma-test-shim.js`
    is configured based on the default structure of the project. Because we have moved
    the test to a different location and out of the `app/` folder, we need to update
    `karma-test-shim.js` accordingly.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已更改测试规范目录/位置，并基于项目的默认结构配置了 `karma-test-shim.js`。因为我们已经将测试移动到不同的位置并移出了 `app/`
    文件夹，所以我们需要相应地更新 `karma-test-shim.js`。
- en: 'Here is the change that will need to be made:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是需要进行的更改：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Setting up Protractor
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 Protractor
- en: In [Chapter 4](ch04.html "Chapter 4. End-to-End Testing with Protractor"), *End-to-End
    Testing with Protractor*, we discussed the full installation and setup of Protractor.
    This sample application already has Protractor installed and configured. So, we
    will just take a look at the `protractor.conf.js` file.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章。使用 Protractor 进行端到端测试")中，我们讨论了 Protractor 的完整安装和设置。这个示例应用程序已经安装并配置了
    Protractor。因此，我们只需查看 `protractor.conf.js` 文件。
- en: This configured Protractor instance has test reporting implemented. We will
    skip those parts from the config file here and just have a look at the common
    setting options.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置的 Protractor 实例实现了测试报告。我们将跳过配置文件中的这些部分，只查看常见的设置选项。
- en: 'Before we go to the config file overview, to be sure, we will install Protractor
    globally on the system:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入配置文件概述之前，为了确保，我们将在系统上全局安装 Protractor：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Update Selenium WebDriver:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 Selenium WebDriver：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We will have to make sure that Selenium is installed.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须确保 Selenium 已安装。
- en: 'As expected, `protractor.conf.js` is located at the root of the application.
    Here is the complete configuration of the `protractor.conf.js` file:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，`protractor.conf.js` 文件位于应用程序的根目录。以下是 `protractor.conf.js` 文件的完整配置：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Top-down versus bottom-up approach - which one do we use?
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自顶向下与自底向上方法 - 我们使用哪一个？
- en: 'From a development perspective, we have to determine where to start. The approaches
    that we will discuss in this book are as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 从开发的角度来看，我们必须确定从哪里开始。本书中我们将讨论的方法如下：
- en: '**The bottom-up approach**: With this approach, we think about the different
    components we will need (class, service, module, and so on) and then pick the
    most logical one and start coding.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自底向上的方法**：采用这种方法，我们考虑我们需要的不同组件（类、服务、模块等），然后选择最合理的一个并开始编码。'
- en: '**The top-down approach**: With this approach, we work from the user scenario
    and UI. We then create the application around the components in the application.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自顶向下的方法**：采用这种方法，我们从用户场景和UI开始工作。然后，我们围绕应用程序中的组件创建应用程序。'
- en: There are merits to both these approaches, and the choice can be based on your
    team, the existing components, requirements, and so on. In most cases, it is best
    for you to make the choice based on the least resistance.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都有优点，选择可以基于你的团队、现有组件、需求等。在大多数情况下，最好根据最小阻力原则来做出选择。
- en: In this chapter, the approach of the specification is top-down; everything is
    laid out for you from the user scenario and will allow you to organically build
    the application around the UI.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，规范的采用自顶向下的方法；从用户场景开始，所有内容都为你准备好了，这将允许你围绕UI有机地构建应用程序。
- en: Testing a component
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试组件
- en: Before getting into the specifications and the mindset of the feature being
    delivered, it is important to understand the fundamentals of testing a component
    class. A component in Angular is a key feature used in most applications.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入到规格和即将交付的功能的心态之前，了解测试组件类的基本原理非常重要。在Angular中，组件是一个在大多数应用程序中使用的核心功能。
- en: Getting ready to go
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备出发
- en: Our sample application (`quickstart`) has some very basic test specs for unit
    and end-to-end testing. We will start the TDD approach from the very beginning,
    so we will not use any of the test specs and the existing component's code in
    our implementation.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例应用程序（`quickstart`）有一些非常基本的单元和端到端测试规格。我们将从开始就采用TDD方法，因此我们不会在我们的实现中使用任何测试规格和现有组件的代码。
- en: For that, what can we do is just clean up this sample application, and we will
    just keep the folder structure and application bootstrap files.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们可以清理这个示例应用程序，我们只保留文件夹结构和应用程序引导文件。
- en: So, first of all, we will have to remove the unit test file (`app.component.spec.ts`)
    and end-to-end test files (`app.e2e-spec.ts`). These are two test specs that existed
    in the application structure.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先，我们必须删除单元测试文件（`app.component.spec.ts`）和端到端测试文件（`app.e2e-spec.ts`）。这是应用程序结构中存在的两个测试规格。
- en: Setting up a simple component test
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置简单的组件测试
- en: When testing a component, it's important to inject the component into the test
    suite and then initiate the component class as the second task. The tests confirm
    that either the objects or methods in the component's scope are available as expected.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试组件时，将组件注入测试套件并作为第二项任务初始化组件类非常重要。测试确认组件范围内的对象或方法是否按预期可用。
- en: 'To have the component instance in the test suite, we will use the simple `import`
    statement in the test suite and initiate the component object in the `beforeEach`
    method so that we have a new instance of the component object for every test spec
    with that test suite. Here is an example of what this will look like:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要在测试套件中拥有组件实例，我们将在测试套件中使用简单的`import`语句，并在`beforeEach`方法中初始化组件对象，这样我们就可以为每个测试规格创建一个新的组件对象。以下是一个示例，展示这将如何看起来：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: So, as long as the component class is initiated for every test spec, it will
    have a new instance for every spec, and the internal scope will act based on that.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，只要为每个测试规格初始化组件类，它将为每个规格提供一个新实例，内部作用域将根据这一点进行操作。
- en: Initializing the component
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化组件
- en: To test a component, it's important to initialize the component class so that
    we have the component object available to the test suite's scope and all the members
    of the object are available around the specific test suite.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试一个组件，初始化组件类非常重要，这样我们就可以在测试套件的范围内获得组件对象，并且该对象的全部成员在特定的测试套件中都是可用的。
- en: As long as the component contains the template to render the UI, it's important
    to initialize the component before beginning e2e testing, and it depends on DOM
    elements.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 只要组件包含用于渲染UI的模板，在开始端到端测试之前初始化组件非常重要，并且它依赖于DOM元素。
- en: 'So when we plan to do e2e testing for any component, we should initiate that
    in the DOM, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们计划对任何组件进行端到端测试时，我们应该在DOM中初始化它，如下所示：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: End-to-end versus unit test for components
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件的端到端测试与单元测试的比较
- en: In the preceding example, we looked at the component test suite, which is for
    unit testing, and we have to import and create an instance of the component class
    as the unit test. We will test the functionality or feature of every method that
    is defined in the component.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们查看的是组件测试套件，它是用于单元测试的，我们必须导入并创建组件类的实例作为单元测试。我们将测试组件中定义的每个方法的函数或特性。
- en: On the other hand, for end-to-end testing, we do not need to import or create
    an instance of the component class as we will not need to comment with the competent
    object or all its members. Rather, it needs to interact with the DOM elements
    of the landing page of the application that is running.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，对于端到端测试，我们不需要导入或创建组件类的实例，因为我们不需要与组件对象或其所有成员进行注释。相反，它需要与应用程序运行页面的DOM元素交互。
- en: So, for that, we will need to run the application and navigate the test suite
    to the application landing page, and we can do so with the global `browser` object
    provided by Protractor itself.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要运行应用程序并导航测试套件到应用程序的着陆页，我们可以使用Protractor本身提供的全局`browser`对象来完成这一点。
- en: 'Here is an example of what it should look like:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，展示它应该看起来像什么：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can navigate to all the URLs of the application using `browser.get('path')`
    as needed.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`browser.get('path')`按需导航到应用程序的所有URL。
- en: Diving into our comment application
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入我们的评论应用程序
- en: 'Now that the setup and approach have been decided, we can start our first test.
    From a testing point of view, as we will be using a top-down approach, we will
    write our Protractor tests first and then build the application. We will follow
    the same TDD life cycle we have already reviewed: test first, make it run, and
    make it better.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在设置和方案已经确定，我们可以开始我们的第一个测试。从测试的角度来看，因为我们将会使用自顶向下的方法，我们将首先编写Protractor测试，然后构建应用程序。我们将遵循我们已经审查过的相同TDD生命周期：先测试，然后运行，最后改进。
- en: Test first
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 先测试
- en: 'The scenario given is already in a well-specified format and fits our Protractor
    testing template:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的场景已经以良好的格式指定，并且适合我们的Protractor测试模板：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Placing the scenario in the template, we get the following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 将场景放入模板中，我们得到以下代码：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Following the 3 A's (assemble, act, assert), we will fit the user scenario in
    the template.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 按照三个A（组装、行动、断言），我们将用户场景适配到模板中。
- en: Assemble
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组装
- en: 'The browser will need to point to the first page of the application. As the
    base URL has already been defined, we can add the following to the test:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器需要指向应用程序的第一页。因为基本URL已经定义，我们可以在测试中添加以下内容：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now that the test has been prepared, we can move on to the next step: act.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试已经准备就绪，我们可以进行下一步：行动。
- en: Act
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 行动
- en: The next thing we need to do, based on the user specification, is to add an
    actual comment. The easiest thing is to just put some text into an input box.
    The test for this, again without knowing what the element will be called or what
    it will do, is to write it based on what it should be.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 根据用户规格，下一步我们需要做的是添加一个实际的评论。最简单的方法是将一些文本放入输入框中。对于这个测试，同样不知道元素将被命名为什么或它将做什么，我们可以根据它应该是什么来编写它。
- en: 'Here is the code to add the comment section for the application:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为应用程序添加评论部分的代码：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The last assembly component, as a part of the test, is to click on the **Submit**
    button. This can be easily achieved in Protractor using the `click` function.
    Even though we don''t have a page yet, or any attributes, we can still name the
    button that will be created:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个组装组件，作为测试的一部分，是点击**提交**按钮。这可以通过Protractor中的`click`函数轻松实现。即使我们没有页面，或者任何属性，我们仍然可以命名将要创建的按钮：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Finally, we will hit the crux of the test and assert the user's expectations.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将触及测试的核心，并断言用户的期望。
- en: Assert
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 断言
- en: The user expectation is that once the **Submit** button is clicked on, the comment
    is added. This is a little ambiguous, but we can determine that somehow the user
    needs to get notified that the comment was added.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 用户期望的是，一旦点击**提交**按钮，评论就会被添加。这有点模糊，但我们可以确定用户需要以某种方式被告知评论已被添加。
- en: 'The easiest approach is to display all comments on the page. In Angular, the
    easiest way to do this is to add an `*ngFor` object that displays all comments.
    To test this, we will add the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是在页面上显示所有评论。在Angular中，最简单的方法是添加一个显示所有评论的`*ngFor`对象。为了测试这一点，我们将添加以下内容：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now the test has been constructed and meets the user specifications. It is
    small and concise. Here is the completed test:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试已经构建并符合用户规格。它既小又简洁。以下是完成后的测试：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Make it run
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让它运行
- en: Based on the errors and output of the test, we will build our application as
    we go.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 根据错误和测试输出，我们将逐步构建我们的应用程序。
- en: 'Start the web server using the following command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令启动网络服务器：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Run the Protractor test to see the first error:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Protractor测试以查看第一个错误：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Alternatively, we can run this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以运行以下命令：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Our first error could be that it''s not getting the element the locator expected:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能遇到的第一个错误是它没有获取定位器期望的元素：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The reason for the error is simple: it''s not getting the element as defined
    in the locator. We can see the current application and why it''s not getting the
    element.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 错误的原因很简单：它没有获取定位器中定义的元素。我们可以看到当前应用程序以及为什么它没有获取到元素。
- en: Recap the present application
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 回顾当前应用程序
- en: As long as we have cloned the sample Angular `quickstart` project as our application
    to test, it has a ready Angular environment. It Bootstraps the Angular project
    with a simple application component defined with `My First Angular 2 App` as the
    output.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们将样本Angular `quickstart`项目克隆为我们测试的应用程序，它就有一个现成的Angular环境。它使用定义了`My First
    Angular 2 App`作为输出的简单应用程序组件引导Angular项目。
- en: So, in our TDD approach, we should not have any environment/Angular Bootstrap-related
    error, and it seems we are on the right path.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的TDD方法中，我们不应该有任何环境/Angular引导相关的错误，而且看起来我们正在正确的道路上。
- en: Let's take a look at what we have right now in our sample application. On our
    landing page, `index.html`, we have included all required library files and implemented
    `system.js` to load the application files.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们现在在示例应用程序中的情况。在我们的着陆页`index.html`中，我们已经包含了所有必需的库文件并实现了`system.js`来加载应用程序文件。
- en: 'In the `<body>` tag in the `index.html` file, we have initiated the application
    as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在`index.html`文件中的`<body>`标签中，我们如下启动了应用程序：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The HTML tag expects a component with `my-app` as the selector for that component,
    and yes, we have that as `app.component.ts`, as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: HTML标签期望一个具有`my-app`作为选择器的组件，是的，我们有一个作为`app.component.ts`，如下所示：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Angular introduced `ngModule` as an `appModule` to modularize and manage dependencies
    for every component. With this `appModule`, an application can define all the
    required dependencies at a glance. Besides that, it helped lazy-load the modules.
    We will look at the details of `ngModule` in the Angular docs.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Angular引入了`ngModule`作为`appModule`来模块化和管理每个组件的依赖关系。使用这个`appModule`，一个应用程序可以一目了然地定义所有必需的依赖关系。除此之外，它还帮助懒加载模块。我们将在Angular文档中查看`ngModule`的详细信息。
- en: It imports all the required modules in the application, declares all the modules
    from a single entry point, and also defines the Bootstrapping component.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 它导入了应用程序中所有必需的模块，从单个入口点声明所有模块，并定义了引导组件。
- en: The application always Bootstraps based on this file's configuration.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序始终根据此文件的配置引导。
- en: 'The file is located at the application root as `app.module.ts`, and it looks
    as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件位于应用程序根目录下的`app.module.ts`，如下所示：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The entry point to the application is the `main.ts` file, which will import
    the `appModule` file and instruct to Bootstrap the application based on that:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的入口点是`main.ts`文件，它将导入`appModule`文件并指示根据该文件引导应用程序：
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The test couldn't find our input locator. We need to add the input to the page,
    and we need to do that via the component's template.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 测试找不到我们的输入定位器。我们需要将输入添加到页面上，并且我们需要通过组件的模板来完成。
- en: Adding the input
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加输入
- en: 'Here are the steps we need to follow to add the input to the page:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要遵循以下步骤将输入添加到页面上：
- en: 'We will have to add a simple `input` tag to the template of the application
    component, as shown here:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将不得不向应用程序组件的模板中添加一个简单的`input`标签，如下所示：
- en: '[PRE33]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After running the test again, it seems that there are no more errors related
    to the input locator, but it has a new error as the `button` tag was missing:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行测试后，似乎没有更多与输入定位器相关的错误，但有一个新的错误，因为`button`标签缺失：
- en: '[PRE34]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Just like the previous error, we need to add a `button` to the template with
    the appropriate text:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像之前的错误一样，我们需要在模板中添加一个带有适当文本的`button`：
- en: '[PRE35]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'After running the test again, it seems that there are no more errors related
    to the `button` locator, but again, it has a new error, as follows, as the repeater
    locator is missing:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行测试后，似乎没有更多与`button`定位器相关的错误，但再次出现新的错误，因为重复器定位器缺失：
- en: '[PRE36]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This appears to be a result of our assumption that a submitted comment will
    be available on the page through `*ngFor`. To add this to the page, we will use
    a method in the component class to provide the data for the repeater.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎是我们假设提交的评论将通过`*ngFor`在页面上可用。为了将此添加到页面上，我们将使用组件类中的方法来提供重复器的数据。
- en: Component
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组件
- en: As mentioned in the preceding section, the error occurs because there is no
    `comments` object. In order to add the `comments` object, we will use the component
    class that has an array of `comments` in its scope.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，错误发生是因为没有`comments`对象。为了添加`comments`对象，我们将使用在其作用域中有一个`comments`数组组件类。
- en: 'Perform the following steps to add a `comments` object to the scope:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以将`comments`对象添加到作用域：
- en: 'As we already have `AppComponent` as a class in our component, we will need
    to define the comments array, which we can use in a repeater:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们已经在组件中有一个`AppComponent`类，我们需要定义评论数组，我们可以使用它在一个重复器中：
- en: '[PRE37]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, we will add a repeater for the comments in the template, as shown here:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将在模板中添加一个用于评论的重复器，如下所示：
- en: '[PRE38]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s run the Protractor test and see where we are:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行Protractor测试，看看我们现在在哪里：
- en: '[PRE39]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Oops! We are still getting the same error. However, don't worry; there might
    be some other issue.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！我们还在得到相同的错误。然而，别担心；可能还有其他问题。
- en: Let's look at the actual page that gets rendered and see what's going on. In
    Chrome, navigate to `http://localhost:3000` and open the console to see the page
    source (*Ctrl + Shift + J*). Note that the repeater and component are both there;
    however, the repeater is commented out. Since Protractor is only looking at visible
    elements, it won't find the list.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实际渲染的页面，看看发生了什么。在Chrome中，导航到`http://localhost:3000`并打开控制台以查看页面源代码（*Ctrl
    + Shift + J*）。注意，重复器和组件都在那里；然而，重复器被注释掉了。由于Protractor只查看可见元素，它不会找到列表。
- en: Great! Now we know why the repeater list isn't visible, but we have to fix it.
    In order for a comment to show up, it has to exist on the component's `comments`
    scope.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在我们知道为什么重复列表不可见，但我们必须修复它。为了让注释显示出来，它必须存在于组件的`comments`作用域中。
- en: 'The smallest change is to add something to the array to initialize it, as shown
    in the following code snippet:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最小的更改是向数组添加一些内容以初始化它，如下面的代码片段所示：
- en: '[PRE40]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, if we run the test, we get the following output:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行测试，我们会得到以下输出：
- en: '[PRE41]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Great, it seems we are getting closer as the errors have gone down! We have
    tackled almost all the unexpected errors and met our expectations.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，看起来我们越来越接近了，错误已经减少！我们几乎解决了所有意外错误，并达到了我们的预期。
- en: So let's take a look at the changes that we have made so far and what our codes
    look like.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们看看我们迄今为止所做的更改以及我们的代码看起来像什么。
- en: 'Here''s the `body` tag of the `index.html` file:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`index.html`文件的`body`标签：
- en: '[PRE42]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The application component file is as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 应用组件文件如下：
- en: '[PRE43]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Make it pass
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使其通过
- en: With TDD, we want to add the smallest possible component to make the test pass.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TDD，我们希望添加最小的组件来使测试通过。
- en: Since we have hard coded the comments array for the moment to be initialized
    to three items and the first items to be `First comment`, change `First comment`
    to `a sample comment`; this should make the test pass.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们目前将注释数组硬编码为初始化为三个项目，第一个项目为`First comment`，将`First comment`更改为`一个示例注释`；这应该会使测试通过。
- en: 'Here is the code to make the test pass:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使测试通过的代码：
- en: '[PRE44]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Run the test, and bam! We get a passing test:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试，然后！我们得到了一个通过测试：
- en: '[PRE45]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Wait a second! We still have some work to do. Although we got the test to pass,
    it is not done. We added some hacks just to get it to pass. Two things stand out:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下！我们还有一些工作要做。虽然我们通过了测试，但这还没有完成。我们只是添加了一些黑客手段来让它通过。有两件事很突出：
- en: We clicked on the **Submit** button, which really doesn't have any functionality
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们点击了**提交**按钮，但实际上它没有任何功能
- en: We hardcoded the initialization of the expected value for a comment
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们硬编码了注释预期值的初始化
- en: The preceding changes are critical steps that we need to perform before we move
    forward. They will be tackled in the next phase of the TDD life cycle, that is,
    make it better (refactor).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 上述更改是我们需要在我们继续前进之前执行的临界步骤。它们将在TDD生命周期的下一阶段解决，即改进（重构）。
- en: Make it better
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改进
- en: 'The two components that need to be reworked are as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 需要重做的两个组件如下：
- en: Adding behavior to the **Submit** button
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为**提交**按钮添加行为
- en: Removing the hardcoded value of the comments
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除注释的硬编码值
- en: Implementing the Submit button
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现提交按钮
- en: The **Submit** button needs to actually do something. We were able to sidestep
    the implementation by just hardcoding the value. Using our tried-and-trusted TDD
    techniques, switch to an approach focused on unit testing. So far, the focus has
    been on the UI and pushing changes to the code; we haven't written a single unit
    test.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**提交**按钮实际上需要做一些事情。我们通过仅硬编码值来规避了实现。使用我们经过验证和可靠的TDD技术，转向关注单元测试的方法。到目前为止，重点一直在于UI和向代码中推送更改；我们还没有编写任何单元测试。'
- en: For this next bit of work, we will switch gears and focus on driving the development
    of the **Submit** button through tests. We will be following the TDD life cycle
    (test first, make it run, and make it better).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 对于接下来的工作，我们将转换方向，专注于通过测试驱动开发**提交**按钮。我们将遵循TDD生命周期（先测试，然后运行，最后改进）。
- en: Configuring Karma
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 配置Karma
- en: We did something very similar for the to-do list application in [Chapter 3](ch03.html
    "Chapter 3. The Karma Way"), *The Karma Way*. We won't spend as much time diving
    into the code, so review the previous chapters for a deeper discussion of some
    of the attributes.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第3章](ch03.html "第3章。因果之道")的待办事项列表应用程序中做了类似的事情，*因果之道*。我们不会花太多时间深入代码，所以请回顾前面的章节，以深入了解一些属性。
- en: 'Here are the steps we need to follow to configure Karma:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要遵循以下步骤来配置Karma：
- en: 'Update the `files` section with the added files:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`files`部分以包含添加的文件：
- en: '[PRE46]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Start Karma:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Karma：
- en: '[PRE47]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Confirm that Karma is running:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认Karma正在运行：
- en: '[PRE48]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Test first
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 先进行测试
- en: 'Let''s start with a new file in the `spec/unit` folder, called `app.component.spec.ts`.
    This will contain the test spec for the unit test. We will use the base template,
    including all necessary imports, such as `TestBed`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`spec/unit`文件夹中的新文件开始，命名为`app.component.spec.ts`。这将包含单元测试的测试规范。我们将使用基础模板，包括所有必要的导入，如`TestBed`：
- en: '[PRE49]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: According to the specification, when the **Submit** button is clicked on, it
    needs to add a comment. We will need to fill in the blanks of the three components
    of a test (assemble, act, and assert).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 根据规范，当点击**提交**按钮时，需要添加一个注释。我们需要填写测试的三个组成部分的空白（组装、行动和断言）。
- en: '**Assemble**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**组装**'
- en: 'The behavior needs to be part of a component for the frontend to use it. The
    object under testing in this case is the component''s scope. We need to add this
    to the assembly of this test. Like we did in [Chapter 3](ch03.html "Chapter 3. The
    Karma Way"), *The Karma Way*, we will do the same in the following code:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 该行为需要成为组件的一部分，以便前端可以使用它。在这种情况下，测试的对象是组件的作用域。我们需要将此添加到本测试的组装中。像我们在[第3章](ch03.html
    "第3章。Karma之道")中做的那样，*Karma之道*，我们将在以下代码中做同样的事情：
- en: '[PRE50]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now, the component object and its member are available in the test suite and
    will be testable as expected.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，组件对象及其成员在测试套件中可用，并将按预期可测试。
- en: '**Act**'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**行动**'
- en: 'The specification determines that we need to call an `add` method in the component
    object. Add the following code to the `beforeEach` section of the test:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 规范确定我们需要在组件对象中调用一个`add`方法。向测试的`beforeEach`部分添加以下代码：
- en: '[PRE51]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now, the assertion should get the first comment to test.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，断言应该获取第一个注释进行测试。
- en: '**Assert**'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**断言**'
- en: 'Assert that the comment items in the `component` object now contain any comment
    as the first element. Add the following code to the test:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 断言`component`对象中的注释项现在包含任何注释作为第一个元素。向测试中添加以下代码：
- en: '[PRE52]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Save the file, and let's move on to the next step of the life cycle and make
    it run (execute).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件，让我们继续到生命周期中的下一个步骤，让它运行（执行）。
- en: Make it run
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 让它运行
- en: 'Now that we have prepared the test, we need to make the test pass. Looking
    at the output of the console where Karma is running, we see the following:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了测试，我们需要让测试通过。查看Karma运行的控制台输出，我们看到以下内容：
- en: '[PRE53]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Looking at our unit test, we see that this is the `add` function. Let''s go
    ahead and put in an `add` function into the controller''s `scope` object using
    the following steps:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 查看我们的单元测试，我们看到这是`add`函数。让我们继续按照以下步骤在控制器的`scope`对象中添加一个`add`函数：
- en: 'Open the controller scope and create a function named `add`:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制器作用域并创建一个名为`add`的函数：
- en: '[PRE54]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Check Karma''s output, and let''s see where we are:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查Karma的输出，看看我们现在在哪里：
- en: '[PRE55]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, we have hit the expectation. Remember to think of the smallest change
    to get this to work. Modify the `add` function to set the `$scope.comments` array
    to any comment when called:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经达到了预期。记得考虑最小的改动以使其工作。修改`add`函数，在调用时将`$scope.comments`数组设置为任何注释：
- en: '[PRE56]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `unshift` function is a standard JavaScript function that adds an item to
    the front of an array.
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`unshift`函数是一个标准的JavaScript函数，它将一个项目添加到数组的开头。'
- en: 'When we check Karma''s output, we''ll see the following:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们检查Karma的输出时，我们会看到以下内容：
- en: '[PRE57]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Success! The test passes, but again needs some work. Let's move on to the next
    stage and make it better (refactor).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！测试通过了，但仍然需要一些工作。让我们继续到下一个阶段，让它变得更好（重构）。
- en: Make it better
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 让它变得更好
- en: 'The main point that needs to be refactored is the `add` function. It doesn''t
    take any arguments! This should be straightforward to add, and simply confirms
    that the test still runs. Update the `add` function of `app.component.ts` to take
    an argument and use that argument to add to the `comments` array:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 需要重构的主要点是`add`函数。它不接受任何参数！这应该很容易添加，并且只是确认测试仍然运行。更新`app.component.ts`中的`add`函数，使其接受一个参数并使用该参数将内容添加到`comments`数组中：
- en: '[PRE58]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Check the output window of Karma and ensure that the test still passes. The
    complete unit test looks as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 检查Karma的输出窗口，确保测试仍然通过。完整的单元测试如下所示：
- en: '[PRE59]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `AppComponent` class file now looks like this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppComponent`类文件现在看起来是这样的：'
- en: '[PRE60]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Backing up the test chain
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备份测试链
- en: 'We completed the unit test and added the `add` function. Now we can add the
    function to specify the behavior of the **Submit** button. The way to link the
    `add` method to the button is to use the `(click)` event. The steps to add the
    behavior to the **Submit** button are as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了单元测试并添加了 `add` 函数。现在我们可以添加函数来指定**提交**按钮的行为。将 `add` 方法链接到按钮的方式是使用 `(click)`
    事件。将行为添加到**提交**按钮的步骤如下：
- en: 'Open the `app.component.ts` file and update it as follows:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `app.component.ts` 文件并按以下方式更新：
- en: '[PRE61]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Hold on! Is the value hardcoded? Well, again, we want to make the smallest change
    and ensure that the test still passes. We will work through our refactors until
    the code is how we want it to be, but instead of a Big Bang approach, we want
    to make small, incremental changes.
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 等一下！这个值是硬编码的吗？嗯，再次，我们想要做出最小的改变并确保测试仍然通过。我们将通过我们的重构直到代码达到我们想要的样子，但不是采用大爆炸方法，我们想要做出小的、渐进的改变。
- en: Now, let's rerun the Protractor test and ensure that it still passes. The output
    says that it passed, and we are okay. The hardcoded value wasn't removed from
    the comments. Let's go ahead and remove that now.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们重新运行 Protractor 测试并确保它仍然通过。输出显示它通过了，我们没问题。硬编码的值没有被从注释中移除。让我们现在就移除它。
- en: 'The `AppComponent` class file should now look as follows:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AppComponent` 类文件现在应该看起来如下：'
- en: '[PRE62]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Run the test and see that we still get a passing test.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试并查看我们是否仍然得到一个通过测试。
- en: The last thing we need to mop up is the hardcoded value in `(click)`. The comment
    being added should be determined by the input in the comment input text.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后需要清理的是 `(click)` 中的硬编码值。被添加的注释应该由注释输入文本中的输入决定。
- en: Binding the input
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绑定输入
- en: 'Here are the steps we need to follow to bind the input:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们需要遵循的步骤来绑定输入：
- en: 'To be able to bind the input to something meaningful, add an `ngModel` attribute
    to the `input` tag:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了能够将输入绑定到有意义的东西，向 `input` 标签添加一个 `ngModel` 属性：
- en: '[PRE63]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Then, in the `(click)` attribute, simply use the `newComment` model as the
    input:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 `(click)` 属性中，简单地使用 `newComment` 模型作为输入：
- en: '[PRE64]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We will have to import the form module in the app module (`app.module.ts`)
    as it''s a dependency for `ngModel`:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将不得不在应用模块 (`app.module.ts`) 中导入表单模块，因为它是 `ngModel` 的依赖项：
- en: '[PRE65]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Run the Protractor test and confirm that everything has passed and is good to
    go.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Protractor 测试并确认一切通过并且可以继续。
- en: Onward and upward
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向上走
- en: Now that we have the first specification working, and it is end-to-end and unit
    tested, we can start the next specification. The next specification states that
    the user wants the ability to like a comment.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经让第一个规范工作，并且它是端到端和单元测试的，我们可以开始下一个规范。下一个规范表明用户想要点赞评论的能力。
- en: 'We will use the top-down approach and start our test from Protractor. We will
    continue to follow the TDD life cycle: test first, make it run, and make it better.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用自顶向下的方法，并从 Protractor 开始我们的测试。我们将继续遵循 TDD 生命周期：先测试，然后运行，然后改进。
- en: Test first
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 先测试
- en: 'Following the pattern, we will start with a basic Protractor test template:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 按照模式，我们将从一个基本的 Protractor 测试模板开始：
- en: '[PRE66]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'When we fill in the specification, we get the following:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们填写规范时，我们得到以下内容：
- en: '[PRE67]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: With the template in place, we are ready to construct the test.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板就位后，我们准备好构建测试。
- en: Assemble
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组装
- en: 'The assembly of this test will require a comment to exist. Place the comment
    within the existing posted comment test. It should look similar to this:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试的组装需要存在一个注释。将注释放置在现有的已发布注释测试中。它应该看起来像这样：
- en: '[PRE68]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Act
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 行动
- en: 'The user specification we test is that the **Like** button performs an action
    for a specific comment. Here are the steps that will be required and the code
    required to carry them out (note that the following steps will be added to the
    `beforeEach` text):'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测试的用户规范是**点赞**按钮对特定评论执行一个动作。以下是执行这些步骤所需的步骤和代码（注意以下步骤将添加到 `beforeEach` 文本中）：
- en: 'Store the first comment so that it can be used in the test:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储第一个评论以便在测试中使用：
- en: '[PRE69]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Find the first comment''s `likeButton`:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到第一个评论的 `likeButton`：
- en: '[PRE70]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The code for the **Like** button when it is clicked on is as follows:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当点击**点赞**按钮时的代码如下：
- en: '[PRE71]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Assert
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 断言
- en: 'The specification expectation is that once the comment has been liked, it is
    liked. This is best done by putting an indicator of the number of likes and ensuring
    that the count is `1`. The code will then be as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 规范期望是，一旦注释被点赞，它就被点赞了。这最好通过放置点赞数量的指示器并确保计数为 `1` 来完成。代码将如下所示：
- en: '[PRE72]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The created test now looks like this:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的测试现在看起来如下：
- en: '[PRE73]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Make it run
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让它运行
- en: 'The test has been prepared and is itching to run. We will now run it and fix
    the code until the test passes. The following steps will detail the error and
    fix the cycle required to make the test path:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 测试已经准备就绪，迫不及待地想要运行。我们现在将运行它，并修复代码直到测试通过。以下步骤将详细说明错误和修复循环，以使测试路径通过：
- en: Run Protractor.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Protractor。
- en: 'View the error message in the command line:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中查看错误信息：
- en: '[PRE74]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'As the error states, there is no **like** button. Go ahead and add the button:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如错误信息所述，没有 **点赞** 按钮。请继续添加该按钮：
- en: '[PRE75]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Run Protractor.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Protractor。
- en: 'View the next error message:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看下一个错误信息：
- en: '[PRE76]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: By adding the **like** button, we caused our other test to fail. The reason
    is our use of the `getText()` method. Protractor's `getText()` method gets the
    inner text, including inner elements.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加 **点赞** 按钮，我们导致其他测试失败。原因是我们的 `getText()` 方法使用不当。Protractor 的 `getText()`
    方法获取内部文本，包括内部元素。
- en: 'To fix this, we need to update the previous test to include **like** as part
    of the test:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了修复这个问题，我们需要更新之前的测试以包括 **点赞** 作为测试的一部分：
- en: '[PRE77]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Run Protractor.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Protractor。
- en: 'View the next error message:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看下一个错误信息：
- en: '[PRE78]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'It''s time to add a `likes` binding. This one is a little more involved. The `likes`
    needs to be bound to a comment. We need to change the way the comments are held
    in the component. Comments need to hold the `comment` title and the number of
    likes. A comment should be an object like this:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候添加一个 `likes` 绑定了。这个稍微复杂一些。`likes` 需要绑定到一个评论上。我们需要更改组件中保存评论的方式。评论需要保存 `comment`
    标题和点赞数。一个评论应该是一个像这样的对象：
- en: '[PRE79]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Again, the focus of this step is just to get the test to pass. The next step
    is to update the component's `add` function to create comments based on the object
    that we described in the preceding steps.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次强调，这一步的重点只是确保测试通过。下一步是更新组件的 `add` 函数，以便根据我们在前几步中描述的对象创建评论。
- en: 'Open `app.component.ts` and edit the `add` function, as follows:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `app.component.ts` 并编辑 `add` 函数，如下所示：
- en: '[PRE80]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Update the page to use the value for the comment:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新页面以使用评论的值：
- en: '[PRE81]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Before rerunning the Protractor test, we need to add the new `comment.likes`
    binding to the HTML page:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在重新运行 Protractor 测试之前，我们需要将新的 `comment.likes` 绑定添加到 HTML 页面：
- en: '[PRE82]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now rerun the Protractor tests, and let''s see where the errors are:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在重新运行 Protractor 测试，看看错误在哪里：
- en: '[PRE83]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'As the inner text of the comment has changed, we need to change the expectation
    of the test:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于评论的内部文本已更改，我们需要更改测试的预期：
- en: '[PRE84]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Run Protractor:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Protractor：
- en: '[PRE85]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Finally, we are down to the expectation of the test. In order to make this
    test pass, the smallest change will be to make the **like** button update the
    likes on the `comment` array. The first step is to add a `like` method to the
    controller, which will update the number of likes:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们来到了测试的预期。为了使这个测试通过，最小的更改将是使 **点赞** 按钮更新 `comment` 数组上的点赞数。第一步是在控制器中添加一个
    `like` 方法，该方法将更新点赞数：
- en: '[PRE86]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Link the `like` method to the HTML page using a `(click)` attribute on the
    button, as follows:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用按钮上的 `(click)` 属性将 `like` 方法链接到 HTML 页面，如下所示：
- en: '[PRE87]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Run Protractor and confirm that the tests pass!
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Protractor 并确认测试通过！
- en: 'The page now looks like the following screenshot:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 页面现在看起来如下截图所示：
- en: '![Make it run](img/image_06_004.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![让它运行](img/image_06_004.jpg)'
- en: Compared with the diagram at the beginning of this chapter, all the features
    have been created. Now that we've made the test pass in Protractor, we need to
    check the unit tests to ensure that our changes didn't break the them.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章开头的图示相比，所有功能都已创建。现在我们已经使用 Protractor 使测试通过，我们需要检查单元测试以确保我们的更改没有破坏它们。
- en: Fixing the unit tests
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修复单元测试
- en: 'One of the primary changes required was to make the comment an object consisting
    of a value and the number of likes. Before thinking too much about how the unit
    tests could have been affected, let''s kick them off. Execute the following command:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的主要更改之一是将评论变成一个包含值和点赞数的对象。在过多地考虑单元测试可能受到影响之前，让我们启动它们。执行以下命令：
- en: '[PRE88]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'As expected, the error is related to the new `comment` object:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，错误与新的 `comment` 对象有关：
- en: '[PRE89]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Reviewing the expectation, it seems like the only thing required is for `comment.value`
    to be used in the expectation, as opposed to the `comment` object itself. Change
    the expectation as follows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 检查预期，似乎唯一需要的是在预期中使用 `comment.value`，而不是 `comment` 对象本身。按照以下方式更改预期：
- en: '[PRE90]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Save the file and check the Karma output. Confirm that the test passes. Both
    the Karma and Protractor tests pass, and we have completed the primary user behaviors
    of adding a comment and liking it. We are now free to move on to the next step
    and make things better.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件并检查 Karma 输出。确认测试通过。Karma 和 Protractor 测试都通过了，我们已经完成了添加评论和点赞的主要用户行为。现在我们可以自由地继续下一步并使事情变得更好。
- en: Make it better
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让它变得更好
- en: All in all, the approach ended with the result we wanted. Users are now able
    to like a comment in the UI and see the number of likes. The major thing from
    a refactor standpoint is that we have not unit-tested the `like` method.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这种方法最终达到了我们想要的结果。用户现在能够在 UI 中点赞评论并看到点赞数。从重构的角度来看，主要的事情是我们没有对 `like` 方法进行单元测试。
- en: Reviewing our development to-do list, we see that the list is an action that
    we wrote down. Before completely wrapping up the feature, let's discuss the option
    of adding a unit test for the `like` functionality.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们的开发待办事项列表，我们看到列表是我们写下的一项操作。在完全完成功能之前，让我们讨论为 `like` 功能添加单元测试的选项。
- en: Coupling the test
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试耦合
- en: As already discussed, tests are tightly coupled to the implementation. This
    is a good thing when there is a complicated logic involved or we need to ensure
    that certain aspects of the application behave in certain ways. It is important
    to be aware of the coupling and know when it is important to bring it into the
    application and when it is not. The `like` function, which we created, simply
    increments a counter on an object. This can be easily tested; however, the coupling
    that we will bring in with a unit test will not give us the extra value.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，测试与实现紧密耦合。当涉及复杂的逻辑或我们需要确保应用程序的某些方面以特定方式行为时，这是一个好事。重要的是要意识到耦合，并知道何时将其引入应用程序，何时不引入。我们创建的
    `like` 函数只是简单地在一个对象上增加计数器。这可以很容易地进行测试；然而，我们将通过单元测试引入的耦合不会给我们带来额外的价值。
- en: In this case, we will not add another unit test for the `like` method. As the
    application progresses, we may find the need to add a unit test in order to develop
    and extend the function.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个情况下，我们不会为 `like` 方法添加另一个单元测试。随着应用程序的发展，我们可能会发现需要添加单元测试以开发和扩展功能。
- en: 'Here are some things I consider when adding a test:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加测试时，我会考虑以下一些事情：
- en: Does adding a test outweigh the cost of maintaining it?
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加测试是否超过了维护它的成本？
- en: Is the test adding value to the code?
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试是否为代码增加了价值？
- en: Does it help other developers understand the code better?
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是否有助于其他开发者更好地理解代码？
- en: Is the functionality being tested in some or the other way?
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否以某种方式正在测试功能？
- en: Based on our decision, there is no more refactoring or testing required. In
    the next section, we will take a step back and review the main points of this
    chapter.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的决定，不再需要重构或测试。在下一节中，我们将退后一步，回顾本章的主要观点。
- en: Self-test questions
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自我测试问题
- en: Q1\. Karma needs the Selenium WebDriver to run tests.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. Karma 需要 Selenium WebDriver 来运行测试。
- en: 'True'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误
- en: 'Q2\. Given the following code segment, how would you select the following button:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: Q2. 给定以下代码段，你会如何选择以下按钮：
- en: '[PRE91]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '`element.all(by.button(''button''))`'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`element.all(by.button(''button''))`'
- en: '`element.all(by.css(''type=button''))`'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`element.all(by.css(''type=button''))`'
- en: '`element(by.buttonText(''Click Me'')`'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`element(by.buttonText(''Click Me''))`'
- en: Summary
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we walked through the TDD techniques of using Protractor and
    Karma together. As the application was developed, we were able to see where, why,
    and how to apply TDD testing tools and techniques.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了使用 Protractor 和 Karma 一起进行 TDD 技术的方法。随着应用程序的开发，我们能够看到在哪里、为什么以及如何应用
    TDD 测试工具和技术。
- en: The approach, top-down, was different from the bottom-up approach discussed
    in [Chapter 3](ch03.html "Chapter 3. The Karma Way"), *The Karma Way*, and [Chapter
    4](ch04.html "Chapter 4. End-to-End Testing with Protractor"), *End-to-End Testing
    with Protractor*. With the bottom-up approach, the specifications are used to
    build unit tests and then build the UI layer on top of that. In this chapter,
    a top-down approach was shown to focus on the user's behavior.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法，自顶向下，与第 3 章（“Karma 方式”，[ch03.html](ch03.html "Chapter 3. The Karma Way")）、第
    4 章（“使用 Protractor 进行端到端测试”，[ch04.html](ch04.html "Chapter 4. End-to-End Testing
    with Protractor")）中讨论的自底向上方法不同。在自底向上的方法中，规格用于构建单元测试，然后在上面构建 UI 层。在本章中，展示了自顶向下的方法，重点关注用户的行为。
- en: 'The top-down approach tests the UI and then filters the development through
    the other layers. Both the approaches have their merits. When applying TDD, it
    is essential to know how to use both. In addition to walking through a different
    TDD approach, we saw some of the core testing components of Angular, such as the
    following:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 自顶向下的方法首先测试UI，然后通过其他层过滤开发。这两种方法都有其优点。在应用TDD（测试驱动开发）时，了解如何使用这两种方法是至关重要的。除了介绍不同的TDD方法外，我们还看到了Angular的一些核心测试组件，例如以下内容：
- en: Testing a component from end-to-end and unit perspectives
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从端到端和单元测试的角度测试组件
- en: Importing a component class to the test suite and initiating it for unit testing
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将组件类导入测试套件并为其进行单元测试的初始化
- en: Protractor's ability to bind to `ngModel`, send keystrokes to input columns,
    and get an element's text by its inner HTML code and all subelements
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Protractor能够绑定到`ngModel`，向输入列发送按键，并通过其内部HTML代码及其所有子元素获取元素文本的能力
- en: The next chapter will build on the techniques used here and look into headless
    browser testing, advanced techniques for Protractor, and how to test Angular routes.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将基于这里使用的技术，探讨无头浏览器测试、Protractor的高级技术以及如何测试Angular路由。
