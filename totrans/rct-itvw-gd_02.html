<html><head></head><body>
<div id="_idContainer025">
<h1 class="chapter-number" id="_idParaDest-56"><a id="_idTextAnchor055"/><span class="koboSpan" id="kobo.1.1">2</span></h1>
<h1 id="_idParaDest-57"><a id="_idTextAnchor056"/><span class="koboSpan" id="kobo.2.1">Understanding ReactJS Fundamentals and Its Features</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Web development is a critical requirement for today’s modern businesses to generate long-term customer relationships because it provides a platform to interact with your customers. </span><span class="koboSpan" id="kobo.3.2">However, it is challenging to build scalable and optimized web applications for large enterprises that have heavy </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">user interactions.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">JavaScript is a popular programming language for web development. </span><span class="koboSpan" id="kobo.5.2">It has become more popular over the past few years, and it is used to create a wide variety of applications, including web-based apps, mobile apps, desktop apps, and games. </span><span class="koboSpan" id="kobo.5.3">As part of JavaScript’s evolution, a few libraries were created while keeping its reusable </span><strong class="bold"><span class="koboSpan" id="kobo.6.1">user interface</span></strong><span class="koboSpan" id="kobo.7.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.8.1">UI</span></strong><span class="koboSpan" id="kobo.9.1">) in mind to speed up development, but they failed to improve its performance by re-rendering the whole UI even for any small change. </span><span class="koboSpan" id="kobo.9.2">This situation has been overcome by the introduction of the ReactJS library, which is based on composable components and it only re-renders specific parts of the application wherever the screen updates are required. </span><span class="koboSpan" id="kobo.9.3">Before we deep dive into ReactJS’s features, it is important to understand the fundamentals of React so that you can face interviews with confidence and have a strong foundation for the React </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">developer role.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">This chapter will give you complete knowledge of React fundamentals such as class components, functional components, state, props, and JSX as a starting point. </span><span class="koboSpan" id="kobo.11.2">You must understand important features such as virtual DOM unidirectional data flow, refs, the context API, and </span><strong class="bold"><span class="koboSpan" id="kobo.12.1">server-side rendering </span></strong><span class="koboSpan" id="kobo.13.1">(</span><strong class="bold"><span class="koboSpan" id="kobo.14.1">SSR</span></strong><span class="koboSpan" id="kobo.15.1">) to be able to answer most questions asked </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">by interviewers.</span></span></p>
<p><span class="koboSpan" id="kobo.17.1">In this chapter, we’re going to cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.19.1">Prerequisites </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">to ReactJS</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">Introduction </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">to ReactJS</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.23.1">Understanding JSX</span></span></li>
<li><span class="koboSpan" id="kobo.24.1">Building views with elements </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">and components</span></span></li>
<li><span class="koboSpan" id="kobo.26.1">Controlling the component data using props </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">and state</span></span></li>
<li><span class="koboSpan" id="kobo.28.1">Understanding the importance of </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">key prop</span></span></li>
<li><span class="koboSpan" id="kobo.30.1">Learning about </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">event handling</span></span></li>
<li><span class="koboSpan" id="kobo.32.1">Understanding the </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">virtual DOM</span></span></li>
<li><span class="koboSpan" id="kobo.34.1">Difference between unidirectional data flow and bidirectional </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">data flow</span></span></li>
<li><span class="koboSpan" id="kobo.36.1">Accessing DOM elements </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">in React</span></span></li>
<li><span class="koboSpan" id="kobo.38.1">Managing state globally using the </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">context API</span></span></li>
<li><span class="koboSpan" id="kobo.40.1">Understanding </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">server-side rendering</span></span></li>
</ul>
<h1 id="_idParaDest-58"><a id="_idTextAnchor057"/><span class="koboSpan" id="kobo.42.1">Prerequisites to ReactJS</span></h1>
<p><span class="koboSpan" id="kobo.43.1">For this chapter, you need to know about the following web technologies</span><a id="_idIndexMarker092"/><span class="koboSpan" id="kobo.44.1"> and topics before you can learn about ReactJS’s fundamentals and its features. </span><span class="koboSpan" id="kobo.44.2">These technologies will act as a strong foundation for </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">learning ReactJS:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.46.1">Basic knowledge of HTML, CSS, </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">and JavaScript</span></span></li>
<li><span class="koboSpan" id="kobo.48.1">The fundamentals of ES6 features such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.49.1">let</span></strong><span class="koboSpan" id="kobo.50.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.51.1">const</span></strong><span class="koboSpan" id="kobo.52.1">, arrow functions, classes, imports and exports, the spread operator, promises and destructing, </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">and more</span></span></li>
<li><span class="koboSpan" id="kobo.54.1">A basic understanding of package managers such </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">as npm</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.56.1">By understanding these prerequisites, you will have a clear understanding of the core building blocks of web development and commonly used ECMAScript features in the </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">React ecosystem.</span></span></p>
<h1 id="_idParaDest-59"><a id="_idTextAnchor058"/><span class="koboSpan" id="kobo.58.1">Introduction to ReactJS</span></h1>
<p><span class="koboSpan" id="kobo.59.1">ReactJS’s popularity</span><a id="_idIndexMarker093"/><span class="koboSpan" id="kobo.60.1"> in the JavaScript community stems from its ability to build large-scale applications where the data changes repeatedly over time. </span><span class="koboSpan" id="kobo.60.2">At the beginning of the interview process, an interviewer expects you to discuss an introduction to ReactJS, its features, your reason for choosing it for programming, JSX and its purpose in React development, and more. </span><span class="koboSpan" id="kobo.60.3">So, let’s answer</span><a id="_idIndexMarker094"/><span class="koboSpan" id="kobo.61.1"> some </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">introductory questions.</span></span></p>
<h2 id="_idParaDest-60"><a id="_idTextAnchor059"/><span class="koboSpan" id="kobo.63.1">What is React?</span></h2>
<p><span class="koboSpan" id="kobo.64.1">React (also known as </span><strong class="bold"><span class="koboSpan" id="kobo.65.1">React.js</span></strong><span class="koboSpan" id="kobo.66.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.67.1">ReactJS</span></strong><span class="koboSpan" id="kobo.68.1">) is an open source frontend</span><a id="_idIndexMarker095"/><span class="koboSpan" id="kobo.69.1"> JavaScript library that</span><a id="_idIndexMarker096"/><span class="koboSpan" id="kobo.70.1"> is used for building</span><a id="_idIndexMarker097"/><span class="koboSpan" id="kobo.71.1"> UIs, especially for single-page and mobile apps. </span><span class="koboSpan" id="kobo.71.2">It is used for handling the view layer of web and </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">mobile apps.</span></span></p>
<p><span class="koboSpan" id="kobo.73.1">React was created by Jordan Walke, a software engineer working for Facebook, and later maintained by the Facebook team. </span><span class="koboSpan" id="kobo.73.2">React was first deployed on Facebook’s newsfeed in 2011 and on Instagram </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">in 2012.</span></span></p>
<h2 id="_idParaDest-61"><a id="_idTextAnchor060"/><span class="koboSpan" id="kobo.75.1">What are the reasons for choosing React for programming?</span></h2>
<p><span class="koboSpan" id="kobo.76.1">React is a popular choice among</span><a id="_idIndexMarker098"/><span class="koboSpan" id="kobo.77.1"> frontend libraries nowadays for web development and there are multiple reasons for that. </span><span class="koboSpan" id="kobo.77.2">Here are some of the most </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">notable reasons:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.79.1">Fast</span></strong><span class="koboSpan" id="kobo.80.1">: React can handle complex updates while maintaining a fast and </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">responsive UI.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.82.1">Declarative</span></strong><span class="koboSpan" id="kobo.83.1">: It follows a declarative approach in which you write all the code you need. </span><span class="koboSpan" id="kobo.83.2">Thereafter, React is going to be in charge of taking your declared code and performing all the JavaScript/DOM steps for the </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">desired output.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.85.1">High performance</span></strong><span class="koboSpan" id="kobo.86.1">: React has better performance compared to other JavaScript languages due to its less expensive DOM manipulation calls by using the virtual </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">DOM strategy.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.88.1">SEO-friendly</span></strong><span class="koboSpan" id="kobo.89.1">: React allows you to create web applications that are </span><strong class="bold"><span class="koboSpan" id="kobo.90.1">search engine optimization</span></strong><span class="koboSpan" id="kobo.91.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.92.1">SEO</span></strong><span class="koboSpan" id="kobo.93.1">)-friendly via SSR features. </span><span class="koboSpan" id="kobo.93.2">This feature makes</span><a id="_idIndexMarker099"/><span class="koboSpan" id="kobo.94.1"> apps faster with lower page load times and quicker rendering times, which, in turn, leads to better search engine ranking compared to </span><strong class="bold"><span class="koboSpan" id="kobo.95.1">client-side </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.96.1">rendering</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.97.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.98.1">CSR</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">).</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.100.1">Cross-platform</span></strong><span class="koboSpan" id="kobo.101.1">: The library supports building web applications, cross-platform desktop apps, and even mobile apps using </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">React Native.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.103.1">Easy to test</span></strong><span class="koboSpan" id="kobo.104.1">: The library provides a comprehensive set of testing utilities to test the components easily by simulating user behavior </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">in tests.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.106.1">Strong community support</span></strong><span class="koboSpan" id="kobo.107.1">: It has very strong community support with millions of developers across the globe who can access or share resources such as tutorials, articles, blogs, and YouTube videos and discuss them in various forums </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">and communities.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.109.1">The preceeding reasons justify</span><a id="_idIndexMarker100"/><span class="koboSpan" id="kobo.110.1"> why ReactJS is a popular library compared to other frameworks or libraries. </span><span class="koboSpan" id="kobo.110.2">ReactJS also has some notable features that bring several benefits </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">to businesses.</span></span></p>
<h2 id="_idParaDest-62"><a id="_idTextAnchor061"/><span class="koboSpan" id="kobo.112.1">What are the major features of React?</span></h2>
<p><span class="koboSpan" id="kobo.113.1">React has some outstanding features</span><a id="_idIndexMarker101"/><span class="koboSpan" id="kobo.114.1"> that make it a superior choice among modern frontend technologies. </span><span class="koboSpan" id="kobo.114.2">Some of its major features are </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.116.1">It uses the </span><strong class="bold"><span class="koboSpan" id="kobo.117.1">JavaScript XML</span></strong><span class="koboSpan" id="kobo.118.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.119.1">JSX</span></strong><span class="koboSpan" id="kobo.120.1">) syntax, a syntax extension of JavaScript that allows developers</span><a id="_idIndexMarker102"/><span class="koboSpan" id="kobo.121.1"> to write HTML in their JavaScript code, which makes the code easy </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">and understandable.</span></span></li>
<li><span class="koboSpan" id="kobo.123.1">It uses a virtual DOM instead of Real DOM since Real DOM manipulations are expensive. </span><span class="koboSpan" id="kobo.123.2">The legacy JavaScript frameworks update the whole DOM at once, which makes web applications </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">quite slow.</span></span></li>
<li><span class="koboSpan" id="kobo.125.1">It supports SSR, which offers quick initial page load times and SEO-friendly applications compared </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">to CSR.</span></span></li>
<li><span class="koboSpan" id="kobo.127.1">It follows a </span><strong class="bold"><span class="koboSpan" id="kobo.128.1">unidirectional data flow</span></strong><span class="koboSpan" id="kobo.129.1"> or one-way data binding in which the data flows from parent to child</span><a id="_idIndexMarker103"/><span class="koboSpan" id="kobo.130.1"> but not vice versa. </span><span class="koboSpan" id="kobo.130.2">This helps make the application less error-prone and easier to debug and provides more control over </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">the data.</span></span></li>
<li><span class="koboSpan" id="kobo.132.1">It uses reusable or composable UI components to develop the view at a fast pace and follows the </span><strong class="bold"><span class="koboSpan" id="kobo.133.1">Don’t Repeat Yourself</span></strong><span class="koboSpan" id="kobo.134.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.135.1">DRY</span></strong><span class="koboSpan" id="kobo.136.1">) principle, which states that duplication in logic</span><a id="_idIndexMarker104"/><span class="koboSpan" id="kobo.137.1"> should </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">be eliminated.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.139.1">React can be written either in </span><strong class="bold"><span class="koboSpan" id="kobo.140.1">JSX</span></strong><span class="koboSpan" id="kobo.141.1"> or JavaScript code, but most developers use JSX in their code</span><a id="_idIndexMarker105"/><span class="koboSpan" id="kobo.142.1"> since the benefits are worth the learning curve. </span><span class="koboSpan" id="kobo.142.2">The next section will provide answers to the most common questions you’ll be asked at the beginning of </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">the interview.</span></span></p>
<h1 id="_idParaDest-63"><a id="_idTextAnchor062"/><span class="koboSpan" id="kobo.144.1">Understanding JSX</span></h1>
<p><span class="koboSpan" id="kobo.145.1">It is recommended that you use JSX</span><a id="_idIndexMarker106"/><span class="koboSpan" id="kobo.146.1"> with React to describe what the UI should look like in a web application. </span><span class="koboSpan" id="kobo.146.2">Even though JSX is not mandatory to use in React, it comes with several advantages, all of which we’ll </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">cover here.</span></span></p>
<h2 id="_idParaDest-64"><a id="_idTextAnchor063"/><span class="koboSpan" id="kobo.148.1">What is JSX?</span></h2>
<p><span class="koboSpan" id="kobo.149.1">JSX is an XML-like syntax</span><a id="_idIndexMarker107"/><span class="koboSpan" id="kobo.150.1"> extension of the JavaScript language that’s based on ES6, which means you can structure component rendering using syntax such as HTML. </span><span class="koboSpan" id="kobo.150.2">This means it is just syntactic sugar that allows you to write HTML inside JavaScript and place it in the DOM without using any </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">createElement()</span></strong><span class="koboSpan" id="kobo.152.1"> or </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">appendChild()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.154.1"> methods.</span></span></p>
<p><span class="koboSpan" id="kobo.155.1">Let’s look at an example of a simple JSX code snippet to better understand how </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">it works:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.157.1">
const myElement = &lt;h1&gt;This is my first JSX code&lt;/h1&gt;
ReactDOM.render(myElement, document.getElementById
  ('root'));</span></pre> <p><span class="koboSpan" id="kobo.158.1">After rendering the code, React outputs the content inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">&lt;h1&gt;</span></strong><span class="koboSpan" id="kobo.160.1"> tag to </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">your DOM.</span></span></p>
<p><span class="koboSpan" id="kobo.162.1">The plain JavaScript code snippet</span><a id="_idIndexMarker108"/><span class="koboSpan" id="kobo.163.1"> without the preceding JSX code would look </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.165.1">
const myElement = React.createElement('h1', {},
  'This is my React element without JSX code!');
ReactDOM.render(myElement, document.getElementById
  ('root'));</span></pre> <p class="callout-heading"><span class="koboSpan" id="kobo.166.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.167.1">JSX is stricter than HTML, so all the elements should have a </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">closing tag.</span></span></p>
<h2 id="_idParaDest-65"><a id="_idTextAnchor064"/><span class="koboSpan" id="kobo.169.1">Why can’t browsers understand JSX?</span></h2>
<p><span class="koboSpan" id="kobo.170.1">Web browsers can only read JavaScript</span><a id="_idIndexMarker109"/><span class="koboSpan" id="kobo.171.1"> objects but not JSX because there is no inherent implementation for the browser engines to read and understand the syntax. </span><span class="koboSpan" id="kobo.171.2">To use JSX, you need to use transpilers or compilers such as Babel to convert JSX code into its respective plain JavaScript</span><a id="_idIndexMarker110"/><span class="koboSpan" id="kobo.172.1"> code </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">at runtime:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer015">
<span class="koboSpan" id="kobo.174.1"><img alt="Figure 2.1: JSX transpilation" src="image/Figure_02.01_B18603.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.175.1">Figure 2.1: JSX transpilation</span></p>
<p><span class="koboSpan" id="kobo.176.1">The preceding diagram explains how the transpilation works</span><a id="_idIndexMarker111"/><span class="koboSpan" id="kobo.177.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">JSX code.</span></span></p>
<h2 id="_idParaDest-66"><a id="_idTextAnchor065"/><span class="koboSpan" id="kobo.179.1">What are the advantages of JSX?</span></h2>
<p><span class="koboSpan" id="kobo.180.1">JSX is not mandatory</span><a id="_idIndexMarker112"/><span class="koboSpan" id="kobo.181.1"> for writing React applications, but it offers </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">many benefits:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.183.1">JSX makes it easier to read and understand the structure of a component just by seeing its layout </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">in code</span></span></li>
<li><span class="koboSpan" id="kobo.185.1">Most developers find it helpful as a visual aid while writing the template code for </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">the UI</span></span></li>
<li><span class="koboSpan" id="kobo.187.1">It allows you to create reusable components that can be reused throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">your application</span></span></li>
<li><span class="koboSpan" id="kobo.189.1">It can show useful errors and warning messages in </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">React applications</span></span></li>
<li><span class="koboSpan" id="kobo.191.1">JSX makes optimizations while translating the code into regular JavaScript, so it improves performance</span><a id="_idIndexMarker113"/><span class="koboSpan" id="kobo.192.1"> compared to writing </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">normal JavaScript</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.194.1">Once you are familiar with JSX code, it is easy to build views with elements </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">and components.</span></span></p>
<h1 id="_idParaDest-67"><a id="_idTextAnchor066"/><span class="koboSpan" id="kobo.196.1">Building views with elements and components</span></h1>
<p><span class="koboSpan" id="kobo.197.1">Both elements and components</span><a id="_idIndexMarker114"/><span class="koboSpan" id="kobo.198.1"> are basic building blocks for creating React views</span><a id="_idIndexMarker115"/><span class="koboSpan" id="kobo.199.1"> or apps. </span><span class="koboSpan" id="kobo.199.2">It is easy to build</span><a id="_idIndexMarker116"/><span class="koboSpan" id="kobo.200.1"> a UI with isolated, customizable, and reusable components. </span><span class="koboSpan" id="kobo.200.2">The following </span><a id="_idIndexMarker117"/><span class="koboSpan" id="kobo.201.1">questions and the content they cover will help you answer the basics of ReactJS and will act as a foundation for the next set of questions in </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">this book.</span></span></p>
<h2 id="_idParaDest-68"><a id="_idTextAnchor067"/><span class="koboSpan" id="kobo.203.1">What are components?</span></h2>
<p><span class="koboSpan" id="kobo.204.1">A component is an</span><a id="_idIndexMarker118"/><span class="koboSpan" id="kobo.205.1"> independent, reusable code block that divides the UI into smaller pieces. </span><span class="koboSpan" id="kobo.205.2">For example, while building the UI part of a web application using the React library, you can break its UI into small pieces for reusability purposes, highlighted with blue boxes in the </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">following figure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer016">
<span class="koboSpan" id="kobo.207.1"><img alt="Figure 2.2: React components" src="image/Figure_02.02_B18603.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.208.1">Figure 2.2: React components</span></p>
<p><span class="koboSpan" id="kobo.209.1">Each piece can be considered a component and is represented in a separate file instead of the UI being built in a single file. </span><span class="koboSpan" id="kobo.209.2">These components can be reused across the application wherever</span><a id="_idIndexMarker119"/><span class="koboSpan" id="kobo.210.1"> they </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">are applicable.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.212.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.213.1">Each component returns some HTML code, but you can only return a single HTML element. </span><span class="koboSpan" id="kobo.213.2">Otherwise, JSX will throw an error saying </span><em class="italic"><span class="koboSpan" id="kobo.214.1">JSX expressions must have one </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.215.1">parent element.</span></em></span></p>
<h2 id="_idParaDest-69"><a id="_idTextAnchor068"/><span class="koboSpan" id="kobo.216.1">What are the different ways to create components?</span></h2>
<p><span class="koboSpan" id="kobo.217.1">There are two possible ways to create a component in ReactJS. </span><span class="koboSpan" id="kobo.217.2">Let’s look </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">at them:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.219.1">Function components</span></strong><span class="koboSpan" id="kobo.220.1">: This is the simplest approach</span><a id="_idIndexMarker120"/><span class="koboSpan" id="kobo.221.1"> to creating components, and these are just JavaScript</span><a id="_idIndexMarker121"/><span class="koboSpan" id="kobo.222.1"> functions. </span><span class="koboSpan" id="kobo.222.2">In other words, these components are pure JavaScript functions that accept a </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">props</span></strong><span class="koboSpan" id="kobo.224.1"> object as the first parameter and return React elements to render </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">the output:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.226.1">
function User({ message }) {
    return &lt;h1&gt;{`Hello, ${message}`}&lt;/h1&gt;;
  }
  export default User;</span></pre></li> </ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.227.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.228.1">It is also possible to use local state in function components after the introduction of the React </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">Hooks feature.</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.230.1">Class components</span></strong><span class="koboSpan" id="kobo.231.1">: Class components</span><a id="_idIndexMarker122"/><span class="koboSpan" id="kobo.232.1"> can be created</span><a id="_idIndexMarker123"/><span class="koboSpan" id="kobo.233.1"> using ES6 classes, </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">extending </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">React.Component</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.237.1">The preceding function component can be written </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">as follows:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.239.1">
 class User extends React.Component {
  render() {
    return &lt;h1&gt;{`Hello, ${this.props.message}`} &lt;/h1&gt;;
  }
 }
 export default User;</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.240.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">render()</span></strong><span class="koboSpan" id="kobo.242.1"> method in the preceding code is the only mandatory method that needs to be implemented in every </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">class component.</span></span></p></li> </ul>
<h2 id="_idParaDest-70"><a id="_idTextAnchor069"/><span class="koboSpan" id="kobo.244.1">What is the difference between an element and a component?</span></h2>
<p><span class="koboSpan" id="kobo.245.1">An element is a plain object</span><a id="_idIndexMarker124"/><span class="koboSpan" id="kobo.246.1"> that describes a component instance or DOM node</span><a id="_idIndexMarker125"/><span class="koboSpan" id="kobo.247.1"> with its desired properties to represent the UI at a certain point in time. </span><span class="koboSpan" id="kobo.247.2">It contains information such as the component’s type, its properties, and any child elements under it. </span><span class="koboSpan" id="kobo.247.3">It is cheaper to create React elements compared to </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">DOM elements.</span></span></p>
<p><span class="koboSpan" id="kobo.249.1">The syntactical representation of any React element is </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.251.1">
React.createElement(type, {props}, children);</span></pre> <p><span class="koboSpan" id="kobo.252.1">Here is an example of creating a simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">SignOut</span></strong><span class="koboSpan" id="kobo.254.1"> React element where an element contains </span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">another element:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.256.1">
const element = React.createElement("div",
  { id: "signout-container" },
React.createElement("button", {id: "signout-btn"},
  "Sign Out")
);</span></pre> <p><span class="koboSpan" id="kobo.257.1">The preceding </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">React.createElement</span></strong><span class="koboSpan" id="kobo.259.1"> method</span><a id="_idIndexMarker126"/><span class="koboSpan" id="kobo.260.1"> returns an </span><a id="_idIndexMarker127"/><span class="koboSpan" id="kobo.261.1">object, as </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.263.1">
{
  type: 'div',
  props: {
  children: {
    type: 'button',
    props:  {
      children: 'SignOut'
      id: 'signout-btn'
    }
  },
    id: 'signout-container'
  }
}</span></pre> <p><span class="koboSpan" id="kobo.264.1">Finally, it is rendered to the DOM </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">ReactDOM.render()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.268.1">The same React element can be simplified and represented in JSX in a </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">short notation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.270.1">
const signoutElement = &lt;div id="signout-container"&gt;
  &lt;button id="signout-btn"&gt;SignOut&lt;/button&gt;
    &lt;div&gt;;</span></pre> <p class="callout-heading"><span class="koboSpan" id="kobo.271.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.272.1">React elements are immutable – that is, once you create an element, you can’t modify its children or </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">attributes further.</span></span></p>
<p><span class="koboSpan" id="kobo.274.1">A component, on the other hand, is composed of React elements. </span><span class="koboSpan" id="kobo.274.2">In other words, a component is a factory for creating elements. </span><span class="koboSpan" id="kobo.274.3">This component can be one of two types – a class or a function type that optionally takes input and returns an element tree </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">as output.</span></span></p>
<p><span class="koboSpan" id="kobo.276.1">Let’s understand this concept</span><a id="_idIndexMarker128"/><span class="koboSpan" id="kobo.277.1"> by looking at an example that uses</span><a id="_idIndexMarker129"/><span class="koboSpan" id="kobo.278.1"> the preceding </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">SignOut</span></strong><span class="koboSpan" id="kobo.280.1"> React element to create a </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">React component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.282.1">
const SignOut = ({handleSignOut}) =&gt; (
  &lt;div id="signout-container"&gt;
    &lt;button id="signout-btn" onClick={ handleSignOut}&gt;
      SignOut
    &lt;/button&gt;
  &lt;div&gt;
)</span></pre> <p><span class="koboSpan" id="kobo.283.1">The following figure represents how elements and components are structured inside the </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">React view:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer017">
<span class="koboSpan" id="kobo.285.1"><img alt="Figure 2.3: Components versus elements" src="image/Figure_02.03_B18603.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.286.1">Figure 2.3: Components versus elements</span></p>
<p><span class="koboSpan" id="kobo.287.1">These components can be further categorized</span><a id="_idIndexMarker130"/><span class="koboSpan" id="kobo.288.1"> into pure components, </span><strong class="bold"><span class="koboSpan" id="kobo.289.1">higher-order components </span></strong><span class="koboSpan" id="kobo.290.1">(</span><strong class="bold"><span class="koboSpan" id="kobo.291.1">HOCs</span></strong><span class="koboSpan" id="kobo.292.1">), and more, alongside</span><a id="_idIndexMarker131"/><span class="koboSpan" id="kobo.293.1"> their specific functionality. </span><span class="koboSpan" id="kobo.293.2">You will learn more about them in the </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">upcoming questions.</span></span></p>
<h2 id="_idParaDest-71"><a id="_idTextAnchor070"/><span class="koboSpan" id="kobo.295.1">What are pure components?</span></h2>
<p><span class="koboSpan" id="kobo.296.1">Pure components</span><a id="_idIndexMarker132"/><span class="koboSpan" id="kobo.297.1"> are components that render the same output for the same state and props. </span><span class="koboSpan" id="kobo.297.2">It is possible to achieve pure functionality within function components with the help of the Memoize API (that is, </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">React.memo()</span></strong><span class="koboSpan" id="kobo.299.1">), which you can wrap around the component. </span><span class="koboSpan" id="kobo.299.2">This API is mainly useful for </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">performance optimizations.</span></span></p>
<p><span class="koboSpan" id="kobo.301.1">The Memoize API prevents unnecessary updates from being rendered using shallow comparisons of props. </span><span class="koboSpan" id="kobo.301.2">This means it doesn’t compare the previous state with the new state. </span><span class="koboSpan" id="kobo.301.3">This is because the function component itself prevents re-rendering by default when you set (that is, using the setter function) the same </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">state again.</span></span></p>
<p><span class="koboSpan" id="kobo.303.1">Let’s understand this memoization concept using an example. </span><span class="koboSpan" id="kobo.303.2">First, create a parent </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">UserEnquiryForm</span></strong><span class="koboSpan" id="kobo.305.1"> component to enter the user input and then create another component to display the same information called </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">UserProfile</span></strong><span class="koboSpan" id="kobo.307.1">; this is the child component. </span><span class="koboSpan" id="kobo.307.2">The child component has been wrapped with the Memoize API to prevent the same prop details</span><a id="_idIndexMarker133"/><span class="koboSpan" id="kobo.308.1"> from being passed down from the </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">parent component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.310.1">
import { memo, useState } from 'react';
const UserProfile = memo(function UserProfile
  ({ name, age }) {
  return (&lt;&gt;
           &lt;p&gt;Name:{name}&lt;/p&gt;
           &lt;p&gt;Age: {age}&lt;/p&gt;
         &lt;/&gt;);
});
export default function UserEnquiryForm() {
  const [name, setName] = useState('');
  const [age, setAge] = useState(0);
  const [email, setEmail] = useState('');
  return (
    &lt;&gt;
      &lt;label&gt;
        Name: &lt;input value={name} onChange=
          {e =&gt; setName(e.target.value)} /&gt;
      &lt;/label&gt;
      &lt;label&gt;
        Age: &lt;input value={age} onChange=
          {e =&gt; setAge(e.target.value)} /&gt;
      &lt;/label&gt;
        &lt;label&gt;
        Email: &lt;input value={email} onChange=
          {e =&gt; setEmail(e.target.value)} /&gt;
      &lt;/label&gt;
      &lt;hr/&gt;
      &lt;UserProfile name={name} age={age}/&gt;
    &lt;/&gt;
  );
}</span></pre> <p><span class="koboSpan" id="kobo.311.1">In the preceding code, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">email</span></strong><span class="koboSpan" id="kobo.313.1"> property has not been passed down to the child component. </span><span class="koboSpan" id="kobo.313.2">So, there won’t be any re-rendering for the changes on </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">email input.</span></span></p>
<p><span class="koboSpan" id="kobo.315.1">However, in class components, the component will become a pure component since we extended it with </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">PureComponent</span></strong><span class="koboSpan" id="kobo.317.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">Component</span></strong><span class="koboSpan" id="kobo.319.1">. </span><span class="koboSpan" id="kobo.319.2">Internally, a pure component implements the </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">shouldComponentUpdate()</span></strong><span class="koboSpan" id="kobo.321.1"> life cycle method with </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">shallow comparison.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.323.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.324.1">It is recommended that all React components act like pure functions concerning their props. </span><span class="koboSpan" id="kobo.324.2">This guideline helps improve performance as it prevents unnecessary re-renders and avoids unexpected bugs in </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.326.1">Apart from pure components, another special type of component is also created as a</span><a id="_idIndexMarker134"/><span class="koboSpan" id="kobo.327.1"> pattern in the React ecosystem. </span><span class="koboSpan" id="kobo.327.2">It works as a pure function with zero side effects, similar to a pure </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">component’s behavior.</span></span></p>
<h2 id="_idParaDest-72"><a id="_idTextAnchor071"/><span class="koboSpan" id="kobo.329.1">What is a higher-order component?</span></h2>
<p><span class="koboSpan" id="kobo.330.1">An HOC is a function that takes a component</span><a id="_idIndexMarker135"/><span class="koboSpan" id="kobo.331.1"> and returns a new component. </span><span class="koboSpan" id="kobo.331.2">HOCs are not part of the React API but they are an advanced technique for reusing component logic. </span><span class="koboSpan" id="kobo.331.3">You can share props and states between components </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">using HOCs.</span></span></p>
<p><span class="koboSpan" id="kobo.333.1">An HOC can be represented with the </span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">following syntax:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.335.1">
const withHigherOrderComponent = (OriginalComponent) =&gt; (props) =&gt; &lt;OriginalComponent {...props} /&gt;;</span></pre> <p><span class="koboSpan" id="kobo.336.1">Third-party libraries such as Redux’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">connect</span></strong><span class="koboSpan" id="kobo.338.1"> and Relay’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">createFragmentContainer</span></strong><span class="koboSpan" id="kobo.340.1"> have been created</span><a id="_idIndexMarker136"/><span class="koboSpan" id="kobo.341.1"> based on the </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">HOC concept.</span></span></p>
<h2 id="_idParaDest-73"><a id="_idTextAnchor072"/><span class="koboSpan" id="kobo.343.1">What are fragments and where do you use them?</span></h2>
<p><span class="koboSpan" id="kobo.344.1">A React fragment</span><a id="_idIndexMarker137"/><span class="koboSpan" id="kobo.345.1"> is a syntax that allows you to wrap or group a list of child elements to a React component without the need to add an extra node to the DOM. </span><span class="koboSpan" id="kobo.345.2">You can use either </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">&lt;Fragment&gt;</span></strong><span class="koboSpan" id="kobo.347.1"> or a shorter syntax with an empty </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">tag (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">&lt;&gt;&lt;/&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.351.1">For example, let’s take an </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">Author</span></strong><span class="koboSpan" id="kobo.353.1"> component</span><a id="_idIndexMarker138"/><span class="koboSpan" id="kobo.354.1"> to represent an author who has posted several blog posts. </span><span class="koboSpan" id="kobo.354.2">This component loops through the author’s blog posts and displays them without adding an extra DOM node such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">&lt;div&gt;</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.356.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">&lt;span&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.359.1">
function Author() {
         return posts.map(post =&gt;
                 &lt;Fragment key={ post.id}&gt;
                       &lt;Post title={post.text} body={post.body} /&gt;
                       &lt;Date date= {post.date} /&gt;
                 &lt;/Fragment&gt;
    );
}</span></pre> <p><span class="koboSpan" id="kobo.360.1">In the preceding code snippet, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">&lt;Fragment&gt;</span></strong><span class="koboSpan" id="kobo.362.1"> tag is used to support the </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">key</span></strong><span class="koboSpan" id="kobo.364.1"> prop while iterating the list items. </span><span class="koboSpan" id="kobo.364.2">The alternative </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">&lt;&gt;&lt;/&gt;</span></strong><span class="koboSpan" id="kobo.366.1"> syntax doesn’t support key attributes. </span><span class="koboSpan" id="kobo.366.2">Hence, it is preferred to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">&lt;Fragment&gt;</span></strong><span class="koboSpan" id="kobo.368.1"> over </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">&lt;&gt;&lt;/&gt;</span></strong><span class="koboSpan" id="kobo.370.1"> if you’re iterating the </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">list items.</span></span></p>
<p><span class="koboSpan" id="kobo.372.1"> There are a few more benefits</span><a id="_idIndexMarker139"/><span class="koboSpan" id="kobo.373.1"> of </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">using fragments:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.375.1">Fragments are faster and use less memory on very large or deep </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">DOM trees</span></span></li>
<li><span class="koboSpan" id="kobo.377.1">CSS frameworks or libraries such as </span><strong class="bold"><span class="koboSpan" id="kobo.378.1">Flexbox</span></strong><span class="koboSpan" id="kobo.379.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.380.1">CSS Grid</span></strong><span class="koboSpan" id="kobo.381.1"> require a direct parent-child relationship</span><a id="_idIndexMarker140"/><span class="koboSpan" id="kobo.382.1"> and adding</span><a id="_idIndexMarker141"/><span class="koboSpan" id="kobo.383.1"> an extra </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">&lt;div&gt;</span></strong><span class="koboSpan" id="kobo.385.1"> element will disturb the </span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">desired layout</span></span></li>
<li><span class="koboSpan" id="kobo.387.1">The DOM inspector</span><a id="_idIndexMarker142"/><span class="koboSpan" id="kobo.388.1"> is less clustered since it doesn’t contain any additional </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">DOM nodes</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.390.1">Now that you understand the various building blocks of a component, you can easily learn how to control the data in a component or between components. </span><span class="koboSpan" id="kobo.390.2">Data management is crucial for any </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">web application.</span></span></p>
<h1 id="_idParaDest-74"><a id="_idTextAnchor073"/><span class="koboSpan" id="kobo.392.1">Controlling component data using props and state</span></h1>
<p><span class="koboSpan" id="kobo.393.1">The data inside a component</span><a id="_idIndexMarker143"/><span class="koboSpan" id="kobo.394.1"> is controlled by props</span><a id="_idIndexMarker144"/><span class="koboSpan" id="kobo.395.1"> and state. </span><span class="koboSpan" id="kobo.395.2">All kinds of React applications are based</span><a id="_idIndexMarker145"/><span class="koboSpan" id="kobo.396.1"> on these two concepts, and they are important core topics</span><a id="_idIndexMarker146"/><span class="koboSpan" id="kobo.397.1"> that help with creating efficient and robust applications. </span><span class="koboSpan" id="kobo.397.2">These topics are not only useful in interviews, as you will also encounter their usage in </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">everyday jobs.</span></span></p>
<h2 id="_idParaDest-75"><a id="_idTextAnchor074"/><span class="koboSpan" id="kobo.399.1">What are props in React?</span></h2>
<p><span class="koboSpan" id="kobo.400.1">Props, which stands</span><a id="_idIndexMarker147"/><span class="koboSpan" id="kobo.401.1"> for properties, are arguments that appear in the form of either individual values or an object holding a set of values that are passed into components. </span><span class="koboSpan" id="kobo.401.2">Their naming convention is similar to that of HTML attributes. </span><span class="koboSpan" id="kobo.401.3">They help pass data from the parent component to the child component and are used to render the child component dynamically on the screen. </span><span class="koboSpan" id="kobo.401.4">This means that props act as a channel for components to communicate inside the </span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">component tree.</span></span></p>
<p><span class="koboSpan" id="kobo.403.1">The main purpose</span><a id="_idIndexMarker148"/><span class="koboSpan" id="kobo.404.1"> of props in React is to achieve the following </span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">component functionality:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.406.1">Pass the custom data to your component based on </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">business needs.</span></span></li>
<li><span class="koboSpan" id="kobo.408.1">Trigger state changes in a component based on the </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">prop’s value.</span></span></li>
<li><span class="koboSpan" id="kobo.410.1">Access props via </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">props.propName</span></strong><span class="koboSpan" id="kobo.412.1"> for a function component or </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">this.props.reactProp</span></strong><span class="koboSpan" id="kobo.414.1"> for a class component inside the component’s rendering code. </span><span class="koboSpan" id="kobo.414.2">This data is helpful</span><a id="_idIndexMarker149"/><span class="koboSpan" id="kobo.415.1"> for conditionally rendering </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">the UI.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.417.1">The following is an example of how props</span><a id="_idIndexMarker150"/><span class="koboSpan" id="kobo.418.1"> are passed from a parent component to a child component (in this </span><span class="No-Break"><span class="koboSpan" id="kobo.419.1">case, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">Employee</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.422.1">
import React from 'react';
function App() {
return (
    &lt; &gt;
        &lt;Employee name="John" age="30" department="Manufacturing"&gt;&lt;/
          Employee&gt;
        &lt;Employee name="Malcolm" age="35" department="Engineering" &gt;&lt;/
          Employee&gt;
        &lt;Employee name="Luther" department="Finance"&gt;&lt;/Employee&gt;
    &lt;/ &gt;
);
}
function Employee(props) {
return (
    &lt; &gt;
        &lt;span&gt;Name: {props.name} &lt;/span&gt;
        &lt;span&gt;Age: {props.age} &lt;/span&gt;
        &lt;span&gt;Department: {props.department} &lt;/span&gt;
    &lt;/ &gt;
)
}
Employee.defaultProps = {
    name: "Jack",
    age: "45",
    department: "HR"
}
export default App; </span></pre> <p><span class="koboSpan" id="kobo.423.1">In the preceding code, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">defaultProps</span></strong><span class="koboSpan" id="kobo.425.1"> property</span><a id="_idIndexMarker151"/><span class="koboSpan" id="kobo.426.1"> has been used to assign the default values of props. </span><span class="koboSpan" id="kobo.426.2">These will be used if no explicit props </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">are passed.</span></span></p>
<p><span class="koboSpan" id="kobo.428.1">The better alternative to access the properties of a props object is by using destructuring from ES6 (</span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">ECMAScript 2015).</span></span></p>
<p><span class="koboSpan" id="kobo.430.1">With the help of destructuring, the preceding child component can be rewritten </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.432.1">
function Employee({name, age, department}) {
return (
    &lt;&gt;
        &lt;span&gt;Name: {name} &lt;/span&gt;
        &lt;span&gt;Age: {age} &lt;/span&gt;
        &lt;span&gt;Department: {department} &lt;/span&gt;
    &lt;/&gt;
)
}</span></pre> <p class="callout-heading"><span class="koboSpan" id="kobo.433.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.434.1">Props</span><a id="_idIndexMarker152"/><span class="koboSpan" id="kobo.435.1"> are immutable (read-only) in nature and trying to modify these values will throw an error. </span><span class="koboSpan" id="kobo.435.2">If you still need to modify the data in a component, then state is the right choice for managing </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">your data.</span></span></p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor075"/><span class="koboSpan" id="kobo.437.1">Can you describe state in React?</span></h2>
<p><span class="koboSpan" id="kobo.438.1">State is an in-built JavaScript object</span><a id="_idIndexMarker153"/><span class="koboSpan" id="kobo.439.1"> where you store property values that belong to the component. </span><span class="koboSpan" id="kobo.439.2">In other words, state is private and fully controlled by the component. </span><span class="koboSpan" id="kobo.439.3">The crucial part of state is that whenever the state object changes, the </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">component re-renders.</span></span></p>
<p><span class="koboSpan" id="kobo.441.1">The scope of state is always inside the component, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer018">
<span class="koboSpan" id="kobo.443.1"><img alt="Figure 2.4: Scope of state inside a component" src="image/Figure_02.04_B18603.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.444.1">Figure 2.4: Scope of state inside a component</span></p>
<p><span class="koboSpan" id="kobo.445.1">Here is an example of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">User</span></strong><span class="koboSpan" id="kobo.447.1"> functional component with a welcome message as the state to explain more about </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">its usage:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.449.1">
import React, { useState } from "react";
function User() {
  const [message, setMessage] = useState
    ("Welcome to React world");
  return (
    &lt;&gt;
      &lt;h1&gt;{message}&lt;/h1&gt;
    &lt;/&gt;
  );
}</span></pre> <p><span class="koboSpan" id="kobo.450.1">In the preceding code, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">useState</span></strong><span class="koboSpan" id="kobo.452.1"> Hook was used to add state to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">User</span></strong><span class="koboSpan" id="kobo.454.1"> component. </span><span class="koboSpan" id="kobo.454.2">It returns an array which contains the current state and the setter function to update </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">the state.</span></span></p>
<p><span class="koboSpan" id="kobo.456.1">Compared to the functional</span><a id="_idIndexMarker154"/><span class="koboSpan" id="kobo.457.1"> component, the class component holds the state properties inside a built-in state object and accesses it through </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">this.state.message</span></strong><span class="koboSpan" id="kobo.459.1"> inside the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">User</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.461.1"> component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.462.1">
class User extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      message: "Welcome to React world",
    };
  }
  render() {
    return (
      &lt;&gt;
        &lt;h1&gt;{this.state.message}&lt;/h1&gt;
      &lt;/&gt;
    );
  }
}</span></pre> <p><span class="koboSpan" id="kobo.463.1">The built-in </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">setState</span></strong><span class="koboSpan" id="kobo.465.1"> function is used to update the state of the preceding </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">class component.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.467.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.468.1">It is recommended to make the state</span><a id="_idIndexMarker155"/><span class="koboSpan" id="kobo.469.1"> variable as simple as possible for readability purposes and minimize the stateful components to achieve a single source </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">of truth.</span></span></p>
<h2 id="_idParaDest-77"><a id="_idTextAnchor076"/><span class="koboSpan" id="kobo.471.1">What are the main differences between props and state?</span></h2>
<p><span class="koboSpan" id="kobo.472.1">Both props and state are plain</span><a id="_idIndexMarker156"/><span class="koboSpan" id="kobo.473.1"> JavaScript objects that are used to manage the data</span><a id="_idIndexMarker157"/><span class="koboSpan" id="kobo.474.1"> of a component, but they are used in different ways and have </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">different characteristics:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-1">
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style T---Body">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.476.1">Props</span></strong></span></p>
</td>
<td class="No-Table-Style T---Body">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.477.1">State</span></strong></span></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style T---Body">
<p><span class="koboSpan" id="kobo.478.1">Read-only </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">and immutable</span></span></p>
</td>
<td class="No-Table-Style T---Body">
<p><span class="koboSpan" id="kobo.480.1">Mutable and </span><span class="No-Break"><span class="koboSpan" id="kobo.481.1">changes asynchronously</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style T---Body">
<p><span class="koboSpan" id="kobo.482.1">Props are passed from the parent component to the </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">child component</span></span></p>
</td>
<td class="No-Table-Style T---Body">
<p><span class="koboSpan" id="kobo.484.1">Managed by the </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">component itself</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style T---Body">
<p><span class="koboSpan" id="kobo.486.1">Accessed by </span><span class="No-Break"><span class="koboSpan" id="kobo.487.1">child components</span></span></p>
</td>
<td class="No-Table-Style T---Body">
<p><span class="koboSpan" id="kobo.488.1">Cannot be accessed by </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">child components</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style T---Body">
<p><span class="koboSpan" id="kobo.490.1">Props make </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">components reusable</span></span></p>
</td>
<td class="No-Table-Style T---Body">
<p><span class="koboSpan" id="kobo.492.1">State cannot make </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">components reusable</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style T---Body">
<p><span class="koboSpan" id="kobo.494.1">Used for communication </span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">between components</span></span></p>
</td>
<td class="No-Table-Style T---Body">
<p><span class="koboSpan" id="kobo.496.1">Used for rendering </span><span class="No-Break"><span class="koboSpan" id="kobo.497.1">dynamic changes</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.498.1">Table 2.1: Props versus state</span></p>
<p><span class="koboSpan" id="kobo.499.1">Unlike props, state can be updated in different ways. </span><span class="koboSpan" id="kobo.499.2">Let’s learn more about batching multiple </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">state updates.</span></span></p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor077"/><span class="koboSpan" id="kobo.501.1">How does React batch multiple state updates?</span></h2>
<p><span class="koboSpan" id="kobo.502.1">React prevents components from re-rendering for each state update. </span><span class="koboSpan" id="kobo.502.2">React makes this possible by optimizing application performance using group updates within event handlers with the help</span><a id="_idIndexMarker158"/><span class="koboSpan" id="kobo.503.1"> of built-in Hooks. </span><span class="koboSpan" id="kobo.503.2">This entire process is known as </span><strong class="bold"><span class="koboSpan" id="kobo.504.1">batching</span></strong><span class="koboSpan" id="kobo.505.1">. </span><span class="koboSpan" id="kobo.505.2">React version 17 only supports batching for browser events, whereas React version 18 supports an improved</span><a id="_idIndexMarker159"/><span class="koboSpan" id="kobo.506.1"> version of batching known as </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.507.1">automatic batching</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.508.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.509.1">Automatic batching supports state updates that are invoked from any location instead of just browser events. </span><span class="koboSpan" id="kobo.509.2">In other words, it supports native event handlers, asynchronous operations, timeouts, </span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">and intervals.</span></span></p>
<p><span class="koboSpan" id="kobo.511.1">Let’s look at an example demonstrating </span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">automatic batching:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.513.1">
import { useState } from 'react';
export default function MultiState() {
  const [count, setCount] = useState(0);
  const [message, setMessage] = useState('Batching');
  console.log('Application re-rendered');
  const handleAsyncFetch = () =&gt; {
    fetch(https://jsonplaceholder.typicode.com/todos/1
      ).then(() =&gt; {
        // trigger only one(1) re-render due to
           Automatic Batching
        setCount(count +1);
        setMessage('Automatic batching');
      });
  }
  return (
    &lt;&gt;
      &lt;h1&gt;{count}&lt;/h1&gt;
      &lt;button onClick={handleAsyncFetch}&gt;
        Click Me!&lt;/button&gt;
    &lt;/&gt;
  )
}</span></pre> <p><span class="koboSpan" id="kobo.514.1">Even though the preceding code updates two state variables using an event handler, React will batch them automatically</span><a id="_idIndexMarker160"/><span class="koboSpan" id="kobo.515.1"> by default and the component will only </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">re-render once.</span></span></p>
<h2 id="_idParaDest-79"><a id="_idTextAnchor078"/><span class="koboSpan" id="kobo.517.1">Can you prevent automatic batching?</span></h2>
<p><span class="koboSpan" id="kobo.518.1">Automatic batching</span><a id="_idIndexMarker161"/><span class="koboSpan" id="kobo.519.1"> is a great feature of the React library that optimizes rendering performance. </span><span class="koboSpan" id="kobo.519.2">However, there are situations where you need to re-render your component for each state update or update one state depending on another updated state value. </span><span class="koboSpan" id="kobo.519.3">React introduced the </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">flushSync</span></strong><span class="koboSpan" id="kobo.521.1"> API function from ReactDOM to stop automatic batching whenever necessary. </span><span class="koboSpan" id="kobo.521.2">This function is also useful for use cases where you need to flush updates immediately to the DOM in case you’re integrating with third-party code such as browser APIs and </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">UI libraries.</span></span></p>
<p><span class="koboSpan" id="kobo.523.1">For example, let’s say you want to update the scroll position on a web page after adding a new to do or task to a simple to do list app. </span><span class="koboSpan" id="kobo.523.2">This behavior is helpful if you wish to have a direct focus on the new to do content. </span><span class="koboSpan" id="kobo.523.3">In this scenario, the latest to do state needs to be updated immediately for you to get the correct </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">scroll position:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.525.1">
  const handleAddTodo = (todoName) =&gt; {
    flushSync(() =&gt; {
      setTodos([...todos, { id: uuid(), task: todoName }]);
    });
    todoListRef.current.scrollTop = todoListRef.
</span><span class="koboSpan" id="kobo.525.2">      current.scrollHeight;
  };</span></pre> <p><span class="koboSpan" id="kobo.526.1">The usage of this function</span><a id="_idIndexMarker162"/><span class="koboSpan" id="kobo.527.1"> is not common and using it can often impact application </span><span class="No-Break"><span class="koboSpan" id="kobo.528.1">performance badly.</span></span></p>
<h2 id="_idParaDest-80"><a id="_idTextAnchor079"/><span class="koboSpan" id="kobo.529.1">How do you update objects inside the state?</span></h2>
<p><span class="koboSpan" id="kobo.530.1">You shouldn’t update</span><a id="_idIndexMarker163"/><span class="koboSpan" id="kobo.531.1"> React’s state object directly. </span><span class="koboSpan" id="kobo.531.2">Instead, you need to create</span><a id="_idIndexMarker164"/><span class="koboSpan" id="kobo.532.1"> a new object or make a copy of the existing object and then set the state with the newly created object. </span><span class="koboSpan" id="kobo.532.2">So, while updating the state object, you always need to treat objects inside the state as read-only, even though JavaScript objects </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">are mutable.</span></span></p>
<p><span class="koboSpan" id="kobo.534.1">Let’s see this comparison in action and show the results of these two updating processes. </span><span class="koboSpan" id="kobo.534.2">As an example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">WeatherReport</span></strong><span class="koboSpan" id="kobo.536.1"> component has been created, along with its properties, including </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">temperature</span></strong><span class="koboSpan" id="kobo.538.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">city</span></strong><span class="koboSpan" id="kobo.540.1">. </span><span class="koboSpan" id="kobo.540.2">After that, component properties are mutated directly inside the </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">event handler:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.542.1">
function WeatherReport() {
  const [weather, setWeather] = useState({
    temperature: 26,
    city: "Singapore",
  });
  const handleWeatherChange = (e) =&gt; {
    if (e.target.name === "temperature") {
      weather.temperature = e.target.value;
    }
    if (e.target.name === "city") {
      weather.city = e.target.value;
    }
  };
  return (
    &lt;&gt;
      &lt;label&gt;
        Temparature:
        &lt;input value={weather.temperature} onChange=
          {handleWeatherChange} /&gt;
      &lt;/label&gt;
      &lt;label&gt;
        City:
        &lt;input value={weather.city} onChange={handleWeatherChange} /&gt;
      &lt;/label&gt;
      &lt;div&gt;
        Report:
        &lt;span&gt;{weather.temperature}&lt;/span&gt;
        &lt;span&gt;{weather.city}&lt;/span&gt;
      &lt;/div&gt;
    &lt;/&gt;
  );
}</span></pre> <p><span class="koboSpan" id="kobo.543.1">Once the preceding code has been deployed, try to enter the new weather details in the UI. </span><span class="koboSpan" id="kobo.543.2">You will see that the input fields won’t </span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">get updated.</span></span></p>
<p><span class="koboSpan" id="kobo.545.1">You can fix this by creating a new copy of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">weather</span></strong><span class="koboSpan" id="kobo.547.1"> object and then setting the state. </span><span class="koboSpan" id="kobo.547.2">To do that, let’s update the preceding </span><span class="No-Break"><span class="koboSpan" id="kobo.548.1">event handler:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.549.1">
handleWeatherChange(e) {
    setWeather({
        ...weather,
        [e.target.name]: e.target.value
    })
}</span></pre> <p><span class="koboSpan" id="kobo.550.1">The preceding code updates the weather details in the UI </span><span class="No-Break"><span class="koboSpan" id="kobo.551.1">as intended.</span></span></p>
<p><span class="koboSpan" id="kobo.552.1">Sometimes, only one field</span><a id="_idIndexMarker165"/><span class="koboSpan" id="kobo.553.1"> needs to be modified in the state object. </span><span class="koboSpan" id="kobo.553.2">In this case, it is recommended</span><a id="_idIndexMarker166"/><span class="koboSpan" id="kobo.554.1"> to use object spread syntax to get the benefit of reusing the previous state object property values instead of setting each field in </span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">the state.</span></span></p>
<h2 id="_idParaDest-81"><a id="_idTextAnchor080"/><span class="koboSpan" id="kobo.556.1">How do you update nested state objects?</span></h2>
<p><span class="koboSpan" id="kobo.557.1">It is quite easy to update</span><a id="_idIndexMarker167"/><span class="koboSpan" id="kobo.558.1"> top-level state objects with the spread syntax. </span><span class="koboSpan" id="kobo.558.2">But when it comes to nested state objects, you cannot update the required nested property directly like you can in regular </span><span class="No-Break"><span class="koboSpan" id="kobo.559.1">JavaScript objects.</span></span></p>
<p><span class="koboSpan" id="kobo.560.1">This can be explained further with an example: we’ll take a nested state object and modify the nested property inside it. </span><span class="koboSpan" id="kobo.560.2">To demonstrate this behavior, let’s consider the </span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">User</span></strong><span class="koboSpan" id="kobo.562.1"> state object with nested address details as </span><span class="No-Break"><span class="koboSpan" id="kobo.563.1">a property:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.564.1">
{
    name: 'Tom',
    age: 35,
    address: {
        country: 'United States',
        state: 'Texas',
        postalCode: 73301
    }
}</span></pre> <p><span class="koboSpan" id="kobo.565.1">Now, you can try to update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">postalCodeproperty</span></strong><span class="koboSpan" id="kobo.567.1"> using an expression like </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">user.address.postalCode = 75015</span></strong><span class="koboSpan" id="kobo.569.1"> in your React components, similar to how you do in plain JavaScript. </span><span class="koboSpan" id="kobo.569.2">The screen won’t be updated with the </span><span class="No-Break"><span class="koboSpan" id="kobo.570.1">latest value.</span></span></p>
<p><span class="koboSpan" id="kobo.571.1">If it is not possible to flatten</span><a id="_idIndexMarker168"/><span class="koboSpan" id="kobo.572.1"> the nested </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">User</span></strong><span class="koboSpan" id="kobo.574.1"> object as a workaround, then there are two possible approaches to update the </span><span class="No-Break"><span class="koboSpan" id="kobo.575.1">state properly:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.576.1">Create separate </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.577.1">nested objects</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.578.1">:</span></span><p class="list-inset"><span class="koboSpan" id="kobo.579.1">In this approach, first, create</span><a id="_idIndexMarker169"/><span class="koboSpan" id="kobo.580.1"> a separate new copy of the nested object (</span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">updatedAddress</span></strong><span class="koboSpan" id="kobo.582.1">) using the spread syntax. </span><span class="koboSpan" id="kobo.582.2">After that, create a new top-level object (</span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">updatedUser</span></strong><span class="koboSpan" id="kobo.584.1">) that points to the newly created </span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">nested object:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.586.1">
const updatedAddress = { ...user.address,
  postalCode: 75015 };
const updatedUser = { ...user, address:
  updatedAddress };
setUser(updatedUser);</span></pre></li> <li><strong class="bold"><span class="koboSpan" id="kobo.587.1">Update nested object with a single </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.588.1">function call</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.589.1">:</span></span><p class="list-inset"><span class="koboSpan" id="kobo.590.1">It is also possible to update</span><a id="_idIndexMarker170"/><span class="koboSpan" id="kobo.591.1"> the nested object together with a top-level object by using the spread syntax within a single state </span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">setter function:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.593.1">
setUser({
  ...user,
  address: {
    ...user.address,
    postalCode: 75015
  }
});</span></pre></li> </ul>
<p><span class="koboSpan" id="kobo.594.1">If you would like to go beyond the traditional</span><a id="_idIndexMarker171"/><span class="koboSpan" id="kobo.595.1"> approach, third-party libraries such as </span><strong class="bold"><span class="koboSpan" id="kobo.596.1">Immer</span></strong><span class="koboSpan" id="kobo.597.1"> provide a convenient way to update the deeply nested state objects. </span><span class="koboSpan" id="kobo.597.2">This library enables direct nested object updates just like regular JavaScript updates </span><span class="No-Break"><span class="koboSpan" id="kobo.598.1">the properties.</span></span></p>
<p><span class="koboSpan" id="kobo.599.1">Mutating nested objects using Immer looks </span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.601.1">
setUser(user =&gt; {
  user.address.postalCode = 75015;
});</span></pre> <p><span class="koboSpan" id="kobo.602.1">The component’s state can be an array</span><a id="_idIndexMarker172"/><span class="koboSpan" id="kobo.603.1"> of items as well, not just a primitive value or an object type. </span><span class="koboSpan" id="kobo.603.2">However, you need to supply the additional key prop, as detailed in the </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">upcoming questions.</span></span></p>
<h1 id="_idParaDest-82"><a id="_idTextAnchor081"/><span class="koboSpan" id="kobo.605.1">Understanding the importance of key props</span></h1>
<p><span class="koboSpan" id="kobo.606.1">Keys help you control component</span><a id="_idIndexMarker173"/><span class="koboSpan" id="kobo.607.1"> or element instances. </span><span class="koboSpan" id="kobo.607.2">They play a major role in deciding whether the element needs to be re-rendered or not in a list of elements. </span><span class="koboSpan" id="kobo.607.3">Hence, every developer should have an idea about the importance of a </span><span class="No-Break"><span class="koboSpan" id="kobo.608.1">key prop.</span></span></p>
<h2 id="_idParaDest-83"><a id="_idTextAnchor082"/><span class="koboSpan" id="kobo.609.1">What is a key prop and what is the purpose of it?</span></h2>
<p><span class="koboSpan" id="kobo.610.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.611.1">key</span></strong><span class="koboSpan" id="kobo.612.1"> is a special attribute that you need to include</span><a id="_idIndexMarker174"/><span class="koboSpan" id="kobo.613.1"> when creating a list of elements in a component. </span><span class="koboSpan" id="kobo.613.2">This key prop helps React identify</span><a id="_idIndexMarker175"/><span class="koboSpan" id="kobo.614.1"> which elements have changed and been added or removed. </span><span class="koboSpan" id="kobo.614.2">In other words, it helps you retain a unique identity of the elements or among the siblings in the list even after the elements have </span><span class="No-Break"><span class="koboSpan" id="kobo.615.1">been modified.</span></span></p>
<p><span class="koboSpan" id="kobo.616.1">Even if you don’t supply</span><a id="_idIndexMarker176"/><span class="koboSpan" id="kobo.617.1"> a key prop, the list can render the content to the browser successfully, but with a warning message logged in the console, as </span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">shown here:</span></span></p>
<pre class="console">
<strong class="bold"><span class="koboSpan" id="kobo.619.1">Warning: Each child in an array or iterator</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.620.1">         should have a unique "key" prop</span></strong></pre> <p><span class="koboSpan" id="kobo.621.1">It is recommended to use a unique ID value from the data as a key prop. </span><span class="koboSpan" id="kobo.621.2">This value can be a string </span><span class="No-Break"><span class="koboSpan" id="kobo.622.1">or number.</span></span></p>
<p><span class="koboSpan" id="kobo.623.1">Let’s understand this key prop concept</span><a id="_idIndexMarker177"/><span class="koboSpan" id="kobo.624.1"> in a better way by implementing the to do list of a programmer. </span><span class="koboSpan" id="kobo.624.2">Here, you are assigning a key to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">TodoItem</span></strong><span class="koboSpan" id="kobo.626.1"> component while iterating from the list and not to the extracted </span><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">&lt;</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">li&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.629.1"> tag:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.630.1">
import React from "react";
import ReactDOM from "react-dom";
function TodoItem(props) {
    const { item: todo } = props;
    return &lt;li&gt;{todo.id}: {todo.message}&lt;/li&gt;;
}
function TodoList(props) {
    const { todos: list } = props;
    const updatedTodos = list.map((todo) =&gt; {
        return &lt;TodoItem key={todo.id} item={todo} /&gt;;
    });
    return &lt;ul&gt;{updatedTodos}&lt;/ul&gt;;
}
const devTodoItems = [{id: 1, message:"Write a component"}, {id:2, message:"Test it"}, {id:3, message:"Publish the component"}]; 
ReactDOM.render( 
    &lt;TodoList todos={ devTodoItems } /&gt;, 
    document.getElementById("root") 
);  </span></pre> <p><span class="koboSpan" id="kobo.631.1">It is discouraged to assign</span><a id="_idIndexMarker178"/><span class="koboSpan" id="kobo.632.1"> indexes (received from iterating the list of elements) as keys because if the elements of the list get reordered in the future, then the keys of the elements will </span><span class="No-Break"><span class="koboSpan" id="kobo.633.1">also change.</span></span></p>
<h1 id="_idParaDest-84"><a id="_idTextAnchor083"/><span class="koboSpan" id="kobo.634.1">Learning about event handling</span></h1>
<p><span class="koboSpan" id="kobo.635.1">Event handling is essential for interacting</span><a id="_idIndexMarker179"/><span class="koboSpan" id="kobo.636.1"> with a web page in an application. </span><span class="koboSpan" id="kobo.636.2">React has its own event handling ecosystem. </span><span class="koboSpan" id="kobo.636.3">The event handler determines what action has to be taken whenever a particular event is fired. </span><span class="koboSpan" id="kobo.636.4">This section will give you a good understanding of event handling in the </span><span class="No-Break"><span class="koboSpan" id="kobo.637.1">React library.</span></span></p>
<h2 id="_idParaDest-85"><a id="_idTextAnchor084"/><span class="koboSpan" id="kobo.638.1">What are synthetic events?</span></h2>
<p><span class="koboSpan" id="kobo.639.1">A synthetic event is a cross-browser wrapper</span><a id="_idIndexMarker180"/><span class="koboSpan" id="kobo.640.1"> around a browser’s actual native event object. </span><span class="koboSpan" id="kobo.640.2">It provides a unified API that prevents browser inconsistencies and ensures that the event works across </span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">multiple platforms.</span></span></p>
<p><span class="koboSpan" id="kobo.642.1">There are some similarities between synthetic events and native events if you use the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">preventDefault</span></strong><span class="koboSpan" id="kobo.644.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">stopPropogation</span></strong><span class="koboSpan" id="kobo.646.1"> methods in those two events. </span><span class="koboSpan" id="kobo.646.2">It is also possible to access native events directly by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.647.1">nativeEvent</span></strong><span class="koboSpan" id="kobo.648.1"> attribute on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">syntheticEvent</span></strong><span class="koboSpan" id="kobo.650.1"> instance. </span><span class="koboSpan" id="kobo.650.2">As an example, the following search component is still able to access the native input event and other properties or methods inside </span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">the handler:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.652.1">
function Search() {
  handleInputChange(e) {
      // 'e' represents synthetic event
      const nativeEvent = e.nativeEvent;
      e.stopPropogation();
      e.preventDefault();
      // Code goes here..
</span><span class="koboSpan" id="kobo.652.2">  }
  return &lt;input onChange={handleInputChange} /&gt;
}</span></pre> <p><span class="koboSpan" id="kobo.653.1">The event handling in React has a few differences compared to HTML event handling, which we will discuss in the </span><span class="No-Break"><span class="koboSpan" id="kobo.654.1">next section.</span></span></p>
<h2 id="_idParaDest-86"><a id="_idTextAnchor085"/><span class="koboSpan" id="kobo.655.1">How do you differentiate between React event handling and HTML event handling?</span></h2>
<p><span class="koboSpan" id="kobo.656.1">React event handling</span><a id="_idIndexMarker181"/><span class="koboSpan" id="kobo.657.1"> is similar to event handling DOM elements</span><a id="_idIndexMarker182"/><span class="koboSpan" id="kobo.658.1"> in HTML. </span><span class="koboSpan" id="kobo.658.2">However, there are some notable differences </span><span class="No-Break"><span class="koboSpan" id="kobo.659.1">between them:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.660.1">Naming convention</span></strong><span class="koboSpan" id="kobo.661.1">: In HTML, the name of the event is represented in lowercase as </span><span class="No-Break"><span class="koboSpan" id="kobo.662.1">a convention:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.663.1">
&lt;button onclick="handleSingUp()"&gt;SingUp&lt;/button&gt;</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.664.1">However, in React, the name should be </span><span class="No-Break"><span class="koboSpan" id="kobo.665.1">in camelCase:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.666.1">&lt;button onClick={handleSignUp}&gt;SingUp&lt;/button&gt;</span></pre></li> <li><strong class="bold"><span class="koboSpan" id="kobo.667.1">Avoiding default behavior</span></strong><span class="koboSpan" id="kobo.668.1">: In HTML, you can avoid the default behavior of the event by returning </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">false</span></strong><span class="koboSpan" id="kobo.670.1"> inside the </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">event handler.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.672.1">As an example, let’s take a simple login form that contains a username and a password field to input the data. </span><span class="koboSpan" id="kobo.672.2">After submitting the form, you need to restrict the default behavior of an </span><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">onsubmit</span></strong><span class="koboSpan" id="kobo.674.1"> event, and the enclosing form must not </span><span class="No-Break"><span class="koboSpan" id="kobo.675.1">be refreshed:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.676.1">
&lt;form onsubmit="console.log('The form has been
  submitted.'); return false"&gt;
      &lt;input type="text" name="name" /&gt;
      &lt;input type="password" name="password" /&gt;
      &lt;button type="submit"&gt;Login&lt;/button&gt;
&lt;/form&gt;</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.677.1">However, in React, the default behavior can be prevented by calling the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">event.preventDefault()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.679.1"> method:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.680.1">function Login() {  
    function handleSubmit(e) { 
        e.preventDefault(); 
        console.log('You submitted Login form.'); 
    }  
    
    return (
        &lt;form onsubmit="handleSubmit"&gt; 
            &lt;input type="text" name="name" /&gt; 
            &lt;input type="password" name="password" /&gt; 
            &lt;button type="submit"&gt;Login&lt;/button&gt; 
        &lt;/form&gt;
    )   
} </span></pre></li> <li><strong class="bold"><span class="koboSpan" id="kobo.681.1">Invoking function</span></strong><span class="koboSpan" id="kobo.682.1">: In HTML, either you need to invoke</span><a id="_idIndexMarker183"/><span class="koboSpan" id="kobo.683.1"> the function by inserting</span><a id="_idIndexMarker184"/><span class="koboSpan" id="kobo.684.1"> parentheses (that is, </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">()</span></strong><span class="koboSpan" id="kobo.686.1">) after the function name or use </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">addEventListener()</span></strong><span class="koboSpan" id="kobo.688.1"> to attach events </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">and listeners.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.690.1">The following example shows a button </span><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">onclick</span></strong><span class="koboSpan" id="kobo.692.1"> event and invoking the respective handler. </span><span class="koboSpan" id="kobo.692.2">This can be done in </span><span class="No-Break"><span class="koboSpan" id="kobo.693.1">two ways.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.694.1">For the first approach, you can insert parentheses for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">handleSiginUp</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.696.1">function’s name:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.697.1">
&lt;button onclick="handleSingUp()"&gt;</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.698.1">As an alternative approach, you can use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">addEventListener()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.700.1"> method:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.701.1">&lt;p id="signup"&gt; 
    Please SignUp 
&lt;/p&gt; 
 
&lt;button id="myBtn" /&gt; 
 
&lt;script&gt; 
    const element = document.getElementById("myBtn"); 
    element.addEventListener('click', handleSignUp); 
    function handleSignUp() {  
        document.getElementById("signup").innerHTML +=
          'SignUp completed'; 
    } 
&lt;/script&gt; </span></pre><p class="list-inset"><span class="koboSpan" id="kobo.702.1">However, in React, you just need</span><a id="_idIndexMarker185"/><span class="koboSpan" id="kobo.703.1"> to specify the method</span><a id="_idIndexMarker186"/><span class="koboSpan" id="kobo.704.1"> name inside the curly braces (</span><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">{}</span></strong><span class="koboSpan" id="kobo.706.1">) of the event </span><span class="No-Break"><span class="koboSpan" id="kobo.707.1">attribute's value.</span></span></p></li> </ul>
<h2 id="_idParaDest-87"><a id="_idTextAnchor086"/><span class="koboSpan" id="kobo.708.1">How do you bind event handlers in class components?</span></h2>
<p><span class="koboSpan" id="kobo.709.1">There are several ways</span><a id="_idIndexMarker187"/><span class="koboSpan" id="kobo.710.1"> to bind event</span><a id="_idIndexMarker188"/><span class="koboSpan" id="kobo.711.1"> handlers in React </span><span class="No-Break"><span class="koboSpan" id="kobo.712.1">class components:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.713.1">Binding event handlers in </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.714.1">the constructor</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">:</span></span><p class="list-inset"><span class="koboSpan" id="kobo.716.1">In JavaScript, classes are not bound by default; the same applies to React when you are defining the event handlers as a class. </span><span class="koboSpan" id="kobo.716.2">However, it is possible to bind the event handlers to an instance using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">this</span></strong><span class="koboSpan" id="kobo.718.1"> keyword in a </span><span class="No-Break"><span class="koboSpan" id="kobo.719.1">constructor function.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.720.1">As an example, let’s add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.721.1">handleUserDetails()</span></strong><span class="koboSpan" id="kobo.722.1"> binding inside </span><span class="No-Break"><span class="koboSpan" id="kobo.723.1">the constructor:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.724.1">
class User extends Component { 
    constructor(props) { 
      super(props); 
      this.handleUserDetails = this.handleUserDetails.
</span><span class="koboSpan" id="kobo.724.2">        bind(this); 
    } 
  
    handleUserDetails() { 
      console.log("Show User details"); 
    } 
  
    render() { 
      return &lt;button onClick={this.handleUserDetails}&gt;Profile&lt;/
        button&gt;; 
    } 
  
} </span></pre><p class="list-inset"><span class="koboSpan" id="kobo.725.1">If you forget to bind</span><a id="_idIndexMarker189"/><span class="koboSpan" id="kobo.726.1"> the handler, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.727.1">this</span></strong><span class="koboSpan" id="kobo.728.1"> keyword</span><a id="_idIndexMarker190"/><span class="koboSpan" id="kobo.729.1"> will be undefined when the function </span><span class="No-Break"><span class="koboSpan" id="kobo.730.1">is invoked.</span></span></p></li> <li><strong class="bold"><span class="koboSpan" id="kobo.731.1">Public class </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.732.1">fields syntax</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.733.1">:</span></span><p class="list-inset"><span class="koboSpan" id="kobo.734.1">If you are not interested in binding handlers in the constructor, the public class fields approach is much better for readability</span><a id="_idIndexMarker191"/><span class="koboSpan" id="kobo.735.1"> and ease of use. </span><span class="koboSpan" id="kobo.735.2">This syntax is enabled by default in the </span><strong class="bold"><span class="koboSpan" id="kobo.736.1">Create React App</span></strong><span class="koboSpan" id="kobo.737.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.738.1">CRA</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.739.1">) tool.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.740.1">The previous binding approach can be rewritten and simplified using public class fields syntax, as </span><span class="No-Break"><span class="koboSpan" id="kobo.741.1">shown here:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.742.1">
class User extends Component {
  handleUserDetails = () =&gt; {
    console.log("Show User details");
  }
  render() {
    return &lt;button onClick={this.handleUserDetails}&gt;Profile&lt;/
      button&gt;; 
  }
}</span></pre></li> <li><strong class="bold"><span class="koboSpan" id="kobo.743.1">Use </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.744.1">arrow functions</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.745.1">:</span></span><p class="list-inset"><span class="koboSpan" id="kobo.746.1">Arrow functions can be passed</span><a id="_idIndexMarker192"/><span class="koboSpan" id="kobo.747.1"> in the callbacks directly</span><a id="_idIndexMarker193"/><span class="koboSpan" id="kobo.748.1"> without the need to bind with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.749.1">this</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.750.1">keyword explicitly.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.751.1">The arrow function is passed in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.752.1">User</span></strong><span class="koboSpan" id="kobo.753.1"> component callback, </span><span class="No-Break"><span class="koboSpan" id="kobo.754.1">like so:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.755.1">
handleUserDetails() { 
    console.log("Show User details"); 
} 
render() { 
    return &lt;button onClick={() =&gt; this.handleUserDetails()}&gt;
      Profile&lt;/button&gt;; 
} </span></pre><p class="list-inset"><span class="koboSpan" id="kobo.756.1">The main problem with this arrow function approach is that a different callback is created every time the component renders, and the child component might do extra re-rendering if the callbacks are passed as props to child components. </span><span class="koboSpan" id="kobo.756.2">Hence, it is recommended to use either a binding in a constructor or the public class fields </span><span class="No-Break"><span class="koboSpan" id="kobo.757.1">syntax approach.</span></span></p></li> </ul>
<p><span class="koboSpan" id="kobo.758.1">The magic behind the React library, including syncing the component data with the UI, DOM updates, and more, is taken care of by the virtual DOM. </span><span class="koboSpan" id="kobo.758.2">In the next section, you will learn about virtual </span><a id="_idIndexMarker194"/><span class="koboSpan" id="kobo.759.1">DOM, its importance, and its processes</span><a id="_idIndexMarker195"/><span class="koboSpan" id="kobo.760.1"> behind </span><span class="No-Break"><span class="koboSpan" id="kobo.761.1">the scenes.</span></span></p>
<h1 id="_idParaDest-88"><a id="_idTextAnchor087"/><span class="koboSpan" id="kobo.762.1">Understanding virtual DOM</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.763.1">DOM</span></strong><span class="koboSpan" id="kobo.764.1"> stands for </span><strong class="bold"><span class="koboSpan" id="kobo.765.1">Document Object Model</span></strong><span class="koboSpan" id="kobo.766.1"> and it represents the entire UI</span><a id="_idIndexMarker196"/><span class="koboSpan" id="kobo.767.1"> of a web page (HTML) in a tree data format. </span><span class="koboSpan" id="kobo.767.2">virtual DOM was not invented by React, but it uses it as its core feature. </span><span class="koboSpan" id="kobo.767.3">Its main purpose is to minimize the number of DOM operations when re-rendering the UI. </span><span class="koboSpan" id="kobo.767.4">React uses this feature to enhance its performance. </span><span class="koboSpan" id="kobo.767.5">There’s a high chance you’ll get questions related to this topic in </span><span class="No-Break"><span class="koboSpan" id="kobo.768.1">an interview.</span></span></p>
<h2 id="_idParaDest-89"><a id="_idTextAnchor088"/><span class="koboSpan" id="kobo.769.1">What is virtual DOM?</span></h2>
<p><span class="koboSpan" id="kobo.770.1">virtual DOM</span><a id="_idIndexMarker197"/><span class="koboSpan" id="kobo.771.1"> is an in-memory, lightweight virtual representation of Real DOM that’s generated by React components. </span><span class="koboSpan" id="kobo.771.2">The virtual representation of a UI is stored in memory and synced with Real DOM</span><a id="_idIndexMarker198"/><span class="koboSpan" id="kobo.772.1"> to align with the latest state updates. </span><span class="koboSpan" id="kobo.772.2">This is possible through a library known as </span><strong class="bold"><span class="koboSpan" id="kobo.773.1">ReactDOM</span></strong><span class="koboSpan" id="kobo.774.1">, and this step happens in between the render function</span><a id="_idIndexMarker199"/><span class="koboSpan" id="kobo.775.1"> being called and elements being displayed on the screen. </span><span class="koboSpan" id="kobo.775.2">This entire process is known </span><span class="No-Break"><span class="koboSpan" id="kobo.776.1">as </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.777.1">reconciliation</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.778.1">.</span></span></p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor089"/><span class="koboSpan" id="kobo.779.1">How does virtual DOM work?</span></h2>
<p><span class="koboSpan" id="kobo.780.1">React and Vue.js technologies</span><a id="_idIndexMarker200"/><span class="koboSpan" id="kobo.781.1"> use virtual DOM under the hood to abstract the manual DOM operations away from developers. </span><span class="koboSpan" id="kobo.781.2">This programming mechanism works in four </span><span class="No-Break"><span class="koboSpan" id="kobo.782.1">major steps.</span></span></p>
<p><span class="koboSpan" id="kobo.783.1">As an example, let’s take a simple search form with an inputfield inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.784.1">CitySearch component</span></strong><span class="koboSpan" id="kobo.785.1"> and see how the virtual DOM works. </span><span class="koboSpan" id="kobo.785.2">We’ll provide diagrams for ease </span><span class="No-Break"><span class="koboSpan" id="kobo.786.1">of understanding:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.787.1">
function CitySearch() { 
    return ( 
       &lt;div&gt; 
        &lt;h2&gt;Find city:&lt;/h2&gt; 
        &lt;form&gt; 
            &lt;span&gt; 
                City: 
            &lt;/span&gt;
            &lt;input onChange={handleCitySearch} /&gt; 
        &lt;/form&gt; 
       &lt;/div&gt; 
    ) 
 }</span></pre> <p><span class="koboSpan" id="kobo.788.1">The preceeding city search</span><a id="_idIndexMarker201"/><span class="koboSpan" id="kobo.789.1"> works internally with the following steps of virtual </span><span class="No-Break"><span class="koboSpan" id="kobo.790.1">DOM mechanism:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.791.1">When the application is rendered for the first time, React creates a virtual DOM representing the UI and stores the same </span><span class="No-Break"><span class="koboSpan" id="kobo.792.1">in memory:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer019">
<span class="koboSpan" id="kobo.793.1"><img alt="Figure 2.5: Initial ﻿vrtual DOM" src="image/Figure_02.05_B18603.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.794.1">Figure 2.5: Initial vrtual DOM</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.795.1">Whenever the underlying state changes, it will automatically create a new virtual DOM for the update. </span><span class="koboSpan" id="kobo.795.2">Since virtual DOM is just an object representing the UI, there won’t be any changes (such as repainting) in the UI at </span><span class="No-Break"><span class="koboSpan" id="kobo.796.1">this point:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer020">
<span class="koboSpan" id="kobo.797.1"><img alt="Figure 2.6: Updated ﻿virtual DOM" src="image/Figure_02.06_B18603.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.798.1">Figure 2.6: Updated virtual DOM</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.799.1">Once the new virtual DOM</span><a id="_idIndexMarker202"/><span class="koboSpan" id="kobo.800.1"> has been created, React compares</span><a id="_idIndexMarker203"/><span class="koboSpan" id="kobo.801.1"> it to a pre-updated version</span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.802.1"> or snapshot of virtual DOM. </span><span class="koboSpan" id="kobo.802.2">React uses the </span><strong class="bold"><span class="koboSpan" id="kobo.803.1">diffing</span></strong><span class="koboSpan" id="kobo.804.1"> algorithm to compare the changes; this process is known </span><span class="No-Break"><span class="koboSpan" id="kobo.805.1">as </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.806.1">reconciliation</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.807.1">:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer021">
<span class="koboSpan" id="kobo.808.1"><img alt="  Figure 2.7: Comparing ﻿virtual DOM snapshots" src="image/Figure_02.07_B18603.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.809.1">  Figure 2.7: Comparing virtual DOM snapshots</span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.810.1">After the reconciliation process, React uses a render library such as ReactDOM, which takes the changes</span><a id="_idIndexMarker205"/><span class="koboSpan" id="kobo.811.1"> and updates that in </span><span class="No-Break"><span class="koboSpan" id="kobo.812.1">Real DOM:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer022">
<span class="koboSpan" id="kobo.813.1"><img alt="Figure 2.8: Updated Real DOM" src="image/Figure_02.08_B18603.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.814.1">Figure 2.8: Updated Real DOM</span></p>
<h2 id="_idParaDest-91"><a id="_idTextAnchor090"/><span class="koboSpan" id="kobo.815.1">What is Shadow DOM?</span></h2>
<p><span class="koboSpan" id="kobo.816.1">Shadow DOM is a web component</span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.817.1"> technology that’s designed primarily for scoping variables and CSS. </span><span class="koboSpan" id="kobo.817.2">This is useful when CSS styles defined in a parent component don’t affect or apply to a </span><span class="No-Break"><span class="koboSpan" id="kobo.818.1">child component.</span></span></p>
<h2 id="_idParaDest-92"><a id="_idTextAnchor091"/><span class="koboSpan" id="kobo.819.1">What is the difference between Real DOM, virtual DOM, and Shadow DOM?</span></h2>
<p><span class="koboSpan" id="kobo.820.1">In modern web</span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.821.1"> development, virtual DOM</span><a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.822.1"> and shadow DOM</span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.823.1"> have been introduced</span><a id="_idIndexMarker210"/><span class="koboSpan" id="kobo.824.1"> to improve performance</span><a id="_idIndexMarker211"/><span class="koboSpan" id="kobo.825.1"> and encapsulation</span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.826.1"> as add-ons to </span><span class="No-Break"><span class="koboSpan" id="kobo.827.1">real DOM.</span></span></p>
<p><span class="koboSpan" id="kobo.828.1">Some of the notable differences among these three DOMs are </span><span class="No-Break"><span class="koboSpan" id="kobo.829.1">listed here:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table002">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style T---Body">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.830.1">Real DOM</span></strong></span></p>
</td>
<td class="No-Table-Style T---Body">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.831.1">Virtual DOM</span></strong></span></p>
</td>
<td class="No-Table-Style T---Body">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.832.1">Shadow DOM</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style T---Body">
<p><span class="koboSpan" id="kobo.833.1">It creates a single DOM for the </span><span class="No-Break"><span class="koboSpan" id="kobo.834.1">entire screen</span></span></p>
</td>
<td class="No-Table-Style T---Body">
<p><span class="koboSpan" id="kobo.835.1">It creates a copy of the entire real DOM in memory and keeps track </span><span class="No-Break"><span class="koboSpan" id="kobo.836.1">of changes</span></span></p>
</td>
<td class="No-Table-Style T---Body">
<p><span class="koboSpan" id="kobo.837.1">It creates small copies of Real DOM with its isolated scope (that is, scoped CSS styles </span><span class="No-Break"><span class="koboSpan" id="kobo.838.1">and JavaScript)</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style T---Body">
<p><span class="koboSpan" id="kobo.839.1">Any change will involve re-rendering the </span><span class="No-Break"><span class="koboSpan" id="kobo.840.1">whole screen</span></span></p>
</td>
<td class="No-Table-Style T---Body">
<p><span class="koboSpan" id="kobo.841.1">The state change will involve re-rendering the specific part of </span><span class="No-Break"><span class="koboSpan" id="kobo.842.1">the page</span></span></p>
</td>
<td class="No-Table-Style T---Body">
<p><span class="koboSpan" id="kobo.843.1">The changes apply to its own </span><span class="No-Break"><span class="koboSpan" id="kobo.844.1">web component</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style T---Body">
<p><span class="koboSpan" id="kobo.845.1">Implemented in web browsers, such as via the </span><span class="No-Break"><span class="koboSpan" id="kobo.846.1">Solid.js library</span></span></p>
</td>
<td class="No-Table-Style T---Body">
<p><span class="koboSpan" id="kobo.847.1">Implemented in JavaScript libraries such as React, Vue, </span><span class="No-Break"><span class="koboSpan" id="kobo.848.1">and others</span></span></p>
</td>
<td class="No-Table-Style T---Body">
<p><span class="koboSpan" id="kobo.849.1">Implemented in web components, such as Lit and </span><span class="No-Break"><span class="koboSpan" id="kobo.850.1">Vaadin libraries</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style T---Body">
<p><span class="koboSpan" id="kobo.851.1">Suitable for small to medium scale applications without </span><span class="No-Break"><span class="koboSpan" id="kobo.852.1">complex interactivity</span></span></p>
</td>
<td class="No-Table-Style T---Body">
<p><span class="koboSpan" id="kobo.853.1">Suitable for large-scale applications with </span><span class="No-Break"><span class="koboSpan" id="kobo.854.1">complex interactivity</span></span></p>
</td>
<td class="No-Table-Style T---Body">
<p><span class="koboSpan" id="kobo.855.1">Suitable for small to medium scale applications with less </span><span class="No-Break"><span class="koboSpan" id="kobo.856.1">complex interactivity</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style T---Body">
<p><span class="koboSpan" id="kobo.857.1">Uses less CPU and memory compared to </span><span class="No-Break"><span class="koboSpan" id="kobo.858.1">virtual DOM</span></span></p>
</td>
<td class="No-Table-Style T---Body">
<p><span class="koboSpan" id="kobo.859.1">Uses more CPU and memory compared to </span><span class="No-Break"><span class="koboSpan" id="kobo.860.1">Real DOM</span></span></p>
</td>
<td class="No-Table-Style T---Body">
<p><span class="koboSpan" id="kobo.861.1">Uses less CPU and memory compared to </span><span class="No-Break"><span class="koboSpan" id="kobo.862.1">virtual DOM</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style T---Body">
<p><span class="koboSpan" id="kobo.863.1">Doesn’t support encapsulation because components can be </span><span class="No-Break"><span class="koboSpan" id="kobo.864.1">modified outside</span></span></p>
</td>
<td class="No-Table-Style T---Body">
<p><span class="koboSpan" id="kobo.865.1">Supports encapsulation because components cannot be </span><span class="No-Break"><span class="koboSpan" id="kobo.866.1">modified outside</span></span></p>
</td>
<td class="No-Table-Style T---Body">
<p><span class="koboSpan" id="kobo.867.1">Supports encapsulation because components cannot be </span><span class="No-Break"><span class="koboSpan" id="kobo.868.1">modified outside</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.869.1">Table 2.2: Real DOM versus irtual DOM versus Shadow DOM</span></p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor092"/><span class="koboSpan" id="kobo.870.1">What is React Fiber?</span></h2>
<p><span class="koboSpan" id="kobo.871.1">Fiber is a new reconciliation engine</span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.872.1"> that was introduced in React version 16 to enable in-built scheduling and incremental rendering of virtual DOM. </span><span class="koboSpan" id="kobo.872.2">Incremental rendering means having the ability to split rendering work into chunks and spread it out over multiple frames. </span><span class="koboSpan" id="kobo.872.3">So, with the help of incremental rendering, Fiber improves application performance in areas such</span><a id="_idIndexMarker214"/><span class="koboSpan" id="kobo.873.1"> as animation, layout, </span><span class="No-Break"><span class="koboSpan" id="kobo.874.1">and gestures.</span></span></p>
<p><span class="koboSpan" id="kobo.875.1">This reconciler is a complete</span><a id="_idIndexMarker215"/><span class="koboSpan" id="kobo.876.1"> rewrite of an old reconciliation algorithm called </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.877.1">stack reconciler</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.878.1">.</span></span></p>
<h1 id="_idParaDest-94"><a id="_idTextAnchor093"/><span class="koboSpan" id="kobo.879.1">Data flow and communication in React applications</span></h1>
<p><span class="koboSpan" id="kobo.880.1">The unidirectional data flow</span><a id="_idIndexMarker216"/><span class="koboSpan" id="kobo.881.1"> feature of React</span><a id="_idIndexMarker217"/><span class="koboSpan" id="kobo.882.1"> makes the UI simple</span><a id="_idIndexMarker218"/><span class="koboSpan" id="kobo.883.1"> and predictable</span><a id="_idIndexMarker219"/><span class="koboSpan" id="kobo.884.1"> for data changes in small to large-scale applications. </span><span class="koboSpan" id="kobo.884.2">It is quite important to know the benefits of data flow and communication between components to better understand the relevant </span><span class="No-Break"><span class="koboSpan" id="kobo.885.1">React concepts.</span></span></p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor094"/><span class="koboSpan" id="kobo.886.1">Can you describe unidirectional data flow in React?</span></h2>
<p><span class="koboSpan" id="kobo.887.1">Unidirectional data flow</span><a id="_idIndexMarker220"/><span class="koboSpan" id="kobo.888.1"> is also known as one-way data binding and is where</span><a id="_idIndexMarker221"/><span class="koboSpan" id="kobo.889.1"> the data flows one way only while being transferred between different parts of an application. </span><span class="koboSpan" id="kobo.889.2">This technique or feature already exists in functional </span><span class="No-Break"><span class="koboSpan" id="kobo.890.1">reactive programming.</span></span></p>
<p><span class="koboSpan" id="kobo.891.1">React follows unidirectional data flow, where the data is transferred from parent to child using props but not vice versa. </span><span class="koboSpan" id="kobo.891.2">Moreover, the child components can’t update data that comes from the parent component. </span><span class="koboSpan" id="kobo.891.3">React doesn’t encourage bidirectional or two-way binding to make sure you are following a clean data </span><span class="No-Break"><span class="koboSpan" id="kobo.892.1">flow architecture.</span></span></p>
<p><span class="koboSpan" id="kobo.893.1">The following figure </span><a id="_idIndexMarker222"/><span class="koboSpan" id="kobo.894.1">gives a clearer idea</span><a id="_idIndexMarker223"/><span class="koboSpan" id="kobo.895.1"> of the data flow </span><span class="No-Break"><span class="koboSpan" id="kobo.896.1">in React:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer023">
<span class="koboSpan" id="kobo.897.1"><img alt="Figure 2.9: Unidirectional versus ﻿bidirectional data flow" src="image/Figure_02.09_B18603.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.898.1">Figure 2.9: Unidirectional versus bidirectional data flow</span></p>
<p><span class="koboSpan" id="kobo.899.1">The only way to update the data</span><a id="_idIndexMarker224"/><span class="koboSpan" id="kobo.900.1"> in the parent component is by triggering the events from the </span><span class="No-Break"><span class="koboSpan" id="kobo.901.1">child component.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.902.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.903.1">In contrast to React, Vue.js follows two-way data binding or bidirectional data flow between </span><span class="No-Break"><span class="koboSpan" id="kobo.904.1">the components.</span></span></p>
<h2 id="_idParaDest-96"><a id="_idTextAnchor095"/><span class="koboSpan" id="kobo.905.1">What are the advantages of unidirectional data flow?</span></h2>
<p><span class="koboSpan" id="kobo.906.1">The main advantage of unidirectional data flow</span><a id="_idIndexMarker225"/><span class="koboSpan" id="kobo.907.1"> is having a single source of truth for your data. </span><span class="koboSpan" id="kobo.907.2">There are many other advantages of the unidirectional data flow feature. </span><span class="koboSpan" id="kobo.907.3">Some of the key benefits are </span><span class="No-Break"><span class="koboSpan" id="kobo.908.1">listed here:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.909.1">Debugging</span></strong><span class="koboSpan" id="kobo.910.1">: Since the developers know where the data comes from and where it goes, it is much easier to </span><span class="No-Break"><span class="koboSpan" id="kobo.911.1">debug problems</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.912.1">Less error-prone</span></strong><span class="koboSpan" id="kobo.913.1">: The data flows in one direction, which makes the programs less error-prone and gives the developers </span><span class="No-Break"><span class="koboSpan" id="kobo.914.1">better control</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.915.1">Efficiency</span></strong><span class="koboSpan" id="kobo.916.1">: No extra resources are wasted with the known boundaries of unidirectional data flow</span><a id="_idIndexMarker226"/><span class="koboSpan" id="kobo.917.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.918.1">the application</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.919.1">You cannot always depend on the state, props, and data flow concepts to control the view layer. </span><span class="koboSpan" id="kobo.919.2">Irrespective of the JavaScript library, you may need access to DOM elements, and accessing elements through conventional approaches such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.920.1">document.getElementById</span></strong><span class="koboSpan" id="kobo.921.1"> becomes cumbersome. </span><span class="koboSpan" id="kobo.921.2">In the next section, you will find a better alternative to </span><span class="No-Break"><span class="koboSpan" id="kobo.922.1">access DOM.</span></span></p>
<h1 id="_idParaDest-97"><a id="_idTextAnchor096"/><span class="koboSpan" id="kobo.923.1">How do you access DOM?</span></h1>
<p><span class="koboSpan" id="kobo.924.1">DOM manipulation</span><a id="_idIndexMarker227"/><span class="koboSpan" id="kobo.925.1"> is taken care of by the React library under the hood, without the need for any manual DOM updates. </span><span class="koboSpan" id="kobo.925.2">But sometimes, you might encounter use cases (focusing, scrolling to specific elements, and so on) to have DOM element access managed by React. </span><span class="koboSpan" id="kobo.925.3">As a solution to these use cases, refs have been introduced to access the </span><span class="No-Break"><span class="koboSpan" id="kobo.926.1">DOM nodes.</span></span></p>
<p><span class="koboSpan" id="kobo.927.1">A React interviewer might expect a good knowledge of DOM access and possible use cases, both of which cannot be handled through a traditional </span><span class="No-Break"><span class="koboSpan" id="kobo.928.1">declarative approach.</span></span></p>
<h2 id="_idParaDest-98"><a id="_idTextAnchor097"/><span class="koboSpan" id="kobo.929.1">What are refs? </span><span class="koboSpan" id="kobo.929.2">How do you create refs?</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.930.1">Ref</span></strong><span class="koboSpan" id="kobo.931.1"> is the shorthand for a reference</span><a id="_idIndexMarker228"/><span class="koboSpan" id="kobo.932.1"> to an element or a component. </span><span class="koboSpan" id="kobo.932.2">Refs are used to access DOM nodes or React elements that are created in the render method. </span><span class="koboSpan" id="kobo.932.3">The reference to the DOM element is available in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.933.1">current</span></strong><span class="koboSpan" id="kobo.934.1"> attribute of the ref. </span><span class="koboSpan" id="kobo.934.2">In other words, refs are plain JavaScript objects with additional  current property. </span><span class="koboSpan" id="kobo.934.3">To understand this ref concept in a better way, let’s look at an example of implementing auto-focus behavior for an input element</span><a id="_idIndexMarker229"/><span class="koboSpan" id="kobo.935.1"> using a ref. </span><span class="koboSpan" id="kobo.935.2">To do that, we'll follow the </span><span class="No-Break"><span class="koboSpan" id="kobo.936.1">following instructions::</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.937.1">Import the </span><strong class="source-inline"><span class="koboSpan" id="kobo.938.1">useRef</span></strong><span class="koboSpan" id="kobo.939.1"> Hook from the </span><span class="No-Break"><span class="koboSpan" id="kobo.940.1">React library.</span></span></li>
<li><span class="koboSpan" id="kobo.941.1">Declare </span><strong class="source-inline"><span class="koboSpan" id="kobo.942.1">inputRef</span></strong><span class="koboSpan" id="kobo.943.1"> inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.944.1">SignUpForm</span></strong><span class="koboSpan" id="kobo.945.1"> component with the return value of </span><span class="No-Break"><span class="koboSpan" id="kobo.946.1">the Hook.</span></span></li>
<li><span class="koboSpan" id="kobo.947.1">Pass </span><strong class="source-inline"><span class="koboSpan" id="kobo.948.1">inputRef</span></strong><span class="koboSpan" id="kobo.949.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.950.1">&lt;input&gt;</span></strong><span class="koboSpan" id="kobo.951.1"> element, which connects the input’s DOM node to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.952.1">inputRef.current</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.953.1"> property.</span></span></li>
<li><span class="koboSpan" id="kobo.954.1">While loading the component instance, apply focus to an input element programmatically by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.955.1">focus()</span></strong><span class="koboSpan" id="kobo.956.1"> on the DOM node within the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.957.1">useEffect</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.958.1"> Hook.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.959.1">After following all the preceding</span><a id="_idIndexMarker230"/><span class="koboSpan" id="kobo.960.1"> steps, the final component that’s using refs should look </span><span class="No-Break"><span class="koboSpan" id="kobo.961.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.962.1">
import {useRef, useEffimport {useRef, useEffect} from 'react'; 
export default function SignUpForm() { 
  const inputRef = useRef(null); 
  useEffect(() =&gt; { 
    inputRef.current.focus(); 
  }, []) 
  return ( 
    &lt;&gt; 
      &lt;input type="email" ref={inputRef} /&gt; 
      &lt;button&gt; 
        Verify Email 
      &lt;/button&gt; 
    &lt;/&gt; 
  ); 
} </span></pre> <p><span class="koboSpan" id="kobo.963.1">Similar to how the </span><strong class="source-inline"><span class="koboSpan" id="kobo.964.1">useRef</span></strong><span class="koboSpan" id="kobo.965.1"> Hook is used in function components, </span><strong class="source-inline"><span class="koboSpan" id="kobo.966.1">createRef</span></strong><span class="koboSpan" id="kobo.967.1"> is typically used when creating</span><a id="_idIndexMarker231"/><span class="koboSpan" id="kobo.968.1"> a ref in a </span><span class="No-Break"><span class="koboSpan" id="kobo.969.1">class component.</span></span></p>
<h2 id="_idParaDest-99"><a id="_idTextAnchor098"/><span class="koboSpan" id="kobo.970.1">What is the main purpose of refs?</span></h2>
<p><span class="koboSpan" id="kobo.971.1">The main purpose</span><a id="_idIndexMarker232"/><span class="koboSpan" id="kobo.972.1"> of refs is to imperatively modify a child outside of the typical one-way data flow. </span><span class="koboSpan" id="kobo.972.2">A few common use cases</span><a id="_idIndexMarker233"/><span class="koboSpan" id="kobo.973.1"> that can be handled through refs as an escape hatch are </span><span class="No-Break"><span class="koboSpan" id="kobo.974.1">discussed here:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.975.1">For the first use case, let’s talk about how UI elements are modified through certain events or actions. </span><span class="koboSpan" id="kobo.975.2">This use case category includes scenarios such as managing input field focus, text selection, and media control (</span><span class="No-Break"><span class="koboSpan" id="kobo.976.1">or playback).</span></span><p class="list-inset"><span class="koboSpan" id="kobo.977.1">As an example, let’s look at the aforementioned text selection and audio scenarios controlled through external </span><span class="No-Break"><span class="koboSpan" id="kobo.978.1">button clicks:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.979.1">
 //Text selection 
const hasInputText = inputRef.current.value.length &gt; 0; 
if (hasInputText) { 
    inputRef.current.select(); 
} 
// Audio controls 
const playAudio = () =&gt; { 
    audioRef.current.play(); 
}; 
const pauseAudio = () =&gt; { 
    audioRef.current.pause(); 
}; </span></pre></li> <li><span class="koboSpan" id="kobo.980.1">For the second use case, let’s talk about triggering imperative animations in the UI without writing any explicit animations either through CSS </span><span class="No-Break"><span class="koboSpan" id="kobo.981.1">or JavaScript.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.982.1">Here is an example of accessing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.983.1">div</span></strong><span class="koboSpan" id="kobo.984.1"> element and finding its position based on the scroll event to perform certain actions in </span><span class="No-Break"><span class="koboSpan" id="kobo.985.1">the layout:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.986.1">
  function handleScroll() {
    const block = blockRef.current;
    const { y } = block.getBoundingClientRect();
    const blockBackgroundColor = y &lt;= 0 ?
</span><span class="koboSpan" id="kobo.986.2">      'white' : 'black';
    setBackground(blockBackgroundColor);
  }</span></pre></li> <li><span class="koboSpan" id="kobo.987.1">For the third use case, let’s discuss integrating with third-party DOM libraries in a </span><span class="No-Break"><span class="koboSpan" id="kobo.988.1">React application.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.989.1">It is easy to integrate an existing application with some of the JavaScript plugins or libraries using refs. </span><span class="koboSpan" id="kobo.989.2">For example, third-party plugins such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.990.1">DataTable.js</span></strong><span class="koboSpan" id="kobo.991.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.992.1">select2</span></strong><span class="koboSpan" id="kobo.993.1"> can easily be accessed</span><a id="_idIndexMarker234"/><span class="koboSpan" id="kobo.994.1"> inside React applications without recreating them </span><span class="No-Break"><span class="koboSpan" id="kobo.995.1">from scratch.</span></span></p></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.996.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.997.1">It is recommended to avoid refs if you can implement the </span><span class="No-Break"><span class="koboSpan" id="kobo.998.1">task declaratively.</span></span></p>
<h2 id="_idParaDest-100"><a id="_idTextAnchor099"/><span class="koboSpan" id="kobo.999.1">How do you compare refs with state?</span></h2>
<p><span class="koboSpan" id="kobo.1000.1">Both refs and state</span><a id="_idIndexMarker235"/><span class="koboSpan" id="kobo.1001.1"> are used to persist</span><a id="_idIndexMarker236"/><span class="koboSpan" id="kobo.1002.1"> the component data between renders. </span><span class="koboSpan" id="kobo.1002.2">However, there are many differences </span><span class="No-Break"><span class="koboSpan" id="kobo.1003.1">between them:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table003">
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style T---Body">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1004.1">Ref</span></strong></span></p>
</td>
<td class="No-Table-Style T---Body">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1005.1">State</span></strong></span></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style T---Body">
<p><span class="koboSpan" id="kobo.1006.1">Created by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1007.1">useRef(initialValue)</span></strong><span class="koboSpan" id="kobo.1008.1"> Hook, which returns the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1009.1">{current: initialValue}</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1010.1">JavaScript object</span></span></p>
</td>
<td class="No-Table-Style T---Body">
<p><span class="koboSpan" id="kobo.1011.1">Created by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1012.1">useState(initialValue)</span></strong><span class="koboSpan" id="kobo.1013.1"> Hook, which returns the current state value and the setter function to update the state– that is, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1014.1">[</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1015.1">value, setValue]</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style T---Body">
<p><span class="koboSpan" id="kobo.1016.1">Doesn’t trigger a re-render for any changes that are made </span><span class="No-Break"><span class="koboSpan" id="kobo.1017.1">to it</span></span></p>
</td>
<td class="No-Table-Style T---Body">
<p><span class="koboSpan" id="kobo.1018.1">Triggers a re-render for any change </span><span class="No-Break"><span class="koboSpan" id="kobo.1019.1">in state</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style T---Body">
<p><span class="koboSpan" id="kobo.1020.1">It is often used to communicate with </span><span class="No-Break"><span class="koboSpan" id="kobo.1021.1">external APIs</span></span></p>
</td>
<td class="No-Table-Style T---Body">
<p><span class="koboSpan" id="kobo.1022.1">It is frequently used within a component to change </span><span class="No-Break"><span class="koboSpan" id="kobo.1023.1">its appearance</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style T---Body">
<p><span class="koboSpan" id="kobo.1024.1">It is possible to update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1025.1">current</span></strong><span class="koboSpan" id="kobo.1026.1"> attribute value outside the rendering process – that is, ref </span><span class="No-Break"><span class="koboSpan" id="kobo.1027.1">is mutable</span></span></p>
</td>
<td class="No-Table-Style T---Body">
<p><span class="koboSpan" id="kobo.1028.1">You should not update the state variables directly; a setter function should be used to modify the value – that is, state </span><span class="No-Break"><span class="koboSpan" id="kobo.1029.1">is immutable</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style T---Body">
<p><span class="koboSpan" id="kobo.1030.1">React cannot track </span><span class="No-Break"><span class="koboSpan" id="kobo.1031.1">ref changes</span></span></p>
</td>
<td class="No-Table-Style T---Body">
<p><span class="koboSpan" id="kobo.1032.1">React can track </span><span class="No-Break"><span class="koboSpan" id="kobo.1033.1">state changes</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style T---Body">
<p><span class="koboSpan" id="kobo.1034.1">You shouldn’t read or write refs during the </span><span class="No-Break"><span class="koboSpan" id="kobo.1035.1">rendering process</span></span></p>
</td>
<td class="No-Table-Style T---Body">
<p><span class="koboSpan" id="kobo.1036.1">You can read state at </span><span class="No-Break"><span class="koboSpan" id="kobo.1037.1">any time</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style T---Body">
<p><span class="koboSpan" id="kobo.1038.1">Avoid using refs unless declarative views based on state can’t be implemented, since changes to the DOM structure may conflict with React’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.1039.1">diff</span></strong><span class="koboSpan" id="kobo.1040.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1041.1">update</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1042.1"> approach</span></span></p>
</td>
<td class="No-Table-Style T---Body">
<p><span class="koboSpan" id="kobo.1043.1">It’s always recommended to use state for </span><span class="No-Break"><span class="koboSpan" id="kobo.1044.1">UI updates</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1045.1">Table 2.3: Ref versus state</span></p>
<p><span class="koboSpan" id="kobo.1046.1">Even though refs</span><a id="_idIndexMarker237"/><span class="koboSpan" id="kobo.1047.1"> are less strict (in terms of mutation) than state, most of the time, you will be using</span><a id="_idIndexMarker238"/><span class="koboSpan" id="kobo.1048.1"> state over refs because refs are an escape hatch for accessing the DOM, which you don’t need </span><span class="No-Break"><span class="koboSpan" id="kobo.1049.1">that often.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1050.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1051.1">If you are storing the information across the re-renders without rendering on the screen, then you should use refs. </span><span class="koboSpan" id="kobo.1051.2">Otherwise, you always need to use state to </span><span class="No-Break"><span class="koboSpan" id="kobo.1052.1">store data.</span></span></p>
<h2 id="_idParaDest-101"><a id="_idTextAnchor100"/><span class="koboSpan" id="kobo.1053.1">What are forward refs?</span></h2>
<p><span class="koboSpan" id="kobo.1054.1">Nowadays, components</span><a id="_idIndexMarker239"/><span class="koboSpan" id="kobo.1055.1"> are more complex and barely use plain HTML elements directly. </span><span class="koboSpan" id="kobo.1055.2">This leads to a parent and child component hierarchy with composable views. </span><span class="koboSpan" id="kobo.1055.3">If you just try to pass down the ref to the child component as a prop, the child component won’t receive the actual DOM element that needs to be accessed. </span><span class="koboSpan" id="kobo.1055.4">Instead, it returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.1056.1">{</span></strong> <span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1057.1">current:</span></strong></span><span class="No-Break"> </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1058.1">null}</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1059.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1060.1">React’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.1061.1">forwardRef</span></strong><span class="koboSpan" id="kobo.1062.1"> is a method that allows a parent component to pass down refs to its children. </span><span class="koboSpan" id="kobo.1062.2">In the following example, the child component receivesa ref from its parent component by wrapping it with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1063.1">forwardRef</span></strong><span class="koboSpan" id="kobo.1064.1"> method. </span><span class="koboSpan" id="kobo.1064.2">This, in turn, forwards it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1065.1">&lt;button/&gt;</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1066.1">DOM element:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1067.1">
import { forwardRef } from 'react';
const MySignInButton = forwardRef(function  MySignInButton(props, ref) {
  const { label, ...otherProps } = props;
  return (
    &lt;label&gt;
      {label}
      &lt;button {...otherProps} ref={ref} /&gt;
    &lt;/label&gt;
  );
});</span></pre> <p><span class="koboSpan" id="kobo.1068.1">The preceding child component receives a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1069.1">ref</span></strong><strong class="source-inline"><a id="_idIndexMarker240"/></strong><span class="koboSpan" id="kobo.1070.1"> as a second argument, whereas the first argument refers </span><span class="No-Break"><span class="koboSpan" id="kobo.1071.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1072.1">props</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1073.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1074.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1075.1">You can limit the information you expose about your DOM node instead of passing the entire DOM node using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1076.1">userImperativeHandle</span></strong><span class="koboSpan" id="kobo.1077.1"> Hook. </span><span class="koboSpan" id="kobo.1077.2">You will learn more about this Hook in </span><a href="B18603_03.xhtml#_idTextAnchor110"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1078.1">Chapter 3</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1079.1">.</span></span></p>
<h1 id="_idParaDest-102"><a id="_idTextAnchor101"/><span class="koboSpan" id="kobo.1080.1">Managing state globally using the context API</span></h1>
<p><span class="koboSpan" id="kobo.1081.1">Context helps</span><a id="_idIndexMarker241"/><span class="koboSpan" id="kobo.1082.1"> you share global data with the child</span><a id="_idIndexMarker242"/><span class="koboSpan" id="kobo.1083.1"> components, even</span><a id="_idIndexMarker243"/><span class="koboSpan" id="kobo.1084.1"> though those components exist at a deeper level in the component tree. </span><span class="koboSpan" id="kobo.1084.2">You can perform state management for large-scale applications by using the context API and Hooks. </span><span class="koboSpan" id="kobo.1084.3">There’s a high chance you’ll get interview questions related to context implementation to solve</span><a id="_idIndexMarker244"/><span class="koboSpan" id="kobo.1085.1"> common use cases regarding maintaining</span><a id="_idIndexMarker245"/><span class="koboSpan" id="kobo.1086.1"> data globally in </span><span class="No-Break"><span class="koboSpan" id="kobo.1087.1">React applications.</span></span></p>
<h2 id="_idParaDest-103"><a id="_idTextAnchor102"/><span class="koboSpan" id="kobo.1088.1">What is prop drilling?</span></h2>
<p><span class="koboSpan" id="kobo.1089.1">Prop drilling refers to the process of sending props</span><a id="_idIndexMarker246"/><span class="koboSpan" id="kobo.1090.1"> from a higher-level component to a lower-level component in a component tree by going through several other components in the middle that don’t need the data but only help in passing it around. </span><span class="koboSpan" id="kobo.1090.2">This prop drilling term doesn’t exist in ReactJS officially, but it is frequently used to represent </span><span class="No-Break"><span class="koboSpan" id="kobo.1091.1">the situation.</span></span></p>
<h2 id="_idParaDest-104"><a id="_idTextAnchor103"/><span class="koboSpan" id="kobo.1092.1">Can you describe context?</span></h2>
<p><span class="koboSpan" id="kobo.1093.1">Context is used to solve</span><a id="_idIndexMarker247"/><span class="koboSpan" id="kobo.1094.1"> the prop drilling issue. </span><span class="koboSpan" id="kobo.1094.2">It provides a way to pass data from parent-level components to child components by storing the data in a central location without the need to pass the data manually at each level of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1095.1">component tree.</span></span></p>
<p><span class="koboSpan" id="kobo.1096.1">You can use context in React by following three </span><span class="No-Break"><span class="koboSpan" id="kobo.1097.1">simple steps:</span></span></p>
<ol>
<li><strong class="bold"><span class="koboSpan" id="kobo.1098.1">Create the context</span></strong><span class="koboSpan" id="kobo.1099.1">: The built-in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1100.1">createContext(defaultValue)</span></strong><span class="koboSpan" id="kobo.1101.1"> factory function</span><a id="_idIndexMarker248"/><span class="koboSpan" id="kobo.1102.1"> from the React library is used to create the context object. </span><span class="koboSpan" id="kobo.1102.2">It only accepts one argument to provide the default value. </span><span class="koboSpan" id="kobo.1102.3">Let’s create a user context with the </span><span class="No-Break"><span class="koboSpan" id="kobo.1103.1">default username:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1104.1">
// userContext.js
import { createContext } from 'react'; 
export const UserContext = createContext('Jonathan'); </span></pre></li> <li><strong class="bold"><span class="koboSpan" id="kobo.1105.1">Provide the context</span></strong><span class="koboSpan" id="kobo.1106.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1107.1">Context.Provider</span></strong><span class="koboSpan" id="kobo.1108.1"> component needs to be applied</span><a id="_idIndexMarker249"/><span class="koboSpan" id="kobo.1109.1"> to the parent component with the context changes that were supplied to its child components. </span><span class="koboSpan" id="kobo.1109.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1110.1">value</span></strong><span class="koboSpan" id="kobo.1111.1"> prop on this component is used to set the </span><span class="No-Break"><span class="koboSpan" id="kobo.1112.1">context value.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.1113.1">In this step, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1114.1">username</span></strong><span class="koboSpan" id="kobo.1115.1"> field is going to be updated with current user details as context for the </span><span class="No-Break"><span class="koboSpan" id="kobo.1116.1">provider component:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.1117.1">
import { UserContext } from './userContext'; 
function App() { 
  const value = 'Michael'; 
  return ( 
    &lt;Context.Provider value={value}&gt; 
      &lt;MyParentComponent /&gt; 
    &lt;/Context.Provider&gt; 
  ); 
} </span></pre><p class="list-inset"><span class="koboSpan" id="kobo.1118.1">The child components that need</span><a id="_idIndexMarker250"/><span class="koboSpan" id="kobo.1119.1"> to consume the context should be wrapped inside the </span><span class="No-Break"><span class="koboSpan" id="kobo.1120.1">provider component.</span></span></p></li> <li><strong class="bold"><span class="koboSpan" id="kobo.1121.1">Consume the context</span></strong><span class="koboSpan" id="kobo.1122.1">: The child components can consume</span><a id="_idIndexMarker251"/><span class="koboSpan" id="kobo.1123.1"> the context using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1124.1">useContext</span></strong><span class="koboSpan" id="kobo.1125.1"> Hook. </span><span class="koboSpan" id="kobo.1125.2">This Hook returns the value of </span><span class="No-Break"><span class="koboSpan" id="kobo.1126.1">the context:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1127.1">
import { useContext } from 'react'; 
import { UserContext } from './context'; 
function MyChildComponent() { 
  const currentUser = useContext(UserContext); 
  return &lt;span&gt;{currentUser}&lt;/span&gt;; 
} </span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.1128.1">You will learn more about the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1129.1">useContext</span></strong><span class="koboSpan" id="kobo.1130.1"> Hook in </span><a href="B18603_03.xhtml#_idTextAnchor110"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1131.1">Chapter 3</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1132.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1133.1">These steps have been represented with a diagram to help you understand context </span><span class="No-Break"><span class="koboSpan" id="kobo.1134.1">in action:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer024">
<span class="koboSpan" id="kobo.1135.1"><img alt="Figure 2.10: Context in action" src="image/Figure_02.10_B18603.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1136.1">Figure 2.10: Context in action</span></p>
<h2 id="_idParaDest-105"><a id="_idTextAnchor104"/><span class="koboSpan" id="kobo.1137.1">What is the purpose of context?</span></h2>
<p><span class="koboSpan" id="kobo.1138.1">The main purpose</span><a id="_idIndexMarker252"/><span class="koboSpan" id="kobo.1139.1"> of context is to allow your components to access global data without you facing any prop drilling problems and re-render the components when the global data has </span><span class="No-Break"><span class="koboSpan" id="kobo.1140.1">been changed.</span></span></p>
<p><span class="koboSpan" id="kobo.1141.1">Here are some of the common use cases</span><a id="_idIndexMarker253"/> <span class="No-Break"><span class="koboSpan" id="kobo.1142.1">of context:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1143.1">Theme information for applying branding to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1144.1">entire application</span></span></li>
<li><span class="koboSpan" id="kobo.1145.1">Authenticated user </span><span class="No-Break"><span class="koboSpan" id="kobo.1146.1">profile information</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.1147.1">User settings</span></span></li>
<li><span class="koboSpan" id="kobo.1148.1">Preferred </span><span class="No-Break"><span class="koboSpan" id="kobo.1149.1">language settings</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.1150.1">Application configuration</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1151.1">So far, we’ve learned how to render the React application on the client side. </span><span class="koboSpan" id="kobo.1151.2">In the next section, you will learn how to render web content on the server side to improve page loading speed, along with a few </span><span class="No-Break"><span class="koboSpan" id="kobo.1152.1">other benefits.</span></span></p>
<h1 id="_idParaDest-106"><a id="_idTextAnchor105"/><span class="koboSpan" id="kobo.1153.1">Understanding the server-side rendering technique</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.1154.1">SSR</span></strong><span class="koboSpan" id="kobo.1155.1"> is rapidly becoming a more</span><a id="_idIndexMarker254"/><span class="koboSpan" id="kobo.1156.1"> prominent feature in JavaScript libraries and frameworks. </span><span class="koboSpan" id="kobo.1156.2">React-based frameworks such as Next.js, Gatsby, and others make creating SSR much easier. </span><span class="koboSpan" id="kobo.1156.3">Nowadays, interviewers expect</span><a id="_idIndexMarker255"/><span class="koboSpan" id="kobo.1157.1"> a good knowledge of SSR, along with </span><span class="No-Break"><span class="koboSpan" id="kobo.1158.1">regular </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1159.1">CSR</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1160.1">.</span></span></p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor106"/><span class="koboSpan" id="kobo.1161.1">What is server-side rendering?</span></h2>
<p><span class="koboSpan" id="kobo.1162.1">SSR is a popular</span><a id="_idIndexMarker256"/><span class="koboSpan" id="kobo.1163.1"> alternative rendering method for </span><strong class="bold"><span class="koboSpan" id="kobo.1164.1">single-page applications</span></strong><span class="koboSpan" id="kobo.1165.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1166.1">SPAs</span></strong><span class="koboSpan" id="kobo.1167.1">). </span><span class="koboSpan" id="kobo.1167.2">This technique renders a client-side SPA on the server</span><a id="_idIndexMarker257"/><span class="koboSpan" id="kobo.1168.1"> and then sends a fully rendered HTML page to the client. </span><span class="koboSpan" id="kobo.1168.2">This is helpful for SEO purposes because search engines can easily find the content first before they send the page to </span><span class="No-Break"><span class="koboSpan" id="kobo.1169.1">the users.</span></span></p>
<h2 id="_idParaDest-108"><a id="_idTextAnchor107"/><span class="koboSpan" id="kobo.1170.1">What is the main difference between server-side rendering and client-side rendering?</span></h2>
<p><span class="koboSpan" id="kobo.1171.1">CSR is the rendering mode</span><a id="_idIndexMarker258"/><span class="koboSpan" id="kobo.1172.1"> in which the browser downloads</span><a id="_idIndexMarker259"/><span class="koboSpan" id="kobo.1173.1"> a minimal HTML page and it renders using JavaScript. </span><span class="koboSpan" id="kobo.1173.2">The data fetching, templating, and routing processes are handled on the client side – that is, by </span><span class="No-Break"><span class="koboSpan" id="kobo.1174.1">the browser.</span></span></p>
<p><span class="koboSpan" id="kobo.1175.1">SSR, on the other hand, converts HTML files on the server into a fully rendered HTML page that includes the data for </span><span class="No-Break"><span class="koboSpan" id="kobo.1176.1">the client.</span></span></p>
<h2 id="_idParaDest-109"><a id="_idTextAnchor108"/><span class="koboSpan" id="kobo.1177.1">When do you need to use server-side rendering?</span></h2>
<p><span class="koboSpan" id="kobo.1178.1">Which rendering method</span><a id="_idIndexMarker260"/><span class="koboSpan" id="kobo.1179.1"> is used depends on the requirements of the business. </span><span class="koboSpan" id="kobo.1179.2">But here, we have mentioned a few situations where you can consider </span><span class="No-Break"><span class="koboSpan" id="kobo.1180.1">using SSR:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1181.1">If you are prioritizing SEO and building a blog site, it is recommended to </span><span class="No-Break"><span class="koboSpan" id="kobo.1182.1">use SSR</span></span></li>
<li><span class="koboSpan" id="kobo.1183.1">If your website needs a faster initial page </span><span class="No-Break"><span class="koboSpan" id="kobo.1184.1">load time</span></span></li>
<li><span class="koboSpan" id="kobo.1185.1">If the application has a simple UI with less interactivity with a smaller number of features </span><span class="No-Break"><span class="koboSpan" id="kobo.1186.1">and pages</span></span></li>
<li><span class="koboSpan" id="kobo.1187.1">If the application contains less </span><span class="No-Break"><span class="koboSpan" id="kobo.1188.1">dynamic data</span></span></li>
<li><span class="koboSpan" id="kobo.1189.1">If the user traffic on the website </span><span class="No-Break"><span class="koboSpan" id="kobo.1190.1">is less</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1191.1">A few other pre-rendering</span><a id="_idIndexMarker261"/><span class="koboSpan" id="kobo.1192.1"> techniques are also available, such as </span><strong class="bold"><span class="koboSpan" id="kobo.1193.1">static site generation</span></strong><span class="koboSpan" id="kobo.1194.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1195.1">SSG</span></strong><span class="koboSpan" id="kobo.1196.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.1197.1">incremental static regeneration</span></strong><span class="koboSpan" id="kobo.1198.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1199.1">ISR</span></strong><span class="koboSpan" id="kobo.1200.1">), both of which will be</span><a id="_idIndexMarker262"/><span class="koboSpan" id="kobo.1201.1"> discussed in </span><a href="B18603_09.xhtml#_idTextAnchor276"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1202.1">Chapter 9</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1203.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1204.1">We have now answered </span><a id="_idIndexMarker263"/><span class="koboSpan" id="kobo.1205.1">a lot of fundamental questions about React. </span><span class="koboSpan" id="kobo.1205.2">This knowledge also acts as a foundation for answering the next stage of questions in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1206.1">upcoming chapters.</span></span></p>
<h1 id="_idParaDest-110"><a id="_idTextAnchor109"/><span class="koboSpan" id="kobo.1207.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1208.1">In this chapter, we discussed a lot of fundamental concepts that are frequently asked about in React interviews. </span><span class="koboSpan" id="kobo.1208.2">We started by introducing ReactJS and JSX and discussing their advantages in building robust web applications. </span><span class="koboSpan" id="kobo.1208.3">Then, we went on to talk about the core building blocks of ReactJS, such as elements, components, props, and state, and how the virtual DOM and one-way data flow work behind </span><span class="No-Break"><span class="koboSpan" id="kobo.1209.1">the scenes.</span></span></p>
<p><span class="koboSpan" id="kobo.1210.1">Lastly, we covered questions related to an application’s interaction through event handling and how to share data globally using context and SSR in the React ecosystem. </span><span class="koboSpan" id="kobo.1210.2">In the next chapter, we will consider questions related to Hooks, their importance, and how Hooks make React so much better by implementing functionalities faster and </span><span class="No-Break"><span class="koboSpan" id="kobo.1211.1">more effectively.</span></span></p>
</div>
</body></html>