- en: Simulate Your Backend with a Proxy API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用代理API模拟你的后端
- en: 'As we''ve been working through building up our application, we''ve done a ton
    of really great work but nearly all of it has been in this weird state where the
    data all lives completely inside of our React application. The reality is that
    this won''t be true for most projects you work on, so we''ll want to do a little
    bit of work to try to put the state of our Create React App project outside of
    React itself. To do that, we can take advantage of another feature in our Create
    React App world: proxy backends!'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们构建应用程序的过程中，我们已经做了大量的出色工作，但几乎所有的工作都处于一种奇怪的状态，数据完全存在于我们的React应用程序内部。但现实是，对于你将要工作的多数项目来说，这不会是事实，因此我们想要做一些工作，尝试将我们的Create
    React App项目的状态置于React本身之外。为此，我们可以利用Create React App世界中的另一个特性：代理后端！
- en: In addition, we'll need to spend a little bit of time talking about how we can
    actually get the data from that backend server into our Create React App project!
    A backend without a frontend isn't particularly useful, and vice versa! Similarly,
    a developer who has no understanding of either direction will be in a difficult
    situation, where they are designing systems with no sense of how they would need
    to interact with each other!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要花一点时间讨论如何将数据从后端服务器实际获取到我们的Create React App项目中！没有前端的后端并不特别有用，反之亦然！同样，一个对这两个方向都没有理解的开发者将处于一个困难的情况，他们设计系统时没有意识到它们需要如何相互交互！
- en: The simulated backend server we'll be building will act as the design document
    for our frontend developers to follow. It's not meant to be the final backend
    that we'll actually use, but rather, it will function as the framework that other
    developers can work with to better understand how to properly interact with our
    frontend and how to build a backend API that doesn't require us to completely
    rebuild our frontend!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的模拟后端服务器将作为我们前端开发人员遵循的设计文档。它并不是我们最终将使用的最终后端，而是作为一个框架，其他开发人员可以在此基础上工作，更好地理解如何正确地与我们的前端交互，以及如何构建一个不需要我们完全重建前端的后端API！
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Learning about the proxy feature
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解代理功能
- en: Implementing a quick `Express.js` server that should have a small footprint
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个占用空间小的快速`Express.js`服务器
- en: Learning a little bit about the React component methods
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习一点关于React组件方法的知识
- en: Getting data in or out of our backend proxy via Fetch
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Fetch从我们的后端代理获取或发送数据
- en: Updating our tests
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新我们的测试
- en: Simulating a backend server with the proxy API
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用代理API模拟后端服务器
- en: We've been building up our application over time with Create React App, but
    we've kept it almost entirely a frontend-only application. That's all well and
    good, but the reality is that you will probably be building an application that
    has a server behind it! The good news is that creating a simulated backend in
    Create React App projects remains as simple as possible while still giving you
    a good feel for how things would translate into a real-world scenario or project!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在使用Create React App构建我们的应用程序，但我们几乎将其完全保持为纯前端应用程序。这当然很好，但现实是，你可能会构建一个后面有服务器的应用程序！好消息是，在Create
    React App项目中创建模拟后端仍然尽可能简单，同时还能让你对现实世界场景或项目中的事物转换有一个良好的感觉！
- en: Setting up the backend API
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置后端API
- en: 'As mentioned, pretending there is a backend to our Create React App project
    requires very little effort and gets us back into development incredibly quickly.
    For us to take advantage of this, we''ll need to first set up a `"proxy"` in our
    `package.json` file. A proxy is a way for us to tell Create React App that any
    requests we make should go to this other server when it may look like we''re making
    requests locally, instead. Let''s start with configuring our project and then
    move on to implementing this further:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，假装我们的Create React App项目有一个后端需要付出非常少的努力，并且能让我们非常快地回到开发状态。为了利用这一点，我们首先需要在`package.json`文件中设置一个`"proxy"`。代理是一种让我们告诉Create
    React App，我们发出的任何请求都应该发送到这个其他服务器，即使它看起来像是在本地发出请求。让我们从配置我们的项目开始，然后继续实现这一功能：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We''ll also want to add a command to run and execute our server that we can
    easily run via `yarn`, so we''ll also need to update the `"scripts"` section of
    `package.json` to include a new command. We''ll arbitrarily name it `"backend"`
    so that when we''re ready to run our server, we just run the `yarn backend` command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望添加一个命令来运行和执行我们的服务器，这样我们就可以通过 `yarn` 容易地运行它，因此我们还需要更新 `package.json` 中的
    `"scripts"` 部分，以包含一个新的命令。我们将随意命名为 `"backend"`，这样当我们准备好运行我们的服务器时，我们只需运行 `yarn backend`
    命令即可：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This by itself won''t actually do anything. We''ll need to implement a `server`
    behind the scenes that can actually respond and react to any of the API calls
    that we''re making along the way. We''ll need another library in our project to
    do that, though, since by itself we can''t just simulate an API. We''ll need to
    add another library to our project that can handle the server and `HTTP` functionality. I
    personally prefer using `Express.js` for this, so we''ll use that as our library
    of choice for this project. In our command window, we''ll add express via `yarn`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 仅此还不够。我们需要在幕后实现一个 `server`，它能够对我们在过程中发出的任何 API 调用做出响应和反应。不过，由于我们本身无法模拟 API，我们还需要在我们的项目中添加另一个库来做这件事。我个人更喜欢使用
    `Express.js` 来做这件事，因此我们将选择它作为我们项目的库。在我们的命令窗口中，我们将通过 `yarn` 添加 express：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We then create a new file in the root of our Create React App project called
    `server.js`. This will act as the code that will serve all of the the requests
    that our application will be making to simulate a real-world scenario. Our server
    will not actually be stateful; instead, we will simulate that behavior through
    static data returned from our little, fake API.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在 Create React App 项目的根目录中创建一个新的文件，名为 `server.js`。这将成为服务所有我们应用程序将发出的请求的代码，以模拟现实世界的场景。我们的服务器实际上不会是状态化的；相反，我们将通过从我们的小型、虚假
    API 返回的静态数据来模拟这种行为。
- en: This section is going to be a little heavier on Node.js and Express concepts
    than React, since we need to be able to set up a quick server to act as our simulated
    backend!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个部分将比 React 更侧重于 Node.js 和 Express 概念，因为我们需要能够设置一个快速的服务器来充当我们的模拟后端！
- en: 'We''ll start off with a basic skeleton for our server, which will do a little
    bit of setup work that `express` requires from us. In `server.js`, in our root
    directory of our project, we will have the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从为我们的服务器创建一个基本的骨架开始，这将执行 `express` 从我们这里要求的一些设置工作。在 `server.js` 中，在我们的项目根目录中，我们将有以下内容：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We'll start off by loading Express into our server project. We'll need to pull
    this into our project via a `require()` statement rather than an `import()` statement,
    since we will be running this via Node. Next, we'll need to build out our server
    in our app variable, which is the instantiation of the `express.js` code. We'll
    also set the port that we'll run this on, which is the port we specified in our
    proxy configuration. I tend to pick ports in multiples of 1,000, but you can use
    whatever port numbers you personally prefer!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先将 Express 加载到我们的服务器项目中。由于我们将通过 Node 运行它，我们需要通过 `require()` 语句而不是 `import()`
    语句将其拉入我们的项目。接下来，我们需要在我们的应用程序变量中构建我们的服务器，这是 `express.js` 代码的实例化。我们还将设置我们将运行的端口，这是我们在代理配置中指定的端口。我倾向于选择
    1,000 的倍数作为端口，但你可以使用你个人偏好的任何端口号！
- en: Next, we'll need to tell our app to use the express JSON middleware, which will
    let us react and respond to JSON post body statements later on (we'll need this
    when we go to create a new `Todo` item in our server). After that, we have our
    first example of a route in our express server. This just returns, in JSON, an
    empty body when someone makes a request to the root of our proxy API backend.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要告诉我们的应用程序使用 express JSON 中间件，这将使我们能够对 JSON post body 语句做出反应和响应（当我们去创建服务器中的新
    `Todo` 项目时，我们将需要这样做）。之后，我们在我们的 express 服务器中有了第一个路由的例子。当有人对我们的代理 API 后端根目录发起请求时，它只是返回一个空的
    JSON 主体。
- en: Let’s spend a few minutes talking a little bit more about the structure of a
    route in express. While we won’t get into the full details and write the whole
    thing out from start to finish, it is worth at least understanding what a route
    is and how it is written in Express to avoid any confusion later on.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花几分钟时间更详细地讨论一下 Express 中路由的结构。虽然我们不会深入细节并从头到尾写出来，但至少了解什么是路由以及如何在 Express
    中编写路由是值得的，以避免以后产生任何混淆。
- en: A route is structured and written as `(the name of the express() variable).(HTTP
    method)(“path”, (request_variable, response_variable)` and then a function off
    of that. Every route should end with sending something back to the requester,
    and, in our case (since we’re writing a little API), it should be sending back
    some JSON.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 路由是结构化和编写的，形式为`(express()变量的名称).(HTTP方法)("path", (请求变量, 响应变量))`然后是一个基于该路径的函数。每个路由都应该以向请求者发送某些内容结束，在我们的情况下（因为我们正在编写一个小型API），应该发送一些JSON。
- en: This is enough for us to do right now; we'll be expanding on this configuration
    later on in this chapter!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这就足够我们目前使用了；我们将在本章后面的内容中进一步扩展这个配置！
- en: Middleware is a pipeline of functions that are executed in between the time
    the server sees the request, the request goes into the proper route, and then
    is returned back to the sender. In this case, all JSON bodies are converted into
    JSON so that we can read from them without a lot of extra code each time.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件是一系列函数，它们在服务器看到请求、请求进入正确的路由，然后返回给发送者的过程中执行。在这种情况下，所有JSON体都被转换为JSON，这样我们就可以在不添加大量额外代码的情况下每次都从中读取。
- en: Finally, we'll need to set up a listener for our application. We'll listen to
    the port that we specified earlier, and then specify a function that is to be
    executed when the app finishes listening on that port. In our case, we'll just
    have a little message that logs out letting us know that the server is set up
    and running correctly!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要设置一个监听器来监听我们的应用程序。我们将监听我们之前指定的端口，然后指定一个函数，当应用程序完成对该端口的监听时执行。在我们的情况下，我们只有一个简单的消息，它会记录下来，让我们知道服务器已设置并正确运行！
- en: This code is very minimal, but as a result of how minimal it is, it also requires
    some maintenance. For example, every time you make a change in the code, you will
    need to restart your backend server (not the Create React App project, though).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码非常简洁，但由于它的简洁性，它也需要一些维护。例如，每次你更改代码时，你都需要重新启动你的后端服务器（尽管不是Create React App项目）。
- en: Figuring out our backend requests
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定我们的后端请求
- en: 'To figure out how we''ll need to structure our API, it helps to take another
    look at the UI to identify different types of functions that can occur:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定我们将如何构建我们的API，重新查看UI以识别可能发生的不同类型的函数很有帮助：
- en: '![](img/39a2dbaa-8c05-40e4-a160-439cd93de7c0.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/39a2dbaa-8c05-40e4-a160-439cd93de7c0.png)'
- en: 'Looking at that UI, can you figure out what we need? We need representations
    of `Todo` items and a way to get the current list of them, and we need a way to
    change their state, to delete items, or to add new items. We''ll start off simple
    by implementing our index of Todos, but that will require an initial step of figuring
    out the data structure we''re going to use. First, we''ll need an object for each
    `todo`. Each `todo` will need the same representation as their internal objects:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 看看那个用户界面，你能弄清楚我们需要什么吗？我们需要`Todo`项的表示以及获取当前项列表的方法，我们还需要一种改变它们状态、删除项或添加新项的方法。我们将从实现`Todo`索引开始，但这需要先确定我们将要使用的数据结构。首先，我们需要为每个`todo`创建一个对象。每个`todo`都需要与它们的内部对象相同的表示：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We''ll also need a representation of some instances of internal `id`, so our
    new object would be as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一些内部`id`实例的表示，所以我们的新对象将是以下形式：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let's start off by constructing this in the server so we can get a good feel
    for how to handle this in the other actions later!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在服务器中构建这个开始，这样我们就可以在后面的操作中更好地了解如何处理它！
- en: Building the Todos index API request
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Todos索引API请求
- en: 'First, back in `server.js`, we''ll need to put together our list of `Todo`
    items. You''ll likely recognize these from the `Todo` items that we''ve used previously,
    with the exception of the fact that we now also have some `id` in the items as
    well. This is a closer representation to what we''d see normally in a server,
    where the items would not only contain their normal attributes but also form of
    primary keys as well. We''ll store these as a `const` since we don''t want to
    be able to accidentally overwrite them later:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，回到`server.js`，我们需要整理我们的`Todo`项列表。你可能会从之前使用的`Todo`项中认出这些项，除了我们现在在项中也有一些`id`之外。这更接近我们在服务器中通常看到的形式，其中项不仅包含它们的正常属性，还包含主键的形式。我们将这些存储为`const`，因为我们不希望不小心在以后覆盖它们：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To `get` these Todos out via the server, we''ll need to create a new route
    to an endpoint, `/api/todos`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过服务器`get`到这些Todos，我们需要创建一个指向端点的新的路由，`/api/todos`：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'First, you''ll need to start up the backend using `yarn backend`. Next, if
    we send a request via some network tool to send `HTTP` requests (for example,
    using Postman), we should be able to verify the results by making a `GET` request
    to `http://localhost:4000/api/todos`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要使用 `yarn backend` 启动后端。接下来，如果我们通过某些网络工具发送 `HTTP` 请求（例如，使用 Postman），我们应该能够通过向
    `http://localhost:4000/api/todos` 发送 `GET` 请求来验证结果：
- en: '![](img/1cc3c876-0284-41bd-8478-ea11bb19449d.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1cc3c876-0284-41bd-8478-ea11bb19449d.png)'
- en: We can also delete the `app.get("/"...)` line, since we no longer require that
    code.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以删除 `app.get("/"...)` 行，因为我们不再需要那段代码。
- en: There are a lot of ways to simulate requests to your backend. Similar to choices
    on code editors, Postman is my tool of choice for manually sending `HTTP` requests
    to verify the results, or you may already have tools available to you, such as
    CURL! Whatever you prefer to use should work just fine.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多方法可以模拟对后端的请求。类似于代码编辑器的选择，Postman 是我手动发送 `HTTP` 请求以验证结果的工具，或者你可能已经拥有可用的工具，例如
    CURL！无论你使用什么，都应该没问题。
- en: Building the add Todo API request
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建添加待办事项的 API 请求
- en: We'll also need to be able to create new Todos. To do that, we'll implement
    the next portion of our API, where we will create a route in `server.js` that
    is able to handle receiving an `HTTP` post with a body. Remember that line of
    code from earlier, where we instructed express to use the JSON middleware? The
    code for this isn't very complicated either. We specify to express that we can
    accept an `HTTP` post and give it the standard `req`, `res` arguments.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要能够创建新的待办事项。为此，我们将实现我们 API 的下一部分，在 `server.js` 中创建一个能够处理接收带有正文的 `HTTP` 请求的路由。记得之前的那行代码，我们指示
    express 使用 JSON 中间件？这个代码也不复杂。我们告诉 express 我们可以接受一个 `HTTP` 请求，并给它标准的 `req`，`res`
    参数。
- en: 'From there, since we only have a few items in our `Todo` list, we give the
    new `Todo` an `id` of the length of that list plus one, and then we fill it up
    with the rest of the body that is passed in by the user, using the object spread
    operator! As follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里开始，由于我们的 `Todo` 列表中只有几个条目，我们给新的 `Todo` 分配一个等于列表长度的 `id`，然后使用对象展开运算符填充用户传递的其余正文！如下所示：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Again, to verify that we''re doing things correctly, we''ll send a quick test
    via Postman with a `Todo` body and verify that we get sent back the list of Todos,
    plus the new one that we post in! Refer to the following screenshot:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，为了验证我们是否正确地做了事情，我们将通过 Postman 发送一个快速的测试，带有 `Todo` 正文，并验证我们是否收到了待办事项列表，以及我们发布的新的一个！参考以下截图：
- en: '![](img/11a5cd23-4615-4e7f-a508-1de0e94aa4f6.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/11a5cd23-4615-4e7f-a508-1de0e94aa4f6.png)'
- en: 'That''s all we need to add a new `Todo`, so now we can move on to the next
    piece of functionality: deleting a `Todo`!'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是我们添加新 `Todo` 所需要做的所有事情，所以现在我们可以继续到下一个功能：删除 `Todo`！
- en: Building the remove Todo API request
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建删除待办事项的 API 请求
- en: Deleting a `Todo` is equally simple! Much like accepting a post route, we have
    to accept a delete route and specify an `id` in the body. This will allow us to
    use a URL such as `/api/todos/3`, where `3` would be the `id` of the `Todo` we
    want to delete! We can access `params` in the URL via `req.params.[the name of
    the param]`. In the following case, the name of the param we specify is `:id`,
    which means the variable we can access is `req.params.id`!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 删除一个 `Todo` 也很简单！就像接受一个 post 路由一样，我们必须接受一个 delete 路由并在正文中指定一个 `id`。这将允许我们使用类似
    `/api/todos/3` 的 URL，其中 `3` 将是我们想要删除的 `Todo` 的 `id`！我们可以通过 `req.params.[参数名称]`
    访问 URL 中的 `params`。在以下情况下，我们指定的参数名称是 `:id`，这意味着我们可以访问的变量是 `req.params.id`！
- en: 'From there, we just `filter` out the instances of `id` that don''t match and
    call it a day! Remember that any `params` URLs are passed in as strings; that''s
    why we do a quick `parseInt()` on the `id` before our `filter` function! As follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，我们只需 `filter` 出不匹配的 `id` 实例，然后结束！记住，任何 `params` URL 都是以字符串形式传递的；这就是为什么我们在
    `filter` 函数之前对 `id` 进行快速 `parseInt()` 的原因！如下所示：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then we''ll run it in Postman and verify the results:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将在 Postman 中运行它并验证结果：
- en: '![](img/4650f2af-6eb4-4e3c-b0e5-42c2a0119957.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4650f2af-6eb4-4e3c-b0e5-42c2a0119957.png)'
- en: The React component life cycle for mounting
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React 组件的生命周期（挂载）
- en: We need to understand the React component life cycle for mounting components
    as well, since we'll need to hook into that later as part of hooking everything
    back up to our application. There are two main categories of phases when dealing
    with React components. The first is the **Render Phase**, where React is concerned
    about how the initial component is created and rendered to the page. You should
    keep these clean and without side-effects, so, as an example, we would not include
    any calls to our backend to fill in data or components on the page. The functions
    that are most commonly used here are `constructor()` and `render()`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要了解 React 组件的生命周期，以便挂载组件，因为我们稍后需要将其作为将一切重新连接到应用程序的一部分。处理 React 组件时，有两个主要的阶段。第一个是
    **渲染阶段**，在这个阶段，React 关注的是如何创建初始组件并将其渲染到页面上。你应该保持这些阶段干净，没有副作用，例如，我们不会包含任何调用后端以填充数据或页面上组件的调用。这里最常用的函数是
    `constructor()` 和 `render()`。
- en: 'The second phase, however, is the phase where we can modify things after the
    fact. The main function to mention here is `componentDidMount()`, which is where
    we can (and will) fire off requests to our backend server. The diagram for these
    calls might look something like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，第二个阶段是我们可以在事后修改事物的阶段。这里要提到的主函数是 `componentDidMount()`，我们可以在其中（并将会）向我们的后端服务器发起请求。这些调用的图示可能看起来像这样：
- en: '![](img/6af7a1b1-a73c-4fd2-ac2e-686c497629d9.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6af7a1b1-a73c-4fd2-ac2e-686c497629d9.png)'
- en: Where to put API requests
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API 请求的放置位置
- en: Based on that, we will have to create a `componentDidMount()` function that
    will contain the code that we need to fire off requests to our backend server,
    instead of sticking them in `constructor()` or in some other function! This ensures
    that our component will update and mount in a sane manner!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，我们将不得不创建一个 `componentDidMount()` 函数，它将包含我们需要向我们的后端服务器发起请求的代码，而不是将它们放在 `constructor()`
    或其他函数中！这确保了我们的组件将以合理的方式更新和挂载！
- en: Communicating with your proxy server with React
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 React 与你的代理服务器通信
- en: Now that we've written all of the code that we need for now on the server side
    of things, we'll need to modify our `TodoList` component to actually make calls
    out to the service that we wrote! The great news is that, yet again, everything
    we need to be able to do this already exists for us in our Create React App project!
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了服务器端所需的所有代码，我们需要修改我们的 `TodoList` 组件，以便真正调用我们编写的服务！好消息是，再次，我们需要的所有东西都已经存在于我们的
    Create React App 项目中！
- en: 'This is also a good opportunity for us to talk about another modern Javascript
    function: `Async`/`Await`!'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一个很好的机会，让我们来谈谈另一个现代 JavaScript 函数：`Async`/`Await`！
- en: Working with Async/Await
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Async/Await
- en: If we want to fetch data out of the server, the best tool for us to do that
    is by using some new Javascript syntax around asynchronous actions and calls!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想从服务器获取数据，最适合我们使用的工具就是通过一些新的 JavaScript 语法来处理异步操作和调用！
- en: 'This is called `Async`/`Await`, and is a method of performing operations that
    don''t require our application to completely hang, but will wait for results while
    processing other data. If you''re familiar with promises, you might be familiar
    with code that looks something like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为 `Async`/`Await`，是一种执行不需要应用程序完全挂起但会在处理其他数据的同时等待结果的操作方法。如果你熟悉承诺，你可能熟悉看起来像这样的代码：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is fine, but there is a better way to do this. This code can get particularly
    messy the larger it grows, and even more so if we introduce different branches
    or failure criteria and conditions we need to account for. Eventually, a mess
    of promises can turn into code that is just impossible to trace through when things
    go wrong, and we want to avoid that if we can.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可以的，但还有更好的方法来做这件事。随着代码的增长，这段代码可能会变得特别混乱，尤其是如果我们引入了不同的分支或需要考虑的失败标准时。最终，一串承诺可能会变成在出错时难以追踪的代码，我们希望尽量避免这种情况。
- en: Introducing Fetch
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Fetch
- en: 'The good news is that Fetch is also an incredibly simple library to work with!
    The syntax for it is simple and clear enough that it should be easy to understand
    what it does pretty quickly. Of course, that begs the question: what is Fetch?'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，Fetch 也是一个极其简单的库，易于使用！它的语法简单明了，应该很容易快速理解其功能。当然，这引发了一个问题：什么是 Fetch？
- en: The short answer is that Fetch is an `HTTP` request mechanism that has been
    made a first-class citizen in the Javascript world. The long answer is that Fetch
    is an attempt by the Javascript community and contributors to handle `HTTP` requests
    from Javascript code in a standardized way, instead of the multiple hundreds (or
    maybe even thousands) of different choices that all require their own implementations,
    patterns, configurations, and so on.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 简短的回答是，Fetch是一个`HTTP`请求机制，它已经被提升为JavaScript世界中的第一公民。更长的回答是，Fetch是JavaScript社区和贡献者尝试以标准化的方式处理JavaScript代码中的`HTTP`请求的尝试，而不是数百（甚至可能是数千）种不同的选择，每种选择都需要自己的实现、模式、配置等等。
- en: Fetch’s utility stems from it being ubiquitous and part of the Javascript language
    standard, although not every browser supports it fully yet. As such, instead of
    picking some other random library to work with, it is much easier for us to rely
    instead on the standard, knowing full well that the skills learned as you work
    with Fetch should transfer just fine into any other libraries that you might pick
    up and start using.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Fetch的实用性源于其无处不在，并且是JavaScript语言标准的一部分，尽管目前并非所有浏览器都完全支持它。因此，我们不必选择其他随机的库来工作，而是更容易依赖于标准，因为我们深知，你在使用Fetch时学到的技能应该可以很好地转移到你可能选择并开始使用的任何其他库中。
- en: Getting our list of Todos from the server
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从服务器获取待办事项列表
- en: To get Todos, we'll need to change how our state is built out. If you think
    back to our earliest implementations of the `TodoList` component, we built all
    of our Todos as an array of strings and then allowed our `Todo` component to do
    the rest of the work. This ends up not being a great model when we’re actually
    getting information in and out of our server, so we’ll want to transition ourselves
    over from relying on simple strings to store the information about the Todos to
    a model where the data structures for the Todos match both their component implementations
    and their data representations on the server side.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取待办事项，我们需要改变我们构建状态的方式。如果你回想起我们最早的`TodoList`组件实现，我们是将所有的待办事项作为一个字符串数组构建的，然后允许我们的`Todo`组件完成其余的工作。当我们实际上从服务器获取信息时，这种模型并不理想，因此我们希望从依赖于简单的字符串来存储待办事项信息过渡到一个模型，其中待办事项的数据结构与其组件实现和服务器端的数据表示相匹配。
- en: 'To start modifying `TodoList` to fit our new world, we''ll want to start with
    a blank list of Todos and a flag to capture whether the data has been loaded yet
    or not. In `src/TodoList/TodoList.js` add the following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始修改`TodoList`以适应我们的新世界，我们希望从一个空的待办事项列表和一个标志开始，这个标志用来捕获数据是否已经加载。在`src/TodoList/TodoList.js`中添加以下代码：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This `loaded` flag is actually pretty important; without it, we run into a scenario
    where when the page first loads, either the page looks blank or it displays *No
    items*, when in reality it just hasn’t loaded the full list of items yet! To create
    a better user experience, we’ll instead want to rely on a flag that tells the
    application whether it has completed loading and displays a message about that
    to the user, instead of relying on whether the `items state` property has values
    in it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`loaded`标志实际上非常重要；没有它，我们可能会遇到一个场景，即当页面首次加载时，页面看起来是空的，或者显示*无项*，而实际上它只是还没有加载完整的项列表！为了创造更好的用户体验，我们希望依赖于一个标志来告诉应用程序它是否已经完成加载，并向用户显示有关此的信息，而不是依赖于`items状态属性`中是否有值。
- en: 'If you remember from our server, `Todo` items will now be populated from the
    data structure that we created in our server file, so they can no longer just
    be the descriptions. This will require us to restructure some of our code, so
    we''ll go back through and fix up the code that is broken by this change. First,
    let''s add a new item:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得我们的服务器，`Todo`项现在将从我们在服务器文件中创建的数据结构中填充，因此它们不再只是描述。这将要求我们重构一些代码，所以我们将回过头来修复因这一变化而损坏的代码。首先，让我们添加一个新项：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It’s easier for us to break `newItem` into a separate variable and then pass
    that into the `setState()` call, otherwise we’d end up making that line of code
    really long and also very fragile in regards to any data-structure changes that
    might happen along the way:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 将`newItem`拆分成一个单独的变量然后传递给`setState()`调用对我们来说更容易，否则我们可能会使这一行代码变得非常长，而且对任何可能发生的数据结构变化来说也非常脆弱：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We also do a similar operation with our `removeTodo` call. We’ll move our list
    of filtered items, based on the description. Next, is our `renderItems()` call,
    which is also going to check the new state variable to see whether the data has
    been loaded from the server yet. Also, we’re going to pass in a few new properties
    to our `Todo` component to make it respect our data structure. Specifically, we’ll
    pass in the `id`, `done`, and `critical` flags to allow those to be set in `Todo`
    as part of the passed-in `props`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还对 `removeTodo` 调用执行了类似的操作。我们将根据描述移动过滤后的项目列表。接下来是 `renderItems()` 调用，它也将检查新的状态变量以确定数据是否已从服务器加载。此外，我们还将向
    `Todo` 组件传递一些新属性，使其遵守我们的数据结构。具体来说，我们将传递 `id`、`done` 和 `critical` 标志，以便在 `Todo`
    中作为传入的 `props` 部分设置：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Note that we''re passing in some new props to the `Todo` components, which
    means we''ll need to modify those to allow `state` to be set via `props` for whether
    a `Todo` is done and whether a `Todo` is critical. Open up `src/Todo/Todo.js`
    and we''ll take care of that really quickly in the `constructor()` function:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们向 `Todo` 组件传递了一些新的属性，这意味着我们需要修改它们以允许通过 `props` 设置 `state`，以便确定一个 `Todo`
    是否已完成以及一个 `Todo` 是否是关键的。打开 `src/Todo/Todo.js`，我们将在 `constructor()` 函数中迅速处理这个问题：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Head back to `src/TodoList/TodoList.js`, and let''s start writing our `Async`/`Await`
    functionality. We''ll create a new function that is part of the React standard
    component life cycle, `componentDidMount()`, where we will declare it as an `async`
    function. Remember that any place we want to use `await` in our code, we have
    to do so inside of a function that has been declared as `async`! We''ll start
    off with a simple body so that we can verify how it all works first, and then
    we''ll flesh it out a little more:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 `src/TodoList/TodoList.js`，让我们开始编写我们的 `Async`/`Await` 功能。我们将创建一个新的函数，它是 React
    标准组件生命周期的一部分，`componentDidMount()`，我们将将其声明为一个 `async` 函数。记住，我们想要在代码中使用 `await`
    的任何地方，都必须在已经声明为 `async` 的函数内部这样做！我们将从一个简单的主体开始，以便首先验证它的工作方式，然后我们会对其进行更多扩展：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we''ll need to use `fetch` to make the request to our simulated backend,
    where we will `await` the results of `fetch`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要使用 `fetch` 向我们的模拟后端发起请求，我们将 `await` `fetch` 的结果：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Remember that we are proxying requests to a different backend through Create
    React App! As a result, we don't need to specify a port or host, since it is pretending
    to be the same port/host.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们通过 Create React App 代理请求到不同的后端！因此，我们不需要指定端口或主机，因为它假装是相同的端口/主机。
- en: This backend server is meant to act as a placeholder for when you build a backend
    onto the same application or service as where this code runs for minimum latency.
    This is a great model for when you're building the frontend for something but
    the backend isn't fully built yet!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个后端服务器旨在作为当你在一个与代码运行相同的应用程序或服务上构建后端时的占位符，以实现最小延迟。当你正在构建某个前端但后端尚未完全构建时，这是一个非常好的模型！
- en: 'We''ll also need to take those results and convert them into JSON if we want
    to do anything with them, which is also an `async` call:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要对这些结果进行任何操作，我们还需要将它们转换为 JSON 格式，这也是一个 `async` 调用：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, don''t forget that our server returns data back in the following form:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，别忘了我们的服务器以以下形式返回数据：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'So finally, we need to replace the state of items to the new state:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 所以最后，我们需要将项目的状态替换为新状态：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And there we are! Now when the page refreshes, you should see the same list
    of components as before but now the data comes from our simulated backend instead!
    This should leave the full body of this function looking like the following code
    snippet:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！现在当页面刷新时，你应该看到与之前相同的组件列表，但现在数据来自我们的模拟后端！这应该让这个函数的完整体看起来像以下代码片段：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Creating a new Todo on the server
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在服务器上创建一个新的 Todo
- en: 'We''ll also want to be able to create a new `Todo` by using `HTTP` post to
    create a new `Todo`. This will also be an `async` function since we’ll be making
    an `async` call to `fetch` to send data. Since posting via `HTTP` is more complicated
    than getting, we’ll also need to specify some options into our `fetch` call. Specifically,
    we can configure the call by specifying the `HTTP` method (`POST` in our case),
    the headers (just an accept `header` for JSON data, which is the same as what
    we’d normally use to communicate with any JSON API), and the body of what we’re
    posting to the server, which is just the data structure of a new `Todo`. If it
    is successful, we will add the new `Todo` onto our state and call it a day. Back
    in `src/TodoList/TodoList.js`, as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望能够通过使用`HTTP` post来创建一个新的`Todo`。这也会是一个`async`函数，因为我们将会对`fetch`进行`async`调用以发送数据。由于通过`HTTP`
    post比获取更复杂，我们还需要在我们的`fetch`调用中指定一些选项。具体来说，我们可以通过指定`HTTP`方法（在我们的情况下是`POST`），头部（仅一个接受`header`的JSON数据，这与我们通常与任何JSON
    API通信时使用的是相同的），以及我们要发送到服务器的正文来配置调用，这只是一个新的`Todo`的数据结构。如果成功，我们将新的`Todo`添加到我们的状态中，然后结束。回到`src/TodoList/TodoList.js`，如下所示：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Deleting a Todo
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除待办事项
- en: 'Deleting a `Todo` is going to be very similar to creating a `Todo`, so there’s
    not actually that much that we have to describe here. The biggest and most important
    things are that the method is set to `DELETE` and the `id` of the `Todo` we want
    to delete is passed in via the URL:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 删除`Todo`的过程将与创建`Todo`非常相似，所以这里实际上没有太多需要描述的。最重要的事情是方法设置为`DELETE`，以及我们想要删除的`Todo`的`id`将通过URL传递：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We''ll also need to change how the `removeTodo` function is called from `src/Todo/Todo.js`,
    so open that file up and change the argument that it passes in to be by the Todo''s
    `id` instead of by its description! As follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更改从`src/Todo/Todo.js`中调用`removeTodo`函数的方式，所以打开该文件，并将它传递的参数更改为Todo的`id`而不是其描述！如下所示：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This should get us most of the functionality that we want, but the problem we
    have right now is that our code is not nearly as simple to test as we'd like.
    In fact, we actually have a few failing tests that we'll need to fix up!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该能让我们获得我们想要的绝大部分功能，但我们目前遇到的问题是我们的代码并不像我们希望的那样简单易测试。事实上，我们实际上有几个失败的测试需要修复！
- en: Getting back to passing tests
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回到通过测试
- en: Tests are failing. We'll start by hitting *u* to update our snapshots, then
    move on to working with our code to fix up the rest of the tests. The good news
    is that our tests for the `Todo` component are really easy to fix up! Remember
    that our `Todo` component takes in a few other properties to initialize now; as
    per our test, it really only takes in the `description` and `removeTodo` properties.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 测试失败了。我们将首先按`u`来更新我们的快照，然后继续与我们的代码一起工作，修复其余的测试。好消息是，我们的`Todo`组件的测试很容易修复！记住，我们的`Todo`组件现在接受一些其他属性来初始化；根据我们的测试，它实际上只接受`description`和`removeTodo`属性。
- en: Fixing the Todo test
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复待办事项测试
- en: 'We need to change our initialization of the shallow-rendered component to take
    in the `id`, `critical`, and `done` properties instead! In `src/Todo/Todo.test.js`,
    we''ll change the first failing test suite by changing the `const component` statement
    to include these additional properties:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更改我们的浅渲染组件的初始化，以接受`id`、`critical`和`done`属性！在`src/Todo/Todo.test.js`中，我们将通过将`const
    component`语句更改以包含这些额外的属性来更改第一个失败的测试套件：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Rerun the tests and now we should only be down to a single failing test suite!
    Unfortunately, this will also be the hardest test suite to fix!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行测试，现在我们应该只剩下单个失败的测试套件！不幸的是，这将也是最难修复的测试套件！
- en: Fixing our last failing test suite through refactoring
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过重构修复我们最后的失败的测试套件
- en: Unfortunately, our code now brings us into a scenario where our components are
    actually really hard to test appropriately. We have the code that has to fetch
    data off the backend mixed in with the code that initializes our components, as
    well as being mixed in with the behaviors when buttons are clicked! That's no
    good, so we'll need to fix this!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们的代码现在让我们陷入了一个场景，我们的组件实际上很难进行适当的测试。我们的代码必须从后端获取数据，与初始化我们的组件的代码混合，以及与按钮点击时的行为混合！这不行，所以我们需要修复这个问题！
- en: The good news is that the easiest way for us to fix this up doesn't require
    a mountain of effort; instead, it requires us to just move some of the code around
    in a way that would make it more extensible. The first operation we'll need to
    perform is moving all of our code that interacts with the backend into its own
    separate service library!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，我们修复这个问题的最简单方法不需要大量的努力；相反，它只需要我们将一些代码移动到使其更易于扩展的方式。我们首先需要执行的操作是将所有与后端交互的代码移动到它自己的独立服务库中！
- en: The service library pattern is a great pattern for when you need to lock down
    behaviors and interactions with external services into simpler APIs that make
    it easier for your code, or other people's code, to interact efficiently with
    a backend server!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 服务库模式是一个非常好的模式，当你需要将行为和与外部服务的交互锁定到更简单的 API 中时，这将使你的代码或他人的代码更容易高效地与后端服务器交互！
- en: Building service libraries
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建服务库
- en: 'We''ll start off by moving all of our API calls into a new file, `src/TodoService.js`.
    We''ll start with the simplest call, which is the call to `fetchTodos` items from
    the server:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从将所有 API 调用移动到一个新文件 `src/TodoService.js` 开始。我们将从最简单的调用开始，即从服务器获取 `fetchTodos`
    项目：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, we've written our `fetchTodos()` function as an `async` function that,
    for the most part, does what it did originally. The only major different here
    is that we've changed the `return` statement to not just send back the list of
    `todos` from the server, but also the `HTTP` status code from the server!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将我们的 `fetchTodos()` 函数编写为一个 `async` 函数，大部分功能与最初相同。这里唯一的重大不同是，我们将 `return`
    语句改为不仅从服务器发送回 `todos` 列表，还发送服务器的 `HTTP` 状态码！
- en: 'Next, we''ll implement the call to create a `Todo` on the server:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现创建服务器上的 `Todo` 的调用：
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Again, this post is almost identical to what you saw previously, except with
    the modification around the `return` statement. Finally, we''ll move on to the
    delete call on our server:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这篇文章几乎与你之前看到的一样，只是对 `return` 语句进行了修改。最后，我们将继续进行服务器上的删除调用：
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We''ve added a few functions, so we''ll `export` them at the end of the service
    library. All we need to do is `export` these three functions as named functions:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一些函数，所以我们将它们在服务库的末尾 `export`。我们只需要将这些三个函数作为命名函数 `export`：
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Implementing our service library in TodoList
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 TodoList 中实现服务库
- en: 'Now that we have our `TodoService` library, we have to go back to our `src/TodoList/TodoList.js`
    file and find all of the areas where we used to have the `fetch` code written
    into our component. We''ll need to start off at the top of our file by importing
    those three named functions from our `TodoService`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 `TodoService` 服务库，我们必须回到我们的 `src/TodoList/TodoList.js` 文件，找到我们曾经在我们的组件中写入
    `fetch` 代码的所有区域。我们需要从文件的顶部开始，导入来自 `TodoService` 的这三个命名函数：
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, we''ll need to go into our `componentDidMount()` function, where we''ll
    modify it to call the `fetchTodos()` function instead:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要进入我们的 `componentDidMount()` 函数，我们将对其进行修改以调用 `fetchTodos()` 函数：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Look at how nice and clean that function is now! This is definitely a move
    for the better, no matter what! Now, let''s move on to our `addTodo()` function
    call:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个函数现在多么干净漂亮！这绝对是一个向好的方向发展的举措！现在，让我们继续到我们的 `addTodo()` 函数调用：
- en: '[PRE32]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, we''ll modify our `removeTodo()` function:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将修改我们的 `removeTodo()` 函数：
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This will get us most of the way back toward fixing our failing tests, but the
    last place we need to get some work done is in the failing tests themselves.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们大部分回到修复失败的测试，但我们还需要在失败的测试本身做一些工作。
- en: Finally fixing our last failing test suite
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后修复我们失败的测试套件
- en: First, head on over to the failing test suite, `src/TodoList/TodoList.test.js`,
    where we will need to create something in Jest called a **mock library**. A mock
    library is basically just a way for us to tell Jest that we need to fake the behavior
    of a particular `import` module so that, whenever it is used, our fake mock functions
    will be used instead. This will allow us to mock the behavior of the entire service
    library that we wrote, allowing us to test our components and verify functionality
    without needing tests that actually make calls to some backend API somewhere!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，前往失败的测试套件，`src/TodoList/TodoList.test.js`，在那里我们需要在 Jest 中创建一个 **mock 库**。mock
    库基本上是我们告诉 Jest 我们需要伪造一个特定的 `import` 模块的行为，这样，无论何时使用它，我们的伪造 mock 函数都将被使用。这将允许我们伪造我们编写的整个服务库的行为，使我们能够测试我们的组件并验证功能，而无需实际调用某个后端
    API 的测试！
- en: 'We''ll start the top of our test file, underneath our `import` statements,
    by adding the library mock and three `mock` functions:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在测试文件的顶部，在`import`语句之下，添加库模拟和三个`mock`函数：
- en: '[PRE34]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We're writing these in a way that the functions will always work, always return
    an empty list of `todos`, and will always return a fake `HTTP` status `200` code!
    With that out of the way, we can clean up our failing tests.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写这些代码的方式是，函数始终会工作，始终返回一个空的`todos`列表，并且始终返回一个假的`HTTP`状态码`200`！处理完这些之后，我们可以清理失败的测试。
- en: 'The two tests that are failing are doing so because the behavior is erratic
    when we''re dealing with non-async tests that deal with `async` functionality!
    We can instead write our tests—similar to how we write the rest of our function
    calls—to be `async` functions! Think about the structure of a test declaration:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 失败的两个测试是因为当我们处理非异步测试且涉及`async`功能时，行为是随机的！我们可以将我们的测试写成`async`函数，类似于我们写其他函数调用一样！想想测试声明的结构：
- en: '[PRE35]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If we wanted to instead make that test async-capable, we would instead write
    our test declaration as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要使那个测试异步化，我们就会将测试声明写成如下：
- en: '[PRE36]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Bearing that in mind, let''s take a look at the corrected function:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们看看修正后的函数：
- en: '[PRE37]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'It''s not dramatically different from the test we had previously, with the
    addition of the call to `addTodo()` requiring an `await` statement. Now let''s
    take a look at our test for `removeTodo()`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前进行的测试相比，并没有太大的不同，只是增加了对`addTodo()`的调用需要`await`语句。现在让我们来看看我们对`removeTodo()`的测试：
- en: '[PRE38]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You might get an error message about the first test, the test where it tries
    to render a component without crashing. Our new `async`/`await` additions make
    this test no longer viable, so just delete it! Run the tests now, and we should
    see the follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会收到关于第一个测试的错误信息，即尝试渲染组件而不崩溃的测试。由于我们新的`async`/`await`添加，这个测试不再可行，所以只需删除它！现在运行测试，我们应该看到以下结果：
- en: '[PRE39]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: There we are, back to a fully-passing suite of tests!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们又回到了一个完全通过测试的套件！
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we spent a fair amount of time exploring our options for making,
    simulating, and running a backend server alongside our Create React App project.
    This allows us to pass projects off to other teams where they know the implicit
    data structure contracts that need to exist as part of the development process
    between frontend and backend development teams.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们花了不少时间探索了在Create React App项目旁边制作、模拟和运行后端服务器的选项。这使我们能够将项目转交给其他团队，他们知道在前后端开发团队之间作为开发过程一部分需要存在的隐式数据结构合约。
- en: We also spent a good chunk of time exploring our options for retrieving data
    from inside a React project out to a server! This is only one possible option
    for implementation out of many; in general, Javascript projects tend to have a
    ton of different (and all equally good in their own rights) ways to implement
    a lot of common functionality. Using Fetch and a service library is just one possible
    way to do this, but it's a way that I've personally found a lot of success with
    and tend to stick with, unless I see a need to do something more complicated.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还花了不少时间探索了从React项目内部检索数据到服务器的选项！这只是许多实现方式中的一种；一般来说，JavaScript项目往往有大量的（并且每种方式都有其自身的优点）实现许多常见功能的方法。使用Fetch和库服务只是实现这一点的可能方式之一，但这是我个人发现非常成功并且倾向于坚持的方式，除非我看到需要做更复杂的事情。
- en: 'In the next chapter, we''ll explore some of the more progressive options for
    supporting a web application in a way that supports both mobile users and users
    with poor internet connections: progressive web apps! Create React App ships with
    really great support for building progressive web applications right out of the
    gate, so we''ll take a deep dive into building a progressive web app, what functionality
    and opportunities that affords us, and how we can take advantage of that to make
    a truly modern React application, all while remaining inside the confines of our
    Create React App project!'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨一些更先进的选择，以支持以支持移动用户和互联网连接较差的用户的方式构建Web应用程序：渐进式Web应用程序！Create React
    App自带构建渐进式Web应用程序的出色支持，因此我们将深入探讨构建渐进式Web应用程序，它为我们提供了哪些功能和机会，以及我们如何利用这些功能来制作一个真正现代的React应用程序，同时仍然保持在Create
    React App项目的范围内！
