<html><head></head><body>
		<div>
			<div id="_idContainer330" class="Content">
			</div>
		</div>
		<div id="_idContainer331" class="Content">
			<h1 id="_idParaDest-244"><a id="_idTextAnchor325"/>12. Unit Testing</h1>
		</div>
		<div id="_idContainer360" class="Content">
			<p class="callout-heading"><a id="_idTextAnchor326"/><a id="_idTextAnchor327"/>Overview</p>
			<p class="callout">In this chapter, we will look at approaches to unit testing Vue.js applications in order to improve our quality and speed of delivery. We will also look at using tests to drive development using T<strong class="bold">est-Driven Development </strong>(<strong class="bold">TDD</strong>).</p>
			<p class="callout">As we proceed, you will gain an understanding of why code needs to be tested and what kinds of testing can be employed on different parts of a Vue.js application. You will see how to unit test isolated components and their methods using shallow rendering and <strong class="source-inline">vue-test-utils</strong>, and you will learn how to test asynchronous component code. Throughout the course of the chapter, you will gain familiarity with techniques to write efficient unit tests for <strong class="bold">mixins</strong> and <strong class="bold">filters</strong>. Toward the end of the chapter, you will become familiar with approaches to testing a Vue.js applications that includes routing and Vuex, and you will learn about using snapshot tests to validate your user interface.</p>
			<h1 id="_idParaDest-245"><a id="_idTextAnchor328"/>Introduction</h1>
			<p>In this chapter, we will look at the purpose and approaches to testing Vue.js applications effectively.</p>
			<p>In previous chapters, we saw how to build reasonably complex Vue.js applications. This chapter is about testing them to maintain code quality and prevent defects.</p>
			<p>Unit testing will allow us to write fast and specific tests that we can develop against and ensure that features don't exhibit unwanted behavior. We'll see how to write unit tests for different parts of a Vue.js application, such as components, mixins, filters, and routing. We will use tools supported by the Vue.js core team, such as <strong class="source-inline">vue-test-utils</strong>, and tools supported by the rest of the open source community, such as the Vue Testing library and the <strong class="bold">Jest testing framework</strong>. These different tools will serve to illustrate different philosophies and approaches to unit testing.</p>
			<h1 id="_idParaDest-246"><a id="_idTextAnchor329"/>Why We Need to Test Code</h1>
			<p>Testing is crucial for ensuring that the code does what it's meant to do.</p>
			<p>Quality production software is empirically correct. That means that for the enumerated cases that developers and testers have found, the application behaves as expected.</p>
			<p>This lies in contrast with software that has <em class="italic">proven</em> to be correct, which is a very time-consuming endeavor and is usually part of academic research projects. We are still at the point where <strong class="bold">correct software</strong> (proven) is still being built to show what kinds of systems are possible to build with this constraint of correctness.</p>
			<p>Testing prevents the introduction of defects such as bugs and regressions (that is, when a feature stops working as expected). In the next section, we will learn about the various types of testing.</p>
			<h1 id="_idParaDest-247"><a id="_idTextAnchor330"/>Understanding Different Types of Testing</h1>
			<p>The testing spectrum spans from end-to-end testing (by manipulating the user interface) to integration tests, and finally to unit tests. End-to-end tests test everything, including the user interface, the underlying HTTP services, and even database interactions; nothing is mocked. For example, if you've got an e-commerce application, an end-to-end test might actually place a real order with a real credit card, or it might place a test order, with a test credit card.</p>
			<p>End-to-end tests are costly to run and maintain. They require the use of full-blown browsers controlled through programmatic drivers such as <strong class="bold">Selenium</strong>, <strong class="bold">WebdriverIO</strong>, or <strong class="bold">Cypress</strong>. This type of test platform is costly to run, and small changes in the application code can cause end-to-end tests to start failing.</p>
			<p>Integration or system-level tests ensure that a set of systems is working as expected. This will usually involve deciding on a limit as to where the <strong class="bold">system under test</strong> lies and allowing it to run, usually against mocked or stubbed upstream services and systems (which are therefore not under test). Since external data access is stubbed, a whole host of issues, such as timeouts and flakes, can be reduced (when compared to end-to-end tests). Integration test suites are usually fast enough to run as a continuous integration step, but the full test suite tends not to be run locally by engineers.</p>
			<p>Unit tests are great at providing fast feedback during development. Unit testing paired with TDD is part of extreme programming practice. Unit tests are great at testing complicated logic or building a system from its expected output. Unit tests are usually fast enough to run that developers code against them before sending their code for review and continuous integration tests.</p>
			<p>The following is an interpretation of the pyramid of testing. It can be interpreted as: you should have a high number of cheap and fast unit tests, a reasonable number of system tests, and a few end-to-end UI tests:</p>
			<div>
				<div id="_idContainer332" class="IMG---Figure">
					<img src="image/B15218_12_01.jpg" alt="Figure 12.1: Pyramid of testing diagram&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.1: Pyramid of testing diagram</p>
			<p>Now that we've looked at why we should be testing applications, let's start writing some tests.</p>
			<h1 id="_idParaDest-248">Y<a id="_idTextAnchor331"/>our First Test</h1>
			<p>To illustrate how quick and easy it is to get started with automated unit tests in a Vue CLI project, we will start by setting up and writing a unit test with Jest, <strong class="source-inline">@vue-test-utils</strong>. There is an official Vue CLI package that can be used to generate a setup that includes unit testing with Jest and <strong class="source-inline">vue-test-utils</strong>. The following command should be run in a project that has been set up with Vue CLI:</p>
			<p class="source-code">vue add @vue/unit-jest</p>
			<p>Vue CLI adds Jest as the test runner, <strong class="source-inline">@vue/test-utils</strong>, the official <strong class="source-inline">Vue.js</strong> testing utilities, and <strong class="source-inline">vue-jest</strong>, a processor for <strong class="source-inline">.vue</strong> single-file component files in Jest. It adds a <strong class="source-inline">test:unit</strong> script.</p>
			<p>By default, it creates a <strong class="source-inline">tests/unit</strong> folder, which we'll remove. Instead, we can create a <strong class="source-inline">__tests__</strong> folder and create an <strong class="source-inline">App.test.js</strong> file as follows.</p>
			<p>We will use <strong class="source-inline">shallowMount</strong> to render the application and test that it displays the correct text. For the purposes of this example, we'll use the text: "<strong class="source-inline">The Vue.js Workshop Blog</strong>". </p>
			<p><strong class="source-inline">shallowMount</strong> does a <strong class="bold">shallow render</strong>, which means that only the top level of a component is rendered; all the child components are stubbed. This is useful for testing a component in isolation since the child components' implementations are not run:</p>
			<p class="source-code">import { shallowMount } from '@vue/test-utils'</p>
			<p class="source-code">import App from '../src/App.vue'</p>
			<p class="source-code">test('App renders blog title correctly', () =&gt; {</p>
			<p class="source-code">  const wrapper = shallowMount(App)</p>
			<p class="source-code">  expect(wrapper.text()).toMatch("The Vue.js Workshop Blog")</p>
			<p class="source-code">})</p>
			<p>This test will fail when we run <strong class="source-inline">npm run test:unit</strong> because we do not have <strong class="source-inline">The Vue.js Workshop Blog</strong> in the <strong class="source-inline">App</strong> component:</p>
			<div>
				<div id="_idContainer333" class="IMG---Figure">
					<img src="image/B15218_12_02.jpg" alt="Figure 12.2: Blog title heading failing the test at the command line&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.2: Blog title heading failing the test at the command line</p>
			<p>In order to get the test to pass, we can implement our blog title heading in the <strong class="source-inline">App.vue</strong> file:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div id="app" class="p-10"&gt;</p>
			<p class="source-code">    &lt;div class="flex flex-col"&gt;</p>
			<p class="source-code">      &lt;h2</p>
			<p class="source-code">        class="leading-loose pb-4 flex justify-center m-auto           md:w-1/3 text-xl mb-8 font-bold text-gray-800 border-b"</p>
			<p class="source-code">      &gt;</p>
			<p class="source-code">      The Vue.js Workshop Blog</p>
			<p class="source-code">      &lt;/h2&gt;</p>
			<p class="source-code">    &lt;/div&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p>Now that we have got the right heading, <strong class="source-inline">npm run test:unit</strong> will pass:</p>
			<div>
				<div id="_idContainer334" class="IMG---Figure">
					<img src="image/B15218_12_03.jpg" alt="Figure 12.3: Blog heading test passing&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.3: Blog heading test passing</p>
			<p>We can also check that it renders as expected in the browser:</p>
			<p class="source-code">The Vue.js Workshop Blog</p>
			<p>You have just completed your first piece of TDD. This process started by writing a test that failed. This failure was followed by an update to the code under test (in this case the <strong class="source-inline">App.vue</strong> component), which made the failing test pass. The TDD process gives us confidence that our features have been tested properly since we can see that tests fail before they pass when we update the code that drives our feature.</p>
			<h1 id="_idParaDest-249">Tes<a id="_idTextAnchor332"/>ting Components</h1>
			<p>Components are at the core of Vue.js applications. Writing unit tests for them is straightforward with <strong class="source-inline">vue-test-utils</strong> and Jest. Having tests that exercise the majority of your components gives you confidence that they behave as designed. Ideal unit tests for components run quickly and are simple.</p>
			<p>We'll carry on building the blog application example. We have now built the heading, but a blog usually also needs a list of posts to display.</p>
			<p>We'll create a <strong class="source-inline">PostList</strong> component. For now, it will just render a <strong class="source-inline">div</strong> wrapper and support a <strong class="source-inline">posts</strong> <strong class="source-inline">Array</strong> prop:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div class="flex flex-col w-full"&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  props: {</p>
			<p class="source-code">    posts: {</p>
			<p class="source-code">      type: Array,</p>
			<p class="source-code">      default: () =&gt; []</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>We can add some data in the <strong class="source-inline">App</strong> component:</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  data() {</p>
			<p class="source-code">    return {</p>
			<p class="source-code">      posts: [</p>
			<p class="source-code">        {</p>
			<p class="source-code">          title: 'Vue.js for React developers',</p>
			<p class="source-code">          description: 'React has massive popularity here are the             key benefits of Vue.js over it.',</p>
			<p class="source-code">          tags: ['vue', 'react'],</p>
			<p class="source-code">        },</p>
			<p class="source-code">        {</p>
			<p class="source-code">          title: 'Migrating an AngularJS app to Vue.js',</p>
			<p class="source-code">          description: 'With many breaking changes, AngularJS developers             have found it easier to retrain to Vue.js than Angular 2',</p>
			<p class="source-code">          tags: ['vue', 'angularjs']</p>
			<p class="source-code">        }</p>
			<p class="source-code">      ]</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>Now that we have some posts, we can pass them as a bound prop to the <strong class="source-inline">PostList</strong> component from the <strong class="source-inline">App</strong> component:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;!-- rest of template --&gt;</p>
			<p class="source-code">        &lt;PostList :posts="posts" /&gt;</p>
			<p class="source-code">  &lt;!-- rest of template --&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">import PostList from './components/PostList.vue'</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  components: {</p>
			<p class="source-code">    PostList</p>
			<p class="source-code">  },</p>
			<p class="source-code">  // rest of component properties</p>
			<p class="source-code">}</p>
			<p>Our <strong class="source-inline">PostList</strong> component will render out each post in a <strong class="source-inline">PostListItem</strong> component, which we'll create as follows.</p>
			<p><strong class="source-inline">PostListItem</strong> takes two props: <strong class="source-inline">title</strong> (which is a string) and <strong class="source-inline">description</strong> (also a string). It renders them in an <strong class="source-inline">h3</strong> tag and a <strong class="source-inline">p</strong> tag, respectively:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div class="flex flex-col m-auto w-full md:w-3/5 lg:w-2/5 mb-4"&gt;</p>
			<p class="source-code">    &lt;h3 class="flex text-md font-semibold text-gray-700"&gt;</p>
			<p class="source-code">      {{ title }}&lt;/h3&gt;</p>
			<p class="source-code">    &lt;p class="flex leading-relaxed"&gt;{{ description }}&lt;/p&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  props: {</p>
			<p class="source-code">    title: {</p>
			<p class="source-code">      type: String</p>
			<p class="source-code">    },</p>
			<p class="source-code">    description: {</p>
			<p class="source-code">      type: String</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>We now need to loop through the posts and render out a <strong class="source-inline">PostListItem</strong> component with relevant props bound in the <strong class="source-inline">PostList.vue</strong> component:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  !-- rest of template --&gt;</p>
			<p class="source-code">    &lt;PostListItem</p>
			<p class="source-code">      v-for="post in posts"</p>
			<p class="source-code">      :key="post.slug"</p>
			<p class="source-code">      :title="post.title"</p>
			<p class="source-code">      :description="post.description"</p>
			<p class="source-code">    /&gt;</p>
			<p class="source-code">  &lt;!-- rest of template --&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">import PostListItem from './PostListItem.vue'</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  components: {</p>
			<p class="source-code">    PostListItem,</p>
			<p class="source-code">  },</p>
			<p class="source-code">  // rest of component properties</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>We can now see the heading and the post list in the application:</p>
			<p class="source-code">The Vue.js Workshop blog</p>
			<p>To test the <strong class="source-inline">PostListItem</strong> component, we can shallow render with some arbitrary <strong class="source-inline">title</strong> and <strong class="source-inline">description</strong> props set, and check that they get rendered:</p>
			<p class="source-code">import { shallowMount } from '@vue/test-utils'</p>
			<p class="source-code">import PostListItem from '../src/components/PostListItem.vue'</p>
			<p class="source-code">test('PostListItem renders title and description correctly',   () =&gt; {</p>
			<p class="source-code">  const wrapper = shallowMount(PostListItem, {</p>
			<p class="source-code">    propsData: {</p>
			<p class="source-code">      title: 'Blog post title',</p>
			<p class="source-code">      description: 'Blog post description'</p>
			<p class="source-code">    }</p>
			<p class="source-code">  })</p>
			<p class="source-code">  expect(wrapper.text()).toMatch("Blog post title")</p>
			<p class="source-code">  expect(wrapper.text()).toMatch("Blog post description")</p>
			<p class="source-code">})</p>
			<p>The test output of <strong class="source-inline">npm run test:unit __tests__/PostListItem.test.js</strong> is as follows; the component passes the test:</p>
			<div>
				<div id="_idContainer335" class="IMG---Figure">
					<img src="image/B15218_12_04.jpg" alt="Figure 12.4: PostListItem test output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.4: PostListItem test output</p>
			<p>Next, we'll see one of the pitfalls of shallow rendering. When testing the <strong class="source-inline">PostList</strong> component, all we can do is test the number of <strong class="source-inline">PostListItem</strong> components it's rendering:</p>
			<p class="source-code">import { shallowMount } from '@vue/test-utils'</p>
			<p class="source-code">import PostList from '../src/components/PostList.vue'</p>
			<p class="source-code">import PostListItem from '../src/components/PostListItem.vue'</p>
			<p class="source-code">test('PostList renders the right number of PostListItem',   () =&gt; {</p>
			<p class="source-code">  const wrapper = shallowMount(PostList, {</p>
			<p class="source-code">    propsData: {</p>
			<p class="source-code">      posts: [</p>
			<p class="source-code">        {</p>
			<p class="source-code">          title: "Blog post title",</p>
			<p class="source-code">          description: "Blog post description"</p>
			<p class="source-code">        }</p>
			<p class="source-code">      ]</p>
			<p class="source-code">    }</p>
			<p class="source-code">  })</p>
			<p class="source-code">  expect(wrapper.findAll(PostListItem)).toHaveLength(1)</p>
			<p class="source-code">})</p>
			<p>This passes, but we are testing something that the user will not directly interact with, the number of <strong class="source-inline">PostListItem</strong> instances rendered in <strong class="source-inline">PostList</strong>, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer336" class="IMG---Figure">
					<img src="image/B15218_12_05.jpg" alt="Figure 12.5: PostList test output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.5: PostList test output</p>
			<p>A better solution is to use the <strong class="source-inline">mount</strong> function, which renders the full component tree, whereas the <strong class="source-inline">shallow</strong> function would only render out the children of the component being rendered. With <strong class="source-inline">mount</strong>, we can assert that the titles and descriptions are rendered to the page.</p>
			<p>The drawback of this approach is that we're testing both the <strong class="source-inline">PostList</strong> component and the <strong class="source-inline">PostListItem</strong> component since the <strong class="source-inline">PostList</strong> component doesn't render the title or description; it renders a set of <strong class="source-inline">PostListItem</strong> components that in turn render the relevant title and description.</p>
			<p>The code will be as follows:</p>
			<p class="source-code">import { shallowMount, mount } from '@vue/test-utils'</p>
			<p class="source-code">import PostList from '../src/components/PostList.vue'</p>
			<p class="source-code">// other imports and tests</p>
			<p class="source-code">test('PostList renders passed title and description for each   passed post', () =&gt; {</p>
			<p class="source-code">  const wrapper = mount(PostList, {</p>
			<p class="source-code">    propsData: {</p>
			<p class="source-code">      posts: [</p>
			<p class="source-code">        {</p>
			<p class="source-code">          title: 'Title 1',</p>
			<p class="source-code">          description: 'Description 1'</p>
			<p class="source-code">        },</p>
			<p class="source-code">        {</p>
			<p class="source-code">          title: 'Title 2',</p>
			<p class="source-code">          description: 'Description 2'</p>
			<p class="source-code">        }</p>
			<p class="source-code">      ]</p>
			<p class="source-code">    }</p>
			<p class="source-code">  })</p>
			<p class="source-code">  const outputText = wrapper.text()</p>
			<p class="source-code">  expect(outputText).toContain('Title 1')</p>
			<p class="source-code">  expect(outputText).toContain('Description 1')</p>
			<p class="source-code">  expect(outputText).toContain('Title 2')</p>
			<p class="source-code">  expect(outputText).toContain('Description 2')</p>
			<p class="source-code">})</p>
			<p>The new tests pass as per the following output of <strong class="source-inline">npm run test:unit __tests__/PostList.vue</strong>:</p>
			<div>
				<div id="_idContainer337" class="IMG---Figure">
					<img src="image/B15218_12_06.jpg" alt="Figure 12.6: Test run for PostList with both shallow and mounted tests&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.6: Test run for PostList with both shallow and mounted tests</p>
			<p>We have now seen how to write unit tests for Vue.js components using Jest and <strong class="source-inline">vue-test-utils</strong>. These tests can be run often, and test runs complete within seconds, which gives us near-immediate feedback while working on new or existing components.</p>
			<h2 id="_idParaDest-250">Exerci<a id="_idTextAnchor333"/>se 12.01: Building and Unit Testing a Tag List Component</h2>
			<p>When creating the fixture for <strong class="source-inline">posts</strong>, we populated a <strong class="source-inline">tags</strong> field with <strong class="source-inline">vue</strong>, <strong class="source-inline">angularjs</strong>, and <strong class="source-inline">react</strong> but did not display them. To make tags useful, we will display the tags in the post list.</p>
			<p>To access the code files for this exercise, refer to <a href="https://packt.live/2HiTFQ1">https://packt.live/2HiTFQ1</a>:</p>
			<ol>
				<li>We can start by writing a unit test that will explain what we expect a <strong class="source-inline">PostListItem</strong> component to do when passed a set of tags as props. It expects that each tag will be rendered with a hashtag prepended to it; for example, the <strong class="source-inline">react</strong> tag will be shown as <strong class="source-inline">#react</strong>. In the <strong class="source-inline">__tests__/PostListItem.test.js</strong> file, we can add a new <strong class="source-inline">test</strong>:<p class="source-code">// rest of tests and imports</p><p class="source-code">test('PostListItem renders tags with a # prepended to   them', () =&gt; {</p><p class="source-code">  const wrapper = shallowMount(PostListItem, {</p><p class="source-code">    propsData: {</p><p class="source-code">      tags: ['react', 'vue']</p><p class="source-code">    }</p><p class="source-code">  })</p><p class="source-code">  expect(wrapper.text()).toMatch('#react')</p><p class="source-code">  expect(wrapper.text()).toMatch('#vue')</p><p class="source-code">})</p><p>This test fails when run with <strong class="source-inline">npm run test:unit __tests__/PostListItem.test.js</strong>:</p><div id="_idContainer338" class="IMG---Figure"><img src="image/B15218_12_07.jpg" alt="Figure 12.7: Tag test for PostListItem failing&#13;&#10;"/></div><p class="figure-caption">Figure 12.7: Tag test for PostListItem failing</p></li>
				<li>Next, we should implement the tag list rendering in <strong class="source-inline">src/components/PostListItem.vue</strong>. We'll add tags as props of the <strong class="source-inline">Array</strong> type and use <strong class="source-inline">v-for</strong> to render out the tags:<p class="source-code">&lt;template&gt;</p><p class="source-code">    &lt;!-- rest of template --&gt;</p><p class="source-code">    &lt;div class="flex flex-row flex-wrap mt-4"&gt;</p><p class="source-code">      &lt;a</p><p class="source-code">        v-for="tag in tags"</p><p class="source-code">        :key="tag"</p><p class="source-code">        class="flex text-xs font-semibold px-2 py-1 mr-2           rounded border border-blue-500 text-blue-500"</p><p class="source-code">      &gt;</p><p class="source-code">        #{{ tag }}</p><p class="source-code">      &lt;/a&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">    &lt;!-- rest of template --&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  props: {</p><p class="source-code">    // rest of props</p><p class="source-code">    tags: {</p><p class="source-code">      type: Array,</p><p class="source-code">      default: () =&gt; []</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p><p>With the <strong class="source-inline">PostListItem</strong> component implemented, the unit test should now pass:</p><div id="_idContainer339" class="IMG---Figure"><img src="image/B15218_12_08.jpg" alt="Figure 12.8: PostListItem unit test passing&#13;&#10;"/></div><p class="figure-caption">Figure 12.8: PostListItem unit test passing</p><p>However, the tags are not displayed in the application:</p><div id="_idContainer340" class="IMG---Figure"><img src="image/B15218_12_09.jpg" alt="Figure 12.9: PostList displaying without tags despite &#13;&#10;the correct PostListItem implementation&#13;&#10;"/></div><p class="figure-caption">Figure 12.9: PostList displaying without tags despite the correct PostListItem implementation</p></li>
				<li>We can write a unit test for <strong class="source-inline">PostList</strong> that would show this behavior. In essence, we'll be passing some tags in our <strong class="source-inline">posts</strong> list and running the same assertions as are already present in the <strong class="source-inline">PostListItem.test.js</strong> file. We'll do this in <strong class="source-inline">__tests__/PostList.test.js</strong>:<p class="source-code">// rest of tests and imports</p><p class="source-code">test('PostList renders tags for each post', () =&gt; {</p><p class="source-code">  const wrapper = mount(PostList, {</p><p class="source-code">    propsData: {</p><p class="source-code">      posts: [</p><p class="source-code">        {</p><p class="source-code">          tags: ['react', 'vue']</p><p class="source-code">        },</p><p class="source-code">        {</p><p class="source-code">          tags: ['html', 'angularjs']</p><p class="source-code">        }</p><p class="source-code">      ]</p><p class="source-code">    }</p><p class="source-code">  })</p><p class="source-code">  const outputText = wrapper.text()</p><p class="source-code">  expect(outputText).toContain('#react')</p><p class="source-code">  expect(outputText).toContain('#vue')</p><p class="source-code">  expect(outputText).toContain('#html')</p><p class="source-code">  expect(outputText).toContain('#angularjs')</p><p class="source-code">})</p><p>As per our application output, the test is failing when run with <strong class="source-inline">npm run test:unit __tests__/PostList.test.js</strong>:</p><div id="_idContainer341" class="IMG---Figure"><img src="image/B15218_12_10.jpg" alt="Figure 12.10: PostList tags test failing&#13;&#10;"/></div><p class="figure-caption">Figure 12.10: PostList tags test failing</p></li>
				<li>In order to fix this test, we can find the issue in <strong class="source-inline">src/components/PostList.vue</strong>, where the <strong class="source-inline">tags</strong> prop for <strong class="source-inline">PostListItem</strong> is not bound. By updating <strong class="source-inline">src/components/PostList.vue</strong> to bind the <strong class="source-inline">tags</strong> prop, we can fix the unit test:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;!-- rest of template--&gt;</p><p class="source-code">    &lt;PostListItem</p><p class="source-code">      v-for="post in posts"</p><p class="source-code">      :key="post.slug"</p><p class="source-code">      :title="post.title"</p><p class="source-code">      :description="post.description"</p><p class="source-code">      :tags="post.tags"</p><p class="source-code">    /&gt;</p><p class="source-code">  &lt;!-- rest of template --&gt;</p><p class="source-code">&lt;/template&gt;</p><p>The failing unit test now passes, as shown in the following screenshot:</p><div id="_idContainer342" class="IMG---Figure"><img src="image/B15218_12_11.jpg" alt="Figure 12.11: PostList tags test passing&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 12.11: PostList tags test passing</p>
			<p>The tags also appear in the application, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer343" class="IMG---Figure">
					<img src="image/B15218_12_12.jpg" alt="Figure 12.12: Blog list rendering with tags&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.12: Blog list rendering with tags</p>
			<p>We have now seen how we can test rendered component output with both the shallow rendering and mounting of components. Let's briefly understand what each of these terms means:</p>
			<ul>
				<li><strong class="bold">Shallow rendering</strong>: This renders at a depth of 1, meaning that if children are components, they will just be rendered as the component tag; their template will not be run.</li>
				<li><strong class="bold">Mounting</strong>: This renders the full component tree in a similar fashion as would be rendered in the browser.</li>
			</ul>
			<p>Next, we'll look at how to test component methods.</p>
			<h1 id="_idParaDest-251">Testing Meth<a id="_idTextAnchor334"/>ods, Filters and Mixins</h1>
			<p>Since <strong class="bold">filters</strong> and <strong class="bold">mixins</strong> generate their output based solely on function parameters, they are straightforward to unit test. It is not recommended to test methods unless it's strictly necessary since the user doesn't call methods on the component directly. The users see the rendered UI, and their interactions with the application are manifested as events (for example, <strong class="source-inline">click</strong>, <strong class="source-inline">input change</strong>, <strong class="source-inline">focus change</strong>, and <strong class="source-inline">scroll</strong>).</p>
			<p>For example, a filter that truncates its input to eight characters would be implemented as follows:</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  filters: {</p>
			<p class="source-code">    truncate(value) {</p>
			<p class="source-code">      return value &amp;&amp; value.slice(0, 8)</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>There are two options to test it. We could test it directly by importing the component and calling <strong class="source-inline">truncate</strong> on some input, as per the <strong class="source-inline">truncate.test.js</strong> file:</p>
			<p class="source-code">import PostListItem from '../src/components/PostListItem.vue'</p>
			<p class="source-code">test('truncate should take only the first 8 characters', () =&gt; {</p>
			<p class="source-code">  expect(</p>
			<p class="source-code">    PostListItem.filters.truncate('longer than 8 characters')</p>
			<p class="source-code">  ).toEqual('longer t')</p>
			<p class="source-code">})</p>
			<p>The alternative is to check where it's being used in the <strong class="source-inline">PostListItem</strong> component:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;!-- rest of template --&gt;</p>
			<p class="source-code">    &lt;h3 class="flex text-md font-semibold text-gray-700"&gt;</p>
			<p class="source-code">      {{ title | truncate }}</p>
			<p class="source-code">    &lt;/h3&gt;</p>
			<p class="source-code">  &lt;!-- rest of template --&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p>Now we can test <strong class="source-inline">truncate</strong> by checking what happens when we pass a long title into the <strong class="source-inline">PostListItem</strong> component in the <strong class="source-inline">PostListItem.test.js</strong> file, which we do in the following test:</p>
			<p class="source-code">// imports</p>
			<p class="source-code">test('PostListItem renders title and description correctly',   () =&gt; {</p>
			<p class="source-code">  const wrapper = shallowMount(PostListItem, {</p>
			<p class="source-code">    propsData: {</p>
			<p class="source-code">      title: 'Blog post title',</p>
			<p class="source-code">      description: 'Blog post description'</p>
			<p class="source-code">    }</p>
			<p class="source-code">  })</p>
			<p class="source-code">  expect(wrapper.text()).toMatch("Blog post title")</p>
			<p class="source-code">  expect(wrapper.text()).toMatch("Blog post description")</p>
			<p class="source-code">})</p>
			<p class="source-code">// other tests</p>
			<p>The preceding code will generate the output shown in the following screenshot:</p>
			<div>
				<div id="_idContainer344" class="IMG---Figure">
					<img src="image/B15218_12_13.jpg" alt="Figure 12.13: PostListItem test for the title failing because &#13;&#10;the content of the title is truncated&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.13: PostListItem test for the title failing because the content of the title is truncated</p>
			<p>To fix this, we could update the failing test to expect <strong class="source-inline">Blog pos</strong> instead of <strong class="source-inline">Blog post title</strong>.</p>
			<p>These two approaches are great for testing filters. As we saw before with <strong class="bold">mount</strong> versus <strong class="bold">shallow</strong> rendering, the difference is in the <strong class="bold">tightness</strong> of the unit test. The tighter unit test is the direct <strong class="source-inline">filters.truncate()</strong> test since it directly accesses the <strong class="source-inline">truncate</strong> filter. The looser unit test is the test using passed props and validating the component output. A tighter unit will usually mean tests are simpler, but it comes at the cost of sometimes testing functionality in a fashion that is very removed from how the end user perceives it. For example, the user would never call <strong class="source-inline">filters.truncate()</strong> directly.</p>
			<p>We have seen how to test an arbitrary <strong class="source-inline">truncate</strong> filter. We will now implement an <strong class="source-inline">ellipsis</strong> filter and test it.</p>
			<p>The <strong class="source-inline">ellipsis</strong> filter will be applied to the post description and will limit its length to <strong class="source-inline">40</strong> characters plus <strong class="source-inline">…</strong>.</p>
			<h2 id="_idParaDest-252">Exercise 12.0<a id="_idTextAnchor335"/>2: Building and Testing an ellipsis Filter</h2>
			<p>We have seen how to test an arbitrary <strong class="source-inline">truncate</strong> filter; we will now implement an <strong class="source-inline">ellipsis</strong> filter and test it.</p>
			<p>To access the code files for this exercise, refer to <a href="https://packt.live/2UK9Mcs">https://packt.live/2UK9Mcs</a>.</p>
			<p>Now let's look at the steps to build and test an <strong class="source-inline">ellipsis</strong> filter:</p>
			<ol>
				<li value="1">We can start by writing a set of tests for the <strong class="source-inline">ellipsis</strong> filter (which will live in <strong class="source-inline">src/components/PostListItem.vue</strong>). One test should check that the filter does nothing if the passed value is less than <strong class="source-inline">50</strong> characters; another should check that if the passed value is more than <strong class="source-inline">50</strong> characters, it truncates to <strong class="source-inline">50</strong> and appends <strong class="source-inline">…</strong>. We will do this in a <strong class="source-inline">__tests__/ellipsis.test.js</strong> file:<p class="source-code">import PostListItem from '../src/components/PostListItem.vue'</p><p class="source-code">test('ellipsis should do nothing if value is less than 50   characters', () =&gt; {</p><p class="source-code">  expect(</p><p class="source-code">    PostListItem.filters.ellipsis('Less than 50 characters')</p><p class="source-code">  ).toEqual('Less than 50 characters')</p><p class="source-code">})</p><p class="source-code">test('ellipsis should truncate to 50 and append "..." when   longer than 50 characters', () =&gt; {</p><p class="source-code">  expect(</p><p class="source-code">    PostListItem.filters.ellipsis(</p><p class="source-code">      'Should be more than the 50 allowed characters by a         small amount'</p><p class="source-code">    )</p><p class="source-code">  ).toEqual('Should be more than the 50 allowed characters by     a...')</p><p class="source-code">})</p></li>
				<li>We can now implement the logic for <strong class="source-inline">ellipsis</strong> in <strong class="source-inline">src/components/PostListItem.vue</strong>. We will add a <strong class="source-inline">filters</strong> object with <strong class="source-inline">ellipsis</strong>, which will use <strong class="source-inline">String#slice</strong> if the passed value is longer than <strong class="source-inline">50</strong> characters and do nothing otherwise:<p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  // rest of component properties</p><p class="source-code">  filters: {</p><p class="source-code">    ellipsis(value) {</p><p class="source-code">      return value &amp;&amp; value.length &gt; 50</p><p class="source-code">        ? `${value.slice(0, 50)}...`</p><p class="source-code">        : value</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p><p>In this case, the test now passes <strong class="source-inline">npm run test:unit __tests__/ellipsis.test.js</strong>, as shown in <em class="italic">Figure 12.14</em>:</p><div id="_idContainer345" class="IMG---Figure"><img src="image/B15218_12_14.jpg" alt="Figure 12.14: The ellipsis filter unit test passing&#13;&#10;"/></div><p class="figure-caption">Figure 12.14: The ellipsis filter unit test passing</p></li>
				<li>We now need to integrate our <strong class="source-inline">ellipsis</strong> filter into the component. To check whether this will work, we can first write the test in <strong class="source-inline">__tests__/PostListItem.test.js</strong>:<p class="source-code">// other tests and imports</p><p class="source-code">test('PostListItem truncates long descriptions', () =&gt; {</p><p class="source-code">  const wrapper = shallowMount(PostListItem, {</p><p class="source-code">    propsData: {</p><p class="source-code">      description: 'Very long blog post description that goes         over 50 characters'</p><p class="source-code">    }</p><p class="source-code">  })</p><p class="source-code">  expect(wrapper.text()).toMatch("Very long blog post description     that goes over 50 ...")</p><p class="source-code">})</p><p>This test fails since we don't use the filter in the component template. The output will be as follows:</p><div id="_idContainer346" class="IMG---Figure"><img src="image/B15218_12_15.jpg" alt="Figure 12.15: PostListItem ellipsis test failing&#13;&#10;"/></div><p class="figure-caption">Figure 12.15: PostListItem ellipsis test failing</p></li>
				<li>To get the test to pass, we need to pipe the <strong class="source-inline">description</strong> property into the <strong class="source-inline">ellipsis</strong> filter in <strong class="source-inline">src/components/PostListItem.vue</strong>:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;!-- rest of template --&gt;</p><p class="source-code">    &lt;p class="flex leading-relaxed"&gt;{{ description | ellipsis }}      &lt;/p&gt;</p><p class="source-code">  &lt;!-- rest of template --&gt;</p><p class="source-code">&lt;/template&gt;</p><p>Now, the test will pass, as displayed in the following screenshot:</p><div id="_idContainer347" class="IMG---Figure"><img src="image/B15218_12_16.jpg" alt="Figure 12.16: PostListItem ellipsis test passing&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 12.16: PostListItem ellipsis test passing</p>
			<p>We can see the descriptions being truncated in the application interface in the browser, as follows:</p>
			<div>
				<div id="_idContainer348" class="IMG---Figure">
					<img src="image/B15218_12_17.jpg" alt="Figure 12.17: Blog post item descriptions being truncated to 50 characters&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.17: Blog post item descriptions being truncated to 50 characters</p>
			<p>We have now seen how to test filters and other properties of a Vue.js component not only by testing directly against the object but also by testing the functionality where it is being used in component-level tests.</p>
			<p>Next, we will see how to deal with an application that uses Vue.js routing.</p>
			<h1 id="_idParaDest-253">Testing Vue Routi<a id="_idTextAnchor336"/>ng</h1>
			<p>We have currently got an application that renders what is our blog home page or <strong class="bold">feed view</strong>.</p>
			<p>Next, we should have post pages. To do this, we will use Vue Router, as covered in previous chapters, and ensure that our routing works as designed with unit tests.</p>
			<p>Vue Router is installed using <strong class="source-inline">npm</strong>, specifically, <strong class="source-inline">npm install vue-router</strong>, and wiring it up in the <strong class="source-inline">main.js</strong> file:</p>
			<p class="source-code">// other imports</p>
			<p class="source-code">import router from './router'</p>
			<p class="source-code">// other imports and configuration </p>
			<p class="source-code">new Vue({</p>
			<p class="source-code">  render: h =&gt; h(App),</p>
			<p class="source-code">  router,</p>
			<p class="source-code">}).$mount(‹#app›)</p>
			<p>The <strong class="source-inline">router.js</strong> file registers <strong class="source-inline">vue-router</strong> with Vue using <strong class="source-inline">Vue.use</strong> and instantiates a <strong class="source-inline">VueRouter</strong> instance:</p>
			<p class="source-code">import Vue from 'vue'</p>
			<p class="source-code">import VueRouter from 'vue-router'</p>
			<p class="source-code">Vue.use(VueRouter)</p>
			<p class="source-code">export default new VueRouter({})</p>
			<p>A router with no routes isn't very useful. We'll define the root path (<strong class="source-inline">/</strong>) to display the <strong class="source-inline">PostList</strong> component in the <strong class="source-inline">router.js</strong> file, as follows:</p>
			<p class="source-code">// other imports</p>
			<p class="source-code">import PostList from './components/PostList.vue'</p>
			<p class="source-code">// registering of Vue router</p>
			<p class="source-code">const routes = [</p>
			<p class="source-code">  {</p>
			<p class="source-code">    path: '/',</p>
			<p class="source-code">    component: PostList</p>
			<p class="source-code">  }</p>
			<p class="source-code">]</p>
			<p class="source-code">export default new VueRouter({</p>
			<p class="source-code">  routes</p>
			<p class="source-code">})</p>
			<p>Now that we've got our initial route, we should update the <strong class="source-inline">App.vue</strong> file to leverage the component being rendered by the router. We'll render <strong class="source-inline">render-view</strong> instead of directly using <strong class="source-inline">PostList</strong>. The <strong class="source-inline">posts</strong> binding, however, stays the same:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;!-- rest of template --&gt;</p>
			<p class="source-code">      &lt;router-view</p>
			<p class="source-code">        :posts="posts"</p>
			<p class="source-code">      /&gt;</p>
			<p class="source-code">  &lt;!-- rest of template --&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p>Now, our posts in the <strong class="source-inline">App.vue</strong> file are missing a bit of core data to render a <strong class="source-inline">SinglePost</strong> component. We need to make sure to have the <strong class="source-inline">slug</strong> and <strong class="source-inline">content</strong> properties to render something useful on our <strong class="source-inline">SinglePost</strong> page:</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  data() {</p>
			<p class="source-code">    return {</p>
			<p class="source-code">      posts: [</p>
			<p class="source-code">        {</p>
			<p class="source-code">          slug: 'vue-react',</p>
			<p class="source-code">          title: 'Vue.js for React developers',</p>
			<p class="source-code">          description: 'React has massive popularity here are the             key benefits of Vue.js over it.',</p>
			<p class="source-code">          content:</p>
			<p class="source-code">            'React has massive popularity here are the key benefits               of Vue.js over it.</p>
			<p class="source-code">            See the following table, we'll also look at how the is               the content of the post.</p>
			<p class="source-code">            There's more, we can map React concepts to Vue and               vice-versa.',</p>
			<p class="source-code">          tags: ['vue', 'react'],</p>
			<p class="source-code">        },</p>
			<p class="source-code">        {</p>
			<p class="source-code">          slug: 'vue-angularjs',</p>
			<p class="source-code">          title: 'Migrating an AngularJS app to Vue.js',</p>
			<p class="source-code">          description: 'With many breaking changes, AngularJS developers             have found it easier to retrain to Vue.js than Angular 2',</p>
			<p class="source-code">          content:</p>
			<p class="source-code">            'With many breaking changes, AngularJS developers have               found it easier to retrain to Vue.js than Angular 2</p>
			<p class="source-code">            Vue.js keeps the directive-driven templating style while               adding a component model.</p>
			<p class="source-code">            It's performant thanks to a great reactivity engine.',</p>
			<p class="source-code">          tags: ['vue', 'angularjs']</p>
			<p class="source-code">        }</p>
			<p class="source-code">      ]</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>We can now start working on a <strong class="source-inline">SinglePost</strong> component. For now, we'll just have some placeholders in the template. Also, <strong class="source-inline">SinglePost</strong> will receive <strong class="source-inline">posts</strong> as a prop, so we can fill that in as well:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div class="flex flex-col w-full md:w-1/2 m-auto"&gt;</p>
			<p class="source-code">    &lt;h2</p>
			<p class="source-code">      class="font-semibold text-sm mb-4"</p>
			<p class="source-code">    &gt;</p>
			<p class="source-code">      Post: RENDER ME</p>
			<p class="source-code">    &lt;/h2&gt;</p>
			<p class="source-code">    &lt;p&gt;Placeholder for post.content&lt;/p&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  props: {</p>
			<p class="source-code">    posts: {</p>
			<p class="source-code">      type: Array,</p>
			<p class="source-code">      default: () =&gt; []</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>Next, we will register <strong class="source-inline">SinglePost</strong> in <strong class="source-inline">router.js</strong>, with the <strong class="source-inline">/:postId</strong> path (which will be available to the component under <strong class="source-inline">this.$route.params.postId</strong>):</p>
			<p class="source-code">// other imports</p>
			<p class="source-code">import SinglePost from './components/SinglePost.vue'</p>
			<p class="source-code">// vue router registration</p>
			<p class="source-code">const routes = [</p>
			<p class="source-code">  // other route</p>
			<p class="source-code">  {</p>
			<p class="source-code">    path: '/:postId',</p>
			<p class="source-code">    component: SinglePost</p>
			<p class="source-code">  }</p>
			<p class="source-code">]</p>
			<p class="source-code">// exports and router instantiation</p>
			<p>If we switch back to implementing the <strong class="source-inline">SinglePost</strong> component, we've got access to <strong class="source-inline">postId</strong>, which will map to the slug in the <strong class="source-inline">posts</strong> array, and we've also got access to <strong class="source-inline">posts</strong> since it's being bound onto <strong class="source-inline">render-view</strong> by <strong class="source-inline">App</strong>. Now we can create a computed property, <strong class="source-inline">post</strong>, which finds posts based on <strong class="source-inline">postId</strong>:</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  // other properties</p>
			<p class="source-code">  computed: {</p>
			<p class="source-code">    post() {</p>
			<p class="source-code">      const { postId } = this.$route.params</p>
			<p class="source-code">      return posts.find(p =&gt; p.slug === postId)</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>From this computed <strong class="source-inline">post</strong> property, we can extract <strong class="source-inline">title</strong> and <strong class="source-inline">content</strong> if <strong class="source-inline">post</strong> exists (we have to watch out for posts that don't exist). So, still in <strong class="source-inline">SinglePost</strong>, we can add the following computed properties:</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  // other properties</p>
			<p class="source-code">  computed: {</p>
			<p class="source-code">    // other computed properties</p>
			<p class="source-code">    title() {</p>
			<p class="source-code">      return this.post &amp;&amp; this.post.title</p>
			<p class="source-code">    },</p>
			<p class="source-code">    content() {</p>
			<p class="source-code">      return this.post &amp;&amp; this.post.content</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>We can then replace the placeholders in the template with the value of the computed properties. So, our template ends up as follows:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div class="flex flex-col w-full md:w-1/2 m-auto"&gt;</p>
			<p class="source-code">    &lt;h2</p>
			<p class="source-code">      class="font-semibold text-sm mb-4"</p>
			<p class="source-code">    &gt;</p>
			<p class="source-code">      Post: {{ title }}</p>
			<p class="source-code">    &lt;/h2&gt;</p>
			<p class="source-code">    &lt;p&gt;{{ content }}&lt;/p&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p>Finally, we should make the whole post item a <strong class="source-inline">router-link</strong> that points to the right slug in the <strong class="source-inline">PostListItem.vue</strong> file:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;router-link</p>
			<p class="source-code">    class="flex flex-col m-auto w-full md:w-3/5 lg:w-2/5 mb-4"</p>
			<p class="source-code">    :to="`/${slug}`"</p>
			<p class="source-code">  &gt;</p>
			<p class="source-code">    &lt;!-- rest of the template --&gt;</p>
			<p class="source-code">  &lt;/router-link&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p><strong class="source-inline">router-link</strong> is a Vue Router-specific link, which means that on the <strong class="source-inline">PostList</strong> page, upon clicking on a post list item, we are taken to the correct post's URL, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer349" class="IMG---Figure">
					<img src="image/B15218_12_18.jpg" alt="Figure 12.18: Post list view displayed in the browser&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.18: Post list view displayed in the browser</p>
			<p>We'll be redirected to the correct URL, the post's slug, which will render the right post by <strong class="source-inline">slug</strong>, as shown in <em class="italic">Figure 12.19</em>.</p>
			<div>
				<div id="_idContainer350" class="IMG---Figure">
					<img src="image/B15218_12_19.jpg" alt="Figure 12.19: Single post view displaying in the browser&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.19: Single post view displaying in the browser</p>
			<p>To test <strong class="source-inline">vue-router</strong>, we will explore a new library that's better suited to testing applications with routing and a Vuex store, the Vue Testing library, which is accessible on <strong class="source-inline">npm</strong> as <strong class="source-inline">@testing-library/vue</strong>.</p>
			<p>We can install it with <strong class="source-inline">npm install --save-dev @testing-library/vue</strong>.</p>
			<p>To test <strong class="source-inline">SinglePost</strong> routing and rendering, we do the following. First of all, we should be able to access the <strong class="source-inline">SinglePost</strong> view by clicking on a post title in the <strong class="source-inline">PostList</strong> view. In order to do this, we check that we're on the home page by examining the content (we'll see two posts with the titles). Then we'll click a post title and check that the content from the home page is gone and the post content is displayed:</p>
			<p class="source-code">import {render, fireEvent} from '@testing-library/vue'</p>
			<p class="source-code">import App from '../src/App.vue'</p>
			<p class="source-code">import router from '../src/router.js'</p>
			<p class="source-code">test('Router renders single post page when clicking a post title',   async () =&gt; {</p>
			<p class="source-code">  const {getByText, queryByText} = render(App, { router })</p>
			<p class="source-code">  expect(queryByText('The Vue.js Workshop Blog')).toBeTruthy()</p>
			<p class="source-code">  expect(queryByText('Vue.js for React developers')).toBeTruthy()</p>
			<p class="source-code">  expect(queryByText('Migrating an AngularJS app to Vue.js')).    toBeTruthy()</p>
			<p class="source-code">  await fireEvent.click(getByText('Vue.js for React developers'))</p>
			<p class="source-code">  expect(queryByText('Migrating an AngularJS app to Vue.js')).    toBeFalsy()</p>
			<p class="source-code">  expect(queryByText('Post: Vue.js for React developers')).    toBeTruthy()</p>
			<p class="source-code">  expect(</p>
			<p class="source-code">    queryByText(</p>
			<p class="source-code">      'React has massive popularity here are the key benefits of         Vue.js over it. See the following table, we'll also look at         how the is the content of the post. There's more, we can         map React concepts to Vue and vice-versa.'</p>
			<p class="source-code">    )</p>
			<p class="source-code">  ).toBeTruthy()</p>
			<p class="source-code">})</p>
			<p>We should check that navigating directly to a valid post URL will yield the correct result. In order to do this, we'll use <strong class="source-inline">router.replace('/')</strong> to clear any state that's set, and then use <strong class="source-inline">router.push()</strong> with a post slug. We will then use the assertions from the previous code snippet to validate that we are on the <strong class="source-inline">SinglePost</strong> page, not the home page:</p>
			<p class="source-code">test('Router renders single post page when a slug is set',   async () =&gt; {</p>
			<p class="source-code">  const {queryByText} = render(App, { router })</p>
			<p class="source-code">  await router.replace('/')</p>
			<p class="source-code">  await router.push('/vue-react')</p>
			<p class="source-code">  expect(queryByText('Migrating an AngularJS app to Vue.js')).    toBeFalsy()</p>
			<p class="source-code">  expect(queryByText('Post: Vue.js for React developers')).    toBeTruthy()</p>
			<p class="source-code">  expect(</p>
			<p class="source-code">    queryByText(</p>
			<p class="source-code">      'React has massive popularity here are the key benefits of         Vue.js over it. See the following table, we'll also look at         how the is the content of the post. There's more, we can map         React concepts to Vue and vice-versa.'</p>
			<p class="source-code">    )</p>
			<p class="source-code">  ).toBeTruthy()</p>
			<p class="source-code">})</p>
			<p>Those two tests work as expected when run with <strong class="source-inline">npm run test:unit __tests__/SinglePost.test.js</strong>. The following screenshot displays the desired output:</p>
			<div>
				<div id="_idContainer351" class="IMG---Figure">
					<img src="image/B15218_12_20.jpg" alt="Figure 12.20: Routing tests passing for SinglePost&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.20: Routing tests passing for SinglePost</p>
			<p>We have now seen how to use the Vue.js Testing library to test an application that uses <strong class="source-inline">vue-router</strong>.</p>
			<h2 id="_idParaDest-254">Exercise 12.03: Buil<a id="_idTextAnchor337"/>ding a Tag Page and Testing Its Routing</h2>
			<p>Much like we have built a single-post page, we'll now build a tag page, which is similar to the <strong class="source-inline">PostList</strong> component except only posts with a certain tag are displayed and each post is a link to a relevant single-post view.</p>
			<p>To access the code files for this exercise, refer to <a href="https://packt.live/39cJqZd">https://packt.live/39cJqZd</a>:</p>
			<ol>
				<li value="1">We can start by creating a new <strong class="source-inline">TagPage</strong> component in <strong class="source-inline">src/components/TagPage.vue</strong>. We know it will receive <strong class="source-inline">posts</strong> as a prop and that we will want to render a <strong class="source-inline">PostList</strong> component:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div class="flex flex-col md:w-1/2 m-auto"&gt;</p><p class="source-code">    &lt;h3</p><p class="source-code">    class="font-semibold text-sm text-center mb-6"</p><p class="source-code">    &gt;</p><p class="source-code">      #INSERT_TAG_NAME</p><p class="source-code">    &lt;/h3&gt;</p><p class="source-code">    &lt;PostList :posts="[]" /&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">import PostList from './PostList'</p><p class="source-code">export default {</p><p class="source-code">  components: {</p><p class="source-code">    PostList</p><p class="source-code">  },</p><p class="source-code">  props: {</p><p class="source-code">    posts: {</p><p class="source-code">      type: Array,</p><p class="source-code">      default: () =&gt; []</p><p class="source-code">    }</p><p class="source-code">  },</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>Next, we want to wire the <strong class="source-inline">TagPage</strong> component into the router in <strong class="source-inline">src/router.js</strong>. We'll import it and add it as part of <strong class="source-inline">routes</strong> with the <strong class="source-inline">/tags/:tagName</strong> path:<p class="source-code">// other imports</p><p class="source-code">import TagPage from './components/TagPage.vue'</p><p class="source-code">// Vue router registration</p><p class="source-code">const routes = [</p><p class="source-code">  // other routes</p><p class="source-code">  {</p><p class="source-code">    path: '/tags/:tagName',</p><p class="source-code">    component: TagPage</p><p class="source-code">  }</p><p class="source-code">]</p><p class="source-code">// router instantiation and export</p></li>
				<li>We can now use <strong class="source-inline">$route.params.tagName</strong> in a computed property and create a <strong class="source-inline">tagPosts</strong> computed property that filters posts by tag:<p class="source-code">&lt;script&gt;</p><p class="source-code">// imports</p><p class="source-code">export default {</p><p class="source-code">  // rest of component</p><p class="source-code">  computed: {</p><p class="source-code">    tagName() {</p><p class="source-code">      return this.$route.params.tagName</p><p class="source-code">    },</p><p class="source-code">    tagPosts() {</p><p class="source-code">      return this.posts.filter(p =&gt; p.tags.includes(this.tagName))</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>Now that we have access to <strong class="source-inline">tagPosts</strong> and <strong class="source-inline">tagName</strong>, we can replace the placeholders in the template. We will render <strong class="source-inline">#{{ tagName }}</strong> and bind <strong class="source-inline">tagPosts</strong> to the <strong class="source-inline">posts</strong> prop of <strong class="source-inline">PostList</strong>:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div class="flex flex-col md:w-1/2 m-auto"&gt;</p><p class="source-code">    &lt;h3</p><p class="source-code">      class="font-semibold text-sm text-center mb-6"</p><p class="source-code">    &gt;</p><p class="source-code">      #{{ tagName }}</p><p class="source-code">    &lt;/h3&gt;</p><p class="source-code">    &lt;PostList :posts="tagPosts" /&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p>Now, the page displays as follows if we navigate, for example, to <strong class="source-inline">/tags/angularjs</strong>:</p><div id="_idContainer352" class="IMG---Figure"><img src="image/B15218_12_21.jpg" alt="Figure 12.21: Tag page for angularjs&#13;&#10;"/></div><p class="figure-caption">Figure 12.21: Tag page for angularjs</p></li>
				<li>The next step is to convert the tag anchors (<strong class="source-inline">a</strong>) in <strong class="source-inline">PostListItem</strong> to <strong class="source-inline">router-link</strong> that points to <strong class="source-inline">/tags/${tagName}</strong> (in <strong class="source-inline">src/components/PostListItem.vue</strong>):<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;!-- rest of template --&gt;</p><p class="source-code">      &lt;router-link</p><p class="source-code">        :to="`/tags/${tag}`"</p><p class="source-code">        v-for="tag in tags"</p><p class="source-code">        :key="tag"</p><p class="source-code">        class="flex text-xs font-semibold px-2 py-1 mr-2           rounded border border-blue-500 text-blue-500"</p><p class="source-code">      &gt;</p><p class="source-code">        #{{ tag }}</p><p class="source-code">      &lt;/router-link&gt;</p><p class="source-code">  &lt;!-- rest of template --&gt;</p><p class="source-code">&lt;/template&gt;</p></li>
				<li>Now it is time to write some tests. We will first check that being on the home page and clicking on <strong class="source-inline">#angularjs</strong> puts us on the <strong class="source-inline">angularjs</strong> tag page. We'll write it as follows in <strong class="source-inline">__tests__/TagPage.test.js</strong>:<p class="source-code">import {render, fireEvent} from '@testing-library/vue'</p><p class="source-code">import App from '../src/App.vue'</p><p class="source-code">import router from '../src/router.js'</p><p class="source-code">test('Router renders tag page when clicking a tag in the post     list item', async () =&gt; {</p><p class="source-code">  const {getByText, queryByText} = render(App, { router })</p><p class="source-code">  expect(queryByText('The Vue.js Workshop Blog')).    toBeTruthy()</p><p class="source-code">  expect(queryByText('Vue.js for React developers')).    toBeTruthy()</p><p class="source-code">  expect(queryByText('Migrating an AngularJS app to Vue.js')).    toBeTruthy()</p><p class="source-code">  await fireEvent.click(getByText('#angularjs'))</p><p class="source-code">  expect(queryByText('Migrating an AngularJS app to Vue.js')).    toBeTruthy()</p><p class="source-code">  expect(queryByText('Vue.js for React developers')).toBeFalsy()</p><p class="source-code">  expect(queryByText('React')).toBeFalsy()</p><p class="source-code">})</p></li>
				<li>We should also test that going directly to the tag URL works as expected; that is, we do not see irrelevant content:<p class="source-code">// import &amp; other tests</p><p class="source-code">test('Router renders tag page when a URL is set', async () =&gt; {</p><p class="source-code">  const {queryByText} = render(App, { router })</p><p class="source-code">  await router.push('/')</p><p class="source-code">  await router.replace('/tags/angularjs')</p><p class="source-code">  expect(queryByText('Migrating an AngularJS app to Vue.js')).    toBeTruthy()</p><p class="source-code">  expect(queryByText('Vue.js for React developers')).    toBeFalsy()</p><p class="source-code">  expect(queryByText('React')).toBeFalsy()</p><p class="source-code">})</p><p>The tests pass since the application is working as expected. Therefore, the output will be as follows:</p><div id="_idContainer353" class="IMG---Figure"><img src="image/B15218_12_22.jpg" alt="Figure 12.22: TagPage routing tests passing on the command line&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 12.22: TagPage routing tests passing on the command line</p>
			<p>We've now seen how to implement and test an application that includes <strong class="source-inline">vue-router</strong>. In the next section, we will learn about testing Vuex in detail.</p>
			<h1 id="_idParaDest-255"><a id="_idTextAnchor338"/>Testing Vuex</h1>
			<p>To show h<a id="_idTextAnchor339"/>ow to test a component that relies on Vuex (Vue.js's official global state management solution), we'll implement and test a newsletter subscription banner.</p>
			<p>To start with, we should create the banner template. The banner will contain a <strong class="source-inline">Subscribe to the newsletter</strong> call to action and a close icon:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div class="text-center py-4 md:px-4"&gt;</p>
			<p class="source-code">    &lt;div</p>
			<p class="source-code">      class="py-2 px-4 bg-indigo-800 items-center text-indigo-100</p>
			<p class="source-code">      leading-none md:rounded-full flex md:inline-flex"</p>
			<p class="source-code">      role="alert"</p>
			<p class="source-code">    &gt;</p>
			<p class="source-code">      &lt;span</p>
			<p class="source-code">        class="font-semibold ml-2 md:mr-2 text-left flex-auto"</p>
			<p class="source-code">      &gt;</p>
			<p class="source-code">        Subscribe to the newsletter</p>
			<p class="source-code">      &lt;/span&gt;</p>
			<p class="source-code">      &lt;svg</p>
			<p class="source-code">        class="fill-current h-6 w-6 text-indigo-500"</p>
			<p class="source-code">        role="button"</p>
			<p class="source-code">        xmlns="http://www.w3.org/2000/svg"</p>
			<p class="source-code">        viewBox="0 0 20 20"</p>
			<p class="source-code">      &gt;</p>
			<p class="source-code">        &lt;title&gt;Close&lt;/title&gt;</p>
			<p class="source-code">        &lt;path</p>
			<p class="source-code">          d="M14.348 14.849a1.2 1.2 0 0 1-1.697 0L10 11.819l-2.651</p>
			<p class="source-code">          3.029a1.2 1.2 0 1 1-1.697-1.697l2.758-3.15-2.759-3.152a1.            2</p>
			<p class="source-code">          1.2 0 1 1 1.697-1.697L10 8.183l2.651-3.031a1.2 1.2 0 1 1</p>
			<p class="source-code">          1.697 1.697l-2.758 3.152 2.758 3.15a1.2 1.2 0 0 1 0 1.            698z"</p>
			<p class="source-code">        /&gt;</p>
			<p class="source-code">      &lt;/svg&gt;</p>
			<p class="source-code">    &lt;/div&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p>We can display the <strong class="source-inline">NewsletterBanner</strong> component in the <strong class="source-inline">App.vue</strong> file as follows:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;!-- rest of template --&gt;</p>
			<p class="source-code">    &lt;NewsletterBanner /&gt;</p>
			<p class="source-code">  &lt;!-- rest of template --&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">import NewsletterBanner from './components/NewsletterBanner.vue'</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  components: {</p>
			<p class="source-code">    NewsletterBanner</p>
			<p class="source-code">  },</p>
			<p class="source-code">  // other component properties</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>We'll then install Vuex with the <strong class="source-inline">npm install --save vuex</strong> command. Once Vuex is installed, we can initialize our store in a <strong class="source-inline">store.js</strong> file as follows:</p>
			<p class="source-code">import Vue from 'vue'</p>
			<p class="source-code">import Vuex from 'vuex'</p>
			<p class="source-code">Vue.use(Vuex)</p>
			<p class="source-code">export default new Vuex.Store({</p>
			<p class="source-code">  state: {},</p>
			<p class="source-code">  mutations: {}</p>
			<p class="source-code">})</p>
			<p>Our Vuex store is also registered in the <strong class="source-inline">main.js</strong> file:</p>
			<p class="source-code">// other imports</p>
			<p class="source-code">import store from './store'</p>
			<p class="source-code">// other configuration</p>
			<p class="source-code">new Vue({</p>
			<p class="source-code">  // other vue options</p>
			<p class="source-code">  store</p>
			<p class="source-code">}).$mount('#app')</p>
			<p>In order to decide whether the newsletter banner should be displayed or not, we need to add an initial state to our store:</p>
			<p class="source-code">// imports and configuration</p>
			<p class="source-code">export default new Vuex.Store({</p>
			<p class="source-code">  state: {</p>
			<p class="source-code">    dismissedSubscribeBanner: false</p>
			<p class="source-code">  }</p>
			<p class="source-code">})</p>
			<p>To close the banner, we need a mutation that will set <strong class="source-inline">dismissedSubscribeBanner</strong> to <strong class="source-inline">true</strong>:</p>
			<p class="source-code">// imports and configuration</p>
			<p class="source-code">export default new Vuex.Store({</p>
			<p class="source-code">  // other store configuration</p>
			<p class="source-code">  mutations: {</p>
			<p class="source-code">    dismissSubscribeBanner(state) {</p>
			<p class="source-code">      state.dismissedSubscribeBanner = true</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">})</p>
			<p>We can now use the store state and the <strong class="source-inline">dismissSubscribeBanner</strong> mutation to decide whether to show the banner (using <strong class="source-inline">v-if</strong>) and whether to close it (binding to a click on the <strong class="source-inline">close</strong> button):</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div v-if="showBanner" class="text-center py-4 md:px-4"&gt;</p>
			<p class="source-code">    &lt;!-- rest of template --&gt;</p>
			<p class="source-code">      &lt;svg</p>
			<p class="source-code">        @click="closeBanner()"</p>
			<p class="source-code">        class="fill-current h-6 w-6 text-indigo-500"</p>
			<p class="source-code">        role="button"</p>
			<p class="source-code">        xmlns=http://www.w3.org/2000/svg</p>
			<p class="source-code">        viewBox="0 0 20 20"</p>
			<p class="source-code">      &gt;</p>
			<p class="source-code">    &lt;!-- rest of the template --&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  methods: {</p>
			<p class="source-code">    closeBanner() {</p>
			<p class="source-code">      this.$store.commit('dismissSubscribeBanner')</p>
			<p class="source-code">    }</p>
			<p class="source-code">  },</p>
			<p class="source-code">  computed: {</p>
			<p class="source-code">    showBanner() {</p>
			<p class="source-code">      return !this.$store.state.dismissedSubscribeBanner</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>At this point, the banner looks like this in a browser:</p>
			<div>
				<div id="_idContainer354" class="IMG---Figure">
					<img src="image/B15218_12_23.jpg" alt="Figure 12.23: Newsletter banner displayed in a browser&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.23: Newsletter banner displayed in a browser</p>
			<p>To write unit tests, we will use the Vue Testing library, which provides a facility for injecting a Vuex store. We'll need to import the store and the <strong class="source-inline">NewsletterBanner</strong> component.</p>
			<p>We can start with a sanity check that, by default, the newsletter banner is displayed:</p>
			<p class="source-code">import {render, fireEvent} from '@testing-library/vue'</p>
			<p class="source-code">import NewsletterBanner from '../src/components/  NewsletterBanner.vue'</p>
			<p class="source-code">import store from '../src/store'</p>
			<p class="source-code">test('Newsletter Banner should display if store is initialised   with it not dismissed', () =&gt; {</p>
			<p class="source-code">  const {queryByText} = render(NewsletterBanner, { store })</p>
			<p class="source-code">  expect(queryByText('Subscribe to the newsletter')).toBeTruthy()</p>
			<p class="source-code">})</p>
			<p>The next check should be that if the store has <strong class="source-inline">dismissedSubscribeBanner: true</strong>, the banner should not be displayed:</p>
			<p class="source-code">// imports and other tests</p>
			<p class="source-code">test('Newsletter Banner should not display if store is initialised with   it dismissed', () =&gt; {</p>
			<p class="source-code">  const {queryByText} = render(NewsletterBanner, { store: {</p>
			<p class="source-code">    state: {</p>
			<p class="source-code">      dismissedSubscribeBanner: true</p>
			<p class="source-code">    }</p>
			<p class="source-code">  } })</p>
			<p class="source-code">  expect(queryByText('Subscribe to the newsletter')).toBeFalsy()</p>
			<p class="source-code">})</p>
			<p>The final test we'll write is to make sure that clicking the banner's close button commits a mutation to the store. We can do this by injecting a stub as the <strong class="source-inline">dismissSubscribeBanner</strong> mutation and checking that it is called when clicking the close button:</p>
			<p class="source-code">// imports and other tests</p>
			<p class="source-code">test('Newsletter Banner should hide on "close" button click',   async () =&gt; {</p>
			<p class="source-code">  const dismissSubscribeBanner = jest.fn()</p>
			<p class="source-code">  const {getByText} = render(NewsletterBanner, {</p>
			<p class="source-code">    store: {</p>
			<p class="source-code">      ...store,</p>
			<p class="source-code">      mutations: {</p>
			<p class="source-code">        dismissSubscribeBanner</p>
			<p class="source-code">      }</p>
			<p class="source-code">    }</p>
			<p class="source-code">  })</p>
			<p class="source-code">  await fireEvent.click(getByText('Close'))</p>
			<p class="source-code">  expect(dismissSubscribeBanner).toHaveBeenCalledTimes(1)</p>
			<p class="source-code">})</p>
			<p>The tests will now pass when run with <strong class="source-inline">npm run test:unit __tests__/NewsletterBanner.test.js</strong>, as follows:</p>
			<div>
				<div id="_idContainer355" class="IMG---Figure">
					<img src="image/B15218_12_24.jpg" alt="Figure 12.24: Unit tests for NewsletterBanner passing on the command line&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.24: Unit tests for NewsletterBanner passing on the command line</p>
			<p>We've now seen how the Vue.js Testing library can be used to test application functionality driven by Vuex.</p>
			<h2 id="_idParaDest-256">Exercise 12.04: Building<a id="_idTextAnchor340"/> and Testing a Cookie Disclaimer Banner (Vuex)</h2>
			<p>We'll now look at how to implement a cookie disclaimer banner using Vuex and how to test it with the Vue.js Testing library.</p>
			<p>We will store whether the cookie banner is showing in Vuex (the default is <strong class="source-inline">true</strong>); when the banner is closed, we will store it in Vuex.</p>
			<p>Test this opening/closing with a mock Vuex store. To access the code files for this exercise, refer to <a href="https://packt.live/36UzksP">https://packt.live/36UzksP</a>:</p>
			<ol>
				<li value="1">Create a green cookie banner with a <strong class="source-inline">Cookies Disclaimer</strong> title in bold, the disclaimer, and an <strong class="source-inline">I agree</strong> button. We will create this in <strong class="source-inline">src/components/CookieBanner.vue</strong>:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div</p><p class="source-code">    class="flex flex-row bg-green-100 border text-center       border-green-400</p><p class="source-code">    text-green-700 mt-8 px-4 md:px-8 py-3 rounded relative"</p><p class="source-code">    role="alert"</p><p class="source-code">  &gt;</p><p class="source-code">    &lt;div class="flex flex-col"&gt;</p><p class="source-code">      &lt;strong class="font-bold w-full flex"&gt;Cookies Disclaimer</p><p class="source-code">      &lt;/strong&gt;</p><p class="source-code">      &lt;span class="block sm:inline"&gt;We use cookies to improve your experience&lt;/span&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">    &lt;button</p><p class="source-code">      class="ml-auto align-center bg-transparent         hover:bg-green-500</p><p class="source-code">      text-green-700 font-semibold font-sm hover:text-white         py-2 px-4 border</p><p class="source-code">      border-green-500 hover:border-transparent rounded"</p><p class="source-code">    &gt;</p><p class="source-code">      I agree</p><p class="source-code">    &lt;/button&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p></li>
				<li>Next, we will import, register, and render <strong class="source-inline">CookieBanner</strong> below <strong class="source-inline">router-view</strong> in <strong class="source-inline">src/App.vue</strong>:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;!-- rest of template --&gt;</p><p class="source-code">      &lt;CookieBanner /&gt;</p><p class="source-code">  &lt;!-- rest of template --&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">// other imports</p><p class="source-code">import CookieBanner from './components/CookieBanner.vue'</p><p class="source-code">export default {</p><p class="source-code">  components: {</p><p class="source-code">    // other components</p><p class="source-code">    CookieBanner</p><p class="source-code">  },</p><p class="source-code">  // other component properties</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>Add a <strong class="source-inline">state</strong> slice to control whether to display the cookie banner. In our Vuex store, we will initialize this <strong class="source-inline">acceptedCookie</strong> field as <strong class="source-inline">false</strong>:<p class="source-code">// imports and configuration</p><p class="source-code">export default new Vuex.Store({</p><p class="source-code">  state: {</p><p class="source-code">    // other state fields</p><p class="source-code">    acceptedCookie: false</p><p class="source-code">  },</p><p class="source-code">  // rest of vuex configuration</p><p class="source-code">})</p></li>
				<li>We will also need an <strong class="source-inline">acceptCookie</strong> mutation to close the banner:<p class="source-code">// imports and configuration</p><p class="source-code">export default new Vuex.Store({</p><p class="source-code">  // rest of vuex configuration</p><p class="source-code">  mutations: {</p><p class="source-code">    // other mutations</p><p class="source-code">    acceptCookie(state) {</p><p class="source-code">      state.acceptedCookie = true</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">})</p></li>
				<li>Next, we will expose store state as an <strong class="source-inline">acceptedCookie</strong> computed property. We will create an <strong class="source-inline">acceptCookie</strong> function that triggers the <strong class="source-inline">acceptCookie</strong> mutation:<p class="source-code">export default {</p><p class="source-code">  methods: {</p><p class="source-code">    acceptCookie() {</p><p class="source-code">      this.$store.commit('acceptCookie')</p><p class="source-code">    }</p><p class="source-code">  },</p><p class="source-code">  computed: {</p><p class="source-code">    acceptedCookie() {</p><p class="source-code">      return this.$store.state.acceptedCookie</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>We will use <strong class="source-inline">v-if</strong> to show the banner when cookies have not been accepted yet. The <strong class="source-inline">I agree</strong> button will close the banner when it's clicked by toggling <strong class="source-inline">acceptCookie</strong>:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div</p><p class="source-code">    v-if="!acceptedCookie"</p><p class="source-code">    class="flex flex-row bg-green-100 border text-center       border-green-400</p><p class="source-code">    text-green-700 mt-8 px-4 md:px-8 py-3 rounded relative"</p><p class="source-code">    role="alert"</p><p class="source-code">  &gt;</p><p class="source-code">    &lt;!-- rest of template --&gt;</p><p class="source-code">    &lt;button</p><p class="source-code">      @click="acceptCookie()"</p><p class="source-code">      class="ml-auto align-center bg-transparent         hover:bg-green-500</p><p class="source-code">      text-green-700 font-semibold font-sm hover:text-white         py-2 px-4 border</p><p class="source-code">      border-green-500 hover:border-transparent rounded"</p><p class="source-code">    &gt;</p><p class="source-code">      I agree</p><p class="source-code">    &lt;/button&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p>We have now got a cookie banner that shows until <strong class="source-inline">I agree</strong> is clicked, as shown in the following screenshot:</p><div id="_idContainer356" class="IMG---Figure"><img src="image/B15218_12_25.jpg" alt="Figure 12.25: Cookie banner displayed in the browser&#13;&#10;"/></div><p class="figure-caption">Figure 12.25: Cookie banner displayed in the browser</p></li>
				<li>We will now write a test that checks that the <strong class="source-inline">CookieBanner</strong> component is displayed by default:<p class="source-code">import {render, fireEvent} from '@testing-library/vue'</p><p class="source-code">import CookieBanner from '../src/components/CookieBanner.vue'</p><p class="source-code">import store from '../src/store'</p><p class="source-code">test('Cookie Banner should display if store is initialised with   it not dismissed', () =&gt; {</p><p class="source-code">  const {queryByText} = render(CookieBanner, { store })</p><p class="source-code">  expect(queryByText('Cookies Disclaimer')).toBeTruthy()</p><p class="source-code">})</p></li>
				<li>We will also write a test to check that if <strong class="source-inline">acceptedCookie</strong> is true in the store, the cookie banner won't be displayed:<p class="source-code">test('Cookie Banner should not display if store is initialised   with it dismissed', () =&gt; {</p><p class="source-code">  const {queryByText} = render(CookieBanner, { store: {</p><p class="source-code">    state: {</p><p class="source-code">      acceptedCookie: true</p><p class="source-code">    }</p><p class="source-code">  } })</p><p class="source-code">  expect(queryByText('Cookies Disclaimer')).toBeFalsy()</p><p class="source-code">})</p></li>
				<li>Finally, we want to check that when the <strong class="source-inline">I agree</strong> button is clicked, the <strong class="source-inline">acceptCookie</strong> mutation is triggered:<p class="source-code">test('Cookie Banner should hide on "I agree" button click',   async () =&gt; {</p><p class="source-code">  const acceptCookie = jest.fn()</p><p class="source-code">  const {getByText} = render(CookieBanner, {</p><p class="source-code">    store: {</p><p class="source-code">      ...store,</p><p class="source-code">      mutations: {</p><p class="source-code">        acceptCookie</p><p class="source-code">      }</p><p class="source-code">    }</p><p class="source-code">  })</p><p class="source-code">  await fireEvent.click(getByText('I agree'))</p><p class="source-code">  expect(acceptCookie).toHaveBeenCalledTimes(1)</p><p class="source-code">})</p><p>The three tests we wrote pass when run with <strong class="source-inline">npm run test:unit __tests__/CookieBanner.test.js</strong>, as follows:</p><div id="_idContainer357" class="IMG---Figure"><img src="image/B15218_12_26.jpg" alt="Figure 12.26: Tests for the cookie banner passing&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 12.26: Tests for the cookie banner passing</p>
			<p>We've now seen how to test components that rely on Vuex for state and updates.</p>
			<p>Next, we'll look at snapshot testing and see how it simplifies the testing of render output.</p>
			<h1 id="_idParaDest-257"><a id="_idTextAnchor341"/>Snapshot Testing</h1>
			<p><strong class="bold">Snapshot <a id="_idTextAnchor342"/>tests</strong> provide a way to write tests for fast-changing pieces of code without keeping the assertion data inline with the test. They store snapshots instead.</p>
			<p>Changes to a snapshot reflect changes to the output, which is quite useful for code reviews.</p>
			<p>For example, we can add a snapshot test to the <strong class="source-inline">PostList.test.js</strong> file:</p>
			<p class="source-code">// imports and tests</p>
			<p class="source-code">test('Post List renders correctly', () =&gt; {</p>
			<p class="source-code">  const wrapper = mount(PostList, {</p>
			<p class="source-code">    propsData: {</p>
			<p class="source-code">      posts: [</p>
			<p class="source-code">        {</p>
			<p class="source-code">          title: 'Title 1',</p>
			<p class="source-code">          description: 'Description 1',</p>
			<p class="source-code">          tags: ['react', 'vue']</p>
			<p class="source-code">        },</p>
			<p class="source-code">        {</p>
			<p class="source-code">          title: 'Title 2',</p>
			<p class="source-code">          description: 'Description 2',</p>
			<p class="source-code">          tags: ['html', 'angularjs']</p>
			<p class="source-code">        }</p>
			<p class="source-code">      ]</p>
			<p class="source-code">    }</p>
			<p class="source-code">  })</p>
			<p class="source-code">  expect(wrapper.text()).toMatchSnapshot()</p>
			<p class="source-code">})</p>
			<p>When we next run this test file, with <strong class="source-inline">npm run test:unit __tests__/PostList.test.js</strong>, we will get the following output:</p>
			<div>
				<div id="_idContainer358" class="IMG---Figure">
					<img src="image/B15218_12_27.jpg" alt="Figure 12.27: Snapshot test run for the first time&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.27: Snapshot test run for the first time</p>
			<p>The snapshot was written to <strong class="source-inline">__tests__/__snapshots__/PostList.test.js.snap</strong>, as follows:</p>
			<p class="source-code">// Jest Snapshot v1, https://goo.gl/fbAQLP</p>
			<p class="source-code">exports[`Post List renders correctly 1`] = `</p>
			<p class="source-code">"Title 1 Description 1 </p>
			<p class="source-code">      #react</p>
			<p class="source-code">    </p>
			<p class="source-code">      #vue</p>
			<p class="source-code">    Title 2 Description 2 </p>
			<p class="source-code">      #html</p>
			<p class="source-code">    </p>
			<p class="source-code">      #angularjs"</p>
			<p class="source-code">`;</p>
			<p>This makes it easy to quickly see what the changes mean in terms of concrete output.</p>
			<p>We've now seen how to use snapshot tests. Next, we'll put all the tools we learned in the chapter together to add a new page.</p>
			<h2 id="_idParaDest-258">Activity 12.01: Adding a Si<a id="_idTextAnchor343"/><a id="_idTextAnchor344"/>mple Search by Title Page with Tests</h2>
			<p>We have already built a post list page, a single-post view page, and a posts-by-tag page.</p>
			<p>A great way to resurface old content on a blog is by implementing a good search functionality. We will add search to the <strong class="source-inline">PostList</strong> page:</p>
			<ol>
				<li value="1">Create the search form with an input and a button in a new file at <strong class="source-inline">src/components/SearchForm.vue</strong>.</li>
				<li>We'll now get the form to display by importing, registering, and rendering it in <strong class="source-inline">src/App.vue</strong>.<p>We are now able to see the search form in the application, as follows:</p><div id="_idContainer359" class="IMG---Figure"><img src="image/B15218_12_28.jpg" alt="Figure 12.28: The post list view with a search form&#13;&#10;"/></div><p class="figure-caption">Figure 12.28: The post list view with a search form</p></li>
				<li>We're now ready to add a snapshot test for the search form. In <strong class="source-inline">__tests__/SearchForm.test.js</strong>, we should add <strong class="source-inline">SearchForm should match expected HTML</strong>.</li>
				<li>We want to track the contents of the search form input using <strong class="source-inline">v-model</strong> to two-way bind the <strong class="source-inline">searchTerm</strong> instance variable and the contents of the input.</li>
				<li>When the search form is submitted, we'll need to update the URL with the right parameter. This can be done with <strong class="source-inline">this.$router.push()</strong>. We will store the search in a <strong class="source-inline">q</strong> query parameter.</li>
				<li>We will want to reflect the state of the <strong class="source-inline">q</strong> query parameter in the search form input. We can do this by reading <strong class="source-inline">q</strong> from <strong class="source-inline">this.$route.query</strong> and setting it as the initial value for the <strong class="source-inline">searchTerm</strong> data field in the <strong class="source-inline">SearchForm</strong> component state.</li>
				<li>Next, we'll want to filter the posts passed to <strong class="source-inline">PostList</strong> on the home page. We'll use <strong class="source-inline">this.$route.query.q</strong> in a computed property that filters posts by their title. This new computed property will then be used instead of <strong class="source-inline">posts</strong> in <strong class="source-inline">src/App.vue</strong>.</li>
				<li>Next, we should add a test that changes the search query parameter and check that the app shows the right result. To do this, we can import <strong class="source-inline">src/App.vue, src/store.js</strong> and <strong class="source-inline">src/router.js</strong>, and render the app with the store and the router. We can then update the search field contents by using the fact that the placeholder for the field is <strong class="source-inline">Search</strong>. Finally, we can submit the form by clicking the element where <strong class="source-inline">test id</strong> is <strong class="source-inline">Search</strong> (which is the <strong class="source-inline">search</strong> button).<p class="callout-heading">Note</p><p class="callout">The solution for this activity can be found via <a href="B15218_Solution_Final_SZ_ePub.xhtml#_idTextAnchor405">this link</a>.</p></li>
			</ol>
			<h1 id="_idParaDest-259"><a id="_idTextAnchor345"/>Summary</h1>
			<p>Throughout this chap<a id="_idTextAnchor346"/>ter, we've looked at different approaches to testing different types of Vue.js applications.</p>
			<p>Testing in general is useful for empirically showing that the system is working. Unit tests are the cheapest to build and maintain and should be the base of testing functionality. System tests are the next level up in the testing pyramid and allow you to gain confidence that the majority of features are working as expected. End-to-end tests show that the main flows of the full system work.</p>
			<p>We've seen how to unit test components, filters, component methods, and mixins, as well as testing through the layers, and testing component output in a black box fashion instead of inspecting component internals to test functionality. Using the Vue.js Testing library, we have tested advanced functionality, such as routing and applications, that leverage Vuex.</p>
			<p>Finally, we looked at snapshot testing and saw how it can be an effective way to write tests for template-heavy chunks of code.</p>
			<p>In the next chapter, we will look at end-to-end testing techniques that can be applied to Vue.js applications.</p>
		</div>
		<div>
			<div id="_idContainer361" class="Content">
			</div>
		</div>
	</body></html>