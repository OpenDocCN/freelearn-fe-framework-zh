<html><head></head><body>
<div id="_idContainer134" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-273"><a id="_idTextAnchor276" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1.1">15</span></h1>
<h1 id="_idParaDest-274" class="calibre5"><a id="_idTextAnchor277" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.2.1">Adding Persistence to Socket.IO Using MongoDB</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.3.1">Now that we have implemented a Socket.IO backend and frontend, let’s spend some time integrating it with the MongoDB database by temporarily storing messages in the database and replaying them when a new user joins, so that users can see the chat history after they join. </span><span class="kobospan" id="kobo.3.2">Additionally, we will refactor our chat app to be ready for future expansions and maintenance. </span><span class="kobospan" id="kobo.3.3">Finally, we will test out the new structure by implementing new commands to join and </span><span><span class="kobospan" id="kobo.4.1">switch rooms.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.5.1">In this chapter, we are going to cover the following </span><span><span class="kobospan" id="kobo.6.1">main topics:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.7.1">Storing and replaying messages </span><span><span class="kobospan" id="kobo.8.1">using MongoDB</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.9.1">Refactoring the app to be </span><span><span class="kobospan" id="kobo.10.1">more extensible</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.11.1">Implementing commands to join and </span><span><span class="kobospan" id="kobo.12.1">switch rooms</span></span></li>
</ul>
<h1 id="_idParaDest-275" class="calibre5"><a id="_idTextAnchor278" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.13.1">Technical requirements</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.14.1">Before we start, please install all requirements from </span><a href="B19385_01.xhtml#_idTextAnchor016" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.15.1">Chapter 1</span></em></span></a><em class="italic"><span class="kobospan" id="kobo.16.1">, Preparing for Full Stack Development</span></em><span class="kobospan" id="kobo.17.1">, and </span><a href="B19385_02.xhtml#_idTextAnchor028" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.18.1">Chapter 2</span></em></span></a><em class="italic"><span class="kobospan" id="kobo.19.1">, Getting to Know Node.js </span></em><span><em class="italic"><span class="kobospan" id="kobo.20.1">and MongoDB</span></em></span><span><span class="kobospan" id="kobo.21.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.22.1">The versions listed in those chapters are the ones used in the book. </span><span class="kobospan" id="kobo.22.2">While installing a newer version should not be an issue, please note that certain steps might work differently on a newer version. </span><span class="kobospan" id="kobo.22.3">If you are having an issue with the code and steps provided in this book, please try using the versions mentioned in </span><em class="italic"><span class="kobospan" id="kobo.23.1">Chapters 1</span></em> <span><span class="kobospan" id="kobo.24.1">and </span></span><span><em class="italic"><span class="kobospan" id="kobo.25.1">2</span></em></span><span><span class="kobospan" id="kobo.26.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.27.1">You can find the code for this chapter on </span><span><span class="kobospan" id="kobo.28.1">GitHub: </span></span><a href="https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch15" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.29.1">https://github.com/PacktPublishing/Modern-Full-Stack-React-Projects/tree/main/ch15</span></span></a><span><span class="kobospan" id="kobo.30.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.31.1">If you cloned the full repository for the book, Husky may not find the </span><strong class="source-inline"><span class="kobospan" id="kobo.32.1">.git</span></strong><span class="kobospan" id="kobo.33.1"> directory when running </span><strong class="source-inline"><span class="kobospan" id="kobo.34.1">npm install</span></strong><span class="kobospan" id="kobo.35.1">. </span><span class="kobospan" id="kobo.35.2">In that case, just run </span><strong class="source-inline"><span class="kobospan" id="kobo.36.1">git init</span></strong><span class="kobospan" id="kobo.37.1"> in the root of the corresponding </span><span><span class="kobospan" id="kobo.38.1">chapter folder.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.39.1">The CiA video for this chapter can be found </span><span><span class="kobospan" id="kobo.40.1">at: </span></span><a href="https://youtu.be/Mi7Wj_jxjhM" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.41.1">https://youtu.be/Mi7Wj_jxjhM</span></span></a><span><span class="kobospan" id="kobo.42.1">.</span></span></p>
<h1 id="_idParaDest-276" class="calibre5"><a id="_idTextAnchor279" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.43.1">Storing and replaying messages using MongoDB</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.44.1">Currently, if a new user joins the chat, they will not see any messages until someone actively sends messages. </span><span class="kobospan" id="kobo.44.2">As such, new users will not be able to participate well in ongoing discussions. </span><span class="kobospan" id="kobo.44.3">To solve this issue, we can store messages in the database and replay them when a </span><span><span class="kobospan" id="kobo.45.1">user joins.</span></span></p>
<h2 id="_idParaDest-277" class="calibre7"><a id="_idTextAnchor280" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.46.1">Creating the Mongoose schema</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.47.1">Follow </span><a id="_idIndexMarker841" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.48.1">these steps to create a Mongoose schema for storing </span><span><span class="kobospan" id="kobo.49.1">chat messages:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.50.1">Copy the existing </span><strong class="source-inline1"><span class="kobospan" id="kobo.51.1">ch14</span></strong><span class="kobospan" id="kobo.52.1"> folder to a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.53.1">ch15</span></strong><span class="kobospan" id="kobo.54.1"> folder, </span><span><span class="kobospan" id="kobo.55.1">as follows:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.56.1">$ cp -R ch14 ch15</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.57.1">Open the new </span><strong class="source-inline1"><span class="kobospan" id="kobo.58.1">ch15</span></strong><span class="kobospan" id="kobo.59.1"> folder in </span><span><span class="kobospan" id="kobo.60.1">VS Code.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.61.1">Create a new </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.62.1">backend/src/db/models/message.js</span></strong></span><span><span class="kobospan" id="kobo.63.1"> file.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.64.1">Inside it, define a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.65.1">messageSchema</span></strong><span class="kobospan" id="kobo.66.1">, which we are going to use to store chat messages in </span><span><span class="kobospan" id="kobo.67.1">the database:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.68.1">
import mongoose, { Schema } from 'mongoose'
const messageSchema = new Schema({</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.69.1">The message schema should contain </span><strong class="source-inline1"><span class="kobospan" id="kobo.70.1">username</span></strong><span class="kobospan" id="kobo.71.1"> (person who sent the message), </span><strong class="source-inline1"><span class="kobospan" id="kobo.72.1">message</span></strong><span class="kobospan" id="kobo.73.1">, a </span><strong class="source-inline1"><span class="kobospan" id="kobo.74.1">room</span></strong><span class="kobospan" id="kobo.75.1"> that it was sent in, and a </span><strong class="source-inline1"><span class="kobospan" id="kobo.76.1">sent</span></strong><span class="kobospan" id="kobo.77.1"> date for when the message </span><span><span class="kobospan" id="kobo.78.1">was sent:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.79.1">
  username: { type: String, required: true },
  message: { type: String, required: true },
  room: { type: String, required: true },
  sent: { type: Date, expires: 5 * 60, default: Date.now, required: true },
})</span></pre><p class="calibre3"><span class="kobospan" id="kobo.80.1">For the </span><strong class="source-inline"><span class="kobospan" id="kobo.81.1">sent</span></strong><span class="kobospan" id="kobo.82.1"> date, we specify </span><strong class="source-inline"><span class="kobospan" id="kobo.83.1">expires</span></strong><span class="kobospan" id="kobo.84.1"> to make the messages automatically expire after 5 minutes (</span><strong class="source-inline"><span class="kobospan" id="kobo.85.1">5 * 60</span></strong><span class="kobospan" id="kobo.86.1"> seconds). </span><span class="kobospan" id="kobo.86.2">This ensures that our database does not get cluttered with lots of chat messages. </span><span class="kobospan" id="kobo.86.3">We also set the </span><strong class="source-inline"><span class="kobospan" id="kobo.87.1">default</span></strong><span class="kobospan" id="kobo.88.1"> value to </span><strong class="source-inline"><span class="kobospan" id="kobo.89.1">Date.now</span></strong><span class="kobospan" id="kobo.90.1"> so that all messages are by default tagged as being sent at the </span><span><span class="kobospan" id="kobo.91.1">current time.</span></span></p></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.92.1">Info</span></p>
<p class="callout"><span class="kobospan" id="kobo.93.1">MongoDB only actually checks for data expiration once a minute, so the expired documents might persist for up to a minute past their defined </span><span><span class="kobospan" id="kobo.94.1">expiration time.</span></span></p>
<ol class="calibre15">
<li value="6" class="calibre11"><span class="kobospan" id="kobo.95.1">Create a </span><a id="_idIndexMarker842" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.96.1">model from the schema and </span><span><span class="kobospan" id="kobo.97.1">export it:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.98.1">
export const Message = mongoose.model('message', messageSchema)</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.99.1">After creating the Mongoose schema and model, let’s move on to creating the service functions for dealing with </span><span><span class="kobospan" id="kobo.100.1">chat messages.</span></span></p>
<h2 id="_idParaDest-278" class="calibre7"><a id="_idTextAnchor281" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.101.1">Creating the service functions</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.102.1">We need to create service functions</span><a id="_idIndexMarker843" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.103.1"> to save a new message in the database and to get all messages sent in a given room, sorted by </span><strong class="source-inline"><span class="kobospan" id="kobo.104.1">sent</span></strong><span class="kobospan" id="kobo.105.1"> date, showing the oldest messages first. </span><span class="kobospan" id="kobo.105.2">Follow these steps to implement the </span><span><span class="kobospan" id="kobo.106.1">service functions:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.107.1">Create a new </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.108.1">backend/src/services/messages.js</span></strong></span><span><span class="kobospan" id="kobo.109.1"> file.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.110.1">Inside it, import the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.111.1">Message</span></strong></span><span><span class="kobospan" id="kobo.112.1"> model:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.113.1">
import { Message } from '../db/models/message.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.114.1">Then, define a function to create a new </span><strong class="source-inline1"><span class="kobospan" id="kobo.115.1">Message</span></strong><span class="kobospan" id="kobo.116.1"> object in </span><span><span class="kobospan" id="kobo.117.1">the database:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.118.1">
export async function createMessage({ username, message, room }) {
  const messageDoc = new Message({ username, message, room })
  return await messageDoc.save()
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.119.1">Also, define </span><a id="_idIndexMarker844" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.120.1">a function to get all messages from a certain room, listing the oldest </span><span><span class="kobospan" id="kobo.121.1">messages first:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.122.1">
export async function getMessagesByRoom(room) {
  return await Message.find({ room }).sort({ sent: 1 })
}</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.123.1">Next, we are going to use these service functions in our </span><span><span class="kobospan" id="kobo.124.1">chat server.</span></span></p>
<h2 id="_idParaDest-279" class="calibre7"><a id="_idTextAnchor282" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.125.1">Storing and replaying messages</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.126.1">Now that we have all the </span><a id="_idIndexMarker845" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.127.1">functions, we need to implement storing and replaying messages </span><a id="_idIndexMarker846" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.128.1">in our chat server. </span><span class="kobospan" id="kobo.128.2">Follow these steps to implement </span><span><span class="kobospan" id="kobo.129.1">the functionality:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.130.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.131.1">backend/src/socket.js</span></strong><span class="kobospan" id="kobo.132.1"> and import the service functions we </span><span><span class="kobospan" id="kobo.133.1">defined earlier:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.134.1">
import { createMessage, getMessagesByRoom } from './services/messages.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.135.1">When a new user connects, get all messages from the current room, and send (replay) them to the user </span><span><span class="kobospan" id="kobo.136.1">using </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.137.1">socket.emit</span></strong></span><span><span class="kobospan" id="kobo.138.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.139.1">
export function handleSocket(io) {
  io.on('connection', </span><strong class="bold1"><span class="kobospan1" id="kobo.140.1">async</span></strong><span class="kobospan1" id="kobo.141.1"> (socket) =&gt; {
    const room = socket.handshake.query?.room ?? </span><span class="kobospan1" id="kobo.141.2">'public'
    socket.join(room)
    console.log(socket.id, 'joined room:', room)
</span><strong class="bold1"><span class="kobospan1" id="kobo.142.1">    const messages = await getMessagesByRoom(room)</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.143.1">    messages.forEach(({ username, message }) =&gt;</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.144.1">      socket.emit('chat.message', { username, message }),</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.145.1">    )</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.146.1">Additionally, when </span><a id="_idIndexMarker847" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.147.1">a user sends </span><a id="_idIndexMarker848" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.148.1">a message, store it in </span><span><span class="kobospan" id="kobo.149.1">the database:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.150.1">
    socket.on('chat.message', (message) =&gt; {
      console.log(`${socket.id}: ${message}`)
      io.to(room).emit('chat.message', {
        username: socket.user.username,
        message,
      })
</span><strong class="bold1"><span class="kobospan1" id="kobo.151.1">      createMessage({ username: socket.user.username, message, room })</span></strong><span class="kobospan1" id="kobo.152.1">
    })</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.153.1">Start the frontend server </span><span><span class="kobospan" id="kobo.154.1">as follows:</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.155.1">$ npm run dev</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.156.1">Then, start the backend server (do not forget to start the Docker container for </span><span><span class="kobospan" id="kobo.157.1">the database!):</span></span><pre class="source-code">
<strong class="bold1"><span class="kobospan1" id="kobo.158.1">$ cd backend/</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.159.1">$ npm run dev</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.160.1">Go to </span><strong class="source-inline1"><span class="kobospan" id="kobo.161.1">http://localhost:5173/</span></strong><span class="kobospan" id="kobo.162.1">, log in and send some messages. </span><span class="kobospan" id="kobo.162.2">Then, open a new tab, log</span><a id="_idIndexMarker849" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.163.1"> in with a different user, and you will see the messages sent earlier </span><span><span class="kobospan" id="kobo.164.1">get </span></span><span><a id="_idIndexMarker850" class="calibre6 pcalibre1 pcalibre"/></span><span><span class="kobospan" id="kobo.165.1">replayed:</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer131">
<span class="kobospan" id="kobo.166.1"><img alt="Figure 15.1 – Successfully replaying stored messages" src="image/B19385_15_1.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.167.1">Figure 15.1 – Successfully replaying stored messages</span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.168.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.169.1">The screenshot in </span><span><em class="italic"><span class="kobospan" id="kobo.170.1">Figure 15</span></em></span><em class="italic"><span class="kobospan" id="kobo.171.1">.1</span></em><span class="kobospan" id="kobo.172.1"> is from a later version of the app, where we show messages when a user joins a room (we are going to implement these messages later in this chapter). </span><span class="kobospan" id="kobo.172.2">Here, we use these messages to show that replaying works when the user joins after a message </span><span><span class="kobospan" id="kobo.173.1">was sent.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.174.1">If you wait 5 minutes and then join the chat again, you will see that the existing messages have expired and are not </span><span><span class="kobospan" id="kobo.175.1">replayed anymore.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.176.1">Now, let’s make it clearer which messages were replayed in the </span><span><span class="kobospan" id="kobo.177.1">user interface.</span></span></p>
<h2 id="_idParaDest-280" class="calibre7"><a id="_idTextAnchor283" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.178.1">Visually distinguishing replayed messages</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.179.1">Currently, it looks like the </span><a id="_idIndexMarker851" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.180.1">other user sent the message right after we joined. </span><span class="kobospan" id="kobo.180.2">It is not clear that the message was replayed from the server. </span><span class="kobospan" id="kobo.180.3">To solve this issue, we can visually distinguish replayed messages by, for example, making them slightly grayer. </span><span class="kobospan" id="kobo.180.4">Let’s do that now, </span><span><span class="kobospan" id="kobo.181.1">as follows:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.182.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.183.1">backend/src/socket.js</span></strong><span class="kobospan" id="kobo.184.1"> and add a </span><strong class="source-inline1"><span class="kobospan" id="kobo.185.1">replayed</span></strong><span class="kobospan" id="kobo.186.1"> flag to the </span><span><span class="kobospan" id="kobo.187.1">replayed messages:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.188.1">
    const messages = await getMessagesByRoom(room)
    messages.forEach(({ username, message }) =&gt;
      socket.emit('chat.message', { username, message</span><strong class="bold1"><span class="kobospan1" id="kobo.189.1">, replayed: true</span></strong><span class="kobospan1" id="kobo.190.1"> }),
    )</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.191.1">Now, edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.192.1">src/components/ChatMessage.jsx</span></strong><span class="kobospan" id="kobo.193.1">, and if the </span><strong class="source-inline1"><span class="kobospan" id="kobo.194.1">replayed</span></strong><span class="kobospan" id="kobo.195.1"> flag was set, display the messages with a </span><span><span class="kobospan" id="kobo.196.1">lower opacity:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.197.1">
export function ChatMessage({ username, message</span><strong class="bold1"><span class="kobospan1" id="kobo.198.1">, replayed</span></strong><span class="kobospan1" id="kobo.199.1"> }) {
  return (
    &lt;div</span><strong class="bold1"><span class="kobospan1" id="kobo.200.1"> style={{ opacity: replayed ? </span><span class="kobospan1" id="kobo.200.2">0.5 : 1.0 }}</span></strong><span class="kobospan1" id="kobo.201.1">&gt;</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.202.1">Do not forget to update </span><strong class="source-inline1"><span class="kobospan" id="kobo.203.1">propTypes</span></strong><span class="kobospan" id="kobo.204.1"> and add the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.205.1">replayed</span></strong></span><span><span class="kobospan" id="kobo.206.1"> flag:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.207.1">
ChatMessage.propTypes = {
  username: PropTypes.string,
  message: PropTypes.string.isRequired,
</span><strong class="bold1"><span class="kobospan1" id="kobo.208.1">  replayed: PropTypes.bool,</span></strong><span class="kobospan1" id="kobo.209.1">
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.210.1">Go to </span><strong class="source-inline1"><span class="kobospan" id="kobo.211.1">http://localhost:5173/</span></strong><span class="kobospan" id="kobo.212.1"> again and repeat the same procedure (sending messages from one user, then logging in with a different user in another tab), and </span><a id="_idIndexMarker852" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.213.1">you will see that replayed messages are now easy to distinguish from </span><span><span class="kobospan" id="kobo.214.1">new messages:</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer132">
<span class="kobospan" id="kobo.215.1"><img alt="Figure 15.2 – Replayed messages are now displayed in a lighter color" src="image/B19385_15_2.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.216.1">Figure 15.2 – Replayed messages are now displayed in a lighter color</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.217.1">Now that we have successfully stored our message history in the database, let’s focus a bit on refactoring the chat app to make it more extensible and maintainable in </span><span><span class="kobospan" id="kobo.218.1">the future.</span></span></p>
<h1 id="_idParaDest-281" class="calibre5"><a id="_idTextAnchor284" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.219.1">Refactoring the app to be more extensible</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.220.1">For the refactoring, we will start by defining service functions for all chat functionality that our </span><span><span class="kobospan" id="kobo.221.1">server provides.</span></span></p>
<h2 id="_idParaDest-282" class="calibre7"><a id="_idTextAnchor285" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.222.1">Defining service functions</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.223.1">Follow </span><a id="_idIndexMarker853" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.224.1">these steps to get started defining service functions for the </span><span><span class="kobospan" id="kobo.225.1">chat functionality:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.226.1">Create a new </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.227.1">backend/src/services/chat.js</span></strong></span><span><span class="kobospan" id="kobo.228.1"> file.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.229.1">Inside it, import the service functions related </span><span><span class="kobospan" id="kobo.230.1">to messages:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.231.1">
import { createMessage, getMessagesByRoom } from './messages.js'</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.232.1">Define a new function to send a private message directly to </span><span><span class="kobospan" id="kobo.233.1">a user:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.234.1">
export function sendPrivateMessage(
  socket,
  { username, room, message, replayed },
) {
  socket.emit('chat.message', { username, message, room, replayed })
}</span></pre><p class="calibre3"><span class="kobospan" id="kobo.235.1">Private messages will be used to, for example, replay messages to a specific user, and are not stored in </span><span><span class="kobospan" id="kobo.236.1">the database.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.237.1">Also, define a function to send a </span><span><span class="kobospan" id="kobo.238.1">system message:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.239.1">
export function sendSystemMessage(io, { room, message }) {
  io.to(room).emit('chat.message', { message, room })
}</span></pre><p class="calibre3"><span class="kobospan" id="kobo.240.1">System messages will be used to, for example, announce that a user joined a room. </span><span class="kobospan" id="kobo.240.2">We also do not want to store these in </span><span><span class="kobospan" id="kobo.241.1">the database.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.242.1">Then, define</span><a id="_idIndexMarker854" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.243.1"> a function to send a </span><span><span class="kobospan" id="kobo.244.1">public message:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.245.1">
export function sendPublicMessage(io, { username, room, message }) {
  io.to(room).emit('chat.message', { username, message, room })
  createMessage({ username, message, room })
}</span></pre><p class="calibre3"><span class="kobospan" id="kobo.246.1">Public messages will be used to send regular chat messages to a room. </span><span class="kobospan" id="kobo.246.2">These messages are stored in the database so that we can replay </span><span><span class="kobospan" id="kobo.247.1">them later.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.248.1">We also define a new function to join a given </span><strong class="source-inline1"><span class="kobospan" id="kobo.249.1">socket</span></strong><span class="kobospan" id="kobo.250.1"> to </span><span><span class="kobospan" id="kobo.251.1">a </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.252.1">room</span></strong></span><span><span class="kobospan" id="kobo.253.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.254.1">
export async function joinRoom(io, socket, { room }) {
  socket.join(room)</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.255.1">Inside this function, send a system message telling everyone in the room that </span><span><span class="kobospan" id="kobo.256.1">someone joined:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.257.1">
  sendSystemMessage(io, {
    room,
    message: `User "${socket.user.username}" joined room "${room}"`,
  })</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.258.1">Then, replay </span><a id="_idIndexMarker855" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.259.1">all messages that were sent to the room privately to the user that just </span><span><span class="kobospan" id="kobo.260.1">joined it:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.261.1">
  const messages = await getMessagesByRoom(room)
  messages.forEach(({ username, message }) =&gt;
    sendPrivateMessage(socket, { username, message, room, replayed: true })
  )
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.262.1">Lastly, define a service function to get the user info from the </span><strong class="source-inline1"><span class="kobospan" id="kobo.263.1">socketId</span></strong><span class="kobospan" id="kobo.264.1">. </span><span class="kobospan" id="kobo.264.2">We simply copy and paste the code we have previously had in </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.265.1">backend/src/socket.js</span></strong></span><span><span class="kobospan" id="kobo.266.1"> here:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.267.1">
export async function getUserInfoBySocketId(io, socketId) {
  const sockets = await io.in(socketId).fetchSockets()
  if (sockets.length === 0) return null
  const socket = sockets[0]
  const userInfo = {
    socketId,
    rooms: Array.from(socket.rooms),
    user: socket.user,
  }
  return userInfo
}</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.268.1">Now that we have created the service functions for the chat functionality, let’s use them in the </span><span><span class="kobospan" id="kobo.269.1">Socket.IO server.</span></span></p>
<h2 id="_idParaDest-283" class="calibre7"><a id="_idTextAnchor286" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.270.1">Refactoring the Socket.IO server to use the service functions</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.271.1">Now that we </span><a id="_idIndexMarker856" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.272.1">have defined service functions, let’s refactor the chat server code to use them. </span><span class="kobospan" id="kobo.272.2">Follow these steps to </span><span><span class="kobospan" id="kobo.273.1">do so:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.274.1">Open </span><strong class="source-inline1"><span class="kobospan" id="kobo.275.1">backend/src/socket.js</span></strong><span class="kobospan" id="kobo.276.1"> and find the </span><span><span class="kobospan" id="kobo.277.1">following import:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.278.1">
import { createMessage, getMessagesByRoom } from './services/messages.js'</span></pre><p class="calibre3"><em class="italic"><span class="kobospan" id="kobo.279.1">Replace</span></em><span class="kobospan" id="kobo.280.1"> the preceding import with the following import to the new chat </span><span><span class="kobospan" id="kobo.281.1">service functions:</span></span></p><pre class="source-code"><span class="kobospan1" id="kobo.282.1">import {
  joinRoom,
  sendPublicMessage,
  getUserInfoBySocketId,
} from './services/chat.js'</span></pre></li> <li class="calibre11"><em class="italic"><span class="kobospan" id="kobo.283.1">Replace</span></em><span class="kobospan" id="kobo.284.1"> the whole </span><strong class="source-inline1"><span class="kobospan" id="kobo.285.1">handleSocket</span></strong><span class="kobospan" id="kobo.286.1"> function with the following new code. </span><span class="kobospan" id="kobo.286.2">When a connection is made, we automatically join the public room using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.287.1">joinRoom</span></strong> <span><span class="kobospan" id="kobo.288.1">service function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.289.1">
export function handleSocket(io) {
  io.on('connection', (socket) =&gt; {
</span><strong class="bold1"><span class="kobospan1" id="kobo.290.1">    joinRoom(io, socket, { room: 'public' })</span></strong></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.291.1">Then, define a listener for the </span><strong class="source-inline1"><span class="kobospan" id="kobo.292.1">chat.message</span></strong><span class="kobospan" id="kobo.293.1"> event and send it to the given room by using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.294.1">sendPublicMessage</span></strong> <span><span class="kobospan" id="kobo.295.1">service function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.296.1">
    socket.on('chat.message', (room, message) =&gt;
      sendPublicMessage(io, { username: socket.user.username, room, message }),
    )</span></pre></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.297.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.298.1">We changed the signature of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.299.1">chat.message</span></strong><span class="kobospan" id="kobo.300.1"> event to require passing a room now, so that we can implement a better way to deal with multiple rooms later. </span><span class="kobospan" id="kobo.300.2">Later, we need to make sure to adjust the client code to </span><span><span class="kobospan" id="kobo.301.1">accommodate this.</span></span></p>
<ol class="calibre15">
<li value="4" class="calibre11"><span class="kobospan" id="kobo.302.1">Next, define a</span><a id="_idIndexMarker857" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.303.1"> listener for the </span><strong class="source-inline1"><span class="kobospan" id="kobo.304.1">user.info</span></strong><span class="kobospan" id="kobo.305.1"> event, in which we use the </span><strong class="source-inline1"><span class="kobospan" id="kobo.306.1">async</span></strong><span class="kobospan" id="kobo.307.1"> service function </span><strong class="source-inline1"><span class="kobospan" id="kobo.308.1">getUserInfoBySocketId</span></strong><span class="kobospan" id="kobo.309.1"> and return the result of it in </span><strong class="source-inline1"><span class="kobospan" id="kobo.310.1">callback</span></strong><span class="kobospan" id="kobo.311.1"> to turn this event into </span><span><span class="kobospan" id="kobo.312.1">an acknowledgment:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.313.1">
    socket.on('user.info', async (socketId, callback) =&gt;
      callback(await getUserInfoBySocketId(io, socketId)),
    )
  })</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.314.1">Finally, we can re-use the authentication middleware </span><span><span class="kobospan" id="kobo.315.1">from before:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.316.1">
  io.use((socket, next) =&gt; {
    if (!socket.handshake.auth?.token) {
      return next(new Error('Authentication failed: no token provided'))
    }
    jwt.verify(
      socket.handshake.auth.token,
      process.env.JWT_SECRET,
      async (err, decodedToken) =&gt; {
        if (err) {
          return next(new Error('Authentication failed: invalid token'))
        }
        socket.auth = decodedToken
        socket.user = await getUserInfoById(socket.auth.sub)
        return next()
      },
    )
  })
}</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.317.1">Now that our chat server is refactored, let’s continue with refactoring the </span><span><span class="kobospan" id="kobo.318.1">client-side code.</span></span></p>
<h2 id="_idParaDest-284" class="calibre7"><a id="_idTextAnchor287" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.319.1">Refactoring the client-side code</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.320.1">Now that our</span><a id="_idIndexMarker858" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.321.1"> server-side code uses service functions to encapsulate the functionality of the chat app, let’s do a similar refactoring of the client-side code by extracting client-side commands into separate functions, </span><span><span class="kobospan" id="kobo.322.1">as follows:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.323.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.324.1">src/hooks/useChat.js</span></strong><span class="kobospan" id="kobo.325.1"> and within the </span><strong class="source-inline1"><span class="kobospan" id="kobo.326.1">useChat</span></strong><span class="kobospan" id="kobo.327.1"> hook, define a new function to clear </span><span><span class="kobospan" id="kobo.328.1">the messages:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.329.1">
  function clearMessages() {
    setMessages([])
  }</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.330.1">Then, define an </span><strong class="source-inline1"><span class="kobospan" id="kobo.331.1">async</span></strong><span class="kobospan" id="kobo.332.1"> function to get all rooms that the user </span><span><span class="kobospan" id="kobo.333.1">is in:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.334.1">
  async function getRooms() {
    const userInfo = await socket.emitWithAck('user.info', socket.id)
    const rooms = userInfo.rooms.filter((room) =&gt; room !== socket.id)
    return rooms
  }</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.335.1">We can</span><a id="_idIndexMarker859" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.336.1"> now use these functions in the </span><strong class="source-inline1"><span class="kobospan" id="kobo.337.1">sendMessage</span></strong><span class="kobospan" id="kobo.338.1"> function, </span><span><span class="kobospan" id="kobo.339.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.340.1">
  async function sendMessage(message) {
    if (message.startsWith('/')) {
      const command = message.substring(1)
      switch (command) {
        case 'clear':
          </span><strong class="bold1"><span class="kobospan1" id="kobo.341.1">clearMessages()</span></strong><span class="kobospan1" id="kobo.342.1">
          break
        case 'rooms': {
          const rooms = </span><strong class="bold1"><span class="kobospan1" id="kobo.343.1">await getRooms()</span></strong><span class="kobospan1" id="kobo.344.1">
          receiveMessage({
            message: `You are in: ${rooms.join(', ')}`,
          })
          break
        }</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.345.1">Lastly, we adjust the </span><strong class="source-inline1"><span class="kobospan" id="kobo.346.1">chat.message</span></strong><span class="kobospan" id="kobo.347.1"> event to send </span><strong class="source-inline1"><span class="kobospan" id="kobo.348.1">room</span></strong><span class="kobospan" id="kobo.349.1"> in addition to </span><strong class="source-inline1"><span class="kobospan" id="kobo.350.1">message</span></strong><span class="kobospan" id="kobo.351.1">. </span><span class="kobospan" id="kobo.351.2">For now, we always send messages to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.352.1">'</span></strong><span><strong class="source-inline1"><span class="kobospan" id="kobo.353.1">public'</span></strong></span><span><span class="kobospan" id="kobo.354.1"> room:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.355.1">
        default:
          receiveMessage({
            message: `Unknown command: ${command}`,
          })
          break
      }
    } else {
      socket.emit('chat.message', </span><strong class="bold1"><span class="kobospan1" id="kobo.356.1">'public',</span></strong><span class="kobospan1" id="kobo.357.1"> message)
    }
  }</span></pre><p class="calibre3"><span class="kobospan" id="kobo.358.1">In the next section, we will expand this to be able to switch between </span><span><span class="kobospan" id="kobo.359.1">different rooms.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.360.1">Go to </span><strong class="source-inline1"><span class="kobospan" id="kobo.361.1">http://localhost:5173/</span></strong><span class="kobospan" id="kobo.362.1"> and verify that the chat app still works the same way </span><a id="_idIndexMarker860" class="calibre6 pcalibre1 pcalibre"/><span><span class="kobospan" id="kobo.363.1">as before.</span></span></li>
</ol>
<p class="calibre3"><span class="kobospan" id="kobo.364.1">Now that we have successfully refactored our chat app to be more extensible, let’s test out the flexibility of the new structure by implementing new commands to join and </span><span><span class="kobospan" id="kobo.365.1">switch rooms.</span></span></p>
<h1 id="_idParaDest-285" class="calibre5"><a id="_idTextAnchor288" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.366.1">Implementing commands to join and switch rooms</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.367.1">Let’s now test out the </span><a id="_idIndexMarker861" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.368.1">new structure by implementing commands to join and switch rooms on the chat app, </span><span><span class="kobospan" id="kobo.369.1">as follows:</span></span></p>
<ol class="calibre15">
<li class="calibre11"><span class="kobospan" id="kobo.370.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.371.1">backend/src/socket.js</span></strong><span class="kobospan" id="kobo.372.1"> and define a new listener below the </span><strong class="source-inline1"><span class="kobospan" id="kobo.373.1">chat.message</span></strong><span class="kobospan" id="kobo.374.1"> listener, which will call the </span><strong class="source-inline1"><span class="kobospan" id="kobo.375.1">joinRoom</span></strong><span class="kobospan" id="kobo.376.1"> service function when we receive a </span><strong class="source-inline1"><span class="kobospan" id="kobo.377.1">chat.join</span></strong><span class="kobospan" id="kobo.378.1"> event from </span><span><span class="kobospan" id="kobo.379.1">the client:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.380.1">
    socket.on('chat.join', (room) =&gt; joinRoom(io, socket, { room }))</span></pre><p class="calibre3"><span class="kobospan" id="kobo.381.1">As we can see, having a </span><strong class="source-inline"><span class="kobospan" id="kobo.382.1">joinRoom</span></strong><span class="kobospan" id="kobo.383.1"> service function makes it really simple to reuse the code to join a new room here. </span><span class="kobospan" id="kobo.383.2">It already sends a system message telling everyone that someone joined the room, just like it does when the user joins the </span><strong class="source-inline"><span class="kobospan" id="kobo.384.1">public</span></strong><span class="kobospan" id="kobo.385.1"> room by default </span><span><span class="kobospan" id="kobo.386.1">upon connection.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.387.1">Edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.388.1">src/components/ChatMessage.jsx</span></strong><span class="kobospan" id="kobo.389.1"> and </span><span><span class="kobospan" id="kobo.390.1">display </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.391.1">room</span></strong></span><span><span class="kobospan" id="kobo.392.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.393.1">
export function ChatMessage({ </span><strong class="bold1"><span class="kobospan1" id="kobo.394.1">room,</span></strong><span class="kobospan1" id="kobo.395.1"> username, message, replayed }) {
  return (
    &lt;div style={{ opacity: replayed ? </span><span class="kobospan1" id="kobo.395.2">0.5 : 1.0 }}&gt;
      {username ? </span><span class="kobospan1" id="kobo.395.3">(
        &lt;span&gt;
          </span><strong class="bold1"><span class="kobospan1" id="kobo.396.1">&lt;code&gt;[{room}]&lt;/code&gt; </span></strong><span class="kobospan1" id="kobo.397.1">&lt;b&gt;{username}&lt;/b&gt;: {message}
        &lt;/span&gt;</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.398.1">Add the </span><strong class="source-inline1"><span class="kobospan" id="kobo.399.1">room</span></strong><span class="kobospan" id="kobo.400.1"> prop</span><a id="_idIndexMarker862" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.401.1"> to the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.402.1">propTypes</span></strong></span><span><span class="kobospan" id="kobo.403.1"> definition:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.404.1">
ChatMessage.propTypes = {
  username: PropTypes.string,
  message: PropTypes.string.isRequired,
  replayed: PropTypes.bool,
</span><strong class="bold1"><span class="kobospan1" id="kobo.405.1">  room: PropTypes.string,</span></strong><span class="kobospan1" id="kobo.406.1">
}</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.407.1">Now, edit </span><strong class="source-inline1"><span class="kobospan" id="kobo.408.1">src/hooks/useChat.js</span></strong><span class="kobospan" id="kobo.409.1"> and define a state hook to store the room we are </span><span><span class="kobospan" id="kobo.410.1">currently in:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.411.1">
export function useChat() {
  const { socket } = useSocket()
  const [messages, setMessages] = useState([])
</span><strong class="bold1"><span class="kobospan1" id="kobo.412.1">  const [currentRoom, setCurrentRoom] = useState('public')</span></strong></pre><p class="calibre3"><span class="kobospan" id="kobo.413.1">By default, we are in the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.414.1">public</span></strong></span><span><span class="kobospan" id="kobo.415.1"> room.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.416.1">Define a new function to </span><span><span class="kobospan" id="kobo.417.1">switch rooms:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.418.1">
  function switchRoom(room) {
    setCurrentRoom(room)
  }</span></pre><p class="calibre3"><span class="kobospan" id="kobo.419.1">At the moment, we are only calling </span><strong class="source-inline"><span class="kobospan" id="kobo.420.1">setCurrentRoom</span></strong><span class="kobospan" id="kobo.421.1"> here, but we might want to extend this function later, so it is good practice to abstract it in advance into a </span><span><span class="kobospan" id="kobo.422.1">separate function.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.423.1">Define a </span><a id="_idIndexMarker863" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.424.1">new function to join a room by sending the </span><strong class="source-inline1"><span class="kobospan" id="kobo.425.1">chat.join</span></strong><span class="kobospan" id="kobo.426.1"> event and switching the </span><span><span class="kobospan" id="kobo.427.1">current room:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.428.1">
  function joinRoom(room) {
    socket.emit('chat.join', room)
    switchRoom(room)
  }</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.429.1">Change the </span><strong class="source-inline1"><span class="kobospan" id="kobo.430.1">sendMessage</span></strong><span class="kobospan" id="kobo.431.1"> function to accept arguments for commands, </span><span><span class="kobospan" id="kobo.432.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.433.1">
  async function sendMessage(message) {
    if (message.startsWith('/')) {
      const </span><strong class="bold1"><span class="kobospan1" id="kobo.434.1">[command, ...args]</span></strong><span class="kobospan1" id="kobo.435.1"> = message.substring(1)</span><strong class="bold1"><span class="kobospan1" id="kobo.436.1">.split(' ')</span></strong><span class="kobospan1" id="kobo.437.1">
      switch (command) {</span></pre><p class="calibre3"><span class="kobospan" id="kobo.438.1">We can now send commands such as </span><strong class="source-inline"><span class="kobospan" id="kobo.439.1">/join &lt;room-name&gt;</span></strong><span class="kobospan" id="kobo.440.1"> and the room name will be stored </span><span><span class="kobospan" id="kobo.441.1">in </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.442.1">args[0]</span></strong></span><span><span class="kobospan" id="kobo.443.1">.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.444.1">Define a new command to join a room, in which we first check whether arguments were passed to </span><span><span class="kobospan" id="kobo.445.1">the command:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.446.1">
        case 'join': {
          if (args.length === 0) {
            return receiveMessage({
              message: 'Please provide a room name: /join &lt;room&gt;',
            })
          }</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.447.1">Then, we ensure that </span><a id="_idIndexMarker864" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.448.1">we have not already joined the room by using the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.449.1">getRooms</span></strong></span><span><span class="kobospan" id="kobo.450.1"> function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.451.1">
          const room = args[0]
          const rooms = await getRooms()
          if (rooms.includes(room)) {
            return receiveMessage({
              message: `You are already in room "${room}".`,
            })
          }</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.452.1">Finally, we can join the room by using the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.453.1">joinRoom</span></strong></span><span><span class="kobospan" id="kobo.454.1"> function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.455.1">
          joinRoom(room)
          break
        }</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.456.1">Similarly, we can implement the </span><strong class="source-inline1"><span class="kobospan" id="kobo.457.1">/switch</span></strong><span class="kobospan" id="kobo.458.1"> command </span><span><span class="kobospan" id="kobo.459.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.460.1">
        case 'switch': {
          if (args.length === 0) {
            return receiveMessage({
              message: 'Please provide a room name: /switch &lt;room&gt;',
            })
          }
          const room = args[0]
          const rooms = await getRooms()
          if (!rooms.includes(room)) {
            return receiveMessage({
              message: `You are not in room "${room}". </span><span class="kobospan1" id="kobo.460.2">Type "/join ${room}" to join it first.`,
            })
          }
          switchRoom(room)
          receiveMessage({
            message: `Switched to room "${room}".`,
          })
          break
        }</span></pre><p class="calibre3"><span class="kobospan" id="kobo.461.1">In this case, we </span><a id="_idIndexMarker865" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.462.1">are checking whether the user is in the room already. </span><span class="kobospan" id="kobo.462.2">If not, we tell them that they must join the room first before switching </span><span><span class="kobospan" id="kobo.463.1">to it.</span></span></p></li> <li class="calibre11"><span class="kobospan" id="kobo.464.1">Adjust the </span><strong class="source-inline1"><span class="kobospan" id="kobo.465.1">chat.message</span></strong><span class="kobospan" id="kobo.466.1"> event to send to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.467.1">currentRoom</span></strong><span class="kobospan" id="kobo.468.1">, </span><span><span class="kobospan" id="kobo.469.1">as follows:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.470.1">
    } else {
      socket.emit('chat.message', </span><strong class="bold1"><span class="kobospan1" id="kobo.471.1">currentRoom</span></strong><span class="kobospan1" id="kobo.472.1">, message)
    }</span></pre></li> <li class="calibre11"><span class="kobospan" id="kobo.473.1">Go to </span><strong class="source-inline1"><span class="kobospan" id="kobo.474.1">http://localhost:5173/</span></strong><span class="kobospan" id="kobo.475.1">, send a message to the public room, then join the </span><strong class="source-inline1"><span class="kobospan" id="kobo.476.1">react</span></strong><span class="kobospan" id="kobo.477.1"> room by executing the </span><strong class="source-inline1"><span class="kobospan" id="kobo.478.1">/join react</span></strong><span class="kobospan" id="kobo.479.1"> command. </span><span class="kobospan" id="kobo.479.2">Send a different message to </span><span><span class="kobospan" id="kobo.480.1">that room.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.481.1">Open another browser window, log in with a different user, and you will see that the first message from the </span><strong class="source-inline1"><span class="kobospan" id="kobo.482.1">public</span></strong><span class="kobospan" id="kobo.483.1"> room gets replayed. </span><span class="kobospan" id="kobo.483.2">However, we do not see the message from the </span><strong class="source-inline1"><span class="kobospan" id="kobo.484.1">react</span></strong><span class="kobospan" id="kobo.485.1"> room, because we have not joined </span><span><span class="kobospan" id="kobo.486.1">it yet!</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.487.1">Now, in the second browser window, call </span><strong class="source-inline1"><span class="kobospan" id="kobo.488.1">/join react</span></strong><span class="kobospan" id="kobo.489.1"> as well. </span><span class="kobospan" id="kobo.489.2">You will see that the second message gets </span><span><span class="kobospan" id="kobo.490.1">replayed now.</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.491.1">Try using </span><strong class="source-inline1"><span class="kobospan" id="kobo.492.1">/switch public</span></strong><span class="kobospan" id="kobo.493.1"> to switch back to the </span><strong class="source-inline1"><span class="kobospan" id="kobo.494.1">public</span></strong><span class="kobospan" id="kobo.495.1"> room and send another message there. </span><span class="kobospan" id="kobo.495.2">You will see that both clients receive it because they are both in </span><a id="_idIndexMarker866" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.496.1">the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.497.1">public</span></strong></span><span><span class="kobospan" id="kobo.498.1"> room.</span></span></li>
</ol>
<p class="calibre3"><span class="kobospan" id="kobo.499.1">The result of these actions can be seen in the </span><span><span class="kobospan" id="kobo.500.1">following screenshot:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer133">
<span class="kobospan" id="kobo.501.1"><img alt="Figure 15.3 – Chatting in different rooms" src="image/B19385_15_3.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.502.1">Figure 15.3 – Chatting in different rooms</span></p>
<h1 id="_idParaDest-286" class="calibre5"><a id="_idTextAnchor289" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.503.1">Summary</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.504.1">In this chapter, we first connected our chat app to the database by storing messages in MongoDB. </span><span class="kobospan" id="kobo.504.2">We also learned how to make documents expire after a certain amount of time. </span><span class="kobospan" id="kobo.504.3">Then, we implemented functionality to replay messages when a new user joins the chat. </span><span class="kobospan" id="kobo.504.4">Next, we spent some time refactoring the chat app to make it more extensible and maintainable in the future. </span><span class="kobospan" id="kobo.504.5">Finally, we implemented ways to join new rooms and switch </span><span><span class="kobospan" id="kobo.505.1">between rooms.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.506.1">Up until now, we have only been using libraries to develop our apps. </span><span class="kobospan" id="kobo.506.2">In the next chapter, </span><a href="B19385_16.xhtml#_idTextAnchor291" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.507.1">Chapter 16</span></em></span></a><em class="italic"><span class="kobospan" id="kobo.508.1">, Getting Started with Next.js</span></em><span class="kobospan" id="kobo.509.1">, we will learn how to use a full-stack React framework for developing apps. </span><span class="kobospan" id="kobo.509.2">Frameworks, such as Next.js, provide more structure for our apps and offer us a lot of features, such as server-side rendering, out of </span><span><span class="kobospan" id="kobo.510.1">the box.</span></span></p>
</div>
</body></html>