- en: Introduction to Modern Web Application Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现代Web应用开发简介
- en: According to the Stack Overflow developer survey 2017 ([https://insights.stackoverflow.com/survey/2017#developer-profile-specific-developer-types](https://insights.stackoverflow.com/survey/2017#developer-profile-specific-developer-types)),
    *full-stack web developer* is the most popular developer title. The software industry
    defines a full-stack developer as someone who can work on different areas of an
    application stack. The term stack refers to different components and tools that
    make up an application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 根据2017年Stack Overflow开发者调查([https://insights.stackoverflow.com/survey/2017#developer-profile-specific-developer-types](https://insights.stackoverflow.com/survey/2017#developer-profile-specific-developer-types))，*全栈Web开发者*是最受欢迎的开发者头衔。软件行业将全栈开发者定义为能够在应用栈的不同领域工作的开发者。术语栈指的是构成应用的不同组件和工具。
- en: In terms of web application development, the stack can be broadly classified
    into two areas—**frontend** and **backend** stack or **client-side** and **server-side**
    stack. Frontend generally refers to the part that is responsible for rendering
    the user interface, and backend refers to the part that is responsible for the
    business logic, database interactions, user authentication, server configuration,
    and so on. A full-stack Java web application developer is expected to work on
    both frontend and backend technologies, ranging from writing HTML/JavaScript for
    the user interface to writing Java class files for business logic and SQL queries
    for database operations as required.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web应用开发方面，技术栈可以大致分为两个领域——**前端**和**后端**技术栈或**客户端**和**服务器端**技术栈。前端通常指的是负责渲染用户界面的部分，而后端则指的是负责业务逻辑、数据库交互、用户认证、服务器配置等部分。全栈Java
    Web应用开发者需要在前端和后端技术方面工作，从编写用户界面的HTML/JavaScript到编写业务逻辑的Java类文件和数据库操作的SQL查询。
- en: With an ever-evolving software architecture landscape, the scope of technologies
    that a full-stack web developer is expected to work has increased tremendously.
    It is no longer enough that we can write HTML and JavaScript to build a user interface,
    we are expected to know client-side frameworks such as Angular, React, VueJS,
    and so on. It is also not enough that we are proficient in enterprise Java and
    SQL, we are expected to know server-side frameworks such as Spring, Hibernate,
    Play, and so on.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 随着软件架构的不断演变，全栈Web开发者需要掌握的技术范围大大增加。仅仅能够编写HTML和JavaScript来构建用户界面已经不够了，我们还需要了解客户端框架，如Angular、React、VueJS等。仅仅精通企业Java和SQL也不够，我们还需要了解服务器端框架，如Spring、Hibernate、Play等。
- en: 'In this chapter, we will introduce the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: Modern full-stack web development
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代全栈Web开发
- en: Web architecture patterns
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web架构模式
- en: Choosing the right pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择合适的模式
- en: Modern full-stack web development
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现代全栈Web开发
- en: If we were to even begin discussing the life of a full-stack developer, it would
    be worthy of a whole book by itself – so let's leave that for another day.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要开始讨论全栈开发者的生活，那将足以写成一整本书——所以让我们留到另一天再说。
- en: Let's look at a user story about a full-stack Java web application and see what
    is involved.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个全栈Java Web应用的用例，看看其中涉及的内容。
- en: 'Let''s use an example of developing a user management module for a typical
    Java web application. Let''s assume that you would be writing unit test cases
    for the all the code hence we won''t detail them out here:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以开发一个典型Java Web应用的用户管理模块为例。假设你会为所有代码编写单元测试用例，所以我们在这里不会详细说明：
- en: You would start by designing the architecture for the feature. You would decide
    on the plugins and frameworks to use, patterns to follow, and so on.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你会从设计该功能的架构开始。你会决定要使用的插件和框架、要遵循的模式等。
- en: You will be modeling the domain model for the feature depending on the database
    technology used.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将根据使用的数据库技术对特征进行领域模型建模。
- en: Then, you would create server-side code and database queries to persist and
    fetch data from the database.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，你会创建服务器端代码和数据库查询，以持久化和从数据库中检索数据。
- en: Once the data is ready you would implement server-side code for any business
    logic.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据准备好后，你会实现任何业务逻辑的服务器端代码。
- en: Then, you would implement an API that can be used to provide data for the presentation
    over an HTTP connection.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，你会实现一个API，可以通过HTTP连接提供数据。
- en: You would write integration tests for the API.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将为API编写集成测试。
- en: Now, since the backend is ready, you would start writing frontend code in JavaScript
    or a similar technology.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，由于后端已经准备好了，你将开始用JavaScript或类似的技术编写前端代码。
- en: You would write client-side services to fetch data from the backend API.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将编写客户端服务以从后端API获取数据。
- en: You would write client-side components to display the data on a web page.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将编写客户端组件以在网页上显示数据。
- en: You would build the page and style it as per the design provided.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将根据提供的设计构建页面并对其进行样式设计。
- en: You would write automated end to end tests for the web page.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将为网页编写自动化的端到端测试。
- en: It is not done yet. Once you have tested everything works locally you would
    create pull requests or check-in the code to the version control system used.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这还没有完成。一旦你测试了一切在本地都能正常工作，你将创建拉取请求或将代码检查到所使用的版本控制系统中。
- en: You would wait for the continuous integration process to verify everything,
    and fix anything that is broken.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将等待持续集成过程来验证一切，并修复任何损坏的部分。
- en: Once everything is green and the code is accepted, typically you would start
    the deployment of this feature to a staging or acceptance environment, either
    on-premises or to a cloud provider. If it is the latter you would be expected
    to be familiar with the cloud technologies used as well. You would also be upgrading
    the database schema as necessary and writing migration scripts when required.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一切都绿灯亮起，代码被接受后，通常你将开始将这个功能部署到预发布或验收环境，无论是在本地还是在云服务提供商那里。如果是后者，你还需要熟悉所使用的云技术。你还需要根据需要升级数据库模式，并在需要时编写迁移脚本。
- en: Once the feature is accepted you might be responsible for deploying it into
    the production environment in a similar way, and troubleshoot issues where necessary.
    In some teams, you might swap the steps with other team members so that you would
    be deploying a feature developed by your co-worker while s/he deploys yours.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦功能被接受，你可能会负责以类似的方式将其部署到生产环境中，并在必要时解决出现的问题。在一些团队中，你可能会与其他团队成员交换步骤，这样你就可以部署你的同事开发的功能，同时他们部署你的功能。
- en: You might also be responsible, along with your co-workers, to make sure the
    production environment is up and running including the database, virtual machines,
    and so on.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能还需要与你的同事一起确保生产环境正常运行，包括数据库、虚拟机等等。
- en: As you can see it is no easy task. The range of responsibilities spawns across
    making stylesheet updates on the client side to running database migration scripts
    on a virtual machine in the production cloud service. If you are not familiar
    enough, this would be a herculean task and you would soon be lost in the vast
    ocean of frameworks, technologies, and design patterns out there.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这不是一件容易的任务。责任范围从客户端的样式表更新到在生产云服务中的虚拟机上运行数据库迁移脚本。如果你不够熟悉，这将是一项艰巨的任务，你很快就会迷失在众多框架、技术和设计模式的大海中。
- en: 'Full stack development is not for the faint-hearted. It takes a lot of time
    and effort in keeping yourself up to date with various technologies and patterns
    in multiple disciplines of software development. Following are some of the common
    problems you might face as a full-stack Java developer:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 全栈开发不是一件容易的事情。它需要花费大量的时间和精力来保持自己与软件开发多个领域的各种技术和模式同步。以下是一些你可能作为全栈Java开发者会遇到的一些常见问题：
- en: Client-side development is not just about writing plain HTML and JavaScript
    anymore. It is becoming as complex as server-side development with build tools,
    transpilers, frameworks, and patterns.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端开发不再仅仅是编写纯HTML和JavaScript了。它正变得和服务器端开发一样复杂，包括构建工具、转译器、框架和模式。
- en: There is a new framework almost every week in the JavaScript world and if you
    are coming from a Java background it could be very overwhelming for you.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在JavaScript的世界里，几乎每周都会出现一个新的框架，如果你是从Java背景过来的，这可能会让你感到非常压倒性。
- en: Container technologies such as Docker revolutionalized the software industry
    but they also introduced a lot of new stuff to learn and keep track of, such as
    orchestration tools, container management tools, and so on.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器技术如Docker革命性地改变了软件行业，但它们也引入了许多新的学习内容，需要跟踪，例如编排工具、容器管理工具等等。
- en: Cloud services are growing day by day. To stay on track you would have to familiarize
    yourself with their API and related orchestration tools.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云服务每天都在增长。为了保持同步，你需要熟悉它们的API和相关编排工具。
- en: Java server-side technologies have also undergone a major shift in recent times
    with the introduction of JVM languages such as Scala, Groovy, Kotlin, and so on,
    forcing you to keep yourself up to date with them. On the other side, server-side
    frameworks are becoming more feature rich and hence more complex.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 近年来，随着Scala、Groovy、Kotlin等JVM语言的引入，Java服务器端技术也经历了重大转变，迫使你必须跟上它们的步伐。另一方面，服务器端框架变得越来越功能丰富，因此也变得更加复杂。
- en: The most important thing of all is the pain of making sure all of these work
    together well when required. It will need a lot of configuration, some glue code,
    and endless cups of coffee.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是确保所有这些在需要时能够良好协作的痛苦。这需要大量的配置、一些粘合代码和无数杯咖啡。
- en: '**Transpilers** are source-to-source compilers. Whereas a traditional compiler
    compiles from source to binary, a transpiler compiles from one type of source
    code to another type of source code. TypeScript and CoffeeScript are excellent
    examples of this, both compile down to JavaScript.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**转换器**是源到源的编译器。与传统编译器从源代码编译到二进制代码不同，转换器将一种类型的源代码编译成另一种类型的源代码。TypeScript和CoffeeScript是这方面的优秀例子，它们都编译成JavaScript。'
- en: It's very easy to get lost here and this is where technologies such as JHipster
    and Spring Boot step in to help. We will see the details in later chapters but
    in short, they help by providing the wiring between moving parts so that you only
    need to concentrate on writing business code. JHipster also helps by providing
    the abstractions to deploy and manage the application to various cloud providers.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里很容易迷失方向，这就是JHipster和Spring Boot等技术的用武之地，它们可以帮助我们。我们将在后面的章节中看到详细内容，但简而言之，它们通过提供移动部件之间的连接，让你只需专注于编写业务代码。JHipster还通过提供部署和管理应用程序到各种云提供商的抽象来帮助。
- en: Web architecture patterns
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web架构模式
- en: The full-stack landscape is further complicated by the different web architecture
    patterns commonly used these days. The widely used web application architecture
    patterns today can be broadly classified into two—**monolithic architecture**
    and **microservice architecture**, the latter being the new kid on the block.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 全栈领域由于目前广泛使用的不同Web架构模式而变得更加复杂。今天广泛使用的Web应用程序架构模式可以大致分为两种——**单体架构**和**微服务架构**，后者是新兴的架构模式。
- en: 'Let''s take a look at the following in detail:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看以下内容：
- en: Monolithic architecture
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单体架构
- en: Microservice architecture
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务架构
- en: Monolithic web architecture
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单体Web架构
- en: 'A monolithic architecture is the most used pattern for web applications due
    to its simplicity in development and deployment. Though the actual moving parts
    will differ from application to application, the general pattern remains the same.
    In general, a monolithic web application may do the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 单体架构是Web应用程序最常用的模式，因为它在开发和部署上的简单性。尽管实际的运动部件会因应用程序而异，但一般模式保持不变。一般来说，单体Web应用程序可能执行以下操作：
- en: It can support different clients such as desktop/mobile browsers and native
    desktop/mobile applications
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以支持不同的客户端，如桌面/移动浏览器和原生桌面/移动应用程序
- en: It can expose APIs for third-party consumption
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以暴露API供第三方消费
- en: It can integrate with other applications over REST/SOAP web services or message
    queues
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以通过REST/SOAP Web服务或消息队列与其他应用程序集成
- en: It can handle HTTP requests, execute business logic, access a database, and
    can exchange data with other systems
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以处理HTTP请求，执行业务逻辑，访问数据库，并且可以与其他系统交换数据
- en: It can run on web application containers such as Tomcat, JBoss, and so on
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以在诸如Tomcat、JBoss等Web应用程序容器上运行
- en: It can be scaled vertically by increasing the power of the machines it runs
    on or scaled horizontally by adding additional instances behind load balancers
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以通过增加运行其上的机器的功率进行垂直扩展，或者通过在负载均衡器后面添加额外的实例进行水平扩展
- en: '**REST** (**Representational State Transfer**) relies on a stateless, client-server,
    cacheable communications protocol. HTTP is the most commonly used protocol for
    REST. It is a lightweight architectural style in which RESTful HTTP communication
    is used to transfer data between a client and server or between two systems.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**REST**（**表征状态转移**）依赖于无状态的、客户端-服务器、可缓存的通信协议。HTTP是REST最常用的协议。它是一种轻量级架构风格，其中RESTful
    HTTP通信用于在客户端和服务器或两个系统之间传输数据。'
- en: '**SOAP** (**Simple Object Access Protocol**) is a messaging protocol using
    HTTP and XML. It is widely used in SOAP web services to transfer data between
    two different systems.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**SOAP**（**简单对象访问协议**）是一种使用HTTP和XML的消息协议。它在SOAP Web服务中广泛用于在两个不同的系统之间传输数据。'
- en: 'An example of a typical monolithic web application architecture would be as
    follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的单体Web应用程序架构的例子如下：
- en: Let's imagine an online hotel reservation system that takes reservation orders
    online from customers, verifies the room availability, verifies the payment option,
    makes the reservation, and notifies the hotel. The application consists of several
    layers and components including a client-side app, which builds a nice rich user
    interface, and several other backend components responsible for managing the reservations,
    verifying payment, notifying customers/hotels, and so on.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一个在线酒店预订系统，该系统从客户那里在线接收预订订单，验证房间可用性，验证支付选项，进行预订，并通知酒店。该应用程序由多个层和组件组成，包括客户端应用程序，它构建了一个丰富的用户界面，以及负责管理预订、验证支付、通知客户/酒店等的多其他后端组件。
- en: 'The application will be deployed as a single monolithic **Web Application Archive** (**WAR**)
    file that runs on a web application container such as Tomcat and will be scaled
    horizontally by adding multiple instances behind an Apache web server acting as
    a load balancer. Take a look at the following diagram:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将作为单个单体**Web应用程序存档**（**WAR**）文件部署，在Web应用程序容器（如Tomcat）上运行，并通过在充当负载均衡器的Apache
    Web服务器后面添加多个实例进行水平扩展。请看以下图表：
- en: '![](img/1f631e18-1e1c-41b3-aac2-5d5ff802dbb4.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1f631e18-1e1c-41b3-aac2-5d5ff802dbb4.jpg)'
- en: 'The advantages of a monolithic web application architecture are as detailed
    here:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 单体式Web应用程序架构的优点如下所述：
- en: Simpler to develop as the technology stack is uniform throughout all layers.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发更简单，因为技术栈在所有层都是统一的。
- en: Simpler to test as the entire application is bundled in a single package making
    it easier to run integration and end-to-end tests.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试更简单，因为整个应用程序捆绑在一个单独的包中，这使得运行集成和端到端测试更容易。
- en: Simpler and faster to deploy, as you only have one package to worry about.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署更简单、更快，因为你只需要担心一个包。
- en: Simpler to scale as you can multiply the number of instances behind a load balancer
    to scale out.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展更简单，因为你可以通过增加负载均衡器后面的实例数量来扩展。
- en: Requires a smaller team to maintain the application.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护应用程序需要较小的团队。
- en: Team members share more or less the same skill set.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队成员共享或多或少相同的技能集。
- en: The technical stack is simpler and most of the times easier to learn.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术栈更简单，大多数情况下更容易学习。
- en: Initial development is faster hence making time to market faster.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始开发更快，因此使上市时间更快。
- en: Requires simpler infrastructure. Even a simple application container or JVM
    will be sufficient to run the application.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要更简单的基础设施。即使是一个简单的应用程序容器或JVM也足以运行应用程序。
- en: 'The disadvantages of a monolithic web application architecture are as detailed
    here:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 单体式Web应用程序架构的缺点如下所述：
- en: Components are tightly coupled together resulting in unwanted side effects such
    as changes to one component causing a regression in another and so on.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件紧密耦合在一起，导致出现不希望出现的副作用，例如一个组件的更改可能导致另一个组件的回归，等等。
- en: Becomes complex and huge over time resulting in slow development turnaround.
    New features will take more time to develop and refactoring of existing features
    will be more difficult due to tight coupling.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着时间的推移变得复杂和庞大，导致开发周期缓慢。新功能开发将花费更多时间，由于紧密耦合，现有功能的重构将更加困难。
- en: The entire application needs to be redeployed for any changes.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何更改都需要重新部署整个应用程序。
- en: Is less reliable due to tightly coupled modules. A small issue in a service
    might break the entire application.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于模块紧密耦合，可靠性较低。服务中的一个小的错误可能会破坏整个应用程序。
- en: Newer technology adoption is difficult as entire application needs to be migrated.
    Incremental migration is not possible most of the time. Hence many monolithic
    applications end up having an outdated technology stack.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于整个应用程序需要迁移，新技术采用困难。大多数情况下，增量迁移是不可能的。因此，许多单体应用程序最终会拥有过时的技术栈。
- en: Critical services cannot be scaled individually resulting in increased resource
    usage as the entire application will need to be scaled.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键服务无法单独扩展，导致资源使用增加，因为整个应用程序都需要扩展。
- en: Huge monolith applications will have a higher start-up time and high resource
    usage in terms of CPU and memory.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大型单体应用程序将具有较长的启动时间和较高的CPU和内存资源使用率。
- en: Teams will be more interdependent and it will be challenging to scale the teams.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队之间的相互依赖性将更强，扩展团队将更具挑战性。
- en: Microservice architecture
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务架构
- en: 'The microservice architecture has gained momentum in recent years, and is gaining
    popularity in web application development due to its modularity and scalability.
    Microservice architecture can offer almost all the features of a monolith that
    we saw in the earlier section. Additionally, it offers many more features and
    flexibility, and hence is often considered a superior choice for complex applications.
    Unlike the monolithic architecture, it''s quite difficult to generalize the microservice
    architecture as it could vary heavily depending on the use case and implementation.
    But they do share some common traits and they are, in general, the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，微服务架构得到了快速发展，由于其模块化和可扩展性，在Web应用开发中越来越受欢迎。微服务架构几乎可以提供我们在早期部分看到的单体架构的所有功能。此外，它还提供了许多更多功能和灵活性，因此通常被认为是复杂应用的更优选择。与单体架构不同，微服务架构很难进行一般化，因为它可能严重依赖于用例和实现。但它们确实有一些共同特征，通常如下：
- en: Microservice components are loosely coupled. Components can be developed, tested,
    deployed, and scaled independently without disrupting other components.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务组件是松散耦合的。组件可以独立开发、测试、部署和扩展，而不会干扰其他组件。
- en: Components need not be developed using the same technology stack. This means
    a single component can choose its own technology stack and programming language.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件不需要使用相同的技术栈进行开发。这意味着单个组件可以选择自己的技术栈和编程语言。
- en: They often utilize advanced features such as service discovery, circuit breaking,
    load balancing, and so on.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们经常利用高级功能，如服务发现、断路器、负载均衡等。
- en: Microservice components are mostly lightweight and they do a specific functionality.
    For example, an authentication service will only care about authenticating a user
    into the system.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务组件大多是轻量级的，并且执行特定的功能。例如，一个身份验证服务只会关心将用户验证到系统中。
- en: Often has an extensive monitoring and troubleshooting setup.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常具有广泛的监控和故障排除设置。
- en: 'An example of a microservice web application architecture would be as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一个微服务Web应用架构的例子如下：
- en: Let's imagine a huge online e-commerce system where customers can go through
    categories of merchandise, maintain favorites, add items to a shopping cart, make
    and track orders, and so on. The system has inventory management, customer management,
    multiple payment modes, order management, and so on. The application consists
    of several modules and components including a UI gateway application, which builds
    a nice rich user interface and also handles user authentication and load balancing,
    and several other backend applications responsible for managing the inventory,
    verifying payment, and managing orders. It also has performance monitoring and
    automatic failover for services.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一个庞大的在线电子商务系统，顾客可以浏览商品类别，维护收藏夹，将商品添加到购物车，下单并跟踪订单等。该系统具有库存管理、客户管理、多种支付方式、订单管理等。应用程序由多个模块和组件组成，包括一个UI网关应用程序，它构建了一个丰富的用户界面，并处理用户身份验证和负载均衡，以及负责管理库存、验证支付和管理订单的几个其他后端应用程序。它还具有性能监控和服务的自动故障转移。
- en: 'The application will be deployed as multiple executable WAR files in Docker
    containers hosted by a cloud provider. Take a look at the following diagram:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将以多个可执行WAR文件的形式部署在云提供商托管的Docker容器中。请查看以下图表：
- en: '![](img/a317c956-4678-47c3-b60e-67baed5d0cac.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a317c956-4678-47c3-b60e-67baed5d0cac.png)'
- en: 'The advantages of a microservice web application architecture are as detailed
    here:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务Web应用架构的优势如下详细说明：
- en: Loosely coupled components resulting in better isolation, easier to test and
    faster to startup.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 松散耦合的组件导致更好的隔离性，更容易测试和更快地启动。
- en: Faster development turnaround and better time to market. New features can be
    built faster and existing features can be easily refactored.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更快的开发周期和更短的市场投放时间。新功能可以更快地构建，现有功能也可以轻松重构。
- en: Services can be deployed independently making the application more reliable
    and make patching easier.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务可以独立部署，这使得应用程序更可靠，补丁更容易应用。
- en: Issues, such as a memory leak in one of the services, are isolated and hence
    will not bring down the entire application.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题，例如某个服务中的一个内存泄漏，将被隔离，因此不会导致整个应用程序崩溃。
- en: Technology adoption is easier, components can be independently upgraded in incremental
    migration making it possible to have a different stack for each component.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术采用更容易，组件可以在增量迁移中独立升级，使得每个组件都有不同的堆栈成为可能。
- en: More complex and efficient scaling models can be established. Critical services
    can be scaled more effectively. Infrastructure is used more efficiently.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以建立更复杂和高效的扩展模型。关键服务可以更有效地扩展。基础设施的使用效率更高。
- en: Individual components will start up faster making it possible to parallelize
    and improve overall start-up.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个组件启动更快，这使得并行化和提高整体启动速度成为可能。
- en: Teams will be less dependent on each other. Best suited for agile teams.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队之间的依赖性会减少。最适合敏捷团队。
- en: 'The disadvantages of a microservice web application architecture are as detailed
    here:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务Web应用架构的缺点如下所述：
- en: More complex in terms of the overall stack as different components might have
    different technology stacks forcing the team to invest more time in keeping up
    with them.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在整体堆栈方面更为复杂，因为不同的组件可能有不同的技术堆栈，迫使团队投入更多时间来跟上它们。
- en: Difficult to perform end-to-end tests and integration tests as there are more
    moving parts in the stack.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于堆栈中有更多移动部件，执行端到端测试和集成测试变得困难。
- en: The entire application is more complex to deploy as there are complexities with
    containers and virtualization involved.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整个应用程序部署起来更复杂，因为涉及到容器和虚拟化的复杂性。
- en: Scaling is more efficient but setting upscaling is more complex as it would
    require advanced features such as service discovery, DNS routing, and so on.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展更高效，但设置扩展更复杂，因为它需要高级功能，如服务发现、DNS路由等。
- en: Requires a larger team to maintain the application as there are more components
    and more technologies involved.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要一个更大的团队来维护应用程序，因为有更多的组件和更多的技术涉及。
- en: Team members share varying skill sets based on the component they work on, making
    replacements and knowledge sharing harder.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队成员根据他们工作的组件共享不同的技能组合，这使得替换和知识共享更困难。
- en: The technical stack is complex and most of the times harder to learn.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术堆栈复杂，大多数时候更难学习。
- en: Initial development time will be higher making time to market slower.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始开发时间会更高，使得上市时间变慢。
- en: Requires a complex infrastructure. Most often will require containers (Docker)
    and multiple JVM or app containers to run on.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要复杂的基础设施。通常将需要容器（Docker）和多个JVM或应用容器来运行。
- en: Choosing the right pattern
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择正确的模式
- en: When starting a new project, it is always difficult to choose an architecture
    pattern these days. There are so many factors to take into account and it is easy
    to get confused with all the **hype** around different patterns and technologies
    (see **Hype Driven Development** ([https://blog.daftcode.pl/hype-driven-development-3469fc2e9b22](https://blog.daftcode.pl/hype-driven-development-3469fc2e9b22))).
    Following are some general guidelines on when to choose a monolithic web application
    architecture over a microservice architecture and vice versa.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动新项目时，如今选择架构模式总是很困难。有许多因素需要考虑，很容易被围绕不同模式和技术的**炒作**所迷惑（参见**炒作驱动开发**([https://blog.daftcode.pl/hype-driven-development-3469fc2e9b22](https://blog.daftcode.pl/hype-driven-development-3469fc2e9b22)))）。以下是关于何时选择单体Web应用架构而不是微服务架构以及相反的一些一般性指南。
- en: When to choose a monolithic architecture
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择单体架构的时机
- en: 'The following list can be used as a general guide when choosing a monolithic
    architecture. This is not a definitive list but gives an idea of when to go with
    a monolithic architecture over microservices:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表可以作为选择单体架构而不是微服务架构的一般性指南。这不是一个确定的列表，但可以给出何时选择单体架构的思路：
- en: When the **application** **scope** is small and well defined, and you are sure
    that the application will not grow tremendously in terms of features. For example,
    a blog, a simple online shopping website, a simple CRUD application, and so on.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当**应用程序****范围**小且定义明确，并且你确信应用程序在功能上不会大幅增长。例如，一个博客、一个简单的在线购物网站、一个简单的CRUD应用程序等。
- en: When the **team size** is small, say less than eight people (it's not a hard
    limit but rather practical).
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当**团队规模**较小时，比如说少于八人（这不是一个硬性限制，而是一个实际限制）。
- en: When the **average skill set** of the team is either novice or intermediate.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当团队的**平均技能水平**为新手或中级时。
- en: When **time to market** is critical.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当**上市时间**至关重要时。
- en: When you do not want to spend too much on **infrastructure**, monitoring, and
    so on.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你不想在**基础设施**、监控等方面花费太多时。
- en: When your **user base** is rather small and you do not expect them to grow.
    For example, an enterprise app targeting a specific set of users.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你的**用户基础**相对较小，并且你预计它们不会增长。例如，针对特定用户群体的企业应用。
- en: In most practical use cases, a monolithic architecture would suffice. Read on
    to the next section to see when you should consider a microservice architecture
    over monolithic.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数实际用例中，单体架构就足够了。继续阅读下一节，了解何时应考虑微服务架构而不是单体架构。
- en: When to choose a microservice architecture
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择微服务架构的时机
- en: 'The following list can be used as a general guide when choosing a microservice
    architecture. This is not a definitive list but gives an idea of when to go with
    microservices architecture over a monolith. Please note that unlike choosing a
    monolithic architecture, the decision here is more complex and may involve cross
    consideration among many of the following points:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表可以作为选择微服务架构的一般指南。这不是一个确定的列表，但可以给出何时选择微服务架构而不是单体架构的想法。请注意，与选择单体架构不同，这里的决策更为复杂，可能涉及以下许多点的交叉考虑：
- en: When the **application** **scope** is large and well defined and you are sure
    that the application will grow tremendously in terms of features. For example,
    an online e-commerce store, a social media service, a video streaming service
    with a large user base, an API provider, and so on.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当**应用范围**大且定义明确，并且你确信应用在功能上会大幅增长。例如，一个在线电子商务商店、社交媒体服务、面向大量用户的视频流媒体服务、API提供商等。
- en: When the **team size** is large, there must be enough members to effectively
    develop individual components independently.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当**团队规模**较大时，必须有足够的成员来独立有效地开发各个组件。
- en: When the **average skill set** of the team is good and team members are confident
    about advanced microservice patterns.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当团队的**平均技能水平**较高，并且团队成员对高级微服务模式有信心。
- en: When **time to market** is not critical. The microservice architecture will
    take more time to get right up front.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当**上市时间**不是关键。微服务架构在初期需要更多时间来正确实施。
- en: When you are ready to spend more on **infrastructure**, monitoring, and so on,
    in order to improve the product quality.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你准备在**基础设施**、监控等方面投入更多，以提高产品质量。
- en: When your **user base** is huge and you expect them to grow. For example, a
    social media application targeting users all over the world.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你的**用户基础**庞大，并且你预计它们会增长。例如，面向全球用户的社交媒体应用。
- en: Though a monolithic architecture would suffice in most cases, investing up front
    in a microservice architecture will reap long-term benefits when the application
    grows huge.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在大多数情况下单体架构就足够了，但在一开始就投资于微服务架构，当应用规模变得巨大时，将带来长期的好处。
- en: For more on these architecture patterns, you can refer to [https://articles.microservices.com/monolithic-vs-microservices-architecture-5c4848858f59](https://articles.microservices.com/monolithic-vs-microservices-architecture-5c4848858f59).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些架构模式，你可以参考[https://articles.microservices.com/monolithic-vs-microservices-architecture-5c4848858f59](https://articles.microservices.com/monolithic-vs-microservices-architecture-5c4848858f59)。
- en: Summary
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: So far, we've seen what full stack development is and compared two of the most
    prominent architecture patterns. We also learned advantages and disadvantages
    of monolithic and microservice architecture, which helps us to choose the right
    pattern for our use cases at hand.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了全栈开发是什么，比较了两种最突出的架构模式。我们还学习了单体和微服务架构的优缺点，这有助于我们为手头的用例选择正确的模式。
- en: In the next chapter, we will take a deep dive into the JHipster platform and
    look at all the options it provides. We will also learn how to install JHipster
    and set up our tools and development environment.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨JHipster平台，并查看它提供的所有选项。我们还将学习如何安装JHipster以及设置我们的工具和开发环境。
