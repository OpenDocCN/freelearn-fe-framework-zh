<html><head></head><body>
		<div>
			<div id="_idContainer190" class="Content">
			</div>
		</div>
		<div id="_idContainer191" class="Content">
			<h1 id="_idParaDest-128"><a id="_idTextAnchor181"/>6. Routing</h1>
		</div>
		<div id="_idContainer238" class="Content">
			<p class="callout-heading"><a id="_idTextAnchor182"/>Overview</p>
			<p class="callout">In this chapter, we will understand how routing and Vue Router work. We will also set up, implement, and manage the routing system in our app with Vue Router. Then we will look at dynamic routing for passing parameter values and nested routes for better reusability in complex applications. In addition, we will look at JavaScript Hooks, which can be used for features such as authentication and error handling. By the end of this chapter, you will be ready to handle static and dynamic routing in any Vue application.</p>
			<h1 id="_idParaDest-129"><a id="_idTextAnchor183"/>Introduction</h1>
			<p><strong class="bold">Routing</strong> is one of the most essential and primary parts of building dynamic web applications. You may be familiar with the word in its everyday context. For example, when we use Google Maps, we find the best route to get to a location. Routing in Vue and other frameworks is much the same. It is the process of getting a user to their desired location. When a user enters <strong class="source-inline">website.com/about</strong> into their URL bar, they are routed to the about page.</p>
			<p>With <strong class="bold">Single-Page Applications</strong> (<strong class="bold">SPAs</strong>), routing allows navigation within the application to be done smoothly and without the need for page refreshing. In web development, routing is the matching mechanism by which we decide how to connect HTTP requests to the code that handles them. We use routing whenever there is a need for URL navigation in our application. Most modern web applications contain a lot of different URLs, even single-page ones. Thus, routing plays a significant role in creating a navigation system and helps users move around our application and the web quickly.</p>
			<p>In short, routing is a way for an application to interpret what resource users want based on the URL provided. It is a system for web-based resource navigation with URLs, such as paths to assets (images and videos), scripts, and stylesheets.</p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor184"/>Vue Router</h1>
			<p>Vue Router, as stated in the Vue.js documentation, is officially recommended as a router service for any Vue.js application. It provides a single entry point for communication between components with routes, hence controlling the flow of the application effectively, regardless of the user's behavior.</p>
			<p>With a wide range of features, it eases the process of switching pages without the need to refresh the page.</p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor185"/>Setting Up Vue Router</h2>
			<p>Vue Router is not installed by default; however, it can easily be enabled when creating an application with Vue CLI. Create an application by running the following command:</p>
			<p class="source-code">vue create &lt;your-project-name&gt;</p>
			<p>Select the <strong class="source-inline">Manually select features</strong> option as shown in <em class="italic">Figure 6.1</em>:</p>
			<div>
				<div id="_idContainer192" class="IMG---Figure">
					<img src="image/B15218_06_01.jpg" alt="Figure 6.1: Select the manual preset to create a new Vue.js project&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1: Select the manual preset to create a new Vue.js project</p>
			<p>After choosing the option to manually select features, you will be shown a list of features as presented in <em class="italic">Figure 6.2</em>. At the time of writing, by default <strong class="source-inline">Babel</strong> and <strong class="source-inline">Linter / Formatter</strong> are selected. Using the <em class="italic">down arrow</em> key, navigate to the <strong class="source-inline">Router</strong> option. With the option highlighted, press the <em class="italic">spacebar</em> to enable it, and then press <em class="italic">Enter</em> to continue.</p>
			<div>
				<div id="_idContainer193" class="IMG---Figure">
					<img src="image/B15218_06_02.jpg" alt="Figure 6.2: Add Vue Router to the project&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2: Add Vue Router to the project</p>
			<p>Next, you will be shown a prompt asking if you want to use <strong class="source-inline">history mode</strong> for router configuration, as shown in <em class="italic">Figure 6.3</em>. Enable history mode by entering <strong class="source-inline">Y</strong>. History mode allows navigating between pages without the reload required by the default hash mode. We'll compare the two modes more closely later in the chapter:</p>
			<div>
				<div id="_idContainer194" class="IMG---Figure">
					<img src="image/B15218_06_03.jpg" alt="Figure 6.3: Configure Vue Router with history mode&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.3: Configure Vue Router with history mode</p>
			<p>Finally, continue with the rest of the process and we will have a Vue.js application with Vue Router ready to use.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you would like to add Vue Router to an existing Vue.js application, you can install it as an application's dependency with the following command:</p>
			<p class="callout"><strong class="source-inline">npm install vue-router</strong></p>
			<p>The next step is to understand the basics of how <strong class="source-inline">vue-router</strong> performs synchronization between the browser URL and the application's view.</p>
			<p>First, let's look at the <strong class="source-inline">router-view</strong> element.</p>
			<h1 id="_idParaDest-132">The<a id="_idTextAnchor186"/> router-view Element</h1>
			<p>The <strong class="source-inline">router-view</strong> element is a <strong class="bold">functional</strong> component in which the app routing system loads the matched and up-to-date view content of any given URL path received from the user.</p>
			<p>In short, <strong class="source-inline">router-view</strong> is a Vue component whose job is to do the following:</p>
			<ul>
				<li>Render different child components</li>
				<li>Mount and unmount itself automatically at any nesting level, depending on the route's given path</li>
			</ul>
			<p>Without <strong class="source-inline">router-view</strong>, it is almost impossible to have dynamic content rendered correctly for users at runtime. For example, when a user navigates to the <strong class="source-inline">Home</strong> page, <strong class="source-inline">router-view</strong> knows and renders the content related to that page only.</p>
			<p>In the next section, we will see how we can set the entry point (default route) of an application by passing it a prop.</p>
			<h1 id="_idParaDest-133">Usi<a id="_idTextAnchor187"/>ng Props to Define the Entry Point of an Application</h1>
			<p>Since <strong class="source-inline">router-view</strong> is a component, it can also receive props. The only prop it receives is <strong class="source-inline">name</strong>, which is the same name registered in the corresponding route's record defined in the <strong class="source-inline">router</strong> object at the initialization phase.</p>
			<p>Any other additional attributes are passed directly to the child component of <strong class="source-inline">router-view</strong> during rendering. Here is an example with a class attribute:</p>
			<p class="source-code">&lt;router-view class="main-app-view"/&gt;</p>
			<p>If <strong class="source-inline">router-view</strong> renders as a child component, we can create an associated template where the layout is defined. A very simple example of a template is as follows:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div&gt;Hello World&lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt; </p>
			<p>The child component receives the passed attribute class, and the actual output after rendering becomes the following:</p>
			<p class="source-code">&lt;div class="main-app-view"&gt;Hello World&lt;/div&gt;</p>
			<p>Of course, for our template to be useful, it should also contain the <strong class="source-inline">&lt;router-view/&gt;</strong> element so that content we want to route has somewhere to be rendered. One common setup is to have a navigation menu within the template and <strong class="source-inline">router-view</strong> underneath. That way the content changes between pages but the menu stays the same.</p>
			<p>Navigate to <strong class="source-inline">App.vue</strong> and ensure your template has the following code:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div id="app"&gt;</p>
			<p class="source-code">    &lt;div id="nav"&gt;</p>
			<p class="source-code">      &lt;router-link to="/"&gt;Home&lt;/router-link&gt; |</p>
			<p class="source-code">      &lt;router-link to="/about"&gt;About&lt;/router-link&gt;</p>
			<p class="source-code">    &lt;/div&gt;</p>
			<p class="source-code">    &lt;router-view/&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p>Let's remove all the code within <strong class="source-inline">&lt;div id="app"&gt;</strong> and leave only one single <strong class="source-inline">&lt;router-view/&gt;</strong> component:</p>
			<p class="source-code">&lt;div id="app"&gt;</p>
			<p class="source-code">    &lt;router-view/&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p>We will now comment out all the code for <strong class="source-inline">routes</strong> as follows:</p>
			<p class="source-code">const routes = [</p>
			<p class="source-code">  // {</p>
			<p class="source-code">  //   path: '/',</p>
			<p class="source-code">  //   name: 'Home',</p>
			<p class="source-code">  //   component: Home</p>
			<p class="source-code">  // },</p>
			<p class="source-code">  // {</p>
			<p class="source-code">  //   path: '/about',</p>
			<p class="source-code">  //   name: 'About',</p>
			<p class="source-code">  //   // route level code-splitting</p>
			<p class="source-code">  //   // this generates a separate chunk (about.[hash].js) for     this route</p>
			<p class="source-code">  //   // which is lazy-loaded when the route is visited.</p>
			<p class="source-code">  //   component: () =&gt; import(/* webpackChunkName: "about" */     '../views/About.vue')</p>
			<p class="source-code">  // }</p>
			<p class="source-code">]</p>
			<p>Now our app output will be rendered as a blank page running on <strong class="source-inline">localhost:8080</strong>, as shown in <em class="italic">Figure 6.4</em>:</p>
			<div>
				<div id="_idContainer195" class="IMG---Figure">
					<img src="image/B15218_06_04.jpg" alt="Figure 6.4: Hello Vue Router application in the browser&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.4: Hello Vue Router application in the browser</p>
			<p>The output is an empty page because we have not set up any router configurations in our file, including mapping the paths with the related view. Without this step, the routing system will not be able to pick the right view and render it into our <strong class="source-inline">router-view</strong> element dynamically.</p>
			<p>In t<a id="_idTextAnchor188"/>he next section, we will see how to set up Vue Router.</p>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor189"/>Setting Up Vue Router for Vue to Use</h1>
			<p>When we add Vue Router to our project, Vue CLI creates and adds a <strong class="source-inline">router</strong> folder to the code directory, containing a single auto-generated <strong class="source-inline">index.js</strong> file. This file contains the necessary configurations for our router.</p>
			<p>We will navigate to the file and go through the basic predefined configuration for Vue Router.</p>
			<p>First, you will notice that we need to import both <strong class="source-inline">Vue</strong> and <strong class="source-inline">VueRouter</strong> from the <strong class="source-inline">vue</strong> and <strong class="source-inline">vue-router</strong> packages, respectively. Then we call <strong class="source-inline">Vue.use (VueRouter)</strong> to install it as a plugin for use within our application:</p>
			<p class="source-code">import Vue from 'vue'</p>
			<p class="source-code">import VueRouter from 'vue-router'</p>
			<p class="source-code">Vue.use(VueRouter)</p>
			<p><strong class="source-inline">Vue.use</strong> is a global method, as discussed in <em class="italic">Chapter 5</em>, <em class="italic">Global Component Composition</em>. It triggers the internal <strong class="source-inline">install</strong> method of <strong class="source-inline">VueRouter</strong> together with the Vue constructor as soon as Vue is available as a global variable of the application. This method has a built-in mechanism to prevent installing a plugin more than once.</p>
			<p>After executing <strong class="source-inline">Vue.use(VueRouter)</strong>, the following objects are available for access in any component:</p>
			<ul>
				<li><strong class="source-inline">this.$router</strong> – The global router object</li>
				<li><strong class="source-inline">this.$route</strong> – The current route object</li>
			</ul>
			<p><strong class="source-inline">this</strong> points to the component in context.</p>
			<p>Now that we have registered the use of Vue Router in our application, let's move on to the next step – defining the routes for the configuration object of the router instance.</p>
			<h2 id="_idParaDest-135">Defi<a id="_idTextAnchor190"/>ning the Routes</h2>
			<p>In a web application, a <strong class="source-inline">route</strong> is a URL path pattern and is mapped to a specific handler. The <strong class="source-inline">handler</strong>, in modern web development, is a component, defined and located in a physical file. For example, when the user enters the route <strong class="source-inline">localhost:8080//home</strong>, if <strong class="source-inline">Home</strong> is mapped to this specific route, the routing system knows to trigger the handler <strong class="source-inline">Home</strong> to render the content accordingly.</p>
			<p>As seen in the preceding example, it is crucial to set up the routes (or paths) for navigation within the application.</p>
			<p>Each route is an object literal whose properties are declared by the <strong class="source-inline">RouteConfig</strong> interface:</p>
			<p class="source-code">interface RouteConfig = {</p>
			<p class="source-code">  path: string,</p>
			<p class="source-code">  component?: Component,</p>
			<p class="source-code">  name?: string, // for named routes</p>
			<p class="source-code">  components?: { [name: string]: Component }, // for named views</p>
			<p class="source-code">  redirect?: string | Location | Function,</p>
			<p class="source-code">  props?: boolean | Object | Function,</p>
			<p class="source-code">  alias?: string | Array&lt;string&gt;,</p>
			<p class="source-code">  children?: Array&lt;RouteConfig&gt;, // for nested routes</p>
			<p class="source-code">  beforeEnter?: (to: Route, from: Route, next: Function) =&gt; void,</p>
			<p class="source-code">  meta?: any,</p>
			<p class="source-code">  // 2.6.0+</p>
			<p class="source-code">  caseSensitive?: boolean, // use case sensitive match? (    default: false)</p>
			<p class="source-code">  pathToRegexpOptions?: Object // path-to-regexp options for     compiling regex</p>
			<p class="source-code">}</p>
			<p>All the routes needed for an application are located within the <strong class="source-inline">Array</strong> instance of <strong class="source-inline">routes</strong>:</p>
			<p class="source-code">const routes = [</p>
			<p class="source-code">  //Route1,</p>
			<p class="source-code">  //Route2,</p>
			<p class="source-code">  //...</p>
			<p class="source-code">]</p>
			<p>Now, let's come back to the previous file, and uncomment the code inside <strong class="source-inline">routes</strong>. There will be two predefined routes, <strong class="source-inline">home</strong> and <strong class="source-inline">about</strong>, each as an object and located in the <strong class="source-inline">routes</strong> array, for our convenience. </p>
			<p>Let's take a closer look at the first route as an example:</p>
			<p class="source-code">  {</p>
			<p class="source-code">    path: '/',</p>
			<p class="source-code">    name: 'home',</p>
			<p class="source-code">    component: Home</p>
			<p class="source-code">  }</p>
			<p>The <strong class="source-inline">path</strong> property is a <strong class="bold">required</strong> string that indicates the path of the targeted route and is resolved to an absolute URL path for the browser's navigation. For instance, the <strong class="source-inline">/about</strong> path will be translated into <strong class="source-inline">&lt;app domain&gt;/about</strong> (<strong class="source-inline">localhost:8080/about</strong> or <strong class="source-inline">example.com/about</strong>).</p>
			<p>In this case, Vue Router understands <strong class="source-inline">/</strong> – the empty path – as the default path for loading the application when there is no other indicator after the forward slash <strong class="source-inline">/</strong>, for example when the user navigates to <strong class="source-inline">&lt;app-domain&gt;</strong> or <strong class="source-inline">&lt;app-domain&gt;/</strong>.</p>
			<p>The next property is <strong class="source-inline">name</strong>, which is a string, indicating the name given to the targeted route. Even though it is <strong class="bold">optional</strong>, it's strongly recommended to have every route defined with a name, for better code maintenance and route tracking purposes, which we will discuss further later in this chapter, in the <em class="italic">Passing route parameters</em> section.</p>
			<p>The last property is <strong class="source-inline">component</strong>, which is a Vue component instance. <strong class="source-inline">router-view</strong> uses this property as a reference to the view component to render the page content when the path is active.</p>
			<p>Here we have the route defined as the <strong class="source-inline">home</strong> route, mapped as the default path to the application and tied to the <strong class="source-inline">Home</strong> component for content.</p>
			<p>Vue CLI also auto-generates two simple components for these two sample routes – <strong class="source-inline">Home</strong> and <strong class="source-inline">About</strong>.</p>
			<p>In the next section, we'll go over some tips that can be helpful when loading components to be used with routes.</p>
			<h2 id="_idParaDest-136">Tips<a id="_idTextAnchor191"/> on Loading Components for Route Configuration</h2>
			<p>Certainly, we need to import the component to tie it to the targeted route in the same <strong class="source-inline">index.js</strong> file. The classic and most popular way is to import it at the top of the file, as follows:</p>
			<p class="source-code">import Home from '../views/Home.vue'</p>
			<p>Often this will be added under the main imports as shown in <em class="italic">Figure 6.5</em>:</p>
			<div>
				<div id="_idContainer196" class="IMG---Figure">
					<img src="image/B15218_06_05.jpg" alt="Figure 6.5: Import Home component on line 3 – src/router/index.js&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.5: Import Home component on line 3 – src/router/index.js</p>
			<p>However, a more efficient way is to lazy-load the component.</p>
			<p><strong class="bold">Lazy loading</strong>, also known as on-demand loading is a technique that aims to optimize the content of a website or web application at runtime. It helps to reduce the time consumption and amount of resources required to download for an application on the first load. This optimization is critical to ensure the best user experience possible, where every millisecond of waiting matters. Besides this, lazy loading also allows better code-splitting at the route level, along with performance optimization in large or complex applications.</p>
			<p>We can lazy-load the component with the benefit of using <strong class="source-inline">webpack</strong>. Instead of importing the <strong class="source-inline">About</strong> component at the top of the file, as we did with <strong class="source-inline">Home</strong> (see <em class="italic">Figure 6.5</em>), we can instead dynamically add the following right after defining the name for the <strong class="source-inline">about</strong> route:</p>
			<p class="source-code">component: () =&gt; import(/* webpackChunkName: "about" */   '../views/About.vue')</p>
			<p>Here we dynamically lazy-load the <strong class="source-inline">About</strong> view component for the <strong class="source-inline">about</strong> route. During compilation, <strong class="source-inline">webpack</strong> generates a separate chunk with the designated name (<strong class="source-inline">"about"</strong>) for the <strong class="source-inline">about</strong> route, and only loads it when the user visits this route.</p>
			<p>In most cases, since the user will likely land on the default path on the first go, it is better to not lazy-load the default component (<strong class="source-inline">Home</strong> in our app) but to import it in the normal way. Hence, the tip here is to determine which components should be lazy-loaded when designing your routing and combine the two methods for the most benefit.</p>
			<p>We will now see how to set up the router instance.</p>
			<h2 id="_idParaDest-137">Setti<a id="_idTextAnchor192"/>ng up the Router Instance</h2>
			<p>After defining the routes, the final step is to create the <strong class="source-inline">router</strong> instance based on the given configuration options:</p>
			<p class="source-code">const router = new VueRouter({</p>
			<p class="source-code">  mode: 'history',</p>
			<p class="source-code">  base: process.env.BASE_URL,</p>
			<p class="source-code">  routes</p>
			<p class="source-code">})</p>
			<p>A configuration is an object consisting of different properties that help to form the app's router. We will now examine these properties in the following subsections.</p>
			<h3 id="_idParaDest-138"><a id="_idTextAnchor193"/>routes</h3>
			<p><strong class="source-inline">routes</strong> is a must-have option to pass to the constructor. Without this, the router won't be able to recognize the paths and direct users to the suitable view content accordingly.</p>
			<h3 id="_idParaDest-139"><a id="_idTextAnchor194"/>mode</h3>
			<p><strong class="source-inline">mode</strong> determines the router's mode. There are two modes in <strong class="source-inline">VueRouter</strong> for URLs:</p>
			<ul>
				<li><strong class="source-inline">history</strong> mode: This leverages the default <strong class="source-inline">history.pushState()</strong> API by means of the <strong class="source-inline">HTML5 History</strong> API. It allows us to achieve URL navigation without a page reload and makes the URL path human-readable, such as <strong class="source-inline">yourapplication.com/about</strong>.</li>
				<li><strong class="source-inline">hash</strong> mode: This uses a hash symbol (<strong class="source-inline">#</strong>) to simulate a URL, for example, <strong class="source-inline">yourapplication.com/#about</strong> for an <strong class="source-inline">about</strong> page or <strong class="source-inline">youapplication/#/</strong> for the <strong class="source-inline">home</strong> URL of your application.</li>
			</ul>
			<h3 id="_idParaDest-140"><a id="_idTextAnchor195"/>base</h3>
			<p><strong class="source-inline">base</strong> determines the base URL for the app. It will be set as <strong class="source-inline">process.env.BASE_URL</strong> to allow developers to control this from outside of the application code (from a <strong class="source-inline">.env</strong> file, for example). Hence developers can set the directory from which the code should be served upon running.</p>
			<p>With <strong class="source-inline">base</strong> finally out of the way now, we have the <strong class="source-inline">router</strong> instance created. All that is left is to export it:</p>
			<p class="source-code">export default router</p>
			<p>Then import it in <strong class="source-inline">main.js</strong>, right before the creation of the main app instance's <strong class="source-inline">new Vue</strong> object. We still need to specify <strong class="source-inline">router</strong> in the instance configuration, as shown in the following:</p>
			<p class="source-code">import router from './router'</p>
			<p class="source-code">Vue.config.productionTip = false</p>
			<p class="source-code">new Vue({</p>
			<p class="source-code">  router, //specify the router configuration for use</p>
			<p class="source-code">  render: h =&gt; h(App)</p>
			<p class="source-code">}).$mount('#app')</p>
			<p>With this updated code, our application will now render as follows:</p>
			<div>
				<div id="_idContainer197" class="IMG---Figure">
					<img src="image/B15218_06_06.jpg" alt="Figure 6.6: Home page of the Hello Vue Router application in the browser&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.6: Home page of the Hello Vue Router application in the browser</p>
			<p>If we navigate to <strong class="source-inline">localhost:8080/about</strong>, we will see the rendered content of the <strong class="source-inline">about</strong> component from the auto-generated code:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div class="about"&gt;</p>
			<p class="source-code">    &lt;h1&gt;This is an about page&lt;/h1&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p>The website should look similar to that shown in <em class="italic">Figure 6.7</em>:</p>
			<div>
				<div id="_idContainer198" class="IMG---Figure">
					<img src="image/B15218_06_07.jpg" alt="Figure 6.7: About page of the &quot;Hello Vue Router&quot; application in the browser&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.7: About page of the "Hello Vue Router" application in the browser</p>
			<p>In this section, we looked at how lazily loading components can be used to speed up large and complex SPAs. We also looked at some of the options that can be set when setting up your router, such as routes, mode, and base. In the next section, we will learn how to implement and add a message feed page with the help of Vue Router.</p>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor196"/>Exercise 6.01: Implementing and Adding a Message Feed Page Using Vue Router </h2>
			<p>We are going to create a new page that displays a list of messages to the user. Users will be able to visit this page whenever they enter the <strong class="source-inline">localhost:8080/messages</strong> path in the browser.</p>
			<p>To access the code files for this exercise, refer to <a href="https://packt.live/35alpze">https://packt.live/35alpze</a>.</p>
			<ol>
				<li>Use the application generated with <strong class="source-inline">vue create</strong> as a starting point or create a new one with <strong class="source-inline">vue-cli</strong>. Ensure you had the router enabled when generating your project as described earlier in the chapter:<p class="source-code">vue create Exercise6.01</p></li>
				<li>Let's create a new view component called <strong class="source-inline">MessageFeed</strong> by adding a <strong class="source-inline">MessageFeed.vue</strong> file to the <strong class="source-inline">./src/views/</strong> folder:<div id="_idContainer199" class="IMG---Figure"><img src="image/B15218_06_08.jpg" alt="Figure 6.8: The views directory hierarchy&#13;&#10;"/></div><p class="figure-caption">Figure 6.8: The views directory hierarchy</p><p>The component will render a list of messages. Our message list is defined as an array of strings called <strong class="source-inline">messages</strong> in the component's <strong class="source-inline">data</strong> property as follows:</p><p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div&gt;</p><p class="source-code">    &lt;h2&gt; Message Feed &lt;/h2&gt;</p><p class="source-code">    &lt;p v-for="(m, i) in messages" :key="i"&gt;</p><p class="source-code">    {{ m }}</p><p class="source-code">    &lt;/p&gt;</p><p class="source-code">&lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  data() {</p><p class="source-code">    return {</p><p class="source-code">      messages: [</p><p class="source-code">        'Hello, how are you?',</p><p class="source-code">        'The weather is nice',</p><p class="source-code">        'This is message feed',</p><p class="source-code">        'And I am the fourth message'</p><p class="source-code">      ]</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>Create a router file at <strong class="source-inline">src/router/index.js</strong>. It should import <strong class="source-inline">VueRouter</strong> and tell Vue to use the router as follows:<p class="source-code">import Vue from 'vue'</p><p class="source-code">import VueRouter from 'vue-router'</p><p class="source-code">import Home from '../views/Home.vue'</p><p class="source-code">Vue.use(VueRouter)</p></li>
				<li>Next, in <strong class="source-inline">./src/router/index.js</strong>, we declare a route designated for <strong class="source-inline">MessageFeed</strong>, named <strong class="source-inline">messageFeed</strong> and with its path set to <strong class="source-inline">/messages</strong>. We will also lazy-load the component. This step will be completed by appending an object with the required information to the <strong class="source-inline">routes</strong> array:<p class="source-code">export const routes = [</p><p class="source-code">  {</p><p class="source-code">    path: '/',</p><p class="source-code">    name: 'home',</p><p class="source-code">    component: Home</p><p class="source-code">  },</p><p class="source-code">  {</p><p class="source-code">    path: '/about',</p><p class="source-code">    name: 'about',</p><p class="source-code">    // route level code-splitting</p><p class="source-code">    // this generates a separate chunk (about.[hash].js) for       this route</p><p class="source-code">    // which is lazy-loaded when the route is visited.</p><p class="source-code">    component: () =&gt; import(/* webpackChunkName: "about" */ '../      views/About.vue')</p><p class="source-code">  }, {</p><p class="source-code">    path: '/messages',</p><p class="source-code">    name: 'messageFeed',</p><p class="source-code">    component: () =&gt; import(/* webpackChunkName: "messages" */ '../      views/MessageFeed.vue')</p><p class="source-code">  }</p><p class="source-code">]</p></li>
				<li>Finally, in the same file, create a <strong class="source-inline">router</strong> instance using the <strong class="source-inline">routes</strong> we defined:<p class="source-code">const router = new VueRouter({</p><p class="source-code">  mode: 'history',</p><p class="source-code">  base: process.env.BASE_URL,</p><p class="source-code">  routes</p><p class="source-code">})</p><p class="source-code">export default router</p></li>
				<li>Run the application using the following command:<p class="source-code">yarn serve</p></li>
				<li>Upon visiting <strong class="source-inline">localhost:8080/messages</strong> in the browser, the page should appear with the correct content – the <strong class="source-inline">Message Feed</strong> page as shown in the following screenshot:<div id="_idContainer200" class="IMG---Figure"><img src="image/B15218_06_09.jpg" alt="Figure 6.9: Message feed page rendered by the application&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 6.9: Message feed page rendered by the application</p>
			<p>This demonstrates how simple it is to add a new page route to a Vue.js application using Vue Router, while keeping your code organized and easy to read. Now that we have our routes ready to use, we can provide users with the ability to navigate between pages, without typing the full path.</p>
			<h2 id="_idParaDest-142">Setting u<a id="_idTextAnchor197"/>p Navigation Links</h2>
			<p>If <strong class="source-inline">router-view</strong> is in charge of rendering the correct active view content relative to the URL path, <strong class="source-inline">router-link</strong> is a Vue component that helps users to navigate within an app that has routing enabled. By default, it renders an anchor tag <strong class="source-inline">&lt;a&gt;</strong> with a correct <strong class="source-inline">href</strong> link generated by its <strong class="source-inline">to</strong> prop.</p>
			<p>In our example app generated by Vue CLI, since there are two routes pre-populated, there are also two <strong class="source-inline">router-link</strong> instances added to the <strong class="source-inline">&lt;template&gt;</strong> section of <strong class="source-inline">App.vue</strong> right before <strong class="source-inline">&lt;router-view/&gt;</strong>:</p>
			<p class="source-code">&lt;div id="nav"&gt;</p>
			<p class="source-code">  &lt;router-link to="/"&gt;Home&lt;/router-link&gt; |</p>
			<p class="source-code">  &lt;router-link to="/about"&gt;About&lt;/router-link&gt;</p>
			<p class="source-code">&lt;/div&gt;</p>
			<p>Since we are using the <strong class="source-inline">base</strong> option with the <strong class="source-inline">history</strong> mode, the <strong class="source-inline">to</strong> prop of each <strong class="source-inline">router-link</strong> should receive an identical value with the <strong class="source-inline">path</strong> property declared in the targeted <strong class="source-inline">route</strong> object. </p>
			<p>In addition, because our routes are named, another alternative to the <strong class="source-inline">to</strong> prop is to have the same value as the name, instead of the path. Using the name is highly recommended to avoid complex link refactoring in case we have to adjust the paths given to some routes in our app. Hence, we can rewrite our links as follows:</p>
			<p class="source-code">&lt;div id="nav"&gt;</p>
			<p class="source-code">      &lt;router-link to="home"&gt;Home&lt;/router-link&gt; |</p>
			<p class="source-code">      &lt;router-link to="about"&gt;About&lt;/router-link&gt; |</p>
			<p class="source-code">    &lt;/div&gt;</p>
			<p>We can also choose to bind a location descriptor object to the <strong class="source-inline">to</strong> prop, in a similar format as a <strong class="source-inline">route</strong> object. Consider the following example:</p>
			<p class="source-code">  &lt;router-link :to="{path: '/'}"&gt;Home&lt;/router-link&gt;</p>
			<p>In addition, an extra <strong class="source-inline">CSS</strong> class <strong class="source-inline">router-link-active</strong> will be added to the <strong class="source-inline">&lt;a&gt;</strong> tag, when the related route is <strong class="source-inline">active</strong>. This class can be customized through the <strong class="source-inline">active-class</strong> prop of the <strong class="source-inline">router-link</strong> component.</p>
			<p>In <strong class="source-inline">DevTools</strong>, we can see the <strong class="source-inline">router-link</strong> component rendered as follows:</p>
			<div>
				<div id="_idContainer201" class="IMG---Figure">
					<img src="image/B15218_06_10.jpg" alt="Figure 6.10: router-link in the browser's DevTools&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.10: router-link in the browser's DevTools</p>
			<p>The view in the browser will be as follows:</p>
			<div>
				<div id="_idContainer202" class="IMG---Figure">
					<img src="image/B15218_06_11.jpg" alt="Figure 6.11: Home page of Hello Vue Router app with navigation links&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.11: Home page of Hello Vue Router app with navigation links</p>
			<p>Note that since we have access to <strong class="source-inline">this.$router</strong> within a component, we can trigger a navigation route programmatically by using <strong class="source-inline">this.$router.push()</strong> and pass a path or a router object in a similar way to using <strong class="source-inline">to</strong>:</p>
			<p class="source-code">      this.$router.push('/home')</p>
			<p>In this section, we created an example page that rendered a list of messages at the <strong class="source-inline">/messages</strong> route location. We also looked at how you can use the <strong class="source-inline">&lt;router-link/&gt;</strong> element to navigate between our views in a way similar to traditional HTML <strong class="source-inline">&lt;a&gt;</strong> tags.</p>
			<p>Next, we will see how you can programmatically send a user to their last viewed route in a manner similar to the web browser's <em class="italic">back</em> button.</p>
			<h3 id="_idParaDest-143"><a id="_idTextAnchor198"/>Tip to Implement the Back Button</h3>
			<p>Sometimes we would like to navigate back to the previous page. Using <strong class="source-inline">this.$router.push()</strong> can achieve this, but this adds more routes in the history stack, instead of going back. The correct technique is to use <strong class="source-inline">this.$router.go(steps)</strong>, in which <strong class="source-inline">steps</strong> is an integer indicating the number of steps to go back/forward in the history stack. This functionality works similarly to <strong class="source-inline">window.history.go(steps)</strong>.</p>
			<p>Consider the following example:</p>
			<p class="source-code">this.$router.go(-1) // similar to window.history.back()  -   go back one page</p>
			<p>Besides this, you can also navigate forward to a page that was loaded before and still exists in the history stack by using the same method, as follows:</p>
			<p class="source-code">this.$router.go(1) // similar to window.history.forward() –   go forward one page</p>
			<p>In this section, we looked at how you can manually access the router's history in order to send a user to the page they were previously on.</p>
			<p>In the next section, we'll make use of navigation links to add our new message feed page to our application's <strong class="source-inline">nav</strong> menu.</p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor199"/>Exercise 6.02: Adding the Navigation Link to the MessageFeed Route </h2>
			<p>We will add a quick link to the <strong class="source-inline">MessageFeed</strong> route we created in <em class="italic">Exercise 6.01</em>, <em class="italic">Implementing and Adding a Message Feed Page Using Vue Router</em>, using the <strong class="source-inline">to</strong> prop and <strong class="source-inline">router-link</strong> as explained in the preceding topic.</p>
			<p>To access the code files for this exercise, refer to <a href="https://packt.live/3lr8cYR">https://packt.live/3lr8cYR</a>.</p>
			<ol>
				<li value="1">Use the starter application generated by Vue as a starting point or create a new one with <strong class="source-inline">Vue cli</strong>. Ensure you have the router enabled when generating your project as described earlier in the chapter:<p class="source-code">vue create Exercise6.02</p></li>
				<li>In the <strong class="source-inline">./src/App.vue</strong> file, besides the auto-generated <strong class="source-inline">router-link</strong> components for <strong class="source-inline">home</strong> and <strong class="source-inline">about</strong>, add another <strong class="source-inline">router-link</strong> component that points to the <strong class="source-inline">/messages</strong> path under the <strong class="source-inline">Message Feed</strong> title:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div id="app"&gt;</p><p class="source-code">    &lt;div id="nav"&gt;</p><p class="source-code">      &lt;router-link to="/"&gt;Home&lt;/router-link&gt; |</p><p class="source-code">      &lt;router-link to="/about"&gt;About&lt;/router-link&gt; |</p><p class="source-code">      &lt;router-link to="/messages"&gt;Message Feed&lt;/router-link&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">    &lt;router-view/&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p>We will see the navigation links available in any view and they will not disappear when users navigate away since they are not a part of the <strong class="source-inline">router-view</strong> component. Our screen should look as follows:</p><div id="_idContainer203" class="IMG---Figure"><img src="image/B15218_06_12.jpg" alt="Figure 6.12. Home page of the Hello Vue Router app with updated navigation links&#13;&#10;"/></div><p class="figure-caption">Figure 6.12. Home page of the Hello Vue Router app with updated navigation links</p></li>
				<li>Let's change the <strong class="source-inline">to</strong> value to point to the object named <strong class="source-inline">messageFeed</strong>, which is the same as the <strong class="source-inline">name</strong> given for this route in <strong class="source-inline">./src/App.vue</strong>:<p class="source-code">&lt;router-link :to="{ name: `messageFeed` }"&gt;Message Feed   &lt;/router-link&gt;</p></li>
				<li>The navigation should work as before; clicking on the <strong class="source-inline">Message Feed</strong> link should direct you to <strong class="source-inline">/messages</strong>, as shown in the following screenshot:<div id="_idContainer204" class="IMG---Figure"><img src="image/B15218_06_13.jpg" alt="Figure 6.13: Message Feed page of Hello Vue Router after clicking on the Message Feed link&#13;&#10;"/></div><p class="figure-caption">Figure 6.13: Message Feed page of Hello Vue Router after clicking on the Message Feed link</p></li>
				<li>Now, open the <strong class="source-inline">index.js</strong> file located in the <strong class="source-inline">./src/router/</strong> folder and change the path defined for the <strong class="source-inline">messageFeed</strong> route from <strong class="source-inline">/messages/</strong> to <strong class="source-inline">/messagesFeed</strong>:<p class="source-code">export const routes = [</p><p class="source-code">  {</p><p class="source-code">    path: '/',</p><p class="source-code">    name: 'home',</p><p class="source-code">    component: Home</p><p class="source-code">  },</p><p class="source-code">  {</p><p class="source-code">    path: '/about',</p><p class="source-code">    name: 'about',</p><p class="source-code">    // route level code-splitting</p><p class="source-code">    // this generates a separate chunk (about.[hash].js) for       this route</p><p class="source-code">    // which is lazy-loaded when the route is visited.</p><p class="source-code">    component: () =&gt; import(/* webpackChunkName: "about" */ '../views/About.vue')</p><p class="source-code">  }, {</p><p class="source-code">    path: '/messagesFeed',</p><p class="source-code">    name: 'messageFeed',</p><p class="source-code">    component: () =&gt; import(/* webpackChunkName: "messageFeed" */       '../views/MessageFeed.vue')</p><p class="source-code">  }</p><p class="source-code">]</p></li>
				<li>Run the application using the following command:<p class="source-code">yarn serve</p><p>Navigate to the app's <strong class="source-inline">Home</strong> page and click on <strong class="source-inline">Message Feed</strong> again. It should display the same <strong class="source-inline">messages feed</strong> page as before but note that the URL path changed to <strong class="source-inline">/messagesFeed</strong>:</p><div id="_idContainer205" class="IMG---Figure"><img src="image/B15218_06_14.jpg" alt="Figure 6.14: Message Feed page rendered with the updated URL path&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 6.14: Message Feed page rendered with the updated URL path</p>
			<p>Note how easy it is to set up the link to the <strong class="source-inline">/messages</strong> path with just one line of code, as well as updating the related path without refactoring. So far, we have just defined some simple routes without any additional parameters for the targeted route. This will be our next challenge.</p>
			<h1 id="_idParaDest-145">Passing Route <a id="_idTextAnchor200"/>Parameters</h1>
			<p>In the previous sections of this chapter, each route was a standalone view and did not need to pass or connect any data to the other routes. But the power of routing is not limited only to this. With <strong class="bold">named</strong> routes, we can also easily enable data communication between routes.</p>
			<p>In our example app, we want our <strong class="source-inline">about</strong> page to be able to receive a data string called <strong class="source-inline">user</strong> as the user's name from the link trigger. This can be achieved by changing the <strong class="source-inline">to</strong> prop from a string literal to an object literal of <strong class="source-inline">:to="{ name: 'about' }"</strong>, and then adding a new <strong class="source-inline">params: { user: 'Adam' }</strong> property to that object:</p>
			<p class="source-code">&lt;router-link :to="{ name: 'about', params: { user: 'Adam' }}"&gt;</p>
			<p class="source-code">  About</p>
			<p class="source-code">&lt;/router-link&gt;</p>
			<p>This change informs the router to pass the desired parameters to the <strong class="source-inline">About</strong> page when users click on the targeted link. These additional parameters are not visible on the rendered <strong class="source-inline">href</strong> link, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer206" class="IMG---Figure">
					<img src="image/B15218_06_15.jpg" alt="Figure 6.15: Generated href link is without parameters&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.15: Generated href link is without parameters</p>
			<p>However, the Vue system is tracking these additional parameters. Using the Vue DevTools, we can view the parameters by expanding the <strong class="source-inline">to</strong> prop as shown in <em class="italic">Figure 6.16</em>:</p>
			<div>
				<div id="_idContainer207" class="IMG---Figure">
					<img src="image/B15218_06_16.jpg" alt="Figure 6.16: The params of the to object in Vue DevTools&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.16: The params of the to object in Vue DevTools</p>
			<p>In the <strong class="source-inline">About.vue</strong> file, since we have access to the currently active <strong class="source-inline">$route</strong> (see the <em class="italic">Vue Router</em> section earlier in this chapter), we can retrieve the data passed with the link as <strong class="source-inline">$route.params.user</strong> and print out the value:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div class="about"&gt;</p>
			<p class="source-code">    &lt;h1&gt;About {{$route.params.user}}&lt;/h1&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p>The output will be as follows:</p>
			<div>
				<div id="_idContainer208" class="IMG---Figure">
					<img src="image/B15218_06_17.jpg" alt="Figure 6.17: The About page renders the user passed through route params&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.17: The About page renders the user passed through route params</p>
			<p>Any prop user of <strong class="source-inline">params</strong> will not be visible on the URL path, thus keeping the path clean and securing the data transferred between views from the user.</p>
			<p>But using <strong class="source-inline">$route.params.user</strong> is not convenient or readable and doesn't keep the component reusable in the long run. We can improve this by decoupling the passed <strong class="source-inline">params</strong> with the <strong class="source-inline">props</strong> within the component.</p>
			<p>We will now see h<a id="_idTextAnchor201"/>ow to decouple the <strong class="source-inline">params</strong> with the help of <strong class="source-inline">props</strong>.</p>
			<h1 id="_idParaDest-146"><a id="_idTextAnchor202"/>Decoupling Params with Props</h1>
			<p>In the <strong class="source-inline">index.js</strong> file, let's adjust the configuration of the <strong class="source-inline">about</strong> route with an additional property called <strong class="source-inline">props</strong>. By setting this property's value to <strong class="source-inline">true</strong>, the router will automatically understand and map <strong class="source-inline">$route.params</strong> into the <strong class="source-inline">props</strong> component accordingly:</p>
			<p class="source-code">{</p>
			<p class="source-code">    path: '/about',</p>
			<p class="source-code">    name: 'about',</p>
			<p class="source-code">    component: () =&gt; import(/* webpackChunkName: "about" */       '../views/About.vue'),</p>
			<p class="source-code">    props: true</p>
			<p class="source-code">  }</p>
			<p>In the <strong class="source-inline">About.vue</strong> file, we will declare the <strong class="source-inline">props</strong> type as follows:</p>
			<p class="source-code">props: {</p>
			<p class="source-code">    user: String</p>
			<p class="source-code">  }</p>
			<p>And in the <strong class="source-inline">&lt;template&gt;</strong> section, we will replace <strong class="source-inline">$route.params.user</strong> with <strong class="source-inline">user</strong>:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div class="about"&gt;</p>
			<p class="source-code">    &lt;h1&gt;About {{user}}&lt;/h1&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p>The output will still be the same, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer209" class="IMG---Figure">
					<img src="image/B15218_06_18.jpg" alt="Figure 6.18: The About page renders the user passed through route params &#13;&#10;and mapped to props&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.18: The About page renders the user passed through route params and mapped to props</p>
			<p>In addition to this, you can also define the data that you want to pass within the <strong class="source-inline">props</strong> property of the <strong class="source-inline">route</strong> configuration. Instead of a Boolean value, <strong class="source-inline">props</strong> can now be declared as an object with the required data, as in the following example:</p>
			<p class="source-code">{</p>
			<p class="source-code">    path: '/about',</p>
			<p class="source-code">    name: 'about',</p>
			<p class="source-code">    component: () =&gt; import(/* webpackChunkName: "about" */       '../views/About.vue'),</p>
			<p class="source-code">    props: { age: 32 }</p>
			<p class="source-code">  }</p>
			<p>With a similar step, we will declare <strong class="source-inline">age</strong> as a <strong class="source-inline">props</strong> component in <strong class="source-inline">About.vue</strong>, and print it out to the screen as text:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div class="about"&gt;</p>
			<p class="source-code">    &lt;h1&gt;About {{user}}&lt;/h1&gt;</p>
			<p class="source-code">    &lt;h2&gt;Age: {{age}}&lt;/h2&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  props: {</p>
			<p class="source-code">    user: String,</p>
			<p class="source-code">    age: Number</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>Now when the <strong class="source-inline">About</strong> page is clicked, the page will render as follows:</p>
			<div>
				<div id="_idContainer210" class="IMG---Figure">
					<img src="image/B15218_06_19.jpg" alt="Figure 6.19: About page rendered with the props preset in the router configuration&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.19: About page rendered with the props preset in the router configuration</p>
			<p>Our previous user data is not visible anymore! This is because, now, <strong class="source-inline">props</strong> is declared with static data in the configuration of the <strong class="source-inline">About</strong> route and can't be overridden from outside. Its value is and will remain the same throughout the process of navigating around the app, regardless of what values we pass in <strong class="source-inline">params</strong> of the <strong class="source-inline">to</strong> prop in the targeted <strong class="source-inline">router-link</strong> component.</p>
			<p>We will now learn how to pass the content of the selected message to a new message page and print it.</p>
			<h2 id="_idParaDest-147">Exercise 6.03: Pas<a id="_idTextAnchor203"/>sing the Content of the Selected Message to a New Message Page and Having It Printed Out </h2>
			<p>We shall continue from <em class="italic">Exercise 6.02</em>, <em class="italic">Adding the Navigation Link to the MessageFeed Route</em>, where we defined the <strong class="source-inline">MessageFeed</strong> route with a URL path to <strong class="source-inline">messages</strong>. This view will render a list of predefined messages in the <strong class="source-inline">data</strong> property of the <strong class="source-inline">view</strong> component's options.</p>
			<p>In this exercise, we will create a new <strong class="source-inline">message</strong> page, designated to render the content of a message selected by the user. It should be reusable.</p>
			<p>To access the code files for this exercise, refer to <a href="https://packt.live/36mTwTY">https://packt.live/36mTwTY</a>.</p>
			<ol>
				<li value="1">In the <strong class="source-inline">./src/views/</strong> folder, we create a new single-file component called <strong class="source-inline">Message.vue</strong>. This component receives a <strong class="source-inline">content</strong> prop of type <strong class="source-inline">string</strong> and renders it under a <strong class="source-inline">&lt;p&gt;</strong> tag:<p class="source-code">&lt;template&gt;</p><p class="source-code">    &lt;div&gt;</p><p class="source-code">        &lt;p&gt;{{content}}&lt;/p&gt;</p><p class="source-code">    &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">    props: {</p><p class="source-code">        content: {</p><p class="source-code">            default: '',</p><p class="source-code">            type: String</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>Let's register the created view component to the existing <strong class="source-inline">routes</strong> in <strong class="source-inline">./src/router/index.js</strong>. We will define the new route as a <strong class="source-inline">message</strong> with the path to <strong class="source-inline">/message</strong>. It will also accept <strong class="source-inline">props: true</strong> in order to map all parameters passed to the route to the related prop accordingly. The full list of routes to be used is as follows:<p class="source-code">export const routes = [</p><p class="source-code">  {</p><p class="source-code">    path: '/',</p><p class="source-code">    name: 'home',</p><p class="source-code">    component: Home</p><p class="source-code">  },</p><p class="source-code">  {</p><p class="source-code">    path: '/about',</p><p class="source-code">    name: 'about',</p><p class="source-code">    component: () =&gt; import(/* webpackChunkName: "about" */       '../views/About.vue')</p><p class="source-code">  },</p><p class="source-code">  {</p><p class="source-code">    path: '/messages',</p><p class="source-code">    name: 'messageFeed',</p><p class="source-code">    component: () =&gt; import(/* webpackChunkName: "messages" */ '../views/MessageFeed.vue')</p><p class="source-code">  },</p><p class="source-code">  {</p><p class="source-code">    path: '/message',</p><p class="source-code">    name: 'message',</p><p class="source-code">    component: () =&gt; import(/* webpackChunkName: "message" */ '../views/Message.vue'),</p><p class="source-code">    props: true</p><p class="source-code">  }</p><p class="source-code">]</p></li>
				<li>Since the route is registered and ready to be used, we need to make changes to the <strong class="source-inline">&lt;template&gt;</strong> section of <strong class="source-inline">./src/views/MessageFeed.vue</strong> to ensure each message line is now clickable and will redirect the user to the new route when clicked. Let's replace the <strong class="source-inline">&lt;p&gt;</strong> tag with <strong class="source-inline">router-click</strong>. And because we have named our new route as <strong class="source-inline">message</strong>, we will set <strong class="source-inline">to</strong> to bind to <strong class="source-inline">{ name: 'message' }</strong>:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div&gt;</p><p class="source-code">  &lt;h2&gt; Message Feed &lt;/h2&gt;</p><p class="source-code">  &lt;div v-for="(m, i) in messages" :key="i" &gt;</p><p class="source-code">    &lt;router-link :to="{ name: 'message'}"&gt;</p><p class="source-code">      {{ m }}</p><p class="source-code">    &lt;/router-link&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p></li>
				<li>Under <strong class="source-inline">template</strong>, we'll add a <strong class="source-inline">script</strong> tag containing some sample data for our <strong class="source-inline">messages</strong>:<p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  data() {</p><p class="source-code">    return {</p><p class="source-code">      messages: [</p><p class="source-code">        'Hello, how are you?',</p><p class="source-code">        'The weather is nice',</p><p class="source-code">        'This is message feed',</p><p class="source-code">        'And I am the fourth message'</p><p class="source-code">      ]</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>When you open the <strong class="source-inline">./messages</strong> page, all the messages are now clickable as shown in the following screenshot:<div id="_idContainer211" class="IMG---Figure"><img src="image/B15218_06_20.jpg" alt="Figure 6.20: Message Feed page after changing messages to be clickable&#13;&#10;"/></div><p class="figure-caption">Figure 6.20: Message Feed page after changing messages to be clickable</p></li>
				<li>Now when the user clicks on a message, it will open a new page. However, the page content will be empty, as we have not passed any content parameter to the <strong class="source-inline">&lt;route-click&gt;</strong> component, as shown in the following screenshot:<div id="_idContainer212" class="IMG---Figure"><img src="image/B15218_06_21.jpg" alt="Figure 6.21: Message page with no content generated&#13;&#10;"/></div><p class="figure-caption">Figure 6.21: Message page with no content generated</p></li>
				<li>Let's go back to <strong class="source-inline">./src/views/MessageFeed.vue</strong> and add <strong class="source-inline">params: { content: m }</strong>:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div&gt;</p><p class="source-code">  &lt;h2&gt; Message Feed &lt;/h2&gt;</p><p class="source-code">  &lt;div v-for="(m, i) in messages" :key="i" &gt;</p><p class="source-code">    &lt;router-link :to="{ name: 'message', params: { content: m       }}"&gt;</p><p class="source-code">      {{ m }}</p><p class="source-code">    &lt;/router-link&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p></li>
				<li>Now when you click on the first message, <strong class="source-inline">Hello, how are you?</strong>, the output will be the following:<div id="_idContainer213" class="IMG---Figure"><img src="image/B15218_06_22.jpg" alt="Figure 6.22: Message page with the clicked message's content rendered&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 6.22: Message page with the clicked message's content rendered</p>
			<p>Simple, isn't it? We have completed the flow from a feed of messages to a detailed page of a single selected message dynamically with <strong class="source-inline">router-link</strong> and the combination of <strong class="source-inline">params</strong> and <strong class="source-inline">props</strong> of the component. However, there is one significant downside to this approach. </p>
			<p>Let's refresh the page while you are still on the <strong class="source-inline">./message</strong> path of the first message. The output will be the same as in <em class="italic">Step 5</em> – an empty content page. Upon refresh, the route is triggered without any <strong class="source-inline">content</strong> <strong class="source-inline">params</strong> passed, unlike when the user clicked on a specific link, and the <strong class="source-inline">params</strong> passed previously were not saved or cached. Hence there is no content. </p>
			<p>In the following section, we will learn how to intercept the navigation flow and solve this problem with <strong class="bold">Router Hooks</strong>.</p>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor204"/>Router Hooks</h1>
			<p>The gener<a id="_idTextAnchor205"/>al flow of route navigation is described in the following diagram:</p>
			<div>
				<div id="_idContainer214" class="IMG---Figure">
					<img src="image/B15218_06_23.jpg" alt="Figure 6.23: Navigation resolution flow diagram&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.23: Navigation resolution flow diagram</p>
			<p>Once navigation is triggered on a certain route, Vue Router provides several primary navigation guards, or Hooks, for developers to guard or intercept that navigation process. These guards can be hooked either globally or in the component, depending on the type. Some examples are as follows:</p>
			<ul>
				<li>Globally: <strong class="source-inline">beforeEach</strong>, <strong class="source-inline">beforeResolve</strong>, and <strong class="source-inline">afterEach</strong></li>
				<li>Per component: <strong class="source-inline">beforeEnter</strong></li>
				<li>In-component: <strong class="source-inline">beforeRouteUpdate</strong>, <strong class="source-inline">beforeRouteEnter</strong>, and <strong class="source-inline">beforeRouterLeave</strong></li>
			</ul>
			<p>As seen in <em class="italic">Figure 6.23</em>, navigation is considered completed only after all the Hooks or guards have been resolved, including any asynchronous guard. Now, let's see how to set up <strong class="source-inline">beforeEach</strong> Hooks.</p>
			<h2 id="_idParaDest-149">Setting up beforeEach H<a id="_idTextAnchor206"/>ooks</h2>
			<p><strong class="source-inline">beforeEach</strong> is a global Hook and is called at the very beginning of navigation, <strong class="bold">before</strong> the other global and in-component Hooks are triggered (<strong class="bold">except</strong> for <strong class="source-inline">beforeRouteLeave</strong> of the previous view component). It should be defined as a global method of the <strong class="source-inline">router</strong> instance during initialization in the <strong class="source-inline">index.js</strong> file and takes the following syntax:</p>
			<p class="source-code">const router = new VueRouter({</p>
			<p class="source-code">  //...</p>
			<p class="source-code">})</p>
			<p class="source-code">router.beforeEach(beforeEachCallback)</p>
			<p>In the preceding snippet, <strong class="source-inline">beforeEachCallback</strong> is a <strong class="source-inline">hook</strong> function that receives three arguments:</p>
			<p class="source-code">const beforeEachCallback = (</p>
			<p class="source-code">  to, // The destination route</p>
			<p class="source-code">  from, //The source route</p>
			<p class="source-code">  next //The function to trigger to resolve the hook</p>
			<p class="source-code">) =&gt; { … })</p>
			<p>Or we could write this directly as follows:</p>
			<p class="source-code">router.beforeEach((to, from, next) =&gt; { … })</p>
			<p>For example, if we want to display a different page to display a generic message whenever a user navigates to <strong class="source-inline">About</strong> without a param value for the user, we can hook <strong class="source-inline">beforeEach</strong> as follows:</p>
			<p class="source-code">router.beforeEach((</p>
			<p class="source-code">  to, // The destination route</p>
			<p class="source-code">  from, //The source route</p>
			<p class="source-code">  next //The function to trigger to resolve the hook</p>
			<p class="source-code">) =&gt; {</p>
			<p class="source-code">  if (to.name === 'about' &amp;&amp; (!to.params || !to.params.user)) {</p>
			<p class="source-code">    next({ name: 'error' })</p>
			<p class="source-code">  }</p>
			<p class="source-code">  else {</p>
			<p class="source-code">    next();</p>
			<p class="source-code">  }</p>
			<p class="source-code">})</p>
			<p>Here, we check if the destination route is <strong class="source-inline">about</strong> and if it doesn't have any additional params passed, nor any value for the <strong class="source-inline">user</strong> param passed, we will navigate to an <strong class="source-inline">error</strong> route instead. Otherwise, just proceed as normal with <strong class="source-inline">next()</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout"><strong class="source-inline">next()</strong> is required to be called <strong class="bold">exactly once in any given non-overlapped flow logic</strong> (once for <strong class="source-inline">if</strong> and once for <strong class="source-inline">else</strong>), or else there will be errors.</p>
			<p>We still need to create an <strong class="source-inline">error</strong> page with an <strong class="source-inline">Error.vue</strong> view component that displays a simple message:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">    &lt;div&gt;</p>
			<p class="source-code">        &lt;h2&gt;No param passed.&lt;/h2&gt;</p>
			<p class="source-code">    &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p>Also, make sure to register the path accordingly:</p>
			<p class="source-code">{</p>
			<p class="source-code">    path: '/error',</p>
			<p class="source-code">    name: 'error',</p>
			<p class="source-code">    component: () =&gt; import(/* webpackChunkName: "error" */       '../views/Error.vue'),</p>
			<p class="source-code">  }</p>
			<p>Now, in the <strong class="source-inline">Home</strong> view, after clicking on the <strong class="source-inline">About</strong> link, the app will render the <strong class="source-inline">Error</strong> page instead of the <strong class="source-inline">About</strong> page as seen in the following screenshot:</p>
			<div>
				<div id="_idContainer215" class="IMG---Figure">
					<img src="image/B15218_06_24.jpg" alt="Figure 6.24: Error page displayed when About is clicked without any param passed&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.24: Error page displayed when About is clicked without any param passed</p>
			<p>Now let's go to the <strong class="source-inline">App.vue</strong> file and assign the <strong class="source-inline">to</strong> prop to bind to an <strong class="source-inline">{ name: 'about', params: { user: 'Adam' }}</strong> object instead:</p>
			<p class="source-code">      &lt;router-link :to="{ name: 'about', params: { user: 'Adam'         }}"&gt;About&lt;/router-link&gt;</p>
			<p>Let's navigate back to our app's <strong class="source-inline">Home</strong> page and click on the <strong class="source-inline">About</strong> link. Since we have a proper <strong class="source-inline">params</strong> passed, the output will be as follows:</p>
			<div>
				<div id="_idContainer216" class="IMG---Figure">
					<img src="image/B15218_06_25.jpg" alt="Figure 6.25: About page displayed when there is a user passed in the params&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.25: About page displayed when there is a user passed in the params</p>
			<p>Moreover, from now on, every time we refresh the <strong class="source-inline">About</strong> page, we will get redirected to the <strong class="source-inline">Error</strong> page instead since there is no <strong class="source-inline">user</strong> param passed on refreshing.</p>
			<p>We shall now look at a few key distinguishing points between the <strong class="source-inline">beforeEach</strong> and <strong class="source-inline">beforeResolve</strong> Hooks.</p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor207"/>Differentiating Between the beforeEach and beforeResolve Hooks</h2>
			<p>We can also register the global Hook with <strong class="source-inline">beforeResolve</strong> with the same syntax. However, unlike <strong class="source-inline">beforeEach</strong>, which is triggered at the creation phase of navigation, <strong class="source-inline">beforeResolve</strong> will be triggered just before the navigation is carried out and confirmed, <strong class="bold">after all the Hooks (both global and in-component) are resolved</strong>:</p>
			<p class="source-code">router.beforeResolve((</p>
			<p class="source-code">  to, // The destination route</p>
			<p class="source-code">  from, //The source route</p>
			<p class="source-code">  next //The function to trigger to resolve the hook</p>
			<p class="source-code">) =&gt; {</p>
			<p class="source-code">  if (to.name === 'about' &amp;&amp; (!to.params || !to.params.user)) {</p>
			<p class="source-code">    next({ name: 'error' })</p>
			<p class="source-code">  }</p>
			<p class="source-code">  else {</p>
			<p class="source-code">    next();</p>
			<p class="source-code">  }</p>
			<p class="source-code">})</p>
			<p>The output results will remain the same as in <em class="italic">Figure 6.25</em>:</p>
			<div>
				<div id="_idContainer217" class="IMG---Figure">
					<img src="image/B15218_06_26.jpg" alt="Figure 6.26: About page displayed when there is a user passed in the params&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.26: About page displayed when there is a user passed in the params</p>
			<p>Let's now look at the <strong class="source-inline">afterEach</strong> Hook in detail.</p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor208"/>The afterEach Hook</h2>
			<p>The <strong class="source-inline">afterEach()</strong> Hook is the last global navigation guard to be triggered after the navigation is confirmed (which means after <strong class="source-inline">beforeResolve()</strong>). Unlike the other global guards, the Hook function to pass to <strong class="source-inline">afterEach()</strong> does not receive a <strong class="source-inline">next</strong> function, hence it won't affect the navigation.</p>
			<p>In addition, the <strong class="source-inline">to</strong> and <strong class="source-inline">from</strong> parameters are read-only <strong class="source-inline">Route</strong> objects. Hence the best use case for <strong class="source-inline">afterEach</strong> is to save data such as the last visited <strong class="source-inline">Route</strong> object for a <strong class="source-inline">Back</strong> button, the passed <strong class="source-inline">params</strong> of the <strong class="source-inline">route</strong> destination, or page view tracking. For example, we can have a default value of <strong class="source-inline">user</strong>, assign it, and save it whenever needed:</p>
			<p class="source-code">let user = 'Adam';</p>
			<p class="source-code">router.beforeEach((to, from, next) =&gt; {</p>
			<p class="source-code">  if (to.name === 'about' &amp;&amp; (!to.params || !to.params.user)) {</p>
			<p class="source-code">    next({ name: 'about', params: { user }})</p>
			<p class="source-code">  }</p>
			<p class="source-code">  else {</p>
			<p class="source-code">    user = to.params.user;</p>
			<p class="source-code">    next()</p>
			<p class="source-code">  }</p>
			<p class="source-code">});</p>
			<p class="source-code">router.afterEach((to, from) =&gt; {</p>
			<p class="source-code">  if (to.name === 'about' &amp;&amp; to.params &amp;&amp; to.params.user) {</p>
			<p class="source-code">    user = to.params.user;</p>
			<p class="source-code">  }</p>
			<p class="source-code">})</p>
			<p>Now in the <strong class="source-inline">App.js</strong> file, instead of <strong class="source-inline">Adam</strong>, add the following:</p>
			<p class="source-code">&lt;router-link </p>
			<p class="source-code">  :to="{ name: 'about', params: { user: 'Adam' }}"</p>
			<p class="source-code">&gt;</p>
			<p class="source-code">  About</p>
			<p class="source-code">&lt;/router-link&gt;</p>
			<p>Let's change it to <strong class="source-inline">Alex</strong>:</p>
			<p class="source-code">&lt;router-link </p>
			<p class="source-code">  :to="{ name: 'about', params: { user: 'Alex' }}"</p>
			<p class="source-code">&gt;</p>
			<p class="source-code">  About</p>
			<p class="source-code">&lt;/router-link&gt;</p>
			<p>The output now when clicking on the <strong class="source-inline">About</strong> link is as follows:</p>
			<div>
				<div id="_idContainer218" class="IMG---Figure">
					<img src="image/B15218_06_27.jpg" alt="Figure 6.27: About page displaying the new user's name – Alex&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.27: About page displaying the new user's name – Alex</p>
			<p>But on reload, the <strong class="source-inline">About</strong> page renders with the default user – <strong class="source-inline">Adam</strong> – instead since there is a user passed to the <strong class="source-inline">params</strong>, as follows:</p>
			<div>
				<div id="_idContainer219" class="IMG---Figure">
					<img src="image/B15218_06_28.jpg" alt="Figure 6.28: About page displaying the default user value on reload – Adam&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.28: About page displaying the default user value on reload – Adam</p>
			<p>In this section, we looked at the <strong class="source-inline">afterEach</strong> Hook. We used the <strong class="source-inline">afterEach</strong> Hook to pass data through to the <strong class="source-inline">about</strong> page without having to have that data contained in the URL. This same technique can be used for updating other behavior such as the desired target page when pressing the <strong class="source-inline">back</strong> button.</p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor209"/>Personalizing Hooks per Route</h2>
			<p>Instead of defining a global Hook, which can cause unseen bugs and requires a route check, we can define a <strong class="source-inline">beforeEnter</strong> guard directly in the targeted route's configuration object, for example, our <strong class="source-inline">About</strong> route:</p>
			<p class="source-code">beforeEnter: (to, from, next) =&gt; {</p>
			<p class="source-code">      if (!to.params || !to.params.user) {</p>
			<p class="source-code">        to.params.user = 'Adam'</p>
			<p class="source-code">      }</p>
			<p class="source-code">      next()</p>
			<p class="source-code">    }</p>
			<p>With this approach, both on reload and on clicking a link to navigate to the <strong class="source-inline">About</strong> page, the output is now consistent, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer220" class="IMG---Figure">
					<img src="image/B15218_06_29.jpg" alt="Figure 6.29: About page rendered with the user value Adam&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.29: About page rendered with the user value Adam</p>
			<p class="callout-heading">Note</p>
			<p class="callout">With <strong class="source-inline">beforeEnter()</strong>, <strong class="source-inline">to</strong> is write-able and you will have access to <strong class="source-inline">this</strong> (which points to the specific route – <strong class="source-inline">About</strong>). It will only be triggered when users trigger navigation to the <strong class="source-inline">About</strong> page.</p>
			<p>In this section, we looked at the different router Hooks available in Vue, including <strong class="source-inline">beforeEach</strong>, <strong class="source-inline">beforeResolve</strong>, and <strong class="source-inline">afterEach</strong>. We saw how each of these Hooks is called at a different point in the routing process. As a practical example, we looked at a route that, if not provided a parameter, instead directs the user to an error page. These Hooks can be very useful especially when setting up an authenticated route. In the next section, we'll look at setting up in-component Hooks.</p>
			<h1 id="_idParaDest-153">Setting up in-Component Hook<a id="_idTextAnchor210"/>s</h1>
			<p>Finally, we can also use in-component Hooks as component life cycle Hooks where we want to scope those Hooks to component-level for better code maintenance or enhance the workflow where the same component needs to behave differently in a certain use case. </p>
			<p>We can have the <strong class="source-inline">About</strong> component now with the <strong class="source-inline">beforeRouteEnter()</strong> Hook defined as follows:</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  data() {</p>
			<p class="source-code">    return {</p>
			<p class="source-code">      user: ''</p>
			<p class="source-code">    }</p>
			<p class="source-code">  },</p>
			<p class="source-code">  beforeRouteEnter(to, from, next) {</p>
			<p class="source-code">    if (!to.params || !to.params.user) {</p>
			<p class="source-code">      next(comp =&gt; {</p>
			<p class="source-code">        comp.user = 'Alex'</p>
			<p class="source-code">      })</p>
			<p class="source-code">    }</p>
			<p class="source-code">    else {</p>
			<p class="source-code">      next();</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>As you can see, we don't have access to the <strong class="source-inline">this</strong> scope of the component during <strong class="source-inline">beforeRouteEnter</strong>, because the view component is still being created at the moment of triggering. Luckily, we can access the instance through a callback passed to <strong class="source-inline">next()</strong>. Whenever the navigation is confirmed, which means the component is created, the callback will be triggered, and the component instance will be available as the sole argument (<strong class="source-inline">comp</strong>) of the callback.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">For <strong class="source-inline">beforeRouteUpdate</strong> and <strong class="source-inline">beforeRouteLeave</strong>, the component has been created, hence this instance is available and there won't be a need for a callback for <strong class="source-inline">next()</strong>. In fact, a callback function is only supported in <strong class="source-inline">next()</strong> within the use of <strong class="source-inline">beforeRouteEnter()</strong>.</p>
			<p><strong class="source-inline">beforeRouteUpdate</strong> is called when the same component is reused for a different route. This applies when we use dynamic routing, which will be discussed in the next section.</p>
			<p><strong class="source-inline">beforeRouteLeave</strong> is triggered when the component is going to be deactivated or before the user navigates away from the current view. This is called right before the <strong class="source-inline">beforeEach</strong> guard of the new navigation and is usually used in editor components to prevent users from navigating away without saving. </p>
			<p>In this guard, we can cancel the new navigation by passing <strong class="source-inline">false</strong> to the <strong class="source-inline">next()</strong> function.</p>
			<p>For example, imagine that we add the following Hook to the component's option in the <strong class="source-inline">About.vue</strong> file:</p>
			<p class="source-code">//...</p>
			<p class="source-code">  beforeRouteLeave(to, from, next) {</p>
			<p class="source-code">    const ans = window.confirm('You are about to leave the About       page. Are you sure?');</p>
			<p class="source-code">    next(!!ans);</p>
			<p class="source-code">  }</p>
			<p>When we navigate away from the <strong class="source-inline">About</strong> page, a pop-up dialog will appear asking for confirmation as shown in the following screenshot and then continue navigating accordingly:</p>
			<div>
				<div id="_idContainer221" class="IMG---Figure">
					<img src="image/B15218_06_30.jpg" alt="Figure 6.30: Dialog asking to confirm before navigating away from the About page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.30: Dialog asking to confirm before navigating away from the About page</p>
			<p>In this section, we looked at setting up in-component Hooks, that is, Hooks that are scoped to specific components. We set up an in-component Hook for our <strong class="source-inline">About</strong> component that asks a user to confirm before leaving the page. In the next section, we will move our message list into an external file to be loaded only when <strong class="source-inline">MessageFeed</strong> is in view.</p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor211"/>Exercise 6.04: Extracting a Messages List to an External File and Loading It Only When MessageFeed Is in View </h2>
			<p>Going back to <em class="italic">Exercise 6.03</em>, <em class="italic">Passing the Content of the Selected Message to a New Message Page and Having It Printed Out</em>, now we will do a bit of code enhancement using the <strong class="source-inline">beforeEnter</strong> and <strong class="source-inline">beforeRouteEnter</strong> router hooks. This exercise is meant to make you more familiar with using router hooks.</p>
			<p>To access the code files for this exercise, refer to <a href="https://packt.live/3lg1F2R">https://packt.live/3lg1F2R</a>.</p>
			<ol>
				<li value="1">Let's extract the <strong class="source-inline">messages</strong> static data from <strong class="source-inline">./src/views/MessageFeed.vue</strong> and save it in <strong class="source-inline">./src/assets/messages.js</strong>:<p class="source-code">const messages = [</p><p class="source-code">  'Hello, how are you?',</p><p class="source-code">  'The weather is nice',</p><p class="source-code">  'This is message feed',</p><p class="source-code">  'And I am the fourth message'</p><p class="source-code">];</p><p class="source-code">export default messages;</p></li>
				<li>In <strong class="source-inline">./src/views/MessageFeed.vue</strong>, we will replace the local data property with <strong class="source-inline">props: { messages: { type: String, default: [] }}</strong>:<p class="source-code">export default {</p><p class="source-code">  props: {</p><p class="source-code">    messages: {</p><p class="source-code">      type: Array,</p><p class="source-code">      default: () =&gt; []</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>Now we need to load the list of <strong class="source-inline">messages</strong> and assign it to the <strong class="source-inline">messages</strong> <strong class="source-inline">params</strong> upon navigation to the <strong class="source-inline">messages</strong> route. We will do this by using the <strong class="source-inline">beforeEnter</strong> Hook in the route's configuration object. Don't forget to add <strong class="source-inline">props: true</strong> to normalize the <strong class="source-inline">params</strong> into related <strong class="source-inline">props</strong> for rendering. You can do that by modifying your <strong class="source-inline">route</strong> defined in <strong class="source-inline">src/router/index.js</strong> as follows:<p class="source-code">{</p><p class="source-code">    path: '/messages',</p><p class="source-code">    name: 'messageFeed',</p><p class="source-code">    component: () =&gt; import(/* webpackChunkName: "messages" */       '../views/MessageFeed.vue'),</p><p class="source-code">    props: true,</p><p class="source-code">    async beforeEnter(to, from, next) {</p><p class="source-code">      next()</p><p class="source-code">    }</p><p class="source-code">  },</p></li>
				<li>We will lazy-load the list of messages with <strong class="source-inline">import</strong>:<p class="source-code">const module = await import (/* webpackChunkName: "messagesFeed"   */ '../assets/messages.js');</p></li>
				<li>Then, retrieve the needed information as follows:<p class="source-code">  const messages = module.default;</p><p class="source-code">  if (messages &amp;&amp; messages.length &gt; 0) {</p><p class="source-code">    to.params.messages = messages;</p><p class="source-code">  }</p></li>
				<li>The full code for the route in <strong class="source-inline">src/router/index.js</strong> should be the following:<p class="source-code">{</p><p class="source-code">    path: '/messages',</p><p class="source-code">    name: 'messageFeed',</p><p class="source-code">    component: () =&gt; import(/* webpackChunkName: "messages" */       '../views/MessageFeed.vue'),</p><p class="source-code">    props: true,</p><p class="source-code">    async beforeEnter(to, from, next) {</p><p class="source-code">      if (!to.params || !to.params.messages) {</p><p class="source-code">        const module = await import (/* webpackChunkName:           "messagesFeed" */ '../assets/messages.js');</p><p class="source-code">      const messages = module.default;</p><p class="source-code">        if (messages &amp;&amp; messages.length &gt; 0) {</p><p class="source-code">          to.params.messages = messages;</p><p class="source-code">        }</p><p class="source-code">      }</p><p class="source-code">      next()</p><p class="source-code">    }</p><p class="source-code">  },</p><p>When viewing the website, we should see a message feed similar to that of the last exercise. This is shown in the following screenshot:</p><div id="_idContainer222" class="IMG---Figure"><img src="image/B15218_06_31.jpg" alt="Figure 6.31: Message Feed page after refactoring&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 6.31: Message Feed page after refactoring</p>
			<p>At this point, we have learned and practiced how to configure routers, pass parameters, and intercept navigation between pages in the application using different routing Hooks. In the next section, we are going to look at a more advanced topic – <strong class="bold">dynamic routing</strong>.</p>
			<h1 id="_idParaDest-155"><a id="_idTextAnchor212"/>Dynamic Routing</h1>
			<p>If there is a l<a id="_idTextAnchor213"/>ot of data that <a id="_idTextAnchor214"/>follows the same format, such as a list of users, or a list of messages, and it's required to create a page for each of them, we need to use a routing pattern. With a routing pattern, we can create a new route dynamically from the same component based on some additional information. For example, we want to render the <strong class="source-inline">User</strong> view component for every user but with different <strong class="source-inline">id</strong> values. Vue Router provides us with the ability to use dynamic segments denoted by a colon (<strong class="source-inline">:</strong>) to achieve dynamic routing.</p>
			<p>Instead of using <strong class="source-inline">params</strong>, which doesn't persist its value on refresh or appear in the URL, we define the required <strong class="source-inline">params</strong> directly in the path as follows:</p>
			<p class="source-code">{</p>
			<p class="source-code">    path: '/user/:id',</p>
			<p class="source-code">    name: 'user',</p>
			<p class="source-code">    component: () =&gt; import(/* webpackChunkName: "user" */       '../views/User.vue')</p>
			<p class="source-code">  }</p>
			<p>In the preceding code, <strong class="source-inline">:id</strong> means the <strong class="source-inline">params</strong> here are not static. When the route matches the given pattern, Vue Router will render the corresponding component with the appropriate content, while keeping the URL as it should be. And the value of <strong class="source-inline">:id</strong> will be exposed as this <strong class="source-inline">$route.params.id</strong> in that view component's instance:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div&gt;</p>
			<p class="source-code">    &lt;h1&gt;About a user: {{$route.params.id}}&lt;/h1&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p>When users select URLs such as <strong class="source-inline">/user/1</strong> and <strong class="source-inline">/user/2</strong> (<strong class="source-inline">./src/App.vue</strong>), Vue will automatically generate sub-pages using our template.</p>
			<p>Navigation paths will be mapped to the same route pattern and component, but with different information, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer223" class="IMG---Figure">
					<img src="image/B15218_06_32.jpg" alt="Figure 6.32: Navigate to /user/2&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.32: Navigate to /user/2</p>
			<p>When you click on <strong class="source-inline">User 1</strong>, you will see the following:</p>
			<div>
				<div id="_idContainer224" class="IMG---Figure">
					<img src="image/B15218_06_33.jpg" alt="Figure 6.33: Navigate to /user/1&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.33: Navigate to /user/1</p>
			<p>We can also normalize <strong class="source-inline">id</strong> to the <strong class="source-inline">props</strong> of the <strong class="source-inline">User</strong> component with <strong class="source-inline">props: true</strong> and combine it with <strong class="source-inline">beforeRouteEnter()</strong> to load data of the selected user before the instance is created and rendered:</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">import users from '../assets/users.js';</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  props: {</p>
			<p class="source-code">    id: Number</p>
			<p class="source-code">  },</p>
			<p class="source-code">  data() {</p>
			<p class="source-code">    return {</p>
			<p class="source-code">      name: '',</p>
			<p class="source-code">      age: 0</p>
			<p class="source-code">    }</p>
			<p class="source-code">  },</p>
			<p class="source-code">  beforeRouteEnter(to, from, next) {</p>
			<p class="source-code">    next(vm =&gt; {</p>
			<p class="source-code">      const user = users[vm.id];</p>
			<p class="source-code">      vm.name = user.name;</p>
			<p class="source-code">      vm.age = user.age;</p>
			<p class="source-code">    })</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>Now we can adjust <strong class="source-inline">&lt;template&gt;</strong> to print out the details of the user:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div&gt;</p>
			<p class="source-code">    &lt;h1&gt;About a user: {{$route.params.id}}&lt;/h1&gt;</p>
			<p class="source-code">    &lt;h2&gt;Name: {{name}}&lt;/h2&gt;</p>
			<p class="source-code">    &lt;p&gt;Age: {{age}}&lt;/p&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p>The output when selecting <strong class="source-inline">/user/1</strong> will now be as follows:</p>
			<div>
				<div id="_idContainer225" class="IMG---Figure">
					<img src="image/B15218_06_34.jpg" alt="Figure 6.34: Navigate to /user/1 with updated UI&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.34: Navigate to /user/1 with updated UI</p>
			<p>And if we are in the <strong class="source-inline">user/:id</strong> route and change the <strong class="source-inline">:id</strong> to another user, we need to update the local data accordingly since <strong class="source-inline">beforeRouteEnter</strong> will not be triggered again in this case. In fact, all the lifecycle Hooks of the components will not be called, as the component instance is not re-created:</p>
			<p class="source-code">beforeRouteUpdate(to, from, next) {</p>
			<p class="source-code">    const user = users[to.params.id - 1];</p>
			<p class="source-code">    this.name = user.name;</p>
			<p class="source-code">    this.age = user.age;</p>
			<p class="source-code">    next();</p>
			<p class="source-code">  }</p>
			<p>In this section, we looked at dyna<a id="_idTextAnchor215"/>mic routing by setting up a route that extracts a parameter from the given URL. This technique allows you to create user-friendly URLs and pass information to routes dynamically. In the next section, we will look at catching error paths.</p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor216"/>Catching Error Paths</h2>
			<p>Other important routes that we always need to remember to handle besides the <strong class="source-inline">Home</strong> page ('<strong class="source-inline">/</strong>') include <strong class="source-inline">error</strong> routes, such as <strong class="source-inline">404 Not found</strong> when the URL path doesn't match any registered path, among others.</p>
			<p>For <strong class="source-inline">404 Not found</strong>, we can use the <strong class="source-inline">regex</strong> asterisk <strong class="source-inline">*</strong>, which stands for <em class="italic">matching everything</em> to collect all the cases that don't match the routes. This router's configuration should be located at the end of the array routes to avoid matching the wrong path:</p>
			<p class="source-code">{</p>
			<p class="source-code">    path: '*',</p>
			<p class="source-code">    name: '404',</p>
			<p class="source-code">    component: () =&gt; import(/* webpackChunkName: "404" */       '../views/404.vue'),</p>
			<p class="source-code">  }</p>
			<p>When we type a wrong path for <strong class="source-inline">/users</strong>, the output will be as follows: </p>
			<div>
				<div id="_idContainer226" class="IMG---Figure">
					<img src="image/B15218_06_35.jpg" alt="Figure 6.35: Redirect to 404 when the '/users' path is not found&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.35: Redirect to 404 when the '/users' path is not found</p>
			<p>In this section, we looked at how the <strong class="source-inline">*</strong> regex wildcard can be used to create a catch-all <strong class="source-inline">404</strong> page displayed to anyone that navigates to a non-existent route. Next, we will be implementing a message route that passes relevant data in the URL itself using a dynamic routing pattern.</p>
			<h2 id="_idParaDest-157">Exercise 6.05: Implementing a Messa<a id="_idTextAnchor217"/>ge Route for Each Message with a Dynamic Routing Pattern </h2>
			<p>Going back to our message feed in <em class="italic">Exercise 6.04</em>, <em class="italic">Extracting a Messages List to an External File and Loading Only When MessageFeed Is in View</em>, we will refactor our <strong class="source-inline">Message</strong> path to use routing patterns to dynamically navigate to a specific message path upon the user's selection. This will get you familiar with creating and maintaining dynamic routes in combination with other navigation Hooks.</p>
			<p>To access the code files for this exercise, refer to <a href="https://packt.live/32sWogX">https://packt.live/32sWogX</a>.</p>
			<ol>
				<li value="1">Let's open <strong class="source-inline">./src/router/index.js</strong> and have the path configuration of the message route change to <strong class="source-inline">/message/:id</strong>, where <strong class="source-inline">id</strong> will be the index of that <strong class="source-inline">message</strong> in the list of messages:<p class="source-code">{</p><p class="source-code">    path: '/message/:id',</p><p class="source-code">    name: 'message',</p><p class="source-code">    component: () =&gt; import(/* webpackChunkName: "message" */       '../views/Message.vue'),</p><p class="source-code">    props: true,</p><p class="source-code">}</p></li>
				<li>Now navigate to <strong class="source-inline">./src/views/MessageFeed.vue</strong> and change the <strong class="source-inline">to</strong> prop of <strong class="source-inline">router-link</strong> for each message to the following:<p class="source-code">&lt;router-link :to="`/message/${i}`"&gt;</p></li>
				<li>Let's go back to <strong class="source-inline">./src/router/index.js</strong> and define <strong class="source-inline">beforeEnter</strong> as an asynchronous Hook for lazy-loading the content of the message into the content prop of our <strong class="source-inline">Message</strong> component:<p class="source-code">async beforeEnter(to, from, next) {</p><p class="source-code">      if (to.params &amp;&amp; to.params.id) {</p><p class="source-code">        const id = to.params.id;</p><p class="source-code">        const { module } = await import (/* webpackChunkName:           "messagesFeed" */ '../assets/messages.js');</p><p class="source-code">        const messages = module.default;</p><p class="source-code">        if (messages &amp;&amp; messages.length &gt; 0 &amp;&amp; id &lt;           messages.length) {</p><p class="source-code">          to.params.content = messages[id];</p><p class="source-code">        }</p><p class="source-code">      }</p><p class="source-code">      next()</p><p class="source-code">    },</p></li>
				<li>Run the application using the following command:<p class="source-code">yarn serve</p><p>When clicking on the first message in the <strong class="source-inline">Message Feed</strong>, the next page will be as follows:</p><div id="_idContainer227" class="IMG---Figure"><img src="image/B15218_06_36.jpg" alt="Figure 6.36: The page displayed when visiting the /message/0 path&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 6.36: The page displayed when visiting the /message/0 path</p>
			<p>Now that you have learned how to use dynamic routing, you can play around even further with more layers of routing patterns, such as <strong class="source-inline">message/:id/author/:aid</strong>. However, for such a case, we normally use a better approach, <strong class="bold">nested routes</strong>.</p>
			<h1 id="_idParaDest-158"><a id="_idTextAnchor218"/>Nested Routes</h1>
			<p>In reality, many appli<a id="_idTextAnchor219"/>cations are composed of components that consist of several multiple-level nested components. For example, <strong class="source-inline">/user/settings/general</strong> indicates that a general view is nested in the <strong class="source-inline">settings</strong> view and this <strong class="source-inline">settings</strong> view is nested within the <strong class="source-inline">user</strong> view. It represents the <strong class="source-inline">General information</strong> section of a user's settings page.</p>
			<p>Most of the time, we want the URL to correspond to such a structure, as demonstrated in the following screenshot:</p>
			<div>
				<div id="_idContainer228" class="IMG---Figure">
					<img src="image/B15218_06_37.jpg" alt="Figure 6.37: User with two nested views – Info and Extra&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.37: User with two nested views – Info and Extra</p>
			<p>Vue Router makes it easy to achieve this structure using <strong class="source-inline">nested</strong> route configurations and the <strong class="source-inline">router-view</strong> component.</p>
			<p>Let's go back to the <strong class="source-inline">User.vue</strong> view in our previous example (located in <strong class="source-inline">./src/views/</strong>) and add a nested <strong class="source-inline">router-view</strong> component in the <strong class="source-inline">&lt;template&gt;</strong> section:</p>
			<p class="source-code">&lt;div&gt;</p>
			<p class="source-code">  &lt;h1&gt;About a user: {{$route.params.id}}&lt;/h1&gt;</p>
			<p class="source-code">  &lt;router-link :to="{ name: 'userinfo', params: { id: id }}"&gt;Info     &lt;/router-link&gt; |</p>
			<p class="source-code">  &lt;router-link :to="/user/${id}/extra"&gt;Extra&lt;/router-link&gt;</p>
			<p class="source-code">  &lt;router-view/&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p>In order to start rendering components to this <strong class="source-inline">router-view</strong>, we will configure the <strong class="source-inline">user</strong> route to have the children option, which accepts an array of route configurations for the child routes. For our example, we'll be adding an <strong class="source-inline">info</strong> and <strong class="source-inline">extra</strong> page for each user. These child routes will be accessed as <strong class="source-inline">/user/:id/info</strong> and <strong class="source-inline">/user/:id/extra</strong> giving each user a unique <strong class="source-inline">info</strong> and <strong class="source-inline">extra</strong> page:</p>
			<p class="source-code">{</p>
			<p class="source-code">    path: '/user/:id',</p>
			<p class="source-code">    name: 'user',</p>
			<p class="source-code">    component: () =&gt; import(/* webpackChunkName: "user" */       '../views/User.vue'),</p>
			<p class="source-code">    props: true,</p>
			<p class="source-code">    children: [{</p>
			<p class="source-code">      path: 'info',</p>
			<p class="source-code">      name: 'userinfo',</p>
			<p class="source-code">      component: () =&gt; import(/* webpackChunkName: "info" */         '../views/UserInfo.vue')</p>
			<p class="source-code">    }, {</p>
			<p class="source-code">      path: 'extra',</p>
			<p class="source-code">      component: () =&gt; import(/* webpackChunkName: "extra" */         '../views/UserExtra.vue')</p>
			<p class="source-code">    }]</p>
			<p class="source-code">  }</p>
			<p>Not all the nested paths need to start with <strong class="source-inline">/</strong> as their parent path, which will avoid them being treated as a root path and make things easier for Vue Router to compute the matching route.</p>
			<p>Of course, we will have to create two new views in the folder that will render all the information about a user based on the <strong class="source-inline">id</strong> received:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div&gt;</p>
			<p class="source-code">    &lt;h2&gt;Name: {{name}}&lt;/h2&gt;</p>
			<p class="source-code">    &lt;p&gt;Age: {{age}}&lt;/p&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">import users from '../assets/users.js';</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  data() {</p>
			<p class="source-code">    return {</p>
			<p class="source-code">      name: '',</p>
			<p class="source-code">      age: 0</p>
			<p class="source-code">    }</p>
			<p class="source-code">  },</p>
			<p class="source-code">  beforeRouteEnter(to, from, next) {</p>
			<p class="source-code">    next(vm =&gt; {</p>
			<p class="source-code">      const user = users[to.params.id - 1];</p>
			<p class="source-code">      vm.name = user.name;</p>
			<p class="source-code">      vm.age = user.age;</p>
			<p class="source-code">    })</p>
			<p class="source-code">  },</p>
			<p class="source-code">  beforeRouteUpdate(to, from, next) {</p>
			<p class="source-code">    const user = users[to.params.id - 1];</p>
			<p class="source-code">    this.name = user.name;</p>
			<p class="source-code">    this.age = user.age;</p>
			<p class="source-code">    next();</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>We also create <strong class="source-inline">UserExtra.vue</strong>, which will render extra information (if there is any). In this example, it will render only simple text:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div&gt;</p>
			<p class="source-code">    &lt;h2&gt;I'm an extra section&lt;/h2&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p>The nested views are ready! Whenever the user clicks on the <strong class="source-inline">Info</strong> link, it will load the <strong class="source-inline">UserInfo</strong> view into it and update the URL as follows:</p>
			<div>
				<div id="_idContainer229" class="IMG---Figure">
					<img src="image/B15218_06_38.jpg" alt="Figure 6.38: User page with nested UserInfo view&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.38: User page with nested UserInfo view</p>
			<p>When the user clicks on <strong class="source-inline">Extra</strong>, they will see the same as is shown in the following screenshot:</p>
			<div>
				<div id="_idContainer230" class="IMG---Figure">
					<img src="image/B15218_06_39.jpg" alt="Figure 6.39: User page with nested UserExtra view&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.39: User page with nested UserExtra view</p>
			<p>In this section we looked at nested routes, that is, routes that have multiple children. In our example, the child routes were user info and user extra. This pattern allows us to create pages that extend their parent pages. In the preceding example, we can now make edits to the <strong class="source-inline">About a user</strong> header and have it take effect on all child routes. As projects grow, making use of this pattern will allow you to avoid having duplicate code across multiple views.</p>
			<p>In the next section, we will use what we've learned so far to create navigation tabs for our message view component.</p>
			<h2 id="_idParaDest-159">Exercise 6.06: Building Navigation Tab<a id="_idTextAnchor220"/>s within the Message View </h2>
			<p>We will adapt the knowledge learned from the <em class="italic">Nested Routes</em> section to build a <strong class="bold">Navigation</strong> tab section within the <strong class="source-inline">Message</strong> view from <em class="italic">Exercise 6.05</em>, <em class="italic">Implementing a Message Route for Each Message with a Dynamic Routing Pattern</em>.</p>
			<p>To access the code files for this exercise, refer to <a href="https://packt.live/2U9Bn6I">https://packt.live/2U9Bn6I</a>.</p>
			<ol>
				<li value="1">Firstly, let's make some changes to our <strong class="source-inline">messages</strong> database in <strong class="source-inline">src/assets/messages.js</strong> by adding the following <strong class="source-inline">author</strong> and <strong class="source-inline">sent</strong> fields:<p class="source-code">const messages = [</p><p class="source-code">  {</p><p class="source-code">    content: 'Hello, how are you?',</p><p class="source-code">    author: 'John',</p><p class="source-code">    sent: '12 May 2019'</p><p class="source-code">  }, {</p><p class="source-code">    content: 'The weather is nice',</p><p class="source-code">    author: 'Lily',</p><p class="source-code">    sent: '12 Jun 2019'</p><p class="source-code">  },</p><p class="source-code">  {</p><p class="source-code">    content: 'This is message feed',</p><p class="source-code">    author: 'Smith',</p><p class="source-code">    sent: '10 Jan 2020'</p><p class="source-code">  },</p><p class="source-code">  {</p><p class="source-code">    content: 'And I am the fourth message',</p><p class="source-code">    author: 'Chuck',</p><p class="source-code">    sent: '1 Apr 2021'</p><p class="source-code">  },</p><p class="source-code">];</p></li>
				<li>Next, we will create a <strong class="source-inline">MessageAuthor.vue</strong> view that renders only the name of the creator of the message:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div&gt;</p><p class="source-code">    &lt;h3&gt;Author:&lt;/h3&gt;</p><p class="source-code">    &lt;p&gt;{{message.author}}&lt;/p&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  props: {</p><p class="source-code">    message: {</p><p class="source-code">      type: Object,</p><p class="source-code">      default: () =&gt; {}</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>Then we will create a <strong class="source-inline">MessageInfo.vue</strong> view that renders the <strong class="source-inline">message.sent</strong> value:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div&gt;</p><p class="source-code">    &lt;h3&gt;Message info: &lt;/h3&gt;</p><p class="source-code">    &lt;p&gt;{{message.sent}}&lt;/p&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  props: {</p><p class="source-code">    message: {</p><p class="source-code">      type: Object,</p><p class="source-code">      default: () =&gt; {}</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p></li>
				<li>Once we are done with the components, we need to register the new nested route under the children of the <strong class="source-inline">message</strong> route, inside our router at <strong class="source-inline">src/router/index.js</strong>:<p class="source-code">{</p><p class="source-code">      path: '/message/:id',</p><p class="source-code">      name: 'message',</p><p class="source-code">    component: () =&gt; import(/* webpackChunkName: "message" */       '../views/Message.vue'),</p><p class="source-code">    async beforeEnter(to, from, next) { ... },</p><p class="source-code">    props: true,</p><p class="source-code">    children: [{</p><p class="source-code">      path: 'author',</p><p class="source-code">      name: 'messageAuthor',</p><p class="source-code">      props: true,</p><p class="source-code">      component: () =&gt; import(/* webpackChunkName:         "messageAuthor" */ '../views/MessageAuthor.vue'),</p><p class="source-code">    }, {</p><p class="source-code">      path: 'info',</p><p class="source-code">      props: true,</p><p class="source-code">      name: 'messageInfo',</p><p class="source-code">      component: () =&gt; import(/* webpackChunkName: "messageInfo"         */ '../views/MessageInfo.vue'),</p><p class="source-code">    }]</p><p class="source-code">  }</p></li>
				<li>Finally, in <strong class="source-inline">Message.vue</strong>, we will refactor the code to the following:<p class="source-code">&lt;template&gt;</p><p class="source-code">  &lt;div&gt;</p><p class="source-code">    &lt;p&gt;Message content: {{message.content}}&lt;/p&gt;</p><p class="source-code">    &lt;router-link :to="{ name: 'messageAuthor', params: { message }}"&gt;Author&lt;/router-link&gt; |</p><p class="source-code">    &lt;router-link :to="{ name: 'messageInfo', params: { message }}"&gt;Info&lt;/router-link&gt;</p><p class="source-code">    &lt;router-view/&gt;</p><p class="source-code">  &lt;/div&gt;</p><p class="source-code">&lt;/template&gt;</p><p class="source-code">&lt;script&gt;</p><p class="source-code">export default {</p><p class="source-code">  props: {</p><p class="source-code">    id: {</p><p class="source-code">      type: String</p><p class="source-code">    },</p><p class="source-code">    message: {</p><p class="source-code">      default: () =&gt; {},</p><p class="source-code">      type: Object,</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">&lt;/script&gt;</p><p>And now we can navigate between the <strong class="source-inline">Author</strong> and <strong class="source-inline">Info</strong> tabs within a <strong class="source-inline">Message</strong> as follows:</p><div id="_idContainer231" class="IMG---Figure"><img src="image/B15218_06_40.jpg" alt="Figure 6.40: Message page with Info selected&#13;&#10;"/></div><p class="figure-caption">Figure 6.40: Message page with Info selected</p></li>
				<li>Run the application using the following command:<p class="source-code">yarn serve</p><p>You will see the following when you select the <strong class="source-inline">Author</strong> option:</p><div id="_idContainer232" class="IMG---Figure"><img src="image/B15218_06_41.jpg" alt="Figure 6.41: Message page with Author selected&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 6.41: Message page with Author selected</p>
			<p>With this exercise, we have covered almost all the basic functionalities of Vue Router, especially on handling dynamic and nested routing. In the final section, we will go through how to create a reusable layout for view- templating our application.</p>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor221"/>Using Layouts</h1>
			<p>There are many ways to impl<a id="_idTextAnchor222"/>ement layouts <a id="_idTextAnchor223"/>in a Vue.js application. One of them is using <strong class="source-inline">slot</strong> and creating a static wrapper layout component on top of <strong class="source-inline">router-view</strong>. Despite its flexibility, this approach results in a heavy performance cost, both in the unnecessary re-creation of the component and in the extra data-fetching required on every route change. </p>
			<p>In this section, we will discuss a better approach, which is to take advantage of the power of the dynamic component. The components are as follows:</p>
			<p class="source-code">&lt;component :is="layout"/&gt;</p>
			<p>In the <strong class="source-inline">App.vue</strong> file, we will change the default view generated by Vue CLI to only <strong class="source-inline">&lt;router-view&gt;</strong> and a wrapper around it. This wrapper is a dynamic component that will render whatever component is defined in the <strong class="source-inline">layout</strong> variable:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div id="app"&gt;</p>
			<p class="source-code">    &lt;component :is="layout"&gt;</p>
			<p class="source-code">      &lt;router-view/&gt;</p>
			<p class="source-code">    &lt;/component&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p class="source-code">&lt;script&gt;</p>
			<p>By default, we will define <strong class="source-inline">layout</strong> in <strong class="source-inline">data</strong> to be the <strong class="source-inline">default.vue</strong> layout:</p>
			<p class="source-code">&lt;script&gt;</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  data() {</p>
			<p class="source-code">    return {</p>
			<p class="source-code">      layout: () =&gt; import(/* webpackChunkName: "defaultlayout" */         './layouts/default.vue')</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;/script&gt;</p>
			<p>And in the <strong class="source-inline">layouts</strong> folder, we will create the <strong class="source-inline">default</strong> layout component with a simple header navigation, a <strong class="source-inline">main</strong> slot to render the actual content (which is whatever <strong class="source-inline">&lt;router-view&gt;</strong> renders), and a footer:</p>
			<p class="source-code">&lt;template&gt;</p>
			<p class="source-code">  &lt;div class="default"&gt;</p>
			<p class="source-code">    &lt;nav&gt;</p>
			<p class="source-code">      &lt;router-link to="/"&gt;Home&lt;/router-link&gt; |</p>
			<p class="source-code">      &lt;router-link to="/about"&gt;About&lt;/router-link&gt;</p>
			<p class="source-code">    &lt;/nav&gt;</p>
			<p class="source-code">    &lt;main class="main"&gt;</p>
			<p class="source-code">      &lt;slot/&gt;</p>
			<p class="source-code">    &lt;/main&gt;</p>
			<p class="source-code">    &lt;footer&gt;</p>
			<p class="source-code">      &lt;div&gt;Vue Workshop Chapter 06&lt;/div&gt;</p>
			<p class="source-code">    &lt;/footer&gt;</p>
			<p class="source-code">  &lt;/div&gt;</p>
			<p class="source-code">&lt;/template&gt;</p>
			<p>Going back to our <strong class="source-inline">App.vue</strong> file, in order to make the layout <strong class="source-inline">component</strong> render in response to corresponding route changes, <strong class="source-inline">router-view</strong> should control which layout to render. In other words, <strong class="source-inline">layout</strong> should be updatable and decided by the view component rendered inside <strong class="source-inline">router-view</strong>. To achieve this, we will define the <strong class="source-inline">currentLayout</strong> property as synchronous with <strong class="source-inline">layout</strong> using <strong class="source-inline">sync</strong> on <strong class="source-inline">&lt;router-view&gt;</strong>:</p>
			<p class="source-code">&lt;component :is="layout"&gt;</p>
			<p class="source-code">  &lt;router-view :currentLayout="layout"/&gt;</p>
			<p class="source-code">&lt;/component&gt;</p>
			<p>And upon creating an instance of the <strong class="source-inline">Home.vue</strong> component, we will emit an <strong class="source-inline">update:currentLayout</strong> event with the desired layout to be updated and rendered accordingly:</p>
			<p class="source-code">import DefaultLayout from '../layouts/default.vue';</p>
			<p class="source-code">export default {</p>
			<p class="source-code">  name: 'home',</p>
			<p class="source-code">  components: {</p>
			<p class="source-code">    HelloWorld,</p>
			<p class="source-code">  },</p>
			<p class="source-code">  created() {</p>
			<p class="source-code">    this.$emit('update:currentLayout', DefaultLayout)</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>The output will be as follows:</p>
			<div>
				<div id="_idContainer233" class="IMG---Figure">
					<img src="image/B15218_06_42.jpg" alt="Figure 6.42: Home page rendered with a layout&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.42: Home page rendered with a layout</p>
			<p>Since the <strong class="source-inline">layout</strong> component is not part of the <strong class="source-inline">router-view</strong> component, it will only re-render whenever the layout changes from within the view. This will maintain the performance of the app during user navigation.</p>
			<p>In this section, we looked at how the dyna<a id="_idTextAnchor224"/>mic <strong class="source-inline">component</strong> component can be used to provide different layouts for different routes. This gives us the ability to have different common layouts, for example, one global menu for user-facing pages and another for admin pages, rendered based on the routes used. In the next section, we'll build on what we learned here by creating a message application with dynamic nested routing and layouts.</p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor225"/>Activity 6.01: Creating a Message SPA with Dynamic, Nested Routing, and Layouts </h2>
			<p>This activity aims to leverage your knowledge about Vue Router regarding registering routes and handling dynamic routes, nested routes, and route Hooks to create a <strong class="bold">Message</strong> <strong class="bold">SPA</strong>. This application will allow users to compose new messages, view a message feed, and navigate between messages to see their details:</p>
			<ol>
				<li value="1">Create a <strong class="source-inline">MessageEditor</strong> view (at <strong class="source-inline">src/views/MessageEditor.vue</strong>) that will render a view with <strong class="source-inline">textarea</strong> to the user and a <strong class="source-inline">submit</strong> button to save the message.</li>
				<li>Register the <strong class="source-inline">editor</strong> route with <strong class="source-inline">MessageEditor</strong> as its view in <strong class="source-inline">src/router/index.js</strong>.</li>
				<li>Create a <strong class="source-inline">MessageList</strong> view (at <strong class="source-inline">src/views/MessageList.vue</strong>) that will render a list of <strong class="source-inline">message id</strong> values wrapped by an <strong class="source-inline">a</strong> tag, which will direct to the single message page with the given <strong class="source-inline">id</strong> upon selection.</li>
				<li>Register the <strong class="source-inline">list</strong> route with <strong class="source-inline">MessageList</strong> as its view in <strong class="source-inline">src/router/index.js</strong>.</li>
				<li>Add the <strong class="source-inline">Messages</strong> view (at <strong class="source-inline">src/views/Messages.vue</strong>), which will render links to either <strong class="source-inline">editor</strong> or <strong class="source-inline">list</strong> as its nested routes and render the nested view accordingly.</li>
				<li>When the user navigates away from <strong class="source-inline">editor</strong>, should some content not yet have been submitted, display a message asking if they want to save before navigating away. <strong class="source-inline">Yes</strong> will continue, <strong class="source-inline">No</strong> will abort the navigation.</li>
				<li>Add a <strong class="source-inline">Message</strong> view (at <strong class="source-inline">src/views/Message.vue</strong>), which will render message content from <strong class="source-inline">props</strong> and have a <strong class="source-inline">back</strong> button to go back to the previous view. By default, it should go to <strong class="source-inline">messages</strong>.</li>
				<li>Register the <strong class="source-inline">Message</strong> view with the dynamic route of <strong class="source-inline">message/:id</strong> in <strong class="source-inline">src/router/index.js</strong>.</li>
				<li>Improve the UI by creating two different simple layouts, one for <strong class="source-inline">messages</strong> (with the title only) and one for <strong class="source-inline">message</strong> (with both the <strong class="source-inline">title</strong> and the <strong class="source-inline">back</strong> button).</li>
			</ol>
			<p>The expected output is as follows:</p>
			<ul>
				<li>The <strong class="source-inline">/list</strong> view that displays a feed of messages should look as follows:</li>
			</ul>
			<div>
				<div id="_idContainer234" class="IMG---Figure">
					<img src="image/B15218_06_43.jpg" alt="Figure 6.43: The /list view in the Messages app&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.43: The /list view in the Messages app</p>
			<ul>
				<li>The <strong class="source-inline">/editor</strong> view that allows the user to compose and send a new message looks as follows:</li>
			</ul>
			<div>
				<div id="_idContainer235" class="IMG---Figure">
					<img src="image/B15218_06_44.jpg" alt="Figure 6.44: The /editor view in the Messages app&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.44: The /editor view in the Messages app</p>
			<ul>
				<li>The <strong class="source-inline">/message/:id</strong> dynamic route (here, <strong class="source-inline">/message/0</strong> for a message with the <strong class="source-inline">id</strong> of <strong class="source-inline">0</strong>) in the <strong class="source-inline">Message</strong> app looks as follows: </li>
			</ul>
			<div>
				<div id="_idContainer236" class="IMG---Figure">
					<img src="image/B15218_06_45.jpg" alt="Figure 6.45: The /message/0 view in the Message app&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.45: The /message/0 view in the Message app</p>
			<p>An alert will be displayed when the user tries to navigate away with an unsaved message as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer237" class="IMG---Figure">
					<img src="image/B15218_06_46.jpg" alt="Figure 6.46: The /editor view when the user tries to navigate away with an unsaved message&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.46: The /editor view when the user tries to navigate away with an unsaved message</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found via <a href="B15218_Solution_Final_SZ_ePub.xhtml#_idTextAnchor393">this link</a>.</p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor226"/>Summary</h1>
			<p>Throughout this chapter, we have learn<a id="_idTextAnchor227"/>ed about the most basic and useful functionalities offered by Vue Router for building routing for any Vue.js application in an effective and organized manner.</p>
			<p><strong class="source-inline">router-view</strong> and <strong class="source-inline">router-link</strong> allow app developers to easily set up the navigation paths to their related views and maintain the SPA concept. The fact that they are Vue components themselves provides us as developers with the benefits of the Vue architecture, giving us flexibility in implementing nested views or layouts.</p>
			<p>Defining the route as an object with different properties simplifies the architecture process, including refactoring existing paths and adding a new route to the system. Using router parameters and patterns provides dynamic routing with reusable views and allows communication and data preservation between pages.</p>
			<p>And finally, with Hooks, we saw how we can intercept the navigation flow, setting up authentication where needed, redirecting to the desired path, or even loading and keeping some important data before the users land on the targeted page. There is an unlimited number of use cases where these Hooks can be extremely useful, such as when implementing a back button for instance.</p>
			<p>With these, we are now capable of composing a Vue.js application with a proper navigation system for users to explore, while maintaining the data flow in every navigation use case (dynamic routes and nested views) and the application design layout.</p>
			<p>In the next chapter, you are going to explore how to apply transitions to the routing and different animations for beautiful loading effects for your Vue components and application.</p>
		</div>
		<div>
			<div id="_idContainer239" class="Content">
			</div>
		</div>
	</body></html>