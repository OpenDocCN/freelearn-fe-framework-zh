- en: Getting Started
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: Developing applications in JavaScript is always a challenge. Due to its malleable
    nature and lack of type checking, building a decent-sized application in JavaScript
    is difficult. Moreover, we use JavaScript for all types of processes, such as
    **user interface** (**UI**) manipulation, client-server interaction, and business
    processing/validations. As a result, we end up with spaghetti code that is difficult
    to maintain and test.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中开发应用程序始终是一个挑战。由于其可塑性和缺乏类型检查，构建一个相当大的JavaScript应用程序是困难的。此外，我们使用JavaScript进行各种过程，如**用户界面（UI）**操作、客户端-服务器交互以及业务处理/验证。结果，我们得到了难以维护和测试的意大利面代码。
- en: Libraries such as jQuery do a great job of taking care of various browser quirks
    and providing constructs that can lead to an overall reduction in the lines of
    code. However, these libraries lack any structural guidance that can help us when
    the code-base  `/grows`.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于jQuery这样的库在处理各种浏览器怪癖和提供可以减少代码行数的结构方面做得很好。然而，这些库缺乏任何结构性的指导，这在我们代码库`/增长`时能帮助我们。
- en: In recent years, JavaScript frameworks have emerged to manage this complexity.
    Many of these frameworks, including earlier versions of Angular, use a design
    pattern called **Model-View-Controller** to separate the elements of the application
    into more manageable pieces. The success of these frameworks and their popularity
    in the developer community have established the value of using this pattern.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，JavaScript框架已经出现以管理这种复杂性。许多这些框架，包括Angular的早期版本，使用一种称为**模型-视图-控制器（MVC）**的设计模式来将应用程序的元素分割成更易于管理的部分。这些框架的成功以及它们在开发者社区中的流行确立了使用这种模式的价值。
- en: Web development, however, is constantly evolving and has changed a lot since
    Angular was first introduced in 2009\. Technologies such as Web Components, the
    new version of JavaScript (ES2015), and TypeScript have all emerged. Taken together,
    they offer the opportunity to build a new, forward-looking framework. And with
    this new framework comes a new design pattern—the component pattern.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Web开发，然而，一直在不断演变，自从2009年Angular首次推出以来已经发生了很大变化。诸如Web组件、JavaScript的新版本（ES2015）和TypeScript等技术都已经出现。综合来看，它们为我们提供了构建一个新、前瞻性框架的机会。而随着这个新框架的出现，也带来了一种新的设计模式——组件模式。
- en: This chapter is dedicated to understanding the component pattern and how to
    put it into practice as we build a simple app using Angular.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章致力于理解组件模式，以及如何在构建一个简单的Angular应用时将其付诸实践。
- en: 'The topics that we will cover in this chapter are as follows:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: '**Angular basics**: We will briefly talk about the component pattern that is
    used to build Angular applications'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Angular基础知识**：我们将简要介绍用于构建Angular应用的组件模式。'
- en: '**Building our first Angular app**: We will build a small game—*Guess the Number!—*in
    Angular'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建我们的第一个Angular应用**：我们将使用Angular构建一个小游戏——“猜数字！”'
- en: '**An introduction to some Angular constructs**: We will review some of the
    constructs that are used in Angular, such as interpolation, expressions, and the
    data binding syntax'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一些Angular构造的介绍**：我们将回顾Angular中使用的一些构造，例如插值、表达式和数据绑定语法。'
- en: '**Change detection**: We will discuss how change detection is managed in an
    Angular app'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变更检测**：我们将讨论在Angular应用中如何管理变更检测。'
- en: '**Tools and resources**: Lastly, we will provide some resources and tools that
    will come in handy during Angular development and debugging'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工具和资源**：最后，我们将提供一些在Angular开发和调试过程中会很有用的资源和工具。'
- en: Angular basics
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular基础知识
- en: Let's get started by looking at how Angular implements the component pattern.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从了解Angular如何实现组件模式开始。
- en: The component pattern
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件模式
- en: Angular applications use the component pattern. You may not have heard of this
    pattern, but it is all around us. It is used not only in software development
    but also in manufacturing, construction, and other fields. Put simply, it involves
    combining smaller, discrete building blocks into larger finished products. For
    example, a battery is a component of an automobile.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Angular应用使用组件模式。你可能没有听说过这种模式，但它无处不在。它不仅用于软件开发，还用于制造、建筑和其他领域。简单来说，它涉及将较小的、离散的构建块组合成更大的成品。例如，电池是汽车的一个组件。
- en: In software development, components are logical units that can be combined into
    larger applications. Components tend to have internal logic and properties that
    are shielded or hidden from the larger application. The larger application then
    consumes these building-blocks through specific gateways, called **interfaces**,
    which expose only what is needed to make use of the component. In this way, the
    component's internal logic can be modified without affecting the larger application,
    as long as the interfaces are not changed.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中，组件是逻辑单元，可以组合成更大的应用程序。组件通常具有内部逻辑和属性，这些逻辑和属性被屏蔽或隐藏在更大的应用程序中。然后，更大的应用程序通过称为**接口**的特定网关消耗这些构建块，这些接口仅公开使用组件所需的内容。这样，只要接口没有改变，就可以修改组件的内部逻辑，而不会影响更大的应用程序。
- en: Getting back to our battery example, the car consumes the battery through a
    series of connectors. If the battery dies, however, it can be replaced by an entirely
    new battery, as long as that battery has the same connectors. This means that
    the builder of the car does not have to worry about the internals of the battery,
    which simplifies the process of building the car. Even more importantly, the car
    owner does not have to replace their car every time the battery dies.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的电池例子，汽车通过一系列连接器消耗电池。然而，如果电池耗尽，只要新电池有相同的连接器，就可以完全更换。这意味着汽车制造商不必担心电池的内部结构，这简化了汽车制造的过程。更重要的是，车主不必每次电池耗尽时都更换他们的汽车。
- en: To extend the analogy, manufacturers of batteries can market them for a range
    of different vehicles, for example, ATVs, boats, or snowmobiles. So the component
    pattern enables them to realize even greater economies of scale.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了扩展这个类比，电池制造商可以将它们推广到各种不同的车辆上，例如ATV、船只或雪地摩托车。因此，组件模式使它们能够实现更大的规模经济。
- en: Using the component pattern in web applications
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Web应用程序中使用组件模式
- en: As web applications continue to become more sophisticated, the need to be able
    to construct them out of smaller and discrete components becomes more compelling.
    Components allow applications to be built in a way that prevents them from becoming
    messes of spaghetti code. Instead, component-based design allows us to reason
    about specific parts of the application in isolation from the other parts, and
    then we can stitch the application together into a finished, whole through agreed-upon
    points of connection.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Web应用程序变得越来越复杂，能够用更小、更离散的组件构建它们的必要性变得更加迫切。组件允许以防止应用程序变成一团乱麻代码的方式构建应用程序。相反，基于组件的设计允许我们独立于其他部分对应用程序的特定部分进行推理，然后我们可以通过约定的连接点将应用程序缝合成一个完整的成品。
- en: Also, maintenance costs are less because each component's internal logic can
    be managed separately without affecting the other parts of the application. And
    putting applications together using self-describing components makes the application
    easier to understand at a higher level of abstraction.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，维护成本较低，因为每个组件的内部逻辑可以单独管理，而不会影响应用程序的其他部分。并且使用自描述组件组装应用程序使得在更高层次上理解应用程序变得更加容易。
- en: Why weren't components used before in Angular?
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么以前在Angular中没有使用组件？
- en: If this idea makes so much sense, why was the component pattern not adopted
    in earlier versions of Angular? The answer is that the technologies that existed
    when Angular was first released did not fully support the implementation of this
    pattern in web applications.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个想法如此合理，为什么组件模式没有被早期版本的Angular采用？答案是，Angular最初发布时存在的技术并没有完全支持在Web应用程序中实现这种模式。
- en: Earlier versions of Angular, however, made substantial steps in the direction
    of enabling more intelligent web application design and organization. For example,
    they implemented the MVC pattern, which separates an application into a model,
    view, and controller (you will see the use of the MVC pattern continuing within
    the components that we will build in Angular).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Angular的早期版本在实现更智能的Web应用程序设计和组织方向上迈出了实质性的步伐。例如，它们实现了MVC模式，将应用程序分为模型、视图和控制（你将在我们将在Angular中构建的组件中看到MVC模式的持续使用）。
- en: With the MVC pattern, the model is the data, the view is a web page (or a mobile
    app screen or even a Flash page), and the controller populates the view with data
    from the model. In this way, separation of concerns is achieved. Following this
    pattern along with an intelligent use of directives will get you pretty close
    to components.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MVC模式，模型是数据，视图是一个网页（或移动应用屏幕，甚至Flash页面），控制器从模型中填充视图的数据。通过这种方式，实现了关注点的分离。遵循这个模式并智能地使用指令，可以使你非常接近组件。
- en: So, the earlier versions of Angular allowed applications to be designed and
    built more logically. However, this approach was limited by the fact that the
    technologies used were not truly isolated. Instead, they all ended up being rendered
    without any true separation from other elements on the screen.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Angular的早期版本允许以更逻辑的方式设计和构建应用程序。然而，这种方法受到所使用的技术并非真正隔离的限制。相反，它们最终都被渲染，没有任何真正的分离，与其他屏幕上的元素混合在一起。
- en: What's new that enables Angular to use the component pattern?
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么新特性使得Angular能够使用组件模式？
- en: By contrast, the newest version of Angular embraces recently emerging technologies,
    which make it possible to implement the component pattern more fully. These technologies
    include Web Components, ES2015 (the new version of JavaScript), and TypeScript.
    Let's discuss what each of these technologies brings to the mix that makes this
    possible.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，Angular的最新版本拥抱了最近兴起的科技，这使得更全面地实现组件模式成为可能。这些技术包括Web Components、ES2015（JavaScript的新版本）和TypeScript。让我们讨论一下这些技术各自为这个可能带来的贡献。
- en: Web Components
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web Components
- en: 'Web Components is an umbrella term that actually covers four emerging standards
    for web browsers:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Web Components是一个总称，实际上涵盖了四个针对网络浏览器的正在兴起的标准化：
- en: Custom elements
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义元素
- en: Shadow DOM
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阴影DOM
- en: Templates
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板
- en: HTML imports
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML导入
- en: More information on Web Components can be found at [https://www.webcomponents.org/introduction](https://www.webcomponents.org/introduction)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于Web Components的信息可以在[https://www.webcomponents.org/introduction](https://www.webcomponents.org/introduction)找到
- en: 'Let''s now discuss each of these in detail:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将详细讨论这些内容：
- en: '**Custom elements** enable new types of DOM elements to be created other than
    the standard HTML tags such as `<div>` and `<p>`.  You will see the use of these
    custom elements throughout this book. For example, the application that we are
    building in this chapter will have a root element named `<app-root>`, but you
    can give this element any name you like.  Individual components will also use
    custom elements. For example, in the following chapters we are building a more
    sophisticated application that breaks the screen down into components. The header
    of the page will use a custom element `<abe-header>`  to display its content (the
    prefix `abe` is unique to our application and helps to avoid naming collisions
    with native HTML elements or custom elements in other apps). The ability to add
    custom tags provides a location on the screen that can be reserved for binding
    a component. In short, this is the first step towards separating a component from
    the rest of the page and making it possible to become truly self-contained.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义元素**允许创建除标准HTML标签（如`<div>`和`<p>`）之外的新类型的DOM元素。你将在本书的各个部分看到这些自定义元素的使用。例如，我们在本章构建的应用程序将有一个名为`<app-root>`的根元素，但你也可以给它任何你喜欢的名字。单个组件也将使用自定义元素。例如，在接下来的章节中，我们将构建一个更复杂的应用程序，将屏幕分解成组件。页面的头部将使用自定义元素`<abe-header>`来显示其内容（前缀`abe`仅属于我们的应用程序，有助于避免与原生HTML元素或其他应用程序中的自定义元素发生命名冲突）。添加自定义标签的能力提供了一个屏幕上的位置，可以用于绑定组件。简而言之，这是将组件从页面其余部分分离出来并使其真正自包含的第一步。'
- en: '**Shadow DOM** provides a hidden area on the page for scripts, CSS, and HTML.
    Markup and styles that are within this hidden area will not affect the rest of
    the page, and equally importantly they will not be affected by the markup and
    styles on other parts of the page. Our component can use this hidden area to render
    its display. So, this is the second step in making our component self-contained.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阴影DOM**在页面上提供了一个隐藏区域，用于脚本、CSS和HTML。这个隐藏区域内的标记和样式不会影响页面的其余部分，同样重要的是，它们也不会受到页面其他部分标记和样式的影响。我们的组件可以使用这个隐藏区域来渲染其显示。因此，这是使我们的组件自包含的第二步。'
- en: '**Templates** are fragments of HTML that do not initially render in a web page,
    but can be activated at runtime using JavaScript. Many JavaScript frameworks already
    support some form of templating. Web Components standardize this templating and
    provide direct support for it in the browser. Templates can be used to make the
    HTML and CSS inside the Shadow DOM used by our component dynamic. So, this is
    the third step in making our component.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板**是HTML片段，最初不会在网页中渲染，但可以在运行时通过JavaScript激活。许多JavaScript框架已经支持某种形式的模板。Web
    Components标准化了这种模板，并在浏览器中直接提供支持。模板可以用来使我们的组件使用的Shadow DOM中的HTML和CSS动态化。因此，这是制作我们组件的第三步。'
- en: The final standard that makes up Web Components is **HTML imports**. They provide
    a way to load resources such as HTML, CSS, and JavaScript in a single bundle.
    Angular does not use HTML imports. Instead, it relies on JavaScript module loading,
    which we will discuss a little later in this chapter.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构成Web Components的最后一个标准是**HTML导入**。它们提供了一种在单个包中加载资源（如HTML、CSS和JavaScript）的方法。Angular不使用HTML导入。相反，它依赖于JavaScript模块加载，我们将在本章稍后讨论这一点。
- en: Angular and Web Components
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular和Web Components
- en: Web Components are not fully supported in current web browsers. For that reason,
    Angular components are not strictly Web Components. It is probably more accurate
    to say that Angular components implement the design principles behind Web Components.
    They also make it possible to build components that can run in today's browsers.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Web Components在当前的网络浏览器中并未得到完全支持。因此，Angular组件并不是严格意义上的Web Components。可能更准确的说法是，Angular组件实现了Web
    Components背后的设计原则。它们还使得构建能在当今浏览器中运行的组件成为可能。
- en: At the time of writing, Angular supports evergreen browsers, such as Chrome,
    Firefox, Safari, and Edge, as well as IE 9 and above. It also has support for
    Android and IOS. For a list of browsers supported by Angular, visit [https://angular.io/guide/browser-support.](https://angular.io/guide/browser-support)
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Angular支持Chrome、Firefox、Safari和Edge等evergreen浏览器，以及IE 9及以上版本。它还支持Android和iOS。要查看Angular支持的浏览器列表，请访问[https://angular.io/guide/browser-support.](https://angular.io/guide/browser-support)
- en: Therefore, throughout the rest of this book, we will focus on building Angular
    components and not Web Components. Despite this distinction, Angular components
    align closely with Web Components and can even inter-operate with them. As browsers
    begin to support Web Components more fully, the differences between Angular components
    and Web Components will begin to disappear. So, if you want to begin adopting
    the Web Component standards of the future, Angular provides you with the opportunity
    to do so today.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本书的剩余部分，我们将专注于构建Angular组件而不是Web Components。尽管有这种区别，Angular组件与Web Components非常接近，甚至可以与它们交互。随着浏览器开始更全面地支持Web
    Components，Angular组件与Web Components之间的差异将开始消失。所以，如果你想要开始采用未来的Web Component标准，Angular为你提供了这样的机会。
- en: Language support in Angular
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular中的语言支持
- en: You can develop components with ES5 (the version of JavaScript supported in
    all current browsers), but Angular enhances the ability to develop components
    by adding support for key features that are found in the latest languages, such
    as ES2015 and TypeScript.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用ES5（所有当前浏览器支持的JavaScript版本）开发组件，但Angular通过添加对最新语言（如ES2015和TypeScript）中找到的关键特性的支持，增强了开发组件的能力。
- en: ES2015
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ES2015
- en: 'ES2015 is the new version of JavaScript; it was approved in June 2015\. It
    adds many improvements to the language, which we will see throughout this book,
    but the two that interest us the most at this point are the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ES2015是JavaScript的新版本；它在2015年6月获得批准。它为语言添加了许多改进，我们将在本书的整个过程中看到这些改进，但在此阶段最吸引我们注意的两个是以下内容：
- en: Classes
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类
- en: Module loading
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块加载
- en: '**Classes** did not previously exist in JavaScript. The key advantage of using
    them, now that they do exist, is that they offer a simple, clear syntax that we
    can use to create convenient containers for the code in our components. As you
    will find when you begin working on the applications in this book. Classes also
    provide a convenient shorthand designation for our components that makes it easier
    to stitch them together with each other through things such as dependency injection.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**类**在JavaScript中之前并不存在。现在它们存在后，使用它们的关键优势是它们提供了一个简单、清晰的语法，我们可以用它来创建方便的容器来存放组件中的代码。正如你将在本书中的应用程序开发中找到的那样。类还为我们的组件提供了一个方便的简写名称，这使得通过诸如依赖注入之类的手段将它们拼接在一起变得更加容易。'
- en: To be clear, JavaScript classes do not introduce something that is completely
    new. The **Mozilla Developer Network** (**MDN**) describes them as primarily syntactical
    sugar over JavaScript's existing prototype-based inheritance.  For more information
    visit [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明确，JavaScript 类并没有引入完全新的东西。**Mozilla 开发者网络**（**MDN**）将它们描述为在 JavaScript 现有的基于原型的继承之上的主要语法糖。更多信息请访问[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes)。
- en: We'll explore classes throughout the examples in this book. If you have not
    worked with object-oriented languages, you may not be familiar with classes, so
    we will cover them as we work through the examples in this chapter.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的示例中探索类。如果你没有使用过面向对象的语言，你可能对类不太熟悉，因此我们将随着本章的示例逐步介绍它们。
- en: ES2015 also introduces a new approach to **module loading**. A module provides
    a way for JavaScript files to be encapsulated. When they are encapsulated, they
    do not pollute the global namespace and can interact with other modules in a controlled
    manner.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ES2015 还引入了一种新的模块加载方法。模块提供了一种封装 JavaScript 文件的方式。当它们被封装时，它们不会污染全局命名空间，并且可以以受控的方式与其他模块交互。
- en: Once we have our modules defined, we need a way to load them into our application
    for execution. Module loading allows us to select just what we need for our application
    from the modules that make up Angular and other components that we create or use.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了我们的模块，我们需要一种方法将它们加载到我们的应用程序中以执行。模块加载允许我们从构成 Angular 和我们创建或使用的其他组件的模块中选择我们需要的部分。
- en: Currently, a range of approaches and libraries exists to support module loading
    in JavaScript. ES2015 adds a new, consistent syntax for loading modules as part
    of the language. The syntax is straightforward and involves prefixing modules
    with the `export` keyword (or using the default export) and then using `import`
    to consume them elsewhere in our application.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，存在一系列方法和库来支持 JavaScript 中的模块加载。ES2015 为加载模块添加了一种新的、一致的语法，作为语言的一部分。这种语法简单明了，涉及在模块前加上
    `export` 关键字（或使用默认导出），然后在应用程序的其他地方使用 `import` 来消费它们。
- en: ES 2015 module loading enables us to combine components into useful bundles
    or features that can be imported or exported within our applications. In fact,
    modules are at the core of Angular itself. We will see that modules are used extensively
    both in Angular itself and in the applications that we are building throughout
    this book.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ES 2015 模块加载使我们能够将组件组合成有用的包或功能，这些包或功能可以在我们的应用程序中导入或导出。实际上，模块是 Angular 本身的核心。我们将看到模块在
    Angular 本身以及本书中构建的应用程序中都被广泛使用。
- en: It is important to understand that, while Angular uses syntax that has similarities
    to ES2015 module-loading syntax, Angular modules (which we will discuss a little
    later in this chapter) are not the same as JavaScript modules. For further details
    on these differences, see the Angular documentation at [https://angular.io/guide/architecture#ngmodules-vs-javascript-modules](https://angular.io/guide/architecture#ngmodules-vs-javascript-modules).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，虽然 Angular 使用与 ES2015 模块加载语法相似的语法，但 Angular 模块（我们将在本章稍后讨论）并不等同于 JavaScript
    模块。有关这些差异的更多详细信息，请参阅 Angular 文档[https://angular.io/guide/architecture#ngmodules-vs-javascript-modules](https://angular.io/guide/architecture#ngmodules-vs-javascript-modules)。
- en: Because ES2015 is not fully supported by today's browsers, we will need to convert
    ES2015 into ES5 in order to use features such as classes and module loading in
    our applications. We do this through a process called **transpilation**.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 ES2015 并非今天所有浏览器都完全支持，因此我们需要将 ES2015 转换为 ES5，以便在我们的应用程序中使用类和模块加载等功能。我们通过一个称为**转译**的过程来完成这项工作。
- en: Transpilation is like compilation, except that instead of converting our code
    into a machine language as compilation does, transpilation converts one type of
    source code to another type of source code. In this case, it converts ES2015 to
    ES5\. There are several tools called **transpilers** that enable us to do that.
    Common transpilers include Traceur and Babel. TypeScript (which we will discuss
    next) is also a transpiler, and it is the one that we will use for the examples
    in this book.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 转译类似于编译，但与编译将我们的代码转换为机器语言不同，转译将一种源代码转换为另一种源代码。在这种情况下，它将ES2015转换为ES5。有几个称为**转译器**的工具使我们能够做到这一点。常见的转译器包括Traceur和Babel。TypeScript（我们将在下一节讨论）也是一个转译器，我们将使用它来本书中的示例。
- en: Once ES2015 is transpiled to ES5, we can then use a module loader such as **SystemJS**
    to load our modules. **SystemJS** follows the ES2015 syntax for module loading
    and gives us the ability to do module loading in today's browsers. Alternatively,
    we can  use a module bundler such as **webpack** to load and combine our modules.
    For the projects in this book we will be using **webpack** to load, bundle, and
    deploy the modules in our applications.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦ES2015被转换为ES5，我们就可以使用像**SystemJS**这样的模块加载器来加载我们的模块。**SystemJS**遵循ES2015的模块加载语法，并使我们能够在今天的浏览器中执行模块加载。或者，我们可以使用像**webpack**这样的模块打包器来加载和组合我们的模块。对于本书中的项目，我们将使用**webpack**来加载、打包和部署我们的应用程序中的模块。
- en: Since the release of ES2015, the schedule for releases of new versions of ECMAScript
    (the official name for JavaScript) is on an annual basis—so we now have ES2016
    and ES2017 and will soon have ES2018.  Since the features that we are highlighting
    throughout this book were first introduced in ES2015, we will be referring to
    ES2015 instead of any of the newer versions. The newer versions, however, are
    fully compatible with the language features that we are highlighting here and
    elsewhere in the book.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 自从ES2015发布以来，ECMAScript（JavaScript的官方名称）新版本的发布周期已经变为每年一次——因此我们现在有了ES2016和ES2017，很快我们还将有ES2018。由于本书中强调的功能最初是在ES2015中引入的，因此我们将引用ES2015而不是任何更新的版本。然而，更新的版本与本书中强调的语言功能完全兼容。
- en: TypeScript
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript
- en: 'TypeScript was created by Microsoft as a superset of JavaScript, which means
    that it contains the features of ES2015 (such as classes and module loading) and
    adds the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript是由微软创建的，它是JavaScript的超集，这意味着它包含了ES2015的功能（如类和模块加载）并添加了以下内容：
- en: Types
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型
- en: Decorators
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰器
- en: '**Types** allow us to mark variables, properties, and parameters in our classes
    to indicate that they are numbers, strings, Booleans, or various structures such
    as arrays and objects. This enables us to perform type checking at design time
    to make sure that the proper types are being used in our application.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**类型**允许我们在类中标记变量、属性和参数，以指示它们是数字、字符串、布尔值或各种结构，如数组和对象。这使得我们能够在设计时执行类型检查，以确保在我们的应用程序中使用正确的类型。'
- en: '**Decorators** are simple annotations that we can add to our classes using
    the `@` symbol along with a function. They provide instructions (called metadata)
    for the use of our classes. In the case of Angular, decorators allow us to identify
    our classes as Angular components. Decorators also enable us to specify a custom
    element to which to bind our component and to identify a template that adds an
    HTML view to our component. We will cover much more about the use of decorators
    as we go through this book.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**装饰器**是我们可以使用`@`符号和函数添加到我们的类中的简单注释。它们为我们的类的使用提供了指令（称为元数据）。在Angular的情况下，装饰器允许我们将我们的类标识为Angular组件。装饰器还使我们能够指定一个自定义元素来绑定我们的组件，并识别一个模板，该模板为我们的组件添加HTML视图。随着我们通过本书的学习，我们将详细介绍装饰器的使用。'
- en: Decorators  are not part of ES2015, but are part of a proposal to include them
    in the JavaScript language in the future. They were added to TypeScript as part
    of a collaboration between Microsoft and Google. As mentioned earlier, TypeScript
    compiles into ES5, so we are able to use both types and decorators in browsers
    that do not fully support ES2015 or the proposed standard for decorators.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器不是ES2015的一部分，但它是将它们包含在JavaScript语言未来版本中的一个提案的一部分。它们作为微软和谷歌合作的一部分被添加到TypeScript中。如前所述，TypeScript编译成ES5，因此我们能够在不完全支持ES2015或装饰器提议标准的浏览器中使用类型和装饰器。
- en: As mentioned previously, it is not necessary to use either ES2015 or TypeScript
    with Angular. However, we think that you will see the advantages of using them
    as we work through the examples in this book.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，使用ES2015或TypeScript与Angular一起使用并非必需。然而，我们认为，随着我们通过本书中的示例进行，你会看到使用它们的优点。
- en: Putting it all together
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容整合在一起
- en: By following the Web Component standards and adding support for ES2015 and TypeScript,
    Angular gives us the ability to create web applications that implement the component
    design pattern. These components help realize the vision behind the standards
    of building large-scale applications through collections of self-describing and
    self-contained building blocks.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循Web组件标准并添加对ES2015和TypeScript的支持，Angular使我们能够创建实现组件设计模式的Web应用程序。这些组件有助于实现通过自描述和自包含的构建块构建大型应用程序的愿景。
- en: We hope that you will see in the examples in this book that Angular enables
    components to be constructed in a straightforward and declarative way that makes
    it easier for developers to implement them. As we proceed through the examples
    in this book, we will highlight where each of these technologies is being used.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望你在本书的示例中看到，Angular使组件能够以简单和声明性的方式构建，这使得开发者更容易实现它们。随着我们通过本书中的示例进行，我们将突出显示这些技术被使用的位置。
- en: Angular modules
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular模块
- en: Components are the basic building block of an Angular application. But how do
    we then organize these building blocks into complete applications? Angular modules
    provide the answer to this question. They enable us to combine our components
    into reusable groups of functionality that can be exported and imported throughout
    our application. For example, in a more sophisticated application we would want
    to have modules for things such as authentication, common utilities, and external
    service calls. At the same time, modules enable us to group features within an
    application in a way that allows us to load them on demand. This is called lazy
    loading, a topic that we will cover in Chapter 4, *Building Personal Trainer*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是Angular应用程序的基本构建块。但我们是如何将这些构建块组织成完整的应用程序的呢？Angular模块为这个问题提供了答案。它们使我们能够将我们的组件组合成可重用的功能组，这些组可以在整个应用程序中导出和导入。例如，在一个更复杂的应用程序中，我们可能希望有用于认证、通用工具和外部服务调用的模块。同时，模块使我们能够以允许按需加载的方式对应用程序中的功能进行分组。这被称为懒加载，我们将在第4章“构建个人教练”中介绍这个主题。
- en: Each Angular application will have one or more modules that contain its components.
    Angular has introduced `NgModule` as a way to conveniently specify the components
    that make up a module. Every Angular application must have at least one of these
    modules—the root module.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Angular应用程序将有一个或多个包含其组件的模块。Angular引入了`NgModule`作为方便指定构成模块的组件的方式。每个Angular应用程序都必须至少有一个这样的模块——根模块。
- en: Angular itself is built as modules that we import into our application. So you
    will see the use of modules all over as you build Angular apps.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Angular本身是作为模块构建的，我们将它们导入到我们的应用程序中。所以，当你构建Angular应用程序时，你将看到模块的广泛应用。
- en: The basic steps to building Angular applications
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Angular应用程序的基本步骤
- en: 'To sum up: at a basic level, you will see that to develop applications in Angular,
    you will do the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下：在基本层面上，你会发现，要在Angular中开发应用程序，你需要做以下事情：
- en: Create components
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建组件
- en: Bundle them into modules
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将它们打包成模块
- en: Bootstrap your application
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引导你的应用程序
- en: The best way to understand Angular and the component design pattern is by seeing
    it in action. Hence, we are going to build our first Hello World app in Angular.
    This app will help you become familiar with the Angular framework and see the
    component design pattern in action.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通过看到Angular和组件设计模式在实际中的应用来理解Angular和组件设计模式是最佳方式。因此，我们将使用Angular构建我们的第一个Hello
    World应用程序。这个应用程序将帮助你熟悉Angular框架，并看到组件设计模式在实际中的应用。
- en: Let's get started doing that.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始做吧。
- en: The customary Hello Angular app – Guess the Number!
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传统的Hello Angular应用程序 - 猜数字！
- en: As our first exercise, we want to keep things simple, but still showcase the
    framework's capabilities. Therefore, we are going to build a very simple game
    called *Guess the Number!*. The objective of the game is to guess a random computer-generated
    number in as few tries as possible.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们的第一个练习，我们希望保持简单，但仍然展示框架的能力。因此，我们将构建一个非常简单的游戏，名为*猜数字！*。游戏的目标是用尽可能少的尝试次数猜出一个随机生成的计算机数字。
- en: 'This is how the game looks:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这个游戏的外观：
- en: '![](img/00005.jpeg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00005.jpeg)'
- en: Let's now build *Guess the Number!*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在构建“猜数字”！
- en: Building Guess the Number!
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建“猜数字”！
- en: The standard practice while building user interfaces is to build them top-down.
    Start by designing the UI and then plug in the data and behavior according to
    your needs. With such an approach, the UI, data, and behavioral aspects of the
    app are all tightly coupled, which is a less than ideal situation!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建用户界面时，通常的做法是从上到下构建。首先设计UI，然后根据需要插入数据和行为。采用这种方法，应用程序的UI、数据和行为方面都紧密耦合，这并不是一个理想的情况！
- en: With component-based design, we work differently. We start by looking at the
    UI and expected behavior, and then we encapsulate all of this into a building
    block that we call a **component**. This component is then hosted on our page.
    Within the component, we separate the UI into a view and the behavior into a class,
    with the appropriate properties and methods needed to support the behavior. If
    you are not familiar with classes, don't worry. We'll be discussing what they
    are in detail as we move through the example.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 基于组件的设计，我们的工作方式有所不同。我们首先查看UI和预期的行为，然后将其封装到一个我们称之为**组件**的构建块中。然后，这个组件被托管在我们的页面上。在组件内部，我们将UI分为视图，将行为分为类，并包含支持行为的适当属性和方法。如果您不熟悉类，请不要担心。随着我们通过示例的进展，我们将详细讨论它们是什么。
- en: Okay, so let's identify the UI and behavior that we will need for our application.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那么让我们确定我们应用程序需要的UI和行为。
- en: Designing our first component
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计我们的第一个组件
- en: 'To determine what needs to go into our component, we will start by detailing
    the features that we want the app to support:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定我们的组件需要包含什么，我们将首先详细说明我们希望应用程序支持的功能：
- en: Generating random numbers (`original`)
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成随机数字（`original`）
- en: Providing input for a user to guess the value (`guess`)
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为用户提供猜测值的输入（`guess`）
- en: Tracking the number of guesses already made (`noOfTries`)
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪已经做出的猜测数量（`noOfTries`）
- en: Giving the user hints to improve their guess based on their input (`deviation`)
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据用户的输入（`偏差`）提供提示以改善他们的猜测
- en: Giving a success message if the user guesses the number correctly (`deviation`)
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户猜对了数字，显示成功消息（`偏差`）
- en: Now that we have our features, we can determine what we need to display to the
    user and what data we need to track. For the preceding feature set, the elements
    in parentheses denote the properties that will support those features and will
    need to be included in our component.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的功能，我们可以确定我们需要向用户显示什么，以及我们需要跟踪哪些数据。对于前面的功能集，括号中的元素表示将支持这些功能的属性，并将需要包含在我们的组件中。
- en: Designing the component is a very crucial process. If it is done right, we can
    logically organize our application in a way that makes it understandable and easy
    to maintain.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 设计组件是一个非常关键的过程。如果做得正确，我们可以逻辑地组织我们的应用程序，使其易于理解和维护。
- en: While building any app, we urge you to first think about the functionality you
    want to offer, and then the data and behavior that can support the functionality.
    Lastly, think about how to build a user interface for it. This is a good practice
    irrespective of the library or framework that you use to build your app.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建任何应用程序时，我们强烈建议您首先考虑您想要提供的功能，然后是支持该功能的数据和行为。最后，考虑如何为它构建用户界面。这是一个无论您使用什么库或框架来构建应用程序都是良好的实践。
- en: Developing our first component
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发我们的第一个组件
- en: Now that we have a design for our first component, we’ll start developing it
    using the **Angular Command Line Interface** (**Angular CLI**). The Angular CLI enables
    us to start building Angular applications and deploying them through a series
    of console commands. We’ll be covering the **Angular CLI** in greater detail in
    future chapters. For now, we will install it and use it to generate a basic application
    as the beginning point for our first component.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的第一个组件设计了方案，我们将开始使用**Angular命令行界面**（**Angular CLI**）来开发它。Angular CLI使我们能够通过一系列控制台命令开始构建Angular应用程序并将它们部署出去。我们将在未来的章节中更详细地介绍**Angular
    CLI**。目前，我们将安装它并使用它来生成一个基本的应用程序，作为我们第一个组件的起点。
- en: To use the **Angular CLI** you must first install **Node.js** and **npm** (**Node**'s
    package manager). **Node** is available cross-platform and you can download it
    from [http://nodejs.org](http://nodejs.org). Installing **Node **also installs **npm**. For
    this book, we are using **Node.js** version 8.9.4 and **npm** version 5.6.0\.
    You can find more information about installing **Node** and updating **npm** to
    the latest version at [https://docs.npmjs.com/getting-started/installing-node](https://docs.npmjs.com/getting-started/installing-node).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 **Angular CLI**，您必须首先安装 **Node.js** 和 **npm**（**Node** 的包管理器）。**Node** 可跨平台使用，您可以从
    [http://nodejs.org](http://nodejs.org) 下载它。安装 **Node** 也会安装 **npm**。对于本书，我们使用
    **Node.js** 版本 8.9.4 和 **npm** 版本 5.6.0。您可以在 [https://docs.npmjs.com/getting-started/installing-node](https://docs.npmjs.com/getting-started/installing-node)
    找到有关安装 **Node** 和将 **npm** 更新到最新版本的更多信息。
- en: 'Once **Node** and **npm **are installed, open a Command Prompt and type the
    following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了 **Node** 和 **npm**，打开命令提示符并输入以下内容：
- en: '[PRE0]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This installs the **Angular CLI** that we will use to start building our application. Now
    from a directory on your local machine, enter the following commands:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装我们将用于启动应用程序的 **Angular CLI**。现在，从您的本地机器上的一个目录中，输入以下命令：
- en: '[PRE1]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With the first command the **Angular CLI** will create a new Angular project
    on your local machine (the `--inlineTemplate` flag creates a template within our
    component, which is perfect for what we want to show in this chapter). With the
    second command, you are navigating to the directory that the **Angular CLI** has
    created for your new project. The third command launches the application, which
    you can view at `http://localhost:4200/`. If you do that you should see a standard
    default Angular page in the browser.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令将使用 **Angular CLI** 在您的本地机器上创建一个新的 Angular 项目（`--inlineTemplate` 标志在组件内部创建模板，这对于我们本章要展示的内容非常合适）。第二个命令将您导航到
    **Angular CLI** 为您的新项目创建的目录。第三个命令启动应用程序，您可以在 `http://localhost:4200/` 上查看。如果您这样做，您应该在浏览器中看到一个标准的默认
    Angular 页面。
- en: Installing Bootstrap
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Bootstrap
- en: 'There is one more step before we build out the specifics of our application.
    Let’s add the Bootstrap library to enhance the look and feel of our application.
    First, stop the application by typing *Ctrl* + *C* in the Terminal from which
    it was launched and enter *Y* when asked if you want to terminate the batch job.
    Next from the `guessthenumber` directory, enter the following command:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们构建应用程序的具体细节之前，还有一步。让我们添加 Bootstrap 库来增强应用程序的外观和感觉。首先，通过在启动应用程序的终端中输入 *Ctrl*
    + *C* 来停止应用程序，并在被询问是否要终止批处理作业时输入 *Y*。然后从 `guessthenumber` 目录，输入以下命令：
- en: '[PRE2]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will install the latest release of Bootstrap (which at the time of writing
    was version 4.0.0). You may see a few warning messages about unmet dependencies.
    You can ignore them.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装 Bootstrap 的最新版本（在撰写本文时为版本 4.0.0）。您可能会看到一些关于未满足依赖项的警告消息。您可以忽略它们。
- en: 'Next configure your new project to include the Bootstrapstyle sheet:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来配置您的项目以包含 Bootstrap 样式表：
- en: In the `guessthenumber` directory find and open the file `angular.json`
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `guessthenumber` 目录中找到并打开文件 `angular.json`
- en: In that file find the `projects` property, which contains the settings in our
    new project
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该文件中找到 `projects` 属性，它包含我们新项目的设置
- en: Then find the `styles` property within `architect.build.options` and you will
    see that it contains an array that holds `styles.css`, the default style sheet
    for our new project
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后找到 `architect.build.options` 中的 `styles` 属性，您会看到它包含一个数组，该数组包含 `styles.css`，这是新项目的默认样式表。
- en: 'Add to that array the location of the `bootstrap.min.css` style sheet like
    so:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `bootstrap.min.css` 样式表的路径添加到该数组中：
- en: '[PRE3]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: These instructions for including Bootstrap using the **Angular CLI** can be
    found at [https://github.com/angular/angular-cli/wiki/stories-include-bootstrap](https://github.com/angular/angular-cli/wiki/stories-include-bootstrap).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **Angular CLI** 包含 Bootstrap 的说明可以在 [https://github.com/angular/angular-cli/wiki/stories-include-bootstrap](https://github.com/angular/angular-cli/wiki/stories-include-bootstrap)
    找到。
- en: What do we have so far?
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们目前有什么？
- en: If you take a look in the `guessthenumber` directory that the **Angular CLI **has
    been created, you will see a large number of files. This may look overwhelming
    at first, but the important thing to understand is that the **Angular CLI** has
    generated all these files for us with just a few command line statements. In that
    way it makes getting started with an Angular application much smoother and easier.
    It takes the grunt work out of the process and enables us able to build and serve
    our application with minimal effort. In this chapter, we will be focusing on just
    a few files that we will need to touch in order to create our application.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`guessthenumber`目录，你会看到**Angular CLI**已经创建，你会看到大量的文件。一开始这可能会让你感到不知所措，但重要的是要理解**Angular
    CLI**只通过几个命令行语句就为我们生成了所有这些文件。这样，它使得开始使用Angular应用程序变得更加顺畅和容易。它从过程中移除了繁琐的工作，使我们能够以最小的努力构建和提供我们的应用程序。在本章中，我们将专注于我们为了创建应用程序需要接触的几个文件。
- en: If you are running the application in Internet Explorer, there is one file that
    you will need to look at—`polyfill.ts`. This adds various other files that are
    needed to run the application in Internet Explorer. You will need to uncomment
    several sections in that file to add these necessary files. Instructions for doing
    this are contained in the file itself.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用Internet Explorer运行应用程序，你需要查看一个文件——`polyfill.ts`。这个文件添加了运行应用程序在Internet
    Explorer中所需的其他文件。你需要取消注释该文件中的几个部分以添加这些必要的文件。有关如何操作的说明包含在该文件本身中。
- en: Before turning to building out the specifics of our application, let's take
    a look at one of the key files that will be used to get our application up and
    running.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在转向构建我们应用程序的具体细节之前，让我们先看看一个关键的文件，这个文件将用于使我们的应用程序启动和运行。
- en: Downloading the example code
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 下载示例代码
- en: 'The code in this book is available on GitHub at [https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample).
    It is organized in checkpoints that allow you to follow along step by step as
    we build our sample projects in this book. The branch to download for this chapter
    is GitHub''s Branch: checkpoint1.1\. Look in the `guessthenumber` folder for the
    code we are covering here. If you are not using Git, download the snapshot of Checkpoint
    1.1 (a ZIP file) from the following GitHub location: [https://github.com/chandermani/angular6byexample/tree/checkpoint1.1](https://github.com/chandermani/angular6byexample/tree/checkpoint1.1).
    Refer to the `readme.md` file in the `guessthenumber` folder when setting up the
    snapshot for the first time.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的代码可在GitHub上找到，网址为[https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample)。它组织成检查点，允许你跟随我们的步骤逐步构建本书中的示例项目。本章要下载的分支是GitHub的分支：checkpoint1.1。在`guessthenumber`文件夹中查找我们在这里覆盖的代码。如果你不使用Git，请从以下GitHub位置下载Checkpoint
    1.1的快照（ZIP文件）：[https://github.com/chandermani/angular6byexample/tree/checkpoint1.1](https://github.com/chandermani/angular6byexample/tree/checkpoint1.1)。在设置快照时，请参考`guessthenumber`文件夹中的`readme.md`文件。
- en: The host file - index.html
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主文件 - index.html
- en: 'Navigate to the `src` folder in the `guessthenumber` directory and open `index.html`.
    You will see the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到`guessthenumber`目录中的`src`文件夹并打开`index.html`。你会看到以下内容：
- en: '[PRE4]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`index.html` is the host file for our application. It will be launched by the
    browser when the application is first run and will host the components in our
    application. If you have any exposure to web development, most of the HTML code
    in this file should look familiar . It has standard `html`, `head`, and `body`
    tags along with a couple of optional tags, one a meta tag for the viewport, which
    configures how the app will display in a mobile device, and the other a link to
    an Angular favicon image that will display on the tab in the browser in which
    the application is loaded.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html`是我们应用程序的主文件。当应用程序首次运行时，浏览器将启动它，并托管我们的应用程序组件。如果你有任何接触过Web开发，这个文件中的大部分HTML代码应该看起来很熟悉。它有标准的`html`、`head`和`body`标签，以及几个可选标签，其中一个是一个viewport的meta标签，它配置了应用程序在移动设备上的显示方式，另一个是链接到Angular
    favicon图像的链接，该图像将在加载应用程序的浏览器标签中显示。'
- en: Custom element
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义元素
- en: 'However, there is one more important tag on the page that may not look as familiar
    to you:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，页面上还有一个可能对你来说不那么熟悉的标签：
- en: '[PRE5]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This tag is a **custom element**. It instructs Angular where to inject the component
    that we will be building.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个标签是一个**自定义元素**。它指示Angular将我们构建的组件注入到何处。
- en: '*Guess the Number!* and all the other apps that are part of this book have
    been tested against the Angular 6 final release.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*猜数字游戏!* 以及本书中的所有其他应用程序都已针对 Angular 6 最终版本进行了测试。'
- en: The component file
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件文件
- en: Now let's turn to building out the specifics of our application. Given the previous
    discussion of the component pattern, you will not be surprised that to do this
    we will be constructing a component.  In this case our application will be simple
    enough that we will need only one component (later in this book you will see the
    use of multiple components as we build more complex applications). The Angular
    CLI has already given us a start by generating a component file for us. Of course,
    that file does not contain any of the particulars of our application, so we will
    have to modify it. To do that navigate to the `src` folder in the `app` directory
    and open `app.component.ts`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向构建我们应用程序的具体细节。鉴于之前对组件模式的讨论，你不会对这样做需要构建一个组件感到惊讶。在这种情况下，我们的应用程序足够简单，我们只需要一个组件（在本书的后面部分，你将看到在构建更复杂的应用程序时使用多个组件）。Angular
    CLI 已经为我们生成了一个组件文件。当然，该文件不包含我们应用程序的任何特定细节，因此我们需要对其进行修改。为此，导航到 `app` 目录下的 `src`
    文件夹并打开 `app.component.ts`。
- en: The import statement
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入语句
- en: 'At the top of the page, you will find the following line:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面顶部，你会找到以下行：
- en: '[PRE6]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is an import statement. It tells us what modules we will be loading and
    using in our component. In this case, we are selecting one module that we need
    to load from Angular: `Component`. Angular has many other modules, but we load
    only what we need.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个导入语句。它告诉我们将在组件中加载和使用哪些模块。在这种情况下，我们正在选择从 Angular 加载的一个模块：`Component`。Angular
    有许多其他模块，但我们只加载所需的模块。
- en: You'll notice that the location from which we are importing is not identified
    as a path or directory within our application. Instead, it is identified as `@angular/core`.
    Angular has been divided into barrel modules that are prefixed with `@angular`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，我们导入的位置并没有被标识为应用程序中的路径或目录。相反，它被标识为 `@angular/core`。Angular 已经被划分为以 `@angular`
    为前缀的桶模块。
- en: These barrels combine several modules that are logically related. In this case,
    we are indicating that we want to import the `core` barrel module, which in turn
    brings in the `Component` module.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这些桶组合了逻辑上相关的几个模块。在这种情况下，我们表示我们想要导入 `core` 桶模块，它反过来又引入了 `Component` 模块。
- en: The Angular documentation describes a barrel as**:**A way to roll up exports from
    several ES2015 modules into a single convenient ES2015 module. The barrel itself
    is an ES2015 module file that re-exports selected exports of other ES2015 modules.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 文档将桶描述为**：**一种将多个 ES2015 模块的导出汇总到一个方便的 ES2015 模块中的方法。桶本身是一个 ES2015 模块文件，它重新导出其他
    ES2015 模块的选定导出。
- en: For more information about barrels, see [https://angular.io/guide/glossary#barrel](https://angular.io/guide/glossary#barrel).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于桶（barrel）的信息，请参阅 [https://angular.io/guide/glossary#barrel](https://angular.io/guide/glossary#barrel)。
- en: Decorator
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器
- en: 'Next, replace the code block that starts with `@Component` with the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将开始于 `@Component` 的代码块替换为以下内容：
- en: '[PRE7]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is the decorator for our component and it is placed directly above the
    class definition, which we will discuss soon. The `@` symbol is used to identify
    a decorator. The `@Component` decorator has a property called selector, and you
    may not be surprised to see that it is set to the `<app-root>` tag in our HTML
    page. This setting tells Angular to inject this component into that tag on the
    HTML page.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的组件装饰器，它直接放置在类定义之上，我们将在稍后讨论。`@` 符号用于标识装饰器。`@Component` 装饰器有一个名为 selector
    的属性，你可能会惊讶地看到它被设置为我们的 HTML 页面中的 `<app-root>` 标签。这个设置告诉 Angular 将此组件注入到 HTML 页面中的该标签。
- en: The decorator also has a property called `template`, and this property identifies
    the HTML markup for our component. Notice the use of back ticks (introduced by
    ES2015) for rendering the template string over multiple lines. Alternatively,
    we can set a `templateUrl` property that would point to a separate file.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器还有一个名为 `template` 的属性，这个属性用于标识我们组件的 HTML 标记。注意这里使用了反引号（由 ES2015 引入）来在多行中渲染模板字符串。或者，我们也可以设置一个
    `templateUrl` 属性，它将指向一个单独的文件。
- en: Defining the class
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义类
- en: 'Now replace the code block that begins with  `export class AppComponent` with
    the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将开始于 `export class AppComponent` 的代码块替换为以下内容：
- en: '[PRE8]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you have been developing in ES5, the version of JavaScript that is supported
    in all current browsers, you may not be familiar with the use of classes here.
    So, we will take a few moments to walk through what makes up a class (for those
    of you who have developed using an object-oriented programming language, such
    as C# or Java, this should be familiar territory).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直在使用 ES5 开发，这是所有当前浏览器都支持的 JavaScript 版本，你可能不熟悉这里类的使用。因此，我们将花几分钟时间来解释一下类由什么组成（对于那些使用面向对象编程语言（如
    C# 或 Java）进行开发的你们来说，这应该是一个熟悉的地方）。
- en: The class file holds the code that we will use to run our component. At the
    top, we give the class a name, which is `AppComponent`. Then, inside the curly
    braces, we have four lines that declare the properties for our class. These are
    similar to ES5 variables, and we will use them to hold the values that we will
    need to run the application (you'll notice that these are the four values that
    we identified when we designed our component).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 类文件包含我们将用于运行组件的代码。在顶部，我们给类一个名字，它是 `AppComponent`。然后，在括号内，我们有四行声明了我们类的属性。这些类似于
    ES5 变量，我们将使用它们来保存我们需要运行应用程序的值（你会注意到这些是我们设计组件时确定的四个值）。
- en: What makes these properties different from standard JavaScript variables is
    that each property name is followed by `:` and a number. These set the type of
    the property. In this case, we are indicating that each of these four properties
    will be set to the number type, which means we are expecting the values of all
    of these properties to be numbers. The ability to specify types for our properties
    is provided by TypeScript and it is not available in standard JavaScript.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性与标准 JavaScript 变量不同的地方在于，每个属性名称后面跟着 `:` 和一个数字。这些设置了属性的类型。在这种情况下，我们表明这四个属性将被设置为数字类型，这意味着我们期望所有这些属性的值都是数字。为我们的属性指定类型的能力是由
    TypeScript 提供的，而在标准 JavaScript 中不可用。
- en: As we move down, we will see three blocks of script that have names, followed
    by parentheses, and then curly braces with several lines of script inside them.
    These are the methods for our class, and they contain the operations that our
    component will support. They are a lot like standard JavaScript functions.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们向下移动，我们将看到三个带有名称的脚本块，后面跟着括号，然后是包含多行脚本的括号。这些是我们类的函数，它们包含我们的组件将支持的运算。它们与标准的
    JavaScript 函数非常相似。
- en: The first of these methods is `constructor()`, which is a special method that
    will run when an instance of our component is first created. In our example, the
    constructor does only one thing when the class is created; it calls another method
    in our class, called `initializeGame()`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法中的第一个是 `constructor()`，这是一个特殊的方法，当我们的组件实例首次创建时将会运行。在我们的例子中，当类被创建时，构造函数只做了一件事；它调用我们类中的另一个方法，称为
    `initializeGame()`。
- en: The `initializeGame()` method sets the starting values of the four properties
    in the class using the assignment operator `=`. We set these values to `null`
    or `zero`, except for `original`, in which we use a random number generator to
    create the number to be guessed.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`initializeGame()` 方法使用赋值运算符 `=` 设置类中四个属性的起始值。我们将这些值设置为 `null` 或 `zero`，除了
    `original`，我们使用随机数生成器来创建要猜测的数字。'
- en: The class holds one more method called `verifyGuess()`, which updates the `deviation`
    and `noOfTries` properties. This method is not being called from within the component
    class; instead, it will be called from the view, as we will see when we examine
    the view more closely later. You'll also notice that our methods refer to properties
    in the same class by prepending `this` to them.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 该类还包含一个名为 `verifyGuess()` 的方法，该方法更新 `deviation` 和 `noOfTries` 属性。这个方法不是在组件类内部被调用的；相反，它将从视图中被调用，正如我们稍后更仔细地检查视图时将会看到的。你也会注意到，我们的方法通过在它们前面添加
    `this` 来引用同一类中的属性。
- en: The module file
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块文件
- en: As we mentioned earlier, every Angular component must be contained within an
    Angular module. This means that at a minimum we must add at least one Angular
    module file to the root of our application. We call this the **root module**.
    For a simple application like *Guess the Number!*, the root module may be the
    only module we will need. However, as an Angular application increases in size,
    it will often make sense to have multiple Angular module files broken down by
    features. We will cover that situation as we move into building more complex applications
    in later chapters in this book.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，每个Angular组件都必须包含在一个Angular模块中。这意味着我们至少必须在应用程序的根目录中添加至少一个Angular模块文件。我们称这个为**根模块**。对于像“猜数字！”这样的简单应用程序，根模块可能就是我们所需要的唯一模块。然而，随着Angular应用程序规模的增加，通常有多个按功能划分的Angular模块文件是有意义的。随着我们在本书后面的章节中构建更复杂的应用程序，我们将讨论这种情况。
- en: 'Let''s go ahead and take a look at our Angular module file. Again the Angular
    CLI has created this file for us. Open `app.module.ts` in the `app` directory
    within the `src` folder and you will see the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续查看我们的Angular模块文件。同样，Angular CLI已经为我们创建了此文件。在`src`文件夹中的`app`目录下打开`app.module.ts`，你会看到以下内容：
- en: '[PRE9]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first two statements import `BrowserModule` and `NgModule`. Notice that,
    while `NgModule` is being imported from `@angular/core`, `BrowserModule` is being
    imported from a different module: `@angular/platform-browser`. What's significant
    here is that the import is not coming from `@angular/core`, but from a separate
    module that is specific to browser-based applications. This is a reminder that
    Angular can support devices other than browsers, such as mobile devices, hence
    the need to place `BrowserModule` into a separate module.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个语句导入了`BrowserModule`和`NgModule`。注意，虽然`NgModule`是从`@angular/core`导入的，但`BrowserModule`是从一个不同的模块导入的：`@angular/platform-browser`。这里重要的是，导入不是来自`@angular/core`，而是来自一个专门针对基于浏览器的应用程序的独立模块。这是一个提醒，Angular可以支持除浏览器以外的设备，因此需要将`BrowserModule`放入一个单独的模块中。
- en: The other import in this file is our component `AppComponent`. If you go back
    to that component you will notice that `export` is added in front of the class
    definition, which means we are using module loading within our own application.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件中的另一个导入是我们自己的组件`AppComponent`。如果你回到那个组件，你会注意到在类定义前添加了`export`，这意味着我们正在使用我们自己的应用程序中的模块加载。
- en: We next define a new component `AppModule`.  There is nothing in the class itself
    other than a few imports and a decorator: `@ngModule`. We can use this decorator
    to configure the module in our application. The first property is declarations
    and with that property we provide an array of the components that will be used
    in our application. In this case, we have just one component: `AppComponent`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个新的组件`AppModule`。在类本身中除了几个导入和一个装饰器`@ngModule`之外，没有其他内容。我们可以使用这个装饰器来配置我们的应用程序模块。第一个属性是声明，通过这个属性我们提供了一个数组，其中包含了将在我们的应用程序中使用的组件。在这种情况下，我们只有一个组件：`AppComponent`。
- en: We next add imports, which in this case include the `BrowserModule`. As the
    name suggests, this module will provide the functionality needed to run our application
    in a browser. The next property is `providers`. This property is used to register
    providers (such as services and other objects) that will be available to be used
    throughout our application through dependency injection. We have no need for providers
    in the simple application we are building here, so this property is empty. We
    will be discussing providers and dependency injection in detail in [Chapter 3](part0117.html#3FIHQ0-7edc9b1e1ea341adae33006323903887),
    *More Angular – SPA, Routing*.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加了导入，其中包含`BrowserModule`。正如其名所示，这个模块将提供在浏览器中运行我们的应用程序所需的功能。下一个属性是`providers`。这个属性用于注册提供者（如服务和其他对象），这些提供者将通过依赖注入在整个应用程序中可用。在我们构建的简单应用程序中，我们没有必要使用提供者，因此这个属性是空的。我们将在[第3章](part0117.html#3FIHQ0-7edc9b1e1ea341adae33006323903887)“更多Angular
    – SPA，路由”中详细讨论提供者和依赖注入。
- en: Finally, we set the `bootstrap` property. This indicates the first component
    that will be loaded when our application starts up. Again this is the `AppComponent`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们设置了`bootstrap`属性。这表示当我们的应用程序启动时将首先加载的第一个组件。再次强调，这是`AppComponent`。
- en: With this configuration in place, we are now ready to bootstrap our component.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配置就绪后，我们现在可以引导我们的组件了。
- en: Bootstrapping
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引导启动
- en: The class definition for `AppComponent` operates as a blueprint for the component,
    but the script inside it does not run until we have created an instance of the
    component. In order to run our application then, we need something in our application that
    creates this instance. The process of doing that requires us to add code that
    bootstraps our component.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppComponent`的类定义作为组件的蓝图，但其中的脚本在创建组件实例之前不会运行。为了运行我们的应用，我们需要在应用中添加一些代码来启动组件。完成这个过程需要我们添加启动组件的代码。'
- en: 'In the `src` folder, look for a file named `main.ts`. Open it and you will
    see the following code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src`文件夹中，寻找一个名为`main.ts`的文件。打开它，您将看到以下代码：
- en: '[PRE10]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, we are importing `enableProdMode` from `@angular/core` and the 
    `platformBrowserDynamic` module from `@angular/platform-browser-dynamic`. Like
    the import of `BrowseModule` in the `appModule` file, this latter import is specifically
    for browser-based applications. Next we add an import of our `AppModule` and a
    file called `environment` that is located in the `environments` directory of our
    application.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在从`@angular/core`导入`enableProdMode`，以及从`@angular/platform-browser-dynamic`导入`platformBrowserDynamic`模块。就像在`appModule`文件中导入`BrowseModule`一样，这个后者的导入专门用于基于浏览器的应用。接下来，我们添加了对我们的`AppModule`和一个位于应用`environments`目录中的名为`environment`的文件的导入。
- en: In the next lines of code we check to see if the constant `environment` in the `environment` file has
    its `production` property set to `true`, and if so, call `enableProdMode()`, which
    as the name suggests enables production mode. The default setting for `environment.production` is
    `false`, which is fine for our purposes here since we are not running the application
    in production mode.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的代码行中，我们检查`environment`文件中的常量`environment`是否将其`production`属性设置为`true`，如果是，则调用`enableProdMode()`，正如其名称所暗示的，这将启用生产模式。`environment.production`的默认设置是`false`，这对于我们的目的来说很合适，因为我们不是在生产模式下运行应用。
- en: If you open `environments.ts`, you will see some comments that provide guidance
    for overwriting the settings in this file as part of the build process. We won't
    be covering the Angular build process until [Chapter 2](part0065.html#1TVKI0-7edc9b1e1ea341adae33006323903887),
    *Building Our First App – 7 Minute Workout*; so we won't cover that material here.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打开`environments.ts`，您将看到一些注释，这些注释提供了在构建过程中覆盖此文件设置的指导。我们不会在[第2章](part0065.html#1TVKI0-7edc9b1e1ea341adae33006323903887)“构建我们的第一个应用
    – 7分钟健身”中涵盖Angular的构建过程；因此，我们在这里不会涉及该材料。
- en: Finally, we call the `platformBrowserDynamic().boostrapModule` method with our `AppModule` as
    a parameter. The `bootstrapModule` method then creates a new instance of our `AppModule` component,
    which in turn initializes our `AppComponent`, which we have marked as the component
    to bootstrap. It does that by calling our component's constructor method.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`platformBrowserDynamic().boostrapModule`方法并传入我们的`AppModule`作为参数。然后，`bootstrapModule`方法创建了一个新的`AppModule`组件实例，它反过来初始化我们的`AppComponent`，这是我们标记为启动组件的。它是通过调用我们组件的构造函数方法来做到这一点的。
- en: We're up and running!
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们已经启动并运行了！
- en: 'Well, the app is complete and ready to be tested! From the `guessthenumber`
    directory again type the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，应用已经完成，准备进行测试！再次从`guessthenumber`目录中输入以下命令：
- en: '[PRE11]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The app should appear on your browser.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 应用应该会出现在您的浏览器上。
- en: If you are having trouble running the app, you can check out a working version
    available on GitHub at [https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample). If
    you are not using Git, download the snapshot of Checkpoint 1.1 (a ZIP file) from
    the following GitHub location: [https://github.com/chandermani/angular6byexample/tree/checkpoint1.1](https://github.com/chandermani/angular6byexample/tree/checkpoint1.1).
    Refer to the `readme.md` file in the `guessthenumber` folder when setting up the
    snapshot for the first time
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在运行应用时遇到困难，可以在GitHub上查看可用的工作版本，链接为[https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample)。如果你不使用Git，可以从以下GitHub位置下载Checkpoint
    1.1的快照（ZIP文件）：[https://github.com/chandermani/angular6byexample/tree/checkpoint1.1](https://github.com/chandermani/angular6byexample/tree/checkpoint1.1)。在首次设置快照时，请参考`guessthenumber`文件夹中的`readme.md`文件。
- en: If we glance at our component file and template, we should be mightily impressed
    with what we have achieved. We are not writing any code to update the UI when
    the application is running. Still, everything works perfectly.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们浏览一下组件文件和模板，我们应该会对我们所取得的成就感到非常震撼。我们在应用运行时并没有编写任何代码来更新UI。尽管如此，一切运行得都非常完美。
- en: Digging deeper
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入挖掘
- en: To understand how this app functions in the Angular context, we need to delve
    a little deeper into our component. While the class definition in the component
    is pretty simple and straightforward, we need to look more closely at the HTML
    in the template to understand how Angular is working here. It looks like standard
    HTML with some new symbols, such as `[ ]`, `( )`, `{{`, and `}}`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这个应用程序在Angular环境中的工作方式，我们需要更深入地了解我们的组件。虽然组件中的类定义非常简单直接，但我们需要更仔细地查看模板中的HTML，以了解Angular在这里是如何工作的。它看起来像标准的HTML，但有一些新的符号，如
    `[ ]`、`( )`、`{{` 和 `}}`。
- en: 'In the Angular world, these symbols mean the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular的世界里，这些符号的含义如下：
- en: '`{{` and `}}` are interpolation symbols'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{{` 和 `}}` 是插值符号'
- en: '`[ ]` represents property bindings'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[ ]` 表示属性绑定'
- en: '`( )` represents event bindings'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( )` 表示事件绑定'
- en: Clearly, these symbols have some behavior attached to them and seem to be linking
    the view HTML and component code. Let's try to understand what these symbols actually
    do.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这些符号有一些附加的行为，并且似乎将视图HTML和组件代码连接起来。让我们尝试理解这些符号实际上做什么。
- en: Interpolation
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插值
- en: 'Look at this HTML fragment from the template in  `app.component.ts`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看 `app.component.ts` 模板中的此HTML片段：
- en: '[PRE12]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The term `noOfTries` is sandwiched between two interpolation symbols. Interpolation
    works by replacing the content of the interpolation markup with the value of the
    expression (`noOfTries`) inside the interpolation symbol. In this case, `noOfTries`
    is the name of a component property. So the value of the component property will
    be displayed as the contents inside the interpolation tags.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 术语 `noOfTries` 被夹在两个插值符号之间。插值通过将插值标记的内容替换为插值符号内表达式的值（`noOfTries`）来实现。在这种情况下，`noOfTries`
    是一个组件属性的名称。因此，组件属性的值将显示为插值标签内的内容。
- en: 'Interpolations are declared using this syntax: `{{expression}}`. This expression
    looks similar to a JavaScript expression, but is always evaluated in the context
    of the component. Notice that we did not do anything to pass the value of the
    property to the view. Instead, the interpolation tags read the value of the property
    directly from the component without any need for additional code.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 插值使用以下语法声明：`{{expression}}`。这个表达式看起来类似于JavaScript表达式，但总是在组件的上下文中进行评估。请注意，我们没有做任何事情来传递属性的值到视图中。相反，插值标签直接从组件中读取属性的值，而不需要任何额外的代码。
- en: Tracking changes in the number of tries
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪尝试次数的变化
- en: 'Another interesting aspect of interpolation is that changes made to component
    properties are automatically synchronized with the view. Run the app and make
    some guesses; the `noOfTries` value changes after every guess and so does the
    view content:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 插值的一个有趣方面是，对组件属性的更改会自动与视图同步。运行应用程序并做出一些猜测；每次猜测后，`noOfTries` 的值都会改变，视图内容也会相应改变：
- en: '![](img/00006.jpeg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00006.jpeg)'
- en: Interpolation is an excellent debugging tool in scenarios where we need to see
    the state of the model. With interpolation, we don't have to put a breakpoint
    in code just to know the value of a component property. Since interpolation can
    take an expression, we can pass a component's method call or a property and see
    its value.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们需要查看模型状态的场景中，插值是一个出色的调试工具。有了插值，我们不必在代码中设置断点，只需知道组件属性的值。由于插值可以接受表达式，我们可以传递组件的方法调用或属性并查看其值。
- en: Expressions
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式
- en: Before going any further, we need to spend a few moments understanding what
    template expressions are in Angular.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们需要花几分钟时间来理解Angular中的模板表达式是什么。
- en: 'Template expressions in Angular are nothing but pieces of plain JavaScript
    code that are evaluated in the context of the component instance associated with
    the template in which they are used. But as the documentation at [https://angular.io/docs/ts/latest/guide/template-syntax.html#template-expressions](https://angular.io/docs/ts/latest/guide/template-syntax.html#template-expressions) makes
    it clear, there are some differences:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Angular中的模板表达式不过是用于在它们使用的模板上下文中评估的纯JavaScript代码片段。但正如[https://angular.io/docs/ts/latest/guide/template-syntax.html#template-expressions](https://angular.io/docs/ts/latest/guide/template-syntax.html#template-expressions)文档所明确指出的，有一些差异：
- en: Assignment is prohibited
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赋值是被禁止的
- en: The `new` operator is prohibited
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new` 运算符是被禁止的'
- en: The bitwise operators `|` and `&` are not supported
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按位运算符 `|` 和 `&` 不受支持
- en: Increment and decrement operators, `++` and `--`, aren't supported
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增量和减量运算符 `++` 和 `--` 不受支持
- en: Template expression operators, such as `|` and `?.`, add new meanings
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板表达式运算符，如 `|` 和 `?.`，添加了新的含义
- en: 'In the light of our discussion on component-based design, you probably won''t
    be surprised to learn that the documentation also makes some things clear; template
    expressions cannot:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于组件的设计讨论中，您可能不会对文档也明确了一些事情感到惊讶；模板表达式不能：
- en: Refer to anything in the global namespace
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用全局命名空间中的任何内容
- en: Refer to a window or document
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用窗口或文档
- en: Call `console.log`
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `console.log`
- en: Instead, these expressions are confined to the expression context, which is
    typically the component instance supporting a particular template.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，这些表达式被限制在表达式上下文中，这通常是支持特定模板的组件实例。
- en: 'However, these limitations do not stop us from doing some nifty stuff with
    expressions. As we can see in the following examples, these all are valid expressions:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些限制并不会阻止我们用表达式做一些巧妙的事情。正如我们可以在以下示例中看到，这些都是有效的表达式：
- en: '[PRE13]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Having looked into expressions, we strongly advise you to keep your expressions
    simple, thus keeping the HTML readable. The `*ngIf="formHasErrors()"` expression
    is always better than `*ng-if="name==null || email==null || emailformatInValid(email)
    || age < 18"`. So, when an expression starts to become complex, move it into a
    method in your component.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了表达式之后，我们强烈建议您保持表达式简单，这样可以使 HTML 更易于阅读。`*ngIf="formHasErrors()"` 表达式总是比 `*ng-if="name==null
    || email==null || emailformatInValid(email) || age < 18"` 更好。因此，当表达式开始变得复杂时，请将其移动到组件中的方法中。
- en: The safe navigation operator
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全导航操作符
- en: 'Before we move on there is one other expression that we should touch on: the
    Angular safe navigation operator (`?.`). This operator provides a convenient way
    to check for null values in lengthy property paths, like so:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，还有一个其他表达式我们应该讨论一下：Angular 安全导航操作符 (`?.`)。这个操作符提供了一个方便的方式来检查长属性路径中的空值，如下所示：
- en: '[PRE14]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If the safe navigation operator finds a null value (here the customer), it stops
    processing the path, but lets the application continue running. Without it, the
    application will crash when it reaches anything after the first null (here the
    customer name) and the view will not display. The safe navigation operator is
    especially helpful in situations where you are loading data asynchronously and
    it might not be immediately available to the view. The safe navigation operator
    will prevent the application from crashing and then load the data when it is available.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果安全导航操作符发现空值（这里指客户），它会停止处理路径，但允许应用程序继续运行。如果没有它，应用程序在到达第一个空值（这里指客户名称）之后将会崩溃，视图将不会显示。安全导航操作符在您异步加载数据且数据可能无法立即提供给视图的情况下特别有用。安全导航操作符将防止应用程序崩溃，并在数据可用时加载数据。
- en: Data binding
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据绑定
- en: Learning interpolation and expressions was easy. Now let's look at another framework
    construct that is being used by our sample app-data binding. We will be covering
    data binding in far more detail in the upcoming chapters. At this point, we will
    just touch briefly on the bindings that are used in the sample app we are building.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 学习插值和表达式很容易。现在让我们看看另一个框架结构，即我们示例应用中使用的数据绑定。我们将在接下来的章节中更详细地介绍数据绑定。在此阶段，我们只是简要地讨论我们正在构建的示例应用中使用的绑定。
- en: Property binding
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性绑定
- en: If we look through the template in `app.component.ts`, we will see several places
    where square brackets `[ ]` are used. These are **property bindings**.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看 `app.component.ts` 中的模板，我们会看到几个使用方括号 `[ ]` 的地方。这些都是**属性绑定**。
- en: 'Let''s look at the first of the bindings that we created:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们创建的第一个绑定：
- en: '[PRE15]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This binding works by linking the value of the `guess` property in our component
    class to the `value` of the input field in the view. The binding is dynamic; so,
    as the value of the `guess` property changes, the `value` of the input field will
    be synchronized to the same value; and we do not have to write any code to do
    that.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这种绑定通过将组件类中 `guess` 属性的值与视图中的输入字段的 `value` 相链接来实现。绑定是动态的；因此，当 `guess` 属性的值发生变化时，输入字段的
    `value` 也会同步到相同的值；我们不需要编写任何代码来做这件事。
- en: At the outset, when we initialize the game, this property is set to null in
    the initialization method of the component class, so we will not see anything
    in the input field. However, as the game progresses, this number will be updated
    with the value of the guess as it changes.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在一开始，当我们初始化游戏时，这个属性在组件类的初始化方法中被设置为 null，所以我们不会在输入字段中看到任何内容。然而，随着游戏的进行，这个数字将随着猜测值的变化而更新。
- en: Event binding
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件绑定
- en: Looking again at the template in `app.component.ts`, we find several places
    where parentheses `( )` appear. These are **event bindings**.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 再次查看 `app.component.ts` 中的模板，我们发现有几个地方出现了括号 `( )`。这些是 **事件绑定**。
- en: 'Let''s look at the HTML code line that we created for the first of these event
    bindings. It should be familiar since the event binding is on the same tag that
    we first looked at for property binding: the `input` tag:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们为这些事件绑定中的第一个创建的 HTML 代码行。它应该很熟悉，因为事件绑定是在我们最初查看属性绑定时相同的标签上：`input` 标签：
- en: '[PRE16]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this case, the `input` event of the input element is bound to an expression.
    The expression sets the `guess` property in our component class to `$event.target.value`,
    which is the value being entered by the user. Behind the scenes, when we use this
    syntax, Angular sets up an event handler for the event that we are binding to.
    In this case, the handler updates the `guess` property in our component class
    whenever the user enters a number in the `input` field.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，输入元素的 `input` 事件绑定到一个表达式上。该表达式将我们的组件类中的 `guess` 属性设置为 `$event.target.value`，这是用户输入的值。在幕后，当我们使用这种语法时，Angular
    为我们绑定的事件设置了一个事件处理器。在这种情况下，每当用户在 `input` 字段中输入一个数字时，处理器就会更新我们的组件类中的 `guess` 属性。
- en: 'There are a couple of other places in our code where the `( )` parentheses
    appear:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中还有其他几个地方出现了 `( )` 括号：
- en: '[PRE17]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: These two event bindings tie the `click` events for the buttons on the screen
    to methods in our component. So in this case, behind the scenes, Angular sets
    up event handlers that bind directly to the methods in our component. When the
    Verify button is clicked, the `verifyGuess` method is called, and when the Restart
    button is clicked, the `initializeGame` method is called.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个事件绑定将屏幕上按钮的 `click` 事件绑定到我们的组件中的方法。因此在这种情况下，在幕后，Angular 设置了直接绑定到我们的组件中方法的处理器。当点击验证按钮时，会调用
    `verifyGuess` 方法，而当点击重启按钮时，会调用 `initializeGame` 方法。
- en: As you work through the samples in this book, you will see many places where
    the `[]` tags for property bindings are combined with the `()` tags for events.
    In fact, this pairing is so common that, as we will see later, Angular has come
    up with a shorthand syntax to combine these tags into one.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在你通读这本书的示例时，你会看到很多将属性绑定中的 `[]` 标签与事件绑定中的 `()` 标签结合的地方。事实上，这种配对如此常见，以至于我们稍后将会看到，Angular
    已经想出了一个简写语法来将这些标签合并为一个。
- en: Structural directives
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构指令
- en: 'Next, we''ll examine something that looks similar to data binding but incorporates
    an Angular feature that we haven''t seen before: **structural directives**:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将检查一些看起来类似于数据绑定但结合了之前我们没有见过的 Angular 功能的东西：**结构指令**：
- en: '[PRE18]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`*ngIf` inside the `<p>` tags is the `NgIf` structural directive. Structural
    directives allow us to manipulate the structure of DOM elements. The `NgIf` directive
    removes or adds DOM elements based on the result of an expression that is assigned
    to it.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`<p>` 标签内的 `*ngIf` 是 `NgIf` 结构指令。结构指令允许我们操作 DOM 元素的结构。`NgIf` 指令根据分配给它的表达式的结果来删除或添加
    DOM 元素。'
- en: The asterisk `*` in front of `ngIf` is a simplified syntax that Angular, under
    the hood, expands into `ng-template`, which is Angular's implementation of the
    Web Components template that we discussed earlier. We'll be learning a lot more
    about this syntax and about structural directives in the next chapter.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `ngIf` 中的星号 `*` 是 Angular 在底层扩展为 `ng-template` 的简化语法，而 `ng-template` 是 Angular
    对我们之前讨论过的 Web Components 模板的实现。我们将在下一章中学习更多关于这种语法和结构指令的内容。
- en: In this case we are using `NgIf` with a simple expression, similar to the types
    of expression we saw with interpolation. The expression resolves to either `true`
    or `false` based on the value of the guess being made and its relation (higher,
    lower, or equal) to the correct number. It then assigns that result to `NgIf`,
    which will either add the DOM element if the result is `true` or remove it if
    it is `false`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用 `NgIf` 与一个简单的表达式，类似于我们看到的插值表达式。该表达式根据猜测的值及其与正确数字的关系（更高、更低或相等）解析为
    `true` 或 `false`。然后它将该结果分配给 `NgIf`，这将根据结果为 `true` 时添加 DOM 元素，为 `false` 时删除它。
- en: Revisiting our app
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视我们的应用
- en: 'So now that we have looked more closely at what makes up our view, let''s take
    another look at our app when it is up and running. When we run our app, Angular
    binding starts up once the browser has rendered the raw HTML in our view. The
    framework then compiles this view template and, in the process, sets up the necessary
    binding. Next, it does the necessary synchronization between our component class
    and the view template that produces the final rendered output. The following screenshot
    depicts the transformations that happen to the view template after data binding
    is done for our app:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经更仔细地研究了构成我们视图的内容，让我们再次看看我们的应用程序在运行时的样子。当我们运行应用程序时，Angular绑定会在浏览器渲染我们视图中的原始HTML后启动。然后，框架编译这个视图模板，在这个过程中设置必要的绑定。接下来，它在我们组件类和视图模板之间进行必要的同步，以生成最终的渲染输出。以下截图展示了在为我们应用程序完成数据绑定后视图模板所发生的转换：
- en: '![](img/00007.jpeg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00007.jpeg)'
- en: We can ourselves see the untransformed view template of the app (what is shown
    on the left-hand side of the preceding screenshot) by removing the three `*ngIf` directives
    and the expressions assigned to them from the paragraphs below the input box and
    refreshing the app in the browser.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过从输入框下方的段落中移除三个`*ngIf`指令及其分配的表达式，并在浏览器中刷新应用程序，来查看应用程序未转换的视图模板（如前一个截图左侧所示）。
- en: Angular differs from other template frameworks, in that these bindings between
    a component and its view are live. Changes made to the properties of the component
    update the view. Angular never regenerates the HTML; it just works on the relevant
    part of the HTML and updates only the HTML elements that need to change as component
    properties change. This data binding capability makes Angular an exceptional view
    templating engine too.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Angular与其他模板框架不同，其组件与其视图之间的绑定是动态的。对组件属性的更改会更新视图。Angular永远不会重新生成HTML；它只是在HTML的相关部分上工作，并仅更新需要根据组件属性更改而更改的HTML元素。这种数据绑定能力使Angular成为一个卓越的视图模板引擎。
- en: Looking at how our code handles updates
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看我们的代码如何处理更新
- en: 'If we go back and look at the code for our class, we will see that the properties
    and methods in the class do not directly reference the view. Instead, the methods
    simply operate on the properties in the class. As a consequence, the code for
    our class is more readable, hence more maintainable (and of course, testable):'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾一下我们类的代码，我们会看到类中的属性和方法并不直接引用视图。相反，方法只是对类中的属性进行操作。因此，我们类的代码更易于阅读，因此更易于维护（当然，可测试）：
- en: '![](img/00008.jpeg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00008.jpeg)'
- en: So far, we have discussed how Angular updates the view based on changes in a
    component's properties. This is an important concept to understand as it can save
    us from countless hours of debugging and frustration. The next section is dedicated
    to learning about change detection and how these updates are managed.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了Angular如何根据组件属性的更改来更新视图。这是一个重要的概念，因为它可以让我们避免无数小时的调试和挫败感。下一节将专门介绍变更检测以及这些更新是如何管理的。
- en: Maintaining state
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 维护状态
- en: First, let's look at how we maintain state in our Angular application. Since
    Angular apps are dynamic and not static, we need to understand the mechanisms
    that are used to make sure that these dynamic values are kept up to date as the
    data in an application gets updated. For example, in our application, how does
    the number of guesses get updated on the screen? How does the application decide
    to display the correct message about whether the guess is correct based on the
    user input?
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何在我们的Angular应用程序中维护状态。由于Angular应用程序是动态的而不是静态的，我们需要了解确保这些动态值随着应用程序数据的更新而保持更新的机制。例如，在我们的应用程序中，屏幕上的猜测次数是如何更新的？应用程序是如何根据用户输入决定显示关于猜测是否正确的正确消息的？
- en: Component as the container for state
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件作为状态的容器
- en: Since we have been emphasizing so far that Angular uses the component design
    pattern, you will probably not be surprised to know that the basic container for
    the application state is the component itself. This means that when we have a
    component instance, all the properties in the component and their values are available
    for the template instance that is referenced in the component. At a practical
    level, this means that we can use these values directly in expressions and bindings
    in the template without having to write any plumbing code to wire them up.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们之前一直在强调Angular使用组件设计模式，因此你可能不会对知道应用程序状态的基本容器是组件本身而感到惊讶。这意味着当我们有一个组件实例时，组件中的所有属性及其值都可用于组件中引用的模板实例。在实践层面，这意味着我们可以在模板中直接使用这些值，而不需要编写任何管道代码来连接它们。
- en: 'In the sample app, for example, to determine what message to display, we can
    use `deviation` directly in the template expression. Angular will scan our component
    to find a property with that name and use its value. The same is true for `noOfTries`;
    Angular will look for the value of this property within our component and then
    use it to set its value in the interpolation within the template. We don''t have
    to write any other code:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在示例应用中，为了确定要显示的消息，我们可以在模板表达式中直接使用`deviation`。Angular会扫描我们的组件以找到具有该名称的属性并使用其值。对于`noOfTries`也是如此；Angular将在我们的组件内查找该属性的值，然后将其用于在模板的插值中设置其值。我们不需要编写任何其他代码：
- en: '[PRE19]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Change detection
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变更检测
- en: So how does Angular keep track of changes in our component as it runs? So far,
    it appears as if this is all done by magic. We just set up our component properties
    and methods, and then we bind them to the view using interpolation along with
    property and event binding. Angular does the rest!
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，Angular是如何在运行时跟踪我们组件中的变更的呢？到目前为止，这似乎都是通过魔法完成的。我们只是设置了组件属性和方法，然后通过插值以及属性和事件绑定将它们绑定到视图上。Angular完成其余的工作！
- en: But this does not happen by magic, of course, and in order to make effective
    use of Angular, you need to understand how it updates these values as they change.
    This is called **change detection**, and Angular has a very different approach
    to doing this than what previously existed.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 但这当然不是魔法发生的，为了有效地使用Angular，你需要了解它是如何随着这些值的变化而更新它们的。这被称为**变更检测**，Angular在执行这一操作时与之前的方法非常不同。
- en: 'If you use the debugger tool in your browser to walk through the application,
    you will see how change detection works. Here, we are using Chrome''s Developer
    tools and setting a watch for the `noOfTries` property. If you place a breakpoint
    at the end of the `verifyGuess()` method, you will see that when you enter a guess,
    the `noOfTries` property is first updated as soon as you hit the breakpoint, as
    follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用浏览器中的调试工具遍历应用程序，你会看到变更检测是如何工作的。在这里，我们使用Chrome的开发者工具并监视`noOfTries`属性。如果你在`verifyGuess()`方法的末尾设置断点，你会看到当你输入一个猜测时，`noOfTries`属性会立即在到达断点时更新，如下所示：
- en: '![](img/00009.jpeg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![图片2](img/00009.jpeg)'
- en: 'Once you move past the breakpoint, the display on the screen updates with the
    correct number of guesses, as seen in the following screenshot:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你越过断点，屏幕上的显示将更新为正确的猜测次数，如下面的截图所示：
- en: '![](img/00010.jpeg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](img/00010.jpeg)'
- en: What is really going on under the hood is that Angular is reacting to events
    in the application and using change detectors, which go through every component,
    to determine whether anything has changed that affects the view. In this case,
    the event is a button click. The event generated by the button click calls the
    `verifyGuess()` method on the component that updates the `noOfTries` property.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在引擎盖下真正发生的事情是，Angular正在响应应用程序中的事件，并使用变更检测器，这些检测器遍历每个组件，以确定是否有任何影响视图的变更发生。在这种情况下，事件是一个按钮点击。按钮点击生成的事件在组件上调用`verifyGuess()`方法，以更新`noOfTries`属性。
- en: That event triggers the change detection cycle, which identifies that the `noOfTries`
    property that is being used in the view has changed. As a result, Angular updates
    the element in the view that is bound to `noOfTries` with the new value of that
    property.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 该事件触发了变更检测周期，该周期识别出在视图中使用的`noOfTries`属性已更改。因此，Angular使用该属性的新值更新绑定到`noOfTries`的视图中的元素。
- en: As you can see, this is a multistep process where Angular first updates the
    components and domain objects in response to an event, then runs change detection,
    and finally rerenders elements in the view that have changed. And, it does this
    on every browser event (as well as other asynchronous events, such as XHR requests
    and timers). Change detection in Angular is reactive and one way.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这是一个多步骤的过程，其中 Angular 首先根据事件更新组件和域对象，然后运行变更检测，最后重新渲染已更改的视图元素。而且，它会在每个浏览器事件（以及其他异步事件，如
    XHR 请求和定时器）上执行此操作。Angular 的变更检测是响应式的且单向的。
- en: This approach allows Angular to make just one pass through the change detection
    graph. It is called **one-way data binding**, and it vastly improves the performance
    of Angular.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法允许 Angular 只通过一次遍历变更检测图。这被称为 **单向数据绑定**，并且极大地提高了 Angular 的性能。
- en: We'll be covering Angular change detection in depth in Chapter 8, *Some Practical
    Scenarios*. For a description of this process by the Angular team, visit [https://vsavkin.com/two-phases-of-angular-2-applications-fda2517604be#.fabhc0ynb](https://vsavkin.com/two-phases-of-angular-2-applications-fda2517604be#.fabhc0ynb).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第8章“一些实用场景”中深入探讨 Angular 的变更检测。要了解 Angular 团队对这一过程的描述，请访问 [https://vsavkin.com/two-phases-of-angular-2-applications-fda2517604be#.fabhc0ynb](https://vsavkin.com/two-phases-of-angular-2-applications-fda2517604be#.fabhc0ynb)。
- en: Tools
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具
- en: 'Tools make our lives easy, and we are going to share some tools that will help
    you with different aspects of Angular development, from code writing to debugging:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 工具使我们的生活变得简单，我们将分享一些工具，这些工具将帮助你在 Angular 开发的不同方面，从代码编写到调试：
- en: '**Visual Studio Code**: This is a new IDE that Microsoft has developed ([https://code.visualstudio.com/](https://code.visualstudio.com/)).
    It provides excellent IntelliSense and code completion support for Angular and
    TypeScript. Visual Studio 2017 ([https://www.visualstudio.com/](https://www.visualstudio.com/))
    also includes support for Angular and TypeScript.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio Code**: 这是 Microsoft 开发的新 IDE ([https://code.visualstudio.com/](https://code.visualstudio.com/))。它为
    Angular 和 TypeScript 提供了出色的 IntelliSense 和代码补全支持。Visual Studio 2017 ([https://www.visualstudio.com/](https://www.visualstudio.com/))
    也包括对 Angular 和 TypeScript 的支持。'
- en: '**IDE extensions**: Many of the popular IDEs on the market have plugins/extensions
    that make Angular development easy for us. Examples include:'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IDE 扩展**: 市面上许多流行的 IDE 都有插件/扩展，使 Angular 开发变得容易。例如：'
- en: '**JetBrains WebStorm**: [https://www.jetbrains.com/webstorm/](https://www.jetbrains.com/webstorm/)'
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JetBrains WebStorm**: [https://www.jetbrains.com/webstorm/](https://www.jetbrains.com/webstorm/)'
- en: '**Angular2 Snippets for Sublime Text**: [https://github.com/evanplaice/angular2-snippets](https://github.com/evanplaice/angular2-snippets) and
    the **TypeScript plugin for Sublime** [https://github.com/Microsoft/TypeScript-Sublime-Plugin](https://github.com/Microsoft/TypeScript-Sublime-Plugin)'
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Angular2 Snippets for Sublime Text**: [https://github.com/evanplaice/angular2-snippets](https://github.com/evanplaice/angular2-snippets)
    以及 **Sublime Text 的 TypeScript 插件** [https://github.com/Microsoft/TypeScript-Sublime-Plugin](https://github.com/Microsoft/TypeScript-Sublime-Plugin)'
- en: '**Angular 2 TypeScript snippets for Atom** [https://atom.io/packages/angular-2-typescript-snippets ](https://atom.io/packages/angular-2-typescript-snippets)and
    the **TypeScript** plugin forAtom: [https://atom.io/packages/atom-typescript](https://atom.io/packages/atom-typescript)'
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Angular 2 TypeScript snippets for Atom** [https://atom.io/packages/angular-2-typescript-snippets](https://atom.io/packages/angular-2-typescript-snippets)
    和 **Atom 的 TypeScript 插件** [https://atom.io/packages/atom-typescript](https://atom.io/packages/atom-typescript)'
- en: 'The **Angular language service**: One of the exciting new Developer tools,
    it provides auto-completions, error checking, and F12 navigation inside Angular
    templates that are placed in component decorators or external HTML files. You
    can find installation instructions and more information about the service at [https://angular.io/guide/language-service](https://angular.io/guide/language-service).'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Angular 语言服务**：这是一款令人兴奋的新开发者工具，它为放置在组件装饰器或外部 HTML 文件中的 Angular 模板提供自动补全、错误检查和
    F12 导航。您可以在 [https://angular.io/guide/language-service](https://angular.io/guide/language-service)
    找到安装说明和有关该服务的更多信息。'
- en: '**Browser developer console**: All current browsers have excellent capabilities
    when it comes to JavaScript debugging. Since we are working with JavaScript, we
    can put in breakpoints, add a watch, and do everything that is otherwise possible
    with JavaScript. Remember that a lot of errors with code can be detected just
    by looking at the browser''s console window.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浏览器开发者控制台**：所有当前浏览器在 JavaScript 调试方面都有出色的功能。由于我们使用 JavaScript，我们可以设置断点、添加监视，并执行所有其他使用
    JavaScript 可能执行的操作。请记住，许多代码错误仅通过查看浏览器的控制台窗口就可以检测到。'
- en: '**Augury** ([https://augury.angular.io/](https://augury.angular.io/)): This
    is a Chrome Dev Tools extension for debugging Angular applications.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Augury** ([https://augury.angular.io/](https://augury.angular.io/))：这是一个用于调试Angular应用程序的Chrome
    Dev Tools扩展。'
- en: 'Component vendors are starting to offer support for Angular as well. For example,
    Telerik has released Kendo UI for Angular: [http://www.telerik.com/kendo-angular-ui/](http://www.telerik.com/kendo-angular-ui/).'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件供应商也开始提供对Angular的支持。例如，Telerik发布了Kendo UI for Angular：[http://www.telerik.com/kendo-angular-ui/](http://www.telerik.com/kendo-angular-ui/).
- en: Resources
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源
- en: 'Angular is a new framework, but already a vibrant community is starting to
    emerge around it. Together with this book, there are also blogs, articles, support
    forums, and plenty of help. Some of the prominent resources that will be useful
    are explained as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: Angular是一个新的框架，但已经有一个充满活力的社区开始围绕它形成。与这本书一起，还有博客、文章、支持论坛以及大量的帮助。以下是一些有用的突出资源：
- en: '**Framework code and documentation**: The Angular documentation can be found
    at [https://angular.io/docs](https://angular.io/docs). Then, there is always the
    Angular source code, a great source of learning. It can be found at [https://github.com/angular/angular](https://github.com/angular/angular).'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**框架代码和文档**：Angular的文档可以在[https://angular.io/docs](https://angular.io/docs)找到。然后，还有Angular的源代码，这是一个很好的学习资源。它可以在[https://github.com/angular/angular](https://github.com/angular/angular)找到。'
- en: '**The Angular team''s blog**: You can refer to the Angular team''s blog for
    more information about Angular at [https://blog.angular.io/](https://blog.angular.io/).'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Angular团队博客**：您可以通过Angular团队博客了解有关Angular的更多信息，网址为[https://blog.angular.io/](https://blog.angular.io/).'
- en: '**Awesome Angular**: **A curated list of awesome Angular resources**: This
    is a community-driven effort that is maintained at [https://github.com/gdi2290/awesome-angular](https://github.com/gdi2290/awesome-angular).'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Awesome Angular**：**精选的Angular资源列表**：这是一个由社区驱动的努力，维护在[https://github.com/gdi2290/awesome-angular](https://github.com/gdi2290/awesome-angular).'
- en: '**The Angular gitter chat room** (**[https://gitter.im/angular/angular](https://gitter.im/angular/angular)**)is
    very active. Also check out **Angular** on **Reddit**: [https://www.reddit.com/r/Angular](https://www.reddit.com/r/Angular).'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Angular gitter聊天室** (**[https://gitter.im/angular/angular](https://gitter.im/angular/angular)**)非常活跃。同时，您也可以在**Reddit**上查看**Angular**的相关内容：[https://www.reddit.com/r/Angular](https://www.reddit.com/r/Angular).'
- en: '**The Angular Google group** ([https://groups.google.com/forum/#!forum/angular](https://groups.google.com/forum/#!forum/angular))
    and **the Stack Overflow channel** ([http://stackoverflow.com/questions/tagged/Angular](http://stackoverflow.com/questions/tagged/Angular)):
    Head over here if you have any questions or are stuck with some issue.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Angular Google群组** ([https://groups.google.com/forum/#!forum/angular](https://groups.google.com/forum/#!forum/angular))和**Stack
    Overflow频道** ([http://stackoverflow.com/questions/tagged/Angular](http://stackoverflow.com/questions/tagged/Angular))：如果您有任何问题或遇到某些问题，请前往这里。'
- en: '**Angular Expo** ([http://angularexpo.com/](http://angularexpo.com/)): People
    have  created some amazing apps using Angular. This site showcases such apps,
    and most of them have source code available for us to take a look at.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Angular Expo** ([http://angularexpo.com/](http://angularexpo.com/))：人们使用Angular创建了一些令人惊叹的应用程序。这个网站展示了这些应用程序，其中大部分都提供了可供我们查看的源代码。'
- en: That's it! The chapter is complete and it's now time to summarize what you've
    learned.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！这一章已经完成，现在是时候总结您所学的内容了。
- en: Summary
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The journey has started and we have reached the first milestone. Despite this
    chapter being named *Getting Started*, we have covered a lot of concepts that
    you will need to know in order to understand the bigger picture. Your learning
    was derived from our *Guess the Number!* app, which we built and dissected throughout
    the chapter.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 旅程已经开始，我们已经达到了第一个里程碑。尽管这一章名为“入门”，但我们已经涵盖了您为了理解整体概念所需了解的大量概念。您的学习来自于我们构建并剖析整章的“猜数字”应用程序。
- en: You learned how Angular implements the component design pattern using the emerging
    standards for Web Components, along with the latest versions of JavaScript and
    TypeScript. We also reviewed some of the constructs that are used in Angular,
    such as interpolation, expressions, and the data binding syntax. Finally, we took
    a look at change detection and some useful tools and resources that will help
    you get started with Angular development.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 您学习了Angular如何使用Web Components的兴起标准和JavaScript和TypeScript的最新版本来实现组件设计模式。我们还回顾了Angular中使用的一些结构，例如插值、表达式和数据绑定语法。最后，我们探讨了变更检测以及一些有助于您开始Angular开发的实用工具和资源。
- en: The groundwork has been laid, and now we are ready for some serious app development
    on the Angular framework. In the next chapter, we will start working on a more
    complex exercise and expose ourselves to a number of new Angular constructs.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 基础工作已经完成，现在我们准备在 Angular 框架上进行一些严肃的应用程序开发。在下一章中，我们将开始处理一个更复杂的练习，并接触许多新的 Angular
    构造。
