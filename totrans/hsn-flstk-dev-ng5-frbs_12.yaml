- en: Firebase Security and Hosting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Firebase provides flexible security rules with a JavaScript-like syntax, as
    this helps to structure our data and index the frequently used data. Security
    rules are integrated with Firebase authentication, which helps to define read
    and write access based on the user. In this chapter, we will add security rules
    for users and chat nodes to our Firebase database. Firebase security rules provide
    a nice simulator to check new rules before releasing them into production. We
    will also index our user's and their friends data for faster queries. Finally,
    we will deploy our application to the Firebase server. We will set up a different
    deployment environment so that we can test our application in the staging server
    and then deploy the application to the production server.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Firebase security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding security rules for users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding security rules for chat messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indexing users and their friends
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up multiple deployment environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hosting the friends app in Firebase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Firebase security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Firebase security provides tools to manage the security of our application,
    as we can add rules and validate inputs for our data in the Firebase database.
    Firebase provides the following security for our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication**: The first step to secure our application is to identify
    the user. Firebase authentication supports multiple authentication mechanisms,
    such as Google, Facebook, email, and password authentication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authorization**: Once the user is authenticated, we will need to control
    the access to data in our database. Firebase security rules has built-in variables
    and functions, such as an `auth` object, as it helps to control read and write
    operations for users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go to the Firebase portal and navigate to Database|RULES tab. The default Firebase
    security rule is as follows; the `auth!= null` condition means that only authenticated
    users have access to data in the Firebase database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00057.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Firebase security rules provides the following four types of functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.read`: We can define this function for the data and control the user''s read
    operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example shows that only a logged-in user can read their own user
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`.write`: We define this for the data and control the user''s write operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example shows that only a logged-in user can write on their own
    user data node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`.validate`: This function maintains the integrity of the data, and this variable
    provides data validation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example validates the `name` field to be a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`.indexOn`: This provides a child index for the querying and ordering of data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following example, we index the `name` field of user data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Firebase security rules also provide the following predefined variables, which
    are used to define the security rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`root`: This variable gives a `RuleDataSnapshot` instance to access data from
    the root of the Firebase database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following root variables are used to traverse the Firebase database path
    from the root user node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`newData`: This variable provides a `RuleDataSnapshot` instance that represents
    the new data, which exists after the insert operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example validates the new data to be a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`data`: This variable gives a `RuleDataSnapshot` instance that represents the
    data that exists before the insert operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example shows that the current data in the `name` field is not
    null:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`$variables`: This variable represents the dynamic IDs and keys.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following example, the unique ID is assigned to the `$uid` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`auth`: This represents the `auth` object, which provides the UID of the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following example, we access the `auth` object to get a UID of a user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`now`: This variable provides the current time in milliseconds and helps to
    validate the time stamp.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following example, we conclude that the time stamp is greater than the
    current time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Adding security rules for users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our application, users' details play a critical part, so we need to provide
    security rules for our users' details. We have already seen the default settings
    for security. By default, only an authenticated user can access any part of our
    Firebase database. We will modify the security rules for the user node and retain
    the default security rules for the other nodes for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from the following screenshot, for `users` node, `read` and
    `write` operations are allowed for an authentic user with the same unique user
    ID; we will also need to validate the type of data in our user node to maintain
    the data integrity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00058.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To validate the changes in our security rules, Firebase provides a simulator
    to test our changes before deploying it into production. You will see a SIMULATOR
    option on the top-right corner of the RULES tab. This tool provides the mock operation
    without actually performing any CRUD operation within the database. We will test
    the following scenarios on the simulator:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Successful read operation for an authentic user**: Open the simulator and
    enable the Authenticated switch button; it provides a mock uid in the Auth token
    payload text box. In the Location text box, we enter the path as `/users/6e115890-7802-4f56-87ed-4e6ac359c2e0`
    and click on the RUN button. This operation will be successful when the Simulated
    read allowed message appears, as shown in the following screenshot:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00059.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Successful write operation with an authentic user and proper data**: In this
    scenario, we will provide a location path with the user UID with the string name
    data as JSON payload in the simulator. When we click on RUN, this operation is
    considered successful when the Simulated write allowed message appears, as shown
    in the following screenshot. Also, the succeeding screenshots show two ticks,
    which indicates that our authorization and data validation have been successful.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00060.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Failed write operation with a different UID**: In this scenario, we provide
    a wrong UID in the user path location and then perform the same write operation.
    This operation fails, resulting in a Simulated write denied message and a cross
    on the write tag, as follows; you can take a look at more error details by clicking
    on the DETAILS button:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00061.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Failed write operation with data validation:** In this scenario, we provide
    the correct user UID path in Location but the wrong data type in payload. For
    example, we will give number data type for a string name data. This operation
    fails in data validation tag, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00062.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Adding security rules for chat messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will enable the security rules for chat messages. The message
    details node contains two identifiers, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$identifierKey`: The first is the identifier key, which is used for users
    under conversation, and this key is also stored in the user details node. In the
    following example, `"-L-0uxNuc6gC95iQytu9"` is the identifier key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$messageKey`: The second is the message key, which is generated when we push
    a new message in the node. In the following example, `"-L-125Am3LVQQQiN_xlG"`
    is the message key:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We will define the following security rules for a message details node:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Read permission**: We give read permission only to the authentic users'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Write permission**: We give write permission to authentic users and also
    check whether any new data exists before the data push happens'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Validation**: We validate all the fields in the message so that data integrity
    is maintained for any new data insertion, as shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00063.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, we will validate the new rules in the simulator to check whether they
    work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00064.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Indexing users and friends
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Firebase provides the querying and ordering of data upon collection of the nodes
    using any common child key. This query becomes slow when the data grows. To increase
    the performance, the Firebase recommends that you index within a particular child
    field. Firebase indexes the key to the server to increase the performance of the
    query.
  prefs: []
  type: TYPE_NORMAL
- en: 'As part of this section, we will implement an index on our user data to search
    or find friends, which is quite common in any social application. To achieve this,
    we will perform the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating an index within the name field of the user data**: We provide an
    index within the name field of our user data. We will use the `.indexOn` tag for
    the name field, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00065.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Creating a service for querying the data based on the text**: In this task,
    we will query the user data based on the search text. We will provide `orderByChild` as
    the name field of the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s the `friends-search.service.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '**Modifying the template**: We modify the app template to show the search result
    in the drop-down menu below the search text.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s the modified `app.component.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '**Modifying the component**: When an app component is loaded the we query for
    all the user in `ngOnInit()` method and when user click in search text box then
    user list appears with all the names. We also filter the list with the user type
    on the text box and then the `onSearch()` method is called and we query the Firebase
    database with the query range.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s the complete `app.component.ts` file as of now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `\uf8ff` characters is a very high code point in the unicode range, which
    allows you to match all values that start with your search text.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up multiple environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When our application is ready to deploy, we will need to separate the Firebase
    projects for the development and production environments so that we can test our
    code changes in a development environment before deploying them into production.
    We will follow these steps to set up a separate environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a new staging project in Firebase**: Because we cannot use the same
    Firebase features, such as database and storage, we will need to separate the
    production and staging environments. We will then create a new project with the `friends-staging` name; this
    project has the new Firebase environment variables:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00066.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Creating a new environment variable**: The new Firebase project has a new
    environment variable, and you can get configuration from the Firebase project.
    So, navigate to Project Overview | Project settings | Add Firebase to your web
    app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Copy the content into the new environment file, as shown in the following code; we
    have two environment files for staging and production:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `environment.prod.ts` file with production is set as `true`, and this is
    used for the production environment:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `environment.ts` file with production is set as `false`; this will be used
    for the staging environment:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '**Installing Firebase tools**: Once you create a new Firebase project, you
    will need to install the Firebase tools and log into the Firebase portal with
    the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will open your Gmail permission page; clicking on ALLOW will
    give permission to list all the available projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00067.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Using the new Firebase project**: Once we give permission, we will need to
    add the available project based on the current environment in use. Suppose that
    we need to test a new feature under development, we can select a staging environment
    and give the alias name for the staging environment for future use. We can switch
    the environment using the alias name, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates the `.firebaserc` file in the base project directory, which looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Hosting the friends app in Firebase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Firebase supports hosting as a service, and application deployment is easy
    in Firebase. Most applications adopt a two-stage deployment, that is, first staging
    and then production. Once we test the application in the staging environment,
    we can deploy it into the production environment. The steps to deploy an application
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first is to build the application, which creates a `dist` folder that has `index.html`
    and other required files. You can build for production just by adding a `--prod`
    option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to initialize the application project. We will execute the
    init command and select the Firebase features using the space key in the command
    prompt; for our friends application, we will use the database, storage, and hosting
    features of Firebase, and when we select the respective features, it creates a
    default database and storage rules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'It also creates the `firebase.json` file, which looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we deploy our application using the following command; once our application
    is deployed, we can take a look at the deployed application in the Firebase hosting
    our project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The deployed application appears in the Firebase portal. You can see the deployed
    application in the Firebase portal by navigating to  DEVELOP | Hosting, and on
    the right panel Domain and Deployment history appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00068.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, you can open your live application using the following command or
    by pasting the URL as [https://friends-staging.firebaseapp.com](https://friends-staging.firebaseapp.com):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the Firebase security mechanism. We added security
    rules for our friends application database to make our application more secure.
    We indexed the `name` field of our user node for our database so that the search
    query became faster. We then used a search API in our friends application. Finally,
    we created multiple environments for our application so that we were able to separate
    staging from production. We then deployed our application on to Firebase.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about Firebase cloud messaging, Google analytics,
    and ads.
  prefs: []
  type: TYPE_NORMAL
