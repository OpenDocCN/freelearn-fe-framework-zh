- en: Following Best Practices and Developing MERN Further
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遵循最佳实践并进一步开发MERN
- en: In this chapter, we will elaborate on some of the best practices to apply when
    building the six MERN applications in this book. Additionally, we will explore
    other practices that we have not applied in this book but that should be considered
    for real-world applications to ensure reliability and scalability as complexity
    grows. We will review the decisions behind organizing the project code in modules,
    the approaches to applying frontend styling, server-side rendering with data only
    for selective views, and how React interfaces may be composed to manage state
    across components. We will also look at ways to improve security, add testing
    to the projects, and optimize bundling with webpack. Finally, we will wrap up
    with suggestions for enhancing, and steps for extending, the applications built.
    With these insights, you will be better equipped to prepare your full-stack MERN
    projects for the real world.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细阐述在构建本书中的六个MERN应用程序时应应用的一些最佳实践。此外，我们还将探讨本书未应用但应考虑用于实际应用的其它实践，以确保随着复杂性的增长，可靠性和可扩展性。我们将回顾组织项目代码在模块中的决策，应用前端样式的途径，仅对选定视图进行服务器端渲染，以及如何通过React接口来管理组件间的状态。我们还将探讨提高安全性、向项目添加测试以及使用webpack优化打包的方法。最后，我们将总结增强构建的应用程序的建议和扩展步骤。有了这些见解，你将更好地为准备面向现实世界的全栈MERN项目做好准备。
- en: 'The topics covered in this chapter include the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Separation of concerns with modularity in the application structure
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序结构中通过模块化实现关注点分离
- en: Considering the options for CSS styling solutions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑CSS样式解决方案的选项
- en: Server-side rendering with data for selected views
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅对选定视图进行数据的服务器端渲染
- en: Using ES6 classes for stateful versus purely functional components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ES6类来区分有状态组件和纯函数组件
- en: Deciding on whether to use Redux or Flux
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定是否使用Redux或Flux
- en: Security enhancements for storing user credentials
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为存储用户凭据提供安全增强
- en: Writing test code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写测试代码
- en: Optimizing bundle sizes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化包大小
- en: How to add new features to existing applications
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何向现有应用程序添加新功能
- en: Separation of concerns with modularity
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过模块化实现关注点分离
- en: While building the MERN stack applications in this book, we followed a common
    folder structure across each application. We employed a modular approach by dividing
    and grouping the code based on relevance and common functionality. The idea behind
    creating these smaller and distinct sections in the code is to make sure each
    section addresses a separate concern, so individual sections can be reused, as
    well as developed and updated independently. In the following section, we will
    review this structure and its benefits.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书构建MERN堆栈应用程序时，我们遵循了每个应用程序的共同文件夹结构。我们通过根据相关性及共同功能划分和分组代码来采用模块化方法。创建这些较小且独立的代码部分背后的想法是确保每个部分都解决一个单独的问题，这样各个部分就可以被重用，以及独立开发和更新。在下一节中，我们将回顾这个结构和其优势。
- en: Revisiting the application folder structure
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视应用程序文件夹结构
- en: 'In the application folder structure, we kept the client-side and server-side
    code separate with further subdivisions within these two sections. This gave us
    some freedom to design and build the frontend and backend of the application independently.
    At the project root level, the `client` and `server` folders were the main divisions,
    as shown in the following structure:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序文件夹结构中，我们通过在这两个部分内部进行进一步细分，将客户端和服务器端代码分开。这给了我们一定的自由度来独立设计和构建应用程序的前端和后端。在项目根级别，`client`和`server`文件夹是主要的划分，如下所示的结构：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In these `client` and `server` folders, we divided the code further into subfolders
    that mapped to unique functionalities. We did this by dividing models, controllers,
    and routes in the server for specific features, and grouping all components related
    to a feature in one place on the client side. In the following sections, we will
    review the divisions within the `server` and `client` folders.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些`client`和`server`文件夹中，我们将代码进一步细分为映射到独特功能的子文件夹。我们通过在服务器中按特定功能划分模型、控制器和路由，并在客户端将所有与功能相关的组件分组在一个地方来实现这一点。在接下来的章节中，我们将回顾`server`和`client`文件夹内的划分。
- en: Server-side code
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端代码
- en: 'On the server side, we divided the code according to functionality, by separating
    code that defines business models from code implementing routing logic, and controller
    code that responds to client requests at these routes. Within the `server` folder,
    we maintained three main sections, as shown in the following structure:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，我们根据功能划分代码，通过将定义业务模型的代码与实现路由逻辑的代码以及响应这些路由上客户端请求的控制器代码分离。在`server`文件夹中，我们保持了三个主要部分，如下所示的结构：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this structure, each folder contains code with a specific purpose:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种结构中，每个文件夹都包含具有特定目的的代码：
- en: '`models`: This folder is meant to contain all of the Mongoose schema model
    definitions in separate files, with each file representing a single model.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models`：这个文件夹旨在包含所有Mongoose模式模型定义的单独文件，每个文件代表一个单独的模型。'
- en: '`routes`: This folder contains all routes that allow the client to interact
    with the server, with routes placed in separate files that may be associated with
    a model in the `models` folder.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`routes`：这个文件夹包含了所有允许客户端与服务器交互的路由，这些路由被放置在单独的文件中，这些文件可能与`models`文件夹中的某个模型相关联。'
- en: '`controllers`: This folder contains all of the controller functions that define
    logic to respond to incoming requests at the defined routes. These controllers
    are divided into separate files corresponding to the relevant model and route
    files.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`controllers`：这个文件夹包含了所有控制器函数，这些函数定义了响应在定义的路由上接收到的请求的逻辑。这些控制器被分为与相关模型和路由文件对应的单独文件。'
- en: As demonstrated throughout the book, these specific separations of concerns
    for the code on the server side allowed us to extend the server developed for
    the skeleton application by just adding the required model, route, and controller
    files. In the next section, we will go over the divisions in the client-side code
    structure.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如本书中所示，这些针对服务器端代码的具体关注点分离，使我们能够通过仅添加所需的模型、路由和控制器文件来扩展为骨架应用程序开发的服务器。在下一节中，我们将介绍客户端代码结构中的划分。
- en: Client-side code
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端代码
- en: 'The client-side code for the MERN applications consists primarily of React
    components. In order to organize the component code and related helper code in
    a reasonable and understandable manner, we separated the code into folders related
    to a feature entity or unique functionality, as shown in the following structure:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: MERN应用程序的客户端代码主要由React组件组成。为了以合理和可理解的方式组织组件代码和相关辅助代码，我们将代码分离到与功能实体或独特功能相关的文件夹中，如下所示的结构：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding structure, we placed all of the auth-related components and
    helper code in the `auth` folder; common and basic components, such as the `Home` and `Menu`
    components, in the `core` folder; and then we made `post` and `user` folders for
    all of the post-related or user-related components in the respective folders.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的结构中，我们将所有与身份验证相关的组件和辅助代码放在了`auth`文件夹中；常见的和基本的组件，如`Home`和`Menu`组件，放在了`core`文件夹中；然后为所有与帖子相关或用户相关的组件创建了`post`和`user`文件夹。
- en: This separation and grouping of components based on features allowed us to extend
    the frontend views in the skeleton application for each application that followed,
    by adding a new feature-related component code folder, as required, to the `client`
    folder.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这种基于功能分离和组合组件的方法，使我们能够通过向`client`文件夹添加新的与功能相关的组件代码文件夹，按需扩展每个后续应用程序的骨架应用程序的前端视图。
- en: Separating the client and server code, and also modularizing the code within
    these divisions, made it easier to extend the different applications we developed
    throughout the book. In the final section of this chapter, we will further demonstrate the
    advantages of this modularized approach of separating the application code, as
    we outline the general workflow that can be followed to add a new feature to any
    of the existing applications developed in this book. In the next section, we will
    explore the different options available for defining and applying styling to the
    frontend React components, which will be a necessary decision for every full-stack
    MERN project.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 将客户端和服务器代码分离，并在这些分离中模块化代码，使得扩展我们在整本书中开发的不同应用程序变得更加容易。在本章的最后部分，我们将进一步展示这种模块化方法分离应用程序代码的优势，我们将概述可以遵循的一般工作流程，以向本书中开发的任何现有应用程序添加新功能。在下一节中，我们将探讨定义和应用于前端React组件的不同选项，这对于每个全栈MERN项目都是一个必要的决策。
- en: Adding CSS styles
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加CSS样式
- en: When discussing **user interface** (**UI**) implementations for the applications
    in this book, we chose not to focus on the details of the CSS styling code applied
    and instead relied mostly on the default Material-UI stylings. However, given
    that implementing any UI requires us to consider styling solutions, we will briefly
    look at some of the options that are available.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当讨论本书中应用程序的用户界面（UI）实现时，我们选择不关注应用的CSS样式代码的细节，而是主要依赖默认的Material-UI样式。然而，鉴于实现任何UI都需要我们考虑样式解决方案，我们将简要地查看一些可用的选项。
- en: When it comes to adding CSS styles to the frontend, there are a number of options,
    each with pros and cons. In the following sections, we will discuss the two most
    common options, which are external style sheets and inline styles, along with
    the relatively newer approach of writing CSS in JavaScript, or, more specifically,
    JSS, which is used in Material-UI components and hence also for the applications
    in this book.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到向前端添加CSS样式时，有几种选择，每种选择都有其优缺点。在接下来的几节中，我们将讨论两种最常见的选择，即外部样式表和内联样式，以及相对较新的在JavaScript中编写CSS的方法，或者更具体地说，是JSS，它在Material-UI组件中使用，因此也适用于本书中的应用程序。
- en: External style sheets
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部样式表
- en: External style sheets allow us to define CSS rules in separate files, which
    can be injected into the necessary view. Placing CSS styles in external style
    sheets this way was once considered the best practice because it enforced the
    separation of style and content, allowing reusability and also maintaining modularity
    if a separate CSS file was created for each component.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 外部样式表允许我们在单独的文件中定义CSS规则，这些文件可以注入到必要的视图中。以这种方式将CSS样式放在外部样式表中曾经被认为是最佳实践，因为它强制了样式和内容的分离，允许重用，并且如果为每个组件创建单独的CSS文件，还可以保持模块化。
- en: However, as web development technologies continue evolving, the demands of better
    CSS organization and performance are no longer met by this approach. For example,
    using external style sheets while developing frontend views with React components
    limits our control over updating styles based on the component state. Moreover,
    loading external CSS for React applications requires additional webpack configurations
    with `css-loader` and `style-loader`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着Web开发技术的不断发展，更好的CSS组织和性能需求已不再满足这种做法。例如，在用React组件开发前端视图时使用外部样式表限制了我们对基于组件状态更新样式的控制。此外，为React应用程序加载外部CSS需要额外的webpack配置，包括`css-loader`和`style-loader`。
- en: When applications grow and share multiple style sheets, it also becomes impossible
    to avoid selector conflicts because CSS has a single global namespace. Hence,
    though external style sheets may be enough for simple and trivial applications,
    as an application grows, other options for using CSS become more relevant. In
    the next section, we will look at the option of adding styles directly inline.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序增长并共享多个样式表时，由于CSS有一个单一的全球命名空间，因此也变得无法避免选择器冲突。因此，尽管外部样式表可能足够用于简单和琐碎的应用程序，但随着应用程序的增长，使用CSS的其他选项变得更加相关。在下一节中，我们将探讨直接内联添加样式的选项。
- en: Inline styles
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内联样式
- en: Inline CSS is a style defined and applied directly to individual elements in
    the view. Although this takes care of some of the problems faced when using external
    style sheets, such as eliminating the issue of selector conflicts and allowing
    state-dependent styles, it takes away reusability and introduces a few problems
    of its own, such as limiting the CSS features that can be applied.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 内联CSS是直接应用于视图中的单个元素的样式。尽管这解决了一些使用外部样式表时遇到的问题，例如消除选择器冲突问题，并允许基于状态的样式，但它牺牲了可重用性，并引入了一些自身的问题，例如限制了可以应用的CSS功能。
- en: Using only inline CSS for a React-based frontend has important limitations for
    growing applications, such as poor performance because all of the inline styles
    are recomputed at each render, and inline styles are slower than class names,
    to begin with.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用内联CSS进行基于React的前端开发，对于增长中的应用程序来说，有一些重要的限制，例如性能不佳，因为所有的内联样式在每个渲染时都会重新计算，而且内联样式一开始就比类名慢。
- en: Inline CSS may seem like an easy fix in some cases, but it does not serve as
    a good option for overall usage. In the next section, we will explore the option
    to add CSS styles using JavaScript, which addresses some of the issues of using
    inline and external styles.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 内联CSS在某些情况下可能看起来是一个简单的解决方案，但它并不适合整体使用。在下一节中，我们将探讨使用JavaScript添加CSS样式的选项，这解决了使用内联和外部样式的一些问题。
- en: JavaScript Style Sheets (JSS)
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript样式表（JSS）
- en: JSS allows us to write CSS styles using JavaScript in a declarative way. This
    also means that all the features of JavaScript are now available for writing CSS,
    making it possible to write reusable and maintainable styling code.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: JSS允许我们以声明式的方式使用JavaScript编写CSS样式。这也意味着JavaScript的所有功能现在都可以用于编写CSS，使得编写可重用和可维护的样式代码成为可能。
- en: JSS works as a JS to CSS compiler that takes JS objects, where keys represent
    class names and values represent corresponding CSS rules, and then generates the
    CSS along with scoped class names.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: JSS充当一个JS到CSS编译器，它接受JS对象，其中键代表类名，值代表相应的CSS规则，然后生成带有作用域类名的CSS。
- en: In this way, JSS generates unique class names by default when it compiles JSON
    representations to CSS, eliminating the chances of selector conflicts that could
    be faced with external style sheets. Moreover, unlike inline styles, the CSS rules
    that are defined with JSS can be shared across multiple elements and all CSS features
    can be used in the definitions.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，当JSS将JSON表示编译为CSS时，它默认生成唯一的类名，消除了可能遇到的外部样式表的选择器冲突。此外，与内联样式不同，使用JSS定义的CSS规则可以在多个元素之间共享，并且可以在定义中使用所有CSS功能。
- en: Material-UI uses JSS to style its components, and, as a result, we used JSS
    to apply Material-UI themes and also custom CSS to the components developed for
    the frontend views in all of the applications. Based on the utility of each approach,
    you can choose to use one or a combination of external style sheets, inline styles,
    or JSS for styling the frontend of your full-stack application. In the next section,
    we will review the approaches to and relevance of incorporating server-side rendering
    of the React frontend in a full-stack MERN application.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Material-UI使用JSS为其组件设置样式，因此我们使用JSS来应用Material-UI主题，并将自定义CSS应用到所有应用程序的前端视图开发的组件中。根据每种方法的实用性，您可以选择使用外部样式表、内联样式或JSS的组合来为您的全栈应用程序的前端设置样式。在下一节中，我们将回顾在MERN全栈应用程序中集成React前端服务器端渲染的方法及其相关性。
- en: Selective server-side rendering with data
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有数据的选择性服务器端渲染
- en: When we developed the frontend of the base skeleton application in [Chapter
    4](6f2ca10a-8079-4e3a-9d42-a3db8e85b9d9.xhtml), *Adding a React Frontend to Complete
    MERN*, we integrated basic server-side rendering in order to load client-side
    routes directly from the browser address bar when the request went to the server.
    In this server-side rendering implementation, while rendering the React component's
    server-side, we did not consider loading the data from the database for the components
    that displayed data. The data only loads in these components when the client-side
    JavaScript takes over after the initial load of the server side-rendered markup.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[第4章](6f2ca10a-8079-4e3a-9d42-a3db8e85b9d9.xhtml)中开发基础骨架应用程序的前端时，*添加React前端以完成MERN*，我们集成了基本的服务器端渲染，以便在请求发送到服务器时直接从浏览器地址栏加载客户端路由。在这个服务器端渲染实现中，在渲染React组件的服务器端时，我们没有考虑为显示数据的组件从数据库加载数据。数据仅在客户端JavaScript在服务器端渲染标记的初始加载之后接管时才加载到这些组件中。
- en: We did update this implementation to add server-side rendering with data for
    the individual media detail pages in the MERN Mediastream application, which was
    discussed in [Chapter 12](d10817c4-6f74-4ef2-90f4-182466e95b33.xhtml), *Customizing
    the Media Player and Improving the SEO*. In this case, we decided to render this
    specific view with data by injecting data into the server side-generated markup
    of the React frontend. The reasoning behind this selective server-side rendering
    with data only for specific views can be based on certain desired behaviors for
    the view in question, as discussed in the following section.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实更新了这个实现，为MERN Mediastream应用程序中的单个媒体详情页面添加了带有数据的服务器端渲染，这在[第12章](d10817c4-6f74-4ef2-90f4-182466e95b33.xhtml)中讨论过，*定制媒体播放器和改进SEO*。在这种情况下，我们决定通过将数据注入到React前端生成的服务器端标记中，以数据的方式渲染这个特定的视图。这种仅针对特定视图的选择性服务器端渲染数据背后的推理可以基于对所讨论视图的某些期望行为，如下一节所述。
- en: When is server-side rendering with data relevant?
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用带有数据的服务器端渲染相关？
- en: 'Implementing server-side rendering with data for all of the React views in
    an application can get complicated, and will be additional work if we need to
    consider views with client-side authentication or views consisting of multiple
    data sources. In many cases, it may be unnecessary to tackle these complexities
    if the view does not require server-side rendering with data. In order to judge
    whether a view needs to be server-rendered with data, answer the following questions
    for the specific view to make your decision:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的所有 React 视图中实现带有数据的服务器端渲染可能会变得复杂，如果需要考虑具有客户端身份验证的视图或由多个数据源组成的视图，这将是额外的工作。在许多情况下，如果视图不需要带有数据的服务器端渲染，那么处理这些复杂性可能是不必要的。为了判断一个视图是否需要带有数据的服务器端渲染，针对特定的视图回答以下问题以做出决定：
- en: Is it important for the data to be displayed in the initial load of the view
    when JavaScript may not be available in the browser?
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当浏览器中可能没有 JavaScript 时，数据是否需要在视图的初始加载中显示？
- en: Do the view and its data need to be SEO-friendly?
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图及其数据需要 SEO 友好吗？
- en: Loading data in the initial load of the page may be relevant from a usability
    perspective, so it really depends on the use case for the specific view. For SEO,
    server-side rendering with data will give search engines easier access to the
    data content in the view; so, if this is crucial for the view in question, then
    adding server-side rendering with data is a good idea. In the next section, we
    will go over the varied approaches of composing the React frontend in a full-stack
    application.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面初始加载时加载数据可能从可用性角度来看是相关的，所以这实际上取决于特定视图的使用场景。对于 SEO，带有数据的服务器端渲染将使搜索引擎更容易访问视图中的数据内容；因此，如果这对于所讨论的视图至关重要，那么添加带有数据的服务器端渲染是一个好主意。在下一节中，我们将讨论在全栈应用程序中组合
    React 前端的各种方法。
- en: Using stateful versus pure functional components
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用有状态与纯函数组件
- en: While building a UI with React components, composing the views with more stateless
    functional components can make the frontend code manageable, clean, and easier
    to test. However, some components will require the state or life cycle Hooks to
    be more than pure presentational components. In the following sections, we will
    look at what it takes to build stateful and stateless functional React components,
    when to use one or the other, and how often.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 React 组件构建 UI 时，使用更多无状态功能组件来组合视图可以使前端代码易于管理、清洁且易于测试。然而，某些组件将需要状态或生命周期 Hooks
    来成为比纯展示组件更多的组件。在接下来的几节中，我们将探讨构建有状态和无状态功能 React 组件需要什么，何时使用哪一个，以及频率。
- en: Stateful React components with ES6 classes or Hooks
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ES6 类或 Hooks 的有状态 React 组件
- en: We can define stateful React components with ES6 classes or by using Hooks without
    writing a class. React components defined using ES6 classes have access to life
    cycle methods, the `this` keyword, and can manage state with `setState` when building
    stateful components. Similarly, React components defined with a function can also
    access some of these features using Hooks, such as managing state with the `useState` Hook,
    in order to build stateful components.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 ES6 类或通过不编写类的方式使用 Hooks 来定义有状态 React 组件。使用 ES6 类定义的 React 组件可以访问生命周期方法、`this`
    关键字，并在构建有状态组件时使用 `setState` 来管理状态。同样，使用函数定义的 React 组件也可以通过 Hooks 访问一些这些特性，例如使用
    `useState` Hook 来管理状态，以便构建有状态组件。
- en: Stateful components allow us to build interactive components that can manage
    to change data in the state, and propagate any business logic that needs to be
    applied across the UI. Generally, for complex UIs, stateful components should
    be higher-level container components that manage the state of the smaller, stateless
    functional components they are composed of. In comparison, these simpler stateless
    components can be defined as pure functions, as discussed in the next section.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有状态组件使我们能够构建可以管理状态中数据变化并传播需要应用于 UI 的任何业务逻辑的交互式组件。通常，对于复杂的 UI，有状态组件应该是更高级的容器组件，管理它们所组成的较小、无状态功能组件的状态。相比之下，这些更简单的无状态组件可以定义为纯函数，如下一节所述。
- en: Stateless React components as pure functions
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无状态 React 组件作为纯函数
- en: React components can be defined as stateless functional components using the
    ES6 class syntax or as pure functions. The main idea is that a stateless component
    does not modify state and only receives props.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: React 组件可以使用 ES6 类语法或作为纯函数来定义为无状态功能组件。主要思想是，无状态组件不修改状态，只接收 props。
- en: 'The following code defines a stateless component using the ES6 class syntax:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用 ES6 类语法定义了一个无状态组件：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This component, although defined with a class, does not use state. The same
    component can also be defined using JavaScript pure functions, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件虽然是用类定义的，但不使用状态。同样的组件也可以使用 JavaScript 纯函数来定义，如下所示：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: A pure function always gives the same output when given the same input without
    any side effects. Modeling React components as pure functions enforces the creation
    of smaller, more defined, and self-contained components that emphasize UI over
    business logic as there is no state manipulation in these components. These kinds
    of components are composable, reusable, and easy to debug and test. In the next
    section, we will discuss how to combine stateful and stateless components when
    designing the UI.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数在给定相同输入且没有任何副作用的情况下始终给出相同的输出。将 React 组件建模为纯函数强制创建更小、更定义、更自包含的组件，强调 UI 而不是业务逻辑，因为这些组件中没有状态操作。这类组件是可组合的、可重用的，并且易于调试和测试。在下文中，我们将讨论在设计
    UI 时如何组合状态组件和无状态组件。
- en: Designing the UI with stateful components and stateless functional components
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用状态组件和无状态功能组件设计 UI
- en: When thinking about the component composition for a UI, you can design the root
    or a parent component as a stateful component that will contain child components
    or as the composable components that only receive props and cannot manipulate
    state. All the state-changing actions and life cycle issues will be handled by
    the root or parent component, and the changes will be propagated to the child
    components.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当思考 UI 的组件组合时，你可以将根组件或父组件设计为包含子组件的状态组件，或者设计为只接收 props 而不能操作状态的可组合组件。所有状态更改操作和生命周期问题将由根组件或父组件处理，并将更改传播到子组件。
- en: In the applications developed for this book, there is a mixture of stateful
    higher-level components and smaller stateless components. For example, in the
    MERN Social application, the `Profile` component modifies the state for stateless
    child components, such as the `FollowProfileButton` and `FollowGrid` components.
    There is scope for refactoring some of the larger components that were developed
    in this book into smaller, more self-contained components, and this should be
    considered before extending the applications to incorporate more features.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在为本书开发的应用程序中，存在状态组件和较小无状态组件的混合。例如，在 MERN 社交应用中，`Profile` 组件会修改无状态子组件的状态，例如 `FollowProfileButton`
    和 `FollowGrid` 组件。有空间将本书中开发的一些较大组件重构为更小、更自包含的组件，在扩展应用程序以包含更多功能之前应考虑这一点。
- en: The main takeaway that can be applied to new component designs, or when refactoring
    existing components, is that as the React application grows and gets more complex,
    it is better to have more stateless functional components added to higher-level
    stateful components that are in charge of managing state for the inner components.
    In the next section, we will briefly discuss popular libraries and patterns that
    can be utilized on top of React to handle state management across growing React
    applications.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 可以应用于新组件设计或重构现有组件的主要经验教训是，随着 React 应用程序的扩展和复杂化，最好在负责管理内部组件状态的高级状态组件中添加更多无状态功能组件。在下文中，我们将简要讨论可以在
    React 上使用以处理增长中的 React 应用程序状态管理的流行库和模式。
- en: Using Redux or Flux
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Redux 或 Flux
- en: When React applications begin to grow and become more complex, managing communication
    between components can become problematic. When using regular React, the way to
    communicate is to pass down values and callback functions as props to the child
    components. However, this can be tedious if there are a lot of intermediary components
    that the callback must pass through. To address these state communication and
    management-related issues as the React application grows, people turn to use React
    with libraries and architecture patterns such as Redux and Flux.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当 React 应用程序开始增长并变得更加复杂时，管理组件之间的通信可能会变得有问题。在使用常规 React 时，通信的方式是将值和回调函数作为 props
    传递给子组件。然而，如果有很多中间组件需要传递回调，这可能会很繁琐。为了解决随着 React 应用程序增长而出现的这些状态通信和管理相关的问题，人们转向使用带有
    Redux 和 Flux 等库和架构模式的 React。
- en: 'It is outside the scope of this book to delve into the details of integrating
    React with the Redux library or the Flux architecture, but you can consider these
    options for their growing MERN applications while keeping the following in mind:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 本书范围之外，不深入探讨将React与Redux库或Flux架构集成的细节，但在考虑扩展MERN应用程序时，请记住以下几点：
- en: Redux and Flux utilize patterns that enforce changing states in a React application
    from a central location. A trick to avoid using Redux or Flux in React applications
    of manageable sizes is to move all state changes up the component tree to the
    parent components.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux和Flux利用模式强制在React应用程序中从中央位置更改状态。对于可管理的React应用程序，避免使用Redux或Flux的一个技巧是将所有状态更改移动到组件树的上层父组件。
- en: Smaller applications work just as well without Flux or Redux.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 较小的应用程序在没有Flux或Redux的情况下也能正常工作。
- en: You can learn more about using React with Redux at [https://redux.js.org/](https://redux.js.org/),
    and about using React with Flux at [facebook.github.io/flux/](http://facebook.github.io/flux/).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://redux.js.org/](https://redux.js.org/)了解更多关于使用Redux与React结合的信息，以及如何在[facebook.github.io/flux/](http://facebook.github.io/flux/)中使用React与Flux结合。
- en: You can choose to integrate Flux or Redux based on your application size and
    complexity. In the next section, we will discuss the security implementations
    applied to the MERN applications developed in this book and the possible enhancements
    that could be made.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据应用程序的大小和复杂性选择集成Flux或Redux。在下一节中，我们将讨论本书开发的MERN应用程序中应用的安全实现，以及可能进行的改进。
- en: Enhancing security
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强安全性
- en: In the MERN applications developed for this book, we kept the auth-related security
    implementations simple by using **JSON web tokens** (**JWTs**) as an authentication
    mechanism and by storing hashed passwords in the user collection. The approaches
    followed in these implementations are standard practices for adding authentication
    to a web application. However, there are advanced options available for adding
    more layers of security, if that is required for certain applications. In the
    following sections, we will go over the security choices made for building the
    applications in this book and point to possible enhancements.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书开发的MERN应用程序中，我们通过使用**JSON web tokens**（JWTs）作为认证机制，并在用户集合中存储散列密码，使与认证相关的安全实现保持简单。这些实现中遵循的方法是向Web应用程序添加认证的标准做法。然而，如果某些应用程序需要更多的安全层，则还有更高级的选项可供选择。在接下来的章节中，我们将讨论为构建本书中的应用程序所做的安全选择，并指出可能的改进。
- en: JSON web tokens – client-side or server-side storage
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON web tokens – 客户端或服务器端存储
- en: With the JWT authentication mechanism, the client side becomes responsible for
    maintaining the user state. Once the user signs in, the token sent by the server
    is stored and maintained by the client-side code on browser storage, such as `sessionStorage`.
    Hence, it is also up to the client-side code to invalidate the token by removing
    it when a user signs out or needs to be signed out. This mechanism works out well
    for most applications that require minimal authentication to protect access to
    resources. However, for instances where it may be necessary to track user sign-ins,
    sign-outs, and to let the server know that a specific token is no longer valid
    for signing in, just the client-side handling of the tokens is not enough.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JWT认证机制，客户端负责维护用户状态。一旦用户登录，服务器发送的令牌被存储并由客户端代码在浏览器存储中维护，例如`sessionStorage`。因此，客户端代码也有责任在用户注销或需要注销时通过删除令牌来使令牌失效。这种机制对于大多数只需要最小认证来保护资源访问的应用程序来说效果很好。然而，对于可能需要跟踪用户登录、注销，并让服务器知道特定令牌不再有效的情况，仅客户端处理令牌是不够的。
- en: For these cases, the implementation discussed for handling JWT tokens on the
    client side can be extended to storage on the server side as well. In the specific
    case of keeping track of invalidated tokens, a MongoDB collection can be maintained
    by the server to store these invalidated tokens as a reference, which is moderately
    similar to how it is done for storing session data on the server side.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些情况，讨论的客户端JWT令牌处理实现可以扩展到服务器端存储。在特定情况下，为了跟踪已失效的令牌，服务器可以维护一个MongoDB集合来存储这些失效的令牌作为参考，这与在服务器端存储会话数据的方式相似。
- en: The thing to be cautious about and to keep in mind is that storing and maintaining
    auth-related information on both the client and server side may be overkill in
    most cases. Therefore, it is entirely up to the specific use case and the related
    trade-offs to be considered. In the next section, we will review our options for
    storing user passwords securely.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 需要小心的是，在客户端和服务器端存储和维护与身份验证相关的信息在大多数情况下可能是过度行为。因此，这完全取决于具体的用例和相关权衡。在下一节中，我们将回顾我们存储用户密码的安全选项。
- en: Securing password storage
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护密码存储
- en: While storing user credentials for authentication in the user collection, we
    made sure that the original password string provided by the user was never stored
    directly in the database. Instead, we generated a hash of the password along with
    a salt value using the `crypto` module in Node.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户集合中存储用于身份验证的用户凭据时，我们确保用户提供的原始密码字符串从未直接存储在数据库中。相反，我们使用Node中的`crypto`模块生成密码的哈希值和盐值。
- en: 'In `user.model.js` from our applications, we defined the following functions
    to generate the hashed `password` and `salt` values:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序的`user.model.js`中，我们定义了以下函数来生成加密的`password`和`salt`值：
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With this implementation, every time a user enters a password to sign in, a
    hash is generated with the salt. If the generated hash matches the stored hash,
    then the password is correct; otherwise, the password is wrong. So, in order to
    check whether a password is correct, the salt is required, and therefore it is
    stored with the user details in the database along with the hash.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此实现，每次用户输入密码进行登录时，都会使用盐值生成一个哈希值。如果生成的哈希值与存储的哈希值匹配，则密码正确；否则，密码错误。因此，为了检查密码是否正确，需要盐值，因此它将盐值与哈希值一起存储在数据库中，与用户详细信息一起。
- en: This is the standard practice for securing passwords stored for user authentication,
    but there are other advanced approaches that may be explored if a specific application's
    security requirements demand it. Some options that can be considered include multi-iteration
    hashing approaches, other secure hashing algorithms, limiting the number of login
    attempts per user account, and multi-level authentication with additional steps,
    such as answering security questions or entering security codes. These options
    can add more layers of security as needed. In the next section, we will discuss
    options for adding test code in full-stack React applications, which is essential
    for building sturdy production-ready applications.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是保护存储在用户身份验证中的密码的标准做法，但如果有特定的应用程序需要更高级别的安全性，可以探索其他高级方法。可以考虑的一些选项包括多迭代哈希方法、其他安全的哈希算法、限制每个用户账户的登录尝试次数以及多级认证，包括回答安全问题或输入安全代码等额外步骤。根据需要，这些选项可以增加更多安全层。在下一节中，我们将讨论在全栈React应用程序中添加测试代码的选项，这对于构建健壮的生产就绪应用程序至关重要。
- en: Writing test code
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测试代码
- en: Though discussing and writing test code is outside the scope of this book, it
    is a crucial part of developing reliable software. As full-stack JavaScript applications
    become more mainstream over time, the need for better testing capabilities is
    producing a good number of testing tools in this ecosystem. In the following sections,
    we will first look at some of the popular testing tools that are available for
    testing the different parts of a MERN-based application. Then, to help you get
    started with writing test code for the MERN applications developed in this book,
    we will also discuss an example of adding a client-side test to the MERN Social
    application from [Chapter 5](27d3dbdf-0617-4ad8-9dcc-27afa417c174.xhtml), *Growing
    the Skeleton into a Social Media Application*.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然讨论和编写测试代码超出了本书的范围，但它却是开发可靠软件的关键部分。随着全栈JavaScript应用程序越来越主流，对更好的测试能力的需求在这个生态系统中产生了大量测试工具。在接下来的几节中，我们将首先查看一些可用于测试基于MERN应用程序不同部分的流行测试工具。然后，为了帮助您开始编写本书中开发的MERN应用程序的测试代码，我们还将讨论一个将客户端测试添加到第5章中MERN社交应用程序的例子，即*将骨架扩展成社交媒体应用程序*。
- en: Testing tools for full-stack JavaScript projects
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全栈JavaScript项目的测试工具
- en: A whole range of testing tools is available for incorporating testing and maintaining
    code quality in full-stack JavaScript projects. These include tools that can help
    with performing static analysis on the code to maintain readability, and with
    integrating unit testing, integration testing, and end-to-end testing in MERN-based
    applications. In the following sections, we will highlight a few of these popular
    testing tools that can be used with the projects in this book, such as ESLint
    for static analysis, Cypress for frontend testing, and Jest for comprehensive
    testing in JavaScript applications.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于全栈 JavaScript 项目，有一系列测试工具可用于集成测试和维护代码质量。这些工具包括可以帮助执行代码静态分析以保持可读性的工具，以及帮助在
    MERN 基础应用程序中集成单元测试、集成测试和端到端测试的工具。在接下来的几节中，我们将突出介绍一些可用于本书中项目的流行测试工具，例如用于静态分析的 ESLint、用于前端测试的
    Cypress 和用于 JavaScript 应用程序全面测试的 Jest。
- en: Static analysis with ESLint
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ESLint 进行静态分析
- en: A good practice for improving and maintaining code quality is to use a linting
    tool with your project. Linting tools perform static analysis on the code to find
    problematic patterns or behaviors that violate specified rules and guidelines.
    Linting code in a JavaScript project can improve overall code readability and
    also help you to find syntax errors before the code is executed. For linting in
    MERN-based projects, you can explore ESLint, which is a JavaScript linting utility
    that allows developers to create their own lint rules.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 提高和维护代码质量的一个好习惯是使用 linting 工具与您的项目一起使用。linting 工具对代码执行静态分析，以查找违反指定规则和指南的问题模式或行为。在
    JavaScript 项目中进行 linting 可以提高整体代码的可读性，并帮助您在代码执行之前找到语法错误。对于 MERN 基础项目中的 linting，您可以探索
    ESLint，这是一个允许开发者创建自己的 lint 规则的 JavaScript linting 工具。
- en: You can learn more about using and customizing ESLint at [eslint.org](http://esling.org).
    You can choose to use the Airbnb JavaScript Style Guide ([github.com/airbnb/javascript](https://github.com/airbnb/javascript))
    to define your lint rules with `eslint-config-airbnb`**.**
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [eslint.org](http://esling.org) 上了解更多关于使用和自定义 ESLint 的信息。您可以选择使用 Airbnb
    JavaScript 风格指南 ([github.com/airbnb/javascript](https://github.com/airbnb/javascript))，并通过
    `eslint-config-airbnb`**.** 定义您的 lint 规则。
- en: You can configure ESLint in your preferred editor and make it a seamless part
    of your development workflow. This will help you to maintain standards in your
    code while you are writing it. In the next section, we will take a look at Cypress,
    which can help to test any code that runs in the browser.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在您偏好的编辑器中配置 ESLint，并使其成为您开发工作流程中无缝的一部分。这将帮助您在编写代码时保持代码标准。在下一节中，我们将探讨 Cypress，它可以帮助测试在浏览器中运行的任何代码。
- en: End-to-end testing with Cypress
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Cypress 进行端到端测试
- en: Cypress provides a complete set of tools for testing the frontend of modern
    web applications. Using Cypress, we can write end-to-end tests, unit tests, and
    integration tests for the frontend of our MERN-based applications. Cypress also
    provides its own locally installed test runner, allowing us to write and run tests,
    and debug in real time in the browser as we build the application.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Cypress 为测试现代网络应用程序的前端提供了一套完整的工具。使用 Cypress，我们可以为我们的 MERN 基础应用程序的前端编写端到端测试、单元测试和集成测试。Cypress
    还提供自己的本地安装的测试运行器，允许我们在构建应用程序的同时在浏览器中实时编写、运行测试和调试。
- en: You can learn more about using Cypress at [cypress.io](https://www.cypress.io/) to
    get started with setting up end-to-end testing for JavaScript applications in
    the browser.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [cypress.io](https://www.cypress.io/) 上了解更多关于使用 Cypress 的信息，以开始设置在浏览器中为
    JavaScript 应用程序设置端到端测试。
- en: Performing UI testing with Cypress will allow you to ship out your projects
    more confidently, as you will be able to catch more bugs early on before they
    are encountered by the end users of the application. In the next section, we will
    discuss Jest, which can be used to add tests to any JavaScript code base.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Cypress 进行 UI 测试将使您更有信心地发布项目，因为您将能够在最终用户遇到之前更早地捕捉到更多错误。在下一节中，我们将讨论 Jest，它可以用于向任何
    JavaScript 代码库添加测试。
- en: Comprehensive testing with Jest
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Jest 进行全面测试
- en: Jest is a comprehensive testing framework for JavaScript. Although it has been
    more commonly known for testing React components, it can be used for general-purpose
    testing with any JavaScript library or framework. Among the many JavaScript testing
    solutions in Jest, it provides support for mocking and snapshot testing, comes
    with an assertion library, and tests in Jest are written in the **Behavior-Driven
    Development** (**BDD**) style.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 是一个全面的 JavaScript 测试框架。尽管它更常被用于测试 React 组件，但它可以用于任何 JavaScript 库或框架的通用测试。在
    Jest 的众多 JavaScript 测试解决方案中，它提供了模拟和快照测试的支持，附带一个断言库，并且 Jest 中的测试以 **行为驱动开发**（**BDD**）风格编写。
- en: To learn more about Jest, read the documentation at [https://facebook.github.io/jest/docs/en/getting-started.html](https://facebook.github.io/jest/docs/en/getting-started.html).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 Jest 的信息，请阅读位于 [https://facebook.github.io/jest/docs/en/getting-started.html](https://facebook.github.io/jest/docs/en/getting-started.html)
    的文档。
- en: Besides testing the React components, Jest can be also be adapted to write test
    code for the Node-Express-Mongoose-based backend as required. Hence, it is a solid
    testing option to add test code for MERN applications. In the next section, we
    will explore how you can use Jest to add a test to the MERN Social application,
    which was developed in  [Chapter 5](27d3dbdf-0617-4ad8-9dcc-27afa417c174.xhtml),
    *Growing the Skeleton into a Social Media Application*.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 除了测试 React 组件外，Jest 还可以适应编写基于 Node-Express-Mongoose 的后端测试代码。因此，它是为 MERN 应用程序添加测试代码的一个可靠的测试选项。在下一节中，我们将探讨如何使用
    Jest 向在 [第 5 章](27d3dbdf-0617-4ad8-9dcc-27afa417c174.xhtml) 中开发的 MERN 社交应用程序添加测试，该应用程序名为
    *将骨架扩展成社交媒体应用程序*。
- en: Adding a test to the MERN Social application
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向 MERN 社交应用添加测试
- en: In order to demonstrate how to get started with adding tests to MERN applications,
    we will set up Jest and use it to add a client-side test to the MERN Social application.
    Before defining a test case, followed by writing and running the corresponding
    test code, first, we will set up for testing by installing the necessary packages,
    defining the test run script, and creating a folder for the test code, as discussed
    in the following sections.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何开始向 MERN 应用程序添加测试，我们将设置 Jest 并使用它向 MERN 社交应用程序添加客户端测试。在定义测试用例、编写和运行相应的测试代码之前，首先，我们将通过安装必要的包、定义测试运行脚本和创建测试代码文件夹来设置测试环境，如以下章节所述。
- en: Installing the packages
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装包
- en: 'In order to set up Jest and integrate the test code with our projects, we first
    need to install the relevant Node packages. The following packages will be required
    in order to write the test code and run the tests:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置 Jest 并将测试代码与我们的项目集成，我们首先需要安装相关的 Node 包。以下包将用于编写测试代码和运行测试：
- en: '`jest`: To include the Jest testing framework'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jest`：用于包含 Jest 测试框架'
- en: '`babel-jest`: To compile JS code for Jest'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`babel-jest`：用于编译 Jest 的 JS 代码'
- en: '`react-test-renderer`: To create a snapshot of the DOM tree rendered by a React
    DOM without using a browser'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react-test-renderer`：用于创建不使用浏览器的 React DOM 渲染的 DOM 树快照'
- en: 'To install these packages as `devDependencies`, run the following `yarn` command
    from the command line:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要将它们作为 `devDependencies` 安装，请在命令行中运行以下 `yarn` 命令：
- en: '[PRE6]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once these packages are installed, we can start adding tests after configuring
    the test runner script, as discussed in the next section.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了这些包，我们就可以在配置测试运行脚本之后开始添加测试，如下一节所述。
- en: Defining the script to run tests
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义运行测试的脚本
- en: 'In order to run any test code that we write using Jest, we will define a script
    command to run the tests. We will update the run scripts defined in `package.json` in
    order to add a script for running tests with the `jest` command, as shown in the
    following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行我们使用 Jest 编写的任何测试代码，我们将定义一个脚本来运行测试。我们将更新 `package.json` 中定义的运行脚本，以便添加一个使用
    `jest` 命令运行测试的脚本，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With this script defined, if we run `yarn test` from the command line, it will
    prompt Jest to find the test code in the application folders and run the tests.
    In the next section, we will add the folder that will contain the test code files
    for the project.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了此脚本后，如果我们从命令行运行 `yarn test`，它将提示 Jest 在应用程序文件夹中查找测试代码并运行测试。在下一节中，我们将添加包含项目测试代码文件的文件夹。
- en: Adding a tests folder
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加测试文件夹
- en: To add the client-side test in the MERN Social application, we will create a
    folder, called `tests`, in the client folder, which will contain test files relevant
    to testing the React components. When the test command is run, Jest will look
    for the test code in these files.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要在MERN社交应用中添加客户端测试，我们将在客户端文件夹中创建一个名为`tests`的文件夹，该文件夹将包含与测试React组件相关的测试文件。当运行测试命令时，Jest将在这些文件中查找测试代码。
- en: The test case for this example will be a test on the `Post` component in the
    frontend of the MERN Social application, and we will add tests for the `Post`
    component in a file called `post.test.js`. This file will be placed in the `tests`
    folder. Now that we have a file ready for adding the test code, in the next section,
    we will demonstrate how to add an example test case.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的测试用例将是MERN社交应用前端`Post`组件的测试，我们将在名为`post.test.js`的文件中添加对`Post`组件的测试。此文件将放置在`tests`文件夹中。现在我们已经准备好添加测试代码的文件，在下一节中，我们将演示如何添加一个示例测试用例。
- en: Adding the test
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加测试
- en: For the MERN Social application, we will write a test to check whether the delete
    button on a post is only visible when the signed-in user is also the creator of
    the post. This means that the delete button will only be a part of the rendered
    Post view if the `_id` of the authenticated user is the same as the `postedby`
    value of the post data being rendered.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于MERN社交应用，我们将编写一个测试来检查帖子上的删除按钮是否仅在登录用户也是帖子创建者时可见。这意味着如果认证用户的`_id`与正在渲染的帖子数据的`postedby`值相同，则删除按钮才会是渲染的Post视图的一部分。
- en: 'In order to implement this test case, we will add code that takes care of the
    following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现此测试用例，我们将添加处理以下内容的代码：
- en: Defines dummy data for a post and an `auth` object containing authenticated
    user details
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义了一个帖子和一个包含认证用户详情的`auth`对象的虚拟数据
- en: Mocks the methods in `auth-helper.js`
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟`auth-helper.js`中的方法
- en: 'Defines the test, and, within the test definition, does the following:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义测试，并在测试定义中执行以下操作：
- en: Declares the `post` and `auth` variables
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明`post`和`auth`变量
- en: Sets the return value of the mocked `isAuthenticated` method to the dummy `auth`
    object
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将模拟的`isAuthenticated`方法的返回值设置为虚拟`auth`对象
- en: Uses `renderer.create` to create the `Post` component with the required dummy
    props passed and wrapped in `MemoryRouter` to provide the props related to `react-router`
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`renderer.create`创建带有所需虚拟属性并通过`MemoryRouter`包装的`Post`组件，以提供与`react-router`相关的属性
- en: Generates and matches snapshots
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成并匹配快照
- en: 'The code in `post.test.js` to incorporate the steps described for this specific
    test will be as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`post.test.js`中的代码将按照以下步骤进行：'
- en: '[PRE8]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this code, we first defined dummy posts and `auth` objects, and then added
    the test case for checking the visibility of the delete option. In this test case,
    we mocked the `isAuthenticated` method and rendered the `Post` component using
    the dummy post data. Then, we generated a snapshot with this rendered component,
    which will be matched with the expected snapshot. In the next section, we will
    discuss how generated snapshots are compared in this test.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们首先定义了虚拟帖子`post`和`auth`对象，然后添加了检查删除选项可见性的测试用例。在这个测试用例中，我们模拟了`isAuthenticated`方法，并使用虚拟帖子数据渲染了`Post`组件。然后，我们使用此渲染组件生成了一个快照，该快照将与预期的快照进行匹配。在下一节中，我们将讨论生成的快照是如何在这个测试中进行比较的。
- en: Generating a snapshot of the correct Post view
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成正确的Post视图快照
- en: The first time this test is run, we will provide it with the values required
    to generate the correct snapshot of the Post view. The correct snapshot for this
    test case will contain the delete button when the `user._id` of the `auth` object
    is equal to the `postedBy` value of the `post` object. This snapshot is generated
    when the test is run for the first time, and it will be used for comparison in
    future test executions.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行此测试时，我们将提供生成Post视图正确快照所需的值。对于此测试用例的正确快照将包含删除按钮，当`auth`对象的`user._id`等于`post`对象的`postedBy`值时。此快照是在测试第一次运行时生成的，它将在未来的测试执行中进行比较。
- en: This kind of snapshot testing in Jest basically records snapshots of rendered
    component structures to compare them to future renderings. When the recorded snapshot
    and the current rendering don't match, the test fails, indicating that something
    has changed. In the next section, we will go over the steps of running the test
    and checking the test output.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 中的这种快照测试基本上记录了渲染组件结构的快照，以与未来的渲染进行比较。当记录的快照和当前的渲染不匹配时，测试失败，表明有东西发生了变化。在下一节中，我们将介绍运行测试和检查测试输出的步骤。
- en: Running and checking the test
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行和检查测试
- en: In the code that we added to the `post.test.js` file, the dummy `auth` object
    and the `post` object refer to the same user; therefore, running this test in
    the command line will prompt Jest to generate a snapshot that will contain the
    delete option and also pass the test.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们添加到 `post.test.js` 文件中的代码中，模拟的 `auth` 对象和 `post` 对象指向同一个用户；因此，在命令行中运行此测试将提示
    Jest 生成一个包含删除选项的快照，并通过测试。
- en: 'To run the test, go into the project folder from the command line:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行测试，请从命令行进入项目文件夹：
- en: '[PRE9]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The test output generated when this command runs will show that the test passed,
    as portrayed in the following screenshot:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行此命令时，生成的测试输出将显示测试已通过，如下面的截图所示：
- en: '![](img/9a50bd38-3fca-4012-abb8-168378bc6265.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9a50bd38-3fca-4012-abb8-168378bc6265.png)'
- en: The recorded snapshot that is generated, when this test runs successfully for
    the first time, is added automatically to a `_snapshots_` folder in the `tests`
    folder. This snapshot represents the state where the delete button is rendered
    in the view since the authenticated user is also the creator of the post.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当此测试首次成功运行时，生成的记录快照会自动添加到 `tests` 文件夹中的 `_snapshots_` 文件夹。这个快照代表了删除按钮在视图中渲染的状态，因为认证用户也是帖子的创建者。
- en: We can now check whether the test actually fails when the component is rendered
    with an authenticated user that is not the creator of the post. To perform this
    check, we will update the dummy data objects by changing the `user._id`, so it
    does not match the `postedBy` value, and then run the test again. This will give
    us a failed test, as the current rendering will no longer have a delete button
    that is present in the recorded snapshot.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以检查当组件以不是帖子创建者的认证用户渲染时，测试是否实际上失败了。为了执行此检查，我们将通过更改 `user._id` 来更新模拟数据对象，使其不匹配
    `postedBy` 值，然后再次运行测试。这将给我们一个失败的测试，因为当前的渲染将不再有记录快照中存在的删除按钮。
- en: 'As shown in the following test log, the test fails and indicates that the rendered
    tree does not match the recorded snapshot since the elements representing the
    delete button are missing in the received value:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下测试日志所示，测试失败，并指示渲染的树与记录的快照不匹配，因为接收到的值中缺少表示删除按钮的元素：
- en: '![](img/255aafac-37de-4e30-a94b-99ccd2fa2fa7.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/255aafac-37de-4e30-a94b-99ccd2fa2fa7.png)'
- en: We have a client-side test for checking whether a signed-in user can view the
    delete button on their posts. Using this setup, more tests can be added for the
    MERN application utilizing the capabilities of Jest.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个客户端测试来检查已登录用户是否可以在他们的帖子中查看删除按钮。使用这个设置，可以为利用 Jest 功能的 MERN 应用程序添加更多测试。
- en: Writing test code will make the application you develop reliable and also help
    ensure code quality. Using tools such as ESLint, Cypress, and Jest, we can incorporate
    different ways of ensuring the overall quality of MERN-based applications. In
    the next section, we will move on to discussing ways to optimize the bundling
    of the application code.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试代码将使你开发的应用程序可靠，并有助于确保代码质量。使用 ESLint、Cypress 和 Jest 等工具，我们可以采用不同的方式来确保基于
    MERN 的应用程序的整体质量。在下一节中，我们将讨论优化应用程序代码打包的方法。
- en: Optimizing the bundle size
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化包大小
- en: As you develop and grow a MERN application, chances are the size of the bundles
    produced with webpack will also grow, especially if large third-party libraries
    are used. Larger bundle sizes will affect performance and increase the initial
    load time of the application. We can make changes in the code to ensure we don't
    end up with large bundles and also utilize features packed in webpack to help
    optimize bundling.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你开发和扩展 MERN 应用程序，webpack 产生的包的大小也可能增长，尤其是如果使用了大型第三方库。更大的包大小会影响性能并增加应用程序的初始加载时间。我们可以通过修改代码来确保我们不会得到大的包，并利用
    webpack 中打包的功能来帮助优化打包。
- en: Before going into the code to update it for bundle size optimization, you can
    also get familiar with the default optimization options that are part of webpack.
    In the MERN applications, we used the `mode` config to utilize the default settings
    for both development and production mode. To view an overview of the options that
    are available, please refer to the article at [https://medium.com/webpack/webpack-4-mode-and-optimization-5423a6bc597a](https://medium.com/webpack/webpack-4-mode-and-optimization-5423a6bc597a).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入代码以更新它以进行包大小优化之前，您还可以熟悉 webpack 的一部分默认优化选项。在 MERN 应用程序中，我们使用了 `mode` 配置来利用开发和生产模式的默认设置。要查看可用选项的概述，请参阅文章
    [https://medium.com/webpack/webpack-4-mode-and-optimization-5423a6bc597a](https://medium.com/webpack/webpack-4-mode-and-optimization-5423a6bc597a)。
- en: In the following section, we will highlight concepts such as code splitting
    and dynamic imports, which can give us control over producing smaller bundles
    and decreasing load time.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将强调代码拆分和动态导入等概念，这些概念可以让我们控制生成更小的包并减少加载时间。
- en: Code splitting
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码拆分
- en: Instead of loading all the code at once in one bundle, we can use the code splitting
    feature supported by webpack to lazy-load parts of the application code as currently
    needed by the user. After we modify the application code to introduce code-splitting,
    webpack can create multiple bundles rather than one large bundle. These bundles
    can be loaded dynamically at runtime, allowing us to improve the performance of
    the application.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是一次性将所有代码加载到一个包中，而是可以使用 webpack 支持的代码拆分功能按需懒加载应用程序代码的一部分。在修改应用程序代码以引入代码拆分后，webpack
    可以创建多个包而不是一个大的包。这些包可以在运行时动态加载，从而提高应用程序的性能。
- en: To learn more about code splitting support in webpack and how to make necessary
    changes to the setup and configuration, take a look at the guidelines in the documentation
    at [https://webpack.js.org/guides/code-splitting/](https://webpack.js.org/guides/code-splitting/).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 webpack 中的代码拆分支持以及如何对设置和配置进行必要的更改，请参阅文档中的指南 [https://webpack.js.org/guides/code-splitting/](https://webpack.js.org/guides/code-splitting/)。
- en: There are several ways to introduce code splitting for the application code,
    but the most important syntax you will come across for this purpose is the dynamic
    `import()`. In the next section, we will look at how to use `import()` with our
    MERN applications.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以为应用程序代码引入代码拆分，但您将遇到的最重要语法是动态 `import()`。在下一节中，我们将探讨如何使用 `import()` 与我们的
    MERN 应用程序。
- en: Dynamic import()
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态导入()
- en: 'Dynamic `import()` is a function-like version of the regular import, and it
    enables the dynamic loading of JS modules. Using `import(moduleSpecifier)` will
    return a promise for the module namespace object of the requested module. When
    using regular static imports, we import a module at the top of the code and then
    use it in the code as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Dynamic `import()` 是常规导入的类似函数版本，它允许动态加载 JS 模块。使用 `import(moduleSpecifier)` 将返回请求模块的模块命名空间对象的承诺。当使用常规静态导入时，我们在代码顶部导入一个模块，然后在代码中使用它如下：
- en: '[PRE10]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In contrast, if we were to use dynamic `import()` instead of adding the static
    import at the beginning, the code would look like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相反，如果我们使用动态 `import()` 而不是在开头添加静态导入，代码将看起来像这样：
- en: '[PRE11]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This allows us to import and load the module when the code requires it. While
    bundling the application code, webpack will treat calls to `import()` as split
    points and automatically start code splitting by placing the requested module
    and its children into a separate chunk from the main bundle.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们在代码需要时导入和加载模块。在打包应用程序代码时，webpack 将将 `import()` 的调用视为拆分点，并自动通过将请求的模块及其子模块放入主包之外的一个单独的块中来实现代码拆分。
- en: 'In order to optimize the bundling of the frontend React code by applying code
    splitting at a given component, we need to pair dynamic `import()` with React
    Loadable – a higher-order component for loading components with promises. As an
    example, we will look at the shopping cart developed in Chapter 8, *Extending
    the Marketplace for Orders and Payments*. While building the interface of the
    cart, we composed the `Cart` component by importing and adding the `Checkout`
    component to the view, as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过在给定组件处应用代码拆分来优化前端 React 代码的打包，我们需要将动态 `import()` 与 React Loadable 配对——这是一个用于使用承诺加载组件的高阶组件。作为一个例子，我们将查看第
    8 章 *扩展订单和支付的市场* 中开发的购物车。在构建购物车界面时，我们通过导入并添加 `Checkout` 组件到视图中来组合 `Cart` 组件，如下所示：
- en: '[PRE12]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To introduce code splitting here and import the `Checkout` component dynamically,
    we can replace the static import at the beginning with a `Loadable` Checkout,
    as shown in the following code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要在此处引入代码拆分并动态导入`Checkout`组件，我们可以将开始的静态导入替换为`Loadable` Checkout，如下所示：
- en: '[PRE13]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Making this change and using webpack to build the code again will produce a
    `bundle.js` file of reduced size, and generate another smaller bundle file representing
    the split code, which will now only load when the `Cart` component is rendered.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 进行此更改并使用webpack重新构建代码将生成一个更小的`bundle.js`文件，并生成另一个表示拆分代码的更小的bundle文件，该文件现在仅在`Cart`组件渲染时加载。
- en: Route-based code splitting is also another option besides using dynamic imports.
    It can be an effective approach for introducing code splitting in React apps that
    use routes to load components in the view. To learn more about implementing code
    splitting, specifically with React Router, view the article at [https://tylermcginnis.com/react-router-code-splitting/](https://tylermcginnis.com/react-router-code-splitting/).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用动态导入之外，基于路由的代码拆分也是另一种选择。对于使用路由在视图中加载组件的React应用程序，这是一种有效的引入代码拆分的方法。要了解更多关于实现代码拆分的信息，特别是关于React
    Router，请查看[https://tylermcginnis.com/react-router-code-splitting/](https://tylermcginnis.com/react-router-code-splitting/)上的文章。
- en: We can apply code-splitting mechanisms across our application code as required.
    The thing to keep in mind is that effective code splitting will depend on using
    it correctly and applying it at the right places in the code – places that will
    benefit in optimization from resource-load prioritization. In the next section,
    we will outline the steps that can be repeated to add new features to the MERN
    applications developed in this book.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据需要在我们应用程序代码中应用代码拆分机制。需要注意的是，有效的代码拆分将取决于正确使用它并在代码的正确位置应用它——这些位置将从资源加载优先级优化中受益。在下一节中，我们将概述可以重复执行的步骤，以添加本书中开发的MERN应用程序的新功能。
- en: Extending the applications
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展应用程序
- en: Throughout the chapters of this book, as we developed each application, we added
    features by extending the existing code in a common and repeatable number of steps.
    In this final section, we will review those steps, setting a guideline for adding
    more features to the current versions of the applications.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的章节中，随着我们开发每个应用程序，我们通过扩展现有代码的常见和可重复的步骤添加了功能。在本节的最后，我们将回顾这些步骤，为添加更多功能到当前版本的应用程序设定一个指南。
- en: Extending the server code
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展服务器代码
- en: For a specific feature that will require data persistence and APIs to allow
    the views to manipulate the data, we can start by extending the server code and
    adding the necessary models, routes, and controller functions, as outlined in
    the following sections.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要数据持久性和API以允许视图操作数据的特定功能，我们可以从扩展服务器代码和添加必要的模型、路由和控制器函数开始，如下文所述。
- en: Adding a model
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加模型
- en: For the data persistence aspect of the feature, design the data model considering
    the fields and values that need to be stored. Then, define and export a Mongoose
    schema for this data model in a separate file, and place it in the `server/models`
    folder. With the data structure defined and ready for the database, you can move
    on to adding the API endpoints for manipulating this data, as discussed next.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对于该功能的数据库持久性方面，在设计数据模型时考虑需要存储的字段和值。然后，在单独的文件中定义并导出一个Mongoose模式，并将其放置在`server/models`文件夹中。在定义好数据结构并准备好数据库后，你可以继续添加操作此数据的API端点，如下一节所述。
- en: Implementing the APIs
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现API
- en: In order to manipulate and access the data that will be stored in the database
    based on the model, you need to design the APIs relevant for the desired feature.
    To start implementing the APIs, you have to add the corresponding controller methods
    and route declarations, as discussed in the following sections.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了根据模型操纵和访问将存储在数据库中的数据，你需要设计与所需功能相关的API。要开始实现API，你必须添加相应的控制器方法和路由声明，如下文所述。
- en: Adding controllers
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加控制器
- en: With the APIs decided, add the corresponding controller functions that will
    respond to the requests to these APIs in a separate file in the `server/controllers`
    folder. The controller functions in this file should access and manipulate the
    data for the model defined for this feature. Next, we will look at how to declare
    the routes that will invoke these controller methods when the requests come in.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 确定了API之后，在`server/controllers`文件夹中的单独文件中添加相应的控制器函数，这些函数将响应对这些API的请求。这个文件中的控制器函数应访问和操作为该功能定义的模型数据。接下来，我们将探讨如何在请求到来时声明将调用这些控制器方法的路由。
- en: Adding routes
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加路由
- en: To complete the implementation of the backend APIs, corresponding routes need
    to be declared and mounted on the Express app. In a separate file in the `server/routes`
    folder, first, declare and export the routes for these APIs, assigning the relevant
    controller functions that should be executed when a specific route is requested.
    Then, load these new routes on the Express app in the `server/express.js` file,
    just like the other existing routes in the application.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成后端API的实现，需要声明相应的路由并将其挂载到Express应用程序上。在`server/routes`文件夹中的单独文件中，首先声明并导出这些API的路由，指定在请求特定路由时应执行的相关控制器函数。然后，在`server/express.js`文件中加载这些新路由，就像应用程序中的其他现有路由一样。
- en: This will produce a working version of the new backend APIs that can be run
    and checked from a REST API client application. Then, these APIs can be used in
    the frontend views for the feature being developed, which you will add by extending
    the client code, as discussed in the next section.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个可以由REST API客户端应用程序运行和检查的新后端API的工作版本。然后，这些API可以用于正在开发的特征的前端视图中，您将通过扩展客户端代码来实现这一点，如下一节所述。
- en: Extending the client code
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展客户端代码
- en: On the client side, first, design the views required for the feature, and determine
    how these views will incorporate user interaction with the data relevant to the
    feature. Then, add the fetch API code to integrate with the new backend APIs,
    define the new components that represent these new views, and update the existing
    code to include these new components in the frontend of the application, as outlined
    in the following sections.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，首先设计所需的视图，并确定这些视图将如何结合用户与该功能相关的数据交互。然后，添加fetch API代码以与新的后端API集成，定义代表这些新视图的新组件，并更新现有代码以包括这些新组件在前端应用程序中，如以下各节所述。
- en: Adding the API fetch methods
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加API fetch方法
- en: Before adding the fetch methods that will make calls to the backend APIs, you
    will determine a location for placing the new frontend code. In the client folder,
    create a new folder to house the components and helper code relevant to the feature
    module being developed. Then, to integrate the new backend APIs with the frontend
    of the application, define and export the corresponding fetch methods in a separate
    file in this new components folder. Finally, you can populate this folder with
    the React components that will be the frontend of this feature, as discussed in
    the next section.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加将调用后端API的fetch方法之前，您将确定放置新前端代码的位置。在客户端文件夹中，创建一个新文件夹来存放与正在开发的特征模块相关的组件和辅助代码。然后，为了将新后端API与应用程序的前端集成，在这个新组件文件夹中定义并导出相应的fetch方法。最后，您可以填充这个文件夹，其中包含将成为该功能前端的React组件，如下一节所述。
- en: Adding components
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加组件
- en: To start adding the UI for the feature, you can create and export new React
    components that represent views for the desired feature in separate files in the
    new folder. If authentication is required, you can integrate it into these new
    components using the existing auth-helper methods. Once the React components are
    implemented, they need to be loaded into the main application view, as discussed
    in the next section.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始添加该功能的UI，您可以在新文件夹中创建并导出代表所需功能视图的新React组件，这些组件位于单独的文件中。如果需要身份验证，您可以使用现有的auth-helper方法将这些新组件集成到其中。一旦实现了React组件，它们需要被加载到主应用程序视图中，如下一节所述。
- en: Loading new components
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载新组件
- en: In order to incorporate these new components into the frontend, the components
    either need to be added into existing components or rendered at their own client-side
    routes.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这些新组件集成到前端，这些组件要么需要添加到现有组件中，要么在它们自己的客户端路由中渲染。
- en: If these new components need to be rendered at individual routes, update the
    `MainRouter.js` code to add new routes that load these components at given URL
    paths. Then, these URLs can be used as links to load the components from other
    views in the application, or directly by visiting the URL from the browser address
    bar.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些新组件需要在单独的路由上渲染，更新`MainRouter.js`代码以添加新路由，这些路由在给定的URL路径上加载这些组件。然后，这些URL可以用作链接，从应用的其他视图中加载组件，或者直接通过浏览器地址栏访问这些URL。
- en: However, if the new components need to become part of existing views, then import
    the components into the existing components to add them to the view as desired.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果新组件需要成为现有视图的一部分，那么将组件导入现有组件中，以按需将它们添加到视图中。
- en: The new components can also be linked with existing components, such as in the
    `Menu` component, by linking to new components that were added with individual
    routes.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 新组件也可以通过链接到带有单独路由的新组件，与现有组件（如`Menu`组件）相关联。
- en: With the components integrated and connected to the backend, the new feature
    implementation is complete. These steps can be repeated to add on even more new
    features to the existing MERN-based applications built throughout this book.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 随着组件集成并连接到后端，新功能实现完成。这些步骤可以重复使用，以向本书中构建的现有MERN应用添加更多新功能。
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this final chapter, we reviewed and elaborated on some of the best practices
    that we used while building the MERN applications in this book, highlighted areas
    of improvement, gave pointers to address issues that may crop up when applications
    grow, and, finally, set down steps to continue developing more features into the
    existing applications.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后，我们回顾并详细阐述了在构建本书中的MERN应用时使用的最佳实践，突出了改进领域，提供了解决应用增长时可能出现的问题的指导，并最终确定了继续开发现有应用更多功能的步骤。
- en: We saw that modularizing the application's code structure helped to extend the
    application easily, choosing to use JSS over inline CSS and external style sheets
    kept the styling code contained and easy to work with, and only implementing server-side
    rendering for specific views as required kept unnecessary complications out of
    the code.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，模块化应用代码结构有助于轻松扩展应用，选择使用JSS而不是内联CSS和外部样式表，使样式代码易于管理和操作，并且仅在需要时实现特定视图的服务器端渲染，从而避免了代码中的不必要复杂性。
- en: We discussed the benefits of creating fewer stateful components that are composed
    of smaller and more defined stateless functional components, and how this can
    be applied while refactoring existing components or designing new components to
    extend the applications. For growing applications that may run into issues with
    managing and communicating state across hundreds of components, we pointed to
    options such as Redux and Flux, which may be considered to address these issues.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了创建更少的状态组件（由更小、更明确的非状态功能性组件组成）的好处，以及如何在重构现有组件或设计新组件以扩展应用时应用这一点。对于可能遇到在数百个组件之间管理和通信状态问题的增长型应用，我们指出了如Redux和Flux等选项，这些选项可以考虑用来解决这些问题。
- en: For applications that may have higher demands for stricter security enforcement,
    we looked back at our existing implementation of user authentication with JWT
    and password encryption and discussed possible extensions for improved security.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可能对更严格的安全执行有更高要求的用例，我们回顾了现有的基于JWT的用户身份验证和密码加密实现，并讨论了可能的扩展以增强安全性。
- en: We highlighted testing tools such as ESLint, Cypress, and Jest. Then, we used
    Jest to demonstrate how test code can be added to the MERN applications and discussed
    how good practices, such as writing test code and using a linting tool, can improve
    code quality besides ensuring reliability in an application.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强调了测试工具，如ESLint、Cypress和Jest。然后，我们使用Jest演示了如何向MERN应用添加测试代码，并讨论了如何通过编写测试代码和使用代码检查工具等良好实践来提高代码质量，同时确保应用的可靠性。
- en: We also looked at bundle optimization features, such as code splitting, that
    can help to improve performance by reducing the initial bundle size, and by lazy-loading
    parts of the application as required.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了捆绑优化功能，如代码拆分，这些功能可以通过减少初始捆绑大小以及按需懒加载应用的部分来帮助提高性能。
- en: Finally, we reviewed and set down the repeatable steps that were used throughout
    the book, which you can use as a guideline moving forward to extend the MERN applications
    by adding more features as desired.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们回顾并记录了整本书中使用的可重复步骤，您可以用这些步骤作为指南，在前进的过程中通过添加更多所需功能来扩展 MERN 应用程序。
